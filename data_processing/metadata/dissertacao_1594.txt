UNIVERSIDADE FEDERAL DO ESTADO DO RIO DE JANEIRO

CENTRO DE CIÊNCIAS EXATAS E TECNOLOGIA

CURSO DE PÓS-GRADUAÇÃO EM MATEMÁTICA

Criptografia: dos rudimentos à atualidade

Emerson Joaquim de Araújo

Rio de Janeiro

2018

Emerson Joaquim de Araújo

Criptografia: dos rudimentos à atualidade

Trabalho de Conclusão de Curso apresentado ao

Programa de Pós-graduação em Matemática

PROFMAT da UNIRIO, como requisito para a

obtenção do grau de MESTRE em Matemática.

Orientador: Ronaldo da Silva Busse

Doutor em Matemática - UFRJ

Rio de Janeiro

2018

    De Araújo, Emerson Joaquim

    Criptografia: dos rudimentos à atualidade / Emerson Joaquim de Araújo – 

2018

    76.p

    1.Matemática   2. Álgebra.   I. Título

Dedicatória

A Deus, o Autor e Consumador de minha fé, a

minha   esposa   por   ter   me   dado   forças   nos

momentos difícies ao longo dessa jornada, aos

meus   pais   por   mim   guiarem   ao   caminho   do

estudo e aprendizagem e a todos meus colegas

do   PROFMAT   que   de   alguma   forma

contribuíram para a conclusão deste trabalho.

Agradecimentos

Ao fim desta caminhada aproveito para agradecer àqueles que, direta e indiretamente,

contribuíram nesta conquista, por isso agradeço:

A Deus, por ter me orientador e dado forças para continuar enfrentando as dificuldades

ao longo do curso e por esta concedendo mais uma conquista na minha vida.

A minha amada e querida esposa, pelo apoio e compreensão, mesmo nos momentos de

estresse.

Ao   Professor   Ronaldo,   orientador   deste   trabalho,   que   de   forma   compreensiva   e

acolhedora deu um “norte” no desenvolvimento dessa obra.

A   todos   os   professores   do   PROFMAT   –   UNIRIO,   que   contribuíram   de   forma

significativa com profissionalismo, dedicação, incentivo e qualidade das aulas.

Aos   colegas   do   PROFMAT,   pelos   momentos   de   convivência   e   conhecimentos

compartilhados.   Em   particular   a  Alcebiades,   João   Jolvino,   Márcio,   Luiz   Leão,   Luciane,

Leandro e Vandré pela amizade e companherismo.

Enfim, a todos que contribuíram para que essa conquista fosse possível.

Resumo

6

Este   trabalho  tem  por  objetivo  apresentar  a  evolução   da  criptografia   e  mostrar  de

forma  clara  e  concisa  a  diferença  existente  entre  a  criptografia  simétrica  e  a  assimétrica,

detalhando em exemplo o seu funcionamento. Apresenta, ainda, um breve histórico sobre o

desenvolvimento da criptografia, desde o seu surgimento até a Era Moderna, mostrando como

a evolução dos antigos métodos criptográficos culminaram nos mais modernos sistemas de

criptografia. Finalmente, para melhor compreensão do contéudo, também é feito um resumo

de tópicos da Teoria dos Números.

Palavras-chave: Criptografia, criptografia simétrica, criptografia assimétrica.

Abstract

7

This work aims to present the evolution of cryptography and to show in a clear and

concise way the difference between symmetric and asymmetric cryptography, describing in

detail their operation. It also presents a brief history of the development of cryptography, from

its inception to the Modern Era, showing how the evolution of the old cryptographic methods

culminated in the most modern cryptography systems. Finally, for a better understanding of

the content, a summary of Number Theory topics will also be done. 

Keywords: cryptography, symmetric cryptography, asymmetric cryptography. 

LISTA DE FIGURAS

8

Figura 1 – Classificação dos Campos da Criptologia

Figura 2 – Tumba de Khnumhotep II

Figura 3 – Tablete de cerâmica da Mesopotâmia

Figura 4 – Cifras hebraicas

Figura 5 – Bastão de Licurgo

Figura 6 – Cifra de César

Figura 7 – Código Políbio

Figura 8 – Al-Kindi

Figura 9 – Leone Battista Alberti

Figura 10 – Disco de Alberti

Figura 11 – Johannes Trithemius

Figura 12 – Tabula recta

Figura 13 – Cifra de Vigenère

Figura 14 – Cifra de Bacon 

Figura 15 – Enigma M4

Figura 16 – Alan Turing

Figura 17 – A relação a = qn + r; 0 ≤ r < n.

Figura 18 – Modelo simplificado da encriptação simétrica

Figura 19 – Máquina de três rotores com fiação representada por contatos numerados

Figura 20 – Representação geral do algoritmo de encriptação DES

Figura 21 – Criptografia de chave pública

Figura 22 – Ron Rivest, Adi Shamir e Leonard Adleman

Sumário

9

Introdução..............................................................................................................................11

Capítulo 1 – Navegando na história da Criptografia.........................................................13

    1.1 - Idade Antiga................................................................................................................13

        1.1.1 – Khnumhotep  II...................................................................................................13

        1.1.2 – Mesopotâmia.......................................................................................................14

        1.1.3 – Antigo Testamento...............................................................................................14

        1.1.4 – Bastão de Licurgo................................................................................................16

        1.1.5 – Cifra de César......................................................................................................16

        1.1.6 – Outros destaques na idade Antiga.......................................................................17

            1.1.6.1 – Euclides de Alexandria (330 a.c. a 270 a.c.)................................................17

            1.1.6.2 – Erastótenes de Cirene (276 a.c. a 194 a.c.)..................................................17

        1.1.7 – Políbio (204 a.c. a 122 a.c.).................................................................................18

    1.2 – Idade Média................................................................................................................18

    1.3 – Idade Moderna............................................................................................................19

        1.3.1 – Disco de Alberti...................................................................................................20

        1.3.2 – Tabula Recta........................................................................................................23

        1.3.3 – Cifra de Vigenère.................................................................................................24

        1.3.4 – Cifra de Bacon.....................................................................................................26

    1.4 – Era das Guerras..........................................................................................................26

        1.4.1 – Primeira Guerra Mundial …...............................................................................27

        1.4.2 – Enigma e a Segunda Guerra Mundial.................................................................28

        1.4.3 –  Criptoanalistas de Bletchley Park ….................................................................30

Capítulo 2 – Conceitos básicos de Teoria dos Números.....................................................32

    2.1 – Divisibilidade e o algoritmo da divisão......................................................................32

    2.2 – Algoritmo de Euclides................................................................................................34

    2.3 – Aritmética Modular....................................................................................................36

    2.4 – Números primos.........................................................................................................38

        2.4.1 – Teorema Fundamental da Aritmética..................................................................38

    2.5 – Teoremas de Fermat e Euler.......................................................................................38

10

Capítulo 3 – Criptografia ou encriptação Simétrica..........................................................41

    3.1 – Modelo de Cifra Simétrica.........................................................................................41

    3.2 – Formas de ataque a um sistema de encriptação..........................................................42

    3.3 – Técnicas de encriptação..............................................................................................43

        3.3.1 – Técnicas de substituição......................................................................................43

            3.3.1.1 – Cifra de César...............................................................................................43

            3.3.1.2 – Cifras monoalfabéticas.................................................................................44

            3.3.1.3 – Cifras polialfabéticas....................................................................................45

        3.3.2 – Técnicas de transposição.....................................................................................45

        3.3.3 – Máquinas de rotor................................................................................................46

        3.3.4 – Esteganografia.....................................................................................................47

    3.4 – Data Encryption Standard (DES)...............................................................................48

        3.4.1 – Encriptação do Data Encryption Standard (DES) …..........................................48

        3.4.2 – Decriptação do Data Encryption Standard (DES)...............................................50

            3.4.2.1 – Exemplo do DES..........................................................................................50

    3.5 – Advanced Encryption Standard (Padrao de Encriptacao Avancada) ou AES............60

Capitulo 4 – Criptografia ou encriptação Assimétrica......................................................62

    4.1 – Criptografia de chave pública....................................................................................62

    4.2 – Modelo de Cifra Assimétrica......................................................................................64

    4.3 – Criptoanálise de chave pública...................................................................................66

    4.4 – Algoritmo RSA...........................................................................................................67

        4.4.1 – Descrição matemática do algoritmo....................................................................68

        4.4.2 – Exemplo do RSA.................................................................................................69

Considerações finais..............................................................................................................73

Referências Bibliográficas....................................................................................................75

Introdução

11

Um   dos   problemas   enfrentados   pelos   seres   humanos   ao   longo   do   tempo   foi   a

nessecidade   de   trocar   informações,   sem   perigo   de  interceptação,   desde   a   mais   remota

civilização até os dias modernos este continua sendo um dos desafios mais intrigantes.

A palavra criptografia vem do grego Kryptós “escondido” e gráphein “escrita”, e por

definição  é  a  ciência  que  estuda  as   formas   e técnicas  pelas  quais  a  informação  pode ser

transformada da sua forma original para outra ilegível aos que não tem acesso as convenções

previamente estabelecidas, e a criptoanálise é a ciência que estuda as formas de se decifrar

tais informações.

Ao longo do tempo a evolução criptográfica tornou-se necessária, pois os métodos

usados estavam ficando absoleto e de fácil decodificação, devido a isto surgiu a necessidade

de usar cada vez mais técnicas e métodos de difícil solução.

Atualmente a criptografia consiste em uma série de fórmulas matemáticas, em que se

utiliza um segredo (chamado de chave) para cifrar e decifrar as mensagens. Este segredo pode

ser   o   mesmo   para   as   duas   operações   (criptografia   simétrica)   ou   pode   haver   segredos

diferentes, um para cifrá-la e outro para decifrá-la (criptografia assimétrica). 

Neste trabalho iremos mostrar como a criptografia evoluiu ao longo dos séculos e

estudar  alguns algortimos simétricos e assimétricos, onde mostraremos de forma concisa e

simples o funcionamento dos mesmos através de exemplos simples, mas ao mesmo tempo

complexo, pois a realização dos passos requer uma atenção ímpar.

Definiremos para compreenssão e fácil entendimento alguns termos segundo

Stallings   (2015).   Uma   mensagem   original   é   conhecida   como   texto   claro,   enquanto   a

mensagem codificada é chamada de texto cifrado. O processo de converter um texto claro em

um texto cifrado é conhecido como cifração ou encriptação; restaurar o texto claro a partir do

texto cifrado é decifração ou decriptação. Os muitos esquemas utilizados para encriptação

constituem a área de estudo conhecida como criptografia. Esse esquema é designado sistema

criptográfico ou cifra. As técnicas empregadas para decifrar uma mensagem sem qualquer

conhecimento ou detalhes de encriptação estão na área da criptoanálise, que é o que os leigos

chamam de “quebrar o código”. As áreas da criptografia e criptoanálise, juntas, são chamadas

de criptologia.

12

Figura 1: Classificação dos Campos da Criptologia
(Fonte: Entendendo Criptografia – Um livro texto para estudantes e profissionais)

No primeiro capítulo, apresentaremos um resumo histórico, mostrando a evolução da

criptografia desde a Civilização Egípcia à Segunda Guerra Mundial.

No segundo capítulo, apresentaremos os conceitos preliminares em teoria dos números

e a noção de número primo, que será o ingrediente fundamental para o desenvolvimento da

criptografia simétrica e mais ainda na assimétrica.

No terceiro capítulo, apresentaremos com mais detalhes a criptografia simétrica, onde

abordaremos   o   modelo   da   cifra,   formas   de   ataques,   algumas   das   principais   técnicas   de

encriptação e culminaremos com o Data Encryption Standard (DES), que foi o algoritmo de

encriptação simétrica dominante por muitos anos, especialmente em aplicações financeiras.

Finalmente,   no   quarto   capítulo,   apresentaremos   a   criptografia   assimétrica,   onde

mostraremos   o   modelo   da   cifra,   a   criptoanálise   de   chave   pública,   o   algoritmo   RSA,   a

descrição matemática do algoritmo RSA e um exemplo do RSA.

CAPÍTULO 1

Navegando na história da Criptografia

13

1.1 – IDADE ANTIGA

1.1.1 – Khnumhotep II

Segundo Kahn (1996), um dos primeiros relatos que se tem sobre um texto escrito que

incorporou um dos elementos essenciais da criptografia: uma transformação deliberada da

escrita, data de 1900 a.c., a história aconteceu numa vila egípcia perto do rio nilo chamada

Menet   Khufu.   O   Khnumhotep   II,   homem   de   grande   importância,   arquiteto   do   faraó

Amenemhet   II,   construiu   alguns   monumentos   para   o   faraó,   os   quais   precisavam   ser

documentados, contudo essas informações, escritas em tabletes de argila, não deveriam cair

no domínio público. Foi então que o escriba Khnumhotep II teve a ideia de substituir algumas

palavras ou trechos de texto desses tabletes. Caso o documento fosse roubado, o ladrão não

encontraria o caminho que o levaria ao tesouro -   morreria de fome e sede, perdido nas

catacumbas da pirâmide, pois os faraós acreditavam que a morte era apenas uma passagem

para outra vida e com isto, em sua tumba deveria ter tudo que uma pessoa precisaria para

viver, tais como: ouros, comidas, roupas, utensílios, etc. 

Figura 2: Tumba de Khnumhotep II
(Fonte: https://br.pinterest.com/pin/363243526177139263/)

1.1.2 – Mesopotâmia

14

Para Kahn (1996), a quarta grande civilização da antiguidade, a Mesopotâmia, superou

o Egito na questão criptográfica, pois foi por volta de 1500 a.c. chegou a um nível bastante

moderno, o primeiro registro do uso da criptografia nesta região está numa fórmula para fazer

esmaltes para cerâmica. O tablete usava símbolos especiais que podem ter vários significados

diferentes. 

Figura 3: Tablete de cerâmica da Mesopotâmia

(Fonte: https://www.museum.ie/The-Collections/ Documentation-Discoveries/March-
2016/Cuneiform-tablets-the-genesis-of-documentation)

Nessa   época   os   egípcios,   chineses,   indianos   e   os   mesopotâmios   desenvolveram   a

esteganografia1 (escrita cifrada):

- Tatuagens com mensagens na cabeça de escravos. Infelizmente era preciso esperar o cabelo

crescer para esconder a mensagem. A decifração era feita no barbeiro.

- Marcas na parte interna de caixas de madeira usadas para transportar cera. As marcas eram

escondidas com cera nova. Para decifrar, bastava derreter a cera.

- Mensagens colocadas dentro do estômago de animais...e também de humanos.

1.1.3 – Antigo Testamento

Segundo Kahn (1996), também foram descobertos escritos em Uruk (atual Iraque) em

1 Esteganografia era uma palavra absoleta que foi revivida por David Kahn e recebeu o significado que tem 

hoje.

 
15

que os escribas ocasionalmente convertiam os nomes dos reis selêucidas em números.

As sagradas escrituras não escaparam a um toque de criptografia, a tradição hebraica

oferece pelo menos duas dessas conversões no Antigo Testamento (nenhum é registrado para

o   novo).   Em   Jeremias   25:26   e   51:41,   a   forma  SESAQUE   aparece   no   lugar   de   Babel

(“Babilônia”). A segunda ocorrência demonstra claramente a falta de um motivo de sigilo,

uma vez que a frase com SESAQUE é imediatamente seguida por uma usando “Babilônia”:

Como foi tomada SESAQUE, e apanhada de surpresa a glória de toda a terra! Como se tornou

Babilônia um espanto entre as nações. A confirmação de que SESAQUE é realmente um

substituto para Babel e não um lugar totalmente separado vem da Septuaginta e dos Targuns,

as paráfrases aramaicas da Bíblia, que simplesmente usam “Babel”, onde a versão do antigo

Testamento   tem   SESAQUE.   A   segunda   transformação,   em   Jeremias   51:1,   coloca   LEB

KAMAI (“coração do rei”) para KASHDIM (“caldeus”). Ambas as transformações resultaram

de aplicação de uma substituição tradicional de letras chamada “atbash”, na qual a última letra

do alfabeto hebraico substitui a primeira letra e vice-versa, a penúltima substitui a segunda e

vice-versa, e assim por diante. É o hebraico equivalente de a = z, b = y, c = x, …, z = A. Estas

cifras baseiam-se no sistema de substituição simples (ou substituição monoalfabética).

Figura 4: Cifras hebraicas
(Fonte: http://www.quadibloc.com/crypto/ppen01.htm) 

1.1.4 – Bastão de Licurgo

16

Conforme explica  Singh (2007), outra forma usada na antiguidade para criptografar

mensagens   é   o   scytale   ou   bastão   de   Licurgo,   foram   usados   pelos   espartanos,   os   mais

guerreiros dos gregos, esse foi o primeiro sistema de criptografia militar. No quinto século

a.c., eles empregaram esse dispositivo que é o aparato mais antigo usado na criptografia e um

dos poucos já inventados em toda a história da ciência para cifras de transposição. O sistema

consiste em um bastão ou cajado de madeira em torno do qual uma tira de papiro, couro ou

pergaminho   é   enrolada,   a   mensagem   secreta   é   escrita   no   pergaminho   no   sentido   do

comprimento do bastão, o pergaminho é então desenrolado e enviado ao seu destino com as

letras desconectadas e sem sentido, ou seja, a mensagem foi cifrada. Para que o destinatário

consiga   decifrar   a   mensagem   é   necessário   que   possua   um   bastão   de   mesma   espessura   e

diâmetro que o primeiro, pois com isto conseguiria formar a mensagem enviada.

Figura 5: Bastão de Licurgo
(Fonte: Singh, 2007, p. 24)

1.1.5 – Cifra de César

Segundo Singh (2007), o primeiro documento que usa uma cifra de substituição com

propósito   militar   aparece   nas   Guerras   da   Gália   de   Júlio   César,   imperador   romano.   Ele

descreve como enviou uma mensagem para Cícero, que estava prestes a se render, pois estava

cercado pelo exército inimigo. Nessa ocasião ele substituiu as letras do alfabeto romano por

letras   gregas,   tornando   a   mensagem   incompreensível   para   o   inimigo.   César   descreve   a

dramática entrega da mensagem: “O mensageiro recebeu instruções para que, se não pudesse

se aproximar, jogasse uma lança com a mensagem amarrada por uma tira de couro, dentro das

fortificações do campo... Com medo, o gaulês arremessou a lança como fora instruído. Por

acaso   a   arma   encravou-se   em   uma   torre   e   passou   dois   dias   sem   ser   vista   pelos   nossos

soldados, até que, no terceiro dia, um soldado a viu, retirando-a e entregando a mensagem

17

para Cícero. Ele a leu e depois a recitou em voz alta para a tropa em formação, trazendo

grande alegria para todos."

Embora o imperador tenha usado a substituição das letras do alfabeto romano por

letras   gregas,   a   sua   máxima   em   criptografar   mensagens   consiste   em   alterar   as   letras

desviando-as em três posições, ou seja, A se tornando D, B se tornando E, etc. A seguir, um

exemplo clássico da cifra de César:

Mensagem original: ATACAR PELO NORTE

Mensagem cifrada: DWDFDU SHOR QRUWH

Figura 6: Cifra de César
(Fonte: https://pplware.sapo.pt/linux/whatcripto-identificador-decifrador-cifras-
criptograficas/#foobox-1/3/Whatcripto_4.jpg).

Esse método possui uma fraqueza simples de se notar, pois uma simples análise das

letras do idioma e um bom conhecimento de sua estrutura é possível uma pessoa decifrar a

mensagem. Por exemplo, no caso do Português, é fácil verificar que a letra  A  aparece com

maior frequência que as demais letras e que a letra Q sempre é precedida pela letra U.

1.1.6 – Outros destaques na idade Antiga

1.1.6.1 – Euclides de Alexandria (330 a.c. a 270 a.c.)

Compilou e sistematizou o que havia na época sobre geometria e teoria dos números.

Escreveu "Elementos", obra que influênciou de forma significativa a criptografia moderna nos

computadores.

1.1.6.2 – Erastótenes de Cirene (276 a.c. a 194 a.c.)

Criou   o   método   conhecido   como   o   "Crivo   de   Erastótenes",   usado   para   identificar

números primos.

1.1.7 – Políbio (204 a.c. a 122 a.c.)

Segundo Kahn (1996), Políbio inventou um sistema de sinalização que foi adotado

amplamente   como   método   criptográfico.   Ele   organizou   as   letras   em   um   quadrado   5x5   e

numerou as linhas e colunas.

18

Figura 7: Código Políbio
(Fonte: https://3l3m3nt4l.blogspot.com.br/2017/01/el-cuadrado-de-polibio.html)

Cada letra pode ser representada por dois números – o da linha e o da coluna. Assim,

M = 32, P = 35. Políbio sugeriu que esses números fossem transmitidos por meio de tochas,

ou seja, três tochas na mão direita e duas na mão esquerda representando o M, por exemplo.

Esse método pode sinalizar mensagens por longas distâncias.

1.2 – IDADE MÉDIA

De acordo com Schneeberger (2007), esse período está compreendido entre os anos

476 a 1453, costuma-se ainda chamar a Idade Média de “Idade das Trevas”, pois teria sido

uma época de muita ignorância e obscurantismo. Porém essa qualificação não corresponde à

realidade. Além de ser pejorativa e preconceituosa, a pessoa que assim se manifesta revela

desconhecimento   histórico,   pois   foi   uma   época   de   notáveis   realizações   culturais,

especialmente as da civilização muçulmana.

Nesse período se destacou o árabe  Al-Kindi  (Iraque, 801-853), conhecido como  o

filósofo   dos   árabes,   foi   o   precursor   da   criptoanálise   para   a   substituição   monoalfabética,

publicou um manuscrito sobre a decifração de mensagens criptográficas.

19

Figura 8: Al-Kindi
(Fonte:http://www.muslimheritage.com/)

De acordo com Wazlawick (2016), o manuscrito incluía uma descrição do método de

análise de frequência para a decifração de mensagens criptográficas simples. Suponha, por

exemplo,   uma   criptografia   simples   de   substituição   de   símbolos   na   qual   cada   letra   da

mensagem original é substituída pela letra seguinte do alfabeto e o Z substituído pelo A. Com

essa   técnica,   uma   palavra   escrita,   por   exemplo   como   “dsquphsbgjb”   seria   decifrada   se

substituíssemos cada letra imediatamente anterior no alfabeto, resultando assim na palavra:

“criptografia”.

Agora imagine que as letras fossem substituídas de forma não tão lógica, como por exemplo,

“A” por “N”, “B” por “%”, “C” por “9” etc. Como você decifraria uma mensagem como

“HGS&JW%@KKS”?   Sem   saber   o   método   de   criptografia   fica   muito   difícil   traduzir   a

mensagem,  pois  cada  caractere  na  frase pode  ser,  em  princípio,  qualquer  uma  das  letras,

números ou sinais especiais utilizados na escrita.

O método descrito por Al-Kindi baseia-se em uma análise estatística da frequência de cada

letra numa determinada língua. Wazlawick (2016) mostra que em português, por exemplo, a

letra mais frequente em textos é a letra “A”, que aparece em média 14,63%, seguida da letra

“E” com uma média de 12,57%. Assim, em uma mensagem criptografada suficientemente

longa, que se saiba estar escrita originalmente em português, um caractere que apareça por

volta de 14,63% das vezes tem grande chance de ser a letra “A”. Já um caractere que apareça

cerca de 12,57% das vezes tem chance de ser a letra “E”. E assim por diante.

1.3 – IDADE MODERNA

Schneeberger (2006) explica como ocorreu o desenvolvimento cultural nesse época:

20

As   condições   básicas   que   proporcionaram   o   renascimento   cultural   foram   as

transformações socioeconômicas ocorridas na Europa durante a Baixa Idade Média,

com   destaque   para   a   expansão   urbano   comercial,   a   ascensão   da   burguesia,   o

fortalecimento   do   poder   real,   a   fundação   das   universidades   e   a   renovação   dos

contatos com o mundo oriental.

A Itália foi a primeira a acordar, sendo responsável pelos primeiros grandes avanços,

tanto   na   política,   com   Maquiavel,   na   medicina,   com   Leonardo   da   Vinci,   na   arte,   com

Michelangelo, entre outras. Em relação a criptografia destaca-se o italiano  Leone Battista

Alberti.

1.3.1 Disco de Alberti

Conforme explica Kahn (1996), Leone Battista Alberti é conhecido como o pai da

criptografia ocidental, ele publicou, em 1466, o livro Modes scribendi in ziferas, onde fala do

disco de cifra, o primeiro sistema polialfabético conhecido. 

Figura 9: Leone Battista Alberti
(Fonte: https://gl.wikipedia.org/wiki/Leon_Battista_Alberti)

O disco de cifra era constituído por dois discos concêntricos e de raios diferentes. O

disco maior era fixo, e o menor móvel. Alberti dividiu cada uma das circunferências em vinte

e   quatro   setores,   em   cada   um   dos   setores   do   disco   maior   escreveu   o   alfabeto   em   letras

maiúsculas pela sua ordem normal, mas não continha as letras H, J, K, U, W e Y, nos quatro

setores que sobraram colocou os algarismos 1, 2, 3 e 4. 

21

Figura 10: Disco de Alberti

(Fonte: http://www.mateureka.it/wp-content/uploads/2012/11/disco-cifrante-leon-battista-
alberti.jpg)
No disco fixo, colocou de uma forma normal, em cada um dos setores, as letras do alfabeto,

que eram 20, e os numerais 1, 2, 3 e 4.

Já no disco móvel, colocou, em ordem aleatória, as letras minúsculas do alfabeto (exceto as

letras j, u e w) mais a palavra et (que significa e).

Uma das desvantagens deste método, é que emissor e receptor têm que ter dois discos iguais e

muito bem guardados, pois a segurança deste sistema depende de ocultar os discos de olhos

indiscretos.

Segue   abaixo   um   exemplo   prático   extraído   de   uma   avaliação   da   disciplina   de

Criptografia do Centro de Educação a Distância do Estado do Rio de Janeiro (CEDERJ):

Para   codificar   ou   decifrar   mensagens   utilizando   discos   de   Alberti   ou   discos   de   cifras

procedemos do seguinte modo:

(i) Escolhemos a letra-chave (letra minúscula) e a palavra-chave (letras maiúsculas).

(ii)   Coincidimos   a   letra-chave   com   a   primeira   letra   da   palavra-chave   e   obtemos   a

codificação da primeira letra da mensagem original através de sua correspondente no

“disco das maiúsculas”.

(iii)   Coincidimos   a   letra-chave   com   a   segunda   letra   da   palavra-chave   e   obtemos   a

codificação  da segunda letra da mensagem original através de sua correspondente no

”disco das maiúsculas”.

(iv)   Repetimos   estes   procedimentos   até   a   última   letra   da   palavra-chave   e,   se   a

codificação não houver terminado, voltamos ao item (i), ou seja, coincidimos a letra-

chave   com   a   primeira   letra   da   palavra-chave   e   obtemos   a   codificação   da   letra

correspondente   da   mensagem   original,   continuando   com   o   processo   até   concluir   a

codificação.

Por exemplo: Codifique a palavra cederj utilizando o disco de Alberti da figura abaixo, a

letra-chave n e a palavra-chave BOLA

22

(i) coincidimos n com B e a letra maiúscula correspondente a c é I.

(ii) coincidimos n com O e a letra maiúscula correspondente a e é N.

(iii) coincidimos n com L e a letra maiúscula correspondente a d é F.

(iv) coincidimos n com A e a letra maiúscula correspondente a e é Z.

(v) coincidimos n com B e a letra maiúscula correspondente a r é Z.

(vi) coincidimos n com O e a letra maiúscula correspondente a j é S.

   • A codificação de cederj é INFZZS.

Utilize o disco de Alberti da figura abaixo, a letra-chave k e a palavra-chave MAR para

decodificar a mensagem

GUVPFJYVBZBAKBQYBMFUYP. (2.0 pontos)

Solução
Coincidindo a letra-chave k com M, A e R obtemos as três tabelas de decodificação

23

Portanto, a mensagem decodificada é:

URSOS HIBERNAM NO INVERNO.

1.3.2 Tabula recta

De acordo com Kahn (1996), a polialfabeticidade deu mais um passo em 1518, com o

surgimento do primeiro livro impresso sobre criptografia, escrito por um dos mais famosos

intelectuais   de   sua   época.   Este   era   Johannes   Trithemius,   um   monge   beneditino   que   se

interessava por alquimia e outros poderes místicos, fez dele uma das figuras mais veneradas

da ciência oculta.

Figura 11: Johannes Trithemius
(Fonte: https://codesandmagic.files.wordpress.com/2013/03/20710_trithemius_4100.jpg)

Johannes Trithemius criou uma cifra que recebeu o nome de Tabula recta, essa cifra

foi descrita em um de seus livros, o terceiro volume de uma série. A Tabula recta  consiste

numa tabela de 26x26 preenchida da seguinte maneira: a primeira linha é preenchida com o

alfabeto latino em ordem alfabética. A segunda linha é o mesmo alfabeto só que deslocado

uma casa para a esquerda. A terceira linha é deslocada em mais uma casa e assim por diante

até chegarmos a 25 deslocamentos. No 26º deslocamento o ciclo se reinicia voltando-se à

configuração inicial da primeira linha.

24

Figura 12: Tabula recta
(Fonte: https: www.staff.uni-mainz.de/pommeren/Cryptology/Classic/2_Polyalph/Trithem.gif)

1.3.3 Cifra de Vigenère

Para Kahn (1996), embora os créditos sejam dados ao francês Blaise Vigenère, a cifra

foi primeiramente descrita em 1553, por Giovanni Battista Belaso no livro intitulado por La

cifra del Sig Giovan Batista Belaso.  Esta cifra é constituída por 26 cifras de César, com

diferentes variações. A diferença é que numa cifra de César, cada letra do alfabeto é deslocada

da sua posição um número fixo de lugares, enquanto na cifra de Vigenère consiste de várias

cifras de César com diferentes valores de deslocamentos.

Vejamos um exemplo para compreendermos o funcionamento da cifra:

Vamos encriptar a frase “matar o rei”, usando a palavra-chave “morte”. A palavra-chave deve

ser repetida até completar o comprimento da mensagem a ser enviada, da seguinte forma:

Palavra-chave

Mensagem

Texto cifrado

m o

m a

y

o

r

t

k

t

a

t

e

r

v

m

o

a

o

r

f

r

e

v

25

t

i

b

A primeira letra do texto, que é a letra “m”, é cifrada com o alfabeto da linha “m”, que é a

primeira letra da palavra-chave. Procuramos a letra na linha “m” que esteja a coluna “m”, que

no caso é a letra “y”. Esta será a primeira letra do texto cifrado.

Passando   para   a   segunda   letra   do   texto   normal,   que   é   a   letra   “a”,   procuramos   a   linha

correspondente   à   letra   “o”,   segunda   letra   da   chave,   e   localizamos   a   letra   que   esteja   na

intersecção dessa linha com a coluna da letra procurada, “a”. No caso, a letra é “o”, segunda

letra do texto cifrado.

E assim sucessivamente, até o final da cifragem.

Figura 13: Cifra de Vigenère
(Fonte: http://cryptograma.blogspot.com.br/2015/06/historia-da-criptografia-cifras-e.html)

A  supremacia   da   cifra   de   Vigenère   teve   fim   em   1854   quando   Charles   Babbage,

considerado o pai do computador, desenvolveu uma técnica criptanalítica capaz de extrair a

chave do criptograma e decifrá-lo.

1.3.4 Cifra de Bacon

26

De   acordo   com   Kahn   (1996),   Sir   Francis   Bacon,   o   inventor   de   um   sistema

esteganográfico, denominado seu alfabeto de bilateral, utilizou a combinação de duas letras, A

e B em grupos de cinco. Esta cifra foi conhecida como Cifra de Bacon, hoje, é classificada

como decodificação binária de 5 bits.

Figura 14: Cifra de Bacon 
(Fonte: https://encdesarrollo.wordpress.com/2012/09/27/esteganografia-en-redes-sociales-2/)

1.4 – Era das Guerras

De acordo com C. L. Barczak (2014), foi durante o século XIX que humanidade teve

um progresso considerável em relação ao desenvolvimento das ciências, tecnologias e das

artes. No fim desse século a eletricidade e eletrônica tiveram grandes avanços, e um dos

grandes marcos na ciência foi a descoberta da propagação das ondas eletromagnéticas por

Heinrich Hertz que construiu circuitos para produzir e detectar a radiação eletromagnética.

Chamadas de ondas Hertzianas hoje são mais conhecidas como ondas eletromagnéticas ou

ondas de rádio.

Ainda segundo C. L. Barczak (2014), a história da invenção do rádio passa pelo Brasil

através da figura do padre gaúcho Roberto Landell de Moura (Porto Alegre, 1862-1928), ele

desenvolveu aparelhos para transmissão e recepção de voz humana sem a utilização de fios

condutores   como   era   usual   na   época   nos   sistemas   de   telefone   e   telégrafo.   Ele   fez   uma

experiência em São Paulo, entretanto o sucesso do feito o fez duvidarem de sua sanidade

27

mental. Sete anos depois conseguiu a patente brasileira de seu invento. Em 1901, embarcou

para os Estados Unidos, mesmo sem apoio das autoridades brasileiras, lá ele conseguiu a

patente do transmissor de ondas eletromagnéticas, do telégrafo sem fio e do telefone sem fio. 

Entretanto, foi na Europa que outro pesquisador e inventor obteve sucesso com uma

invenção similar ao de Landell de Moura, foi o físico italiano Guglielmo Marconi, que de

forma   independente   construiu   seus   próprios   circuitos   e   aparelhos.   Em   1885   ele   realizou

experiências, demonstrando a possibilidade de telecomunicações a distância por meio de onda

eletromagnéticas, no início as transmissões eram feita em pequenas distâncias, mas em 1886

Marconi embarcou para a Inglaterra em busca de apoio e financiamento, o qual conseguiu e

de forma eficaz em 1889, ano em que instalou o telégrafo sem fio em dois navios, permitindo

a transmissão de mensagens entre localidades distantes e isoladas. Utilizando o código Morse

comprovou a possibilidade de comunicação a distância por meio de ondas eletromagnéticas.

Em 1909, Marconi recebeu o Prêmio Nobel de Física.

 Para Kahn (1996), o rádio foi aproveitado pelos generais logo após seu surgimento,

em 1885, e utilizado como instrumento de guerra, pois ampliava de forma significativa a

principal vantagem militar: controle instantâneo e contínuo de um exército inteiro por um

único   comandante,   porém   a   vasta   amplificação   de   comunicações   militares   pelo   rádio   era

acompanhada por uma probabilidade enorme de interceptação.

1.4.1 – Primeira Guerra Mundial

Conforme explica  C. L.  Barczak  (2014), em 1914, o Cruzador alemão Magdeburg

fazia patrulha no Golfo da Finlândia quando foi descoberto por navios russos, para evitar um

encontro com os russos o comandante procurou sair do local mantendo-se em silêncio, porém

o navio entrou em um nevoeiro e possivelmente por erros de navegação acabou encalhado em

águas rasas nas proximidades da Ilha Odensholm (hoje Ilha Osmussar). Não conseguindo se

livrar do encalhe, o comandante pediu ajuda a outros navios, porém sem sucesso mesmo

depois de muitas tentativas. Sem pode movimentar o navio o comandante decidiu por sua

destruição,   pois   essa   seria   a   melhor   forma   dos   russos   não   capturar   informações

imprescindíveis.   Entretanto,   com   a   aproximação   dos   navios   russos   houve   uma   grande

confusão e muitos dos documentos contendo manuais de códigos e chaves foram deixados

para trás, pois antes do comandante dar a ordem de destruição do navio por cargas explosivas,

28

um tripulante acionou antes que fosse dado a ordem final o que ocasionou o abandono do

navio imediatamente e consequentemente a morte de muitos tripulantes. Em virtude de todos

esses transtornos muitos documentos e vários livros de códigos acabaram esquecidos. Mesmo

depois   das   explosões,   o   Magdeburg   não   afundou   permanecendo   encalhado.   Com   isto   os

marinheiros russos puderam entrar no navio e fazer busca por documentos que pudessem

colocar   em   “xeque”   a  Alemanha,   vários   livros   de   códigos   foram   encontrados,   devido   ao

grande valor do achado, os russos distribuíram cópias dos livros e das chaves de cifração aos

aliados   britânicos.   Com   o   auxílio   desses   achados,   os   britânicos   procuraram   decifrar   os

códigos alemãs, porém não obtiveram sucesso, pois faltava alguma chave.

Só em agosto de 1914 com a captura do navio mercante alemão Hobart, foi possível decifrar

os códigos da Marinha alemã, pois neste navio estava o código que faltava. Esse foi o ponto

crucial que causou a derrota da Alemanha na Primeira Guerra Mundial.

1.4.2 – Enigma e a Segunda Guerra Mundial

Foi em fevereiro de 1918 que o engenheiro elétrico e inventor alemã Arthur Scherbius

submeteu sua patente para uma máquina de cifragem usando rotores. Nessa época, Scherbius

fundou a empresa Scherbius & Ritter, junto com seu amigo Richard Ritter. Sinhg (2007) relata

o começo:

Era uma firma de engenharia inovadora que trabalhava com tudo, de turbinas

a travesseiros aquecidos. Scherbius estava encarregado da área de pesquisa e

desenvolvimento   e   buscava   sempre   novas   oportunidades.   Um   de   seus

projetos   era   substituir   os   sistemas   de   criptografia   inadequados,   usados   na

Primeira   Guerra   Mundial,   trocando-se   as   cifras   de   papel   e   lápis   por   uma

forma   de   cifragem   que   usasse   a   tecnologia   do   século   XX.   […]   ele

desenvolveu   uma   máquina   criptográfica   que   era   basicamente,   uma   versão

elétrica do disco de cifras de Alberti. Chamada de Enigma, a invenção de

Scherbius se tornaria o mais terrível sistema de cifragem da História.

Scherbius   e   Ritter   procuraram   a   Marinha   alemã,   mas   não   houve   interesse   pela

máquina. Os oficiais acreditavam que a máquina provia boa segurança, mas não acharam que

houvesse tráfego suficiente de informações para torná-la necessária.

Scherbius   e   Ritter   então   transferiram   os   direitos   de   patente   para   a  Gewerkschaft

Securitas.   Em   09   de   julho   de   1923,   a  Securitas  fundou   a  Chiffriermaschine   Aktien-

Gesellschaft  (ou máquinas de Cifragem de Sociedade Anônima), em cuja diretoria estavam

29

Scherbius e Ritter, até este momento a Enigma foi produzida e comercializada no meio civil,

o primeiro modelo foi denominado enigma A.

Embora   não   tenha   vingado   comercialmente,   a   máquina   Enigma,   com   algumas

alterações, foi finalmente adotada pela Marinha alemã em 1926 (Kahn, 1996) e, alguns anos

mais tarde, em 1928, e com mais alterações, pelo Exército.

Várias versões da enigma foram adquiridas por diferentes nações, tais como a Polônia,

que adquiriu uma versão da Enigma C para estudos pelos serviços de inteligência. A Marinha

italiana   comprou   a   Enigma   D,   assim   também   como   a   Espanha   durante   a   Guerra   Civil

Espanhola. O Exército suiço usou a Enigma modelo K, uma versão modificada da Enigma D.

O Japão usou o Enigma T, também chamada de Enigma Tirpiz, uma adaptação da Enigma D.

Dentre os vários modelos da Enigma, a que mais causou transtorno e assombro na sua

“quebra” de código foi a Enigma M4, exclusivamente desenvolvida para a divisão U-Boot da

Kriegsmarire  (Marinha   Alemã),   teve   papel   fundamental   na   Batalha   do   Atlântico   e   foi

introduzida em 1942, os criptoanalistas de Bletchley Park, a chamaram de Shark-key (Chave-

tubarão). Seu código permaneceu sem ser quebrado por nove meses, até outubro de 1942,

quando livros de códigos novos foram capturados. Os operadores da Enigma recebiam livros

códigos mensalmente com a chave para cada dia.

Figura 15: Enigma M4
(Fonte: http://www.jproc.ca/crypto/enigma.html)

 
1.4.3 –  Criptoanalistas de Bletchley Park

30

“A  enigma   é   uma   máquina   de   cifragem   muito   complicada   e   decifrá-la   exigiu   um

imerso poder intelectual” Sighn (2007).

Quando   a   Primeira   Guerra   acabou,   os   criptoanalistas   britânicos   continuaram

monitorando as comunicações alemãs. Mas, em 1926, com a entrada em funcionamento da

máquina Enigma, começaram a surgir mensagens impossíveis de serem decifradas, tanto por

eles quanto pelos norte-americanos e pelos franceses. O único País que insistiu nas tentativas

de decifragem foi a Polônia.

O matemático Marian Rejewski teve um papel fundamental na insistência polonesa,

pois ele conseguiu mostrar que a Enigma possuía falhas e esse foi o ponto de partida de

estudo dos criptoanalistas de Bletchley Park. Foi quando apareceu a figura do matemático

inglês Alan Turing (1912-1954), responsável por identificar a maior fraqueza da máquina

Enigma.

Figura 16: Alan Turing
(Fonte: http://horizontes.sbc.org.br/index.php/2016/11/22/alan-turing-e-a-enigma/)

Turing juntamente com o time de Bletchley Park desenvolveu a máquina Colossus,

para decifrar a cifra Lorenz, uma cifra utilizada pelo alto comando alemã.

As   informações   obtidas   em   Bletchley   Park   eram   passadas   apenas   as   mais   altas

patentes   militares   e   membros   selecionados   do   gabinete   de   guerra.   O   primeiro   ministro

britânico Winston Churchill chegou a chamar a grande e heterogênea equipe de “os gansos

que botam ovos de ouro e jamais grasnam”(Singh, 2007).

Com as informações privilegiadas, os aliados tinham que manter o segredo sobre a

 
 
“quebra” da cifra da Enigma, pois o fator surpresa era singular nas batalhas, pois se os alemãs

desconfiassem que suas comunicações não eram mais seguras, as Enigmas seriam reforçadas

e Bletchley Park estaria de volta ao ponto de partida. Explica Sighn (2007):

31

Como   no   caso   do   telegrama   Zimmermann,   os   britânicos   tomaram   várias

precauções para evitar despertar suspeitas, tais como afundar a embarcação

alemã depois de roubar seus livros de códigos. Isso faria […] acreditar  que o

material cifrado fora para o fundo do oceano e não caíra em mãos aliadas.

O segredo em torno de Bletchley Park terminou em 1974 com o lançamento do livro

The Ultra Secret, de F. W. Winterbotham. Aqueles que tinham contribuído para o esforço de

guerra podiam receber então o reconhecimento merecido. Entre eles, Marian Rejewski, que

havia sido “relegado ao trabalho de lidar com cifras rotineiras, numa pequena unidade do

serviço de informações” (Singh, 2007). 

Singh (2017) relata que não ficou claro até hoje porque Rejewski não fora convidado a

fazer parte da equipe de criptoanalistas de Bletchley Park, “mas, em consequência disso, ele

ignorava   completamente   as   atividades   da   Escola   de   Códigos   e   Cifras   do   Governo”,   não

sabendo   até   a   publicação   do   livro  The   Ultra   Secret  que   “suas   ideias   tinham   fornecido   o

fundamento para a decifragem rotineira da Enigma durante a guerra.

Entre os que não sobreviveram ao fim do segredo, estão Alastair Denniston, o primeiro

diretor de Bletchley Park, e Alan Turing.

CAPÍTULO 2

Conceitos básicos de Teoria dos Números

32

Na teoria dos números os conceitos e as técnicas são muito abstratos, e geralmente é

difícil   entendê-los   intuitivamente   sem   exemplos.   Por   conseguinte,   este   capítulo   conterá

diversos exemplos, cada um dos quais destacados em uma caixa sombreada. Os conceitos e

técnicas   abordados   neste   capítulo   são  fundamentais   para   o   entendimento   dos   próximos

capítulos. Este capítulo oferece uma visão geral desses conceitos. 

2.1 – Divisibilidade e o algoritmo da divisão

Divisibilidade

“Dizemos que um b diferente de zero divide a se a = mb para algum m, onde a, b e m

são inteiros. Os seja, b divide a  se não houver resto na divisão. A notação b | a normalmente é

usada   para   indicar   que  b  |  a.  Além   disso,   se  b  |  a,   afirmamos   que  b  é   um  divisor  de

a.”(Stallings, 2015)

Os divisores de 24 são 1, 2, 3, 4, 6, 8, 12 e 24.

Vejamos algumas das propriedades de divisibilidade:

Propriedade 1: Se a | 1, então a = ±1.

Propriedade 2: Se a | b e b | a, então a = ±b.

Propriedade 3: Qualquer b ≠ 0 divide 0.

Propriedade 4: Se a | b e b | c, então a | c. 

Prova: Por suposição b = aq e c = bp. Logo, c = (aq)p = a(qp). Então a | c

5 | 55 e 55 | 165 = 5 | 165
Propriedade 5: Se  b | g e b | h, então b | (mg + nh) para inteiros quaisquer m e n.

Prova: Observe que:

Se b | g, então g tem a forma g = bg

para algum inteiro g

1  

.

1

Se b | h, então h tem a forma h = bh

para algum inteiro h

1  

.

1

•

•

Assim,

mg + nh = mbg
1

 + nbh

1

 = b(mg

 + nh

)

1

1

e portanto, b divide mg + ng.

33

a = 6; b = 12; c = 54; d = 3; e = 2
6 | 12 e 6 | 54. 
Para mostrar 6 | (3 × 12 + 2 × 54),
temos (3 × 12 + 2 × 54) = 6 (3 × 2 + 2 × 9),
e é óbvio que 6 | (6 (3 × 2 + 2 × 9)).

Algoritmo da divisão

Dado qualquer inteiro positivo n e qualquer inteiro não negativo a, se dividirmos a por

n, obteremos um quociente inteiro q e um resto inteiro r que obedecem a seguinte relação:

                        a = qn + r     0 ≤ r < n; q = [a / n]

(2.1)

onde [x] é o maior inteiro menor ou igual a x. A equação 2.1 é chamada de algoritmo da

divisão.2

A figura 17 ilustra que, para a e n positivos, conseguimos sempre encontrar q e r que

satisfazem a relação anterior. Representando os inteiros  na linha de números;  a  cairá em

algum ponto nessa linha. Começando em 0 prossiga para n, 2n, até qn, de modo que qn ≤ a e

(q + 1)n > a.

A distância de qn e a é r, e encontramos os valores únicos de q e r. Chamamos de resíduo o

resto r.

a = 13; n = 8;  13 = 1 × 8 + 5;                r = 5   q = 1
a = -13; n = 8;  -13 = (-2) × 8 + 3;         r = 3   q = -2
A Figura 17b contém outro exemplo

Figura 17: A relacao a = qn + r; 0 ≤ r < n.
(Fonte: Stallings, 2015, p. 66)

2

"A equação expressa um teorema, em vez  de um  algoritmo;  mas, por tradição, este é conhecido como
algoritmo da divisão." (Stallings, 2015)

2.2 – Algoritmo de Euclides

Conforme explica Stallings (2015), o algoritmo de Euclides é uma das técnicas mais

básicas da teoria dos números, e com este algoritmo conseguimos encontrar o máximo divisor

comum   de   dois   inteiros   positivos   de   forma   mais   simples.   Primeiro   precisamos   de   uma

definição simples: “dois inteiros são relativamente primos se seu único fator comum inteiro e

34

positivo for 1.” (Stallings, 2015)

Máximo divisor comum

“Lembre-se de que b diferente de zero é definido como um divisor de a se a = mb para

algum m, onde a, b e m são inteiros. Usaremos a notação mdc(a,b) para significar o máximo

divisor  comum  de  a  e  b,   que   é   o   maior   inteiro   que   divide   tanto  a  quanto  b.   Também

indicamos mdc(0,0) = 0.” (Stallings, 2015)

De modo formal, o inteiro positivo c é considerado o máximo divisor comum de a e b

se

1. c é um divisor de a e de b;

2. Qualquer divisor de a e b é um divisor de c.

Uma definição equivalente é a seguinte:

mdc(a,b) = máx[k, tal que k | a e k | b]

Temos que ter  o máximo divisor comum positivo, mdc(a,b) = mdc(a,-b) = mdc(-a,b)

= mdc(-a,-b). Geralmente, mdc(a,b) = mdc(|a|,|b|).

mdc(80,15) = mdc(80,-15) = 5

Porém, como todos os inteiros diferentes de zero dividem 0, temos que mdc(a,0) = |a|.

Falamos que dois inteiros a e b são relativamente primos se seu único fator comum inteiro e

positivo for 1. Isso é o mesmo que dizer que a e b são relativamente primos se mdc(a,b) = 1.

7 e 24 são relativamente primos porque os divisores positivos de 7 são 1 e 7, e os

divisores positivos de 24 são 1, 3, 4, 6, 8, 12 e 24, de modo que 1 é o único

inteiro nas duas listas.

Encontrando o máximo divisor comum

A  descrição   do   algoritmo   creditado   a   Euclides   usado   para   achar   de   forma   fácil   o

máximo divisor comum de dois inteiros. Suponhamos que  dois inteiros a e b, de modo que d

=  mdc(a,b). Como mdc(|a|,|b|) = mdc(a,b), então podemos assumir que  a  ≥  b  >  0.  Agora,

35

dividindo a por b e aplicando o algoritmo de divisão, podemos afirmar: 

a = q

b + r

1

1

0 ≤ r

 < b

1

(2.2)

“Acontece que, se  r
1

  = 0, então  b  |  a  e  d =  mdc(a,b) =  b. Mas, se  r

  ≠  0, podemos

1

afirmar que d | r

1

. Isto é, por conta das propriedades básicas de divisibilidade: as relações d | a

e  d  |  b, juntas, implicam que  d  | (a –  q

b), o mesmo que  d  |  r
1

1

. Antes de proceder com o

algoritmo de Euclides, precisamos responder à pergunta: Qual é o mdc (b,r

)? Sabemos que

1

d | b e d | r

1

. Agora, pegue qualquer inteiro arbitrário c que divide tanto b quanto r

. 

1

Assim,  c  | (q

b + r

1

1

) =  a.  Visto que  c  divide tanto  a  quanto  b, devemos ter  c  ≤  d, que é o

máximo divisor comum de a e b. Portanto, d = mdc(b, r

).” (Stallings, 2015)

1

Retornando à equação 2.2. Suponha que r
1

 ≠ 0. Visto que b > r

1

, podemos dividir b por

 e aplicar o algoritmo de divisão para obter:

r
1

b = q

r
1

 + r
2

2

0 ≤ r
2

 <  r

1

Como antes, se  r

 = 0, então d =  r
1

2

, e, se r

≠ 0, então d = mdc( r
2 

1

,  r

2

). Esse processo

de divisão continua até que apareça algum resto zero, digamos, na fase (n+1), onde   r

n – 1

 é

dividido por  r
n

. O resultado é o seguinte sistema de equações:

a = q
b = q
2
 = q
r
1

b + r
1
1
 + r
r
1
 + r
r
3
2

3

2

                  ●    

                  ●    

                                      ●    
 = q
 = q

r
n - 2
   r

r

n

 + r
n
 + 0

n - 1
r
n

n - 1
n + 1
d = mdc(a, b) = r
n

0 < r
0 < r
0 < r

< b
1 
<  r
2 
<  r
3 

1

2

                 ●

                 ●

                 ●
0 < r
<  r
n 
<  r
0 < r
2
3 

n – 1

(2.3)

A cada iteração, temos d = mdc(r
t

, r

), até que finalmente d = mdc(r

t + 1

, 0) = r
n

n

. Com

isto   acharemos   o  máximo   divisor  comum  de  dois  inteiros  aplicando   de  forma   repetida   o

algoritmo da divisão. O esquema descrito é conhecido como o algoritmo de Euclides.

Faremos   agora   um   exemplo   com   um   número   grande   para   mostrar   o   poder   desse

algoritmo:

 
                          
 
 
       
36

Para encontrar d = mdc(a, b) = mdc(1160718174, 316258250)

a = q

b + r

1

1

b = q

r

 + r
1

2

2

r

1

 = q

r

 + r
2

3

3

r

2

 = q

r

 + r
3

4

4

r

3

 = q

r

 + r
4

5

5

 = q

r

4

r

 + r
5

6

6

r

5

 = q

r

 + r
6

7

7

r

6

 = q

r

 + r
7

8

8

 = q

r

7

r

 + r
8

9

9

1160718174 = 3 × 316258250   +  211943424

d = mdc(316258250, 211943424)

316258250 =   1 × 211943424   +  104314826

d = mdc(211943424, 104314826)

211943424 =   2 × 104314826   +      3313772

d = mdc(104314826, 3313772)

104314826 =     31 × 3313772   +      1587894

d = mdc(3313772, 1587894)

3313772     =       2 × 1587894   +        137984

d = mdc(1587894, 137984)

1587894     =       11 × 137984   +          70070

d = mdc(137984, 70070)

137984       =           1 × 70070   +          67914

d = mdc(70070, 67914)

70070         =           1 × 67914   +            2156

d = mdc(67914, 2156)

67914        =            31 × 2516   +            1078

d = mdc(2156, 1078)

r

8

 = q

r
9

10

 + r

10

2156          =              2 × 1078   +                  0

d = mdc(1078, 0) = 1078

Portanto, d = mdc(1160718174, 316258250) = 1078

(Fonte: Stallings, 2015, p. 68)

 Observe que no exemplo, começamos dividindo 1160718174 por 316258250, o que

resulta em 3 com um resto de 211943424. Depois, tomamos 316258250 e o dividimos por

211943424. Continuamos com esse processo até chegarmos a um resto 0, produzindo 1078

como resultado.

2.3 – Aritmética Modular

Módulo

Sendo  a  um inteiro, e  n, um número positivo, definimos  a  mod  n  para ser o resto

quando a é dividido por n. O inteiro n é chamado de módulo. Com isto, para qualquer inteiro

a, sempre podemos reescrever a Equação 2.1 da seguinte forma:

a = qn + r  0 ≤ r < n; q = [a/n]

a = [a/n] × n + (a mod n)

13 mod 9 = 4;         - 13 mod 7 = 5

Dois inteiros a e b são considerados congruentes módulo n, se (a mod n) = (b mod

n). Isso é escrito como a ≡ b (mod n).

47 ≡ 2 (mod 15);         83 ≡ - 7 (mod 10)

37

Note que, se a ≡ 0 (mod n), então n | a.

Propriedades de congruências

Temos por propriedades de congruências:

1. a ≡ b (mod n), se n | (a – b).

2. a ≡ b (mod n) implica b ≡ a (mod n)

3. a ≡ b (mod n) e b ≡ c (mod n) implica a ≡ c (mod n) 

17 ≡ 2 (mod 5)  porque 17 - 2 = 15 = 5 × 3

-13 ≡ 5 (mod 6) porque - 13 - 5 = -18 = 6 × (-2)

36 ≡ 0 (mod 9) porque 36 - 0 = 36 = 9 × 3

Operações de aritmética modular

Veja que, por definição (Figura 17), o operador (mod n) mapeia todos os inteiros para

o conjunto {0, 1, …, (n – 1)}. Isso sugere a pergunta: podemos realizar operações aritméticas

dentro dos limites desse conjunto? A resposta é que podemos; e aritmética modular é como é

conhecida essa técnica.

As propriedades da aritmética modular são:

1.

2.

3.

[(a mod n) + (b mod n)] mod n = (a + b) mod n

[(a mod n)  - (b mod n)] mod n = (a - b) mod n

[(a mod n) × (b mod n)] mod n = (a × b) mod n

Exemplos:

13 mod 5 = 3; 19 mod 5 = 4
[(13 mod 5) + (19 mod 5)] mod 5 = 7 mod 5 = 2
(13 + 19) mod 8 = 32 mod 5 = 2
[(13 mod 5) – (19 mod 5)] mod 5 = – 1 mod 5 = 4
(13 – 19) mod 5 = – 4 mod 5 = 1
[(13 mod 5) × (19 mod 5)] mod 5 = 12 mod 5 = 2
(13 × 19) mod 5 = 247 mod 5 = 2

Já na exponenciação realizamos da mesma forma que na aritmética comum.

Para encontrar 137 mod 11, podemos proceder da seguinte forma:

132 = 169 ≡ 4 (mod 11)
134 = (132)2 ≡ 42 ≡ 5 (mod 11)
137 ≡ 13 × 4 × 5 ≡ 260 ≡ 7 (mod 11)

38

Com isto é possível verificar que as regras da aritmética comum são as mesmas que as

usadas na aritmética modular.

2.4 – Números primos

Para Stallings (2015), o estudo dos números primos é de fundamental importância no

estudo da teoria dos números. Na realidade, livros inteiros foram escritos sobre o assunto.

Um inteiro p > 1 é um número primo se, e somente se, seus únicos divisores forem ± 1

e ± p. Os números primos desempenham um papel importante na teoria dos números.

2.4.1 – Teorema Fundamental da Aritmética

Qualquer inteiro a > 1 pode ser fatorado de uma forma exclusiva como

a = p

a1 × p

a2  × … × p
t

2

at

1

onde p

 < p

2

1

 < … < p

t  

são números primos e cada a

 é um inteiro positivo. Isso é conhecido
t

como teorema fundamental da aritmética.

77 = 7 × 11
1300 = 22 × 52 × 13
29645 = 5 × 72 × 112

2.5 – Teoremas de Fermat e Euler

Segue abaixo dois teoremas bastante importantes no estudo da criptografia de chave

pública.

Teorema de Fermat3

O teorema de Fermat afirma o seguinte: se  p  é primo e  a  é um inteiro positivo não

divisível por p, então

a p – 1 = 1 (mod p).

a = 5, p = 17
52 = 25 ≡ 8(mod 17)

3 Este, às vezes, é conhecido como pequeno Teorema de Fermat.

39

54 = 64 ≡ 13(mod 17)
58 = 169 ≡ 16(mod 17)
516 = 256 ≡ 1(mod 17)
a p - 1 ≡ 516 = 516 ≡ 1(mod 17)

Outra forma equivalente e de grande utilidade do teorema de Fermat é: se p é primo e

a um inteiro positivo, então

a p = a (mod p)

p = 5, a = 3                   a p = 35 = 243 ; 3(mod 5) = a(mod p)

p = 5, a = 10                a p = 105 = 100000 ; 10(mod 5) ; 0(mod 5) = a(mod p)

Teorema de Euler

Uma função de grande importância na teoria dos números é a função totiente de Euler,

a qual será apresentada antes do teorema de Euler. Essa função “é escrita como φ(n), definida

como   o   número   de   inteiros   positivos   menores     que  n  e   relativamente   primos   de  n.   Por

convenção, φ(1) = 1.” (Stallings, 2015)

DETERMINE φ(17) e φ(25).

Como 17 é primo, todos os inteiros positivos de 1 até 16 são relativamente primos de 17.

Assim, φ(17) = 16.

Para   determinar  φ(25),   listamos   todos   os   inteiros   positivos   menores   que   25   que   são

relativamente primos dele:

1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 

16, 17, 18, 19, 21, 22, 23, 24.

Existem 20 numeros na lista, de modo que φ(25) = 20.

Na tabela 1 temos uma lista dos 30 primeiros valores de φ(n). Observe que φ(1) não

tem significado, porém seu valor é definido como 1.

Portanto ficar evidente que se p  é primo, temos:

φ(p) = p – 1

Supondo   que   tenhamos   dois   números   primos  p  e  q,   com  p  diferente   de  q.

Conseguiremos mostrar que, para n = pq,

φ(n) = φ(pq) = φ(p) × φ(q) = (p – 1) × (q – 1)

40

Tabela 1: Alguns valores da funcão totiente de euler φ(n).
(Fonte: Stallings, 2015, p. 187)

Teorema de Euler: Dados inteiros a, n primos entre si, com n > 1, temos que:

a φ(n) ≡ 1 (mod n)

a = 3; n = 10; φ(10) = 4       a φ(n)(n) = 34 = 81 = 1(mod 10) = 1(mod n)
a = 2; n = 11; φ(11) = 10     a φ(n)(n) = 210 = 1024 = 1(mod 11) = 1(mod n)

Uma outra forma útil de representar o teorema de Euler é:

a φ(n) + 1 ≡ a (mod n)

CAPÍTULO 3

Criptografia ou encriptação Simétrica

41

Conforme explica Stallings (2015), a encriptação simétrica é também conhecida como

encriptação convencional ou encriptação de chave única, ela foi por muito tempo o único tipo

em uso antes do desenvolvimento da encriptação por chave pública na década de 1970. Esse

continua sendo de longe o mais usado dos dois tipos de encriptação. 

3.1 – Modelo de Cifra Simétrica

Segue abaixo um esquema de encriptação simétrica com cinco itens, conforme mostra

Stallings (2015):

• Texto   claro:  mensagem   ou  dados   originais   onde   é   possível   a   compreensão   e  que

servem como entrada do algoritmo de encriptação.

• Algoritmo de encriptação: é o que realiza as diversas substituições e transformações

no texto claro.

• Chave secreta:  também é uma entrada para o algoritmo de encriptação. O valor da

chave é independente do texto claro e do algoritmo. O algoritmo irá produzir uma

saída   diferente,   dependendo   da   chave   usada   no   momento.   As   substituições   e

transformações exatas realizadas pelo algoritmo dependem da chave.

• Texto cifrado: é a mensagem incompreensível, produzida como saída do algoritmo de

encriptação.   Ela   depende   do   texto   claro   e   da   chave   secreta.   Para   determinada

mensagem, duas chaves diferentes produzirão dois textos cifrados distintos. O texto

cifrado é um conjunto de dados aparentemente aleatório e, nesse formato, ininteligível.

• Algoritmo de decriptação: é o algoritmo de codificação executado de modo inverso.

Ele apanha o texto cifrado e a chave secreta e produz o texto original.

Ainda segundo  Stallings  (2015), existem dois requisitos para o uso seguro da encriptação

simétrica:

1. O que se precisa é um algoritmo de encriptação forte. Temos que ter no mínimo um

algoritmo que qualquer oponente que conheça o algoritmo e tenha acesso a um ou

mais textos cifrados não seja capaz de decifrar o texto cifrado ou descobrir a chave.

Esse requisito normalmente é indicado de maneira mais forte: o oponente deverá ser

incapaz de decriptar o texto cifrado ou descobrir a chave, mesmo que possua diversos

textos cifrados com seus respectivos textos claros.

2. A obtenção dos códigos das chaves secretas entre o emissor e o receptor devem ser

obtidas de forma segura e protegida. Pois se alguém conseguir descobrir a chave e o

algoritmo, toda a comunicação usando essa chave poderá ser lida.

42

Figura 18: Modelo simplificado da encriptação simétrica
(Fonte: Stallings, 2015, p. 21)

Stallings (2015), explica que não é preciso manter o algoritmo secreto, mas sim a

chave secreta. Essa característica da encriptação simétrica é o que a torna viável para uso

generalizado. Stallings (2015) afirma: “O fato de que o algoritmo não precisa ser mantido

secreto   significa   que   os   fabricantes   podem   desenvolver,   e   realmente   têm   desenvolvido,

implementações de chip de baixo custo com algoritmos de encriptação de dados. Esse chips

são encontrados com facilidade e estão incorporados em diversos produtos.” Sendo assim,

manter o sigilo da chave é o principal problema no uso da criptografia simétrica.

3.2 – Formas de ataque a um sistema de encriptação

Geralmente, o ataque a um sistema de encriptação tem o objetivo de recuperar a chave

em uso, em vez de simplesmente recuperar o texto claro a partir de um único texto cifrado.

Para Stallings (2015), existem duas técnicas gerais para o ataque a um esquema de

encriptação convencional, a criptoanálise e o ataque por força bruta.

Assim Stallings (2015) explica as duas formas de ataque:

• Criptoanálise: é o tipo de ataque que utiliza a natureza do algoritmo, e talvez de mais

algum conhecimento das características comuns ao texto claro, ou ainda de algumas

amostras de pares de texto claro-texto cifrado. Esse é o tipo de ataque que visa explora

as  específicações   do  algoritmo   para  tentar  deduzir  um texto  claro  específico  ou  a

chave utilizada.

• Ataque   por  força   bruta:    é   o   tipo   de   ataque   onde   são   testadas   todas   as   chaves

possíveis em um trecho do texto cifrado, até obter uma tradução comprensível para o

texto   claro.   Na   média,   metade   de   todas   as   chaves   possíveis   precisam   ser

experimentadas para então se obter sucesso.

Um efeito catastrófico é se algum dos tipos de ataque desses tiver sucesso na dedução da

chave   todas   as   mensagens   futuras   e   passadas,   encriptadas   com   essa   chave,   ficam

43

comprometidas.

3.3 – Técnicas de encriptação

Nesta seção examinaremos algumas técnicas de encriptação clássicas:

3.3.1 – Técnicas de substituição

Para Stallings (2015), uma técnica de substituição é aquela em que as letras do texto

claro são substituídas por outras letras, números ou símbolos.4

3.3.1.1 – Cifra de César

Conforme explica  Stallings (2015), a cifra de substituição que foi elaborado por Júlio

Cesar é a mais simples e a mais antiga em uso. A cifra de César envolve substituir cada letra

do alfabeto por aquela que fica três posições adiante.

Por exemplo:

claro: a vitória será nossa

       cifra: D YLWRULD VHUD QRVVD

Observe que o alfabeto recomeça no final, de modo que a letra Z é a A. Podemos

definir a transformação listando todas as alternativas, da seguinte forma:

Claro: a b c d e
Cifra: D E F G H I

f g h i

t u v w x y z
J K L M N O P Q R S T U V W X Y Z A B C

j k l m n o p q r

s

Atribuindo um valor numérico a cada letra:

a

0

n

13

b

1

o

14

c

2

p

15

d

3

q

16

e

4

r

17

f

5

s

18

g

6

t

19

h

7

u

20

i

8

v

21

j

9

w

22

k

10

x

23

l

11

y

24

m

12

z

25

4 Texto claro está sempre em minúsculas; texto cifrado está em maiúsculas.

44

Observe que o algoritmo é ser expresso da forma a seguir. Para cada letra em texto

claro p, substitua-a pela letra do texto cifrado C:5

C = E(3,p) = (p + 3) mod 26

Um deslocamento pode ser de qualquer magnitude, de modo que o algoritmo de César

geral é

C = E(k,p) = (p + k) mod 26

onde k assume um valor no intervalo de 1 a 25. O algoritmo de decriptação é simplesmente

p = D(k,C) = (C - k) mod 26

Se  for  conhecido  que   determinado  texto  cifrado  é  uma   cifra   de  César,  então  uma

criptoanálise pela força bruta será facilmente realizada. Basta experimentar todas as 25 chaves

possíveis.

3.3.1.2 – Cifras monoalfabéticas

Como visto no subitem anterior, a cifra de César não tem tanta segurança, pois possui

apenas 25 chaves possíveis. Para conseguir um aumento considerável no espaço de chaves

permitir-se uma substituição arbitrária. Conforme sugere Stallings (2015), iremos definir o

termo permutação. “Uma permutação é um conjunto finito de elementos S em uma sequência

ordenada de todos os elementos de  S, com cada um aparecendo exatamente uma vez. Por

exemplo, se S = {a, b, c}, existem seis permutações de S” (Stallings, 2015):

abc, acb, bac, bca, cab, cba.

Em geral, existem  n! permutações de um conjunto de  n  elementos, pois o primeiro

deles pode ser escolhido de n  maneiras, o segundo, de n – 1 maneiras, o terceiro, de n – 2

maneiras, e assim por diante.

Lembrando da atribuição para a cifra de César:

Claro: a b c d e
Cifra: D E F G H I

f g h i

t u v w x y z
J K L M N O P Q R S T U V W X Y Z A B C

j k l m n o p q r

s

Se, em vez disso, a linha “cifra” puder ser qualquer permutação dos 26 caracteres

alfabéticos,   então   haverá   26!   ou   mais   do   que   4   x   1026  chaves   possíveis.   Essa   técnica   é

conhecida como  cifra por substituição monoalfabética, pois um único alfabeto de cifra é

utilizado por mensagem.

5 Definimos a mod n como sendo o resto quando a é dividido por n. Por exemplo, 13 mod 7 = 6

Stallings (2015) explica que as cifras monoalfabéticas são fáceis de se quebrar porque

reflete os dados de frequência do alfabeto original. 

45

3.3.1.3 – Cifras polialfabéticas

Stallings (2015) afirma que uma outra forma de melhorar a técnica monoalfabética

simples é usar diferentes substituições monoalfabéticas enquanto se prossegue pela mensagem

de texto claro. O nome que se dar para essa técnica é  cifra por substituição polialfabética.

Para  Stallings (2015),  essas técnicas têm as seguintes características em comum:

1. Um conjunto de regras de substituição monoalfabéticas é utilizado.

2. Uma   chave   define   qual   regra   em   particular   é   escolhida   para   determinada

transformação.

Uma das mais simples e mais conhecida cifras polialfabéticas é a cifra de Vigenère. 

3.3.2 – Técnicas de transposição

  A  transposição,   consiste   em   trocar   a   posição   das   letras   da   mensagem   original,

promovendo   uma   permutação   das   letras   segundo   um   algoritmo   e   uma   chave   bem

determinadas. Uma técnica de transposição muito conhecida é o bastão de Licurgo, conforme

visto na seção 1.1.4.

Conforme explica Stallings (2015), a cifra mais simples desse tipo é conhecida como

cerca de trilho  que consiste em escrever o texto claro em uma sequência de diagonais, e

depois lido como uma sequência de linhas. Por exemplo, para cifrar a mensagem “matemática

aplicada” com uma cerca de trilho de profundidade 2, escrevemos o seguinte:

m t m t

c a l

c d

a e a

i a p

i a a

A mensagem encriptada é 

MTMTCALCDAEAIAPIAA

Para  Stallings (2015), esse tipo de cifra seria fácil de ser criptanalisada. Um forma

mais difícil seria escrever a mensagem em um retângulo, linha por linha, e a ler coluna por

coluna, mas permutar a ordem destas. Nesse caso a chave para o algoritmo seria a ordem das

colunas. Por exemplo,

46

Chave:

Texto claro:

4 3 1 2 5 6 7

a n i m a i s

e s t a r a m

a n d a n d o

Texto cifrado:      ITDMAANSNAEAARNIADSMO

Assim, neste exemplo, a chave é 431567. Para codificar iremos iniciar com a coluna rotulada

com 1, neste caso, a coluna 3. Escreva todas as letras dessa coluna. Prossiga para a coluna 4,

que é rotulada com 2, depois para a coluna 2, então para a coluna 1, por fim a 5, 6 e 7.

3.3.3 – Máquinas de rotor

As máquinas de rotor6 era a classe de sistemas que tem a aplicação mais importante do

princípio de múltiplas etapas de codificação.

Na figura 19 é ilustrado o princípio básico da máquina de rotor. Conforme explica

Stallings (2015), a máquina de rotor é composta por um conjunto de cilindros que tem rotação

independente, e através dos quais pulsos elétricos podem fluir. Observe que cilindro tem 26

pinos de entrada e 26 pinos de saída, com fiação interna que conecta cada pino de entrada a

um   único   pino   de   saída.   Para   efeito   de   entendimento,   iremos   mostrar   somente   três   das

conexões internas em cada cilindro.

Figura 19: Máquina de três rotores com fiação representada por contatos numerados.
(Fonte: Stallings, 2015, p. 38)

6

"Máquinas baseadas no princípio de rotor foram usadas para Alemanha (Enigma) e pelo Japão (Purple) na
Segunda Guerra Mundial. A quebra desses dois códigos pelos Aliados foi um fator significativo para o
resultado da Guerra."(Stallings,2015)

47

Se relacionarmos um pino de entrada e saída a apenas uma letra do alfabeto, uma

substituição monoalfabética é definida em um único cilindro. Por exemplo, na Figura 19, se

um operador pressionar uma tecla para a letra B, um sinal elétrico é aplicado ao segundo pino

do primeiro cilindro e flui pela conexão interna para o vigésimo terceiro pino de saída.

Considere uma máquina com um único cilindro conforme  sugere Stallings  (2015),

após pressionar cada tecla de entrada, uma posição é girada no cilindro fazendo com que

conexões   internas   se   desloquem   de   acordo.   Com   isto,   uma   cifra   de   substituição

monoalfabética diferente é definida. Após pressionar 26 letras de texto claro, o cilindro giraria

26 vezes, ou seja, voltaria a posição inicial. Assim, conseguimos um algoritmo de substituição

polialfabética com um período de 26. É óbvio que um sistema  com um único cilindro é

simples, além de ser fácil descobrir a chave.  O poder da  máquina de rotor está no uso de

múltiplos cilindros, em que os pinos de saída de um cilindro são conectados aos de entrada do

seguinte.  A  Figura  19   mostra   um  sistema   de   três   cilindros.  A  metade   esquerda   da   figura

mostra uma posição em que a entrada do operador para o primeiro pino (letra b em texto

claro) é direcionada pelos três cilindros para aparecer na saída do segundo pino (letra I em

texto cifrado).

Stallings (2015) afirma que: “com múltiplos cilindros, aquele mais próximo da entrada

do operador gira uma posição de pino a cada toque de tecla. A metade direita da Figura 19

mostra   a   configuração   do  sistema   depois   de  um  único   toque   de   tecla.   Para   cada   rotação

completa do cilindro interno, o do meio gira uma posição de pino. O resultado é que existem

26 x 26 x 26 = 17.576 alfabetos de substituição diferentes usados antes que o sistema repita.

O acréscimo de quarto e quinto rotores resulta em períodos de 456.976 e 11.881.376 letras,

rescpectivamente.   Assim,   determinada   configuração   de   uma   máquina   de   5   rotores   é

equivalente a uma cifra de Vigenère com um tamanho de chave de 11.881.376.”

Para Stallings (2015), a máquina de rotor tem um significado bastante importante, pois

ela direciona para a cifra mais usada de todos os tempos: Data Encryption Standard (DES).

3.3.4 – Esteganografia

Uma mensagem em texto claro pode estar oculta de duas maneiras, segundo explica

Stallings (2015), a esteganografia tem como método esconder a existência da mensagem e a

criptografia   tem   como   métodos   tornar   a   mensagem   ininteligível   a   estranhos   por   meio   de

várias transformações do texto.

 
“Uma forma simples de esteganografia, mas demorada de se construir, é aquela em

que um arranjo de palavras e letras dentro de um texto aparentemente inofensivo soletra a

mensagem real. Por exemplo, a sequência de primeiras letras de cada palavra da mensagem

geral soletra a mensagem escondida.” (Stallings, 2015)

48

3.4 – Data Encryption Standard (DES)

O   Data   Encryption   Standard   –   DES   –   é  um  padrão   criptográfico   criado   em   1977

através   de   uma   licitação   aberta   pela   antiga  Agência   de   Segurança  Americana   –   National

Security Agency  (NSA).  O   único   concorrente   foi   o   algoritmo   LUCIFER  da   International

Business Machine – IBM, conforme Schneier (1994). Após algumas  modificações no seu

código original, chegou-se ao padrão de 64 bits de leitura, aplicando uma chave com 56 bits à

mensagem.

Stallings (2015), explica que até o uso do advanced encryption standard (AES), em

2001, o esquems de codificação mais utilizado era o data encryption standard (DES). Pontua

que o DES foi adotado no ano de 1977 pelo National Bureau of Standards, agora National

Institute of Standards and Technology (NIST), como Federal Information Processing Standard

$ (FIPS PUB 46). O algoritmo é conhecido como data encryption algorithm (DEA). O DES

funciona do seguinte moso: os dados são codificados em blocos de 64 bits usando uma chave

de 56 bits. O algoritmo transforma a entrada de 64 bits em uma série de etapas para a saída de

64 bits. As mesmas etapas, com a chave, são empregadas para reverter a codificação.

Passado   anos,   o   algoritmo   de   decodificação   simétrica   dominante   foi   o   DES,

especialmente em aplicações financeiras. O DES foi ganhando espaço cada vez mais e em

1994 o NIST reafirmou o DES para uso federal por outros cinco anos, o NIST recomendou o

uso do DES para aplicações que não tenham informações de proteção ou confidenciais. Em

1999, o NIST emitiu uma nova versão do seu padrão (FIPS PUB 46-3), que indicava que o

DES deveria ser utilizado apenas para sistemas legados, e que o triple DES (que basicamente

envolve repetir o algoritmo DES três  vezes  sobre o texto claro com duas  ou três chaves

diferentes para produzir o texto cifrado) fosse empregado.

3.4.1 – Encriptação do Data Encryption Standard (DES)

Iremos   apresentar   esse   sistema   de   encriptação   DES   segundo   Stallings   (2015).   Na

figura 20 iremos apresentar uma ilustração do esquema geral. Para começarmos, introduz-se o

texto   claro   e   a   chave,   que   são   as   duas   entradas   necessárias   em   qualquer   esquema   de

encriptação. Neste caso, o texto claro precisa ter 64 bits de extensão, e a chave tem 58 bits de

extensão.7

49

Figura 20: Representação geral do algoritmo de encriptação DES.
(Fonte: Stallings, 2015, p. 55)

“Fazendo   uma   verificação   do   lado   esquerdo   da   figura   20,   podemos   ver   que   o

processamento do texto claro prossegue em três fases. Primeiro, o texto claro de 64 bits passa

por   uma   permutação   inicial   (IP,   do   acrônimo   em   inglês   para  initial   permutation),   que

reorganiza   os   bits   afim   de   produzir   a  entrada   permutada.   Isso   é   seguido   por   uma   fase

consistindo em 16 rodas da mesma função, que envolve funções de permutação e substituição.

A saída da última (décima sexta) rodada baseia-se em 64 bits que são uma função do texto

7 Na realidade, a funcão espera uma chave de 64 bits como entrada. Porém, somente 56 desses bits são usados;
outros 8 bits podem ser empregados como bits de paridade ou simplesmente definidos arbitrariamente.

50

claro de entrada e da chave. As metades esquerda e direita da saída são trocadas para produzir

a pré-saída. Finalmente, a pré-saída é passada por uma permutação [IP-1], que é o inverso da

função de permutação inicial, a fim de produzir o texto cifrado de 64 bits.” (Stallings, 2015)

Ainda segundo Stallings (2015), o lado direto da Figura 20 mostra a chave que é

usada, no caso a de 56 bits. Primeiro, a chave passa por uma função de permutação. Logo

após, para cada uma das 16 rodadas, uma subchave (Ki) é produzida pela combinação de um

deslocamento circular a esquerda e uma permutação. Uma subchave diferente é produzida

para cada função de permutação em cada rodada, por conta dos deslocamentos repetidos dos

bits da chave.

3.4.2 – Decriptação do Data Encryption Standard (DES)

A decriptação de uma cifra do DES usar-se basicamente o mesmo algoritmo, apenas

alterando a ordem das chaves a serem usadas. Além disso, as permutações inicial e final são

invertidas.

3.4.2.1 – Exemplo do DES

Traremos nesta seção um exemplo completo de mensagem encriptada e decriptada

pelo sistema criptográfico DES.

Para encriptar devemos converter uma mensagem em uma sequência de números. Para

efeito de exemplificação, tomaremos a seguinte tabela de conversão:

a

10

b

11

c

d

e

f

g

h

i

j

k

l

m n

o

p

q

r

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

s

t

u

v w x

y

z

-

0

1

2

3

4

5

6

7

8

9

28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46

Tabela 1

O espaço entre palavras será substituído pelo nº. 36. As conversões do texto a ser

encriptado será feito sem considerar acentos e letras maiúscula. A vantagem de se utilizar dois

dígitos para representar uma letra reside no fato de que tal procedimento evita a ocorrência de

ambiguidades. Por exemplo, se a fosse convertido em 1 e b em 2, teríamos que ab seria 12,

mas l também seria 12. Logo, não poderiamos concluir se 12 seria ab ou l.

O sistema DES consiste de um algoritmo de criptografia simétrico e polialfabético

51

com entrada e saída binárias. Sendo assim, uma mensagem a ser enviada deve ser convertida

em uma sequência binária.

Como visto anteriormente, o algoritmo precisa de duas entradas: a mensagem a ser

enviada  e,  portanto,  codificada  e  a  chave,  que  é a  “senha”  que  irá  manter  a  transmissão

sigilosa.

Consideremos as seguintes tabelas para a construção da Criptografia DES:

52

53

54

O texto claro convertido em uma sequência binária é dividido em blocos M que podem

ser de 64 dígitos cada.

Consideremos   a   função  I  que   permuta   a   posição   dos   64   dígitos   do   bloco  M.

Geralmente I é definida por uma tabela.

Para   efeito   de   compreensão   do   algoritmo,   chamemos   a   imagem   I(M)     de   N

  e

0

descrevamos uma rodada do algoritmo (geralmente são realizadas 16 rodadas), que:

(i)

Dividamos   o   bloco  N

0

  de   64   dígitos   em   duas   partes:   a   parte   “esquerda”,   que

chamaremos de E

 e a parte “direita” que chamaremos de D
0

.

0

(ii)

Consideremos a função X que expande o bloco D

, de 32 dígitos, para um bloco X(D

)

0

0

de 48 dígitos. Além da expansão, nessa etapa temos também uma permutação de dígitos, uma

vez que, à semelhança de I, X é dada por uma tabela.

(iii)

Consideremos um bloco aleatório de 48 dígitos binário que denotaremos por K

. Esse

1

bloco é parte das chaves do sistema criptográfico (para cada rodada há uma chave).

(iv)

Uma soma binária dígito a dígito entre X(D

) e K
1

0

 é realizada.

(v)

O bloco X(D

) + K

0

1

 é dividido em blocos B

, …, B

1

8

 de 6 dígitos cada e, utilizando 8

funções redutoras S

, …, S

1

8

. Essas funções transformam B

  de 6 dígitos em blocos B'

de 4
i  

i

dígitos. Desse modo, o bloco X(D

) + K

0

1

 é transformado em um bloco S  de 32 dígitos.

(vi)

Uma outra permutação de dígitos P é aplicada ao bloco S.

(vii) Uma outra soma binária dígito a dígito é feita entre o bloco P(S) e o bloco E

. Essa

0

soma é chamada de D

.

1

(viii) Definimos o bloco E
1

 como sendo o bloco D

.

0

(ix)

Um novo bloco N

 é formado pela junção do bloco E
1

1

 com o bloco D

1

 formado acima.

O bloco N
1

 é submetido a uma nova rodada conforme descrito acima e obtemos N
2

, N
3

até N

16

.

Após as 16 rodadas, é realizada uma troca de lados em N

 entre os blocos E

16

 e D

. 

16

16

Chamemos essa troca de T. Assim, T(E

16

) = D'

 e T(D

16

) = E'

16

 e, temos um novo bloco

16

T(N

) = N '

16

.

16

Por fim, a inversa da função permutação I, ou seja, I-1  é aplicada em N'

  e este é o

16

bloco encriptado, que chamaremos de C. Assim, I-1(N '

16

) = C.

Simplificado, temos a seguinte composta:

55

I(M) = N

 = E

D

→ X ○  I(M) = E
0
0 

0

0

X(D

0

)

→ ○

K
i

 ○ X ○ I(M) = E

 [ X(D

) + K
1

0

] = E

 [ B

B

B

2

1

3

B

4

B

5

B

6

B

7

B

8

0

] →

0

S ○ K1 ○ X ○ I(M) = E0 [ S1(B1) S2(B2) S3(B3) … S7(B7) S8(B8)] 

B'
S ○ K1 ○ X ○ I(M) = E0 [ B'
1 

B'
B'
3 
2 

B'
B'
5 
4 

B'
B'
7 
6 

8

] → S ○ K1 ○ X ○ I(M) = E0S

→ P ○ S ○ K1 ○ X ○ I(M) = E0 P(S) → E0 ○ P ○ S ○ K1 ○ X ○ I(M) = [E0  + P(S)] →

D0 ○ E0 ○ P ○ S ○ K1 ○ X ○ I(M) = D0[E0 + P(S)] → D0 ○ E0 ○ P ○ S ○ K1 ○ X ○ I(M) = D0D1

→ D0 ○ E0 ○ P ○ S ○ K1 ○ X ○ I(M) = E1D1 → D0 ○ E0 ○ P ○ S ○ K1 ○ X ○ I(M) = N1

Chamando D0 ○ E0 ○ P ○ S ○ K1 ○ X = Z1. Logo,

Z1 ○ I(M) = N1.

Aplicando 16 rodadas, temos:

Z16 ○…○ Z1 ○ I(M) = N16 → T ○ Z16 ○…○ Z1 ○ I(M) = N '16 →

I -1 ○ T ○ Z16 ○…○ Z1 ○ I (M) = C 

Chamando I -1 ○ T ○ Z16 ○…○ Z1 ○ I(M) = DES, temos

DES(M) = C.

Como o algoritmo é simétrico, para decifrar C, basta aplicá-lo novamente, ou seja

                                               DES(C) = M.

Sigamos ao exemplo prático:

Seja a mensagem PROFMAT_RJ. Suponhamos que o emissor A, queira enviar essa

mensagem ao receptor B usando a Criptografia DES. Assim o emissor A associa a mensagem

aos números correspondentes na TABELA 1, obtendo a sequência de números:

que, respectivamente, na base binária são:

25  27  24  15  22  10  29  36  27  19,

011001  011011  011000  001111  010110  000010  011101  100100  011011  010011

Agrupando a sequência de bits em blocos de 64 bits temos:

M = 0110010110110110000011110101100000100111011001000110110100110000.           (1)

 
Notemos que tinhamos apenas 60 bits. Os bits que ficaram faltando para completar um

bloco de 64 bits foram obtidos acrescentando-se 4 zeros ao final da sequência.

Logo, para o início do processo de ciframento, a mensagem passa pela primeira fase

que é a função permutação I, a partir da TABELA 2, no qual é obtida pela sequência a seguir:

56

I(M)=N0= 1111001100000010100010100110100101010101011101110001011001001100   (2)

O  n-ésimo bit de  (2)  é o  m-ésimo bit de  (1), sendo que  m  e  n  estão relacionados de

acordo com a entrada mn da TABELA 2. Por exemplo, se n = 1, a TABELA 2 fornece m =

59, n = 2, a TABELA 2 fornece m = 51.

Logo, o 1º bit de (2) é o 59º bit de (1), o 2º bit de (2) é o 51º bit de (1) e assim por diante.

Separando (2) em blocos de 32 bits, obtemos dois blocos. Chamaremos os primeiros

32 bits de bloco da “esquerda” e denotaremos por “E0” e os outros 32 bits restantes de bloco

da “direita” e denotaremos por “D0”. Assim,

E0 = 11110011000000101000101001101001

                           D0 = 01010101011101110001011001001100    

   (3)

Para o bloco D0  faremos uma expansão usando a TABELA 4. Assim, essa sequência

de 32 bits será transformada em uma nova sequência com 48 bits, dada por:

                     X (D0) = 110000010110100110001110000110010111010110110111              (4)

O n-ésimo bit de (4) é o m-ésimo de (3), sendo que m e n estão relacionados de acordo

com a entrada da TABELA 4. Por exemplo, se n = 1, a TABELA 4 fornece m = 15. Logo, o

1º bit de (4) é o 15º bit de (3) e assim, por diante.

Consideremos   uma   sequência   binária   de   48   bits,   que   será   a   chave   (que   deve   ser

mantida em sigilo pelos comunicantes):

K1 = 111101101010010010100011000110010110100111010001

Fazendo a soma binária, dígito a dígito, dos 48 bits do bloco X (D 0) com a chave K1,

temos a nova sequência:

  
X (D0) +  K1  = 001101111100110100101101000000000001110001100110.

57

Usaremos agora, as Caixas S TABELA 6 para comprimir a sequência acima de 48 bits

para 32 bits binários. Primeiramente, dividiremos a sequência anterior em blocos de 6 bits

obtendo: B1 o primeiro bloco, B2 o segundo bloco até o oitavo bloco:

001101   111100   110100   101101   000000   000001   110001   100110

         B1            B2           B3           B4            B5           B6           B7           B8

Os blocos B, serão reduzidos a quatro bits cada utilizando-se as Caixas Si do seguinte

modo:

O primeiro e último dígito de Bi  formam, em decimal, um número  x de 0 a 3, que

corresponde a uma das quatro linhas de Si. Os quatro dígitos intermediários de Bi formam, em

decimal,   um  número  y  de   0   a   15,   que   corresponde   a   uma   das   16   colunas   de  Si.  Assim,

localizamos o número sx,y na tabela Si. O número s é um número de 0 a 15, que em binário,

corresponde a uma sequência B'i de quatro dígitos que será colocada no lugar de Bi.

Por exemplo, no primeiro bloco

B1 = 001101,

temos que o primeiro e o último dígitos, 0 e 1, formam o número binário 01, que em decimal

é o número 1, ou seja, temos a segunda linha de S1. Os quatro dígitos do meio de B1 formam o

número binário 0110, que em decimal é o número 6, que corresponde a sétima coluna de S 1.

Logo, localizamos  sx,y = 111,6, ou seja, s = 11, que em binário é 1011. Assim B1 = 001101 é

substituído por B'1 = 1011.

De modo analógo para o restante dos blocos vamos obter:

 B'2 = 1001,  B'3 = 1101,  B'4 = 1110,  B'5 = 0110,  B'6 = 0010,  B'7 = 0101,  B'8 = 1101.

Juntando todos os blocos B'i, para i = 1, 2, 3, ...8, em uma só sequência obtemos:

S = 10111001110111100110001001011101

Usando   a  TABELA   5,   fazemos   uma   nova   permutação   da   sequência   acima   à

semelhança da que fizemos na sequência (1) a qual chamaremos de P(S):

P(S) = 01010011111000111110111101001100

58

Fazendo a soma binária de E0 + P(S) temos:

D1 = E0 + P(S) = 10100000111000010110010100100101

Juntando, respectivamente, as sequências D0 e D1 temos:

N1 = 0101010101110111000101100100110010100000111000010110010100100101

Aplicando a troca T dos blocos de 32 dígitos dos lados esquerdo e direito temos:

T(N1) = N'1= 1010000011100001011001010010010101010101011101110001011001001100

Para finalizar a criptografia vamos utilizar a TABELA 3 e aplicar a permutação I -1 na

sequência anterior:

C = I -1(N'1) = 1101010100000110010111110000100000000111111101001001110110100000

Logo   essa  sequência,   é   a  mensagem  criptografada.  Assim   o  emissor  A  envia   essa

mensagem para o receptor B.

Para o  deciframento, a sequência recebida o receptor B deverá proceder de modo

analógo ao processo de ciframento.

O receptor B aplicará a função I a partir da TABELA 2, que é a primeira fase, e obterá

a sequência a seguir:

I(C) = 1010000011100001011001010010010101010101011101110001011001001100

Separando   a   sequência   anterior   em   blocos   de   32   bits,   obtemos   dois   blocos.

Chamaremos os 32 bits de bloco da “esquerda”, que denotaremos por “E0” e os outros 32 bits

restantes de bloco da “direita”, que será denotado por “D0”:

E0 = 10100000111000010110010100100101

D0 = 01010101011101110001011001001100

59

Para o bloco D0 faremos a expansão usando a TABELA 4. Assim, a sequência de 32

bits será transformada em uma nova sequência com 48 bits:

X(C) = 110000010110100110001110000110010111010110110111

Usando a mesma chave K1  de 48 bits que usamos para cifrar a mensagem, dada a

seguir:

K1 = 111101101010010010100011000110010110100111010001

Fazemos   a   soma   binária   desses   48   bits   com   o   bloco   X(C)   e   obtemos   uma   nova

sequência:

X(C) + K1 = 001101111100110100101101000000000001110001100110

Utilizando a TABELA 6, das Caixas S, e fazendo os mesmos procedimentos adotados

no ciframento, separemos a sequência em blocos de 6 bits:

001101   111100   110100   101101   000000   000001   110001   100110

         B1            B2           B3           B4            B5           B6           B7           B8

Teremos a seguinte redução de 6 bits para 4 bits dada a seguir:

B'1 = 1011,  B'2 = 1001, B'3 = 1101, B'4 = 1110, B'5 = 0110, B'6 = 0010, B'7 = 0101, B'8 = 1101

Juntando todos os blocos B'i, para i = 1, 2, ...8, em uma só sequência obtemos:

S = 10111001110111100110001001011101

Usando   a  TABELA   5,   da   função   permutação,   na   sequência   acima   obtemos   a

sequência a seguir no qual chamaremos de P(S):

P(S) = 01010011111000111110111101001100

60

Fazendo a soma binária de E0 + P(S) temos:

D1 = E0 + P(S) = 11110011000000101000101001101001

Juntando, respectivamente, as sequências D0 e D1 temos:

N1 = 0101010101110111000101100100110011110011000000101000101001101001

Aplicando T:

T(N1) = N'1 = 1111001100000010100010100110100101010101011101110001011001001100

Para finalizar o deciframento vamos utilizar a  TABELA 3  e aplicar a função I  -1  na

sequência anterior chegando em:

M = I-1(N'1) = 0110010110110110000011110101100000100111011001000110110100110000

Logo, essa sequência, é a mensagem decifrada. Ou seja, separando essa sequência em

blocos de 6 bits e passando para a base decimal, obtemos os números:

25  27  24  15  22  10  29  36  27  19

que corresponde a mensagem original PROFMAT_RJ.

Nesse exemplo, para simplificar, usamos uma única rodada, mas isso é inseguro. Para

oferecer maior segurança e resistência à criptoanálise o ideal é que se realizem várias rodadas,

no caso 16 rodadas é o tamanho típico para a criptografia DES.

3.5 – Advanced Encryption Standard (Padrao de Encriptacao Avancada) ou AES

Segundo  Stallings (2015), o AES  foi publicado pelo National Institute of Standards

and Technology (Instituto Nacional de Padrões e Tecnologia), ou NIST, em 2001, que foi

61

escolhido através de um concurso que desenvolvesse um algoritmo de chave simétrica para

proteger   informações,  os   vencedores   foram   os   belgas  Vincent   Rijmen   e  Joan   Daemen.  A

definição  do AES  conforme   Stallingsn(2015):  "é uma  cifra  de bloco  e foi  adotado  como

método padrão pelo governo dos Estados Unidos pela eficiência demonstrada". Após 2006, o

AES tornou-se um dos algoritmos mais populares, usado para Criptografia de chave simétrica,

e se concretizou como o substituto do DES. Comparada as cifras de chave pública como a

RSA, a estrutura do AES e a maioria das cifras simétricas são bastante complexas e não

explicadas tão facilmente quanto outras cifras criptográficas. 

O tamanho de bloco fixo do AES e da chave são de 128 bits, além desse valor, a chave

também pode ser de 192 ou 256 bits, o AES não é complexo de executar e precisa de pouca

memória, possui software e hardware rápidos.

Capitulo 4

Criptografia ou encriptação Assimétrica

62

Por mais de dois mil anos, desde a época da cifra de César até a década de 70, a

comunicação cifrada exigia que as duas partes comunicantes compartilhassem um segredo em

comum, a chave simétrica usada para cifrar e decifrar. Uma dificuldade dessa abordagem é

que as duas partes têm que escolher, conjuntamente e de alguma maneira, qual é a chave.

Mas, para isso, é preciso comunicação segura. Uma alternativa seria um encontro entre as

partes para que escolhessem, pessoalmente, a chave. Porém, no atual mundo em rede, o mais

provável é que as partes comunicantes nunca possam se encontrar. No intuito de resolver este

problema, vários cientistas na década de 70 voltaram suas pesquisas para a busca de uma

solução que desse fim a este impasse. Porém, em 1976, Diffie e Hellman apresentaram um

algoritmo conhecido como Diffie Hellman Key Exchange, que tornou possível a comunicação

por criptografia sem a necessidade de compartilhamento antecipado de uma chave secreta

comum. Uma abordagem da comunicação segura radicalmente diferente e de uma elegância

que levou ao desenvolvimento dos atuais sistemas de criptografia de chaves públicas.

4.1 – Criptografia de chave pública

Stallings (2015) explica que a maior e talvez a única revolução verdadeira em toda a

história da criptografia foi o progresso da criptografia de chave pública. De seu surgimento

até   os   dias   atuais   é   possível   verificar   que   as   ferramentas   elementares   da   substituiçãp   e

permutação são os mais usados nos sistemas criptográficos. Depois de muitos anos surgiu a

máquina   de   encriptação/decriptação   de   rotor,   a   qual   foi   de   fundamental   importância   no

avanço da criptografia simétrica, este progresso reduziu de forma significativa o trabalho que

seriam   calculados   à   mão.  A  máquina   de   encriptação/decriptação   de   rotor   possibilitou   o

surgimento de cifras cada vez mais complexas. Com a utilização dos computadores, muitos

sistemas foram surgindo, e dentre estes tivemos como ponto forte o Data Encryption Standard

(DES), que foi desenvolvido pela Lucifer na IBM. Mesmo com todo o desenvolvimento tanto

das   máquinas   de   rotor   quanto   do   DES   ainda   não   foi   possível   deixar   de   usar   muitas   das

ferramentas básicas de substituição e permutação.

Houve uma mudança significativa no cenário da criptografia com o surgimento da

criptografia de chave pública. Temos de um lado, os algoritmos que são baseados em funções

63

matemáticas chamados de chave pública que usavam substituição e permutação. Outro ponto

significativo é que a criptografia de chave pública é assimétrica, que necessita do uso de duas

chaves separadas, ao contrário da criptografia simétrica, que utiliza apenas uma chave. A

importância   de   usar   duas   chaves   é   que   haverá   consequêcnias   significativas   nas   áreas   de

confidencialidade, distribuição de chave e autenticação.

Conforme explica  Stallings (2015), existem muitas produções erradas com relação à

criptografia de chave pública. A primeira delas é dizer que a criptografia de chave pública é

mais segura contra a criptoanálise do que a criptografia simétrica. O que acontece realmente,

é que o tamanho da chave e o trabalho computacional envolvido para quebrar uma cifra é o

que necessita qualquer esquema de criptografia para sua segurança. Não há nada em princípio

sobre a criptografia simétrica ou de chave pública que torne uma superior à outra, do ponto de

vista de resistência à criptoanálise.

O segundo erro é afirmar que a criptografia simétrica se tornou inadequada devido ao

uso da criptografia de chave pública. De outro modo, por conta do overhead computacional

dos   esquemas   de   criptografia   de   chave   pública   atuais,   parece   não   haver   probabilidade

previsível de que a criptografia simétrica será abandonada. 

E finalmente, ainda existe um desconforto na distribuição de chave quando se usa a

criptografia de chave pública, pois afirmam ser trivial, em comparação com o tratamento um

tanto desajeitado que é envolvido com os centros de distribuição de chave para a criptografia

simétrica.   O   que   realmente   acontece,   é   que   existe   a   necessidade   de   alguma   forma   de

protocolo, geralmente abrangendo um agente central, e os procedimentos envolvidos não são

mais simples nem mais eficientes do que aqueles exigidos para a criptografia simétrica.

Para Stallings (2015), a evolução do conceito de criptografia de chave pública se deve

ao   fato   da   tentativa   de   atacar   dois   dos   problemas   mais   difíceis   associados   à   encriptação

simétrica. O primeiro é o da distribuição de chaves.

"A encriptação simétrica requer (1) que dois comunicantes já compartilhem uma chave, que

de alguma forma foi distribuída a eles; ou (2) o uso de um centro de distribuição de chaves.

Whitfield   Diffie,   um   dos   descobridores   da   encriptação   de   chave   pública   (com   Martin

Hellman, ambos da Stanford University, na época), raciocinou que esse segundo requisito

anulava a essência da criptografia: a capacidade de manter sigilo total sobre a sua própria

comunicação. Conforme foi dito por Diffie: “afinal, qual seria a vantagem de desenvolver

criptossistemas impenetráveis, se seus usuários fossem forçados a compartilhar suas chaves

64

com um CDC que poderia ser comprometido por roubo ou suborno?”"(Stallings, 2015)

O   segundo   problema   sobre   o   qual   Diffie   ponderou,   e   que   estava   aparentemente   não

relacionado com o primeiro, foi o de assinaturas digitais. Se o uso da criptografia tivesse que

se tornar comum, não apenas nas situações militares, mas para fins comerciais e particulares,

então   as   mensagens   e   documentos   eletrônicos   precisariam   do   equivalente   das   assinaturas

usadas nos documentos em papel. Ou seja, poderia ser criado um método para estipular, para a

satisfação de todas as partes, que uma mensagem digital foi enviada por determinada pessoa?

Diffie e Hellman fizeram uma descoberta incrível em 1976, surgindo com um método que

resolvia os dois problemas e que era radicalmente diferente de todas as técnicas anteriores de

criptografia, quatro milênios atrás.8

4.2 – Modelo de Cifra Assimétrica

Stallings (2015) explica que os algoritmos assimétricos precisam de duas chaves: uma

para codificação e outra diferente, mas que seja usada para a decodificação. Segue algumas

das principais características:

➢ É   praticamente   difícil   determinar   computacionalmente   a   chave   de   decodificação

conhecemdo apenas o algoritmo de criptografia e da chave de codificação.

➢ Qualquer chave pode ser escolhida para ser usada para codificação com a outra para

decodificação.

Segue abaixo um esquema de encriptação de chave pública com cinco itens, conforme

mostra Stallings (2015):

• Texto   claro:  mensagem   ou  dados   originais   onde   é   possível   a   compreensão   e  que

servem como entrada do algoritmo de encriptação.

• Algoritmo de encriptação: é o que realiza as diversas substituições e transformações

no texto claro.

8  "Diffi e e Hellman apresentaram  publicamente  os conceitos da criptografia de chave pública em
1976. Hellman dá crédito a Merkle com a descoberta independente e simultânea do conceito, embora
Merkle   não   o   tenha   publicado   antes   de   1978.   De   fato,   o   primeiro   documento   não   confidencial
descrevendo a distribuição de chave pública e a criptografia foi uma proposta de projeto de 1974 por
Merkle (<http://
merkle.com/1974>). Porém, esse não foi o verdadeiro início. O almirante Bobby Inman, como diretor
da   National   Security Agency  (NSA),   reivindicou   que   a   criptografia   de   chave   pública   tinha   sido
descoberta na  NSA em meados da  década  de  1960.  A primeira  apresentação  documentada  desses
conceitos veio em 1970, do Communications-Electronics Security Group, o equivalente britânico da
NSA, em um relatório confidencial de James Ellis. Ellis referia-se à técnica como   criptografia não
secreta." (Stallings, 2015)

65

• Chaves pública e privada: São as chaves usadas no algoritmo, sendo uma usada para

a codificação, e a outra para codificação. As transformações exatas realizadas pelo

algoritmo dependem da chave pública ou privada que é fornecida como entrada.

• Texto cifrado:  é a mensagem embaralhada produzida como saída. Ela depende do

texto claro e da chave. Para determinada mensagem, duas chaves diferentes produzirão

dois textos cifrados diferentes.

• Algoritmo de decriptação:  é o algoritmo que recebe o texto inelegível e a chave

produz o texto original.

Figura 21: Criptografia de chave pública
(Fonte:  Stallings, 2015, p. 202)

66

Segue as etapas essenciais segundo Stallings (2015):

1. Cada usuário gera um par de chaves a ser usado para a encriptação e a decriptação das

mensagens.

2. Cada usuário coloca uma das duas chaves em um registrador público ou em outro

arquivo acessível. Essa é a chave pública. A chave acompanhante permanece privada.

Como a Figura 21.1a sugere, cada usuário mantém uma coleção de chaves públicas

obtidas de outros.

3. Se Bob deseja enviar uma mensagem confidencial para Alice, ele a encripta usando a

chave pública de Alice.

4. Quando Alice recebe a mensagem, ela a decripta usando sua chave privada. Nenhum

outro destinatário pode decriptar a mensagem, pois somente Alice conhece a chave

privada de Alice.

Observe que as chaves públicas ficam disponíveis para todos os participantes, cada

participante   produz   localmente   as   chaves   privadas   e,   portanto,   nunca   necessitam   serem

distribuídas. A comunicação recebida estará protegida sempre que a chave privada de um

usuário permanecer protegida e secreta. Uma questão importante e eficaz é que em qualquer

momento   um   sistema   pode   alterar   sua   chave   privada   e   publicar   uma   chave   pública

correspondente para substituir sua antiga.

4.3 – Criptoanálise de chave pública

Stallings (2015) explica que tanto um sistema de codificação simétrico quanto o de

chave pública estam suscetíveis a um ataque de força bruta. A contramedida é a mesma: use

chaves grandes. Ainda assim, existe um dilema a ser considerado. Uma função matemática

reversível para uso é do que depende os sistemas de chave pública. A dificuldade de executar

os cálculos dessas funções pode não crescer de froma constante com o número de bits na

chave, mas sim mais rapidamente do que isso. Concluir-se com isto que o ataque por força

bruta   se   torna   impraticável   se   o   tamanho   da   chave   for   consideravelmente   grande,   porém

pequeno pequeno para que a encriptação e a decriptação sejam viáveis. Mas o que acontece na

prática? Acontece que o usuário ganha de um lado com um impraticável ataque por força

bruta   devido   ao   grande   tamanho   da   chave,   mas   por   outro   lado   perde   em   velocidade   de

encriptação/decriptação, pois ficou muito lenta para uso geral. De outro modo, a encriptação

67

de chave pública atualmente é confinada a aplicações de gerenciamento de chave e assinatura.

Um outro modo de atacar um sistema de chave pública é achar alguma  forma de

calcular a chave privada dada a chave pública. Até agora, a matemática não mostrou que essa

forma de ataque é inviável para determinado algoritmo de chave pública. Com isto, o RSA e

qualquer outro algoritmo utilizado são suspeitos. Um problema que parece insolúvel de um

ponto de vista pode ter uma solução se for visto de uma maneira inteiramente diferente, isto é

o que mostra a  história da criptoanálise.

Por fim, há outra forma de ataque que é singular aos sistemas de chave pública. É um

ataque de mensagem provável. Suponha, por exemplo, que uma mensagem tivesse que ser

enviada   contendo   exclusivamente   uma   chave   DES   de   56   bits.   Um   invasor   conseguiria

encriptar todas as chaves DES possíveis de 56 bits usando a chave pública e descobrir a chave

encriptada testando com o texto cifrado transmitido.

Portanto, para o esquema de chave pública o tamanho da chave não importa, pois o ataque é

reduzido   a   um   por   força   bruta   em   uma   chave   de   56   bits.   Se   adicionarmos   alguns   bits

aleatórios a mensagens simples podemos impedri esse tipo de ataque.

4.4 – Algoritmo RSA

Stallings (2015) explica que a introdução de uma npva técnica para criptografia foi

feito através de um artigo pioneiro de Diffie e Hellman e, de fato, causou alvoroço entre os

criptologistas,   pois   desafiou   os   mesmos   a   encontrarem   um   algoritmo   criptográfico   que

atendesse os requisitos para os sistemas de chave pública. Muitos algoritmos foram propostos.

Alguns deles, embora inicialmente promissores, provaram ser falhos.

Figura 22: Ron Rivest, Adi Shamir e Leonard Adleman
(Fonte: brilliant.org)

68

Só em 1977 que surgiu uma das primeiras respostas ao desafio, desenvolvida por Ron

Rivest, Adi Shamir e Len Adleman, no MIT, e publicada em 1978. O esquema Rivest-Shamir-

Adleman (RSA), desde essa época, tem reinado soberano como a técnica de uso geral mais

aceita e implementada para a encriptação de chave pública.

Uma cifra de bloco em que o texto claro e o cifrado são inteiros entre 0 e n − 1, para

algum n é a definição do esquema RSA. Um tamanho típico para n é 1024 bits, ou 309 dígitos

decimais. Ou seja, n é menor que 21024. 

4.4.1 – Descrição matemática do algoritmo

Coutinho (2000) explica que para criptografar uma mensagem M, usando uma chave

pública (e, n), onde e e n são inteiros positivos, façamos o seguinte:

• Represente a mensagem como um inteiro entre 0 e n – 1. (Se a mensagem for longa,

quebre-a em blocos de modo que isso possa ser feito).

• Criptografe a mensagem elevando cada bloco M à “e-ésima” potência módulo n. 

Então, o resultado criptografado C é o resto da divisão de Mepor n:

C ≡ Me mod n.

•

Para decifrar a mensagem criptografada, eleve-a a uma outra potência  d  e calcule o

resto da divisão de Cd por n. Assim,

M ≡ Cd mod n = (Me)d mod n = Med mod n.

Tanto o emissor quanto o receptor precisam conhecer o valor de n. O emissor conhece

o   valor   de  e,   e   somente   o   receptor   sabe   do   valor   de  d.  Assim,   esse   é   um   algoritmo   de

encriptação de chave pública com um chave pública PU = (e, n) e uma chave privada PR = (d,

n). Para que esse algoritmo seja satisfatório à encriptação de chave pública, os seguintes

requisitos precisam ser atendidos:

1. É possível encontrar valores de e, d e n, tais que  Med mod n = M para todo M < n.

2. É relativamente fácil calcular  Me mod n  e Cd mod n para todos os valores de  M < n.

3. Conhecendo e e n, é inviável determinar d.

Precisamos encontrar um relacionamento na forma

Med mod n = M

O relacionamento mostrado se mantém se e e d forem inversos multiplicativos módulo

φ(n), onde φ(n) é a função totiente de Euler. O capítulo 2 mostrou que, para p, q primos, φ(pq)

69

= (p – 1)(q – 1). O relacionamento entre e e d pode ser expresso como

Isso é equivalente a dizer

ed mod φ(n) = 1

ed = 1 mod φ(n)

d = e -1 mod φ(n)

Ou seja, e e d são inversos multiplicativos mod φ(n). Observe que, de acordo com as

regras da aritmética modular, isso é verdadeiro somente se d (e, portanto, e) for relativamente

primo de φ(n). de modo equivalente, mdc(φ(n), d) = 1.

Agora   estamos   prontos   para   formular   o   esquema   RSA.   Os   ingredientes   são   os

seguintes:

p, q, dois números primos

(privados, escolhidos)

n = pq

(público, calculado)

e, com mdc(φ(n), e) = 1, 1 < e < φ(n)

(público, escolhido)

d = e-1 (mod φ(n))

(privado, calculado)

A chave privada consiste em (d,  n), e a chave pública, em (e,  n). Suponha que o

usuário A tenha publicado sua chave pública e que o usuário B queira enviar a mensagem M

para A. Então, B calcula C = M e mod n e transnite C. Ao receber esse texto cifrado, o usuário

A decripta calculando M = Cd mod n.

4.4.2 – Exemplo do RSA

Para usarmos o método RSA, devemos converter uma mensagem em uma sequência de

números. Chamaremos essa etapa de pré-codificação.

Para   efeito   de   exemplificação,   tomemos   a   seguinte   tabela   de   conversão   na   pré-

codificação:

a

10

b

11

c

d

e

f

g

h

i

j

k

l

m n

o

p

q

r

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

s

t

u

v w x

y

z

_

0

1

2

3

4

5

6

7

8

9

28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46

O espaço entre palavras será substituído pelo nº. 36. Por exemplo, a frase “PROFMAT_RJ”, é

70

convertida no número

25272415221029362719

A vantagem de se utilizar 2 dígitos para representar uma letra reside no fato de que tal

procedimento evita a ocorrência de ambiguidades. Por exemplo, se a fosse convertido em 1 e

b em 2; teríamos que ab seria 12; mas l também seria 12: Logo, não poderíamos concluir se

12 seria ab ou l.

Precisamos   determinar   2   primos   distintos,   que   denotaremos   por  p  e  q,   que   são

denominados parâmetros RSA. Seja

que é chamado de módulo RSA.

n = pq,

A última etapa da pré-codificação consiste em separar o número acima em blocos

cujos valores sejam menores que n.

A mensagem cuja conversão foi feita acima pode ser separada nos seguintes blocos:

25  27  24  15  22  10  29  36  27  19

A maneira de escolher os blocos não é única e não precisa ser homogênea (todos os

blocos com o mesmo número de dígitos), mas devemos tomar alguns cuidados como, por

exemplo, não começar um bloco com zero, pois isto traria problemas na hora de montar a

sequência recebida (o zero no início do bloco não pode aparecer!).

Passemos ao processo de codificação. Temos n = pq com p e q primos.

Tomemos

Seja e < φ(n) inteiro positivo inversível módulo φ(n), ou seja,

φ(n) = (p – 1) (q – 1).

Esse número e é chamado de expoente de enciframento.

mdc (e, φ(n)) = 1.

O par (n, e) é denominado chave pública de codificação do sistema RSA.

Agora, codifiquemos cada bloco obtido na pré-codificação. Após a codificação, os

blocos não poderão ser reunidos de modo que não possamos distinguí-los, pois isto tornaria

impossível a decodificação da mensagem.

A codificação de um bloco  b  será denotada por  C(b). Temos que  C(b) é o resto da

divisão de be por n, isto é,

C(b) ≡ be  (mod n).

Por exemplo, se p = 29 e q = 67, então n = 1943. Logo, φ(n) = 1848, pois n = 1943 = 29 x 67. 

Tomemos  e  =   701   (observe   que   mdc   (701,   1848)   =   1).  Assim,   o   último   bloco,  19,   da

mensagem anterior é codificado como o resto da divisão de 19701 por 1943. Calculando:

71

195 ≡ 717 (mod1953)

1910 ≡ 1137 (mod 1943)

1920 ≡ 674 (mod 1943)

1940 ≡ 1557 (mod 1943)

1980 ≡ 1328 (mod 1943)

19100 ≡ 1292 (mod 1943)

19300 ≡ 1834 (mod 1943)

19600 ≡ 223 (mod 1943)

19700 ≡ 552 (mod 1943)

19701 ≡ 773 (mod 1943)

Fazendo o mesmo para os outro blocos,

Bloco 25: 

25701 ≡ 895 (mod 1943)

Bloco 27:

27701 ≡ 259 (mod 1943)

Bloco 24:

24701 ≡ 198 (mod 1943)

Bloco 15:

15701 ≡ 595 (mod 1943)

Bloco 22:

22701 ≡ 1849 (mod 1943)

Bloco 10:

10701 ≡ 155 (mod 1943)

Bloco 29:

29701 ≡ 841 (mod 1943)

Bloco 36:

36701 ≡ 384 (mod 1943)

Codificando toda a mensagem, obtemos a seguinte sequência de blocos:

895 – 259 – 198 – 595 – 1849 – 155 – 841 – 384 – 259 – 773

Para decodificar uma mensagem codificada, precisamos de n e do inverso de e módulo

φ(n), que chamaremos de d, ou seja

ed ≡ 1 (mod φ(n)).

O par (n, d) é denominado chave privada de decodificação do sistema RSA.

Seja  a  =  C(b) um bloco da mensagem codificada, então  D(a) será o resultado da

decodificação. Temos que D(a) é o resto da divisão de ad por n, isto é,

D(a) ≡ ad (mod n).

Para   calcular  d,   sendo   conhecidos  e  e  φ(n),   basta   aplicar   o   algoritmo   euclidiano

estendido,   pois   1   =  ed  –  k  φ(n).   Esperamos   que,   decodificando   os   blocos   da   mensagem

codificada,   possamos   encontrar   a   mensagem   original,   ou   seja,

 D(C(b))   =  b.   Para

decodificarmos, não é necessário conhecermos p e q, basta conhecer n e d.

No exemplo que estamos acompanhando, temos que n = 1943 e e = 701.

Usando o algoritmo euclediano estendido para descobrir d, temos:

72

Assim, temos:

1848 = 2.701 + 446

701 = 1.446 + 255

446 = 1.255 + 191

255 = 1.191 + 64

191 = 3.64 – 1 

1 = 3.64 – 191

1 = 3.(255 – 1.191) – 1.191

1 = 3.255 – 4.191

1 = 3.255 – 4.(446 – 1.255)

1 = 7.255 – 4.446

1 = 7.(701 – 1.446) – 4.446

1 = 7.701 – 11.446

1 = 7.701 – 11.(1848 – 2.701)

1 = 29.701 – 11.1848

Logo, concluímos que d = 29.

Assim, para decodificar o bloco 773 recebido, devemos calcular o resto da divisão de

77329 por 1943, ou seja, 19:

19 ≡ 77329 (mod 1943)

Logo, a sequência decodificada será

que corresponde, via tabela de conversão, à expressão “PROFMAT_RJ”

25  27  24  15  22  10  29  36  27  19

Considerações finais

73

Embora   este   trabalho   não   tenha   foco   na   aplicabilidade   da   criptografia   no   ensino

básico,   é   possível   verificar   que   muitas   das   cifras   utilizadas   ao   longo   do   texto   pode   ser

desenvolvida   e   ter   como   ponto   de   referência   do   processo   de   ensino   e   aprendizagem   a

abordagem   de   assuntos   de   interesse   do   estudante,   tornando   a   Matemática   interessante   e

motivadora. A criptografia pode ser utilizada como um gerador de situações desafiadoras que

permitem   o   aprofundamento   dos   assuntos   desenvolvidos   no   ensino   básico,   possibilitando

dessa forma ao estudante perceber a utilização do conhecimento em situações práticas.

Um exemplo simples e sem muito custo de utilização de uma cifra em sala de aula,

seria a cifra de Cesár, nessa cifra pode ser utilizado o conceito de permutação e combinação,

assunto este que pode ser abordado de forma lúdica e que os estudantes aprendam de forma

significativa.

Os materiais necessários são apenas papel e lápis e/ou caneta. Passos a serem desenvolvidos

na aplicação da atividade:

1º   passo:  O   professor  levará   várias   frases   codificadas,   todas   preparadas   antes   da  aula,   o

interessante é usar várias variações da cifra, ou seja, andar duas, três, quatro, cinco casas e não

apenas três como na cifra original.

2º passo:  O professor dissertará um pouco sobre a cifra e sua utilização explicando como

descobrir as frases usando as várias variações no alfabeto.

3º passo: Com as frases já descorbertas, o professor questionará os estudantes numa discussão

onde   seja   levado   em   consideração   pontos   importantes   da   cifra,   tais   como:   senha   única,

permutação, combinação e dificuldade na decifragem.

Outro exemplo seria a construção e utilização de um bastão de Licurgo, essa cifra é

uma das quais pode ser usada em sala de aula de forma significativa. Materiais necessários:

- Garrafas pets de vários tamanho;

- Cola;

- Papel; e

- Lápis e/ou caneta.

Passos a serem seguindos:

1º passo: A preparação de todo material a ser utilizado será feito antes de sua aplicabilidade

em sala de aula, devido a isto, o professor levará as garrafas com diâmetros diferentes e as

74

tiras de papel já com as frases prontas.

2º passo: O professor comentará um pouco dessa cifra com os estudantes e sua importância

na história.

3º passo: Logo em seguida, distribuirá as garrafas com diâmetros diferentes e as várias tiras

de papel e verificará se os estudantes serão capazaes de descobrirem as frases.

4º passo:  Possivelmente os estudantes conseguiram desvendar as frases, pois no 2º passo o

professor já explicou como a cifra era utilizada. 

5º passo: Questionamentos e discussões sobre o tema estudado, principlamente em relação a

noção de senha única, ou seja, o professor entrará com o conceito de criptografia simétrica

(neste caso será a senha usada para cifrar que será a mesma para decifrar).

Observe que o importante nessa atividade não é a descorberta das frases, mas sim o conceito

de senha única utilizada para descobrir as frases, neste caso a senha utilizada foi o diâmetro da

garrafa, pois as frases só seram descorbertas nas garrafas corretas.

Referências Bibliográficas:

75

AVALIAÇÃO à distância: Criptografia. Centro de Educação à Distância do Estado do Rio de

Janeiro. Rio de Janeiro: Fundação CECIERJ, 2017.

Coutinho, S. C. Números inteiros e Criptografia RSA, 2ª ed., vol. 2 de Série de Computação e

Matemática. Instituto de Matemática Pura e Aplicada (IMPA), Rio de Janeiro, 2000.

C. L. Barczark. A Indecifrável Enigma. São Paulo. Clube de Autores. 2014.

Kahn,   David.  The   Codebreakers:   The   Comprehensive   History   of   Secret.   E.U.A..   Editora

Scribner Book Company, 1996.

Schneeberger, Carlos Alberto.  História Geral: teoria e prática. São Paulo. Editora Rideel,

2006.

Singh, Simon. O livro dos códigos. Rio de Janeiro. Editora Record, 2007. 

Stallings,   William.  Criptografia   e   segurança   de   redes:   princípios   e   práticas/William

Stallings; tradução Daniel Vieira; revisão técnica Paulo Sérgio Licciardi Messeder Barreto,

Rafael Misoczki. - 6. ed. - São Paulo: Pearson Education do Brasil, 2015.

Wazlawick, Raul Sidnei. História da Computação. Rio de Janeiro. Editora Elsevier, 2016.

