UNIVERSIDADE FEDERAL DO CARIRI
CENTRO DE CIˆENCIAS E TECNOLOGIA
PROGRAMA DE P ´OS-GRADUAC¸ ˜AO EM MATEM ´ATICA EM REDE
NACIONAL

C ´ASSIO GOMES DE LIMA

DETERMINANDO A DATA DAS FESTIVIDADES M ´OVEIS
ATRAV´ES DA LINGUAGEM C++

JUAZEIRO DO NORTE
2017

C ´ASSIO GOMES DE LIMA

DETERMINANDO A DATA DAS FESTIVIDADES M ´OVEIS ATRAV´ES DA
LINGUAGEM C++

(Mestrado)

apresentada

Disserta¸c˜ao
ao
Programa de P´os-gradua¸c˜ao em Matem´atica
em Rede Nacional (PROFMAT), do Depar-
tamento de Matem´atica da Universidade
Federal do Cariri, como parte dos requisitos
necess´arios para a obten¸c˜ao do t´ıtulo de
´Area de concen-
Mestre em Matem´atica.
tra¸c˜ao: Ensino de Matem´atica.

Orientador: Prof. Dr. Paulo C´esar Caval-
cante de Oliveira

JUAZEIRO DO NORTE
2017

                             Dados Internacionais de Catalogação na Publicação Universidade Federal do Cariri Sistema de Bibliotecas  L732d Lima, Cássio Gomes de. Determinando a data das festividades móveis através da linguagem C++/ Cássio Gomes de Lima. – 2017. 54 f.: il.; color.; enc. ; 30 cm.  Dissertação (Mestrado) – Universidade Federal do Cariri, Centro de Ciências e Tecnologia –Programa de Pós-graduação em Matemática em Rede Nacional, Juazeiro do Norte, 2017. Área de Concentração: Ensino de Matemática.  Orientação: Prof. Dr. Paulo César Cavalcante de Oliveira.   1. Aritmética modular.  2. Fórmula de Gauss. 3. Linguagem C++. I. Oliveira, Paulo César Cavalcante de. II. Título.                         CDD 513.1  1

`A Francisca, Felipe e C´ıcero (in memoriam).

AGRADECIMENTOS

A Deus, por dar-me sa´ude, vontade e mais essa oportunidade, no sentido de

tornar-me sempre melhor, principalmente como pessoa.

`A Francisca Gomes da Silva Lima, minha amorosa m˜ae, sem a qual, diﬁcilmente
eu teria chegado at´e aqui, e tamanho esfor¸co fez para, praticamente sozinha, proporcionar
a mim e a meu irm˜ao o p˜ao, a educa¸c˜ao e o modelo de f´e que temos.

A Felipe Gomes de Lima, meu eterno e valoroso irm˜ao, amigo, leal e compa-

nheiro, apoio desde sempre e retid˜ao como nunca.

`A Mar´ılia Muryel Estevam Alves, minha amada, que tanto me ajudou e me

deu garra, e pelo carinho e dedica¸c˜ao nos momentos alegres e tristes.

Ao meu orientador Paulo C´esar Cavalcante de Oliveira, pelo apoio, pelas in-
dica¸c˜oes e que, desde o tempo da gradua¸c˜ao, mesmo n˜ao tendo sido meu professor, ´e
exemplo de competˆencia e eﬁciˆencia.

Aos professores Fl´avio Fran¸ca Cruz e Job Saraiva Furtado Neto, pelo valoroso

tempo investido e pelas relevantes sugest˜oes no trabalho.

`A professora Maria Silvana Alcˆantara Costa, coordenadora do programa nesta
institui¸c˜ao, pelo apoio desde antes do curso at´e, tenho certeza, quando sentir que n˜ao
h´a mais necessidade, e pelo compromisso e responsabilidade com esta turma e com a
institui¸c˜ao.

Aos professores Pl´acido Francisco de Assis Andrade, Clarisse Dias de Albu-
querque, Juscelino Pereira Silva e Francisco Calvi da Cruz J´unior, pelas boas orienta¸c˜oes
em sala e fora dela.

Aos professores M´ario de Assis, Zelalber Gondim, Carlos Alberto (Carl˜ao),
Luiz Antˆonio (Luizin), Luciana Maria, B´arbara Paula, Alexsandro Coelho, Pedro Ferreira,
Jos´e Tiago, K´atia Pires, Val´eria Gerˆonimo, Ricardo Rodrigues (al´em do j´a citado Fl´avio
Fran¸ca) e outros (n˜ao citados e n˜ao menos importantes), da gradua¸c˜ao, e tamb´em a
Guttenberg Sergist´otanes, Marcos Aur´elio (o de Matem´atica e o de Inglˆes), Gilberto
Alves, Edilberto Gon¸calves, Neuma Xenofonte, Ernesto Luiz (in memoriam), Jorgeana
Jorge, Luis Edvan, Marcos Chaves, Ana Paula (a de Qu´ımica e a de Portuguˆes) e Cl´audio
Dantas, pela excelente forma¸c˜ao acadˆemica, exemplo e inspira¸c˜ao, formadores da s´olida
base sobre a qual me construi neste meio.

Aos meus companheiros de curso, pela presen¸ca e apoio, por todos os momentos
de riso e coopera¸c˜ao, pelas novas amizades, e especialmente a Helano, Rommel e Irl˜a, pela
for¸ca, palpites, alegrias e amizade. Tamb´em s˜ao meus professores.

A todos, meus eternos professores.
Ao PROFMAT, pelo aperfei¸coamento pessoal, intelectual e proﬁssional, eterno,

e `a CAPES, pelo apoio ﬁnanceiro com a bolsa de aux´ılio.

1

“A nobreza e a excelˆencia de uma ciˆencia
devem ser julgadas pela certeza das demons-
tra¸c˜oes que ela usa. Sem d´uvida as disci-
plinas matem´aticas est˜ao em primeiro lugar
entre todas as outras.”

Crist´ov˜ao Cl´avio (1538-1612)

RESUMO

O calend´ario como o conhecemos hoje (gregoriano) sofreu algumas altera¸c˜oes importan-
tes, e muita resistˆencia de pa´ıses, reinos e at´e mesmo de bispos de regi˜oes mais afastadas,
at´e ser aceito como uno, reconhecendo os erros do tomado anteriormente (juliano). At´e
a reforma promulgada pelo Papa Greg´orio XIII, apenas seguia-se a regra de acrescentar
um dia a fevereiro a cada 4 anos, e isso gerou uma defasagem, por exemplo, na data de
in´ıcio das esta¸c˜oes, que n˜ao mais coincidiam com solst´ıcios e equin´ocios astronˆomicos,
fazendo com que a P´ascoa fosse festejada fora do per´ıodo determinado no Conc´ılio de
Nic´eia, e conseguinte, outras festividades m´oveis. Ap´os 1582, o proclamado Ano da Re-
forma, houve desaven¸ca e desestrutura¸c˜ao na Igreja Cat´olica, e tamb´em desta com na¸c˜oes
pelo mundo. Tanto ´e que Gr´ecia e Turquia, por exemplo, mantiveram-se com o antigo
calend´ario at´e a ´ultima d´ecada de 20. A inﬂuˆencia da igreja garantiria, a n´ıvel mundial,
a ades˜ao ao novo calend´ario, e, al´em disso, a pr´opria evolu¸c˜ao da sociedade, cada vez
mais interligada e interdependente, levaria `a ado¸c˜ao do mesmo, cedo ou tarde. O c´alculo
dos anos bissextos ´e bem claro e simples, at´e na Bula Papal do pr´oprio Greg´orio, e assim
como ele, a regra da determina¸c˜ao do domingo de P´ascoa s˜ao facilmente encontrados, e
este ´ultimo, com o surgimento e desenvolvimento da inform´atica, acelerou ainda mais tal
cˆomputo. Este trabalho visa, sob o olhar da problem´atica das datas m´oveis e a hist´oria do
calend´ario gregoriano, apresentar a F´ormula de Gauss que determina a data da P´ascoa de
qualquer ano ap´os 1600, e “traduzi-la” numa linguagem de programa¸c˜ao C++. Para isso,
conter´a os t´opicos necess´arios da aritm´etica para a constru¸c˜ao do mesmo, em especial a
aritm´etica modular, al´em do instrumental b´asico de programa¸c˜ao para a confecc¸c˜ao deste
programa. Logo, um aluno de ensino m´edio com conhecimento b´asico ou em um curso
t´ecnico/proﬁssionalizante de inform´atica, com a leitura deste texto, ter´a os fundamen-
tos para a implementa¸c˜ao da regra em outras linguagens (at´e em planilhas eletrˆonicas),
baseando-se na matem´atica por tr´as desse processo.

Palavras-chave: Aritm´etica Modular. F´ormula de Gauss. Linguagem C++.

RESUM´E

Le calendrier comme nous le connaissons aujourd’hui (gr´egorien) a subi des changements
importants et beaucoup de r´esistance de la part des pays, royaumes et mˆeme des ´evˆeques
des r´egions plus ´eloign´ees, pour ˆetre accept´e comme l’une, en reconnaissant les erreurs
du prise pr´ec´edemment (julien). Jusqu’`a la r´eforme promulgu´ee par Pape Gr´egoire XIII,
seulement il a ´et´e suivi la r`egle d’ajouter un jour `a F´evrier chaque 4 ans, et cela a cr´e´e un
lag, par exemple, au d´ebut des saisons, qui ne co¨ıncident plus avec solstices et ´equinoxe
astronomique, ce qui provoque la fˆete de Pˆaques c´el´ebr´ee en dehors de la p´eriode sp´eciﬁ´ee
au Conseil de Nice, et donc d’autres festivals mobiles. Apr`es 1582, a proclam´e l’ann´ee de
la R´eforme, il y avait d´esaccord et la rupture dans l’Eglise catholique, et cela aussi avec
certains pays du monde. Si bien que Gr`ece et Turquie, par exemple, est rest´e avec l’ancien
calendrier jusqu’`a la derni`ere d´ecennie `a 20. L’inﬂuence de l’´eglise garantirait, partout
dans le monde, le respect du nouveau calendrier, et en plus, l’´evolution de la soci´et´e, de
plus en plus interconnect´e et interd´ependant, conduirait `a l’adoption du mˆeme, tˆot ou
tard. Le calcul des ann´ees bissextiles est clair et simple, mˆeme dans la bulle papale de
lui-mˆeme Gr´egoire, et comme il, la r`egle de d´etermination du dimanche de Pˆaques sont
faciles `a trouver, et ce dernier, avec l’´emergence et le d´eveloppement des technologies de
l’information, aussi acc´el´er´ee tel calcul plus. Le pr´esent document vise, sous le regard
du probl`eme des dates mobiles, et l’histoire du calendrier gr´egorien, pr´esente la formule
Gauss qui d´etermine la date de Pˆaques dans une ann´ee apr`es 1600, et la-traduisez pour
une langage de programmation C ++. Pour cela, contiendra les sujets arithm´etiques
n´ecessaires `a la construction du mˆeme, en particulier l’arithm´etique modulaire, en plus
de l’instrumental de programmation de base pour la fabrication de ce programme. Ainsi,
un ´el`eve du secondaire ayant une connaissance de base ou un cours de technicien en
informatique, `a la lecture de ce texte, aura le fondement de la mise en œuvre de la r`egle
dans d’autres langues (mˆeme dans des feuilles de calcul), sur la base des math´ematiques
derri`ere ce processus.

Mots-cl´es: Arithm´etique Modulaire. Formule Gauss. Langage C++.

Lista de ilustra¸c˜oes

Figura 1 – Execut´avel do programa media . . . . . . . . . . . . . . . . . . . . . . 31
. . . . . . . . . . . . . . . . . . . 33
Figura 2 – Execut´avel do programa Fibonacci
Figura 3 – Execut´avel do programa divisao lenta . . . . . . . . . . . . . . . . . . 34
Figura 4 – Execut´avel do programa multiplos . . . . . . . . . . . . . . . . . . . . 36
Figura 5 – Gr´aﬁco das fun¸c˜oes f (x) = 2, 6x + 0, 8 e g(x) = 2, 6x − 0, 2 . . . . . . . 41
Figura 6 – Execut´avel do programa Pascoa, com a data para 2017 . . . . . . . . 48
Figura 7 – Execut´avel do programa Pascoa, com a data para 2049 . . . . . . . . 49
Figura 8 – Execut´avel do programa Pascoa, com a data para 2076 . . . . . . . . 49
Figura 9 – Execut´avel do programa zeller . . . . . . . . . . . . . . . . . . . . . . 54

Lista de tabelas

Tabela 1 – Mudan¸cas no calend´ario, segundo J´ulio C´esar e Augusto C´esar.
Tabela 2 – Constantes da congruˆencia de Zeller, para cada mˆes.
Tabela 3 – Principais festividades cat´olicas relativas `a P´ascoa.

. . . . 13
. . . . . . . . . . 41
. . . . . . . . . . . 47

Sum´ario

1

2
2.1
2.2
2.3
2.4

3
3.1
3.2
3.3

4
4.1
4.2
4.3

5

INTRODUC¸ ˜AO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

NOC¸ ˜OES B ´ASICAS DE TEORIA DOS N ´UMEROS . . . . . . . . . . . . . 15
Divisibilidade em Z . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
Divis˜ao Euclidiana e M´aximo Divisor Comum . . . . . . . . . . . . . . . . . 18
Congruˆencias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
Congruˆencias Lineares e o Teorema Chinˆes dos Restos . . . . . . . . . . . . 24

LINGUAGEM C++: NOC¸ ˜OES B ´ASICAS . . . . . . . . . . . . . . . . . . 28
Iniciando um primeiro programa . . . . . . . . . . . . . . . . . . . . . . . . 28
Repetindo passos: la¸cos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Tomando decis˜oes: if e else . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

A P ´ASCOA EM LINGUAGEM C++ . . . . . . . . . . . . . . . . . . . . . 39
Congruˆencia de Zeller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
A P´ascoa e a F´ormula de Gauss
. . . . . . . . . . . . . . . . . . . . . . . . 43
A F´ormula de Gauss em C++ . . . . . . . . . . . . . . . . . . . . . . . . . 47

CONSIDERAC¸ ˜OES FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . 51

APˆENDICE – C´alculo do dia da semana de uma data qualquer com C++ . . . . . 52

REFERˆENCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

1 Introdu¸c˜ao

Pessach(passagem, em hebraico): festa da tradi¸c˜ao judaica, em comemora¸c˜ao
`a liberta¸c˜ao do povo hebreu da escravid˜ao no Egito, que teria acontecido em 14 Nisan de
1440 a.C. O calend´ario judaico come¸ca na primavera, onde Nisan ´e o primeiro mˆes, que,
como os outros, sempre come¸ca na lua nova, portanto o d´ecimo quarto dia sempre ´e lua
cheia. Conta-se no cristianismo que a morte de Jesus aconteceu na semana do Pessach.
Da´ı a associa¸c˜ao deste com a P´ascoa, desde o in´ıcio do cristianismo, e de onde deriva o
pr´oprio nome [6].

A quest˜ao ´e que a P´ascoa (celebra¸c˜ao da Ressurrei¸c˜ao de Jesus) era comemo-
rada nas igrejas da ´Asia Menor, como na grande ´Efeso (hoje Igreja Cat´olica Ortodoxa),
juntamente com os judeus, exatamente no 14 Nisan, independente do dia da semana,
ao passo que as igrejas de Roma e Alexandria (poderosas na ´epoca1), entre outras igre-
jas ocidentais e orientais, o faziam no primeiro domingo ap´os esta data, pela tradicional
importˆancia deste dia ap´os Jesus Cristo.

Quanto ao calend´ario, o imperador romano J´ulio C´esar implantou, a partir
de 46 a.C., o ano como tendo 12 meses, com o mˆes februarius tendo 29 dias, e um 30o
dia a cada 4 anos. No imp´erio de Ot´avio (posteriormente chamado de Augusto C´esar )
foi dado ao mˆes quintilis o nome de julius, em homenagem ao antigo imperador. Em
seguida, convencendo o senado, conseguiu que o mˆes sextilis fosse trocado por augustus,
em sua homenagem, fazendo com que se acrescentasse a este mais um dia (para, assim
como o mˆes de J´ulio C´esar, tivesse 31), que seria retirado de februarius. Isso ´e mostrado
na Tabela 1.

No ano 325 d.C., o imperador romano Constantino convocou o Conc´ılio de
Nic´eia 2, presidido pelo bispo ´Osio de C´ordoba (Hispˆania) em nome do velho Papa Silvestre
I, onde, dentre outros temas de interesse da f´e crist˜a, foi deﬁnido que todas as igrejas
deveriam celebrar a P´ascoa no mesmo dia, num domingo, mas n˜ao mais consultando o
calend´ario judaico. Ficou deﬁnido ent˜ao que deveria ser celebrada “no domingo a seguir
`a lua cheia, depois de 21 de Mar¸co (Equin´ocio3 de Primavera), o que d´a um domingo
entre 22 de Mar¸co e 25 de Abril ” [13].

Todos as igrejas estavam cumprindo o determinado em Nic´eia, por´em com
o passar dos s´eculos foi-se vendo uma defasagem de 10 dias entre a data de in´ıcio da

1

`A ´epoca do Conc´ılio de Nic´eia, a capital do imp´erio romano era Constantinopla, fundada pelo ent˜ao
imperador Constantino, e recentemente movida da antiga Roma. Isso justiﬁca o prest´ıgio desta perante
as igrejas durante o conc´ılio.

2 Hoje Iznik, cidade turca no arredores de Istambul.
3 O equin´ocio ´e o fenˆomeno onde dia e noite tem a mesma dura¸c˜ao, em todos os pontos da Terra.
No hemisf´erio norte, quando ´e equin´ocio de Primavera, no hemisf´erio sul ´e equin´ocio de Outono, e
vice-versa.

Cap´ıtulo 1. Introduc¸˜ao

13

Calend´ario de J´ulio C´esar Depois de Augusto C´esar

Mˆes
Januarius
Februarius
Martius
Aprilis
Maius
Junius
Quintilis
Sextilis
September
October
November
December

Dias
31
29/30
31
30
31
30
31
30
31
30
31
30

Mˆes
Januarius
Februarius
Martius
Aprilis
Maius
Junius
Julius
Augustus
September
October
November
December

Dias
31
28/29
31
30
31
30
31
31
30
31
30
31

Tabela 1 – Mudan¸cas no calend´ario, segundo J´ulio C´esar e Augusto C´esar.
Fonte: [9].

primavera e o equin´ocio propriamente dito, devido ao calend´ario de J´ulio C´esar, gerando
assim uma grande confus˜ao. A solu¸c˜ao j´a vinha sendo debatida a alguns s´eculos por
intelectuais e nobrezas, mas nunca deﬁnida por l´ıder algum. O problema de retirar dias
para voltar o equin´ocio para a data certa, exigia tamanho poder e inﬂuˆencia, que seria
“necess´aria a autoridade de um papa para implantar a mudan¸ca (assim como j´a havia
sido o papel de um ditador romano)” [4].

E assim o fez o Papa Greg´orio XIII, que para tentar consertar tudo, convi-
dou estudiosos para propor e analisar alternativas. O m´edico e professor italiano Luigi
Lilio, com a ajuda de seu irm˜ao Antonio, sugeriu que se retirassem 10 dias para voltar
o equin´ocio `a data normal, al´em de alterar como seriam determinados os anos bissextos,
para n˜ao mais se ter esse problema no futuro. Segundo ele, 365, 2425 dias era uma apro-
xima¸c˜ao bem melhor para o ano tr´opico4, diferente dos 365, 25 dias do calend´ario juliano
(com mais de 11 minutos de diferen¸ca). Isso resulta em 365 dias, 5 horas, 49 minutos e
12 segundos; s˜ao apenas 26, 8 segundos al´em do ano tr´opico!

Para chegar a esse valor, deveria-se continuar a contagem dos anos bissextos,
excluindo os anos seculares (m´ultiplos de 100), com exce¸c˜ao do m´ultiplos de 400, que
continuariam com um dia a mais:

365 +

1
4

−

1
100

+

1
400

= 365, 2425.

(1.1)

E assim, com o “aval” do matem´atico e astrˆonomo jesu´ıta Crist´ov˜ao Cl´avio,
Greg´orio publicou a bula papal Inter Gravissimas em 24 de fevereiro de 1582, determi-
nando: que a pr´oxima quinta-feira 4 de outubro seria sucedida pela sexta-feira 15 de
outubro; que o ano 1600 continuaria bissexto; que os 3 anos seculares seguintes n˜ao o

4 Tempo que a Terra leva para completar sua ´orbita.

Cap´ıtulo 1. Introduc¸˜ao

14

seriam (1700, 1800 e 1900), mas o ano 2000 voltaria a sˆe-lo, tomando esse mesmo padr˜ao
adiante; al´em de outras diretrizes sociais e eclesi´asticas decorrentes dessas mudan¸cas [11].
Enviou para todas as igrejas, ao passo que aquelas da ´Asia Menor, n˜ao reconhecendo a
primazia do papa, continuaram seguindo o calend´ario juliano, e o fazem at´e hoje. J´a os
pa´ıses foram cedendo `as recomenda¸c˜oes. Alguns cat´olicos, imediatamente, como Espanha,
Fran¸ca e Portugal (e Brasil, por consequˆencia), e outros com o passar dos anos, sendo
registrado que Gr´ecia e Turquia (predominantemente cat´olicos ortodoxos) adotaram-nas
em 1923 e 1926, respectivamente, e por ´ultimo a Rep´ublica Popular da China, com sistema
pr´oprio (o antiqu´ıssimo calend´ario chinˆes).

O objetivo central deste trabalho ´e apresentar um algoritmo que calcula a
data m´ovel da P´ascoa, que depende do plenil´unio5, do domingo, entre todos os dias
da semana, e tamb´em do equin´ocio da primavera (no hemisf´erio norte!). Para isso, na
introdu¸c˜ao mostrou-se o motivo hist´orico do cˆomputo e suas particularidades, al´em da
sua contextualiza¸c˜ao com a reforma do calend´ario promulgada pelo Papa Greg´orio XIII,
que inﬂuencia no c´alculo desta data, pela presen¸ca (ou n˜ao) do 366o dia.

No cap´ıtulo 2 ser´a apresentado todo o embasamento necess´ario para a cons-
tru¸c˜ao do algoritmo que depende apenas de Teoria dos N´umeros, mais especiﬁcamente
de um t´opico: congruˆencias, ou, como `as vezes ´e chamada, aritm´etica dos restos. Isso se
explica pelo car´ater c´ıclico dos c´alculos envolvidos na determina¸c˜ao da tal data.

J´a o cap´ıtulo 3 abordar´a os pormenores da linguagem de programa¸c˜ao C++,
desde o b´asico para um rotina simples at´e uns poucos comandos mais soﬁsticados que ser˜ao
usados na implementa¸c˜ao do algoritmo do c´alculo da P´ascoa. Lembrando-se que por se
tratar de uma l´ogica de programa¸c˜ao, acrescentando poucas linhas ´e poss´ıvel incrementar
um algoritmo simples, e torn´a-lo mais completo e eﬁciente.

O passo a passo da constru¸c˜ao de um programa nessa linguagem que retorne
a data da P´ascoa de um ano qualquer (a partir de 1600) ser´a ilustrado no cap´ıtulo 4.
Como esta data ´e referˆencia para a determina¸c˜ao de outras festividades religiosas6 (ﬁxas,
com rela¸c˜ao a ela), facilmente ´e poss´ıvel determin´a-los por consequˆencia da praticidade
da linguagem usada e do simples c´alculo que ´e feito para tal. Os comandos b´asicos de
C++ descritos aqui, os exemplos apresentados e discutidos e o fato do objeto de pesquisa
(o calend´ario) ser t˜ao concreto, por estar t˜ao atrelado `a vida cotidiana, gera interesse
por parte dos alunos do ensino m´edio, podendo ser usado sem problemas por aqueles
estudantes de escolas t´ecnicas ou proﬁssionalizantes do curso de inform´atica.

5 Lua cheia.
6 Da´ı sua importˆancia para a Igreja.

2 No¸c˜oes B´asicas de Teoria dos N´umeros

Uma parte importante da teoria dos n´umeros ´e a que estuda fenˆomenos c´ıclicos,
pois a natureza, f´ısica e humana, frequentemente se manifesta em situa¸c˜oes desse tipo. Por
exemplo: Numa rodovi´aria, Pedro que toma um ˆonibus `as 10 horas da manh˜a ´e informado
que o tempo estimado de viagem ´e de 16 horas, ao que imediatamente ele calcula a sua
chegada `as 2 da manh˜a do dia seguinte. Ora, como somar 10 + 16 e obter como resultado
2? Simples: usando a aritm´etica dos restos, ou como tamb´em ´e conhecida, aritm´etica
modular. Para iniciar a abordagem do tema, tratemos da divisibilidade entre inteiros.

2.1 DIVISIBILIDADE EM Z

´E sabido que nem todo n´umero natural (ou inteiro) ´e divis´ıvel por outro. Neste
caso, dizemos que essa divis˜ao deixa resto (diferente de zero). Quando a divis˜ao ´e poss´ıvel,
usamos a seguinte deﬁni¸c˜ao:

Deﬁni¸c˜ao 1 Dados dois n´umeros inteiros a e b com a (cid:54)= 0, diz-se que a divide b (ou a|b)
quando existir um q ∈ Z tal que b = a · q. Sendo assim, a ´e divisor de b, ou b ´e m´ultiplo
de a, ou ainda b ´e divis´ıvel por a.

Quando a n˜ao divide b, ou, em outras palavras, quando n˜ao existir q ∈ Z tal que b = aq,
representa-se por a(cid:54) | b. Ainda, se q existe, ele ´e chamado de quociente de b por a.

Exemplo 1 1, 2, 3, 4, 6 e 12 s˜ao todos divisores de 12, pois

12 = 1 · 12,

12 = 2 · 6,

12 = 3 · 4.

Logo, temos que 1|12, 2|12, 3|12, 4|12, 6|12 e 12|12. Entretanto, 5(cid:54) | 12, pois n˜ao existe
q ∈ Z tal que 12 = 5q.

(cid:5)

Note-se que

pois

a ∈ Z∗ , a|b ⇒ −a|b

b = aq = (−a)(−q).

Isso signiﬁca que para cada divisor de um n´umero, o sim´etrico1 daquele tamb´em

o ´e. Com isso, e partindo ainda da Deﬁni¸c˜ao 1,temos:

1 Mesmo valor absoluto, mas com sinal oposto.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

16

Proposi¸c˜ao 2.1.1 A rela¸c˜ao de divisibilidade em Z ´e:

i) reﬂexiva; e

ii) transitiva.

Demonstra¸c˜ao:
i) a = a · 1 ⇒ a divide ele mesmo.
ii) Signiﬁca que se a|b e b|c ⇒ a|c. De fato:

a|b ⇒ b = aq1

b|c ⇒ c = bq2 = aq1q2 ⇒ a|c.

Entretanto, essa rela¸c˜ao n˜ao ´e sim´etrica, como por exemplo 2 | 10 mas 10(cid:54) | 2.

Al´em destas propriedades, temos:

Proposi¸c˜ao 2.1.2 Sejam a, b, c ∈ Z. Assim:

i) 1|a e a|0.

ii) se a|1, ent˜ao a = ±1.

iii) se a|b e c|d, ent˜ao ac|bd.

iv) se a|b e b|a, ent˜ao a = ±b.

v) se a|b, com b (cid:54)= 0, ent˜ao |a| ≤ |b|.

Demonstra¸c˜ao:
i) a = 1 · a e 0 = a · 0.
ii) a|1 ⇒ 1 = aq ⇒ a = q = 1 ou a = q = −1.
iii) De fato, a|b e c|d ⇒ b = aq1 e d = cq2. Ent˜ao bd = aq1cq2 = (ac)(q1q2) ⇒ ac|bd.
iv) De fato, a|b e b|a ⇒ b = aq1 e a = bq2 = aq1q2. Ent˜ao q1 = q2 = 1 ou q1 = q2 = −1 ⇒
a = ±b.
v) De fato, como a | b, com b (cid:54)= 0 ⇒ b = aq, o que implica que |b| = |a||q|. S´o que
q (cid:54)= 0 ⇒ |q| ≥ 1 ⇒ |b| ≥ |a|.

Por ﬁm, uma das mais importantes propriedades da divisibilidade:

Proposi¸c˜ao 2.1.3 Sejam a, b e c inteiros, tais que a (cid:54)= 0. Se a divide b e c, ent˜ao divide
qualquer combina¸c˜ao linear2 entre eles, isto ´e:

2 Em referˆencia ao car´ater linear (linha reta) da express˜ao formada quando comparada a uma constante,

e representada no sistema de coordenadas xOy.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

17

a|b e a|c ⇒ a|(bx + cy), ∀x, y ∈ Z.

Demonstra¸c˜ao:
De a | b e a | c, temos que b = aq1 e c = aq2, com q1, q2 ∈ Z. Com isso, para quaisquer
x, y ∈ Z, tem-se que

bx + cy = aq1x + aq2y = a(q1x + q2y) ⇒ a|(bx + cy).

Note que, por esta propriedade, se a | bi, com i = 1, 2,. . . , n, para quaisquer

xi ∈ Z, temos que

a|(b1x1 + b2x2 + . . . + bnxn).

Exemplo 2 ([1]) Temos que, se a | (2x − 3y) e a | (4x − 5y), ent˜ao a | y. De fato, pela
Proposi¸c˜ao 2.1.3, temos que

a|[i(2x − 3y) + j(4x − 5y)]

, ∀i, j ∈ Z.

Se a divide qualquer combina¸c˜ao linear, ou seja, para quaisquer i e j, divide, em especial,
para i = −2 e j = 1:

a|[−2(2x − 3y) + (4x − 5y)] ⇒ a|y.

(cid:5)

Para complementar esta se¸c˜ao, mais outra important´ıssima propriedade:

Proposi¸c˜ao 2.1.4 Sejam a, b ∈ Z e n ∈ N. Nessas condi¸c˜oes, (a − b)|(an − bn).

Demonstra¸c˜ao:
Vamos usar indu¸c˜ao sobre n. A princ´ıpio, pela Proposi¸c˜ao 2.1.2(i), n = 0 ´e v´alido pois

(a − b)|(a0 − b0) ⇒ (a − b)|0.

Suponhamos agora, por hip´otese de indu¸c˜ao, que (a − b)|(an − bn). Temos que

an+1 − bn+1 = aan − bbn = aan − ban + ban − bbn = (a − b)an + b(an − bn).

Sabemos que (a − b)|(a − b) e (a − b)|(an − bn), por hip´otese. Logo, da Proposi¸c˜ao 2.1.3,
temos que (a − b)|(an+1 − bn+1), e pela indu¸c˜ao, para todo n ∈ N.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

18

2.2 DIVIS ˜AO EUCLIDIANA E M ´AXIMO DIVISOR COMUM

Para tratarmos desse importante t´opico, ser´a introduzido no texto o Princ´ıpio
da Boa Ordem, mas sua demonstra¸c˜ao, apesar de simples, ser´a omitida, por n˜ao ser
objetivo do texto. Para aprecia¸c˜ao da mesma, consultar [1].

Teorema 2.2.1 (Princ´ıpio da Boa Ordem) Todo subconjunto n˜ao-vazio de Z+ possui
um menor elemento.

A divis˜ao euclidiana (que tem esse nome devido o vasto uso na obra-prima Elementos, de
Euclides) ´e a base deste trabalho.

Teorema 2.2.2 (Divis˜ao Euclidiana) Sejam a e b dois inteiros, com a > 0. Existem
´unicos inteiros q e r tais que

b = aq + r

, 0 ≤ r < a.

Demonstra¸c˜ao:
Suponhamos o conjunto S de inteiros n˜ao-negativos da forma b − na, com n ∈ Z. S ´e n˜ao
vazio, pois, como a > 0 ⇒ a ≥ 1, e assim, para um n = −|b|, temos

b − na = b + |b|a ≥ b + |b|

que ´e n˜ao negativo, e portanto, “poss´ıvel” elemento de S. Al´em do mais, pelo Princ´ıpio
da Boa Ordem, existe um menor b − na. Seja ele

r = b − qa ou b = aq + r

, q ∈ Z.

No mais, se r ≥ a, ent˜ao ter´ıamos um x ∈ N tal que r = a + x = b − qa o que implica

x = b − (q + 1)a < r

e portanto, contradi¸c˜ao ao fato de r ser o m´ınimo de S. Agora, mostremos que q e r s˜ao
´unicos. Suponhamos outros q(cid:48), r(cid:48) ∈ Z tais que

b = aq(cid:48) + r(cid:48)

, 0 ≤ r(cid:48) < a.

Assim

aq + r = aq(cid:48) + r(cid:48) ⇒ r − r(cid:48) = (q(cid:48) − q)a ⇒ a|(r − r(cid:48)).

Como 0 ≤ r, r(cid:48) < a, isso implica que |r − r(cid:48)| < a. Mas tamb´em a | (r − r(cid:48)), ent˜ao, pela
Proposi¸c˜ao 2.1.2(v), deve ser

r − r(cid:48) = 0 ⇒ r = r(cid:48)

al´em de

q(cid:48) − q = 0 ⇒ q(cid:48) = q,

pois a (cid:54)= 0.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

19

Dividindo ent˜ao b por a, damos a q e r os nomes quociente e resto, respecti-
vamente. ´E interessante ainda comentar que atrav´es desse algoritmo podemos deﬁnir um
n´umero inteiro como par ou ´ımpar, a seguir.

Deﬁni¸c˜ao 2 (Paridade) Seja b ∈ Z. Ent˜ao

i) se o resto da divis˜ao de b por 2 for 0, ent˜ao b = 2q recebe o nome de “par”;

ii) se o resto da divis˜ao de b por 2 for 1, ent˜ao b = 2q + 1 recebe o nome de “´ımpar”.

Generalizando essa deﬁni¸c˜ao, estabelecemos o seguinte corol´ario:

Corol´ario 2.2.1 Seja n ∈ N. Dado a ≥ 2, sempre ´e poss´ıvel express´a-lo, de forma ´unica,
como n = ak + r, onde k, r ∈ N e r ´e um dos n´umeros 0, 1, 2, . . . , a − 1.

Vamos aplicar isso num exemplo.

Exemplo 3 ([7]) De n inteiros consecutivos, um, e apenas um deles, ´e divis´ıvel por n.
Pelo Corol´ario 2.2.1, cada um dos n n´umeros (distintos) ´e escrito, de forma ´unica, como
nk + r, com r < n. Como s˜ao consecutivos, cada um ter´a um valor distinto para r, e
portanto, apenas um deles ter´a r = 0, isto ´e, ´e divis´ıvel por n, deixando resto 0.

(cid:5)

Exemplo 4 Quantos termos da PA 3, 8, 13, . . . est˜ao entre 84 e 427? Perceba que cada
elemento dessa PA ´e um elemento da forma 5k − 2, com k = 1, 2, 3, . . . . Ent˜ao conta-se
essa quantidade de termos analisando qual o maior valor poss´ıvel de k tal que 5k −2 < 427
e da´ı subtrai-se do valor encontrado em 5k − 2 < 84:

5k − 2 < 427 ⇒ k < 85, 8 e 5k − 2 < 84 ⇒ k < 17, 2.

Isso signiﬁca que, como k ´e natural, temos 85 termos da PA menores que 427, sendo 17
menores que 84, o que nos d´a 85 − 17 = 68 destes termos no intervalo (84, 427). Como
op¸c˜ao, poder´ıamos simplesmente ter adicionado 2 unidades a cada termo da PA e aos
limites do intervalo, que a quantidade requisitada no problema se manteria, pois haveria
apenas um deslocamento das posi¸c˜oes; os elementos da “nova” PA seriam 5, 10, 15, . . .,
entre 86 e 429. Assim, os elementos “coincidiriam” com os m´ultiplos positivos de 5. A
estrat´egia seria calcular o quociente dos extremos do intervalo e 5, pela divis˜ao euclidiana:

429 = 5 · 85 + 4

e 86 = 5 · 17 + 1.

Os m´ultiplos de 5 s˜ao

5 · 1, 5 · 2, 5 · 3, . . . , 5 · 17 = 85
(cid:125)
(cid:123)(cid:122)
(cid:124)
≤86

, 5 · 18 = 90, . . . , 5 · 85 = 425
(cid:125)
(cid:123)(cid:122)
86<n<429

(cid:124)

, 5 · 86 = 430, . . .
(cid:125)
(cid:123)(cid:122)
≥429

(cid:124)

concluindo assim como na solu¸c˜ao anterior.

(cid:5)

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

20

Generalizando esse importante resultado, dados a, c ∈ N, com a < c, o quo-
ciente da divis˜ao euclidiana de c por a nos d´a a quantidade de m´ultiplos positivos de a
(cid:3), que ´e a
menores que c. Representaremos esse quociente (inteiro – e positivo) por (cid:2) c
parte inteira do racional c
a. Isso demonstra a proposi¸c˜ao abaixo, base para o Cap´ıtulo 4:

a

Proposi¸c˜ao 2.2.1 Dados a, b, c ∈ Z, com 0 < a < b < c, o n´umero de m´ultiplos de a
entre b e c ´e dado por:

i)

ii)

(cid:105)

(cid:104) c
a

(cid:105)

(cid:104) c
a

−

−

(cid:20)b − 1
a

(cid:21)

, b incluso; ou

(cid:21)

, b excluso.

(cid:20) b
a

A partir deste ponto precisaremos de uma das mais importantes deﬁni¸c˜oes da
Matem´atica: m´aximo divisor comum. Sejam ent˜ao a e b dois inteiros, n˜ao simultanea-
mente nulos. Dizemos que d ∈ Z∗ ´e um divisor comum de a e b se d | a e d | b. Baseado
nisso:

Deﬁni¸c˜ao 3 (M´aximo divisor comum) Um n´umero d ∈ Z∗
comum de a e b se satisfaz as propriedades:

+ ´e o m´aximo divisor

i) d ´e um divisor comum de a e b; e

ii) sendo c um divisor comum de a e b, ent˜ao c|d.

Assim, indica-se d por mdc(a, b) ou apenas (a, b), nota¸c˜ao usada neste trabalho.
Decorre diretamente da´ı, por (i), que d ´e um divisor comum a ambos os n´umeros e, por
(ii), que ´e o maior dentre os divisores comuns. Note-se que tomando d1 e d2, ambos mdc
dos mesmos n´umeros, ent˜ao pela deﬁni¸c˜ao acima

d1 ≤ d2

e d2 ≤ d1 ⇒ d1 = d2.

Isto signiﬁca que quando o mdc de dois n´umeros existe, ele ´e ´unico (unicidade
do mdc). Para ser mais “exato”, ele sempre existe. Isso ´e garantido, pelo seguinte lema:

Lema 1 (Lema de Euclides) Sejam a, b, n ∈ N, onde a < na < b. Se (a, b − na)
existe, ent˜ao (a, b) tamb´em existe, e ambos tem o mesmo valor.

Demonstra¸c˜ao:
Chamemos de d = (a, b−na). Logo, d|a e d|(b−na), e pela Proposi¸c˜ao 2.1.3, temos que
d|(b − na + na) ⇒ d|b. Assim, d divide a e b, restando mostrar que ´e o m´aximo divisor.
Seja um d(cid:48) divisor comum a a e b. Tamb´em pela propriedade supracitada, d(cid:48)|(b − na), e
desta forma, d(cid:48)|d ⇒ d(cid:48) ≤ d. Logo, d = (a, b).

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

21

Deﬁni¸c˜ao 4 Sejam a e b dois inteiros n˜ao simultaneamente nulos. Dizemos que eles s˜ao
coprimos, ou primos entre si, se e somente se o mdc(a, b) = 1.

Existe uma importante implica¸c˜ao sobre essa deﬁni¸c˜ao, apresentada abaixo.

Teorema 2.2.3 Dois inteiros a e b s˜ao coprimos se e somente se existem inteiros x e y
tais que ax + by = 1.

Demonstra¸c˜ao:
(⇒) Se a e b s˜ao coprimos, ent˜ao temos que

mdc(a, b) = 1 ⇒ ax + by = 1

com x e y inteiros.
(⇐) Suponha d = mdc(a, b), ent˜ao d|a e d|b, o que, pela Proposi¸c˜ao 2.1.3, indica que
d divide qualquer combina¸c˜ao linear entre a e b, inclusive d|(ax + by). Mas como a e b
s˜ao coprimos, ent˜ao existem x e y tais que

ax + by = 1 ⇒ d|1 ⇒ d = mdc(a, b) = 1.

Os pr´oximos resultados decorrem diretamente do teorema acima:

Corol´ario 2.2.2 Sejam a, b ∈ Z, n˜ao mutuamente nulos. Ent˜ao

(cid:18) a

(a, b)

(cid:19)

,

b
(a, b)

= 1.

Demonstra¸c˜ao:
Cada uma das fra¸c˜oes s˜ao inteiros, pois (a, b)|a e (a, b)|b. Assim, existem x e y inteiros
tais que

logo, dividindo ambos os membros por (a, b):

ax + by = (a, b)

+

ax
(a, b)
a
(a, b)

x +

by
(a, b)
b
(a, b)

=

(a, b)
(a, b)

y = 1.

Corol´ario 2.2.3 Sejam a e b coprimos. Ent˜ao

a|c

e

b|c ⇒ ab|c.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

22

Demonstra¸c˜ao:
Sejam q, k ∈ Z tais que

a|c ⇒ c = aq; e

b|c ⇒ c = bk.

Como (a, b) = 1, ent˜ao existem x, y ∈ Z tais que

⇒ ax + by = 1

⇒ axc + byc = c

⇒ ax(bk) + by(aq) = c

⇒ ab(xk + yq) = c

⇒ ab|c.

2.3 CONGRUˆENCIAS

Deﬁni¸c˜ao 5 Sejam a, b ∈ Z e um m ∈ N. Dizemos que a e b s˜ao congruentes m´odulo
m se e somente se os restos da divis˜ao euclidiana deles por m s˜ao iguais. Quando a ´e
congruente a b m´odulo m, escrevemos

a ≡ b mod m.

Em outras palavras, se a congruˆencia n˜ao for veriﬁcada, dizemos que a e b s˜ao

n˜ao congruentes ou incongruentes, m´odulo m. Expressamos a (cid:54)≡ b mod m.

´E importante mencionar que o resto da divis˜ao de qualquer inteiro por 1 ´e 0,

portanto

a ≡ b mod 1 , ∀a, b ∈ Z.

Por esse motivo, desconsidere-se este caso; neste trabalho, m > 1.

As propriedades abaixo s˜ao consequˆencias diretas da deﬁni¸c˜ao acima.

Proposi¸c˜ao 2.3.1 Sejam a, b, c, m ∈ Z, com m > 1. Tem-se que

i) a ≡ a mod m,

(reﬂexiva)

ii) se a ≡ b mod m, ent˜ao b ≡ a mod m,

(sim´etrica)

iii) se a ≡ b mod m e b ≡ c mod m, ent˜ao a ≡ c mod m.

(transitiva)

Percebe-se que a congruˆencia m´odulo m ´e, ent˜ao, uma rela¸c˜ao de equivalˆencia
em Z. Al´em disso, ´e poss´ıvel veriﬁcar se dois n´umeros s˜ao congruentes m´odulo m, sem
dividir ambos por m. ´E suﬁciente dividir a diferen¸ca entre eles (a − b ou b − a, j´a que
tratamos de Z). Isso est´a expl´ıcito na propriedade abaixo.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

23

Proposi¸c˜ao 2.3.2 Sejam a, b, m ∈ Z, com m > 1. Ent˜ao

a ≡ b mod m ⇔ m|(b − a).

Demonstra¸c˜ao:
(⇒) Consideremos a divis˜ao euclidiana de a e b por m:

a = mq + r, 0 ≤ r < m
b = mq(cid:48) + r(cid:48), 0 ≤ r(cid:48) < m

(cid:41)

⇒

⇒ b − a = mq(cid:48) + r(cid:48) − mq − r = m(q(cid:48) − q) + (r(cid:48) − r).

Por hip´otese, a e b s˜ao congruentes, logo os seus restos na divis˜ao por m s˜ao iguais, e
portanto

r = r(cid:48) ⇒ b − a = m(q(cid:48) − q) ⇒ m|(b − a).

(⇐) Como m|b − a, ent˜ao existe um k ∈ Z tal que b − a = km ⇒ b = km + a. Dividindo
a por m, temos a = mq + r. Assim

b = km + qm + r = (k + q)m + r.

Percebe-se que tanto a quanto b deixam o mesmo resto r na divis˜ao por m, logo

⇒ a ≡ b mod m.

As propriedades abaixo mostram as opera¸c˜oes de adi¸c˜ao e multiplica¸c˜ao usando

congruˆencias. Esse teorema ´e importante para o algoritmo do c´alculo de uma data.

Teorema 2.3.1 Sejam a, b, c, d, m ∈ Z, com m > 1. Ent˜ao:

i) se a ≡ b mod m e c > 0, ent˜ao ac ≡ bc mod mc;

ii) se a ≡ b mod m e c ≡ d mod m, ent˜ao a + c ≡ b + d mod m e ac ≡ bd mod m;

iii) se a ≡ b mod m, ent˜ao a + c ≡ b + c mod m e ac ≡ bc mod m.

Demonstra¸c˜ao:
i) Como a ≡ b mod m, ent˜ao ∃q ∈ Z tal que

a − b = qm ⇒ ac − bc = qmc ⇒ ac ≡ bc mod mc.

ii) Como a ≡ b mod m e c ≡ d mod m, ent˜ao ∃q, k ∈ Z tal que

a − b = qm e

c − d = km.

Somando membro a membro

(a − b) + (c − d) = qm + km ⇒ (a + c) − (b + d) = (q + k)m ⇒ a + c ≡ b + d mod m.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

24

Da mesma forma, tomando a = qm + b e c = km + d, temos

ac − bd = (qm + b)(km + d) − bd = (qkm + qd + bk)m ⇒ ac ≡ bd mod m.

iii) An´aloga a ii).

Por ﬁm, vˆe-se que existe o cancelamento aditivo para congruˆencias, mas veja-

mos como funciona o cancelamento multiplicativo:

Proposi¸c˜ao 2.3.3 Dados a, b, c, m ∈ Z, com m > 1, ent˜ao

ac ≡ bc mod m ⇔ a ≡ b mod

m
(c, m)

.

Demonstra¸c˜ao:
Temos que

ac ≡ bc mod m ⇔ m|(b − a)c ⇔

m
(c, m)

|(b − a)

c
(c, m)

.

Como, pelo Teorema 2.2.3,

c
(c, m)

e

m
(c, m)

s˜ao coprimos, ent˜ao

⇔

m
(c, m)

|(b − a) ⇔ a ≡ b mod

m
(c, m)

.

2.4 CONGRUˆENCIAS LINEARES E O TEOREMA CHINˆES DOS RES-

TOS

Se uma congruˆencia do tipo

aX ≡ b mod m,

onde a, b, m ∈ Z, com m ≥ 1

tem solu¸c˜ao, signiﬁca que procuramos inteiros x tais que m|(ax − b). Usaremos a seguinte
proposi¸c˜ao:

Proposi¸c˜ao 2.4.1 Dados a, b, m ∈ Z, com m ≥ 1, ent˜ao

∃x ∈ Z, ax ≡ b mod m ⇔ (a, m)|b.

Demonstra¸c˜ao:
(⇒) Seja d = (a, m). Suponhamos que existe x inteiro tal que ax ≡ b mod m. Ent˜ao
existe um k tal que

ax − b = mk ou ax − mk = b.

Mas d|a e d|m, logo, pela Proposi¸c˜ao 2.1.3, d|(ax − mk) ⇒ d|b.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

25

(⇐) Suponhamos agora que d|b, ent˜ao existe um q ∈ Z tal que b = dq. Ainda, tomemos
x e y tais que ax − my = d. Temos:

ax − my = d

⇔ aqx − mqy = dq = b

⇔ aqx − b = mqy

⇔ aqx ≡ b mod m

com qx sendo uma solu¸c˜ao da congruˆencia linear.

Dizemos que, dado um xi encontrado como solu¸c˜ao da congruˆencia

aX ≡ b mod m

este ´e uma solu¸c˜ao particular. Isso porque todo xj, com i (cid:54)= j, tal que xi ≡ xj mod m,
tamb´em ´e uma solu¸c˜ao da congruˆencia. Ent˜ao precisamos saber como encontrar todas
as solu¸c˜oes incongruentes m´odulo m. O teorema abaixo garante isso, mas por n˜ao estar
diretamente relacionado ao objeto do trabalho, sua demonstra¸c˜ao ser´a omitida, podendo
ser encontrada em [1] ou [7].

Teorema 2.4.1 Seja d = (a, m), onde d|b. Ent˜ao a congruˆencia linear

aX ≡ b mod m

tem exatamente d solu¸c˜oes da forma

x0, x1 = x0 +

m
d

, x2 = x0 +

2m
d

, . . . , xd−1 = x0 +

(d − 1)m
d

tais que s˜ao incongruentes duas a duas m´odulo m.

Congruˆencias lineares resolvem importantes problemas te´oricos e pr´aticos (como
no Cap´ıtulo 4). Vamos apresentar o Teorema Chinˆes dos Restos, e um exemplo de sua
aplica¸c˜ao.

Teorema 2.4.2 (Teorema Chinˆes dos Restos) Sejam m1, m2, . . . , mn inteiros posi-
tivos coprimos dois a dois. O sistema de congruˆencias lineares






X ≡ r1 mod m1
X ≡ r2 mod m2

...

X ≡ rn mod mn

possui uma ´unica solu¸c˜ao m´odulo M = m1m2 · · · mn.

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

26

Demonstra¸c˜ao:

Tomemos os n´umeros Mi =
coprimos e pelo Teorema 2.4.1, temos que

M
mi

, com i = 1, 2, . . . , n. Logo, pelo fato dos mi serem

(Mi, mi) = 1|ri ⇒ ∃xi tal que Mixi ≡ 1 mod mi.

(2.1)

Com isso, uma solu¸c˜ao do sistema ´e

x = M1r1x1 + M2r2x2 + . . . + Mnrnxn.

De fato, mi|Mj, com i (cid:54)= j, logo

Mj ≡ 0 mod mi ⇒






M1r1x1 ≡ 0 mod mi
M2r2x2 ≡ 0 mod mi
...

Mirixi ≡ Mirixi mod mi

...
Mnrnxn ≡ 0 mod mi

Somando as congruˆencias, temos x ≡ Mirixi mod mi. Sabendo de (2.1), ent˜ao

X ≡ ri · 1 ≡ ri mod mi.

A solu¸c˜ao existe, mostremos ent˜ao que ´e ´unica. Suponhamos y outra solu¸c˜ao do sistema,
logo

y ≡ x mod mi ⇒ mi|(y − x).

Como os mi s˜ao coprimos, diretamente pelo Corol´ario 2.2.3, temos que:

M = m1m2 · · · mn|(y − x) ⇒ y ≡ x mod M.

Logo o sistema possui ´unica solu¸c˜ao m´odulo M .

Considerando o exposto, temos que M |(x − (cid:80)n

i=1 Mirixi), ou seja

x =

n
(cid:88)

i=1

Mirixi + M k,

com k ∈ Z.

Chamaremos a express˜ao acima de solu¸c˜ao geral do sistema de equa¸c˜oes lineares. Apli-
quemos num exemplo.

Exemplo 5 ([15]) Vamos encontrar um inteiro x tal que

5X ≡ 1 mod 19
5X ≡ 16 mod 18

(cid:41)

(2.2)

Cap´ıtulo 2. Noc¸˜oes B´asicas de Teoria dos N´umeros

27

Primeiramente, temos que:

≡ 20 mod 19
1 + 19
5X ≡ 1 ≡
5X ≡ 16 ≡ 16 + 3 · 18 ≡ 70 mod 18

(cid:41)

Como (5, 19) = (5, 18) = 1, podemos usar o resultado da Proposi¸c˜ao 2.3.3:

X ≡ 4 mod 19
X ≡ 14 mod 18

(cid:41)

(2.3)

Signiﬁca que resolver o sistema (2.3) ´e equivalente a resolver o sistema (2.2). Aplicando
o Teorema Chinˆes dos Restos, temos

M = 19 · 18 = 342, M1 = 18, M2 = 19.

Temos tamb´em que uma de suas solu¸c˜oes ´e

Encontremos x1 e x2:

x ≡ 18 · 4x1 + 19 · 14x2 mod 342.

18x1 ≡ 1 mod 19 ⇒ x1 = 18
19x2 ≡ 1 mod 18 ⇒ x2 = 1

(cid:41)

Substituindo (2.5) em (2.4), temos

x ≡ 72 · 18 + 266 · 1 ≡ 1562 ≡ 194 mod 342.

Vejamos que 5 · 194 = 970 = 19 · 51 + 1 = 18 · 53 + 16.

(2.4)

(2.5)

(cid:5)

3 Linguagem C++: No¸c˜oes B´asicas

A princ´ıpio, ´e bom diferenciar algoritmo de programa. Para o primeiro, Davis
declara em [5] que “´e uma descri¸c˜ao das etapas a serem executadas, normalmente a
um alto n´ıvel de abstra¸c˜ao. Um algoritmo ´e detalhado, mas geral”. Pode ser usada
qualquer linguagem que consiga descrever a sequˆencia de passos e os objetos tratados.
Em contrapartida, um programa ´e o resultado de um algoritmo traduzido para uma
linguagem de programa¸c˜ao, para, atrav´es de um compilador 1, efetuar as tarefas `as quais
foi destinado.

Um algoritmo como o da divis˜ao euclidiana, para encontrar os inteiros q e r tais
que na divis˜ao de a por b tenhamos a = bq + r, ou o chamado algoritmo de Euclides para
encontrar o m´aximo divisor comum entre dois n´umeros, s˜ao bons exemplos de “sequˆencias
de passo a passo”. O programa (=software) num smartphone que reconhece o n´umero
digitado como sendo da agenda e efetua uma liga¸c˜ao para o mesmo, apesar de ter uma
“sequˆencia de tarefas, com entrada e sa´ıda de valores”, ´e executado por um sistema
operacional, portanto, n˜ao ´e apenas um algoritmo.

A linguagem de programa¸c˜ao escolhida para este trabalho ´e o C++, linguagem
derivada do antigo (e ainda usado) C, por´em mais aprimorado. O programa utilizado
como compilador e editor de texto2 para a elabora¸c˜ao das rotinas aqui presentes ´e o
Code::Blocks3, podendo ser usado qualquer um, como o Dev-C++4, que assim como o
anterior, ´e gratuito.

´E bom salientar neste ponto que alguns elementos necess´arios a um completo
entendimento da programa¸c˜ao, como o funcionamento de um compilador, o conceito de
computador simpliﬁcado, deﬁni¸c˜ao de estruturas e classes, entre outros, ser˜ao omitidos,
por divergirem do objetivo deste texto. Para maior aprofundamento, ver [3], [5] ou [10].

3.1 INICIANDO UM PRIMEIRO PROGRAMA

Antes de tudo, alguns detalhes. A linguagem C++ ´e case sensitive, o que
signiﬁca que diferencia mai´usculas de min´usculas. A quantidade de espa¸cos tamb´em n˜ao
inﬂuencia no programa, desde que n˜ao estejam no meio do nome de palavras chaves,
comandos e vari´aveis. Estas podem iniciar seu nome apenas com uma letra ou um ca-
ractere de sublinhado, e no resto do nome pode-se usar algarismos tamb´em. Al´em disso,

1 Software que converte a linguagem de programa¸c˜ao, chamada de alto n´ıvel, para a linguagem de

m´aquina (bin´aria), chamada de baixo n´ıvel.

2 Qualquer programa que edite texto serve, por´em ´e desvantajoso usar um editor qualquer, pois um
apropriado ao C++ pode analisar e apontar erros, completar comandos e at´e contribuir com um
melhor design gr´aﬁco, separando comandos, vari´aveis, texto, coment´arios, etc.

3 http://www.codeblocks.org/. Vers˜oes dispon´ıveis para Windows, Macintosh e Linux.
4 http://www.bloodshed.net/devcpp.html. Vers˜oes dispon´ıveis para Windows e Linux/Unix.

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

29

´e necess´ario um certo “cuidado” com acentos, na hora de exibir textos. Nos programas
abaixo, estes ser˜ao evitados.

Um programa o mais simples poss´ıvel precisa de alguns elementos b´asicos

essenciais para poder ser compilado5. Ficaria assim:

1

2

3

4

5

6

# include < iostream >
using namespace std ;
int main ()
{

return 0;

}

As instru¸c˜oes em C++ sempre terminam com ponto e v´ırgula, por´em vemos
que na primeira linha deste primeiro programa n˜ao tem. ´E o que chamamos de diretiva
do pr´e-processador. Este ´e um programa que analisa o programa-fonte e executa algumas
modiﬁca¸c˜oes conforme as diretivas, que s˜ao fun¸c˜oes (instru¸c˜oes) espec´ıﬁcas para ele, que
n˜ao fazem parte da linguagem C++. Sempre come¸cam com #. Esta diretiva (#include)
inclui outro arquivo exatamente no local onde ´e chamada, copiando o seu conte´udo e
colando neste ponto. Neste caso, o arquivo ´e a biblioteca6 iostream, respons´avel pelo
gerenciamento de entrada e sa´ıda de dados no programa.

O comando using serve para dizer ao compilador onde est˜ao (espa¸co de tra-
balho) as fun¸c˜oes e classes presentes no programa, e neste caso, no namespace std
(=standard, padr˜ao). Neste “namespace ” est˜ao, por exemplo, os comandos cin>> e
cout<<, que t˜ao usados ser˜ao neste trabalho.

A fun¸c˜ao main (=principal ) ´e “a fun¸c˜ao” do programa, isto ´e, o que queremos
fazer estar´a dentro de main; come¸ca ap´os o { e termina no }. Vˆe-se que a ´unica instru¸c˜ao
da linguagem C++ mesmo neste primeiro programa ´e o “return 0”, que signiﬁca retornar
valor zero, j´a que a fun¸c˜ao main ´e do tipo inteiro, logo deve devolver “a quem a chamou”
um inteiro, e neste exemplo como n˜ao deveria fazer coisa alguma, retorna o valor nulo.
Nos parˆenteses devem ser colocados certos parˆametros, de acordo com o uso espec´ıﬁco de
main. Para uso neste trabalho, os parˆenteses estar˜ao sempre vazios.

Para n˜ao ﬁcarmos apenas com este primeiro programa “trivial”, tomaremos
mais quatro instru¸c˜oes, comuns no uso do C++: cin, cout, declara¸c˜ao de vari´avel e
atribui¸c˜ao (=).

Exemplo 6 Vejamos como criar um programa que pe¸ca 4 n´umeros naturais ao usu´ario
e exiba na tela a m´edia aritm´etica desse conjunto. Neste caso, dever´a aparecer uma
mensagem na tela pedindo cada n´umero por vez, e para isso usaremos o comando cout

5 Doravante, entenda como montado, traduzido em linguagem de m´aquina.
6 Biblioteca ´e um conjunto de comandos e fun¸c˜oes elaborados para situa¸c˜oes espec´ıﬁcas dentro de um
programa. Por exemplo, a biblioteca cstdlib, cont´em um comando chamado rand(), que gera um
n´umero pseudo-aleat´orio.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

30

(sa´ıda), com o operador de inser¸c˜ao7 <<. Para ler cada valor e armazen´a-lo, usaremos
cin (entrada), acompanhado do operador de extra¸c˜ao8 >>. Mas para armazenar,
devemos declarar vari´aveis. Uma vari´avel ´e um espa¸co de mem´oria destinada a armazenar
um tipo de dado. Toda vari´avel deve ser declarada (e muitas vezes inicializada) antes
do seu uso. Chamaremos de a, b, c e d, al´em de uma m, onde ser´a guardada o valor da
m´edia. Para declar´a-las, primeiro diz-se seu tipo, podendo ser basicamente inteira (int),
real (ﬂoat ou double – decimais), l´ogica (bool – verdadeiro ou falso), caractere (char
– um caractere, imprim´ıvel ou n˜ao) e void (void – o “nada”). O nosso programa ﬁcaria
assim:

# include < iostream >
using namespace std ;

// Isso eh um comentario , sempre apos as barras
// duplas . O compilador ignora essa parte do
// programa .

int main ()
{

float a ,b ,c ,d , m ;

// Perceba que todas as variaveis foram declaradas
// juntas ( sao todas do mesmo tipo ) , mas nao foram
// inicializadas

cout < < " Digite o primeiro numero : " ;
cin > > a ;
cout < < " \ nDigite o segundo numero : " ;
cin > > b ;
cout < < " \ nDigite o terceiro numero : " ;
cin > > c ;
cout < < " \ nDigite o quarto numero : " ;
cin > > d ;
m =( a + b + c + d ) /4;
cout < < " \ n \ nMedia dos quatro numeros digitados : " <<m ;
return 0;

}

No in´ıcio do programa, no primeiro pedido, espera-se a intera¸c˜ao do usu´ario.
O mesmo digita um n´umero, e ao teclar enter, o programa registra esse valor na vari´avel
a, ao que em seguida o programa j´a faz o pr´oximo pedido. Ap´os o registro na vari´avel
d, o programa calcula a m´edia dos 4 n´umeros e guarda o valor na vari´avel m. Assim
funciona o operador de atribui¸c˜ao =. Ele copia o valor que est´a (ou que resulta, no caso
de express˜oes) do lado direito e registra na vari´avel que est´a do lado esquerdo. Note-se
que as vari´aveis declaradas s˜ao todas do tipo ﬂoat 9, pelo fato da m´edia poder precisar de
casas decimais para ser expressa. Em seguida, o programa exibe a string10 “Media dos
quatro numeros digitados: ” e o valor de m, previamente calculado. O programa, ao

7 Serve para inserir dados na stream que ser´a exibida. Stream ´e uma sequˆencia de dados.
8 Para extrair os dados da stream inserida.
9 O tipo double, que tamb´em armazena n´umeros decimais, reserva uma quantidade maior de mem´oria,

por isso a escolha por ﬂoat.

10 Sequˆencia de caracteres; um tipo de vetor, que funciona como vari´avel.

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

31

ﬁnal, exibe o tempo de execu¸c˜ao, e aguarda o usu´ario teclar algum bot˜ao para fechar (ou
continuar, quando for o caso). O caractere “\n” passa para a pr´oxima linha. Um exemplo
da tela do execut´avel11 segue abaixo.

Figura 1 – Execut´avel do programa media
Fonte: pr´opria.

(cid:5)

3.2 REPETINDO PASSOS: LAC¸ OS

Em diversas situa¸c˜oes ´e necess´ario que uma certa instru¸c˜ao (ou instru¸c˜oes)
sejam efetuadas algumas vezes, at´e que se atinja um resultado esperado, ou uma quanti-
dade satisfat´oria. Para isso, nas linguagens de programa¸c˜ao, se usa o la¸co (do inglˆes loop,
como normalmente ´e conhecido). Por exemplo, para se calcular o quociente e o resto de
no algoritmo da divis˜ao, pode ser um procedimento relativamente lento, e a velocidade
reduz se a diferen¸ca entre divisor e dividendo aumenta, pois ´e preciso que se encontre
um m´ultiplo do divisor o maior poss´ıvel, mas que seja menor ou igual ao dividendo (ver
Exemplo 8). Por´em, aproveitando a praticidade de um programa em C++, facilmente
se encontra quociente e resto de uma divis˜ao desta forma. Mas antes, ser˜ao apresentados
os tipos de la¸cos usados no C++.

O la¸co for geralmente ´e usado quando se quer repetir uma instru¸c˜ao uma

quantidade de vezes ﬁxa, determinada.

1

for ( inicializacao ; teste ; incremento )

Uma vari´avel ´e escolhida para funcionar como contador ; a ele se referem os
trˆes termos no parˆenteses. Ap´os a chamada do la¸co, ele ´e inicializado (podendo at´e ser
declarado nesse ponto). Em seguida faz-se o teste (no in´ıcio do la¸co), lembrando que por
se tratar de um contador, geralmente ´e uma compara¸c˜ao de ordem (>, ≥, < ou ≤). Esse
teste ´e feito toda vez que o la¸co ´e reiniciado. Se o teste resultar em verdadeiro, ele cumpre
a instru¸c˜ao dada e, no ﬁm do la¸co, antes de reiniciar, aumenta (ou diminui) o valor do

11 Programa que realmente “executa” as instru¸c˜oes determinadas, gerado pelo compilador.

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

32

contador. Recome¸ca, refazendo o teste. O la¸co for n˜ao exige ponto-e-v´ırgula, por´em a
instru¸c˜ao ligada ao la¸co, sim. Caso haja mais de uma instru¸c˜ao a repetir, s´o agrup´a-las
entre chaves.

Exemplo 7 Vamos ver como escrever os 30 primeiros termos da sequˆencia de Fibonacci.
Considerando F1 = F2 = 1 os dois primeiros termos da sequˆencia, e sabendo ent˜ao que
Fn+2 = Fn + Fn+1, n˜ao ´e nada dif´ıcil calcular tais termos, por´em, a quantidade exige
um certo esfor¸co. Por se tratar de uma recorrˆencia, o mesmo c´alculo ´e repetido algumas
vezes para encontrar o termo seguinte. Por esse motivo, o la¸co se torna interessante. O
programa ﬁcaria o seguinte:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

# include < iostream >
using namespace std ;
int main ()
{

int i , fn2 =2 , fn1 =1 , fn , fax ;
cout < <1 < < " \ t " < <1 < < " \ t " ;
for ( i =0; i <28; i ++)
{

cout < < fn2 < < " \ t " ;
fn = fn1 ;
fax = fn2 ;
fn2 = fn2 + fn1 ;
fn1 = fax ;

}
return 0;

}

Foram usadas 5 vari´aveis nesse programa: trˆes vari´aveis para a sequˆencia (fn2,
fn1 e fn, para Fn+2, Fn+1 e Fn, respectivamente), uma para a contagem do la¸co (i) e
outra auxiliar (fax). Foram escritos os dois primeiros termos da sequˆencia, e justamente
por isso, o teste s´o conta at´e i< 28 no la¸co. Dentro deste, ele imprime fn2= 2 (declarada
e j´a inicializada) com o comando cout<<. Neste ponto, os valores s˜ao

fn2= 2

fax (sem valor)

fn1= 1

fn (sem valor)

Da´ı come¸ca os “repasses” de valores. ´E preciso destacar que as quatro linhas
restantes do la¸co n˜ao s˜ao igualdades, s˜ao atribui¸c˜oes (valor do lado direito atribu´ıdo `a
vari´avel do lado esquerdo). Assim, fn recebe o valor de fn1, fax recebe o de fn2 (e
reserva!), fn2 recebe o pr´oprio valor somado ao que est´a em fn1, e por ﬁm, fn1 recebe
o que estava reservado em fax. Este ciclo se repete 28 vezes, j´a que i come¸ca com valor
nulo. A imagem do programa em execu¸c˜ao seria assim:

No ﬁm, apenas fn2 estava sendo exibido, mas sempre com um valor diferente.

O caractere “\t” imprime o espa¸co de um par´agrafo.

(cid:5)

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

33

Figura 2 – Execut´avel do programa Fibonacci
Fonte: pr´opria.

O segundo la¸co ´e o while. Um pouco parecido com o for, mas a condi¸c˜ao de
t´ermino pode n˜ao ser ﬁxa, isto ´e, o la¸co pode encerrar de acordo com um fator externo.
Como no for, ele pode ser usado com um contador (para ser testado), ou um teste de
igualdade, e este ´e efetuado antes de come¸car; sendo verdadeiro, efetua as instru¸c˜oes
correspondentes.

Exemplo 8 Assim seria um programa que calcula o quociente e o resto da divis˜ao de
476 por 25, usando o algoritmo da divis˜ao. Neste caso, ser˜ao testados todos os m´ultiplos
de 25, at´e encontrar o maior desses m´ultiplos que seja menor ou igual a 476. O programa
ﬁcaria assim:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

# include < iostream >
using namespace std ;
int main ()
{

int q =0 , r ;
while (( q *25) <=476)
{

cout < <q < < " * 25 = " <<q *25 < < " \ t " ;
q ++;

}
q - -;
r =476 - q *25;
cout < < " \ n \ nDividindo 476 por 25 obtemos :\ n " ;
cout < < " quociente = " <<q < < endl ;
cout < < " resto = " <<r < < endl ;
return 0;

}

A princ´ıpio, o quociente ´e inicializado (q=0) antes do la¸co, e seu produto por 25
´e testado, comparado ao dividendo (476). A cada itera¸c˜ao do la¸co, ´e impresso o produto
de q por 25, e o mesmo ´e incrementado em 1 unidade (q++, que ´e igual a atribui¸c˜ao
q=q+1). Quando q aumenta a ponto do produto ser maior que 476, o la¸co n˜ao inicia, e o
programa segue na pr´oxima linha. Como q aumentou mais do que devia, retorna-se assim
ao valor anterior, subtraindo 1 (q--). Calcula-se ent˜ao o resto com o quociente correto,
e enﬁm imprime-se o resultado. O comando endl pula para a pr´oxima linha, como o

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

34

caractere “\n”. Uma imagem do execut´avel encontra-se abaixo.

Figura 3 – Execut´avel do programa divisao lenta
Fonte: pr´opria.

A verdade ´e que esse programa poderia ter calculado mais r´apido, sem usar o

while, mas usando dois detalhes da linguagem C++. Ficaria assim:

# include < iostream >
using namespace std ;
int main ()
{

1

2

3

4

5

6

7

8

9

10

11

12

}

int q , r ;
q =476/25;
r =476%25;
cout < < " Dividindo 476 por 25 obtemos :\ n " ;
cout < < " quociente = " <<q < < endl ;
cout < < " resto = " <<r < < endl ;
return 0;

Primeiro, as duas vari´aveis s˜ao inteiras (q e r), mas como o resto ´e diferente de
0, signiﬁca que a divis˜ao n˜ao ´e exata, ou seja, o quociente 476/25 tem casas decimais. Em
C++, um n´umero inteiro que recebe um valor decimal s´o registra a parte inteira desse
n´umero. Isto tudo garante que q recebe o quociente da divis˜ao. Em segundo lugar, o
s´ımbolo de porcentagem ´e usado para calcular o resto da divis˜ao, ou seja, podemos us´a-lo
para calcular m´odulo. O que foi usado neste programa alternativo ser´a muito usado no
Cap´ıtulo 4.

(cid:5)

Para encerrar esta se¸c˜ao, o terceiro tipo de la¸co ´e o do-while. Ele ´e muito
semelhante ao while. A diferen¸ca ´e que o programa sempre inicia o la¸co, realizando o
teste ap´os cada itera¸c˜ao. Sua sintaxe ﬁcaria:

1

2

3

4

5

do
{

instrucoes ;
...

} while ( teste ) ;

O detalhe aqui ´e o uso de ponto-e-v´ırgula ap´os os parˆenteses do teste.

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

35

3.3 TOMANDO DECIS ˜OES: IF E ELSE

O objetivo de se programar ´e fazer com que o computador realize tarefas (na
maioria das vezes dispendiosas), e pra isso `as vezes ´e preciso tomar algumas decis˜oes. Isso
signiﬁca que o programa deve saber o que fazer caso determinadas condi¸c˜oes sejam aten-
didas; caso contr´ario, n˜ao realiza aquela(s) instru¸c˜ao(˜oes) espec´ıﬁca(s). Para incrementar
ainda mais, ´e poss´ıvel fazˆe-lo cumprir outros comandos somente na falta da condi¸c˜ao
determinada. Estamos falando dos comandos if e else.

O comando if (se, em inglˆes) tem sintaxe bem simples. Ap´os cham´a-lo no
programa, ´e colocado uma condi¸c˜ao entre parˆenteses, e a instru¸c˜ao seguinte s´o ´e efetuada
caso o teste retorne em verdadeiro, sen˜ao simplesmente a pula. Caso haja mais de uma
instru¸c˜ao (condicional ), s´o agrup´a-las entre chaves.

Exemplo 9 Apresentamos a seguir um programa que conta quantos m´ultiplos de um
certo inteiro a existem entre dois outros inteiros b e c, tais que 1 < a < b < c. Aqui, o
programa deve perguntar ao usu´ario valores para registrar nas trˆes vari´aveis da quest˜ao.
Em seguida procurar quantos m´ultiplos de a est˜ao entre b e c, sendo b < ma < c, ∀m ∈ N,
com m > 1. O programa ﬁcaria assim:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

# include < iostream >
using namespace std ;
int main ()
{

int a ,b ,c , m =2 , n =0;
cout < < " Digite um valor para a : " ;
cin > > a ;
cout < < " \ nDigite um valor para b : " ;
cin > > b ;
cout < < " \ nDigite um valor para c : " ;
cin > > c ;
while (( m * a ) <c )
{

if ( m *a > b ) n ++;
m ++;

}
cout < < " \ n \ nExistem " <<n < < " multiplos de " <<a < < " entre " <<b < < " e " <<c

;

return 0;

}

Ap´os o registro dos trˆes valores, o programa testa, no while, se o dobro de a
´e menor que c, haja vista que 1a=a<b, logo estaria trivialmente fora das condi¸c˜oes; por
isso m inicializa com 2. E se 2a>c, o programa nem entra no la¸co. Supondo 2a<c, a
primeira instru¸c˜ao agora testa se tamb´em ´e maior que b. Se for, acrescenta 1 ao contador
de m´ultiplos n. Cumprindo ou n˜ao a condi¸c˜ao do if, o programa deve testar o pr´oximo

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

36

m´ultiplo, por isso m incrementa em 1 sempre que entra no la¸co. Ap´os isso, o la¸co repete
tantas vezes forem necess´arias para at´e ma ultrapassar c. No ﬁm, ´e exibida a quantidade
de m´ultiplos de a entre b e c. A seguir, uma imagem do execut´avel.

Figura 4 – Execut´avel do programa multiplos
Fonte: pr´opria.

Uma alternativa a este programa, que o tornaria mais completo, ´e se us´assemos
o comando else (sen˜ao, em inglˆes). Isto signiﬁca que ´e poss´ıvel fazer com que o programa
realize certas instru¸c˜oes somente se o teste do if for verdadeiro, e outras determinadas
fun¸c˜oes somente se esse teste for falso. Implementando este comando no programa ante-
rior, ter´ıamos:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

# include < iostream >
using namespace std ;
int main ()
{

int a ,b ,c , m =2 , n =0;
cout < < " Digite um valor para a : " ;
cin > > a ;
cout < < " \ nDigite um valor para b : " ;
cin > > b ;
cout < < " \ nDigite um valor para c : " ;
cin > > c ;
if (2* a < c )
{

while (( m * a ) <c )
{

if ( m *a > b ) n ++;
m ++;

}
if ( n ==0)

cout < < " \ n \ nNao existem multiplos de " <<a < < " entre " <<b < < " e " <<c ;

else

cout < < " \ n \ nExistem " <<n < < " multiplos de " <<a < < " entre " <<b < < " e "

<<c ;

}
else
{

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

37

cout < < " \ n \ nNao existem multiplos de " <<a < < " entre " <<b < < " e " <<c ;

}
return 0;

26

27

28

29

}

Veja que neste caso, temos um teste logo no in´ıcio: o programa s´o testar´a o
la¸co, se 2a for menor que c. Ap´os a contagem no la¸co, o programa compara n com 0 (o
operador == signiﬁca “igual”), e se for igual, assim como se nem entrar no la¸co, exibir´a
que “n˜ao existe multiplos de a entre b e c”. Se n˜ao for n==0, ´e porque tem m´ultiplos, e
ent˜ao ser´a exibida a outra frase com tal quantidade.

Uma segunda alternativa seria usar o resultado proposto em 2.2.1. O programa

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

ﬁcaria bem mais simples:

# include < iostream >
using namespace std ;
int main ()
{

int a ,b ,c , n ;
cout < < " Digite um valor para a : " ;
cin > > a ;
cout < < " \ nDigite um valor para b : " ;
cin > > b ;
cout < < " \ nDigite um valor para c : " ;
cin > > c ;
n =(( c -1) / a ) -( b / a ) ;
if ( n !=0) cout < < " \ n \ nExistem " <<n < < " multiplos de " <<a < < " entre " <<b

< < " e " <<c ;

else cout < < " \ n \ nNao existem multiplos de " <<a < < " entre " <<b < < " e " <<

c ;
return 0;

}

Para concluir, vemos no teste do if um operador l´ogico: N ˜AO, representado
por !=, e usado acima como diferente, ou n˜ao igual. Al´em deste, tamb´em ´e comum o uso
dos operadores l´ogicos E e OU, representados respectivamente por && e ||.

(cid:5)
Um outro comando ´util em C++ ´e o comando switch. Ele pode substituir
os condicionais if-else nos casos em que h´a v´arios caminhos a serem direcionados. Na
sua sintaxe, ele compara a vari´avel (ou express˜ao) em quest˜ao com cada valor constante
declarado em cada case (caso, em inglˆes). Tendo valor igual a constante, o programa
ent˜ao efetua as instru¸c˜oes relativas a esse case. O caso default ´e para quando o teste
n˜ao corresponder a nenhum dos casos declarados. O comando break interrompe o switch,
fazendo com que seja cumprido apenas o que est´a dentro do caso determinado. Sem ele, o
programa efetuar´a as instru¸c˜oes do caso seguinte, e assim por diante, perdendo o sentido
do switch.

Cap´ıtulo 3. Linguagem C++: Noc¸˜oes B´asicas

38

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

switch ( variavel )
{

case valor1 :

instrucoes ;
...
break ;
case valor2 :

instrucoes ;
...
break ;

case ...

instrucoes ;
...
break ;

default :

instrucoes ;
...

}

4 A P´ascoa em Linguagem C++

Para in´ıcio, vamos determinar alguns parˆametros para o in´ıcio dos nossos
c´alculos. Tomaremos como base o ano de 1600, pois foi o primeiro ano que “deixou
de ser bissexto”. Como o dia acrescentado (quando acontece) ´e 29 de fevereiro, esse ser´a
o ´ultimo dia do ano anterior. Ent˜ao o primeiro dia do ano ´e 1o de mar¸co, terminando em
fevereiro, o 12o mˆes. Tomemos tamb´em um n´umero para cada dia da semana, a partir do
0 para o domingo, at´e o 6 para o s´abado.

4.1 CONGRUˆENCIA DE ZELLER

Primeiramente, encontraremos uma express˜ao que determina o primeiro dia
(1o de mar¸co) de um ano Y qualquer. Deﬁniremos aqui zY como sendo esse dia, ou seja:

1o/mar¸co/Y ⇒ zY .

Um ano qualquer inicia 365 dias ap´os o ano anterior, isto ´e, sabendo que
365 ≡ 1 mod 7, um dia da semana depois. No caso do ano anterior ter sido bissexto, ou
seja, ter havido o 29 de fevereiro, teremos 2 dias a mais. Ent˜ao o ano de 1601 come¸ca no
dia z1600 + 1 mod 7 (lembrando que estamos usando n´umeros de 0 a 6 para representar os
dias da semana)1. Da mesma forma, o ano 1602 come¸ca no dia z1600 + 2 mod 7, e 1603
come¸ca no dia z1600 + 3 mod 7. Por´em 1604 come¸ca ap´os um 29 de fevereiro, logo seu
primeiro dia ´e z1600 + 4 + 1 mod 7. Os anos bissextos interferem no c´alculo.

Temos que levar em conta quantos anos bissextos tem entre 1600 e o ano Y .
Baseado na Proposi¸c˜ao 2.2.1, temos que contar a quantidade de m´ultiplos de 4 maiores
que 1600 e menores que ou iguais a Y , e descontar dessa quantidade aqueles que s˜ao
m´ultiplos de 100 e n˜ao s˜ao de 400. No ﬁnal disso, teremos o total de anos bissextos no
intervalo acima. Chamaremos esse n´umero de b. Segue assim:





b =

(cid:21)

(cid:18)(cid:20) Y
4

−

(cid:20)1600
4

(cid:21)(cid:19)

−

(cid:21)

(cid:18)(cid:20) Y
100

−

(cid:20)1600
100

(cid:21)(cid:19)

(cid:21)

(cid:18)(cid:20) Y
400

−

−

(cid:20)1600
400

(cid:21)(cid:19)











(cid:124)

(cid:125)

(cid:124)

(cid:123)(cid:122)
m´ultiplos de 400

(cid:125)

(cid:19)

(cid:124)
(cid:20) Y
4
(cid:20) Y
4

=

=

(cid:123)(cid:122)
m´ultiplos de 4
(cid:21)

− 400 −

(cid:21)

(cid:21)

−

(cid:20) Y
100

(cid:21)

(cid:125)
(cid:18)(cid:20) Y
100
(cid:20) Y
400

+

− 16 −

(cid:21)

− 388.

(cid:123)(cid:122)
m´ultiplos de 100
(cid:20) Y
400

(cid:21)

+ 4

Com isso, determinamos uma express˜ao para b:

1 Essa nota¸c˜ao nos d´a o resto da divis˜ao por 7.

Cap´ıtulo 4. A P´ascoa em Linguagem C++

40

Proposi¸c˜ao 4.1.1 O n´umero de anos bissextos entre 1600 e um certo ano Y ´e dado por

b =

(cid:21)

(cid:20) Y
4

−

(cid:21)

(cid:20) Y
100

+

(cid:21)

(cid:20) Y
400

− 388.

Organizemos agora tudo numa ´unica rela¸c˜ao:

zY = (z1600 + (Y − 1600) + b) mod 7.

(4.1)

Isso signiﬁca que zY ´e dado contando z1600 mais um dia a cada ano que se passa de 1600 at´e
o ano Y (nesse caso, Y −1600), mais um dia para cada ano bissexto (b). Agora, precisamos
de uma referˆencia. Sabendo que o dia 1o de mar¸co de 2017 foi numa quarta-feira, temos

Calculemos b para este ano:

z2017 = 3.

b =

(cid:20)2017
4
b = 101.

(cid:21)

−

(cid:21)

(cid:20)2017
100

+

(cid:21)

(cid:20)2017
400

− 388

Como 101 ≡ 3 mod 7, de (4.2) e (4.3), aplicados em (4.1), temos:

3 = (z1600 + 2017 − 1600 + 101) mod 7

3 = (z1600 + 518) mod 7.

Sabendo que 518 ≡ 0 mod 7, conseguimos ent˜ao deﬁnir z1600:

z1600 ≡ 3 mod 7.

(4.2)

(4.3)

Esse resultado nos indica que o dia da semana de 1o de mar¸co de 1600 tamb´em

foi uma quarta-feira. Podemos agora deﬁnir uma express˜ao para zY :

zY = (3 + Y − 1600 +

(cid:21)

(cid:20) Y
4

−

(cid:21)

(cid:20) Y
100

+

(cid:21)

(cid:20) Y
400

− 388) mod 7.

Como 1600 + 388 ≡ 0 mod 7, concluimos a nossa express˜ao:

Proposi¸c˜ao 4.1.2 O primeiro dia de mar¸co de um ano Y qualquer ´e dado por

(cid:18)

zY =

3 + Y +

(cid:21)

(cid:20)Y
4

−

(cid:21)

(cid:20) Y
100

+

(cid:20) Y
400

(cid:21)(cid:19)

mod 7.

Seguindo daqui, devemos calcular agora o primeiro dia de cada mˆes de um
certo ano Y . Aproveitaremos a nota¸c˜ao anterior: seja zm,Y o primeiro dia do mˆes m do
ano Y . Temos que do dia 1o de um certo mˆes para o dia 1o do mˆes seguinte s˜ao somados
30 ou 31 dias. Por´em,

30 ≡ 2 mod 7 e 31 ≡ 3 mod 7

Cap´ıtulo 4. A P´ascoa em Linguagem C++

41

ent˜ao, na pr´atica, s˜ao somados 2 ou 3 dias ao dia da semana, assim:

z2,Y ≡ (z1,Y + 3) mod 7

z3,Y ≡ (z2,Y + 2) ≡ (z1,Y + 5) mod 7

z4,Y ≡ (z3,Y + 3) ≡ (z1,Y + 8) mod 7 . . .

Resumindo, devemos somar, para cada mˆes, o valor correspondente na tabela

abaixo:

mar
3

abr mai
6

8

jun jul
13
11

ago
16

set
19

out nov dez
26
24
21

jan fev
32
29

Tabela 2 – Constantes da congruˆencia de Zeller, para cada mˆes.
Fonte: pr´opria.

ressaltando que o 3 na coluna de mar¸co “se refere” ao mesmo presente na Proposi¸c˜ao
4.1.2. A seguinte f´ormula emp´ırica nos fornece esses valores para cada m = 1, 2, . . . , 12:
(cid:20)13m − 1
5

(4.4)

1 +

(cid:21)

.

Uma forma de mostrar a validade da express˜ao acima ´e atrav´es do gr´aﬁco das

fun¸c˜oes f, g : R → R, tais que f (x) = 2, 6x + 0, 8 e g(x) = 2, 6x − 0, 2:

Figura 5 – Gr´aﬁco das fun¸c˜oes f (x) = 2, 6x + 0, 8 e g(x) = 2, 6x − 0, 2
Fonte: Geogebra.

A ﬁgura acima nos mostra que os pontos

(1, 3), (2, 6), (3, 8), . . . , (12, 32)

Cap´ıtulo 4. A P´ascoa em Linguagem C++

42

que nos interessam (da tabela acima), estar˜ao abaixo da reta do gr´aﬁco de f , por´em acima
do gr´aﬁco de g.

Substituindo ent˜ao 3 por (4.4) na express˜ao de zY , da Proposi¸c˜ao 4.1.2,

temos:

Proposi¸c˜ao 4.1.3 O primeiro dia do mˆes m de um dado ano Y ´e dado por

zm,Y = 1 +

(cid:21)

(cid:20)13m − 1
5

+ Y +

(cid:21)

(cid:20)Y
4

−

(cid:21)

(cid:20) Y
100

+

(cid:21)

(cid:20) Y
400

mod 7.

E como a cada dia que se passa somamos 1 dia, deﬁnimos aqui zd,m,Y com d

referente ao dia:

zd,m,Y = d +

(cid:21)

(cid:20)13m − 1
5

+ Y +

(cid:21)

(cid:20)Y
4

−

(cid:21)

(cid:20) Y
100

+

(cid:21)

(cid:20) Y
400

mod 7.

Agora, apliquemos na equa¸c˜ao acima a mudan¸ca Y = 100s + y:
(cid:21)
(cid:20)100s + y
(cid:20) 100s + y
400
4

(cid:20)100s + y
100

(cid:20) 13m − 1
5

+100s+y +

−

+

(cid:21)

(cid:21)

(cid:21)

zd,m,Y = d+

mod 7. (4.5)

Observemos o seguinte:

(cid:21)

(cid:20)100s + y
4

−

(cid:21)

(cid:20)100s + y
100

+

(cid:21)

(cid:20)100s + y
400

(cid:104)
25s +

(cid:104)

=

+
(cid:104) s
4
s ´e a quantidade de s´eculos em Y , e y s˜ao os anos remascentes da divis˜ao por

+
(cid:104) y
400

s +
(cid:104) y
100

= 24s +

−
(cid:105)

(4.6)

−

(cid:105)

.

(cid:105)

y
100
(cid:105)
+

(cid:104) s
4
+

(cid:105)

y
400
(cid:105)

(cid:105)

y
4
(cid:104) y
4

100 (portanto menor que este), ent˜ao
(cid:104) y
100

e assim, substituindo em (4.6), temos

(cid:105)

=

(cid:105)

(cid:104) y
400

= 0

24s +

(cid:105)

(cid:104) y
4

−

(cid:105)

(cid:104) y
100

+

(cid:105)

(cid:104) s
4

+

(cid:105)

(cid:104) y
400

= 24s +

(cid:105)

(cid:104) y
4

+

(cid:105)

(cid:104) s
4

agora substituindo na equa¸c˜ao (4.5):

zd,m,Y = d +

(cid:21)

(cid:20)13m − 1
5

+ 100s + y + 24s +

(cid:105)

(cid:104) y
4

+

(cid:105)

(cid:104) s
4

mod 7.

Como 124s ≡ −2s mod 7, ﬁnalizamos a chamada congruˆencia de Zeller:

Teorema 4.1.1 (Congruˆencia de Zeller) Seja a data d/m/Y , onde d, m e Y repre-
sentam dia, mˆes e ano, respectivamente, sendo Y = 100s + y, com s ≥ 16. O dia da
semana correspondente ´e dado por

zd,m,Y = d +

(cid:21)

(cid:20)13m − 1
5

− 2s + y +

(cid:105)

(cid:104) y
4

+

(cid:105)

(cid:104) s
4

mod 7.

Um programa em C++ aplicando a Congruˆencia de Zeller ´e apresentado no

Apˆendice A.

Cap´ıtulo 4. A P´ascoa em Linguagem C++

43

4.2 A P ´ASCOA E A F ´ORMULA DE GAUSS

Primeiramente, precisamos determinar dois valores, a e b, que s˜ao os restos da
divis˜ao do ano por 4 e 7, respectivamente. Para isso, tomando o ano como Y = 100s + y,
assim como foi feito na se¸c˜ao anterior. Temos ent˜ao:

Y = 100s + y ≡ a mod 4 ⇒ y ≡ a mod 4
Y = 100s + y ≡ b mod 7 ⇒ 98s + y ≡ b − 2s mod 7 ⇒ y ≡ b − 2s mod 7.

Essa duas congruˆencias lineares formam o seguinte sistema:

y ≡ a mod 4
y ≡ b − 2s mod 7

(cid:41)

(4.7)

Pelo Teorema Chinˆes dos Restos, temos M = 4 · 7 = 28, M1 = 7 e M2 = 4,

logo

Temos que

y = 7 · ay1 + 4 · (b − 2s)y2 mod 28.

(4.8)

7y1 ≡ 1 mod 4 ⇒ y1 = 3
4y2 ≡ 1 mod 7 ⇒ y2 = 2.

E assim, aplicando em (4.8)

y ≡ 21a + 8b − 16s mod 28 ⇒ y = 21a + 8b − 16s + 28k, k ∈ Z

que ´e a solu¸c˜ao geral do sistema (4.7). Aproveitando este resultado, temos

(cid:105)

(cid:104) y
4

= 5a + 2b − 4s + 7k ⇒

(cid:105)

(cid:104) y
4

≡ 5a + 2b − 4s mod 7.

Somando com a segunda equa¸c˜ao de (4.7), resulta em

y +

(cid:105)

(cid:104) y
4

≡ 5a + 3b − 6s mod 7.

(4.9)

Vamos substituir (4.9) na f´ormula de Zeller (Teorema 4.1.1):

zd,m,Y = d +

(cid:21)

(cid:20) 13m − 1
5

− 2s + 5a + 3b − 6s +

(cid:105)

(cid:104) s
4

mod 7

e como −8s ≡ 6s mod 7, ent˜ao

zd,m,Y = d +

(cid:21)

(cid:20)13m − 1
5

+ 5a + 3b + 6s +

(cid:105)

(cid:104) s
4

mod 7.

Interessa-nos encontrar um domingo de mar¸co, logo usaremos na congruˆencia
acima zd,m,Y = 0, m = 1 e d = D, que, quando encontrarmos, ser´a a data da P´ascoa,
resultando assim em:

⇒ 0 = D +

(cid:21)

(cid:20) 13 · 1 − 1
5

+ 5a + 3b + 6s +

(cid:105)

(cid:104) s
4

mod 7

⇒ D = −2 − 5a − 3b − 6s −
(cid:104) s
4

⇒ D = 5 + 2a + 4b + s −

mod 7

(cid:105)

(cid:104) s
4
mod 7.

(cid:105)

(4.10)

Cap´ıtulo 4. A P´ascoa em Linguagem C++

44

Se a quest˜ao fosse encontrar “o sexto domingo depois de 1o mar¸co”, por exem-
plo, j´a ter´ıamos ferramentas suﬁcientes, mas o c´alculo da P´ascoa n˜ao leva em conta apenas
o calend´ario solar (para o equin´ocio de primavera), mas tamb´em o calend´ario lunar (para
a lua cheia). Ent˜ao temos mais o que considerar.

Meton foi um matem´atico e astrˆonomo ateniense, criador do ciclo metˆonico.
Segundo esse ciclo, o tempo de 235 luna¸c˜oes ´e quase o mesmo de 19 anos tr´opicos. Isto
´e, ap´os esse per´ıodo, as fases da lua caem no mesmo dia, ou muito pr´oximo disso. Cada
ano ocupa um lugar no ciclo, e a esse lugar denominamos n´umero dourado. Seja um dos
ciclos come¸cados no ano 0, ent˜ao o n´umero dourado de um ano Y ´e o resto c da divis˜ao
deste por 19:

Y ≡ c mod 19.

(4.11)

Outra deﬁni¸c˜ao a se fazer ´e a chamada idade da lua, ou, como chamaremos
neste trabalho, a “epacta”. A epacta est´a relacionada ao dia 1o de mar¸co. Logo num ano
em que a lua nova acontece nesta data, ent˜ao a epacta deste ano ´e 0.

Segundo a Igreja, no chamado ano 0 desta era, um dos ciclos come¸cou e a
epacta ´e 8. O primeiro ano lunar do ciclo tem 354 dias, e assim o ano seguinte dever´a ter
a epacta igual a 8 + 11 = 19 (11 dias a mais pela diferen¸ca entre os anos solar e lunar).
No ano seguinte, a epacta ´e 19 + 11 = 30, nesse caso 0; subtraimos para obter um inteiro
positivo menor que 30. Assim, representamos a epacta por E, onde ela seria expressa por

E ≡ 8 + 11c mod 30.

(4.12)

Ainda assim o calend´ario apontava as fases da lua 4 dias depois. O motivo ´e a
disparidade entre as 235 luna¸c˜oes e os 19 anos solares2 sendo necess´ario incluir a chamada
“equa¸c˜ao solar ”, a qual referia os anos bissextos apenas `aqueles que fossem seculares
m´ultiplos de 400. Nos outros casos (seculares n˜ao-bissextos), subtrai-se 1 das epactas. J´a
a denominada “equa¸c˜ao lunar3” soma 1 dia a cada 300 anos, sete vezes, mais 1 dia 400
anos ap´os isso, completando um ciclo de 2500 anos. As express˜oes abaixo representam as
corre¸c˜oes:

equa¸c˜ao solar ⇒

equa¸c˜ao lunar ⇒

(cid:105)

(cid:104) s
− s;
4
(cid:20)8s + 13
25

(cid:21)

.

A equa¸c˜ao (4.12), com as express˜oes acima, ﬁca assim:

E ≡ 8 + 11c +

(cid:105)

(cid:104) s
4

− s +

(cid:21)

(cid:20)8s + 13
25

mod 30.

(4.13)

235 luna¸c˜oes = 6939, 688 dias e 19 anos solares = 6939, 602 dias, em m´edia.

2
3 Assim como foi feito na Figura 5, na se¸c˜ao anterior, ´e poss´ıvel mostrar graﬁcamente a validade da

express˜ao abaixo.

Cap´ıtulo 4. A P´ascoa em Linguagem C++

45

A lua nova pascal sempre acontece no dia 31 − E de mar¸co. Chamaremos de

N essa data:

N = 31 − E ≡ 31 − 8 − 11c −

(cid:105)

(cid:104) s
4

⇒ N ≡ 23 + 19c −

(cid:105)

(cid:104) s
4

+ s −

+ s −

(cid:20)8s + 13
25
(cid:21)
(cid:20) 8s + 13
25

(cid:21)

mod 30

mod 30.

Sabemos que a lua cheia acontece 13 dias ap´os isso. Chamaremos essa data de

P , determinada por:

P = N + 13 ≡ 13 + 23 + 19c −

(cid:105)

(cid:104) s
4

+ s −

(cid:21)

(cid:20)8s + 13
25

mod 30

⇒ P ≡ 6 + 19c −

(cid:105)

(cid:104) s
4

+ s −

(cid:21)

(cid:20) 8s + 13
25

mod 30.

A data da primeira lua cheia no dia 21 de mar¸co ou ap´os esta data ´e dada por:

d = P − 21 ≡ 6 − 21 + 19c −

(cid:105)

(cid:104) s
4

⇒ d ≡ 15 + 19c −

(cid:105)

(cid:104) s
4

+ s −

⇒ d ≡ 19c + W mod 30

(cid:21)

mod 30

+ s −

(cid:20)8s + 13
25
(cid:21)
(cid:20)8s + 13
25

mod 30

(4.14)

(cid:105)

(cid:104) s
4

−

(cid:20)8s + 13
25

(cid:21)

.

onde d representa o resto da divis˜ao de 19c + W por 30 e W = 15 + s −

Agora, vamos encontrar o primeiro domingo ap´os essa data, ent˜ao devemos, a princ´ıpio,
somar 1 (para o pr´oximo dia) a P , ent˜ao

P = d + 22.

(4.15)

Na congruˆencia (4.10), usando (4.14) e (4.15) obtemos:

e = D − d − 22

⇒ e ≡ 5 − 22 + 2a + 4b − d + s −

(cid:105)

(cid:104) s
4

mod 7

⇒ e ≡ 2a + 4b + 6d + U mod 7

(4.16)

onde, a partir deste ponto, tomaremos o resultado da divis˜ao de 2a + 4b + 6d + U por 30
(cid:105)
(cid:104) s
como e, sendo U = 4 + s −
. Isolando D na primeira congruˆencia, temos a express˜ao
4
ﬁnal que usaremos para determinar o domingo da P´ascoa:

D = 22 + d + e.

(4.17)

Calculamos para a P´ascoa em mar¸co, mas tomamos abril como uma extens˜ao,

com as seguintes considera¸c˜oes:

i) se 22 + d + e ≤ 31, a P´ascoa acontece em mar¸co; e

Cap´ıtulo 4. A P´ascoa em Linguagem C++

46

ii) se 22 + d + e > 31, tomamos D = d + e − 9, e a P´ascoa ser´a em abril.

Entretanto, temos duas observa¸c˜oes aqui, devido ao fato de que nas epactas
24 e 25, o intervalo entre duas luas novas ´e 29 dias, enquanto que nas outras contamos 30
dias.

A primeira ´e que se for epacta 24, temos:

(4.13) ⇒ 24 ≡ 8 + 11c +

(cid:105)

(cid:104) s
4

− s +

⇒ 24 − 8 ≡ 11c +

⇒ −16 ≡ 19c −

(cid:105)

(cid:105)

(cid:104) s
4
(cid:104) s
4

− s +

+ s −

(cid:21)

mod 30

(cid:20)8s + 13
25
(cid:21)
(cid:20)8s + 13
25
(cid:20)8s + 13
25

(cid:21)

mod 30

mod 30

(4.14) ⇒ d ≡ 15 − 16 ≡ −1 ≡ 29 mod 30

logo, d = 29. Neste caso, d ´e subtra´ıdo de 1, o que faz e somar 1. Se o resultado de e + 1
for 6, a data da P´ascoa que seria 29 + 6 − 9 = 26 ser´a uma semana antes, em 19 de abril.
Se e + 1 < 6, nada altera.

A segunda exce¸c˜ao ´e na epacta 25, o que por c´alculos an´alogos aos de cima,
acarretaria d = 28, e isso se o n´umero dourado c ≥ 11. Nada ´e alterado se e (cid:54)= 6, mas se
e = 6, ent˜ao a data da P´ascoa tamb´em ´e antecipada em uma semana, ﬁcando em 18 de
abril.

Agora, tomando (4.7), (4.11), (4.14), (4.16), (4.17) e as duas exce¸c˜oes supra-

citadas, resumamos tudo na F´ormula de Gauss para o cˆomputo da P´ascoa:

Teorema 4.2.1 (F´ormula de Gauss) Seja Y = 100s + y um ano maior que ou igual
a 1600. A data D da P´ascoa deste ano ´e dada pela express˜ao D = 22 + d + e de mar¸co
ou D = d + e − 9 de abril, onde:

i) Y ≡ a mod 4;

ii) Y ≡ b mod 7;

iii) Y ≡ c mod 19;

iv) 19c + W ≡ d mod 30;

v) 2a + 4b + 6d + U ≡ e mod 7
(cid:20)8s + 13
25

com W = 15 + s −

(cid:104) s
4

−

(cid:105)

(cid:21)

e U = 4 + s −

(cid:105)
. Por´em:

(cid:104) s
4

1. se d = 29 e e = 6, ent˜ao a P´ascoa ser´a em 19 de abril;

2. se d = 28, e = 6 e c ≥ 11, ent˜ao a P´ascoa ser´a em 18 de abril.

Cap´ıtulo 4. A P´ascoa em Linguagem C++

47

As express˜oes de W e U ﬁcam destacadas, porque seus valores mant´em-se em
nos anos de um mesmo s´eculo, podendo at´e repetir para pr´oximo. Por exemplo, entre
os anos 1900 e 2099, temos W = 24 e U = 19. Por ﬁm, relembrando da importˆancia
da P´ascoa para a liturgia crist˜a, por exemplo, ela ´e referˆencia para a determina¸c˜ao das
outras festividades m´oveis. As mais populares, resumidas na tabela:

Festividade
Cinzas
Sexta da Paix˜ao
Corpo de Cristo

data (relativa a P´ascoa), em dias
46, antes
2, antes
60, depois

Tabela 3 – Principais festividades cat´olicas relativas `a P´ascoa.
Fonte: [12].

al´em da Quaresma, referente ao per´ıodo de 40 dias, que se inicia na quarta-feira de Cinzas.

4.3 A F ´ORMULA DE GAUSS EM C++

Agora vamos traduzir a f´ormula de Gauss, deduzida na se¸c˜ao anterior, para a

linguagem de programa¸c˜ao C++. Primeiramente, o programa ﬁcaria o seguinte:

# include < iostream >
using namespace std ;
int main ()
{

int a ,b ,c ,d ,e , ano , s ;
cout < < " \ n \ tALGORITMO DE GAUSS PARA O COMPUTO DA PASCOA \ n \ n " ;
cout < < " Insira um ano maior que ou igual a 1600: " ;
cin > > ano ;

s = ano /100;
a = ano %4;
b = ano %7;
c = ano %19;
d =(19* c +15+ s -( s /4) -((8* s +13) /25) ) %30;
e =(2* a +4* b +6* d +4+ s -( s /4) ) %7;

if ( d ==29 && e ==6) // Excecao 1

cout < < " \ nA Pascoa desse ano eh no dia 19 de abril .\ n " ;

else

if ( d ==28 && e ==6 && c >=11) // Excecao 2

cout < < " \ nA Pascoa desse ano eh no dia 18 de abril .\ n " ;

else

if (( d + e +22) <=31)

cout < < " \ nA Pascoa desse ano eh no dia " <<d + e +22 < < " de marco .\ n " ;

else

cout < < " \ nA Pascoa desse ano eh no dia " <<d +e -9 < < " de abril .\ n " ;

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

Cap´ıtulo 4. A P´ascoa em Linguagem C++

48

27

28

29

}

return 0;

No in´ıcio do programa, ´e pedido um ano maior que ou igual a 16004 e em

seguida armazenado o seu valor na vari´avel ano.

Na segunda parte do programa, s˜ao efetuados os c´alculos (de acordo com
F´ormula de Gauss) e registrados os valores em s, a, b, c, d e e, estes dois ´ultimos j´a com
as express˜oes de W e U inseridas.

Na pr´oxima parte, s˜ao testadas as exce¸c˜oes, em trˆes if aninhados, e com uso
do comando else, pois garante que s´o efetuar´a uma das quatro instru¸c˜oes, para o ano
inserido. Primeiro testa a exce¸c˜ao 1 (se d= 29 e e= 6), com uso do operador l´ogico E
(&&), e, se n˜ao, testa a 2, (se d= 28, e= 6 e c≥ 11), onde as datas ser˜ao 19 ou 18 de abril,
respectivamente. Por ´ultimo, caso n˜ao atenda `a uma das exce¸c˜oes, ou seja, o caso geral, o
programa testa no terceiro if se a data ser´a em mar¸co (d+e+22≤ 31) ou, se n˜ao, em abril.
Neste programa n˜ao ´e preciso declarar uma outra vari´avel (que seria D, por
exemplo, em referˆencia a F´ormula de Gauss), pois ela s´o serviria para armazenar o re-
sultado da data a ser mostrada na frase ﬁnal “A Pascoa desse ano ...”. Ao inv´es
disso, a express˜ao que daria o valor de D ´e calculada e exibida junto do texto apropriado.
Poderia-se ter usado essa vari´avel, e ter sido feito o teste com rela¸c˜ao ao mˆes, mas aumen-
taria o tamanho do programa. Contudo, da forma como est´a, n˜ao foi necess´ario reservar
mais outra parte da mem´oria para outra vari´avel do programa. Seguem imagens do exe-
cut´avel, calculando a data da P´ascoa para o ano de 2017 (atual), 2049 e 2076 (exce¸c˜oes),
respectivamente.

Figura 6 – Execut´avel do programa Pascoa, com a data para 2017
Fonte: pr´opria.

Este texto encerra-se com uma vers˜ao mais completa deste programa, elen-
cando as festividades mostradas na Tabela 3, com exce¸c˜ao da Sexta-feira da Paix˜ao. Por
ser apenas 2 dias antes do domingo de P´ascoa, o seu c´alculo ´e trivial e dispens´avel, e
aumentaria ainda mais o tamanho do programa.

1

# include < iostream >

4 Devido o uso da Congruˆencia de Zeller para a dedu¸c˜ao da F´ormula de Gauss.

Cap´ıtulo 4. A P´ascoa em Linguagem C++

49

Figura 7 – Execut´avel do programa Pascoa, com a data para 2049
Fonte: pr´opria.

Figura 8 – Execut´avel do programa Pascoa, com a data para 2076
Fonte: pr´opria.

using namespace std ;
int main ()
{
int a ,b ,c ,d ,e , D =19 , ano ,s , mpas =4 , mcinz =2 , mcc =6 , bi =0 , exc =0 , cinz , cc ;

cout < < " \ n \ tFESTIVIDADES CATOLICAS MOVEIS \ n \ n " ;
cout < < " Insira um ano maior que ou igual a 1600: " ;
cin > > ano ;

s = ano /100;
a = ano %4;
b = ano %7;
c = ano %19;
d =(19* c +15+ s -( s /4) -((8* s +13) /25) ) %30;
e =(2* a +4* b +6* d +4+ s -( s /4) ) %7;

// coeficientes da
// formula de Gauss

if ( d ==29 && e ==6) // Excecao 1

exc ++;

else if ( d ==28 && e ==6 && c >=11) { // Excecao 2

D - -;
exc ++;}

else if (( d + e +22) <=31)

// casos gerais

D = d + e +22;

else

D = d +e -9;

if (( ano %4==0 && ano %100!=0) || ( ano %400==0) ) // teste do dia

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

Cap´ıtulo 4. A P´ascoa em Linguagem C++

50

bi =1;

// 29 de fevereiro

cc =D -1;
if ( exc ==1) {

// soh muda no 3 o caso
// teste do caso

cinz =D -15;
mcinz ++;}

else if (( d + e +22) <=31) {

mpas - -;
cinz =D -18+ bi ;
mcc - -;}

else if (( d +e -9) ==1) {

cinz =14;
cc =31;
mcc - -;}

else if (( d +e -9) <=15)

cinz = D +13+ bi ;

else {

cinz =D -15;
mcinz ++;}

cout < < " \ nQuarta - feira de Cinzas : " << cinz < < " / " << mcinz ;
cout < < " \ nPascoa : " <<D < < " / " << mpas ;
cout < < " \ nCorpo de Cristo : " <<cc < < " / " << mcc < < " \ n " ;

return 0;

}

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

5 Considera¸c˜oes Finais

´E esperado que um aluno de ensino m´edio, ap´os a leitura deste trabalho, esteja
melhor preparado nos seus estudos sobre algoritmos e linguagens de programa¸c˜ao, e nos
t´opicos estudados e d´uvidas recorrentes de aritm´etica. A verdade ´e que muitos alunos de
gradua¸c˜ao da ´area de inform´atica, que estudam programa¸c˜ao, tem muitas diﬁculdades em
escrever programas simples pela inseguran¸ca em t´opicos de matem´atica, principalmente
aritm´etica e ´algebra, que tanto se discute na escola. Este texto vem auxiliar nesse sentido,
trazendo o calend´ario das festas m´oveis como um tema bem instigante, que gera perguntas
e (o melhor) conjecturas a respeito do seus mecanismos aparentemente “obscuros”. Os
exemplos aqui tratados vem mostrar aplica¸c˜oes simples de matem´atica, e sua an´alise pode
responder d´uvidas e at´e remover bloqueios pr´e-existentes. As referˆencias usadas para a
constru¸c˜ao desse texto tem t´opicos interessant´ıssimos sobre Hist´oria, F´ısica, Astronomia,
Teologia, Programa¸c˜ao e ´e claro, a bela Matem´atica, portanto, s˜ao ´otimas indica¸c˜oes.

Apˆendice – C´alculo do dia da semana de
uma data qualquer com C++

Vamos escrever um programa que retorne o dia da semana de uma data in-
formada pelo usu´ario, que alerte sobre “bissextos inexistentes”. Ser´a usado apenas os
t´opicos discutidos no texto. O programa ﬁcaria assim:

# include < iostream >
using namespace std ;
int main ()
{

int dia , mes , ano ,z , bi =0 ,y , c ;
cout < < " Digite uma data valida , lembrando dos anos bissextos !\ n " ;
cout < < " Comecando pelo dia : " ;
cin > > dia ;
cout < < " \ nAgora o mes : " ;
cin > > mes ;
cout < < " \ nPor fim o ano : " ;
cin > > ano ;
if (( ano %4==0 && ano %100!=0) || ( ano %400==0) ) // teste do dia "29"

bi =1;

if ( bi ==0 && dia ==29 && mes ==2)

cout < < " \ n \ nFevereiro nao tem dia 29 para o ano inserido !\ n \ n " ;

// " Ajuste do mes "

else {

if ( mes <=2) {
mes +=10;
ano - -;

}
else

mes -=2;

c = ano /100;
y = ano %100;

z =( dia +((13* mes -1) /5) -2* c + y +( y /4) +( c /4) ) %7;

switch ( z ) {
case 0:

cout < < " \ n \ nDomingo \ n \ n " ;
break ;

case 1:

cout < < " \ n \ nSegunda - feira \ n \ n " ;
break ;

case 2:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

Apˆendice – C´alculo do dia da semana de uma data qualquer com C++ 53

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

cout < < " \ n \ nTerca - feira \ n \ n " ;
break ;

case 3:

cout < < " \ n \ nQuarta - feira \ n \ n " ;
break ;

case 4:

cout < < " \ n \ nQuinta - feira \ n \ n " ;
break ;

case 5:

cout < < " \ n \ nSexta - feira \ n \ n " ;
break ;

case 6:

cout < < " \ n \ nSabado \ n \ n " ;
break ;

}

}
return 0;

}

O programa usa explicitamente a f´ormula de Zeller com as vari´aveis dia, m^es

e ano, armazenando o seu valor na vari´avel z.

Na linha 29 come¸ca o “teste do dia 29”. Na primeira parte, ano deve ser
m´ultiplo de 4 E N ˜AO deve ser de 100, OU ent˜ao deve ser m´ultiplo de 400, condi¸c˜oes
essas para o ano ser bissexto, e sendo satisfeitas, atribuem a bi o valor 1, para testar
o pr´oximo if. Caso n˜ao seja bissexto, bi continua com o valor 0 (pr´e-inicializado), e o
programa testa a pr´oxima condi¸c˜ao, fundamental para o resto do programa. Caso as trˆes
condi¸c˜oes sejam verdadeiras (b = 0, dia = 29 e mes = 2), o programa acusa que o ano
declarado n˜ao ´e bissexto, e portanto, n˜ao aceita dia 29 de fevereiro, e encerra.

Observa-se que o restante do programa s´o acontecer´a se o teste anterior resultar
em falso, pois n˜ao faria sentido n˜ao ter o dia 29 de fevereiro do ano em quest˜ao, e mesmo
assim o programa retornar um dia da semana1. Isso se deve ao uso do comando else,
como explicado na Se¸c˜ao 3.3. Se passar neste teste, o programa deve “ajustar” o mˆes
para o formato que a f´ormula de Zeller exige (mar¸co = 1, abril = 2,. . . , com janeiro e
fevereiro pertencendo ao ano anterior). Assim, se for mes igual a 1 ou 2, soma-se 10, e
ano subtrai 1 de seu valor. Se n˜ao for (mes ≥ 3), apenas reduz-se em 2.

Em seguida, o programa armazena em c a parte inteira da divis˜ao de ano por

100 (n´umero de s´eculos), e em y o resto dessa divis˜ao (anos remanescentes).

Ent˜ao calcula o dia pela f´ormula de Zeller, armazenando-o em z. Depois usa
o comando switch, que analisa cada uma das poss´ıveis respostas. Isso tamb´em poderia

1 Por deﬁni¸c˜ao, a f´ormula de Zeller retorna um valor entre 0 e 6, inclusive, para valores v´alidos de dia,
mˆes e ano, mas, na pr´atica, retornar´a um dos valores para qualquer inteiro inserido nas vari´aveis.
Para o C++, em especial para o programa acima, retornaria tais valores at´e para vari´aveis decimais!
A nossa garantia, pelo menos para este ´ultimo caso, ´e a deﬁni¸c˜ao das vari´aveis como sendo inteiras;
um decimal lido, ser´a armazenado apenas a sua parte inteira.

Apˆendice – C´alculo do dia da semana de uma data qualquer com C++ 54

ser feito com v´arios comandos if aninhados. O case default n˜ao foi necess´ario neste
programa, pois z s´o possui os valores de 0 a 6 como poss´ıveis resultados. Abaixo, uma
imagem do execut´avel, testando a data 30/07/2017.

Figura 9 – Execut´avel do programa zeller
Fonte: pr´opria.

REFERˆENCIAS

[1] ALENCAR FILHO, Edgard de. Teoria elementar dos n´umeros. S˜ao Paulo: No-

bel, 1981.

[2] ALEXANDER, Amir. Inﬁnitesimal: A teoria matem´atica que revolucionou o

mundo. Rio de Janeiro: Zahar, 2016.

E

[3] ALGORITMOS
em:

ESTRUTURAS
<http://homepages.dcc.ufmg.br/

DE

DADOS

pon´ıvel
10/ComputadorSimpliﬁcado/computador-simpliﬁcado.html>. Acesso
maio 2017.

I.

Dis-
rodolfo/aedsi-2-
21
em:

[4] CHERMAN, Alexandre. O tempo que o tempo tem: Por que o ano tem 12 meses

e outras curiosidades sobre o calend´ario. Rio de Janeiro: Zahar, 2008.

[5] DAVIS, Stephen R. Come¸cando a programar em C++ para leigos. Rio de

Janeiro: Alta Books, 2011. (Cole¸c˜ao Para Leigos)

[6] DE ABREU, Maria Youssef; DUR ˜AO, Adja Balbino DE A. B. Um Pequeno
Gloss´ario Terminol´ogico Bil´ıngue Hebraico-Portuguˆes da P´ascoa Judaica.
Signum: Estudos da Linguagem. vol. 9. n. 2. p. 27–43. 2006.

[7] HEFEZ, Abramo. Aritm´etica. 1. ed. 2. reimp. Rio de Janeiro: SBM, 2014. (Cole¸c˜ao

PROFMAT)

[8] MACHADO, Rubens. Data da p´ascoa e ano bissexto. Dispon´ıvel em:
<http://www.astro.iag.usp.br/ rgmachado/other/pascoa.html>. Acesso em:
05
maio 2017.

[9] MARQUES, Manuel Nunes. Origem e evolu¸c˜ao do nosso calend´ario. Dispon´ıvel
em:<http://www.mat.uc.pt/ helios/Mestre/H01orige.htm>. Acesso em: 30 maio
2017.

[10] MIZRAHI, Victorine Viviane. Treinamento em linguagem C++, m´odulo 1. 2.

ed. S˜ao Paulo: Pearson Prentice Hall, 2006.

[11] PAPA

GREG ´ORIO

XIII.

INTER GRAVISSIMAS.

Dispon´ıvel

<http://www.bluewaterarts.com/calendar/NewInterGravissimas.htm>.
em: 05 maio 2017.

em:
Acesso

[12] PAR ´OQUIA

SANTO

ANT ˆONIO

DE

P ´ADUA.

Dispon´ıvel

em:

<http://www.psantoantonio.org.br/calendario.htm>. Acesso em: 01 junho 2017.

Referˆencias

56

[13] PAULINAS. P´ascoa. Dispon´ıvel em: <http://www.ecclesia.pt/catolicopedia/>.

Acesso em: 14 maio 2017.

[14] PEREIRA, Jos´e Ilhano da Silva. Teoria dos N´umeros e a P´ascoa. In: XIII
SEMANA DE INICIAC¸ ˜AO CIENT´IFICA DA URCA. Anais... 2011. Crato: URCA,
2011.

[15] SIDKI, Said. Introdu¸c˜ao `a Teoria dos N´umeros. 1. ed. Rio de Janeiro: IMPA,

1975.

