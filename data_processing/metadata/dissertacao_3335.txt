 UNIVERSIDADE FEDERAL DO CEARÃ 

CENTRO DE CIÃŠNCIAS 

DEPARTAMENTO DE MATEMÃTICA 

PROGRAMA DE PÃ“S-GRADUAÃ‡ÃƒO EM MATEMÃTICA EM REDE NACIONAL 

RAIMUNDO INÃCIO NETO 

O ALGORITMO GANANCIOSO: UMA INTRODUÃ‡ÃƒO Ã€ TEORIA DOS 

MATRÃ“IDES 

FORTALEZA 

2023 

RAIMUNDO INÃCIO NETO 

O ALGORITMO GANANCIOSO: UMA INTRODUÃ‡ÃƒO Ã€ TEORIA DOS MATRÃ“IDES 

DissertaÃ§Ã£o  apresentada  ao  Programa  de 
PÃ³s-GraduaÃ§Ã£o  em  MatemÃ¡tica  em  Rede 
Nacional  (PROFMAT)  do  Departamento  de 
MatemÃ¡tica  da  Universidade  Federal  do 
CearÃ¡,  como  requisito  parcial  Ã   obtenÃ§Ã£o  de 
tÃ­tulo  de  mestre  em  MatemÃ¡tica.  Ãrea  de 
ConcentraÃ§Ã£o: Ensino de MatemÃ¡tica. 

Orientador: Prof. Dr. Marcos Ferreira de Melo. 

FORTALEZA 

2023 

Dados Internacionais de CatalogaÃ§Ã£o na PublicaÃ§Ã£o 

Universidade Federal do CearÃ¡
Sistema de Bibliotecas
Gerada automaticamente pelo mÃ³dulo Catalog, mediante os dados fornecidos pelo(a) autor(a)

I32a

InÃ¡cio Neto, Raimundo.
    O algoritmo ganancioso : uma introduÃ§Ã£o Ã  teoria dos matrÃ³ides / Raimundo InÃ¡cio Neto. â€“ 2023.
    25 f. : il. color.

     DissertaÃ§Ã£o (mestrado) â€“ Universidade Federal do CearÃ¡, Centro de CiÃªncias, Departamento de
MatemÃ¡tica, Programa de PÃ³s-GraduaÃ§Ã£o em MatemÃ¡tica em Rede Nacional, Fortaleza, 2023.
     OrientaÃ§Ã£o: Prof. Dr. Marcos Ferreira de Melo.

1. MatrÃ³ides. 2. DependÃªncia linear. 3. Matrizes (matemÃ¡tica). 4. Teoria dos grafos. 5. Algoritmo

ganancioso. I. TÃ­tulo.

CDD 510

RAIMUNDO INÃCIO NETO 

O ALGORITMO GANANCIOSO: UMA INTRODUÃ‡ÃƒO Ã€ TEORIA DOS MATRÃ“IDES 

DissertaÃ§Ã£o apresentada ao Programa de PÃ³s- 
GraduaÃ§Ã£o  em  MatemÃ¡tica  em  Rede  Nacional 
do  Departamento 
da 
Universidade Federal do CearÃ¡, como requisito 
parcial  Ã   obtenÃ§Ã£o  do  tÃ­tulo  de  mestre  em 
MatemÃ¡tica.  Ãrea  de  concentraÃ§Ã£o:  Ensino  de 
MatemÃ¡tica 

de  MatemÃ¡tica 

Aprovada em 20/01/2023. 

BANCA EXAMINADORA 

________________________________________ 
Prof. Dr. Marcos Ferreira de Melo (Orientador) 

Universidade Federal do CearÃ¡ (UFC) 

_________________________________________ 
Prof. Dr. Marcelo Ferreira de Melo  

Universidade Federal do CearÃ¡ (UFC) 

_________________________________________ 
Prof. Dr. Ã‚ngelo Papa Neto 

Instituto Federal de EducaÃ§Ã£o, CiÃªncia e Tecnologia do CearÃ¡ (IFCE) 

Este trabalho Ã© dedicado ao meu avÃ´ Raimundo 

InÃ¡cio (in memoriam), maior exemplo de um ser 

humano Ã­ntegro e Ã©tico. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

A Deus por ter me dado saÃºde e forÃ§a para superar as dificuldades. 

A esta Universidade, seu corpo docente, direÃ§Ã£o e administraÃ§Ã£o que me deram a 

oportunidade de fazer o curso. 

Aos professores pelas orientaÃ§Ãµes ao longo do curso. 

Ã€ minha famÃ­lia, que em todos os momentos me apoiaram e que ao longo de toda 

a minha formaÃ§Ã£o sempre me incentivaram nos momentos de fraqueza e serviram de alento nos 

momentos difÃ­ceis. 

Aos companheiros de curso, pela ajuda mÃºtua em percorrer esse caminho. 

 
 
 
 
 
 
 
 
 
â€œA matemÃ¡tica, vista corretamente, possui nÃ£o 

apenas verdade, mas tambÃ©m suprema beleza - 

uma beleza fria e austera, como a da escultura.â€ 

(RUSSELL) 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

Em matemÃ¡tica, um matrÃ³ide Ã© uma estrutura apresentada como uma generalizaÃ§Ã£o da noÃ§Ã£o  

de independÃªncia  linear.  EstÃ¡,  portanto,  naturalmente  ligado  Ã  Ã¡lgebra  linear,  mas  tambÃ©m 

Ã  teoria dos grafos, ao algoritmo ganancioso e Ã  geometria. (Para vÃ¡rias questÃµes relacionadas 

com representaÃ§Ã£o). Este trabalho visa estabelecer explicitamente qual a relaÃ§Ã£o dessa estrutura 

com  o  algoritmo  ganancioso.  Partindo  de  problemas  que  exigem  uma  soluÃ§Ã£o  otimizada, 

definimos o conceito de matrÃ³ide e suas propriedades. Em seguida serÃ£o demonstradas atravÃ©s 

de  teoremas  e  exemplos  as  relaÃ§Ãµes  com  matrizes  e  grafos,  assim  como  alguns  tipos  de 

matrÃ³ides. Por fim, serÃ¡ demonstrado o teorema que consolida a ligaÃ§Ã£o com o algoritmo. 

Palavras-chave:  matrÃ³ides;  dependÃªncia  linear;  matrizes  (matemÃ¡tica);  teoria  dos  grafos; 

algoritmo ganancioso. 

 
 
 
 
 
 
 
 
 
ABSTRACT 

In mathematics, a matroid is a structure presented as a general framework for the concept of 

linear independence. It is therefore naturally linked to linear algebra, but also to graph theory, 

the greedy algorithm and geometry. (For various questions related to representation). This work 

aims to explicitly establish the relationship of this structure with the greedy algorithm. Starting 

from  problems  that  require  an  optimized  solution,  we  define  the  concept  of  matroid  and  its 

properties. Next, relations with matrices and graphs, as well as some types of matroids, will be 

demonstrated  through  theorems  and  examples.  Finally,  the  theorem  that  consolidates  the 

connection with the algorithm will be demonstrated. 

Keywords:  matroids;  linear  dependence;  matrices  (mathematics);  graph  theory;  greedy 

algorithm.  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1  âˆ’ Grafo representante das estradas entre cidades...............................................  12 

Figura 2  âˆ’ Exemplo de grafo............................................................................................  14 

Figura 3  âˆ’ O ciclo Ã© um grafo que satisfaz o circuito eliminatÃ³rio do axioma (C3)..........  19 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÃRIO 

1 

2 

2.1 

2.2 

3 

INTRODUÃ‡ÃƒO..................................................................................................  10 

MATRÃ“IDES.....................................................................................................  13 

DefiniÃ§Ã£o de MatrÃ³ides......................................................................................  15 

MatrÃ³ides Pesados..............................................................................................  21 

CONCLUSÃƒO....................................................................................................  24 

REFERÃŠNCIAS.................................................................................................  25 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 10 

1 INTRODUÃ‡ÃƒO 

Em  geral,  quando  temos  que  fazer  escolhas,  tendemos  a  escolher  aquelas  que 

maximizam  nossos  ganhos  e/ou  minimizam  nossas  perdas.  Mas  hÃ¡  problemas  em  que  suas 

soluÃ§Ãµes decorrem de uma sÃ©rie de escolhas sucessivas, e ao fazermos sempre a escolha onde 

a  situaÃ§Ã£o  Ã©  â€œlocalmenteâ€  otimizada,  estamos  utilizando  um  algoritmo  conhecido  como 

â€œAlgoritmo Gananciosoâ€ ou â€œAlgoritmo Guloso.â€ Sobre o algoritmo guloso, Parberry (1995) 

diz: 

Um algoritmo guloso comeÃ§a com uma soluÃ§Ã£o para um subproblema muito pequeno 
e o aumenta sucessivamente para uma soluÃ§Ã£o para o grande problema. O aumento Ã© 
feito de maneira 'gananciosa', ou seja, prestando atenÃ§Ã£o ao ganho de curto prazo ou 
local, sem levar em conta se isso levarÃ¡ a uma boa soluÃ§Ã£o de longo prazo ou global. 
Como na vida real, algoritmos gananciosos Ã s vezes levam Ã  melhor soluÃ§Ã£o, Ã s vezes 
levam a soluÃ§Ãµes muito boas e Ã s vezes levam a soluÃ§Ãµes ruins. O truque Ã© determinar 
quando ser ganancioso. (PARBERRY, 1995, p.101) 

Dessa forma nos vem a seguinte pergunta: Quando podemos ser gananciosos? Antes 

de  responder  a  essa  pergunta,  abaixo  veremos  alguns  problemas  e  tentaremos  resolvÃª-los 

utilizando o algoritmo  guloso. A partir daÃ­,  vamos  estabelecer o cenÃ¡rio ideal  para o uso do 

mesmo. 

Problema 1. 

Um certo nÃºmero de trabalhos serÃ¡ executado por uma Ãºnica mÃ¡quina. Todos 

requerem  o  mesmo  tempo  de  processamento,  uma  hora.  EstÃ£o  associados  a  um  tempo 

para entrega, o qual nÃ£o satisfeito, implica em uma penalidade fixa ğ’‘ğ’Š, independente do 

atraso.  Determinar  a  sequÃªncia  para  execuÃ§Ã£o  dos  trabalhos  de  forma  que  o  total  das 

penalidades seja mÃ­nimo. 

Para  que  o  total  de  penalidades  seja  mÃ­nimo,  podemos  resolver  o  problema  da 

seguinte maneira: A princÃ­pio, devemos organizar os trabalhos em ordem crescente de tempo 

de  entrega,  no  caso  de  empate,  deve-se  organizar  em  ordem  decrescente  de  penalidade. 

ComeÃ§ando assim, a mÃ¡quina deve executar os trabalhos nessa ordem estabelecida, descartando 

somente aqueles trabalhos que nÃ£o puderem ser feitos, obedecendo o tempo de entrega. Por 

fim, os trabalhos descartados serÃ£o feitos apÃ³s o Ãºltimo feito dentro do tempo de entrega, sendo 

esses em qualquer ordem. 

 
 
 
 
 
 
 
 
 
 
 
 11 

Temos entÃ£o que pudemos utilizar o algoritmo guloso nesse problema e ele nos leva 

Ã  melhor soluÃ§Ã£o possÃ­vel. Para melhor visualizaÃ§Ã£o, tomemos o exemplo abaixo. 

TRABALHOS 

T. DE ENTREGA 

PENALIDADE 

1 

1 

9 

2 

3 

7 

3 

2 

6 

Organizando utilizando o algoritmo, temos: 

TRABALHOS 

T. DE ENTREGA 

4 

1 

PENALIDADE 

10 

1 

1 

9 

3 

2 

6 

4 

1 

10 

2 

3 

7 

5 

3 

4 

5 

3 

4 

6 

6 

2 

6 

6 

2 

Com essa ordenaÃ§Ã£o a mÃ¡quina realizaria o trabalho 4, descartaria o 1, realizaria o 

3 e o 2, descartaria o 5, realizaria o 6. Depois  disso realizaria o 1  e 5,  em  qualquer  ordem, 

totalizando uma penalidade P = 13. Que Ã© a menor possÃ­vel, em qualquer situaÃ§Ã£o. 

Problema 2. 

Deseja-se  construir  trechos  de  estradas  que  conectem  cinco  cidades  com  a 

menor quantidade de asfalto possÃ­vel. Sejam as cidades A, B, C, D e E, se hÃ¡ um trecho 

que liga A e B, e outro que ligue B e C, entÃ£o A e C jÃ¡ estÃ£o conectadas. 

Para que a quantidade de asfalto seja a mÃ­nima possÃ­vel, deve-se construir os trechos 

que ligam duas cidades com a menor distÃ¢ncia possÃ­vel. Usando o algoritmo ganancioso, basta 

escolhermos os trechos em ordem crescente de distÃ¢ncia, descartando somente os trechos que 

conectam a uma cidade jÃ¡ escolhida formando um ciclo. Vejamos no exemplo abaixo. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figura 1 - Grafo representante das estradas entre cidades 

 12 

Fonte: elaborada pelo autor. 

A  menor  distÃ¢ncia  entre  duas  cidades  Ã©  2,  logo  o  primeiro  trecho  escolhido  Ã©  o 

trecho DC. Seguindo a ordem crescente, temos em seguida o trecho CB, com distÃ¢ncia 3. O 

prÃ³ximo trecho seria BD, com distÃ¢ncia 4, mas ao fazermos isso criamos um ciclo, pois B jÃ¡ 

estÃ¡  conectada  com  D  pelo  trecho  DCB. Assim,  descartamos  esse  trecho  e  vamos  para  o 

prÃ³ximo de menor valor, que pode ser tanto AC ou BA, pois ambos tÃªm a mesma distÃ¢ncia 5. 

Escolhemos  entÃ£o  AC,  fazendo  isso  descartamos  o  trecho  BA,  pois  terÃ­amos  um  ciclo.  O 

prÃ³ximo e Ãºltimo trecho a ser feito entÃ£o Ã© EC, com distÃ¢ncia 6. Assim, todas as cidades estÃ£o 

conectadas, e a soma dos trechos Ã© 2+3+5+6 = 16, que Ã© a menor possÃ­vel. 

Problema 3. 

ApÃ³s  realizar  uma  venda,  deve-se  dar  um  troco  de  40  centavos  para  o 

comprador entregando a menor quantidade de moedas possÃ­vel. As moedas disponÃ­veis 

para o troco sÃ£o de 5, 10, 20 e 25 centavos. 

Se seguirmos o algoritmo ganancioso, entÃ£o para que a quantidade de moedas seja 

a  menor  possÃ­vel  devemos  comeÃ§ar  com  as  de  maior  valor  e  seguir  em  ordem  decrescente, 

descartando somente aquelas que ultrapassariam a quantia desejada. Temos assim a seguinte 

escolha: Primeiramente escolhemos a de 25 centavos, em seguida a de 10, pois com mais 25 ou 

mais 20, ultrapassarÃ­amos a quantia desejada. Para finalizar, escolhemos a de 5, totalizando 25+ 

10+5 = 40. PorÃ©m para que a quantidade de moedas seja mÃ­nima, a configuraÃ§Ã£o de escolha 

correta deve ser duas moedas de 20 centavos, e nÃ£o as trÃªs moedas obtidas com o algoritmo. 

Podemos concluir com os problemas acima que somente em algumas situaÃ§Ãµes o 

algoritmo ganancioso nos dÃ¡ a resposta para uma questÃ£o de escolhas otimizada. Na seÃ§Ã£o a 

seguir,  veremos  uma  estrutura  matemÃ¡tica  onde  sempre  poderemos  utilizar  o  algoritmo 

ganancioso, dando uma introduÃ§Ã£o Ã  Teoria dos MatrÃ³ides. 

 
 
 
 
 
 
 
 13 

2 MATRÃ“IDES 

SÃ£o passados quase 90 anos desde que pela primeira vez surgiu o termo matrÃ³ide e 

este continua desconhecido da maioria dos amantes da matemÃ¡tica. Apesar disto, os matrÃ³ides 

tÃªm  um  papel  muito  importante  em  diversas  Ã¡reas  cientÃ­ficas.  Ãlgebra,  geometria,  teoria  da 

computaÃ§Ã£o, investigaÃ§Ã£o operacional  sÃ£o algumas das que os utilizam,  muitas vezes sem  o 

saberem. 

Tal como o nome sugere, matrÃ³ide vem da palavra matriz. O conceito de matrÃ³ide 

surgiu  em  1935,  quando  Whitney  tentou  generalizar  a  noÃ§Ã£o  de  dependÃªncia  linear  de  um 

conjunto de vetores, pertencentes a um dado espaÃ§o vetorial. A teoria de matrÃ³ides surgiu da 

tentativa de unificar, de certa maneira a Ã¡lgebra e a teoria dos grafos. Hassler Whitney apÃ³s 

vÃ¡rios  anos  de  estudos  sobre  teoria  dos  grafos  notou  similaridades  entre  as  ideias  de 

independÃªncia e posto em teoria dos grafos a independÃªncia linear e dimensÃ£o no estudo de 

espaÃ§os vetoriais. Vejamos um exemplo na Ã¡lgebra linear: 

Exemplo 2.1 Seja ğ´ a seguinte matriz, com trÃªs linhas, seis colunas e preenchida 

por  nÃºmeros  reais:  ğ´ = [

1 0 0
0 1 0
0 0 1

1 1 0
1 1 0
1 0 0

].  Numerando  as  colunas  da  matriz  ğ´  e 

simplificando a notaÃ§Ã£o, podemos designar por E = {1, 2, 3, 4, 5, 6} o conjunto das colunas da 

matriz ğ´. Reparando nas colunas 1, 4, 5, se tentarmos encontrar nÃºmeros reais ğ‘1, ğ‘2 e ğ‘3 tais 

1
] + ğ‘2 [
0
0
ğ‘2
ğ‘2
ğ‘2

1
1
1
ğ‘3
ğ‘3
0

] + [

que ğ‘1 [

] + [

ğ‘1
0
[
0
ğ‘1 + ğ‘2 + ğ‘3
ğ‘2 + ğ‘3
ğ‘2

[

] + ğ‘3 [

1
1
0

] = [

0
] , teremos de encontrar nÃºmeros reais ğ‘1, ğ‘2 e ğ‘3 tais que 
0
0

] = [

0
],  isto  Ã©  equivalente  a  encontrar  nÃºmeros  reais  ğ‘1, ğ‘2 e  ğ‘3  tais  que 
0
0

] = [

0
0
0

], ou seja, resolver o sistema {

ğ‘1 + ğ‘2 + ğ‘3 = 0
ğ‘2 + ğ‘3 = 0
ğ‘2 = 0

. A Ãºnica soluÃ§Ã£o deste 

sistema Ã© ğ‘1 = ğ‘2 = ğ‘3 = 0. Isto significa que o subconjunto de E formado pelas colunas 1, 4, 

5 de ğ´ Ã© linearmente independente. Este subconjunto nÃ£o seria linearmente independente se o 

sistema anterior tivesse mais do que uma soluÃ§Ã£o. Sendo ğ¼1 a coleÃ§Ã£o de subconjuntos de E, 

formados por colunas da matriz A, linearmente independentes, entÃ£o podemos afirmar que ğ¼1  

tem todos os conjuntos com, no mÃ¡ximo, trÃªs elementos de ğ¸ âˆ’ {6}, exceto os conjuntos {1, 2, 

5} e {3, 4, 5}. 

 
 
 
 
 
 
 
 
     
 14 

Outra  noÃ§Ã£o  Ã©  a  de  grafo.  Este  pode  ser  definido  como  um  conjunto  de  pontos 

(chamados vÃ©rtices do grafo) e uma coleÃ§Ã£o de linhas a unir determinados pontos (chamadas 

arestas do grafo). 

Exemplo 2.2 Na figura 2 pode ver-se o grafo ğº com o conjunto de vÃ©rtices ğ‘‹ =

{ğ‘¥1, ğ‘¥2, ğ‘¥3, ğ‘¥4} e a coleÃ§Ã£o das arestas ğ‘ˆ = {ğ‘¢1, ğ‘¢2, ğ‘¢3, ğ‘¢4, ğ‘¢5, ğ‘¢6}. 

Figura 2 - Exemplo de grafo 

Fonte: Fernandes (2015, p. 38). 

Para  falarmos  da  noÃ§Ã£o  de  dependÃªncia  em  grafos,  necessitamos  de  um  outro 

conceito, o conceito de ciclo. Um ciclo Ã© uma sequÃªncia alternada de vÃ©rtices e arestas de um 

grafo, iniciada e terminada num vÃ©rtice, tal que cada aresta tem uma extremidade no vÃ©rtice 

que imediatamente a precede na sequÃªncia e outra extremidade no vÃ©rtice que imediatamente a 

sucede  na  sequÃªncia. AlÃ©m  disto,  num  ciclo,  todas  as  arestas  sÃ£o  distintas  e  todos  os  seus 

vÃ©rtices tambÃ©m, Ã  exceÃ§Ã£o do primeiro e do Ãºltimo, que sÃ£o o mesmo. Reparando na figura, 

temos por exemplo: 

-A sequÃªncia ğ‘¥3, ğ‘¢1, ğ‘¥1, ğ‘¢5, ğ‘¥2, ğ‘¢2, ğ‘¥3 Ã© um ciclo do grafo ğº. 

-A sequÃªncia ğ‘¥4, ğ‘¢6, ğ‘¥4 tambÃ©m Ã© um ciclo do grafo ğº (ciclos com uma Ãºnica aresta 

chamam-se laÃ§os). 

Quando nomeamos uma aresta ficam definidos os vÃ©rtices que sÃ£o extremidades 

dessa aresta, assim podemos omitir os vÃ©rtices quando estamos a escrever um ciclo. Pensando 

nos ciclos exemplificados anteriormente no grafo ğº, poderÃ­amos escrever o primeiro ciclo como 

 ğ‘¢1, ğ‘¢5, ğ‘¢2,  e  o  segundo,  que  Ã©  um  laÃ§o,  como  ğ‘¢6.  Com  o  conceito  de  ciclo  estabelecido, 

podemos falar da noÃ§Ã£o de dependÃªncia nos conjuntos constituÃ­dos por arestas de um grafo. 

Exemplo 2.3 Olhando para o grafo ğº, e sendo ğ¼2 a coleÃ§Ã£o dos subconjuntos de ğ‘ˆ, 

formados  por  arestas  do  grafo  G  que  nÃ£o  contÃªm  nenhum  ciclo  do  grafo,  entÃ£o,  podemos 

afirmar que ğ¼2 tem todos os conjuntos com, no mÃ¡ximo, trÃªs elementos de ğ‘ˆ âˆ’ {ğ‘¢6}, exceto os 

conjuntos {ğ‘¢1, ğ‘¢2, ğ‘¢5} ğ‘’ {ğ‘¢3, ğ‘¢4, ğ‘¢5}. 

 
 
 
 
 
 
 
 15 

Repare  na  semelhanÃ§a  que  existe  entre  ğ¼1  do  exemplo  2.1  e  ğ¼2  do  exemplo  2.3. 

Whitney reparou nesta semelhanÃ§a e reparou tambÃ©m nas seguintes trÃªs propriedades que ğ¼1 e 

ğ¼2 verificavam: (designando por ğ¼ indiferentemente as coleÃ§Ãµes ğ¼1 e ğ¼2) 

ğ‘·ğŸ) âˆ… Ã© elemento de ğ¼. 

ğ‘·ğŸ) Se ğ‘Œ âˆˆ ğ¼ e ğ‘ âŠ† ğ‘Œ, entÃ£o ğ‘ âˆˆ ğ¼ . 

ğ‘·ğŸ‘) Se ğ‘, ğ‘Œ  âˆˆ  ğ¼ e |ğ‘| > |ğ‘Œ|, entÃ£o existe ğ‘§ âˆˆ ğ‘ âˆ’ ğ‘Œ tal que ğ‘Œ âˆª {ğ‘§} âˆˆ ğ¼ (em que 

|ğ‘Œ| e |ğ‘| designam o nÃºmero de elementos dos conjuntos ğ‘Œ e ğ‘, respectivamente). 

Foi a partir destas trÃªs propriedades que Whitney definiu o conceito de matrÃ³ide. 

2.1 DEFINIÃ‡ÃƒO DE MATRÃ“IDES 

DefiniÃ§Ã£o 2.1.1 Um matrÃ³ide ğ‘€ Ã© uma estrutura do tipo ğ‘€ = (ğ¸, ğ¼) em que ğ¸ Ã© um 

conjunto  finito  e  ğ¼  Ã©  uma  coleÃ§Ã£o  de  subconjuntos  de  ğ¸  que  verificam  as  trÃªs  propriedades 

anteriores. 

Se  ğ‘€ = (ğ¸, ğ¼)  Ã©  um  matrÃ³ide,  entÃ£o  os  conjuntos  de  ğ¼  chamam-se  conjuntos 

independentes do matrÃ³ide ğ‘€. O conjunto ğ¸ Ã© o suporte do matrÃ³ide ğ‘€. O subconjunto de E que 

nÃ£o estÃ¡ em ğ¼ Ã© chamado dependente.  Se o conjunto ğ¼ satisfizer as propriedades P1 e P2 mas nÃ£o 

necessariamente P3, entÃ£o (ğ¸, ğ¼) Ã© denominado um complexo simplicial. 

ProposiÃ§Ã£o 2.1.1 Seja E o conjunto de colunas rotuladas de uma matriz m x n sobre 

um corpo F, e seja ğ¼ o conjunto dos subconjuntos X de E para os quais multiconjuntos (conjunto 

cujos  elementos  podem  ser  repetidos)  de  colunas  rotuladas  por  X  Ã©  linearmente  independente 

(L.I) no espaÃ§o vetorial de dimensÃ£o ğ‘‰(ğ‘š, ğ¹) sobre o corpo F. EntÃ£o (E, ğ¼) Ã© um MatrÃ³ide. 

DemonstraÃ§Ã£o:  Evidentemente,  ğ¼  satisfaz  (P1),  pois  âˆ…  âˆˆ  ğ¼  e  (P2)  tambÃ©m  Ã© 

satisfeito, pois, subconjuntos de conjuntos linearmente independentes tambÃ©m sÃ£o linearmente 

independentes.  Para  provar  (P3),  sejam  ğ¼1 ğ‘’ ğ¼2  conjuntos  independentes  de  ğ¼.  Supondo  que 

|ğ¼1| < |ğ¼2|, devemos provar que âˆƒ ğ‘’ âˆˆ ğ¼2 âˆ’ ğ¼1 com ğ¼1 âˆª {ğ‘’} âˆˆ ğ¼. Por absurdo, vamos supor que 

âˆ€ ğ‘’ âˆˆ ğ¼2 âˆ’ ğ¼1, ğ¼1 âˆª {ğ‘’} âˆ‰ ğ¼ â‡’ ğ¼1 âˆª {ğ‘’} gera vetores linearmente dependentes. Seja W subespaÃ§o 

de  ğ‘‰(ğ‘š, ğ¹)  gerado  por  ğ¼1 âˆª ğ¼2.  Logo  a  dimensÃ£o  de  W  Ã©  no  mÃ­nimo  |ğ¼2|,  pois  ğ¼2 âŠ‚ ğ¼1 âˆª ğ¼2. 

Portanto,  W  estÃ¡  contido  no  gerado  de  ğ¼1.  Assim  |ğ¼2| â‰¤  ğ‘‘ğ‘–ğ‘š ğ‘Š â‰¤   |ğ¼1| < |ğ¼2|   Ã©  uma 

contradiÃ§Ã£o. Logo, concluÃ­mos que ğ¼2 âˆ’ ğ¼1 contÃ©m um elemento ğ‘’ tal que ğ¼1 âˆª {ğ‘’} âˆˆ ğ¼, isto Ã©, 

(P3) Ã© vÃ¡lida. 

 
 
 
 
 
 
 
 
 
 16 

Um MatrÃ³ide obtido de uma matriz A como do exemplo 2.1, denotada por M[A], Ã© 

chamado MatrÃ³ide Vetorial de A.  

Exemplo  2.1.1  Voltando  a  analisar  a  matriz  ğ´ = [

1 0 0
0 1 0
0 0 1

1 1 0
1 1 0
1 0 0

]  do 

exemplo 2.1, cujas colunas sÃ£o rotuladas por 1,2,3,4,5 e 6. Obtemos: 

E = {1, 2, 3, 4, 5, 6} e 

A coleÃ§Ã£o de subconjuntos dependentes Ã©: 

{{1,2,5}, {3,4,5}} âˆª {ğ‘‹ âŠ† ğ¸; |ğ‘‹| â‰¥ 4 ğ‘œğ‘¢ 6 âˆˆ ğ‘‹} 

Dentre  os  conjuntos  dependentes  existem  os  minimais,  ou  seja,  conjuntos 

dependentes cujos subconjuntos prÃ³prios sÃ£o independentes, e isso origina a seguinte definiÃ§Ã£o: 

DefiniÃ§Ã£o  2.1.2  Um  conjunto  dependente  minimal  de  um  MatrÃ³ide  M  serÃ¡ 

denominado circuito de M, e o conjunto de todos os circuitos do MatrÃ³ide M serÃ¡ denominado 

por ğ’ ou ğ’(M).   

Um circuito de M com n elementos Ã© denominado n-circuito. Evidentemente, tal 

como no exemplo anterior, toda vez que ğ’(M) for especificado, M tambÃ©m o serÃ¡: os membros 

de ğ¼(ğ‘€) sÃ£o os subconjuntos de M e E que nÃ£o contÃªm nenhum membro de ğ’(M). Assim, um 

MatrÃ³ide Ã© determinado exclusivamente por seu conjunto ğ’ de circuitos.  

Vamos  agora  analisar  algumas  propriedades  de  ğ’,  com  vista  a  caracterizar  esses 

dois subconjuntos de que pode ocorrer como o conjunto de circuitos de um MatrÃ³ide sobre E. 

Lema 2.1.1 Seja ğ’ o conjunto dos circuitos de um MatrÃ³ide M, entÃ£o sÃ£o vÃ¡lidas 

as seguintes propriedades:  

C1) âˆ… âˆ‰ ğ’.  

C2) Se ğ¶1 ğ‘’ ğ¶2 sÃ£o membros de ğ’ e ğ¶1 âŠ† ğ¶2, entÃ£o ğ¶1 = ğ¶2.  

C3) Se ğ¶1 ğ‘’ ğ¶2 sÃ£o membros distintos de ğ’ e â„° âˆˆ ğ¶1 âˆ© ğ¶2. EntÃ£o existe um membro 

ğ¶3 de ğ’ tal que  ğ¶3 âŠ† (ğ¶1 âˆª ğ¶2) â€“ â„°.  

DemonstraÃ§Ã£o: C1) âˆ… âˆ‰ ğ’. Por P1) âˆ… âˆˆ I, pois I nÃ£o contÃ©m circuito.  

C2) Vamos supor que ğ¶1, ğ¶2 âˆˆ ğ’ com ğ¶1 âŠ† ğ¶2 e ğ¶1 â‰  ğ¶2. âˆƒ ğ“ âˆˆ ğ¶2 âˆ’ ğ¶1. EntÃ£o 

ğ¶1 âŠ† ğ¶2 âˆ’ {ğ“}. Mas ğ¶2 âˆ’ {ğ“} âˆˆ  ğ¼, por P2) ğ¶1 âˆˆ I Ã© um absurdo.  

 
 
 
 
 
 
 
     
 17 

Para  verificar  C3)  vamos  supor  que  nÃ£o  existe  um  circuito  contido  em 

(ğ¶1 âˆª ğ¶2)â€“ {â„°}, ou seja, (ğ¶1 âˆª ğ¶2) â€“ â„° Ã© independente. Por C2), ğ¶2 âˆ’ ğ¶1 â‰  âˆ… entÃ£o existe f em 

ğ¶2 âˆ’ ğ¶1. Como  ğ¶2  Ã©  conjunto  dependente  minimal,  ğ¶2â€“ ğ‘“ âˆˆ ğ¼.  Seja  J  um  subconjunto  de         

ğ¶1 âˆª ğ¶2  que  Ã©  maximal  com  a  propriedade  que  este  contÃ©m  a  ğ¶2 â€“ ğ‘“  Ã©  independente. 

Evidentemente f âˆ‰ J. Mas como ğ¶1 Ã© um circuito, algum elemento g de ğ¶1 nÃ£o estÃ¡ em I. Como 

ğ‘“ âˆˆ ğ¶2 âˆ’ ğ¶1, os elementos f e g sÃ£o distintos. EntÃ£o  

â”‚ğ½â”‚ â‰¤ â”‚(ğ¶1 âˆª ğ¶2) âˆ’ {ğ‘“, ğ‘”} â”‚ = â”‚(ğ¶1 âˆª ğ¶2)â”‚ â€“ 2  < â”‚(ğ¶1 âˆª ğ¶2) â€“ {â„°}â”‚.  

Agora  aplicando,  P3),  tomando  ğ¼1  como  J  e  ğ¼2  como  (ğ¶1 âˆª ğ¶2) â€“ â„°.  O  conjunto 

independente resultado contradiz com a maximalidade de J. 

A condiÃ§Ã£o C3) Ã© chamada de axioma da eliminaÃ§Ã£o do circuito 

Podemos entÃ£o classificar um MatrÃ³ide atravÃ©s das condiÃ§Ãµes C1, C2 e C3. 

Teorema  2.1.1  Seja  E  um  conjunto  e  ğ’  uma  coleÃ§Ã£o  de  subconjuntos  de  E  que 

satisfaz  C1,  C2  e  C3.  Seja  I  uma  coleÃ§Ã£o  de  todos  os  subconjuntos  de  E  que  nÃ£o  contÃ©m 

membros de ğ’. EntÃ£o (ğ¸, ğ¼) Ã© um MatrÃ³ide que tem ğ’ como sua coleÃ§Ã£o de circuitos. 

DemonstraÃ§Ã£o: Primeiramente mostraremos que ğ¼ satisfaz P1, P2 e P3. Por C1, âˆ… 

nÃ£o Ã© um elemento de ğ’, dessa forma âˆ… âˆˆ ğ¼. Logo P1 Ã© satisfeito. Se Y nÃ£o contÃ©m elementos 

de ğ’ e Z estÃ¡ contido em Y, entÃ£o Z nÃ£o contÃ©m elementos de ğ’. Logo P2 Ã© satisfeito.  

Para provar P3, suponhamos que ğ¼1 e ğ¼2 sÃ£o membros de ğ¼ e |ğ¼1| Ë‚ |ğ¼2|. Suponhamos 

que P3 falha para o par ğ¼1, ğ¼2. Agora ğ¼ contÃ©m um elemento que Ã© um subconjunto de ğ¼1 âˆª ğ¼2 e 

contÃ©m  mais  elementos  que  ğ¼1.  Escolha  um  subconjunto  ğ¼3  de  ğ¼  contido  em  ğ¼1 âˆª ğ¼2  tal  que 

a |ğ¼1â€“ ğ¼3| Ã© minimal. Como P3 falha, ğ¼1â€“ ğ¼3 Ã© nÃ£o vazio, assim podemos escolher um elemento 
ğ‘’ deste conjunto. Para cada elemento f de ğ¼3â€“ ğ¼1, seja ğ‘‡ğ‘“ = (ğ¼3 âˆ’ {ğ‘“}) âˆª   {ğ‘’}. EntÃ£o ğ‘‡ğ‘“   âŠ†   ğ¼1 âˆª

ğ¼2  e  â”‚ğ¼1 âˆ’ ğ‘‡ğ‘“â”‚ Ë‚ â”‚ğ¼1â€“ ğ¼3â”‚.  Portanto  ğ‘‡ğ‘“ âˆ‰ ğ¼,  assim  ğ‘‡ğ‘“  contÃ©m  um  elemento  ğ¶ğ‘“  de  ğ’. 

Evidentemente ğ‘“ âˆ‰ ğ¶ğ‘“. Mas, ğ‘’ âˆˆ ğ¶ğ‘“, pois caso contrÃ¡rio temos ğ¶ğ‘“ âŠ† ğ¼3 contradiz o fato que ğ¼3 âˆˆ

ğ¼.   

Seja g um elemento de ğ¼3â€“ ğ¼1. Se ğ¶ğ‘” âˆ© (ğ¼3â€“ ğ¼1) = âˆ…. EntÃ£o ğ¶ğ‘” âŠ† (ğ¼1 âˆ© ğ¼3) âˆª {ğ‘’} âˆ’

{ğ‘”} âŠ† ğ¼1 o que dÃ¡ uma contradiÃ§Ã£o. Portanto, tem um elemento h em ğ¶ğ‘” âˆ© (ğ¼3â€“ ğ¼1). EntÃ£o ğ‘’ âˆˆ

ğ¶ğ‘” âˆ© ğ¶â„. Assim, C3 implica que tem um membro ğ¶ de ğ’ tal que ğ¶ âŠ† (ğ¶ğ‘” âˆª ğ¶â„) âˆ’ {ğ‘’}. Mas, 

ambos ğ¶ğ‘” e ğ¶â„ sÃ£o subconjuntos de ğ¼3 âˆª {ğ‘’} e, portanto ğ¶ âŠ† ğ¼3 Ã© uma contradiÃ§Ã£o. ConcluÃ­mos 

 
 
 
 
 
 
 
 18 

que P3 nÃ£o falha e consequentemente (ğ¸, ğ¼) Ã© um MatrÃ³ide M. 

Para provar que ğ’ Ã© um conjunto ğ’ (M) de circuitos de M, notamos que os seguintes 

enunciados sÃ£o equivalentes.  

(i) C Ã© um circuito de M.  

(ii) C âˆ‰ I(M) e C â€“ x âˆˆ I(M) para todo x em C.  

(iii)  C  contÃ©m  um  membro  Câ€™  de  ğ’  como  um  subconjunto,  mas  Câ€™  nÃ£o  Ã©  um 

subconjunto prÃ³prio de C.  

(iv) C âˆˆ ğ’.  

Como consequÃªncia imediata do teorema anterior tem-se: 

CorolÃ¡rio 2.1.1 Seja ğ’ uma coleÃ§Ã£o de subconjuntos de E. EntÃ£o ğ’ Ã© uma coleÃ§Ã£o 

de subconjuntos do circuito de um MatrÃ³ide M se, e somente se, satisfaz as seguintes condiÃ§Ãµes:  

(C1) âˆ… âˆ‰ ğ’.  

(C2) Se ğ¶1 e ğ¶2 sÃ£o elementos de ğ’ e ğ¶1 âŠ† ğ¶2. EntÃ£o ğ¶1= ğ¶2.  

(C3)  Se  ğ¶1  e  ğ¶2  sÃ£o  elementos  distintos  de  ğ’  e  ğœ€  âˆˆ  ğ¶1  âˆ©  ğ¶2,  entÃ£o,  existe  um 

elemento ğ¶3 de ğ’ tal que ğ¶3 âŠ† (ğ¶1 âˆª ğ¶2) â€“ ğœ€. 

ProposiÃ§Ã£o  2.1.2  Seja  I  um  conjunto  independente  em  um  MatrÃ³ide  M  e  ğœ€  um 

elemento  de  M  tal  que  ğ¼ âˆª {ğœ€}  Ã©  dependente.  EntÃ£o  M  tem  um  Ãºnico  circuito  C  contido  em       

ğ¼ âˆª {ğœ€}, que contÃ©m ğœ€.  

DemonstraÃ§Ã£o:  Evidentemente,  ğ¼ âˆª {ğœ€}  contÃ©m  um  circuito,  pois  ğ¼ âˆª {ğœ€}  Ã©  um 

conjunto  dependente.  Portanto,  todo  circuito  C  contido  em  ğ¼ âˆª {ğœ€}  contÃ©m  ğœ€,  pois,  caso 

contrÃ¡rio,  C  âŠ‚  I,  um  absurdo.  Supor  que  existe  um  circuito  Câ€™,  distinto  de  C,  contido  em            

ğ¼ âˆª {ğœ€}. EntÃ£o, por (C3), (C âˆª Câ€™) âˆ’ ğœ€ contÃ©m um circuito Câ€™, mas (C âˆª Câ€™) âˆ’ ğœ€ âŠ† I, e assim Câ€™ 

âŠ‚  I,  o  que  Ã©  um  absurdo,  pois  I  Ã©  independente.  Portanto,  C  Ã©  o  Ãºnico  circuito  contido  em          

ğ¼ âˆª {ğœ€}  e que contÃ©m ğœ€. 

Com  as definiÃ§Ãµes, teoremas e proposiÃ§Ãµes acima demonstradas, podemos agora 

escrever formalmente como se dÃ¡ a construÃ§Ã£o de matrÃ³ides derivados de grafos, como visto 

no exemplo 2.2. 

ProposiÃ§Ã£o 2.1.3. Seja E o conjunto das arestas de um grafo G e ğ’ a famÃ­lia dos 

 
 
 
 
 
 
 
 19 

conjuntos das arestas dos ciclos de G. EntÃ£o ğ’ Ã© a famÃ­lia dos circuitos de um MatrÃ³ide sobre 

E.  

DemonstraÃ§Ã£o: (C1) âˆ… âˆ‰  ğ’. Por P1, âˆ… âˆˆ ğ¼.  

(C2) Supor ğ¶1  e ğ¶2  âˆˆ ğ’ com ğ¶1 âŠ† ğ¶2  e ğ¶1 â‰  ğ¶2. EntÃ£o âˆƒ ğœ€ âˆˆ   ğ¶2 â€“ ğ¶1 , e assim 

ğ¶1   âŠ† ğ¶2 âˆ’ {ğœ€}. Mas ğ¶2 âˆ’ {ğœ€}   âˆˆ  ğ¼, donde, por P2, ğ¶1 âˆˆ I, uma contradiÃ§Ã£o. 

(C3)  Sejam  ğ¶1  e  ğ¶2  os  conjuntos  das  arestas  de  dois  ciclos  distintos  de  G  que 

possuem ğ‘’ como uma aresta em comum. Considere a Fig. (3). Sejam u e v os vÃ©rtices da aresta 

ğ‘’. Vamos agora construir um ciclo de G cujas arestas estÃ£o contidas em ğ¶1 âˆª ğ¶2 â€“ ğ‘’, para i = 1, 

2,  seja  ğ‘ƒ1  um  caminho  de  u  a  v  em  G  cujas  arestas  estÃ£o  em  ğ¶ğ‘– â€“ ğ‘’.  ComeÃ§ando  em  u, 

percorrendo ğ‘ƒ1 em direÃ§Ã£o de v, seja w o primeiro vÃ©rtice cuja prÃ³xima aresta de ğ‘ƒ1 nÃ£o pertence 

a ğ‘ƒ2. Continuando a percorrer ğ‘ƒ1 de w em direÃ§Ã£o v, encontramos um vÃ©rtice x distinto de w 

que tambÃ©m estÃ¡ em ğ‘ƒ2. Como ğ‘ƒ1 e ğ‘ƒ2 terminam em v tal vÃ©rtice existe. Unindo o subcaminho 

de ğ‘ƒ1 que vai de w a x ao subcaminho de ğ‘ƒ2 vai de x atÃ© w encontramos um ciclo cujas arestas 

estÃ£o  contidas  em  ğ¶1 âˆª ğ¶2 â€“ ğ‘’.  Portanto,  ğ’  satisfaz  a  propriedade  (C3),  ğ¶3 âŠ† ğ¶1 âˆª ğ¶2 âˆ’ ğ‘’. 

Logo ğ’ Ã© a famÃ­lia dos circuitos de um MatrÃ³ide sobre E. 

Assim, um ciclo Ã© uma sequÃªncia alternada de arestas e vÃ©rtices, de um grafo G, 

formando um ciclo fechado. 

Figura 3 - O ciclo Ã© um grafo que satisfaz o circuito eliminatÃ³rio do axioma (C3) 

Fonte: Ales (2017, p. 24). 

DefiniÃ§Ã£o 2.1.3  MATRÃ“IDE UNIFORME: Sejam ğ‘› e  ğ‘Ÿ dois nÃºmeros inteiros 

nÃ£o  negativos,  com  0 â‰¤ ğ‘Ÿ â‰¤ ğ‘›.  Chama-se  matrÃ³ide  uniforme,  denotando-se  por  ğ‘ˆğ‘Ÿ,ğ‘›,  um 

matrÃ³ide ğ‘€ = (ğ¸, ğ¼) em que E Ã© um conjunto com ğ‘› elementos e ğ¼ Ã© a coleÃ§Ã£o de subconjuntos 

de E com, no mÃ¡ximo, ğ‘Ÿ elementos.  

Ã‰ fÃ¡cil verificar que o par (ğ¸, ğ¼) da definiÃ§Ã£o acima constitui um matrÃ³ide. 

 
 
 
 
 
 
 
 20 

Exemplo 2.1.2 Pedro tem uma lista de compras para o supermercado: 1 dÃºzia de 

ovos;  1  kg  de  arroz;  1  lata  de  atum;  1  pacote  de  salada.  No  supermercado,  repara  que  se 

esqueceu da carteira em casa e que nos seus bolsos sÃ³ tem trÃªs reais. Olha para as prateleiras e 

acrescenta Ã  sua lista de produtos os respectivos preÃ§os: 1 dÃºzia de ovos = 1,00 real; 1 kg de 

arroz = 1,10 reais; 1 lata de atum = 1,30 reais; 1 pacote de salada = 1,20 reais. Face ao exposto, 

Pedro tem, no mÃ¡ximo,  dinheiro para  comprar quaisquer dois  produtos  da sua lista. Ou nÃ£o 

compra nada, ou compra um produto, ou compra dois produtos. Estamos perante um problema 

que tem quatro elementos (os produtos da lista do Rui) e podemos construir subconjuntos destes 

quatro elementos com, no mÃ¡ximo, dois elementos (o Rui sÃ³ tem dinheiro para comprar, no 

mÃ¡ximo, dois produtos da lista). Portanto o que temos neste exemplo Ã© o matrÃ³ide uniforme 

ğ‘ˆ2,4. 

DefiniÃ§Ã£o  2.1.4  Seja  um  conjunto  E,  um  conjunto  sobre  o  qual  definimos  uma 

propriedade. Seja o  MÃXIMO (MÃNIMO) ou MAXIMAL (MINIMAL)  subconjunto  ğ‘… âŠ† ğ¸ 

aquele  tal  que  nÃ£o  existe  um  outro  subconjunto  ğ‘…â€² âŠ† ğ¸  que  contÃ©m  (contido  em) ğ‘… 

propriamente, satisfazendo a mesma propriedade.  

Exemplo 2.1.3 Seja ğ¸ = {ğ‘‚, 2, . . . , 10} conjunto dos pares menores ou iguais a 10. 

O  subconjunto  maximal  (minimal)  ğ‘… âŠ† ğ¸  contendo  pares  menores  que  7  Ã©  ğ‘… = {ğ‘‚, 2, 4, 6}    

(ğ‘… = {ğ‘‚}, ğ‘… = {2}, ğ‘… = {4}, ğ‘… = {6} todos minimais). 

Um  outro  tipo  de  matrÃ³ide  que  serÃ¡  utilizado  nas  seÃ§Ãµes  posteriores  sÃ£o  os 

matrÃ³ides transversais. Para caracterizÃ¡-los definiremos alguns elementos bÃ¡sicos. 

Seja  E  um  conjunto  finito  e  ğ‘„ = {ğ‘„1, ğ‘„2, â€¦ , ğ‘„ğ‘›}  um  conjunto  de,  nÃ£o 

necessariamente  distintos,  subconjuntos  de  E.  Um  TRANSVERSAL  DE  Q  Ã©  um  conjunto 

formado tomando-se um Ãºnico elemento de cada subconjunto ğ‘„1, ğ‘„2, â€¦ , ğ‘„ğ‘›, de maneira que 

todos estes elementos sejam distintos. Um PARCIAL TRANSVERSAL DE Q Ã© uma transversal 

de algum subconjunto de ğ‘„. 

Exemplo  2.1.4  ğ‘„ = {ğ‘„1, ğ‘„2, ğ‘„3}  um 

conjunto  de 

subconjuntos  de                                

ğ¸ = {ğ‘’1, ğ‘’2, ğ‘’3, ğ‘’4} onde ğ‘„1 = {ğ‘’2, ğ‘’3, ğ‘’4} e ğ‘„2 = ğ‘„3 = {ğ‘’1}. NÃ£o temos um transversal pois 

ğ‘„2 = ğ‘„3, mas âˆ…, {ğ‘’1}, {ğ‘’2}, {ğ‘’3}, {ğ‘’4}, {ğ‘’1, ğ‘’2}, {ğ‘’1, ğ‘’3}, {ğ‘’1, ğ‘’4} sÃ£o parciais transversais. 

DefiniÃ§Ã£o  2.1.5  Com  as  definiÃ§Ãµes  acima,  ğ‘€ = (ğ¸, ğ¼)  Ã©  um  MATRÃ“IDE 

TRANSVERSAL sobre ğ¸ se ğ¼ Ã© o conjunto de parciais transversais de ğ‘„, ou seja, as parciais 

transversais de ğ‘„ sÃ£o os subconjuntos independentes de ğ¸. As propriedades P1, P2 e P3 sÃ£o 

 
 
 
 
 
 
 
 21 

facilmente verificadas. 

Entre  os  subconjuntos  independentes  de  ğ¸  temos  o  MAXIMAL  PARCIAL 

TRANSVERSAL DE Q, que Ã© o parcial transversal tal que nÃ£o existe nenhum outro parcial 

transversal contendo-o. 

2.2 MATRÃ“IDES PESADOS 

Queremos agora relacionar matrÃ³ides com problemas de otimizaÃ§Ã£o. Grosso modo, 

o objetivo de um problema de otimizaÃ§Ã£o Ã© minimizar/maximizar uma determinada quantidade, 

de acordo com certas restriÃ§Ãµes. Vamos fazer isso atribuindo uma certa quantidade (designada 

por â€œpesoâ€) a cada elemento de E. 

Seja ğ‘€ = (ğ¸, ğ¼) um matrÃ³ide e seja ğ‘¤: ğ¸ âŸ¶ â„0

+ uma funÃ§Ã£o. Dizemos que w Ã© a 

funÃ§Ã£o  peso  do  matrÃ³ide  e  w(x)  Ã©  o  peso  do  elemento  x.  Dado  ğ‘‹ âŠ† ğ¸,  o  peso  de  ğ‘‹,  que 

denotamos por w(X) (abuso de notaÃ§Ã£o!) Ã© a soma de todos os pesos dos seus elementos, ou 

seja, ğ‘¤(ğ‘‹) = âˆ‘

ğ‘¥âˆˆğ‘‹

ğ‘¤(ğ‘¥)

. O problema que pretendemos resolver Ã© o seguinte: 

PROBLEMA: Determinar um conjunto independente maximal de peso mÃ¡ximo. 

Por â€œconjunto independente maximalâ€ entenda-se um conjunto independente que 

nÃ£o  estÃ¡  estritamente  contido  em  nenhum  outro  conjunto  independente.  O  problema  de 

determinar um independente maximal de peso mÃ­nimo Ã© inteiramente anÃ¡logo, logo, focar-nos-

emos apenas no caso acima. 

Vamos  agora  ver  que  a  resposta  ao  problema  acima  Ã©  â€œusando  um  algoritmo 

ganancioso!â€. 

Seja M = (E, I) um matrÃ³ide pesado cuja funÃ§Ã£o peso Ã© ğ‘¤: ğ¸ âŸ¶ â„0

+. Consideremos 

o  seguinte  algoritmo  ganancioso  (ou  guloso),  cujo  objetivo  Ã©  determinar  um  conjunto 

independente maximal de peso mÃ¡ximo: 

â€¢ Passo 1: ComeÃ§amos por considerar o conjunto independente ğ‘‹ = âˆ…  

â€¢  Passo  2:  Acrescentamos  a  X  um  elemento  x  de  peso  mÃ¡ximo  satisfazendo             

ğ‘‹ âˆª {ğ‘¥} âˆˆ ğ¼. 

â€¢ Passo 3:  Continuamos  a acrescentar  elementos como  no  Passo 2  atÃ© obter um 

independente maximal. 

 
 
 
 
 
 
 
 
 
 22 

Nota-se que a propriedade P3 satisfeita pelo matrÃ³ide assegura que conseguimos 

â€œcompletarâ€  qualquer  conjunto  independente  atÃ©  atingirmos  um  independente  maximal,  daÃ­ 

podermos  executar  o  Passo  2  atÃ©  alcanÃ§armos  um  tal  conjunto.  AlÃ©m  disso,  esta  mesma 

propriedade  garante  que  quaisquer  dois  conjuntos  independentes  maximais  tÃªm  a  mesma 

cardinalidade. 

Chegamos enfim ao resultado que procuramos: 

Teorema 2.2.1  O algoritmo  ganancioso  acima encontra a melhor soluÃ§Ã£o  para  o 

PROBLEMA. 

DemonstraÃ§Ã£o: Seja M = (E, I) um matrÃ³ide pesado com funÃ§Ã£o peso ğ‘¤: ğ¸ âŸ¶ â„0

+. 

Suponhamos,  com  vista  a  um  absurdo,  que  o  algoritmo  ganancioso  devolve  um  conjunto 

independente maximal ğ‘‹ = {ğ‘¥1, . . . , ğ‘¥ğ‘›}, mas existe um conjunto independente maximal  ğ‘Œ =
{ğ‘¦1, . . . , ğ‘¦ğ‘›}  satisfazendo  ğ‘¤(ğ‘Œ ) > ğ‘¤(ğ‘‹).  Suponhamos  ainda  que  ğ‘¤(ğ‘¥1) â‰¥ Â· Â· Â· â‰¥ ğ‘¤(ğ‘¥ğ‘›)  e  

ğ‘¤(ğ‘¦1) â‰¥ Â· Â· Â· â‰¥ ğ‘¤(ğ‘¦ğ‘›). EntÃ£o, tem de existir algum 1 â‰¤ ğ‘˜ â‰¤ ğ‘› tal que ğ‘¤(ğ‘¦ğ‘˜) > ğ‘¤(ğ‘¥ğ‘˜). Como 

os  conjuntos  ğ‘‹â€² = {ğ‘¥1, . . . , ğ‘¥ğ‘˜âˆ’1}  e  ğ‘Œâ€² = {ğ‘¦1, . . . , ğ‘¦ğ‘˜}  sÃ£o  independentes  e  |ğ‘Œâ€²| > |ğ‘‹â€²|,  a 

propriedade P2 satisfeita por I garante que existe 1 â‰¤ ğ‘Ÿ â‰¤ ğ‘˜ tal que o conjunto {ğ‘¥1, . . . , ğ‘¥ğ‘˜âˆ’1, ğ‘¦ğ‘Ÿ} 

Ã© independente. Mas ğ‘¤(ğ‘¦ğ‘Ÿ) â‰¥ ğ‘¤(ğ‘¦ğ‘˜) pois ğ‘Ÿ â‰¤ ğ‘˜, e ğ‘¤(ğ‘¦ğ‘˜) > ğ‘¤(ğ‘¥ğ‘˜) pela escolha de ğ‘˜. Logo 

ğ‘¤(ğ‘¦ğ‘Ÿ) > ğ‘¤(ğ‘¥ğ‘˜), pelo que o algoritmo ganancioso teria escolhido o elemento ğ‘¦ğ‘Ÿ ao invÃ©s de ğ‘¥ğ‘˜, 

absurdo! ConcluÃ­mos entÃ£o que X Ã© um independente maximal de peso mÃ¡ximo. 

EstÃ¡ entÃ£o demonstrado que, se um problema de otimizaÃ§Ã£o possui a estrutura de 

matrÃ³ide, entÃ£o um algoritmo ganancioso fornece a melhor soluÃ§Ã£o possÃ­vel. 

Mas, intuitivamente, porque Ã© que a prova funciona? Novamente, a propriedade P3 

Ã© o ingrediente essencial: ela permite-nos assegurar a existÃªncia de uma soluÃ§Ã£o Ã³tima para o 

problema que Ã© consistente com as escolhas que o algoritmo ganancioso vai fazendo. Isto Ã©, 

podemos ir acrescentando cada vez mais elementos aos nossos independentes â€œlocaisâ€ de modo 

a culminar num independente â€œglobalâ€ que satisfaz o pretendido. 

A  observaÃ§Ã£o  prÃ©via  motiva  a  seguinte  questÃ£o:  o  que  acontece  se  nÃ£o 

considerarmos a propriedade P3? SerÃ¡ que as propriedades P1 e P2 sÃ£o suficientes para garantir 

que  um  algoritmo  ganancioso  encontra  a  soluÃ§Ã£o  Ã³tima  para  o  problema  em  questÃ£o? 

Lembremos que um complexo simplicial S Ã© uma estrutura do tipo ğ‘† = (ğ¸, ğ¼) em que o conjunto 

ğ¼ âŠ† ğ‘ƒ(ğ¸), onde P(E) Ã© o conjunto de todos os subconjuntos de ğ¸, satisfaz as propriedades P1 e 

P2,  mas  nÃ£o  necessariamente  P3.  Para  ser  mais  simples,  vamos  continuar  a  referir-nos  aos 

 
 
 
 
 
 
 
 23 

elementos I como â€œindependentesâ€. O prÃ³ximo resultado indica que se um complexo simplicial 

nÃ£o satisfaz P3, entÃ£o existe uma funÃ§Ã£o peso ğ‘¤: ğ¸ âŸ¶ â„0

+ tal que o algoritmo ganancioso NÃƒO 

encontra um independente maximal com peso mÃ¡ximo. Ou seja, a propriedade  P3 Ã© mesmo 

indispensÃ¡vel para que o algoritmo ganancioso forneÃ§a a soluÃ§Ã£o Ã³tima para qualquer funÃ§Ã£o 

peso que possamos considerar! 

Teorema 2.2.2 Se um complexo simplicial nÃ£o for um matrÃ³ide, entÃ£o o algoritmo 

ganancioso pode nÃ£o encontrar a soluÃ§Ã£o Ã³tima para o PROBLEMA. 

DemonstraÃ§Ã£o: Seja ğ‘† = (ğ¸, ğ¼) um complexo simplicial e sejam ğ‘‹, ğ‘Œ âˆˆ ğ¼ tais que 

|ğ‘Œ | > |ğ‘‹| mas ğ‘‹ âˆª {ğ‘¦} âˆ‰ ğ¼ para todo ğ‘¦ âˆˆ ğ‘Œ âˆ’ ğ‘‹ (i.e. |ğ‘‹| e |ğ‘Œ| violam a propriedade P3. Como 

|ğ‘Œ âˆ’ ğ‘‹| > |ğ‘‹ âˆ’ ğ‘Œ |, existe algum 0 < ğ‘ < 1 satisfazendo |ğ‘‹ âˆ’ ğ‘Œ| < ğ‘|ğ‘Œ âˆ’ ğ‘‹|. Consideremos 

a funÃ§Ã£o peso ğ‘¤: ğ¸ âŸ¶ â„0

+  dada por 

ğ‘¤(ğ‘¥) = {

1       ğ‘ ğ‘’ ğ‘¥ âˆˆ ğ‘‹         
ğ‘       ğ‘ ğ‘’ ğ‘¥ âˆˆ ğ‘Œ âˆ’ ğ‘‹ 
 0       ğ‘ ğ‘’ ğ‘¥ âˆ‰ ğ‘Œ âˆª ğ‘‹  

EntÃ£o, no processo de obtenÃ§Ã£o de um independente maximal com peso mÃ¡ximo, o 

algoritmo ganancioso comeÃ§a por escolher todos os elementos de X; consequentemente, nÃ£o 

vai poder escolher nenhum elemento de Y, pois estamos a assumir que ğ‘‹ âˆª {ğ‘¦} âˆ‰ ğ¼ para todo o 

ğ‘¦ âˆˆ ğ‘Œ âˆ’ ğ‘‹.  Assim,  os  elementos  restantes  que  o  algoritmo  escolhe  tÃªm  de  pertencer  a                 

ğ¶ âˆ’ (ğ‘‹ âˆª ğ‘Œ),  pelo  que  todos  terÃ£o  peso  0.  Portanto,  o  peso  do  independente  maximal  Z 

selecionado  pelo  algoritmo  ganancioso  Ã©  dado  por  ğ‘¤(ğ‘) = |ğ‘‹|.  Por  outro  lado,  sendo  Y 

independente, existe algum ğ‘Š âˆˆ ğ¼ maximal tal que ğ‘Œ âŠ† ğ‘Š, e tem-se 

ğ‘¤(ğ‘Š) â‰¥ ğ‘¤(ğ‘Œ) = ğ‘¤(|ğ‘‹ âˆ© ğ‘Œ|) + ğ‘¤(|ğ‘Œ âˆ’ ğ‘‹|) 

                 = |ğ‘‹ âˆ© ğ‘Œ| + ğ‘|ğ‘Œ âˆ’ ğ‘‹| 

               > |ğ‘‹ âˆ© ğ‘Œ| + |ğ‘‹ âˆ’ ğ‘Œ| 

   = |ğ‘‹| = ğ‘¤(ğ‘) 

Portanto,  o  independente  maximal  W  tem  um  peso  superior  ao  independente 

maximal Z fornecido pelo algoritmo ganancioso. Mostramos assim que, para esta funÃ§Ã£o peso, 

o algoritmo ganancioso nÃ£o alcanÃ§a a soluÃ§Ã£o Ã³tima para o problema. 

Combinando os dois teoremas anteriores, obtemos a seguinte caracterizaÃ§Ã£o: 

Teorema  2.2.3:  Os  complexos  simpliciais  em  que  os  algoritmos  gananciosos 

alcanÃ§am a soluÃ§Ã£o Ã³tima para o PROBLEMA sÃ£o precisamente os matrÃ³ides. 

 
 
 
 
 
 
 
 
 24 

3 CONCLUSÃƒO 

Verificamos que inicialmente Ã© definido o conjunto E e em seguida uma â€œestrutura 

de  independÃªnciaâ€  que  gerarÃ¡  I.  Este  passo  nem  sempre  Ã©  evidente.  Para  a  conclusÃ£o  deste 

trabalho,  veremos  o  porquÃª  de  os  problemas  propostos  que  nos  serviram  como  motivaÃ§Ã£o 

podem ser, ou nÃ£o, resolvidos com o algoritmo ganancioso.  

O problema 3 nÃ£o tem resultado otimizado com o algoritmo ganancioso, logo nÃ£o 

possui estrutura de matrÃ³ide. Com relaÃ§Ã£o ao problema 2, temos um problema de grafos, que 

jÃ¡ foi demonstrado possuir uma estrutura de matrÃ³ide. Logo nos resta analisar o problema 1. 

Vejamos novamente o problema: 

Problema  1.  Um  certo  nÃºmero  de  trabalhos  serÃ¡  executado  por  uma  Ãºnica 

mÃ¡quina. Todos requerem o mesmo tempo de processamento, uma hora. EstÃ£o associados 

a  um  tempo  para  entrega,  o  qual  nÃ£o  satisfeito,  implica  em  uma  penalidade  fixa  ğ’‘ğ’Š, 

independente do atraso. Determinar a sequÃªncia para execuÃ§Ã£o dos trabalhos de forma 

que o total das penalidades seja mÃ­nimo. 

Nesse problema um conjunto de trabalhos serÃ£o executados. Seja ğ¸ = {ğ‘’1, â€¦ , ğ‘’ğ‘›} 

este  conjunto  de  trabalhos.  A  cada  trabalho  estÃ¡  associado  um  tempo  de  entrega  e  uma 

penalidade. Podemos assim separar os trabalhos em conjuntos por tempo de entrega. Seja ğ‘„ =

{ğ‘„1, â€¦ , ğ‘„ğ‘›} onde ğ‘„ğ‘– contÃ©m todos os trabalhos a serem entregues no tempo ğ‘¡ = ğ‘–. Definimos 

assim um matrÃ³ide transversal ğ‘€ = (ğ¸, ğ¼) sobre ğ¸. ğ¼ Ã© o conjunto dos parciais transversais de 

ğ‘„, ou seja, o conjunto de sequÃªncias para execuÃ§Ã£o dos trabalhos. Como a cada elemento de ğ¸ 

estÃ¡  associada  uma  penalidade,  uma  funÃ§Ã£o  de  pesos  nÃ£o  negativa,  aplicando  o  algoritmo 

ganancioso, obtemos um transversal S de peso mÃ¡ximo. Consequentemente uma sequÃªncia para 

execuÃ§Ã£o dos trabalhos com um total mÃ­nimo de penalidade.  

 
 
 
 
 
 
 
 
 
 25 

REFERÃŠNCIAS 

ALES, R. MatrÃ³ides e cÃ³digos quÃ¢nticos. 2017. 87p. DissertaÃ§Ã£o (Mestrado em CiÃªncias) â€“ 
Universidade Estadual de Ponta Grossa, Ponta Grossa, 2017. 

FERNANDES, R. O que Ã© um matrÃ³ide? Gazeta de MatemÃ¡tica, n. 175, ano 76, p. 36-40, 
mar. 2015. DisponÃ­vel em: https://gazeta.spm.pt/get?gid=175. Acesso em: 02 jan. 2023. 

MATEUS,  G.  R.  MatrÃ³ides  e  algoritmos  greedy.  1980.  249  p.  DissertaÃ§Ã£o  (Mestrado  em 
Engenharia  de  Sistemas  e  ComputaÃ§Ã£o)  â€“  Universidade  Federal  do  Rio  de  Janeiro,  Rio  de 
Janeiro, 1980. 

OXLEY, J. G. Matroid theory. Oxford: Oxford University Press, 1992. 

PARBERRY, I. Problems on algorithms. Englewood Cliffs, N. J.: Prentice Hall, 1995. 

WHITNEY,  H.  On  the  abstract  properties  of  linear  dependence.  American  Journal 
Mathematics, v. 57, n. 3, p. 509-533, Jul. 1935. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
