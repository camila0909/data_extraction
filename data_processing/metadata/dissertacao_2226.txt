Paulo Cesar dos Santos

C ´odigos veriﬁcadores e corretores de erros

Santo Andr´e, 2018

Universidade Federal do ABC

Centro de Matem´atica, Computac¸ ˜ao e Cognic¸ ˜ao

Paulo Cesar dos Santos

C ´odigos veriﬁcadores e corretores de erros

Orientador: Prof. Dr. Armando Caputi

Dissertac¸ ˜ao de mestrado apresentada ao Centro de

Matem´atica, Computac¸ ˜ao e Cognic¸ ˜ao para

obtenc¸ ˜ao do t´ıtulo de Mestre

Este exemplar corresponde a vers ˜ao final da dissertac¸ ˜ao
defendida pelo aluno Paulo Cesar dos Santos,
e orientada pelo Prof. Dr. Armando Caputi.

Santo Andr´e, 2018

Sistema de Bibliotecas da Universidade Federal do ABCElaborada pelo Sistema de Geração de Ficha Catalográfica da UFABCcom os dados fornecidos pelo(a) autor(a).Santos, Paulo Cesar     Códigos verificadores e corretores de erros / Paulo Cesar Santos. — 2018.     76 fls.     Orientador: Armando Caputi     Dissertação (Mestrado) — Universidade Federal do ABC, MestradoProfissional em Matemática em Rede Nacional - PROFMAT, SantoAndré, 2018.     1. identificação de erros. 2. sistemas modulares. 3. códigos corretores deerros. 4. códigos lineares. I. Caputi, Armando. II. Mestrado Profissional emMatemática em Rede Nacional - PROFMAT, 2018. III. Título.Dedico este trabalho ao meu ﬁlho Augusto

Seabra dos Santos e aos meus pais.

v

A G R A D E C I M E N T O S

Agradec¸o a Deus por esta conquista e por me dar forc¸a nessa trajet ´oria.
`A minha esposa Priscila e ao meu ﬁlho Augusto, por compreender minha ausˆencia

nesses anos de estudos.

`A minha irm˜a Luciana, por sempre me motivar.
Aos meus pais, por sempre incentivar meus estudos e sempre fazer o poss´ıvel para

ajudar.

`A CAPES, pelo apoio ﬁnanceiro.
Aos professores do PROFMAT da UFABC.

Aos colegas da turma.
`A diretora Ana Paula e coordenadora Evelise da EE Profa Ruth S´a, por sempre ajustar

meus hor´arios e incentivar a continuidade de meus estudos.

Em especial, ao professor Armando Caputi, por sua paciˆencia e dedicac¸ ˜ao `as orientac¸ ˜oes.

vii

“ ´E imposs´ıvel progredir sem mudanc¸a, e aqueles que
n˜ao mudam suas mentes n˜ao podem mudar nada.”

(George Bernard Shaw)

ix

R E S U M O

Nesta dissertac¸ ˜ao, apresentamos os d´ıgitos que veriﬁcam erros em c ´odigos num´ericos

e os c ´odigos que identiﬁcam e corrigem erros em informac¸ ˜oes transmitidas ou armaze-

nadas. Em relac¸ ˜ao aos d´ıgitos que veriﬁcam erros, enfocamos os sistemas modulares,

os principais erros que podem ser cometidos na digitac¸ ˜ao de sequˆencias num´ericas e

a eﬁciˆencia do d´ıgito para detectar sua presenc¸a. J´a em c ´odigos corretores de erros,

denotamos os conceitos de um c ´odigo e sua utilidade em um sistema de comunicac¸ ˜ao,

mostramos como codiﬁcar uma informac¸ ˜ao e depois como decodiﬁc´a-la corrigindo erros,

caso existam. Finalmente, explicitamos algumas aplicac¸ ˜oes dos d´ıgitos veriﬁcadores e

c ´odigos corretores de erros para o Ensino Fundamental e M´edio.

Palavras-chave: identiﬁcac¸ ˜ao de erros, sistemas modulares, c ´odigos corretores de

erros, c ´odigos lineares

xi

A B S T R A C T

In this dissertation, we present the digits that verify errors in numerical codes and the

codes that identify and correct errors in transmitted or stored information. Regarding

the digits that verify errors, we focus on the modular systems, the main errors that can

be presented during the typing of numerical sequences and the efﬁciency of the digit to

detect their presence. As for theerror-correcting codes, we denote the concepts of a code

and its use in a communication system, we show how to code pieces of information

and then how to decode it correcting errors, in case they exist. Finally, we described in

details some applications of the veriﬁer digits and error correction codes for Elementary

and Middle School.

Keywords: error identiﬁcation, modular systems, error-correcting codes, linear codes

xiii

C O N T E ´U D O

introduc¸ ˜ao

1

1 conceitos preliminares

3

3

1.1 Divisibilidade
1.2 M´aximo Divisor Comum e equac¸ ˜oes Diofantinas
1.3 Congruˆencia
1.4 An´eis e Corpos
1.5 Classes Residuais

10

12

6

4

2 sistemas de identificac¸ ˜ao modulares

15

2.1 An´alise geral dos sistemas de identiﬁcac¸ ˜ao modulares

16

2.1.1 C ´odigos de barras
2.1.2
Sistema ISBN
2.1.3 D´ıgitos do CPF - Cadastro de pessoas f´ısicas na Receita Fede-

18

16

20
2.2 Erros detect´aveis e n˜ao detect´aveis

ral

22

2.2.1 An´alise de d´ıgitos de veriﬁcac¸ ˜ao m ´odulo k
2.2.2 An´alise de d´ıgitos de veriﬁcac¸ ˜ao m ´odulo 10
2.2.3 An´alise de d´ıgitos de veriﬁcac¸ ˜ao m ´odulo 11

23

25

27

3 c ´odigos corretores de erros

29

3.1 M´etrica de Hamming
3.2 Equivalˆencia de C ´odigos
39
3.3 C ´odigos Lineares

33

38

3.3.1 C ´odigo Linear obtido como imagem ou n ´ucleo de uma transformac¸ ˜ao

linear

41
3.3.2 Matriz Geradora de um C ´odigo
3.3.3 C ´odigos Duais
3.4 Decodiﬁcac¸ ˜ao de canal

51

47

42

xv

xvi

Conte ´udo

4 aplicac¸ ˜oes

63

4.1 Sequˆencia para o Ensino Fundamental

63

4.1.1
4.1.2
4.1.3
4.1.4

64

1a etapa - o que ´e um c ´odigo?
2a etapa - vamos entender um c ´odigo de barras EAN 13?
3a etapa - o que ´e um d´ıgito veriﬁcador?
4a etapa - construindo um c ´odigo num´erico para identiﬁcar s ´olidos
66
geom´etricos
6a etapa - avaliac¸ ˜ao

66

65

4.1.5

67
4.2 Sequˆencia para o Ensino M´edio

67

4.2.1
4.2.2
4.2.3
4.2.4
4.2.5

1a etapa - entendendo um c ´odigo corretor de erros
2o etapa - congruˆencia M ´odulo M e Classes Residuais
3a etapa - codiﬁcar uma informac¸ ˜ao
4a etapa - m´etodo para corrigir um erro
5a etapa - avaliac¸ ˜ao

71

69

73

68

69

I N T R O D U C¸ ˜A O

Nesta dissertac¸ ˜ao, apresentamos e demonstramos os conceitos dos d´ıgitos veriﬁca-

dores de erros em c ´odigos num´ericos e c ´odigos que identiﬁcam e corrigem erros em

informac¸ ˜oes transmitidas ou armazenadas.

Os c ´odigos num´ericos est˜ao presentes em diversas situac¸ ˜oes nos nossos h´abitos

corriqueiros do dia a dia, como por exemplo em sequˆencias num´ericas de c ´odigos de

barras, CPF, RG, contas banc´arias e em diversas outras situac¸ ˜oes.

Os d´ıgitos desses c ´odigos num´ericos utilizam uma congruˆencia m ´odulo k e um vetor

de pesos estabelecido pelo sistema para veriﬁcar a presenc¸a de erros em sequˆencias

num´ericas. Os d´ıgitos conseguem identiﬁcar os erros mais comuns cometidos por falha

humana e apresentam um resultado mais eﬁciente quando o valor de k ´e um n ´umero

primo.

Utilizamos os c ´odigos corretores toda vez que assistimos a um ﬁlme, enviamos um

e-mail etc. Os c ´odigos corretores est˜ao presentes em toda informac¸ ˜ao transmitida ou

armazenada por algum meio tecnol ´ogico e seu objetivo ´e identiﬁcar e corrigir erros

causados por alguma interferˆencia.

Os c ´odigos corretores de erros adicionam uma redundˆancia em uma informac¸ ˜ao de

modo que seja poss´ıvel decodiﬁc´a-la corrigindo erros. Usamos uma transformac¸ ˜ao

linear para codiﬁcar o vetor informac¸ ˜ao e depois usamos uma matriz de paridade para

veriﬁcar se a informac¸ ˜ao foi recebida com erro e, caso tenha, por meio de um algoritmo

conseguimos fazer a correc¸ ˜ao.

Podemos perceber que a Matem´atica est´a presente em diversas situac¸ ˜oes em que n˜ao

a notamos. Pensando nisso, esta dissertac¸ ˜ao tem como objetivo mostrar essas aplicac¸ ˜oes

da Matem´atica para que sejam usadas na sala de aula do Ensino Fundamental e M´edio.

Infelizmente, ´e muito comum ouvir dos alunos do Ensino Fundamental e M´edio que

n˜ao conseguem ver aplicac¸ ˜oes para os conte ´udos do curr´ıculo da Matem´atica, que a

acham dif´ıcil e desestimulante. Mostrar uma situac¸ ˜ao em que o aluno possa aplicar e

contextualizar o conte ´udo da aula tem um resultado mais satisfat ´orio e signiﬁcativo no

processo ensino-aprendizagem.

1

2

introduc¸ ˜ao

Esta dissertac¸ ˜ao foi dividida como segue:

No primeiro cap´ıtulo, apresentamos alguns conceitos preliminares como: Divisibi-

lidade, Equac¸ ˜oes Diofantinas, Congruˆencia M ´odulo k, Congruˆencias Lineares, Anel e

Corpo. Tais conceitos foram utilizados com ferramentas para demonstrar nos demais

cap´ıtulos teoremas e proposic¸ ˜oes.

No segundo cap´ıtulo, apresentamos os d´ıgitos que veriﬁcam erros em c ´odigos

num´ericos, como por exemplo: n ´umero do c ´odigo de barras, n ´umeros de CPF e RG e

c ´odigo ISBN. Em seguida, analisamos os principais erros que podem ser cometidos por

falha humana na digitac¸ ˜ao de uma sequˆencia num´erica e ﬁzemos tamb´em uma an´alise

para veriﬁcar a eﬁciˆencia dos d´ıgitos nos casos dos erros mais comuns.

No terceiro cap´ıtulo, apresentamos os c ´odigos que fazem a identiﬁcac¸ ˜ao e correc¸ ˜ao

dos erros que ocorrem em informac¸ ˜oes transmitidas ou armazenadas. Demonstramos

os C ´odigos Lineares – que ´e a classe de c ´odigos mais utilizada –, Distˆancia Hamming e

algoritmos para fazer a decodiﬁcac¸ ˜ao de mensagens e corrigir erros, caso existam.

Por ´ultimo, no quarto cap´ıtulo, apresentamos uma sequˆencia de etapas que permite

contextualizar o ensino da Matem´atica no Ensino Fundamental e M´edio. O objetivo

desta etapa do trabalho ´e mostrar a Matem´atica presente em diversas situac¸ ˜oes no nosso

cotidiano.

1

C O N C E I T O S P R E L I M I N A R E S

Este cap´ıtulo ser´a destinado a deﬁnic¸ ˜ao e demonstrac¸ ˜ao de conceitos que ser˜ao

usados como ferramentas para embasar os c ´odigos identiﬁcadores e corretores de

erros. Um estudo mais detalhado dos assuntos deste cap´ıtulo podem ser encontradas
em [1], [2], [5].

1.1 divisibilidade

Deﬁnic¸ ˜ao 1.1. Dados dois inteiros a (cid:54)= 0 e b, dizemos que b ´e divis´ıvel por a escrevendo a | b,
quando existir c ∈ Z tal que b = ca. Nesse caso, podemos dizer tamb´em que a ´e divisor ou
um fator de b, e b ´e m ´ultiplo ou divis´ıvel por a. Quando b n˜ao for divis´ıvel por a, usaremos a
seguinte notac¸˜ao: a (cid:45) b.

Quando um inteiro a, diferente de zero, n˜ao divide um inteiro b, Euclides, nos seus

Elementos, utiliza, sem enunci´a-lo, o fato de que sempre ´e poss´ıvel efetuar a divis˜ao de

b por a, com resto.

Teorema 1.2 (Teorema de Euclides). Sejam a e b dois inteiros com b (cid:54)= 0. Existem dois
n ´umeros inteiros q e r tais que:

a = bq + r , com 0 ≤ r < |b|

(1.1)

Nas condic¸ ˜oes do teorema acima, temos que os n ´umero r e q s˜ao chamados, respecti-

vamente, de resto e quociente da divis˜ao de a por b. A demonstrac¸ ˜ao do Teorema de
Euclides est´a dispon´ıvel no livro Hefez [1].

3

4

conceitos preliminares

1.2 m ´aximo divisor comum e equac¸ ˜oes diofantinas

Deﬁnic¸ ˜ao 1.3. Um n ´umero inteiro d ser´a chamado de divisor comum de inteiros a e b se d | a e
d | b.

Deﬁnic¸ ˜ao 1.4. Seja d um inteiro positivo, dizemos que d ´e o m´aximo divisor comum de a e b,

usaremos a notac¸˜ao (a, b), se possuir as seguintes propriedades:

i- d ´e um divisor comum de a e b, e

ii- d ´e divis´ıvel por todo divisor comum de a e b.

Apresentaremos agora, algumas propriedades do M´aximo Divisor Comum de dois

n ´umeros inteiros. Para isso, ser´a deﬁnido o conjunto de todas as combinac¸ ˜oes inteiras

dos inteiros a e b:

I = {ma + nb; m, n ∈ Z}

Teorema 1.5 (Teorema de B´ezout). Se d = (a, b), ent˜ao existem m, n ∈ Z tais que am + bn = d.

Demonstrac¸˜ao. Seja p o menor elemento positivo de I, p = ma + nb. Vamos considerar o

resto e quociente da divis˜ao de a por p como r e q respectivamente:

a = pq + r, com 0 ≤ r < p

r = a − pq

r = a − (am + nb)q

r = a(1 − mq) + b(−nq)

Se fosse r > 0, ter´ıamos r ∈ I, contradizendo a hip ´otese de p ser o menor elemento do
elemento do conjunto I. Logo r = 0 e p | a. De modo an´alogo, p | b e, pela Deﬁnic¸ ˜ao 1.3,
p | d.

Agora, vamos provar que d | p. Pela Deﬁnic¸ ˜ao 1.3, temos que d | a e d | b, neste caso

podemos escrever a = a1d e b = b1d para a1, b1 ∈ Z. E

p = ma + nb

p = ma1d + nb1d

p = d(a1m + b1n)

d | p

Conclu´ımos ent˜ao que p = d.

1.2 m ´aximo divisor comum e equac¸ ˜oes diofantinas

5

Observe que da demonstrac¸ ˜ao acima, segue que se d ´e o menor elemento positivo de

I, ent˜ao d = (a, b).

Deﬁnic¸ ˜ao 1.6. Dados dois inteiros a e b, dizemos que eles s˜ao primos entre si se (a, b) = 1.

A seguir apresentaremos as equac¸ ˜oes diofantinas lineares que ajudam a resolver

v´arios problemas de aritm´etica e ser´a usada na pr ´oxima sec¸ ˜ao para demonstrar o
Teorema 1.15 que vai ser fundamental do Cap´ıtulo 2.

Proposic¸ ˜ao 1.7. A equac¸˜ao aX + bY = c, com a, b, c ∈ Z, admite soluc¸˜ao em inteiros se, somente
se, (a, b) | c.

Demonstrac¸˜ao. Vamos supor que (x0, y0) seja uma soluc¸ ˜ao da equac¸ ˜ao e (a, b) = d,
sabemos que a = a1d e b = b1d, logo:

ax0 + by0 = c

a1x0d + b1y0d = c

d(a1x0 + b1y0) = c

d | c

Reciprocamente, se d | c, ent˜ao existe c1 ∈ Z tal que c = dc1. O Teorema 1.5 garante a

existˆencia de um par (x0, y0) tal que

ax0 + by0 = d

Multiplicando ambos os lados da equac¸ ˜ao acima por c1

c1ax0 + c1by0 = dc1

c1ax0 + c1by0 = c1d = c

donde obtemos a soluc¸ ˜ao (c1x0, c1y0) da equac¸ ˜ao diofantina.

6

conceitos preliminares

Podemos estender os resultados acima para n vari´aveis. Para iniciar, generalizamos a

deﬁnic¸ ˜ao do mdc para n n ´umeros inteiros:

Deﬁnic¸ ˜ao 1.8. Seja d um inteiro positivo, dizemos que d ´e o m´aximo divisor comum de a1, ..., an,
se:

i- d ´e um divisor comum de a1, ..., an;

ii- d ´e divis´ıvel por todo divisor comum de a1, ..., an.

Iremos indicar o mdc de n inteiros com a seguinte notac¸ ˜ao (a1, ..., an). Segue facilmente

da deﬁnic¸ ˜ao que

(a1, . . . , an−1, an) = (a1, . . . (an−1, an))

Da igualdade acima, usando indutivamente a demonstrac¸ ˜ao do Teorema de Bezout,

obtemos a vers˜ao deste teorema para n inteiros:

Teorema 1.9 (Teorema de B´ezout (generalizado)). Se d = (a1, a2, . . . , an), ent˜ao existem
m1, m2, . . . , mn ∈ Z tais que m1a1 + m2a2 + · · · + mnan = d.

Por ﬁm, para equac¸ ˜oes diofantinas de n vari´aveis temos o seguinte resultado:

Proposic¸ ˜ao 1.10. A equac¸˜ao diofantina a1x1 + ... + anxn = c, a1 ∈ Z e c ∈ Z, admite soluc¸˜ao
se, e somente se, (a1, ..., an) divide c.

A demonstrac¸ ˜ao ´e an´aloga `a do caso de duas vari´aveis.

1.3 congru ˆencia

A congruˆencia m ´odulo m ´e uma das ferramentas mais importantes na Teoria dos

N ´umeros, que chamamos de Matem´atica Modular ou Aritm´etica dos Restos. Uma

congruˆencia ´e uma relac¸ ˜ao entre dois inteiros que quando divididos por um terceiro

deixam o mesmo resto, este terceiro inteiro ´e chamado de m ´odulo da congruˆencia. Nesta

sec¸ ˜ao, ser´a apresentado sua deﬁnic¸ ˜ao e propriedades de acordo com a necessidade de

elucidar suas aplicac¸ ˜oes, para oportunizar melhor entendimento no pr ´oximo cap´ıtulo,

onde as aplicaremos.

A relac¸ ˜ao de congruˆencia m ´odulo m entre dois inteiros est´a relacionada com a divis˜ao

euclidiana desses por um terceiro n ´umero ﬁxo, e foi introduzida por Gauss no seu livro
Disquisitiones Arithmeticae em 1801.

1.3 congru ˆencia

7

Deﬁnic¸ ˜ao 1.11. Seja m um n ´umero natural maior do que 1, dizemos que dois n ´umeros inteiros

a e b s˜ao congruentes m´odulo m se os restos de sua divis˜ao por m s˜ao iguais. Quando dois
inteiros s˜ao congruentes m´odulo m, escreve-se a ≡ b mod m.

Observe o seguinte exemplo: 31 ≡ 21 mod 10, pois a divis˜ao de 31 por 10 deixa o

mesmo resto que a de 21 por 10.

Para veriﬁcar se dois inteiros a e b s˜ao congruentes mod m, n˜ao ´e necess´ario fazer a

divis˜ao euclidiana de ambos por m, ´e suﬁciente usar a seguinte proposic¸ ˜ao:

Proposic¸ ˜ao 1.12. Tem-se a ≡ b mod m se, somente se, m | (a − b).

Demonstrac¸˜ao. Se a ≡ b mod m, ent˜ao existem f , p e r inteiros, tais que a = f .m + r e
b = p.m + r. Subtraindo uma da outra a − b = m.( f − p) logo, pela Deﬁnic¸ ˜ao 1.1 temos
que m | (a − b).

Reciprocamente, suponhamos que m | (a − b) pela divis˜ao euclidiana temos que
a = f .m + r com 0 ≤ r < m e b = m.p + q com 0 ≤ q < m. Subtraindo as equac¸ ˜oes
encontramos a − b = m.( f − p) + (r − q), como m | (a − b) conclu´ımos que m | (r − q) e
r = q, pois | r − q |< m.

Portanto a ≡ b mod m.

A seguir, temos algumas propriedades que s˜ao de grande utilidade, pois ser˜ao usadas

para demonstrar algumas aplicac¸ ˜oes no Cap´ıtulo 2.

Proposic¸ ˜ao 1.13. Sejam a, b, c, d, m, n inteiros com m > 1 e n ≥ 1. Temos as seguintes
propriedades:

(i) a ≡ a mod m;

(ii) Se a ≡ b mod m, ent˜ao b ≡ a mod m;

(iii) Se a ≡ b mod m e b ≡ c mod m, ent˜ao a ≡ c mod m;

(iv) Se a ≡ b mod m e c ≡ d mod m, ent˜ao (a + c) ≡ (b + d) mod m;

(v) Se a ≡ b mod m e c ≡ d mod m, ent˜ao a.c ≡ b.d mod m;

(vi) Se a ≡ b mod m, ent˜ao an ≡ bn mod m.

Demonstrac¸˜ao. As demostrac¸ ˜oes de i e ii s˜ao triviais.

8

conceitos preliminares

iii - Se a ≡ b mod m e b ≡ c mod m, ent˜ao m | (a − b) e m | (b − c), logo m |

(a − b + b − c). Portanto m | (a − c), ou seja, a ≡ c mod m.

iv - Se a ≡ b mod m e c ≡ d mod m, temos por deﬁnic¸ ˜ao que m | (a − b) e m | (c − d),
usando as propriedades da divis˜ao de Euclides podemos concluir que m | (a − b + c − d)
ou podemos escrever da seguinte forma m | ((a + c) − (b + d)) o que leva a concluir que
(a + c) ≡ (b + d) mod m.

v - Se a ≡ b mod m e c ≡ d mod m, temos que m | (a − b) e m | (c − d). Observe que:

a.c − b.d = a(c − d) + d(a − b)

Logo, como m | (c − d) e m | (a − b) podemos conluir que m | (a.c − b.d). Portanto

a.c ≡ b.d mod m.

vi - Para demonstrar est´a propriedade ser´a usado induc¸ ˜ao sobre n.

Seja P(n): an ≡ bn mod m.

P(n) ´e v´alida para n = 1, pois a ≡ b mod m por hip ´otese. Suponha P(k) v´alida para

algum k natural. Temos que:

Temos pela hip ´otese de induc¸ ˜ao que:

ak ≡ bk mod m.

E por hip ´otese:

ak ≡ bk mod m

a ≡ b mod m

Aplicando a propriedade v nas equac¸ ˜oes 1.2 e 1.3 temos:

ak+1 ≡ bk+1 mod m

Portanto, por induc¸ ˜ao P(n) ´e v´alida para todo n natural.

(1.2)

(1.3)

1.3 congru ˆencia

9

Observac¸ ˜ao 1.14. De acordo com as propriedades i, ii e iii, podemos concluir que uma relac¸˜ao

de congruˆencia m´odulo m ´e uma relac¸˜ao de equivalˆencia nos inteiros.

E agora, apresentaremos dois teoremas que ser˜ao fundamentais no pr ´oximo cap´ıtulo:

Teorema 1.15. A congruˆencia linear ax ≡ b mod m admite soluc¸˜ao se, somente se, (a, m) | b.

Demonstrac¸˜ao. Vamos supor que a equac¸ ˜ao tenha soluc¸ ˜ao, temos que:

ax ≡ b mod m

m | (ax − b)

Logo, existe um inteiro t, tal que:

mt = ax − b

b = mt − ax

Seja o (a, m) = k, ent˜ao k | a e k | m, logo existem p, d ∈ Z:

a = kd e m = kp

Substituindo as equac¸ ˜oes 1.4 e 1.5, temos:

b = kpt − kdx

b = k(pt − dx)

(1.4)

(1.5)

E portanto k | b
Reciprocamente, se (a, m) | b, a equac¸ ˜ao b = mt − ax sempre admite soluc¸ ˜ao inteira,

por consequˆencia da Proposic¸ ˜ao 1.7.

Teorema 1.16. Sejam a e x n ´umeros inteiros, temos ax (cid:54)≡ 0 mod m, para todo x ∈ {1, ..., m −
1} se, e somente se, (a, m) = 1.

10

conceitos preliminares

Demonstrac¸˜ao. Suponhamos (a, m) = d > 1, logo d | a e d | m e assim a = dd1 e m = dd2
com d2 ∈ {1, ..., m − 1}. Fazendo d2 = x, encontramos o seguintes resultado:

ax = ad2 = d1dd2 = d1m ≡ 0 mod m

O que ´e um absurdo pois ax (cid:54)≡ 0 mod m e portanto d = 1.

Reciprocamente, se (a, m) = 1 e seja x ∈ {1, ..., m − 1} tal que ax ≡ 0 mod m, temos
que m | ax, portanto m | x o que seria um absurdo. Logo ax (cid:54)≡ 0 mod m para
x ∈ {1, ..., m − 1}.

1.4 an ´eis e corpos

Nesta sec¸ ˜ao, ser˜ao deﬁnidos os conceitos de anel e corpo, que ser˜ao usados como

ferramentas no cap´ıtulo 3.

Deﬁnic¸ ˜ao 1.17. Um anel ´e um conjunto A munido das operac¸˜oes adic¸˜ao ( + ) e multiplicac¸˜ao
(×):

+ : A × A → A

e × : A × A → A

(a, b) → a + b

(a, b) → a × b

Que satisfazem as seguintes propriedades:

1. Associatividade da adic¸˜ao:

∀a, b, c ∈ A, (a + b) + c = a + (b + c)

2. Existˆencia de um elemento neutro para a adic¸˜ao, ou seja, existe um elemento chamado zero e

denotado por 0, tal que:

∀ a ∈ A, a + 0 = 0 + a = a

3. Existˆencia de um elemento oposto para a adic¸˜ao, ou seja, existe (−a) ∈ A, tal que:

a + (−a) = (−a) + a = 0

1.4 an ´eis e corpos

11

4. Comutatividade da adic¸˜ao:

∀ a, b ∈ A, a + b = b + a

5. Associatividade da multiplicac¸˜ao:

∀a, b, c ∈ A, (a × b) × c = a × (b × c)

6. Distributividade da multiplicac¸˜ao em relac¸˜ao a adic¸˜ao:

∀a, b, c ∈ A, a × (b + c) = a × b + a × c

Exemplo 1.1. O conjunto dos n ´umeros inteiros Z, racionais Q e reais R, munido das operac¸˜oes

usuais de adic¸˜ao e multiplicac¸˜ao s˜ao exemplos de an´eis .

Deﬁnic¸ ˜ao 1.18. Se um anel A possuir um elemento neutro para a multiplicac¸˜ao, denotado 1,

dizemos que A ´e um anel com unidade.

Deﬁnic¸ ˜ao 1.19. Dado um elemento a de um anel com unidade A, dizemos que ser´a invert´ıvel se
existir um elemento b ∈ A, tal que a × b = 1. Quando isso ocorre, dizemos que b ´e um inverso
de a.

Deﬁnic¸ ˜ao 1.20. Um anel com unidade onde todo elemento n˜ao nulo ´e invert´ıvel ´e chamado de

corpo.

Exemplo 1.2. O conjunto dos n ´umeros reais R, juntamente com as operac¸˜oes usuais de adic¸˜ao

e multiplicac¸˜ao ´e um exemplo de corpo.

Exemplo 1.3. O conjunto A = {0, 1} munido das operac¸˜oes da adic¸˜ao e multiplicac¸˜ao deﬁnidas
abaixo ´e um corpo.

e

+ 0

0

1

0

1

× 0

0

1

0

0

1

1

0

1

0

1

12

conceitos preliminares

1.5 classes residuais

Nesta sec¸ ˜ao, apresentaremos o conceito de classes residuais de Z m ´odulo m.
Qualquer relac¸ ˜ao de congruˆencia m ´odulo m deﬁne uma relac¸ ˜ao de equivalˆencia nos

inteiros, e essas classes de equivalˆencia s˜ao chamadas de classes de congruˆencia ou

classes residuais.

Deﬁnic¸ ˜ao 1.21. A classe residual m´odulo m de um elemento a ∈ Z ´e o conjunto:

[a] = {x ∈ Z; x ≡ a mod m}

O elemento a ser´a chamado de representante da classe residual [a].

O conjunto de todas as classes residuais m ´odulo m, indicado por Zm, ´e:

Zm = {[0], [1], ..., [m − 1]}

Temos que Zm ´e um anel (com unidade) ﬁnito com m elementos.

Exemplo 1.4. Seja m = 2. Logo temos que Z2 = {[0], [1]} com as seguintes operac¸˜oes

+

[0]

[1]

[0]

[0]

[1]

× [0]

[0]

[1]

[0]

[0]

[1]

[1]

[0]

[1]

[0]

[1]

´e um anel. Temos que [1] ´e o ´unico elemento n˜ao nulo de Z2 e ´e invert´ıvel, logo Z2 ´e um corpo.

Exemplo 1.5. Seja m = 3, temos que Z3 = {[0], [1], [3]} com as operac¸˜oes e adic¸˜oes da tabela
abaixo, como [1] e [2] s˜ao invert´ıveis, temos que Z3 ´e um corpo.

+

[0]

[1]

[2]

[0]

[0]

[1]

[2]

[1]

[1]

[2]

[0]

[2]

[2]

[0]

[1]

1.5 classes residuais

13

× [0]

[0]

[1]

[2]

[0]

[0]

[0]

[1]

[0]

[1]

[2]

[2]

[0]

[2]

[1]

2

S I S T E M A S D E I D E N T I F I C A C¸ ˜A O

M O D U L A R E S

No nosso cotidiano, quando utilizamos meios tecnol ´ogicos para digitar uma informac¸ ˜ao

podem ocorrer erros na digitac¸ ˜ao ou na transmiss˜ao. Neste cap´ıtulo ser´a feita uma

an´alise dos d´ıgitos que veriﬁcam a existˆencia de erro na digitac¸ ˜ao de uma sequˆencia

num´erica e no pr ´oximo cap´ıtulo apresentaremos os c ´odigos que fazem correc¸ ˜ao de erros

que podem acontecer na transmiss˜ao de uma informac¸ ˜ao.

Os d´ıgitos veriﬁcadores, presentes em c ´odigos num´ericos, aparecem em diversas

situac¸ ˜oes no nosso dia a dia, como por exemplo, nos n ´umeros de uma conta banc´aria,

nos algarismos do CPF, RG, t´ıtulo de eleitor, n ´umero do cart˜ao de cr´edito, certid˜ao de

nascimento, matr´ıculas de IPTU, c ´odigos de barras e ISBN. Nesses exemplos, usamos

os d´ıgitos para identiﬁcar incorrec¸ ˜oes. No decorrer deste cap´ıtulo, mostraremos essas

aplicac¸ ˜oes da Matem´atica Modular ou Matem´atica dos Restos.

C ´odigos num´ericos que utilizam o d´ıgito veriﬁcador de erros apresentam um conjunto

de regras para estar correto. Se a sequˆencia do c ´odigo n˜ao estiver de acordo com as

regras pr´e estabelecidas pelo sistema, o d´ıgito veriﬁcador indicar´a que a sequˆencia

apresenta n ´umeros inconsistentes. Importante ressaltar que, nesse caso, n˜ao ´e feita

a correc¸ ˜ao autom´atica e n˜ao ´e indicado qual o algarismo est´a incorreto, e pode ser

necess´ario a veriﬁcac¸ ˜ao de todos os algarismos informados. A ideia principal do d´ıgito

´e adicionar um n ´umero suplementar na sequˆencia original do c ´odigo e estabelecer uma

relac¸ ˜ao, que seja ´unica, entre os algarismos da sequˆencia e o d´ıgito.

15

16

sistemas de identificac¸ ˜ao modulares

2.1

an ´alise geral dos sistemas de identificac¸ ˜ao modulares

Os sistemas de identiﬁcac¸ ˜ao modulares apresentam caracter´ısticas semelhantes. Nesta

sec¸ ˜ao, ser´a apresentada uma an´alise geral desses sistemas que utilizam os d´ıgitos como

identiﬁcador ou veriﬁcador de erros em sequˆencias num´ericas.

Todos os c ´odigos num´ericos que utilizam a matem´atica modular para fazer a

identiﬁcac¸ ˜ao de erros apresentam o seguinte formato:

x1x2x3....xnD

(2.1)

Onde D representa o d´ıgito adicional que far´a a veriﬁcac¸ ˜ao dos demais algarismos

digitados, D ´e chamado de d´ıgito veriﬁcador de erros. Considere os algarismos da
sequˆencia x1x2x3....xnD como o vetor α = (x1, x2, x3, ...., xn, D).

Para determinar o valor num´erico de D, utilizamos um vetor de pesos, pr´e estabele-
cido, λ = (p1, p2, ..., pn, pn+1), e os relacionamos aos vetores α e λ atrav´es de um produto
escalar congruente a zero m ´odulo k, sendo k um n ´umero natural pr´e estabelecido pelo
sistema de veriﬁcac¸ ˜ao e p1, ..., pn+1 ∈ Zk

α.λ = (x1, x2, x3, ...., xn, D).(p1, p2, ...pn, pn+1) ≡ 0 mod k

(2.2)

A equac¸ ˜ao acima sempre apresentar´a soluc¸ ˜ao inteira, a partir de oportuna escolha dos

pesos e de k. Como se trata, fundamentalmente, de uma diofantina de duas vari´aveis

X pn+1 + Yk = c(= x1 p1 + · · · + xn pn)

pela Proposic¸ ˜ao 1.7 basta tomar (pn+1, k) = 1. Os d´ıgitos que usam este tipo de sistema
s˜ao chamados de d´ıgitos de veriﬁcac¸ ˜ao m ´odulo k.

2.1.1 C´odigos de barras

O c ´odigo de barras ´e usado mundialmente para identiﬁcar produtos, pois oferecem

vantagens como maior eﬁciˆencia para controlar estoque e maior agilidade no atendi-

mento. O c ´odigo de barras passou por algumas modiﬁcac¸ ˜oes ao longo dos anos, o
mais utilizado ´e o EAN 13, Europen Article Numbering, que ´e uma sequˆencia num´erica
de treze algarismos, e nos EUA e Canad´a, usam o UPC, Universal Product Code, uma

sequˆencia num´erica de doze d´ıgitos.

2.1 an ´alise geral dos sistemas de identificac¸ ˜ao modulares

17

Nesta sec¸ ˜ao, ser´a mostrado o funcionamento do d´ıgito veriﬁcador de erro, que ´e o
d´ecimo terceiro d´ıgito do c ´odigo de barras EAN 13, e ser´a apresentada sua estrutura de
organizac¸ ˜ao.

O c ´odigo de barras EAN 13, da esquerda para direita, ´e dividido em partes que
permite identiﬁcar o pa´ıs de origem, a empresa fabricante e o produto. O ´ultimo

algarismo representa o d´ıgito veriﬁcador, respons´avel por validar as informac¸ ˜oes do
c ´odigo, como na ﬁgura 2.1.

1

Figura 2.1: Exemplo de um c ´odigo de barras

Para determinar a relac¸ ˜ao entre o d´ıgito e as informac¸ ˜oes do c ´odigo usadas para fazer
a identiﬁcac¸ ˜ao das informac¸ ˜oes do EAN 13, vamos representar os seus algarismos na
forma de vetor α:

α = (a1, a2, a3, a4, ..., a11, a12, a13)

(2.3)

Relacionamos o vetor α com um vetor de pesos ﬁxo λ = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1)
de acordo com a equac¸ ˜ao 2.2, o EAN 13 utiliza um sistema de veriﬁcac¸ ˜ao m ´odulo 10.

α.λ = (a1, a2, ..., a12, a13).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10

(2.4)

Exemplo 2.1. Usando o c´odigo de barras da ﬁgura (2.1), temos que os doze primeiros algarismos
s˜ao 560103610017 e o d´ıgito veriﬁcador ´e 4.

1 Dispon´ıvel em http://origemdascoisas.com/a-origem-do-codigo-de-barras/ acesso em 09/01/2017

18

sistemas de identificac¸ ˜ao modulares

Podemos veriﬁcar que com este valor num´erico os algarismos do c´odigo EAN 13 est˜ao corretos,

para isso consideremos α = (5, 6, 0, 1, 0, 3, 6, 1, 0, 0, 1, 7, a13) e usando o vetor de pesos a equac¸˜ao
tem soluc¸˜ao para a13 = 4, pois 0 ≤ a13 ≤ 9.

(5, 6, 0, 1, 0, 3, 6, 1, 0, 0, 1, 7, a13).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10
5.1 + 6.3 + 0.1 + 1.3 + 0.1 + 3.3 + 6.1 + 1.3 + 0.1 + 0.3 + 1.1 + 7.3 + a13.1 ≡ 0 mod 10
5 + 18 + 0 + 3 + 0 + 9 + 6 + 3 + 0 + 0 + 1 + 21 + a13 ≡ 0 mod 10
66 + a13 ≡ 0 mod 10

2.1.2 Sistema ISBN

O sistema ISBN - Internacional Standard Book Number - foi criado em 1967 com a
ﬁnalidade de identiﬁcar, de forma num´erica, livros, CD-ROMs e publicac¸ ˜oes em Braile

segundo o t´ıtulo, o autor, o pa´ıs e a editora, individualizando-os por edic¸ ˜ao.

2

Desde a sua criac¸ ˜ao at´e 01 de janeiro de 2007, os c ´odigos ISBN tinham um formato
com dez algarismos. A partir desta data os n ´umeros ISBN passaram a ter 13 algarismos.
Um ISBN ´e um c ´odigo constitu´ıdo por cinco partes que permitem identiﬁcar o pa´ıs,
editor e t´ıtulo conforme ﬁgura 2.2.

3

2 Dispon´ıvel em http://www.isbn.bn.br/website/ acesso em 13/11/2016
3 Dispon´ıvel em http://isbn.world/747621738469127349812529834387649/sobre˙isbn.html Acesso em

13/11/2016.

2.1 an ´alise geral dos sistemas de identificac¸ ˜ao modulares

19

Figura 2.2: Exemplo de um c ´odigo ISBN

O sistema ISBN de treze d´ıgitos α = (a1, a2, ..., a12, a13) ´e semelhante ao c ´odigo de
barras EAN 13 , da sec¸ ˜ao 2.1.1, para se determinar o valor num´erico do d´ıgito veriﬁcador,
utiliza-se um vetor peso λ = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1), e o produto escalar entre α e
λ deve ser congruente a zero m ´odulo 10.

α.λ = (a1, a2, ..., a12, a13).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10

(2.5)

Exemplo 2.2. O livro A D´ecada de 50 - Populismo e metas desenvolvimentistas no Brasil

escrito por Marly Rodrigues tem como ISBN 9788508042173, sendo o ultimo algarismo o d´ıgito

veriﬁcador.

Fazendo a veriﬁcac¸˜ao, o d´ıgito 3 ´e o ´unico algarismo que torna verdadeira os algarismos de

identiﬁcac¸˜ao do c´odigo ISBN pois 0 ≤ a13 ≤ 9 e:

20

sistemas de identificac¸ ˜ao modulares

(9, 7, 8, 8, 5, 0, 8, 0, 4, 2, 1, 7, a13).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10
9.1 + 7.3 + 8.1 + 8.3 + 5.1 + 0.3 + 8.1 + 0.3 + 4.1 + 2.3 + 1.1 + 7.3 + a13.1 ≡ 0 mod 10
9 + 21 + 8 + 24 + 5 + 0 + 8 + 0 + 4 + 6 + 1 + 21 + a13 ≡ 0 mod 10
107 + a13 ≡ 0 mod 10

2.1.3 D´ıgitos do CPF - Cadastro de pessoas f´ısicas na Receita Federal

O n ´umero do CPF de uma pessoa no Brasil ´e composto por onze algarismos divididos

em duas sec¸ ˜oes. A primeira, com nove n ´umeros, e a segunda, por dois, que s˜ao os

d´ıgitos de veriﬁcac¸ ˜ao que s˜ao calculados separadamente.

Na primeira sec¸ ˜ao, os oito primeiros n ´umeros do CPF s˜ao gerados aleatoriamente e

nono algarismo indica o Estado da regi˜ao ﬁscal respons´avel pela inscric¸ ˜ao. Considere,
por exemplo, o CPF XXX.XXX.XX8 − XX, como o nono algarismo ´e 8, temos que esta
pessoa pertence `a regi˜ao de S˜ao Paulo. Outras regi ˜oes usam outros n ´umeros de 0 at´e 9
para a sua identiﬁcac¸ ˜ao, por exemplo, o n ´umero 9 indica as regi ˜oes de Paran´a e Santa
Catarina.

Na segunda parte dos algarismos do CPF, o d´ecimo e o d´ecimo primeiro algarismo

representam, respectivamente, os dois d´ıgitos veriﬁcadores. O primeiro d´ıgito, veriﬁca

a validade dos nove primeiros algarismos e o segundo tem a ﬁnalidade de veriﬁcar os

dez primeiros e identiﬁcar um erro, que talvez, n˜ao seja detectado no primeiro d´ıgito.

Para calcular os dois d´ıgitos veriﬁcadores do CPF, usamos uma relac¸ ˜ao de congruˆencia

m ´odulo 11.

Considere o seguinte n ´umero de CPF α = (a1, ..., a9, a10, a11), sendo a10 e a11, respecti-

vamente, o primeiro e o segundo d´ıgito veriﬁcador.

Para determinar o valor num´erico de a10, utilizamos o vetor de pesos

λ1 = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

e o vetor α1 = (a1, ..., a9, a10), que s˜ao os dez primeiros n ´umeros de α. Realizamos a
seguinte operac¸ ˜ao:

λ1.α1 ≡ 0 mod 11

(2.6)

2.1 an ´alise geral dos sistemas de identificac¸ ˜ao modulares

21

Para determinar o valor de a11, utilizamos o vetor de pesos λ2 = (11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

e o vetor α2 = a1, ..., a9, a10, a11). Realizamos a seguinte operac¸ ˜ao:

λ2.α2 ≡ 0 mod 11

(2.7)

Observac¸ ˜ao 2.1. O n ´umero do CPF utiliza d´ıgitos de veriﬁcac¸˜ao de erros m´odulo 11 restrito,

nesse caso utiliza-se o algarismo 0 para representar o n ´umero 10.

Exemplo 2.3. Considere a seguinte numerac¸˜ao de um CPF: 395725638a10a11 , neste caso, para
encontrar o valor num´erico dos dois d´ıgitos veriﬁcadores, devemos realizar as seguintes operac¸˜oes:

Primeiramente, vamos calcular o valor de a10:

(3, 9, 5, 7, 2, 5, 6, 3, 8, a10).(10, 9, 8, 7, 6, 5, 4, 3, 2, 1) ≡ 0 mod11
3.10 + 9.9 + 5.8 + 7.7 + 2.6 + 5.5 + 6.4 + 3.3 + 8.2 + a10.1 ≡ 0 mod11
30 + 81 + 40 + 49 + 12 + 25 + 24 + 9 + 16 + a10 ≡ 0 mod11
286 + a10 ≡ 0 mod11

Como 0 ≤ a10 ≤ 10, temos que a10 = 0, pois 286 ´e m ´ultiplo de 11.
Para determinar o valor de a11, usaremos os nove primeiros d´ıgitos e o d´ecimo encontrado na

equac¸˜ao anterior.

(3, 9, 5, 7, 2, 5, 6, 3, 8, 0, a11).(11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) ≡ 0 mod11
3.11 + 9.10 + 5.9 + 7.8 + 2.7 + 5.6 + 6.5 + 3.4 + 8.3 + 0.2 + a11.1 ≡ 0 mod11
33 + 90 + 45 + 56 + 14 + 30 + 30 + 12 + 24 + 0 + a11 ≡ 0 mod11
334 + a11 ≡ 0 mod11

Como 0 ≤ a11 ≤ 10, temos que a11 = 7.
Podemos concluir que, neste exemplo, o n ´umero do CPF com os d´ıgitos veriﬁcadores ´e 395 725

638 - 07.

Quando digitamos os algarismos do CPF em algum aparelho eletr ˆonico, ´e feita a

veriﬁcac¸ ˜ao dos d´ıgitos informados usando os dois d´ıgitos veriﬁcadores. Caso algum

n ´umero seja digitado errado, aparece uma mensagem informando a invalidade dos

n ´umeros.

22

sistemas de identificac¸ ˜ao modulares

2.2

erros detect ´aveis e n ˜ao detect ´aveis

Nesta sec¸ ˜ao, vamos fazer uma an´alise dos erros que podem ser ou n˜ao detectados pelo

d´ıgito veriﬁcador. Quando fazemos o registro manual de um c ´odigo num´erico, podemos

cometer v´arios equ´ıvocos na digitac¸ ˜ao e nem sempre o d´ıgito consegue identiﬁcar a

presenc¸a destes erros.

Exemplo 2.4 (Erro detect´avel). Consideremos o c´odigo de barras EAN 13 da ﬁgura 2.1 cuja

sequˆencia ´e 5601036100174 seja digitado com um erro ´unico 5602036100174.

(5, 6, 0, 2, 0, 3, 6, 1, 0, 0, 1, 7, 4).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10

5 + 18 + 0 + 6 + 0 + 9 + 6 + 3 + 0 + 0 + 1 + 21 + 4 = 73 (cid:54)≡ 0 mod 10

Como o resultado obtido n˜ao ´e m ´ultiplo de 10, ser´a emitido um aviso informando um erro nos

n ´umeros digitados.

Exemplo 2.5 (Erro n˜ao detect´avel). Usando as informac¸˜oes do exemplo anterior, suponha a

mesma sequˆencia com dois erros de digitac¸˜ao 5602036170174.

(5, 6, 0, 2, 0, 3, 6, 1, 7, 0, 1, 7, 4).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10

5 + 18 + 0 + 6 + 0 + 9 + 6 + 3 + 7 + 0 + 1 + 21 + 4 = 80 ≡ 0 mod 10

Os dois algarismos que foram digitados errados se compensam e o d´ıgito veriﬁcador n˜ao detecta

a presenc¸a de erros.

O matem´atico holandˆes Jacobus Koos Verhoef, nascido em 1927, citado na dissertac¸ ˜ao
de mestrado da autora Carla Rejane Fick Pinz [6], 2013 , pesquisou os principais erros
cometidos por falha humana, e os desacertos cometidos ao digitar uma sequˆencia

num´erica podem ser por digitac¸ ˜ao errada de um ´unico termo, transposic¸ ˜ao adjacente,

transposic¸ ˜ao alternada, erro gˆemeo, erro gˆemeo alternado e outros que representa a
soma de erros com frequˆencia menor de 1%.

2.2 erros detect ´aveis e n ˜ao detect ´aveis

23

Tipo de erro

Erro ´unico

Transposic¸ ˜ao adjacente

Transposic¸ ˜ao alternada

Erro gˆemeo

Erro gˆemeo alternada

Outros

... a (cid:55)→ b ...
ab (cid:55)→ ba
abc (cid:55)→ cba
aa (cid:55)→ bb
aba (cid:55)→ cbc

%
79
10,2
0,8
0,6
0,3
9,1

Tabela 1: Tipos de erros e suas frequˆencias

Ser´a feito uma an´alise da eﬁciˆencia dos d´ıgitos veriﬁcadores m ´odulo k na presenc¸a

de erro ´unico, transposic¸ ˜ao adjacente e transposic¸ ˜ao alternada que s˜ao os principais

erros que possivelmente podem ser cometidos por falha humana. Estes desacertos
representam aproximadamente 90% dos erros mais comuns.

2.2.1 An´alise de d´ıgitos de veriﬁcac¸˜ao m´odulo k

Nesta subsec¸ ˜ao, ser´a feita uma an´alise geral dos sistemas modulares de identiﬁcac¸ ˜ao

m ´odulo k.

Para que o d´ıgito veriﬁcador fac¸a a identiﬁcac¸ ˜ao de erros de transposic¸ ˜ao adjacente,
que pesquisas indicam ser aproximadamente 10% dos erros mais comuns, o sistema
de veriﬁcac¸ ˜ao m ´odulo k utiliza o vetor de pesos com entradas diferentes nas posic¸ ˜oes

adjacentes, pois, caso contr´ario, uma simples troca da posic¸ ˜ao dos algarismos n˜ao altera

o valor da soma e o resultado continua sendo congruente a 0 m ´odulo k.

a1 + a2 + a3 + .... + a10 + a11 + a12 + a13 ≡ 0 mod 10

A seguir, apresentaremos dois teoremas que estabelecem uma condic¸ ˜ao entre o vetor

de pesos e k para que os d´ıgitos detectem erro ´unico e erros de transposic¸ ˜ao.

Teorema 2.2. Um d´ıgito veriﬁcador de erros m´odulo k, com vetor de pesos (p1, ..., pn), detecta
todo erro ´unico αi → α

i, na i-´esima posic¸˜ao se, e somente se, mdc (pi, k) = 1.

(cid:48)

(cid:48)

Demonstrac¸˜ao. Por hip ´otese, temos um erro ´unico na i-´esima posic¸ ˜ao αi → α
i ∈ {0, ..., k − 1}. O d´ıgito identiﬁcar´a a presenc¸a do erro se pi(αi − α
αi, α
portanto, pelo Teorema 1.16, mdc (pi, k) = 1.

i, com
i) (cid:54)≡ 0 mod k,

(cid:48)

(cid:48)

24

sistemas de identificac¸ ˜ao modulares

Reciprocamente, se mdc (pi, k) = 1 e se existissem diferentes αi, α

(cid:48)

que k | pi(αi − α

(cid:48)

i) ter´ıamos k | (αi − α

(cid:48)

i) o que seria um absurdo, pois αi (cid:54)= α

i.

i ∈ {1, ..., k − 1} tais

(cid:48)

Teorema 2.3. Um d´ıgito veriﬁcador de erros m´odulo k, com vetor de pesos (p1, ..., pi, ..., pj, ..., pn),
detecta todos os erros de transposic¸˜ao dos algarismos αi e αj, nas posic¸˜oes i e j se, e somente se,
mdc (pi − pj, k) = 1.

Demonstrac¸˜ao. Sem o erro de transposic¸ ˜ao nas posic¸ ˜oes i e j, ter´ıamos a seguinte equac¸ ˜ao:

α1 p1 + ... + αi pi + ... + αj pj + ... + αn pn ≡ 0 mod k

(2.8)

Por hip ´otese, teve um erro de transposic¸ ˜ao nas posic¸ ˜oes i e j, logo, o d´ıgito n˜ao

identiﬁcar´a a presenc¸a deste erro se:

α1 p1 + ... + αj pi + ... + αi pj + ... + αn pn ≡ 0 mod k

Subtraindo as equac¸ ˜oes 2.8 e 2.9, encontramos:

(pi − pj)(αi − αj) ≡ 0 mod k

(2.9)

(2.10)

Neste caso o d´ıgito detecta a presenc¸a de erros de transposic¸ ˜ao dos algarismos nas
(cid:54)= αj, se

posic¸ ˜oes i e j se, e somente se, para quaisquer αi, αj ∈ {1, ..., k − 1} com αi
(pi − pj)(αi − αj) (cid:54)≡ 0 mod k, portanto, pelo Teorema 1.16, mdc (pi − pj, k) = 1.

Reciprocamente, se mdc (pi − pj, k) = 1 e (pi − pj)(αi − αj) ≡ 0 mod k, temos que

k | (αi − αj) o que ´e um absurdo pois αi, αj ∈ {1, ..., k − 1}.

Podemos concluir que os d´ıgitos veriﬁcadores de erros m ´odulo k, apresenta um

melhor resultado para k = 11 devido a facilidade de encontrar pesos primos com 11.

Para k = 10 o d´ıgito apresenta uma desvantagem, pois o d´ıgito n˜ao consegue satisfazer

simultaneamente os dois teoremas, pois se os pesos s˜ao ´ımpares para atender o primeiro

o segundo n˜ao ´e veriﬁcado, uma vez que a diferenc¸a de dois n ´umeros ´ımpares resulta
em n ´umero par. N˜ao ´e muito utilizado valores de k < 10 devido ao tamanho reduzido

de algarismos que podem ser usados sendo imposs´ıvel veriﬁcar todos erros ´unicos e de

transposic¸ ˜ao.

2.2 erros detect ´aveis e n ˜ao detect ´aveis

25

2.2.2 An´alise de d´ıgitos de veriﬁcac¸˜ao m´odulo 10

Mostraremos nesta subsec¸ ˜ao, uma an´alise da eﬁciˆencia dos d´ıgitos veriﬁcadores que
usam o m ´odulo 10. Analisaremos os principais erros que podem ser cometidos por
falha humana, que s˜ao os erros de transposic¸ ˜ao e erro ´unico.

Quando digitamos um c ´odigo de barras EAN 13 ou outra sequˆencia num´erica que
usa o m ´odulo 10, podemos cometer alguns erros que o d´ıgito veriﬁcador consegue
identiﬁc´a-los, e, em outros casos, isto n˜ao ´e poss´ıvel como mostrados nos Exemplos 2.4
e 2.5.

No Exemplo 2.4, a sequˆencia num´erica apresenta um erro ´unico, fato que Verhoef
indica ser o erro mais comum, e o d´ıgito ´e eﬁciente para identiﬁcar o erro . Tal fato
ocorre, pois pelo Teorema 2.2, os pesos utilizados no EAN 13 s˜ao primos com 10.

Caso seja cometido mais de um erro, o d´ıgito pode ser eﬁciente para identiﬁc´a-lo,

mas n˜ao com toda certeza, pois os n ´umeros poderiam se compensar mutuamente e a
soma continuar sendo m ´ultiplo de 10. Fato que acontece no exemplo 2.5.

Existem erros de transposic¸ ˜ao nos quais n˜ao ´e poss´ıvel identiﬁcar que a sequˆencia

est´a incorreta.

Exemplo 2.6. Considere um c´odigo de barras 7896283800245 que, ao ser digito, foi cometido

um erro de transposic¸˜ao adjacente 7896238800245, temos:

(7, 8, 9, 6, 2, 3, 8, 8, 0, 0, 2, 4, 5).(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) ≡ 0 mod 10

7 + 24 + 9 + 18 + 2 + 9 + 8 + 24 + 0 + 0 + 2 + 12 + 5 = 120 ≡ 0 mod 10

Nesse exemplo 2.6 o d´ıgito ´e ineﬁciente para identiﬁcar a presenc¸a de erro. Isto
ocorre, pelo fato do Teorema 2.3 n˜ao ser satisfeito, pois a diferenc¸a de pesos ´ımpares ´e
um n ´umero par e com isso n˜ao ´e primo com 10. A seguir, apresentaremos um Teorema
espec´ıﬁco para o sistema de identiﬁcac¸ ˜ao m ´odulo 10, para que seja poss´ıvel identiﬁcar
um erro de transposic¸ ˜ao:

Teorema 2.4. Uma ´unica transposic¸˜ao adjacente ´e detectada pelo d´ıgito de sistema de veriﬁcac¸˜ao
m´odulo 10 se |ai − ai+1 | (cid:54)= 5

Demonstrac¸˜ao. Seja a1, a2, ..., ai, ai+1, ..., a12, a13 uma sequˆencia de algarismos de um
c ´odigo de barras EAN 13. Temos que:

a1 + 3.a2 + a3 + ... + 3.ai + ai+1 + ... + 3.a12 + a13 ≡ 0 mod 10

(2.11)

26

sistemas de identificac¸ ˜ao modulares

Considere um erro de transposic¸ ˜ao adjacente, logo: a1, a2, ..., ai+1, ai, ..., a12, a13
O erro n˜ao ser´a identiﬁcado pelo d´ıgito veriﬁcador se:

a1 + 3.a2 + a3 + ... + 3.ai+1 + ai + ... + 3.a12 + a13 ≡ 0 mod 10

(2.12)

Subtraindo as equac¸ ˜oes 2.11 e 2.12, temos:

2.ai − 2ai+1 ≡ 0 mod 10
2.(ai − ai+1) ≡ 0 mod10

Como 0 ≤ ai ≤ 9, que permite concluir que | ai − ai+1 | = 5.

Um erro de transposic¸ ˜ao alternada no c ´odigo de barras EAN 13 n˜ao ser´a identiﬁcado

pelo d´ıgito veriﬁcador.

Observac¸ ˜ao 2.5. Uma transposic¸˜ao alternada do tipo:

..., ai, ai+1, ai+2, ... (cid:55)→ ...ai+2, ai+1, ai, ...

N˜ao ´e detectada pelo d´ıgito veriﬁcador do c´odigo de barras EAN 13.

De fato, seja a1, a2, ..., ai, ai+1, ai+2..., a12, a13 uma sequˆencia de algarismos de um

c ´odigo de barras EAN 13. Temos:

a1 + 3.a2 + a3 + ... + 3.ai + ai+1 + 3.ai+2 + ... + 3.a12 + a13 ≡ 0 mod 10

(2.13)

Suponha um erro de transposic¸ ˜ao alternada e que tenha sido digitado a seguinte

sequˆencia: a1, a2, ..., ai+2, ai+1, ai..., a12, a13. Temos:

a1 + 3.a2 + a3 + ... + 3.ai+2 + ai+1 + 3.ai + ... + 3.a12 + a13 ≡ 0 mod 10

(2.14)

Logo, temos que as equac¸ ˜oes 2.13 e 2.14 s˜ao iguais, ou seja, o d´ıgito veriﬁcador n˜ao

indicar´a nenhum erro ao operador.

2.2 erros detect ´aveis e n ˜ao detect ´aveis

27

2.2.3 An´alise de d´ıgitos de veriﬁcac¸˜ao m´odulo 11

O sistema de identiﬁcac¸ ˜ao m ´odulo 11 consegue satisfazer simultaneamente os dois
Teoremas 2.2 e 2.3, ou seja, o d´ıgito consegue identiﬁcar todos os erros ´unicos e de
transposic¸ ˜ao que representam 90% dos erros mais comuns. Por´em apresentam uma
pequena desvantagem para representar o n ´umero 10, ele pode ser representado em

algarismo romano X e nesse caso recebe o nome de sistema completo m ´odulo 11 ou ser

representado por 0 e recebe o nome de sistema restrito m ´odulo 11.

Um sistema completo m ´odulo 11 por introduzir uma letra, apresenta uma pequena in-

conveniˆencia, como por exemplo quando ´e necess´ario informar uma sequencia num´erica

em um auto atendimento telef ˆonico. J´a um sistema restrito m ´odulo 11 n˜ao ´e poss´ıvel

identiﬁcar erros que alteram o d´ıgito de 0 para 10.

Podemos concluir que o d´ıgito veriﬁcador, ou identiﬁcador de erros, n˜ao ´e eﬁcaz

em todos os casos, por´em, consegue identiﬁcar a presenc¸a de erros em sequˆencias

num´ericas nos casos de equ´ıvocos mais comuns.

3

C ´O D I G O S C O R R E T O R E S D E E R R O S

Neste cap´ıtulo, iremos mostrar o funcionamento de c ´odigos que fazem a detecc¸ ˜ao e

correc¸ ˜ao de erros. Foram usadas as seguintes referˆencias [4], [3], [7], [8], [9] e [10].

Os c ´odigos corretores de erros est˜ao presentes em nosso cotidiano toda vez que

assistimos a um programa de TV ou a um ﬁlme em um aparelho de DVD, gravamos

dados em um Pendrive, enviamos um e-mail, trocamos mensagens pelo telefone, e em

v´arias outras situac¸ ˜oes em que ´e necess´ario transmitir uma informac¸ ˜ao ou fazer um

arquivo de dados.

Um c ´odigo corretor de erros tem como princ´ıpio identiﬁcar e corrigir erros que ocor-

rem em dados que, ao serem enviados ou armazenados pela fonte, chegam incorretos no

receptor por alguma interferˆencia. Para que seja poss´ıvel fazer a identiﬁcac¸ ˜ao e correc¸ ˜ao

de um eventual erro no comando, s˜ao adicionados termos redundantes junto com a

mensagem original para que seja poss´ıvel fazer uma comparac¸ ˜ao entre as possibilidades

de envio e o comando recebido.

Para entender melhor o funcionamento desta teoria dos c ´odigos que fazem a correc¸ ˜ao

de erros, considere a seguinte situac¸ ˜ao:

Exemplo 3.1. Um carrinho de brinquedo que funciona com um controle remoto. Neste controle,

as opc¸˜oes de movimento s˜ao: frente, r´e, direita e esquerda.

Estes comandos do controle remoto podem ser codiﬁcados em um produto cartesiano

{0, 1} × {0, 1} da seguinte forma:

29

30

c ´odigos corretores de erros

Frente (cid:55) −→ 00

R ´e (cid:55) −→ 01

Esquerda (cid:55) −→ 10

Direita (cid:55) −→ 11

Considere que, ao serem transmitidos esses sinais no controle remoto, o sinal enviado

tenha sido 00 e, por alguma interferˆencia externa, o carrinho tenha recebido 01, logo, o

movimento ser´a contr´ario ao enviado. Neste caso, n˜ao ´e poss´ıvel fazer a identiﬁcac¸ ˜ao e,

consequentemente, a correc¸ ˜ao do erro. Para que seja poss´ıvel fazer essa identiﬁcac¸ ˜ao,

s˜ao adicionadas, ao c ´odigo original, redundˆancias.

Usando esse Exemplo 3.1, suponha que os comandos de movimento fossem o seguinte:

Frente (cid:55) −→ 0000

R ´e (cid:55) −→ 0101

Esquerda (cid:55) −→ 1010

Direita (cid:55) −→ 1111

Considere que tenha sido enviado do controle remoto o sinal 0100, como o c ´odigo

recebido pelo carrinho n˜ao ´e reconhecido, ´e identiﬁcado que o sinal sofreu algum erro

ao ser transmitido. Comparando o c ´odigo recebido com os que podem ser enviados, o

carrinho n˜ao conseguir´a fazer a correc¸ ˜ao, pois, mesmo supondo que houve um ´unico

erro, o c ´odigo correto pode ser 0101 ou 0000.

Admita agora que o controle remoto desse mesmo exemplo use os seguintes comandos

de movimentos:

Frente (cid:55) −→ 000000

R ´e (cid:55) −→ 010001

Esquerda (cid:55) −→ 100011

Direita (cid:55) −→ 110011

c ´odigos corretores de erros

31

Se o sinal para f rente, 000000, for emitido pelo controle, e o carrinho receber 000010,

1
´e poss´ıvel identiﬁcar e corrigir o erro, pois o c ´odigo mais pr ´oximo

do que pode ser

enviado pela fonte ´e 000000.

Como ilustrado neste exemplo, um c ´odigo corretor de erros tem como princ´ıpio

adicionar termos redundantes ao comando inicial para que seja permitido identiﬁcar e

corrigir poss´ıveis erros. Abaixo segue uma ilustrac¸ ˜ao das etapas do funcionamento de

um c ´odigo corretor de erros.

Figura 3.1: Esquema de um c ´odigo corretor de erros

As informac¸ ˜oes da Figura 3.1 s˜ao:

fonte : Informac¸ ˜ao original que vai ser transmitida ou armazenada.

codificador fonte : Compress˜ao de dados, sua ﬁnalidade ´e usar a menor quanti-
dade de s´ımbolos poss´ıvel para transmitir ou armazenar a informac¸ ˜ao da fonte.

codificador de canal : Adiciona informac¸ ˜oes redundantes para que o receptor
use estas informac¸ ˜oes para detecc¸ ˜ao e correc¸ ˜ao de erros ocorridos por ru´ıdos

ou interferˆencias que afetam a informac¸ ˜ao original quando ela ´e transmitida ou

armazenada.

decodificador de canal : Tenta reconstruir a informac¸ ˜ao do c ´odigo da fonte com

base no codiﬁcador da fonte e na redundˆancia adicionada.

decodificador da fonte : Recupera a informac¸ ˜ao da fonte.

1 A express˜ao mais pr´oximo, intuitivamente clara, ser´a melhor explicada ao tratarmos de Distˆancia de

Hamming.

32

c ´odigos corretores de erros

usu ´ario : Recebe a informac¸ ˜ao da fonte com os poss´ıveis erros j´a corrigidos pelo

decodiﬁcador de canal.

O comando frente do carrinho de controle remoto do Exemplo 3.1, pode ser represen-

tado no seguinte diagrama:

Figura 3.2: Exemplo: carrinho de controle remoto

Neste cap´ıtulo, ser´a feito um estudo de como se transforma o c ´odigo da fonte em

c ´odigo do canal, sendo poss´ıvel fazer a identiﬁcac¸ ˜ao e correc¸ ˜ao de erros ao decodiﬁcar

o comando ou mensagem da fonte.

Ser´a feito um estudo somente de canais sim´etricos. Segundo Abramo Hefez e
Maria L ´ucia T. Villela [3], canais sim´etricos s˜ao aqueles que apresentam as seguintes
propriedades:

• Todos os s´ımbolos transmitidos tˆem a mesma probabilidade (pequena) de serem

recebidos errados.

• Se um s´ımbolo ´e recebido errado, a probabilidade de ser qualquer um dos outros

elementos do alfabeto ´e a mesma.

3.1 m ´etrica de hamming

33

3.1 m ´etrica de hamming

Mas aﬁnal, o que ´e um c ´odigo? Formalmente, para se deﬁnir um c ´odigo, preci-

samos inicialmente de um conjunto ﬁnito A de s´ımbolos denominado alfabeto (em

geral, trabalharemos com alfabetos num´ericos, de modo que podemos nos referir a
seus s´ımbolos como d´ıgitos). O n ´umero de elementos de A, denotado por |A| , ser´a
simbolizado neste trabalho pela letra q. Uma palavra desse alfabeto ´e um elemento de
An, onde n ´e o comprimento da palavra. Um c ´odigo constru´ıdo sobre o alfabeto A ´e
um subconjunto C de An (podem-se considerar c ´odigos em que as palavras tenham
comprimentos diferentes, mas esse caso n˜ao nos interessar´a neste trabalho).

Al´em disso, para que seja poss´ıvel construir um c ´odigo corretor de erros, ser´a necess´ario

tamb´em termos um conceito de distˆancia entre palavras de um c ´odigo, de modo a medir

a proximidade entre elas.

Deﬁnic¸ ˜ao 3.1. A distˆancia de Hamming entre dois pares de palavras u = (u1, ..., un) e
v = (v1, ..., vn), denotado por dH(u, v), ´e o n ´umero de posic¸˜oes onde os d´ıgitos correspondentes
s˜ao diferentes.

dH(u, v) = |{i; ui

(cid:54)= vi, 1 ≤ i ≤ n}|

Considere o seguinte exemplo:

Exemplo 3.2. Considere um alfabeto A = {0, 1}, com as palavras u = (1, 0, 0, 0, 1) e
v = (0, 1, 0, 0, 0) tomadas em A5. A distˆancia Hamming entre u e v ´e dH(u , v) = 3 .

Proposic¸ ˜ao 3.2. A distˆancia de Hamming ´e uma m´etrica em An, ou seja:

i - Positividade: dH(u , v) ≥ 0, ∀u, v ∈ A, sendo igual se, e somente se, u = v.

ii - Simetria: dH(u , v) = dH(v , u), ∀u, v ∈ A.

iii - Desigualdade Triangular: dH(u , v) ≤ dH(u , w) + dH(w , v), ∀u, v, w ∈ A.

Demonstrac¸˜ao. Os itens i e ii s˜ao triviais.

iii - Para demonstrar esta propriedade, ser´a analisado a contribuic¸ ˜ao das i-´esimas
coordenadas de u, v para dH(u, v). Temos duas situac¸ ˜oes para ser veriﬁcada, se a
contribuic¸ ˜ao das i-´esimas coordenadas ´e igual a zero se ui = vi e igual a um se ui (cid:54)= vi.

34

c ´odigos corretores de erros

• Para ui = vi, temos que a contribuic¸ ˜ao das i-´esimas coordenadas a dH(u, v) ´e menor
ou igual a das i-´esimas coordenadas de dH(u, w) + dH(w, v) que pode ser 0, 1 ou 2.

• Agora, se ui (cid:54)= vi, n˜ao podemos ter vi = wi e ui = wi. Portanto a contribuic¸ ˜ao das i-
´esimas coordenadas a dH(v, w) + dH(u, w) ´e maior ou igual a 1, que ´e a contribuic¸ ˜ao
das i-´esimas coordenadas de dH(u, v).

As propriedades da Proposic¸ ˜ao 3.2 caracterizam uma m´etrica, por isso, a distˆancia de

Hamming entre os elementos de An ´e chamado de m´etrica de Hamming.

Deﬁnic¸ ˜ao 3.3. Considere u uma palavra de An e um n ´umero natural r > 0. Ser´a deﬁnido como
disco e bola de raio r e centro u como sendo, respectivamente, os seguintes conjuntos:

D(u , r ) = { v ∈ An; dH(v , u ) (cid:54) r}
S(u , r ) = { v ∈ An; dH(v , u ) = r}

Deﬁnic¸ ˜ao 3.4. A dist ˆancia m´ınima de um c´odigo C ´e dado por:

d = min {dH(u , v); u, v ∈ C e u (cid:54)= v}.

Exemplo 3.3. Dado um alfabeto A = {0, 1} e um c´odigo C ⊂ A4,

C = {(0, 0, 0, 0), (1, 1, 1, 1), (1, 1, 0, 1), (0, 0, 1, 1)},

temos que as distˆancias entre as palavras s˜ao:

dH(0000, 1111) = 4

dH(0000, 1101) = 3

dH(0000, 0011) = 2

dH(1111, 1101) = 1

dH(1111, 0011) = 2

dH(1101, 0011) = 3

Logo a distˆancia m´ınima do c´odigo C ´e d = 1.

Sendo M a quantidade de elementos de um c ´odigo C, para determinar a distˆancia

m´ınima devemos calcular

distˆancias, ou seja, calcular a distˆancia dos elementos

(cid:32)

(cid:33)

M

2

3.1 m ´etrica de hamming

35

de dois em dois, para ent˜ao determinar a m´ınima. Esta operac¸ ˜ao se torna invi´avel para

c ´odigos grandes ( muitas palavras-c ´odigo ), pois apresenta um custo computacional

elevado. Ser´a apresentado at´e o ﬁnal deste cap´ıtulo, uma maneira econ ˆomica para

calcular a distˆancia m´ınima d.

Seja C um c ´odigo com distˆancia m´ınima d ≥ 1, ponha-se:

k =

(cid:115) d − 1
2

(cid:123)

(3.1)

onde

x

(cid:75)

(cid:74)

representa a parte inteira de um n ´umero real x.

Observac¸ ˜ao 3.5. Note que 0 ≤ 2k < d e que k = 0 ⇔ d = 1.

Lema 3.6. Dado um c´odigo C com distˆancia m´ınima d > 1. Se c e c(cid:48) s˜ao palavras distintas de
C, ent˜ao:

(cid:0)D(c , k ) ∩ D(c(cid:48) , k )(cid:1) ∩ C = ∅

Em outras palavras, discos de raio k centrados em uma palavra do c ´odigo n˜ao contˆem

outras palavras do c ´odigo.

Demonstrac¸˜ao. Suponha por absurdo que exista uma palavra-c ´odigo x ∈ D(c , k ) ∩
D(c(cid:48) , k ), logo:

De acordo com a Deﬁnic¸ ˜ao 3.3, ter´ıamos:

dH(x , c ) (cid:54) k
dH(x , c(cid:48) ) (cid:54) k

logo pela desigualdade triangular iii da proposic¸ ˜ao 3.2, temos:

dH(c , c(cid:48) ) (cid:54) dH(x , c ) + dH(x , c(cid:48) ) (cid:54) 2k < d

Isso ´e um absurdo, pois dH(c , c(cid:48) ) (cid:62) d.

O resultado acima sugere a seguinte ideia para a correc¸ ˜ao de erros na transmiss˜ao
(veja ﬁgura 3.3): se uma palavra v recebida estiver numa bola de raio k centrada numa
palavra u do c ´odigo (v (cid:54)= u), assume-se que a palavra transmitida possui dH(u, v) erros
(identiﬁcac¸ ˜ao do erro) e que a correta (a palavra transmitida) ´e a palavra u (correc¸ ˜ao do

erro).

36

c ´odigos corretores de erros

Figura 3.3: Representac¸ ˜ao geom´etrica dos c ´odigos corretores de erros

Teorema 3.7. Um c´odigo C com distˆancia m´ınima d > 1 pode detectar at´e d − 1 erros em uma
(cid:123)

palavra transmitida e corrigir at´e k =

erros.

(cid:115) d − 1
2

Demonstrac¸˜ao. Suponha que, ao transmitir uma palavra a do c ´odigo C, sejam cometidos
t erros na transmiss˜ao, com t (cid:54) k, recebendo a palavra b com d(a , b ) = t (cid:54) k. Neste
caso, temos que b ∈ D(a , k ), pelo lema 3.6, temos que b /∈ D(a(cid:48) , k ) para a (cid:54)= a(cid:48), e,
assim, podemos concluir que dH(a , b ) ´e menor que a distˆancia de b a qualquer outra
palavra do c ´odigo C e, ent˜ao, teremos a a partir b.

Por outro lado, se na transmiss˜ao de uma palavra-c ´odigo podemos introduzir nela
at´e d − 1 erros sem encontrar outra palavra c ´odigo, e assim , a detecc¸ ˜ao do erro ser´a

poss´ıvel.

Com base no Teorema 3.7, podemos concluir que quanto maior a distˆancia m´ınima
entre as palavras do c ´odigo, melhor ser´a a sua capacidade de corrigir erros. Na Teoria

dos C ´odigos, ´e fundamental poder calcular d ou, pelo menos, determinar uma cota

inferior para ele.

Deﬁnic¸ ˜ao 3.8. Seja um c´odigo C ⊂ An com distˆancia m´ınima d e seja k =

(cid:115) d − 1
2

(cid:123)

. Dizemos

que este c´odigo ´e perfeito se:

D(c , k ) = An

(cid:91)

c ∈ C

Um c ´odigo ´e perfeito quando todos os elementos de An pertence a alguma bola de
raio k centradas nas palavras-c ´odigo de C. Um c ´odigo perfeito consegue corrigir de

3.1 m ´etrica de hamming

37

maneira ´unica, uma palavra recebida, ou seja, uma palavra recebida sempre pertence a

alguma bola.

De acordo com o Teorema 3.7, podemos obter uma estrat´egia para detecc¸ ˜ao e correc¸ ˜ao
de erros de uma palavra recebida. Considere C um c ´odigo com distˆancia m´ınima d.

Temos que a quantidade de erros que este c ´odigo corrige ´e k =
a ´e recebida temos duas situac¸ ˜oes para serem veriﬁcadas segundo Hefez e Villea [3]:

. Se uma palavra

(cid:115) d − 1
2

(cid:123)

i - A palavra a encontra-se em um disco de raio k em torno de uma palavra c
do c ´odigo. ( essa palavra ´e ´unica, pela prova do Teorema (3.7)). Nesse caso,
substitui-se a por c.

ii - A palavra a n˜ao se encontra em nenhum disco de raio k em torno de uma palavra c

do c ´odigo. Nesse caso, n˜ao ´e poss´ıvel decodiﬁcar a com boa margem de seguranc¸a.

Na primeira situac¸ ˜ao (i), n˜ao se sabe a quantidade de erros que foram cometidos na

transmiss˜ao, pois poder´ıamos ter cometido mais do que k erros, afastando, assim, a da

palavra original, e a aproximando de uma outra palavra do c ´odigo, e, o item (ii), n˜ao

ocorre em c ´odigos perfeitos. Existe uma maneira de otimizar a correc¸ ˜ao, pois quanto

maior for d, maior ser´a a chance de que seja um caso do item (i).

A Teoria dos C ´odigos Corretores de Erros apresenta trˆes parˆametros fundamentais:

• M: Quantidade de palavras ( n ´umero de elementos ) do c ´odigo.

• d: Distˆancia min´ıma entre duas palavras quaisquer do c ´odigo.

• n: Comprimento de uma palavra-c ´odigo ( o n ´umero n, corresponde ao espac¸o de

An de um c ´odigo ).

O objetivo da teoria ´e estabelecer uma relac¸ ˜ao entre estes parˆametros produzindo

c ´odigos mais eﬁcientes e eﬁcazes. Os c ´odigos que interessam s˜ao aqueles em que M e d

sejam grandes relativamente a n, ou seja, um c ´odigo capaz de transmitir ou armazenar

bastante informac¸ ˜ao M com uma boa capacidade de correc¸ ˜ao com d relativamente

grande. Isso n˜ao ´e uma tarefa f´acil, pois quando se aumenta o n ´umero de palavras M,

diminui-se a distˆancia m´ınima d entre elas.

38

c ´odigos corretores de erros

3.2

equival ˆencia de c ´odigos

Um conceito importante nos c ´odigos ´e a noc¸ ˜ao de equivalˆencia, para que seja poss´ıvel

deﬁnir equivalˆencia entre c ´odigos, ´e necess´ario deﬁnir o conceito de isometria.

Deﬁnic¸ ˜ao 3.9. Dado um alfabeto A e n um n ´umero natural, dizemos que uma func¸˜ao F : An →
An ´e uma isometria de An se ela preserva distˆancia de Hamming. Ou seja:

dH(F(x), F(y)) = dH(x, y); ∀x, y ∈ An

As isometrias para a m´etrica de Hamming apresentam as seguintes propriedades:

Proposic¸ ˜ao 3.10. Toda isometria de An ´e uma bijec¸˜ao de An.

Demonstrac¸˜ao. Suponha que F : An → An seja uma isometria. Seja x, y ∈ An, tal
que F(x) = F(y), logo, temos que dH(x, y) = dH(F(x), F(y)) = 0, implicando em x = y.
Podemos concluir que F ´e injetora e, como toda aplicac¸ ˜ao injetora de um conjunto ﬁnito

nele pr ´oprio ´e sobrejetora, temos que a func¸ ˜ao F ´e uma bijec¸ ˜ao.

Deﬁnic¸ ˜ao 3.11. Sejam dois c´odigos C e C(cid:48) em An, dizemos que C(cid:48) ´e equivalente a C se existir
uma isometria F de An tal que F(C) = C(cid:48).

A equivalˆencia de c ´odigos ´e uma relac¸ ˜ao de equivalˆencia, ou seja, apresenta as

seguintes propriedades:

i Reﬂexiva: Todo c ´odigo ´e equivalente a si pr ´oprio.

ii Sim´etrica: Se C(cid:48) ´e equivalente a C, ent˜ao C ´e equivalente a C(cid:48).

iii Transitiva: Se C” ´e equivalente a C(cid:48) e C(cid:48) ´e equivalente a C, ent˜ao C” ´e equivalente a

C.

Proposic¸ ˜ao 3.12. Dois c´odigos equivalentes possuem os mesmos parˆametros.

Demonstrac¸˜ao. Como os dois c ´odigos est˜ao contido em An eles apresentam o mesmo
comprimento n. Considerando que s˜ao c ´odigos equivalentes, existe uma bijec¸ ˜ao de
An que leva um ao outro, ou seja, eles apresentam a mesma cardinalidade M. E como
existe uma isometria por hip ´otese, os c ´odigos C e C(cid:48) apresentam a mesma distˆancia
min´ıma.

3.3 c ´odigos lineares

39

3.3 c ´odigos lineares

A classe de c ´odigos mais utilizada ´e a linear, caracterizada por utilizar-se de uma

estrutura vetorial. Para que seja poss´ıvel construir um c ´odigo linear, ser˜ao tomados:

• F um corpo ﬁnito com q elementos tomado como alfabeto.

• Um espac¸o vetorial Fn sobre F.

• C um subconjunto de Fn.

Deﬁnic¸ ˜ao 3.13. Um c´odigo C ⊂ Fn ser´a chamado de c´odigo linear se for um subespac¸o vetorial
de Fn.

Exemplo 3.4. Considere o carrinho de controle remoto usado no comec¸o do cap´ıtulo com os

seguintes comandos de movimento:

Frente (cid:55) −→ 00

Re (cid:55) −→ 01

Esquerda (cid:55) −→ 10

Direita (cid:55) −→ 11

Para que seja poss´ıvel fazer a identiﬁcac¸˜ao e correc¸˜ao de poss´ıveis erros quando o sinal ´e

transmitido, s˜ao adicionadas redundˆancias ao c´odigo inicial, como se segue:

Frente (cid:55) −→ 00000

Re (cid:55) −→ 01101

Esquerda (cid:55) −→ 10110

Direita (cid:55) −→ 11011

Neste exemplo o alfabeto ´e A = F = {0, 1} e o c´odigo ´e imagem de F2 atrav´es de uma

transformac¸˜ao linear, sendo subespac¸o vetorial de F5. De fato:

40

c ´odigos corretores de erros

T :

F2 →

F5

(x1, x2)

(cid:55)→ (x1, x2, x1 + x2, x1, x2)

Por deﬁnic¸ ˜ao, todo c ´odigo linear ´e um espac¸o vetorial de dimens˜ao ﬁnita. Seja b a
dimens˜ao de um c ´odigo C e v1, v2, ..., vb uma de suas bases. Todo elemento do c ´odigo
pode ser escrito de forma ´unica:

c = u1v1 + u2v2 + ... + ubvb

sendo ui, i = 1, ..., b elementos de F. Temos ent˜ao que n ´umero de palavras de um

c ´odigo ´e:

M = qb

Como os c ´odigos lineares s˜ao subespac¸os vetoriais, obtemos uma vantagem para

calcular a distˆancia m´ınima d, pois o vetor 0, elemento neutro da soma, sempre estar´a

em um c ´odigo linear e nos permite introduzir a seguinte:

Deﬁnic¸ ˜ao 3.14. Dado x ∈ Fn, deﬁne-se peso de x como sendo o n ´umero inteiro:

w(x) = |{i/xi (cid:54)= 0}|= dH(x, 0)

e peso m´ınimo de um c´odigo linear:

w(C) = min{w(x); x ∈ C, x (cid:54)= 0}.

Proposic¸ ˜ao 3.15. Seja C ⊂ Fn um c´odigo linear com uma distˆancia m´ınima d. Ent˜ao:

i) ∀x, y ∈ Fn, temos que dH(x, y) = w(x − y).

ii) d = w(C).

Demonstrac¸˜ao. Para demonstrar item i, suponha x = (a1, a2, ..., an) e y = (b1, b2, ..., bn)
palavras de um c ´odigo C. Pela deﬁnic¸ ˜ao da m´etrica de Hamming e da deﬁnic¸ ˜ao do

peso , temos:

dH(x, y) = |{i, ai (cid:54)= bi, 1 ≤ i ≤ n}| = |{i, ai − bi (cid:54)= 0, 1 ≤ i ≤ n}| = dH(x − y, 0) = w(x − y)

O item ii decorre do fato que, para todo par de elementos x, y ∈ C com x (cid:54)= y, tem-se

um elemento z = x − y ∈ C e portanto d(x, y) = w(z).

3.3 c ´odigos lineares

41

Exemplo 3.5. Dado o corpo F = {0, 1} e o c´odigo C = {00000, 01011, 10100, 11111} subespac¸o
vetorial de F5 e uma imagem de F2 atrav´es de uma transformac¸˜ao linear. Para obter a distˆancia
m´ınima desse c´odigo, calculamos M − 1 = 4 − 1 = 3 pesos:

w(01011) = 3

w(10100) = 2

w(11111) = 5

Portanto a distˆancia m´ınima do c´odigo ´e 2.

Na sec¸ ˜ao 3.1, vimos que, para conhecer a distˆancia m´ınima de um c ´odigo, era ne-

(cid:32)

(cid:33)

M

2

cess´ario calcular

distˆancias, para ent˜ao determinar a m´ınima, isso n˜ao ser´a

mais necess´ario, pois a distˆancia m´ınima ´e igual ao peso do c ´odigo linear, ou seja,
ser´a necess´ario calcular a distˆancia entre cada um dos M − 1 elementos n˜ao nulos e o

elemento neutro.

Ainda assim, n˜ao se resolve o problema de c ´odigos grandes, mesmo calculando-se
M − 1 distˆancias, apresenta-se um custo computacional alto, portanto, ser´a necess´ario

desenvolver outro m´etodo para calcular a distˆancia m´ınima.

3.3.1 C´odigo Linear obtido como imagem ou n ´ucleo de uma transformac¸˜ao linear

Podemos descrever c ´odigos lineares como subespac¸os vetoriais de C de um espac¸o
vetorial Fn de duas maneiras: uma como imagem, e outra como n ´ucleo de uma
transformac¸ ˜ao linear. Nesta subsec¸ ˜ao e na pr ´oxima, ser´a estabelecido uma estrutura

matem´atica no processo de codiﬁcac¸ ˜ao e decodiﬁcac¸ ˜ao. Uma palavra-c ´odigo ser´a

constru´ıda a partir de um vetor informac¸ ˜ao e ser´a acrescentada redundˆancia atrav´es de

uma transformac¸ ˜ao linear.

Ser´a obtida uma representac¸ ˜ao do c ´odigo C atrav´es de uma transformac¸ ˜ao linear.

Para isso escolha uma base v1, v2, ..., vb de C e considere a seguinte aplicac¸ ˜ao:

T :

Fb

(u1, ..., ub)

→
(cid:55)→ u1.v1 + u2.v2 + ... + ub.vb

Fn

Temos que T ´e uma transformac¸ ˜ao linear injetora e Im(T) = C.

42

c ´odigos corretores de erros

Exemplo 3.6. Suponha um c´odigo C ⊂ F6 sobre um corpo F = {0, 1} com a seguinte base
(001000, 100100, 010010, 000001). Seja x = (1001) a palavra a ser enviada de espac¸o vetorial
F4. Para codiﬁcar a palavra x, fazemos:

T(x) = 1.(001000) + 0.(100100) + 0.(010010) + 1.(000001)

T(x) = 001001

Assim, o vetor informac¸˜ao x = (1001) ´e codiﬁcada e ser´a enviada como vetor c´odigo 001001.

Seja C um c ´odigo linear representado por uma transformac¸ ˜ao linear T. Para deter-
minar se z ∈ Fn ´e ou n˜ao um vetor c ´odigo ´e necess´ario obter uma base v1, v2, ..., vb de
Im(T) e resolver o sistema de equac¸ ˜oes:

u1.v1 + u2.v2 + ... + ub.vb = z

A resoluc¸ ˜ao desse sistema de equac¸ ˜oes, em geral, pode apresentar um custo compu-

tacional elevado. Para reduzir este custo, podemos obter um c ´odigo linear C de uma
outra maneira, usando o n ´ucleo de uma transformac¸ ˜ao linear. Para isso, seja C(cid:48) um
subespac¸o de Fn complementar de C, isto ´e:

e considere a aplicac¸ ˜ao linear:

C ⊕ C(cid:48) = Fn

H : C ⊕ C(cid:48) → Fn−b

u ⊕ z

(cid:55)→ z

Sendo o n ´ucleo o c ´odigo C. Para saber se uma palavra-c ´odigo pertence a C, basta

veriﬁcar se H(z) = 0, o que apresenta um baixo custo computacional.

3.3.2 Matriz Geradora de um C´odigo

Mostraremos nesta subsec¸ ˜ao, um processo para codiﬁcar o vetor informac¸ ˜ao. Para
isso, seja F um corpo ﬁnito e C ⊂ Fn um c ´odigo linear. Iremos chamar a terna de
inteiros (n, b, d) de parˆametros do c´odigo linear sendo:

• n - comprimento do vetor c ´odigo;

3.3 c ´odigos lineares

43

• b - dimens˜ao do c ´odigo C;

• d - distˆancia m´ınima.

Para determinar a matriz geradora de um c ´odigo linear, iremos considerar {j1, ..., jb}
como base can ˆonica de Fb, a base can ˆonica de Fn representada por { f1, ..., fn} e
{v1, ..., vb} sendo uma base do c ´odigo C. A matriz geradora transmite elementos
de um espac¸o Fb, ou seja, uma transformac¸ ˜ao linear T:

T : Fb → Fn

´E poss´ıvel escrever todos os elementos da base do c ´odigo linear C na base can ˆonica

de Fn:





v1 = u11 f1 + · · · + u1n fn
... =
vb = ub1 f1 + · · · + ubn fn

. . . +

+

...

...

sendo os coeﬁcientes uij elementos de F. Ent˜ao, a matriz geradora de um c ´odigo ´e:

G =







u11 u12
...
...
ub1 ub2







· · · u1n
...
. . .
· · · ubn

Cada linha da matriz geradora G corresponde a um vetor que pertence ao c ´odigo C,
isto ´e, C ´e um subespac¸o de Fn gerado pelas linhas de G, que ´e uma base do c ´odigo.
Todos os elementos do c ´odigo C s˜ao os vetores z ∈ Fn da forma x.G = z para todo
x ∈ Fb.

Exemplo 3.7. Consideremos F = {0, 1} e C ⊂ F6 um c´odigo. Se β = {(0, 1, 0, 1, 0, 0), (1, 0, 1, 1, 0, 1)}
´e uma base de C, temos a seguinte matriz geradora:

(cid:32)

0 1 0 1 0 0

1 0 1 1 0 1

(cid:33)

Neste caso, a palavra c´odigo da fonte x = 10 ´e codiﬁcada como:

(cid:32)

(cid:16)

(cid:17)

.

1 0

(cid:33)

0 1 0 1 0 0

1 0 1 1 0 1

= 010100

44

c ´odigos corretores de erros

Exemplo 3.8. Usando os mesmos dados do exemplo anterior, suponhamos, agora, que seja dada

a palavra c´odigo 101101 de um c´odigo e que queremos descobrir a palavra do c´odigo da fonte, ou
seja, x ∈ F2. Temos:

(cid:16)

x1 x2

(cid:32)

(cid:17)

.

0 1 0 1 0 0

1 0 1 1 0 1

(cid:33)

(cid:16)

=

1 0 1 1 0 1

(cid:17)

Resolvendo o produto matricial, encontramos:

(cid:16)

x2 x1 x2 x1 + x2 0 x2

(cid:16)

(cid:17)

=

1 0 1 1 0 1

(cid:17)

Assim, conseguimos determinar a palavra do c´odigo da fonte, que ´e x = 01.

O sistema de equac¸ ˜oes usado no exemplo anterior apresentou uma resoluc¸ ˜ao simples,

pois a matriz geradora n˜ao era complexa. Esse fato n˜ao acontece em todos os casos,

em alguns, a resoluc¸ ˜ao pode ser muito trabalhosa. Para facilitar a resoluc¸ ˜ao, na matriz

geradora, podemos efetuar operac¸ ˜oes alg´ebricas que correspondem a mudanc¸a de bases,

tais como:

L1. Permutar duas linhas.

L2. Multiplicar uma linha por um escalar n˜ao nulo.

L3. Adicionar um m ´ultiplo escalar de uma linha a outra.

Deﬁnic¸ ˜ao 3.16. Uma matriz geradora G de um c´odigo C est´a na forma padr˜ao se tivermos:

G = (Idb|A)

onde Idb ´e a matriz identidade de ordem b, e A, uma matriz b × (n − b).

Exemplo 3.9. Considere o c´odigo linear C ⊂ F5, sendo F = {0, 1} com a seguinte matriz
geradora:









0 1 0 0 0

1 0 0 0 1

0 0 1 0 1

0 0 0 1 1









Efetuando permutac¸˜oes das linhas, podemos obter:

3.3 c ´odigos lineares

45









1 0 0 0 1

0 1 0 0 0

0 0 1 0 1

0 0 0 1 1









que ´e uma matriz geradora na forma padr˜ao de um c ´odigo C.

N˜ao s˜ao todas as matrizes geradoras que s˜ao poss´ıveis de serem transformadas na

forma padr˜ao usando somente as operac¸ ˜oes com as linhas, como por exemplo, se a

matriz geradora do exemplo anterior fosse:







0 0 0 1 1

1 0 0 0 1

0 0 1 0 1







Se permutarmos as colunas, ser´a poss´ıvel obter a matriz geradora na forma padr˜ao.

De uma forma geral, podemos efetuar as seguintes operac¸ ˜oes:

C1. Permutac¸ ˜ao de duas colunas.

C2. Multiplicac¸ ˜ao de uma coluna por um escalar n˜ao nulo.

Dessa forma, podemos encontrar a matriz geradora na forma padr˜ao de um c ´odigo

C(cid:48) equivalente a C.







1 0 0 0 1

0 1 0 0 1

0 0 1 0 1







Observac¸ ˜ao 3.17. Ao efetuar as operac¸˜oes com as colunas em uma base de C, implica efetu´a-las

em todas as palavras-c´odigo de C, o que caracteriza uma isometria.

Usando essas operac¸ ˜oes com as colunas, chegamos ao seguinte resultado:

Teorema 3.18. Dado um c´odigo C, existe um c´odigo equivalente C(cid:48) com matriz geradora na
forma padr˜ao.

Demonstrac¸˜ao. Suponhamos G uma matriz geradora de c ´odigo C. Usando as operac¸ ˜oes

L1, L2, L3 e C1, podemos determinar G na forma padr˜ao:

46

c ´odigos corretores de erros

Seja:







g11 g12
...
...
gb1 gb2







· · · g1n
...
. . .
· · · gbn

Como a primeira linha n˜ao ´e nula, pois os vetores s˜ao linearmente independentes,
existe um elemento n˜ao nulo e por meio de C1, podemos assumir g11 (cid:54)= 0 e, usando L2,
podemos multiplicar os elementos dessa linha por g−1
11 , encontrando g11 = 1. Usando
L3, podemos somar as linhas seguintes de G com a primeira linha multiplicada respec-
tivamente por (−)g21, (−1)g31, etc. Depois dessas operac¸ ˜oes, encontramos a seguinte
matriz:










1 b12
0 b22
...
...
0 bb2










· · · b1n
· · · b2n
...
. . .
· · · bbn

Na segunda linha, temos, certamente, um elemento n˜ao nulo que, quando multipli-

cado pelo seu inverso, L2, e ao usar C1, podemos encontrar a seguinte matriz:

Usando L3, obtemos:










1 c12
0
1
...
...
0 cb2

c13
c23
. . .
cb3










· · ·
c1n
· · · b2n
...
· · ·

cbn










1 0 d13
0 1 d23
...
...
. . .
0 0 db3










· · · d1n
· · · d2n
...
· · · dbn

e assim, sucessivamente, podemos encontrar a matriz geradora na forma padr˜ao.

G(cid:48) = (Idb|A)

3.3 c ´odigos lineares

47

3.3.3 C´odigos Duais

Deﬁnic¸ ˜ao 3.19. Seja C ⊂ Fn um c´odigo linear com uma matriz geradora G. Deﬁnimos como
c´odigo dual C⊥:

C⊥ = {v ∈ Fn; (cid:104)v, u(cid:105) = 0, ∀u ∈ C}

Um c ´odigo C⊥ apresenta as seguintes propriedades:

i. C⊥ ´e um subespac¸o vetorial de Fn;

ii. x ∈ C⊥ ⇐⇒ Gxt = 0.

Demonstrac¸˜ao. No item i, consideremos u, v ∈ C⊥ e α ∈ Fn, e, usando a deﬁnic¸ ˜ao 3.19,
temos que para todo x ∈ C:

(cid:104)u + αv, x(cid:105) = (cid:104)u, x(cid:105) + α.(cid:104)v, x(cid:105) = 0

portanto, podemos concluir que u + αv ∈ C⊥, logo, C⊥ ´e um subespac¸o vetorial de

Fn.

Temos, no item ii, que x ∈ C⊥ se, somente se, x ´e ortogonal a todos os elementos de
uma base C, o que ´e equivalente a dizer G.xt = 0, pois as linhas de G s˜ao uma base de
C.

Como C⊥ ´e um subespac¸o vetorial de Fn, ortogonal a C, ´e, portanto, um c ´odigo linear

que ser´a chamado de c ´odigo dual.

Proposic¸ ˜ao 3.20. Seja C ⊂ Fn um c´odigo linear de dimens˜ao b com matriz geradora, na forma
padr˜ao, G = (Idb|A). Ent˜ao:

i. dimC⊥ = n − b

ii. H = (−At|Idn−b) ´e uma matriz geradora de C⊥.

Demonstrac¸˜ao. i - Sendo x = (x1, ..., xn) ∈ C⊥ se, e somente se, G.xt = 0, como G est´a na
forma padr˜ao, podemos escrever a seguinte relac¸ ˜ao:

48

c ´odigos corretores de erros



1 0 0 · · · 0 a1(b+1)
0 1 0 · · · 0 a2(b+1)
0 0 1 · · · 0 a3(b+1)
...
. . .
0 0 0 · · · 1 ab(b+1)
Efetuando o produto das matrizes, encontramos:

a1(b+2)
a2(b+2)
a3(b+2)
...
ab(b+2)

· · · a1n
· · · a2n
· · · a3n
...
. . .
· · · abn










...

...

...

...














.





















x1
x2
x3
...
xn























0

0

0
...
0

=












x1 + a1(b+1).xb+1 + a1(b+2).xb+2 + · · · + a1n.xn
x2 + a2(b+1).xb+1 + a2(b+2).xb+2 + · · · + a2n.xn
x3 + a3(b+1).xb+1 + a3(b+2).xb+2 + · · · + a3n.xn
...
xb + ab(b+1).xb+1 + ab(k+2).xb+2 + · · · + abn.xn












=























0

0

0
...
0

Podemos escrever a matriz produto da seguinte maneira:























x1
x2
x3
...
xb













= −



a1(b+1).xb+1 + a1(b+2).xb+2 + · · · + a1n.xn
a2(b+1).xb+1 + a2(b+2).xb+2 + · · · + a2n.xn
a3(b + 1).xb+1 + a3(b+2).xb+2 + · · · + a3n.xn
...
ab(b+1).xb+1 + ab(b+2).xb+2 + · · · + abn.xn


















a1(b+2)
a2(b+2)
a3(b+2)
...
ab(b+2)
Logo, C⊥ possui qn−b elementos onde xb+1, ..., xn podem ser escolhidos aleatoria-

· · · a1n
· · · a2n
· · · a3n
...
. . .
· · · abn

a1(b+1)
a2(b+1)
a3(b+1)
...
ab(b+1)

xb+1
xb+2
xb+3
...
xn

x1
x2
x3
...
xb























































= −

.

mente, portanto, podemos concluir que dimC⊥ = n − b

ii - As linhas de H s˜ao linearmente independentes, portanto, geram um subespac¸o
vetorial de dimens˜ao n − b. Como as linhas de H s˜ao ortogonais `as linhas de G, temos
que o espac¸o gerado pelas linhas de H est´a contido em C⊥. E, como estes subespac¸os
apresentam a mesma dimens˜ao, eles coincidem. Isso prova que H = (−At|Idn−b) ´e a
matriz geradora de C⊥.

Proposic¸ ˜ao 3.21. Seja C um c´odigo de dimens˜ao b em Fn, e uma matriz geradora G. Uma
matriz H de ordem (n − b) × n, com coeﬁcientes em F e com linhas linearmente independentes,
´e uma matriz geradora de C⊥ se, e somente se, G.Ht = 0.

3.3 c ´odigos lineares

49

Demonstrac¸˜ao. As linhas de H geram um subespac¸o vetorial de Fn com dimens˜ao
n − b, logo, a mesma dimens˜ao de C⊥. Se h1, h2, ..., hn−b e g1, g2, ..., gb s˜ao as linhas
respectivamente de H e G, temos:

(G.Ht)ij = (cid:104)gi, hj(cid:105)

Desse modo, G.Ht = 0 ´e equivalente dizer que todos os vetores do subespac¸o gerado
pelas linhas de H est˜ao em C⊥. E, como esse subespac¸o tem a mesma dimens˜ao de C⊥,
ent˜ao:

G.Ht = 0 ⇐⇒ C⊥ ´e gerado pelas linhas de H.

Corol´ario 3.22. (C⊥)⊥ = C

Demonstrac¸˜ao. Sejam G e H matrizes geradoras, respectivamente, de C e C⊥. Como
G.Ht = 0, temos:

(G.Ht)t = 0t

H.Gt = 0

logo, G ´e a matriz geradora de (C⊥)⊥.

A seguir, ser´a apresentado um resultado que nos permitir´a deﬁnir com mais facilidade

se uma palavra pertence ou n˜ao ao c ´odigo C. Esta proposic¸ ˜ao apresenta um custo

computacional mais barato.

Proposic¸ ˜ao 3.23. Seja C um c´odigo linear, e suponhamos que H seja uma matriz geradora de
C⊥. Ent˜ao, temos que v ∈ C se, somente se, H.vt = 0.

Demonstrac¸˜ao. Pelo Corol´ario 3.22 e Deﬁnic¸ ˜ao 3.19 ii, temos que v ∈ C se, somente se,
v ∈ (C⊥)⊥ se, e somente se, H.vt = 0.

Podemos concluir que ´e poss´ıvel descobrir se uma palavra-c ´odigo pertence a um
c ´odigo apenas com o produto da matriz geradora de C⊥ por um vetor. A matriz H ´e
chamada de matriz teste de paridade de C.

Dado um c ´odigo C com teste de paridade H e um vetor v ∈ Fn, ser´a chamado o vetor

H.vt de s´ındrome de v.

50

c ´odigos corretores de erros

Exemplo 3.10. Seja C um c´odigo sobre o corpo F = {0, 1} com a seguinte matriz geradora na
forma padr˜ao, isto ´e G = (Idb|A):







G =

1 0 0 1 1 1

0 1 0 0 1 1

0 0 1 0 1 0







Podemos determinar a matriz teste de paridade H = (−At|Idn−b):







H =

1 0 0 1 0 0

1 1 1 0 1 0

1 1 0 0 0 1







Assim, dados dois vetores v1 = (100111) e v2 = (010101), podemos veriﬁcar se as palavras

c´odigos v1 e v2 pertencem ao c´odigo C.

e

H.vt

1 = 0







1 0 0 1 0 0

1 1 1 0 1 0

1 1 0 0 0 1







.

H.vt

2 = 0







1 0 0 1 0 0

1 1 1 0 1 0

1 1 0 0 0 1







.





























1

0

0

1

1

1





























0

1

0

1

0

1













0

0

0

=













1

1

0

=

Portanto, podemos concluir, pela proposic¸˜ao 3.23, que v1 ∈ C e v2 ∈/ C.

3.4 decodificac¸ ˜ao de canal

51

A matriz H teste de paridade apresenta informac¸ ˜oes sobre o valor do peso d do

c ´odigo.

Lema 3.24. Dada uma matriz teste de paridade H de um c´odigo C, temos que o peso de C ´e

maior ou igual a s se, e somente se, quaisquer s-1 colunas de H s˜ao linearmente independentes.

Demonstrac¸˜ao. Consideremos uma matriz de paridade H e que cada conjunto de s − 1
colunas ´e linearmente independente. Sejam c = (c1, ..., cn) uma palavra n˜ao nula de um
c ´odigo C e h1, ..., hn as colunas de H, como H.ct = 0, temos que:

0 = H.ct = ∑ cihi

Se w(c) ≤ s − 1 ´e o n ´umero de componentes n˜ao nulas da palavra c e a equac¸ ˜ao H.ct =
0 = ∑ cihi, h´a uma combinac¸ ˜ao nula de um n ´umero t de colunas, isto ´e, 1 ≤ t ≤ s − 1, o
que ´e uma contradic¸ ˜ao. Portanto, podemos concluir que w(c) ≥ s, ent˜ao, w(C) ≥ s.

Reciprocamente, consideremos W(C) ≥ s, e suponhamos, por absurdo, que H tenha

s − 1 colunas h1, ..., hs−1 linearmente dependentes. Dessa forma:

ci.hi + ... + cs−i.hs−i = 0

Logo, c = (0, ..., ci, 0, ..., 0, cs−i, 0, ..., 0) ∈ C, e isso implicaria em w(c) ≤ s − 1 < s, o que
seria um absurdo.

Teorema 3.25. Dada uma matriz teste de paridade H de um c´odigo C, temos que o peso C ´e
igual a s se, e somente se, quaisquer s − 1 colunas de H forem linearmente independentes e
existirem s colunas dependentes.

Demonstrac¸˜ao. Suponhamos que w(C) = s. Temos que todo o conjunto de s − 1 co-
lunas de H ´e linearmente independente. Logo, existem s colunas de H linearmente
dependentes, pois, caso contr´ario, w(C) ≥ s + 1.

Reciprocamente, vamos supor agora que todo conjunto de colunas de H ´e linearmente
independente e existem s colunas linearmente dependentes. Logo, temos w(C) ≥ s,
por´em w(C) n˜ao pode ser maior que s, pois, novamente, todo conjunto com s colunas ´e

linearmente independente, o que ´e uma contradic¸ ˜ao.

3.4 decodificac¸ ˜ao de canal

A decodiﬁcac¸ ˜ao de canal ´e o procedimento que permite detectar e corrigir erros
de um c ´odigo. O m´etodo original foi apresentado na d´ecada de 90 no laborat ´orio

52

c ´odigos corretores de erros

Bell por D. Slepian, e apresentava um custo computacional elevado. Esse m´etodo foi

aperfeic¸oado e ser´a apresentado nesta sec¸ ˜ao.

Para isso, vamos deﬁnir o vetor erro e como a diferenc¸a entre o vetor recebido r e o

enviado c,ou seja:

e = r − c

Exemplo 3.11. Consideremos um c´odigo C ∈ F = {0, 1} e que tenha sido transmitido a
palavra-c´odigo 101101, e recebido a palavra-c´odigo 010101, ent˜ao:

e = 010101 − 101101 = 111000

O vetor erro serve para identiﬁcar, atrav´es de seu peso, a quantidade de erros
cometidos na transmiss˜ao. No exemplo anterior, e = 111000, apresenta peso igual a 3.
Sabemos que H a matriz teste de paridade de um c ´odigo C, e para c ∈ C, temos que

H.ct = 0. Portanto podemos escrever a seguinte relac¸ ˜ao:

H.et = H.(rt − ct) = H.rt − H.ct = H.rt

Lembre que chamamos de s´ındrome de v o vetor H.vt. Como H.et = H.rt, temos
por consequˆencia que a palavra recebida r e o vetor erro e tem a mesma s´ındrome.
Considere hi a i-´esima coluna da matriz teste de paridade H e e = (α1...αn), temos que:

n
∑
i=1

αihi = H.et = H.rt

A seguir, apresentaremos um importante resultado que permite efetuar a correc¸ ˜ao de

uma palavra transmitida com erro.

Lema 3.26. Dado um c´odigo linear C sobre um corpo Fn com capacidade k de correc¸˜ao de erros.
Se r ∈ Fn e c ∈ C s˜ao tais que d(c, r) ≤ k, existe um ´unico vetor e com w(e) ≤ k, cuja
s´ındrome ´e igual `a s´ındrome de r e tal que c = r − e.

Demonstrac¸˜ao. Seja e = r − c, temos que H.et = H.rt e w(e) = d(c, r) ≤ k, logo, e satisfaz a
condic¸ ˜ao desejada. Para provar a unicidade, suponhamos que e = (α1...αn) e e(cid:48) = (α(cid:48)
1...α(cid:48)
n)
sejam dois vetores em que w(e) ≤ k e w(e(cid:48)) ≤ k apresentam a mesma s´ındrome que r.
Se H ´e a matriz teste de paridade de C, temos que:

H.et = H.e

(cid:48)t

3.4 decodificac¸ ˜ao de canal

53

n
∑
i=2

αi.hi =

n
∑
i=1

α(cid:48)
i.hi

α1h1 + ... + αnhn − α(cid:48)

1.h1 − ... − α(cid:48)

n.hn = 0

(α1 − α(cid:48)

1)h1 + ... + (αn − α(cid:48)

n)hn = 0

o que nos fornece uma relac¸ ˜ao de dependˆencia linear entre 2k colunas de H, pois

(cid:115) d − 1
2

(cid:123)

sabemos que k =
s˜ao linearmente independentes, pelo Teorema 3.25, temos que αi = α(cid:48)
temos que e = e(cid:48).

, ou seja, 2k ≤ d − 1, e como quaisquer d − 1 colunas de H

i para todo i, logo,

Agora, vamos determinar e quando w(e) ≤ 1, ou seja, o vetor erro tem todas as suas

entradas nulas ou existe apenas uma de suas entradas n˜ao nula. Para que isso seja
poss´ıvel, suponhamos um c ´odigo C que tenha distˆancia m´ınima d ≥ 3 e que o vetor
erro e, introduzido entre a palavra transmitida c e a recebida r, seja tal que w(e) ≤ 1.

Se H.et = 0, a palavra recebida n˜ao apresenta erro, logo c = r.
Agora se H.et (cid:54)= 0, ent˜ao w(e) = 1 e e = (0, ..., 0, α, 0, ..., 0), com α (cid:54)= 0, apenas a i-´esima

entrada n˜ao ´e nula. Como:

H.rt = H.et = αhi

Para que seja poss´ıvel saber em qual entrada do vetor erro e est´a o elemento n˜ao nulo,
basta analisar as colunas de H e localizar a coluna hi, sendo, assim, poss´ıvel identiﬁcar
o erro. A matriz teste de paridade H deve apresentar as seguintes propriedades:

i) Nenhuma coluna de H deve ser nula, caso contr´ario, um erro na posic¸ ˜ao corres-

pondente `a linha nula n˜ao seria detectado.

ii) Todas as colunas de H devem ser ´unicas. Caso duas colunas sejam iguais, erros

nas posic¸ ˜oes correspondentes a essas linhas podem ser inidentiﬁc´aveis.

Usando todas essas informac¸ ˜oes, podemos descrever um algoritmo que permite a

decodiﬁcac¸ ˜ao em um c ´odigo corretor de um erro.

Algoritmo 1. Seja H uma matriz teste de paridade de um c´odigo C e seja r um vetor recebido.
Considere d ≥ 3.

(i) Determine H.rt;

54

c ´odigos corretores de erros

(ii) Se H.rt = 0, aceite a palavra recebida r;

(iii) Se H.rt = st (cid:54)= 0, compare st com as colunas de H;

(iv) Se existirem i e α, tais que st = α.hi, para α ∈ F, ent˜ao e ´e a n-upla com α na posic¸˜ao i e

zeros nas outras posic¸˜oes. Corrija r pondo c = r − e;

(v) Se n˜ao ocorrer o item iv, foi cometido mais de um erro.

Exemplo 3.12. Consideremos C um c´odigo com a seguinte matriz geradora:

(cid:33)

(cid:32)

1 0 1 1 0

0 1 0 1 1

Sendo G = (Idk|A), ou seja, uma matriz geradora na forma padr˜ao, e sendo Id2×2 a matriz

identidade e A2×3 a matriz A.

Podemos determinar a matriz de teste de paridade H(n−k)×n, pois H = (−At|Idn−k):







1 0 1 0 0

1 1 0 1 0

0 1 0 0 1







Vamos supor que seja recebida uma palavra r = (10100), temos:

H.et = H.rt








1 0 1 0 0

1 1 0 1 0

0 1 0 0 1







.
























0

1

0

=

1










0

1

0

0

Como o produto matricial n˜ao ´e o vetor nulo, temos que a palavra foi transmitida com erro.

Analisando as colunas de H encontramos que o erro aconteceu na quarta coluna, portanto,

podemos escrever da seguinte maneira o vetor erro e = 00010, e o vetor enviado como:

c = r − e

c = 10100 − 00010 = 10110

ou seja, a palavra c´odigo transmitida foi c = 10110.

3.4 decodificac¸ ˜ao de canal

55

A seguir mostraremos um segundo algoritmo para a decodiﬁcac¸ ˜ao de mensagens.
Para isso, seja C ⊂ Fn um c ´odigo corretor de erros, sendo H a matriz de teste de
paridade, d a distˆancia m´ınima, M = qb o n ´umero de palavras do c ´odigo C e que o

c ´odigo tenha a capacidade de corrigir k =

(cid:123)

erros. Quando H.et = H.rt, dizemos

(cid:115) d − 1
2

que r e e apresentam a mesma s´ındrome, e se w(e) = d(r, c) < k, ent˜ao e ´e determinado
de maneira ´unica por r.

Deﬁnic¸ ˜ao 3.27. Seja v ∈ Fn, chamamos cada conjunto da forma v + C de classe lateral de v
segundo C:

v + C = {v + c; c ∈ C}

Lema 3.28. Sejam u, v ∈ Fn, u e v tˆem a mesma s´ındrome se, e somente se, u ∈ v + C

Demonstrac¸˜ao.

H.ut = H.vt ⇔ H.(u − v)t = 0 ⇔ u − v ∈ C ⇔ u ∈ v + C

A classe lateral de v segundo C apresenta as seguintes propriedades:

i) v + C = v(cid:48) + C ⇔ v − v(cid:48) ∈ C;

ii) (v + C) ∩ (v(cid:48) + C) (cid:54)= 0 =⇒ v + C = v(cid:48) + C;

iii) ∪
v∈Fn

(v + C) = Fn;

iv) |(v + C)|= |C|= qb

As classes laterais s˜ao classes de equivalˆencia da relac¸ ˜ao v − v(cid:48) ∈ C. O n ´umero de
classes laterias de v segundo C ´e qn−b, sendo n o comprimento do c ´odigo e b a sua
dimens˜ao.

Exemplo 3.13. Seja F = {0, 1} um corpo e C ⊂ Fn seja um c´odigo gerado pela seguinte matriz:

(cid:32)

G =

(cid:33)

1 0 1 1

0 1 0 1

Temos que:

• q = 2, pois o alfabeto F tem dois elementos;

56

c ´odigos corretores de erros

• n = 4, pois a matriz geradora G tem quatro colunas;

• b = 2, pois a matriz geradora, que ´e uma base de C, tem duas linhas;

• |(v + C)|= 22 = 4, ou seja, o n ´umero de elementos da classe lateral ´e 4;

• O n ´umero de classes laterais ´e 24−2 = 4.

Usando a matriz geradora, temos que o c´odigo C = {0000, 0101, 1011, 1110} e as classes

laterais segundo C s˜ao:

0000 + C = {0000, 0101, 1011, 1110}

1000 + C = {1000, 1101, 0011, 0110}

0100 + C = {0100, 0001, 1111, 1010}

0010 + C = {0010, 0111, 1001, 1100}

Podemos encontrar os elementos da classe lateral construindo uma tabela da seguinte

maneira: na primeira linha e coluna, colocamos, a palavra-c ´odigo zero e, nos demais

elementos da primeira linha, as outras palavras-c ´odigo de C. Para encontrar o vetor v

da segunda linha e primeira coluna, devemos encontrar o vetor que apresenta a menor

distˆancia Hamming do vetor que est´a na primeira linha e primeira coluna, os demais

itens da segunda linha s˜ao determinados atrav´es da soma do vetor v com as demais
colunas da primeira linha, sendo a soma em Z2, no caso do exemplo anterior, e assim,
sucessivamente, at´e a linha qn−b. Abaixo, segue a tabela do exemplo anterior:

0000

1011

0101

1110

1000

0011

1101

0110

0100

1111

0001

1010

0010

1001

0111

1100

Chamamos de l´ıder de classe o elemento que apresenta o menor peso entre os

elementos da classe lateral. No exemplo anterior, temos:

• 0000 ´e l´ıder de 0000 + C;

• 1000 ´e l´ıder de 1000 + C;

• 0100 e 0001 s˜ao l´ıderes de 0100 + C;

3.4 decodificac¸ ˜ao de canal

57

• 0010 ´e l´ıder de 0010 + C.

Podemos observar que, em alguns casos, temos mais de um l´ıder de classe lateral, e

nos interessam as que apresentam somente um l´ıder. A seguir, apresentaremos uma

importante proposic¸ ˜ao:

Proposic¸ ˜ao 3.29. Seja C um c´odigo linear em Fn com distˆancia m´ınima d. Se u ∈ Fn ´e tal que:

w(u) ≤ (cid:115) d − 1
2

(cid:123)

= k

ent˜ao u ´e o ´unico elemento l´ıder de sua classe.

Demonstrac¸˜ao. Vamos supor u, v ∈ Fn, com w(u) ≤ (cid:115) d − 1
2
j´a sabemos que u − v ∈ C, temos:

(cid:123)

e w(v) ≤ (cid:115) d − 1
2

(cid:123)

. Como

w(u − v) ≤ w(u) + w(v) ≤ (cid:115) d − 1
2

(cid:123)

+

(cid:115) d − 1
2

(cid:123) ≤ d − 1

Portanto, u − v tem peso menor que d, ou seja, u = v.

Novamente usando essas informac¸ ˜oes, podemos descrever um algoritmo que permite

a decodiﬁcac¸ ˜ao em c ´odigo corretor de um erro pela s´ındrome que apresenta um n ´umero

de erros menor ou igual a k. Iremos usar a ´ultima proposic¸ ˜ao para encontrar o elemento
l´ıder de classe, ou seja, vamos determinar u ∈ Fn, tal que w(u) ≤ k, e, em seguida,
calcular as s´ındromes desses elementos e organiz´a-los em uma tabela.

Algoritmo 2.

i) Determine a s´ındrome st = H.rt;

ii) Se s estiver na tabela, seja l o elemento l´ıder da classe determinada por s, troque r por r − l;

iii) Se s n˜ao estiver na tabela, ent˜ao, a mensagem recebida cont´em mais do k erros.

Para entender o funcionamento do algoritmo, vamos mostrar dois exemplos. O

primeiro exemplo foi constru´ıdo com distˆancia m´ınima 3, ou seja, corrige apenas um

erro, j´a o segundo, foi constru´ıdo com distˆancia m´ınima 5, ent˜ao, este c ´odigo consegue

fazer a correc¸ ˜ao de no m´aximo dois erros.

Exemplo 3.14. Considere um c´odigo bin´ario criado para transmitir a palavra PROFMAT.

Para isso, considere C um c´odigo com a seguinte matriz geradora e que na transmiss˜ao seja

cometido no m´aximo um erro. Este exemplo ´e adaptac¸˜ao do exerc´ıcio 5.5 da p´agina 111 do

livro [3] :

58

c ´odigos corretores de erros

G =












1 1 0 0 1 0 0 0 0

1 0 0 1 0 0 0 1 0

1 1 1 0 0 0 0 0 1

0 1 0 1 0 1 0 0 0

0 0 1 1 0 0 1 0 0












Usando as operac¸˜oes com as linhas e colunas, podemos encontrar G na sua forma padr˜ao:

G(cid:48) =












1 0 0 0 0 0 1 1 0

0 1 0 0 0 1 1 0 0

0 0 1 0 0 0 1 1 1

0 0 0 1 0 1 0 1 0

0 0 0 0 1 1 0 0 1












e a matriz teste de paridade H:

H =









0 1 0 1 1 1 0 0 0

1 1 1 0 0 0 1 0 0

1 0 1 1 0 0 0 1 0

0 0 1 0 1 0 0 0 1









A distˆancia m´ınima deste c´odigo ´e 3, sendo assim, esse c´odigo faz a correc¸˜ao de um e detecta

dois erros. Tomando como exemplo o alfabeto da nossa l´ıngua, podemos deﬁnir um c´odigo fonte

para transmitir a mensagem da seguinte forma:

P = 00011

R = 10110

O = 00101

F = 11000

M = 01001

A = 10000

T = 11010

Iremos codiﬁcar o c´odigo fonte em palavra-c´odigo fazendo um produto matricial do c´odigo

fonte com a matriz geradora na forma padr˜ao G(cid:48), de acordo com o seguinte diagrama:

Vamos enviar a palavra PROFMAT, usando a matriz geradora, encontraremos as seguintes

palavras c´odigo:

3.4 decodificac¸ ˜ao de canal

59

Figura 3.4: Transformar c ´odigo fonte em c ´odigo canal

P = 000110011

R = 101101011

O = 001011110

F = 110001010

M = 010010101

A = 100000110

T = 110100000

Para que seja poss´ıvel fazer a decodiﬁcac¸˜ao de um c´odigo recebido, vamos determinar o elemento

l´ıder de classe, ou seja, vamos determinar todos os elementos do corpo do c´odigo com peso menor

ou igual a 1:

L´ıder

s´ındrome

000000000

100000000

010000000

001000000

000100000

000010000

000001000

000000100

000000010

000000001

0000

0110

1100

0111

1010

1001

1000

0100

0010

0001

Para entender o funcionamento do algoritmo, considere que seja recebido o c´odigo 000110011,
como H.rt = (0000)t, temos que n˜ao houve erro na transmiss˜ao e, fazendo a decodiﬁcac¸˜ao, temos
que a palavra fonte ´e P.

60

c ´odigos corretores de erros

Consideremos, agora, que seja recebido o seguinte c´odigo 111001010, como H.rt = (0111)t,
temos que a mensagem foi recebida com erro. Consultando a tabela, temos que o l´ıder de
classe ´e 001000000 e, usando o algoritmo, ou seja, trocando o vetor recebido r por r − l =
111001010 − 001000000 = 110001010, fazendo a decodiﬁcac¸˜ao, encontramos a letra F.

Exemplo 3.15. Vamos usar as informac¸˜oes do exemplo 3.1 que foi utilizado no in´ıcio deste

cap´ıtulo. Seja C um c´odigo com distˆancia m´ınima 5, logo, este c´odigo ´e eﬁciente para corrigir at´e

dois erros.

Ser´a usado a seguinte matriz geradora G:

(cid:32)

G =

1 0 1 1 0 0 1 1 0

0 1 0 1 1 1 0 0 1

(cid:33)

e matriz teste de paridade H

H =

















1 0 1 0 0 0 0 0 0

1 1 0 1 0 0 0 0 0

0 1 0 0 1 0 0 0 0

0 1 0 0 0 1 0 0 0

1 0 0 0 0 0 1 0 0

1 0 0 0 0 0 0 1 0

0 1 0 0 0 0 0 0 1

















Temos as seguintes informac¸˜oes:

Comando C´odigo Fonte C´odigo Canal

Frente

R´e

Esquerda

Direita

00

01

10

11

000000000

010111001

101100110

111011111

Para fazer a correc¸˜ao de erro ´e necess´ario construir a tabela de l´ıder com peso menor ou igual a

dois com sua respectiva s´ındrome:

3.4 decodificac¸ ˜ao de canal

61

L´ıder

S´ındrome

L´ıder

S´ındrome

000000000

0000000

010000010

0111011

100000000

1100110

010000001

0111000

010000000

0111001

001100000

1100000

001000000

1000000

001010000

1010000

000100000

0100000

001001000

1001000

000010000

0010000

001000100

1000100

000001000

0001000

001000010

1000010

000000100

0000100

001000001

1000001

000000010

0000010

000110000

0110000

000000001

0000001

000101000

0101000

110000000

1011111

000100100

0100100

101000000

0100110

000100010

0100010

100100000

1000110

000100001

0100001

100010000

1110110

000011000

0011000

100001000

1101110

000010100

0010100

100000100

1100010

000010010

0010010

100000010

1100100

000010001

0010001

100000001

1100111

000001100

0001100

011000000

1111001

000001010

0001010

010100000

0011001

000001001

0001001

010010000

0101001

000000110

0000110

010001000

0110001

000000101

0000101

010000100

0111101

000000011

0000011

Suponha que o carrinho deste exemplo receba os seguintes comandos:

Com um erro:
r = 001100110, calculando H.rt = (1100110)t, a mensagem chegou ao receptor com erro e
consultando a tabela, trocamos r por r − l = 001100110 − 100000000 = 101100110 e o comando
´e ESQUERDA.

Com dois erros:
r = 010100001, calculando H.rt = (0011000)t, a mensagem chegou ao receptor com erro e
consultando a tabela, trocamos r por r − l = 01010001 − 000011000 = 010111001 e o comando
´e R ´E.

4

A P L I C A C¸ ˜O E S

Neste cap´ıtulo, apresentamos duas sequˆencias de atividades com o objetivo de mostrar

aplicac¸ ˜oes de alguns conte ´udos do Ensino Fundamental e M´edio usando os d´ıgitos

veriﬁcadores e c ´odigos corretores de erros.

Mostrar uma aplicac¸ ˜ao de um conte ´udo de forma pr´atica facilita o processo de ensino-

aprendizagem: a Matem´atica torna-se interessante para o aluno quando ele consegue

perceber e aplicar a teoria em situac¸ ˜oes pr´aticas. Um processo signiﬁcativo para o

educando, deve permitir que ele consiga fazer relac¸ ˜oes com o seu cotidiano, segundo os
Parˆametros Curriculares Nacionais [11]:

[...] O signiﬁcado da Matem´atica para o aluno resulta das conex ˜oes que ele

estabelece entre ela e as demais disciplinas, entre ela e seu cotidiano e das
conex ˜oes que ele estabelece entre os diferentes temas matem´aticos. (p.19)

O objetivo das sequˆencias de atividades ´e instigar no aluno uma maneira diferente

de entender o conte ´udo do curr´ıculo, perceber a Matem´atica aplicada no seu dia a

dia, mostrar que a Matem´atica n˜ao ´e um ciˆencia encerrada em si mesma. Com estas

atividades ´e poss´ıvel oportunizar uma participac¸ ˜ao melhor dos alunos no seu processo

de aprendizagem.

4.1

sequ ˆencia para o ensino fundamental

Para o Ensino Fundamental, apresentamos uma sequˆencia de atividades que utilizam

os d´ıgitos veriﬁcadores de erros para aplicar alguns conte ´udos deste segmento educaci-

onal e desenvolver a curiosidade, investigac¸ ˜ao, criar estrat´egias e compreender padr ˜oes.
Segundo a Base Nacional [12], sobre a Matem´atica:

63

64

aplicac¸ ˜oes

No Ensino Fundamental, essa ´area, por meio da articulac¸ ˜ao de seus
diversos campos – Aritm´etica, ´Algebra, Geometria, Estat´ıstica e Probabi-
lidade, precisa garantir que os alunos relacionem observac¸ ˜oes emp´ıricas

do mundo real a representac¸ ˜oes (tabelas, ﬁguras e esquemas) e associem

essas representac¸ ˜oes a uma atividade matem´atica (conceitos e propriedades),

fazendo induc¸ ˜oes e conjecturas. Assim, espera-se que eles desenvolvam a

capacidade de identiﬁcar oportunidades de utilizac¸ ˜ao da matem´atica para

resolver problemas, aplicando conceitos, procedimentos e resultados para
obter soluc¸ ˜oes e interpret´a-las segundo os contextos das situac¸ ˜oes. (p.265)

Esta atividade ´e um sugest˜ao para o sexto ano Ensino Fundamental. Com estas

atividades, ser´a poss´ıvel mostrar uma aplicac¸ ˜ao para as operac¸ ˜oes dos n ´umeros naturais,
divisibilidade e n ´umeros primos. Segundo o PCN [11], um aluno do ensino fundamental
do ciclo 3 deve:

Reconhecer os signiﬁcados dos n ´umeros naturais em diferentes contextos e

estabelecimento de relac¸ ˜oes entre n ´umeros naturais, tais como “ser m ´ultiplo”,

“ser divisor de”.

Mostraremos v´arias etapas as quais foram pensadas para serem desenvolvidas em 10

aulas; esta sugest˜ao pode ser adaptada para as demais s´eries.

4.1.1

1a etapa - o que ´e um c´odigo?

Comec¸ar esta etapa investigando o conceito dos alunos sobre c ´odigos, veriﬁcar

o sentido dessa palavra para eles. Depois, solicitar que fac¸am uma consulta a um

dicion´ario da L´ıngua Portuguesa – uma sugest˜ao ´e dicion´ario on-line Priberam

1

:

1. Colec¸ ˜ao de leis. 2. Colec¸ ˜ao de regras, preceitos, f ´ormulas, etc. 3. Sistema
de s´ımbolos que permite interpretar, transmitir uma mensagem, representar
uma informac¸ ˜ao de dados. 4. Sistema convencional, rigorosamente estru-
turado, de s´ımbolos ou de sinais e de regras combinat ´orias integrado no

processo da comunicac¸ ˜ao.

1 ”c ´odigo”,

in Dicion´ario

Priberam da

L´ıngua

Portuguesa

[em linha],

2008-2013,

https://www.priberam.pt/dlpo/c%C3%B3digo [consultado em 17-01-2018].

4.1 sequ ˆencia para o ensino fundamental

65

Em seguida, questionar se eles reconhecem algum c ´odigo no seu dia a dia. Usando as

respostas dos alunos, explicar e explorar o conceito de c ´odigos num´ericos, sua utilidade

e importˆancia no nosso cotidiano para fazer identiﬁcac¸ ˜oes. Dar exemplo pr´aticos, como

c ´odigos de barras, n ´umeros de CPF e RG, CEP – c ´odigo de enderec¸amento postal etc.

O objetivo desta etapa ´e mostrar que utilizamos esses c ´odigos num´ericos em diversas

situac¸ ˜oes corriqueiras nos nossos h´abitos cotidianos. Com essas investigac¸ ˜oes podemos

motivar os alunos para as etapas seguintes e ajud´a-los a perceber que a Matem´atica est´a

presente em diversas situac¸ ˜oes.

4.1.2

2a etapa - vamos entender um c´odigo de barras EAN 13?

Nesta etapa vamos mostrar um c ´odigo de barras, apresentar as partes que identiﬁcam

o pa´ıs, produto, empresa e o d´ıgito veriﬁcador. Salientar a sua importˆancia e utilidade

nos supermercados, por exemplo, e que seus algarismos somente est˜ao corretos se

seguirem um conjunto de regras.

Escrever os algarismos de um c ´odigo de barras na lousa e mostrar tal conjunto

de regras. N˜ao ser´a usado um rigor matem´atico para descrever essas regras; uma

sugest˜ao ´e escrever os n ´umeros do c ´odigo de barras multiplicando de forma alternada
e respectiva por 1 e 3 e depois somar os produtos. Veja um exemplo:

Vamos usar os seguintes algarismos de um c ´odigo de barras: 7896051020158

7 ∗ 1 + 8 ∗ 3 + 9 ∗ 1 + 6 ∗ 3 + 0 ∗ 1 + 5 ∗ 3 + 1 ∗ 1 + 0 ∗ 3 + 2 ∗ 1 + 0 ∗ 3 + 1 ∗ 1 + 5 ∗ 3 + 8 ∗ 1

7 + 24 + 9 + 18 + 0 + 15 + 1 + 0 + 2 + 0 + 1 + 15 + 8 = 100

Para que estejam corretos os algarismos do c ´odigo de barras, a soma dever ser

m ´ultiplo de 10; caso n˜ao seja, algum n ´umero foi escrito de forma incorreta.

Propor que fac¸am o c´alculo de outros n ´umeros de c ´odigos de barras e em alguns com

um erro nos algarismos (um erro que seja detect´avel e outro n˜ao detect´avel)

Ap ´os os alunos calcularem alguns exemplos para sistematizar o processo, fazer alguns

questionamentos:

• - Ser´a que todos os c ´odigos num´ericos usam o mesmo processo do c ´odigo de

barras?

• - Por que, em alguns casos, mesmo com o erro na escrita dos algarismos do c ´odigo

de barras, o resultado foi um n ´umero m ´ultiplo de 10?

66

aplicac¸ ˜oes

• - Qual o motivo de usar um sistema de regras que n˜ao identiﬁca todos os erros?

O objetivo desses questionamentos ´e despertar a curiosidade para outros c ´odigos

num´ericos e mostrar que, por mais que parec¸am simples, para os algarismos do c ´odigo

de barras ou n ´umeros de um CPF existe uma matem´atica aplicada.

4.1.3 3a etapa - o que ´e um d´ıgito veriﬁcador?

Nesta etapa, salientar a importˆancia de usar um d´ıgito veriﬁcar em um c ´odigo

num´erico: em destaque, o do c ´odigo de barras. Em seguida, questionar os alunos se

depois da segunda etapa eles conseguem determinar o valor num´erico de um d´ıgito

veriﬁcador.

Para calcular d´ıgito veriﬁcador do c ´odigo de barras, deve-se repetir o processo da

etapa anterior sem escrever o d´ıgito e determinar qual algarismo dever ser adicionado

para que seja um n ´umero m ´ultiplo de 10.

Segue um exemplo:

7 ∗ 1 + 8 ∗ 3 + 9 ∗ 1 + 6 ∗ 3 + 0 ∗ 1 + 5 ∗ 3 + 1 ∗ 1 + 0 ∗ 3 + 2 ∗ 1 + 0 ∗ 3 + 1 ∗ 1 + 5 ∗ 3 = 92

Logo, o valor num´erico do algarismo do d´ıgito dever ser 8. Propor para calcular o

d´ıgito de outros n ´umeros de c ´odigo de barras.

4.1.4

4a etapa - construindo um c´odigo num´erico para identiﬁcar s´olidos geom´etricos

Em grupo, utilizar quatro cores de cartolinas e montar 4 tamanhos diferentes de
paralelep´ıpedos, cubos e tetraedros. Cada grupo dever´a montar um c ´odigo num´erico

para identiﬁcar seus s ´olidos geom´etricos e escolher um m´etodo para calcular o d´ıgito

que ir´a identiﬁcar a presenc¸a de erros. Neste momento, deixar os alunos fazerem

escolhas de acordo com os seus crit´erios e depois fazer uma socializac¸ ˜ao de cada grupo

e fazer os seguintes questionamentos:

• - Se vocˆes trocarem o c ´odigo num´erico de um s ´olido geom´etrico com outros

grupos, ser´a poss´ıvel identiﬁcar as caracter´ısticas do s ´olido?

• - N˜ao ser´a necess´ario um padr˜ao para o c ´odigo num´erico?

4.2 sequ ˆencia para o ensino m ´edio

67

• - O que ´e relevante para identiﬁcar os s ´olidos?

• - O m´etodo escolhido para determinar o valor num´erico do d´ıgito ´e eﬁciente?

Como saber se foi feita a melhor escolha para calcular o d´ıgito?

Depois desses questionamentos, montar um c ´odigo num´erico padr˜ao para a sala de

aula, como na sugest˜ao a seguir:

Um c ´odigo num´erico para identiﬁcar nesta ordem: COR - COMPRIMENTO DA
ARESTA DA BASE – NOME DO S ´OLIDO GEOM ´ETRICO – D´IGITO. Escolher alga-
rismos para representar cada caracter´ıstica do s ´olido geom´etrico e calcular o d´ıgito

conforme as orientac¸ ˜oes a seguir:

Para determinar o d´ıgito, pode-se orientar os alunos o seguinte m´etodo:

• 1o - Determinar n ´umeros para multiplicar o algarismo que representa a cor,
comprimento da aresta da base, nome do s ´olido geom´etrico e d´ıgito, como por
exemplo, 2, 3, 5 e 1 respectivamente.

• 2o - Escolher um n ´umero para dividir a soma, como por exemplo, 6 ou 7. Nesse
primeiro momento, seria interessante fazer a escolha do n ´umero 6 e mostrar
que n˜ao ´e eﬁciente para identiﬁcar erro ´unico e erro de transposic¸ ˜ao e depois
destacar que o algarismo 7 ou qualquer outro n ´umero primo ´e mais eﬁciente para
identiﬁcar tais erros.

Para sistematizar o processo, pedir para os grupos trocarem os c ´odigos num´ericos

para veriﬁcar a existˆencia de erro.

4.1.5 6a etapa - avaliac¸˜ao

Para a avaliac¸ ˜ao, propor algumas sequˆencias num´ericas de c ´odigos de barras e pedir

aos alunos para determinarem o d´ıgito veriﬁcador e outras sequˆencias de c ´odigos de

barras para veriﬁcarem se existe erro nos n ´umeros informados.

4.2

sequ ˆencia para o ensino m ´edio

A sequˆencia de atividade destinada para o Ensino M´edio foi escolhida para mostrar

aplicac¸ ˜oes do conte ´udo de sistemas lineares, n ´umeros bin´arios, congruˆencias m ´odulo

68

aplicac¸ ˜oes

M e matrizes e incentivar a investigac¸ ˜ao, criatividade, criac¸ ˜ao de estrat´egias e de

algoritmos.

Cada etapa, tem o objetivo de levar o aluno a um aprendizado real e signiﬁcativo,

segundo os Parˆametros Curriculares do Ensino M´edio [11] um deve:

Aplicar seus conhecimentos matem´aticos a situac¸ ˜oes diversas, utilizando-

os na interpretac¸ ˜ao da ciˆencia, na atividade tecnol ´ogica e nas atividades
cotidianas.(p.42)

Esta sequˆencia tem um tempo estimado de 10 aulas.

4.2.1

1a etapa - entendendo um c´odigo corretor de erros

Vamos utilizar um programa editor de texto para escrever a palavra “PARALE-
LEP´IPRDO” e mostrar para os alunos que o programa identiﬁca o erro e sugere
como correc¸ ˜ao a palavra correta “PARALELEP´IPEDO”. Em seguida escrever a palavra
“HACA” e, neste caso, o corretor identiﬁca o erro e sugere como correc¸ ˜ao ”VACA,

FACA, JACA”e com estas opc¸ ˜oes n˜ao ´e poss´ıvel fazer a correc¸ ˜ao, pois n˜ao ´e informado

nenhuma informac¸ ˜ao adicional.

Com estes dois exemplos, ´e poss´ıvel explicar a distˆancia de Hamming e mostrar que

´e poss´ıvel fazer a correc¸ ˜ao do erro quando uma ´unica palavra apresenta uma distˆancia

m´ınima de outra. Em seguida, explorar outros exemplos com os alunos e enfatizar que

usamos c ´odigos corretores em toda informac¸ ˜ao transmitida ou armazenada e que para

identiﬁcar e corrigir erros ´e necess´ario adicionar redundˆancias na informac¸ ˜ao original.

Citar exemplos para despertar a curiosidade dos alunos.

Aproveitando esta etapa, explicar os d´ıgitos dos c ´odigos num´ericos que veriﬁcam a

existˆencia de erros e n˜ao faz a indicac¸ ˜ao do algarismo errado ou a correc¸ ˜ao do mesmo.

Usamos diariamente os c ´odigos num´ericos e os c ´odigos corretores e n˜ao percebemos a

Matem´atica envolvida nessas situac¸ ˜oes.

O objetivo desta etapa ´e explicar os conceitos b´asicos de um c ´odigo corretor de erros,

mostrar a sua importˆancia e aplicac¸ ˜oes no nosso cotidiano.

4.2 sequ ˆencia para o ensino m ´edio

69

4.2.2

2o etapa - congruˆencia M´odulo M e Classes Residuais

Um conte ´udo de extrema importˆancia para as pr ´oximas etapas ´e a Matem´atica dos

Restos ou Congruˆencia M ´odulo M e Classes Residuais. Explorar os conceitos b´asicos,

estes conte ´udos ser˜ao usados nas operac¸ ˜oes com matrizes. A matriz informac¸ ˜ao utiliza
somente os algarismos 0 ou 1, e o produto entre a matriz informac¸ ˜ao e a matriz geradora
´e em Z2 pois assim ´e poss´ıvel fazer a decodiﬁcac¸ ˜ao. O aluno deve entender que s ´o pode
usar como algarismos 1 ou 0 e compreender o motivo de trocar, por exemplo, o n ´umero
´ımpar por um ou par por zero.

4.2.3

3a etapa - codiﬁcar uma informac¸˜ao

Nesta etapa e nas demais ser´a usado uma adaptac¸ ˜ao de um exerc´ıcio do livro [3]
p´agina 111. Este mesmo exerc´ıcio foi usado nesta dissertac¸ ˜ao como exemplo na sec¸ ˜ao
3.4. Ser´a usado um c ´odigo que ´e poss´ıvel fazer a detecc¸ ˜ao e correc¸ ˜ao de um erro.

Vamos usar um c ´odigo bin´ario para mandar e receber mensagens, para isso cada

letra do nosso alfabeto ser´a relacionado com uma matriz bin´aria e ser´a chamada de

matriz informac¸ ˜ao. Para codiﬁcar, usaremos uma matriz geradora de c ´odigo e produto

matricial entre a matriz informac¸ ˜ao e a matriz geradora ser´a chamado de matriz c ´odigo.

Com a multiplicac¸ ˜ao da matriz informac¸ ˜ao e a geradora de c ´odigo ´e poss´ıvel codiﬁcar

uma mensagem e adicionar nela redundˆancia, facilitando assim detectar e corrigir erros.

Usaremos a notac¸ ˜ao G para indicar a matriz geradora de c ´odigos:

G =












1 0 0 0 0 0 1 1 0

0 1 0 0 0 1 1 0 0

0 0 1 0 0 0 1 1 1

0 0 0 1 0 1 0 1 0

0 0 0 0 1 1 0 0 1












Matriz informac¸ ˜ao das letras do nosso alfabeto:

70

aplicac¸ ˜oes

A =

D =

G =

(cid:16)

(cid:16)

(cid:16)

1 0 0 0 0

0 1 0 0 0

0 0 1 0 0

(cid:17)

(cid:17)

(cid:17)

0 0 0 1 0

1 0 1 0 0
(cid:17)

0 1 1 0 0
(cid:16)

0 0 1 1 0
(cid:17)

1 1 1 0 0

(cid:17)

1 1 0 1 0
(cid:16)

0 0 1 1 1

1 1 0 1 1

(cid:17)

(cid:17)

(cid:17)

(cid:16)

J =

M =

(cid:16)

(cid:16)

(cid:16)

P =

S =

V =

Y =

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:16)

(cid:16)

(cid:16)

B =

E =

H =

K =

N =

Q =

T =

W =

Z =

0 0 0 0 1
(cid:16)

1 0 0 1 0
(cid:17)

(cid:16)

(cid:17)

0 1 0 1 0
(cid:16)

0 0 1 0 1

1 0 1 1 0
(cid:17)

(cid:16)

1 1 0 0 1
(cid:16)

(cid:17)

(cid:16)

1 1 1 1 0
(cid:17)

1 0 0 1 1

(cid:16)

(cid:16)

C =

F =

I =

L =

O =

R =

U =

X =

1 1 0 0 0
(cid:17)

(cid:16)

1 0 0 0 1
(cid:16)

0 1 0 0 1
(cid:16)

0 0 0 1 1

(cid:17)

(cid:16)

(cid:16)

(cid:16)

1 0 1 0 1

0 1 0 1 1

1 0 1 1 1

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:17)

Para usar espac¸o entre as letras: ESPAC¸ O =

Segue um exemplo para codiﬁcar a letra A:

(cid:16)

0 0 0 0 0

(cid:17)

(cid:16)

A :

1 0 0 0 0

(cid:17)

.












1 0 0 0 0 0 1 1 0

0 1 0 0 0 1 1 0 0

0 0 1 0 0 0 1 1 1

0 0 0 1 0 1 0 1 0

0 0 0 0 1 1 0 0 1












(cid:16)

=

1 0 0 0 0 0 1 1 0

(cid:17)

Observac¸ ˜ao 4.1. As operac¸˜oes com as matrizes s˜ao em Z2, ou seja, quando o resultado da soma
for um n ´umero par, substituir o resultado por zero e quando o resultado da soma for ´ımpar,

substituir por 1. Ver sec¸˜ao 1.5.

Usando estas instruc¸ ˜oes, dividir os alunos em grupos e cada grupo codiﬁcar uma men-

sagem para pass´a-la para outro grupo fazer a decodiﬁcac¸ ˜ao. Para fazer a decodiﬁcac¸ ˜ao

usaremos sistemas lineares, e como a matriz codiﬁcadora est´a na forma padr˜ao a

soluc¸ ˜ao n˜ao ser´a complicada. Veja um exemplo, para decodiﬁcar a matriz c ´odigo
(cid:16)

(cid:17)

0 0 1 0 0 0 1 1 1

.

Como a informac¸ ˜ao ´e uma matriz linha com cinco colunas, e neste caso como ela ´e

(cid:16)

(cid:17)

desconhecida usaremos uma matriz gen´erica:

a11

a12

a13

a14

a15

. Sabemos que o

produto desta matriz gen´erica pela matriz geradora deve resultar na matriz c ´odigo:

4.2 sequ ˆencia para o ensino m ´edio

71

(cid:16)

a11

a12

a13

a14

a15












(cid:17)

.

1 0 0 0 0 0 1 1 0

0 1 0 0 0 1 1 0 0

0 0 1 0 0 0 1 1 1

0 0 0 1 0 1 0 1 0

0 0 0 0 1 1 0 0 1












(cid:16)

=

0 0 1 0 0 0 1 1 1

(cid:17)

Resolvendo o sistema encontramos a seguinte matriz informac¸ ˜ao:

(cid:16)

0 0 1 0 0

(cid:17)

.

Logo, foi transmitido a letra C.

4.2.4

4a etapa - m´etodo para corrigir um erro

Vamos mostrar um m´etodo para identiﬁcar e corrigir um erro em um c ´odigo num´erico.

Ser´a usado uma matriz para veriﬁcar se existe erro e, caso exista, ser´a poss´ıvel fazer a

sua identiﬁcac¸ ˜ao e como estamos usando matrizes bin´arias ´e poss´ıvel fazer a correc¸ ˜ao
pois cada termo aij ´e 0 ou 1.

A matriz teste est´a relacionada com a matriz geradora do c ´odigo e suas linhas s˜ao

ortogonais, logo, ´e f´acil descobrir se uma matriz c ´odigo apresenta erro, pois o produto

entre a matriz teste e transposta da matriz c ´odigo deve ser a matriz nula e caso n˜ao seja
existe um erro em algum termo aij.
Usaremos a seguinte matriz teste:

H =









0 1 0 1 1 1 0 0 0

1 1 1 0 0 0 1 0 0

1 0 1 1 0 0 0 1 0

0 0 1 0 1 0 0 0 1









Para exempliﬁcar a correc¸ ˜ao do erro, suponhamos que o receptor tenha recebido a

matriz c ´odigo

(cid:16)

1 0 0 1 1 1 1 0 1

(cid:17)

72

aplicac¸ ˜oes

Fazendo o teste para veriﬁcar erro:









0 1 0 1 1 1 0 0 0

1 1 1 0 0 0 1 0 0

1 0 1 1 0 0 0 1 0

0 0 1 0 1 0 0 0 1









.











































1

0

0

1

1

1

1

0

1

















1

0

0

0

=

Como o produto n˜ao ´e a matriz nula, a informac¸ ˜ao foi recebida com erro. Para

identiﬁcar a posic¸ ˜ao do erro basta identiﬁcar na matriz de teste a coluna que corresponde
ao resultado. Fazendo est´a an´alise identiﬁcamos a 6a coluna com erro,logo para corrigir
(cid:16)
basta trocar o termo a16 da matriz c ´odigo:
Fazendo um novo teste, encontramos:

1 0 0 1 1 0 1 0 1

(cid:17)

.









0 1 0 1 1 1 0 0 0

1 1 1 0 0 0 1 0 0

1 0 1 1 0 0 0 1 0

0 0 1 0 1 0 0 0 1









.











































1

0

0

1

1

1

1

0

1

















0

0

0

0

=

Ap ´os os alunos entenderem o processo para veriﬁcar a existˆencia de erro, agora

em grupo novamente, solicitar que codiﬁquem uma nova mensagem e em algumas

letras acrescentar um erro e depois trocar entre os grupos para fazer a decodiﬁcac¸ ˜ao,

identiﬁcando e corrigindo erros, caso exista.

Caso seja cometido mais do que um erro, n˜ao ser´a poss´ıvel fazer a identiﬁcac¸ ˜ao e

correc¸ ˜ao. Explicar para os alunos que existem c ´odigos que fazem correc¸ ˜ao de mais de

um erro e usam um m´etodo apropriado.

4.2 sequ ˆencia para o ensino m ´edio

73

4.2.5

5a etapa - avaliac¸˜ao

Uma sugest˜ao de avaliac¸ ˜ao ´e usar a quarta etapa para veriﬁcar se os alunos compre-

enderam o processo de codiﬁcac¸ ˜ao e decodiﬁcac¸ ˜ao de informac¸ ˜oes corrigindo erros.

B I B L I O G R A F I A

[1] HEFEZ, Abramo; Curso de ´Algebra, Rio de Janeiro, Instituto de Matem´atica Pura

e Aplicada, 2002.

[2] NETO, Antonio Caminha Muniz; T ´opicos de Matem´atica Elementar, Teoria dos
N ´umeros. SBM, Colec¸ ˜ao do Professor de Matem´atica, Vol.5, Rio de Janeiro, 2012.

[3] HEFEZ, Abramo; VILLELA, Maria L ´ucia T.; C ´odigos Corretores de Erros, Rio de

Janeiro, Instituto de Matem´atica Pura e Aplicada, 2008.

[4] ALENCAR, Marcelo; Informac¸ ˜ao, codiﬁcac¸ ˜ao e seguranc¸a de redes, Rio de Janeiro,

Editora Elsevier LTDA, 2015.

[5] MILIES, C´esar Polcino, COELHO, S ˆonia Pitta; N ´umeros - Uma introduc¸ ˜ao Ma-

tem´atica, S˜ao Paulo, Editora Universidade de S˜ao Paulo,3a edic¸ ˜ao, 2001.

[6] PINZ, Carla Rejane Fick. D´ıgitos veriﬁcadores e detecc¸ ˜ao de erros. Dissertac¸ ˜ao de
Mestrado Proﬁssional em Matem´atica em Rede Nacional - PROFMAT, Universidade
Federal do Rio Grande do Norte, 2013.

[7] SILVEIRA, Raphael Bruno Rodrigues da; C ´odigos Corretores de Erros: Exemplos
da Matem´atica aplicada em situac¸ ˜oes Cotidiana; Dissertac¸ ˜ao de Mestrado em Rede
Nacional - PROFMAT, Universidade Federal Rural do Rio de Janeiro, 2015.

[8] NICOLETTI, Everton Rodrigo, Aplicac¸ ˜oes de ´Algebra Linear aos C ´odigos Corre-
tores de Erros e ao Ensino M´edio; Dissertac¸ ˜ao de Mestrado em rede Nacional -
PROFMAT, Universidade Estadual Paulista - Campus de Rio Claro, 2015.

[9] MILIES, C´esar Polcino; Breve introduc¸ ˜ao ´a Teoria dos C ´odigos Corretores de Erros;
In: Col ´oquio de Matem´atica da Regi˜ao Centro-Oeste, 2009, Universidade Federal
de Mato Grosso do Sul, Campo Grande, 2009.

75

76

Bibliograﬁa

[10] BAHIA, Flaviano; Um primeiro curso sobre c ´odigos corretores de erros, In: I
Encontro Regional de Matem´atica Aplicada e Computacional, Universidade S˜ao
Jo˜ao del-Rei, 2010.

[11] BRASIL, Minist´erio da Educac¸ ˜ao(MEC);Secret´aria da Educac¸ ˜ao M´edia e Tec-
nol ´ogica(Semtec); Parˆametros Curriculares Nacionais para o Ensino M´edio, Bras´ılia,
2000.

[12] BRASIL, Minist´erio da Educac¸ ˜ao (MEC); Base Nacional Comum Curricular, Bras´ılia,

2017.

