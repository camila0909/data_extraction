Universidade Federal de Goi´as - UFG

Instituto de Matem´atica e Estat´ıstica

Programa de Mestrado Proﬁssional em Matem´atica

em Rede Nacional

Aritm´etica com Python

Rog´erio da Silva Cavalcante

Goiˆania – GO

2018

Rog´erio da Silva Cavalcante

Aritm´etica com Python

Disserta¸c˜ao apresentada ao Programa de Mes-
trado Proﬁssional em Matem´atica em Rede Na-
cional do Instituto de Matem´atica e Estat´ıs-
tica da Universidade Federal de Goi´as, como
requisito parcial para a obten¸c˜ao do t´ıtulo de
Mestre em Matem´atica.

Orientadora: Dra. Thaynara Arielly de Lima

Goiˆania – GO
2018

Ficha de identificação da obra elaborada pelo autor, através doPrograma de Geração Automática do Sistema de Bibliotecas da UFG.CDU 51Cavalcante, Rogério da Silva      Aritmética com Python [manuscrito]  / Rogério da SilvaCavalcante. - 2018.       59 f.       Orientador: Profa. Dra. Thaynara Arielly de Lima.      Dissertação (Mestrado) - Universidade Federal de Goiás, Institutode Matemática e Estatística (IME), PROFMAT - Programa de Pósgraduação em Matemática em Rede Nacional - Sociedade Brasileirade Matemática (RG), Goiânia, 2018.     Bibliografia.      Inclui tabelas, algoritmos, lista de figuras, lista de tabelas.      1. Lógica. 2. Programação. 3. Aritmética. 4. Python. 5. Ensino deMatemática. I. Lima, Thaynara Arielly de, orient. II. Título.Todos os direitos reservados. ´E proibida a reprodu¸c˜ao total ou par-
cial deste trabalho sem a autoriza¸c˜ao da universidade, do autor e do
orientador.

Rog´erio da Silva Cavalcante graduou-se em Matem´atica pela Univer-
sidade Federal de Goi´as no ano de 2006. Atua como professor do ensino
b´asico desde 2000, j´a lecionou em escola estaduais, municipais e desde
2013 est´a no IFG Cˆampus Itumbiara.

Dedico este trabalho aos meus pais,
Marluce e Jeremias pela conﬁan¸ca e respeito.

Agradecimentos

Agrade¸co a Deus por tudo que tem me proporcionado.

Aos meus pais Jeremias e Marluce pelo modo ´ımpar com que me educaram e por
todo o suporte moral, psicol´ogico e ﬁnanceiro sem o qual essa conquista n˜ao se concretizaria.

Agrade¸co `a minha companheira Edilene Cristina que nesse ´arduo per´ıodo de lutas

e renuncias, demonstrou f´e e esperan¸ca na conclus˜ao exitosa de tal jornada.

As minhas irm˜as Andr´ea, Alean e Ariadna e ao meu irm˜ao Renato pela torcida e

apoio.

Um agradecimento especial a professora doutora Thaynara Arielly de Lima pela
impec´avel orienta¸c˜ao, constante incentivo e cont´ınua compreens˜ao que culminaram na
realiza¸c˜ao deste trabalho.

Aos colegas da Escola Municipal Honestino Monteiro Guimar˜aes, em destaque para
Talita, Jeovane e Gilson cujas saudosas conversas me impulsionavam para um aprimora-
mento pessoal e proﬁssional.

Aos colegas do IFG cˆampus Itumbiara pelo apoio, di´alogos e not´oria ˆenfase na
importˆancia da conclus˜ao de tal etapa, em especial para Leonardo Garcia Marques pela
disposi¸c˜ao em compartilhar tempo e conhecimentos sobre LATEX, programa¸c˜ao e Python.

Por ﬁm agrade¸co a CAPES, SBM, IMPA e UFG por ofertarem novas possibilidades

atrav´es do PROFMAT.

DON’T PANIC.
(Douglas Adams)

Resumo

Objetivamos neste trabalho mostrar o qu˜ao eﬁcazes podem ser os recursos tecnol´ogicos
quando utilizados para o ensino. Escolhemos utilizar a linguagem de programa¸c˜ao Python
no ensino de matem´atica, especiﬁcamente aritm´etica, exibindo como a l´ogica transita
naturalmente entre a computa¸c˜ao e a matem´atica, mostrando desta maneira uma inter-
disciplinariedade nata entre esses assuntos. S˜ao propostos programas constru´ıdos a partir
das demonstra¸c˜oes de alguns resultados cl´assicos em aritm´etica, visando integrar o ensino
desses resultados ao ensino de ferramentas b´asicas de uma linguagem de programa¸c˜ao.

Palavras-chave: L´ogica. Programa¸c˜ao. Aritm´etica. Python. Ensino de Matem´atica.

Abstract

We aim to show how eﬀective the technological resources can be when used for teaching.
We chose to use the Python programming language in mathematics teaching, speciﬁcally
arithmetic, showing how logic moves naturally between computing and mathematics,
thereby showing a natural interdisciplinarity between these subjects. We propose programs
built from the demonstrations of some classic results in arithmetic, aiming to integrate the
teaching of these results to the teaching of basic tools of a programming language.

Keywords: Logic, Programming, Python, Arithmetic, Teaching Mathematics.

Lista de ﬁguras

Figura 1 – Empresas que usam Python . . . . . . . . . . . . . . . . . . . . . . . . 25
Figura 2 – Outras empresas que usam Python . . . . . . . . . . . . . . . . . . . . 26
Figura 3 – Aplicativos que usam Python . . . . . . . . . . . . . . . . . . . . . . . 26
Figura 4 – Institui¸c˜oes que usam Python . . . . . . . . . . . . . . . . . . . . . . . 26
Figura 5 – Pixar usa Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
Figura 6 – Coment´ario de Eric Raymond . . . . . . . . . . . . . . . . . . . . . . . 26
27
Figura 7 – Coment´ario de Peter Norvig . . . . . . . . . . . . . . . . . . . . . . . .
27
Figura 8 – Coment´ario de Cuon Dong . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 9 – Coment´ario de Bjarne Stroutrup . . . . . . . . . . . . . . . . . . . . . 28
Figura 10 – Coment´ario de Donald Knuth . . . . . . . . . . . . . . . . . . . . . . . 28
Figura 11 – Guido Van Rossum: Criador do Python . . . . . . . . . . . . . . . . . . 28
Figura 12 – Monty Python, grupo de humor que inspirou o nome linguagem . . . . 28
Figura 13 – Logomarca do Python . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
Figura 14 – S´ıtio para download do Python . . . . . . . . . . . . . . . . . . . . . . 29
Figura 15 – Download do Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Figura 16 – Indicador do download no Google Chrome . . . . . . . . . . . . . . . . 29
Figura 17 – Janela de conﬁrma¸c˜ao da execu¸c˜ao do instalador Python . . . . . . . . 30
Figura 18 – Janela de sele¸c˜ao das conﬁgura¸c˜oes . . . . . . . . . . . . . . . . . . . . 30
Figura 19 – Progresso da instala¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Figura 20 – Janela de conﬁrma¸c˜ao da execu¸c˜ao do instalador Python . . . . . . . . 30
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Figura 21 – Python Shell
31
Figura 22 – Caminho para o modo de edi¸c˜ao . . . . . . . . . . . . . . . . . . . . . .
Figura 23 – Modo de edi¸c˜ao do Python . . . . . . . . . . . . . . . . . . . . . . . . .
31
Figura 24 – Caminho para executar o programa no modo de edi¸c˜ao . . . . . . . . . 32
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Figura 25 – “Ok” para salvar
Figura 26 – Nomeando o arquivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Figura 27 – Resultado do programa . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

Lista de tabelas

Tabela 1 – Opera¸c˜oes b´asicas
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Tabela 2 – Fatiamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Tabela 3 – Operadores relacionais . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Tabela 4 – not
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Tabela 5 – and . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Tabela 6 – or . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Tabela 7 – Convers˜ao de dados
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Tabela 8 – Listas num´ericas com list e range . . . . . . . . . . . . . . . . . . . . 50

Sum´ario

Introdu¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

21

1 Uma breve introdu¸c˜ao ao Python . . . . . . . . . . . . . . . . . . . . .

25

1.1 Porque Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

1.2

Instala¸c˜ao e ambienta¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

1.3 Python como calculadora . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

1.4 Vari´aveis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

34

1.5 Entrada de Dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

41

1.6 Estruturas b´asicas

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

2 Aplica¸c˜oes da Aritm´etica b´asica em Python . . . . . . . . . . . . . . .

53

2.1 Divis˜ao Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

2.2 Bases num´ericas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

2.3 Um pouco mais de aritm´etica . . . . . . . . . . . . . . . . . . . . . . . . . 60

2.3.1 M´aximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . .

61

2.3.2 Primos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

3 Considera¸c˜oes ﬁnais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

75

Referˆencias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

77

21

Introdu¸c˜ao

O avan¸co do mundo digital trouxe consigo in´umeros impactos nos mais variados
ramos da atua¸c˜ao humana, desde uma planta¸c˜ao a produ¸c˜ao em larga escala, telecomuni-
ca¸c˜oes, meios de transporte, medicina, pesquisas cient´ıﬁcas, rela¸c˜oes sociais (globaliza¸c˜ao),
seguran¸ca nacional, educa¸c˜ao, etc.

Tal avan¸co est´a em correspondˆencia biun´ıvoca com o desenvolvimento social. As
necessidades da sociedade implicam surgimentos de novas tecnologias que por sua vez
implicam novas formas sociais de interagir, se organizar e estruturar, como exemplo, temos
as pr´aticas de ensino nas mais variadas escolas.

Esse desenvolvimento tecnol´ogico goza de uma velocidade maior que as mudan¸cas
ocorridas em uma escola, principalmente durante e ap´os a guerra fria, onde uma bipolariza-
¸c˜ao mundial acelerou o surgimento e difus˜ao de tecnologias (computadores, internet, etc).
De uma maneira geral, a escola n˜ao acompanhou tal ritmo, pois a mesma necessita de um
aperfei¸coamento tanto de pessoas como de infra estruturas, processos que podem ser demo-
rados, principalmente na realidade das escolas p´ublicas brasileiras, onde o ﬁnanciamento
de forma¸c˜ao de pessoal e investimento em laborat´orios ainda n˜ao ´e ideal.

Neste sentido uma quest˜ao que torna-se pertinente ´e : como mediar tal avan¸co na

busca de uma nova educa¸c˜ao, novas pr´aticas, novas possibilidades?

Tal questionamento vai de encontro com um dos objetivos do Regimento 2017 do
PROFMAT (Mestrado Proﬁssional em Matem´atica em Rede Nacional) do cap´ıtulo I Art.
2o.

Art. 2o O PROFMAT tem como objetivo proporcionar forma¸c˜ao mate-
m´atica aprofundada e relevante ao exerc´ıcio da docˆencia na Educa¸c˜ao
B´asica, visando dar ao egresso a qualiﬁca¸c˜ao certiﬁcada para o exerc´ıcio
da proﬁss˜ao de professor de Matem´atica (SILVA, 2016, p.1).

As mudan¸cas dentro do ambiente escolar s˜ao complexas pois demandam uma

harmonia entre docentes, discentes, gest˜ao e comunidade.

22

Introdu¸c˜ao

As mudan¸cas demorar˜ao mais do que alguns pensam, porque os mo-
delos tradicionais est˜ao muito sedimentados, em parte, eles funcionam,
e com isso torna-se complicado fazer mudan¸cas profundas. Por outro
lado encontramo-nos em processos desiguais de aprendizagem e evolu¸c˜ao
pessoal e social. Apesar de haver avan¸cos, muitas institui¸c˜oes e muitos
proﬁssionais mantˆem uma distˆancia entre teoria e pr´atica, entre suas
ideias e a¸c˜oes. Se as pessoas tˆem diﬁculdades para evoluir, conviver e
trabalhar em conjunto, isso se reﬂete na pr´atica pedag´ogica (MORAN;
MASETO; BEHRENS, 2013, pp.24-25).

As mudan¸cas na educa¸c˜ao passam em primeiro momento por educadores, n˜ao
necessariamente professores, mas tamb´em os pais, diretores e os pr´oprios alunos que
estejam dispostos, maduros e que sejam motivadores, pois o gerenciamento das emo¸c˜oes
afeta o rendimento de qualquer pessoa em sua aprendizagem.

A Educa¸c˜ao focada na forma¸c˜ao do ser humano, numa abordagem mais ampla
poss´ıvel, pode fazer uso de recursos tecnol´ogicos que s˜ao um grande facilitador desse
processo por diversos motivos:

1. Desaﬁam as institui¸c˜oes a sair do tradicional;

2. Facilitam a pesquisa, multiplicam os espa¸cos de atua¸c˜ao ;

3. Possibilitam uma aprendizagem mais participativa e integrada;

4. Oferecem aplicativos, jogos, v´ıdeos, dentre outros recursos, que proporcionam dina-

mismo nos processos educativos em geral.

´E importante destacar que o fato de se ter um computador (ou qualquer outro
recurso tecnol´ogico), n˜ao acarreta que se tenha aprendizagem. O professor como mediador
do conhecimento deve buscar e planejar atividades, com objetivos bem determinados que
potencializem tais recursos.

Nesse contexto um fator marcante ao utilizarmos tecnologias como mediadores
educacionais ´e o impacto expl´ıcito no espa¸co geogr´aﬁco da sala de aula. Tal abordagem
metodol´ogica propicia uma maior integra¸c˜ao entre ensino `a distˆancia e presencial, incen-
tivando o nascimento de uma escola mais criativa e menos normativa e quem sabe mais
libert´aria no sentido de que nem todos devam aprender as mesmas coisas, no mesmo tempo
e submetidos `as mesmas metodologias.

Toda sociedade ser´a uma sociedade que aprende de in´umeras formas, em tempo
real, com vast´ıssimo material audiovisual dispon´ıvel.(MORAN; MASETO; BEHRENS,
2013, p.67)

O presente trabalho tem a proposta de relacionar o ensino de matem´atica (mais
especiﬁcamente aritm´etica) com a utiliza¸c˜ao da linguagem de programa¸c˜ao Python, pois ´e

23

cada vez mais recorrente o acesso a tecnologias e as transforma¸c˜oes que estas possibilitam
`a sociedade. Nesse contexto as pr´aticas de ensino de matem´atica podem tentar usufruir
desses recursos tecnol´ogicos para dar um maior dinamismo e tornar a aprendizagem mais
prazerosa e signiﬁcativa.

Por ﬁm, este trabalho est´a estruturado conforme describo abaixo:

∙ Introdu¸c˜ao : Tem por objetivo justiﬁcar a viabilidade e importˆanica da utiliza¸c˜ao de

tecnologias na educa¸c˜ao;

∙ Cap´ıtulo 1: apresenta de maneira breve como utilizar a linguagem Python e algumas

de suas ferramentas;

∙ Cap´ıtulo 2: apresenta alguns programas em Python, elaborados a partir de ideias
presentes em demonstra¸c˜oes cl´assicas de resultados de aritm´etica, exempliﬁcando
como a rela¸c˜ao entre teoria e pr´atica pode ser frut´ıfera;

∙ Cap´ıtulo 3: traz as considera¸c˜oes ﬁnais, mostrando possibilidades de trabalhos futuros
na busca de aprofundamento, tanto na linguagem Python como na sua utiliza¸c˜ao
para o ensino da matem´atica.

25

Cap´ıtulo 1

Uma breve introdu¸c˜ao ao Python

1.1 Porque Python

Dentre tantas op¸c˜oes em tecnologias, resolvemos trabalhar com a linguagem de

programa¸c˜ao Python por diversos motivos, os quais ser˜ao elencados abaixo:

“Python ´e, provavelmente, a linguagem de programa¸c˜ao popular mais f´acil e agra-
d´avel de lidar. O c´odigo Python ´e simples para ler e escrever, e consegue ser conciso sem
ser enigm´atico” (SUMMERFIELD, 2012, p.1).

A linguagem de programa¸c˜ao Phyton ´e muito interessante como primeira
linguagem de programa¸c˜ao devido a sua simplicidade e clareza. Embora
simples, ´e tamb´em uma linguagem poderosa, podendo ser usada para
administrar sistemas e desenvolver grandes projetos. ´E uma linguagem
clara e objetiva, pois vai direto ao ponto, sem rodeios.(MENEZES, 2016,
p.24)

Al´em do fato de Python ser um software livre (pode ser baixado gratuitamente) e
multiplataforma (funciona nos sistema operacionais Windows, Linux e MacOS X, entre
outros), ´e uma linguagem que vem crescendo nos ´ultimos anos e ´e utilizadas por v´arias
empresas. Al´em disso, ´e recomendada por diversos proﬁssionais da ´area da computa¸c˜ao e
adodata por diversas empresas, como ´e ilustrado da Figura 1 a Figura 13.

Algumas empresas que usam o Python segundo (Python Brasil, 2018)

Figura 1 – Empresas que usam Python

26

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

Outras empresas que utilizam o Python de acordo com (Masanori, 2018)

Figura 2 – Outras
Python

empresas

que

usam

Figura 3 – Aplicativos que usam Python

Figura 4 – Institui¸c˜oes que usam Python

Figura 5 – Pixar usa Python

1.2 Instala¸c˜ao e ambienta¸c˜ao

Primeiramente vamos mostrar como baixar e instalar o Python no sistema opera-
cional Windowns 7, utilizando o navegador Google Chrome. Acessemos (Python ORG,
2018c)

Nessa tela da Figura 14, passemos o mouse no campo “Downloads”, depois cli-
quemos em “Python 3.6.4”, que ´e a vers˜ao dispon´ıvel no dia 12/01/2018. Ap´os o clique,
automaticamente come¸car´a o download do Python como indicam as Figuras 15 e 16.

Ap´os a conclus˜ao do download, cliquemos no indicador de download da Figura 16.
Ent˜ao ser´a aberta a janela de execu¸c˜ao conforme Figura 17. Cliquemos em “executar”,
ap´os esse passo ser´a aberta a janela do instalador, cliquemos em “Install Now” de acordo
com a Figura 18, ent˜ao o interpretador do Python come¸car´a a ser instalado (Figura 19).
Terminada a instala¸c˜ao aparecer´a o bot˜ao close, ao clicar em tal bot˜ao o interpretador da
linguagem Python estar´a instalado no computador.

1.2.

Instala¸c˜ao e ambienta¸c˜ao

27

Figura 6 – Coment´ario de Eric Raymond

Figura 7 – Coment´ario de Peter Norvig

Para iniciar o Python, no Windows 7, basta seguir a sequˆencia de comandos:

Menu iniciar → Todos os programas → Python 3.6 → IDLE (Python 3.6 32-
bit), conforme ilustra a Figura 20.

28

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

Figura 8 – Coment´ario de Cuon Dong

Figura 9 – Coment´ario de Bjarne Stroutrup

Uma janela ser´a aberta (Figura 21), descrita pelo interpretador como Python 3.6.4
Shell e nela ´e poss´ıvel construir nossos programas em Python. Fa¸camos nosso primeiro
programa.

Digite: print(“Bem vindo ao Python”) e depois aperte enter.

1.2.

Instala¸c˜ao e ambienta¸c˜ao

29

Figura 10 – Coment´ario

de Donald

Figura 11 – Guido Van Rossum: Criador

Knuth

do Python

Figura 12 – Monty Python, grupo de hu-
mor que inspirou o nome lin-
guagem

Figura 13 – Logomarca do Python

Figura 14 – S´ıtio para download do Python

O comando print(“Texto”) permite imprimir a palavra Texto na tela.

C´odigo 1.1 – Primeiro programa

30

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

Figura 15 – Download do Python

Figura 16 – Indicador do download no
Google Chrome

Figura 17 – Janela de conﬁrma¸c˜ao da
instalador

do

execu¸c˜ao
Python

Figura 18 – Janela de sele¸c˜ao das conﬁ-

gura¸c˜oes

Figura 19 – Progresso da instala¸c˜ao

1 Python 3.6.4 ( v3 .6.4: d48eceb , Dec 19 2017 , 06:04:45) [ MSC v .1900

32 bit ( Intel ) ] on win32

2 Type " copyright " , " credits " or " license () " for more information .

3 >>> print ( " Bem vindo ao Python " )

4 Bem vindo ao Python

Observe que antes do print temos >>>, isto indica que estamos no modo interativo
do Python (Python Shell), ou seja os comandos s˜ao executados logo ap´os o enter. O modo
interativo se apresenta por padr˜ao ao abrirmos o interpretador. Mas nossos programas
ser˜ao digitados no modo de edi¸c˜ao. Para isso, no Python Shell, basta clicar em File→New
File (Figura 22) dando acesso ao modo de edi¸c˜ao, conforme Figura 23.

1.2.

Instala¸c˜ao e ambienta¸c˜ao

31

Figura 21 – Python Shell

Figura 20 – Janela de conﬁrma¸c˜ao da
instalador

do

execu¸c˜ao
Python

Figura 22 – Caminho para o modo de

edi¸c˜ao

Figura 23 – Modo de edi¸c˜ao do Python

Fa¸camos o mesmo programa do C´odigo 1.1 no modo de edi¸c˜ao:

C´odigo 1.2 – Primeiro Programa Modo de Edi¸c˜ao

1 print ( " Bem vindo ao Python " )

Depois de digitar print(“Bem vindo ao python”) e apertar enter n˜ao acontecer´a
nada. A ﬁm de executarmos tal programa primeiro ´e necess´ario salv´a-lo, seguindo os
passos: Run → Run module → Ok → nome do arquivo → Salvar ; ap´os isso,
instantaneamente aparecer´a uma janela (modo interativo) mostrando o resultado do seu
programa. Tal procedimento ´e ilustrado conforme Figuras 24, 25, 26 e 27.

Por ﬁm nossos programas ter˜ao o seguinte aspecto visual como o do C´odigo 1.3
durante todo o trabalho. Tudo o que for digitado ap´os # ser´a ignorado pelo Python, sendo
considerado um coment´ario.

32

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

Figura 24 – Caminho para executar o
programa no modo de edi-
¸c˜ao

Figura 25 – “Ok” para salvar

Figura 26 – Nomeando o arquivo

Figura 27 – Resultado do programa

C´odigo 1.3 – Programa e resultado

1 print ( " Bem vindo ao Python " )

2 RESTART : # Coment ´a rio : Abaixo segue o resultado do programa

3 Bem vindo ao Python

1.3 Python como calculadora

Podemos utilizar o Python como uma calculadora bem poderosa, pois suporta
n´umeros t˜ao grandes quanto a mem´oria do computador pode aguentar. Os s´ımbolos das
opera¸c˜oes b´asicas no Python s˜ao +,−,*,/,**,// e %. Dados 𝑎, 𝑏 ∈ R, vemos, na Tabela
1, o que cada um desses s´ımbolos retorna quando acionado com os n´umeros 𝑎 e 𝑏. J´a no
C´odigo 1.4, vemos como usar o Python como calculadora.

Tabela 1 – Opera¸c˜oes b´asicas

S´ımbolo Comando

+
−
*
/
**
//
%

𝑎 + 𝑏
𝑎 − 𝑏
𝑎 * 𝑏
𝑎/𝑏
𝑎 * * 𝑏
𝑎//𝑏
𝑎%𝑏

Retorna:
A soma
A subtra¸c˜ao
A multiplica¸c˜ao
A divis˜ao
A potˆencia
O quociente em Z
A resto da divis˜ao em Z

C´odigo 1.4 – Opera¸c˜oes Matem´aticas

1 >>> 16+5 #

Ap ´o s apertar Enter teremos exibido na tela a soma .

2 21

1.3. Python como calculadora

33

3 >>> 16 - 5 # A subtra ¸c ~a o .

4 11

5 >>> 16 * 5 # O asterisco * , retorna a multiplica ¸c ~a o .

6 80

7 >>> 16 * * 5 # Os * * representam a pot ^e ncia , aqui 16 est ´a elevado a

5.

8 1048576

9 >>> 16/5 # A barra (/) retorna a divis ~a o .

10 3.2

11 >>> 16//5 # Duas (//) retornam o quociente da divis ~a o inteira .

12 3

13 >>> 16%5 # O s ´ı mbolo (%) ( porcentagem ) retorna o resto da divis ~a o

inteira .

14 1

´E importante digitar os comandos apresentados no C´odigo 1.4 com outros valores.
Uma op¸c˜ao para efetuar os C´odigos ´e acessando (Python ORG, 2018a), que nos encami-
nhar´a para uma vers˜ao do Python Shell online, caso se tenha conex˜ao com a internet,
proporcionando uma aprendizagem dinˆamica em tempo real concomitante `a leitura.

√

Caso se queira efetuar c´alculos com valores, digamos mais espec´ıﬁcos, como:
2, 𝜋, 𝑒, temos que importar, como no c´odigo abaixo, a biblioteca math, tal biblio-
teca nos d´a acesso a uma boa gama de conte´udos matem´aticos. Para maiores detalhes,
consultar (MENEZES, 2016; SUMMERFIELD, 2012; Python ORG, 2018b).

C´odigo 1.5 – 2

√

2, 𝜋𝑒 e 𝑒𝜋

1 >>> import math # importando a biblioteca

2 >>> math . sqrt (2) # A ra ´ı z quadrada de 2.

3 1.4142135623730951

4 >>> math . pi # A constante pi

5 3.141592653589793

6 >>> math . e # A constante e

7 2.718281828459045

8 >>> 2 * * ( math . sqrt (2) ) # Pot ^e ncia com expoente irracional

9 2.665144142690225

10 >>> math . pi * * ( math . e ) # Pi elevado a e

11 22.45915771836104

12 >>> math . e * * ( math . pi ) # e elevado a pi

13 23.140692632779263

Ainda explorando os recursos do Python como calculadora, podemos resolver
express˜oes num´ericas e at´e calcular potˆencias relativamente grandes, como no C´odigo 1.6:

34

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

C´odigo 1.6 – Express˜oes num´ericas e 71000

1 >>> 2 * * 3+12/4 * 2 -10 # Uma express ~a o aritm ´e tica simples

2 4.0

3 >>> 2 * * 3+12/(4 * 2 -10) # Observe o uso do par ^e nteses , alterando o

resultado

4 2.0

5 >>> 2 * * 3+12/4 * (2 -10)

6 -16.0

7 >>> 7 * * 1000 # C ´a lculo de uma pot ^e ncia grande , cujo c ´a lculo manual

´e invi ´a vel

8 1 2 5 3 2 5 6 6 3 9 9 6 5 7 1 8 3 1 8 1 0 7 5 5 4 8 3 2 3 8 2 7 3 4 2 0 6 1 6 4 9 8 5 0 7 5 0 8 0 9 8 6 1 7 1 4 6 3 4 9 5 0 0 7

9 5 2 0 9 7 0 5 9 6 3 1 7 3 8 1 1 6 4 3 2 4 4 8 8 3 9 0 5 4 3 5 1 5 2 0 7 6 3 1 9 8 6 1 5 9 1 9 5 5 1 5 9 4 0 7 6 6 8 5 8 2 8 9 8

10 9 4 6 7 2 6 3 0 2 2 7 6 1 7 9 0 8 3 8 2 7 0 8 5 4 5 7 9 8 3 0 0 1 5 1 1 1 2 4 6 6 6 1 2 0 3 9 8 4 6 2 4 3 5 8 9 2 9 8 3 2 5 7 1

11 6 1 5 7 1 8 0 1 4 7 0 4 0 9 6 3 0 5 6 6 8 0 9 7 5 0 7 6 1 3 2 7 3 6 6 3 0 2 3 2 2 6 8 9 5 2 5 0 5 4 1 3 8 5 9 2 7 1 5 8 4 2 6 0

12 8 8 6 8 4 4 9 4 0 8 2 4 1 6 7 6 8 6 1 7 7 0 8 1 8 9 5 9 2 2 8 6 9 3 6 0 3 9 9 2 2 3 1 1 1 2 5 6 8 3 7 1 9 2 1 5 0 4 6 6 8 9 1 5

13 6 7 3 8 3 5 2 5 9 0 1 3 7 2 4 1 5 5 4 5 1 0 1 8 5 8 5 5 9 6 4 5 4 9 9 2 7 5 7 5 4 9 3 2 4 7 3 9 1 1 3 2 5 4 8 5 3 4 3 7 8 4 9 7

14 9 7 8 8 0 6 0 8 4 9 5 1 0 8 5 8 7 4 2 0 2 0 1 1 8 3 6 3 6 2 3 1 5 7 2 7 4 2 0 1 0 9 5 5 4 7 8 2 9 8 8 7 9 1 5 3 0 0 8 8 2 8 9 7

15 1 1 8 4 4 5 5 0 5 0 0 2 3 0 4 8 5 6 3 8 4 1 3 1 8 9 9 4 7 1 3 2 1 4 2 2 4 3 9 4 7 3 3 4 1 9 9 2 5 9 3 0 0 7 3 5 6 2 2 4 9 2 9 3

16 7 4 1 9 4 5 3 6 5 0 0 6 1 4 9 0 3 0 2 1 0 5 1 2 7 9 2 0 3 1 4 4 3 0 4 0 1 6 3 6 8 5 5 6 7 7 5 4 9 1 3 6 3 3 7 4 8 1 3 2 1 8 1 1

17 3 4 9 6 7 8 4 2 7 0 7 6 0 9 1 4 3 7 3 4 5 0 4 5 3 9 9 3 3 7 3 4 8 6 1 1 2 6 1 1 6 8 0 5 5 9 2 9 3 5 5 4 0 2 9 9 2 8 2 3 1 9 2 4

18 9 1 1 9 0 3 6 0 0 2 7 0 3 6 1 1 2 2 8 3 1 8 0 9 3 5 8 7 2 7 7 5 2 1 4 5 1 7 4 6 4 0 1 3 1 7 8 2 7 4 6 5 7 1 0 0 7 3 6 3 2 1 5 6

19 4 6 0 6 8 3 8 2 5 2 7 3 9 6 0 1 1 5 6 4 1 4 6 2 8 4 4 5 5 4 3 6 6 3 1 4 4 6 9 6 0 5 0 6 5 0 1 6 0 8 1 2 6 2 1 8 1 4 3 2 7 0 6 2

20 6 6 6 1 9 5 1 7 2 7 0 1 7 8 0 2 0 0 2 8 6 6 4 5 0 2 3 8 2 3 0 8 3 1 8 5 9 2 8 0 6 1 3 7 1 3 1 0 3 0 0 8 2 9 2 8 4 0 7 1 1 4 1 2

21 07731280600001

1.4 Vari´aveis

At´e agora est´avamos digitando explicitamente os n´umeros e realizando c´alculos com
os mesmo atrav´es do Python, no entanto em termos de C´odigo ´e bem melhor utilizarmos
uma vari´avel (que pode ser uma letra ou um outro nome 1 qualquer).
O conte´udo de uma vari´avel pode ser do tipo, inteiro (int), decimal (ﬂoat), palavra (string),
vetor (lista), etc. A vantagem de se utilizar vari´aveis ´e que podemos manipul´a-las dentro
de um c´odigo (programa) e deixar expl´ıcita a l´ogica de programa¸c˜ao por tr´as do algoritmo.

Vejamos exemplos de vari´aveis num´ericas no Python Shell no C´odigo 1.7.

1

o nome deve obrigatoriamente come¸car com uma letra, podem conter n´umeros e o s´ımbolo

1.4. Vari´aveis

35

C´odigo 1.7 – Declarando e manipulando vari´aveis

1 >>> a = 3 # Declarando a vari ´a vel a , e atribuindo - lhe o valor 3

2 >>> a

3 3

4 >>> 7+ a # Operando com a

5 10

6 >>> 6 * a # Outra opera ¸c ~a o com a

7 18

8 >>> b =10 # Declarando b

9 >>> b

10 10

11 >>> a + b # Operando com a e b

12 13

13 >>> a * b

14 30

15 >>> a / b

16 0.3

17 >>> c =2 * a +3 * b # Definindo c em fun ¸c ~a o de a e b

18 >>> c

19 36

20 >>> a + b + c

21 49

Nos exemplos ilustrados no C´odigo 1.7, atribu´ımos valores num´ericos `as vari´aveis. Contudo,
veremos que tamb´em ´e poss´ıvel atribuir outros “objetos” `as vari´aveis. Por exemplo ´e poss´ıvel
atribuir uma palavra ou cadeia de caracteres (string) a determinada vari´avel. ´E importante
ressaltar que uma cadeia de caracteres no Python sempre deve estar especiﬁcada entre
aspas duplas ou simples.

Vejamos no C´odigo 1.8 uma vari´avel do tipo cadeia de caractere e a fun¸c˜ao, print
(j´a usada no C´odigo 1.1). O Python reconhece que a fun¸c˜ao print deve ser executada,
mostrando na tela o que estava em seu argumento (ou seja o que estiver dentro dos
parˆenteses).

C´odigo 1.8 – Vari´avel do tipo string

1 >>> x = " Ol ´a Python " # Declarando x do tipo cadeia de caractere

2 >>> print ( x ) # A fun ¸c ~a o print imprimir ´a o conte ´u do da vari ´a vel x

3 Ol ´a Python

Al´em de enviarmos mensagens, podemos operar com palavras: acessar qualquer

dos caracteres que a comp˜oem, concatenar, fatiar e compor.

Supondo que temos uma vari´avel 𝑥 do tipo palavra, podemos saber o tamanho

36

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

(quantidade de caracteres) de 𝑥 atrav´es da fun¸c˜ao len2, logo len(𝑥)=“tamanho de 𝑥”. ´E
poss´ıvel tamb´em acessar cada caractere da palavra 𝑥 de acordo com a sua posi¸c˜ao 𝑖 por
meio do comando 𝑥[𝑖]. Ressaltamos que a primeira posi¸c˜ao ´e interpretada como posi¸c˜ao zero,
caso a leitura da palavra seja da esquerda para a direita, com isso 0 ≤ 𝑖 ≤len(𝑥)−1. Caso
leia-se 𝑥 da direita para a esquerda os ´ındices 𝑖 ser˜ao negativos, com −len(𝑥)≤ 𝑖 ≤ −1.
Por exemplo, considere atribu´ıda a palavra matem´atica `a vari´avel 𝑥, 𝑥=‘matem´atica’.
Ent˜ao, len(𝑥)=10, 𝑥[3] = e, 𝑥[9] = a e 𝑥[−2] = c. A ﬁgura abaixo apresenta a posi¸c˜ao de
todos os caracteres:

𝑥[−10] 𝑥[−9] 𝑥[−8] 𝑥[−7] 𝑥[−6] 𝑥[−5] 𝑥[−4] 𝑥[−3] 𝑥[−2] 𝑥[−1]

𝑥 =

m

a

t

e

m

´a

t

i

c

a

𝑥[0]

𝑥[1]

𝑥[2]

𝑥[3]

𝑥[4]

𝑥[5]

𝑥[6]

𝑥[7]

𝑥[8]

𝑥[9]

Outra opera¸c˜ao poss´ıvel com uma vari´avel 𝑥 do tipo cadeia de caractere ´e o
fatiamento. Por exemplo, o comando 𝑥[𝑖 : 𝑗] fatia a palavra 𝑥, nos retornando seus
caracteres entre as posi¸c˜oes 𝑖 e 𝑗 − 1, incluindo os caracteres nestas posi¸c˜oes. Na tabela a
seguir temos alguns dos comandos de fatiamento:

Tabela 2 – Fatiamento

Comando
𝑥[𝑖 : 𝑗]
𝑥[𝑖 :]
𝑥[: 𝑗]
𝑥[:]
𝑥[:: −1]
𝑥[:: 2]
𝑥[:: −2]

Retorna a fatia
de 𝑥[𝑖] at´e 𝑥[𝑗 − 1]
de 𝑥[𝑖] at´e o ´ultimo caractere
do primeiro at´e 𝑥[𝑗 − 1]
toda a vari´avel 𝑥
𝑥 de tr´as pra frente
de 𝑥[0] pra frente de 2 em 2
de 𝑥[−1] pra tr´as de 2 em 2

Supondo agora que tenhamos duas vari´aveis 𝑥 e 𝑦 do tipo cadeia de caractere, a

opera¸c˜ao 𝑥 + 𝑦 retorna a concatena¸c˜ao de 𝑥 com 𝑦.

Abaixo um C´odigo para melhor esclarecimento de tais opera¸c˜oes.

C´odigo 1.9 – Concatena¸c˜ao e Fatiamento

1 >>> x = ’ matem ´a tica ’ # Declarando x vari ´a vel tipo string

2 >>> y = " computa ¸c ~a o " # Declarando y

3 >>> len ( x ) # A fun ¸c ~a o len retorna o tamanho de x

4 10

5 >>> print ( y [3]) # Acessando o caractere da terceira posi ¸c ~a o de y

6 p

2 A fun¸c˜ao len s´o se aplica a vari´aveis tipo string ou lista

1.4. Vari´aveis

37

7 >>> print ( x + y ) # " Soma " de x com y , que ´e interpretado como a

concatena ¸c ~a o de x com y

8 matem ´a ticacomputa ¸c ~a o

9 >>> print ( y + x )

10 computa ¸c ~a omatem ´a tica

11 >>> x [0:4] # Fatia de x que vai de x [0] at ´e x [3]

12 ’ mate ’

13 >>> y [6:] # Fatia de y que vai de y [6] at ´e y [9] ( ´u ltimo caractere )

14 ’a ¸c ~a o ’

15 >>> x [:: -1] # Esse comando retorna x de tr ´a s pra frente

16 ’ acit ´a metam ’

17 >>> y [ -10: -5] # Fatia que vai de y [ -10] at ´e y [ -6]

18 ’ compu ’

19 >>> x [::2] # Retorna de x [0] at ´e o ´u ltimo caractere de 2 em 2.

20 ’ mtmtc ’

21 >>> x [:: -2] # Percorre de tr ´a s pra frente de 2 em 2 , come ¸c ando em

x [ -1]

22 ’ ai ´a ea ’

Finalmente, temos a composi¸c˜ao que ´e uma opera¸c˜ao que permite compor ou
inserir numa mensagem vari´aveis designadas atrav´es de marca¸c˜oes. Por exemplo, na
mensagem: print(‘Rog´erio tem %d anos.’%𝑥), temos que o s´ımbolo %d ´e marcador dentro
da mensagem; tal marca ser´a substitu´ıda pelo valor da vari´avel 𝑥. No Python temos os
marcadores: %d para inteiros, %f para decimais (ﬂoat) e %s para palavras (strings).

No C´odigo 1.10 apresentamos exemplos do uso de marca¸c˜oes dentro de um programa.

C´odigo 1.10 – Marcadores

1 >>> idade =38 # declarando a vari ´a vel idade do tipo inteiro

2 >>> print ( " Rog ´e rio tem % d anos " % idade ) # O % d ser ´a trocado pelo

valor de idade , essa ´e a composi ¸c ~a o .

3 Rog ´e rio tem 38 anos

4 >>> fruta = ’ melancia ’ # declarando a vari ´a vel fruta do tipo string

5 >>> print ( " Rog ´e rio tem % d anos e gosta de % s " %( idade , fruta ) )

6 Rog ´e rio tem 38 anos e gosta de melancia

7 >>> # no exemplo acima % s foi trocado pelo " valor " de fruta

8 >>> nome = ’ Rog ´e rio ’

9 >>> qtde =5

10 >>> vu =1.80

11 >>> print ( ’% s comprou % d canetas por R$

%4.2 f ’ %( nome , qtde , qtde * vu ) )

12 Rog ´e rio comprou 5 canetas por R$ 9.00

13 >>> # O marcador % s foi trocado pelo valor da vari ´a vel nome

38

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

14 >>> # O marcador % d pelo valor de qtde

15 >>> # O marcador %4.2 f foi trocado pelo valor de 5 * (1.80)

16 >>> # No %4.2 f , o 4 significa 4 caracteres , 2 casa decimais e f

float

Tratemos agora as vari´aveis l´ogicas ou booleanas que s˜ao True (verdadeiro) e False
(falso). Podemos declarar uma vari´avel como True ou False, mas geralmente estamos
interessados em realizar compara¸c˜oes l´ogicas, com o uso de operadores relacionais. O
resultado dessas compara¸c˜oes s˜ao sempre um valor l´ogico (True ou False) que depende da
proposi¸c˜ao especiﬁcada. Os operadores relacionais do Python est˜ao elencados na Tabela 3,
ilustrados no C´odigo 1.11.

Tabela 3 – Operadores relacionais

S´ımbolo Compara¸c˜ao (Pergunta)

==
! =
>
<
>=
<=

igualdade
diferente
maior do que
menor do que
maior ou igual
menor ou igual

1 >>> a = True # Declarando a do tipo l ´o gico ( booleana )

C´odigo 1.11 – Operadores relacionais

2 >>> b = False

3 >>> c =5

4 >>> d =10

5 >>> a == b # Perguntando se a ´e igual a b .

6 False

7 >>> a != b # Perguntando se a ´e diferente de b .

8 True

9 >>> c ==7

10 False

11 >>> c < d # Comparando c com d , neste caso , perguntando se c ´e

menor que b .

12 True

13 >>> d >= 10 # Comparando b com 10; neste caso , perguntando se ´e

maior ou igual a 10.

14 True

15 >>> d > 10 # Perguntando se d ´e maior que 10.

16 False

17 >>> # Pode - se escrever a =2 ou a = 2 o Python entende as duas

formas

1.4. Vari´aveis

39

No Python, tamb´em ´e poss´ıvel especiﬁcar operadores l´ogicos, que s˜ao: not (n˜ao),
and (e) e or (ou), conhecidos tamb´em como nega¸c˜ao (∼ ou ¬), conjun¸c˜ao (∧) e disjun¸c˜ao
(∨), respectivamente.

Sejam 𝑝 e 𝑞 proposi¸c˜oes quaisquer. Pode-se formar outras proposi¸c˜oes envolvendo

𝑝, 𝑞 e os operadores l´ogicos. Por exemplo: ¬𝑝 (not 𝑝), 𝑝 ∧ 𝑞 (𝑝 and 𝑞) e 𝑝 ∨ 𝑞 (𝑝 or 𝑞).

As Tabelas 4, 5 e 6 apresentam os valores de verdade das proposi¸c˜oes compostas
envolvendo proposi¸c˜oes 𝑝 e 𝑞 a partir dos valores de verdade de 𝑝 e de 𝑞 e do operador
utilizado na constru¸c˜ao da proposi¸c˜ao. O C´odigo 1.12 exempliﬁca o uso de tais operadores.

Tabela 4 – not

𝑝 not 𝑝
V
F

F
V

Tabela 5 – and

𝑝
𝑞
V V
V F
F V
F F

𝑝 and 𝑞
V
F
F
F

Tabela 6 – or

𝑝
𝑞
V V
V F
F V
F F

𝑝 or 𝑞
V
V
V
F

C´odigo 1.12 – Operadores l´ogicos

1 >>> p = True

2 >>> q = False

3 >>> c =5

4 >>> d =10

5 >>> not p # A nega ¸c ~a o de p

6 False

7 >>> p or q # A proposi ¸c ~a o p ou q

8 True

9 >>> c !=5 and d ==10 # Proposi ¸c ~a o composta usando o and , ser ´a falsa

de acordo com a Tabela 5.

10 False

11 >>> c <5 or 2 * d > 18 # Proposi ¸c ~a o composta usando o or , ser ´a

verdadeira de acordo com a Tabela 6.

12 True

13 >>> ( d % c ==0 and d >=10) or ( not ( p and q ) ) # Uma proposi ¸c ~a o mais

complexa ( express ~a o l ´o gica )

14 True

Observe que a ´ultima express˜ao l´ogica do C´odigo 1.12 ´e um pouco mais complexa; e
existe uma ordem de prioridade a ser obedecida para determinar seu valor l´ogico: primeiro
os (), segundo o not, terceiro o and e por ´ultimo o or.

Diante de tal hierarquia resolvamos a express˜ao l´ogica:

40

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

(d%c==0 and d>=10) or (not (p and q)) com p=True, q=False, c=5 e d=10

Como d%c==0 ´e Verdadeira (V) pois 10 ´e divis´ıvel por 5, d>=10 ´e V, pois d=10,

logo (d%c==0 and d>=10) ´e V.

Como p and q ´e F, logo (not (p and q)) ´e V

Finalmente nossa express˜ao se resume em V or V que ´e V.

De modo simpliﬁcado:

(V

and

(d%c==0 and d>=10) or
or
or
or
V

V )
V
V

and q))
(p
(V and F))

(not
(not
(not F)

V

Um outro tipo de vari´avel que usaremos ser˜ao as listas ou vetores. Podemos entender
uma lista como os vag˜oes de um trem, sendo que uma lista poder ter zero ou mais vag˜oes
e dentro dos mesmos seus elementos.

Uma lista L de 𝑛 elementos ´e representada por L=[𝑥0,𝑥1,. . .,𝑥𝑛−1], em que os
colchetes servem para indicar que L ´e uma lista. Uma lista vazia em Python ´e representada
por L=[ ]. Os elementos 𝑥𝑖 de L podem ser palavras (strings), n´umeros ou at´e mesmo
outra lista. Por exemplo, seja L a lista com as vogais, ou seja, L=[‘a’,‘e’,‘i’,‘o’,‘u’]. Os
elementos de L s˜ao letras, mas como dito anteriormente, podemos ter elementos de outros
tipos, como, por exemplo, na lista W=[1,2,‘x’,‘y’,[‘a’,‘b’]] os dois primeiros elementos s˜ao
n´umeros inteiros, o terceiro e quarto s˜ao letras e o ´ultimo ´e outra lista.

Seja L uma lista. Assim como nas palavras (strings), podemos usar a fun¸c˜ao len
para descobrirmos o tamanho de L, podemos acessar qualquer elemento de L com o
comando L[i] , 0 ≤ 𝑖 ≤ len(L) − 1 , e ainda, podemos fatiar L exatamente como na Tabela
1, ou seja, L[𝑖:𝑗] ´e uma fatia de L que vai de L[𝑖] at´e L[𝑗 − 1].

Agora, especiﬁcamente para listas, podemos modiﬁcar qualquer um de seus elemen-
tos, atribuindo novo valor ao elemento 𝑖, por meio do comando L[𝑖]= novo valor. Al´em disso,
podemos acrescentar um vag˜ao ao ﬁnal de uma lista, atrav´es do m´etodo append. De um
modo geral o m´etodo append funciona da seguinte maneira: se L=[𝑥0,𝑥1,. . .,𝑥𝑛−1] uma lista
com 𝑛 elementos, ao digitarmos L.append(𝑥𝑛), L se modiﬁcar´a para L=[𝑥0,𝑥1,. . .,𝑥𝑛−1, 𝑥𝑛]
passando a ter 𝑛 + 1 elementos.

Dadas listas L e W, L+W ser´a uma nova lista come¸cando no primeiro elemento
de L e terminando no ´ultimo de W ordenadamente. Ressaltamos ainda que 𝑛*L designa
. Abaixo segue um C´odigo utilizando todos os recursos descritos
a lista L + L + . . . + L

⏟

 ⏞
𝑛 vezes

acima.

C´odigo 1.13 – Listas e algumas opera¸c˜oes

 
1.5. Entrada de Dados

41

1 >>> L =[ ’a ’ , ’b ’ , ’c ’ , ’d ’ , ’e ’] # declarando L , vari ´a vel tipo lista

( vetor )

2 >>> L

3 [ ’a ’ , ’b ’ , ’c ’ , ’d ’ , ’e ’]

4 >>> len ( L ) # A fun ¸c ~a o len retorna o tamanho da lista

5 5

6 >>> L [2] # Aqui estamos acessando um elemento da lista ( lembre - se

que a contagem das posi ¸c oes inicia - se em zero )

7 ’c ’

8 >>> L [2]=15 # Atribuindo um novo valor a posi ¸c ~a o 2 de L

9 >>> L

10 [ ’a ’ , ’b ’ , 15 , ’d ’ , ’e ’]

11 >>> L . append ( ’f ’) # O append insere uma nova entrada ao final de

L , cujo conte ´u do ´e f .

12 >>> L # Agora L ter ´a tamanho 6 e L [5]= ’ f ’

13 [ ’a ’ , ’b ’ , 15 , ’d ’ , ’e ’ , ’f ’]

14 >>> print ( L +[ ’g ’ , ’h ’ ]) # Somando listas

15 [ ’a ’ , ’b ’ , 15 , ’d ’ , ’e ’ , ’f ’ , ’g ’ , ’h ’]

16 >>> print (2 * [3 ,4]) # Multiplicando uma lista por 2

17 [3 , 4 , 3 , 4]

18 >>> L [2:5] # Fatia de L da segunda at ´e a quarta posi ¸c ~a o

19 [15 , ’d ’ , ’e ’]

20 >>> L [:: -1] # Invertendo a lista

21 [ ’h ’ , ’g ’ , ’f ’ , ’e ’ , ’d ’ , 15 , ’b ’ , ’a ’]

1.5 Entrada de Dados

At´e aqui nossos pequenos programas j´a vinham com valores fornecidos previamente
para as vari´aveis. No entanto podemos solicitar que um usu´ario forne¸ca dados (atrav´es do
teclado por exemplo), a ﬁm de executar um programa diversas vezes, sem alterar sua estru-
tura. A fun¸c˜ao que permite a entrada de dados ´e a input. Sua sintaxe ´e input(’mensagem
solicitando ao usu´ario um dado’)

Vejamos um exemplo acerca de entrada de dados no C´odigo 1.14 .

C´odigo 1.14 – Entrada de Dados

1 x = input ( " Digite um n ´u mero : " ) # x ter ´a o valor que for digitado

2 print ( x )

3 RESTART : # Ap ´o s o RESTART temos a execu ¸c ~a o do programa

4 Digite um n ´u mero :56

5 56

42

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

No programa do C´odigo 1.14 tem-se que digitar um n´umero e depois apertar a tecla enter
(caso contr´ario o programa n˜ao ´e executado); no exemplo, foi digitado o 56.

Prosseguindo, vejamos outro programa com entrada de dados, no C´odigo 1.15.

1 nome = input ( " Digite seu nome : " ) # Aqui a vari ´a vel nome que

C´odigo 1.15 – Input e marcadores

depende da entrada

2 print ( " Muito prazer %s , bons estudos . " % nome )

3 RESTART :

4 Digite seu nome : Edilene

5 Muito prazer Edilene , bons estudos .

´E importante destacar o seguinte detalhe, se digit´assemos no Programa 1.14 acima,
no lugar de n´umero a palavra ol´a e no Programa 1.15 no lugar de nome o n´umero 123,
por exemplo, os programas rodariam perfeitamente (se poss´ıvel, fa¸ca o teste). Isto ocorre
porque a fun¸c˜ao input sempre retorna um valor do tipo cadeia de caractere (string) e
para contornar tal situa¸c˜ao devemos converter a entrada de dados de acordo com o tipo
que queremos para a vari´avel. O Programa 1.16 exempliﬁca a situa¸c˜ao descrita acima.

C´odigo 1.16 – Entrada sem convers˜ao

1 a = input ( " Digite o primeiro n ´u mero : " )

2 b = input ( " Digite o segundo n ´u mero : " )

3 print ( a + b )

4 RESTART :

# O print retornou a concatena ¸c ~a o de 40 com 12

5 Digite o primeiro n ´u mero : 40

6 Digite o segundo n ´u mero : 12

7 4012

A convers˜ao da entrada de dados ´e algo bem interessante e bastante funcio-

nal.Vejamos algumas convers˜oes na tabela abaixo:

Tabela 7 – Convers˜ao de dados

Comando
x=int(input(’no: ’))
x=ﬂoat(input(’no: ’))
x=str(123)

Entrada
23
3.14
123

Retorna
23 tipo inteiro
3.14 tipo ﬂoat(decimal)
’123’ tipo string(caractere)

Nosso pr´oximo C´odigo ´e bem parecido com o C´odigo 1.16, no entanto, com os

dados convertidos

1.6. Estruturas b´asicas

43

C´odigo 1.17 – Entrada de dados com convers˜ao

1 a = int ( input ( " Digite o primeiro n ´u mero : " ) )

2 b = int ( input ( " Digite o segundo n ´u mero : " ) )

3 print ( a + b )

4 RESTART :

# O print nessa caso retorna a soma de 40 com 12

5 Digite o primeiro n ´u mero : 40

6 Digite o segundo n ´u mero : 12

7 52

Observe que a convers˜ao dos dados de entrada no C´odigo 1.17 permite que o Python

entenda 40 e 12 como n´umeros, o que n˜ao ocorre no C´odigo 1.16.

Podemos tamb´em converter n´umeros em strings, caso o interesse seja aplicar um
m´etodo espec´ıﬁco para strings, para uma lista dos m´etodos aplic´aveis a string consultar
(SUMMERFIELD, 2012, p. 68-70).

1.6 Estruturas b´asicas

Todos os programas at´e aqui foram sequenciais, isto ´e, executaram todas as linhas
uma ap´os a outra. No entanto isso nem sempre ser´a necess´ario. Por vezes pode-se estar
interessado que uma parte do programa seja executada apenas se uma dada condi¸c˜ao for
verdadeira. Em Python a estrutura de decis˜ao ´e o if .

O if ´e o nosso “se”, que pode ser entendido da seguinte forma: Se a condi¸c˜ao for

verdadeira fa¸ca algo. Essa condi¸c˜ao ser´a uma express˜ao l´ogica e a estrutura do if ser´a:

if <condi¸c˜ao>:

comando 1
comando 2
...
comando n

Observe que ap´os a condi¸c˜ao do if temos o s´ımbolo :(dois pontos) e que os comandos de
1 at´e n est˜ao todos alinhados e um pouco `a direita e abaixo do if ; este recuo `a direita
´e chamado de identa¸c˜ao e caracteriza o bloco de comando(s) do Python, nesse caso da
estrutura if . Como dito anteriormente, tal bloco s´o ser´a executado caso a condi¸c˜ao do if
seja verdadeira, caso contr´ario ser´a ignorado na execu¸c˜ao do programa.

O pr´oximo Programa pedir´a que o usu´ario forne¸ca dois n´umeros e retornar´a uma

mensagem dizendo qual foi o maior n´umero.

44

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

C´odigo 1.18 – Estrutura condicional if

1 a = int ( input ( " Digite o primeiro n ´u mero : " ) )

2 b = int ( input ( " Digite o segundo n ´u mero : " ) )

3 if a > b : # A linha 4 s ´o ser ´a executada caso a > b seja verdadeiro

4

print ( ’O primeiro n ´u mero ´e o maior ’)

5 if b > a :

6

print ( ’O segundo n ´u mero ´e o maior ’)

7 RESTART : # Aqui ´e o resultado do programa j ´a na janela interativa

8 Digite o primeiro n ´u mero : 35

9 Digite o segundo n ´u mero : 98

10 O segundo n ´u mero ´e o maior

Vejamos outro Programa, usando if , que leia a velocidade de um carro, caso esteja
acima de 80 km/h, calcule uma multa de R$ 5,00 por km/h quando o ve´ıculo est´a nestas
condi¸c˜oes e emita uma mensagem dizendo que o carro foi multado e o respectivo valor de
multa.

C´odigo 1.19 – Estrutura condicional if

1 v = int ( input ( ’ Qual a velocidade do carro ? ’) )

2 if v > 80:

3

4

m = 5 * (v -80)

print ( " Voc ^e foi multado , sua multa foi de %5.2 f " % m )

5 RESTART :

6 Qual a velocidade do carro ? 85

7 Voc ^e foi multado , sua multa foi de R$ 25.00

Pode-se usar v´arios if ’s no mesmo Programa, no entanto quando temos uma
condi¸c˜ao complementar ao if podemos fazer uso de outra palavra reservada do Python
que ´e o else. Por exemplo, no Programa 1.19 caso a velocidade seja menor ou igual a 80,
podemos usar o else para emitir uma mensagem ao usu´ario. Tal situa¸c˜ao ´e exempliﬁcada
no Programa 1.20.

C´odigo 1.20 – Uso do else

1 v = int ( input ( ’ Qual a velocidade do carro ? ’) )

2 if v > 80:

3

4

m = 5 * (v -80)

print ( " Voc ^e foi multado , sua multa foi de %5.2 f " % m )

5 else :

6

print ( " Parab ´e ns ! Voc ^e est ´a no limite permitido " )

7 RESTART :

8 Qual a velocidade do carro ? 80

9 Parab ´e ns ! Voc ^e est ´a no limite permitido

1.6. Estruturas b´asicas

45

Outra estrutura muito importante ´e a de repeti¸c˜ao (la¸co), que ´e usada para executar
a mesma parte de um programa v´arias vezes enquanto uma condi¸c˜ao for verdadeira. Uma
das estruturas de repeti¸c˜ao do Python ´e o while, cujo formato ´e:

while<condi¸c˜ao>:
comando 1
comando 2
...
comando n

Por exemplo, se quisermos um Programa que imprima todos os n´umeros naturais de 1 at´e
10, podemos utilizar um while, como no Programa 1.21:

C´odigo 1.21 – Estrutura while

1 x =1 # declarando a vari ´a vel x e atribuindo - lhe valor 1

2 while x <=10: # As linhas 3 e 4 ser ~a o executadas enquanto x <=10

3

4

print ( x )

x = x +1 # aqui um novo conceito , o contador , incrementa - se a x

uma unidade a cada execu ¸c ~a o

5 RESTART :

6 1

7 2

8 3

9 4

10 5

11 6

12 7

13 8

14 9

15 10

Observe que 𝑥, a cada vez que o la¸co se repetia, era acrescido do valor constante
1; quando isso ocorre com uma vari´avel em um programa, tal vari´avel recebe o nome de
contador.

Quando o valor que uma vari´avel vai recebendo durante a execu¸c˜ao de um programa

varia, estamos diante de um acumulador.

Observe tamb´em que os valores impressos na sa´ıda est˜ao na vertical, isto ´e, o print
imprime um n´umero e salta uma linha, at´e o la¸co ﬁndar. Caso queiramos apresentar a
sa´ıda dos n´umeros na horizontal, podemos criar um vetor para receber cada valor de 𝑥 e
depois imprimir tal vetor conforme C´odigo 1.22.

46

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

C´odigo 1.22 – Programa usando while com vetor de sa´ıda

1 x =1

2 n ´u meros =[]

3 while x <=10:

4

5

n ´u meros . append ( x )

x = x +1

6 print ( n ´u meros )

7 RESTART :

8 [1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10]

Uma outra alternativa seria usar o comando print(𝑥, end=“ ”). Tal comando
imprime todos os valores de 𝑥 gerados no la¸co da estrutura de repeti¸c˜ao em linha horizontal,
como ilustra o c´odigo abaixo:

C´odigo 1.23 – Imprimindo em linha

1 x =1

2 while x <=10:

3

4

print (x , end = " " )

x = x +1

5 RESTART :

6 1 2 3 4 5 6 7 8 9 10

Podemos fazer varia¸c˜oes do Programa 1.22 como: listar todos os n´umeros pares (ou
´ımpares) at´e 30, ou at´e um dado 𝑛 ∈ N fornecido pelo usu´ario; exibir apenas os m´ultiplos
de 3, dentre outras. Enﬁm, s˜ao v´arias as possibilidades tanto usando o if quanto o while
que propiciam atacar v´arios problemas, buscando um programa que os solucione.

O Programa 1.24 a seguir, pedir´a ao usu´ario que forne¸ca um n´umero (natural) e

exibir´a todos os n´umeros pares at´e o n´umero fornecido.

1 n = int ( input ( ’ Digite um n ´u mero : ’) )

C´odigo 1.24 – Pares at´e um certo n

2 x =0

3 pares = []

4 while x <= n :

5

6

pares . append ( x )

x = x +2

7 print ( ’ Todos os pares at ´e % d s ~a o ’%n , pares )

8 RESTART : Abaixo uma execu ¸c ~a o quando o n = 10

9 Digite um n ´u mero : 10

10 Todos os pares at ´e 10 s ~a o [0 , 2 , 4 , 6 , 8 , 10]

1.6. Estruturas b´asicas

47

Para efeito de treinamento, fa¸camos um programa que leia 10 n´umeros fornecidos
pelo usu´ario e retorne a m´edia dos 10 n´umeros. Nesse programa ser˜ao usados tanto contador
quanto acumulador.

C´odigo 1.25 – M´edia de 10 n´umeros fornecidos pelo usu´ario

1 n = 1 # Aqui nosso contador

2 s = 0 # Aqui nosso acumulador

3 while n <=10:

4

5

6

x = int ( input ( " Digite o % d o n ´u mero : " % n ) )
s = s + x

n = n +1

7 print ( " A m ´e dia dos 10 n ´u meros fornecidos ´e %5.2 f " %( s /10) )

8 RESTART :
9 Digite o 1 o n ´u mero : 1
10 Digite o 2 o n ´u mero : 2
11 Digite o 3 o n ´u mero : 3
12 Digite o 4 o n ´u mero : 4
13 Digite o 5 o n ´u mero : 5
14 Digite o 6 o n ´u mero : 6
15 Digite o 7 o n ´u mero : 7
16 Digite o 8 o n ´u mero : 8
17 Digite o 9 o n ´u mero : 9
18 Digite o 10 o n ´u mero : 10
19 A m ´e dia dos 10 n ´u meros fornecidos ´e

5.50

Observe que a vari´avel s acumula (somando) todos os 10 valores inseridos pelo
usu´ario, enquanto que a vari´avel n vai incrementando seu valor de 1 em 1, ou seja n ´e um
contador.

Podemos entender que um contador ´e um caso particular de acumulador no qual

acumula sempre um mesmo valor constante.

`As vezes ´e necess´ario colocar uma estrutura dentro de outra em um programa. Tal
procedimento chama-se ”aninhar”; ent˜ao em estruturas aninhadas temos um if dentro de
outro if , ou um while dentro de outro while, ou um if dentro de um while e vice-versa.

Fa¸camos um programa que calcule o valor da conta telefˆonica de acordo com os
minutos gastos se a empresa oferece os seguintes planos: abaixo de 100 minutos cobra R$
0,40 o minuto; entre 100 e 200 minutos cobra R$ 0,35 por minuto; acima de 200 minutos
cobra R$ 0,20 por minuto.

C´odigo 1.26 – Conta telefˆonica

1 min = int ( input ( " Quantos minutos voc ^e utilizou esse m ^e s ?

" ) )

2 if min < 100:

48

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

3

p = 0.40

4 else :

5

6

7

8

if min < 200: # Esse if est ´a aninhado ( dentro ) do else

p = 0.35

else : # esse else est ´a aninhado no else da linha 4

p = 0.20

9 print ( " Sua conta esse m ^e s ser ´a de R$ %6.2 f " %( min * p ) )

10 RESTART :

11 Quantos minutos voc ^e utilizou esse m ^e s ?

150

12 Sua conta esse m ^e s ser ´a de R$

52.50

Podemos tamb´em substituilr um par else e if pela palavra reservada elif . Esteti-
camente utilizar o elif ´e interessante quando o programa apresenta muitos pares else e if .
O c´odigo a seguir ´e praticamente idˆentico ao C´odigo 1.26, exceto pelo uso do elif

C´odigo 1.27 – Conta telefˆonica, uso do elif

1 min = int ( input ( " Quantos minutos voc ^e utilizou esse m ^e s ?

" ) )

2 if min < 100:

3

p = 0.40

4 elif min < 200: # elif substituindo um else e if

5

p = 0.35

6 else :

7

p = 0.20

8 print ( " Sua conta esse m ^e s ser ´a de R$ %6.2 f " %( min * p ) )

9 RESTART :

10 Quantos minutos voc ^e utilizou esse m ^e s ?

150

11 Sua conta esse m ^e s ser ´a de R$

52.50

No C´odigo 1.28, temos mais um exemplo de estruturas aninhadas. Tal programa
exibe a tabuada de multiplica¸c˜ao do 1 ao 10, para isso vamos usar um while dentro de
um while.

C´odigo 1.28 – Tabuada de Multiplica¸c˜ao

1 tabuada =1

2 while tabuada <=10:

3

4

5

6

7

n ´u mero = 1

while n ´u mero <=10: # while aninhado com while

print ( " % d x % d = % d " %( tabuada , n ´u mero , tabuada * n ´u mero ) )

n ´u mero +=1 # abrevia ¸c ~a o de n ´u mero = n ´u mero +1

tabuada +=1

8 # A sa ´ı da desse programa n ~a o ser ´a apresentada , rode - o e entenda o

porqu ^e .

1.6. Estruturas b´asicas

49

Outra palavra reservada bem ´util ´e o break. O break ´e uma instru¸c˜ao que for¸ca
a parada do la¸co de um while. Por exemplo, se quisermos escrever um programa que
imprima a soma dos n´umeros digitados por um usu´ario, onde tal usu´ario digita tantos
n´umeros quanto queira, parando a soma apenas quando o 0 (zero) for digitado, da´ı temos
o n´umero 0 como condi¸c˜ao de parada (break).

C´odigo 1.29 – Soma dos n valores fornecidos, uso do break

1 s =0

2 while True : # esse while roda infinitamente

3

4

5

6

n = int ( input ( " Digite um n ´u mero para somar ou 0 para sair : " ) )

if n == 0: # um if aninhado dentro do while

break

s = s + n # s acumulando todos os valores digitados

7 print ( " A soma de todos os n ´u meros digitados ´e % d " % s )

8 RESTART :

9 Digite um n ´u mero para somar ou 0 para sair : 3

10 Digite um n ´u mero para somar ou 0 para sair : 5

11 Digite um n ´u mero para somar ou 0 para sair : 7

12 Digite um n ´u mero para somar ou 0 para sair : 6

13 Digite um n ´u mero para somar ou 0 para sair : 0

14 A soma de todos os n ´u meros digitados ´e 21

Dando continuidade `as estruturas b´asicas, temos no Python uma estrutura muito
interessante quando queremos percorrer os elementos de uma lista (vetor), tal estrutura ´e
o for.

Sua sintaxe ´e a seguinte:

for nome da vari´avel in lista:

comando 1
comando 2
...
comando n

Ele funciona como se fosse um while; enquanto a vari´avel est´a percorrendo os

elementos da lista ele executa o bloco de comandos.

Vejamos um programa usando o for que imprima os cinco primeiros quadrados

perfeitos :

C´odigo 1.30 – Quadrados usando o for

1 for i in [1 ,2 ,3 ,4 ,5]: # a vari ´a vel i assumir ´a os valores de 1 a 5

2

print ( i * * 2)

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

50

3 RESTART :

4 1

5 4

6 9

7 16

8 25

O for ´e muito interessante para lidarmos com listas n´umericas. No entanto, n˜ao ´e

muito pr´atico digitar expl´ıcitamente uma lista como no Programa 1.30.

Para gerar uma lista num´erica vamos usar o comando list(range(n))=[0,1,2,...,n-1].
A Tabela 8 ilustra os comandos b´asicos das listas com range e o C´odigo 1.31 exempliﬁca o
uso de cada um destes comandos.

Tabela 8 – Listas num´ericas com list e range

Comando
list(range(n))
list(range(p,n))
list(range(p,n,k))

Retorna
[0,1,2,...,n-1]
[p,p+1,p+2,...,n-1]
[p,p+k,p+2k,...,p+lk]

com p+lk < n

C´odigo 1.31 – Listas com list e range

1 v_1 = list ( range (10) )

2 v_2 = list ( range (5 ,10) )

3 v_3 = list ( range (1 ,10 ,2) )

4 print ( v_1 , ’\ n ’ ,v_2 , ’\ n ’ , v_3 ) # O \ n serve para pular linha dentro

do print

5 RESTART :

6 [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9]

7 [5 , 6 , 7 , 8 , 9]

8 [1 , 3 , 5 , 7 , 9]

Utilizando o for podemos criar listas mais espec´ıﬁcas, como os primeiros 10 cubos

positivos, como no C´odigo 1.32.

C´odigo 1.32 – Dez primeiros cubos

1 cubos =[]

2 for i in range (1 ,11) : # intervalo de 1 at ´e 10

3

cubos . append ( i * * 3)

4 print ( ’ Os dez primeiros cubos positivos s ~a o : \ n ’ , cubos )

5 RESTART :

6 Os dez primeiros cubos positivos s ~a o :

7 [1 , 8 , 27 , 64 , 125 , 216 , 343 , 512 , 729 , 1000]

1.6. Estruturas b´asicas

51

Encerraremos este cap´ıtulo com o conceito de fun¸c˜oes. O Python j´a possui algumas

fun¸c˜oes pr´e-deﬁnidas, por exemplo len, input, print, dentre outras outras.

A ideia ´e criar outras fun¸c˜oes, cujo processo funcionar´a basicamente da seguinte
forma: deﬁniremos uma fun¸c˜ao de uma ou mais vari´aveis e, dentro da deﬁni¸c˜ao da mesma,
tem-se c´odigos que far˜ao com que a fun¸c˜ao retorne algum valor (podendo ocorrer de criar-se
fun¸c˜oes que n˜ao precisem de parˆametros e/ou n˜ao retornem nada). Sua sintaxe ´e:

def nome da fun¸c˜ao(parametros):

comando 1
comando 2
...
comando n
return express˜ao

Vamos criar uma fun¸c˜ao que retorne a soma de dois n´umeros, conforme C´odigo 1.33.

C´odigo 1.33 – Fun¸c˜ao soma

1 def soma (x , y ) :

2

return x + y

3 print ( soma (10 ,90) )

4 RESTART :

5 100

6 >>> soma (5 ,11) # chamando a fun ¸c ~a o interativamente

7 16

8 >>> soma (1.3 ,2.7)

9 4.0

10 >>> soma ( -1 , -8)

11 -9

Vejamos outra fun¸c˜ao que diz se um dado natural ´e par.

C´odigo 1.34 – Fun¸c˜ao par

1 def epar ( n ) :

2

3

4

5

if n %2==0:

return True

else :

return False

6 RESTART :

7 >>> epar (1)

8 False

9 >>> epar (4)

10 True

52

Cap´ıtulo 1. Uma breve introdu¸c˜ao ao Python

No pr´oximo cap´ıtulo utilizaremos, conforme a necessidade, os comandos aqui apre-
sentados com o intuito de resolver alguns problemas de matem´atica atrav´es de programas
na linguagem Python.

53

Cap´ıtulo 2

Aplica¸c˜oes da Aritm´etica b´asica em
Python

Vamos apresentar neste cap´ıtulo alguns resultados que envolvem n´umeros naturais
(denotado por N), no intuito de implement´a-los com a linguagem Python. Apresentaremos
por exemplo: a divis˜ao euclidiana, o algoritmo de Euclides1, o Crivo de Erat´ostenes, dentre
outros. Tais resultados, apesar de milenares, se mostram como algoritmos bastante eﬁcazes
quando implementados.

2.1 Divis˜ao Euclidiana

Comecemos com a deﬁni¸c˜ao de divisibilidade entre dois n´umeros naturais.

Deﬁni¸c˜ao 2.1 (Divisibilidade). Dados 𝑎,𝑏, ∈ N, com 𝑎 ̸= 0, dizemos que 𝑎 divide 𝑏 se
existir 𝑐 ∈ N tal que 𝑏 = 𝑎 · 𝑐. Denotamos 𝑎 divide 𝑏 por 𝑎|𝑏.

Por exemplo: 5|10 pois existe 2 ∈ N tal que 10 = 5 · 2. Quando 𝑎|𝑏, diz-se que 𝑏 ´e

um m´ultiplo de 𝑎 ou 𝑏 ´e divis´ıvel por 𝑎.

Ocorre que nem sempre 𝑎 dividir´a 𝑏, mas pode-se sempre fazer a divis˜ao de 𝑏 por 𝑎
deixando algum resto, este ´e o conte´udo do teorema a seguir, a Divis˜ao Euclidiana, o qual
Euclides j´a utilizava nos Elementos2.

Antes de enunciar o Teorema da Divis˜ao Euclidiana, vamos assumir como axioma

o Princ´ıpio da Boa Ordem:

Axioma 2.1 (Boa Ordem). Todo subconjunto n˜ao vazio de N possui um menor elemento.

1 Matem´atico grego que viveu por volta de 300 a.C. e escritor da inestim´avel obra Os Elementos
2 Uma das obras mais importantes da matem´atica, composta por 13 livros onde se reunia praticamente

todo conhecimento matem´atico da ´epoca

54

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

Teorema 2.1 (Divis˜ao Euclidiana). Dados 𝑎, 𝑏 ∈ N com 0 < 𝑎 < 𝑏. Existem dois ´unicos
naturais 𝑞 e 𝑟 tais que:

𝑏 = 𝑎𝑞 + 𝑟

com 𝑟 < 𝑎

Demonstra¸c˜ao. Existˆencia: Considere a sequˆencia 𝑆 de n´umeros naturais

𝑆 = (𝑏, 𝑏 − 𝑎, . . . , 𝑏 − 𝑛 · 𝑎, . . .)

Pelo Axioma 2.1 tal sequˆencia n˜ao pode decrescer inﬁnitamente, uma vez que caracteriza
um subconjunto n˜ao vazio de N; logo 𝑆 possuir´a um menor elemento 𝑟, digamos 𝑟 = 𝑏−𝑞 ·𝑎.
Note que se 𝑟 < 𝑎 teremos mostrado a existˆencia de 𝑞 e 𝑟 como est´a no enunciado do
Teorema.

De fato, 𝑟 < 𝑎, pois caso 𝑟 > 𝑎 ter´ıamos 𝑟 − 𝑎 > 0 ∈ 𝑆; isto contraria o fato de 𝑟

ser o m´ınimo de 𝑆. Logo 𝑏 = 𝑎𝑞 + 𝑟 com 𝑟 < 𝑎.

Unicidade: Suponha que existam 𝑟′ e 𝑞′ tais que 𝑏 = 𝑎𝑞′ + 𝑟′ com 𝑟′ < 𝑎. Segue
que 𝑟 ≤ 𝑟′ < 𝑎 e 0 ≤ 𝑟′ − 𝑟 < 𝑎. Da igualdade 0 = 𝑏 − 𝑏 = 𝑎𝑞′ + 𝑟′ − (𝑎𝑞 + 𝑟) temos
que (𝑞 − 𝑞′)𝑎 = 𝑟′ − 𝑟 =⇒ 𝑎|𝑟′ − 𝑟 =⇒ 𝑟′ − 𝑟 = 0 j´a que 𝑎 > 𝑟′ − 𝑟. Portanto 𝑟′ = 𝑟 e
consequentemente 𝑞′ = 𝑞.

Por exemplo:

Caso 𝑏 = 37 e 𝑎 = 7 temos 𝑞 = 5 e 𝑟 = 2, pois 37 = 7 · 5 + 2;

Caso 𝑏 = 89 e 𝑎 = 13 temos 𝑞 = 6 e 𝑟 = 11, pois 89 = 13 · 6 + 11.

Observemos que a demonstra¸c˜ao acima nos fornece um algoritmo para dividir dois
n´umeros naturais, vejamos a implementa¸c˜ao de um programa em Python que nos retorne
o quociente e o resto da divis˜ao de dois naturais fornecidos pelo usu´ario.

C´odigo 2.1 – Divis˜ao Euclidiana

1 b = int ( input ( " digite o valor de b : " ) )

2 a = int ( input ( " digite o valor de a : " ) )

3 q , r =0 ,0 # q e r s ~a o quociente e resto respectivamente

4 if b >= a :

5

6

7

8

while b - q *a >= a :

q = q +1

r =b - q * a

print ( " Na divis ~a o de % d por %d , temos quociente % d e resto

% d " %( b ,a ,q , r ) )

9 else :

10

print ( " Na divis ~a o de % d por %d , temos quociente % d e resto

% d " %( b ,a ,q , b ) )

11 RESTART :

2.2. Bases num´ericas

55

12 digite o valor de b : 37

13 digite o valor de a : 7

14 Na divis ~a o de 37 por 7 , temos quociente 5 e resto 2

Alternativamente poder´ıamos calcular o quociente e o resto atrav´es das opera¸c˜oes

// e %, como no programa abaixo:

C´odigo 2.2 – Divis˜ao Euclidiana com opera¸c˜oes

1 b = int ( input ( ’ Digite o valor de b : ’) )

2 a = int ( input ( ’ Digite o valor de a : ’) )

3 q = b // a

4 r = b % a

5 print ( ’ Na divis ~a o de % d por %d , temos quociente % d e resto

% d ’ %( b ,a ,q , r ) )

6 RESTART :

7 Digite o valor de b : 46

8 Digite o valor de a : 7

9 Na divis ~a o de 46 por 7 , temos quociente 6 e resto 4

Contudo, como pretende-se fazer uma conex˜ao entre as demonstra¸c˜oes dos resultados
e sua implementa¸c˜ao, acreditamos que, didaticamente, o C´odigo 2.1 ´e mais interessante.

2.2 Bases num´ericas

V´arias civiliza¸c˜oes criaram maneiras de organizar a forma como representariam suas
quantidades para atender diversas demandas. Tais maneiras s˜ao conhecidas como sistemas
de numera¸c˜ao, dentre os quais podemos citar: Romano, Maia, Eg´ıpcio, dentre outros.
Atualmente o sistema universalmente utilizado para representar n´umeros ´e o decimal
posicional.

Esse sistema de numera¸c˜ao que ´e uma variante do sistema sexagesimal
utilizado pelos babilˆonios 1700 anos antes de Cristo, foi desenvolvido
na China e na ´India. Existem documentos do s´eculo VI comprovando a
utiliza¸c˜ao desse sistema. Posteriormente, foi se espalhando pelo Oriente
M´edio, por meio das caravanas, tendo encontrado grande aceita¸c˜ao entre
os povos ´arabes. A introdu¸c˜ao do sistema decimal na Europa foi tardia
por causa dos preconceitos da Idade M´edia. Por exemplo, num documento
de 1299, os banqueiros de Floren¸ca condenavam seu uso. (SIDKI, 1975,
p.7)

No sistema decimal todo n´umero ´e formado por uma sequˆencia dos algarismos:

0, 1, 2, 3, 4, 5, 6, 7, 8, 9

Como s˜ao dez algarismos da´ı o nome decimal (base 10), posicional pois a posi¸c˜ao do
algarismo na sequˆencia que forma o n´umero lhe atribui um peso (potˆencia de 10) diferente.

56

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

Por exemplo, 23 = 2 · 101 + 3 · 100 e 32 = 3 · 101 + 2 · 100; portanto, a posi¸c˜ao em que os
n´umeros 2 e 3 se apresentam ´e importante.

De uma maneira geral, o n´umero 𝑏𝑛 𝑏𝑛−1 . . . 𝑏2 𝑏1 𝑏0 no sistema decimal ´e o mesmo

que 𝑏𝑛 · 10𝑛 + 𝑏𝑛−1 · 10𝑛−1 + . . . + 𝑏2 · 102 + 𝑏1 · 101 + 𝑏0 · 100 com 𝑛 ∈ N e 0 ≤ 𝑏𝑖 ≤ 9.

Outro sistema que conv´em destacar ´e o bin´ario (base 2) usado na computa¸c˜ao.

Futuramente, exempliﬁcaremos tal sistema.

Tanto o sistema decimal quanto o bin´ario s˜ao posicionais e de base constante. Na
verdade, dados dois n´umeros 𝑎 e 𝑏 > 1 arbitr´arios podemos sempre escrever 𝑎 na base 𝑏. O
modo de fazˆe-lo se baseia no Teorema da Mudan¸ca de Base que ´e uma aplica¸c˜ao da divis˜ao
euclidiana. Contudo, para prov´a-lo, iremos fazer uso do Segundo Princ´ıpio de Indu¸c˜ao que
ser´a demonstrado abaixo.

Teorema 2.2 (Segundo Princ´ıpio de Indu¸c˜ao). Sejam 𝑃 (𝑛) uma propriedade referente
a n´umeros naturais, 𝑛 ∈ N, e 𝑎 um n´umero natural. Se 𝑃 (𝑎) ´e verdadeira e, se para
𝑎 ≤ 𝑘 < 𝑛, a validade de 𝑃 (𝑘) implicar a veracidade de 𝑃 (𝑛), ent˜ao 𝑃 (𝑛) ser´a verdadeira
para todo natural 𝑛 ≥ 𝑎.

Demonstra¸c˜ao. Considere o conjunto 𝑉 = {𝑛 ∈ N; 𝑃 (𝑛) verdadeira} queremos provar que
𝑉 = N. Suponha por absurdo que 𝑉 ̸= N, da´ı N∖𝑉 ̸= ∅. Logo, pelo Axioma 2.1 existe o
menor elemento 𝑘 ∈ N∖𝑉 , ou seja 𝑘 ´e o menor natural para o qual n˜ao vale 𝑃 , o que quer
dizer que 𝑃 vale para todos os naturais menores que 𝑘 implicando 𝑃 (𝑘) ser verdadeira, o
que ´e um absurdo. Portanto 𝑉 = N.

Agora temos condi¸c˜oes de demonstrar o Teorema da Mudan¸ca de Base.

Teorema 2.3 (Mudan¸ca de Base). Dados a, b ∈ N, com b > 1, existem n´umeros naturais
𝑐0, 𝑐1,. . . ,𝑐𝑛 menores do que b, univocamente determinados, tais que a = 𝑐0 + 𝑐1𝑏 + 𝑐2𝑏2 +
. . . + 𝑐𝑛𝑏𝑛.

Demonstra¸c˜ao. A demonstra¸c˜ao ser´a por indu¸c˜ao em 𝑎. Note que, se 𝑎 = 0, basta tomar
𝑐𝑖 = 0, 0 ≤ 𝑖 ≤ 𝑛. Nossa hip´otese de indu¸c˜ao ´e que todo natural menor do que 𝑎 tem
representa¸c˜ao 𝑑0 + 𝑑1𝑏 + 𝑑2𝑏2 + . . . + 𝑑𝑘𝑏𝑘 em que 𝑘 e cada 𝑑𝑖 s˜ao naturais e cada 𝑑𝑖 < 𝑏 ´e
´unico.

Aplicando a divis˜ao euclidiana para 𝑎 e 𝑏 temos que 𝑎 = 𝑏𝑞 + 𝑟 com 𝑟 < 𝑏
com 𝑞 e 𝑟 ´unicos. Como 𝑞 < 𝑎, logo 𝑞 = 𝑑0 + 𝑑1𝑏 + 𝑑2𝑏2 + . . . + 𝑑𝑘𝑏𝑘 donde segue que
𝑎 = 𝑟 + 𝑑0𝑏 + 𝑑1𝑏2 + 𝑑2𝑏3 + . . . + 𝑑𝑘𝑏𝑘+1. Da´ı basta tomar 𝑛 = 𝑘 + 1, 𝑐0 = 𝑟 e 𝑐𝑖 = 𝑑𝑖−1
com 1 ≤ 𝑖 ≤ 𝑛 e esta forma de representar 𝑎 ´e ´unica pois herda a unicidade dos n´umeros
𝑑𝑖 e 𝑟.

2.2. Bases num´ericas

57

Os n´umeros 𝑐0, 𝑐1𝑏, 𝑐2, . . . + 𝑑𝑛 s˜ao ditos os “d´ıgitos” de 𝑎 na base 𝑏, comumente

representados na forma 𝑎 = (𝑐𝑛𝑐𝑛−1 . . . 𝑐0)𝑏.

A demonstra¸c˜ao do Teorema 2.3 acima nos fornece um algoritmo para passar um

n´umero 𝑎 para a base 𝑏, basta aplicar a divis˜ao euclidiana como segue:

𝑎 = 𝑏𝑞0 + 𝑟0, 𝑟0 < 𝑏,

𝑞0 = 𝑏𝑞1 + 𝑟1, 𝑟1 < 𝑏,

𝑞1 = 𝑏𝑞2 + 𝑟2, 𝑟2 < 𝑏,

...

Como 𝑎 > 𝑞0 > 𝑞1 > . . . > 𝑞𝑖, 𝑖 ∈ N, em algum momento ter-se-´a 𝑞𝑛−1 < 𝑏 para algum 𝑛.
Portanto, de

𝑞𝑛−1 = 𝑏𝑞𝑛 + 𝑟𝑛,

segue que 𝑞𝑛 = 0 =⇒ 0 = 𝑞𝑗 para todo 𝑗 ≥ 𝑛. Da´ı tem-se, 0 = 𝑟𝑘 para todo 𝑘 ≥ 𝑛 + 1.
Finalmente, temos que

𝑎 = 𝑟0 + 𝑟1𝑏1 + . . . + 𝑟𝑛𝑏𝑛

Como exemplo vamos passar o 13 para a base bin´aria:

Donde

13 = 2 · 6 + 1

6 = 2 · 3 + 0

3 = 2 · 1 + 1

1 = 2 · 0 + 1

13 = 2(2 · 3 + 0) + 1

13 = 22 · 3 + 0 · 21 + 1 · 20

13 = 22 · (2 · 1 + 1) + 0 · 21 + 1 · 20

13 = 23 · 1 + 1 · 22 + 0 · 21 + 1 · 20
∴ 13 = (1101)2

Vejamos um m´etodo mais pr´atico, ilustrado pela maneira tradicional de se repre-
sentar a divis˜ao, para converter da base 10 para base 2. Transformaremos 13 em bin´ario

58

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

13

1

2

6

0

2

3

1

2

1

novamente:

Portanto pelo m´etodo das divi-
s˜oes sucessivas
Temos que o 13 na base bin´a-
ria ´e 1101, representamos assim
13 = (1101)2 .

Para outro n´umero qualquer, basta repertimos o processo descrito acima, at´e o
quociente chegar ao valor 1, da´ı teremos a representa¸c˜ao bin´aria do referido n´umero que
ser´a a concatena¸c˜ao do ´ultimo quociente com os restos das divis˜oes anteriores (indo do
´ultimo at´e o primeiro, como indica a seta na ﬁgura acima). A tarefa agora ´e transformar
esse algoritmo num programa em Python.

Observe que os quocientes v˜ao mudando de valor, sempre a parte inteira da metade
do valor anterior; isto acontece at´e o ´ultimo quociente ter valor 1 (isso sugere o uso de um
while [enquanto]). Em cada passo temos que armazenar os respectivos restos (isso sugere
o uso de uma lista ou uma string vazia), onde o ´ultimo valor dessa lista ser´a o ´ultimo
quociente, depois basta imprimir a lista na ordem inversa. Vamos ao Programa 2.3:

1 n = int ( input ( ’ Digite o n ´u mero a ser convertido pra bin ´a rio : ’) )

C´odigo 2.3 – Convers˜ao bin´aria

2 base = " "

3 q = n

4 while n >= 2:

5

6

7

8

base = base + str ( n %2)

n = n // 2

if n == 1:

base = base + str ( n )

9 print ( ’O % d na base 2 ´e ’%q , base [:: -1])

10 RESTART :

11 Digite o n ´u mero a ser convertido pra bin ´a rio : 13

12 O 13 na base 2 ´e

1101

Escolhemos a base 2 pois os computadores trabalham utilizando a base bin´aria, mas
podemos escrever um n´umero natural 𝑛 para qualquer base 𝑏 (𝑏 > 1) como prova o
Teorema 2.3. Por exemplo vamos passar o n´umero 𝑛 = 1245 para a base 𝑏 = 3.

2.2. Bases num´ericas

59

1245

3

0

415

3

1

138

3

0

46

3

1

15

0

3

5

2

3

1

Portanto pelo m´etodo das divi-
s˜oes sucessivas
Temos que o 1245 na base 3 ´e
1201010, representamos assim
1245 = (1201010)3 .

Vejamos como implementar um programa em Python que forne¸ca a mudan¸ca de
base, onde ser˜ao solicitados o n´umero 𝑛 e a base 𝑏 para a qual se deseja fazer a convers˜ao.
A ideia ´e dividir o n´umero 𝑛 sucessivas vezes pela base 𝑏, bem semelhante ao que foi feito
para a base 2.

C´odigo 2.4 – Convers˜ao para base b

1 b = int ( input ( ’ Digite a base para a qual quer converter : ’) )

2 n = int ( input ( ’ Digite o n ´u mero que quer converter : ’) )

3 k = n

4 base =[]

5 while n >= b :

6

7

base . append ( n % b )

n = n // b

8 if n <= b -1:

9

base . append ( n )

10 print ( ’% d na base % d ´e ’ %( k , b ) , base [:: -1])

11 RESTART :

12 Digite a base para a qual quer converter : 3

13 Digite o n ´u mero que quer converter : 1245

14 1245 na base 3 ´e [1 , 2 , 0 , 1 , 0 , 1 , 0]

15 >>>

16 Digite a base para a qual quer converter : 17

17 Digite o n ´u mero que quer converter : 810

18 810 na base 17 ´e [2 , 13 , 11]

No Programa 2.4 optou-se por apresentar a resposta em um vetor, para que quando
a base for maior que 10, n˜ao haja confus˜ao. Assim deve-se interpretar 810 = [2, 13, 11] =
(2, 13, 11)17 = 2 · 172 + 13 · 171 + 11 · 170.

Claramente, dado um n´umero (𝛼𝑛𝛼𝑛−1 . . . 𝛼0)𝑏 numa base qualquer 𝑏, com 𝛼𝑖 < 𝑏

60

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

com 𝑖 ∈ {0, 1, . . . , 𝑛} podemos convertˆe-lo para base 10 efetuando o c´alculo:

𝛼𝑛𝑏𝑛 + 𝛼𝑛−1𝑏𝑛−1 + . . . + 𝛼0𝑏0

Por exemplo, (2014)5 = [2, 0, 1, 4]5 ´e 259, pois 2 · 53 + 0 · 52 + 1 · 51 + 4 · 50 = 259
O Programa 2.5 efetua tal convers˜ao.

C´odigo 2.5 – Convers˜ao da base b para base 10

1 b = int ( input ( " Forneca a base : " ) )

2 n = []

3 x , i = 1 ,0

4 a , N = 0 , 0

5 while True :

6

7

8

9

a = int ( input ( " Digite o % d algarismo ou um valor >= % d para

sair : " %( x , b ) ) )

if a >= b :

break

n . append ( a )

10

x += 1

11 while i <= len ( n ) -1:

12

13

N += n [ i ] * b * * (( len ( n ) -1 - i ) )

i +=1

14 print ( " O n ´u mero " ,n , ’( base % d ) ´e % d na base dez ’ %( b , N ) )

15 RESTART :

16 Forneca a base : 17

17 Digite o 1 algarismo ou um valor >= 17 para sair : 2

18 Digite o 2 algarismo ou um valor >= 17 para sair : 1

19 Digite o 3 algarismo ou um valor >= 17 para sair : 3

20 Digite o 4 algarismo ou um valor >= 17 para sair : 1

21 Digite o 5 algarismo ou um valor >= 17 para sair : 1

22 Digite o 6 algarismo ou um valor >= 17 para sair : 20

23 O n ´u mero [2 , 1 , 3 , 1 , 1] ( base 17) ´e 172840 na base dez

2.3 Um pouco mais de aritm´etica

Nesta se¸c˜ao abordaremos mais alguns teoremas e problemas relacionados aos
n´umeros naturais, e como a linguagem de programa¸c˜ao Python se apresenta como um
bom recurso did´atico na compreens˜ao e aplica¸c˜ao dos resultados que seguem.

Comecemos tratando do c´alculo do m´aximo divisor comum entre dois n´umeros, um
cl´assico dentre os algoritmos. Logo ap´os, apresentamos alguns resultados sobre n´umeros
primos.

2.3. Um pouco mais de aritm´etica

61

2.3.1 M´aximo Divisor Comum

Dados dois naturais 𝑎 e 𝑏 ambos n˜ao nulos, diremos que 𝑑 ´e um divisor comum de

𝑎 e 𝑏 se 𝑑|𝑎 e 𝑑|𝑏.

Por exemplo, 3 ´e divisor comum de 15 e 27.

Deﬁni¸c˜ao 2.2. Diremos que 𝑑 ´e o m´aximo divisor comum de 𝑎 e 𝑏 se:

i) 𝑑 ´e um divisor comum de 𝑎 e 𝑏;

ii) Se 𝑐 ´e um divisor comum de 𝑎 e 𝑏, ent˜ao 𝑐|𝑑.

Denotaremos o mdc de 𝑎 e 𝑏 por mdc(𝑎,𝑏).

Seguem alguns exemplos e propriedades. Nos itens que seguem 𝑎 e 𝑏 s˜ao naturais

diferentes de zero.

∙ mdc(2,4)=2;

∙ mdc(1,𝑎)=1 e mdc(𝑎,𝑎)=𝑎;

∙ mdc(𝑎,𝑏)=𝑎 ⇐⇒ 𝑎|𝑏;

∙ mdc(𝑎,𝑏)=mdc(𝑏,𝑎).

O mdc(𝑎,𝑏) quando existe ´e ´unico. De fato, seja 𝑑 =mdc(𝑎, 𝑏), suponhamos que
exista outro 𝑑′ =mdc(𝑎,𝑏) assim ter´ıamos que 𝑑 ≤ 𝑑′ e 𝑑′ ≤ 𝑑, pelo Item ii da Deﬁni¸c˜ao
2.2. Conclui-se assim que 𝑑 = 𝑑′.

Outro fato de extrema relevˆancia ´e que sempre existe o mdc(𝑎,𝑏) entre dois naturais
𝑎 e 𝑏 n˜ao nulos. Para veriﬁcar tal propriedade, basta tomar o maior elemento comum nos
conjuntos dos divisores de 𝑎 e 𝑏; tal elemento ´e o mdc(𝑎,𝑏) e ser´a no m´ınimo 1, pois 1
divide qualquer n´umero.

Quando o mdc(𝑎,𝑏)=1, 𝑎 e 𝑏 s˜ao ditos primos entre si.

A seguir vejamos um m´etodo que mostra como encontrar o mdc(𝑎,𝑏). Tal m´etodo ´e
conhecido por Algoritmo de Euclides. Mas antes precisamos de um resultado preliminar
que ser´a apresentado como um problema:

Problema 2.1. Dados 𝑎,𝑏, 𝑛 ∈ N n˜ao nulos, com 𝑎 ≤ 𝑛𝑎 ≤ 𝑏, ent˜ao mdc(𝑎,𝑏)=mdc(𝑎,𝑏 −
𝑛𝑎)

Solu¸c˜ao: Seja 𝑑 = mdc(𝑎,𝑏), pelo fato de 𝑑|𝑎 e 𝑑|𝑏 tem-se que 𝑑|𝑏 − 𝑛𝑎. Seja
𝑑′ = mdc(𝑎,𝑏 − 𝑛𝑎), tem-se que 𝑑′|𝑎 e 𝑑′|𝑏 − 𝑛𝑎 logo 𝑑′|𝑏 − 𝑛𝑎 + 𝑛𝑎, isto ´e, 𝑑′|𝑏, portanto
(cid:4)
𝑑 = 𝑑′.

62

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

Dados 𝑎, 𝑏 ∈ N n˜ao nulos, com 𝑎 ≤ 𝑏, o procedimento abaixo ´e o Algoritmo de
Euclides. Tal algortimo ´e utilizado para se calcular o m´aximo divisor comum entre dois
n´umeros.

Algoritmo de Euclides:

Caso: 𝑎 = 1 ou 𝑎 = 𝑏 ou 𝑎|𝑏 teremos que mdc(𝑎,𝑏)=𝑎.

Caso: 𝑎 (cid:45) 𝑏 pela divis˜ao euclidiana temos:

𝑏 = 𝑎𝑞1 + 𝑟1

com 𝑟1 < 𝑎

Se 𝑟1|𝑎 temos que 𝑟1 = mdc(𝑎,𝑟1) = mdc(𝑎,𝑏 − 𝑎𝑞1) = mdc(𝑎,𝑏)

E se 𝑟1 (cid:45) 𝑎 pela divis˜ao euclidiana temos:

𝑎 = 𝑟1𝑞2 + 𝑟2

com 𝑟2 < 𝑟1

Se 𝑟2|𝑟1 temos que 𝑟2 = mdc(𝑟1,𝑟2) = mdc(𝑟1,𝑎 − 𝑟1𝑞2) = mdc(𝑟1,𝑎) = mdc(𝑏 − 𝑎𝑞1,𝑎) =
mdc(𝑏,𝑎) = mdc(𝑎,𝑏)

E se 𝑟2 (cid:45) 𝑟1, aplicamos a divis˜ao euclidiana novamente

𝑟1 = 𝑟2𝑞3 + 𝑟3

com 𝑟3 < 𝑟2.

Repetindo este procedimento, teremos uma sequˆencia de restos decrescente, desta foram,
em algum momento tal processo ter´a que parar devido ao Axioma 2.1, uma vez que o
conjunto formado pelos restos dessas divis˜oes ´e limitado inferiormente pelo zero. Ent˜ao
existir´a algum 𝑛 ∈ N com 𝑟𝑛|𝑟𝑛−1, portanto temos que 𝑟𝑛 = mdc(𝑎,𝑏).

O Algoritmo de Euclides se apresenta de uma maneira mais pr´atica atrav´es do

dispositivo abaixo, conhecido como jogo da velha.

𝑞1
𝑎

𝑏
𝑟1

𝑞2
𝑟1

𝑞1
𝑎
𝑟2

𝑏
𝑟1

𝑞1
𝑎
𝑟2

𝑞2
𝑟1
𝑟3

𝑞𝑛−1
. . .
. . . 𝑟𝑛−2
𝑟𝑛
. . .

𝑏
𝑟1

𝑞𝑛
𝑟𝑛−1

𝑞𝑛+1
𝑟𝑛 = mdc(𝑎, 𝑏)

Exempliﬁcando vamos calcular o mdc(255, 221)

1

6

2

255 221 34 17

34

17

Logo mdc(255, 221) = 17

Nosso objetivo agora ´e fazer um programa que calcule o mdc de dois n´umeros

fornecidos pelo usu´ario.

2.3. Um pouco mais de aritm´etica

63

Para isso, basta notar que o mdc entre os dois n´umeros ´e o resto 𝑟𝑛 que divide o
resto 𝑟𝑛−1 para algum 𝑛. Conv´em notar que as divis˜oes come¸cam por 𝑏 e 𝑎 e depois 𝑎 por
𝑟1 e a assim sucessivamente, sugerindo o uso de um while at´e haver divis˜ao exata.

C´odigo 2.6 – mdc(𝑎, 𝑏)

1 a = int ( input ( " Digite o primeiro n ´u mero : " ) )

2 b = int ( input ( " Digite o segundo n ´u mero : " ) )

3 x , y =a , b

4 while b % a != 0:

5

a , b = b %a , a

6 print ( " mdc (% d ,% d ) = % d " %( x ,y , a ) )

7 RESTART :

8 Digite o primeiro n ´u mero : 255

9 Digite o segundo n ´u mero : 221

10 mdc (255 ,221) = 17

Apenas para ilustrar, segue o c´odigo abaixo com a fun¸c˜ao mdc

C´odigo 2.7 – Fun¸c˜ao mdc(𝑎, 𝑏)

1 def mdc (a , b ) :

2

3

4

while b % a !=0:

b , a =a , b % a

return a

5 >>> # O Python j ´a reconheceu a nova fun ¸c ~a o mdc

6 >>> # basta cham ´a -la , como segue os exemplos

7 >>> mdc (255 ,221)

8 17

9 >>> mdc (54 ,16)

10 2

2.3.2 Primos

Antes do primeiro problema, vamos deﬁnir n´umero primo.

Deﬁni¸c˜ao 2.3. Um n´umero natural 𝑝 > 1 ´e dito primo se ´e divis´ıvel apenas por 1 e por
si mesmo.

Observa¸c˜ao: Quando 𝑛 n˜ao for primo, dizemos que 𝑛 ´e composto.

Problema 2.2. Dado 𝑛 ∈ N com 𝑛 > 1 como decidir se 𝑛 ´e primo ou composto?

Solu¸c˜ao: Caso 𝑛 = 2 ser´a primo por deﬁni¸c˜ao, caso contr´ario basta dividir 𝑛
por cada 𝑑 ∈ {2, 3, . . . , 𝑛 − 1}. Se ocorrer de alguma divis˜ao ser exata para algum 𝑑, isto ´e,

64

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

deixar resto zero pode-se parar o processo pois 𝑛 ser´a composto apresentando no m´ınimo
(cid:4)
trˆes divisores: 1, 𝑑 e 𝑛. Caso contr´ario 𝑛 ser´a primo.

Agora vamos fazer um programa que nos forne¸ca a informa¸c˜ao se dado 𝑛 > 1
natural ´e primo ou n˜ao. Observe que durante a solu¸c˜ao apresentada temos dois conceitos
l´ogicos que s˜ao traduzidos por duas palavras reservadas do Python (for e if ). O uso do
for de d´a, pois vamos fazer divis˜oes partindo do 2 at´e o antecessor do n´umero fornecido,
enquanto que o if se mostra ´util, pois analisamos inicialmente se o numero fornecido ´e 2
e depois dentro do for analisamos os restos das divis˜oes. Isto posto vejamos o programa
abaixo:

1 n = int ( input ( ’ Digite um n ´u mero natural maior que 1: ’) )

C´odigo 2.8 – Teste de primalidade

2 if n ==2:

3

print ( ’% d ´e primo ’% n )

4 else :

5

6

7

8

9

10

11

for d in range (2 , n ) :

if n % d ==0 and d != n -1:

print ( ’% d n ~a o ´e primo ’% n )

break

else :

if d == n -1:

print ( ’% d ´e primo ’% n )

12 RESTART :

13 Digite um n ´u mero natural maior que 1: 7493

14 7493 n ~a o ´e primo

15 >>>

16 RESTART :

17 Digite um n ´u mero natural maior que 1: 18446744073709551617

18 18446744073709551617 n ~a o ´e primo

Sabemos que dado 𝑛 ∈ N, temos que 𝑛 ´e primo ou 𝑛 ´e composto. Um fato de
extrema relevˆancia ´e que caso 𝑛 seja composto, existem primos que quando multiplicados
reproduzem 𝑛, ou seja, existem primos que comp˜oem 𝑛. Tal aﬁrma¸c˜ao ´e o conte´udo do
pr´oximo teorema.

Teorema 2.4 (Teorema Fundamental da Aritm´etica). Seja 𝑛 ∈ N, 𝑛 > 1. Ent˜ao 𝑛 se
escreve de modo ´unico (a menos da ordem dos fatores) como produto de primos.

Demonstra¸c˜ao. Usaremos o Segundo Princ´ıpio de Indu¸c˜ao sobre 𝑛. O resultado ´e v´alido
para 𝑛 = 2. Suponha o resultado v´alido para cada natural 2 ≤ 𝑘 < 𝑛. Se 𝑛 for primo o
resultado ´e claramente v´alido. Caso 𝑛 seja composto, existem 𝑛1 e 𝑛2, ambos menores

2.3. Um pouco mais de aritm´etica

65

que, 𝑛 com 𝑛 = 𝑛1𝑛2. Pela hip´otese de indu¸c˜ao 𝑛1 = 𝑝1𝑝2 . . . 𝑝𝑟 e 𝑛2 = 𝑞1𝑞2 . . . 𝑞𝑠 logo
𝑛 = 𝑝1 . . . 𝑝𝑟𝑞1 . . . 𝑞𝑠.

Agora vamos provar a unicidade. Suponha que 𝑛 = 𝑝1𝑝2 . . . 𝑝𝑟 = 𝑞1𝑞2 . . . 𝑞𝑠 com 𝑝𝑖,
1 ≤ 𝑖 ≤ 𝑟, e 𝑞𝑗, 1 ≤ 𝑗 ≤ 𝑠, primos. Temos ent˜ao que algum 𝑝𝑖|𝑞1𝑞2 . . . 𝑞𝑠, o que implica
𝑝𝑖 = 𝑞𝑗; reordenando os primos na decomposi¸c˜ao de 𝑛 podemos supor que sejam 𝑝1 = 𝑞1.
Assim teremos 𝑝2 . . . 𝑝𝑛 = 𝑞2 . . . 𝑞𝑠 assim teremos, por hip´otese de indu¸c˜ao, que 𝑟 = 𝑠 uma
vez que 𝑞2 . . . 𝑞𝑠 < 𝑛. Portanto teremos 𝑝𝑖 = 𝑞𝑗, 2 ≤ 𝑖, 𝑗 ≤ 𝑟.

Para exempliﬁcar, vejamos a decomposi¸c˜ao em fatores primos de alguns n´umero:

6 = 2 · 3 = 2 × 3; 15 = 3 · 5; 18 = 2 · 3 · 3 = 2 · 32.

Uma maneria pr´atica na qual um n´umero ´e decomposto se apresenta no m´etodo

abaixo:

𝑛
𝑝1
𝑝2
𝑛1
𝑛2
𝑝3
...
...
𝑛𝑟−1 𝑝𝑟

1

6 2
3 3
1

15 3
5
5
1

18 2
3
9
3
3
1

Se 𝑛 = 𝑛0, cada 𝑛𝑖 ´e o quociente de 𝑛𝑖−1 por 𝑝𝑖 com 𝑖 = 1, 2, . . . , 𝑟, e o n´umero 𝑝𝑖
corresponde ao menor primo que divide 𝑛𝑖−1. Tal processo acaba quando o quociente da
divis˜ao de 𝑛𝑟−1 por 𝑝𝑟 ´e 1. Assim, a forma fatorada de 𝑛 em primos ser´a 𝑛 = 𝑝1𝑝2 . . . 𝑝𝑟.

Observa¸c˜ao: Forma fatorada e decomposi¸c˜ao em primos s˜ao sinˆonimos.

Esse m´etodo por si s´o j´a estrutura um programa que, dado 𝑛, nos retorne a forma

fatorada de 𝑛.

Quando tem-se fatores repetidos na decomposi¸c˜ao de 𝑛, diremos que tal fator tem
multiplicidade igual ao n´umero de vezes em que aparece na fatora¸c˜ao. Por exemplo em
18 = 2 · 3 · 3 dizemos que 3 tem multiplicidade 2.

Assim a fatora¸c˜ao de 𝑛 de forma geral ´e 𝑛 = 𝑝𝑟1

1 𝑝𝑟2

2 . . . 𝑝𝑟𝑘

𝑘 com 𝑟𝑖 > 0 com

𝑖 = 1, . . . , 𝑘.

O Programa 2.9 exibe os fatores (e suas multiplicidades) de um n´umero 𝑛 em um

vetor.

1 n = int ( input ( ’ Entre com o n ´u mero : ’) )

C´odigo 2.9 – Decomposi¸c˜ao de 𝑛

2 fatores = []

3 d = 2

4 while n > 1:

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

66

5

6

7

8

9

if n % d == 0:

n = n / d

fatores . append ( d )

else :

d += 1

10 print ( fatores ) # esse ´e o vetor com todos os fatores de n

11 RESTART :

12 Entre com o n ´u mero : 18

13 [2 , 3 , 3]

14 >>>

15 RESTART :

16 Entre com o n ´u mero : 7493

17 [59 , 127]

De posse do Teorema 2.4 vamos apresentar outro teste de primalidade devido a
Erat´ostenes3. Tal m´etodo ´e melhor que o mostrado no Problema 2.2, no entanto tamb´em ´e
lento. Outros testes de primalidade podem ser encontrados em (MOREIRA; SALDANHA,
2011).

Teorema 2.5. Seja 𝑛 ∈ N, com 𝑛 > 1. Se nenhum 𝑝 primo com 𝑝 ≤
𝑛 ´e primo.

√

𝑛 divide 𝑛, ent˜ao

Demonstra¸c˜ao. Iremos demonstrar utilizando a contra-positiva, ou seja, mostraremos que
𝑛 que divide 𝑛. Seja 𝑛 um n´umero
se 𝑛 ´e composto ent˜ao existe 𝑝 primo com 𝑝 ≤
composto. Suponha, por contradi¸c˜ao, que 𝑡 ´e o menor primo que divide 𝑛 e 𝑡 >
𝑛. Pelo
Teorema Fundamental da Aritm´etica 2.4 temos que ter, no m´ınimo, outro primo 𝑡1 que
𝑛, de onde, 𝑛 = 𝑡 · 𝑡1 > 𝑛, absurdo.
divide 𝑛. Ent˜ao 𝑡1 ≥ 𝑡 >

√

√

√

Exempliﬁcando, considere 𝑛 = 71. Como ⌊

71⌋ = 8, em que ⌊𝑥⌋ ´e o maior inteiro
menor do que ou igual a 𝑥, com 𝑥 ∈ R, para testar se 71 ´e primo, basta dividir este n´umero
apenas pelos primos entre 2 e 8.

√

O Programa 2.10, mostra este teste de primalidade. Neste programa ﬁzemos as

divis˜oes de 𝑛 por n´umeros de 2 at´e ⌊

𝑛⌋, usando o while e if .

√

C´odigo 2.10 – Teste de primalidade (Erat´ostenes)

1 n = int ( input ( " Digite um n ´u mero > 1 , que vamos testar se ´e primo :

" ) )

2 p = int ( n * * 0.5)

3 while p >= 1: # Temos que testar p =1 , por causa das ra ´ı zes de 2 e

3

3 Matem´atico grego que viveu por volta dos anos 230 a.C

2.3. Um pouco mais de aritm´etica

67

4

5

6

7

8

9

if n % p == 0 and p !=1:

print ( ’ O n ´u mero % d n ~a o ´e primo . ’ % n )

break

if p == 1:

print ( ’O n ´u mero % d ´e primo . ’ % n )

p = p - 1

10 RESTART :

11 Digite um n ´u mero > 1 , que vamos testar se ´e primo : 4294967297

12 O n ´u mero 4294967297 n ~a o ´e primo .

O Programa 2.11 ´e uma adapta¸c˜ao do Programa 2.10, no qual foi criada uma

fun¸c˜ao que retorna True se um dado 𝑛 natural ´e primo e False, caso contr´ario.

C´odigo 2.11 – Fun¸c˜ao ehprimo

1 def ehprimo ( n ) :

2

3

4

5

6

7

8

9

p = int ( n * * 0.5)

while p >= 1:

if n % p == 0 and p !=1:

return False

break

if p == 1:

return True

p = p - 1

10 RESTART :

11 >>> ehprimo (111)

12 False

13 >>> ehprimo (65537)

14 True

De modo geral n˜ao ´e simples determinar a primalidade ou n˜ao de um n´umero
natural grande sem ferramentas computacionais. Podemos ilustar tal aﬁrma¸c˜ao resgatando
um epis´odio envolvendo dois grandes matem´aticos, que s˜ao Fermat4 e Euler5, conforme
apresentado em (LEITE, 1985; HEFEZ, 2011; PENHA, 1983).

Fermat em uma carta enviada a seu amigo Bernard Frenide de Bessy em 1640
aﬁrmava crer que os n´umeros da forma 𝐹𝑛 = 22𝑛 + 1 (n´umeros de Fermat ou primos de
Fermat) fossem primos para todo natural 𝑛.

Vejamos alguns valores de 𝐹𝑛:

𝐹0 = 220 +1 = 2+1 = 3, 𝐹1 = 221 +1 = 4+1 = 5, 𝐹3 = 223 +1 = 256+1 = 257
4 Pierre de Fermat (1601-1665) matem´atico francˆes do s´ec. XVII; deu v´arias contribui¸c˜oes em Teoria dos

N´umeros

5 Leonhard Euler (1707-1783) matem´atico su´ı¸co, ﬁgura entre os maiores e mais produtivos matem´aticos

de todos os tempos.

68

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

𝐹4 = 224 + 1 = 65537 que s˜ao de fato primos.

J´a 𝐹5 = 225+1 = 4294967297 n˜ao foi veriﬁcado ser primo por Fermat, provavelmente
por ser muito grande. No entanto Euler, quase 100 anos depois, em 1732 mostrou que 𝐹5 ´e
composto com um fator igual a 641. De fato tem-se que 𝐹5 = 4294967297 = 641 × 6700417.
Maiores detalhes de como Euler conseguiu fatorar 𝐹5 podem ser encontrado em em
(PENHA, 1983).

Podemos veriﬁcar a n˜ao primalidade de 𝐹5 e sua fatora¸c˜ao utilizando os C´odigos

2.10 e 2.11 respectivamente.

A fatora¸c˜ao de um dado 𝑛, nos possibilita determinar, entre outras coisas, as citadas

abaixo relativas a 𝑛 :

1. Quantos divisores 𝑛 possui;

2. Quais s˜ao tais divisores, qual ´e a soma e o produto destes divisores.

De modo geral seja 𝑛 = 𝑝𝑟1

𝑘 e sejam 𝐷, 𝐷(𝑛), 𝑆(𝑛) e 𝑃 (𝑛) o n´umero de
divisores, o conjunto dos divisores, a soma dos divisores e o produto do divisores de 𝑛. A
t´ıtulo de ilustra¸cao, 𝐷 e 𝑆(𝑛) podem ser calculados pelas f´ormulas:

2 . . . 𝑝𝑟𝑘

1 𝑝𝑟2

𝐷 = (𝑟1 + 1)(𝑟2 + 1) . . . (𝑟𝑘 + 1)

𝑆(𝑛) =

𝑝𝑟1+1
1 − 1
𝑝1 − 1

. . .

𝑝𝑟𝑘+1
𝑘 − 1
𝑝𝑘 − 1

𝑃 (𝑛) = 𝑛 𝐷

2

A demonstra¸c˜ao da express˜ao para 𝐷 pode ser consultada em (LIMA et al., 2006),
enquanto que para ver uma demonstra¸c˜ao sobre 𝑆(𝑛) consultar (HEFEZ, 2011). Provemos
a f´ormula para 𝑃 (𝑛) a seguir.

Problema 2.3. Dado 𝑛 ∈ N, com 𝑛 > 1, prove que o produto dos divisores de 𝑛, denotado
por 𝑃 (𝑛), ´e igual a 𝑛 𝐷

2 , onde 𝐷 ´e o n´umero de divisores de 𝑛.

Solu¸c˜ao: Seja {𝑑1, 𝑑2, . . . , 𝑑𝐷} o conjunto dos divisores de 𝑛. Temos ent˜ao que
𝑛 = 𝑑𝑖 · 𝑑𝑗 com 𝑖 ̸= 𝑗 para algum 𝑖, 𝑗 ∈ {1, . . . , 𝐷}, segue que 𝑃 (𝑛) = 𝑑1 · 𝑑2 · . . . · 𝑑𝐷
pode ser reordenado de tal modo que a cada dois fatores o resultado seja sempre 𝑛, logo
𝑃 (𝑛) = 𝑛 · 𝑛 · . . . · 𝑛

= 𝑛 𝐷
2 .

⏟

 ⏞
𝐷
2 vezes

Caso 𝑛 = 𝑘2 teremos para algum 𝑖 e 𝑗, 𝑑𝑖 = 𝑑𝑗 = 𝑘 que ´e contado duas vezes no
(cid:4)

produto e no entanto s´o uma vez no conjunto dos divisores.

 
2.3. Um pouco mais de aritm´etica

69

Como consequˆencia os ´unicos n´umeros que tem uma quantidade ´ımpar de divisores

s˜ao os quadrados perfeitos.

A ideia agora ´e elaborar um programa que dado 𝑛 ∈ N, 𝑛 > 1 calculemos 𝐷, 𝐷(𝑛),

𝑆(𝑛) e 𝑃 (𝑛) mencionados acima.

A estrat´egia se baseia no fato de que para cada divisor 𝑑𝑖 de 𝑛 temos 𝑛 = 𝑑𝑖 · 𝑑′
𝑖,
ou seja os divisores aparecem aos pares. Ent˜ao criaremos um vetor e armazenaremos os
𝑑𝑖 e seus respectivo 𝑑′
𝑛. De
posse do vetor dos divisores basta varrer todos seus elementos com dois acumuladores,
um pra soma e outro para o produto. O n´umero de divisores ´e simplesmente len(vetor do
divisores). O C´odigo 2.12 apresenta uma poss´ıvel solu¸c˜ao em Python.

𝑖 e faremos todos os testes de divisibilidade enquanto 𝑑 ≤

√

C´odigo 2.12 – Quantidade, conjunto, soma e produto dos divisores de 𝑛

1 n = int ( input ( ’ Entre com o valor de n : ’) )

2 d ,S , P =1 ,0 ,1

3 vetor =[]

4 while d <= n * * 0.5:

5

6

7

8

if n % d ==0:

vetor . append ( d )

vetor . append ( n // d )

d = d +1

9 divisores = list ( set ( vetor ) ) # eliminando repeti ¸c ~o es

10 divisores . sort () # deixando os elementos na ordem crescente

11 for i in range ( len ( divisores ) ) :

12

13

S = S + divisores [ i ]

P = P * divisores [ i ]

14 print ( ’O n ´u mero

de divisores de % d ´e D =% d ’ %( n , len ( divisores ) ) )

15 print ( ’D (% d ) = ’%n , divisores )

16 print ( ’A soma de todos os divisores de % d ´e S (% d ) =% d ’ %( n ,n , S ) )

17 print ( ’E o produto de todos os divisores de % d ´e

P (% d ) =% d ’ %( n ,n , P ) )

18 RESTART :

19 Entre com o valor de n : 60

20 O n ´u mero

de divisores de 60 ´e D =12

21 D (60) = [1 , 2 , 3 , 4 , 5 , 6 , 10 , 12 , 15 , 20 , 30 , 60]

22 A soma de todos os divisores de 60 ´e S (60) =168

23 E o produto de todos os divisores de 60 ´e P (60) =46656000000

No embalo dos primos temos mais dois problemas que surgem naturalmente, s˜ao

eles:

1. Quantos n´umeros primos existem?

70

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

2. Dado 𝑛 ∈ N quais s˜ao todos os primos at´e 𝑛?

A resposta aos questionamentos acima, seguem no pr´oximo teorema e no pr´oximo problema,
devido a Euclides e Erat´ostenes respectivamente.

Teorema 2.6 (Euclides). Existem inﬁnitos n´umeros primos.

Demonstra¸c˜ao. Suponhamos que existam apenas um n´umero ﬁnito de n´umeros primos
𝑝1, 𝑝2, . . . , 𝑝𝑘 e seja 𝑛 = 𝑝1𝑝2 . . . 𝑝𝑘 + 1. Pelo Teorema 2.5 um dos 𝑝𝑖, 𝑖 = 1, . . . 𝑘, divide 𝑛;
ora mas como 𝑝𝑖|𝑝1𝑝2 . . . 𝑝𝑖 . . . 𝑝𝑘 temos que 𝑝𝑖|𝑛 − 𝑝1𝑝2 . . . 𝑝𝑘 = 1, o que ´e um absurdo.

Problema 2.4 (Crivo de Erat´ostenes). Dado 𝑛 ∈ N com 𝑛 > 1, determine todos os
primos at´e 𝑛 (inclusive).

Solu¸c˜ao: A ideia ´e montar uma tabela com todos os n´umeros naturais de 2 at´e

𝑛 e fazer o seguinte procedimento:

1. deixar o 2 e riscar todos os seus m´ultiplos at´e 𝑛;

2. deixar o pr´oximo n´umero primo maior que 2, que ´e 3, e riscar todos os seus m´ultiplos

at´e 𝑛;

3. deixar o pr´oximo n´umero primo maior do que 3, que ´e 5 e riscar todos os seus

m´ultiplos at´e 𝑛;

E assim sucessivamente at´e n˜ao ser mais poss´ıvel tal procedimento. Os n´umeros que
ﬁcarem intactos (n˜ao forem riscados) ser˜ao os primos at´e 𝑛.

Para efeitos ilustrativos, vejamos o processo com 𝑛 = 50

1

11
11

21

31
31

41
41

2
2

12

22

32

42

3
3

13
13

23
23

33

43
43

4

14

24

34

44

5
5

15

25

35

45

6

16

26

36

46

7
7

17
17

27

37
37

47
47

8

18

28

38

48

9

19
19

29
29

39

49

10

20

30

40

50

Logo os primos at´e 50 s˜ao {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}

(cid:4)

Vejamos agora um programa que nos retorna todos os primos at´e um dado 𝑛
fornecido pelo usu´ario. J´a percebemos que existem diversas formas de resolver o mesmo

2.3. Um pouco mais de aritm´etica

71

problema, tamb´em n˜ao ´e diferente com os programas, vamos utilizar a fun¸c˜ao ehprimo do
c´odigo 2.10 e a partir da´ı testar a fun¸c˜ao ehprimo, do Programa 2.11, dentro de um for e
os n´umeros que forem primos ser˜ao armazenados em um vetor; ao ﬁm do la¸co do for basta
imprimir tal vetor para visualizaramos os primos at´e 𝑛.O C´odigo 2.13 faz este trabalho.

C´odigo 2.13 – Crivo de Erat´ostenes

1 def ehprimo ( n ) :

2

3

4

5

6

7

8

p = int ( n * * 0.5)

while p >=1:

if n % p ==0 and p !=1:

break

if p ==1:

return True

p =p -1

9 vetor_primos =[]

10 n = int ( input ( ’ Digite o n ´u mero de parada : ’) )

11 for i in range (2 , n +1) :

12

13

if ehprimo ( i ) :

vetor_primos . append ( i )

14 print ( ’ Todos os primos at ´e % d s ~a o ’%n , vetor_primos )

15 RESTART :

16 Digite o n ´u mero de parada : 50

17 Todos os primos at ´e 50 s ~a o [2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 ,

31 , 37 , 41 , 43 , 47]

Para encerrarmos este cap´ıtulo, vejamos alguns n´umeros especiais: primos gˆemeos,

n´umeros perfeitos e primos de Mersene6.

Deﬁni¸c˜ao 2.4. Dizemos que dois primos 𝑝 e 𝑞 s˜ao gˆemeos se 𝑝 − 𝑞 = 2.

Vejamos abaixo um programa que mostra todos os pares de primos gˆemeos at´e um

dado 𝑛 fornecido pelo usu´ario.

C´odigo 2.14 – Primos gˆemeos

1 primos =[]

2 g ^e meos =[]

3 for i in range (2 , int ( input ( " n : " ) ) +1) :

4

5

if all ([ i % a !=0 for a in range (2 , int ( i * * 0.5) +1) ]) :

primos . append ( i )

6 for i in range ( len ( primos ) ) :

7

if primos [ i ]+2 in primos :

6 Marin Mersenne (1588-1648) matem´atico francˆes cujo nome ´e lembrado pelos primos da forma 2𝑝 − 1

72

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

8

g ^e meos . append ([ primos [ i ] , primos [ i ]+2])

9 print ( ’ Os pares de primos g ^e meos s ~a o : ’ ,g ^e meos )

10 RESTART :

11 n : 50

12 Os pares de primos g ^e meos s ~a o :

[[3 , 5] , [5 , 7] , [11 , 13] , [17 ,

19] , [29 , 31] , [41 , 43]]

Podemos encontrar em (WATANABE, 2013) um resultado muito interessante
sobre primos gˆemeos devido Yitang Zhang7. Em (WATANABE, 2013) tamb´em encontra-
se o maior par de primos gˆemeos descoberto at´e a data de sua publica¸c˜ao. A saber,
3576801695685 × 2666669 − 1 e 3576801695685 × 2666669 + 1.

Atualmente, de acordo com o (The Prime Pages , 2018) o maior par de primos

gˆemeos ´e

2996863034895 · 21290000 − 1 e 2996863034895 · 21290000 + 1

Um n´umero ´e chamado de perfeito quando a soma de seus divisores ´e igual ao seu dobro ou
de forma equivalente se a soma de seus divisores pr´oprios ´e igual a ele mesmo. (divisores
pr´oprios s˜ao os divisores de um n´umero exceto ele mesmo)

Deﬁni¸c˜ao 2.5. Seja 𝑛 um natural e 𝑆(𝑛) a soma de seus divisores, se 𝑆(𝑛) = 2𝑛, dizemos
que 𝑛 ´e perfeito.

Vejamos alguns exemplos de n´umeros perfeitos: 6, 28, 496 de fato o s˜ao, pois sejam
𝐷(6), 𝐷(28) e 𝐷(496) o conjunto dos divisores pr´oprios de cada n´umero respectivamente,
temos que:

𝐷(6) = {1, 2, 3}

e

6 = 1 + 2 + 3

𝐷(28) = {1, 2, 4, 7, 14}

e

28 = 1 + 2 + 3 + 4 + 7 + 14

𝐷(496) = {1, 2, 4, 8, 16, 31, 62, 124, 248}

e

496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248

Finalmente tratemos os n´umeros de Mersenne. Os n´umeros da forma 𝑀𝑝 = 2𝑝 − 1

com 𝑝 primo s˜ao chamados de n´umeros de Mersenne.

Deﬁni¸c˜ao 2.6. Os primos de Mersenne s˜ao os primos da forma 𝑀𝑝 = 2𝑝 − 1, em que 𝑝
´e primo.

Durante muitos s´eculos acreditou-se que os n´umeros de Mersenne fossem primos,

contudo, Hudalricus Regius mostrou que 211 − 1 ´e composto.

7 Matem´atico Chinˆes, professor da Universidade de New Hampshire

2.3. Um pouco mais de aritm´etica

73

𝑀2 = 22 − 1 = 3, 𝑀3 = 23 − 1 = 7, 𝑀5 = 25 − 1 = 31, 𝑀7 = 27 − 1 = 127
s˜ao os primeiros primos de Mersenne. Para uma lista com todos conhecidos at´e a atualidade
veja (Mersenne Researchs , 2018, 2018)

Existe um resultado que estabelece a rela¸c˜ao entre n´umeros perfeitos e primos de
Mersenne. Este ´e apresentado no pr´oximo teorema, cuja demonstra¸c˜ao pode ser encontrada
em (HEFEZ, 2011).

Teorema 2.7. Um n´umero 𝑛 ∈ N ´e perfeito par se, e somente se, 𝑛 = 2𝑝−1(2𝑝 − 1) com
2𝑝 − 1 um primo de Mersenne.

Observemos que:

6 = 21(22 −1), 28 = 22(23 −1) e 496 = 24(25 −1) s˜ao os n´umeros pefeitos associados

aos Primos de Mersenne 𝑀2, 𝑀3 e 𝑀5 citados acima.

Uma curiosidade: Segundo (Mersenne Researchs , 2018) o maior Primo de Mersenne
´e 277232917 − 1 com 23249425 dig´ıtos. Tal n´umero foi descoberto por Pace, Woltman,
Kurowski, Blosser & GIMPS em 26 de Dezembro de 2017; este ´e tamb´em o maior primo
j´a descoberto e o n´umero perfeito associado a ele ´e 277232916 · (277232917 − 1).

Por ﬁm apresentamos um programa que dado uma lista com os primeiros 𝑝 n´umeros

primos, retorna os primos de Mersenne 2𝑝 − 1.

C´odigo 2.15 – Primos de Mersenne

1 def ehprimo ( n ) :

2 p = int ( n * * 0.5)

3

4

5

6

7

8

9

while p >= 1:

if n % p == 0 and p !=1:

return False

break

if p == 1:

return True

p = p - 1

10 primos =[]

11 n = int ( input ( ’n : ’) )

12 for i in range (2 , n +1) :

13

14

if ehprimo ( i ) :

primos . append ( i )

15 mersenne =[]

16 for i in primos :

17

18

if ehprimo (2 * *i -1) :

mersenne . append ( " 2^% d - 1 " % i )

19 print ( mersenne )

74

Cap´ıtulo 2. Aplica¸c˜oes da Aritm´etica b´asica em Python

RESTART :

n : 20

[ ’ 2^2 - 1 ’ , ’ 2^3 - 1 ’ , ’ 2^5 - 1 ’ , ’ 2^7 - 1 ’ , ’ 2^13 - 1 ’ , ’ 2^17 -

1 ’ , ’ 2^19 - 1 ’]

20

21

22

23

O programa acima retornou os seguintes primos de Mersenne 22 − 1, 23 − 1, 25 − 1,

27 − 1, 213 − 1, 217 − 1 e 219 − 1.

Finalizemos o cap´ıtulo salientando que os programas aqui apresentados podem
ser melhorados e por vezes n˜ao apresentam uma melhor performace quando se considera
tempo de execu¸c˜ao e espa¸co de armazenamento. Contudo, a principal ﬁnalidade deste
trabalho ´e fazer uma ponte entre o ensino de introdu¸c˜ao `a programa¸c˜ao com a linguagem
Python e o ensino de no¸c˜oes b´asicas da Teoria dos n´umeros.

75

Cap´ıtulo 3

Considera¸c˜oes ﬁnais

A presente disserta¸c˜ao teve como objetivo central apresentar a possibilidade da
linguagem de programa¸c˜ao Python como ferramenta para o ensino de aritm´etica. Neste
sentido, apresentamos algumas funcionalidades do Python, aquelas que seriam utilizadas nos
programas desenvolvidos, discutimos alguns resultados centrais de aritm´etica e propusemos
programas em Python para tais resultados, buscando utilizar as demonstra¸c˜oes apresentadas
para elaborar nossos c´odigos. Entendemos, que tais programas podem n˜ao ser os mais
eﬁcientes no que diz respeito a tempo de execu¸c˜ao e espa¸co de armazenamento de dados,
contudo, a ideia era propor um material que permitisse interligar o ensino de uma linguagem
de programa¸c˜ao com o entendimento dos resultados e de suas provas. Todos os programas
foram desenvolvidos pelo autor desta disserta¸c˜ao. Vale ressaltar que, al´em de construir um
programa ´e importante tamb´em vˆe-lo sendo executado linha a linha para entender seu
funcionamento. Sugerimos consultar (Philip Guo, 2018) para tal ferramenta. A visualiza¸c˜ao
da execu¸c˜ao de um programa, al´em de facilitar o entendimento das estruturas b´asicas (if ,
while e for ), estimula a busca por c´odigos mais enxutos.

O autor desta disserta¸c˜ao ´e professor no Instituto Federal de Goi´as (IFG), Cˆampus
Itumbiara. Pretende-se, como trabalho futuro, adaptar esta disserta¸c˜ao em um projeto
de ensino voltado para estudantes do n´ıvel m´edio. O IFG de Itumbiara cont´em uma
infraestrutura favor´avel `a execuc˜ao do projeto, pois conta com quatro laborat´orios de
inform´atica e internet em todas salas. Assim, acredita-se que este projeto ir´a complementar
a forma¸c˜ao dos estudantes apresentando-lhes uma linguagem de programa¸c˜ao moderna e
t´opicos de Teoria dos n´umeros, assunto praticamete esquecido no ensino m´edio.

Ressalta-se ainda que o autor pretende incrementar o material j´a proposto nesta
disserta¸c˜ao, focando na constru¸c˜ao de c´odigos acerca de outros assuntos em Matem´atica,
tais como, matrizes, gr´aﬁcos, trigonometria, fun¸c˜oes elementares e estat´ıstica. Al´em disso,
pretende-se trabalhar com os alunos mais sobre a linguagem Python: suas bibliotecas,
jogos, orienta¸c˜ao `a objeto, banco de dados, dentre outros assuntos.

77

Referˆencias

HEFEZ, A. Elementos de Aritm´etica, 2a Edi¸c˜ao, Rio de Janeiro. [S.l.]: SBM,
2011.

LEITE, P. F. N´umeros de fermat. Revista do Professor de Matem´atica, v. 07, 1985.

LIMA, E. L. et al. A matem´atica do ensino m´edio, vol. 2. Cole¸cao do Professor de
Matem´atica, SBM, 2006.

Masanori. Python Zumbi 0. 2018. Dispon´ıvel em: <https://www.youtube.com/watch?
v=6La690qlH5w&list=PLUukMN0DTKCtbzhbYe2jdF4cr8MOWClXc>. Acessado em
07/09/2018.

MENEZES, N. N. C. Introdu¸c˜ao `a programa¸c˜ao com Python–2a edi¸c˜ao:
Algoritmos e l´ogica de programa¸c˜ao para iniciantes. [S.l.]: Novatec Editora, 2016.

Mersenne Researchs . Prime numbers records. 2018. Dispon´ıvel em: <https:
//www.mersenne.org/primes/>. Acessado em 06/09/2018.

MORAN, J.; MASETO, M. T.; BEHRENS, M. A. Novas Tecnologias E Media¸c˜ao
Pedag´ogica. [S.l.]: Papirus, 2013. (Cole¸c˜ao Papirus Educa¸c˜ao). ISBN 9788530805944.

MOREIRA, C. G. T. d. A.; SALDANHA, N. C. Testes de primalidade: probabil´ısticos
e determin´ısticos. [S.l.: s.n.], 2011.

PENHA, G. de la. Euler e a teoria dos n´umeros. Revista do Professor de Matem´atica,
v. 04, 1983.

Philip Guo. Python tutor. 2018. Dispon´ıvel em: <http://pythontutor.com/>. Acessado
em 15/01/2018.

Python Brasil. Empresas Python. 2018. Dispon´ıvel em: <https://python.org.br/
empresas/>. Acessado em 07/09/2018.

Python ORG. Interative Python Online. 2018. Dispon´ıvel em: <https:
//www.python.org/shell/>. Acessado em 05/01/2018.

. Python Documents. 2018. Dispon´ıvel em: <https://docs.python.org/3/library/

math.html>. Acessado em 07/09/2018.

78

Referˆencias

. Python Download. 2018. Dispon´ıvel em: <https://www.python.org/>.

Acessado em 12/01/2018.

SIDKI, S. Introdu¸c˜ao `a teoria dos n´umeros. [S.l.]: IMPA, 1975.

SILVA, H. A. d. Regimento do profmat - sbm. 2016.

SUMMERFIELD, M. Programa¸c˜ao em Python 3: Uma introdu¸c˜ao completa `a
linguagem Python. [S.l.]: Alta Books, 2012. (Biblioteca do Programador).

The Prime Pages . Prime numbers. 2018. Dispon´ıvel em: <https://primes.utm.edu/
largest.html#Mersenne>. Acessado em 05/09/2018.

WATANABE, R. Not´ıcias espetaculares. Revista do Professor de Matem´atica, v. 82,
p. 2–6, 2013.

