Universidade Federal de GoiÂ´as - UFG

Instituto de MatemÂ´atica e EstatÂ´Ä±stica

Programa de Mestrado Proï¬ssional em MatemÂ´atica

em Rede Nacional

AritmÂ´etica com Python

RogÂ´erio da Silva Cavalcante

GoiË†ania â€“ GO

2018

RogÂ´erio da Silva Cavalcante

AritmÂ´etica com Python

DissertaÂ¸cËœao apresentada ao Programa de Mes-
trado Proï¬ssional em MatemÂ´atica em Rede Na-
cional do Instituto de MatemÂ´atica e EstatÂ´Ä±s-
tica da Universidade Federal de GoiÂ´as, como
requisito parcial para a obtenÂ¸cËœao do tÂ´Ä±tulo de
Mestre em MatemÂ´atica.

Orientadora: Dra. Thaynara Arielly de Lima

GoiË†ania â€“ GO
2018

Ficha de identificaÃ§Ã£o da obra elaborada pelo autor, atravÃ©s doPrograma de GeraÃ§Ã£o AutomÃ¡tica do Sistema de Bibliotecas da UFG.CDU 51Cavalcante, RogÃ©rio da Silva      AritmÃ©tica com Python [manuscrito]  / RogÃ©rio da SilvaCavalcante. - 2018.       59 f.       Orientador: Profa. Dra. Thaynara Arielly de Lima.      DissertaÃ§Ã£o (Mestrado) - Universidade Federal de GoiÃ¡s, Institutode MatemÃ¡tica e EstatÃ­stica (IME), PROFMAT - Programa de PÃ³sgraduaÃ§Ã£o em MatemÃ¡tica em Rede Nacional - Sociedade Brasileirade MatemÃ¡tica (RG), GoiÃ¢nia, 2018.     Bibliografia.      Inclui tabelas, algoritmos, lista de figuras, lista de tabelas.      1. LÃ³gica. 2. ProgramaÃ§Ã£o. 3. AritmÃ©tica. 4. Python. 5. Ensino deMatemÃ¡tica. I. Lima, Thaynara Arielly de, orient. II. TÃ­tulo.Todos os direitos reservados. Â´E proibida a reproduÂ¸cËœao total ou par-
cial deste trabalho sem a autorizaÂ¸cËœao da universidade, do autor e do
orientador.

RogÂ´erio da Silva Cavalcante graduou-se em MatemÂ´atica pela Univer-
sidade Federal de GoiÂ´as no ano de 2006. Atua como professor do ensino
bÂ´asico desde 2000, jÂ´a lecionou em escola estaduais, municipais e desde
2013 estÂ´a no IFG CË†ampus Itumbiara.

Dedico este trabalho aos meus pais,
Marluce e Jeremias pela conï¬anÂ¸ca e respeito.

Agradecimentos

AgradeÂ¸co a Deus por tudo que tem me proporcionado.

Aos meus pais Jeremias e Marluce pelo modo Â´Ä±mpar com que me educaram e por
todo o suporte moral, psicolÂ´ogico e ï¬nanceiro sem o qual essa conquista nËœao se concretizaria.

AgradeÂ¸co `a minha companheira Edilene Cristina que nesse Â´arduo perÂ´Ä±odo de lutas

e renuncias, demonstrou fÂ´e e esperanÂ¸ca na conclusËœao exitosa de tal jornada.

As minhas irmËœas AndrÂ´ea, Alean e Ariadna e ao meu irmËœao Renato pela torcida e

apoio.

Um agradecimento especial a professora doutora Thaynara Arielly de Lima pela
impecÂ´avel orientaÂ¸cËœao, constante incentivo e contÂ´Ä±nua compreensËœao que culminaram na
realizaÂ¸cËœao deste trabalho.

Aos colegas da Escola Municipal Honestino Monteiro GuimarËœaes, em destaque para
Talita, Jeovane e Gilson cujas saudosas conversas me impulsionavam para um aprimora-
mento pessoal e proï¬ssional.

Aos colegas do IFG cË†ampus Itumbiara pelo apoio, diÂ´alogos e notÂ´oria Ë†enfase na
importË†ancia da conclusËœao de tal etapa, em especial para Leonardo Garcia Marques pela
disposiÂ¸cËœao em compartilhar tempo e conhecimentos sobre LATEX, programaÂ¸cËœao e Python.

Por ï¬m agradeÂ¸co a CAPES, SBM, IMPA e UFG por ofertarem novas possibilidades

atravÂ´es do PROFMAT.

DONâ€™T PANIC.
(Douglas Adams)

Resumo

Objetivamos neste trabalho mostrar o quËœao eï¬cazes podem ser os recursos tecnolÂ´ogicos
quando utilizados para o ensino. Escolhemos utilizar a linguagem de programaÂ¸cËœao Python
no ensino de matemÂ´atica, especiï¬camente aritmÂ´etica, exibindo como a lÂ´ogica transita
naturalmente entre a computaÂ¸cËœao e a matemÂ´atica, mostrando desta maneira uma inter-
disciplinariedade nata entre esses assuntos. SËœao propostos programas construÂ´Ä±dos a partir
das demonstraÂ¸cËœoes de alguns resultados clÂ´assicos em aritmÂ´etica, visando integrar o ensino
desses resultados ao ensino de ferramentas bÂ´asicas de uma linguagem de programaÂ¸cËœao.

Palavras-chave: LÂ´ogica. ProgramaÂ¸cËœao. AritmÂ´etica. Python. Ensino de MatemÂ´atica.

Abstract

We aim to show how eï¬€ective the technological resources can be when used for teaching.
We chose to use the Python programming language in mathematics teaching, speciï¬cally
arithmetic, showing how logic moves naturally between computing and mathematics,
thereby showing a natural interdisciplinarity between these subjects. We propose programs
built from the demonstrations of some classic results in arithmetic, aiming to integrate the
teaching of these results to the teaching of basic tools of a programming language.

Keywords: Logic, Programming, Python, Arithmetic, Teaching Mathematics.

Lista de ï¬guras

Figura 1 â€“ Empresas que usam Python . . . . . . . . . . . . . . . . . . . . . . . . 25
Figura 2 â€“ Outras empresas que usam Python . . . . . . . . . . . . . . . . . . . . 26
Figura 3 â€“ Aplicativos que usam Python . . . . . . . . . . . . . . . . . . . . . . . 26
Figura 4 â€“ InstituiÂ¸cËœoes que usam Python . . . . . . . . . . . . . . . . . . . . . . . 26
Figura 5 â€“ Pixar usa Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
Figura 6 â€“ ComentÂ´ario de Eric Raymond . . . . . . . . . . . . . . . . . . . . . . . 26
27
Figura 7 â€“ ComentÂ´ario de Peter Norvig . . . . . . . . . . . . . . . . . . . . . . . .
27
Figura 8 â€“ ComentÂ´ario de Cuon Dong . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 9 â€“ ComentÂ´ario de Bjarne Stroutrup . . . . . . . . . . . . . . . . . . . . . 28
Figura 10 â€“ ComentÂ´ario de Donald Knuth . . . . . . . . . . . . . . . . . . . . . . . 28
Figura 11 â€“ Guido Van Rossum: Criador do Python . . . . . . . . . . . . . . . . . . 28
Figura 12 â€“ Monty Python, grupo de humor que inspirou o nome linguagem . . . . 28
Figura 13 â€“ Logomarca do Python . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
Figura 14 â€“ SÂ´Ä±tio para download do Python . . . . . . . . . . . . . . . . . . . . . . 29
Figura 15 â€“ Download do Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Figura 16 â€“ Indicador do download no Google Chrome . . . . . . . . . . . . . . . . 29
Figura 17 â€“ Janela de conï¬rmaÂ¸cËœao da execuÂ¸cËœao do instalador Python . . . . . . . . 30
Figura 18 â€“ Janela de seleÂ¸cËœao das conï¬guraÂ¸cËœoes . . . . . . . . . . . . . . . . . . . . 30
Figura 19 â€“ Progresso da instalaÂ¸cËœao . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Figura 20 â€“ Janela de conï¬rmaÂ¸cËœao da execuÂ¸cËœao do instalador Python . . . . . . . . 30
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Figura 21 â€“ Python Shell
31
Figura 22 â€“ Caminho para o modo de ediÂ¸cËœao . . . . . . . . . . . . . . . . . . . . . .
Figura 23 â€“ Modo de ediÂ¸cËœao do Python . . . . . . . . . . . . . . . . . . . . . . . . .
31
Figura 24 â€“ Caminho para executar o programa no modo de ediÂ¸cËœao . . . . . . . . . 32
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Figura 25 â€“ â€œOkâ€ para salvar
Figura 26 â€“ Nomeando o arquivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Figura 27 â€“ Resultado do programa . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

Lista de tabelas

Tabela 1 â€“ OperaÂ¸cËœoes bÂ´asicas
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Tabela 2 â€“ Fatiamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Tabela 3 â€“ Operadores relacionais . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Tabela 4 â€“ not
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Tabela 5 â€“ and . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Tabela 6 â€“ or . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Tabela 7 â€“ ConversËœao de dados
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Tabela 8 â€“ Listas numÂ´ericas com list e range . . . . . . . . . . . . . . . . . . . . 50

SumÂ´ario

IntroduÂ¸cËœao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

21

1 Uma breve introduÂ¸cËœao ao Python . . . . . . . . . . . . . . . . . . . . .

25

1.1 Porque Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

1.2

InstalaÂ¸cËœao e ambientaÂ¸cËœao . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

1.3 Python como calculadora . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

1.4 VariÂ´aveis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

34

1.5 Entrada de Dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

41

1.6 Estruturas bÂ´asicas

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

2 AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python . . . . . . . . . . . . . . .

53

2.1 DivisËœao Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

2.2 Bases numÂ´ericas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

2.3 Um pouco mais de aritmÂ´etica . . . . . . . . . . . . . . . . . . . . . . . . . 60

2.3.1 MÂ´aximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . .

61

2.3.2 Primos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

3 ConsideraÂ¸cËœoes ï¬nais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

75

ReferË†encias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

77

21

IntroduÂ¸cËœao

O avanÂ¸co do mundo digital trouxe consigo inÂ´umeros impactos nos mais variados
ramos da atuaÂ¸cËœao humana, desde uma plantaÂ¸cËœao a produÂ¸cËœao em larga escala, telecomuni-
caÂ¸cËœoes, meios de transporte, medicina, pesquisas cientÂ´Ä±ï¬cas, relaÂ¸cËœoes sociais (globalizaÂ¸cËœao),
seguranÂ¸ca nacional, educaÂ¸cËœao, etc.

Tal avanÂ¸co estÂ´a em correspondË†encia biunÂ´Ä±voca com o desenvolvimento social. As
necessidades da sociedade implicam surgimentos de novas tecnologias que por sua vez
implicam novas formas sociais de interagir, se organizar e estruturar, como exemplo, temos
as prÂ´aticas de ensino nas mais variadas escolas.

Esse desenvolvimento tecnolÂ´ogico goza de uma velocidade maior que as mudanÂ¸cas
ocorridas em uma escola, principalmente durante e apÂ´os a guerra fria, onde uma bipolariza-
Â¸cËœao mundial acelerou o surgimento e difusËœao de tecnologias (computadores, internet, etc).
De uma maneira geral, a escola nËœao acompanhou tal ritmo, pois a mesma necessita de um
aperfeiÂ¸coamento tanto de pessoas como de infra estruturas, processos que podem ser demo-
rados, principalmente na realidade das escolas pÂ´ublicas brasileiras, onde o ï¬nanciamento
de formaÂ¸cËœao de pessoal e investimento em laboratÂ´orios ainda nËœao Â´e ideal.

Neste sentido uma questËœao que torna-se pertinente Â´e : como mediar tal avanÂ¸co na

busca de uma nova educaÂ¸cËœao, novas prÂ´aticas, novas possibilidades?

Tal questionamento vai de encontro com um dos objetivos do Regimento 2017 do
PROFMAT (Mestrado Proï¬ssional em MatemÂ´atica em Rede Nacional) do capÂ´Ä±tulo I Art.
2o.

Art. 2o O PROFMAT tem como objetivo proporcionar formaÂ¸cËœao mate-
mÂ´atica aprofundada e relevante ao exercÂ´Ä±cio da docË†encia na EducaÂ¸cËœao
BÂ´asica, visando dar ao egresso a qualiï¬caÂ¸cËœao certiï¬cada para o exercÂ´Ä±cio
da proï¬ssËœao de professor de MatemÂ´atica (SILVA, 2016, p.1).

As mudanÂ¸cas dentro do ambiente escolar sËœao complexas pois demandam uma

harmonia entre docentes, discentes, gestËœao e comunidade.

22

IntroduÂ¸cËœao

As mudanÂ¸cas demorarËœao mais do que alguns pensam, porque os mo-
delos tradicionais estËœao muito sedimentados, em parte, eles funcionam,
e com isso torna-se complicado fazer mudanÂ¸cas profundas. Por outro
lado encontramo-nos em processos desiguais de aprendizagem e evoluÂ¸cËœao
pessoal e social. Apesar de haver avanÂ¸cos, muitas instituiÂ¸cËœoes e muitos
proï¬ssionais mantË†em uma distË†ancia entre teoria e prÂ´atica, entre suas
ideias e aÂ¸cËœoes. Se as pessoas tË†em diï¬culdades para evoluir, conviver e
trabalhar em conjunto, isso se reï¬‚ete na prÂ´atica pedagÂ´ogica (MORAN;
MASETO; BEHRENS, 2013, pp.24-25).

As mudanÂ¸cas na educaÂ¸cËœao passam em primeiro momento por educadores, nËœao
necessariamente professores, mas tambÂ´em os pais, diretores e os prÂ´oprios alunos que
estejam dispostos, maduros e que sejam motivadores, pois o gerenciamento das emoÂ¸cËœoes
afeta o rendimento de qualquer pessoa em sua aprendizagem.

A EducaÂ¸cËœao focada na formaÂ¸cËœao do ser humano, numa abordagem mais ampla
possÂ´Ä±vel, pode fazer uso de recursos tecnolÂ´ogicos que sËœao um grande facilitador desse
processo por diversos motivos:

1. Desaï¬am as instituiÂ¸cËœoes a sair do tradicional;

2. Facilitam a pesquisa, multiplicam os espaÂ¸cos de atuaÂ¸cËœao ;

3. Possibilitam uma aprendizagem mais participativa e integrada;

4. Oferecem aplicativos, jogos, vÂ´Ä±deos, dentre outros recursos, que proporcionam dina-

mismo nos processos educativos em geral.

Â´E importante destacar que o fato de se ter um computador (ou qualquer outro
recurso tecnolÂ´ogico), nËœao acarreta que se tenha aprendizagem. O professor como mediador
do conhecimento deve buscar e planejar atividades, com objetivos bem determinados que
potencializem tais recursos.

Nesse contexto um fator marcante ao utilizarmos tecnologias como mediadores
educacionais Â´e o impacto explÂ´Ä±cito no espaÂ¸co geogrÂ´aï¬co da sala de aula. Tal abordagem
metodolÂ´ogica propicia uma maior integraÂ¸cËœao entre ensino `a distË†ancia e presencial, incen-
tivando o nascimento de uma escola mais criativa e menos normativa e quem sabe mais
libertÂ´aria no sentido de que nem todos devam aprender as mesmas coisas, no mesmo tempo
e submetidos `as mesmas metodologias.

Toda sociedade serÂ´a uma sociedade que aprende de inÂ´umeras formas, em tempo
real, com vastÂ´Ä±ssimo material audiovisual disponÂ´Ä±vel.(MORAN; MASETO; BEHRENS,
2013, p.67)

O presente trabalho tem a proposta de relacionar o ensino de matemÂ´atica (mais
especiï¬camente aritmÂ´etica) com a utilizaÂ¸cËœao da linguagem de programaÂ¸cËœao Python, pois Â´e

23

cada vez mais recorrente o acesso a tecnologias e as transformaÂ¸cËœoes que estas possibilitam
`a sociedade. Nesse contexto as prÂ´aticas de ensino de matemÂ´atica podem tentar usufruir
desses recursos tecnolÂ´ogicos para dar um maior dinamismo e tornar a aprendizagem mais
prazerosa e signiï¬cativa.

Por ï¬m, este trabalho estÂ´a estruturado conforme describo abaixo:

âˆ™ IntroduÂ¸cËœao : Tem por objetivo justiï¬car a viabilidade e importË†anica da utilizaÂ¸cËœao de

tecnologias na educaÂ¸cËœao;

âˆ™ CapÂ´Ä±tulo 1: apresenta de maneira breve como utilizar a linguagem Python e algumas

de suas ferramentas;

âˆ™ CapÂ´Ä±tulo 2: apresenta alguns programas em Python, elaborados a partir de ideias
presentes em demonstraÂ¸cËœoes clÂ´assicas de resultados de aritmÂ´etica, exempliï¬cando
como a relaÂ¸cËœao entre teoria e prÂ´atica pode ser frutÂ´Ä±fera;

âˆ™ CapÂ´Ä±tulo 3: traz as consideraÂ¸cËœoes ï¬nais, mostrando possibilidades de trabalhos futuros
na busca de aprofundamento, tanto na linguagem Python como na sua utilizaÂ¸cËœao
para o ensino da matemÂ´atica.

25

CapÂ´Ä±tulo 1

Uma breve introduÂ¸cËœao ao Python

1.1 Porque Python

Dentre tantas opÂ¸cËœoes em tecnologias, resolvemos trabalhar com a linguagem de

programaÂ¸cËœao Python por diversos motivos, os quais serËœao elencados abaixo:

â€œPython Â´e, provavelmente, a linguagem de programaÂ¸cËœao popular mais fÂ´acil e agra-
dÂ´avel de lidar. O cÂ´odigo Python Â´e simples para ler e escrever, e consegue ser conciso sem
ser enigmÂ´aticoâ€ (SUMMERFIELD, 2012, p.1).

A linguagem de programaÂ¸cËœao Phyton Â´e muito interessante como primeira
linguagem de programaÂ¸cËœao devido a sua simplicidade e clareza. Embora
simples, Â´e tambÂ´em uma linguagem poderosa, podendo ser usada para
administrar sistemas e desenvolver grandes projetos. Â´E uma linguagem
clara e objetiva, pois vai direto ao ponto, sem rodeios.(MENEZES, 2016,
p.24)

AlÂ´em do fato de Python ser um software livre (pode ser baixado gratuitamente) e
multiplataforma (funciona nos sistema operacionais Windows, Linux e MacOS X, entre
outros), Â´e uma linguagem que vem crescendo nos Â´ultimos anos e Â´e utilizadas por vÂ´arias
empresas. AlÂ´em disso, Â´e recomendada por diversos proï¬ssionais da Â´area da computaÂ¸cËœao e
adodata por diversas empresas, como Â´e ilustrado da Figura 1 a Figura 13.

Algumas empresas que usam o Python segundo (Python Brasil, 2018)

Figura 1 â€“ Empresas que usam Python

26

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

Outras empresas que utilizam o Python de acordo com (Masanori, 2018)

Figura 2 â€“ Outras
Python

empresas

que

usam

Figura 3 â€“ Aplicativos que usam Python

Figura 4 â€“ InstituiÂ¸cËœoes que usam Python

Figura 5 â€“ Pixar usa Python

1.2 InstalaÂ¸cËœao e ambientaÂ¸cËœao

Primeiramente vamos mostrar como baixar e instalar o Python no sistema opera-
cional Windowns 7, utilizando o navegador Google Chrome. Acessemos (Python ORG,
2018c)

Nessa tela da Figura 14, passemos o mouse no campo â€œDownloadsâ€, depois cli-
quemos em â€œPython 3.6.4â€, que Â´e a versËœao disponÂ´Ä±vel no dia 12/01/2018. ApÂ´os o clique,
automaticamente comeÂ¸carÂ´a o download do Python como indicam as Figuras 15 e 16.

ApÂ´os a conclusËœao do download, cliquemos no indicador de download da Figura 16.
EntËœao serÂ´a aberta a janela de execuÂ¸cËœao conforme Figura 17. Cliquemos em â€œexecutarâ€,
apÂ´os esse passo serÂ´a aberta a janela do instalador, cliquemos em â€œInstall Nowâ€ de acordo
com a Figura 18, entËœao o interpretador do Python comeÂ¸carÂ´a a ser instalado (Figura 19).
Terminada a instalaÂ¸cËœao aparecerÂ´a o botËœao close, ao clicar em tal botËœao o interpretador da
linguagem Python estarÂ´a instalado no computador.

1.2.

InstalaÂ¸cËœao e ambientaÂ¸cËœao

27

Figura 6 â€“ ComentÂ´ario de Eric Raymond

Figura 7 â€“ ComentÂ´ario de Peter Norvig

Para iniciar o Python, no Windows 7, basta seguir a sequË†encia de comandos:

Menu iniciar â†’ Todos os programas â†’ Python 3.6 â†’ IDLE (Python 3.6 32-
bit), conforme ilustra a Figura 20.

28

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

Figura 8 â€“ ComentÂ´ario de Cuon Dong

Figura 9 â€“ ComentÂ´ario de Bjarne Stroutrup

Uma janela serÂ´a aberta (Figura 21), descrita pelo interpretador como Python 3.6.4
Shell e nela Â´e possÂ´Ä±vel construir nossos programas em Python. FaÂ¸camos nosso primeiro
programa.

Digite: print(â€œBem vindo ao Pythonâ€) e depois aperte enter.

1.2.

InstalaÂ¸cËœao e ambientaÂ¸cËœao

29

Figura 10 â€“ ComentÂ´ario

de Donald

Figura 11 â€“ Guido Van Rossum: Criador

Knuth

do Python

Figura 12 â€“ Monty Python, grupo de hu-
mor que inspirou o nome lin-
guagem

Figura 13 â€“ Logomarca do Python

Figura 14 â€“ SÂ´Ä±tio para download do Python

O comando print(â€œTextoâ€) permite imprimir a palavra Texto na tela.

CÂ´odigo 1.1 â€“ Primeiro programa

30

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

Figura 15 â€“ Download do Python

Figura 16 â€“ Indicador do download no
Google Chrome

Figura 17 â€“ Janela de conï¬rmaÂ¸cËœao da
instalador

do

execuÂ¸cËœao
Python

Figura 18 â€“ Janela de seleÂ¸cËœao das conï¬-

guraÂ¸cËœoes

Figura 19 â€“ Progresso da instalaÂ¸cËœao

1 Python 3.6.4 ( v3 .6.4: d48eceb , Dec 19 2017 , 06:04:45) [ MSC v .1900

32 bit ( Intel ) ] on win32

2 Type " copyright " , " credits " or " license () " for more information .

3 >>> print ( " Bem vindo ao Python " )

4 Bem vindo ao Python

Observe que antes do print temos >>>, isto indica que estamos no modo interativo
do Python (Python Shell), ou seja os comandos sËœao executados logo apÂ´os o enter. O modo
interativo se apresenta por padrËœao ao abrirmos o interpretador. Mas nossos programas
serËœao digitados no modo de ediÂ¸cËœao. Para isso, no Python Shell, basta clicar em Fileâ†’New
File (Figura 22) dando acesso ao modo de ediÂ¸cËœao, conforme Figura 23.

1.2.

InstalaÂ¸cËœao e ambientaÂ¸cËœao

31

Figura 21 â€“ Python Shell

Figura 20 â€“ Janela de conï¬rmaÂ¸cËœao da
instalador

do

execuÂ¸cËœao
Python

Figura 22 â€“ Caminho para o modo de

ediÂ¸cËœao

Figura 23 â€“ Modo de ediÂ¸cËœao do Python

FaÂ¸camos o mesmo programa do CÂ´odigo 1.1 no modo de ediÂ¸cËœao:

CÂ´odigo 1.2 â€“ Primeiro Programa Modo de EdiÂ¸cËœao

1 print ( " Bem vindo ao Python " )

Depois de digitar print(â€œBem vindo ao pythonâ€) e apertar enter nËœao acontecerÂ´a
nada. A ï¬m de executarmos tal programa primeiro Â´e necessÂ´ario salvÂ´a-lo, seguindo os
passos: Run â†’ Run module â†’ Ok â†’ nome do arquivo â†’ Salvar ; apÂ´os isso,
instantaneamente aparecerÂ´a uma janela (modo interativo) mostrando o resultado do seu
programa. Tal procedimento Â´e ilustrado conforme Figuras 24, 25, 26 e 27.

Por ï¬m nossos programas terËœao o seguinte aspecto visual como o do CÂ´odigo 1.3
durante todo o trabalho. Tudo o que for digitado apÂ´os # serÂ´a ignorado pelo Python, sendo
considerado um comentÂ´ario.

32

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

Figura 24 â€“ Caminho para executar o
programa no modo de edi-
Â¸cËœao

Figura 25 â€“ â€œOkâ€ para salvar

Figura 26 â€“ Nomeando o arquivo

Figura 27 â€“ Resultado do programa

CÂ´odigo 1.3 â€“ Programa e resultado

1 print ( " Bem vindo ao Python " )

2 RESTART : # Coment Â´a rio : Abaixo segue o resultado do programa

3 Bem vindo ao Python

1.3 Python como calculadora

Podemos utilizar o Python como uma calculadora bem poderosa, pois suporta
nÂ´umeros tËœao grandes quanto a memÂ´oria do computador pode aguentar. Os sÂ´Ä±mbolos das
operaÂ¸cËœoes bÂ´asicas no Python sËœao +,âˆ’,*,/,**,// e %. Dados ğ‘, ğ‘ âˆˆ R, vemos, na Tabela
1, o que cada um desses sÂ´Ä±mbolos retorna quando acionado com os nÂ´umeros ğ‘ e ğ‘. JÂ´a no
CÂ´odigo 1.4, vemos como usar o Python como calculadora.

Tabela 1 â€“ OperaÂ¸cËœoes bÂ´asicas

SÂ´Ä±mbolo Comando

+
âˆ’
*
/
**
//
%

ğ‘ + ğ‘
ğ‘ âˆ’ ğ‘
ğ‘ * ğ‘
ğ‘/ğ‘
ğ‘ * * ğ‘
ğ‘//ğ‘
ğ‘%ğ‘

Retorna:
A soma
A subtraÂ¸cËœao
A multiplicaÂ¸cËœao
A divisËœao
A potË†encia
O quociente em Z
A resto da divisËœao em Z

CÂ´odigo 1.4 â€“ OperaÂ¸cËœoes MatemÂ´aticas

1 >>> 16+5 #

Ap Â´o s apertar Enter teremos exibido na tela a soma .

2 21

1.3. Python como calculadora

33

3 >>> 16 - 5 # A subtra Â¸c ~a o .

4 11

5 >>> 16 * 5 # O asterisco * , retorna a multiplica Â¸c ~a o .

6 80

7 >>> 16 * * 5 # Os * * representam a pot ^e ncia , aqui 16 est Â´a elevado a

5.

8 1048576

9 >>> 16/5 # A barra (/) retorna a divis ~a o .

10 3.2

11 >>> 16//5 # Duas (//) retornam o quociente da divis ~a o inteira .

12 3

13 >>> 16%5 # O s Â´Ä± mbolo (%) ( porcentagem ) retorna o resto da divis ~a o

inteira .

14 1

Â´E importante digitar os comandos apresentados no CÂ´odigo 1.4 com outros valores.
Uma opÂ¸cËœao para efetuar os CÂ´odigos Â´e acessando (Python ORG, 2018a), que nos encami-
nharÂ´a para uma versËœao do Python Shell online, caso se tenha conexËœao com a internet,
proporcionando uma aprendizagem dinË†amica em tempo real concomitante `a leitura.

âˆš

Caso se queira efetuar cÂ´alculos com valores, digamos mais especÂ´Ä±ï¬cos, como:
2, ğœ‹, ğ‘’, temos que importar, como no cÂ´odigo abaixo, a biblioteca math, tal biblio-
teca nos dÂ´a acesso a uma boa gama de conteÂ´udos matemÂ´aticos. Para maiores detalhes,
consultar (MENEZES, 2016; SUMMERFIELD, 2012; Python ORG, 2018b).

CÂ´odigo 1.5 â€“ 2

âˆš

2, ğœ‹ğ‘’ e ğ‘’ğœ‹

1 >>> import math # importando a biblioteca

2 >>> math . sqrt (2) # A ra Â´Ä± z quadrada de 2.

3 1.4142135623730951

4 >>> math . pi # A constante pi

5 3.141592653589793

6 >>> math . e # A constante e

7 2.718281828459045

8 >>> 2 * * ( math . sqrt (2) ) # Pot ^e ncia com expoente irracional

9 2.665144142690225

10 >>> math . pi * * ( math . e ) # Pi elevado a e

11 22.45915771836104

12 >>> math . e * * ( math . pi ) # e elevado a pi

13 23.140692632779263

Ainda explorando os recursos do Python como calculadora, podemos resolver
expressËœoes numÂ´ericas e atÂ´e calcular potË†encias relativamente grandes, como no CÂ´odigo 1.6:

34

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

CÂ´odigo 1.6 â€“ ExpressËœoes numÂ´ericas e 71000

1 >>> 2 * * 3+12/4 * 2 -10 # Uma express ~a o aritm Â´e tica simples

2 4.0

3 >>> 2 * * 3+12/(4 * 2 -10) # Observe o uso do par ^e nteses , alterando o

resultado

4 2.0

5 >>> 2 * * 3+12/4 * (2 -10)

6 -16.0

7 >>> 7 * * 1000 # C Â´a lculo de uma pot ^e ncia grande , cujo c Â´a lculo manual

Â´e invi Â´a vel

8 1 2 5 3 2 5 6 6 3 9 9 6 5 7 1 8 3 1 8 1 0 7 5 5 4 8 3 2 3 8 2 7 3 4 2 0 6 1 6 4 9 8 5 0 7 5 0 8 0 9 8 6 1 7 1 4 6 3 4 9 5 0 0 7

9 5 2 0 9 7 0 5 9 6 3 1 7 3 8 1 1 6 4 3 2 4 4 8 8 3 9 0 5 4 3 5 1 5 2 0 7 6 3 1 9 8 6 1 5 9 1 9 5 5 1 5 9 4 0 7 6 6 8 5 8 2 8 9 8

10 9 4 6 7 2 6 3 0 2 2 7 6 1 7 9 0 8 3 8 2 7 0 8 5 4 5 7 9 8 3 0 0 1 5 1 1 1 2 4 6 6 6 1 2 0 3 9 8 4 6 2 4 3 5 8 9 2 9 8 3 2 5 7 1

11 6 1 5 7 1 8 0 1 4 7 0 4 0 9 6 3 0 5 6 6 8 0 9 7 5 0 7 6 1 3 2 7 3 6 6 3 0 2 3 2 2 6 8 9 5 2 5 0 5 4 1 3 8 5 9 2 7 1 5 8 4 2 6 0

12 8 8 6 8 4 4 9 4 0 8 2 4 1 6 7 6 8 6 1 7 7 0 8 1 8 9 5 9 2 2 8 6 9 3 6 0 3 9 9 2 2 3 1 1 1 2 5 6 8 3 7 1 9 2 1 5 0 4 6 6 8 9 1 5

13 6 7 3 8 3 5 2 5 9 0 1 3 7 2 4 1 5 5 4 5 1 0 1 8 5 8 5 5 9 6 4 5 4 9 9 2 7 5 7 5 4 9 3 2 4 7 3 9 1 1 3 2 5 4 8 5 3 4 3 7 8 4 9 7

14 9 7 8 8 0 6 0 8 4 9 5 1 0 8 5 8 7 4 2 0 2 0 1 1 8 3 6 3 6 2 3 1 5 7 2 7 4 2 0 1 0 9 5 5 4 7 8 2 9 8 8 7 9 1 5 3 0 0 8 8 2 8 9 7

15 1 1 8 4 4 5 5 0 5 0 0 2 3 0 4 8 5 6 3 8 4 1 3 1 8 9 9 4 7 1 3 2 1 4 2 2 4 3 9 4 7 3 3 4 1 9 9 2 5 9 3 0 0 7 3 5 6 2 2 4 9 2 9 3

16 7 4 1 9 4 5 3 6 5 0 0 6 1 4 9 0 3 0 2 1 0 5 1 2 7 9 2 0 3 1 4 4 3 0 4 0 1 6 3 6 8 5 5 6 7 7 5 4 9 1 3 6 3 3 7 4 8 1 3 2 1 8 1 1

17 3 4 9 6 7 8 4 2 7 0 7 6 0 9 1 4 3 7 3 4 5 0 4 5 3 9 9 3 3 7 3 4 8 6 1 1 2 6 1 1 6 8 0 5 5 9 2 9 3 5 5 4 0 2 9 9 2 8 2 3 1 9 2 4

18 9 1 1 9 0 3 6 0 0 2 7 0 3 6 1 1 2 2 8 3 1 8 0 9 3 5 8 7 2 7 7 5 2 1 4 5 1 7 4 6 4 0 1 3 1 7 8 2 7 4 6 5 7 1 0 0 7 3 6 3 2 1 5 6

19 4 6 0 6 8 3 8 2 5 2 7 3 9 6 0 1 1 5 6 4 1 4 6 2 8 4 4 5 5 4 3 6 6 3 1 4 4 6 9 6 0 5 0 6 5 0 1 6 0 8 1 2 6 2 1 8 1 4 3 2 7 0 6 2

20 6 6 6 1 9 5 1 7 2 7 0 1 7 8 0 2 0 0 2 8 6 6 4 5 0 2 3 8 2 3 0 8 3 1 8 5 9 2 8 0 6 1 3 7 1 3 1 0 3 0 0 8 2 9 2 8 4 0 7 1 1 4 1 2

21 07731280600001

1.4 VariÂ´aveis

AtÂ´e agora estÂ´avamos digitando explicitamente os nÂ´umeros e realizando cÂ´alculos com
os mesmo atravÂ´es do Python, no entanto em termos de CÂ´odigo Â´e bem melhor utilizarmos
uma variÂ´avel (que pode ser uma letra ou um outro nome 1 qualquer).
O conteÂ´udo de uma variÂ´avel pode ser do tipo, inteiro (int), decimal (ï¬‚oat), palavra (string),
vetor (lista), etc. A vantagem de se utilizar variÂ´aveis Â´e que podemos manipulÂ´a-las dentro
de um cÂ´odigo (programa) e deixar explÂ´Ä±cita a lÂ´ogica de programaÂ¸cËœao por trÂ´as do algoritmo.

Vejamos exemplos de variÂ´aveis numÂ´ericas no Python Shell no CÂ´odigo 1.7.

1

o nome deve obrigatoriamente comeÂ¸car com uma letra, podem conter nÂ´umeros e o sÂ´Ä±mbolo

1.4. VariÂ´aveis

35

CÂ´odigo 1.7 â€“ Declarando e manipulando variÂ´aveis

1 >>> a = 3 # Declarando a vari Â´a vel a , e atribuindo - lhe o valor 3

2 >>> a

3 3

4 >>> 7+ a # Operando com a

5 10

6 >>> 6 * a # Outra opera Â¸c ~a o com a

7 18

8 >>> b =10 # Declarando b

9 >>> b

10 10

11 >>> a + b # Operando com a e b

12 13

13 >>> a * b

14 30

15 >>> a / b

16 0.3

17 >>> c =2 * a +3 * b # Definindo c em fun Â¸c ~a o de a e b

18 >>> c

19 36

20 >>> a + b + c

21 49

Nos exemplos ilustrados no CÂ´odigo 1.7, atribuÂ´Ä±mos valores numÂ´ericos `as variÂ´aveis. Contudo,
veremos que tambÂ´em Â´e possÂ´Ä±vel atribuir outros â€œobjetosâ€ `as variÂ´aveis. Por exemplo Â´e possÂ´Ä±vel
atribuir uma palavra ou cadeia de caracteres (string) a determinada variÂ´avel. Â´E importante
ressaltar que uma cadeia de caracteres no Python sempre deve estar especiï¬cada entre
aspas duplas ou simples.

Vejamos no CÂ´odigo 1.8 uma variÂ´avel do tipo cadeia de caractere e a funÂ¸cËœao, print
(jÂ´a usada no CÂ´odigo 1.1). O Python reconhece que a funÂ¸cËœao print deve ser executada,
mostrando na tela o que estava em seu argumento (ou seja o que estiver dentro dos
parË†enteses).

CÂ´odigo 1.8 â€“ VariÂ´avel do tipo string

1 >>> x = " Ol Â´a Python " # Declarando x do tipo cadeia de caractere

2 >>> print ( x ) # A fun Â¸c ~a o print imprimir Â´a o conte Â´u do da vari Â´a vel x

3 Ol Â´a Python

AlÂ´em de enviarmos mensagens, podemos operar com palavras: acessar qualquer

dos caracteres que a compËœoem, concatenar, fatiar e compor.

Supondo que temos uma variÂ´avel ğ‘¥ do tipo palavra, podemos saber o tamanho

36

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

(quantidade de caracteres) de ğ‘¥ atravÂ´es da funÂ¸cËœao len2, logo len(ğ‘¥)=â€œtamanho de ğ‘¥â€. Â´E
possÂ´Ä±vel tambÂ´em acessar cada caractere da palavra ğ‘¥ de acordo com a sua posiÂ¸cËœao ğ‘– por
meio do comando ğ‘¥[ğ‘–]. Ressaltamos que a primeira posiÂ¸cËœao Â´e interpretada como posiÂ¸cËœao zero,
caso a leitura da palavra seja da esquerda para a direita, com isso 0 â‰¤ ğ‘– â‰¤len(ğ‘¥)âˆ’1. Caso
leia-se ğ‘¥ da direita para a esquerda os Â´Ä±ndices ğ‘– serËœao negativos, com âˆ’len(ğ‘¥)â‰¤ ğ‘– â‰¤ âˆ’1.
Por exemplo, considere atribuÂ´Ä±da a palavra matemÂ´atica `a variÂ´avel ğ‘¥, ğ‘¥=â€˜matemÂ´aticaâ€™.
EntËœao, len(ğ‘¥)=10, ğ‘¥[3] = e, ğ‘¥[9] = a e ğ‘¥[âˆ’2] = c. A ï¬gura abaixo apresenta a posiÂ¸cËœao de
todos os caracteres:

ğ‘¥[âˆ’10] ğ‘¥[âˆ’9] ğ‘¥[âˆ’8] ğ‘¥[âˆ’7] ğ‘¥[âˆ’6] ğ‘¥[âˆ’5] ğ‘¥[âˆ’4] ğ‘¥[âˆ’3] ğ‘¥[âˆ’2] ğ‘¥[âˆ’1]

ğ‘¥ =

m

a

t

e

m

Â´a

t

i

c

a

ğ‘¥[0]

ğ‘¥[1]

ğ‘¥[2]

ğ‘¥[3]

ğ‘¥[4]

ğ‘¥[5]

ğ‘¥[6]

ğ‘¥[7]

ğ‘¥[8]

ğ‘¥[9]

Outra operaÂ¸cËœao possÂ´Ä±vel com uma variÂ´avel ğ‘¥ do tipo cadeia de caractere Â´e o
fatiamento. Por exemplo, o comando ğ‘¥[ğ‘– : ğ‘—] fatia a palavra ğ‘¥, nos retornando seus
caracteres entre as posiÂ¸cËœoes ğ‘– e ğ‘— âˆ’ 1, incluindo os caracteres nestas posiÂ¸cËœoes. Na tabela a
seguir temos alguns dos comandos de fatiamento:

Tabela 2 â€“ Fatiamento

Comando
ğ‘¥[ğ‘– : ğ‘—]
ğ‘¥[ğ‘– :]
ğ‘¥[: ğ‘—]
ğ‘¥[:]
ğ‘¥[:: âˆ’1]
ğ‘¥[:: 2]
ğ‘¥[:: âˆ’2]

Retorna a fatia
de ğ‘¥[ğ‘–] atÂ´e ğ‘¥[ğ‘— âˆ’ 1]
de ğ‘¥[ğ‘–] atÂ´e o Â´ultimo caractere
do primeiro atÂ´e ğ‘¥[ğ‘— âˆ’ 1]
toda a variÂ´avel ğ‘¥
ğ‘¥ de trÂ´as pra frente
de ğ‘¥[0] pra frente de 2 em 2
de ğ‘¥[âˆ’1] pra trÂ´as de 2 em 2

Supondo agora que tenhamos duas variÂ´aveis ğ‘¥ e ğ‘¦ do tipo cadeia de caractere, a

operaÂ¸cËœao ğ‘¥ + ğ‘¦ retorna a concatenaÂ¸cËœao de ğ‘¥ com ğ‘¦.

Abaixo um CÂ´odigo para melhor esclarecimento de tais operaÂ¸cËœoes.

CÂ´odigo 1.9 â€“ ConcatenaÂ¸cËœao e Fatiamento

1 >>> x = â€™ matem Â´a tica â€™ # Declarando x vari Â´a vel tipo string

2 >>> y = " computa Â¸c ~a o " # Declarando y

3 >>> len ( x ) # A fun Â¸c ~a o len retorna o tamanho de x

4 10

5 >>> print ( y [3]) # Acessando o caractere da terceira posi Â¸c ~a o de y

6 p

2 A funÂ¸cËœao len sÂ´o se aplica a variÂ´aveis tipo string ou lista

1.4. VariÂ´aveis

37

7 >>> print ( x + y ) # " Soma " de x com y , que Â´e interpretado como a

concatena Â¸c ~a o de x com y

8 matem Â´a ticacomputa Â¸c ~a o

9 >>> print ( y + x )

10 computa Â¸c ~a omatem Â´a tica

11 >>> x [0:4] # Fatia de x que vai de x [0] at Â´e x [3]

12 â€™ mate â€™

13 >>> y [6:] # Fatia de y que vai de y [6] at Â´e y [9] ( Â´u ltimo caractere )

14 â€™a Â¸c ~a o â€™

15 >>> x [:: -1] # Esse comando retorna x de tr Â´a s pra frente

16 â€™ acit Â´a metam â€™

17 >>> y [ -10: -5] # Fatia que vai de y [ -10] at Â´e y [ -6]

18 â€™ compu â€™

19 >>> x [::2] # Retorna de x [0] at Â´e o Â´u ltimo caractere de 2 em 2.

20 â€™ mtmtc â€™

21 >>> x [:: -2] # Percorre de tr Â´a s pra frente de 2 em 2 , come Â¸c ando em

x [ -1]

22 â€™ ai Â´a ea â€™

Finalmente, temos a composiÂ¸cËœao que Â´e uma operaÂ¸cËœao que permite compor ou
inserir numa mensagem variÂ´aveis designadas atravÂ´es de marcaÂ¸cËœoes. Por exemplo, na
mensagem: print(â€˜RogÂ´erio tem %d anos.â€™%ğ‘¥), temos que o sÂ´Ä±mbolo %d Â´e marcador dentro
da mensagem; tal marca serÂ´a substituÂ´Ä±da pelo valor da variÂ´avel ğ‘¥. No Python temos os
marcadores: %d para inteiros, %f para decimais (ï¬‚oat) e %s para palavras (strings).

No CÂ´odigo 1.10 apresentamos exemplos do uso de marcaÂ¸cËœoes dentro de um programa.

CÂ´odigo 1.10 â€“ Marcadores

1 >>> idade =38 # declarando a vari Â´a vel idade do tipo inteiro

2 >>> print ( " Rog Â´e rio tem % d anos " % idade ) # O % d ser Â´a trocado pelo

valor de idade , essa Â´e a composi Â¸c ~a o .

3 Rog Â´e rio tem 38 anos

4 >>> fruta = â€™ melancia â€™ # declarando a vari Â´a vel fruta do tipo string

5 >>> print ( " Rog Â´e rio tem % d anos e gosta de % s " %( idade , fruta ) )

6 Rog Â´e rio tem 38 anos e gosta de melancia

7 >>> # no exemplo acima % s foi trocado pelo " valor " de fruta

8 >>> nome = â€™ Rog Â´e rio â€™

9 >>> qtde =5

10 >>> vu =1.80

11 >>> print ( â€™% s comprou % d canetas por R$

%4.2 f â€™ %( nome , qtde , qtde * vu ) )

12 Rog Â´e rio comprou 5 canetas por R$ 9.00

13 >>> # O marcador % s foi trocado pelo valor da vari Â´a vel nome

38

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

14 >>> # O marcador % d pelo valor de qtde

15 >>> # O marcador %4.2 f foi trocado pelo valor de 5 * (1.80)

16 >>> # No %4.2 f , o 4 significa 4 caracteres , 2 casa decimais e f

float

Tratemos agora as variÂ´aveis lÂ´ogicas ou booleanas que sËœao True (verdadeiro) e False
(falso). Podemos declarar uma variÂ´avel como True ou False, mas geralmente estamos
interessados em realizar comparaÂ¸cËœoes lÂ´ogicas, com o uso de operadores relacionais. O
resultado dessas comparaÂ¸cËœoes sËœao sempre um valor lÂ´ogico (True ou False) que depende da
proposiÂ¸cËœao especiï¬cada. Os operadores relacionais do Python estËœao elencados na Tabela 3,
ilustrados no CÂ´odigo 1.11.

Tabela 3 â€“ Operadores relacionais

SÂ´Ä±mbolo ComparaÂ¸cËœao (Pergunta)

==
! =
>
<
>=
<=

igualdade
diferente
maior do que
menor do que
maior ou igual
menor ou igual

1 >>> a = True # Declarando a do tipo l Â´o gico ( booleana )

CÂ´odigo 1.11 â€“ Operadores relacionais

2 >>> b = False

3 >>> c =5

4 >>> d =10

5 >>> a == b # Perguntando se a Â´e igual a b .

6 False

7 >>> a != b # Perguntando se a Â´e diferente de b .

8 True

9 >>> c ==7

10 False

11 >>> c < d # Comparando c com d , neste caso , perguntando se c Â´e

menor que b .

12 True

13 >>> d >= 10 # Comparando b com 10; neste caso , perguntando se Â´e

maior ou igual a 10.

14 True

15 >>> d > 10 # Perguntando se d Â´e maior que 10.

16 False

17 >>> # Pode - se escrever a =2 ou a = 2 o Python entende as duas

formas

1.4. VariÂ´aveis

39

No Python, tambÂ´em Â´e possÂ´Ä±vel especiï¬car operadores lÂ´ogicos, que sËœao: not (nËœao),
and (e) e or (ou), conhecidos tambÂ´em como negaÂ¸cËœao (âˆ¼ ou Â¬), conjunÂ¸cËœao (âˆ§) e disjunÂ¸cËœao
(âˆ¨), respectivamente.

Sejam ğ‘ e ğ‘ proposiÂ¸cËœoes quaisquer. Pode-se formar outras proposiÂ¸cËœoes envolvendo

ğ‘, ğ‘ e os operadores lÂ´ogicos. Por exemplo: Â¬ğ‘ (not ğ‘), ğ‘ âˆ§ ğ‘ (ğ‘ and ğ‘) e ğ‘ âˆ¨ ğ‘ (ğ‘ or ğ‘).

As Tabelas 4, 5 e 6 apresentam os valores de verdade das proposiÂ¸cËœoes compostas
envolvendo proposiÂ¸cËœoes ğ‘ e ğ‘ a partir dos valores de verdade de ğ‘ e de ğ‘ e do operador
utilizado na construÂ¸cËœao da proposiÂ¸cËœao. O CÂ´odigo 1.12 exempliï¬ca o uso de tais operadores.

Tabela 4 â€“ not

ğ‘ not ğ‘
V
F

F
V

Tabela 5 â€“ and

ğ‘
ğ‘
V V
V F
F V
F F

ğ‘ and ğ‘
V
F
F
F

Tabela 6 â€“ or

ğ‘
ğ‘
V V
V F
F V
F F

ğ‘ or ğ‘
V
V
V
F

CÂ´odigo 1.12 â€“ Operadores lÂ´ogicos

1 >>> p = True

2 >>> q = False

3 >>> c =5

4 >>> d =10

5 >>> not p # A nega Â¸c ~a o de p

6 False

7 >>> p or q # A proposi Â¸c ~a o p ou q

8 True

9 >>> c !=5 and d ==10 # Proposi Â¸c ~a o composta usando o and , ser Â´a falsa

de acordo com a Tabela 5.

10 False

11 >>> c <5 or 2 * d > 18 # Proposi Â¸c ~a o composta usando o or , ser Â´a

verdadeira de acordo com a Tabela 6.

12 True

13 >>> ( d % c ==0 and d >=10) or ( not ( p and q ) ) # Uma proposi Â¸c ~a o mais

complexa ( express ~a o l Â´o gica )

14 True

Observe que a Â´ultima expressËœao lÂ´ogica do CÂ´odigo 1.12 Â´e um pouco mais complexa; e
existe uma ordem de prioridade a ser obedecida para determinar seu valor lÂ´ogico: primeiro
os (), segundo o not, terceiro o and e por Â´ultimo o or.

Diante de tal hierarquia resolvamos a expressËœao lÂ´ogica:

40

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

(d%c==0 and d>=10) or (not (p and q)) com p=True, q=False, c=5 e d=10

Como d%c==0 Â´e Verdadeira (V) pois 10 Â´e divisÂ´Ä±vel por 5, d>=10 Â´e V, pois d=10,

logo (d%c==0 and d>=10) Â´e V.

Como p and q Â´e F, logo (not (p and q)) Â´e V

Finalmente nossa expressËœao se resume em V or V que Â´e V.

De modo simpliï¬cado:

(V

and

(d%c==0 and d>=10) or
or
or
or
V

V )
V
V

and q))
(p
(V and F))

(not
(not
(not F)

V

Um outro tipo de variÂ´avel que usaremos serËœao as listas ou vetores. Podemos entender
uma lista como os vagËœoes de um trem, sendo que uma lista poder ter zero ou mais vagËœoes
e dentro dos mesmos seus elementos.

Uma lista L de ğ‘› elementos Â´e representada por L=[ğ‘¥0,ğ‘¥1,. . .,ğ‘¥ğ‘›âˆ’1], em que os
colchetes servem para indicar que L Â´e uma lista. Uma lista vazia em Python Â´e representada
por L=[ ]. Os elementos ğ‘¥ğ‘– de L podem ser palavras (strings), nÂ´umeros ou atÂ´e mesmo
outra lista. Por exemplo, seja L a lista com as vogais, ou seja, L=[â€˜aâ€™,â€˜eâ€™,â€˜iâ€™,â€˜oâ€™,â€˜uâ€™]. Os
elementos de L sËœao letras, mas como dito anteriormente, podemos ter elementos de outros
tipos, como, por exemplo, na lista W=[1,2,â€˜xâ€™,â€˜yâ€™,[â€˜aâ€™,â€˜bâ€™]] os dois primeiros elementos sËœao
nÂ´umeros inteiros, o terceiro e quarto sËœao letras e o Â´ultimo Â´e outra lista.

Seja L uma lista. Assim como nas palavras (strings), podemos usar a funÂ¸cËœao len
para descobrirmos o tamanho de L, podemos acessar qualquer elemento de L com o
comando L[i] , 0 â‰¤ ğ‘– â‰¤ len(L) âˆ’ 1 , e ainda, podemos fatiar L exatamente como na Tabela
1, ou seja, L[ğ‘–:ğ‘—] Â´e uma fatia de L que vai de L[ğ‘–] atÂ´e L[ğ‘— âˆ’ 1].

Agora, especiï¬camente para listas, podemos modiï¬car qualquer um de seus elemen-
tos, atribuindo novo valor ao elemento ğ‘–, por meio do comando L[ğ‘–]= novo valor. AlÂ´em disso,
podemos acrescentar um vagËœao ao ï¬nal de uma lista, atravÂ´es do mÂ´etodo append. De um
modo geral o mÂ´etodo append funciona da seguinte maneira: se L=[ğ‘¥0,ğ‘¥1,. . .,ğ‘¥ğ‘›âˆ’1] uma lista
com ğ‘› elementos, ao digitarmos L.append(ğ‘¥ğ‘›), L se modiï¬carÂ´a para L=[ğ‘¥0,ğ‘¥1,. . .,ğ‘¥ğ‘›âˆ’1, ğ‘¥ğ‘›]
passando a ter ğ‘› + 1 elementos.

Dadas listas L e W, L+W serÂ´a uma nova lista comeÂ¸cando no primeiro elemento
de L e terminando no Â´ultimo de W ordenadamente. Ressaltamos ainda que ğ‘›*L designa
. Abaixo segue um CÂ´odigo utilizando todos os recursos descritos
a lista L + L + . . . + L

âŸ

 â
ğ‘› vezes

acima.

CÂ´odigo 1.13 â€“ Listas e algumas operaÂ¸cËœoes

 
1.5. Entrada de Dados

41

1 >>> L =[ â€™a â€™ , â€™b â€™ , â€™c â€™ , â€™d â€™ , â€™e â€™] # declarando L , vari Â´a vel tipo lista

( vetor )

2 >>> L

3 [ â€™a â€™ , â€™b â€™ , â€™c â€™ , â€™d â€™ , â€™e â€™]

4 >>> len ( L ) # A fun Â¸c ~a o len retorna o tamanho da lista

5 5

6 >>> L [2] # Aqui estamos acessando um elemento da lista ( lembre - se

que a contagem das posi Â¸c oes inicia - se em zero )

7 â€™c â€™

8 >>> L [2]=15 # Atribuindo um novo valor a posi Â¸c ~a o 2 de L

9 >>> L

10 [ â€™a â€™ , â€™b â€™ , 15 , â€™d â€™ , â€™e â€™]

11 >>> L . append ( â€™f â€™) # O append insere uma nova entrada ao final de

L , cujo conte Â´u do Â´e f .

12 >>> L # Agora L ter Â´a tamanho 6 e L [5]= â€™ f â€™

13 [ â€™a â€™ , â€™b â€™ , 15 , â€™d â€™ , â€™e â€™ , â€™f â€™]

14 >>> print ( L +[ â€™g â€™ , â€™h â€™ ]) # Somando listas

15 [ â€™a â€™ , â€™b â€™ , 15 , â€™d â€™ , â€™e â€™ , â€™f â€™ , â€™g â€™ , â€™h â€™]

16 >>> print (2 * [3 ,4]) # Multiplicando uma lista por 2

17 [3 , 4 , 3 , 4]

18 >>> L [2:5] # Fatia de L da segunda at Â´e a quarta posi Â¸c ~a o

19 [15 , â€™d â€™ , â€™e â€™]

20 >>> L [:: -1] # Invertendo a lista

21 [ â€™h â€™ , â€™g â€™ , â€™f â€™ , â€™e â€™ , â€™d â€™ , 15 , â€™b â€™ , â€™a â€™]

1.5 Entrada de Dados

AtÂ´e aqui nossos pequenos programas jÂ´a vinham com valores fornecidos previamente
para as variÂ´aveis. No entanto podemos solicitar que um usuÂ´ario forneÂ¸ca dados (atravÂ´es do
teclado por exemplo), a ï¬m de executar um programa diversas vezes, sem alterar sua estru-
tura. A funÂ¸cËœao que permite a entrada de dados Â´e a input. Sua sintaxe Â´e input(â€™mensagem
solicitando ao usuÂ´ario um dadoâ€™)

Vejamos um exemplo acerca de entrada de dados no CÂ´odigo 1.14 .

CÂ´odigo 1.14 â€“ Entrada de Dados

1 x = input ( " Digite um n Â´u mero : " ) # x ter Â´a o valor que for digitado

2 print ( x )

3 RESTART : # Ap Â´o s o RESTART temos a execu Â¸c ~a o do programa

4 Digite um n Â´u mero :56

5 56

42

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

No programa do CÂ´odigo 1.14 tem-se que digitar um nÂ´umero e depois apertar a tecla enter
(caso contrÂ´ario o programa nËœao Â´e executado); no exemplo, foi digitado o 56.

Prosseguindo, vejamos outro programa com entrada de dados, no CÂ´odigo 1.15.

1 nome = input ( " Digite seu nome : " ) # Aqui a vari Â´a vel nome que

CÂ´odigo 1.15 â€“ Input e marcadores

depende da entrada

2 print ( " Muito prazer %s , bons estudos . " % nome )

3 RESTART :

4 Digite seu nome : Edilene

5 Muito prazer Edilene , bons estudos .

Â´E importante destacar o seguinte detalhe, se digitÂ´assemos no Programa 1.14 acima,
no lugar de nÂ´umero a palavra olÂ´a e no Programa 1.15 no lugar de nome o nÂ´umero 123,
por exemplo, os programas rodariam perfeitamente (se possÂ´Ä±vel, faÂ¸ca o teste). Isto ocorre
porque a funÂ¸cËœao input sempre retorna um valor do tipo cadeia de caractere (string) e
para contornar tal situaÂ¸cËœao devemos converter a entrada de dados de acordo com o tipo
que queremos para a variÂ´avel. O Programa 1.16 exempliï¬ca a situaÂ¸cËœao descrita acima.

CÂ´odigo 1.16 â€“ Entrada sem conversËœao

1 a = input ( " Digite o primeiro n Â´u mero : " )

2 b = input ( " Digite o segundo n Â´u mero : " )

3 print ( a + b )

4 RESTART :

# O print retornou a concatena Â¸c ~a o de 40 com 12

5 Digite o primeiro n Â´u mero : 40

6 Digite o segundo n Â´u mero : 12

7 4012

A conversËœao da entrada de dados Â´e algo bem interessante e bastante funcio-

nal.Vejamos algumas conversËœoes na tabela abaixo:

Tabela 7 â€“ ConversËœao de dados

Comando
x=int(input(â€™no: â€™))
x=ï¬‚oat(input(â€™no: â€™))
x=str(123)

Entrada
23
3.14
123

Retorna
23 tipo inteiro
3.14 tipo ï¬‚oat(decimal)
â€™123â€™ tipo string(caractere)

Nosso prÂ´oximo CÂ´odigo Â´e bem parecido com o CÂ´odigo 1.16, no entanto, com os

dados convertidos

1.6. Estruturas bÂ´asicas

43

CÂ´odigo 1.17 â€“ Entrada de dados com conversËœao

1 a = int ( input ( " Digite o primeiro n Â´u mero : " ) )

2 b = int ( input ( " Digite o segundo n Â´u mero : " ) )

3 print ( a + b )

4 RESTART :

# O print nessa caso retorna a soma de 40 com 12

5 Digite o primeiro n Â´u mero : 40

6 Digite o segundo n Â´u mero : 12

7 52

Observe que a conversËœao dos dados de entrada no CÂ´odigo 1.17 permite que o Python

entenda 40 e 12 como nÂ´umeros, o que nËœao ocorre no CÂ´odigo 1.16.

Podemos tambÂ´em converter nÂ´umeros em strings, caso o interesse seja aplicar um
mÂ´etodo especÂ´Ä±ï¬co para strings, para uma lista dos mÂ´etodos aplicÂ´aveis a string consultar
(SUMMERFIELD, 2012, p. 68-70).

1.6 Estruturas bÂ´asicas

Todos os programas atÂ´e aqui foram sequenciais, isto Â´e, executaram todas as linhas
uma apÂ´os a outra. No entanto isso nem sempre serÂ´a necessÂ´ario. Por vezes pode-se estar
interessado que uma parte do programa seja executada apenas se uma dada condiÂ¸cËœao for
verdadeira. Em Python a estrutura de decisËœao Â´e o if .

O if Â´e o nosso â€œseâ€, que pode ser entendido da seguinte forma: Se a condiÂ¸cËœao for

verdadeira faÂ¸ca algo. Essa condiÂ¸cËœao serÂ´a uma expressËœao lÂ´ogica e a estrutura do if serÂ´a:

if <condiÂ¸cËœao>:

comando 1
comando 2
...
comando n

Observe que apÂ´os a condiÂ¸cËœao do if temos o sÂ´Ä±mbolo :(dois pontos) e que os comandos de
1 atÂ´e n estËœao todos alinhados e um pouco `a direita e abaixo do if ; este recuo `a direita
Â´e chamado de identaÂ¸cËœao e caracteriza o bloco de comando(s) do Python, nesse caso da
estrutura if . Como dito anteriormente, tal bloco sÂ´o serÂ´a executado caso a condiÂ¸cËœao do if
seja verdadeira, caso contrÂ´ario serÂ´a ignorado na execuÂ¸cËœao do programa.

O prÂ´oximo Programa pedirÂ´a que o usuÂ´ario forneÂ¸ca dois nÂ´umeros e retornarÂ´a uma

mensagem dizendo qual foi o maior nÂ´umero.

44

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

CÂ´odigo 1.18 â€“ Estrutura condicional if

1 a = int ( input ( " Digite o primeiro n Â´u mero : " ) )

2 b = int ( input ( " Digite o segundo n Â´u mero : " ) )

3 if a > b : # A linha 4 s Â´o ser Â´a executada caso a > b seja verdadeiro

4

print ( â€™O primeiro n Â´u mero Â´e o maior â€™)

5 if b > a :

6

print ( â€™O segundo n Â´u mero Â´e o maior â€™)

7 RESTART : # Aqui Â´e o resultado do programa j Â´a na janela interativa

8 Digite o primeiro n Â´u mero : 35

9 Digite o segundo n Â´u mero : 98

10 O segundo n Â´u mero Â´e o maior

Vejamos outro Programa, usando if , que leia a velocidade de um carro, caso esteja
acima de 80 km/h, calcule uma multa de R$ 5,00 por km/h quando o veÂ´Ä±culo estÂ´a nestas
condiÂ¸cËœoes e emita uma mensagem dizendo que o carro foi multado e o respectivo valor de
multa.

CÂ´odigo 1.19 â€“ Estrutura condicional if

1 v = int ( input ( â€™ Qual a velocidade do carro ? â€™) )

2 if v > 80:

3

4

m = 5 * (v -80)

print ( " Voc ^e foi multado , sua multa foi de %5.2 f " % m )

5 RESTART :

6 Qual a velocidade do carro ? 85

7 Voc ^e foi multado , sua multa foi de R$ 25.00

Pode-se usar vÂ´arios if â€™s no mesmo Programa, no entanto quando temos uma
condiÂ¸cËœao complementar ao if podemos fazer uso de outra palavra reservada do Python
que Â´e o else. Por exemplo, no Programa 1.19 caso a velocidade seja menor ou igual a 80,
podemos usar o else para emitir uma mensagem ao usuÂ´ario. Tal situaÂ¸cËœao Â´e exempliï¬cada
no Programa 1.20.

CÂ´odigo 1.20 â€“ Uso do else

1 v = int ( input ( â€™ Qual a velocidade do carro ? â€™) )

2 if v > 80:

3

4

m = 5 * (v -80)

print ( " Voc ^e foi multado , sua multa foi de %5.2 f " % m )

5 else :

6

print ( " Parab Â´e ns ! Voc ^e est Â´a no limite permitido " )

7 RESTART :

8 Qual a velocidade do carro ? 80

9 Parab Â´e ns ! Voc ^e est Â´a no limite permitido

1.6. Estruturas bÂ´asicas

45

Outra estrutura muito importante Â´e a de repetiÂ¸cËœao (laÂ¸co), que Â´e usada para executar
a mesma parte de um programa vÂ´arias vezes enquanto uma condiÂ¸cËœao for verdadeira. Uma
das estruturas de repetiÂ¸cËœao do Python Â´e o while, cujo formato Â´e:

while<condiÂ¸cËœao>:
comando 1
comando 2
...
comando n

Por exemplo, se quisermos um Programa que imprima todos os nÂ´umeros naturais de 1 atÂ´e
10, podemos utilizar um while, como no Programa 1.21:

CÂ´odigo 1.21 â€“ Estrutura while

1 x =1 # declarando a vari Â´a vel x e atribuindo - lhe valor 1

2 while x <=10: # As linhas 3 e 4 ser ~a o executadas enquanto x <=10

3

4

print ( x )

x = x +1 # aqui um novo conceito , o contador , incrementa - se a x

uma unidade a cada execu Â¸c ~a o

5 RESTART :

6 1

7 2

8 3

9 4

10 5

11 6

12 7

13 8

14 9

15 10

Observe que ğ‘¥, a cada vez que o laÂ¸co se repetia, era acrescido do valor constante
1; quando isso ocorre com uma variÂ´avel em um programa, tal variÂ´avel recebe o nome de
contador.

Quando o valor que uma variÂ´avel vai recebendo durante a execuÂ¸cËœao de um programa

varia, estamos diante de um acumulador.

Observe tambÂ´em que os valores impressos na saÂ´Ä±da estËœao na vertical, isto Â´e, o print
imprime um nÂ´umero e salta uma linha, atÂ´e o laÂ¸co ï¬ndar. Caso queiramos apresentar a
saÂ´Ä±da dos nÂ´umeros na horizontal, podemos criar um vetor para receber cada valor de ğ‘¥ e
depois imprimir tal vetor conforme CÂ´odigo 1.22.

46

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

CÂ´odigo 1.22 â€“ Programa usando while com vetor de saÂ´Ä±da

1 x =1

2 n Â´u meros =[]

3 while x <=10:

4

5

n Â´u meros . append ( x )

x = x +1

6 print ( n Â´u meros )

7 RESTART :

8 [1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10]

Uma outra alternativa seria usar o comando print(ğ‘¥, end=â€œ â€). Tal comando
imprime todos os valores de ğ‘¥ gerados no laÂ¸co da estrutura de repetiÂ¸cËœao em linha horizontal,
como ilustra o cÂ´odigo abaixo:

CÂ´odigo 1.23 â€“ Imprimindo em linha

1 x =1

2 while x <=10:

3

4

print (x , end = " " )

x = x +1

5 RESTART :

6 1 2 3 4 5 6 7 8 9 10

Podemos fazer variaÂ¸cËœoes do Programa 1.22 como: listar todos os nÂ´umeros pares (ou
Â´Ä±mpares) atÂ´e 30, ou atÂ´e um dado ğ‘› âˆˆ N fornecido pelo usuÂ´ario; exibir apenas os mÂ´ultiplos
de 3, dentre outras. Enï¬m, sËœao vÂ´arias as possibilidades tanto usando o if quanto o while
que propiciam atacar vÂ´arios problemas, buscando um programa que os solucione.

O Programa 1.24 a seguir, pedirÂ´a ao usuÂ´ario que forneÂ¸ca um nÂ´umero (natural) e

exibirÂ´a todos os nÂ´umeros pares atÂ´e o nÂ´umero fornecido.

1 n = int ( input ( â€™ Digite um n Â´u mero : â€™) )

CÂ´odigo 1.24 â€“ Pares atÂ´e um certo n

2 x =0

3 pares = []

4 while x <= n :

5

6

pares . append ( x )

x = x +2

7 print ( â€™ Todos os pares at Â´e % d s ~a o â€™%n , pares )

8 RESTART : Abaixo uma execu Â¸c ~a o quando o n = 10

9 Digite um n Â´u mero : 10

10 Todos os pares at Â´e 10 s ~a o [0 , 2 , 4 , 6 , 8 , 10]

1.6. Estruturas bÂ´asicas

47

Para efeito de treinamento, faÂ¸camos um programa que leia 10 nÂ´umeros fornecidos
pelo usuÂ´ario e retorne a mÂ´edia dos 10 nÂ´umeros. Nesse programa serËœao usados tanto contador
quanto acumulador.

CÂ´odigo 1.25 â€“ MÂ´edia de 10 nÂ´umeros fornecidos pelo usuÂ´ario

1 n = 1 # Aqui nosso contador

2 s = 0 # Aqui nosso acumulador

3 while n <=10:

4

5

6

x = int ( input ( " Digite o % d o n Â´u mero : " % n ) )
s = s + x

n = n +1

7 print ( " A m Â´e dia dos 10 n Â´u meros fornecidos Â´e %5.2 f " %( s /10) )

8 RESTART :
9 Digite o 1 o n Â´u mero : 1
10 Digite o 2 o n Â´u mero : 2
11 Digite o 3 o n Â´u mero : 3
12 Digite o 4 o n Â´u mero : 4
13 Digite o 5 o n Â´u mero : 5
14 Digite o 6 o n Â´u mero : 6
15 Digite o 7 o n Â´u mero : 7
16 Digite o 8 o n Â´u mero : 8
17 Digite o 9 o n Â´u mero : 9
18 Digite o 10 o n Â´u mero : 10
19 A m Â´e dia dos 10 n Â´u meros fornecidos Â´e

5.50

Observe que a variÂ´avel s acumula (somando) todos os 10 valores inseridos pelo
usuÂ´ario, enquanto que a variÂ´avel n vai incrementando seu valor de 1 em 1, ou seja n Â´e um
contador.

Podemos entender que um contador Â´e um caso particular de acumulador no qual

acumula sempre um mesmo valor constante.

`As vezes Â´e necessÂ´ario colocar uma estrutura dentro de outra em um programa. Tal
procedimento chama-se â€aninharâ€; entËœao em estruturas aninhadas temos um if dentro de
outro if , ou um while dentro de outro while, ou um if dentro de um while e vice-versa.

FaÂ¸camos um programa que calcule o valor da conta telefË†onica de acordo com os
minutos gastos se a empresa oferece os seguintes planos: abaixo de 100 minutos cobra R$
0,40 o minuto; entre 100 e 200 minutos cobra R$ 0,35 por minuto; acima de 200 minutos
cobra R$ 0,20 por minuto.

CÂ´odigo 1.26 â€“ Conta telefË†onica

1 min = int ( input ( " Quantos minutos voc ^e utilizou esse m ^e s ?

" ) )

2 if min < 100:

48

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

3

p = 0.40

4 else :

5

6

7

8

if min < 200: # Esse if est Â´a aninhado ( dentro ) do else

p = 0.35

else : # esse else est Â´a aninhado no else da linha 4

p = 0.20

9 print ( " Sua conta esse m ^e s ser Â´a de R$ %6.2 f " %( min * p ) )

10 RESTART :

11 Quantos minutos voc ^e utilizou esse m ^e s ?

150

12 Sua conta esse m ^e s ser Â´a de R$

52.50

Podemos tambÂ´em substituilr um par else e if pela palavra reservada elif . Esteti-
camente utilizar o elif Â´e interessante quando o programa apresenta muitos pares else e if .
O cÂ´odigo a seguir Â´e praticamente idË†entico ao CÂ´odigo 1.26, exceto pelo uso do elif

CÂ´odigo 1.27 â€“ Conta telefË†onica, uso do elif

1 min = int ( input ( " Quantos minutos voc ^e utilizou esse m ^e s ?

" ) )

2 if min < 100:

3

p = 0.40

4 elif min < 200: # elif substituindo um else e if

5

p = 0.35

6 else :

7

p = 0.20

8 print ( " Sua conta esse m ^e s ser Â´a de R$ %6.2 f " %( min * p ) )

9 RESTART :

10 Quantos minutos voc ^e utilizou esse m ^e s ?

150

11 Sua conta esse m ^e s ser Â´a de R$

52.50

No CÂ´odigo 1.28, temos mais um exemplo de estruturas aninhadas. Tal programa
exibe a tabuada de multiplicaÂ¸cËœao do 1 ao 10, para isso vamos usar um while dentro de
um while.

CÂ´odigo 1.28 â€“ Tabuada de MultiplicaÂ¸cËœao

1 tabuada =1

2 while tabuada <=10:

3

4

5

6

7

n Â´u mero = 1

while n Â´u mero <=10: # while aninhado com while

print ( " % d x % d = % d " %( tabuada , n Â´u mero , tabuada * n Â´u mero ) )

n Â´u mero +=1 # abrevia Â¸c ~a o de n Â´u mero = n Â´u mero +1

tabuada +=1

8 # A sa Â´Ä± da desse programa n ~a o ser Â´a apresentada , rode - o e entenda o

porqu ^e .

1.6. Estruturas bÂ´asicas

49

Outra palavra reservada bem Â´util Â´e o break. O break Â´e uma instruÂ¸cËœao que forÂ¸ca
a parada do laÂ¸co de um while. Por exemplo, se quisermos escrever um programa que
imprima a soma dos nÂ´umeros digitados por um usuÂ´ario, onde tal usuÂ´ario digita tantos
nÂ´umeros quanto queira, parando a soma apenas quando o 0 (zero) for digitado, daÂ´Ä± temos
o nÂ´umero 0 como condiÂ¸cËœao de parada (break).

CÂ´odigo 1.29 â€“ Soma dos n valores fornecidos, uso do break

1 s =0

2 while True : # esse while roda infinitamente

3

4

5

6

n = int ( input ( " Digite um n Â´u mero para somar ou 0 para sair : " ) )

if n == 0: # um if aninhado dentro do while

break

s = s + n # s acumulando todos os valores digitados

7 print ( " A soma de todos os n Â´u meros digitados Â´e % d " % s )

8 RESTART :

9 Digite um n Â´u mero para somar ou 0 para sair : 3

10 Digite um n Â´u mero para somar ou 0 para sair : 5

11 Digite um n Â´u mero para somar ou 0 para sair : 7

12 Digite um n Â´u mero para somar ou 0 para sair : 6

13 Digite um n Â´u mero para somar ou 0 para sair : 0

14 A soma de todos os n Â´u meros digitados Â´e 21

Dando continuidade `as estruturas bÂ´asicas, temos no Python uma estrutura muito
interessante quando queremos percorrer os elementos de uma lista (vetor), tal estrutura Â´e
o for.

Sua sintaxe Â´e a seguinte:

for nome da variÂ´avel in lista:

comando 1
comando 2
...
comando n

Ele funciona como se fosse um while; enquanto a variÂ´avel estÂ´a percorrendo os

elementos da lista ele executa o bloco de comandos.

Vejamos um programa usando o for que imprima os cinco primeiros quadrados

perfeitos :

CÂ´odigo 1.30 â€“ Quadrados usando o for

1 for i in [1 ,2 ,3 ,4 ,5]: # a vari Â´a vel i assumir Â´a os valores de 1 a 5

2

print ( i * * 2)

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

50

3 RESTART :

4 1

5 4

6 9

7 16

8 25

O for Â´e muito interessante para lidarmos com listas nÂ´umericas. No entanto, nËœao Â´e

muito prÂ´atico digitar explÂ´Ä±citamente uma lista como no Programa 1.30.

Para gerar uma lista numÂ´erica vamos usar o comando list(range(n))=[0,1,2,...,n-1].
A Tabela 8 ilustra os comandos bÂ´asicos das listas com range e o CÂ´odigo 1.31 exempliï¬ca o
uso de cada um destes comandos.

Tabela 8 â€“ Listas numÂ´ericas com list e range

Comando
list(range(n))
list(range(p,n))
list(range(p,n,k))

Retorna
[0,1,2,...,n-1]
[p,p+1,p+2,...,n-1]
[p,p+k,p+2k,...,p+lk]

com p+lk < n

CÂ´odigo 1.31 â€“ Listas com list e range

1 v_1 = list ( range (10) )

2 v_2 = list ( range (5 ,10) )

3 v_3 = list ( range (1 ,10 ,2) )

4 print ( v_1 , â€™\ n â€™ ,v_2 , â€™\ n â€™ , v_3 ) # O \ n serve para pular linha dentro

do print

5 RESTART :

6 [0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9]

7 [5 , 6 , 7 , 8 , 9]

8 [1 , 3 , 5 , 7 , 9]

Utilizando o for podemos criar listas mais especÂ´Ä±ï¬cas, como os primeiros 10 cubos

positivos, como no CÂ´odigo 1.32.

CÂ´odigo 1.32 â€“ Dez primeiros cubos

1 cubos =[]

2 for i in range (1 ,11) : # intervalo de 1 at Â´e 10

3

cubos . append ( i * * 3)

4 print ( â€™ Os dez primeiros cubos positivos s ~a o : \ n â€™ , cubos )

5 RESTART :

6 Os dez primeiros cubos positivos s ~a o :

7 [1 , 8 , 27 , 64 , 125 , 216 , 343 , 512 , 729 , 1000]

1.6. Estruturas bÂ´asicas

51

Encerraremos este capÂ´Ä±tulo com o conceito de funÂ¸cËœoes. O Python jÂ´a possui algumas

funÂ¸cËœoes prÂ´e-deï¬nidas, por exemplo len, input, print, dentre outras outras.

A ideia Â´e criar outras funÂ¸cËœoes, cujo processo funcionarÂ´a basicamente da seguinte
forma: deï¬niremos uma funÂ¸cËœao de uma ou mais variÂ´aveis e, dentro da deï¬niÂ¸cËœao da mesma,
tem-se cÂ´odigos que farËœao com que a funÂ¸cËœao retorne algum valor (podendo ocorrer de criar-se
funÂ¸cËœoes que nËœao precisem de parË†ametros e/ou nËœao retornem nada). Sua sintaxe Â´e:

def nome da funÂ¸cËœao(parametros):

comando 1
comando 2
...
comando n
return expressËœao

Vamos criar uma funÂ¸cËœao que retorne a soma de dois nÂ´umeros, conforme CÂ´odigo 1.33.

CÂ´odigo 1.33 â€“ FunÂ¸cËœao soma

1 def soma (x , y ) :

2

return x + y

3 print ( soma (10 ,90) )

4 RESTART :

5 100

6 >>> soma (5 ,11) # chamando a fun Â¸c ~a o interativamente

7 16

8 >>> soma (1.3 ,2.7)

9 4.0

10 >>> soma ( -1 , -8)

11 -9

Vejamos outra funÂ¸cËœao que diz se um dado natural Â´e par.

CÂ´odigo 1.34 â€“ FunÂ¸cËœao par

1 def epar ( n ) :

2

3

4

5

if n %2==0:

return True

else :

return False

6 RESTART :

7 >>> epar (1)

8 False

9 >>> epar (4)

10 True

52

CapÂ´Ä±tulo 1. Uma breve introduÂ¸cËœao ao Python

No prÂ´oximo capÂ´Ä±tulo utilizaremos, conforme a necessidade, os comandos aqui apre-
sentados com o intuito de resolver alguns problemas de matemÂ´atica atravÂ´es de programas
na linguagem Python.

53

CapÂ´Ä±tulo 2

AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em
Python

Vamos apresentar neste capÂ´Ä±tulo alguns resultados que envolvem nÂ´umeros naturais
(denotado por N), no intuito de implementÂ´a-los com a linguagem Python. Apresentaremos
por exemplo: a divisËœao euclidiana, o algoritmo de Euclides1, o Crivo de EratÂ´ostenes, dentre
outros. Tais resultados, apesar de milenares, se mostram como algoritmos bastante eï¬cazes
quando implementados.

2.1 DivisËœao Euclidiana

Comecemos com a deï¬niÂ¸cËœao de divisibilidade entre dois nÂ´umeros naturais.

Deï¬niÂ¸cËœao 2.1 (Divisibilidade). Dados ğ‘,ğ‘, âˆˆ N, com ğ‘ Ì¸= 0, dizemos que ğ‘ divide ğ‘ se
existir ğ‘ âˆˆ N tal que ğ‘ = ğ‘ Â· ğ‘. Denotamos ğ‘ divide ğ‘ por ğ‘|ğ‘.

Por exemplo: 5|10 pois existe 2 âˆˆ N tal que 10 = 5 Â· 2. Quando ğ‘|ğ‘, diz-se que ğ‘ Â´e

um mÂ´ultiplo de ğ‘ ou ğ‘ Â´e divisÂ´Ä±vel por ğ‘.

Ocorre que nem sempre ğ‘ dividirÂ´a ğ‘, mas pode-se sempre fazer a divisËœao de ğ‘ por ğ‘
deixando algum resto, este Â´e o conteÂ´udo do teorema a seguir, a DivisËœao Euclidiana, o qual
Euclides jÂ´a utilizava nos Elementos2.

Antes de enunciar o Teorema da DivisËœao Euclidiana, vamos assumir como axioma

o PrincÂ´Ä±pio da Boa Ordem:

Axioma 2.1 (Boa Ordem). Todo subconjunto nËœao vazio de N possui um menor elemento.

1 MatemÂ´atico grego que viveu por volta de 300 a.C. e escritor da inestimÂ´avel obra Os Elementos
2 Uma das obras mais importantes da matemÂ´atica, composta por 13 livros onde se reunia praticamente

todo conhecimento matemÂ´atico da Â´epoca

54

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

Teorema 2.1 (DivisËœao Euclidiana). Dados ğ‘, ğ‘ âˆˆ N com 0 < ğ‘ < ğ‘. Existem dois Â´unicos
naturais ğ‘ e ğ‘Ÿ tais que:

ğ‘ = ğ‘ğ‘ + ğ‘Ÿ

com ğ‘Ÿ < ğ‘

DemonstraÂ¸cËœao. ExistË†encia: Considere a sequË†encia ğ‘† de nÂ´umeros naturais

ğ‘† = (ğ‘, ğ‘ âˆ’ ğ‘, . . . , ğ‘ âˆ’ ğ‘› Â· ğ‘, . . .)

Pelo Axioma 2.1 tal sequË†encia nËœao pode decrescer inï¬nitamente, uma vez que caracteriza
um subconjunto nËœao vazio de N; logo ğ‘† possuirÂ´a um menor elemento ğ‘Ÿ, digamos ğ‘Ÿ = ğ‘âˆ’ğ‘ Â·ğ‘.
Note que se ğ‘Ÿ < ğ‘ teremos mostrado a existË†encia de ğ‘ e ğ‘Ÿ como estÂ´a no enunciado do
Teorema.

De fato, ğ‘Ÿ < ğ‘, pois caso ğ‘Ÿ > ğ‘ terÂ´Ä±amos ğ‘Ÿ âˆ’ ğ‘ > 0 âˆˆ ğ‘†; isto contraria o fato de ğ‘Ÿ

ser o mÂ´Ä±nimo de ğ‘†. Logo ğ‘ = ğ‘ğ‘ + ğ‘Ÿ com ğ‘Ÿ < ğ‘.

Unicidade: Suponha que existam ğ‘Ÿâ€² e ğ‘â€² tais que ğ‘ = ğ‘ğ‘â€² + ğ‘Ÿâ€² com ğ‘Ÿâ€² < ğ‘. Segue
que ğ‘Ÿ â‰¤ ğ‘Ÿâ€² < ğ‘ e 0 â‰¤ ğ‘Ÿâ€² âˆ’ ğ‘Ÿ < ğ‘. Da igualdade 0 = ğ‘ âˆ’ ğ‘ = ğ‘ğ‘â€² + ğ‘Ÿâ€² âˆ’ (ğ‘ğ‘ + ğ‘Ÿ) temos
que (ğ‘ âˆ’ ğ‘â€²)ğ‘ = ğ‘Ÿâ€² âˆ’ ğ‘Ÿ =â‡’ ğ‘|ğ‘Ÿâ€² âˆ’ ğ‘Ÿ =â‡’ ğ‘Ÿâ€² âˆ’ ğ‘Ÿ = 0 jÂ´a que ğ‘ > ğ‘Ÿâ€² âˆ’ ğ‘Ÿ. Portanto ğ‘Ÿâ€² = ğ‘Ÿ e
consequentemente ğ‘â€² = ğ‘.

Por exemplo:

Caso ğ‘ = 37 e ğ‘ = 7 temos ğ‘ = 5 e ğ‘Ÿ = 2, pois 37 = 7 Â· 5 + 2;

Caso ğ‘ = 89 e ğ‘ = 13 temos ğ‘ = 6 e ğ‘Ÿ = 11, pois 89 = 13 Â· 6 + 11.

Observemos que a demonstraÂ¸cËœao acima nos fornece um algoritmo para dividir dois
nÂ´umeros naturais, vejamos a implementaÂ¸cËœao de um programa em Python que nos retorne
o quociente e o resto da divisËœao de dois naturais fornecidos pelo usuÂ´ario.

CÂ´odigo 2.1 â€“ DivisËœao Euclidiana

1 b = int ( input ( " digite o valor de b : " ) )

2 a = int ( input ( " digite o valor de a : " ) )

3 q , r =0 ,0 # q e r s ~a o quociente e resto respectivamente

4 if b >= a :

5

6

7

8

while b - q *a >= a :

q = q +1

r =b - q * a

print ( " Na divis ~a o de % d por %d , temos quociente % d e resto

% d " %( b ,a ,q , r ) )

9 else :

10

print ( " Na divis ~a o de % d por %d , temos quociente % d e resto

% d " %( b ,a ,q , b ) )

11 RESTART :

2.2. Bases numÂ´ericas

55

12 digite o valor de b : 37

13 digite o valor de a : 7

14 Na divis ~a o de 37 por 7 , temos quociente 5 e resto 2

Alternativamente poderÂ´Ä±amos calcular o quociente e o resto atravÂ´es das operaÂ¸cËœoes

// e %, como no programa abaixo:

CÂ´odigo 2.2 â€“ DivisËœao Euclidiana com operaÂ¸cËœoes

1 b = int ( input ( â€™ Digite o valor de b : â€™) )

2 a = int ( input ( â€™ Digite o valor de a : â€™) )

3 q = b // a

4 r = b % a

5 print ( â€™ Na divis ~a o de % d por %d , temos quociente % d e resto

% d â€™ %( b ,a ,q , r ) )

6 RESTART :

7 Digite o valor de b : 46

8 Digite o valor de a : 7

9 Na divis ~a o de 46 por 7 , temos quociente 6 e resto 4

Contudo, como pretende-se fazer uma conexËœao entre as demonstraÂ¸cËœoes dos resultados
e sua implementaÂ¸cËœao, acreditamos que, didaticamente, o CÂ´odigo 2.1 Â´e mais interessante.

2.2 Bases numÂ´ericas

VÂ´arias civilizaÂ¸cËœoes criaram maneiras de organizar a forma como representariam suas
quantidades para atender diversas demandas. Tais maneiras sËœao conhecidas como sistemas
de numeraÂ¸cËœao, dentre os quais podemos citar: Romano, Maia, EgÂ´Ä±pcio, dentre outros.
Atualmente o sistema universalmente utilizado para representar nÂ´umeros Â´e o decimal
posicional.

Esse sistema de numeraÂ¸cËœao que Â´e uma variante do sistema sexagesimal
utilizado pelos babilË†onios 1700 anos antes de Cristo, foi desenvolvido
na China e na Â´India. Existem documentos do sÂ´eculo VI comprovando a
utilizaÂ¸cËœao desse sistema. Posteriormente, foi se espalhando pelo Oriente
MÂ´edio, por meio das caravanas, tendo encontrado grande aceitaÂ¸cËœao entre
os povos Â´arabes. A introduÂ¸cËœao do sistema decimal na Europa foi tardia
por causa dos preconceitos da Idade MÂ´edia. Por exemplo, num documento
de 1299, os banqueiros de FlorenÂ¸ca condenavam seu uso. (SIDKI, 1975,
p.7)

No sistema decimal todo nÂ´umero Â´e formado por uma sequË†encia dos algarismos:

0, 1, 2, 3, 4, 5, 6, 7, 8, 9

Como sËœao dez algarismos daÂ´Ä± o nome decimal (base 10), posicional pois a posiÂ¸cËœao do
algarismo na sequË†encia que forma o nÂ´umero lhe atribui um peso (potË†encia de 10) diferente.

56

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

Por exemplo, 23 = 2 Â· 101 + 3 Â· 100 e 32 = 3 Â· 101 + 2 Â· 100; portanto, a posiÂ¸cËœao em que os
nÂ´umeros 2 e 3 se apresentam Â´e importante.

De uma maneira geral, o nÂ´umero ğ‘ğ‘› ğ‘ğ‘›âˆ’1 . . . ğ‘2 ğ‘1 ğ‘0 no sistema decimal Â´e o mesmo

que ğ‘ğ‘› Â· 10ğ‘› + ğ‘ğ‘›âˆ’1 Â· 10ğ‘›âˆ’1 + . . . + ğ‘2 Â· 102 + ğ‘1 Â· 101 + ğ‘0 Â· 100 com ğ‘› âˆˆ N e 0 â‰¤ ğ‘ğ‘– â‰¤ 9.

Outro sistema que convÂ´em destacar Â´e o binÂ´ario (base 2) usado na computaÂ¸cËœao.

Futuramente, exempliï¬caremos tal sistema.

Tanto o sistema decimal quanto o binÂ´ario sËœao posicionais e de base constante. Na
verdade, dados dois nÂ´umeros ğ‘ e ğ‘ > 1 arbitrÂ´arios podemos sempre escrever ğ‘ na base ğ‘. O
modo de fazË†e-lo se baseia no Teorema da MudanÂ¸ca de Base que Â´e uma aplicaÂ¸cËœao da divisËœao
euclidiana. Contudo, para provÂ´a-lo, iremos fazer uso do Segundo PrincÂ´Ä±pio de InduÂ¸cËœao que
serÂ´a demonstrado abaixo.

Teorema 2.2 (Segundo PrincÂ´Ä±pio de InduÂ¸cËœao). Sejam ğ‘ƒ (ğ‘›) uma propriedade referente
a nÂ´umeros naturais, ğ‘› âˆˆ N, e ğ‘ um nÂ´umero natural. Se ğ‘ƒ (ğ‘) Â´e verdadeira e, se para
ğ‘ â‰¤ ğ‘˜ < ğ‘›, a validade de ğ‘ƒ (ğ‘˜) implicar a veracidade de ğ‘ƒ (ğ‘›), entËœao ğ‘ƒ (ğ‘›) serÂ´a verdadeira
para todo natural ğ‘› â‰¥ ğ‘.

DemonstraÂ¸cËœao. Considere o conjunto ğ‘‰ = {ğ‘› âˆˆ N; ğ‘ƒ (ğ‘›) verdadeira} queremos provar que
ğ‘‰ = N. Suponha por absurdo que ğ‘‰ Ì¸= N, daÂ´Ä± Nâˆ–ğ‘‰ Ì¸= âˆ…. Logo, pelo Axioma 2.1 existe o
menor elemento ğ‘˜ âˆˆ Nâˆ–ğ‘‰ , ou seja ğ‘˜ Â´e o menor natural para o qual nËœao vale ğ‘ƒ , o que quer
dizer que ğ‘ƒ vale para todos os naturais menores que ğ‘˜ implicando ğ‘ƒ (ğ‘˜) ser verdadeira, o
que Â´e um absurdo. Portanto ğ‘‰ = N.

Agora temos condiÂ¸cËœoes de demonstrar o Teorema da MudanÂ¸ca de Base.

Teorema 2.3 (MudanÂ¸ca de Base). Dados a, b âˆˆ N, com b > 1, existem nÂ´umeros naturais
ğ‘0, ğ‘1,. . . ,ğ‘ğ‘› menores do que b, univocamente determinados, tais que a = ğ‘0 + ğ‘1ğ‘ + ğ‘2ğ‘2 +
. . . + ğ‘ğ‘›ğ‘ğ‘›.

DemonstraÂ¸cËœao. A demonstraÂ¸cËœao serÂ´a por induÂ¸cËœao em ğ‘. Note que, se ğ‘ = 0, basta tomar
ğ‘ğ‘– = 0, 0 â‰¤ ğ‘– â‰¤ ğ‘›. Nossa hipÂ´otese de induÂ¸cËœao Â´e que todo natural menor do que ğ‘ tem
representaÂ¸cËœao ğ‘‘0 + ğ‘‘1ğ‘ + ğ‘‘2ğ‘2 + . . . + ğ‘‘ğ‘˜ğ‘ğ‘˜ em que ğ‘˜ e cada ğ‘‘ğ‘– sËœao naturais e cada ğ‘‘ğ‘– < ğ‘ Â´e
Â´unico.

Aplicando a divisËœao euclidiana para ğ‘ e ğ‘ temos que ğ‘ = ğ‘ğ‘ + ğ‘Ÿ com ğ‘Ÿ < ğ‘
com ğ‘ e ğ‘Ÿ Â´unicos. Como ğ‘ < ğ‘, logo ğ‘ = ğ‘‘0 + ğ‘‘1ğ‘ + ğ‘‘2ğ‘2 + . . . + ğ‘‘ğ‘˜ğ‘ğ‘˜ donde segue que
ğ‘ = ğ‘Ÿ + ğ‘‘0ğ‘ + ğ‘‘1ğ‘2 + ğ‘‘2ğ‘3 + . . . + ğ‘‘ğ‘˜ğ‘ğ‘˜+1. DaÂ´Ä± basta tomar ğ‘› = ğ‘˜ + 1, ğ‘0 = ğ‘Ÿ e ğ‘ğ‘– = ğ‘‘ğ‘–âˆ’1
com 1 â‰¤ ğ‘– â‰¤ ğ‘› e esta forma de representar ğ‘ Â´e Â´unica pois herda a unicidade dos nÂ´umeros
ğ‘‘ğ‘– e ğ‘Ÿ.

2.2. Bases numÂ´ericas

57

Os nÂ´umeros ğ‘0, ğ‘1ğ‘, ğ‘2, . . . + ğ‘‘ğ‘› sËœao ditos os â€œdÂ´Ä±gitosâ€ de ğ‘ na base ğ‘, comumente

representados na forma ğ‘ = (ğ‘ğ‘›ğ‘ğ‘›âˆ’1 . . . ğ‘0)ğ‘.

A demonstraÂ¸cËœao do Teorema 2.3 acima nos fornece um algoritmo para passar um

nÂ´umero ğ‘ para a base ğ‘, basta aplicar a divisËœao euclidiana como segue:

ğ‘ = ğ‘ğ‘0 + ğ‘Ÿ0, ğ‘Ÿ0 < ğ‘,

ğ‘0 = ğ‘ğ‘1 + ğ‘Ÿ1, ğ‘Ÿ1 < ğ‘,

ğ‘1 = ğ‘ğ‘2 + ğ‘Ÿ2, ğ‘Ÿ2 < ğ‘,

...

Como ğ‘ > ğ‘0 > ğ‘1 > . . . > ğ‘ğ‘–, ğ‘– âˆˆ N, em algum momento ter-se-Â´a ğ‘ğ‘›âˆ’1 < ğ‘ para algum ğ‘›.
Portanto, de

ğ‘ğ‘›âˆ’1 = ğ‘ğ‘ğ‘› + ğ‘Ÿğ‘›,

segue que ğ‘ğ‘› = 0 =â‡’ 0 = ğ‘ğ‘— para todo ğ‘— â‰¥ ğ‘›. DaÂ´Ä± tem-se, 0 = ğ‘Ÿğ‘˜ para todo ğ‘˜ â‰¥ ğ‘› + 1.
Finalmente, temos que

ğ‘ = ğ‘Ÿ0 + ğ‘Ÿ1ğ‘1 + . . . + ğ‘Ÿğ‘›ğ‘ğ‘›

Como exemplo vamos passar o 13 para a base binÂ´aria:

Donde

13 = 2 Â· 6 + 1

6 = 2 Â· 3 + 0

3 = 2 Â· 1 + 1

1 = 2 Â· 0 + 1

13 = 2(2 Â· 3 + 0) + 1

13 = 22 Â· 3 + 0 Â· 21 + 1 Â· 20

13 = 22 Â· (2 Â· 1 + 1) + 0 Â· 21 + 1 Â· 20

13 = 23 Â· 1 + 1 Â· 22 + 0 Â· 21 + 1 Â· 20
âˆ´ 13 = (1101)2

Vejamos um mÂ´etodo mais prÂ´atico, ilustrado pela maneira tradicional de se repre-
sentar a divisËœao, para converter da base 10 para base 2. Transformaremos 13 em binÂ´ario

58

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

13

1

2

6

0

2

3

1

2

1

novamente:

Portanto pelo mÂ´etodo das divi-
sËœoes sucessivas
Temos que o 13 na base binÂ´a-
ria Â´e 1101, representamos assim
13 = (1101)2 .

Para outro nÂ´umero qualquer, basta repertimos o processo descrito acima, atÂ´e o
quociente chegar ao valor 1, daÂ´Ä± teremos a representaÂ¸cËœao binÂ´aria do referido nÂ´umero que
serÂ´a a concatenaÂ¸cËœao do Â´ultimo quociente com os restos das divisËœoes anteriores (indo do
Â´ultimo atÂ´e o primeiro, como indica a seta na ï¬gura acima). A tarefa agora Â´e transformar
esse algoritmo num programa em Python.

Observe que os quocientes vËœao mudando de valor, sempre a parte inteira da metade
do valor anterior; isto acontece atÂ´e o Â´ultimo quociente ter valor 1 (isso sugere o uso de um
while [enquanto]). Em cada passo temos que armazenar os respectivos restos (isso sugere
o uso de uma lista ou uma string vazia), onde o Â´ultimo valor dessa lista serÂ´a o Â´ultimo
quociente, depois basta imprimir a lista na ordem inversa. Vamos ao Programa 2.3:

1 n = int ( input ( â€™ Digite o n Â´u mero a ser convertido pra bin Â´a rio : â€™) )

CÂ´odigo 2.3 â€“ ConversËœao binÂ´aria

2 base = " "

3 q = n

4 while n >= 2:

5

6

7

8

base = base + str ( n %2)

n = n // 2

if n == 1:

base = base + str ( n )

9 print ( â€™O % d na base 2 Â´e â€™%q , base [:: -1])

10 RESTART :

11 Digite o n Â´u mero a ser convertido pra bin Â´a rio : 13

12 O 13 na base 2 Â´e

1101

Escolhemos a base 2 pois os computadores trabalham utilizando a base binÂ´aria, mas
podemos escrever um nÂ´umero natural ğ‘› para qualquer base ğ‘ (ğ‘ > 1) como prova o
Teorema 2.3. Por exemplo vamos passar o nÂ´umero ğ‘› = 1245 para a base ğ‘ = 3.

2.2. Bases numÂ´ericas

59

1245

3

0

415

3

1

138

3

0

46

3

1

15

0

3

5

2

3

1

Portanto pelo mÂ´etodo das divi-
sËœoes sucessivas
Temos que o 1245 na base 3 Â´e
1201010, representamos assim
1245 = (1201010)3 .

Vejamos como implementar um programa em Python que forneÂ¸ca a mudanÂ¸ca de
base, onde serËœao solicitados o nÂ´umero ğ‘› e a base ğ‘ para a qual se deseja fazer a conversËœao.
A ideia Â´e dividir o nÂ´umero ğ‘› sucessivas vezes pela base ğ‘, bem semelhante ao que foi feito
para a base 2.

CÂ´odigo 2.4 â€“ ConversËœao para base b

1 b = int ( input ( â€™ Digite a base para a qual quer converter : â€™) )

2 n = int ( input ( â€™ Digite o n Â´u mero que quer converter : â€™) )

3 k = n

4 base =[]

5 while n >= b :

6

7

base . append ( n % b )

n = n // b

8 if n <= b -1:

9

base . append ( n )

10 print ( â€™% d na base % d Â´e â€™ %( k , b ) , base [:: -1])

11 RESTART :

12 Digite a base para a qual quer converter : 3

13 Digite o n Â´u mero que quer converter : 1245

14 1245 na base 3 Â´e [1 , 2 , 0 , 1 , 0 , 1 , 0]

15 >>>

16 Digite a base para a qual quer converter : 17

17 Digite o n Â´u mero que quer converter : 810

18 810 na base 17 Â´e [2 , 13 , 11]

No Programa 2.4 optou-se por apresentar a resposta em um vetor, para que quando
a base for maior que 10, nËœao haja confusËœao. Assim deve-se interpretar 810 = [2, 13, 11] =
(2, 13, 11)17 = 2 Â· 172 + 13 Â· 171 + 11 Â· 170.

Claramente, dado um nÂ´umero (ğ›¼ğ‘›ğ›¼ğ‘›âˆ’1 . . . ğ›¼0)ğ‘ numa base qualquer ğ‘, com ğ›¼ğ‘– < ğ‘

60

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

com ğ‘– âˆˆ {0, 1, . . . , ğ‘›} podemos convertË†e-lo para base 10 efetuando o cÂ´alculo:

ğ›¼ğ‘›ğ‘ğ‘› + ğ›¼ğ‘›âˆ’1ğ‘ğ‘›âˆ’1 + . . . + ğ›¼0ğ‘0

Por exemplo, (2014)5 = [2, 0, 1, 4]5 Â´e 259, pois 2 Â· 53 + 0 Â· 52 + 1 Â· 51 + 4 Â· 50 = 259
O Programa 2.5 efetua tal conversËœao.

CÂ´odigo 2.5 â€“ ConversËœao da base b para base 10

1 b = int ( input ( " Forneca a base : " ) )

2 n = []

3 x , i = 1 ,0

4 a , N = 0 , 0

5 while True :

6

7

8

9

a = int ( input ( " Digite o % d algarismo ou um valor >= % d para

sair : " %( x , b ) ) )

if a >= b :

break

n . append ( a )

10

x += 1

11 while i <= len ( n ) -1:

12

13

N += n [ i ] * b * * (( len ( n ) -1 - i ) )

i +=1

14 print ( " O n Â´u mero " ,n , â€™( base % d ) Â´e % d na base dez â€™ %( b , N ) )

15 RESTART :

16 Forneca a base : 17

17 Digite o 1 algarismo ou um valor >= 17 para sair : 2

18 Digite o 2 algarismo ou um valor >= 17 para sair : 1

19 Digite o 3 algarismo ou um valor >= 17 para sair : 3

20 Digite o 4 algarismo ou um valor >= 17 para sair : 1

21 Digite o 5 algarismo ou um valor >= 17 para sair : 1

22 Digite o 6 algarismo ou um valor >= 17 para sair : 20

23 O n Â´u mero [2 , 1 , 3 , 1 , 1] ( base 17) Â´e 172840 na base dez

2.3 Um pouco mais de aritmÂ´etica

Nesta seÂ¸cËœao abordaremos mais alguns teoremas e problemas relacionados aos
nÂ´umeros naturais, e como a linguagem de programaÂ¸cËœao Python se apresenta como um
bom recurso didÂ´atico na compreensËœao e aplicaÂ¸cËœao dos resultados que seguem.

Comecemos tratando do cÂ´alculo do mÂ´aximo divisor comum entre dois nÂ´umeros, um
clÂ´assico dentre os algoritmos. Logo apÂ´os, apresentamos alguns resultados sobre nÂ´umeros
primos.

2.3. Um pouco mais de aritmÂ´etica

61

2.3.1 MÂ´aximo Divisor Comum

Dados dois naturais ğ‘ e ğ‘ ambos nËœao nulos, diremos que ğ‘‘ Â´e um divisor comum de

ğ‘ e ğ‘ se ğ‘‘|ğ‘ e ğ‘‘|ğ‘.

Por exemplo, 3 Â´e divisor comum de 15 e 27.

Deï¬niÂ¸cËœao 2.2. Diremos que ğ‘‘ Â´e o mÂ´aximo divisor comum de ğ‘ e ğ‘ se:

i) ğ‘‘ Â´e um divisor comum de ğ‘ e ğ‘;

ii) Se ğ‘ Â´e um divisor comum de ğ‘ e ğ‘, entËœao ğ‘|ğ‘‘.

Denotaremos o mdc de ğ‘ e ğ‘ por mdc(ğ‘,ğ‘).

Seguem alguns exemplos e propriedades. Nos itens que seguem ğ‘ e ğ‘ sËœao naturais

diferentes de zero.

âˆ™ mdc(2,4)=2;

âˆ™ mdc(1,ğ‘)=1 e mdc(ğ‘,ğ‘)=ğ‘;

âˆ™ mdc(ğ‘,ğ‘)=ğ‘ â‡â‡’ ğ‘|ğ‘;

âˆ™ mdc(ğ‘,ğ‘)=mdc(ğ‘,ğ‘).

O mdc(ğ‘,ğ‘) quando existe Â´e Â´unico. De fato, seja ğ‘‘ =mdc(ğ‘, ğ‘), suponhamos que
exista outro ğ‘‘â€² =mdc(ğ‘,ğ‘) assim terÂ´Ä±amos que ğ‘‘ â‰¤ ğ‘‘â€² e ğ‘‘â€² â‰¤ ğ‘‘, pelo Item ii da Deï¬niÂ¸cËœao
2.2. Conclui-se assim que ğ‘‘ = ğ‘‘â€².

Outro fato de extrema relevË†ancia Â´e que sempre existe o mdc(ğ‘,ğ‘) entre dois naturais
ğ‘ e ğ‘ nËœao nulos. Para veriï¬car tal propriedade, basta tomar o maior elemento comum nos
conjuntos dos divisores de ğ‘ e ğ‘; tal elemento Â´e o mdc(ğ‘,ğ‘) e serÂ´a no mÂ´Ä±nimo 1, pois 1
divide qualquer nÂ´umero.

Quando o mdc(ğ‘,ğ‘)=1, ğ‘ e ğ‘ sËœao ditos primos entre si.

A seguir vejamos um mÂ´etodo que mostra como encontrar o mdc(ğ‘,ğ‘). Tal mÂ´etodo Â´e
conhecido por Algoritmo de Euclides. Mas antes precisamos de um resultado preliminar
que serÂ´a apresentado como um problema:

Problema 2.1. Dados ğ‘,ğ‘, ğ‘› âˆˆ N nËœao nulos, com ğ‘ â‰¤ ğ‘›ğ‘ â‰¤ ğ‘, entËœao mdc(ğ‘,ğ‘)=mdc(ğ‘,ğ‘ âˆ’
ğ‘›ğ‘)

SoluÂ¸cËœao: Seja ğ‘‘ = mdc(ğ‘,ğ‘), pelo fato de ğ‘‘|ğ‘ e ğ‘‘|ğ‘ tem-se que ğ‘‘|ğ‘ âˆ’ ğ‘›ğ‘. Seja
ğ‘‘â€² = mdc(ğ‘,ğ‘ âˆ’ ğ‘›ğ‘), tem-se que ğ‘‘â€²|ğ‘ e ğ‘‘â€²|ğ‘ âˆ’ ğ‘›ğ‘ logo ğ‘‘â€²|ğ‘ âˆ’ ğ‘›ğ‘ + ğ‘›ğ‘, isto Â´e, ğ‘‘â€²|ğ‘, portanto
(cid:4)
ğ‘‘ = ğ‘‘â€².

62

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

Dados ğ‘, ğ‘ âˆˆ N nËœao nulos, com ğ‘ â‰¤ ğ‘, o procedimento abaixo Â´e o Algoritmo de
Euclides. Tal algortimo Â´e utilizado para se calcular o mÂ´aximo divisor comum entre dois
nÂ´umeros.

Algoritmo de Euclides:

Caso: ğ‘ = 1 ou ğ‘ = ğ‘ ou ğ‘|ğ‘ teremos que mdc(ğ‘,ğ‘)=ğ‘.

Caso: ğ‘ (cid:45) ğ‘ pela divisËœao euclidiana temos:

ğ‘ = ğ‘ğ‘1 + ğ‘Ÿ1

com ğ‘Ÿ1 < ğ‘

Se ğ‘Ÿ1|ğ‘ temos que ğ‘Ÿ1 = mdc(ğ‘,ğ‘Ÿ1) = mdc(ğ‘,ğ‘ âˆ’ ğ‘ğ‘1) = mdc(ğ‘,ğ‘)

E se ğ‘Ÿ1 (cid:45) ğ‘ pela divisËœao euclidiana temos:

ğ‘ = ğ‘Ÿ1ğ‘2 + ğ‘Ÿ2

com ğ‘Ÿ2 < ğ‘Ÿ1

Se ğ‘Ÿ2|ğ‘Ÿ1 temos que ğ‘Ÿ2 = mdc(ğ‘Ÿ1,ğ‘Ÿ2) = mdc(ğ‘Ÿ1,ğ‘ âˆ’ ğ‘Ÿ1ğ‘2) = mdc(ğ‘Ÿ1,ğ‘) = mdc(ğ‘ âˆ’ ğ‘ğ‘1,ğ‘) =
mdc(ğ‘,ğ‘) = mdc(ğ‘,ğ‘)

E se ğ‘Ÿ2 (cid:45) ğ‘Ÿ1, aplicamos a divisËœao euclidiana novamente

ğ‘Ÿ1 = ğ‘Ÿ2ğ‘3 + ğ‘Ÿ3

com ğ‘Ÿ3 < ğ‘Ÿ2.

Repetindo este procedimento, teremos uma sequË†encia de restos decrescente, desta foram,
em algum momento tal processo terÂ´a que parar devido ao Axioma 2.1, uma vez que o
conjunto formado pelos restos dessas divisËœoes Â´e limitado inferiormente pelo zero. EntËœao
existirÂ´a algum ğ‘› âˆˆ N com ğ‘Ÿğ‘›|ğ‘Ÿğ‘›âˆ’1, portanto temos que ğ‘Ÿğ‘› = mdc(ğ‘,ğ‘).

O Algoritmo de Euclides se apresenta de uma maneira mais prÂ´atica atravÂ´es do

dispositivo abaixo, conhecido como jogo da velha.

ğ‘1
ğ‘

ğ‘
ğ‘Ÿ1

ğ‘2
ğ‘Ÿ1

ğ‘1
ğ‘
ğ‘Ÿ2

ğ‘
ğ‘Ÿ1

ğ‘1
ğ‘
ğ‘Ÿ2

ğ‘2
ğ‘Ÿ1
ğ‘Ÿ3

ğ‘ğ‘›âˆ’1
. . .
. . . ğ‘Ÿğ‘›âˆ’2
ğ‘Ÿğ‘›
. . .

ğ‘
ğ‘Ÿ1

ğ‘ğ‘›
ğ‘Ÿğ‘›âˆ’1

ğ‘ğ‘›+1
ğ‘Ÿğ‘› = mdc(ğ‘, ğ‘)

Exempliï¬cando vamos calcular o mdc(255, 221)

1

6

2

255 221 34 17

34

17

Logo mdc(255, 221) = 17

Nosso objetivo agora Â´e fazer um programa que calcule o mdc de dois nÂ´umeros

fornecidos pelo usuÂ´ario.

2.3. Um pouco mais de aritmÂ´etica

63

Para isso, basta notar que o mdc entre os dois nÂ´umeros Â´e o resto ğ‘Ÿğ‘› que divide o
resto ğ‘Ÿğ‘›âˆ’1 para algum ğ‘›. ConvÂ´em notar que as divisËœoes comeÂ¸cam por ğ‘ e ğ‘ e depois ğ‘ por
ğ‘Ÿ1 e a assim sucessivamente, sugerindo o uso de um while atÂ´e haver divisËœao exata.

CÂ´odigo 2.6 â€“ mdc(ğ‘, ğ‘)

1 a = int ( input ( " Digite o primeiro n Â´u mero : " ) )

2 b = int ( input ( " Digite o segundo n Â´u mero : " ) )

3 x , y =a , b

4 while b % a != 0:

5

a , b = b %a , a

6 print ( " mdc (% d ,% d ) = % d " %( x ,y , a ) )

7 RESTART :

8 Digite o primeiro n Â´u mero : 255

9 Digite o segundo n Â´u mero : 221

10 mdc (255 ,221) = 17

Apenas para ilustrar, segue o cÂ´odigo abaixo com a funÂ¸cËœao mdc

CÂ´odigo 2.7 â€“ FunÂ¸cËœao mdc(ğ‘, ğ‘)

1 def mdc (a , b ) :

2

3

4

while b % a !=0:

b , a =a , b % a

return a

5 >>> # O Python j Â´a reconheceu a nova fun Â¸c ~a o mdc

6 >>> # basta cham Â´a -la , como segue os exemplos

7 >>> mdc (255 ,221)

8 17

9 >>> mdc (54 ,16)

10 2

2.3.2 Primos

Antes do primeiro problema, vamos deï¬nir nÂ´umero primo.

Deï¬niÂ¸cËœao 2.3. Um nÂ´umero natural ğ‘ > 1 Â´e dito primo se Â´e divisÂ´Ä±vel apenas por 1 e por
si mesmo.

ObservaÂ¸cËœao: Quando ğ‘› nËœao for primo, dizemos que ğ‘› Â´e composto.

Problema 2.2. Dado ğ‘› âˆˆ N com ğ‘› > 1 como decidir se ğ‘› Â´e primo ou composto?

SoluÂ¸cËœao: Caso ğ‘› = 2 serÂ´a primo por deï¬niÂ¸cËœao, caso contrÂ´ario basta dividir ğ‘›
por cada ğ‘‘ âˆˆ {2, 3, . . . , ğ‘› âˆ’ 1}. Se ocorrer de alguma divisËœao ser exata para algum ğ‘‘, isto Â´e,

64

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

deixar resto zero pode-se parar o processo pois ğ‘› serÂ´a composto apresentando no mÂ´Ä±nimo
(cid:4)
trË†es divisores: 1, ğ‘‘ e ğ‘›. Caso contrÂ´ario ğ‘› serÂ´a primo.

Agora vamos fazer um programa que nos forneÂ¸ca a informaÂ¸cËœao se dado ğ‘› > 1
natural Â´e primo ou nËœao. Observe que durante a soluÂ¸cËœao apresentada temos dois conceitos
lÂ´ogicos que sËœao traduzidos por duas palavras reservadas do Python (for e if ). O uso do
for de dÂ´a, pois vamos fazer divisËœoes partindo do 2 atÂ´e o antecessor do nÂ´umero fornecido,
enquanto que o if se mostra Â´util, pois analisamos inicialmente se o numero fornecido Â´e 2
e depois dentro do for analisamos os restos das divisËœoes. Isto posto vejamos o programa
abaixo:

1 n = int ( input ( â€™ Digite um n Â´u mero natural maior que 1: â€™) )

CÂ´odigo 2.8 â€“ Teste de primalidade

2 if n ==2:

3

print ( â€™% d Â´e primo â€™% n )

4 else :

5

6

7

8

9

10

11

for d in range (2 , n ) :

if n % d ==0 and d != n -1:

print ( â€™% d n ~a o Â´e primo â€™% n )

break

else :

if d == n -1:

print ( â€™% d Â´e primo â€™% n )

12 RESTART :

13 Digite um n Â´u mero natural maior que 1: 7493

14 7493 n ~a o Â´e primo

15 >>>

16 RESTART :

17 Digite um n Â´u mero natural maior que 1: 18446744073709551617

18 18446744073709551617 n ~a o Â´e primo

Sabemos que dado ğ‘› âˆˆ N, temos que ğ‘› Â´e primo ou ğ‘› Â´e composto. Um fato de
extrema relevË†ancia Â´e que caso ğ‘› seja composto, existem primos que quando multiplicados
reproduzem ğ‘›, ou seja, existem primos que compËœoem ğ‘›. Tal aï¬rmaÂ¸cËœao Â´e o conteÂ´udo do
prÂ´oximo teorema.

Teorema 2.4 (Teorema Fundamental da AritmÂ´etica). Seja ğ‘› âˆˆ N, ğ‘› > 1. EntËœao ğ‘› se
escreve de modo Â´unico (a menos da ordem dos fatores) como produto de primos.

DemonstraÂ¸cËœao. Usaremos o Segundo PrincÂ´Ä±pio de InduÂ¸cËœao sobre ğ‘›. O resultado Â´e vÂ´alido
para ğ‘› = 2. Suponha o resultado vÂ´alido para cada natural 2 â‰¤ ğ‘˜ < ğ‘›. Se ğ‘› for primo o
resultado Â´e claramente vÂ´alido. Caso ğ‘› seja composto, existem ğ‘›1 e ğ‘›2, ambos menores

2.3. Um pouco mais de aritmÂ´etica

65

que, ğ‘› com ğ‘› = ğ‘›1ğ‘›2. Pela hipÂ´otese de induÂ¸cËœao ğ‘›1 = ğ‘1ğ‘2 . . . ğ‘ğ‘Ÿ e ğ‘›2 = ğ‘1ğ‘2 . . . ğ‘ğ‘  logo
ğ‘› = ğ‘1 . . . ğ‘ğ‘Ÿğ‘1 . . . ğ‘ğ‘ .

Agora vamos provar a unicidade. Suponha que ğ‘› = ğ‘1ğ‘2 . . . ğ‘ğ‘Ÿ = ğ‘1ğ‘2 . . . ğ‘ğ‘  com ğ‘ğ‘–,
1 â‰¤ ğ‘– â‰¤ ğ‘Ÿ, e ğ‘ğ‘—, 1 â‰¤ ğ‘— â‰¤ ğ‘ , primos. Temos entËœao que algum ğ‘ğ‘–|ğ‘1ğ‘2 . . . ğ‘ğ‘ , o que implica
ğ‘ğ‘– = ğ‘ğ‘—; reordenando os primos na decomposiÂ¸cËœao de ğ‘› podemos supor que sejam ğ‘1 = ğ‘1.
Assim teremos ğ‘2 . . . ğ‘ğ‘› = ğ‘2 . . . ğ‘ğ‘  assim teremos, por hipÂ´otese de induÂ¸cËœao, que ğ‘Ÿ = ğ‘  uma
vez que ğ‘2 . . . ğ‘ğ‘  < ğ‘›. Portanto teremos ğ‘ğ‘– = ğ‘ğ‘—, 2 â‰¤ ğ‘–, ğ‘— â‰¤ ğ‘Ÿ.

Para exempliï¬car, vejamos a decomposiÂ¸cËœao em fatores primos de alguns nÂ´umero:

6 = 2 Â· 3 = 2 Ã— 3; 15 = 3 Â· 5; 18 = 2 Â· 3 Â· 3 = 2 Â· 32.

Uma maneria prÂ´atica na qual um nÂ´umero Â´e decomposto se apresenta no mÂ´etodo

abaixo:

ğ‘›
ğ‘1
ğ‘2
ğ‘›1
ğ‘›2
ğ‘3
...
...
ğ‘›ğ‘Ÿâˆ’1 ğ‘ğ‘Ÿ

1

6 2
3 3
1

15 3
5
5
1

18 2
3
9
3
3
1

Se ğ‘› = ğ‘›0, cada ğ‘›ğ‘– Â´e o quociente de ğ‘›ğ‘–âˆ’1 por ğ‘ğ‘– com ğ‘– = 1, 2, . . . , ğ‘Ÿ, e o nÂ´umero ğ‘ğ‘–
corresponde ao menor primo que divide ğ‘›ğ‘–âˆ’1. Tal processo acaba quando o quociente da
divisËœao de ğ‘›ğ‘Ÿâˆ’1 por ğ‘ğ‘Ÿ Â´e 1. Assim, a forma fatorada de ğ‘› em primos serÂ´a ğ‘› = ğ‘1ğ‘2 . . . ğ‘ğ‘Ÿ.

ObservaÂ¸cËœao: Forma fatorada e decomposiÂ¸cËœao em primos sËœao sinË†onimos.

Esse mÂ´etodo por si sÂ´o jÂ´a estrutura um programa que, dado ğ‘›, nos retorne a forma

fatorada de ğ‘›.

Quando tem-se fatores repetidos na decomposiÂ¸cËœao de ğ‘›, diremos que tal fator tem
multiplicidade igual ao nÂ´umero de vezes em que aparece na fatoraÂ¸cËœao. Por exemplo em
18 = 2 Â· 3 Â· 3 dizemos que 3 tem multiplicidade 2.

Assim a fatoraÂ¸cËœao de ğ‘› de forma geral Â´e ğ‘› = ğ‘ğ‘Ÿ1

1 ğ‘ğ‘Ÿ2

2 . . . ğ‘ğ‘Ÿğ‘˜

ğ‘˜ com ğ‘Ÿğ‘– > 0 com

ğ‘– = 1, . . . , ğ‘˜.

O Programa 2.9 exibe os fatores (e suas multiplicidades) de um nÂ´umero ğ‘› em um

vetor.

1 n = int ( input ( â€™ Entre com o n Â´u mero : â€™) )

CÂ´odigo 2.9 â€“ DecomposiÂ¸cËœao de ğ‘›

2 fatores = []

3 d = 2

4 while n > 1:

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

66

5

6

7

8

9

if n % d == 0:

n = n / d

fatores . append ( d )

else :

d += 1

10 print ( fatores ) # esse Â´e o vetor com todos os fatores de n

11 RESTART :

12 Entre com o n Â´u mero : 18

13 [2 , 3 , 3]

14 >>>

15 RESTART :

16 Entre com o n Â´u mero : 7493

17 [59 , 127]

De posse do Teorema 2.4 vamos apresentar outro teste de primalidade devido a
EratÂ´ostenes3. Tal mÂ´etodo Â´e melhor que o mostrado no Problema 2.2, no entanto tambÂ´em Â´e
lento. Outros testes de primalidade podem ser encontrados em (MOREIRA; SALDANHA,
2011).

Teorema 2.5. Seja ğ‘› âˆˆ N, com ğ‘› > 1. Se nenhum ğ‘ primo com ğ‘ â‰¤
ğ‘› Â´e primo.

âˆš

ğ‘› divide ğ‘›, entËœao

DemonstraÂ¸cËœao. Iremos demonstrar utilizando a contra-positiva, ou seja, mostraremos que
ğ‘› que divide ğ‘›. Seja ğ‘› um nÂ´umero
se ğ‘› Â´e composto entËœao existe ğ‘ primo com ğ‘ â‰¤
composto. Suponha, por contradiÂ¸cËœao, que ğ‘¡ Â´e o menor primo que divide ğ‘› e ğ‘¡ >
ğ‘›. Pelo
Teorema Fundamental da AritmÂ´etica 2.4 temos que ter, no mÂ´Ä±nimo, outro primo ğ‘¡1 que
ğ‘›, de onde, ğ‘› = ğ‘¡ Â· ğ‘¡1 > ğ‘›, absurdo.
divide ğ‘›. EntËœao ğ‘¡1 â‰¥ ğ‘¡ >

âˆš

âˆš

âˆš

Exempliï¬cando, considere ğ‘› = 71. Como âŒŠ

71âŒ‹ = 8, em que âŒŠğ‘¥âŒ‹ Â´e o maior inteiro
menor do que ou igual a ğ‘¥, com ğ‘¥ âˆˆ R, para testar se 71 Â´e primo, basta dividir este nÂ´umero
apenas pelos primos entre 2 e 8.

âˆš

O Programa 2.10, mostra este teste de primalidade. Neste programa ï¬zemos as

divisËœoes de ğ‘› por nÂ´umeros de 2 atÂ´e âŒŠ

ğ‘›âŒ‹, usando o while e if .

âˆš

CÂ´odigo 2.10 â€“ Teste de primalidade (EratÂ´ostenes)

1 n = int ( input ( " Digite um n Â´u mero > 1 , que vamos testar se Â´e primo :

" ) )

2 p = int ( n * * 0.5)

3 while p >= 1: # Temos que testar p =1 , por causa das ra Â´Ä± zes de 2 e

3

3 MatemÂ´atico grego que viveu por volta dos anos 230 a.C

2.3. Um pouco mais de aritmÂ´etica

67

4

5

6

7

8

9

if n % p == 0 and p !=1:

print ( â€™ O n Â´u mero % d n ~a o Â´e primo . â€™ % n )

break

if p == 1:

print ( â€™O n Â´u mero % d Â´e primo . â€™ % n )

p = p - 1

10 RESTART :

11 Digite um n Â´u mero > 1 , que vamos testar se Â´e primo : 4294967297

12 O n Â´u mero 4294967297 n ~a o Â´e primo .

O Programa 2.11 Â´e uma adaptaÂ¸cËœao do Programa 2.10, no qual foi criada uma

funÂ¸cËœao que retorna True se um dado ğ‘› natural Â´e primo e False, caso contrÂ´ario.

CÂ´odigo 2.11 â€“ FunÂ¸cËœao ehprimo

1 def ehprimo ( n ) :

2

3

4

5

6

7

8

9

p = int ( n * * 0.5)

while p >= 1:

if n % p == 0 and p !=1:

return False

break

if p == 1:

return True

p = p - 1

10 RESTART :

11 >>> ehprimo (111)

12 False

13 >>> ehprimo (65537)

14 True

De modo geral nËœao Â´e simples determinar a primalidade ou nËœao de um nÂ´umero
natural grande sem ferramentas computacionais. Podemos ilustar tal aï¬rmaÂ¸cËœao resgatando
um episÂ´odio envolvendo dois grandes matemÂ´aticos, que sËœao Fermat4 e Euler5, conforme
apresentado em (LEITE, 1985; HEFEZ, 2011; PENHA, 1983).

Fermat em uma carta enviada a seu amigo Bernard Frenide de Bessy em 1640
aï¬rmava crer que os nÂ´umeros da forma ğ¹ğ‘› = 22ğ‘› + 1 (nÂ´umeros de Fermat ou primos de
Fermat) fossem primos para todo natural ğ‘›.

Vejamos alguns valores de ğ¹ğ‘›:

ğ¹0 = 220 +1 = 2+1 = 3, ğ¹1 = 221 +1 = 4+1 = 5, ğ¹3 = 223 +1 = 256+1 = 257
4 Pierre de Fermat (1601-1665) matemÂ´atico francË†es do sÂ´ec. XVII; deu vÂ´arias contribuiÂ¸cËœoes em Teoria dos

NÂ´umeros

5 Leonhard Euler (1707-1783) matemÂ´atico suÂ´Ä±Â¸co, ï¬gura entre os maiores e mais produtivos matemÂ´aticos

de todos os tempos.

68

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

ğ¹4 = 224 + 1 = 65537 que sËœao de fato primos.

JÂ´a ğ¹5 = 225+1 = 4294967297 nËœao foi veriï¬cado ser primo por Fermat, provavelmente
por ser muito grande. No entanto Euler, quase 100 anos depois, em 1732 mostrou que ğ¹5 Â´e
composto com um fator igual a 641. De fato tem-se que ğ¹5 = 4294967297 = 641 Ã— 6700417.
Maiores detalhes de como Euler conseguiu fatorar ğ¹5 podem ser encontrado em em
(PENHA, 1983).

Podemos veriï¬car a nËœao primalidade de ğ¹5 e sua fatoraÂ¸cËœao utilizando os CÂ´odigos

2.10 e 2.11 respectivamente.

A fatoraÂ¸cËœao de um dado ğ‘›, nos possibilita determinar, entre outras coisas, as citadas

abaixo relativas a ğ‘› :

1. Quantos divisores ğ‘› possui;

2. Quais sËœao tais divisores, qual Â´e a soma e o produto destes divisores.

De modo geral seja ğ‘› = ğ‘ğ‘Ÿ1

ğ‘˜ e sejam ğ·, ğ·(ğ‘›), ğ‘†(ğ‘›) e ğ‘ƒ (ğ‘›) o nÂ´umero de
divisores, o conjunto dos divisores, a soma dos divisores e o produto do divisores de ğ‘›. A
tÂ´Ä±tulo de ilustraÂ¸cao, ğ· e ğ‘†(ğ‘›) podem ser calculados pelas fÂ´ormulas:

2 . . . ğ‘ğ‘Ÿğ‘˜

1 ğ‘ğ‘Ÿ2

ğ· = (ğ‘Ÿ1 + 1)(ğ‘Ÿ2 + 1) . . . (ğ‘Ÿğ‘˜ + 1)

ğ‘†(ğ‘›) =

ğ‘ğ‘Ÿ1+1
1 âˆ’ 1
ğ‘1 âˆ’ 1

. . .

ğ‘ğ‘Ÿğ‘˜+1
ğ‘˜ âˆ’ 1
ğ‘ğ‘˜ âˆ’ 1

ğ‘ƒ (ğ‘›) = ğ‘› ğ·

2

A demonstraÂ¸cËœao da expressËœao para ğ· pode ser consultada em (LIMA et al., 2006),
enquanto que para ver uma demonstraÂ¸cËœao sobre ğ‘†(ğ‘›) consultar (HEFEZ, 2011). Provemos
a fÂ´ormula para ğ‘ƒ (ğ‘›) a seguir.

Problema 2.3. Dado ğ‘› âˆˆ N, com ğ‘› > 1, prove que o produto dos divisores de ğ‘›, denotado
por ğ‘ƒ (ğ‘›), Â´e igual a ğ‘› ğ·

2 , onde ğ· Â´e o nÂ´umero de divisores de ğ‘›.

SoluÂ¸cËœao: Seja {ğ‘‘1, ğ‘‘2, . . . , ğ‘‘ğ·} o conjunto dos divisores de ğ‘›. Temos entËœao que
ğ‘› = ğ‘‘ğ‘– Â· ğ‘‘ğ‘— com ğ‘– Ì¸= ğ‘— para algum ğ‘–, ğ‘— âˆˆ {1, . . . , ğ·}, segue que ğ‘ƒ (ğ‘›) = ğ‘‘1 Â· ğ‘‘2 Â· . . . Â· ğ‘‘ğ·
pode ser reordenado de tal modo que a cada dois fatores o resultado seja sempre ğ‘›, logo
ğ‘ƒ (ğ‘›) = ğ‘› Â· ğ‘› Â· . . . Â· ğ‘›

= ğ‘› ğ·
2 .

âŸ

 â
ğ·
2 vezes

Caso ğ‘› = ğ‘˜2 teremos para algum ğ‘– e ğ‘—, ğ‘‘ğ‘– = ğ‘‘ğ‘— = ğ‘˜ que Â´e contado duas vezes no
(cid:4)

produto e no entanto sÂ´o uma vez no conjunto dos divisores.

 
2.3. Um pouco mais de aritmÂ´etica

69

Como consequË†encia os Â´unicos nÂ´umeros que tem uma quantidade Â´Ä±mpar de divisores

sËœao os quadrados perfeitos.

A ideia agora Â´e elaborar um programa que dado ğ‘› âˆˆ N, ğ‘› > 1 calculemos ğ·, ğ·(ğ‘›),

ğ‘†(ğ‘›) e ğ‘ƒ (ğ‘›) mencionados acima.

A estratÂ´egia se baseia no fato de que para cada divisor ğ‘‘ğ‘– de ğ‘› temos ğ‘› = ğ‘‘ğ‘– Â· ğ‘‘â€²
ğ‘–,
ou seja os divisores aparecem aos pares. EntËœao criaremos um vetor e armazenaremos os
ğ‘‘ğ‘– e seus respectivo ğ‘‘â€²
ğ‘›. De
posse do vetor dos divisores basta varrer todos seus elementos com dois acumuladores,
um pra soma e outro para o produto. O nÂ´umero de divisores Â´e simplesmente len(vetor do
divisores). O CÂ´odigo 2.12 apresenta uma possÂ´Ä±vel soluÂ¸cËœao em Python.

ğ‘– e faremos todos os testes de divisibilidade enquanto ğ‘‘ â‰¤

âˆš

CÂ´odigo 2.12 â€“ Quantidade, conjunto, soma e produto dos divisores de ğ‘›

1 n = int ( input ( â€™ Entre com o valor de n : â€™) )

2 d ,S , P =1 ,0 ,1

3 vetor =[]

4 while d <= n * * 0.5:

5

6

7

8

if n % d ==0:

vetor . append ( d )

vetor . append ( n // d )

d = d +1

9 divisores = list ( set ( vetor ) ) # eliminando repeti Â¸c ~o es

10 divisores . sort () # deixando os elementos na ordem crescente

11 for i in range ( len ( divisores ) ) :

12

13

S = S + divisores [ i ]

P = P * divisores [ i ]

14 print ( â€™O n Â´u mero

de divisores de % d Â´e D =% d â€™ %( n , len ( divisores ) ) )

15 print ( â€™D (% d ) = â€™%n , divisores )

16 print ( â€™A soma de todos os divisores de % d Â´e S (% d ) =% d â€™ %( n ,n , S ) )

17 print ( â€™E o produto de todos os divisores de % d Â´e

P (% d ) =% d â€™ %( n ,n , P ) )

18 RESTART :

19 Entre com o valor de n : 60

20 O n Â´u mero

de divisores de 60 Â´e D =12

21 D (60) = [1 , 2 , 3 , 4 , 5 , 6 , 10 , 12 , 15 , 20 , 30 , 60]

22 A soma de todos os divisores de 60 Â´e S (60) =168

23 E o produto de todos os divisores de 60 Â´e P (60) =46656000000

No embalo dos primos temos mais dois problemas que surgem naturalmente, sËœao

eles:

1. Quantos nÂ´umeros primos existem?

70

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

2. Dado ğ‘› âˆˆ N quais sËœao todos os primos atÂ´e ğ‘›?

A resposta aos questionamentos acima, seguem no prÂ´oximo teorema e no prÂ´oximo problema,
devido a Euclides e EratÂ´ostenes respectivamente.

Teorema 2.6 (Euclides). Existem inï¬nitos nÂ´umeros primos.

DemonstraÂ¸cËœao. Suponhamos que existam apenas um nÂ´umero ï¬nito de nÂ´umeros primos
ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜ e seja ğ‘› = ğ‘1ğ‘2 . . . ğ‘ğ‘˜ + 1. Pelo Teorema 2.5 um dos ğ‘ğ‘–, ğ‘– = 1, . . . ğ‘˜, divide ğ‘›;
ora mas como ğ‘ğ‘–|ğ‘1ğ‘2 . . . ğ‘ğ‘– . . . ğ‘ğ‘˜ temos que ğ‘ğ‘–|ğ‘› âˆ’ ğ‘1ğ‘2 . . . ğ‘ğ‘˜ = 1, o que Â´e um absurdo.

Problema 2.4 (Crivo de EratÂ´ostenes). Dado ğ‘› âˆˆ N com ğ‘› > 1, determine todos os
primos atÂ´e ğ‘› (inclusive).

SoluÂ¸cËœao: A ideia Â´e montar uma tabela com todos os nÂ´umeros naturais de 2 atÂ´e

ğ‘› e fazer o seguinte procedimento:

1. deixar o 2 e riscar todos os seus mÂ´ultiplos atÂ´e ğ‘›;

2. deixar o prÂ´oximo nÂ´umero primo maior que 2, que Â´e 3, e riscar todos os seus mÂ´ultiplos

atÂ´e ğ‘›;

3. deixar o prÂ´oximo nÂ´umero primo maior do que 3, que Â´e 5 e riscar todos os seus

mÂ´ultiplos atÂ´e ğ‘›;

E assim sucessivamente atÂ´e nËœao ser mais possÂ´Ä±vel tal procedimento. Os nÂ´umeros que
ï¬carem intactos (nËœao forem riscados) serËœao os primos atÂ´e ğ‘›.

Para efeitos ilustrativos, vejamos o processo com ğ‘› = 50

1

11
11

21

31
31

41
41

2
2

12

22

32

42

3
3

13
13

23
23

33

43
43

4

14

24

34

44

5
5

15

25

35

45

6

16

26

36

46

7
7

17
17

27

37
37

47
47

8

18

28

38

48

9

19
19

29
29

39

49

10

20

30

40

50

Logo os primos atÂ´e 50 sËœao {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}

(cid:4)

Vejamos agora um programa que nos retorna todos os primos atÂ´e um dado ğ‘›
fornecido pelo usuÂ´ario. JÂ´a percebemos que existem diversas formas de resolver o mesmo

2.3. Um pouco mais de aritmÂ´etica

71

problema, tambÂ´em nËœao Â´e diferente com os programas, vamos utilizar a funÂ¸cËœao ehprimo do
cÂ´odigo 2.10 e a partir daÂ´Ä± testar a funÂ¸cËœao ehprimo, do Programa 2.11, dentro de um for e
os nÂ´umeros que forem primos serËœao armazenados em um vetor; ao ï¬m do laÂ¸co do for basta
imprimir tal vetor para visualizaramos os primos atÂ´e ğ‘›.O CÂ´odigo 2.13 faz este trabalho.

CÂ´odigo 2.13 â€“ Crivo de EratÂ´ostenes

1 def ehprimo ( n ) :

2

3

4

5

6

7

8

p = int ( n * * 0.5)

while p >=1:

if n % p ==0 and p !=1:

break

if p ==1:

return True

p =p -1

9 vetor_primos =[]

10 n = int ( input ( â€™ Digite o n Â´u mero de parada : â€™) )

11 for i in range (2 , n +1) :

12

13

if ehprimo ( i ) :

vetor_primos . append ( i )

14 print ( â€™ Todos os primos at Â´e % d s ~a o â€™%n , vetor_primos )

15 RESTART :

16 Digite o n Â´u mero de parada : 50

17 Todos os primos at Â´e 50 s ~a o [2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 ,

31 , 37 , 41 , 43 , 47]

Para encerrarmos este capÂ´Ä±tulo, vejamos alguns nÂ´umeros especiais: primos gË†emeos,

nÂ´umeros perfeitos e primos de Mersene6.

Deï¬niÂ¸cËœao 2.4. Dizemos que dois primos ğ‘ e ğ‘ sËœao gË†emeos se ğ‘ âˆ’ ğ‘ = 2.

Vejamos abaixo um programa que mostra todos os pares de primos gË†emeos atÂ´e um

dado ğ‘› fornecido pelo usuÂ´ario.

CÂ´odigo 2.14 â€“ Primos gË†emeos

1 primos =[]

2 g ^e meos =[]

3 for i in range (2 , int ( input ( " n : " ) ) +1) :

4

5

if all ([ i % a !=0 for a in range (2 , int ( i * * 0.5) +1) ]) :

primos . append ( i )

6 for i in range ( len ( primos ) ) :

7

if primos [ i ]+2 in primos :

6 Marin Mersenne (1588-1648) matemÂ´atico francË†es cujo nome Â´e lembrado pelos primos da forma 2ğ‘ âˆ’ 1

72

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

8

g ^e meos . append ([ primos [ i ] , primos [ i ]+2])

9 print ( â€™ Os pares de primos g ^e meos s ~a o : â€™ ,g ^e meos )

10 RESTART :

11 n : 50

12 Os pares de primos g ^e meos s ~a o :

[[3 , 5] , [5 , 7] , [11 , 13] , [17 ,

19] , [29 , 31] , [41 , 43]]

Podemos encontrar em (WATANABE, 2013) um resultado muito interessante
sobre primos gË†emeos devido Yitang Zhang7. Em (WATANABE, 2013) tambÂ´em encontra-
se o maior par de primos gË†emeos descoberto atÂ´e a data de sua publicaÂ¸cËœao. A saber,
3576801695685 Ã— 2666669 âˆ’ 1 e 3576801695685 Ã— 2666669 + 1.

Atualmente, de acordo com o (The Prime Pages , 2018) o maior par de primos

gË†emeos Â´e

2996863034895 Â· 21290000 âˆ’ 1 e 2996863034895 Â· 21290000 + 1

Um nÂ´umero Â´e chamado de perfeito quando a soma de seus divisores Â´e igual ao seu dobro ou
de forma equivalente se a soma de seus divisores prÂ´oprios Â´e igual a ele mesmo. (divisores
prÂ´oprios sËœao os divisores de um nÂ´umero exceto ele mesmo)

Deï¬niÂ¸cËœao 2.5. Seja ğ‘› um natural e ğ‘†(ğ‘›) a soma de seus divisores, se ğ‘†(ğ‘›) = 2ğ‘›, dizemos
que ğ‘› Â´e perfeito.

Vejamos alguns exemplos de nÂ´umeros perfeitos: 6, 28, 496 de fato o sËœao, pois sejam
ğ·(6), ğ·(28) e ğ·(496) o conjunto dos divisores prÂ´oprios de cada nÂ´umero respectivamente,
temos que:

ğ·(6) = {1, 2, 3}

e

6 = 1 + 2 + 3

ğ·(28) = {1, 2, 4, 7, 14}

e

28 = 1 + 2 + 3 + 4 + 7 + 14

ğ·(496) = {1, 2, 4, 8, 16, 31, 62, 124, 248}

e

496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248

Finalmente tratemos os nÂ´umeros de Mersenne. Os nÂ´umeros da forma ğ‘€ğ‘ = 2ğ‘ âˆ’ 1

com ğ‘ primo sËœao chamados de nÂ´umeros de Mersenne.

Deï¬niÂ¸cËœao 2.6. Os primos de Mersenne sËœao os primos da forma ğ‘€ğ‘ = 2ğ‘ âˆ’ 1, em que ğ‘
Â´e primo.

Durante muitos sÂ´eculos acreditou-se que os nÂ´umeros de Mersenne fossem primos,

contudo, Hudalricus Regius mostrou que 211 âˆ’ 1 Â´e composto.

7 MatemÂ´atico ChinË†es, professor da Universidade de New Hampshire

2.3. Um pouco mais de aritmÂ´etica

73

ğ‘€2 = 22 âˆ’ 1 = 3, ğ‘€3 = 23 âˆ’ 1 = 7, ğ‘€5 = 25 âˆ’ 1 = 31, ğ‘€7 = 27 âˆ’ 1 = 127
sËœao os primeiros primos de Mersenne. Para uma lista com todos conhecidos atÂ´e a atualidade
veja (Mersenne Researchs , 2018, 2018)

Existe um resultado que estabelece a relaÂ¸cËœao entre nÂ´umeros perfeitos e primos de
Mersenne. Este Â´e apresentado no prÂ´oximo teorema, cuja demonstraÂ¸cËœao pode ser encontrada
em (HEFEZ, 2011).

Teorema 2.7. Um nÂ´umero ğ‘› âˆˆ N Â´e perfeito par se, e somente se, ğ‘› = 2ğ‘âˆ’1(2ğ‘ âˆ’ 1) com
2ğ‘ âˆ’ 1 um primo de Mersenne.

Observemos que:

6 = 21(22 âˆ’1), 28 = 22(23 âˆ’1) e 496 = 24(25 âˆ’1) sËœao os nÂ´umeros pefeitos associados

aos Primos de Mersenne ğ‘€2, ğ‘€3 e ğ‘€5 citados acima.

Uma curiosidade: Segundo (Mersenne Researchs , 2018) o maior Primo de Mersenne
Â´e 277232917 âˆ’ 1 com 23249425 digÂ´Ä±tos. Tal nÂ´umero foi descoberto por Pace, Woltman,
Kurowski, Blosser & GIMPS em 26 de Dezembro de 2017; este Â´e tambÂ´em o maior primo
jÂ´a descoberto e o nÂ´umero perfeito associado a ele Â´e 277232916 Â· (277232917 âˆ’ 1).

Por ï¬m apresentamos um programa que dado uma lista com os primeiros ğ‘ nÂ´umeros

primos, retorna os primos de Mersenne 2ğ‘ âˆ’ 1.

CÂ´odigo 2.15 â€“ Primos de Mersenne

1 def ehprimo ( n ) :

2 p = int ( n * * 0.5)

3

4

5

6

7

8

9

while p >= 1:

if n % p == 0 and p !=1:

return False

break

if p == 1:

return True

p = p - 1

10 primos =[]

11 n = int ( input ( â€™n : â€™) )

12 for i in range (2 , n +1) :

13

14

if ehprimo ( i ) :

primos . append ( i )

15 mersenne =[]

16 for i in primos :

17

18

if ehprimo (2 * *i -1) :

mersenne . append ( " 2^% d - 1 " % i )

19 print ( mersenne )

74

CapÂ´Ä±tulo 2. AplicaÂ¸cËœoes da AritmÂ´etica bÂ´asica em Python

RESTART :

n : 20

[ â€™ 2^2 - 1 â€™ , â€™ 2^3 - 1 â€™ , â€™ 2^5 - 1 â€™ , â€™ 2^7 - 1 â€™ , â€™ 2^13 - 1 â€™ , â€™ 2^17 -

1 â€™ , â€™ 2^19 - 1 â€™]

20

21

22

23

O programa acima retornou os seguintes primos de Mersenne 22 âˆ’ 1, 23 âˆ’ 1, 25 âˆ’ 1,

27 âˆ’ 1, 213 âˆ’ 1, 217 âˆ’ 1 e 219 âˆ’ 1.

Finalizemos o capÂ´Ä±tulo salientando que os programas aqui apresentados podem
ser melhorados e por vezes nËœao apresentam uma melhor performace quando se considera
tempo de execuÂ¸cËœao e espaÂ¸co de armazenamento. Contudo, a principal ï¬nalidade deste
trabalho Â´e fazer uma ponte entre o ensino de introduÂ¸cËœao `a programaÂ¸cËœao com a linguagem
Python e o ensino de noÂ¸cËœoes bÂ´asicas da Teoria dos nÂ´umeros.

75

CapÂ´Ä±tulo 3

ConsideraÂ¸cËœoes ï¬nais

A presente dissertaÂ¸cËœao teve como objetivo central apresentar a possibilidade da
linguagem de programaÂ¸cËœao Python como ferramenta para o ensino de aritmÂ´etica. Neste
sentido, apresentamos algumas funcionalidades do Python, aquelas que seriam utilizadas nos
programas desenvolvidos, discutimos alguns resultados centrais de aritmÂ´etica e propusemos
programas em Python para tais resultados, buscando utilizar as demonstraÂ¸cËœoes apresentadas
para elaborar nossos cÂ´odigos. Entendemos, que tais programas podem nËœao ser os mais
eï¬cientes no que diz respeito a tempo de execuÂ¸cËœao e espaÂ¸co de armazenamento de dados,
contudo, a ideia era propor um material que permitisse interligar o ensino de uma linguagem
de programaÂ¸cËœao com o entendimento dos resultados e de suas provas. Todos os programas
foram desenvolvidos pelo autor desta dissertaÂ¸cËœao. Vale ressaltar que, alÂ´em de construir um
programa Â´e importante tambÂ´em vË†e-lo sendo executado linha a linha para entender seu
funcionamento. Sugerimos consultar (Philip Guo, 2018) para tal ferramenta. A visualizaÂ¸cËœao
da execuÂ¸cËœao de um programa, alÂ´em de facilitar o entendimento das estruturas bÂ´asicas (if ,
while e for ), estimula a busca por cÂ´odigos mais enxutos.

O autor desta dissertaÂ¸cËœao Â´e professor no Instituto Federal de GoiÂ´as (IFG), CË†ampus
Itumbiara. Pretende-se, como trabalho futuro, adaptar esta dissertaÂ¸cËœao em um projeto
de ensino voltado para estudantes do nÂ´Ä±vel mÂ´edio. O IFG de Itumbiara contÂ´em uma
infraestrutura favorÂ´avel `a execucËœao do projeto, pois conta com quatro laboratÂ´orios de
informÂ´atica e internet em todas salas. Assim, acredita-se que este projeto irÂ´a complementar
a formaÂ¸cËœao dos estudantes apresentando-lhes uma linguagem de programaÂ¸cËœao moderna e
tÂ´opicos de Teoria dos nÂ´umeros, assunto praticamete esquecido no ensino mÂ´edio.

Ressalta-se ainda que o autor pretende incrementar o material jÂ´a proposto nesta
dissertaÂ¸cËœao, focando na construÂ¸cËœao de cÂ´odigos acerca de outros assuntos em MatemÂ´atica,
tais como, matrizes, grÂ´aï¬cos, trigonometria, funÂ¸cËœoes elementares e estatÂ´Ä±stica. AlÂ´em disso,
pretende-se trabalhar com os alunos mais sobre a linguagem Python: suas bibliotecas,
jogos, orientaÂ¸cËœao `a objeto, banco de dados, dentre outros assuntos.

77

ReferË†encias

HEFEZ, A. Elementos de AritmÂ´etica, 2a EdiÂ¸cËœao, Rio de Janeiro. [S.l.]: SBM,
2011.

LEITE, P. F. NÂ´umeros de fermat. Revista do Professor de MatemÂ´atica, v. 07, 1985.

LIMA, E. L. et al. A matemÂ´atica do ensino mÂ´edio, vol. 2. ColeÂ¸cao do Professor de
MatemÂ´atica, SBM, 2006.

Masanori. Python Zumbi 0. 2018. DisponÂ´Ä±vel em: <https://www.youtube.com/watch?
v=6La690qlH5w&list=PLUukMN0DTKCtbzhbYe2jdF4cr8MOWClXc>. Acessado em
07/09/2018.

MENEZES, N. N. C. IntroduÂ¸cËœao `a programaÂ¸cËœao com Pythonâ€“2a ediÂ¸cËœao:
Algoritmos e lÂ´ogica de programaÂ¸cËœao para iniciantes. [S.l.]: Novatec Editora, 2016.

Mersenne Researchs . Prime numbers records. 2018. DisponÂ´Ä±vel em: <https:
//www.mersenne.org/primes/>. Acessado em 06/09/2018.

MORAN, J.; MASETO, M. T.; BEHRENS, M. A. Novas Tecnologias E MediaÂ¸cËœao
PedagÂ´ogica. [S.l.]: Papirus, 2013. (ColeÂ¸cËœao Papirus EducaÂ¸cËœao). ISBN 9788530805944.

MOREIRA, C. G. T. d. A.; SALDANHA, N. C. Testes de primalidade: probabilÂ´Ä±sticos
e determinÂ´Ä±sticos. [S.l.: s.n.], 2011.

PENHA, G. de la. Euler e a teoria dos nÂ´umeros. Revista do Professor de MatemÂ´atica,
v. 04, 1983.

Philip Guo. Python tutor. 2018. DisponÂ´Ä±vel em: <http://pythontutor.com/>. Acessado
em 15/01/2018.

Python Brasil. Empresas Python. 2018. DisponÂ´Ä±vel em: <https://python.org.br/
empresas/>. Acessado em 07/09/2018.

Python ORG. Interative Python Online. 2018. DisponÂ´Ä±vel em: <https:
//www.python.org/shell/>. Acessado em 05/01/2018.

. Python Documents. 2018. DisponÂ´Ä±vel em: <https://docs.python.org/3/library/

math.html>. Acessado em 07/09/2018.

78

ReferË†encias

. Python Download. 2018. DisponÂ´Ä±vel em: <https://www.python.org/>.

Acessado em 12/01/2018.

SIDKI, S. IntroduÂ¸cËœao `a teoria dos nÂ´umeros. [S.l.]: IMPA, 1975.

SILVA, H. A. d. Regimento do profmat - sbm. 2016.

SUMMERFIELD, M. ProgramaÂ¸cËœao em Python 3: Uma introduÂ¸cËœao completa `a
linguagem Python. [S.l.]: Alta Books, 2012. (Biblioteca do Programador).

The Prime Pages . Prime numbers. 2018. DisponÂ´Ä±vel em: <https://primes.utm.edu/
largest.html#Mersenne>. Acessado em 05/09/2018.

WATANABE, R. NotÂ´Ä±cias espetaculares. Revista do Professor de MatemÂ´atica, v. 82,
p. 2â€“6, 2013.

