UNIVERSIDADE FEDERAL DO ESTADO DO RIO DE JANEIRO 
CENTRO DE CIÊNCIAS EXATAS E TECNOLOGIA 
CURSO DE PÓS-GRADUAÇÃO EM MATEMÁTICA 

SISTEMA DE CRIPTOGAFIA RSA 

JOÃO GREGÓRIO CORRÊA NETO 

RIO DE JANEIRO/RJ 
2013 

1 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
João Gregório Corrêa Neto 

SISTEMA DE CRIPTOGAFIA RSA 

Trabalho de Conclusão de Curso apresentado 
ao Programa de Pós-graduação em 
Matemática PROFMAT da UNIRIO, como 
requisito para a obtenção do grau de MESTRE 
em Matemática.  

Orientador: Silas Fantin 
Doutor em Matemática – USP 

Rio de Janeiro 
2013 

2 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Gregório, João Corrêa Neto 

Sistema de criptografia RSA / João Gregório Corrêa Neto – 2013 
84.p 

João Gregório Corrêa Neto 

1.Matemática 2. Álgebra. I. Título 

SISTEMA DE CRIPTOGAFIA RSA 

3 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
4 

 
 
Dedicatória 

Dedico  a  Deus,  por  ter  consentido  que  eu 

realizasse este trabalho iluminando, nas horas mais 

difíceis,  a  minha  caminhada  para  que  eu  atingisse 

os  meus  objetivos,  a  minha  esposa  Ana  Paula 

que  me 

apoiou  nos  momentos  de 

dificuldade,  meus  filhos  Ana  Beatriz  e  João 

Guilherme  que  se  privaram  da  minha  presença 

em muitos finais de semana e feriados e souberam 

entender que é o melhor para todos, ao meu pai em 

memória, pois esse era um dos sonhos dele, minha 

mãe e a todos meus amigos que de alguma maneira 

puderam me ajudar. 

5 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Resumo 

Este  trabalho  de  conclusão  de  curso  do  programa  de  Pós-graduação  em 

matemática  PROFMAT  da  UNIRIO  apresenta  um  resumo  histórico  sobre  o 

desenvolvimento da  criptografia,  as ideias a partir das quais  foram  criados  alguns dos 

métodos  de  criptografia  atuais  e  culmina  na  apresentação  do  sistema  de  criptografia 

RSA. 

Esse trabalho foi desenvolvido em conjunto com o trabalho do professor Sérgio 

Santos Corrêa Junior cujo tema é Criptografia Via Curvas Elípticas. Em ambos há pré-

requisitos comuns e o mesmo resumo histórico. 

Houve  uma  grande  preocupação  com  o  uso  de  uma  linguagem  adequada  a 

alunos  do  ensino  médio,  por  isso  algumas  demonstrações  foram  adaptadas  e  outras 

omitidas,  por  exigirem  conhecimentos  específicos  que  vão  muito  além  da  grade 

curricular desses estudantes Ao final do trabalho há uma proposta de algumas atividades 

que podem ser aplicadas a esses alunos. Tanto ao longo do desenvolvimento do trabalho 

quanto nas atividades propostas ao final, foi usado o programa computacional gratuito 

Geogebra e a calculadora do Windows.  

Palavras-chaves: Criptografia, RSA, PLD, PDH. 

6 

 
 
 
 
 
 
 
 
 
 
Abstract 

This  Graduate 

final  project  of 

the Graduation  program in Mathematics, 

PROFMAT,  of  UNIRIO  presents  a  summary  of 

the  historical  development 

of cryptography, the 

ideas from  which were  created some of 

its  current  methods 

and culminates with the RSA cryptosystem. 

This  work  was  developed  jointly  with  Professor  Sergio  dos  Santos  Correia 

Junior whose theme is based on Crytography via Eliptic Curves. These works have both 

the same pre requisites and the same common historical summary. 

There was a great concern with the use of appropriate language for high school 

students.  So,  some  demonstrations  were  adapted  and  others  omitted  for  going  far 

beyond  the  mathematics  high  school  curriculum.  In  the  final  part  of  this  project  we 

present some activities that can be applied to the high school students. The technology 

tools  used  in  the  proposed  activities  are  the  free  software  Geogebra  and  the  windows 

calculator. 

Keywords: Crytography, RSA, PLD, PDH. 

7 

 
 
 
 
 
 
 
 
 
 
Agradecimento 

Agradeço, sinceramente 

A  minha  querida  e  amada  esposa  Ana  Paula  que  me  apoiou  nos 

momentos de dificuldade e aguentou meus momentos de stress.  

Aos meus maravilhosos filhos Ana Beatriz e João Guilherme que são 

tudo para mim. 

Ao  professor  Silas,  o  orientador  desse  trabalho,  que  com  muita  dedicação  e 

talento soube ajudar e contribuir de modo decisivo para essa obra.  

A  todos  os  professores  da  UNIRIO,  porque  levaram  a  sério  com  dedicação  e 

profissionalismo o curso de mestrado e fortaleceram a minha formação. 

Ao  meu  pai  que  sempre  me  incentivou  e  partiu  durante  o  curso  e  não  pode 

realizar o seu sonho de ver seu filho mestre, minha mãe que eu amo. 

Ao meu amigo Daniel que me incentivou e ajudou sempre no que pode. 

A PMDC, que me concedeu uma licença para estudos, pois sem isso eu não teria 

conseguido.  

A CAPES, pelo suporte financeiro, que permitiu a realização deste trabalho. 

8 

 
 
 
 
 
 
 
 
 
 
 
 
Sumário 
INTRODUÇÃO .............................................................................................................. 10 

CAPÍTULO 1 ................................................................................................................. 12 

1.1 O CÓDIGO DE CÉSAR ....................................................................................... 12 

1.2  A CIFRA INDECIFRÁVEL ................................................................................ 16 

1.3  MECANIZAÇÃO DO SIGILO ........................................................................... 24 

CAPÍTULO 2 ................................................................................................................. 28 

2.1 PRINCÍPIO DE INDUÇÃO E CONGRUÊNCIA ................................................ 28 

2.2  NÚMEROS DE FERMAT E DE MERSENNE .................................................. 32 

CAPÍTULO 3 ................................................................................................................. 37 

3.1 ALGORITMO PARA O CÁLCULO DE POTÊNCIAS ...................................... 37 

3.2 O PROBLEMA DO LOGARITMO DISCRETO ................................................ 44 

3.3 PROTOCOLO DE DIFFIE-HELLMAN(PDH) – CHAVE TROCADA ............. 49 

3.4 O SISTEMA PÚBLICO DE CRIPTOGRAFIA ELGAMAL .............................. 52 

CAPÍTULO 4 ................................................................................................................. 54 

4.1 FORMULA DE EULER E RAIZES MÓDULO  p.q ........................................... 55     

4.2 SISTEMA DE CRIPTOGRAFIA RSA ................................................................ 62 

4.3 A SEGURANÇA DO MÉTODO ......................................................................... 72 

4.4 ALGORITMO  DE FERMAT .............................................................................. 72 

CAPÍTULO 5 ................................................................................................................. 77 

5.1.  ATIVIDADES  ................................................................................................... 77 

5.2.  SOLUÇÔES DAS ATIVIDADES  ..................................................................... 77 

APENDICE .................................................................................................................... 81 

CONCLUSÃO ................................................................................................................ 83 

BIBLIOGRAFIA ............................................................................................................ 84 

9 

 
 
 
 
 
 
 
 
 INTRODUÇÃO 

A  necessidade  de  troca  de  informações  entre  os  seres  humanos,  sem  perigo  de 

interceptação,  existe  desde  os  tempos  da  Roma  antiga.  Foi  lá  que  surgiu  o  código  de 

César, que consistia numa forma de embaralhar as letras de uma mensagem. 

Em  virtude  da  proliferação  dos  meios  de  comunicação  e  da  necessidade  de 

enviar  numerosas  mensagens  –  transferências  bancárias,  cartas  de  instruções  para 

compra  de  ações,  informações  diplomáticas  secretas,  relatórios  de  atividades  de 

espionagem – tornou-se muito desejável desenvolver métodos confiáveis de codificação 

de mensagens. 

No passado os códigos eram secretos, apenas pelos que enviavam e recebiam as 

mensagens,  mas  sempre  havia  a  possibilidade  de  estudar  mensagens  interceptadas  e 

decifrá-las.  

A  criptografia  (do  grego  Kryptós   “escondido”  e   gráphein   “escrita”)  é  a  ciência  

que estuda as formas e técnicas pelas quais a informação pode ser transformada da sua 

forma  original  para  outra  ilegível  aos  que  não  tem  acesso  as  convenções  previamente 

estabelecidas,  e  a  criptoanálise  é  a  ciência  que  estuda  as  formas  de  se  decifrar  tais 

informações.  

Com o aparecimento dos computadores, novas formas de codificar as mensagens 

foram  criadas,  de  modo  que  os  usuários  pudessem  se  comunicar  com  proteção. 

Entretanto, essa tecnologia estava restrita a governos e organizações militares.  

Atualmente  a  criptografia  consiste  em  uma  série  de  fórmulas  matemáticas,  em 

que se utiliza um segredo (chamado de chave) para cifrar e decifrar as mensagens. Este 

segredo pode ser o mesmo para as duas operações (criptografia simétrica) ou pode haver 

segredos diferentes, um para cifrá-la e outro para decifrá-la (criptografia assimétrica).  

O  objetivo  principal  deste  trabalho  é  estudar  as  principais  características  de 

alguns  sistemas  de  criptografia,  onde  explanaremos  sobre  sua  simplicidade  e  a 

extrema  dificuldade  de  se  violar  o  código  através  da  utilização  de  alguns  destes 

sistemas, onde tentaremos situar os leitores cronologicamente sobre os personagens que 

contribuíram  com  o  assunto  abordado.  A  contribuição  inicial  para  os  sistemas  de 

10 

 
 
 
 
  
 
 
 
 
criptografia  modernos  foi  proposta  em  1976  por  Diffie  e  Hellman  e  sua  efetiva 

execução  foi  conseguida  por  Rivest,  Shamir  e  Adleman,  conhecido  como  sistema  de 

criptografia RSA.   

No primeiro  capítulo,  apresentaremos  alguns métodos  de  criptografia antigos  e 

um resumo histórico, mostrando como a criptografia contribuiu para o desenvolvimento 

tecnológico.  

No  segundo  capítulo,  apresentaremos  os  conceitos  preliminares  e  a  noção  de 

número  primo,  que  será  o  ingrediente  fundamental  para  o  desenvolvimento  deste 

trabalho,  além  de  alguns  algoritmos  de  fatoração,  em  virtude  da  fatoração  de  grandes 

inteiros  ser  um  problema  extremamente  difícil,  e  de  algoritmos  para  o  cálculo  de 

potências de números com centenas de dígitos.  

No terceiro capítulo, apresentaremos o Problema do Logaritmo Discreto 

(PLD),  o  Protocolo  de  Diffie  e  Hellman  (PDH)  e  o  sistema  público  de  criptografia 

ElGamal, que servem de base para alguns sistemas de criptografia. O sistema ElGamal é 

um meio alternativo de criptografia, isento de patente, que foi criado para competir com 

o patenteado sistema de criptografia RSA.   

No  quarto  capítulo  descreveremos  o  sistema  de  criptografia  RSA,  explicando, 

dando exemplos e mostrando a segurança do método.  .   

Finalmente, no quinto capítulo, proporemos algumas atividades, que podem ser 

aplicadas em sala de aula, relacionadas com a abordagem desenvolvida neste trabalho. 

11 

 
 
 
 
 
 
 
 
 
 
 
CAPÍTULO 1 

Durante  milhares  de  anos,  reis,  rainhas  e  generais  dependeram  de  uma 

comunicação  eficiente  para  governar  e  comandar  seus  exércitos.  Ao  mesmo  tempo, 

todos  conheciam  as  consequências  de  suas  mensagens  caírem  em  mãos  inimigas, 

revelando  segredos  preciosos.  O  risco  da  interceptação  pelo  inimigo  motivou  o 

desenvolvimento de códigos e cifras, técnicas para mascarar uma mensagem de maneira 

que só o destinatário possa ler seu conteúdo. 

Esta busca pelo segredo levou as nações a criarem departamentos especializados 

em elaborar códigos que garantissem a segurança das comunicações.  Ao mesmo tempo, 

os  decifradores  de  códigos  inimigos  tentavam  quebrar  esses  códigos,  para  descobrir 

seus segredos. Esta batalha entre criadores de códigos e decifradores desenvolveu uma 

corrida  armamentista  intelectual  que  teve  um  grande  impacto  no  curso  da  história 

humana.  Seus  esforços  para  preservar  ou  destruir  o  sigilo  enriqueceram  várias  áreas, 

como a linguística, a teoria quântica e a Matemática.  

1.1 O código de César 

Um dos  códigos mais  simples consiste em  substituir cada letra do alfabeto por 

outra.  Este  método  recebe  o  nome  de  substituição  monoalfabética.  O  primeiro 

documento, de que se tem  notícia, que usou  uma cifra de substituição para propósitos 

militares  aparece  na  guerra  da  Gália  de  Júlio  César.  Segundo  As  vidas  dos  Césares, 

escrito no século II por Suetônio, um dos tipos de cifra de substituição usada por Júlio 

César consistia em substituir cada letra do alfabeto por outra que estivesse três casas à 

frente, onde a primeira linha consiste do alfabeto original e a segunda linha o alfabeto 

codificado. Na cifra de César, não eram considerados acentos nem os espaços entre as 

palavras.  

a  b  c  d  e 

f  g  h 

i 

j 

k 

l  m  n  o  p  q  r 

s 

t 

u  v  W  x  y  z 

D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  A  B  C 

12 

 
 
 
Como  exemplo,   o   texto   codificado   “PDWHPDWLFDHGLYHUWLGR”   significa  

“Matemática  é  divertido”.   

Apesar  de  Suetônio  só  mencionar  que  César  deslocava  as  letras  em  três  casas, 

não  é  difícil  imaginar  que  podemos  deslocar  de  uma  a  vinte  cinco  casas,  obtendo  25 

codificações  distintas.  Também é claro que se um  inimigo souber que  a  cifra  foi feita 

deslocando-se  as  letras  em  algum  número  de  casas,  ele  poderá,  em  no  máximo  25 

tentativas,  descobrir  a  chave  e  cifrar  a  mensagem.    No  entanto,  se  permitirmos  que  a 

cifra  seja  feita  por  qualquer  rearranjo  do  alfabeto  original,  então  teremos  muitas 

possibilidades,  dificultando  o  trabalho  do  inimigo,  conforme  apresentado  na  primeira 

linha o alfabeto original e na segunda linha o alfabeto cifrado. 

a  b  c  d  e 

f  g  h 

i 

j 

k 

l  m  n  o  p  q 

r 

s 

t  u  v  W  x  y  z 

V  E  J  I  C  A  N  B  L  M  R  T  D  O  W  F  K  Q  G  Y  Z  H  P  S  U  X 

Esse  é  um  exemplo  de  uma  permutação  das  letras,  obtendo  uma  nova  cifra. 

Sabemos  que  são  muitas  cifras  possíveis,  mas  podemos  calcular  o  número  exato.  Se 

aceitarmos  que  cada  letra  possa  ser  substituída  por  outra  ou  por  ela  mesma,  mas  sem 

repetição de letras, ou seja, duas letras distintas não podem ser substituídas pela mesma 

letra, então podemos usar um raciocínio bem conhecido: 

Para substituirmos a letra a existem 26 possibilidades e, para cada uma dessas, 

existem 25 possibilidades para substituirmos a letra b (uma já foi usada pela letra a) e, 

para cada modo de substituir a e b, há 24 substituições possíveis para a letra c (já foram 

usadas duas possibilidades, uma para a letra a e outra para a letra b), e assim por diante 

até  que  para  a  letra  z  restará  uma  única  possibilidade.  Pelo  princípio  multiplicativo, 

chegamos ao número.  

26  . 25  . 24 … 2  .1 = 26  ! (  𝑣𝑖𝑛𝑡𝑒  𝑒  𝑠𝑒𝑖𝑠  𝑓𝑎𝑡𝑜𝑟𝑖𝑎𝑙  ) 

Com o auxílio de um computador encontramos  

26! = 403.291.461.126.605.635.584    𝑥  10(cid:2874)   

13 

 
 
 
 
Observe que 26! é um número gigantesco de cifras, mas neste cálculo admitimos 

que uma letra seja substituída por ela mesma, o que obviamente não é uma boa ideia, 

principalmente se isso ocorrer com várias letras.  

Uma  pergunta  natural  que  surge  é  como  podemos  calcular  o  número  de 

permutações em que nenhuma letra é substituída por ela mesma?  

O  matemático  Leonhard  Euler 
(1707-1783)  encontrou  uma  solução  genial 
para  esse  tipo  de  problema.  As  permutações 
em  que  nenhum  elemento  aparece  em  sua 
de 
original 
posição 
PERMUTAÇÕES 
ou 
DESARRANJOS. 

CAÓTICAS 

chamadas 

são 

O  número  de  cifras  de  substituição  simples  em  que  nenhuma  letra  seja 

substituída por ela mesma é dado por  

𝐷(cid:3041) = 26! (cid:3436)  

1
2!

−   

1
3!

+   

1
4!

−   

1
5!

+ ⋯ + (−1)(cid:2870)(cid:2874) 1
26!

  (cid:3440) 

Usando um computador encontramos  

𝐷(cid:2870)(cid:2874) = 148.362.637.348.470.135.821.287.825   ≅   148  𝑥  10(cid:2870)(cid:2872) 

Mesmo que alguém conseguisse verificar uma cifra por segundo, seriam  necessários a 

seguinte quantidade de anos para se verificar manualmente todas as cifras possíveis  

𝑁 = 4.704.548.368.482.690.760   ≅ 4  𝑥  10(cid:2869)(cid:2876) 

A simplicidade e a força da cifra de substituição fizeram com que ela dominasse 

a arte da escrita secreta durante o primeiro milênio. Os estudiosos achavam que as cifras 

de substituição eram indecifráveis.  

Os  criptoanalistas  árabes  descobriram  um  método  para  quebrar  a  cifra  de 

substituição  monoalfabética.  Eles  perceberam  que  algumas  letras  aparecem  com  mais 

frequência que outras.  As letras  a e  i são as mais comuns no idioma Árabe, enquanto 

que a letra j aparece com uma frequência dez vezes menor. 

14 

 
 
 
   
   
     
 
 
                                                                         
              
     
 
                                                                            
 
Embora não se saiba quem foi o primeiro a perceber que a frequência das letras 

podia  ajudar  a  quebra  de  códigos,  a  descrição  mais  antiga  desta  técnica  vem  de  um 

cientista  do  século  IX,  Abu  Yusef  Ya’qub   ibn   Is-haq  ibn  as-Sabbah  ibn  Omran    ibn 

Ismail al-Kindi,  conhecido  como  o  “filósofo  dos  Árabes”. 

Para  decifrar  uma  mensagem  através  desse  método,  é  necessário,  em  primeiro 

lugar, conhecer o idioma e contar a frequência com que cada letra aparece em um texto 

bastante longo. Em seguida, deve-se contar a frequência com que cada símbolo aparece 

no criptograma que se deseja decifrar.  

Deste  modo,  o  símbolo  mais  comum  no  criptograma  deve  ser  substituído  pela 

letra mais comum; o segundo símbolo mais frequente deve ser transformado na segunda 

letra com maior frequência e assim por diante. 

Por  exemplo,  a  frequência  média  de  cada  letra  na  língua  portuguesa  é  dada  na 

tabela. 

Letra 

% 

Letra 

A 

B 

C 

D 

E 

F 

14,64 

1,04 

3,88 

4,10 

12,57 

1,02 

G 

H 

I 

J 

L 

M 

% 

1,3 

1,28 

6,18 

0,40 

2,78 

4,75 

Letra 

N 

O 

P 

Q 

R 

S 

% 

5,05 

10,73 

2,52 

1,20 

6,53 

7,81 

Letra 

T 

U 

V 

X 

Z 

% 

4,34 

4,64 

1,70 

0,21 

0,47 

Assim,  apenas  contando  a  frequência  de  cada  símbolo  no  texto,  podemos 

descobrir a  que  letra  correspondem  os  símbolos  mais  frequentes.    Isto  geralmente é 

suficiente para decifrar o código, mas só funciona bem se a mensagem for longa. É fácil 

escrever uma mensagem curta cuja contagem de frequência seja totalmente diferente 

da contagem de frequência média do português.  

Por  exemplo,  em  “Zuza  zoou  da  Zezé”  a  letra  mais  frequente  é  o  Z  que  aparece  

5  vezes  em  um  texto  com  14  letras.  Com 

𝟓

𝟏𝟒

≅ 𝟑𝟓%,  a  porcentagem  do  Z  no  texto 

acima é muito maior que os usuais 0,47%. Já o A aparece uma só vez, o que da uma 

porcentagem de cerca de 7%; portanto abaixo dos 14% usuais. 

15 

 
 
 
 
 
 
1.2. A Cifra Indecifrável  

Como  a  análise  de  frequência  destruiu  a  segurança  da  cifra  de  substituição 

monoalfabética, os cifradores se empenharam na criação de outras cifras.  

O 

Francês 
diplomata 
Blaise  de  Vigenère  (1523-1596),  se 
destacou  nessa  tarefa,  criando 
uma  cifra  poderosa  conhecida 
como  Le  Chiffre  Indéchiffrable 
(a cifra indecifrável). 

A ideia de Vigenère foi usar não apenas um, mas 26 alfabetos cifrados distintos. 

Para  isso  criou  uma  tabela  com  o  alfabeto  real  e  mais  26  alfabetos  cifrados,  cada  um 

deslocando uma letra em relação ao alfabeto anterior. 

16 

 
 
 
 
 
 
 
 
 
 
 
 
Com o auxílio dessa tabela, cada letra pode ser cifrada usando qualquer uma das 

26 linhas. Por exemplo, a letra G cifrada pela linha 16 se transforma na letra W e a letra 

P cifrada pela linha 23 se transforma na letra M, conforme pode ser observado na tabela 

a seguir. 

Assim, o remetente de uma mensagem pode usar, por exemplo: 

  A linha 09 para cifrar a primeira letra de seu texto,  

  A linha 15 para a segunda letra,  

  A linha 05 para a terceira letra e assim por diante,  

evitando que uma determinada letra seja sempre substituída por uma mesma letra.  

Para que o destinatário possa decifrar a mensagem é necessário que ele saiba que 

linha  foi  utilizada  em  cada  posição  da  mensagem,  exigindo  um  sistema  previamente 

combinado  para  a  mudança  entre  as  linhas.  Para  isso  utilizava-se  uma  palavra  chave, 

que  precisava  ser  compartilhada  previamente  entre  o  remetente  e  o  destinatário  da 

mensagem, o que muitas vezes era um problema, principalmente quando essas pessoas 

não podiam se encontrar para combinar a chave. 

17 

 
 
 
 
Cada  letra  da  palavra-chave  identificava  uma  linha  da  tabela  e  cada  linha  era 

identificada pela primeira letra à sua direita:  

  A linha 1 era identificada pela letra B,  

  A linha 2 pela letra C,  

  A linha 3 pela letra D e assim por diante,  

até a linha 26, que era identificada pela letra A. 

Para entendermos como funcionava a palavra-chave,  vamos  cifrar  a  frase  “Estou  

de   férias”   usando  a  palavra-chave   “PONTE”.   Primeiro   escrevemos   a   palavra-chave 

repetidas  vezes,  até  que  cada  letra  da  palavra-chave  corresponda  a  uma  letra  da  frase 

que se deseja enviar. 

P 

E 

O 

S 

N 

T 

T 

O 

E 

U 

P 

D 

O 

E 

N 

F 

T 

E 

E 

R 

P 

I 

O 

A 

N 

S 

18 

 
 
 
 
 
Desta forma, temos que: 

  A letra E, será cifrada pela linha 15 (correspondente à letra P na tabela), 

transformando-se em T 

  A letra S será cifrada pela linha 14 (correspondente à letra O na tabela), 

transformando-se em G 

  A letra T será cifrada pela linha 13 (correspondente à letra N na tabela), 

transformando-se em G 

  A letra O será cifrada pela linha 19 (correspondente à letra T na tabela), 

transformando-se em H 

  A letra U será cifrada pela linha 04 (correspondente à letra E na tabela), 

transformando-se em Y 

  A letra D será cifrada pela linha 15 (correspondente à letra P na tabela), 

transformando-se em S 

  A letra E será cifrada pela linha 14 (correspondente à letra O na tabela), 

transformando-se em S 

  A letra F será cifrada pela linha 13 (correspondente à letra N na tabela), 

transformando-se em S 

  A letra E será cifrada pela linha 19 (correspondente à letra T na tabela), 

transformando-se em X 

  A letra R será cifrada pela linha 04(correspondente à letra E na tabela), 

transformando-se em V 

  A letra I será cifrada pela linha 15(correspondente à letra P na tabela), 

transformando-se em X 

  A letra A será cifrada pela linha 14(correspondente à letra O na tabela), 

transformando-se em O 

  A letra S será cifrada pela linha 13(correspondente à letra N na tabela), 

transformando-se em F 

A frase cifrada (codificada) fica  

TGGHYSSSXVXOF 

19 

 
 
 
 
Conforme pode ser observado na tabela abaixo 

É óbvio que qualquer pessoa que conheça a palavra-chave pode decifrar uma 

mensagem cifrada pelo método de Vigenère. Mas e sem essa chave? Você conseguiria 

decifrar as mensagens abaixo sem a palavra-chave? 

TPICQFZCTUFSMQPUD 

QOPVNVSERYNQFV 

PJSWLZFVZJCUZXNYOPVCOI 

RSOCAIPCZHSFUUNIB 

UODTYXYHLGTRLPABSIXDU 

LDVKOEOLEIAACBEONIEV 

BPONPUFVZJCUZ 

Se  você  não  conseguiu  não  fique  frustrado,  pois  realmente  é  muito  difícil 

decifrar  sem  conhecer  a  chave.  Para  se  ter  uma  ideia,  foram  necessários  mais  de  300 

20 

 
 
 
 
 
 
 
 
(trezentos) anos para que alguém conseguisse decifrar uma mensagem sem conhecer a 

palavra-chave.  

lado 

Charles  Babbage  (1791-1871)  na 
foto 
e  Friedrich  Kasiski 
ao 
conseguiram  tal  feito,  independentemente 
um  do  outro.  Kasisk  ainda  publicou  este 
avanço 
no  Die 
Geheimschriften  und  die  Dechiffrir-kunst 
(A escrita secreta e a arte de decifrá-la). 

criptoanálise 

da 

 Mesmo conhecendo as técnicas desenvolvidas por Babbage e Kasisk pode-se 

levar bastante tempo tentando decifrar uma mensagem sem conhecer a palavra-chave. A 

palavra-chave  usada  na  cifra  da  mensagem  anterior  é  PAULINHO.  Tente  decifrar  a 

mensagem. A resposta  é  um  trecho  da  música  “Solução  de  vida”  de  Paulinho  da  Viola. 

E por isso eu lhe digo 

Que não é preciso 

Buscar solução para a vida 

Ela não é uma equação 

Não tem que ser resolvida 

A vida, portanto, meu caro 

Não tem solução 

Podemos  equacionar  a  criptografia  e  a  descriptografia  da  cifra  de  Vigenère. 

Como são 26 letras, podemos pensar em congruência módulo 26, ou seja, nos restos das 

divisões por 26. Assim teremos  

𝐵 = 1 

𝐶 = 2 

𝐷 = 3 

. .. 

𝑍 = 25 

𝐴 = 0 

Observe que o valor de cada letra na tabela de Vigenère é côngruo à soma dos 

valores da linha e da coluna à qual ela pertence, módulo 26. 

21 

 
                                                                                             
 
 
 
 
 
 
 
 
  A letra J destacada acima está na linha 9 e coluna 0(zero). 

0   +   9   ≡   9  (𝑚𝑜𝑑  26) e 9 é o valor atribuído à letra J. 

  A letra D destacada acima está na linha 15 e coluna 14.  

15   +   14   ≡   3  (𝑚𝑜𝑑  26) e 3 é o valor atribuído à letra D. 

  A letra P destacada acima está na linha 21 e coluna 19.  

21   +   19   ≡   14  (𝑚𝑜𝑑  26) e 14 é o valor atribuído à letra P. 

Se quisermos saber que letra se encontra na linha 17 e coluna 22, basta calcular 

 17   +   22     ≡ 13  (𝑚𝑜𝑑  26). 

A letra que está nesta posição é a letra representada pelo número 13, ou seja, é a 

letra N. 

Portanto, para criptografar podemos somar o número que representa a letra que 

queremos cifrar (coluna) com a letra da palavra-chave que será utilizada (linha) e tomar 

o resto da divisão dessa soma por 26.  O valor desse resto é a letra criptografada. 

22 

 
 
 
 
 
 
De modo geral, se α representa o número de uma letra do texto real, λ o número 

da letra da palavra-chave correspondente a essa letra real, podemos calcular  β, o valor 

da letra codificada, pela equação: 

𝛽   ≡   𝛼     +   𝜆  (𝑚𝑜𝑑  26) 

Analogamente, para decodificada, basta calcular α tal que: 

𝛼   ≡   𝛽   −   𝜆  (𝑚𝑜𝑑  26) 

Por  exemplo,  vamos  codificar  a  palavra  MESTRADO  usando  a  palavra-chave 

KZW 

K 

10 

M 

12 

Z 

25 

E 

4 

W 

22 

S 

18 

K 

10 

T 

19 

Z 

25 

R 

17 

W 

22 

A 

0 

K 

10 

D 

3 

Z 

25 

O 

14 

Codificando, temos que:  

10   +   12   ≡   22  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑊 

25   +   4   ≡   3  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝐷 

22   +   18   ≡   14  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑂 

10   +   19   ≡   3  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝐷 

25   +   17   ≡   16  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑄 

22   +   0   ≡   22  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑊 

10   +   3   ≡   13  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑁 

25   +   14   ≡   13  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑁 

A palavra codificada ficou WDODQWNN, vamos agora decodificar:  

22   −   10   ≡   12  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑀 

3   − 25   ≡    −22  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝐸 

14   −   22   ≡    −8  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑆 

3   −   10   ≡    −7    (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑇 

16   −   25   ≡    −9    (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑅 

22   −   22   ≡   0  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝐴 

13   −   10   ≡   3  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝐷 

13   −   25   ≡    −12  (𝑚𝑜𝑑  26) ⇒   𝑙𝑒𝑡𝑟𝑎  𝑂 

23 

 
 
 
 
 
 
 
 
1.3.  MECANIZAÇÃO DO SIGILO 

Desde  que  Babbage  e  Kasiski  destruíram  a  segurança  da  cifra  de  Vinegère, 

nenhum  outro  método  eficaz  de  criptografia  foi  inventado.  Com  o  surgimento  do 

telégrafo,  no  século  XIX,  e  principalmente  após  a  invenção  do  rádio,  por  Guglielmo 

Marconi, na virada do século, era desejada a criação de uma nova cifra que permitisse 

que os homens de negócio  e  os militares explorassem a rapidez das  telecomunicações 

com segurança. 

inventor  alemão 
Em  1918  o 
-1925) 
Arthur  Scherbius 
desenvolveu uma máquina criptográfica 
chamada  ENIGMA,  que  ficou  muito 
conhecida na 2ª guerra mundial. 

(1878 

A máquina Enigma consistia em um certo número de componentes engenhosos, 

como  os  modificadores,  que  eram  peças  que  giravam  a  cada  tecla  usada,  alterando  a 

cifra. 

24 

 
 
 
                                                                                             
 
 
 
 
 
 
Em 1925 Scherbius começou a produção em massa das máquinas enigmas. Nas 

duas  décadas  seguintes  os  militares  alemães  compraram  30  mil  dessas  máquinas.  As 

Máquinas Enigmas se mostraram tão eficientes que os Britânicos e Franceses desistiram 

de  tentar  decifrar  as  mensagens  criptografadas  por  essas  máquinas  e  passaram  essa 

tarefa para os Poloneses.  

Somente  em  1939  os  segredos  da  Enigma  foram  completamente  desvendados 

pelos  matemáticos  Polacos  Marian  Rejewski,  Jerzy   Różycki   e   Henryk   Zygalski  

apresentados abaixo:  

   Marian Rejewski                     Jerzy  Różycki                                   Henryk Zygalski    

Essa façanha exigiu muito trabalho e dedicação e contou até com a traição de um 

Alemão  chamado  Hans-Thilo  Schmidt,  que  vendeu,  para  um  agente  secreto  Francês, 

dois documentos que explicavam o uso da máquina enigma. A busca por novos atalhos 

criptográficos  era  necessária,  pois  a  máquina  Enigma  continuou  evoluindo  durante  a 

guerra.  

Os criptoanalistas eram continuamente desafiados a melhorar ou criar estratégias 

inteiramente  novas.  Houve  muitos  criptoanalistas  notáveis  e  muitos  avanços 

significativos, mas um deles merece ser destacado:  

25 

 
 
 
 
 
 
 
 
Alan Turing (1912-1954) 
identificou  a  maior  fraqueza  da 
máquina  Enigma,  conseguindo 
quebrar  a  cifra  nos  momentos 
mais difíceis. 

Com suas ideias, Turing finalizou, no início de 1940, o projeto de uma máquina 

capaz de quebrar as cifras da Enigma. Tal máquina tinha dois metros de altura, por dois 

de comprimento e um metro de largura e recebeu o nome de Bomba de Turing.  

Uma Máquina de Turing em ação 

Antes de Turing ser convidado para trabalhar como criptoanalista, ele escreveu, 

aos  26  anos,  um  artigo  sobre  uma  máquina  hipotética  capaz  de  se  adaptar  a  diversos 

problemas  de  lógica.  Esse  equipamento  imaginário  recebeu  o  nome  de  máquina 

universal de Turing e foi a primeira ideia para o nosso computador atual. 

Durante  a  Segunda  Guerra  Mundial  os  decifradores  de  códigos  britânicos 

levaram a melhor sobre os criadores de códigos alemães. Além das maquinas de Turing, 

usadas  para  quebrar  as  cifras  da  Enigma,  os  britânicos  criaram  a  máquina  Colossus, 

usada para combater uma cifra ainda mais poderosa, a cifra alemã Lorenz.  

26 

 
 
 
 
 
 
 
 
       
 
 
A  cifra  Lorenz,  feita  pela  máquina  Lorenz  SZ40,  era  usada  para  codificar  a 

comunicação entre Hitler e seus generais. Essa nova cifra era muito mais complicada e 

trouxe  um  grande  desafio  para  os  decifradores  de  códigos.  Certo  dia,  Max  Newman, 

um  matemático de  Bletchley,  apresentou,  baseando-se nas ideias de Turing, um  modo 

de mecanizar a criptoánalise da cifra Lorenz.  

Max  Newman  (1897-1984) 
a  máquina  Colossus, 
todos  os 

projetou 
considerada  a  mãe  de 
computadores. 

27 

 
                                                                                  
 
 
 
 
 
 
CAPÍTULO 2 

Os métodos de criptografia mais modernos,  assim  como  suas ideias principais, 

exigem alguns conceitos e teoremas da teoria dos números, que é o ramo da matemática 

pura  que  estuda  propriedades  dos  números  em  geral,  e  em  particular  dos  números 

inteiros.  Por  isso,  neste  capítulo,  apresentaremos  alguns  tópicos  dessa  teoria  que  são 

essenciais para a perfeita compreensão dos próximos capítulos.  

2.1. Principio da Indução e congruência  

O  principio  da  indução  é  um  método  poderoso  e  eficaz  para  verificar  se  uma 

proposição  válida  para  um  natural  𝑛,  também  é  válida  para  todos  os  naturais  maiores 

que 𝑛. O princípio de indução consiste em duas etapas: 

1.  Mostrar que a proposição é verdadeira para um natural 𝑛 qualquer; 

2.  Mostrar que se a proposição vale para um natural 𝑘 (hipótese de indução), então 

vale para o seu sucessor 𝑘   + 1 (tese de indução). 

Definição  (congruência):  Seja  𝑚  um  inteiro  positivo.  Definimos  a  relação  de 

equivalência ≡ (𝑚𝑜𝑑  𝑚)  para todo 𝑎, 𝑏   ∈   ℤ da seguinte maneira 

𝑎   ≡ 𝑏    (𝑚𝑜𝑑  𝑚)        ⇔       𝑎 − 𝑏 = 𝑘  𝑚        𝑐𝑜𝑚        𝑘   ∈   ℤ 

Dizemos  neste  caso,  que  𝑎  é  côngruo  a  𝑏  módulo  𝑚.  É  fácil  ver  que  ≡

(𝑚𝑜𝑑  𝑚)   é uma relação de equivalência, isto é, que vale as seguintes propriedades: 

  Simetria:  𝑎   ≡ 𝑎  (𝑚𝑜𝑑  𝑚)  

  Reflexiva: 𝑎   ≡ 𝑏  (𝑚𝑜𝑑  𝑚)    ⇒     𝑏   ≡ 𝑎  (𝑚𝑜𝑑  𝑚)  

  Transitiva: 𝑎   ≡ 𝑏  (𝑚𝑜𝑑  𝑚)      𝑒      𝑏   ≡ 𝑐  (𝑚𝑜𝑑  𝑚)      ⇒ 𝑎   ≡ 𝑐  (𝑚𝑜𝑑  𝑚)   

Sabemos que na divisão Euclidiana o resto é um número não negativo, porém, 

para  facilitar  os  cálculos,  muitas  vezes  trabalhamos  com  “restos  negativos”  na  teoria  de  

congruência. Por exemplo, 46   ≡ 4  (𝑚𝑜𝑑  6) ou  46   ≡    −2  (𝑚𝑜𝑑  6). 

28 

 
 
 
 
 
Propriedades de congruência: 

1)  Soma: 𝑎   ≡ 𝑏  (𝑚𝑜𝑑  𝑚) e 𝑐 ≡ 𝑑  (𝑚𝑜𝑑  𝑚)      ⇒ 𝑎 + 𝑐 ≡ 𝑏 + 𝑑  (𝑚𝑜𝑑  𝑚) 

2)  Produto: 𝑎   ≡ 𝑏  (𝑚𝑜𝑑  𝑚)    𝑒    𝑐 ≡ 𝑑  (𝑚𝑜𝑑  𝑚)      ⇒ 𝑎 ∗ 𝑐   ≡ 𝑏 ∗ 𝑑  (𝑚𝑜𝑑  𝑚) 
3)  Potência: 𝑎   ≡ 𝑏  (𝑚𝑜𝑑  𝑚)      ⇒ 𝑎(cid:3041)    ≡ 𝑏(cid:3041)  (𝑚𝑜𝑑  𝑚)   

4)  Divisão: 𝑎 ∗ 𝑐 ≡ 𝑏 ∗ 𝑐  (𝑚𝑜𝑑  𝑚)    𝑒    𝑚𝑑𝑐(𝑐, 𝑚) = 1   ⇒   𝑎   ≡ 𝑏  (𝑚𝑜𝑑  𝑚)  

5)  Corte: 𝑎 ∗ 𝑐 ≡ 𝑏 ∗ 𝑐  (𝑚𝑜𝑑  𝑚)      𝑒      𝑚𝑑𝑐(𝑐, 𝑚) = 𝑑     ⇒     𝑎   ≡ 𝑏  (𝑚𝑜𝑑  

(cid:3040)

(cid:3031)

)  

Estas  propriedades  de  congruências  são  de  fácil  verificação  e  serão  uteis  no 

decorrer do texto. Uma relação de equivalência define uma classe de equivalência. Dado 

𝑎   ∈ ℤ, sua classe de equivalência módulo 𝑚 consiste no conjunto 

𝑎(cid:3364)    = {  𝑥   ∈   ℤ;   𝑥   ≡ 𝑎  (𝑚𝑜𝑑  𝑚)  } = {  𝑥 = 𝑎 + 𝑘𝑚;     𝑘   ∈   ℤ  } 

Temos que se 𝑏   ∈ 𝑎(cid:3364)    então  𝑏  (cid:3365) =    𝑎(cid:3364). Dizemos que 𝑎 é o representante da classe, 

porém podemos escolher qualquer elemento da classe como representante. Denotaremos 

por 

ℤ

(cid:3040)ℤ

=    ℤ(cid:3040) o conjunto das classes de equivalência módulo 𝑚. Obviamente  

ℤ(cid:3040) = {  0(cid:3364), 1(cid:3364), 2(cid:3364), … , 𝑚 − 1

(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)  } 

Sobre  ℤ(cid:3040)  podemos  definir  uma  soma  quanto  um  produto  cujo  resultado 

independe da escolha dos representantes das classes: 

  Soma:      𝑎(cid:3364) + 𝑏(cid:3364) =    𝑎 + 𝑏
(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364) 
  Produto:  𝑎(cid:3364) ∗    𝑏(cid:3364) =    𝑎 ∗ 𝑏(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364) 

Definição  de  Grupo:  Um  conjunto  (𝑮,∗)  não  vazio  munido  de  uma  operação  é 

denominado um grupo se satisfaz as seguintes condições: 

 

 

 

(Existência do Elemento Neutro): ∃  𝑒   ∈ 𝐺;     𝑎 ∗ 𝑒 = 𝑒 ∗ 𝑎 = 𝑎    ∀    𝑎   ∈ 𝐺 

(Existência do Inverso):     ∀  𝑎   ∈ 𝐺,      ∃  𝑏   ∈ 𝐺;       𝑎 ∗ 𝑏 = 𝑒 

(Associativa): 𝑎 ∗ (𝑏 ∗ 𝑐) = (𝑎 ∗ 𝑏) ∗ 𝑐        ∀    𝑎, 𝑏, 𝑐   ∈     𝐺 

Proposição:[  𝑎(cid:3364)    ∈ ℤ(cid:3040)  é  𝑖𝑛𝑣𝑒𝑟𝑡𝑖𝑣𝑒𝑙  ]      ⇔      [  𝑚𝑑𝑐  (𝑎, 𝑚) = 1  ] 

Prova:  

(⇒) 𝑎   ∈    ℤ(cid:3040) é invertível ⇒  ∃  𝑏(cid:3364)    ∈    ℤ(cid:3040)    ;      𝑎(cid:3364)  𝑏(cid:3364) = 1(cid:3364)     ⇒   𝑎𝑏   ≡ 1  (𝑚𝑜𝑑  𝑚) ⇒ 𝑎𝑏 − 1 =
(−𝑘)  𝑚 ⇒ 𝑎𝑏 + 𝑘𝑚 = 1. Como 𝑚𝑑𝑐  (𝑎, 𝑚) divide 𝑎 e 𝑚. Segue    𝑚𝑑𝑐  (𝑎, 𝑚) = 1. 

29 

 
 
 
 
(⇐)  mdc   (a,m)   =   1   ⇒   ∃  𝑏, 𝑘   ∈   ℤ  𝑡𝑞    𝑎𝑏 + 𝑘𝑚 = 1  ⇒   1(cid:3364)    = 𝑎𝑏 + 𝑘𝑚  
⇒  1(cid:3364)    =    𝑎(cid:3364)  𝑏(cid:3364)  em ℤ(cid:3040) ⇒  𝑎   ∈    ℤ(cid:3040) é invertível.  

(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364) =    𝑎(cid:3364)  𝑏(cid:3364)    +    𝑘(cid:3364)  𝑚(cid:3365)  

Denotaremos por 

(ℤ𝒎)∗ = Conjunto dos elementos invertíveis de ℤ(cid:3040) 

Um número primo é um número inteiro maior do que 1, que só admite 
como  divisores  positivos  ele  próprio  e  1.  Os  demais  inteiros  maiores  que  1 
são  chamados  de  números  compostos.  Temos  que  (ℤ𝟏𝟐)∗ = (cid:3419)1(cid:3364), 5(cid:3364), 7(cid:3364), 11(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3423),  isto  é, 
são os elementos de ℤ(cid:2869)(cid:2870) que são primos com 12. 

Temos  que  (  ℤ𝒎

∗   , ∗  )  formado  pelos  elementos  invertíveis  de  ℤ(cid:3040)  formam  um 
grupo que será utilizado no sistema RSA, onde 𝑚 é o produto de dois números primos 
grandes. 

O  próximo  resultado,  conhecido  por  Pequeno  Teorema  de  Fermat  é  um 
importante e bonito resultado da teoria dos números, devido ao Jurista e Magistrado por 
profissão, Pierre de Fermat (1601-1665) que dedicava à matemática seus momentos de 
lazer. Atuou em diversas áreas da Matemática, como Cálculo Infinitesimal, Teoria dos 
Números e Probabilidade. 

Pequeno Teorema de Fermat (P.T.F):   

Se 𝑝 é primo e 𝑎 é inteiro, então 𝑎(cid:3043) ≡ 𝑎  (𝑚𝑜𝑑  𝑝) 

Prova: Para provarmos o pequeno teorema de Fermat, vamos usar o fato de que se 𝑝 é 

primo, então (cid:4672)

𝑝
𝑖

  (cid:4673) =   

(cid:3043)!
(cid:3036)!((cid:3043)(cid:2879)(cid:3036))!  

=

(cid:3043)((cid:3043)(cid:2879)(cid:2869))…((cid:3043)(cid:2879)((cid:3036)(cid:2879)(cid:2869)))

(cid:3036)!

   com 1   ≤   𝑖   ≤   𝑝 − 1 são divisíveis por 

𝑝 pois todos os fatores de 𝑖! são estritamente menores do que p primo. A prova segue 

por indução em 𝑎.  

  Vale para 𝑎 = 1 ∶    1(cid:3043)  –   1   =   0   =   0. 𝑝 

  Suponha que vale para 𝑎 = 𝑘:    𝑘(cid:3043)  –   𝑘   =   𝑐. 𝑝 

  Vamos mostrar que vale para 𝑎 =   𝑘 + 1:  (𝑘 + 1)(cid:3043)    −    (𝑘 + 1)    =   𝑑. 𝑝 

De fato:  

 (𝑘 + 1)(cid:3043) =    𝑘(cid:3043) +    (cid:4672)

(cid:4673) 𝑘(cid:3043)(cid:2879)(cid:2869)1 + (cid:4672)

𝑝
𝑝 − 1(cid:4673) 𝑘1(cid:3043)(cid:2879)(cid:2869)
(cid:4673) 𝑘(cid:3043)(cid:2879)(cid:2870)1(cid:2870) + ⋯ + (cid:4672)
(cid:4579)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4580)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4581)
1
(cid:3040)(cid:3043)

𝑝
2

𝑝

                                    = 𝑘(cid:3043) + 𝑚𝑝 + 1 

+ 1(cid:3043) 

30 

 
 
 
 
Subtraindo (k+1) em ambos os termos 

(𝑘 + 1)(cid:3043)  –  (𝑘 + 1)    =    𝑘(cid:3043)    + 𝑚𝑝 + 1 − (𝑘 + 1) 

                                                                            = (𝑘(cid:3043) − 𝑘) + 𝑚𝑝 

                                                                          = 𝑐𝑝 + 𝑚𝑝 = (𝑐 + 𝑚)  𝑝 

                                                                          = 𝑑. 𝑝            ∎ 

Lembremos que se 𝑝 é primo e 𝑝 divide (𝑎. 𝑏) então p divide  𝑎 ou 𝑝 divide 𝑏. 

De fato, supondo que 𝑝 não divide 𝑏 então 𝑚𝑑𝑐  (𝑝, 𝑏)    =   1. Assim 1   = 𝑚𝑝   +   𝑛𝑏     ⇒

  𝑎   =   𝑚𝑝𝑎   +   𝑛𝑏𝑎   =   𝑝  (𝑚𝑎 + 𝑛𝑘)    ⇒     𝑝  𝑑𝑖𝑣𝑖𝑑𝑒  𝑎. 

Como consequência imediata do P.T.F, temos que se 𝑝 é primo e 𝑝  não divide 𝑎, 

segue que 𝑎(cid:3043)(cid:2879)(cid:2869)  –   1   =   𝑘  𝑝, em linguagem de congruência, 𝑎(cid:3043)(cid:2879)(cid:2869) ≡ 1  (𝑚𝑜𝑑  𝑝). De fato, 

do P.T.F,   𝑎(cid:3043)  –   𝑎 =   𝑎  (cid:3435)𝑎(cid:3043)(cid:2879)(cid:2869)  –   1(cid:3439) =   𝑟. 𝑝  . Como 𝑝 é primo e não divide 𝑎, segue que 

𝑝 divide (𝑎(cid:3043)(cid:2879)(cid:2869) − 1), isto é, 𝑎(cid:3043)(cid:2879)(cid:2869) − 1 = 𝑘  𝑝. 

Definição (Função de Euler): Dado um número inteiro positivo m, define-se  

ϕ(𝑚) = #  {  𝑘   ∈   ℤ;   𝑐𝑜𝑚      0 < 𝑘 < 𝑚        𝑒    𝑚𝑑𝑐  (𝑘, 𝑚) = 1  } 

são primos com 𝑚, isto é, 𝜙  (𝑚) = #  {  ℤ(cid:3040)

Basicamente, a função  𝜙 de Euler conta a quantidade de elementos de  ℤ(cid:3040) que 
∗   }.    Por exemplo, temos que 𝜙  (8) = 4, pois 
∗    =    {1(cid:3364), 3(cid:3364), 5(cid:3364), 7(cid:3364)} e é chamado de sistema reduzido de resíduos módulo 8. De 

temos que ℤ(cid:2876)

maneira geral, para encontrarmos o sistema reduzido de resíduos módulo 𝑚, que são os 
(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)(cid:3364)}  os  que  não  são 
∗ ,  basta  retirar  do  sistema  completo  {0(cid:3364), 1(cid:3364), . . . , 𝑚 − 1

elementos  de  ℤ(cid:3040)

primos com 𝑚. 

Teorema de Euler: Se 𝑎 e 𝑚 são inteiros positivos e 𝑚𝑑𝑐(𝑎, 𝑚)    =   1, então 

𝑎(cid:3109)((cid:3040)) ≡ 1  (𝑚𝑜𝑑  𝑚). 

Note  que  o  Teorema  de  Euler  é  uma  generalização  do  Pequeno  Teorema  de 

Fermat,  que  diz  que  se  p  é  primo  e  não  divide  𝑎  temos  que  𝑎(cid:3043)(cid:2879)(cid:2869) ≡ 1  (𝑚𝑜𝑑  𝑝),  visto 

que 𝜙(𝑝) = 𝑝 − 1. Uma prova deste resultado pode ser encontrada no livro: Introdução 

a Teoria dos Números de José Plínio de Oliveira Santos na página 43. 

31 

 
 
 
 
 
 
2.2.  Números de Fermat e de Mersenne  

Um  resultado  clássico  na  literatura  conhecido  como  Teorema 

Fundamental da Aritmética diz que: “todo número composto é produto de 

números  primos,  e  a  menos  da  ordem  dos  fatores,   esse   produto   é   único”. 

Desta forma, os números primos formam os blocos de base para construção 

dos números inteiros por meio da operação de multiplicação. 

Assim, não é de estranhar que os números primos tenham sido objeto 

de  estudo  por  várias  gerações  de  matemáticos  atraídos  pela  fascinação 

desses números, para responder questionamentos do seguinte tipo:  

  Quantos números primos existem?  

  Como reconhecer se um dado número é primo de maneira eficiente? 

  Existem fórmulas ou algoritmos para gerar números primos?  

Faremos  um  passeio  por  estes  questionamentos  sobre  números 

primos,  visto  que  o  mesmo  será  o  ingrediente  fundamental  para  o 

desenvolvimento da criptografia moderna nos tempos atuais. 

O  primeiro  questionamento  que  gostaríamos  de  responder  é  o 

seguinte: Será que existe uma infinidade de números primos?  

A  resposta  é  afirmativa,  e  a  prova  que  apresentaremos  a  seguir  foi 

dada por Euclides de Alexandria (360 a 295 a.C) que viveu no século 3 antes 

de  cristo,  e  ficou  conhecido  como  o  Pai  da  Geometria,  onde  sua  principal 

obra é conhecida como o livro “Os  Elementos”  apresentada em 13 volumes, 

servindo como principal livro de matemática para época, principalmente no 

que se refere ao que conhecemos hoje como Geometria Euclidiana.  

A  prova  de  Euclides  é  a  seguinte:  Suponhamos  que  a  sucessão 

𝑝(cid:2869)    =   2, 𝑝(cid:2870)    =   3  , . . . ,   𝑝(cid:3045)  dos  𝑟  números  seja  finita.  Consideramos  então 

𝑃   =    𝑝(cid:2869)  𝑝(cid:2870)  . . . 𝑝(cid:3045)    +   1  e  seja  𝑝  um  número  primo  𝑝  que  divide  𝑃.  Esse 

número  𝑝  não  pode  ser  igual  a  qualquer  um  dos  números  primos 

𝑝(cid:2869), 𝑝(cid:2870), . . . , 𝑝(cid:3045)  porque  senão  𝑝  dividiria  a  diferença  𝑃  –  𝑝(cid:2869)  𝑝(cid:2870)  . . . 𝑝(cid:3045)    =   1,  o 

que é impossível. Assim 𝑝 é um número primo que não pertence a sucessão 

32 

 
 
 
 
 
 
 
 
e, por consequência  𝑝(cid:2869), 𝑝(cid:2870), . . . , 𝑝(cid:3045) não podem formar o conjunto de todos os 

números primos. 

A  demonstração  de  Euclides  que  acabamos  de  apresentar,  é  muito 

simples,  entretanto,  ela  não  fornece  qualquer  informação  sobre  o  novo 

número primo 𝑝 posto em destaque, a não ser que ele é, no máximo igual ao 

número 𝑃   =    𝑝(cid:2869)  𝑝(cid:2870)  . . . 𝑝(cid:3045)    +   1   

Em  1878,  o  matemático  Ernst  Kummer  (1810-1893)  deu  a  seguinte 

variante da demonstração de Euclides: Suponhamos que exista somente um 

número  finito  de  primos  𝑝(cid:2869)    <    𝑝(cid:2870)    < ⋯    <    𝑝(cid:3041)  e  seja  𝑁   =    𝑝(cid:2869)  𝑝(cid:2870)  . . . 𝑝(cid:3041)    >

  2.  O  inteiro  N  –  1  sendo  (como  todos  os  inteiros)  o  produto  de  fatores 

primos,  teria  então  um  fator  primo  𝑝(cid:3036),  que  dividiria  também  𝑁,  então  𝑝(cid:3036) 

dividiria 1   =   𝑁  –  (𝑁 − 1), o que é absurdo.  

Será  que  existe  uma  maneira  recorrente  de  encontrarmos 

números primos? Em 1640 Pierre de Fermat (1601 – 1665) afirmou que os 
números  da  forma  𝑭𝒏 = 𝟐𝟐𝒏
estes números são conhecidos como números de Fermat.  

+ 𝟏  para  𝒏   ≥ 𝟎  são  números  primos,  onde 

Os  primeiros  números  de  Fermat  são  𝐹(cid:2868)    =   3, 𝐹(cid:2869)    =   5, 𝐹(cid:2870)    =

  17, 𝐹(cid:2871)    =   257, 𝐹(cid:2872)    =   65.537  e  é  fácil  ver  que  são  primos.  Em  1732, 
Leonard  Euler  (1707-1783)  mostrou  que  𝐹(cid:2873)    =    2(cid:2870)(cid:3121)
primo. 

+ 1 = 2(cid:2871)(cid:2870) + 1  não  é 

De fato: basta observarmos que  

(1) 641   =    2(cid:2872)    +    5(cid:2872)              e        (2) 641   =    2(cid:2875)  . 5   +   1. 

Segue de (2) que 641   =    2(cid:2875)  . 5   +   1     ⇒     5 =

(cid:2874)(cid:2872)(cid:2869)(cid:2879)(cid:2869)

(cid:2870)(cid:3123) =   

(cid:2874)(cid:2872)(cid:2868)

(cid:2870)(cid:3123)  .  

Substituindo em (1) 

641   =    2(cid:2872)    +    5(cid:2872)      ⇒   641 = 2(cid:2872) +    (cid:3436)

(cid:2872)

640
2(cid:2875) (cid:3440)

= 2(cid:2872) +

640(cid:2872)
2(cid:2870)(cid:2876)  

    ⇒ 641   =   

2(cid:2871)(cid:2870)    +    640(cid:2872)
2(cid:2870)(cid:2876)

33 

 
 
 
 
 
 
                                                                     
              ⇒   641    .    2(cid:2870)(cid:2876)    = 2(cid:2871)(cid:2870) +    640(cid:2872)                                                             

Assim, vemos que 2(cid:2871)(cid:2870) +    640(cid:2872) é múltiplo de 641, ou seja: 

2(cid:2871)(cid:2870) + 640(cid:2872) ≡ 0  (𝑚𝑜𝑑  641) ⇒ 2(cid:2871)(cid:2870) + (−1)(cid:2872) ≡ 0  (𝑚𝑜𝑑  641) 

                                                                             ⇒ 2(cid:2871)(cid:2870) +   1   ≡ 0  (𝑚𝑜𝑑  641)   

                                                                    ⇒ 2(cid:2871)(cid:2870) +   1 = 𝑘  . 641  para algum 𝑘   ∈   ℤ  . 

A saber 𝐹(cid:2873)    =    2(cid:2871)(cid:2870) + 1 = 641  . 6700417.  

Os  números  𝑭𝒏    =    𝟐𝟐𝒏

   +   𝟏  primos  são  chamados  de  primos  de 

Fermat,  e  pelos  menos  temos  5  conhecidos,  a  saber,  𝐹(cid:2868)  a  𝐹(cid:2872).  Convêm 

perguntar se existem outros primos de Fermat? 

Em 1880, Landry obteve a fatoração de 𝐹(cid:2874) antes da era dos computadores 

𝐹(cid:2874) = 2(cid:2870)(cid:3122)

+ 1 = 274177  𝑥  67280421310721 

Em  1970,  Morrison  e  Brillhart  obtiveram  a  fatoração  de  𝐹(cid:2875) = 2(cid:2870)(cid:3123)
596  49589127497217  𝑥  5704689200685129054721. 

+ 1 =

números de Fermat 

Fatorado em 

Por 

𝐹(cid:2876) 

𝐹(cid:2877) 

𝐹(cid:2869)(cid:2868) 

𝐹(cid:2869)(cid:2869) 

1980 

1990 

1995 

1988 

Brent e Pollard 

Lenstra e Manasse 

Brent 

Brent e Morain 

A  fatoração  de  grandes  números  é  um  problema  difícil.  Não  se 

conhece até agora nenhum algoritmo de tempo polinomial para realizar essa 

operação. É também um problema importante, por sua aplicação notável na 

criptografia  de  chave  pública,  que  envolve  números  que  devem  ser  difíceis 

de  fatorar.  Qualquer  um  que  se  interesse  por  essas  questões,  quando 

envolvem  grandes  números,  tem  necessidade  evidente  de  ter  acesso  a 

34 

 
 
 
 
 
computadores  modernos  com  alto  poder  de  processamento.  Não  se 

conhecem outras fatorações dos números de Fermat e nada pode se afirmar 

sobre sua primalidade.  

Será  que  existem 

infinitos  números  primos  que  seguem  um 

determinado padrão? A resposta é afirmativa, como a dada por um teorema 

clássico  de  Teoria  dos  números  conhecido  por  Teorema  de  Dirichilet  que 

diz:   “Se   𝑚𝑑𝑐(𝑎, 𝑏)    = 1  então  a  progressão  aritmética  𝑎𝑘   + 𝑏  com  𝑘 =

1, 2, 3, . .. contem infinitos  primos”. 

Não é difícil mostrar que existem infinitos números primos da forma 

4𝑘   + 3  e  6𝑘   + 5  com  𝑘   =   1, 2, 3  . ..  que  proporemos  como  atividades 

em  sala  de  aula  no  capítulo  5,  imitando  a  prova  dada  por  Euclides  no 

século 3 antes de cristo. 

Continuando  a  linha  de  números  primos  que  segue  um  determinado  padrão, 

convêm  destacar  Marin  Mersenne,  matemático  amador  do  século  XVII,  onde  𝑴𝒒    =

  𝟐𝒒    − 𝟏  (com  q  primo)  são  chamados  números  de  Mersenne.  Desde  o  tempo  de 

Mersenne  era  sabido  que  certos  números  de  Mersenne  são  primos  e  que  outros  são 

compostos.  Por  exemplo  𝑀(cid:2870)    =   3,   𝑀(cid:2871)    =   7,   𝑀(cid:2873)    =   31, 𝑀(cid:2875)    =   127  são  primos, 

enquanto que 𝑀(cid:2869)(cid:2869)    =   23 ∗ 89.  

Em 1640, Mersenne afirmou que 𝑀(cid:3044) é primo para 𝑞   =   13, 17, 19, 31, 67, 127 e 

257;  estava  ele  enganado  em  relação  a  67  e  257;  também  não  incluíra  61, 89  e  107 

(entre  os  números  inferiores  a  257)  que  também  fornecem  números  de  Mersenne 

primos. Sua afirmação era extraordinária, em face da grandeza dos números envolvidos.  

Em  relação  aos  números  de  Mersenne,  o  problema  que  se  apresenta 

naturalmente, é de saber se são primos ou compostos  e, neste ultimo caso,  determinar 

seus fatores primos. 

O seguinte resultado clássico sobre os fatores primos foi enunciado por Euler em 

1750  e  demonstrado  por  Lagrange  em  1775  e  ainda  por  Lucas  em  1878:  Se  𝑞  é  um 

número  primo  e  𝑞   ≡ 3  (𝑚𝑜𝑑  4)  então    2𝑞   + 1  divide  𝑀(cid:3044)  se  e  somente  se  2𝑞 + 1  é 

primo; neste caso, se q > 3, então 𝑀(cid:3044) é composto. 

35 

 
 
 
 
 
 
 
Assim  se  𝑞   =   11, 23, 83, 131, 179, 191, 239  ou  251  então  𝑀(cid:3044)  tem  por  fator 

2𝑞 + 1 dado por 23, 47, 167, 263, 359, 383, 479 ou 503 respectivamente. 

Exatamente  como  acontece  com  os  números  de  Fermat,  ainda  existem  vários 

problemas em aberto sobre os números de Mersenne: 

  Existe uma infinidade de números de Mersenne primos? 

  Existe uma infinidade de números de Mersenne compostos? 

Até  hoje  são  conhecidos  48  números  de  Mersenne  𝑀(cid:3044)  que  são  primos.  O 

penúltimo deles com 𝑞   =   43.112.609 com 12.978.189 algarismos foi descoberto em 

2008  por  E.  Smith,  G.F  Woltman,  S.  Kurowski  e  Gimps,  sendo  o  primeiro  número 

primo  com  mais  de  10  (dez)  milhões  de  algarismos,  o  que  valeu  aos  descobridores  o 

prêmio de 100.000 US dólares, outorgado pela Eletronic Frontier Foundation. 

Números  primos  com  mais  de  1  (um)  milhão  de  algarismos  são  chamados  de 

megaprimos.  Hoje  já  se  conhecem  30  megaprimos,  do  quais  11  são  números  de 

Mersenne primos.  

O  maior  deles  com  𝑞   =   57.885.161  com  17.425.170  algarismos  foi 

descoberto durante a realização desta monografia, em 25 de janeiro de 2013 por GIMPS 

(Great Internet Mersenne Prime Search) e Curtis Cooper. 

36 

 
 
 
 
 
 
 
 
 
CAPÍTULO 3 

Neste  capítulo,  veremos  como  é  possível  enviar  mensagens  por  um  meio 
inseguro  sem  o  contato  prévio  entre  os  participantes.  Este  avanço  da  criptografia  é 
baseado no princípio da troca de uma caixa com cadeados.  

Suponha  que  Joãozinho  queira  enviar  uma  caixa  para  Serginho  por  um  meio 

inseguro, de modo que apenas Serginho possa abri-la.  

  Joãozinho envia a caixa fechada com um cadeado para Serginho; 
  Serginho coloca outro cadeado na caixa e a envia para Joãozinho; 
  Joãozinho retira seu cadeado e reenvia a caixa para Serginho que consegue abri-

la. 

Em 1976, Whitfield Diffie e Martin Hellman  publicaram um método que permite a 
troca  de  chaves,  por  um  canal  de  comunicação  inseguro,  entre  duas  partes  que  não 
possuem  nenhum  conhecimento  prévio,  uma  sobre  a  outra.  Este  método  é  conhecido 
como a troca de chaves de Diffie-Hellman. 

Taher  Elgamal,  em  1984,  baseando-se  na  ideia  de  Diffie  e  Hellman,  construiu 
um  método  para  enviar  mensagens  criptografadas  por  um  meio  de  comunicação 
inseguro. Tal método é a base para alguns sistemas de criptografia, entre eles o método 
de criptografia via curvas elípticas. 

Veremos a seguir que é fácil calcular potências, mesmo grandes, de um número 
g módulo N, no entanto, é muito difícil descobrir o expoente ao qual g foi elevado para 
gerar  tal  potência.  Esse  problema,  conhecido  como  PROBLEMA  DO  LOGARITMO 
DISCRETO,  é  a  ferramenta principal para as ideias brilhantes de Diffie-Hellman e El 
Gamal.  

3.1.  Algoritmo para o Cálculo de Potências: 

Veremos  como  calcular  potências  grandes  de  um  numero  g  módulo  outro 
número  N,  onde  N  pode  ter  centenas  de  dígitos.  O  modo  ingênuo  de  calcular  g  é  por 
repetidas multiplicações por g.  

𝑔(cid:2869) ≡ 𝑔  𝑚𝑜𝑑  𝑁 

𝑔(cid:2870) ≡ 𝑔  . 𝑔(cid:2869)  𝑚𝑜𝑑  𝑁 

  𝑔(cid:2871) ≡ 𝑔  . 𝑔(cid:2870)  𝑚𝑜𝑑  𝑁, 

≡ 𝑔  . 𝑔(cid:2871)  𝑚𝑜𝑑  𝑁 

𝑔(cid:2872)

≡ 𝑔  . 𝑔(cid:2872)  𝑚𝑜𝑑  𝑁 

𝑔(cid:2873)

≡ 𝑔  . 𝑔(cid:2873)  𝑚𝑜𝑑  𝑁 

𝑔(cid:2874)

…   

37 

 
 
 
 
 
 
 
  
  
  
 
 
 
É  evidente  que  𝑔(cid:3002)    ≡ 𝑔(cid:3002)  𝑚𝑜𝑑  𝑁,  mas  se  A  é  grande,  o  algoritmo  é 
completamente  impraticável.  Por  exemplo,  se  𝐴 ≈ 2(cid:2869)(cid:2868)(cid:2868)(cid:2868),  então  o  algoritmo  ingênuo 

levaria mais tempo do que a idade estimada do universo. Claramente, se isto é para ser 

útil, temos de encontrar uma melhor maneira de calcular 𝑔(cid:3002)  𝑚𝑜𝑑  𝑁.  

Uma  boa  ideia  é  usar  a  expansão  binária  para  o  expoente  𝐴,  ou  seja, 
escrever    𝐴 = 𝐴(cid:2868) + 𝐴(cid:2869) ∙ 2 + 𝐴(cid:2870) ∙ 2(cid:2870) + 𝐴(cid:2871) ∙ 2(cid:2871) + ⋯ + 𝐴(cid:3045) ∙ 2(cid:3045),com  𝐴(cid:2868), 𝐴(cid:2869), … , 𝐴(cid:3045) ∈ {0,1}, 
onde podemos assumir que 𝐴(cid:3045) = 1.  

Vale lembrar que para obtermos os valores de cada um dos 𝐴(cid:3036)(cid:3294), podemos fazer 
divisões  sucessivas  por  2,  começando  pelo  𝐴,  até  obtermos  um  quociente  zero.  Deste 

modo os 𝐴(cid:3036)(cid:3294) serão os restos obtidos nessas divisões. Observe o exemplo: 

Vamos escrever a expansão binária de 83 

Divisões 

Quociente 

Resto 

83 ÷ 2 

41 ÷ 2 

20 ÷ 2 

10 ÷ 2 

5 ÷ 2 

2 ÷ 2 

1 ÷ 2 

41 

20 

10 

5 

2 

1 

0 

1 

1 

0 

0 

1 

0 

1 

𝑨𝒊𝒔 

𝐴(cid:2868) = 1 

𝐴(cid:2869) = 1 

𝐴(cid:2870) = 0 

𝐴(cid:2871) = 0 

𝐴(cid:2872) = 1 

𝐴(cid:2873) = 0 

𝐴(cid:2874) = 1 

Observando a tabela, podemos escrever:  

83 = 𝐴(cid:2868) + 𝐴(cid:2869) ∙ 2(cid:2869) + 𝐴(cid:2870) ∙ 2(cid:2870) + 𝐴(cid:2871) ∙ 2(cid:2871) + 𝐴(cid:2872). 2(cid:2872) + 𝐴(cid:2873). 2(cid:2873) + 𝐴(cid:2874). 2(cid:2874) 

            =   1     + 1 ∙ 2(cid:2869)    +   𝟎   ∙ 2(cid:2870)    +   𝟎   ∙ 2(cid:2871)    + 1 ∙ 2(cid:2872) + 𝟎 ∙ 2(cid:2873) + 1 ∙ 2(cid:2874) 

            =   1 + 2 + 2(cid:2872) + 2(cid:2874).  

38 

 
 
 
 
 
 
Exemplo 3.1: Suponha que desejamos calcular 7(cid:2872)(cid:2873)(cid:2868)  (  𝑚𝑜𝑑  2563  ). O primeiro passo é 

escrever 450 como uma soma de potência de 2: 

450   =   2   + 2(cid:2874) + 2(cid:2875) + 2(cid:2876)        ⇒      7(cid:2872)(cid:2873)(cid:2868) = 7(cid:2870)(cid:2878)(cid:2870)(cid:3122)(cid:2878)(cid:2870)(cid:3123)(cid:2878)(cid:2870)(cid:3124)

= 7(cid:2870)  .    7(cid:2870)(cid:3122)

.    7(cid:2870)(cid:3123)

.    7(cid:2870)(cid:3124)

Note que é relativamente mais fácil calcular a sequência de valores abaixo, visto 

que, cada número é o quadrado do anterior, conforme observado abaixo 

7              ,      7(cid:2870)(cid:3117)

= 7(cid:2870)    ,

7(cid:2870)(cid:3118)

= 7(cid:2872),

7(cid:2870)(cid:3119)

= 7(cid:2876)    ,

7(cid:2870)(cid:3120)

= 7(cid:2869)(cid:2874)    ,

…   

Além  disso,  visto  que  só  precisamos  destes  valores  módulo  2563,  nunca 

precisaremos armazenar mais do que 4 dígitos. A tabela abaixo lista as potências de 7 
módulo  2563  até 7(cid:2870)(cid:3124)

. 

𝑖 

7(cid:2870)(cid:3284)

  (𝑚𝑜𝑑  2563) 

0 

7 

1 

2 

3 

4 

5 

6 

7 

8 

49 

2401  614 

235  1402  2346  955  2160 

A criação da tabela acima, requer somente 8 multiplicações, e despista o fato de 

que  o  número  7(cid:2870)(cid:3124)

   =    7(cid:2870)(cid:2873)(cid:2874)  tem  um  expoente  bastante  grande,  porque  cada  entrada 

sucessiva na tabela é igual ao quadrado da entrada anterior. Segue da tabela que  

7(cid:2872)(cid:2873)(cid:2868) = 7(cid:2870)    .    7(cid:2870)(cid:3122)

  .    7(cid:2870)(cid:3123)

  .    7(cid:2870)(cid:3124)

≡ 49  . 2346  .    955  .    2160    (  𝑚𝑜𝑑  2563  ) 

    ≡ 1772    (  𝑚𝑜𝑑  2563)                                                                             

Note  que  o  cálculo  do  produto  49  . 2346  . 955  . 2160  ,    pode  ser  reduzido 

módulo 2563 a cada multiplicação, não necessitando lidar com números muito grandes.  

Exemplo 3.2: Determine  𝑎, 𝑐𝑜𝑚  0   ≤ 𝑎   ≤ 999,   tal que  3(cid:2870)(cid:2869)(cid:2876)    ≡ 𝑎  (𝑚𝑜𝑑  1000) .  

Como primeiro passo, escrevemos 218 como soma de potências de 2, dados por 

218 = 2 + 2(cid:2871) +    2(cid:2872) + 2(cid:2874) +    2(cid:2875)   

Então 3(cid:2870)(cid:2869)(cid:2876) torna-se 

3(cid:2870)(cid:2869)(cid:2876) = 3(cid:2870)(cid:2878)(cid:2870)(cid:3119)(cid:2878)  (cid:2870)(cid:3120)(cid:2878)(cid:2870)(cid:3122)(cid:2878)  (cid:2870)(cid:3123)

= 3(cid:2870).   3(cid:2870)(cid:3119)

. 3(cid:2870)(cid:3120)

.   3(cid:2870)(cid:3122)

.   3(cid:2870)(cid:3123)

39 

 
 
 
 
 
 
                                                                                   
 
 
Note que é relativamente mais fácil calcular a sequência de valores  

3(cid:2870)(cid:3116)

= 3              ,      3(cid:2870)(cid:3117)

= 3(cid:2870)    ,

3(cid:2870)(cid:3118)

= 3(cid:2872),

3(cid:2870)(cid:3119)

= 3(cid:2876)    ,

3(cid:2870)(cid:3120)

= 3(cid:2869)(cid:2874) 

 visto que, cada número da sequência é o quadrado do anterior. Além disso, visto que só 

precisamos destes valores módulo 1000, nunca precisaremos armazenar mais do que 3 

dígitos.  

𝑖 

3(cid:2870)(cid:3284)

  (𝑚𝑜𝑑  1000) 

Portanto 

0 

3 

1 

9 

2 

3 

4 

5 

6 

7 

81 

561 

721 

841 

281 

961 

3(cid:2870)(cid:2869)(cid:2876) = 3(cid:2870).   3(cid:2870)(cid:3119)

. 3(cid:2870)(cid:3120)

.   3(cid:2870)(cid:3122)

.   3(cid:2870)(cid:3123)

                                                      ≡ 9. 561  .721  .281.961  (𝑚𝑜𝑑  1000) 

≡ 489  (𝑚𝑜𝑑  1000)           

Observamos  que 

tomamos  apenas  11  multiplicações  para 

calcular 

3(cid:2870)(cid:2869)(cid:2876)  (  𝑚𝑜𝑑  1000), tendo uma enorme economia de tempo sobre a abordagem ingênua. 

E para expoentes grandes, poderíamos economizar ainda mais tempo, procedendo desta 

maneira.  

Formalizando o Algoritmo para o Cálculo de potências 

Passo 1: Calcule a expansão binária de 𝐴 como  

𝐴 = 𝐴(cid:2868) +    𝐴(cid:2869)2 + 𝐴(cid:2870). 2(cid:2870) +    𝐴(cid:2871)  . 2(cid:2871) + ⋯ + 𝐴(cid:3045)  2(cid:3045)   

com 𝐴(cid:2868), . . . 𝐴(cid:3045) ∈ {  0,1}  onde podemos assumir que 𝐴(cid:3045)    =   1 

Passo 2: Calcule as potencias 𝑔(cid:2870)(cid:3284)

    (  𝑚𝑜𝑑  𝑁  )  para 0   ≤ 𝑖   ≤ 𝑟   por sucessivos 

quadraturas 

𝑎(cid:2868)    ≡ 𝑔                                    (𝑚𝑜𝑑  𝑁) 

𝑎(cid:2869)    ≡ 𝑎(cid:2868)

(cid:2870)    ≡ 𝑔(cid:2870)        (𝑚𝑜𝑑  𝑁) 

𝑎(cid:2870)    ≡ 𝑎(cid:2869)

(cid:2870)    ≡ 𝑔(cid:2870)(cid:3118)

      (𝑚𝑜𝑑  𝑁) 

𝑎(cid:2871)    ≡ 𝑎(cid:2870)

(cid:2870)    ≡ 𝑔(cid:2870)(cid:3119)

      (𝑚𝑜𝑑  𝑁) 

40 

 
                 
 
.
.
.

.
.
.

𝑎(cid:3045)    ≡ 𝑎(cid:3045)(cid:2879)(cid:2869)

(cid:2870)

   ≡ 𝑔(cid:2870)(cid:3293)

      (𝑚𝑜𝑑  𝑁) 

Cada termo é o quadrado do anterior, assim requeremos 𝑟 multiplicações. No exemplo 

anterior 𝑔   =   3 e identificamos os 𝑎(cid:3036)  

𝑖 

3(cid:2870)(cid:3284)

  (𝑚𝑜𝑑  1000) 

0 

3 

1 

9 

𝑎(cid:2868) 

𝑎(cid:2869) 

2 

81 

𝑎(cid:2870) 

3 

4 

5 

6 

7 

561 

721 

841 

281 

961 

𝑎(cid:2871) 

𝑎(cid:2872) 

𝑎(cid:2873) 

𝑎(cid:2874) 

𝑎(cid:2875) 

Passo 3: Calculamos 𝑔(cid:3002)  (𝑚𝑜𝑑  𝑁) usando a fórmula 

𝑔(cid:3002) = 𝑔(cid:3002)(cid:3116)(cid:2878)    (cid:3002)(cid:3117)(cid:2870)  (cid:2878)  (cid:3002)(cid:3118).(cid:2870)(cid:3118)  (cid:2878)    (cid:3002)(cid:3119)  .(cid:2870)(cid:3119)  (cid:2878)  …  (cid:2878)  (cid:3002)(cid:3293)  (cid:2870)(cid:3293)

            = (𝑔)(cid:3002)(cid:3116)  . (𝑔(cid:2870))(cid:3002)(cid:3117)  . (cid:3435)𝑔(cid:2870)(cid:3118)

(cid:3439)

(cid:3002)(cid:3118)  . (cid:3435)𝑔(cid:2870)(cid:3119)

(cid:3002)(cid:3119) …  (cid:3435)𝑔(cid:2870)(cid:3293)

(cid:3002)(cid:3293)     

(cid:3439)

(cid:3439)

            ≡ (𝑎(cid:2868))(cid:3002)(cid:3116)  . (𝑎(cid:2869))(cid:3002)(cid:3117). (𝑎(cid:2870))(cid:3002)(cid:3118). (𝑎(cid:2871))(cid:3002)(cid:3119) … (𝑎(cid:3045))(cid:3002)(cid:3293)    (𝑚𝑜𝑑  𝑁)         

com 𝐴(cid:2868), . . . 𝐴(cid:3045) ∈ {  0,1}  onde podemos assumir que 𝐴(cid:3045)    =   1 

Note  que  os  termos  𝑎(cid:2868), 𝑎(cid:2869), . . . , 𝑎(cid:3045)  foram  calculados  no  Passo  2.  Portanto  o 

produto acima pode ser calculado procurando os valores de 𝑎(cid:3036) cujos expoentes 𝐴(cid:3036) é 1 e 

efetuamos sua multiplicação. Isso exige no máximo 𝑟 multiplicações. 

Tempo  de  Processamento:  Executaremos  no  máximo  2𝑟  multiplicações  módulo  𝑁 
para calcular 𝑔(cid:3002), isto é, no máximo 2 log(cid:2870) 𝐴 multiplicações módulo 𝑁 para calcular 𝑔(cid:3002). 
De fato: 

𝐴   ≥ 2(cid:3045)        ⇒      log(cid:2870) 𝐴   ≥ log(cid:2870) 2(cid:3045) = 𝑟       ⇒     2𝑟   ≤ 2 log(cid:2870) 𝐴 

Assim,  mesmo  se  𝐴  é  muito  grande,  digamos  𝐴 ≈ 2(cid:2869)(cid:2868)(cid:2868)(cid:2868),  é  fácil  para  um 

computador  fazer  aproximadamente  2.000  multiplicações  necessárias  para  calcular  2(cid:3002) 

módulo 𝑁 

Exemplo 3.3: Segue do Pequeno Teorema de Fermat que 𝑎(cid:3043)(cid:2879)(cid:2869) ≡ 1  (𝑚𝑜𝑑  𝑝) e tomando 

𝑎   =     2 e 𝑝   =   15.485.863 primo, que 

41 

 
                    
 
 
 
                                                                                                      
 
  
2(cid:2869)(cid:2873).(cid:2872)(cid:2876)(cid:2873).(cid:2876)(cid:2874)(cid:2870)    ≡ 1  (𝑚𝑜𝑑  15.485.863) 

Portanto, sem fazermos qualquer cálculo, sabemos que o número 2(cid:2869)(cid:2873).(cid:2872)(cid:2876)(cid:2873).(cid:2876)(cid:2874)(cid:2870) −   1 é um 

número tendo mais do que 2 milhões de dígitos, é um múltiplo de 15.485.863 

Observação: Um método razoavelmente eficiente para o cálculo de inversos módulo 𝑝, 

é  obtido  através  do  Pequeno  Teorema  de  Fermat  e  do  algoritmo  para  o  Cálculo  de 

potências, visto que 

𝑎(cid:3043)(cid:2879)(cid:2869) ≡ 1  (𝑚𝑜𝑑  𝑝)    𝑒      𝑎(cid:2879)(cid:2869)    ≡ 𝑎(cid:2879)(cid:2869)  (𝑚𝑜𝑑  𝑝)          ⇒        𝑎(cid:3043)(cid:2879)(cid:2870) ≡ 𝑎(cid:2879)(cid:2869)  (𝑚𝑜𝑑  𝑝) 

Isto  nos  dá  uma  alternativa  para  o  método  do  Algoritmo  Euclidiano  Extendido.  Na 

prática,  os  dois  algoritmos  tendem  a  ter  aproximadamente  a  mesma  quantidade  de 

tempo. 

Exemplo  3.4:  Calcularemos  o  inverso  de  𝑎   =   7814  módulo  𝑝   = 17.449  de  2 

maneiras: 

Primeiro, usando que: 𝑎(cid:2879)(cid:2869)    ≡ 𝑎(cid:3043)(cid:2879)(cid:2870)  (𝑚𝑜𝑑  𝑝)   

7814(cid:2879)(cid:2869)    ≡ 7814(cid:2869)(cid:2875).(cid:2872)(cid:2872)𝟕 ≡ 1284  (𝑚𝑜𝑑  17.449) 

Segundo, usando o algoritmo euclidiano extendido, temos que 

7814  𝑢   +   17.449  𝑣   =   1 

𝑢 será o inverso de 𝑎   =   7814. A solução é (𝑢, 𝑣)    =    (1284, −575) assim 7814(cid:2879)(cid:2869) ≡

1284  (𝑚𝑜𝑑  17.449). 

Exemplo  3.5:  Considere  o  número  𝑚   =   15.485.207.  Usando  o  algoritmo  para  o 

cálculo de potências, não é difícil calcular através de um computador a conta abaixo: 

2(cid:3040)(cid:2879)(cid:2869) = 2(cid:2869)(cid:2873).(cid:2872)(cid:2876)(cid:2873).(cid:2870)(cid:2868)𝟔    ≡ 4.136.685  (𝑚𝑜𝑑  15.485.207) 

Como não conseguimos o valor 1, parece que o Pequeno Teorema de Fermat não 

é verdadeiro para 𝑚   =   15.485.207.  

O  que isso nos diz? Se 𝑚 for primo então o pequeno Teorema de  Fermat  nos 

diz  que  deveríamos  ter  obtido  1.  Portanto,  o  fato  de  não  termos  obtido  o  número  1, 

prova  que  o  número  𝑚   =   15.485.207  não  é  primo.  Pensando  nisso  por  um  minuto, 

42 

 
 
 
vemos que isso é um pouco surpreendente, pois um simples cálculo mostra que 𝑚 não é 

primo, sem sabermos nada sobre os fatores de 𝑚. 

Não é fácil obter a fatoração de 𝑚   =   15.485.207   =   3853   ∙ 4019 

O Pequeno Teorema de Fermat nos diz que se  𝑎 é um inteiro não divisível por 

𝑝  então  𝒂𝒑(cid:2879)𝟏    ≡ 𝟏  (𝒎𝒐𝒅  𝒑).      No  entanto,  para  algum  valor  especifico  de  𝑎,  podem 

existir potências menores de 𝑎 que são congruentes a 1.  

Definição: (ordem de 𝒂 módulo 𝒑) Definimos a ordem de 𝑎 módulo 𝑝 como o menor 

expoente 𝑘 ≥ 1  tal que 

𝑎(cid:3038)    ≡ 1  (𝑚𝑜𝑑  𝑝) 

Exemplo  3.6.:  Observe  que  2(cid:2871) ≡ 1  (𝑚𝑜𝑑  7)  e que não existe número positivo menor 

que 3 ao qual elevamos  2 para  obtermos resto 1 na divisão por 7. Logo a ordem de 2 

modulo 7 é 3.  

Proposição.  Seja  𝑝  um  primo  e  𝑎  um  inteiro  não  divisível  por  𝑝.  Suponha  que  𝑎(cid:3041) ≡

1(𝑚𝑜𝑑  𝑝).    Então  a  ordem  𝑘  de  𝑎  módulo  𝑝  divide  𝑛.  Em  particular,  a  ordem  de  𝑎 

divide (𝑝 − 1). 

Prova: Seja 𝑘 a ordem de 𝑎 módulo p, assim 𝑎(cid:3038)    ≡ 1  (𝑚𝑜𝑑  𝑝) e 𝑘 é o menor expoente 

positivo com esta propriedade. Por hipótese, temos que  𝑎(cid:3041) ≡ 1  (𝑚𝑜𝑑  𝑝). Dividindo  𝑛 

por 𝑘, obtemos que: 

Então 

𝑛 = 𝑘𝑞 + 𝑟  𝑐𝑜𝑚  0   ≤ 𝑟   <   𝑘 

1 ≡ 𝑎(cid:3041)    ≡ 𝑎(cid:3038)(cid:3044)(cid:2878)(cid:3045) ≡ (𝑎(cid:3038))(cid:3044)  . 𝑎(cid:3045) ≡ (1)(cid:3044). 𝑎(cid:3045)    ≡ 𝑎(cid:3045)  (𝑚𝑜𝑑  𝑝) 

Mas  𝑟   <   𝑘,  assim  o  fato  de  𝑘  ser  a  menor  potência  positiva  inteira  de  𝑎  que  é 

congruente a 1 implica que 𝑟 = 0. Portanto, 𝑛   =   𝑘  𝑞, assim 𝑘 divide 𝑛. Em particular 

𝑘 divide (𝑝 − 1), pois pelo Pequeno Teorema de Fermat, 𝑎(cid:3043)(cid:2879)(cid:2869) ≡ 1  (𝑚𝑜𝑑  𝑝).   ∎ 

43 

 
 
 
 
 
 
3.2. O Problema do Logaritmo Discreto (PLD)  

O  problema  do  logaritmo  discreto  é  um  problema  matemático  que  surge  em 

diversas  situações,  inclusive  na  utilização  de  curva  elíptica  para  criptografia  de 

mensagens.  

O  logaritmo  discreto  segue  uma  ideia  análoga  ao  do  logaritmo  real  que  já 

conhecemos,  porém  ele  é  tratado  módulo  𝑛.  Para  esclarecer  vamos  fazer  uma 

comparação:  para  calcularmos  o  logaritmo  de  𝑥  na  base  𝑎  no  conjunto  dos  números 

reais,  devemos  encontrar  o  número  real  𝑥  tal  que  𝑎(cid:3051)    =   𝑏;  agora,  para  calcularmos  o 

logaritmo  discreto  de  𝑏  na  base  𝑎  (𝑎  e  𝑏  inteiros),  devemos  encontrar  um  inteiro  𝑥  tal 
que 𝑎(cid:3051) ≡ 𝑏  (𝑚𝑜𝑑  𝑛). Com  essa ideia, queremos  definir  𝑥 = 𝑙𝑜𝑔(cid:3028) 𝑏 como  o logaritmo 
discreto de 𝑏 na base 𝑎, com 𝑥 em ℤ(cid:3041), porém precisamos tomar alguns cuidados com as 

escolhas de 𝑛 e de 𝑎. Veja alguns exemplos: 

  𝑥 = 𝑙𝑜𝑔(cid:2870)(3)  não  existe  para  𝑛 = 4,  pois  2(cid:3051) ≡ 3  (𝑚𝑜𝑑  4)  não  possui  solução, 

visto que 2(cid:3051) ≡ 0  (𝑚𝑜𝑑  4) se 𝑥 é par e 2(cid:3051) ≡ 2  (𝑚𝑜𝑑  4) se  𝑥 é ímpar. 

  𝑥 = 𝑙𝑜𝑔(cid:2871)(7)  também não existe para 𝑛   =   11. Verifique!  

A  impossibilidade  de  definir  alguns  logaritmos  discretos  pode  ser  evitada  se 

trabalharmos  em  conjuntos  onde  eles  sempre  existam.  Por  isso  falaremos  de  um 

importante teorema: 

 Proposição (Teorema da Raiz Primitiva): Seja 𝑝 um número primo. Então existe um 

elemento 𝑎 ∈ (cid:3435)ℤ(cid:3043)(cid:3439)

∗

 cujas potências geram cada elemento de (cid:3435)ℤ(cid:3043)(cid:3439)

∗

, isto é,  

∗

    (cid:3435)ℤ(cid:3043)(cid:3439)

= {  𝑎(cid:2869), 𝑎(cid:2870), 𝑎(cid:2871), … , 𝑎(cid:3043)(cid:2879)(cid:2870), 𝑎(cid:3043)(cid:2879)(cid:2869) = 1  } =  < 𝑎 > 

Elementos com esta propriedade são chamados raízes primitivas de ℤ(cid:3043), ou geradores de 

∗

(cid:3435)ℤ(cid:3043)(cid:3439)

. Eles são os elementos de (cid:3435)ℤ(cid:3043)(cid:3439)

∗

 tendo ordem 𝑝 − 1. 

44 

 
 
 
 
 
 
Exemplo 3.7: 2 é uma raiz primitiva de ℤ𝟏𝟏.  Basta observar que todos os elementos 

de ℤ(cid:2869)(cid:2869)

∗  são gerados por uma potência de 2. 

2(cid:2868)    =   1 

2(cid:2869)    =   2 

2(cid:2870)    =   4 

2(cid:2871)    =   8 

2(cid:2872)    =   5 

2(cid:2873)    =   10 

2(cid:2874)    =   9 

2(cid:2875)    =   7 

2(cid:2876)    =   3 

2(cid:2877)    =   6 

2(cid:2869)(cid:2868)    =   1 

Exemplo 3.8: 2 não é uma raiz primitiva de ℤ𝟏𝟕. Basta observar que ao calcularmos 

∗ . 
as potências de 2, retornamos a 1 antes de obtermos todos os 16 valores de ℤ(cid:2869)(cid:2875)

2(cid:2868)    =   1 

2(cid:2869)    =   2 

2(cid:2870)    =   4 

2(cid:2871)    =   8 

2(cid:2872)    =   16 

2(cid:2873)    =   15 

2(cid:2874)    =   13 

2(cid:2875)    =   9 

2(cid:2876)    =   1 

Exemplo 3.9: 3 é uma raiz primitiva de ℤ𝟏𝟕·. Basta observar que todos os elementos 

de ℤ(cid:2869)(cid:2875)

∗   são gerados por uma potência de 3. 

3(cid:2868)    =   1 

3(cid:2869)    =   3 

3(cid:2870)    =   4 

3(cid:2871)    =   10 

3(cid:2872)    =   13 

3(cid:2873)    =   5 

3(cid:2874)    =   15 

3(cid:2875)    =   11 

3(cid:2876)    =   16 

3(cid:2877)    =   14 

3(cid:2869)(cid:2868)    =   8 

3(cid:2869)(cid:2869)    =   7 

3(cid:2869)(cid:2870)    =   4 

3(cid:2869)(cid:2871)    =   12 

3(cid:2869)(cid:2872)    =   2 

3(cid:2869)(cid:2873)    =   6 

3(cid:2869)(cid:2874)    =   1 

Observação: Se 𝑝 é grande então ℤ(cid:3043) tem várias raízes primitivas. A fórmula precisa diz 

que  ℤ(cid:3043)  tem  exatamente  𝜙  (𝑝 − 1)  raízes  primitivas  onde  𝜙  é  a  função  de  Euler.  Por 

exemplo, podemos checar que a lista completa de raízes primitivas de ℤ(cid:2870)(cid:2877) é dada por 

{  2, 3, 8, 10, 11, 14, 15, 18, 19, 21, 26, 27  } 

 A cardinalidade do conjunto coincide com o valor de 𝜙  (𝑝 − 1) =   𝜙  (28) = 12.  

45 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
Definição  (Problema  do  Logaritmo  Discreto)  Seja  𝑎  uma  raiz  primitiva  de  ℤ(cid:3043),  𝑝 

primo, e seja b um elemento não nulo de ℤ(cid:3043). O Problema do Logaritmo Discreto (PLD) 

é o problema de encontrar um expoente 𝑥 tal que  

𝑎(cid:3051)    ≡ 𝑏    (𝑚𝑜𝑑  𝑝) 

O número 𝑥 é chamado o logaritmo discreto de 𝑏 na base 𝑎  e é denotado por log(cid:3028)(𝑏). 

O Problema do Logaritmo Discreto é um problema bem-posto, isto é, encontrar 

um  expoente  inteiro  𝑥  tal  que  𝑎(cid:3051)    =   𝑏.  No  entanto,  se  houver  uma  solução,  então 

haverá  infinitas  soluções  inteiras,  pois  se  𝑥  é  uma  solução  para  𝑎(cid:3051)    =   𝑏,  então  temos 

que 𝑥   +   𝑘  (𝑝 − 1) também é uma solução para cada valor de 𝑘 em virtude do Pequeno 

Teorema de Fermat que diz que 𝑎(cid:3043)(cid:2879)(cid:2869)    ≡ 1  (𝑚𝑜𝑑  𝑝) . De fato 

𝑎(cid:3051)(cid:2878)(cid:3038)((cid:3043)(cid:2879)(cid:2869))    ≡      𝑎(cid:3051) ∙ (𝑎(cid:3043)(cid:2879)(cid:2869))(cid:3038)
(cid:4579)(cid:4583)(cid:4580)(cid:4583)(cid:4581)
≡(cid:2869)(cid:3286),      (cid:3017).(cid:3021).(cid:3007).

≡   𝑏 ∙ 1(cid:3038)   ≡   𝑏  (𝑚𝑜𝑑  𝑝). 

Por  exemplo,  2(cid:2876) ≡ 3  (𝑚𝑜𝑑  11),  2(cid:2876)(cid:2878)(cid:2869)(cid:2868) ≡ 3  (𝑚𝑜𝑑  11),  2(cid:2876)(cid:2878)(cid:2870)∙(cid:2869)(cid:2868) ≡ 3  (𝑚𝑜𝑑  11),  de 

modo geral 2(cid:2876)(cid:2878)(cid:2869)(cid:2868)(cid:3038) ≡ 3  (𝑚𝑜𝑑  11) para qualquer 𝑘 inteiro.  

Temos  que  log(cid:3028) 𝑏  está  bem  definido  a  menos  de  múltiplos  de  (𝑝 − 1).  Desta 

forma,  restringimos  o  contradomínio  de  ℤ  para  ℤ(cid:2926)(cid:2879)(cid:2869)  para  que  a  função  log(cid:3028)

  esteja 

bem definida. 

log(cid:2911)

∗

∶ (cid:3435)ℤ(cid:2926)(cid:3439)

     →                  ℤ(cid:2926)(cid:2879)(cid:2869)                                             

                          𝑏           →           𝑥      𝑜𝑛𝑑𝑒      𝑎(cid:3051) = 𝑏 

Em  várias  situações,  nos  referimos  ao  logaritmo  discreto  como  o  inteiro  𝑥 

situado entre 0 e 𝑝 − 2 satisfazendo a congruência 𝑎(cid:3051) ≡ 𝑏  (𝑚𝑜𝑑  𝑝). 

Exemplo 3.10: Por simplicidade, vamos considerar 𝑝   =   13 e a =   2. 

(ℤ(cid:2869)(cid:2871))∗    =      {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} 

                            =      (cid:3420)

2(cid:2869) =   2, 2(cid:2870) = 4, 2(cid:2871) = 8,   2(cid:2872) = 3,     2(cid:2873) = 6,   2(cid:2874) = 12  
2(cid:2875) = 11, 2(cid:2876) = 9, 2(cid:2877) = 5, 2(cid:2869)(cid:2868) = 10, 2(cid:2869)(cid:2869) = 7, 2(cid:2869)(cid:2870) = 1

(cid:3424)     

46 

 
 
 
 
 
 
log(cid:2870)

:  (ℤ(cid:2869)(cid:2871))∗    →      ℤ(cid:2869)(cid:2870)      dada  por       log(cid:2870) b = 𝑥        onde    2(cid:2934) = b 

∗

(cid:3435)ℤ𝐩(cid:3439)

= (ℤ𝟏𝟑)∗ 

𝑏 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

𝐛 = 𝟐𝐱 

ℤ𝒑(cid:2879)𝟏 = ℤ𝟏𝟐 

𝒙 = 𝐥𝐨𝐠𝟐 𝒃 

1 = 2(cid:2869)(cid:2870) 

0 = 12 

2 = 2(cid:2869) 

3 = 2(cid:2872) 

4 = 2(cid:2870) 

  5 = 2(cid:2877) 

6 =    2(cid:2869)(cid:2870) 

7 = 2(cid:2869)(cid:2869) 

8 = 2(cid:2871) 

9 = 2(cid:2876) 

10   =    2(cid:2869)(cid:2868) 

11 = 2(cid:2875) 

12 = 2(cid:2874) 

1 

4 

2 

9 

12 

11 

3 

8 

10 

7 

6 

Exemplo 3.11: O número 𝑝 = 56.509 é primo, e podemos checar que a = 2 é uma raiz 

primitiva  módulo  𝑝.  Como  iremos  calcular  o  logaritmo  discreto  de  𝒃 = 𝟑𝟖𝟔𝟕𝟗?  O 

único método que é imediatamente óbvio, é calcular  

2, 2(cid:2870), 2(cid:2871), 2(cid:2872), 2(cid:2873), …      (𝑚𝑜𝑑  𝑝) 

até encontrarmos alguma potência que seja côngruo a 𝑏 = 38679 módulo 𝑝 = 56509. 

47 

 
 
 
 
 
Seria difícil fazer a conta na mão, mas usando um computador, encontramos que 

 2(cid:2869)(cid:2869)(cid:2870)(cid:2871)(cid:2873) ≡ 38679  (𝑚𝑜𝑑  56509),  ou seja,  log(cid:2870)(38679)    =   11235. 

Diferentemente  dos  logaritmos  nos  Reais,  que  são  funções  estritamente 

crescentes  ou  decrescentes  (dependendo  da  base  do  log),  os  logaritmos  discretos 

possuem imagens com caráter praticamente aleatório, o que torna sua resolução bastante 

difícil.  

O exemplo anterior utilizou números pequenos, por isso foi facilmente resolvido 

através  de  um  computador.    No  entanto,  o  cálculo  de  um  logaritmo  discreto  pode  se 

tornar  difícil  até  para  um  computador,  desde  que  os  valores  de  a  e  𝑝  sejam 

cuidadosamente escolhidos. Essa dificuldade deu a Diffie e Hellman uma grande ideia, 

como veremos na seção a seguir. 

O gráfico acima mostra a irregularidade das potências 𝟔𝟐𝟕𝒙 módulo 𝒑 = 𝟗𝟒𝟏 

48 

 
 
 
                
 
 
 
 
 
 
 
 
 
 
 
 
 
3.3. Protocolo de Diffie-Hellman  (PDH) – Chave Trocada 

O Algoritmo de Diffie –Helman ajudará a resolver o seguinte dilema. Cascão e 

Cebolinha  desejam  compartilhar  uma  chave  secreta  para  uso  em  uma  cifra  simétrica, 

mas  o  seu  único  meio  de  comunicação  é  um  canal  de  comunicação  inseguro.  Cada 

pedaço de informação que Cascão e Cebolinha compartilham, é observado pela Mônica.  

Como é possível para Serginho e Joãozinho compartilhar uma chave sem torná-

la disponível para Mônica? À primeira vista parece que Serginho e Joãozinho enfrentam 

uma tarefa impossível, contudo Diffie e Hellman encontraram uma solução. 

No primeiro passo, Serginho e Joãozinho combinam a utilização de um número 

primo grande 𝑝 e um inteiro não nulo 𝑔 módulo 𝑝.  Os valores de  𝑝 e  𝑔, escolhidos por 

Serginho e Joãozinho, são tornados de conhecimento público, permitindo que qualquer 

pessoa, inclusive Mônica, também conheça esses números.   

No segundo passo é Serginho escolher um inteiro secreto 𝑎 que não irá revelar a 

ninguém, enquanto, ao mesmo tempo, Joãozinho escolhe um inteiro b, que ele manterá 

em segredo, não revelando a ninguém. Serginho e Joãozinho usam os inteiros secretos 

para calcular 

𝐴   ≡ 𝑔(cid:3028)  (𝑚𝑜𝑑  𝑝)
(cid:4579)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4580)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4581)
(cid:3020)(cid:3032)(cid:3045)(cid:3034)(cid:3036)(cid:3041)(cid:3035)(cid:3042)  (cid:3030)(cid:3028)(cid:3039)(cid:3030)(cid:3048)(cid:3039)(cid:3028)  (cid:3002)

              𝑒                       𝐵   ≡ 𝑔(cid:3029)  (𝑚𝑜𝑑  𝑝)
(cid:4579)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4580)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4581)
(cid:3011)(cid:3042)ã(cid:3042)(cid:3053)(cid:3036)(cid:3041)(cid:3035)(cid:3042)  (cid:3030)(cid:3028)(cid:3039)(cid:3030)(cid:3048)(cid:3039)(cid:3028)  (cid:3003)

No terceiro passo, Serginho  envia o valor  𝐴 para Joãozinho que, por sua  vez, 

envia o valor 𝐵 para Serginho. Note que Mônica começa a ver os valores de 𝐴 e 𝐵, uma 

vez que eles são enviados através de um  canal  de comunicação inseguro.  Novamente, 

Serginho e Joãozinho usam outra vez, seus inteiros secretos para calcular  

𝐴′   ≡ 𝐵(cid:3028)  (𝑚𝑜𝑑  𝑝)
(cid:4579)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4580)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4581)
(cid:3020)(cid:3032)(cid:3045)(cid:3034)(cid:3036)(cid:3041)(cid:3035)(cid:3042)  (cid:3030)(cid:3028)(cid:3039)(cid:3030)(cid:3048)(cid:3039)(cid:3028)  (cid:3002)′

              𝑒                       𝐵′   ≡ 𝐴(cid:3029)  (𝑚𝑜𝑑  𝑝)
(cid:4579)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4580)(cid:4583)(cid:4583)(cid:4583)(cid:4583)(cid:4581)
(cid:3011)(cid:3042)ã(cid:3042)(cid:3053)(cid:3036)(cid:3041)(cid:3035)(cid:3042)  (cid:3030)(cid:3028)(cid:3039)(cid:3030)(cid:3048)(cid:3039)(cid:3028)  (cid:3003)′

Observe que os valores calculados, A’  e B’, são exatamente os mesmos, pois 

𝐴′ ≡ 𝐵(cid:3028)    ≡ (𝑔(cid:3029))(cid:3028)    ≡ 𝑔(cid:3028)(cid:3029)    ≡ (𝑔(cid:3028))(cid:3029)    ≡ 𝐴(cid:3029)    ≡ 𝐵′ 

Este valor comum onde 𝑨’   ≡ 𝑩(cid:4593)(𝒎𝒐𝒅  𝒑)    é a Chave Trocada .  

49 

 
 
 
 
 
 
 
 
 
Exemplo  3.12:  Serginho  e  Joãozinho  concordam  em  usar  o  primo  𝑝   =   941  e  a  raiz 

primitiva 𝑔   =   627.  

  Serginho escolhe a chave secreta    𝑎   =   347   e calcula 

A   =   390   ≡ 627(cid:2871)(cid:2872)(cid:2875)  (mod  941). 

  Joãozinho escolhe a chave secreta 𝑏   =   781 e calcula  

𝐵   =   691   ≡ 627(cid:2875)(cid:2876)(cid:2869)  (𝑚𝑜𝑑  941). 

Serginho  envia  para  Joãozinho  o  número  𝐴   =   390  e  Joãozinho  envia  para 

Serginho  o  número  𝐵   =   691.  Ambas  as  transmissões  são  feitas  por  um  canal  de 

comunicação inseguro, assim, 𝐴 e 𝐵 podem ser considerados de conhecimento público.  

Os  números  𝑎 = 347  e  𝑏 = 781  não  são  transmitidos  e  permanecem  secretos. 

Neste momento, Serginho e Joãozinho são capazes de calcular a chave compartilhada, 

que é igual a 470.  

𝐵(cid:3028) = 470   ≡ 691(cid:2871)(cid:2872)(cid:2875)  (𝑚𝑜𝑑  941)      e      𝐴(cid:3029) = 470   ≡ 390(cid:2875)(cid:2876)(cid:2869)    (𝑚𝑜𝑑  941) 

Suponha  que  Mônica  tenha  interceptado  os  inteiros  𝐴   =   390  e  𝐵   =   691 

trocados por Serginho e Joãozinho. Para Mônica reconstituir as chaves secretas 𝑎 e 𝑏 de 

Serginho e Joãozinho, ela deverá resolver os seguintes problemas de congruência. 

627(cid:3028)    ≡ 390  (𝑚𝑜𝑑  941)              ou          627(cid:2912)    ≡ 691  (mod  941) 

Assim ela conhecerá os expoentes secretos. Tanto quanto se sabe, este é o único 

caminho para Mônica encontrar o valor secreto compartilhado de Serginho e Joãozinho, 

sem a assistência dos mesmos. É claro que os números utilizados em nosso exemplo são 

muito pequenos para oferecer segurança. Especialistas sugerem que o primo 𝑝 escolhido 

tenha aproximadamente 1000 bits (𝑝   ≈ 2(cid:2869)(cid:2868)(cid:2868)(cid:2868) ) e que o número g tenha ordem igual a 

um número primo próximo de 

(cid:3043)

(cid:2870)

. 

Em geral, o dilema de Mônica é este: Ela sabe quais são os valores   𝐴 = 𝑔(cid:3028) e 

𝐵 = 𝑔(cid:3029)  e também conhece os valores de 𝑝 e 𝑔, por isso, se ela puder resolver o PLD, 

então ela poderá encontrar os valores 𝑎 e 𝑏 e, com isso, Mônica poderá calcular a chave 

secreta compartilhada 𝑔(cid:3028)(cid:3029)  (𝑚𝑜𝑑  𝑝), que não foi transmitida em nenhum momento.  

50 

 
 
 
 
 
 
Aparentemente,  Serginho  e  Joãozinho  estão  seguros  desde  que  Mônica  seja 

incapaz  de  resolver  o  PLD,  mas  isso  não  é  uma  verdade  absoluta.  É  verdade  que  um 

método  para  encontrar  o  valor  compartilhado  entre  Serginho  e  Joãozinho  é  resolver  o 

PLD,  mas  talvez  isso  não  seja  necessário.  A  segurança  da  chave  compartilhada  de 

Serginho  e  Joãozinho  repousa  sobre  a  dificuldade  de  resolver  o  seguinte  problema, 

potencialmente mais fácil.  

Definição: (Problema de Diffie - Hellman – PDH) 

Seja 𝑝 um número primo e 𝑔 um inteiro. O Problema de Diffie-Hellman (PDH) 

é  o  problema  de  calcular  o  valor  de  𝑔(cid:3028)(cid:3029)  (𝑚𝑜𝑑  𝑝)  a  partir  dos  valores  conhecidos  de 

𝐴   =    𝑔(cid:3028)  (𝑚𝑜𝑑  𝑝)   e    𝐵   =    𝑔(cid:3029)  (𝑚𝑜𝑑  𝑝). 

É claro que o PDH não é mais difícil do que o PLD. Se Mônica pode resolver o 

PLD,  então  ela  pode  calcular  os  expoentes  secretos  𝑎  e  𝑏  de  Cascão  e  Cebolinha  que 

formam os valores  interceptados  𝐴 = 𝑔(cid:3028) e  𝐵 = 𝑔(cid:3029), e então fica fácil Mônica  calcular 

sua  chave  compartilhada,  𝑔(cid:3028)(cid:3029)  não  transmitida  em  nenhum  momento.  Na  verdade, 

Mônica  necessita  calcular  apenas  um  dos  valores  de  𝑎  e  𝑏,  para  conhecer  a  chave 

compartilhada.  

O problema inverso é menos claro. Suponha que Mônica tenha um algoritmo 

eficiente para resolver o PDH. Será que Mônica pode usá-lo também para resolver 

de maneira eficiente o PLD? A resposta não é conhecida. 

Diffie  e  Hellman  perceberam,  de 

forma  brilhante,  que  a  dificuldade  do 

problema  do  Logaritmo  Discreto  para 

∗

(cid:3435)ℤ(cid:3043)(cid:3439)

  fornece  uma  possível  solução  para 

esse problema. 

          Diffie                          Helman 

51 

 
 
 
 
 
 
 
 
 
                                                                         
 
 
 
 
 
 
 
3.4.  O Sistema Público de Criptografia ElGamal 

Veremos  agora  como  funciona  a  ideia  de  Elgamal  para  enviar  mensagens  com 
segurança.  Como  esse  método  utiliza  cálculos  numéricos,  surge  a  necessidade  de 
substituir  símbolos  por  números.  A  tabela  ASCII  (Código  Padrão  Americano  para  o 
Intercâmbio de Informação) fornece uma opção de pré-codificação. 

Vamos  supor  que  Serginho  queira  mandar  uma  mensagem  para  Joãozinho  por 
um canal inseguro de modo que ninguém tenha acesso ao seu conteúdo.  Digamos que 
essa  mensagem,  quando  pré-codificada  pela  tabela  ASCII,  fique  representada  pelo 
número 𝑀. 

Primeiramente, Joãozinho e Serginho combinam um número primo 𝑝 e uma raiz 

primitiva 𝑔. Joãozinho utiliza uma chave secreta 𝑎 com a qual calcula  

𝐴   ≡ 𝑔(cid:3028)  (𝑚𝑜𝑑  𝑝). 

e  depois  envia  para  Serginho  o  número  𝐴.  Este  escolhe  uma  chave  provisória  𝑘  e 
calcula: 

𝑐(cid:2869)    ≡ 𝑔(cid:3038)  (𝑚𝑜𝑑  𝑝)         e       𝑐(cid:2870)    ≡ 𝑀  𝐴(cid:3038)  (𝑚𝑜𝑑  𝑝) 

Deste  modo,  Serginho  codifica  a  mensagem  𝑀  criptografada  pelo  par  (𝑐(cid:2869), 𝑐(cid:2870)),    e  em 
seguida, envia o par (𝑐(cid:2869), 𝑐(cid:2870)) para Joãozinho, que por sua vez decodifica a mensagem 𝑀 
através do par (𝑐(cid:2869), 𝑐(cid:2870)) com os seguintes cálculos: 

52 

 
 
 
 
 
Passo 1: Determina  𝑥 ≡ 𝑐(cid:2869)

(cid:3028)    (𝑚𝑜𝑑  𝑝) 

Passo 2: Determina 𝑥(cid:2879)(cid:2869) módulo 𝑝, via Obs. página 40, pois  𝑥(cid:3043)(cid:2879)(cid:2870) ≡ 𝑥(cid:2879)(cid:2869)  (𝑚𝑜𝑑  𝑝), 

Passo 3: Calcula  

  𝑐(cid:2870)  𝑥(cid:2879)(cid:2869) ≡ (  𝑀  .    𝐴(cid:3038)  ) ∙ 𝑥(cid:2879)(cid:2869) ≡   𝑀  .    (𝑔(cid:3028))(cid:3038) ∙ 𝑥(cid:2879)(cid:2869) ≡ 𝑀  .    (𝑔(cid:3038))(cid:3028) ∙ 𝑥(cid:2879)(cid:2869) 

                            ≡ 𝑀  . (𝑐(cid:2869))(cid:3028)(cid:4579)(cid:4580)(cid:4581)
(cid:3030)(cid:3117)(cid:2880)  (cid:3034)(cid:3286)

   ∙ 𝑥(cid:2879)(cid:2869) ≡ 𝑀  .    𝑥   ∙ 𝑥(cid:2879)(cid:2869) ≡ 𝑀  (𝑚𝑜𝑑  𝑝) 

Agora basta que Joãozinho consulte a tabela ASCII para obter a mensagem original. 

Exemplo  3.13:  Joãozinho  usa  o  primo  𝑝   =   467,  a  raiz  primitiva  𝑔   =   2,  escolhe 
𝑎   =   153 para ser sua chave privada secreta e calcula sua chave pública 

𝐴   ≡ 𝑔(cid:3028)    ≡ 2(cid:2869)(cid:2873)(cid:2871) ≡ 224    (𝑚𝑜𝑑  467) 

Serginho  decide  enviar  para  Joãozinho  a  mensagem  𝑀   =   331(Essa  mensagem  é  um 
exemplo  meramente  numérico,  não  tendo  nenhuma  relação  com  a  tabela  ASCII).  Ele 
escolhe  uma  chave  efêmera  ao  acaso,  digamos  𝑘   =   197  e  calcula  os  dois  números a 
seguir: 

c(cid:2869)    ≡ 2(cid:2869)(cid:2877)(cid:2875) ≡ 87  (mod  467)                  e                      c(cid:2870)    ≡ 331  . 224(cid:2869)(cid:2877)(cid:2875)    ≡ 57  (mod  467) 

Serginho envia a mensagem criptografada em par (𝑐(cid:2869), 𝑐(cid:2870))    =    (87, 57) para Joãozinho. 

Joãozinho, utilizando sua chave secreta 𝑎   =   153, faz os seguintes passos 

Passo 1: Calcula   𝑥 ≡ 𝑐(cid:2869)

(cid:3028)    ≡ 87(cid:2869)(cid:2873)(cid:2871) ≡ 367  (𝑚𝑜𝑑  467) 

Passo 2: Calcula  𝑥(cid:3043)(cid:2879)(cid:2870) ≡ 367(cid:2872)(cid:2874)(cid:2873) ≡ 14   ≡ 𝑥(cid:2879)(cid:2869)    (𝑚𝑜𝑑  467)  

Passo 3: Calcula  𝑐(cid:2870)  𝑥(cid:2879)(cid:2869)    ≡ 57  .14     ≡ 331   ≡ 𝑀    (𝑚𝑜𝑑  467) 

e  assim decodifica a mensagem 𝑀   =   331 enviada por Serginho. 

Em 1985, Taher 
ElGamal publicou um 
artigo intitulado  

A Criptografia de chave 
pública e um esquema 
de assinatura com base 
em logaritmos 
discretos. 

53 

 
                                                       
                       
 
 
CAPITULO 4 

Em  virtude  da  proliferação  dos  meios  de  comunicação  e  da  necessidade  de 

enviar  numerosas  mensagens,  tornou-se  muito  desejável  desenvolver  métodos  de 

codificação  de  mensagens.  No  passado  os  códigos  eram  secretos,  apenas  pelos  que 

enviavam  e  recebiam  as  mensagens,  mas  havia  sempre  a  possibilidade  de  estudar 

mensagens interceptadas e decodificá-las. 

Um  grande  progresso  foi  realizado  em  criptografia  com  o  aparecimento  dos 

criptosistemas  de  chave  publica.  As  principais  características  desse  sistema  são  a  sua 

simplicidade, sua chave publica e extrema dificuldade em violar o código.  

A  ideia  foi  proposta  em  1976  por  Diffie  e  Hellman  e  sua  efetiva  execução  foi 

conseguida  por  Rivest,  Shamir  e  Adleman,  onde  este  criptosistema  é  conhecido  como 

RSA  que  iremos  descrevê-lo.  Cada  letra  ou  sinal,  ai  incluído  o  espaço  em  branco, 

corresponde  a  um  número  de  três  algarismos.  No  American  Standard  Code  for 

Information  Interchange  (ASCII),  isto  é,  “No  Código  Americano  Padrão  para 

Intercâmbio  de  Informações”,  esta  correspondência  é  a  seguinte: 

... 

032 

I 

073 

R 

082 

A 

065 

J 

074 

S 

083 

B 

066 

K 

075 

T 

084 

C 

067 

L 

076 

U 

085 

D 

068 

M 

077 

V 

086 

E 

069 

N 

078 

W 

087 

F 

070 

O 

079 

X 

088 

G 

071 

P 

080 

Y 

089 

H 

072 

Q 

081 

Z 

090 

Cada letra ou sinal  da mensagem  é substituído  pelo  numero de três algarismos 

que lhe corresponde produzindo assim um numero 𝑀, que representa a mensagem. Cada 

usuário A do sistema inscreve sua chave num fichário publico, e a mesma é um par de 

inteiros  (𝑛(cid:3002), 𝑠(cid:3002))  positivos.  O  primeiro  inteiro  𝑛(cid:3002)  é  o  produto  de  dois  números  primos 

distintos 𝑝(cid:3002), 𝑞(cid:3002), isto é, 𝑛(cid:3002)    =    𝑝(cid:3002)  . 𝑞(cid:3002) que são muito grande e conservados secretos. Por 

outro lado, 𝑠(cid:3002) é escolhido bem grande de tal forma que seja primo com 𝑝(cid:3002) − 1 e 𝑞(cid:3002) − 1, 

cuja motivação será explicada no decorrer do capitulo. 

54 

 
 
  
 
 
 
 
  
Para  enviar  a  mensagem  M  a  outro  usuário  B,  A  codifica  M  -  a  maneira  de 

codificar  depende  da  pessoa  que  receberá  a  mensagem.  Recebendo  a  mensagem 

codificada  de  A,  o  usuário  B  a  decodifica,  utilizando  seu  numero  secreto  próprio  de 

decodificação, e este processo será exibido em detalhes no decorrer do texto.  

4.1 Fórmula de Euler e raízes módulo 𝒑𝒒 

O  método  de  troca  de  chaves  Diffie-Hellman  e  do  sistema  de  criptografia 

ElGamal  de  chave  pública  estudada  no  capitulo  anterior,  contam  com  o  fato  de  que  é 

fácil de calcular potências 𝑎(cid:3041)  (𝑚𝑜𝑑  𝑝), mas é difícil recuperar o expoente conhecendo 

apenas os valores de 𝑎  (𝑚𝑜𝑑  𝑝) e 𝑎(cid:3041)(𝑚𝑜𝑑  𝑝).  Um resultado essencial que usamos para 

analisar  a  segurança  de  Diffie-Hellman  e  ElGamal  é  o  Pequeno  Teorema  de  Fermat 

visto no capitulo anterior 

𝑎(cid:3043)(cid:2879)(cid:2869) ≡ 1  (𝑚𝑜𝑑  𝑝)            ∀      𝑎   ≠ 𝑘𝑝    𝑐𝑜𝑚  𝑘   ∈ ℤ     

Uma  pergunta  natural  que  surge,  é  o  que  acontece  se  substituirmos  𝑝  por  um 

número  𝑚  não  primo,  isto  é,  será  que  o  resultado  𝑎(cid:3040)(cid:2879)(cid:2869)    ≡ 1  (𝑚𝑜𝑑  𝑚)  é  válido  em 

geral. Vemos facilmente que o resultado não vale em geral, pois se tomarmos  𝑎 = 3 e 

𝑚 = 10 vemos que 𝑎(cid:2877) =    3(cid:2869)(cid:2868)(cid:2879)(cid:2869) ≡ 3  (𝑚𝑜𝑑  10).   

Nesta seção apresentaremos uma generalização do Pequeno Teorema de Fermat 

quando 𝑚   =   𝑝𝑞 é um produto de dois números primos distintos, uma vez que este é o 

caso  mais  relevante  para  aplicações  em  criptografia.  Façamos  um  exemplo  para 

clarearmos  as  ideias,  onde  𝑚   =   3.5   =   15.  Se  fizermos  uma  tabela  de  quadrados  e 

cubos  módulo  15,  eles  não  parecem  muito  interessantes,  mas  muitas  quarta  potências 

são iguais a 1 módulo 15. Mais precisamente, temos que 

  𝑎     ≡ 1    (𝑚𝑜𝑑  15)    para 𝑎   =   1, 2, 4, 7, 8, 11, 13  𝑒  14; 

  𝑎(cid:2872) ≢   1  (𝑚𝑜𝑑  15)       para 𝑎   =   3, 5, 6, 9, 10  𝑒  12  . 

O que distingue a lista de números 1, 2, 4, 7, 8, 11, 13, 14, cujo quarta potência é 

igual a 1 módulo 15 da lista de números 3, 5, 6, 9, 10, 12, 15, cujo quarta é diferente de 

1  modulo  15?  Um  momento  de  reflexão  mostra  que  cada  um  dos  números 

55 

 
 
 
 
 
 
 
 
3, 5, 6, 9, 10, 12, 15  tem  um  fator  não  trivial  em  comum  com  o  módulo  15,  enquanto 

que  os  números  1, 2, 4, 7, 8, 11, 13, 14  são  relativamente  primos  a  15.  Isto  sugere  que 

alguma  versão  do  Pequeno  Teorema  de  Fermat  deve  ser  válida  se  o  número  𝑎  é 

relativamente primo ao “m”, mas certamente o expoente correto não é  (𝑚  –   1). 

Para  𝑚   =   15  descobrimos  que  o  expoente  correto  é  4.  Para  vermos  isso, 

observamos que 𝑎(cid:2870) ≡ 1  (𝑚𝑜𝑑  3)    ⇒ 𝑎(cid:2872) ≡ 1  (𝑚𝑜𝑑  3)  e 𝑎(cid:2872)    ≡ 1  (𝑚𝑜𝑑  5)  ambas como 

conseqüência  do  PTF.  Assim  3  divide  (𝑎(cid:2872)    − 1)  e  5  divide  (𝑎(cid:2872)    − 1),  logo  15  divide 

(𝑎(cid:2872)    − 1), isto é, 𝑎(cid:2872)    ≡ 1  (𝑚𝑜𝑑  15).  

Se  você  pensar  sobre  essas  duas  congruências,  verá  que  a  propriedade 

fundamental do expoente 4 é que ele é um múltiplo de (𝑝  –   1) para 𝑝   =   3 e 𝑝   =   5. 

Note-se  que  isto  não  é  verdade  para  𝑚 − 1 = 14  como  um  expoente.  Com  essa 

observação, estamos prontos para a fórmula fundamental do sistema de criptografia de 

chave pública RSA. 

Proposição 4.1: (Fórmula de Euler para 𝒑𝒒). Sejam 𝑝 e 𝑞 números primos distintos e 

se 𝑔   =   𝑚𝑑𝑐  (𝑝   −   1, 𝑞   −   1), então  

((cid:3043)(cid:2879)(cid:2869)).((cid:3044)(cid:2879)(cid:2869))

(cid:3034)(cid:3415)    ≡ 1      (𝑚𝑜𝑑  𝑝𝑞)    𝑡𝑎𝑙  𝑞𝑢𝑒        𝑚𝑑𝑐(𝑎, 𝑝𝑞) = 1 

𝑎

Em particular, se 𝑝 e 𝑞  são primos ímpares, então  

((cid:3043)(cid:2879)(cid:2869)).((cid:3044)(cid:2879)(cid:2869))

(cid:2870)(cid:3415)    ≡ 1      (𝑚𝑜𝑑  𝑝𝑞)    𝑡𝑎𝑙  𝑞𝑢𝑒        𝑚𝑑𝑐(𝑎, 𝑝𝑞) = 1 

𝑎

Prova:  como 

  𝑚𝑑𝑐(𝑎, 𝑝𝑞) =   1     ⇒     𝑝  𝑛ã𝑜  𝑑𝑖𝑣𝑖𝑑𝑒  𝑎. 

  𝑔 = 𝑚𝑑𝑐(𝑝 − 1, 𝑞 − 1)    ⇒ 𝑔  𝑑𝑖𝑣𝑖𝑑𝑒  (𝑞 − 1). 

Então 

((cid:3043)(cid:2879)(cid:2869)).((cid:3044)(cid:2879)(cid:2869))

(cid:3034)(cid:3415) = (𝑎(cid:3043)(cid:2879)(cid:2869))

𝑎

((cid:3292)(cid:3127)(cid:3117))

(cid:3282)                       visto que 𝑔 divide (𝑞 − 1) 

                                                    ≡ (1)

((cid:3292)(cid:3127)(cid:3117))

(cid:3282)   (𝑚𝑜𝑑  𝑝)            visto que 𝑎(cid:3043)(cid:2879)(cid:2869)    ≡ 1  (𝑚𝑜𝑑  𝑝)   do PTF 

                                                  ≡ 1    (𝑚𝑜𝑑  𝑝) 

56 

 
 
 
O mesmo cálculo, invertendo os papéis de 𝑝 e 𝑞, mostra que 

((cid:3043)(cid:2879)(cid:2869)).((cid:3044)(cid:2879)(cid:2869))

(cid:3034)(cid:3415) ≡ 1    (𝑚𝑜𝑑  𝑞) 

𝑎

Isto mostra que 𝑎

((cid:3043)(cid:2879)(cid:2869)).((cid:3044)(cid:2879)(cid:2869))

(cid:3034)(cid:3415) −   1 é divisível por 𝑝 e 𝑞, e portanto é divisível por 𝑝𝑞, o 

que completa a prova da proposição. ∎ 

O método de troca de chaves Diffie-Hellman e do sistema de criptografia ElGamal de 

chave  pública  estudada  no  capítulo  anterior,  dependem  para  a  sua  segurança  da 

dificuldade de resolver equações da forma 

𝑎(cid:3051) ≡ 𝑏  (𝑚𝑜𝑑  𝑝) 

onde  a,  b  e  p  são  variáveis  conhecidas,  p  é  um  número  primo  e  “x”  é  a  variável 

desconhecida.  O  criptosistema  de  chave  pública  RSA  baseia-se  na  dificuldade  de 

resolver equações da forma  

𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑁) 

onde  agora  as  variáveis  𝑘, 𝑐  e  𝑁  são  conhecidas  e  a  variável  𝑥  é  desconhecida.  Em 

outras  palavras,  a  segurança  do  RSA  baseia-se  no  pressuposto  que  é  difícil  tomar  𝑘-

ésimas raízes módulo 𝑁.  

Lema 4.2. Sejam 𝑎, 𝑚 inteiros com 𝑚   ≥ 1. Então 

𝑎. 𝑑   ≡ 1  (𝑚𝑜𝑑  𝑚)    𝑝𝑎𝑟𝑎  𝑎𝑙𝑔𝑢𝑚    𝑑   ∈   ℤ           ⇔         𝑚𝑑𝑐  (𝑎, 𝑚) = 1 

Prova:  

(⇐)  𝑚𝑑𝑐  (𝑎. 𝑚) = 1   ⇒      ∃    𝑑, 𝑐   ∈   ℤ    ;   𝑎𝑑 + 𝑚𝑐 = 1     

                                                                                  ⇒   𝑎𝑑 − 1 = −𝑐. 𝑚   

                                                                                  ⇒   𝑎𝑑 ≡ 1  (𝑚𝑜𝑑  𝑚)  

57 

 
 
 
 
(⇒)  𝑎. 𝑑   ≡ 1  (𝑚𝑜𝑑  𝑚)    ⇒   𝑎𝑑 − 1 = 𝑐𝑚      para algum 𝑐   ∈   ℤ 

                                                                                        ⇒     𝑎𝑑 − 𝑐𝑚 = 1 

                                                                                      ⇒       𝑚𝑑𝑐  (𝑎, 𝑚)  𝑑𝑖𝑣𝑖𝑑𝑒  1 

                                                                                        ⇒       𝑚𝑑𝑐  (𝑎, 𝑚) =   1. ∎ 

Proposição 4.3: Seja  𝑝 um primo e  𝑘   ≥ 1 um inteiro satisfazendo 𝑚𝑑𝑐  (𝑘, 𝑝 − 1)    =

  1. Então 

𝑥(cid:3038)    ≡ 𝑐  (𝑚𝑜𝑑  𝑝)    têm a única solução 𝑥   ≡    𝑐(cid:3031)  (𝑚𝑜𝑑  𝑝) 

Onde 𝑑 é o inverso de 𝑘 módulo (𝑝 − 1). 

Prova: Se 𝑐   ≡ 0  𝑚𝑜𝑑  𝑝 então 𝑥   ≡ 0  (𝑚𝑜𝑑  𝑝) é a única solução e acabou. Assuma que 

𝑐   ≢ 0  (𝑚𝑜𝑑  𝑝).  Como  𝑚𝑑𝑐  (𝑘, 𝑝 − 1)    =   1  segue  do  Lema  4.2  que  𝑑𝑘   ≡

1  (𝑚𝑜𝑑  𝑝 − 1) o que significa que  

𝑑𝑘   ≡ 1 + 𝑟(𝑝 − 1) 

Vamos agora checar que 𝑥 = 𝑐(cid:3031) é uma solução para 𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑝).  

(𝑐(cid:3031))(cid:3038)    ≡    𝑐(cid:3031)(cid:3038)                                  (𝑚𝑜𝑑    𝑝)  

                          ≡    𝑐(cid:2869)(cid:2878)(cid:3038)((cid:3043)(cid:2879)(cid:2869))            (𝑚𝑜𝑑  𝑝)   visto que 𝑑𝑘 = 1 +   𝑟(𝑝 − 1) 

                          ≡    𝑐(cid:2869)  . (𝑐(cid:3043)(cid:2879)(cid:2869))(cid:3038)    (𝑚𝑜𝑑  𝑝) 

                          ≡   𝑐  . 1(cid:3038)                            (𝑚𝑜𝑑  𝑝)   pelo PTF 

                          ≡ 𝑐                                                (𝑚𝑜𝑑  𝑝) 

Para mostar a unicidade, suponha que 𝑥(cid:2869) e 𝑥(cid:2870) são soluções da congruência  𝑥(cid:3038) ≡
𝑐  (𝑚𝑜𝑑  𝑝).Acabamos de mostrar que  𝑧(cid:3031)(cid:3038)    ≡ 𝑧  (𝑚𝑜𝑑  𝑝) para qualquer valor não nulo 

“z”, então temos que 

𝑥(cid:2869) ≡ 𝑥(cid:2869)

(cid:3038)(cid:3439)
(cid:3031)(cid:3038)    ≡ (cid:3435)𝑥(cid:2869)

(cid:3031)

(cid:3038)(cid:3439)
   ≡ 𝑐(cid:3031)    ≡ (cid:3435)𝑥(cid:2870)

(cid:3031)

≡ 𝑥(cid:2870)

(cid:3038)(cid:3031)    ≡ 𝑥(cid:2870)  (𝑚𝑜𝑑  𝑝) 

Assim 𝑥(cid:2869) e 𝑥(cid:2870) são iguais módulo 𝑝, de modo que 𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑝), tem no máximo uma 
solução. ∎ 

58 

 
 
Exemplo: Resolvendo a congruência para 𝑘 = 1583, 𝑐   =   4714    𝑒  𝑁 = 𝑝   =   7919  

𝑥(cid:3038) = 𝑥(cid:2869)(cid:2873)(cid:2876)(cid:2871)    ≡ 4714  (𝑚𝑜𝑑  7919) 

onde o módulo p = 7919 é primo. Resolvendo a congruência através do algoritmo 

Euclidiano Extendido 

1583  𝑑     ≡ 1  (𝑚𝑜𝑑  7918)        ⇒       𝑑   ≡ 5277    (𝑚𝑜𝑑  7918) 

e segue do Lema 4.2  que  𝑚𝑑𝑐  (𝑑, 𝑝 − 1)    =   1. Pela proposição 4.3 segue que  

𝑥   ≡ 𝑐(cid:3031)    ≡ 4714(cid:2873)(cid:2870)(cid:2875)(cid:2875)    ≡ 6059    (𝑚𝑜𝑑  7919) 

é uma solução para 𝑥(cid:3038) = 𝑥(cid:2869)(cid:2873)(cid:2876)(cid:2871)    ≡     4714  (𝑚𝑜𝑑  7919).   ∎   

A proposição 4.3 mostra que é fácil calcular a k-ésima raiz se o módulo é um 

primo p. A proposição seguinte explica com fazer isso se 𝑁 = 𝑝𝑞 é um produto de 

dois números primos  

Proposição 4.4:  Seja 𝑝 e 𝑞 primos distintos e seja 𝑘   ≥   1 tal que  

𝑚𝑑𝑐  (𝑘, (𝑝 − 1). (𝑞 − 1)) = 1 

Então a congruência 

𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑝𝑞)   tem a única solução 𝑥 ≡ 𝑐(cid:3031)  (𝑚𝑜𝑑  𝑝𝑞) 

Onde 𝑑 é o inverso de 𝑘 módulo (𝑝 − 1). (𝑞 − 1). 

Prova:  Assuma  que  o  𝑚𝑑𝑐  (𝑐, 𝑝𝑞)    =   1.  Como  𝑚𝑑𝑐  (𝑘, (𝑝 − 1). (𝑞 − 1)) = 1  segue 

do Lema 4.2 que 𝑘 tem inverso módulo (𝑝 − 1). (𝑞 − 1), isto é, existe 𝑑   ∈   ℤ tal que 

𝑑. 𝑘   ≡ 1    (𝑚𝑜𝑑  (𝑝 − 1). (𝑞 − 1)  ) 

Isto significa que existe um inteiro r tal que 

𝑑. 𝑘 = 1 + 𝑟(𝑝 − 1). (𝑞 − 1) 

Agora iremos checar que  𝑥 = 𝑐(cid:3031) é uma solução para  𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑝𝑞)  

(𝑐(cid:3031))(cid:3038)    ≡    𝑐(cid:3031)(cid:3038)      (𝑚𝑜𝑑    𝑝𝑞)  

                          ≡    𝑐(cid:2869)(cid:2878)(cid:3038)((cid:3043)(cid:2879)(cid:2869))((cid:3044)(cid:2879)(cid:2869))      (𝑚𝑜𝑑  𝑝𝑞)   visto que 𝑑𝑘 = 1 +   𝑟(𝑝 − 1)(𝑞 − 1) 

59 

 
 
                          ≡    𝑐(cid:2869)  . (cid:3435)𝑐((cid:3043)(cid:2879)(cid:2869)).((cid:3044)(cid:2879)(cid:2869))(cid:3439)

(cid:3038)

    (𝑚𝑜𝑑  𝑝𝑞) 

                          ≡   𝑐  . 1(cid:3038)    (𝑚𝑜𝑑  𝑝𝑞)   pela Fórmula de Euler para 𝑝𝑞 

                          ≡   𝑐            (𝑚𝑜𝑑  𝑝𝑞) 

Para  mostar  a  unicidade,  suponha  que  𝑥 = 𝑢    é  uma  solução  da 

congruência  𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑝𝑞). Então 

  𝑢   ≡ 𝑢(cid:3031)(cid:3038)(cid:2879)(cid:3045)((cid:3043)(cid:2879)(cid:2869))((cid:3038)(cid:2879)(cid:2869))    (𝑚𝑜𝑑  𝑝𝑞)       visto que  𝑑𝑘   =   1   + 𝑟(𝑝 − 1). (𝑞 − 1) 

          ≡   (𝑢(cid:3038))(cid:3031)  . (cid:3435)𝑢((cid:3043)(cid:2879)(cid:2869))((cid:3044)(cid:2879)(cid:2869))(cid:3439)

(cid:2879)(cid:3045)

  (𝑚𝑜𝑑  𝑝𝑞) 

          ≡ (𝑢(cid:3038))(cid:3031)  . 1(cid:2879)(cid:3045)      (𝑚𝑜𝑑  𝑝𝑞)       usando a Fórmula de Euler para 𝑝𝑞 

          ≡ 𝑐(cid:3031)      (𝑚𝑜𝑑  𝑝𝑞)         visto que 𝑢 é solução de 𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑝𝑞). 

Queremos mostrar que  
Ck.d  ≡ c mod n 

Por definição de d, temos que 

Logo em qualquer caso ckd ≡ c mod p 

De maneira análoga provamos o caso 2 

k.d ≡ 1 mod (p – 1).(q – 1) 

Sendo assim temos: 

k.d = 1 + r.(p – 1).(q – 1) 

Queremos calcular separados 
ckd mod p caso 1 
ckd mod q caso 2 

Fazendo o caso 1: 
ckd  ≡ c1[bp-1]r.(q-1) mod p 
Se p ∤ c    ⇒ cp-1 ≡ 1 mod p ( PTF) 
                                ⇒ ckd ≡ c.1r.(q-1) ≡ b mod p  

Se p | c   

⇒ ckd ≡ 0 mod p  

⇒ c ≡ 0 mod p 
⇒ ckd ≡ c mod p 

⇒ y = 0 + k.p 

⇒ w = c + q .(k.p)  

              ⇒ w = c + k.(q.p) 

⇒ 𝑤 ≡ 𝑐  𝑚𝑜𝑑  (𝑝. 𝑞)  

S=(cid:4682)

c(cid:2921).(cid:2914) ≡ c  mod  p
  
c(cid:2921).(cid:2914) ≡ c  mod  q

Observe que b é uma solução de 

(cid:3420)

w ≡ c  mod  p          (1)
w ≡ c  mod  q            (2)

  

Segue de (2) ⇒   𝑤 ≡ 𝑐  𝑚𝑜𝑑  𝑝 

⇒ w – c = q.y 

⇒  w = c + q.y 

De (1) ⇒  c + q.y ≡ 𝑐  𝑚𝑜𝑑  𝑝    

⇒   q.y ≡ 0    𝑚𝑜𝑑  𝑝 
⇒ 𝑞(cid:3364). 𝑦(cid:3364) = 0(cid:3364) 

solução geral 
Como ck.d também é solução de S 
Temos que ck.d = c + (p.q)r 

⇒ 𝑐𝑘.(cid:3031) ≡ 𝑐  𝑚𝑜𝑑  𝑝𝑞 

          ⇒ (𝑐(cid:3031))(cid:3038) ≡ 𝑐  𝑚𝑜𝑑  𝑛.  

60 

 
 
 
 
      
 
 
 
 
 
 
 
 
 
 
 
   
 
 
              ⇒ 𝑤 ≡ 𝑐  𝑚𝑜𝑑  𝑛 

⇒ 𝑥𝑘 ≡ 𝑐  𝑚𝑜𝑑  𝑛. ∎ 

⇒ w = c + t.(p.q) com t ∈ ℤ é a 

Exemplo 4.6: Vamos resolver a congruência  

𝑥(cid:3038) = 𝑥(cid:2869)(cid:2875)(cid:2871)(cid:2876)(cid:2877)    ≡ 43927  (𝑚𝑜𝑑  64349) 

Onde  o  modulo  𝑁   =   64349   =   229.281    é  o  produto  de  dois  primos  𝑝   =   229  e 

𝑞   =   281 e 𝑘   =   17389. O primeiro passo é resolver a congruência  

𝑘  𝑑 = 17389  𝑑   ≡ 1  𝑚𝑜𝑑  63840 

Onde   (𝑝 − 1). (𝑞 − 1) =   228  . 280 = 63840. Vemos que  

𝑑 ≡ 53509    (𝑚𝑜𝑑  63840). 

Então a proposição 4.4 nos diz que 

𝑥   ≡ 𝑐(cid:3031) = 43927(cid:2873)(cid:2871)(cid:2873)(cid:2868)(cid:2877)    ≡ 14458  (𝑚𝑜𝑑  64349) 

é solução para   𝑥(cid:3038) = 𝑥(cid:2869)(cid:2875)(cid:2871)(cid:2876)(cid:2877) ≡ 43927  (𝑚𝑜𝑑  64349) . 

Exemplo 4.7: Serginho desafia Joãozinho para resolver a congruência  

𝑥(cid:3038) = 𝑥(cid:2877)(cid:2876)(cid:2872)(cid:2871) ≡ 134872  (𝑚𝑜𝑑  30069476293) 

O  módulo  𝑁 =   30069476293  é  um  produto  de  dois  números  primos,  mas  se 

Joãozinho não conhece sua fatoração, ele não pode usar a Proposição 4.4 para resolver o 

desafio do Serginho. Depois de aceitar a concessão da derrota de  Joãozinho, Serginho 

informa  a  Joãozinho  que  𝑁   =   30069476293   =   104729  . 287117 = 𝑝. 𝑞.  Com  esta 

nova  informação,  o  desafio  de  Serginho  se  torna  muito  mais  fácil.  Joãozinho  calcula 

(𝑝 − 1). (𝑞 − 1)    =   104728  . 287116   =   3006908448  e resolve a congruência  

𝑘𝑑 = 9843  𝑑   ≡ 1  (𝑚𝑜𝑑  30069084448)   

Para encontrar 𝑏 ≡ 18472798299  (𝑚𝑜𝑑  30069084448)  e calcular a solução  

𝑥 = 𝑐(cid:3031) ≡ 134872(cid:2869)(cid:2876)(cid:2872)(cid:2875)(cid:2870)(cid:2875)(cid:2877)(cid:2876)(cid:2870)(cid:2877)(cid:2877)    ≡ 25470280263    (𝑚𝑜𝑑  30069476293).∎ 

61 

 
 
 
 
 
 
 
Serginho  e  Joãozinho  sempre  trocam  informações  confidenciais  através  de  um 

canal de comunicação inseguro e temem que Mônica possa interceptar estas mensagens. 

Vimos no capítulo 3 várias maneiras em que Serginho e Joãozinho possam realizar essa 

tarefa,  com  base  na  dificuldade  de  resolver  o  Problema  do  Logaritmo  Discreto,  e  na 

próxima seção iremos descrever o criptosistema de chave publica RSA. 

4. 2 O Sistema de Criptografia RSA 

Em  1976,  Whitfield  Diffie  e  Martin  Hellman  escreveram  um  documento 

chamado  “As  novas  direções  da  criptografia”  mostrando  a  ideia  de  usar  criptografia de 

chaves publicas. Vários especialistas tentaram desenvolver um algoritmo que pudessem 

atender as especificações propostas por Diffie-Hellman. 

O RSA foi desenvolvido em 1978 em resposta a essa necessidade no MIT, por 

Ron Rivest, Adi Shamir e Leonard Adleman (daí a sigla RSA). O algoritmo do RSA foi 

o primeiro algoritmo de chaves publicas e vem sendo amplamente usado desde então. 

O RSA é basicamente o resultado de dois cálculos matemáticos. Um para cifrar 

e outro para decifrar. O RSA usa duas chaves criptográficas, uma chave pública e uma 

privada.  No  caso  da  criptografia  assimétrica  tradicional,  a  chave  pública  é  usada  para 

codificar a mensagem e a chave privada é usada para decodificar a mensagem. 

 A  segurança  desse  método  se  baseia  na  dificuldade  da  fatoração  de  números 

inteiros extensos. Em 1977, os criadores do RSA achavam que uma chave de 200 bits 

requereriam  1015  anos,  porém  chaves  com  155  bits  foram  atacadas  em  menos  de  8 

meses.  A  saída  é  que  na  medida  em  que  os  algoritmos  se  tornem  melhores  e  os 

computadores  se  tornem  mais  velozes,  maiores  serão  as  chaves.    Atualmente  chaves 

com  300  dígitos  (1000  bits)  nos  dão  uma  tranquilidade  por  algum  tempo.  Em  níveis 

críticos, chaves com 2000 bits começam a ser usadas.  

O  criptosistema  de  chave  publica  RSA  é  resumido  na  tabela  abaixo  entre 

Joãozinho e Serginho. 

62 

 
 
 
 
 
 
 
 
 
 
 
Joãozinho 

Serginho 

Criação da chave 

  Escolha dos primos secretos 𝑝 e 𝑞 

  Escolha do expoente de 

criptografia 𝑘 de modo que o  

𝑚𝑑𝑐  (𝑘, (𝑝 − 1)(𝑞 − 1)  )    =   1 

  Chave Publica (𝑁   =   𝑝𝑞, 𝑘) 

Codificando a Mensagem 

  Escolhe a mensagem M 

  Usa a chave pública de Joãozinho 

para calcular 𝑐   ≡ 𝑀(cid:3038)  (𝑚𝑜𝑑  𝑁)   

  Enviar mensagem codificada c 

para Joãozinho.  

Decodificando a Mensagem 

  Calcula d onde  

𝑘𝑑 ≡ 1  (𝑚𝑜𝑑(𝑝 − 1)(𝑞 − 1)) 

  Calcula 

𝑐(cid:3031)    ≡ 𝑀(cid:3561)  (𝑚𝑜𝑑  𝑁) 

  Então 𝑀(cid:3561) é igual a mensagem 𝑀 

Tabela RSA 

A chave secreta do Joãozinho é um par de números primos grandes 𝑝 e 𝑞. A sua 

chave  pública  é  o  par  (𝑁, 𝑘),  que  consiste  do  produto  de  𝑁   =   𝑝𝑞  e  um  expoente  de 

criptografia  𝑘  que  é  relativamente  primo  com  (𝑝 − 1)(𝑞 − 1).  Serginho  escolhe  a 

mensagem M e a converte através da chave de criptografia 𝑘 em um inteiro 𝑐 entre 1 e 

𝑁 com o seguinte cálculo  

𝑐 ≡    𝑀(cid:3038)    (𝑚𝑜𝑑  𝑁) 

O  inteiro  c  é  a  mensagem  de  Serginho  codificada,  que  cascão  envia  para  Joãozinho. 

Para  decodificar  a  mensagem,  Joãozinho  resolve  a  congruência  𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑁) 

usando a Proposição 4.4, pois conhece a fatoração de 𝑁 = 𝑝𝑞. Mônica, por outro lado, 

pode  interceptar  a  mensagem  codificada  c  de  Serginho,  mas  como  não  conhece  os 

63 

 
 
 
 
 
 
 
fatores  de  𝑁,  ela  terá  muita  dificuldade  em  resolver  a  congruência  𝑥(cid:3038) ≡ 𝑐  (𝑚𝑜𝑑  𝑁) 

para decodificar a mensagem c em tempo hábil.  

Exemplo  4.8:  Ilustraremos  o  sistema  de  criptografia  de  chave  pública  RSA  com  um 

pequeno  exemplo  numérico.  É  claro  que  este  exemplo  não  é  seguro,  já  que  para 

números  pequenos,  seria  fácil  para  Mônica  encontrar  os  fatores  𝑝  e  𝑞  de  𝑁. 

Implementações  seguras de uso  do criptosistema  RSA módulo 𝑁  utilizam centenas de 

dígitos.  

Joãozinho  

Serginho 

Criação da chave 

Escolha  dos  primos  secretos  𝑝 = 1223  e 

𝑞 = 1987 e 𝑁   =   𝑝. 𝑞 

Escolha  do  expoente  de  criptografia  

𝑘 = 948047 de modo que o  

𝑚𝑑𝑐(𝑘, (𝑝 − 1), (𝑞 − 1)  )    =   1 

Chave pública de Joãozinho 

(𝑁, 𝑘)    =    (2430101, 948047) 

Codificando a Mensagem  

Serginho converte sua mensagem  simples 

em um inteiro  

𝑀 = 1070777   tal que 1   ≤ 𝑀 < 𝑁 
Serginho  usa  a  chave  publica  de 

Joãozinho  

(𝑁, 𝑘)    =    (2430101, 948047) 

para calcular 𝑐   ≡ 𝑀(cid:3038)  (𝑚𝑜𝑑  𝑁) , isto é 
𝑐 ≡ 1070777(cid:2877)(cid:2872)(cid:2876)(cid:2868)(cid:2872)(cid:2875)(𝑚𝑜𝑑  2430101) 

Resultando que  

𝑐 ≡ 1473513  (𝑚𝑜𝑑  2430101) 
Serginho  envia  a  mensagem  codificada 

𝑐 = 1473513   para Joãozinho 

Decodificando a Mensagem 

64 

 
 
 
 
 
 
 
 
 
 
 
 
Joãozinho conhece  

(𝑝 − 1)(𝑞 − 1)    =   2426892   

e calcula d onde  

𝑘  𝑑   =   948047  𝑑 ≡ 1  𝑚𝑜𝑑  2426892   

e encontra que  

𝑑   =   1051235 

Joãozinho decodifica c através do cálculo  

𝑐(cid:3031) ≡ 𝑀  (𝑚𝑜𝑑  𝑁) 

Isto é,  

1473513(cid:2869)(cid:2868)(cid:2873)(cid:2869)(cid:2870)(cid:2871)(cid:2873) ≡ 1070777  𝑚𝑜𝑑  𝑁 

O  valor  encontrado  por  Joãozinho  é  a 
mensagem convertida de Serginho 
. 

Se  𝑝  e  𝑞  são  grandes  números  primos,  tendo,  pelo  menos  100  algarismos  e 

escolhidos  ao  acaso,  a  fatoração  de  n,  que  tem  pelo  menos  200  algarismos  não  pode 

fazer-se em tempo razoável com os métodos hoje conhecidos. Uma pergunta natural, é 

como escolher bem os fatores primos do número 𝑁 = 𝑝𝑞 e a chave 𝑘, de modo que, seja 

pouco provável que o sistema possa ser violado. 

É  muito  importante  para  a  segurança  da  mensagem  que  não  se  possa  fatorar  a 

chave  publica.  Quantos  algarismos  devem  ter  essa  chave  para  que  a  fatoração  exija 

tempo demasiado para ser aplicável? 

Para testar este ponto, várias chaves foram propostas aos matemáticos como um 

desafio.  Assim  foi  o  numero  chamado  RSA-768,  que  tem  768  bits  de  comprimento  e 

232 algarismos decimais 

𝑅𝑆𝐴 − 768   =   

1230  1866  8453  0117  7551  3049  4958  3849  6272  0772  8535  6959  53 

3479  2197  3224  5215  1726  4005  0726  3657  5187  4520  2199  7864  69 

3899  5647  4942  7740  6384  5925  1925  5732  6303  4537  3154  8268  50 

7917  0261  2214  2913  4616  7042  9214  3116  0222  1240  4792  7473  77 

                      9408  0665  3514  1959  7459  8556  6902  1434  13 

65 

 
 
 
 
 
 
 
 
Este  número  foi  escolhido  com  muito  cuidado  em  vista  de  ser  uma  chave 

possível  para  o  RSA.  O  problema  foi  resolvido  em  dezembro  de  2009  por  um  grupo 

internacional  que  conseguiu  determinar  os  dois  fatores  primos,  cada  um  com  116 

algarismos. 

𝑝   = 3347  8071  6989  5689  8786  0441  6984  8212  6908  1770  4794  9837  13 

                  7685  6891  2431  3889  8288  3793  8780  0228  7614  7116  5253  1743  08 

                  7737  8144  6799  9489 

𝑞   =   3674  6043  6667  9959  0428  2446  3379  9627  9526  3227  9158  1643  43   

                    0876  4267  6032  2838  1573  9666  5112  7923  3373  4171  4339  6810  27  

                  0092  7987  3630  8917 

O processo utilizado foi o crivo geral do corpo de números GNFS utilizando o 

software desenvolvido em grande parte na universidade de Bonn. O calculo que durou 

20  meses,  foi  repartido  por  centenas  de  PC’s;;  este  trabalho  exigiria  1.500  anos  com  um  

processador de 2,2 GHz. 

Por causa da segurança, é necessária muita prudência na escolha de chaves para 

o processo RSA. Com o progresso dos métodos de fatoração e a codificação de equipes 

fortes, pode-se imaginar que em menos de uma década, módulos com 1024 bits, que no 

momento oferecem toda segurança, já poderiam ser fatorados pelo método GNFS. Por 

esta  razão  os  cientistas  recomendam  que  as  chaves  com  1024  bits  não  sejam  mais 

utilizadas a partir das Olimpíadas em 2016. 

Faremos agora um exemplo onde a mensagem 𝑀 a ser transmitida será quebrada 

em blocos que devem ser números menores do que 𝑁 = 𝑝𝑞 pois após a decodificação, 

queremos obter a mensagem original e não blocos congruentes, e observamos que: 

  A maneira de escolher os blocos não é única. 

  Os blocos não precisam ter o mesmo tamanho. 

  O bloco não pode começar com zero pois não teríamos como distinguir o bloco 

0𝑛(cid:2869)𝑛(cid:2870) do bloco 𝑛(cid:2869)𝑛(cid:2870) 

Usaremos a seguinte notação: 

  𝑏 =  bloco da mensagem 𝑀, isto é, um inteiro positivo menor do que 𝑁 = 𝑝𝑞. 

  𝐶(𝑏) =  Codificação do bloco b, definido por 𝐶(𝑏) ≡ 𝑏(cid:2871)  (𝑚𝑜𝑑  𝑁) 

66 

 
 
 
 
 
 
 
 
  𝑎 =   bloco codificado, isto é, 𝑎   =   𝐶(𝑏) para algum bloco 𝑏 

  𝐷(𝑎)    = Decodificação do bloco a, definido por 𝐷(𝑎)    ≡ 𝑎(cid:3031)  (𝑚𝑜𝑑  𝑁)  

Se  𝑏  é  um  bloco  da  mensagem  original,  então  só  será  legitimo  chamar  o 

processo  de  decodificação,  se  𝐷(  𝐶(𝑏)  )    =   𝑏,  e  não  é  obvio  que  isto  é  verdade  sem 

conhecer a Proposição 4.4. Primeiramente, mapearemos o alfabeto com números de dois 

algarismos e indicaremos o espaço por : 

A  B  C  D  E  F  G  H  I 

J  K  L  M 

10  11  12  13  14  15  16  17  18  19  20  21  22 

N  O  P  Q  R  S  T  U  V  W  X  Y  Z  espaço 

23  24  25  26  27  28  29  30  31  32  33  34  35 

99 

Desta forma a frase “COELHO  NA  FOGUEIRA”  fica  representada  pelo  número 

𝑀   =   122414211724992310991524163014182710. 

 Joãozinho  

Serginho 

Passo 1:  Cebolinha escolhe  𝑝 = 17 e 
𝑞 = 31 primos secretos, e calcula 
𝑁   =   𝑝. 𝑞 = 527 e como 

(𝑝 − 1)(𝑞 − 1)    =   16.30   =   480 

 Cebolinha escolhe 𝑘   =   41 onde  

𝑚𝑑𝑐  (cid:3435)𝑘, (𝑝 − 1)(𝑞 − 1)(cid:3439) = 1 

e sua chave publica é (𝑁, 𝑘) 

67 

 
 
 
 
 
 
 
Passo 2: Serginho converte sua mensagem 

“coelho  na  fogueira”  em um inteiro M e a 

divide em blocos b tal que 1   ≤ 𝑏 < 𝑁   e 

não começando por zero, conforme abaixo 

122 − 414 − 211 − 72 − 499 

−  23 − 109 − 91 − 524 − 16 

−  301 − 418 − 27 − 10 

Serginho usa a chave publica de Joãozinho  

(𝑁, 𝑘)    =    (527, 41) 

Para cada bloco 𝑏 da mensagem M será 

efetuado o cálculo de codificação. 

 𝐶(𝑏)    ≡ 𝑏(cid:3038)  (𝑚𝑜𝑑  𝑁)  

Joãozinho 

Serginho 

          𝐶(122)– 𝐶(414) − 𝐶(211) − 𝐶(72) 

−  𝐶(499) −   𝑪(𝟐𝟑) − 𝐶(109) − 𝐶(91) 

−  𝐶(524) − 𝐶(16) −   𝐶(301)   

−  𝐶(418)  –   𝐶(27)  –   𝐶(10) 

Por exemplo: 𝐶(23)    =    23(cid:2872)(cid:2869)  (𝑚𝑜𝑑  527) 

        23(cid:2870) = 529   ≡ 2  (𝑚𝑜𝑑  527) ⇒ 

        23(cid:2870)(cid:2868) = (23(cid:2870))(cid:2869)(cid:2868) ≡ −30  (𝑚𝑜𝑑  527) ⇒ 

        23(cid:2872)(cid:2868) = 900   ≡ 373  (𝑚𝑜𝑑  527) ⇒ 

        23(cid:2872)(cid:2869) ≡ 373  . 23   ≡ 147  (𝑚𝑜𝑑  527) 

Logo 𝐶(23)    =   147, analogamente 

            184 − 334 − 129 − 174 − 385 

      −𝟏𝟒𝟕 − 78 − 215 − 173 − 16 

      −449 − 58 − 143. 

Serginho envia 𝑀 em blocos codificado. 

68 

 
 
 
 
 
Passo 3:  Joãozinho malandro, calcula 𝑑  

𝑘  𝑑   =   41  𝑑 ≡ 1  (𝑚𝑜𝑑  480)   

e encontra que  

𝑑   = 281   

Para cada bloco da mensagem, Joãozinho 

decodifica 𝑎 = 𝐶(𝑏) através do cálculo 

𝐷(𝑎)    ≡ 𝑎(cid:3031)  (𝑚𝑜𝑑  𝑁) 

Decodificando 𝑎 = 𝐶(𝑏)    =   147  

usando o método de expansão binária  

𝐷(147) ≡ 147(cid:2870)(cid:2876)(cid:2869)    (𝑚𝑜𝑑  527) 

De fato, usando o método de expansão binária do capítulo 3 

Joãozinho 

Serginho 

          281   =    2(cid:2876)    +    2(cid:2872)    +    2(cid:2871)    +   1 
. 147(cid:2870)(cid:3119)
          147(cid:2870)(cid:2876)(cid:2869)    = 147(cid:2870)(cid:3124)

. 147(cid:2870)(cid:3120)

. 147(cid:2869)   

Segue que 

𝑖 

0 

147(cid:2870)(cid:3284)  

(𝑚𝑜𝑑527)   

147 

𝑖 

5 

147(cid:2870)(cid:3284)  

(𝑚𝑜𝑑527)    188 

Portanto  

1 

2 

6 

35 

2 

4 

7 

3 

16 

8 

171 

256 

𝑫(𝟏𝟒𝟕) ≡   147(cid:2870)(cid:2876)(cid:2869) = 256.256.16.147   ≡ 𝟐𝟑  (𝑚𝑜𝑑  257) 

Desta forma, Joãozinho recupera o inteiro M de Serginho  

        122 − 414 − 211 − 72 − 499 −   23 − 109 − 

            91 − 524   − 16 −   301 − 418 − 27 − 10 

Joãozinho  finalmente  converte  a  informação  numérica  M 

através do alfabeto obtendo:  

“COELHO  NA  FOGUEIRA” 

e abre um sorriso no rosto.  

69 

 
 
 
 
 
 
 
Faremos  agora  um  caso  particular  do  criptosistema  RSA  onde  os  parâmetros 

secretos 𝑝 e 𝑞 são primos distintos satisfazendo  𝑝   ≡ 5  (𝑚𝑜𝑑  6)  e 𝑞   ≡ 5  (𝑚𝑜𝑑  6). A 

motivação desta escolha de 𝑝 e 𝑞 garante que 3 é inversível módulo (𝑝 − 1)(𝑞 − 1) e a 

chave de codificação pública poderá ser (𝑁, 3).  

Primeiro  vamos  determinar  explicitamente  o  inverso  de  3  𝑚𝑜𝑑  (𝑝 − 1)(𝑞 − 1) 

que 

será  denotado  por  𝑑.  Como  𝑝   ≡ 5  (𝑚𝑜𝑑  6), 𝑞   ≡ 5  (𝑚𝑜𝑑  6)    𝑒   − 1   ≡

−1  (𝑚𝑜𝑑  6),  segue  que  (𝑝 − 1) ≡ 4  (𝑚𝑜𝑑  6)    e    (𝑞 − 1) ≡ 4  (𝑚𝑜𝑑  6).  Assim 

(𝑝 − 1)(𝑞 − 1) ≡ −2  (𝑚𝑜𝑑  6),  e  portanto  (𝑝 − 1)(𝑞 − 1)    =   6𝑘 − 2.  Como  𝑑  é  o 

inverso  de  3  𝑚𝑜𝑑  (𝑝 − 1)(𝑞 − 1),  temos  que  3𝑑   ≡ 1  (cid:3435)𝑚𝑜𝑑  (𝑝 − 1)(𝑞 − 1)(cid:3439),    logo 

3𝑑   ≡ 1  (cid:3435)𝑚𝑜𝑑  (6𝑘 − 2)(cid:3439)  e  assim,  3𝑑 = (6𝑘 − 2)𝑡 + 1    para  algum  t  ∈   ℤ.    Já  vimos 

que  podemos  calcular  o  inverso  de  um  número  módulo  (𝑝 − 1)(𝑞 − 1)  através  da 

extensão  do  algoritmo  euclidiano,  mas  tomando  𝑑   =   4𝑘 − 1    segue  que  3𝑑   =

  3  (4𝑘 − 1) =   12𝑘 − 3   =    (6𝑘 − 2). 2   +   1, onde  𝑘   =   

(cid:2869)

(cid:2874)

  [  (𝑝 − 1)(𝑞 − 1) + 2]. 

Serginho 

 Joãozinho  
Passo  1:  Joãozinho  escolhe  como  primos 

≡ 5  (𝑚𝑜𝑑  6)  secretos  𝑝 = 17    e  𝑞 = 23. 

Logo   𝑁   =   𝑝. 𝑞 = 391 

e toma como chave pública 

(𝑁, 3)    =    (391,3) 

Passo 2: Serginho converte sua mensagem 
“AMO  A  OBMEP”  em  um  inteiro  𝑀  

1022249910992411221425 

e a divide em blocos b tal que 1   ≤ 𝑏 < 𝑁   
e  não  começando  por  zero,  conforme 

abaixo 

          102 − 224 − 99 − 109 − 92 − 

          41 − 122 − 142 − 5 
Serginho  usa  a  chave  publica  de 
Joãozinho  

(𝑁, 3)    =    (391, 3) 

Para  cada  bloco  𝑏  da  mensagem  M  será 

efetuado o cálculo de codificação. 

 𝐶(𝑏)    ≡ 𝑏(cid:2871)  (𝑚𝑜𝑑  𝑁) 

70 

 
 
 
 
 
 
 
 
Joãozinho 

Serginho 

Como 𝐶(𝑏)    ≡ 𝑏(cid:2871)  (𝑚𝑜𝑑  𝑁) temos 

          34 − 129 − 228 − 37 − 207 − 

          105 − 44 −   386 − 125 

Serginho  envia  a  mensagem  codificada 

em blocos 

Passo 

3: 

Joãozinho 

usando 

sua 

malandragem de sempre sabe que  

𝑘 =

=   

1
6
1
6

Portanto  

[  (𝑝 − 1). (𝑞 − 1) + 2] 

  [16.22 + 2] = 59           

𝑑 = 4𝑘 − 1 = 4.59 − 1 = 235 

Para  cada bloco da mensagem,  Joãozinho 

decodifica 𝑎 = 𝐶(𝑏) através do cálculo 

𝐷(𝑎)    ≡ 𝑎(cid:3031)  (𝑚𝑜𝑑  𝑁) 

Decodificando,  Joãozinho 

recupera  o 

inteiro 𝑀 de Serginho  

1022249910992411221425 

e  converte  esta 

informação  numérica 

usando o alfabeto obtendo  

AMO A OBMEP 

71 

 
 
 
 
 
 
 
 
 
4.3 A SEGURANÇA DO MÉTODO RSA 

Note  que  determinar  a  chave  privada  de  decodificação  𝑑  não  seria  uma  tarefa 

fácil  sem  conhecer  o  valor  de  (𝑝 − 1)(𝑞 − 1).  Por  isso  deve  ser  guardado  de  forma 

segura  os  valores  dos  primos  𝑝  e  𝑞.  Como  já  vimos,  não  existe  um  método  eficiente 

para se fatorar números grandes, e um ponto muito importante, se refere à escolha dos 

primos 𝑝 e 𝑞. É claro que se forem pequenos, o sistema será mais fácil de quebrar. Mas 

também não basta escolher p e q grandes com  |𝑝 − 𝑞| pequeno, devido  ao Algoritmo 

de  Fermat  descrito  a  seguir.  Contudo,  precisamos  ter  certeza  que  os  números 

(cid:3435)𝑝  –   1(cid:3439), (cid:3435)𝑞  –   1(cid:3439), (𝑝   +   1)  e  (𝑞   +   1)  não  tem  fatores  primos    pequenos,  pois  caso 

contrário,  faria  de  𝑁 = 𝑝𝑞    uma  presa  fácil  para  alguns  algoritmos  de  fatoração 

conhecidos.  Embora  isso  pareça  muito  simples  em  princípio,  na  prática  é  totalmente 

inviável. A razão é que não existem computadores rápidos o suficiente, nem algoritmos 

eficientes,  que  nos  permitam  fatorar  um  número  inteiro  muito  grande  que  não  tenha 

fatores relativamente pequenos. 

Na  verdade,  não  existe  nenhum  algoritmo  conhecido  capaz  de  fatorar  inteiros 

grandes  de  modo  realmente  eficiente,  não  se  sabe  nem  mesmo  se  é  possível  que  esse 

algoritmo exista. 

O Algoritmo de Fermat 

Este  exemplo  está  vinculado  à  necessidade  de  Fermat  encontrar  um  processo 

para  fatorar  números  relativamente  grandes,  para  a  época  é  claro,  ou  mostrar  sua 

primalidade.  Fermat  desenvolveu  dois  algoritmos.  Um  para  fatorar  um  número  inteiro 

qualquer e outro específico para números de Mersenne. Estes resultados mostram o seu 

engenho na manipulação dos números. Segundo Coutinho (Coutinho, 2001 p. 40 e 157), 

o  primeiro  método  consistia  em  fatorar  um  número  utilizando  um  algoritmo  mais  ou 

menos como o descrito a seguir. 

72 

 
 
 
 
 
 
 
 
 
Para  começar  suporemos  que  𝑁  é  ímpar,  já  que  se  𝑁  for  par  então  2  é  um  de 

seus fatores. A ideia do  algoritmo  é tentar  achar  números inteiros positivos  𝑥 e  𝑦 tais 

que N= 𝑥(cid:2870)  –  𝑦(cid:2870). Supondo que encontramos estes números temos que  

𝑁   =    𝑥(cid:2870)  –  𝑦(cid:2870)    =    (𝑥 − 𝑦)(𝑥 + 𝑦) 

Logo (𝑥 − 𝑦) e (𝑥 + 𝑦) são fatores de 𝑁. 

Para poder aplicar o Algoritmo de Fermat, assumiremos que já temos em nosso 

computador  um  algoritmo  para  determinar  a  raiz  quadrada  de  𝑁.  Na  verdade  é 

suficiente  obter  a  parte  inteira  da  raiz  quadrada  de  𝑁.  Se  𝑟  é  um  número  real, 

denotaremos  sua  parte  inteira  por  [𝑟].  Por  exemplo,  (cid:3427)√125(cid:3431) = 11    𝑒  [𝜋] = 3.  É  claro 

que se r é inteiro então [𝑟] = 𝑟. 

O  caso  mais  fácil  do  algoritmo  de  Fermat  ocorre  quando  𝑁  é  um  quadrado 

perfeito, isto é, quando existe algum inteiro 𝑟 tal que 𝑁 = 𝑟(cid:2870). Neste caso, temos que 𝑟 é 

fator de 𝑁. Além disso, na notação acima, 𝑥 = 𝑟 e 𝑦   =   0. Observe que se 𝑦   >   0 então 

𝑁 = 𝑥(cid:2870) − 𝑦(cid:2870)      ⇒       𝑥 = (cid:3493)𝑁 + 𝑦(cid:2870) >    √𝑁   

Isto sugere a seguinte estratégia para encontrar x e y 

Algoritmo de Fermat 

Entrada: inteiro positivo ímpar N 

Saída: um fator de 𝑁 ou uma mensagem indicando que 𝑁 é primo 

Etapa 1: Comece com 𝑥 =    (cid:3427)√𝑁(cid:3431),   se 𝑁 = 𝑥(cid:2870) então 𝑥 é fator de 𝑁  e paramos.  

Etapa 2: Caso contrário, incremente 𝑥 de uma unidade e calculamos  

Etapa 3: Repita a Etapa 2 ate  

𝑦   = (cid:3493)𝑥(cid:2870) − 𝑁 

  Encontrar um valor inteiro para y e assim 𝑁   =    (𝑥 + 𝑦)(𝑥 − 𝑦) 

  Até que 𝑥  seja igual   

(cid:3041)(cid:2878)(cid:2869)

(cid:2870)

  e neste caso 𝑁 é primo 

73 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
O  funcionamento  do  Algoritmo  de  Fermat  ficará  mais  claro  se  fizermos  um 

exemplo numérico. Seja 𝑁   =   1342127 o número que queremos fatorar. A variável 𝑥 

inicializada com a parte inteira da raiz quadrada de 𝑁, que neste caso vale 𝑥   =   1158. 

Mas  

𝑥(cid:2870)    =    1158(cid:2870)      =   1340964   <   𝑁   =   1342127 

Logo passamos a incrementar x de um em um. Fazemos isto até que  

(cid:3493)𝑥(cid:2870) − 𝑁 

Seja  inteiro,  ou  x  seja  igual  a  (𝑛 + 1)/2,  que  neste  caso  vale  671064.  É  mais  fácil 

resumir isto em uma tabela 

𝑥 

1159 

1160 

1161 

1162 

1163 

1164 

𝑦 =    (cid:3493)𝑥(cid:2870) − 𝑁 

33,97 

58,93 

76,11 

90,09 

102,18 

113 

Obtivemos  assim,  um  inteiro  no  sexto  laço.  Portanto  𝑥   =   1164  e  𝑦   =   113  são  os 

valores desejados. Os fatores correspondentes são 𝑥 + 𝑦   =   1277 e 𝑥 − 𝑦   =   1051. 

Prova do Algoritmo de Fermat: 

Não é de modo algum claro porque o algoritmo de Fermat funciona, nem porque 

pára.  Observe  que  é  necessário  considerar  separadamente  o  que  ocorre  quando  𝑁  é 

composto e quando 𝑁 é primo.  

No  primeiro  caso  precisamos  mostrar  que  existe  um  inteiro  𝑥   >    [√𝑁]  tal  que 

𝑦 = √𝑥(cid:2870) −   𝑁é um inteiro menor que 

(cid:3015)(cid:2878)(cid:2869)

(cid:2870)

. Isto significa que se 𝑁 é composto então o 

algoritmo para antes de chegar a 

único valor de x possível é 

(cid:3015)(cid:2878)(cid:2869)

(cid:2870)

. 

(cid:3015)(cid:2878)(cid:2869)

(cid:2870)

. Se 𝑁 é primo, então é necessário verificar que o 

74 

 
 
 
 
 
Suponhamos que 𝑁 pode ser fatorado na forma 𝑁 = 𝑎𝑏 onde 𝑎 ≤ 𝑏. Queremos 

obter inteiros positivos 𝑥 e 𝑦 tais que 𝑁   =    𝑥(cid:2870)  –  𝑦(cid:2870). Em outras palavras 

𝑁   =   𝑎𝑏   =    (𝑥 − 𝑦)(𝑥 + 𝑦)    =    𝑥(cid:2870)  –  𝑦(cid:2870)   

Como 𝑥 − 𝑦   ≤ 𝑥 + 𝑦, isto sugere que tomemos 𝑎   =   𝑥 − 𝑦 e 𝑏   =   𝑥 +   𝑦. Resolvendo 

este sistema de duas equações em duas incógnitas obtemos 

𝑥 =   

𝑎 + 𝑏
2

                        𝑒                        𝑦 =   

𝑏 − 𝑎
2

De fato, expandindo os produtos notáveis verificamos facilmente que  

𝑏 + 𝑎
(cid:3436)
2

(cid:2870)
(cid:3440)

−    (cid:3436)

(cid:2870)

𝑏 − 𝑎
2

(cid:3440)

= 𝑎𝑏 = 𝑁                    (∗) 

Note que 𝑥 e 𝑦 tem que ser números inteiros, mas (𝑏 + 𝑎)/2 e (𝑏 − 𝑎)/2 estão 

escritos na forma de fração. Porém 𝑁 é ímpar por hipótese, logo 𝑎 e 𝑏, que são fatores 

de  𝑁  tem  que  ser  ímpares.  Portanto  (𝑏 + 𝑎)  e  (𝑏 − 𝑎)  são  pares  e  consequentemente 

(𝑏 + 𝑎)/2  e  (𝑏 − 𝑎)/2  são  inteiros.    É  por  isso  que  precisamos  sempre  supor  que  a 

entrada do algoritmo é sempre um número ímpar.  

Se 𝑁 é primo então só podemos ter 𝑎   =   1 e 𝑏   =   𝑁. Com isto 𝑥   =    (𝑛 + 1)/2 

e este é o único valor possível para 𝑥 se 𝑁 é primo. Resta nos considerar o caso em que 

𝑁  é  composto.  Se  𝑎   =   𝑏,  o  algoritmo  já  obtém  a  resposta  desejada  já  na  Etapa  1. 

Podemos  então,  supor  que  N  é  composto  e  não  é  um  quadrado  perfeito,  isto  é,  1   <

  𝑎   <   𝑏   <   𝑁.  Vejamos  que,  neste  caso,  o  algoritmo  vai  parar  se  forem  satisfeitas  as 

desigualdades 

(cid:3427)√𝑁(cid:3431) ≤

𝑎 + 𝑏
2

   <   

𝑛 + 1
2

              (∗∗) 

que provaremos a seguir. 

A  desigualdade  da  direita  nos  diz  que  𝑎 + 𝑏 <   𝑛 + 1.  Substituindo  𝑁   =   𝑎𝑏 

nesta ultima desigualdade e subtraindo 𝑏   + 1 de ambos os membros obtemos 𝑎 − 1   <

  𝑎𝑏 − 𝑏 = (𝑎 − 1)𝑏.  Já  que  𝑎   >   1,  podemos  ainda  cancelar  (𝑎 − 1)  de  ambos  os 

membros.  Fazendo  isso  obtemos  1   <   𝑏.  Este  argumento  mostra  que  1   <   𝑏  é 

75 

 
 
 
 
 
 
equivalente  a  desigualdade  original.  Como  1   <   𝑎   <   𝑏  vale  por  hipótese  provamos 

que 

(cid:3028)(cid:2878)(cid:3029)

(cid:2870)

<   

(cid:3015)(cid:2878)(cid:2869)
. 

(cid:2870)

Consideremos  agora  a  desigualdade  da  esquerda.  Observemos  primeiro  que 

como (cid:3427)√𝑁(cid:3431) ≤ √𝑁, basta verificar que √𝑁    ≤

((cid:3028)(cid:2878)(cid:3029))

(cid:2870)

.  Esta desigualdade é verdadeira se e 

somente se   𝑁 ≤

((cid:3028)(cid:2878)(cid:3029))(cid:3118)
(cid:2872)

. Mas por (∗) segue que 

𝑏 + 𝑎
(cid:3436)
2

(cid:2870)
(cid:3440)

−   𝑁 =    (cid:3436)

(cid:2870)
(cid:3440)

𝑏 − 𝑎
2

que é sempre um numero não negativo. Obtivemos assim que 

((cid:3028)(cid:2878)(cid:3029))(cid:3118)
(cid:2872)

−   𝑁   ≥   0. O que é 

equivalente a desigualdade desejada. 

Voltemos ao algoritmo de Fermat. Lembre que a variável 𝑥 é inicializada com 

o valor (cid:3427)√𝑁(cid:3431) e que vai sendo incrementado de uma unidade a cada laço. Assim (∗∗) nos 

garante que , se 𝑁 for composto, chegaremos a (𝑎 + 𝑏)/2 antes de chegar a (𝑛 + 1)/2. 

Quando 𝑥   =    (𝑎 + 𝑏)/2  

𝑦(cid:2870) = (cid:3436)

𝑎 + 𝑏
2

(cid:2870)
(cid:3440)

−   𝑁 = (cid:3436)

(cid:2870)

𝑏 − 𝑎
2

(cid:3440)

Pela identidade (∗). Atingindo este laço, o algoritmo pára, obtendo 𝑎 e 𝑏 como fatores. 

Portanto, se 𝑁 é composto, o algoritmo sempre pára antes de chegar a 𝑥   =    (𝑛 + 1)/2, 

tendo determinado fatores de 𝑁. ∎ 

Este algoritmo nos diz uma coisa muito importante sobre o  𝑅𝑆𝐴. Lembre-se que 

a segurança do 𝑅𝑆𝐴 depende da dificuldade de fatorar a chave publica 𝑁, que é igual ao 

produto de dois primos. A primeira impressão é que basta escolher os primos grandes, 

para  que  𝑁  é  difícil  de  fatorar.  Mas  isto  não  é  verdade.  Por  exemplo,  se  escolhermos 

primos  grandes,  mais  próximos,  então  𝑁  é  facilmente  fatorável  pelo  algoritmo  de 

Fermat.  

76 

 
 
 
 
 
 
 
 
 
CAPÍTULO 5 

Nesse capítulo iremos propor atividades relativas aos conteúdos abordados 

5.1 Atividades 

 1-  Vamos criptografar a palavra MATEMATICA utilizando a palavra chave RSA 

2-   Com  o  auxilio  de  uma  calculadora  e  utilizando  o  algoritmo  de  Fermat  vamos 

decompor os números: 

a)  352717 

b)  799811 

c)  99400891 

d)  4087 

3-  Vamos criptografar a palavra COPA DO MUNDO dados n= 517 e 𝑒 = 3 

4-  Vamos decodificar a mensagem encontrada na atividade um.   

5-  Tente decodificar a mensagem encontrada na atividade três. 

5.2 Respostas das Tarefas 

1)   

M  A 

12 

R 

17 

29 

D 

26 

S 

18 

34 

S 

T 

19 

A 

26 

45 

T 

E 

4 

R 

17 

21 

V 

M 

12 

S 

18 

30 

E 

A 

26 

A 

26 

52 

A 

T 

19 

R 

17 

36 

K 

I 

8 

S 

18 

26 

A 

C 

2 

A 

26 

28 

C 

A 

26 

R 

17 

43 

R 

ORIGINAL 

CHAVE 

SOMA 

CODIFICADA 

77 

 
 
 
 
 
 
 
 
 
 
2)  Fatores (x + y) e (x – y) 

a)  n = 352717 

   It        x   

y = √𝑥(cid:2870) − 𝑛 

    1      594   10.908712 

    2      595   36.166283 

    3      596   49.989999 

    4      597   60.761830 

    5      598   69.907081 

    6      599   78.000000 

y = 78.000000 é inteiro, logo 352717 tem fatores 521 e 677. 

b)  n = 799811 

   It        x   

y = √𝑥(cid:2870) − 𝑛 

    1      895   34.842503 

    2      896   54.817880 

    3      897   69.267597 

    4      898   81.197291 

    5      899   91.596943 

    6      900   100.940577 

    7      901   109.498858 

    8      902   117.443603 

    9      903   124.891953 

   10      904   131.928011 

   11      905   138.614574 

   12      906   145.000000 

y = 145.000000 é inteiro, logo 799811 tem fatores 761 e 1051. 

c)  n = 99400891 

  It        x   

y = √𝑥(cid:2870) − 𝑛   

  1     9970 

 3.000000 

y = 3.000000 é inteiro, logo 99400891 tem fatores 9967 e 9973. 

78 

 
 
 
 
 
d)  n = 4087 

  It        x   

y = √𝑥(cid:2870) − 𝑛    

 1      

 64  

3.000000 

y = 3.000000 é inteiro, logo 4087 tem fatores 61 e 67 

3)  Considerando os blocos 

122-425-109-91-324-99-22-302-313-24 

Ficarão codificados assim: 

144-431-461-302-345-407-308-433-510-382 

4)  Temos que resolver a congruência da diferença mod 26 

D 

3 

R 

17 

-14 

M 

S 

18 

S 

18 

0 

A 

T 

19 

A 

26 

-7 

T 

V 

21 

R 

17 

4 

E 

E 

4 

S 

18 

-14 

M 

A 

26 

A 

26 

0 

A 

K 

10 

R 

17 

-7 

T 

A 

26 

S 

18 

8 

I 

C 

2 

A 

26 

-24 

C 

R 

17 

R 

17 

0 

A 

CODIFICADA 

CHAVE 

DIFFERENÇA 

ORIGINAL 

5)  Temos  primeiro  que  encontrar  “d”  o  inverso  de  3  mod 𝜑(𝑛) 

𝑑. 𝑒 ≡ 1  (𝑚𝑜𝑑  460) 

⇒ 3. 𝑑 − 1 = 460𝑘 

⇒ 3. 𝑑 = 460𝑘 + 1 

⇒ 3. 𝑑 = 459𝑘 + 𝑘 + 1 

⇒ 𝑘 + 1 = 𝑀(3) ⇒ 𝑘 = 2 

⇒ 𝑑 = 307 

Basta  calcular  [𝑐(𝑏)](cid:3031)  módulo  n.  Agora  vamos  decodificar  o  bloco  144,  usando  o 

método da expansão binária 

79 

 
 
 
 
 
 
 
 
 
 
 
 
    
Queremos encontrar o resto da divisão de 144307 por 517. 

307 = 2(cid:2876) + 2(cid:2873) + 2(cid:2872) + 2(cid:2869) + 2(cid:2868) 

144(cid:2871)(cid:2868)(cid:2875) =    147(cid:2870)(cid:3124)

. 147(cid:2870)(cid:3121)

. 147(cid:2870)(cid:3120)

. 147(cid:2870)(cid:3117)

. 147(cid:2870)(cid:3116)

i 

0 

144(cid:2870)(cid:3284)

144 

(𝑚𝑜𝑑  517) 
144(cid:2871)(cid:2868)(cid:2875) ≡    147(cid:2870)(cid:3124)

122  𝑚𝑜𝑑  517 

1 

56 

2 

34 

3 

4 

5 

6 

7 

8 

122 

408 

507 

100 

177 

309 

. 147(cid:2870)(cid:3121)

. 147(cid:2870)(cid:3120)

. 147(cid:2870)(cid:3117)

. 147(cid:2869) ≡ 144.56.408.507.309 ≡

Repetindo o mesmo processo para cada um dos blocos obteremos: 

122-425-109-91-324-99-22-302-313-24 

80 

 
 
 
 
 
 
 
 
 
 
Apêndice 1 

# 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 

18 

19 

0 

21 

22 

23 

24 

25 

26 

27 

n 

2 

3 

5 

7 

13 

17 

19 

31 

61 

89 

Mn 

3 

7 

31 

127 

8.191 

131.071 

524.287 

2.147.483.647 

2.305.843.009.213.693.951 

618970019…449.562.111 

107 

162259276…010.288.127 

127 

170141183…884.105.727 

Digitos em Mn 

Data do descobrimento 

Descobridor 

1 

1 

2 

3 

4 

6 

6 

10 

19 

27 

33 

39 

Antiguidade 

Antiguidade 

Antiguidade 

Antiguidade 

Antiguidade 

Antiguidade 

aAntiguidade 

Antiguidade 

1456 

1588 

1588 

1772 

1883 

1911 

1914 

1876 

anônimo 

Pietro Antonio Cataldi 

Pietro Antonio Cataldi 

Leonhard Paul Euler 

Ivan Mikheevich Pervushin 

R.E.Powers 

E. Fauquembergue 

Édouard Lucas 

521 

686479766…115.057.151 

157 

30 de janeiro de 1952 

Raphael M. Robinson 

607 

531137992…031.728.127 

183 

30 de janeiro de 1952 

Raphael M. Robinson 

1.279 

104079321…168.729.087 

386 

25 de junho de 1952 

Raphael M. Robinson 

2.203 

147597991…697.771.007 

664 

7 de outubro de 1952 

Raphael M. Robinson 

2.281 

446087557…132.836.351 

687 

9 de outubro de 1952 

Raphael M. Robinson 

3.217 

259117086…909.315.071 

969 

8 de setembro de 1957 

Hans Riesel 

4.253 

190797007…350.484.991 

1.281 

3 de novembro de 1961 

Alexander Hurwitz 

4.423 

285542542…608.580.607 

1.332 

3 de novembro de 1961 

Alexander Hurwitz 

9.689 

478220278…225.754.111 

2.917 

11 de maio de 1963 

Donald B. Gillies 

9.941 

346088282…789.463.551 

2.993 

16 de maio de 1963 

Donald B. Gillies 

11.213 

281411201…696.392.191 

3.376 

2 de junho de 1963 

Donald B. Gillies 

19.937 

431542479…968.041.471 

6.002 

4 de março de 1971 

Bryant Tuckerman 

21.701 

448679166…511.882.751 

6.533 

30 de outubro de 1978 

Landon Curt Noll e Laura Nickel 

23.209 

402874115…779.264.511 

6.987 

9 de fevereiro de 1979 

Landon Curt Noll 

44.497 

854509824…011.228.671 

13.395 

8 de abril de 1979 

H. Nelson e David Slowinski 

81 

 
 
 
28 

86.243 

536927995…433.438.207 

25.962 

25 de setembro de 1982 

David Slowinski 

# 

29 

30 

31 

32 

33 

n 

Mn 

Digitos em Mn 

Data do descobrimento 

Descobridor 

110.503 

521928313…465.515.007 

33.265 

25 de setembro de 1988 

Walt Colquitt e Luke  Welsh 

132.049 

512740276…730.061.311 

39.751 

20 de setembro de 1983 

David Slowinski 

216.091 

746093103…815.528.447 

65.050 

6 de setembro de 1985 

David Slowinski 

756.839 

174135906…544.677.887 

227.832 

19 de setembro de 1992 

 David Slowinskii e Paul Gage 

859.433 

129498125…500.142.591 

258.716 

10 de janeiro de 1994 

David Slowinski e Paul Gage 

34 

1.257.787 

412245773…089.366.527 

378.632 

3 de setembro de 1996 

David Slowinski e Paul Gage 

35 

1.398.269 

814717564…451.315.711 

420.921 

13 de novembro de 1996 

GIMPS / Joel Armengaud 

36 

2.976.221 

623340076…729.201.151 

895.932 

24 de agosto de 1997 

GIMPS / Gordon Spence 

37 

3.021.377 

127411683…024.694.271 

909.526 

27 de janeiro de 1998 

GIMPS / Roland Clarkson 

38 

6.972.593 

437075744…924.193.791 

2.098.960 

1 de junho de 1999 

GIMPS / Nayan Hajratwala 

39 

13.466.917 

924947738…256.259.071 

4.053.946 

14 de novembro de 2001 

GIMPS / Michael Cameron 

40 

20.996.011 

125976895…855.682.047 

6.320.430 

17 de novembro de 2003 

GIMPS / Michael Shafer 

41 

24.036.583 

299410429…733.969.407 

7.235.733 

15 de maio de 2004 

GIMPS / Josh Findley 

42* 

43* 

44* 

45* 

46* 

47* 

48* 

25.964.951 

122164630…577.077.247 

7.816.230 

18 de fevereiro de 2005 

GIMPS / Martin Nowak 

30.402.457 

315416475…652.943.871 

9.152.052 

15 de dezembro de 2005 

32.582.657 

124575026…053.967.871 

9.808.358 

4 de setembro de 2006 

GIMPS / Curtis Cooper 
 & Steven Boone 

GIMPS / Curtis Cooper  
& Steven Boone 

37.156.667 

202254406…308.220.927 

11.185.272 

6 de setembro de 2008 

GIMPS / Hans-Michael Elvenich 

42.643.801 

169873516…562.314.751 

12.837.064 

12 de abril de 2009 

GIMPS / Odd M. Strindmo 

43.112.609 

316470269…697.152.511 

12.978.189 

23 de agosto de 2008 

GIMPS / Edson Smith 

57.885.161 

581887266…724.285.951 

17.425.170 

25 de janeiro de 2013 

GIMPS / Curtis Cooper 

82 

 
 
 
 
Conclusão 

Esse  trabalho  teve  como  objetivo  o  estudo  de  alguns  métodos  de  Criptografia, 

vimos que existem vários métodos de criptografia: Criptografia Simétrica (que usa apenas 

uma  chave),  a  Criptografia  Assimétrica  (chaves-públicas  e  privadas)  e  a  Criptografia  via 

Curvas Elípticas.  

Criptografia  serve  para  vários  propósitos, 

tais  como  a  privacidade  nas 

comunicações, transferências bancárias, informações diplomáticas secretas etc.. 

Vimos  que  é  fácil  criptografar  uma  mensagem  via  RSA,  porém  é  muito  difícil  de 

decifrar,  visto  que  não  existem  computadores  rápidos  o  suficiente,  nem  algoritmos 

eficazes,  que  nos  permitam  fatorar  um  número  inteiro  muito  grande  que  não  tenha 

fatores relativamente pequenos. 

Na  verdade,  não  existe  nenhum  algoritmo  conhecido  capaz  de  fatorar  inteiros 

grandes  de  modo  realmente  eficiente,  não  se  sabe  nem  mesmo  se  é  possível  que  esse 

algoritmo exista. 

 É  preciso  estimular  o  aprendizado  por  vários  caminhos  acessíveis  e  construir 

sólidos alicerces para o ensino e a pesquisa.   

Se  o  processo  de  modernização  do  ensino  se  estende  aos  ramos  de  todas  as 

disciplinas e há um grande esforço no sentido de melhorar seus aprendizados, no ensino 

da Álgebra o rompimento com os moldes tradicionais precisa ser definitivo. Desejamos 

que o ensino da álgebra suceda de maneira dinâmica e que ganhe vida com o uso dos 

instrumentos digitais disponíveis e a partir disso use o método dedutivo. 

83 

 
 
 
 
 
 
 
 
 
 
 
BIBLIOGRAFIA 

[1] Ribenboim, P. Números primos-Velhos Mistérios e Novos Recordes, Coleção 
Matemética Universitária 1ª ed. Rio de Janeiro: IMPA, 2012; 

[2] Coutinho, S. C. Números inteiros e Criptografia RSA, Coleção Matemática e 
Aplicações, Rio de Janeiro, IMPA, 2013; 

[3] Jeffrey Hoffstein, Jill Pipher, J.H. Silverman. - An Introduction to Mathematical 
Cryptography 1ªEd, Springer, 2008 

[4] Singh,Simon, O livro dos códigos tradução de Jorge Calife.- 6ª Ed.- Rio de Janeiro: 
Record, 2007 

[5] Terada, Routo, Revista do professor de Matemática.- 12ª Ed 

[6] Pimentel, Elaine, Álgebra A- Aula 10- Raízes primitivas. 

 [7] Salomão, Rodrigo, Um passeio pelo mundo secreto das curvas elípticas- Aulas 1, 2 
e 3. 

[8] Plínio de Oliveira Santos, José, Introdução a Teoria dos Números  

84 

 
 
 
 
 
 
 
 
