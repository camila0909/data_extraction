Universidade Federal Rural de Pernambuco
Departamento de Matem´atica

Mestrado Proﬁssional em Matem´atica

A ´ALGEBRA DE MATRIZES E O
PROCESSAMENTO DE IMAGENS DIGITAIS

´Aulus Santos Correia de Melo

DISSERTAC¸ ˜AO DE MESTRADO

Recife
2015

Universidade Federal Rural de Pernambuco
Departamento de Matem´atica

´Aulus Santos Correia de Melo

A ´ALGEBRA DE MATRIZES E O PROCESSAMENTO DE
IMAGENS DIGITAIS

Trabalho apresentado ao Programa de Mestrado Proﬁssi-

onal em Matem´atica do Departamento de Matem´atica da

Universidade Federal Rural de Pernambuco como requisito

parcial para obten¸c˜ao do grau de Mestre em Matem´atica.

Orientador: Prof. Dr. Thiago Dias

Recife
2015

Dedico este trabalho aos professores que tive desde o en-

sino b´asico ao mestrado, pois devo a seus entusiasmo e

dedica¸c˜ao o fato de minha op¸c˜ao pela docˆencia e apri-

moramento proﬁssional ter sido t˜ao natural e repleta de

signiﬁcado.

AGRADECIMENTOS

Agrade¸co a minha esposa, Ellen, pelo companheirismo, compreens˜ao e apoio sem os
quais n˜ao seria poss´ıvel o ﬁm desta jornada. Agrade¸co a meus pais, Denisaldo e Helena,
bem como a minha tia e segunda m˜ae, Creuza, pela capacidade de serem um exemplo
constante em minha vida e agrade¸co ao meu ﬁlho, Pietro, por ser uma inﬁnd´avel fonte
de inspira¸c˜ao e alegria para os meus dias.

Ao meu orientador, Thiago Dias, principalmente pela paciˆencia e compreens˜ao dos
problemas enfrentados para a conclus˜ao deste trabalho, bem como pelas sugest˜oes e
corre¸c˜oes oportunas e enriquecedoras.

A Deus, por permitir a ocorrˆencia dos eventos que vieram a me fazer grato neste

momento.

iv

RESUMO

Neste trabalho faremos um estudo sobre a rela¸c˜ao entre a ´algebra de matrizes e o
processamento de imagens digitais com o intuito de fornecer um material de referˆencia ao
professor do ensino m´edio que se proponha a trabalhar tal tema em suas aulas. O trabalho
apresenta-se em duas etapas: a primeira estabelece a rela¸c˜ao entre matrizes e imagens
digitais, introduz o software matem´atico GNU Octave e em seguida apresentamos uma
s´erie de aplica¸c˜oes deste na edi¸c˜ao de imagens digitais. Na segunda etapa, discutiremos
sobre a compress˜ao de imagens e faremos uma exposi¸c˜ao rigorosa da teoria por tr´as de
tal tema.

Palavras-chave:
posi¸c˜ao em Valores Singulares, norma de Frobenius, Compress˜ao de Imagens Digitais.

Imagens Digitais, GNU Octave, Processamento de Imagens, Decom-

v

ABSTRACT

In this work we do a study on the relationship between algebra and matrix processing
digital images in order to provide references to high school teachers to work this theme
in their classes. The work is presented in two stages: the ﬁrst stablishes the relationship
between arrays and digital images, introduces the mathematical GNU Octave software
and then present a series of applications of this in editing digital images. In the second
stage, we discuss about the image compression and do a thorough exposition of the theory
behind such theme.

Keywords: Digital Images, GNU Octave, Image Processing, Singular Value Decompo-
sition, Frobenius Norm, Digital Image Compression.

vi

SUM´ARIO

Cap´ıtulo 1—Introdu¸c˜ao

Cap´ıtulo 2—Imagens digitais

2.1 Sistemas de cores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sistema RGB . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sistemas CMY e CMYK . . . . . . . . . . . . . . . . . . . . . . .
Sistema HSV . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .

2.2 Formato de Arquivos de Imagens

2.1.1
2.1.2
2.1.3

Cap´ıtulo 3—O GNU Octave

3.1 Gerenciamento do Ambiente . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Matrizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . .
3.3 Fun¸c˜oes, scripts e estruturas de controle

Cap´ıtulo 4—A ´Algebra de matrizes e a edi¸c˜ao de imagens

4.1 Ferramentas de manipula¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Edi¸c˜ao de imagens em escala de cinza . . . . . . . . . . . . . . . . . . . .
4.2.1 Ajuste do brilho . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 Negativo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.3 Ajuste do contraste . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.4 Reﬂex˜oes e rota¸c˜oes . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.5 Binariza¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.6 Transi¸c˜ao de imagens . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.7 Marca d’´agua . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Edi¸c˜ao de imagens coloridas . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.1 Coloriza¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.2 Decomposi¸c˜ao RGB e CMY . . . . . . . . . . . . . . . . . . . . .
4.3.3 Posteriza¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Cap´ıtulo 5—Bases matem´aticas para a compress˜ao de imagens digitais

5.1 Decomposi¸c˜ao em Valores singulares
. . . . . . . . . . . . . . . . . . . .
5.2 Normas e SVD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . .
5.3 Distancia m´ınima entre matrizes de postos diferentes

vii

1

3

5
5
6
7
8

10

11
13
19

24

24
24
25
26
26
27
28
30
31
32
33
34
34

36

36
43
45

SUM ´ARIO

Cap´ıtulo 6—A SVD e a compress˜ao de imagens digitais

viii

49

CAP´ITULO 1

INTRODUC¸ ˜AO

No ensino b´asico, o aprendizado de t´opicos da teoria de matrizes ainda encontra

muitas limita¸c˜oes, sobretudo de car´ater aplicacional e, portanto, motivacional.

Parece-nos um consenso entre todos os professores que o aprendizado de um determi-
nado tema torna-se mais eﬁcaz quando o aluno conhece sua aplicabilidade (pelo menos
aquelas que lhe s˜ao poss´ıveis acessar). Acreditamos que esta eﬁc´acia alcance seu ´apice
com o estudante que n˜ao apenas conhece tais aplica¸c˜oes, mas que ´e levado a adquirir
consciˆencia de como utiliz´a-la em sua pr´opria vida pessoal ou proﬁssional. A diferen¸ca
entre o aluno que conhece as aplica¸c˜oes de um tema e o que tem consciˆencia de seu uso
´e como a diferen¸ca entre algu´em que, a partir de um ponto em uma estrada, consegue
visualizar poss´ıveis rotas e algu´em que al´em de visualiz´a-las seja capaz de fazer proje¸c˜oes
sobre como ser´a sua ida em cada dire¸c˜ao. Esta segunda pessoa certamente estar´a mais
apta a decidir por qual caminho seguir´a, bem como o estudante, consciente de como a
matem´atica, ou qualquer outra disciplina, pode conduzi-lo a obten¸c˜ao de um saber con-
creto sobre o que o rodeia, ´e capaz de deﬁnir, com relativa clareza, quais s˜ao as ´areas que
mais lhe afei¸coam e quais seriam vi´aveis a seu investimento pessoal.

As aplica¸c˜oes da matem´atica constituem um dos mais importantes meios de aliar o
ensino desta disciplina aos projetos pessoais e proﬁssionais do estudante, pois s˜ao capazes
de apresent´a-lo nuances da presen¸ca da matem´atica em diversas proﬁss˜oes e campos de
conhecimento, ou simplesmente s˜ao capazes de fascin´a-lo, mantendo-o motivado, em todo
caso.

H´a muito, as matrizes se desenla¸caram dos sistemas de equa¸c˜oes lineares, sobre os
quais se originaram, e se tornaram imensamente aplicadas dentro e fora da matem´atica.
Para um r´apido convencimento, basta apontarmos que elas s˜ao fundamentais para o
desenvolvimento da ´algebra linear e da estat´ıstica, campos de indiscut´ıvel importˆancia
em diversos seguimentos da ciˆencia em geral. Em raz˜ao de sua relevˆancia, o estudo das
matrizes ´e um componente obrigat´orio no curr´ıculo do ensino m´edio e, felizmente, sua
abordagem nos livros did´aticos atuais ´e repleta de aplica¸c˜oes.

Entretanto, defendemos que a exposi¸c˜ao de aplica¸c˜oes por si s´o s˜ao insuﬁcientes para
provocar uma aprendizagem satisfat´oria em uma parcela signiﬁcativa dos alunos, visto
que as aplica¸c˜oes, quando n˜ao efetivadas, podem parecer como coisas demasiadamente
distantes, que s´o poder˜ao ser melhor exploradas no futuro, e assim n˜ao careceriam de um
grande investimento do estudante em sua compreens˜ao, falhando, desta forma, na tarefa
de mantˆe-lo estimulado. Em um cen´ario como este, pode-se dizer, no m´aximo, que o
aluno conheceu as aplica¸c˜oes.

Consideramos o estudo de uma aplica¸c˜ao efetiva em sala de aula, quando o discente
al´em de compreender seu funcionamento ´e capaz de produzir ideias a seu respeito e assim
tornar-se capaz de propor e resolver problemas associados.

1

INTRODUC¸ ˜AO

2

O ensino, pela condu¸c˜ao efetiva de aplica¸c˜oes em sala de aula, das no¸c˜oes iniciais da
teoria das matrizes, no entanto, encontra um dif´ıcil obst´aculo, para o professor e para o
aluno, na complexidade de tais aplica¸c˜oes.

A proposta do presente trabalho ´e reunir material suﬁciente para subsidiar uma
condu¸c˜ao efetiva do uso da ´algebra de matrizes em computa¸c˜ao gr´aﬁca, atrav´es do soft-
ware matem´atico GNU octave. Faremos ainda a exposi¸c˜ao das bases matem´aticas para o
uso da Decomposi¸c˜ao em Valores Singulares na compress˜ao de imagens digitais, a qual,
embora de car´ater t´ecnico, muitas ideias relacionadas s˜ao acess´ıveis ao aluno do ensino
m´edio, e a obten¸c˜ao de resultados atrav´es do octave ´e muito simples.

Faremos, no primeiro cap´ıtulo, uma descri¸c˜ao dos conceitos de imagem digital, espa¸cos
de cor e comentaremos sobre os principais formatos das imagens digitais. No segundo
apresentaremos os princ´ıpios b´asicos do GNU octave. No cap´ıtulo subsequente ser´a feita a
aplica¸c˜ao da ´algebra elementar das matrizes junto as ideias desenvolvidas no cap´ıtulo 1 na
edi¸c˜ao de imagens digitais. No quarto cap´ıtulo teremos o desenvolvimento alg´ebrico que
leva a demonstra¸c˜ao do teorema da decomposi¸c˜ao em valores singulares e mostraremos
porque tal decomposi¸c˜ao fornece bons resultados no processo de redu¸c˜ao de dados de uma
matriz. No ´ultimo cap´ıtulo, discutiremos a aplica¸c˜ao das ideias desenvolvidas no cap´ıtulo
3 na compress˜ao de imagens digitais.

CAP´ITULO 2

IMAGENS DIGITAIS

As imagens digitais surgem como um produto dos esfor¸cos da ciˆencia da computa¸c˜ao
em duas frentes: a codiﬁca¸c˜ao dos sinais relevantes para a constitui¸c˜ao de uma imagem e a
reconstru¸c˜ao desta a partir dos dados codiﬁcados. Suas aplica¸c˜oes v˜ao muito al´em do uso
em computa¸c˜ao gr´aﬁca, alcan¸cando a geologia, a medicina, a astronomia, a engenharia,
entre outras.

Uma imagem ´e o resultado da intera¸c˜ao da luz com um conjunto de receptores ´oticos,
estes capazes de perceber a intensidade da luz e a varia¸c˜ao de cores. A percep¸c˜ao de
diferentes cores em uma imagem corresponde a maneira como c´erebro distingue diferentes
faixas do espectro eletromagn´etico (ﬁgura 2.1). N˜ao h´a d´uvida que a sensa¸c˜ao de cor ´e
fundamental na constitui¸c˜ao da ideia de imagem, de tal modo que, para se descrever
minunciosamente uma imagem, basta indicar a cor presente em cada ponto desta.

Figura 2.1 Espectro vis´ıvel

Fonte: Wikip´edia1

Sendo assim, ´e poss´ıvel fornecer um modelo matem´atico para descrever uma imagem.
Considerando que toda imagem possa ser representada nos limites de um retˆangulo,
podemos identiﬁc´a-la por uma fun¸c˜ao I que associa cada ponto (x, y) do retˆangulo R ⊂ R2
a uma cor I(x, y) correspondente ao efeito da atua¸c˜ao da luz naquele ponto.

Em computa¸c˜ao gr´aﬁca, ocorre a discretiza¸c˜ao do retˆangulo R do dom´ınio de I, pro-
cesso em que h´a uma quebra da imagem em um conjunto ﬁnito de elementos, cada um
associado a uma cor em um sistema de cores C. Cada elemento de I ´e chamado de pixel
(do inglˆes picture element) e uma imagem digital ﬁca deﬁnida por I atrav´es da fun¸c˜ao

I : Nm × Nn → C;

(2.1)

onde Ni = {1, 2, . . . , i}.

As cores de C s˜ao obtidas de um sistema de cor padr˜ao, o qual descreve matemati-
camente todas as cores vis´ıveis e baseia-se no fato do olho humano possuir trˆes tipos de

1Dispon´ıvel em <https://pt.wikipedia.org/wiki/Espectro vis´ıvel> Acesso em out 2015

3

IMAGENS DIGITAIS

4

receptores de cores: receptores para a cor vermelha (Red ), para a verde (Green) e para
a azul (Blue). As demais cores s˜ao formadas atrav´es das combina¸c˜oes dessas trˆes em di-
ferentes intensidades. A intensidade de cada cor pode ser dada por uma escala num´erica
em que o 0 representa a ausˆencia daquele componente e o 1 representa o componente
em sua intensidade m´axima. Podemos ainda, considerar imagens a partir da intensidade
da luz, ou luminosidade, emitida ou reﬂetida em cada ponto de R, atribuindo valores
de 0, para a ausˆencia de luz (preto), at´e 1, para a luminosidade m´axima (branco). Tal
imagem formada por um ´unico componente ´e dita em escala de cinza enquanto as que
possuem trˆes componentes s˜ao as coloridas. Decorre destas considera¸c˜oes que uma ima-
gem em escala de cinza pode ser representada por uma matriz, a qual, em computa¸c˜ao
gr´aﬁca, tem suas entradas discretizadas em elementos do conjunto N255, enquanto uma
imagem colorida ´e dada por trˆes matrizes como esta, cada uma correspondente a uma
das componentes R, G e B.

O conjunto C, no entanto, n˜ao ´e composto por toda as cores do espectro vis´ıvel.
Al´em de ser uma discretiza¸c˜ao do sistema de cores padr˜ao, Ele ´e constru´ıdo conforme as
limita¸c˜oes dos dispositivos de reprodu¸c˜ao de imagem (monitores, impressoras, etc) e do o
uso que se queira fazer da imagem. Um documento de texto, por exemplo, ´e uma imagem
digital cujas cores utilizadas s˜ao o branco (fundo) e o preto (letras), j´a uma anima¸c˜ao em
.gif possui no m´aximo 256 cores em cada frame (imagem de cada quadro da anima¸c˜ao).
A escolha de cores para compor o conjunto C determina algumas caracter´ısticas de
I. O n´umero de bits nescess´arios para representar uma cor em C deﬁne a dimens˜ao ou
profundidade do pixel. O modo da imagem classiﬁca-a segundo sua profundidade de cor
e conjunto de cores utilizados. Os principais modos da imagem s˜ao:

– bitmap: Imagem de um bit que assume os valores preto (0) ou branco (1);

– meio tom ou escala de cinza: Imagem de oito bits em que varia do preto (0) ao
branco (255) passando por diversos tons de cinza, totalizando 256 cores utilizadas.

– RGB : Imagem colorida que, Dependendo do formato, possui de 24 a 32 bits.

– imagem indexada:: 8 bits, colorida. Aqui podem ser estipuladas at´e 256 cores em

um sistema de cor para representar uma imagem.

Exemplo 2.0.1.

(a)

(b)

(c)

(d)

(e)

(f)

Figura 2.2

Na ﬁgura 2.2 temos uma mesma imagem exibida respectivamente em cada modo
descrito acima. A ﬁgura 2.2(a) est´a no modo bitmap, a 2.2(b) est´a em escala de cinza,

2.1 SISTEMAS DE CORES

5

a 2.2(c) colorida e na 2.2(d) indexada. Na ﬁgura 2.2(e) temos o chamado mapa de cores
da imagem indexada 2.2(d) e cont´em todas as cores presentes nela.

Abaixo, exibimos as intensidades da regi˜ao destacada na imagem 2.2(f):







R =

37 38
34 34
33 33
26 11
0

36
33
33
0
55 111 134 125

38
34
33
0

37
34
32
0







G =







124
118
113
108
96

125
118
113
105
99

125
118
113
101
106

125
118
112
97
120







124
117
113
93
128

B =







195
190
186
184
191

196
190
186
193
148

196
191
186
201
110

196
190
185
200
107







195
189
186
196
119

Ser˜ao trabalhados aqui, principalmente, imagens no modo RGB e em escala de cinza.

2.1 SISTEMAS DE CORES

Matematicamente, uma cor ´e dada por coordenadas do espa¸co de cores, deﬁnidas por
um sistema padr˜ao de cor. Diferentes sistemas de cores s˜ao obtidos tomando subconjuntos
do sistema padr˜ao e exibindo as cores destes por algum crit´erio distinto, ou seja, utilizando
bases diferentes para o subespa¸co. Discutiremos adiante a respeito de quatro sistemas de
cor, escolhidos pela sua abrangˆencia ou relevˆancia para este texto.

2.1.1 Sistema RGB

O sistema de cor RGB baseia-se no sistema padr˜ao e ´e muito usado em monitores
e sistemas operacionais. Nele, como j´a foi dito, cada cor ´e dada por trˆes coordenadas
correspondentes a intensidade da luz vermelha, da verde e da azul, as quais combinadas
geram a cor ﬁsicamente. Na ﬁgura 2.3, temos uma foto acompanhada de imagens que
correspondem a intensidade da luz nos canais RGB. As regi˜oes mais escuras indicam as
regi˜oes em que a matriz associada possui valores pr´oximos de 0. Na imagem vermelha
vemos que o rosto e ombros da modelo s˜ao dados em um tom intenso e praticamente
uniforme, o que revela uma grande participa¸c˜ao desta cor nas regi˜oes referidas. A com-
ponente verde ´e percebida com mais intensidade pelo olho humano, isto porque o verde

Figura 2.3 imagem original e decomposta em suas trˆes componentes RGB

2.1 SISTEMAS DE CORES

6

Figura 2.4 Diagramas de forma¸c˜ao de cores

(a) Forma¸c˜ao de cores no CMY

(b) Forma¸c˜ao de cores no RGB

Fonte: Wikipedia2

´e respons´avel pela maior parte da luminˆancia de uma imagem, o azul, por sua vez, exibe
pouca luminˆancia.

2.1.2 Sistemas CMY e CMYK

Em compara¸c˜ao com o RGB, o sistema de cores CMY abandona o paradigma da per-
cep¸c˜ao da cor enquanto luz e adota o da cor enquanto pigmento. Enquanto no sistema
RGB temos as cores formadas a partir da combina¸c˜ao luminosa de diferentes faixas do
espectro eletromagn´etico, no CMY as cores s˜ao obtidas pela subtra¸c˜ao destas em uma
superf´ıcie. Se, por exemplo, percebemos a cor azul ao observar um objeto, isto signiﬁca
que a superf´ıcie daquele objeto absorve as componentes vermelha e verde da luz e reﬂete
apenas a azul. As coordenadas do CMY correspondem as cores ciano (Cian), magenta
(Magenta) e amarelo (Yellow ) cujos pigmentos absorvem, respectivamente, as cores ver-
melha, verde e azul. No sistema RGB, o aumento do valor das coordenadas corresponde
a um aumento de luminˆancia na cor, no CMY um tal aumento corresponde a perda de
luminˆancia, fazendo que, ao contr´ario do RGB, o CMY parta do branco (0, 0, 0) ao preto
(255, 255, 255), conforme indicado na ﬁgura 2.4.

Assim, para obtermos o azul que no RGB ´e dado por (0, 0, 100) basta tomarmos em
coordenadas do CMY a cor (255, 255, 155) que corresponde a uma cor que, submetida
a uma ilumina¸c˜ao, absorve as cores vermelha e verde, e tamb´em 155 n´ıveis da cor azul,
reﬂetindo, portanto, 100 n´ıveis.

Dada uma cor (r, g, b) em coordenadas RGB, sua representa¸c˜ao (c, m, y) em CMY, ´e

obtida atrav´es da transforma¸c˜ao

(c, m, y) = (255, 255, 255) − (r, g, b)

e vemos um exemplo da forma¸c˜ao de uma imagem mediante a decomposi¸c˜ao CMY na
ﬁgura 2.5(c)

2Dispon´ıvel em <https://pt.wikipedia.org/wiki/RGB> Acesso em out 2015

2.1 SISTEMAS DE CORES

7

(c) imagem original e decomposta em suas trˆes componentes CMY

(d) decomposi¸c˜ao em componentes CMYK

Figura 2.5

O sistema CMYK utilizado em impressoras foi instituido por raz˜oes econˆomicas (A
tinta preta correspondente a componente K ´e mais barata), e uma cor (c(cid:48), m(cid:48), y(cid:48), k) em
CMYK ´e obtida de (c, m, k) em CMY mediante as opera¸c˜oes

k = min{c, m, y}
c(cid:48) = c − k
m(cid:48) = m − k
y(cid:48) = y − k.

A ﬁgura 2.5(d) fornece um exemplo de decomposi¸c˜ao em CMKY.

2.1.3 Sistema HSV

O sistema HSV procura representar cores a partir do sistema RGB seguindo uma
compreens˜ao intuitiva do que elas s˜ao. Para tanto, estabelece coordenadas que descre-
vam o conceito de matiz ou tonalidade (Hue), que ´e a cor propriamente dita, satura¸c˜ao
(Saturation), que indica o quanto a cor encontra-se diluida no branco ou pr´oxima dele, e
valor ou brilho (Value), que estabelece a rela¸c˜ao claro/escuro entre as cores. Este sistema
´e muito utilizado por artistas e designers.

A ﬁgura 2.6, diferente do que foi feito nos sistemas anteriores, em que cada imagem-
componente era constituida unicamente das informa¸c˜oes contidas em um grupo de coor-
denadas, tem em cada uma das trˆes ´ultimas imagens atribui¸c˜oes para os valores das trˆes
coordenadas do HSV. A nescessidade de tal atribui¸c˜ao se deve ao fato de que no sistema
HSV uma cor n˜ao pode ser obtida sem o estabelecimento das trˆes coordenadas. Na ﬁgura

2.2 FORMATO DE ARQUIVOS DE IMAGENS

8

(a)

(b)

(c)

(d)

Figura 2.6 Imagem original e representa¸c˜oes de suas componentes HSV

2.6(b) foi obtida mantendo o matiz da imagem original e atribuindo o valor nulo a sa-
tura¸c˜ao e o valor m´aximo ao brilho, assim podemos visualizar como ocorre a distribui¸c˜ao
de cores na imagem. J´a em 2.6(c), observamos o que acontece com as cores em 2.6(b)
quando diluidas no branco, tal imagem ´e feita com os valores da matiz e da satura¸c˜ao da
imagem 2.6(a), no entanto, mantivemos o brilho no m´aximo. Por ﬁm, a imagem 2.6(d)
foi feita a partir dos valores originais da matiz e do brilho, com a satura¸c˜ao dada em
seus valores m´ınimos. Esta ´ultima imagem cont´em as informa¸c˜oes de luminˆancia da foto,
enquanto a 2.6(c) cont´em as informa¸c˜oes de crominˆancia e juntas ela formam a imagem
original 2.6(a). Na ﬁgura 2.7 vemos a aplica¸c˜ao desta mesma t´ecnica de representa¸c˜ao
em uma imagem diferente.

2.2 FORMATO DE ARQUIVOS DE IMAGENS

Na maioria das aplica¸c˜oes em computa¸c˜ao gr´aﬁca, exibir uma imagem n˜ao ´e o bas-
tante. ´E imprescindivel o desenvolvimento de m´etodos para arquivar os dados que des-
crevem a imagem, de modo que possa haver o tr´afego de tais dados e a reconstru¸c˜ao da
imagem a partir deles. Para facilitar o tr´afego e armazenamento de imagens criou-se o
os m´etodos de compress˜ao, que consistem em t´ecnicas de processamento de dados que
procuram reduzir o uso da mem´oria do computador em seu armazenamento. Um formato
de arquivo de imagem re´une um conjunto de normas de compress˜ao e codiﬁca¸c˜ao de da-
dos de uma imagem, de maneira a permitir sua correta interpreta¸c˜ao pelo computador.
Dentre os in´umeros formatos existentes, destacamos quatro deles em fun¸c˜ao de seu amplo
uso e sua importˆancia na breve hist´oria do computador.

BMP: Windows Bitmap. O formato de imagem padr˜ao dos antigos sistemas operacionais
da microsoft foi um dos primeiros formatos criados e tem seu uso reduzido a cada
dia. Embora o formato BMP seja capaz de salvar imagens de alta qualidade, o custo
computacional para isto ´e muito alto, visto que este formato n˜ao faz compress˜ao,
nem suporta a existˆencia de transparˆencia na imagem.

GIF: Graphics Interchange Format. Desenvolvido principalmente para o uso na internet,
suporta imagens com no m´aximo 256 cores, dentre as quais uma pode ser tomada
como transparente, ´e capaz de fazer compress˜ao sem perda da informa¸c˜ao e su-
porta anima¸c˜oes. Exceto pelo seu popular uso em anima¸c˜oes na internet, tamb´em

2.2 FORMATO DE ARQUIVOS DE IMAGENS

9

Figura 2.7

encontra-se caindo em desuso, principalmente pela sua limita¸c˜ao no uso de cores o
que faz os usu´arios de imagens digitais optarem por um formato mais robusto como
o JPEG ou o PNG.

JPEG: Joint Photographics Expert Group. Formato de imagem conhecido pela sua alta
capacidade de compress˜ao, valendo-se da redu¸c˜ao na redundˆancia interpixel e psico-
visual da imagem. A compress˜ao no formato JPEG ´e feita com perda da informa¸c˜ao
e baseia-se na leitura da matriz de dados pelo seu posto, o que, como veremos adi-
ante, permite uma escrita simpliﬁcada de tal matriz, e da´ı, a compress˜ao da imagem.
O formato JPEG ainda leva em considera¸c˜ao a maior sensibilidade do olho humano
na percep¸c˜ao do brilho de uma imagem, priorizando esta caracter´ıstica no momento
da compress˜ao. Suporta imagens de at´e 24 bits, sem transparˆencia e sem anima¸c˜oes.
´E suportado por quase todo dispositivo gr´aﬁco moderno, desde cˆameras digitais a
softwares de edi¸c˜ao de imagens, ´e indicado para fotograﬁas e desaconselhado para
edi¸c˜ao de imagens, visto que este formato comprime a imagem a cada salvamento
fazendo com que ela perca bastante qualidade com essa pr´atica.

PNG: Portable Network Graphics. Formato relativamente recente na computa¸c˜ao gr´aﬁca,
veio com o objetivo de suprir as limita¸c˜oes existentes no uso do GIF. Apresenta uma
compress˜ao sem perdas e suporta cores de at´e 32 bits, sendo 24 bits destinados a re-
presenta¸c˜ao das cores RGB e 8 bits voltados para constru¸c˜ao de transparˆencias em
256 n´ıveis, indo do opaco (0, 0, 0) ao completamente transparente (255, 255, 255).

CAP´ITULO 3

O GNU OCTAVE

O GNU octave, ou octave, ´e uma linguagem interativa de alto n´ıvel para computa¸c˜ao
num´erica. Por ele ´e poss´ıvel operar com matrizes, com fun¸c˜oes, plotar gr´aﬁcos em duas
e trˆes dimens˜oes, desenvolver algoritmos para resolu¸c˜ao dos mais variados problemas,
processar imagens digitais, dentre outras aplica¸c˜oes. ´E seguro aﬁrmar que a extens˜ao do
uso do octave ´e limitada apenas pela criatividade e dom´ınio matem´atico-computacional
do usu´ario.

O octave encontra-se dispon´ıvel para os sistemas operacionais Windows, Linux e Ma-
cOS, ´e um software livre e de c´odigo aberto, isto signiﬁca que pode ser livremente dis-
tribuido e modiﬁcado segundo os termos da GNU, a General Public License (GPL). As
vers˜oes para Windows e MacOS podem ser encontradas na p´agina da sourceforge1; neste
trabalho, utilizamos a vers˜ao 3.8.1 dispon´ıvel para o Linux Ubuntu atrav´es da central de
programas do Ubuntu.

Embora hajam algumas interfaces gr´aﬁcas dispon´ıveis para o octave, todos os pro-
cessos do software s˜ao executados por linha de comando, em que o usu´ario digita uma
instru¸c˜ao e tecla enter, e o octave fornece o resultado esperado, ou emite uma mensagem
de erro caso o comando seja inv´alido. Tal maneira de conduzir a produ¸c˜ao de resultados
´e pouco intuitiva a quem n˜ao possui intimidade com programa¸c˜ao, pois exige do usu´ario
o conhecimento pr´evio dos comandos na realiza¸c˜ao de alguma tarefa, o que torna seu uso
pouco convidativo. No entanto, esta caracter´ıstica ´e imensamente compensada pela vasta
possibilidade aplicacional do octave, fato que deve ser explorado em situa¸c˜oes did´aticas.
Neste trabalho, faremos a exposi¸c˜ao dos principais comandos e daqueles particularmente
´uteis para nossa abordagem atrav´es da seguinte nota¸c˜ao:

Exemplo 3.0.1. : Comando (T´ıtulo)

Breve descri¸c˜ao dos efeitos do comando.
>Entrada par^ametro #(quando houver)
Sa´ıda

Sugerimos ao leitor que a partir daqui leia o texto em curso com o octave aberto, para
uma melhor experiˆencia e compreens˜ao de suas ferramentas. Nos pr´oximos exemplos,
enfatizaremos os argumentos de entrada para distingui-los do comando propriamente
dito. O octave ignorar´a tudo que vier depois dos caracteres # e %, bem como o que estiver
entre chaves. Este recurso ´e usado para inserir coment´arios no espa¸co de trabalho no
octave. ´E poss´ıvel inserir mais de uma instru¸c˜ao no prompt, bastando separ´a-las por
v´ırgula.

1No site <http://octave.sourceforge.net/>

10

3.1 GERENCIAMENTO DO AMBIENTE

11

Exemplo 3.0.2. : comando, comando (V´ırgula)

√
Atribuindo o valor 81 para a vari´avel x e, em seguida, fazendo 4
>x=81, nthroot(x,4)
x = 81
ans = 3

x.

Exemplo 3.0.3. : comando; comando (Ponto e v´ırgula)

Omitindo a visualiza¸c˜ao de um resultado pelo uso de ponto e v´ırgula.
>x=81; nthroot(x,4)
ans = 3
>x=81, nthroot(x,4);
x = 81

Nos ´ultimos exemplos notamos a apari¸c˜ao do ans (do inglˆes answer ), vari´avel que
armazena o ´ultimo resultado obtido pelo octave. Outras vari´aveis especiais s˜ao o pi
, n´umero real π ∼= 3, 1416, o i e o j, ambos representando a unidade imagin´aria dos
n´umeros complexos, o inf (inﬁnite), resultado de divis˜oes do tipo 1/0 e o NaN (Not a
Number ) que ´e exibido como resultado de 0/0.

Outro fato importante para atentar ´e a utiliza¸c˜ao do sinal de igualdade que aqui ´e um
sinal de atribui¸c˜ao. Se, por exemplo, escrevemos x=7, X=(17-3)/2 estaremos atribuindo
valor 7 ao x, e o valor resultante de (17 − 3)/2 ao X (o octave diferencia mai´usculas de
min´usculas). Caso se queira testar a igualdade entre as vari´aveis x e X deve-se digitar
x==X.

3.1 GERENCIAMENTO DO AMBIENTE

Os comandos apresentados a seguir tem a fun¸c˜ao de gerenciar pastas e arquivos uti-
lizados pelo octave, bem como gerenciar o pr´oprio ambiente do octave, suas vari´aveis,
tipos de vari´aveis etc.

Exemplo 3.1.1. : pwd

Indica o diret´orio de trabalho corrente do octave.
>pwd
ans = /home/pasta pessoal

A pasta setada pela instru¸c˜ao pwd ´e onde ﬁcam todos os arquivos salvos pelo octave,
´e nela, tamb´em, onde deve constar os arquivos a serem editados no software (imagens,
fun¸c˜oes, etc).

Exemplo 3.1.2. : mkdir e cd

Criando um novo diret´orio (mkdir) com o nome ’octave’, e em seguida, mudando o di-
ret´orio de trabalho corrente (cd).

3.1 GERENCIAMENTO DO AMBIENTE

12

>mkdir octave
ans = 1
>cd octave, pwd
ans = /home/pasta pessoal/octave

Exemplo 3.1.3. : who e whos

x

Lista as vari´aveis utilizadas (who) e detalha-as (whos).
>who, whos
Variables in the current scope:
ans
Variables in the current scope:
Bytes
=====
26
1

Attr Name Size
==== ==== ====
ans 1x26
1x1

Class
=====
char
double

x

Na coluna denominada Class o octave indica o tipo de vari´avel naquela linha. Dentre
os muitos tipos de vari´aveis, destacaremos o double e o uint8, que, respectivamente,
representam n´umeros reais e n´umeros inteiros entre 0 e 255, associados `a imagens digitais.

Exemplo 3.1.4. : clear vari´avel e clear all

Limpa uma vari´avel especiﬁcada (clear) ou todas (clear all).
>x=-3, y=pi, x+y
x = -3
y = 3.1416
ans = 0.1416
>clear x, who
Variables in the current scope:
y>clear all, who
ans

Os comando clear e clear all removem as atribui¸c˜oes das vari´aveis da mem´oria do

octave. Caso se queira limpar a tela, o comando a ser usado ´e o clc.

Exemplo 3.1.5. : help comando

Descreve uma fun¸c˜ao, em inglˆes, segundo a documenta¸c˜ao constante no octave..

3.2 MATRIZES

13

>help pwd
’pwd’ is a built-in function from the file libinterp/corefcn/dirfns.cc
-- Built-in Function: pwd ()
-- Built-in Function: DIR = pwd ()
Return the current working directory.
cd, dir, ls, mkdir, rmdir.
See also:
Additional help for built-in functions and operators is available in the
online version of the manual. Use the command ’doc <topic>’ to search
the manual index.
Help and information about Octave is also available on the WWW at
http://www.octave.org and via the help@octave.org mailing list

Exemplo 3.1.6. : lookfor voc´abulo

Lista todas as ocorrˆencias no help de um conjunto de caracteres..
>lookfor root
matlabroot
roots
polynomial
nthroot
realsqrt
hypot
cbrt
sqrt
sqrtm
is rooted relative filename
make absolute filename
rlocus

O lookfor exibe como resultado todos os comandos que possuem a palavra no
parˆametro. Os comandos help e lookfor s˜ao os mais importantes para um usu´ario
iniciante do octave. Usados em conjunto, permitem que o usu´ario saiba quais comandos
cont´em a informa¸c˜ao que ele deseja, qual a sintaxe de cada um e quais s˜ao os comandos
relacionados.

3.2 MATRIZES

√

Para efetuar opera¸c˜oes simples, o octave funciona como uma calculadora. Por exem-
32 − 8 basta inserir, como j´a foi visto, o comando
plo, para encontrar o resultado de 7 ·
7*sqrt(3^2-8). Um grande diferencial aqui ´e a possibilidade de operar com matrizes,
mesmo as de dimens˜oes enormes, como ´e o caso das matrizes associadas a uma imagem
digital. O octave trabalha ainda com as opera¸c˜oes termo a termo entre matrizes, que
s˜ao inseridas digitando um ponto antes da opera¸c˜ao indicada. Por exemplo, se A = [aij]
e B = [bij] s˜ao matrizes m × n, a express˜ao A.*B retorna uma matriz C = [cij] tal que

3.2 MATRIZES

14

cij = aij · bij. Se k ´e um escalar, ´e poss´ıvel realizar uma opera¸c˜ao termo a termo entre k
e A fazendo C=A.^k, o retorno de tal express˜ao ´e cij = ak
ij.

Exemplo 3.2.1. : [var1 ,var2 ] e [var1 ;var2 ] (Vetor linha e vetor coluna)

Deﬁnindo vetores.
>v=[3,4,5], u=[6;4;2]

v =

u =

3 4 5

6
4
2

Exemplo 3.2.2. : [var1 , var2 ; var3 , var4 ] (Matrizes)

Deﬁnindo matrizes.
>A=[1,2,3;4,5,6], B=[-1,3;-7,-2]

A =

B =

1
4

2 3
5 6

3
-1
-7 -2

Ao deﬁnir matrizes retangulares declaramos primeiramente as entradas da primeira li-
nha, separando-as por espa¸co ou v´ırgula, e em seguida declaramos as entradas da segunda
linha, separando estas daquelas na primeira linha com ponto e v´ırgula.

Exemplo 3.2.3. : var (´ındice), var (linha, coluna) (Referˆencia)

Referenciando entradas dos vetores u e v e das matrizes A e B.
>v(2), u(3)
ans = 4
ans = 2
>A(2,3), B(4), A(5)
ans = 6
ans = -2
ans = 3

Dada A = [aij], o elemento da i-´esima linha e j-´esima coluna ´e referido no octave como
A(i,j). O comando A(n) toma o n-´esimo elemento elemento da matriz, considerando-a
ordenada de cima para baixo, da esquerda para a direita. Note a diferen¸ca nesta indexa¸c˜ao
dos elementos com a ordem em que se declaram as entradas na deﬁni¸c˜ao de uma matriz,
que ´e da esquerda para a direita, de cima para baixo.

3.2 MATRIZES

15

Exemplo 3.2.4. : var1 :var2 :var3 (Sequˆencia aritm´etica)

Atrav´es da instru¸c˜ao in´ıcio:passo:limite, retorna uma matriz 1 × n cujas entradas
tem diferen¸ca constante dada por passo, come¸cam do n´umero in´ıcio e n˜ao excedem o
n´umero em limite. Caso o passo n˜ao seja declarado, o octave toma por padr˜ao passo=1.
>x=7:-2:-1, y=1:0.3:2.1, z=1:4

x =

y =

z =

7

5

3

1

-1

1.0000 1.3000 1.6000 1.9000

1

2

3

4

Exemplo 3.2.5. : var (linha,:) e var (:,coluna) (Referˆencia a linhas e colunas)

Deﬁnindo uma matriz C, e visualizando sua 2“coluna e 2“linha.
>C=[1:5;-8:-4;20:24;8:12;-2:2], C(:,2), C(2,:)

C =

ans =

3

1

2

4
-8 -7 -6 -5
20 21 22 23
9 10 11
1
0

-2 -1

8

5
-4
24
12
2

2
-7
21
9
-1

ans =

-8 -7 -6 -5 -4

Dada uma matriz A os comandos A(:,k) e A(k,:) exibem, respectivamente, a k-

´esima coluna e a k-´esima linha de A.

Exemplo 3.2.6. : var (var1 :var2 :var3 ; var4 :var5 :var6 ) (Referˆencia sequencial)

Retorna matrizes cujos elementos s˜ao obtidos da matriz C deﬁnida no exemplo 3.2.5.

16

3.2 MATRIZES

>C(3:5,2:4), C(1:2:5,1:3:5)

ans =

ans =

21 22 23
9 10 11
1
0

-1

1

4
20 23
1
-2

A instru¸c˜ao A(in´ıcio1:passo1:fim1,in´ıcio2:passo2:fim2), toma nas linhas entre
in´ıcio1 e fim1, cuja ordem entre as linhas dista passo1, as entradas das colunas entre
in´ıcio2 e fim2, distantes passo2 uma da outra.

Exemplo 3.2.7. : eye, ones, zeros e rand

Retorna matrizes pr´e-deﬁnidas com tamanho deﬁnido no parˆametro.
>eye(2,3), ones(2,3), zeros(2,3), rand(2,3)

ans =
Diagonal Matrix
1 0 0
0 1 0

ans =

1 1 1
1 1 1

0 0 0
0 0 0

ans =

ans =

0.092729 0.181822 0.510887
0.861345 0.487002 0.282149

O comando rand(m,n) Retorna uma matriz m × n de entradas randˆomicas entre 0
e 1. J´a as instru¸c˜oes zeros(m,n) e ones(m,n) retornam matrizes com entradas iguais
a 0 e 1 respectivamente. A instru¸c˜ao eye retorna a matriz identidade generalizada, que
´e uma matriz diagonal generalizada com suas entradas n˜ao-nulas iguais a 1. Nestes
quatro comandos, caso um ´unico escalar seja declarado no parˆametro, o octave retornar´a
uma matriz quadrada com o tamanho indicado, em outras palavras, eye(n) equivale a
eye(n,n).

Exemplo 3.2.8. : round, ceil, ﬂoor e ﬁx

Retornam inteiros segundo algum crit´erio.

3.2 MATRIZES

17

> M=[1.3,-2.9;-3.2,1.9], round(M), ceil(M), floor(M), fix(M)

M =

1.3000 -2.9000
1.9000

-3.2000

ans =

1 -3
2

-3
ans =

2 -2
2

-3
ans =

1 -3
1

-4
ans =

1 -2
1

-3

O comando round(M) retorna os inteiros mais pr´oximos de cada entrada de M. J´a o
comando ceil(M) retorna os maiores inteiros menores ou iguais a cada entrada de M e
floor(M) retorna os menores inteiros maiores ou iguais a cada entrada em M. fix(M)
retorna a parte inteira de cada entrada da matriz M.

Exemplo 3.2.9. : length e size

Retorna o n´umero de entradas de um vetor v e o n´umero de linhas×colunas de uma
matriz A.
>v=[2 1 3 4 5], A=[1:4;2:5;3:6], length(v), [m n]=size(A)

v =

A =

2 1 3 4 5

1 2 3 4
2 3 4 5
3 4 5 6

ans = 5
m = 3
n = 4

Caso o A seja uma matriz associada a uma imagem colorida, o octave a ler´a como
uma matriz 3 -d, o que signiﬁca que quando ﬁzermos size(A) encontraremos trˆes valores
de sa´ıda, ao inv´es de dois. O terceiro valor retorna uma matriz correspondente a alguma
componente RGB, por exemplo, as matrizes A(:,:,1), A(:,:,2) e A(:,:,3) correspon-
dem as matrizes associadas as componentes vermelha, verde e azul respectivamente.

Exemplo 3.2.10. : diag

3.2 MATRIZES

18

Retorna uma matriz diagonal a partir das entradas de v, caso o parˆametro seja uma
matriz, retorna a diagonal principal desta na forma de um vetor.
>diag(v), diag(A)

ans =
Diagonal Matrix

2 0 0 0 0
0 1 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5

ans =

1
3
5

Exemplo 3.2.11. : var1 =var2 \ va3 (Resolu¸c˜ao de sistemas)

Resolve o sistema de equa¸c˜oes lineares dado por Ax = b.
>A=[2,4,-1,6;-5:-2;2:-3:-7;0,0,0,-1], b=[4;5;6;7], x=A\ b
A =

2

4 -1
6
-5 -4 -3 -2
2 -1 -4 -7
0 -1
0

0

b =

x =

4
5
6
7

-12.450549
17.747253
0.087912
-7.000000

Exemplo 3.2.12. : eig

Retorna o vetor de autovalores da matriz A ou a matriz diagonal L de autovalores de A,
junto a uma matriz P que diagonaliza A.

3.3 FUNC¸ ˜OES, SCRIPTS E ESTRUTURAS DE CONTROLE

19

>A=[1,0,-1;1,1,1;-1,0,0], eig(A), [P L]=eig(A)

A =

ans =

P =

L =

1 0 -1
1
1 1
0
-1 0

1.00000
1.61803
-0.61803

0.75294
0.00000
1.00000
0.46534
0.00000 -0.46534

0.40045
-0.64794
0.64794

Diagonal Matrix

1.00000
0
0

0
1.61803

0
0

0 -0.61803

Por ﬁm, algums comandos para matrizes s˜ao auto explicativos, n˜ao necessitando de
exemplos portanto, eles s˜ao o det(A), que calcula o determinante da matriz A, o inv(A),
calcula a matriz inversa da matriz quadrada A, rank(A), calcula o posto de A, trace(A),
calcula o tra¸co, max, min, mean e median retornam, respectivamente, o m´aximo, o m´ınimo,
a m´edia aritm´etica e a mediana de um vetor. Caso o parˆametro de entrada destes quatro
´ultimos comandos seja uma matriz, o octave retornar´a um vetor cujas entradas ser˜ao o
resultado da opera¸c˜ao em quest˜ao aplicada a cada coluna da matriz. Se A ´e uma matriz,
A’ faz com que o octave retorne a transposta de A.

3.3 FUNC¸ ˜OES, SCRIPTS E ESTRUTURAS DE CONTROLE

O octave vem com uma s´erie de fun¸c˜oes pr´e-programadas, trigonom´etricas, hiperb´olicas,

logar´ıtmicas, exponenciais, entre outras, no entanto, ´e na possibilidade de criar novas
fun¸c˜oes que enxergamos o qu˜ao abrangente este software pode ser.

Uma fun¸c˜ao ´e criada atrav´es da instru¸c˜ao function e recebe como parˆametros de
entrada o nome da fun¸c˜ao, que torna-se o comando pelo qual o usu´ario pode recorrer
a fun¸c˜ao, as vari´aveis de entrada e as vari´aveis de sa´ıda. Em seguida, deve-se digitar o
comando, ou a cadeia de comandos, que deﬁnem a fun¸c˜ao. Esta instru¸c˜ao ´e encerrada
com a inclus˜ao de endfunction. No pr´oximo exemplo veremos como funciona o uso desta
instru¸c˜ao.

Exemplo 3.3.1. : Fun¸c˜ao valor cr´ıtico

Deﬁne o valor cr´ıtico de uma matriz Am×n .

3.3 FUNC¸ ˜OES, SCRIPTS E ESTRUTURAS DE CONTROLE

20

>function k=valor critico(A)
>[m n]=size(A);
>s=m+n+1;
>k=s-sqrt(s^2-4*m*n);
>endfunction
>#utiliza¸c~ao
>A=[2,3,4,5;1,2,3,4;6,5,4,3], y=valor critico(A)

A =

2 3 4 5
1 2 3 4
6 5 4 3

y = 4

Veremos no cap´ıtulo 5 que o valor cr´ıtico de uma matriz associada a uma imagem

estabelece um parˆametro de sucesso na compress˜ao desta.

´E poss´ıvel salvar uma fun¸c˜ao para um uso posterior, para isso, usamos o comando
save nome.m nome, onde nome representa o nome da fun¸c˜ao. Feito isto, o octave criar´a
um arquivo com a extens˜ao .m em seu diret´orio corrente, ao qual, atrav´es de um editor
de texto simples como o bloco de notas ou gedit, podemos inserir o c´odigo da fun¸c˜ao
com aquele nome e posteriormente acess´a-la como qualquer outra fun¸c˜ao pr´e-deﬁnida no
octave. O comando para utilizar a fun¸c˜ao salva passa a ser o pr´oprio nome da fun¸c˜ao.

Um script ´e uma cadeia de comandos salvos em um arquivo .m, difere de uma fun¸c˜ao
por n˜ao possuir argumentos de entrada ou sa´ıda, apenas comandos. O exemplo a seguir
cont´em um script que cria uma matriz retangular de tamanho aleat´orio entre 1 e 10, com
entradas inteiras randˆomicas compreendidas entre 0 e 100. Para executar tal script, basta
digitar “maleatoria” no prompt, nome do arquivo .m onde o script foi salvo.

Exemplo 3.3.2. : Script maleat´oria
Script que retorna uma matriz de tamanho entre 1 e 10 com entradas entre 0 e 100.
# Matriz Aleat´oria
m=round(9*rand)+1;
n=round(9*rand)+1;
A=round(100*rand(m,n))

Na instru¸c˜ao acima vemos o comando rand sendo usado sem parˆametros, isto faz com
que ele retorne um n´umero aleat´orio entre 0 e 1. O comando round(A) retorna, para
cada entrada da matriz A, o n´umero natural mais pr´oximo.

As estruturas de controle ocupam um lugar fundamental na utiliza¸c˜ao do octave. Por
meio destas estruturas ´e poss´ıvel condicionar a execu¸c˜ao de comandos ou o retorno de
resultados, tamb´em ´e poss´ıvel ordenar ao octave que continue a executar um comando
enquanto uma determinada condi¸c˜ao for satisfeita ou at´e uma determinada condi¸c˜ao ser
satisfeita. Alguns comandos que produzem os efeitos mencionados s˜ao o if, o for e o
while aos quais exempliﬁcaremos sua sintaxe.

3.3 FUNC¸ ˜OES, SCRIPTS E ESTRUTURAS DE CONTROLE

21

Exemplo 3.3.3. : if

Estrutura.
>if condi¸c~ao1
>comando1
>elseif condi¸c~ao2
>comando2
>else comando3
>endif

Na estrutura acima, caso condi¸c~ao1 seja satisfeita, o octave executar´a o comando1,
caso contr´ario, o programa testar´a a condi¸c~ao2, satisfeita, ele executa comando2. Se as
duas primeiras condi¸c˜oes n˜ao se veriﬁcarem, o octave executa o comando3. Esta, por´em,
n˜ao ´e a ´unica sintaxe v´alida para esta instru¸c˜ao. Podemos inserir mais de um elseif ou
deixar apenas o if com a condi¸c~ao1. O argumento else tamb´em pode ser omitido, caso
seja, e n˜ao forem satisfeitas nenhuma condi¸c˜ao estabelecida pelo if ou pelos elseif’s,
simplesmente n˜ao haver´a retorno algum.

Exemplo 3.3.4. : Script teste do quatro

Testa se x ´e igual a 4 e exibe a mensagem “x ´e quatro!”, em caso aﬁrmativo. Caso o x
seja maior que quatro, exibe “tente um inteiro menor”e caso seja menor do que quatro,
exibe “tente um inteiro maior”.
# No arquivo teste do quatro.m, escrevemos
if x==4
disp("x ´e quatro!")
elseif x>4
disp("tente um inteiro menor")
else disp("tente um inteiro maior")
endif
# No prompt, teremos:
>x=2; teste do quatro
tente um inteiro maior

O uso do comando disp no script acima faz com que o octave exiba a mensagem sem
armazen´a-la no ans. O uso de aspas ´e necess´ario para que o programa enxergue o que
est´a escrito apenas como uma sequˆencia de caracteres, sem valor num´erico algum.

Vemos tamb´em o uso das condi¸c˜oes x==4 e x>4. Tais rela¸c˜oes fazem com que o octave
retorne o valor 1, caso a rela¸c˜ao seja verdadeira, e o valor 0 caso a rela¸c˜ao seja falsa.
Podemos combin´a-las atrav´es dos operadores l´ogicos “e”e “ou”, mediante o uso dos co-
nectivos “&”e “—”; ou neg´a-las em uma proposi¸c˜ao mais complexa, utilizando o comando
“!”. Nas tabelas abaixo, listamos os operadores l´ogicos e principais rela¸c˜oes presentes no
octave:

3.3 FUNC¸ ˜OES, SCRIPTS E ESTRUTURAS DE CONTROLE

22

Rela¸c˜oes
Express˜ao Retorna 1, quando:

x==y
x<y
x>y
x>=y
x<=y
x!=y

x = y
x < y
x > y
x ≥ y
x ≤ y
x (cid:54)= y

Operadores L´ogicos
Express˜ao Retorna 1, quando

x & y
x | y
!x

x (cid:54)= 0 e y (cid:54)= 0
x (cid:54)= 0 ou y (cid:54)= 0
x = 0

Operadores de Incremento
Express˜ao Efeito semelhante a

++x
x++
--x
x--

x=x+1; x
x, x=x+1;
x=x-1; x
x, x=x-1;

Os operadores de incremento determinam a ordem em que o octave adiciona ou sub-
trai uma unidade a uma vari´avel e como ele far´a uso desta vari´avel. Por exemplo, no
comando x=0, y=1, ++x<y, o octave retornar´a para a desigualdade, ans=0, pois primeiro
foi feito o incremento antes da compara¸c˜ao. Caso tiv´essemos escrito x++<y, o retorno se-
ria ans=1, e no entanto, o valor de x seria 1, revelando que houve a compara¸c˜ao antes da
incrementa¸c˜ao.

Os comandos que deﬁnem la¸cos, fornecem instru¸c˜oes para que o programa execute
um comando at´e que uma condi¸c˜ao seja satisfeita. Construiremos la¸cos atrav´es do uso
do for e do while.

Exemplo 3.3.5. : for
Estrutura.
>for var=in´ıcio:fim
>comandos
>endfor

A vari´avel var ser´a atribu´ıdo o valor em in´ıcio e ent˜ao ser˜ao executados comandos,
em seguida, o octave vai adicionando uma unidade a var e executando comandos at´e que
sejam executados os comandos para o n´umero em fim.

Exemplo 3.3.6. : fun¸c˜ao eyes
Fun¸c˜ao que recebe como entrada um inteiro n e cria uma matriz quadrada de ordem n
em que os elementos na diagonal secud´aria s˜ao iguais a 1 e os fora dela s˜ao nulos.
>function X=eyes(n)
>X=zeros(n)
>for i=1:n
>X(i,n+1-i)=1;
>endfor
>endfunction

3.3 FUNC¸ ˜OES, SCRIPTS E ESTRUTURAS DE CONTROLE

23

Exemplo 3.3.7. : while

Estrutura.
>while condi¸c~ao
>comandos
>endwhile

Se a condi¸c˜ao em condi¸c~ao for satisfeita, executa comandos e repete o processo at´e

que condi¸c~ao retorne um resultado falso.

Exemplo 3.3.8. : Fun¸c˜ao teste da razao
Toma como argumentos uma matriz A em Rm×n e um real positivo x e retorna o menor
inteiro k para o qual o valor da express˜ao k*(m+n+1-k)/(m*n) ´e maior do que x.

>function y=teste da razao(A,x)
>[m n]=size(A)
>k=1;
>while k*(m+n+1-k)/(m*n)<=x
>k=k+1;
>endwhile
>y=k;
>endfunction

Na segunda linha do programa acima atribu´ımos `as vari´aveis m e n, respectivamente,
o n´umero de linhas e de colunas de A. Na terceira, estabelecemos o valor inicial da
vari´avel k utilizada no la¸co while. Na sequˆencia (linha 4), o la¸co ´e iniciado e ser´a testado
a desigualdade k · (m + n + 1 − k)/m · n ≥ x, que caso seja verdadeira trocamos k por
seu sucessor (linha 5) e repetiremos o teste at´e que a desigualdade se veriﬁque falsa, a´ı o
la¸co while ´e encerrado atrav´es de endwhile e fazemos a fun¸c˜ao retornar o valor de k ao
qual a desigualdade se mostrou falsa. Por ﬁm, a fun¸c˜ao ´e devidamente encerrada.

CAP´ITULO 4

A ´ALGEBRA DE MATRIZES E A EDIC¸ ˜AO DE
IMAGENS

O GNU octave naturalmente ´e capaz de manipular imagens digitais. Disp˜oe de ferra-
mentas que permitem abrir a matriz de dados de uma imagem a partir de v´arios formatos,
bem como, a partir de uma matriz, salva uma imagem em outros tantos formatos. ´E
poss´ıvel visualizar uma imagem e fazer a convers˜ao entre diversos sistemas, enﬁm, com a
instala¸c˜ao do pacote image, o octave passa a dispor de ferramentas de edi¸c˜ao avan¸cadas.
Nosso objetivo aqui, no entanto, ´e o estudo dos efeitos obtidos atrav´es da aplica¸c˜ao
da ´algebra elementar de matrizes, acess´ıveis ao aluno e ao professor do ensino m´edio,
por tal motivo, ser´a evitado o uso de ferramentas de edi¸c˜ao pr´e-deﬁnidas o tanto quanto
poss´ıvel.

4.1 FERRAMENTAS DE MANIPULAC¸ ˜AO

Para abrir uma imagem e armazen´a-la na vari´avel A, utiliza-se o comando A=imread
("nome da imagem.formato") e para visualiz´a-la, imshow(A). Uma imagem armazenada
em A e salva atrav´es da instru¸c˜ao imwrite(A,"nome da imagem.formato") e podemos
acessar uma descri¸c˜ao t´ecnica da imagem atrav´es de imfinfo.

Para o octave, imagens coloridas e em escala de cinza s˜ao objetos do tipo uint8,
inteiros de 8 bits, e matrizes n˜ao associadas a imagens em escala de cinza ou coloridas s˜ao
do tipo double, reais. Imagens em preto e branco s˜ao obtidas atrav´es de matrizes do tipo
double. Uma vari´avel x pode ser transformada em um tipo ou outro fazendo uint8(x)
ou double(x). A maior diferen¸ca entre estes dois tipos de imagem est´a no retorno de
opera¸c˜oes aritm´eticas, pois as do uint8 retornam o inteiro entre 0 e 255 mais pr´oximo do
resultado esperado. Assim, as express˜oes 8/3, uint8(5/3), uint8(8)/3, uint8(1000)*1,
-uint8(10), fornecem as respostas 2.6667, 1, 3, 255 e 0, respectivamente.

´E poss´ıvel converter imagens RGB (padr˜ao do octave) para o sistema HSV usando
rgb2hsv. O processo inverso ´e feito com hsv2rgb. Nestes dois comandos, a sa´ıda ´e do tipo
double normalizada. Isto signiﬁca que se B=hsv2rgb(A) deve-se efetuar uint8(255*B)
antes de visualizar ou salvar a matriz B.

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

´E poss´ıvel, de uma imagem colorida, obter uma imagem em escala de cinza medi-
ante in´umeras t´ecnicas. Uma muito comum, ´e atribuir a cada pixel da imagem cinza
uma intensidade dada pela m´edia aritm´etica das intensidades de suas trˆes componentes
RGB. Outra maneira, mais utilizada, ´e a de atribuir a cada pixel a intensidade de sua
luminˆancia. Segundo Gomes e Velho em [1], a luminˆancia L de uma cor c = (r, g, b) ´e

24

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

25

dada por

Para simpliﬁcar, utilizaremos os valores arredondados:

L = 0, 299 · r + 0, 587 · g + 0, 114 · b

L = 0, 3 · r + 0, 6 · g + 0, 1 · b

e temos, a seguir, um exemplo de uso destas duas t´ecnicas, junto ao c´odigo utilizado para
produzi-las.

Exemplo 4.2.1.

Convertendo imagens coloridas em imagens em escala de cinza.

ﬁgura 4.1

>I=imread("eg.tiff")
>I=double(I);
>G1=(I(:,:,1)+I(:,:,2)+I(:,:,3))./3;
>imwrite(uint8(G1),"egCinzaMedia.png")
>G2=0.3*I(:,:,1)+0.6*I(:,:,2)+0.1*I(:,:,3);
>imwrite(uint8(G2),"egCinzaLuminacia.png")

(a) Original

(b) M´edia

(c) Luminˆancia

Figura 4.1

4.2.1 Ajuste do brilho

Intuitivamente, o conceito de brilho de uma imagem (ou de uma cor) corresponde
ao qu˜ao claro ou escuro esta ´e percebida. Tal conceito subjetivo tem diferentes inter-
preta¸c˜oes em diferentes sistemas de cores; no HSV, por exemplo, podemos aumentar ou
diminuir o brilho de uma imagem reduzindo ou aumentando a intensidade dada pelo Va-
lor (canal V). O controle do brilho de uma imagem em escala de cinza ´e feito adicionando
ou subtraindo uma constante a cada entrada da matriz de intensidades.

Exemplo 4.2.2.

Aumentando e reduzindo o brilho de uma imagem em 50 n´ıveis.

ﬁgura 4.2

>G2=double(G2)
>G2BrilhoAd=G2.+50;
>G2BrilhoSub=G2.-50;

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

26

(a) Brilho aumentado

(b) Original

(c) Brilho reduzido

Figura 4.2

4.2.2 Negativo

O negativo de uma imagem corresponde a representa¸c˜ao desta com seus valores de
intensidades invertidos, isto signiﬁca que o percentual de proximidade de um tom de
cinza ao branco torna-se, no negativo, o percentual de proximidade deste tom ao preto,
e vice-versa. O negativo N I de uma imagem I ´e obtido fazendo para cada pixel I(x, y)
a transforma¸c˜ao N I(x, y) = 255 − I(x, y).

Exemplo 4.2.3.

Obtendo o negativo de uma imagem.
>G1Negativa=255.-G1;

Figura 4.3

(a) Original

(b) Negativo

Figura 4.3

4.2.3 Ajuste do contraste

O contraste estabelece um distanciamento do conjunto tons de cinza da imagem a
um valor pr´e deﬁnido, denominado limiar. O aumento do contraste torna os tons com
intensidade acima do limiar, mais claros, e os com intensidade abaixo do limiar, mais
escuros. O efeito de aumento de contraste obt´em-se dividindo cada entrada da matriz

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

27

de intensidades pelo limiar e elevando cada termo da matriz resultante a um expoente
maior do que 1. Para reduzir o contraste, elevamos a cada termo a um expoente entre 0
e 1. Vale mencionar que devemos fazer a convers˜ao da imagem para o tipo double antes
de realizarmos os c´alculos, e reconverter os resultados para o tipo uint8 antes salv´a-los.

Exemplo 4.2.4.

Aumentando e reduzindo o contraste de uma imagem por um limiar de 200. Figura 4.4

>G2=double(G2);
>G2ContrasteAd=((G2./200).^2).*200
>G2ContrasteSub=sqrt(G2./200).*200

(a) Contraste aumentado

(b) original

(c) Contraste reduzido

Figura 4.4

4.2.4 Reﬂex˜oes e rota¸c˜oes

A transposi¸c˜ao de matrizes, junto ao produto por matrizes obtidas pelo comando eyes
deﬁnido no exemplo 3.3.6 s˜ao respons´aveis por efeitos de reﬂex˜ao em torno de um eixo
horizontal, vertical e diagonal na imagem. Combinando duas destas reﬂex˜oes, obtemos
rota¸c˜oes de m´utiplos de 90(cid:176). Se ˜In ´e a matriz obtida mediante o comando eyes(n), os
produtos ˜In · A e A · ˜In produzem, respectivamente, reﬂex˜oes em torno do eixo horizontal
e vertical da imagem A. A transposta de A produz a reﬂex˜ao da imagem em torno da
diagonal principal de A.

Exemplo 4.2.5.

Fazendo reﬂex˜oes em torno de um eixo horizontal, vertical e diagonal, e em seguida,
produzindo rota¸c˜oes.
Figura 4.5

>Im=imread("lena512.bmp");
>RI=eyes(512);
>RI*Im; Im*RI; Im’;
>RI*(Im’); RI*Im*RI; (Im’)*RI;

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

28

(a) Original

(b) Reﬂex˜oes

(c) Rota¸c˜oes

Figura 4.5

4.2.5 Binariza¸c˜ao

A binariza¸c˜ao ´e um processo que separa uma imagem em apenas dois tons, preto e
branco, segundo algum crit´erio. O mais comum ´e o thresholding, que atribui a cor branca
para valores acima de um limiar, e a cor preta para valores abaixo deste limiar. Se I ´e
uma imagem em escala de cinza obtemos facilmente tal resultado pelo octave atrav´es da
atribui¸c˜ao B = I ≤ limiar.

Exemplo 4.2.6.

Tornando tons abaixo do limiar 150, pretos, e maiores ou iguais a tal limiar, brancos.
Figura 4.6
>B=G2>=150

(a) original

(b) Binarizacao simples

Figura 4.6

Frequentemente, a aplica¸c˜ao da binariza¸c˜ao pela deﬁni¸c˜ao de um limiar constante
reduz muito a qualidade da imagem ﬁnal. Existem alternativas de binariza¸c˜ao que buscam
resultados melhores, a um custo computacional maior. Valendo-se da impossibilidade do
olho humano distinguir varia¸c˜oes de tons em regi˜oes muito pequenas, `as quais o c´erebro
fornece uma informa¸c˜ao da m´edia dos tons ali presentes, tais t´ecnicas buscam criar tons
de cinza criando padr˜oes branco-preto. Destacaremos o dithering ordenado, como um
exemplo deste tipo de binariza¸c˜ao.

No dithering ordenado dividimos a imagem em regi˜oes quadradas com uma quantidade
constante de pixeis, em seguida, comparamos cada uma destas regi˜oes com um m´odulo

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

29

pr´e-deﬁnido. Pixeis com intensidade maior do que a respectiva entrada do m´odulo s˜ao
tornados brancos e os com intensidade menor ou igual a do m´odulo s˜ao tornados pretos.
A matriz B1 abaixo ´e um exemplo de m´odulo 2 × 2 para realiza¸c˜ao do dithering ordenado

B1 =

(cid:21)

(cid:20) 0 2
3 1

Outros m´odulos podem ser gerados atrav´es da recurs˜ao






Y (1)=B1

(cid:20)

Y (n + 1)=

4 · Y (n)
4 · Y (n) + 3 · U (n)

4 · Y (n) + 2 · U (n)
4 · Y (n) + U (n)

(cid:21)

Onde, Y (n) ´e o m´odulo de dimens˜oes 2n × 2n e U (n) corresponde `a matriz ones(2^n).
Com o ﬁm de criar uma fun¸c˜ao para realizar o dithering ordenado, ﬁzemos uma fun¸c˜ao
para gerar automaticamente os m´odulos, dada a ordem da recurs˜ao, a qual descrevemos
a seguir.

Exemplo 4.2.7. : Fun¸c˜ao modulo

Toma como argumento um n´umero inteiro positivo n e retorna um m´odulo de dimens˜oes
2n × 2n.
>function Y=modulo(n)
>if n==1
>Y=[0,2;3,1];
>else
>Y(1:2^(n-1),1:2^(n-1))=4*modulo(n-1);
>Y(1:2^(n-1),2^(n-1)+1:2^n)=4*modulo(n-1).+2;
>Y(2^(n-1)+1:2^n,1:2^(n-1))=4*modulo(n-1).+3;
>Y(2^(n-1)+1:2^n,2^(n-1)+1:2^n)=4*modulo(n-1).+1;
>endif
>endfunction

Para efetuar o dithering ordenado em uma imagem I construiremos uma matriz com
as mesmas dimens˜oes de I, no entanto, suas entradas ser˜ao r´eplicas do m´odulo obtidas
mediante a instru¸c˜ao repmap(A,m,n), onde A representa um m´odulo, que cria uma nova
matriz replicando A m vezes na dire¸c˜ao vertical e n vezes na horizontal. Tal matriz, ser´a,
por ﬁm, multiplicada pelo n´umero 255/2^(2*d), onde 2^d representa a ordem da matriz
do m´odulo.

Exemplo 4.2.8. : Fun¸c˜ao dito

Toma como argumentos uma imagem I e um inteiro positivo d e Efetua o dithering or-
denado na imagem usando m´odulos de dimens˜oes 2d × 2d.

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

30

>function Y=dito(I,d)
>[m n]=size(I);
>map size=ceil([m n]./2^d);
>mod map=255*repmat(modulo(d),map size)./(2^(2*d));
>mod map=mod map(1:m,1:n);
>Y=(I>mod map);
>endfunction

Exemplo 4.2.9.

Aplica¸c˜ao da fun¸c˜ao dito(I,d) para d=1:3.
>I=imread("egCinzaLuminancia.tiff");
>DO1=dito(I,1);
>DO2=dito(I,2);
>DO3=dito(I,3);

Figura 4.7

(a) Original

(b) M´odulo 2 × 2

(c) M´odulo 4 × 4

(d) M´odulo 8 × 8

Figura 4.7

Resultados melhores de dithering ordenado s˜ao obtidos conforme a imagem seja maior.

4.2.6 Transi¸c˜ao de imagens

A opera¸c˜ao de cross dissolve cria um efeito de transi¸c˜ao de uma imagem em ou-
tra. Dada duas imagens, A e B, ambas com o mesmo tamanho, obtemos a imagem C,
resultante do cross dissolve, atrav´es da express˜ao

C = t · A + (1 − t) · B

onde t ´e um n´umero real no intervalo [0, 1] e indica o percentual de participa¸c˜ao da matriz
A na transi¸c˜ao.

Exemplo 4.2.10.

Aplicando sucessivamente o cross dissolve em duas matrizes.

Figura 4.8

4.2 EDIC¸ ˜AO DE IMAGENS EM ESCALA DE CINZA

31

>A=imread("lin256.jpg");
>B=imread("link.jpg");
>for i=1:7
> C(:,:,i)=0.125*i*A+(1-0.125*i)*B;
>endfor

(b) transi¸c˜ao de imagens

Figura 4.8

Ap´os a execu¸c˜ao do programa acima basta efetuar imwrite(C(:,:,k), "link.jpg")

com k variando de 1 a 7, para o salvamento das imagens.

4.2.7 Marca d’´agua

Podemos produzir um efeito de marca d’´agua mediante a multiplica¸c˜ao de matrizes
termo a termo. Seja A a matriz associada a imagem na qual ser´a inserida a marca d’´agua
e seja B a matriz associada a imagem da marca d’´agua propriamente dita. Primeiramente
criamos uma matriz C atrav´es do comando ones que tenha o tamanho de A. Em seguida
deﬁnimos M como se segue

M =

1
max{B}

· B

onde max{B} ´e a maior entrada de B. Agora atribu´ımos em C uma regi˜ao retangular
igual a M e efetuamos o produto termo a termo entre C e A para obter o efeito em
quest˜ao. Para aumentar o efeito de transparˆencia da marca basta aumentar o brilho da
matriz B antes de efetuar o processo descrito anteriormente.

Exemplo 4.2.11.

Inserido como marca d’´agua a imagem em B no canto inferior direito da imagem em A.
Figura 4.9

4.3 EDIC¸ ˜AO DE IMAGENS COLORIDAS

32

>A=imread("egCinzaLuminancia.jpg");
>B=double(imread("lin.jpg"));
>C=ones(size(A));
>M=B./max(max(B));
>C(end-rows(B)+1:end,end-columns(B)+1:end)=M;
>A com marca=double(C).*double(Im);

(a) original

(b) com marca

Figura 4.9

4.3 EDIC¸ ˜AO DE IMAGENS COLORIDAS

Os efeitos de manipula¸c˜ao do brilho e do contraste, A reﬂex˜ao, a rota¸c˜ao de m´ultiplos
de 90(cid:176), a binariza¸c˜ao, a obten¸c˜ao do negativo, a transi¸c˜ao de imagens e a inclus˜ao de
marca d’´agua podem ser aplicadas em imagens coloridas, bastando efetuar as opera¸c˜oes
em cada canal RGB. Na ﬁgura a seguir, diminuimos o brilho em 50 n´ıveis, aumentamos
o contraste a partir de um limiar de 200, efetuamos a reﬂex˜ao em torno do eixo vertical
e inclu´ımos uma marca d’´agua.

Exemplo 4.3.1.

Aplicando as altera¸c˜oes descritas no par´agrafo anterior.

Figura 4.10

>I=imread("eg.tiff");
>E=I.-50;
>E=((double(E)./200).^2).*200;
>B=double(imread("lin.jpg"));
>M=ones(size(E));
>B=B./max(max(B));
>for i=1:3
>E(:,:,i)=E(:,:,i)*eyes(columns(E));
>M(end-rows(B)+1:end,end-columns(B)+1:end,i)=B;
>endfor
>E=M.*E;
>imwrite(uint8(E),"egEditado.tiff")

4.3 EDIC¸ ˜AO DE IMAGENS COLORIDAS

33

(a) original

(b) Editada

Figura 4.10

4.3.1 Coloriza¸c˜ao

Colorizar uma imagem corresponde `a represent´a-la como se fˆossemos representar toda
a varia¸c˜ao de luminˆancia da imagem atrav´es de um ´unico canal de cor, tal como se
v´ıssemos a imagem atrav´es de um vitral colorido. Para obter a coloriza¸c˜ao C de uma
imagem I, escolhemos uma cor c e criamos uma imagem A com as dimens˜oes de I
contendo apenas a cor c, em seguida, se L ´e a matriz de luminˆancia de I, efetuamos o
produto termo a termo entre L/255 e A.

Exemplo 4.3.2.

Colorizando a imagem I na cor c = (128, 255, 64).

Figura 4.11

>I=double(imread("eg.jpg"));
>L=(0.3*I(:,:,1)+0.6*I(:,:,2)+0.1*I(:,:,3));
>A(:,:,1)=128*ones(size(L));
>A(:,:,2)=255*ones(size(L));
>A(:,:,3)=64*ones(size(L));
>C=A.*(L./255);

(a) original

(b) colorizada

Figura 4.11

4.3 EDIC¸ ˜AO DE IMAGENS COLORIDAS

34

4.3.2 Decomposi¸c˜ao RGB e CMY

Para representar a decomposi¸c˜ao de uma imagem em suas trˆes componentes RGB, tal
como foi feito na ﬁgura 2.3, mantemos a componente que se deseja visualizar e tornamos
as demais iguais a matriz nula. Para uma representa¸c˜ao de como cada componente CMY ´e
impressa no papel, tal como foi feito na ﬁgura 2.5(c), observamos inicialmente que o octave
salva e exibe imagens no sistema RGB com entradas do tipo uint8, logo, o objetivo aqui
´e visualizar em RGB o que seria impresso no papel em CMY. Imprimir uma cor (c, 0, 0)
no papel branco, por exemplo, ´e fazer com que este perca 255 − c n´ıveis de luminˆancia na
componente vermelha, o que no RGB corresponde a cor (255 − c, 255, 255) = (r, 255, 255).
Assim, representamos a impress˜ao de cada componente CMY no papel mantendo os
valores do canal de sua cor oposta e fazendo as demais assumirem o valor m´aximo.

Exemplo 4.3.3.

Obtendo a componente verde e a componente magenta da imagem I.
>clear G, clear M
>G(:,:,1)=zeros(size(I(:,:,1)));
>G(:,:,2)=I(:,:,2);
>G(:,:,3)=zeros(size(I(:,:,1)));
>imwrite(uint8(G),"egG.tiff")
>M(:,:,1)=255*ones(size(I(:,:,1)));
>M(:,:,2)=I(:,:,2);
>M(:,:,3)=255*ones(size(I(:,:,3)));
>imwrite(uint8(M),"egM.tiff")

(a)

(b)

Figura 4.12

4.3.3 Posteriza¸c˜ao

A posteriza¸c˜ao consiste em reduzir o n´umero de cores de uma imagem. O processo
de binariza¸c˜ao de cada componente de uma imagem ´e um exemplo de posteriza¸c˜ao. A
fun¸c˜ao posteriza(X,k) implementada aqui, separa cada componente RGB em n faixas
de cores e enquadra cada pixel de X em uma destas faixas. Abaixo temos a descri¸c˜ao da
fun¸c˜ao seguida de exemplos de uso.

4.3 EDIC¸ ˜AO DE IMAGENS COLORIDAS

35

Exemplo 4.3.4. : Fun¸c˜ao posteriza

Separa cada componente da imagem X em k n´ıveis.
>function Y=posteriza(X,k)
>A=double(X); [m n c]=size(X);
>for i=1:c
>Y(:,:,i)=uint8(floor(k.*A(:,:,i)./256).*(255/(k-1)));
>endfor
>endfunction

Exemplo 4.3.5.

Posterizando uma imagem em 2, 4 e 8 n´ıveis.

Figura 4.13

>I=imread("eg.tiff");
>POST2=posteriza(I,2);
>POST4=posteriza(I,4);
>POST8=posteriza(I,8);

(a) 2 niveis

(b) 4 niveis

(c) 8 n´ıveis

Figura 4.13

Este Cap´ıtulo encerra a primeira etapa deste trabalho ao reunir um conjunto de
ferramentas b´asicas para explora¸c˜ao do octave e do processamento de imagens. Aqui
foi evidente o intenso uso da multiplica¸c˜ao termo a termo de matrizes, a multiplica¸c˜ao
por escalar e a adi¸c˜ao de matrizes em express˜oes do tipo X.+c que s˜ao idˆenticas `as
X+c*ones(size(X)). O produto de matrizes, visto que, ao fornecer resultados dependen-
tes das linhas e colunas das matrizes multiplicadas, foi pouco utilizado nas ferramentas
expostas at´e o momento, uma vez que na edi¸c˜ao ou p´os processamento de imagens a
maioria das opera¸c˜oes s˜ao feitas mediante a transforma¸c˜ao da cor de um pixel em uma
outra cor dependendo apenas da intensidade da cor de entrada. O produto de matrizes,
no entanto, conduzir´a os resultados obtidos nos pr´oximos cap´ıtulos, visto que o m´etodo
de compress˜ao de imagens digitais posteriormente apresentado utiliza-se da visualiza¸c˜ao
de uma matriz como um produto de matrizes pass´ıveis de simpliﬁca¸c˜ao.

CAP´ITULO 5

BASES MATEM´ATICAS PARA A COMPRESS˜AO DE
IMAGENS DIGITAIS

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

Os m´etodos de compress˜ao de imagens digitais apresentados no pr´oximo cap´ıtulo
baseiam-se na possibilidade de decompor uma matriz em um produto de trˆes matrizes,
duas ortogonais e uma diagonal generalizada, o qual torna pass´ıvel a obten¸c˜ao de uma
matriz com uma quantidade de dados reduzida e, no entanto, dentre todas as matrizes
com a mesma quantidade de dados, esta nova matriz obtida ´e, em certo sentido, a mais
pr´oxima poss´ıvel da matriz original. Demonstrar tal resultado ´e o objetivo deste cap´ıtulo
e o conceito de decomposi¸c˜ao em valores singulares governar´a esta meta.

Deﬁni¸c˜ao 5.1. Uma matriz Am×n ´e dita diagonal generalizada se possuir todos as suas
entradas fora da diagonal principal, nulas.

Deﬁni¸c˜ao 5.2. Dada uma matriz m × n A, uma decomposi¸c˜ao A = U SV T ´e dita uma
decomposi¸c˜ao em valores singulares se U e V s˜ao matrizes ortogonais, e S ´e uma matriz
diagonal generalizada cujas entradas na diagonal principal s˜ao n˜ao-negativas.

Iremos nos referir a decomposi¸c˜ao em valores singulares de A como a SVD de A, sigla
para Singular Value Decomposition. ´E not´avel a semelhan¸ca entre a decomposi¸c˜ao em
valores singulares e a decomposi¸c˜ao espectral, garantida para toda matriz sim´etrica pelo
teorema espectral, como enunciado na sequˆencia.

Teorema 5.1 (Teorema espectral). Toda matriz sim´etrica ´e diagonaliz´avel por matriz
ortogonal, em outras palavras, dada uma matriz sim´etrica A ∈ Rm×m, existem uma
matriz ortogonal P e uma matriz diagonal E tais que A = P EP T.

Decorre do teorema acima que as entradas na diagonal principal de E formam o
conjunto de autovalores de A, e os vetores colunas de P constituem uma base ortonormal
de autovetores de A associados aos autovalores em E, correspondendo a i-´esima coluna
de P ao i-´esimo autovalor em E. O teorema espectral ´e um dos principais resultados da
´algebra linear, sua demonstra¸c˜ao foge ao escopo deste trabalho e ser´a omitida aqui. No
entanto, ela pode ser encontrada em [4] e [3]. Junto ao teorema espectral, o conceito de
matrizes n˜ao negativas constituem os fundamentos para a demonstra¸c˜ao da existˆencia
da SVD de uma matriz. A sequˆencia de deﬁni¸c˜oes e proposi¸c˜oes a seguir baseia-se na
exposi¸c˜ao feita em [2] e a pr´oxima deﬁni¸c˜ao cont´em o conceito de matrizes n˜ao negativas,
mas antes de fazˆe-la, por motivo de clareza, faremos uma breve exposi¸c˜ao da nota¸c˜ao
adotada.

36

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

37

Tal como no octave, n˜ao faremos neste texto distin¸c˜ao entre espa¸cos vetoriais iso-
morfos, ﬁcando o Rm×n, espa¸co das matrizes m × n de dimens˜ao ﬁnita sobre R, como
o representante de algum espa¸co vetorial de dimens˜ao ﬁnita. Assim, consideraremos
R1×1 = R e Rm×n = L(E, F ) (L(E, F ) ´e o espa¸co das transforma¸c˜oes lineares E → F
tais que dim E = n e dim F = m), por exemplo. Um vetor (coluna) ´e um elemento
de Rm×1 = Rm e dado um vetor u ∈ Rm chamaremos de vetor linha ao elemento uT de
R1×m. Neste contexto, uma transforma¸c˜ao linear v (cid:55)→ A(v), um produto interno (cid:104)u, v(cid:105)
e uma forma quadr´atica Q(x) ser´a o dados pelos produtos matriciais Av, uTv e xTAx,
respectivamente. Doravante, usaremos GB para indicar o espa¸co gerado pelo conjunto B
de vetores, P(A) para denotar o posto de uma matriz Am×n e a letra grega µ representa
min{m, n}, donde segue que P(A) ≤ µ, ∀A ∈ Rm×n. O escalar zero, o vetor nulo e a
matriz nula ser˜ao respectivamente escritos como 0, 0 e O.
Deﬁni¸c˜ao 5.3. Uma matriz sim´etrica A ∈ Rn×n ´e dita n˜ao negativa (respec. positiva) e
denotada por A ≥ 0 (respec. A > 0) se for sim´etrica e se xTAx ≥ 0 (respec. xTAx > 0)
para todo x ∈ Rn.

O teorema seguinte relaciona matrizes n˜ao negativas e positivas ao sinal de seus au-

tovalores.
Proposi¸c˜ao 5.1. Uma matriz sim´etrica A ∈ Rm×n ´e n˜ao negativa se, e somente se, tem
todos os seus autovalores n˜ao negativos. Ela ser´a positiva se, e somente se, todos os seus
autovalores forem positivos.
Demonstra¸c˜ao: Supondo A ≥ 0, sejam λ ∈ R e v ∈ Rn um vetor n˜ao nulo, tais que
Av = λv. Por deﬁni¸c˜ao

vTAv ≥ 0 ⇒ vT(λv) ≥ 0 ⇒ λ(vTv) ≥ 0

como vTv = (cid:107)v(cid:107)2 ≥ 0, segue que λ ≥ 0. Por outro lado, o teorema espectral garante
a existˆencia de uma base ortonormal de autovetores de A, u1, . . . , un, associados aos
autovalores n˜ao negativos λ1, . . . , λn, respectivamente. Dado v ∈ Rn, existem escalares
α1, . . . , αn tais que

n
(cid:88)

n
(cid:88)

v =

αiui

e Av =

λjαjuj

Assim

i=1

j=1

vTAv =

=

=

=

(cid:32) n

(cid:88)

i=1
(cid:32) n

(cid:88)

(cid:33)T(cid:32) n

(cid:88)

αiui

λjαjuj

(cid:33)

j=1

(cid:33)(cid:32) n

(cid:88)

αiuT
i

λjαjuj

(cid:33)

i=1

j=1

n
(cid:88)

i=1
n
(cid:88)

αiuT
i

n
(cid:88)

j=1

λjαjuj

λjαiαjuT

i uj

i,j=1

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

38

como uT

i uj = 0 sempre que i (cid:54)= j, a ´ultima igualdade acima torna-se

vTAv =

n
(cid:88)

i=1

λiα2

i uT

i ui =

n
(cid:88)

i=1

λiα2

i (cid:107)ui(cid:107)2 =

n
(cid:88)

i=1

λiα2
i

cujo termo geral de (cid:80)n
i ´e n˜ao negativo, visto que λi ≥ 0. Segue que vTAv ≥ 0 e
portanto A ≥ 0. A demonstra¸c˜ao para o caso positivo ´e idˆentica, bastando substituir o
≥ por >. (cid:3)

i=1 λiα2

Sejam a1, . . . , an os vetores coluna de uma matriz A ∈ Rm×n. A matriz ATA = [cij]m×n
tem a sua ij-´esima coordenada dada por aT
i aj, o produto interno entre ai e aj, por
isso, pode-se aﬁrmar que ATA re´une toda informa¸c˜ao da m´etrica entre os vetores ai.
Analogamente, AAT re´une informa¸c˜oes a respeito dos vetores linhas de A. De fato, os
pr´oximos teoremas nos mostram que o estudo de ATA e de AAT revela propriedades da
pr´opria matriz A.

Proposi¸c˜ao 5.2. Dada A ∈ Rm×n, a matriz ATA ´e n˜ao negativa.

Demonstra¸c˜ao: A matriz ATA ´e sim´etrica, a saber

(ATA)T = AT(AT)T = ATA

e para um dado vetor v ∈ Rm

vTATAv = (Av)TAv = (cid:107)Av(cid:107)2 ≥ 0

por conseguinte, ATA ≥ 0. (cid:3)

Para a pr´oxima proposi¸c˜ao usaremos o conceito de complemento ortogonal de um
subespa¸co vetorial W de V , usualmente representado por W ⊥, e correspondente ao con-
junto de vetores de V ortogonais aos vetores em W . O conjunto W ⊥ goza das seguintes
propriedades:

i) W ⊥ ´e um subespa¸co de V ;

ii) W ∪ W ⊥ = {0};

iii) (W ⊥)⊥ = W .

O uso do complemento ortogonal na pr´oxima proposi¸c˜ao se dar´a, tanto pela aplica¸c˜ao
das propriedades acima, quanto pelo lema apresentado a seguir.

Lema 5.1.1. A imagem de uma matriz qualquer ´e perpendicular ao n´ucleo de sua trans-
posta.

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

39

Demonstra¸c˜ao: Em outras palavras, iremos mostrar que para toda matriz A ∈ Rm×n
tem-se N(AT) = Im(A)⊥.

v ∈ N(AT) ⇔ ATv = 0

⇔ ∀u ∈ Rm; (ATv)Tu = 0
⇔ ∀u ∈ Rm; vTAu = 0
⇔ v ∈ Im(A)⊥.

como quer´ıamos mostrar. (cid:3)

Proposi¸c˜ao 5.3. Para qualquer matriz A ∈ Rm×n o posto de ATA ´e igual ao posto de
A.

Demonstra¸c˜ao: Primeiramente, nota-se que N(ATA) = N(A), com efeito, dado v ∈
N(ATA), tem-se

ATAv = 0 ⇒ Av ∈ N(AT) = Im(A)⊥

⇒ Av ∈ Im(A) ∩ Im(A)⊥ = {0}
⇒ Av = 0
⇒ v ∈ N(A)

Por outro lado

v ∈ N(A) ⇒ Av = 0 ⇒ ATAv = 0 ⇒ v ∈ N(ATA)

e da´ı N(ATA) = N(A). Prosseguindo com a demonstra¸c˜ao, o teorema do n´ucleo e da
imagem garante

dimN(ATA) + dimIm(ATA) = m
dimN(A) + P(ATA) = m

⇔
⇔
P(ATA) = m − dimN(A) ⇔
P(ATA) = P(A)

(cid:3)

´E importante salientar que as duas ´ultimas proposi¸c˜oes continuam v´alidas caso to-
memos AAT no lugar de ATA. Com efeito, dada A ∈ Rm×n sempre podemos obter sua
transposta AT. Em particular, as proposi¸c˜oes acima garantem que (AT)TA = AAT ´e n˜ao
negativa e vale P(AAT) = P(AT) = P(A). Logo, dada A tem-se AAT n˜ao negativa e
P(AAT) = P(A).

Enﬁm, prossigamos com o Teorema da Decomposi¸c˜ao em Valores Singulares.

Teorema 5.2 (Teorema da decomposi¸c˜ao em valores singulares). Toda matriz possui
uma decomposi¸c˜ao em valores singulares.

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

40

Demonstra¸c˜ao: Seja A ∈ Rm×n uma matriz qualquer. Devemos provar que existem
matrizes U , V e S tais que U e V sejam ortogonais, S = [sij]m×n, com sii ≥ 0 e sij = 0
sempre que i (cid:54)= j, e A = U SV T.

A matriz ATA ∈ Rn×n ´e sim´etrica e n˜ao negativa, decorre do teorema espectral que
existe uma base de autovetores ortonormais {v1, . . . , vn} tal que ATAvi = λivi, e sendo
P(ATA) = r, podemos nomear os λi de maneira que λi > 0, para 1 ≤ i ≤ r e λi = 0 para
r ≤ i ≤ n.

Os vetores do Rm Av1, . . . , Avn s˜ao ortogonais dois a dois, pois, para i (cid:54)= j

(Avi)T(Avj) = vT

i ATAvj = vT

i (λjvj) = λjvT

i vj = 0.

Al´em disso, temos (cid:107)Avi(cid:107)2 = (Avi)T(Avi) = λi(cid:107)vi(cid:107)2 = λi e portanto, (cid:107)Avi(cid:107) =

λi = σi.
Por ﬁm, tomando Avi = σiui, para i ≤ r, obtemos um conjunto {u1, . . . , ur} de
vetores ortonormais, ao qual, caso r < m, pode ser ampliado a uma base ortogonal
{u1, . . . , um} do Rm, mediante o algoritmo de Gram-Schmidt.

Fazendo U = (cid:2) u1

· · · um
sij = 0, caso i (cid:54)= j, as considera¸c˜oes acima garantem que

· · · vn

(cid:3), V = (cid:2) v1

(cid:3) e S = [sij]m×n com sii = σi e

√

(cid:2) Av1

· · · Avr Avr+1

· · · Avn

(cid:3) = (cid:2) σ1u1

· · · σrur 0 · · · 0 (cid:3) ⇔

A (cid:2) v1

· · · vn

(cid:3) = (cid:2) u1

· · · um

(cid:3)

σ1

. . .










σr

. . .










.

0

m×n

Na ´ultima matriz acima, caso r < n, as n − r colunas n˜ao aludidas ser˜ao nulas e no caso
de r < m, as m − r ´ultimas linhas ser˜ao nulas. Quando r = m (r = n) as referidas linhas
(colunas) n˜ao existir˜ao. Em todo caso, teremos

AV = U S ⇔ AV V T = U SV T ⇔ A = U SV T

o que conclui a demonstra¸c˜ao. (cid:3)

Os vetores u1, . . . , um s˜ao os vetores singulares esquerdos de A, j´a v1, . . . , vn s˜ao os

vetores singulares direitos de A.

Os n´umeros σ1, . . . , σ2 s˜ao chamados de valores singulares da matriz A. Sem risco
de perda para generalidade, daqui para frente convencionaremos que σ1 ≥ σ2 ≥ . . . σr e
usaremos a nota¸c˜ao σi(A) para indicar o i-´esimo maior valor singular de A, tal escrita ´e
particularmente ´util para referirmo-nos a valores singulares de matrizes distintas. Con-
sideraremos ainda σi(A) = 0 para todo i > P(A). Quando necess´ario incluir os valores
singulares nulos em uma listagem escreveremos σ1, . . . , σµ. Vejamos na pr´atica como ´e
feito para a obten¸c˜ao da decomposi¸c˜ao em valores singulares de uma matriz.

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

41

Exemplo 5.1.1. Vamos calcular os valores singulares e os vetores singulares direitos e
esquerdos da matriz A dada abaixo.

A =





7 1
0 0
5 5





Calculando ATA obtemos a matriz

ATA =

(cid:21)

(cid:20) 74 32
32 26

cujas ra´ızes de seu polinˆomio caracter´ıstico λ2 − 100λ + 900 s˜ao λ1 = 90 e λ2 = 10
10. Como visto no
e portanto, os valores singulares de A s˜ao σ1 = 3
teorema 5.1.2, os autovetores de ATA constituem os vetores singulares direitos de A, tais
autovetores s˜ao os vetores unit´arios obtidos atrav´es da solu¸c˜ao dos sistemas de equa¸c˜oes
lineares

10 e σ2 =

√

√

(cid:20) −16

32
32 −64

(cid:21) (cid:20) x
y

(cid:21)

= 0

e

(cid:20) 64 32
32 16

(cid:21) (cid:20) x
y

(cid:21)

= 0,

donde encontramos, respectivamente

(cid:21)

√
√

(cid:20) 2/
1/

5
5

v1 =

e

v2 =

(cid:20) 1/
−2/

√
5
√
5

(cid:21)

como os dois vetores singulares direitos de A. Para calcular os vetores singulares esquer-
dos, observemos que Av1 = σ1u1 e Av2 = σ2u2 e por conseguinte


√







u1 =

1
√
10
3



(cid:20) 2/
1/

√
√

5
5



(cid:21)

7 1
0 0
1 5

2/2

=



0√

2/2



e fazendo

e

u2 =

1
√
10





7 1
0 0
1 5





(cid:20) 1/
−2/

√
5
√
5

(cid:21)

=





u3 =









0
1
0

√

2/2
0
√
2/2

−



 ;

teremos completado uma base ortonormal do R3 e encontrado todos os vetores singulares
esquerdos de A, possibilitando-nos escrever





√

√

A =

√

2/2
0
2/2 −

0
2/2
0
1
√
2/2 0









√
3

10
0
0

0
√
10
0





√
√

(cid:20) 2/
1/

5
1/
5 −2/

√
5
√
5

(cid:21)

.

No octave, o comando svd ´e respons´avel por encontrar os valores singulares de uma

matriz, e ainda fornecer os vetores singulares direitos e esquerdos.

5.1 DECOMPOSIC¸ ˜AO EM VALORES SINGULARES

42

Exemplo 5.1.2. : svd
Encontrando os valores singulares da matriz A e armazenando nas vari´aveis U, S e V as
matrizes da SVD de A.
>A=[7,1;0,0;5,5], svd(A), [U S V]=svd(A)

A =

7 1
0 0
5 5

ans =

9.4868
3.1623

-0.70711
0.00000

0.00000
0.70711
0.00000 -1.00000
0.00000

-0.70711 -0.70711

U =

S =

Diagonal Matrix
9.4868
0
0

0
3.1623
0

V =

-0.89443
0.44721
-0.44721 -0.89443

Os diferentes resultados obtidos manualmente e mediante o uso do octave indicam
que a SVD de uma matriz n˜ao ´e ´unica, entretanto, seus valores singulares s˜ao ´unicos,
visto que s˜ao ra´ızes quadradas dos autovalores de ATA (que por sua vez s˜ao ´unicos).
As matrizes ATA e AAT possuem os mesmos autovalores n˜ao nulos, com autovetores
dados pelas colunas de V e de U respectivamente. Com efeito, dada A = U SV T tem-se
ATA = V STSV T e AAT = U SSTU T, donde

σ2
1

. . .










STS =

σ2
r

. . .










0

n×n

e SST =

σ2
1

. . .










σ2
r

. . .










0

m×m

e portanto, ATA e AAT possuem os mesmo conjunto de autovalores. Da´ı segue que

A e AT possuem os mesmos valores singulares.

Se U SV T ´e uma SVD de uma matriz A de posto r, ent˜ao poderemos usar a nota¸c˜ao

A =

µ
(cid:88)

i=1

σiuivT
i

ou

A =

r
(cid:88)

i=1

σiuivT
i

para referenciar a SVD de A.

5.2 NORMAS E SVD

5.2 NORMAS E SVD

43

Assegurada a existˆencia da SVD de uma matriz qualquer, voltemo-nos ao estudo das
normas espectral e de Frobenius (ou euclidiana) profundamente relacionadas com a SVD
e imprescind´ıveis para o estudo conduzido aqui.

Deﬁni¸c˜ao 5.4. Dada uma matriz A ∈ Rm×n, denotaremos sua norma espectral por (cid:107)A(cid:107)2,
deﬁnida como

(cid:107)A(cid:107)2 = max
x∈Rn

(cid:107)Ax(cid:107)
(cid:107)x(cid:107)

, com x (cid:54)= 0.

A norma espectral de A (tamb´em chamada de norma 2) sinaliza qual ´e o maior fator
de dilata¸c˜ao de um vetor quando submetido a aplica¸c˜ao deﬁnida por A. Entendemos aqui
como fator de dilata¸c˜ao um escalar (cid:15) tal que (cid:107)Av(cid:107) = (cid:15)(cid:107)v(cid:107).

O fator de dilata¸c˜ao de um vetor depende apenas de sua dire¸c˜ao, possibilitando-nos

escrever

(cid:107)A(cid:107)2 = max
(cid:107)x(cid:107)=1

(cid:107)Ax(cid:107) (∗)

com efeito, dado o vetor unit´ario v, o fator de dilata¸c˜ao (cid:15) de um vetor x na dire¸c˜ao de v
´e dado por

(cid:15) =

(cid:107)Ax(cid:107)
(cid:107)x(cid:107)

=

(cid:107)Aδv(cid:107)
(cid:107)δv(cid:107)

=

|δ|(cid:107)Av(cid:107)
|δ|(cid:107)v(cid:107)

= (cid:107)Av(cid:107)

Na pr´oxima proposi¸c˜ao, usaremos a express˜ao (*) no lugar da deﬁni¸c˜ao da norma

espectral.

Teorema 5.3. Para toda matriz A ∈ Rm×n com valores singulares σ1, · · · , σµ tem-se

(cid:107)A(cid:107)2 = σ1.

Demonstra¸c˜ao: Seja U SV T a SVD de A. Por deﬁni¸c˜ao, dado um vetor unit´ario x temos

(cid:107)Ax(cid:107)2 = (U SV Tx)T(U SV Tx) = xTV STU TU SV Tx = xTV STSV Tx

Fazendo y = V Tx notamos que (cid:107)y(cid:107) = 1 e que a ´ultima express˜ao nas igualdades acima
assume a forma

(cid:107)Ax(cid:107)2 = yT

σ2
1

. . .



















σ2
µ

. . .

0

y = σ2

1y2

1 + · · · + σ2

µy2
µ

onde yT = [y1, . . . , yn]. Como σ2
para i = 1, . . . , n, fornece

i y2

i ≤ σ2

1y2

i , o somat´orio dos termos destas desigualdades,

(cid:107)Ax(cid:107)2 = σ2

1y2

1 + · · · + σ2

r y2

r ≤ σ2

1y2

1 + · · · + σ2

1y2

n = σ2

1(y2

1 + · · · + y2

n) = σ2
1

5.2 NORMAS E SVD

44

logo, (cid:107)Ax(cid:107) ≤ σ1 e visto que para x = V [1 0 · · · 0]T a norma de Ax alcan¸ca σ1, conclu´ımos
que

(cid:107)A(cid:107)2 = max
(cid:107)x(cid:107)=1

(cid:107)Ax(cid:107) = σ1

(cid:3)

A norma de Frobenius ´e uma extens˜ao da norma vetorial euclidiana, portanto, ´e
poss´ıvel falar de distˆancia entre matrizes num sentido alg´ebrico muito pr´oximo da distˆancia
entre vetores, como veremos adiante.

Deﬁni¸c˜ao 5.5. A norma de Frobenius de uma matriz ´e o n´umero real denotado por
(cid:107)A(cid:107)F e dado pela express˜ao

(cid:107)A(cid:107)F = (cid:112)tr(ATA).

Fazendo A = [ai

deﬁni¸c˜ao acima,

· · · an], ai ∈ Rm e ATA = [a(cid:48)

ij]m×n, segue que a(cid:48)

ij = aT

i aj e, pela

(cid:107)A(cid:107)F = (cid:112)tr(ATA) =

(cid:113)

aT
1 a1 + · · · + aT

nan = (cid:112)(cid:107)a1(cid:107)2 + · · · + (cid:107)an(cid:107)2.

A ´ultima igualdade evidencia que a norma vetorial ´e um caso particular da norma de
Frobenius. Relacionaremos a norma de Frobenius de uma matriz a seus valores singulares,
para estabelecer esta rela¸c˜ao, valeremo-nos do lema a seguir.
Lema 5.2.1. Sejam P e Q matrizes ortogonais. Para uma dada matriz A ∈ Rm×n, tem-se

(cid:107)A(cid:107)F = (cid:107)P A(cid:107)F = (cid:107)AQ(cid:107)F .

Demonstra¸c˜ao: Por deﬁni¸c˜ao,

(cid:107)P A(cid:107)2

F = tr((P A)T(P A)) = tr(ATP TP A) = tr(ATA) = (cid:107)A(cid:107)F .

Para a segunda igualdade, observemos que tr(A) = tr(AT), assim

(cid:107)AQ(cid:107)F = (cid:107)(AQ)T(cid:107)F = (cid:107)QTAT(cid:107)F = (cid:107)AT(cid:107)F = (cid:107)A(cid:107)F

. (cid:3)

Teorema 5.4. Uma matriz A, de valores singulares σ1, . . . , σµ, tem sua norma de Fro-
benius dada por

(cid:113)

(cid:107)A(cid:107)F =

σ2
1 + · · · + σ2
µ

Demonstra¸c˜ao: Seja A = U SV T a SVD de A.

(cid:107)A(cid:107)2

F = tr(ATA)

= tr((U SV T)T(U SV T))
= tr(V STSV T)
= tr(STS)
= σ2

1 + · · · + σ2
µ

(5.1)
(5.2)

5.3 DISTANCIA M´INIMA ENTRE MATRIZES DE POSTOS DIFERENTES

45

A sequˆencia entre as igualdades 5.1 e 5.2 deveu-se ao lema 5.2.1. Da ´ultima desigual-
µ. (cid:3)

dade acima, temos (cid:107)A(cid:107)F =

σ2
1 + · · · + σ2

(cid:113)

Atrav´es da instru¸c˜ao norm(A), n´os podemos calcular a norma espectral da matriz A.
Inserindo "fro" como segundo argumento, o comando norm(A,"fro") retorna a norma
de Frobenius de A.

Exemplo 5.2.1. : norm

Obtendo, respectivamente, a norma espectral e de Frobenius da matriz A.
>A=[7,1;0,0;5,5], norm(A), norm(A,"fro")

A =

7
0
5

1
0
5
ans = 9.4868
ans =10

5.3 DISTANCIA M´INIMA ENTRE MATRIZES DE POSTOS DIFERENTES

Podemos enxergar a norma de Frobenius de uma matriz como a medida do qu˜ao
distante esta se encontra da matriz nula. ´E natural, ent˜ao, deﬁnir a distˆancia d(A, B)
entre as matrizes A e B em Rm×n, como

Deﬁni¸c˜ao 5.6. d(A, B) = (cid:107)A − B(cid:107)F

O objetivo desta se¸c˜ao ser´a estabelecer, para uma dada matriz A, a existˆencia de uma

matriz B de posto p < P(A), tal que

d(A, B) = min
P(X)≤p

(cid:107)A − X(cid:107)F .

A pr´oxima deﬁni¸c˜ao descreve a matriz para a qual tal distˆancia m´ınima ´e alcan¸cada.

Deﬁni¸c˜ao 5.7. Seja A uma matriz m × n de posto r e A = σ1u1vT
SVD . Ap = σ1u1vT
A.

r sua
p , com p < r, ´e a aproxima¸c˜ao de posto p pela SVD de

1 + · · · + σrurvT

1 + · · · + σpupvT

p+1 + · · · + σrurvT

Visto que A − Ap = σp+1up+1vT

u(cid:48)
i = up+i e v(cid:48)
Decorre dos dois ´ultimos teoremas que (cid:107)A − Ap(cid:107)2 = σp+1 e (cid:107)A − Ap(cid:107)2

i = σp+i,
i = vp+i permite a visualiza¸c˜ao deste somat´orio como a SVD de A − Ap.
p+1 + · · · + σ2
r .
O pr´oximo teorema aﬁrma que Ar ´e a matriz de posto r mais pr´oxima de A, se-
gundo a norma de Frobenius. Para demonstrar tal resultado, estabeleceremos atrav´es
dos pr´oximos trˆes lemas que dada uma matriz B de posto n˜ao maior do que p temos
σi(A − B) ≥ σp+i(A).

r , a mudan¸ca de ´ındices σ(cid:48)

F = σ2

5.3 DISTANCIA M´INIMA ENTRE MATRIZES DE POSTOS DIFERENTES

46

Lema 5.3.1. Sejam A e B matrizes em Rm×n. Considerando o posto de B menor ou
igual a p segue que

σ1(A − B) ≥ σp+1(A).

Demonstra¸c˜ao: Fazendo p = n, m n˜ao poder´a ser menor do que n, portanto P(A) <
n + 1 o que implica em σp+1(A − B) = σn+1(A) = 0 e da´ı σ1(A − B) ≥ σp+1(A).

Seja agora p < n. Mostramos a existˆencia de um vetor w ao qual σ1(A − B) ≥
(cid:107)Aw(cid:107) ≥ σp+1(A). Dado que P(B) ≤ p o teorema do n´ucleo e da imagem nos garante que
dim N(B) ≥ n − p > 0 e portanto N(B) (cid:54)= {0}. Sejam v1, . . . , vn os vetores singulares
direitos de A. Como dim G{v1, . . . , vp+1} + dim N(B) > n segue que G{v1, . . . , vp+1} e
N(B) possuem em comum um subespa¸co W no qual podemos escolher um vetor unit´ario
w que satisfaz as condi¸c˜oes propostas. Com efeito, visto que w ∈ N(B), temos

(cid:107)(A − B)w(cid:107)2 = wT(A − B)T(A − B)w

= (cid:0)(Aw)T − (Bw)T(cid:1)(cid:0)Aw − Bw(cid:1)
= wTATAw
= (cid:107)Aw(cid:107)2

(5.3)

Pelo teorema 5.3, (σ1(A − B))2 = (cid:107)A − B(cid:107)2

2. A deﬁni¸c˜ao de norma espectral e o fato

de w ser unit´ario garantem que

(σ1(A − B))2 = (cid:107)A − B(cid:107)2

2 ≥ (cid:107)(A − B)w(cid:107)2

e pela igualdade 5.3

(σ1(A − B))2 ≥ (cid:107)Aw(cid:107)2.

Como elemento de G{v1, . . . , vp+1}, w pode ser escrito como w = w1v1 + · · · +

wp+1vp+1. Considerando σ1u1vT

1 + · · · + σµuµvT

µ a SVD de A, temos que

Aw =

µ
(cid:88)

i=1

σiuivT

i w

E como w ´e ortogonal a todo vj, p + 1 < j ≤ µ, obtemos as igualdades

donde

Aw =

p+1
(cid:88)

i=1

σiuivT

i w =

p+1
(cid:88)

i=1

σiwiui

(cid:107)Aw(cid:107)2 = (Aw)T(Aw)

=

=

(cid:32) p+1
(cid:88)

i=1

σiwiuT
i

(cid:33)(cid:32) p+1
(cid:88)

j=1

(cid:33)

σjwjuj

p+1
(cid:88)

i,j=1

σiσj wiwj uT

i uj

5.3 DISTANCIA M´INIMA ENTRE MATRIZES DE POSTOS DIFERENTES

47

como uT

i uj = 0 sempre que i (cid:54)= j, segue que

(cid:107)Aw(cid:107)2 =

p+1
(cid:88)

i=1

i w2
σ2

i ≥

p+1
(cid:88)

i=1

p+1w2
σ2
i

como w2

1 + · · · + w2

p+1 = 1, obtemos

e portanto

donde segue que

(cid:107)Aw(cid:107)2 ≥ σ2

p+1

(σ1(A − B))2 ≥ (cid:107)Aw(cid:107)2 ≥ (σp+1(A))2

σ1(A − B) ≥ σp+1(A);

como quer´ıamos provar. (cid:3)

Lema 5.3.2. Se A = A(cid:48) + A(cid:48)(cid:48), ent˜ao, quaisquer que sejam i, j pertencentes ao conjunto
de n´umeros naturais, σi+j−1(A) ≤ σi(A(cid:48)) + σj(A(cid:48)(cid:48)).

Demonstra¸c˜ao: Inicialmente, nota-se que dados vetores unit´arios u e v tem-se

uTAv = (cid:107)Av(cid:107) cos θ ≤ (cid:107)Av(cid:107) ≤ σ1(A),

onde θ ´e o ˆangulo entre u e v.

Assim, para o caso em que i = j = 1 teremos

σ1(A) = u1Av1

1 (A(cid:48) + A(cid:48)(cid:48))v1
= uT
= uT
1 A(cid:48)v1 + uT
1 A(cid:48)(cid:48)v1
≤ σ1(A(cid:48)) + σ1(A(cid:48)(cid:48)),

(5.4)

e conforme visto nos coment´arios que sucederam a deﬁni¸c˜ao 5.7, σp+1(A) = σ1(A − Ap),
tem-se

σi(A(cid:48)) + σj(A(cid:48)(cid:48)) = σ1(A(cid:48) − A(cid:48)

i−1) + σ1(A(cid:48)(cid:48) − A(cid:48)(cid:48)

j−1)

e a desigualdade em 5.4 permite-nos fazer

σi(A(cid:48)) + σj(A(cid:48)(cid:48)) ≥ σ1

(cid:0)A(cid:48) + A(cid:48)(cid:48) − (A(cid:48)

i−1 + A(cid:48)(cid:48)

j−1)(cid:1).

De fato, P(A(cid:48)

i−1 + A(cid:48)(cid:48)

j−1) ≤ i + j − 2, por isso, o lema 5.3.1 pode ser aplicado no ´ultimo

termo da desigualdade acima, deixando-o como

σ1

(cid:0)A(cid:48) + A(cid:48)(cid:48) − (A(cid:48)

i−1 + A(cid:48)(cid:48)

j−1)(cid:1) ≥ σ(i+j−2)+1(A(cid:48) + A(cid:48)(cid:48)) = σi+j−1(A)

da?, σ+j−1(A) ≤ σi(A(cid:48)) + σj(A(cid:48)(cid:48)). (cid:3)

5.3 DISTANCIA M´INIMA ENTRE MATRIZES DE POSTOS DIFERENTES

48

Lema 5.3.3. Teremos σi(A − B) ≥ σp+i(A) para quaisquer matrizes A e B em Rm×n,
com P(B) ≤ p.

Demonstra¸c˜ao: De P(B) ≤ p observamos que σp+1(B) = 0. Aplicando o lema 5.3.2
com A(cid:48) = A − B e A” = B, obtemos

σi(A − B) = σi(A − B) + σp+1(B) ≥ σi+p+1−1

(cid:0)(A − B) + B(cid:1) = σp+i(A).

(cid:3)

Por ﬁm, o pr´oximo teorema estabelece que a menor distˆancia de uma matriz Am×n, de
posto r, com µ = min{m, n}, a uma matriz B, de posto p n˜ao maior que r, ´e alcan¸cada
quando B = Ap.

Teorema 5.5. Sejam A e B matrizes tal como descritas acima.

Demonstra¸c˜ao: Pelo teorema 5.4,

(cid:107)A − B(cid:107)F ≥ (cid:107)A − Ap(cid:107)F .

(cid:107)A − B(cid:107)2

F =

µ
(cid:88)

i=1

σi(A − B)2.

Aplicando o lema 5.3.3 no lado direito desta igualdade,ﬁcamos com

(cid:107)A − B(cid:107)2

F = σ1(A − B)2 + · · · + σµ(A − B)2

≥ σp+1(A)2 + · · · + σµ(A)2
= (cid:107)A − Ap(cid:107)2
F .

(cid:3)

CAP´ITULO 6

A SVD E A COMPRESS˜AO DE IMAGENS DIGITAIS

Como j´a foi dito, uma imagem digital ´e gerada pelo computador a partir de uma
matriz, vista agora como um cojunto de dados. Desta forma, a compress˜ao de imagens
digitais corresponde, estat´ısticamente falando, a redu¸c˜ao das informa¸c˜oes contidas na
matriz de dados, de modo que os dados resultantes ainda sejam capazes de transmitir
a maior parte da informa¸c˜ao contida na matriz original. Em computa¸c˜ao gr´aﬁca, esta
redu¸c˜ao ´e chamada de compress˜ao com perda (da informa¸c˜ao). Veremos neste cap´ıtulo
um m´etodo de redu¸c˜ao com perda que baseia-se no truncamento da matriz de dados,
processo em que A, matriz correspondente a uma imagem, ´e substituida por alguma
aproxima¸c˜ao por sua SVD .

O posto de uma matriz determina a quantidade de informa¸c˜ao nescess´aria para em
sua representa¸c˜ao. Para uma matriz Am×n, por exemplo, teoricamente necessitamos de
mn dados, correspondentes as entradas de A, para descrevˆe-la. O posto de A, sendo
menor do que µ, pemite que voltemo-nos a obten¸c˜ao de p vetores L.I. em A, aos quais
ser˜ao registradas suas pm entradas, deixando os demais n − p vetores serem dados pelos
coeﬁciente das combina¸c˜oes lineares entre os L.I.. O esquema abaixo exibe o n´umero de
dados em cada conjunto de linhas e colunas.

(cid:110)(cid:104)

m

(cid:122)
a1
(cid:124)

n
(cid:125)(cid:124)
(cid:12)
(cid:12) ap+1
(cid:124)

· · · an
(cid:123)(cid:122)
n−p

(cid:123)

(cid:105)

(cid:125)

· · · ap
(cid:123)(cid:122)
p

(cid:125)

A quantidade de informa¸c˜ao contida na matriz A ´e dada pela express˜ao mp + p(n − p) =
p(m + n − p) que, por sua vez, assume µ como valor m´aximo.

Pela SVD entretanto, o vetor A ´e dado por p vetores ortogonais do Rm, u1, . . . , up,
e p vetores ortogonais do Rm, σ1v1, . . . , σpvp. Com isso, para salvar toda a informa¸c˜ao
contida em A ´e suﬁciente que o computador guarde todas as entradas de u1 e σ1v1, todas
as entradas de u2 e σ2v2, exceto uma de cada, que podem ser determinadas a partir das
equa¸c˜oes

uT

1 u2 = 0

e

(σ1v1)T(σ2v2) = 0,

todas as entradas de u3 e σ3v3, exceto duas em cada vetor, as quais s˜ao obtidas mediante
os sistemas

(cid:26) uT
uT

1 u3 = 0
2 u3 = 0

e

(cid:26) (σ1v1)T(σ3v3) = 0
(σ2v2)T(σ3v3) = 0

Enﬁm, para os vetores ui e σivi salvam-se suas entradas, exceto i − 1 em cada vetor,

que s˜ao facilmente calculadas pelo computador atrav´es dos sistemas






uT

1 ui = 0
...
i−1ui = 0

uT

(σ1v1)T(σivi) = 0

...

(σi−1vi−1)T(σivi) = 0

e






49

A SVD E A COMPRESS ˜AO DE IMAGENS DIGITAIS

50

Constitu´ıdos atrav´es dos vetores j´a obtidos Rm, u1, . . . , ui−1 e σ1v1, . . . , σpvi−1. A quan-
tidade de informa¸c˜ao suﬁciente para descrever cada conjunto de vetores ´e dada por

m + (m − 1) + · · · + (m − (p − 1)) = pm −

p(p − 1)
2

n + (n − 1) + · · · + (n − (p − 1)) = pn −

p(p − 1)
2

e assim, a quantidade de informa¸c˜ao contida em A, dada pela sua SVD , totaliza p(m +
n − p + 1) dados.

Embora o n´umero p(m + n − p + 1) seja maior do que p(m + n − p), obtido pelo
isolamento de p vetores L.I., a superioridade da SVD na compress˜ao de imagens reside
em sua capacidade de redu¸c˜ao de dados com o m´ınimo de comprometimento da qualidade
destas.

Ao substituirmos A, uma matriz associada a uma imagem em escala de cinza, por
Ak, sua aproxima¸c˜ao de posto k pela SVD , com k < P(A), estaremos obtendo uma
imagem com uma quantidade menor de informa¸c˜ao, e no entanto, interpretando segundo
o resultado do teorema 5.5, tal imagem, dentre todas que possuem a mesma quantidade
de informa¸c˜ao, ´e a que mais se assemelha a original. No octave, obteremos Ak mediante
a fun¸c˜ao apsvd descrita no exemplo 6.0.1.

Exemplo 6.0.1. : Fun¸c˜ao apsvd

Retorna Ak, a aproxima¸c˜ao de posto k pela SVD de A.
>function Y=apsvd(A,k)
>[m n c]=size(A);
>for i=1:c
>[U(:,:,i) S(:,:,i) V(:,:,i)]=svd(double(A(:,:,i)));
>Y(:,:,i)=U(:,1:k,i)*S(1:k,1:k,i)*V(:,1:k,i)’;
>endfor
>endfunction

A aproxima¸c˜ao obtida pela fun¸c˜ao apsvd, Vale para matrizes associadas a imagens
em escala de cinza e associadas a imagens coloridas, para estas, calcula-se a aproxima¸c˜ao
de posto k pela SVD de cada componente RGB.

Exemplo 6.0.2.

Obtendo o truncamento da imagem lena com k valores singulares.

Figura 6.1

>A=imread(lenaGray.png);
>A 50=apsvd(A,50);
>imwrite(uint8(A 50),"lenaGraySVD50.jpg")

Na ﬁgura 6.1, temos um exemplo de compress˜ao por truncamento da matriz utili-
zando 50 valores singulares em uma imagem com tamanho 512 × 512. Uma quest˜ao que
se apresenta naturalmente ´e se a SVD ´e igualmente eﬁciente para comprimir qualquer

A SVD E A COMPRESS ˜AO DE IMAGENS DIGITAIS

51

(a) Original: lena

(b) Imagem reconstru´ıda com 50 valores singulares

Figura 6.1

imagem. Para respondˆe-la, valeremo-nos de ferramentas para decidir o qu˜ao boa ´e uma
compress˜ao por truncamento da matriz de dados.

A raz˜ao de compress˜ao ´e o quociente ente a quantidade de informa¸c˜ao na imagem
comprimida e a quantidade de informa¸c˜ao na imagem original. Dada A ∈ Rm×n a raz˜ao
de compress˜ao de Ak ´e dada por k(m + n − k + 1)/mn.

Exemplo 6.0.3. : Fun¸c˜ao razao de compressao
Retorna a raz˜ao de compress˜ao de uma matriz com as dimens˜oes de A quando truncada
para a matriz Ak.
>function y=razao de compressao(A,k)
>[m,n]=size(A);
>y=k*(m+n+1-k)/(m*n);
>endfunction

O uso de tal raz˜ao ´e justiﬁcado apenas quando k(m + n − k + 1) < mn (**). Com
o ﬁm de estabelecer os valores de k que validam tal desigualdade, n´os a reescrevemos da
seguinte maneira:

k2 − (m + n + 1)k + mn > 0.

E da´ı obtemos as desigualdades

k <

(m + n + 1) − (cid:112)(m + n + 1)2 − 4mn
2

ou k >

(m + n + 1) + (cid:112)(m + n + 1)2 − 4mn
2

.

Visto que

k >

(m + n + 1) + (cid:112)(m + n + 1)2 − 4mn
2

>

m + n + 1
2

A SVD E A COMPRESS ˜AO DE IMAGENS DIGITAIS

52

k <

e quando substitu´ımos k por (m + n + 1)/2 n˜ao ocorre compress˜ao, pois k(m + n − k + 1)
torna-se (m + n + 1)2/4 > mn, por conseguinte, a express˜ao (**) ´e verdadeira apenas
quando

(m + n + 1) − (cid:112)(m + n + 1)2 − 4mn
2
A express˜ao no lado direito da desigualdade ´e o valor cr´ıtico da imagem, cujo c´alculo
no octave ´e feito atrav´es da fun¸c˜ao deﬁnida no exemplo 3.3.1. A raz˜ao de compress˜ao
expressa, em percentual, a quantidade de informa¸c˜ao em Ak comparada a quantidade
de informa¸c˜ao em A. Este percentual n˜ao deve ser confundido com um percentual da
quantidade de informa¸c˜ao de A utilizada, visto que estamos usando codiﬁca¸c˜oes diferentes
para A e Ak. Na ﬁgura 6.1 a raz˜ao de compress˜ao obtida com o uso de 50 valores singulares
foi de, aproximadamente, 18, 5%, conforme exibido no exemplo a seguir.

.

Exemplo 6.0.4.

Calculando o valor cr´ıtico da imagem ’lena’, bem como sua raz˜ao de compress˜ao para o
truncamento com 50 valores singulares.
Figura 6.1

>I=imread("lena512.bmp"); >valor critico(I)
ans = 489.87
>razao de compressao(I,50)
ans = 0.18597

Para uma medida do quanto ´e perdido em uma imagem ap´os o truncamento de sua
matriz de dados, usaremos o conceito de erro relativo referente a norma de Frobenius.
O erro cometido ao substituir A por Ak ´e, segundo a norma de Frobenius, dado por
(cid:107)A − Ak(cid:107)F . O erro relativo corresponde a raz˜ao (cid:107)A − Ak(cid:107)F /(cid:107)A(cid:107)F e torna-se maior con-
forme k se aproxime de 1.

Exemplo 6.0.5. : Fun¸c˜ao erro relativo
Retorna o erro relativo cometido ao substituir A por Ak.
>function y=erro relativo(A,k)
>y=norm(double(A)-apsvd(A,k),"fro")/norm(double(A),"fro");
>endfunction

Exemplo 6.0.6.

Calculando o erro relativo da imagem I da ﬁgura 6.1, cometido quando substituimos I
por I50.
Figura 6.1
> erro relativo(I,50)
ans = 0.059439

J´a as imagens da ﬁgura 6.2 possuem as mesmas dimens˜oes daquelas na ﬁgura 6.1 e
tamb´em foi feita uma reconstru¸c˜ao com 50 valores singulares, ou seja, obtemos a mesma
raz˜ao de compress˜ao pr´oxima de 18, 5%, e no entanto, conforme calculado no exemplo
5.0.7, o erro relativo cometido foi de 13, 3%.

A SVD E A COMPRESS ˜AO DE IMAGENS DIGITAIS

53

(a) Original: mandril

(b) Reconstruida com 50 valores singulares

Figura 6.2

Exemplo 6.0.7.

Calculando o erro relativo da imagem na ﬁgura 6.2 quando tomamos sua aproxima¸c˜ao de
posto 50 pela SVD e obtendo tal aproxima¸c˜ao..
Figura 6.2

>M=imread("mandril.bmp");
>erro relativo(M,50)
ans = 0.13334
>imwrite(uint8(apsvd(M,50)),"mandrilSVD50.jpg")

N˜ao ´e nosso objetivo estabelecer rigorosamente as raz˜oes pelas quais se d˜ao diferentes
resultados na compress˜ao de imagens atrav´es do truncamento, no entanto, como o intuito
de ﬁrmar bases intuitivas para tal, exibiremos de que maneira se d´a a perda de informa¸c˜ao
na compress˜ao usando a aproxima¸c˜ao pela SVD . Faremos isso analisando como ocor-
reria o ganho de informa¸c˜ao na imagem partindo da matriz A1, a qual representa uma
compress˜ao m´axima, e reconstruindo-a at´e a matriz Ak.

Primeiramente observemos que dada uma matriz m × n A de posto p, em sua SVD
dada por A = σ1u1v1 + · · · + σpupvT
i possuem posto e
i = [v1i, . . . , vni], o produto uivT
norma de Frobenius iguais a 1. Com efeito, sendo vT
i
ﬁca expresso como uivT
i . Vimos
na se¸c˜ao 5.2 que a norma de Frobenius pode ser calculada a partir das colunas de uivT
i
como

i = [v1iui, . . . , vniui], o que evidencia o posto 1 de uivT

p cada uma das matrizes uivT

(cid:107)uivT

i (cid:107)2

F = (cid:107)v1iui(cid:107)2 + · · · + (cid:107)vniui(cid:107)2 = (v2

1i + · · · + v2

ni)(cid:107)ui(cid:107)2 = (cid:107)vT
i (cid:107)2 = 1. Assim, cada componente σiuivi da

i (cid:107)2(cid:107)ui(cid:107)2

e portanto, por vi e ui serem unit´arios, (cid:107)uivT
SVD de A ´e uma matriz de posto 1 e norma de Frobenius igual a σi.

A SVD E A COMPRESS ˜AO DE IMAGENS DIGITAIS

54

(a) valores singulares ‘lena’

(b) valores singulares ‘mandril’

Figura 6.3

A distribui¸c˜ao dos valores singulares nas imagens ‘lena’ e ‘mandril’ s˜ao exibidas na
ﬁgura 6.3. Na ﬁgura 6.3(a) temos o gr´aﬁco dos valores singulares da imagem ’lena’ e na
ﬁgura 6.3(b) o gr´aﬁco dos valores singulares da imagem “mandril”. ´e poss´ıvel notar nas
duas ﬁguras a importˆancia dos primeiros valores singulares na composi¸c˜ao da imagem,
sobretudo do primeiro. O gr´aﬁco na ﬁgura 6.4(b) corresponde a uma plotagem dos
valores singulares da imagem na ﬁgura 6.4(a) de mesmas dimens˜oes das imagens citadas
anteriormente e gerada mediante o comando rand. Fizemos sua reconstru¸c˜ao com 50
valores singulares e obtivemos um erro relativo de 42%.

Baseando-nos no que foi exibido nos dois par´agrafos precedentes, podemos enxergar
a imagem gerada por A1 = σ1u1vT
1 como a base sobre a qual ser˜ao feitas melhores apro-
xima¸c˜oes de A, visto que A1 re´une uma parcela signiﬁcativa da informa¸c˜ao contida em
A. Tais aproxima¸c˜oes tornam-se melhores conforme inclu´ımos detalhes a A1, mediante
a adi¸c˜ao das matrizes de posto 1, σiuivT
i . Pela an´alise dos gr´aﬁcos de valores singula-
res, notamos que a relevncia de tais detalhes para a aproxima¸c˜ao da imagem A por Ai
dependem do qu˜ao grande seja o valor da raz˜ao σi/(cid:107)A(cid:107)F , visto que (cid:107)σiuivT
i (cid:107)F = σi. A
eﬁciˆencia na compress˜ao de imagens fotogr´aﬁcas pela substitui¸c˜ao de A por Ak ocorre de-
vido a existˆencia de grandes regi˜oes com tons de intensidade muito pr´oximas. Na imagem
’lena’, por exemplo, muitos pixeis correspondentes ao tom da pele da modelo s˜ao iguais
ou parecidos, decorre que a perda de detalhes nessa regi˜ao n˜ao compromete a visualiza¸c˜ao
ﬁnal da imagem.

Na ﬁgura 6.5 vemos as vinte e uma primeiras etapas de como ´e “montada”a imagem
’lena’ pelos seus valores singulares. O erro relativo para 1 valor singular ´e de 31% e o
erro relativo cometido pelo truncamento com 21 valores singulares ´e de um pouco mais
de 10%.

A compress˜ao por truncamento de uma imagem colorida ser´a feita aplicando o trun-
camento a cada componente RGB da imagem. A raz˜ao de compress˜ao de uma imagem
colorida m × n comprimida como k valores singulares igual a raz˜ao de compress˜ao de
uma imagem em tons de cinza m × n comprimida com a mesma quantidade de valo-

A SVD E A COMPRESS ˜AO DE IMAGENS DIGITAIS

55

(a) Imagem randˆomica

(b) valores singulares da imagem randˆomica

Figura 6.4

res singulares. A norma de Frobenius ser´a estendida para uma matriz 3d I da seguinte
maneira:

(cid:113)

(cid:107)I(cid:107)F =

(cid:107)R(cid:107)2

F + (cid:107)G(cid:107)2

F + (cid:107)B(cid:107)2
F

onde R, G e B s˜ao, respectivamente, as matrizes das componentes vermelha, verde e
azul da matriz I. Por meio desta norma, ﬁca deﬁnido o erro relativo cometido pelo
truncamento de uma imagem colorida mediante a instru¸c˜ao exposta no exemplo 6.0.8.

Exemplo 6.0.8. : Fun¸c˜ao erro relativo2

Retorna o erro relativo cometido ao substituir A por Ak quando A ´e uma imagem colorida.
>function y=erro relativo2(X,k)
>A=double(X);
>a=norm(A(:,:,1)-apsvd(A(:,:,1),k),"fro");
>b=norm(A(:,:,2)-apsvd(A(:,:,2),k),"fro");
>c=norm(A(:,:,3)-apsvd(A(:,:,3),k),"fro");
>d=norm(A(:,:,1),"fro")^2+norm(A(:,:,2),"fro")^2+norm(A(:,:,3),"fro")^2;
>y=sqrt(a^2+b^2+c^2/d)
>endfunction

Por ﬁm, segue na ﬁgura 6.6 o resultado de uma compress˜ao a raz˜ao de 50%, na qual
obtivemos o erro relativo de 2, 2%. Vale mencionar que esta imagem reconstru´ıda com
150 valores singulares ´e praticamente indistingu´ıvel da original.

Figura 6.5

(a) Original

(b) Reconstruida com 150 valores singulares

Figura 6.6

REFERˆENCIAS BIBLIOGR´AFICAS

[1] GOMES, Jorge; VELHO, Luiz. Computa¸c˜ao Gr´aﬁca: Imagem. 2 ed. Rio de Janeiro:

IMPA, 2002.

[2] LIMA, Elon Lages. ´Algebra Linear. 8 ed. Rio de janeiro: IMPA, 2014.

[3] LAY, David C; tradu¸c˜ao de Val´eria de Magalh˜aes Iorio. ´Algebra linear e suas

aplica¸c˜oes. 4 ed. Rio de Janeiro, LTC, 2013.

[4] HEFEZ, Abramo; FERNANDEZ, Cec´ılia S. Introdu¸c˜ao `a ´Algebra Linear. Rio de

Janeiro: SBM, 2012.

[5] ARA ´UJO, Thelmo de. ´Algebra Linear: Teoria e Aplica¸c˜oes. Rio de Janeiro: SBM,

2014.

[6] TEIXEIRA, Sergio Roberto. Octave:

Uma

Introdu¸c˜ao. Dispon´ıvel

http://www.rodrigofernandez.com.br/ecomp/ref/octave-ﬁnal.pdf.
29 de Julho de 2015.

Acesso

em
em

57

