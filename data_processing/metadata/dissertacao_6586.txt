UNIVERSIDADE FEDERAL DE CAMPINA GRANDE

Programa de Pós-Graduação em Matemática

Mestrado Proﬁssional - PROFMAT/CCT/UFCG

Maria Eduarda de Oliveira Gomes

Os Números Binários Aplicados à Computação

Campina Grande - PB

Junho/2021

G633n 

Gomes, Maria Eduarda de Oliveira. 
       Os  números  binários  aplicados  à  computação  /  Maria  Eduarda  de 
Oliveira Gomes. – Campina Grande, 2021. 
        109 f. : il. color.    

        Dissertação  (Mestrado  em  Matemática)  –  Universidade  Federal  de 
Campina Grande, Centro de Ciências e Tecnologia, 2021.  
       "Orientação: Prof. Dr. José de Arimatéia Fernandes”. 

   Referências. 

       1.  Álgebra  de  Boole.  2.  Números  Binários.  3.  Unicode.  4.  Código 
ASCII. 5. Computação – Padrão UTf-8. I. Fernandes, José de Arimatéia. 
II. Título. 

                                                                            CDU 517.987.3(043) 

FICHA CATALOGRÁFICA ELABORADA PELA BIBLIOTECÁRIA SEVERINA SUELI DA SILVA OLIVEIRA CRB-15/225 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                                                     
 
 
    
 
UNIVERSIDADE FEDERAL DE CAMPINA GRANDE

Programa de Pós-Graduação em Matemática

Mestrado Proﬁssional - PROFMAT/CCT/UFCG

Maria Eduarda de Oliveira Gomes

Os Números Binários Aplicados à Computação

Trabalho de Conclusão de Curso apresen-
tado ao Corpo Docente do Programa de
Pós-Graduação em Matemática - CCT -
UFCG, na modalidade Mestrado Proﬁs-
sional, como requisito parcial para obtenção
do título de Mestre.

Orientador: Prof. Dr. José de Arimatéia Fernandes

Campina Grande - PB
Junho/2021

Honro o fechamento deste ciclo dedicando este trabalho a todos os professores que tive
ao longo dos meus 23 anos de idade, sobretudo aqueles que ultrapassaram as barreiras
do conhecimento cientíﬁco e serviram como fonte de inspiração e motivação para
minha evolução pessoal, acadêmica e proﬁssional. De maneira especial, dedico à
minha mãe Agueda e minhas tias Luciene e Leoneide, minhas primeiras professoras,
que me ensinaram as primeiras letras e os primeiros números, me fazendo, logo cedo,
despertar uma paixão pela matemática.

Agradecimentos

Após dois anos de muito estudo e dedicação, chego ao ﬁnal deste curso de mestrado,
e não poderia deixar de agradecer a algumas pessoas que estiveram comigo e foram
essenciais no decorrer deste período. Por isso, através de poucas, mas sinceras palavras,
destaco e agradeço a importância que elas tiveram nesta consquista e continuam tendo
na minha vida.

Antes, porém, elevo meus pensamentos aos céus, e, humildemente, agradeço a Deus,
ser onipotente, o mestre dos mestres, pela dádiva da vida e por ter me mantido na trilha
correta durante esta etapa acadêmica, sobretudo no decorrer desta pesquisa, me dando
saúde, forças e sabedoria para chegar ao ﬁm, me permitindo, assim, realizar este sonho
nesta existência.

Agora, um agradecimento todo especial, cheio de amor e gratidão, vai para a minha
família, de maneira única e especial para a minha mãe Agueda, pelo amor incondicional,
dedicação, cuidado e por tudo que ela sempre fez por mim, principalmente por ter me
ofertado uma educação de qualidade; e para a minha amada irmã Maria Eloísa, pelo
companheirismo, parceria e por inúmeras vezes ter me compreendido, suprindo a minha
ausência em casa. A vocês, e aos demais membros da minha família materna, serei
eternamente grata por tudo que sou, por tudo que consegui conquistar e pelo carinho
sempre dedicado a mim.

Aos meus amigos, pessoas que não tenho palavras para deﬁnir e descrever o quão
importantes eles são em minha vida. Aqui destaco Andréa, Francisca e a pequena Ana
Júlia, as quais quero agradecer, sobretudo, pela amizade, companheirismo, cumplici-
dade e incentivo de sempre.

A todos que fazem a Escola Monsenhor, pela compreensão das minhas ausências
nas sextas-feiras, onde agradeço na pessoa da gestora e minha amiga Jussara, pessoa
que tenho grande respeito, admiração e estima.

Ao meu ex-professor Me. Bruno Lopes pelo incentivo e por ter me presenteado com

livros e apostilas muito úteis durante o curso.

Ao orientador da minha dissertação, Prof. Dr. José de Arimatéia Fernandes, pelos
importantes ensinamentos, valiosas contribuições e por todo empenho durante este
trabalho, para que, juntos, concluíssemos esta pesquisa.

Aos membros da Banca examinadora Prof. Dr. Rodrigo Cohen Mota Nemer e Prof.
Dr. Lenimar Nunes de Andrade, pelas observações e contribuições para melhoria deste
trabalho.

À UAMat/UFCG, pelo ensino de qualidade oferecido a toda comunidade acadêmica,

onde agradeço na pessoa do Coordenador do curso Prof. Dr. Romildo Lima.

Sou grata também a todos os professores que tive ao longo deste curso de mestrado,
por todo conhecimento transmitido a mim e a meus colegas colegas de turma, os quais
também agradeço pelo companheirismo acadêmico ao longo destes dois últimos anos.
À Sociedade Brasileira de Matemática - SBM, por oferecer o curso em rede nacional.
Por ﬁm, mas não menos importante, os meus agradecimentos vão para aquela ins-
tituição que me fez despertar uma maior admiração e amor pela matemática. Minha
eterna gratidão ao IFPE - Instituto Federal de Educação, Ciência e Tecnologia de
Pernambuco - Campus Pesqueira, por todos os importantes e valiosos conhecimentos
a mim ofertados durante a minha graduação.

“A Matemática é a única linguagem
que temos em comum com a natureza.”
- Stephen Hawking

Resumo

O presente trabalho de conclusão de curso tem como principal objetivo abordar con-
ceitos pertinentes ao sistema de numeração binário, enfatizando, sobretudo, como eles
são aplicados à computação. Através de um levantamento bibliográﬁco, ﬁcou consta-
tado como esses números são úteis no nosso cotidiano, tendo uma de suas principais
aplicações voltada para programação de equipamentos digitais, como computadores e
celulares, por exemplo, uma vez que estes dispositivos apenas entendem 0 e 1, isto é, a
linguagem binária. No entanto, é importante salientar que, dentro desse contexto, estes
números não exprimem quantidades, mas sim estados do sistema, que são compreen-
didos através da passagem de correntes elétricas ou da ausência dela, representando o
1 e o 0, respectivamente, assim como é sugerido pela Álgebra de Boole. Por ﬁm, será
mostrado como tudo isso é feito na prática através de um pequeno chip denominado
processador e fazendo uso do código ASCII e do Unicode, com ênfase para o padrão
UTF-8, utilizado mundialmente como linguagem padrão entre os computadores.

Palavras-chave: Números Binários. Álgebra de Boole. Unicode.

Abstract

The main objective of this course conclusion work is to address concepts relevant to the
binary numbering system, emphasizing, above all, how they are applied to computing.
Through a bibliographic survey, it was found how these numbers are useful in our daily
lives, having one of its main applications focused on programming digital equipment,
such as computers and cell phones, for example, since they only understand 0 and 1,
that is, the binary language. However, it is important to note that, within this context,
these numbers do not express quantities, but rather states of the system, which are
understood through the passage of electrical currents or the absence of it, representing
1 and 0, respectively, as suggested by Boole’s Algebra. Finally, it will be shown how
all this is done in practice through a small chip called a processor and making use
ASCII code and Unicode, with emphasis on the UTF-8 standard, used worldwide as a
standard language among computers.

Keywords: Binary Numbers. Boole Algebra. Unicode.

Lista de ilustrações

18
Figura 1 – Leibniz (1646 – 1716) . . . . . . . . . . . . . . . . . . . . . . . . . .
31
Figura 2 – George Boole (1815 – 1864) . . . . . . . . . . . . . . . . . . . . . .
55
. . . . . . . . . . . . . . . .
Figura 3 – Distribuição no mapa para 2 variáveis
55
. . . . . . . . . . . . . . . .
Figura 4 – Distribuição no mapa para 3 variáveis
56
. . . . . . . . . . . . . . .
Figura 5 – Possíveis agrupamentos para 3 variáveis
Figura 6 – Mapa de Karnaugh para função S = a · b · c + a · c0 + a · b0
57
. . . . .
Figura 7 – Mapa de Karnaugh para função S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0 58
60
Figura 8 – Portas lógicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
Figura 9 – Portas lógicas com o inversor aplicados diretamente na operação . .
61
Figura 10 – Circuito lógico D = A + B · C 0
. . . . . . . . . . . . . . . . . . . .
62
Figura 11 – Circuito lógico . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
Figura 12 – Circuito lógico . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
Figura 13 – Circuito lógico F = A0 · B + B · C 0 + A · B0 · C . . . . . . . . . . . .
64
Figura 14 – Circuito lógico F = A0 · B · C 0 + A0 · B · C + A · B0 · C + A · B · C 0 .
65
Figura 15 – Porta lógica do operador NOR . . . . . . . . . . . . . . . . . . . .
65
Figura 16 – Porta lógica do operador NAND . . . . . . . . . . . . . . . . . . . .
66
Figura 17 – Porta lógica do operador XOR . . . . . . . . . . . . . . . . . . . .
66
Figura 18 – Porta lógica do operador XNOR . . . . . . . . . . . . . . . . . . . .
68
Figura 19 – Circuito em Série . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
Figura 20 – Circuito em Paralelo . . . . . . . . . . . . . . . . . . . . . . . . . .
69
Figura 21 – Circuito Misto . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
Figura 22 – Circuito Inversor . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
Figura 23 – Circuito NAND . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
Figura 24 – Circuito NOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
. . . . . . . . . . . . .
Figura 25 – Barra de endereço de uma busca no Google
72
Figura 26 – Barra de endereço de uma busca no Google
. . . . . . . . . . . . .
73
. . . . . . . . . . . . . . . . . . .
Figura 27 – Jogo Boole - Diﬁculdade Normal
74
Figura 28 – Jogo Boole Resolvido - Diﬁculdade Normal . . . . . . . . . . . . . .
76
Figura 29 – Imagem Bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
. . . . . .
Figura 30 – Grandezas usadas para abreviar valores em computação
78
Figura 31 – Conversão de Bit para Byte . . . . . . . . . . . . . . . . . . . . . .
79
Figura 32 – Processador moderno . . . . . . . . . . . . . . . . . . . . . . . . . .
80
Figura 33 – Computador ENIAC . . . . . . . . . . . . . . . . . . . . . . . . . .
81
Figura 34 – Válvula termiônica . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
Figura 35 – Computador EDVAC . . . . . . . . . . . . . . . . . . . . . . . . . .

82
Figura 36 – Computador IBM 1401 . . . . . . . . . . . . . . . . . . . . . . . . .
83
Figura 37 – Computador System/360 . . . . . . . . . . . . . . . . . . . . . . . .
83
Figura 38 – Microprocessador . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
Figura 39 – Transistor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 40 – Arte ASCII com Mestre Yoda, de Star Wars . . . . . . . . . . . . .
87
Figura 41 – Tabela ASCII Estendida . . . . . . . . . . . . . . . . . . . . . . . . 102
Figura 42 – Tabela ASCII Estendida . . . . . . . . . . . . . . . . . . . . . . . . 103
Figura 43 – Tabela ASCII Estendida . . . . . . . . . . . . . . . . . . . . . . . . 104
Figura 44 – Legenda Unicode . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
Figura 45 – Controles C0 e latim básico . . . . . . . . . . . . . . . . . . . . . . 105
. . . . . . . . . . . . . . . . 106
Figura 46 – Controles C1 e suplemento de Latin-1
Figura 47 – Latim Extended-A . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
Figura 48 – Latim Extended-B . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
Figura 49 – Extensões IPA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
Figura 50 – Arábico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
Figura 51 – Grego e copta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
Figura 52 – Armênio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
Figura 53 – Hebraico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

Lista de tabelas

Tabela 1 – Soma lógica com duas variáveis . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
Tabela 2 – Soma lógica com três variáveis
Tabela 3 – Multiplicação lógica com duas variáveis . . . . . . . . . . . . . . . .
Tabela 4 – Multiplicação lógica com três variáveis . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . .
Tabela 5 – Negação lógica com uma variável
Tabela 6 – Tabelas verdades do axioma da comutatividade . . . . . . . . . . .
Tabela 7 – Tabelas verdades do axioma da distributividade . . . . . . . . . . .
Tabela 8 – Tabelas verdades dos elementos identidade . . . . . . . . . . . . . .
Tabela 9 – Tabelas verdades do complemento
. . . . . . . . . . . . . . . . . .
Tabela 10 – Tabela verdade de mintermos com 3 variáveis . . . . . . . . . . . .
Tabela 11 – Tabela verdade de maxtermos com 3 variáveis . . . . . . . . . . . .
Tabela 12 – Tabela verdade apresentando o valor ﬁnal Sn com 2 variáveis . . . .
Tabela 13 – Tabela verdade apresentando o valor ﬁnal Sn com 3 variáveis . . . .
Tabela 14 – Tabela verdade da função S = a · b · c + a · c0 + a · b0 . . . . . . . . .
Tabela 15 – Tabela verdade da função S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0
Tabela 16 – Tabela verdade do operador NOR com 2 variáveis . . . . . . . . . .
Tabela 17 – Tabela verdade do operador NAND com 2 variáveis . . . . . . . . .
Tabela 18 – Tabela verdade do operador XOR com 2 variáveis . . . . . . . . . .
Tabela 19 – Tabela verdade do operador XNOR com 2 variáveis . . . . . . . . .
Tabela 20 – Tabela verdade de um circuito em série . . . . . . . . . . . . . . . .
Tabela 21 – Tabela verdade de um circuito em série . . . . . . . . . . . . . . . .
Tabela 22 – Tabela verdade de um circuito inversor . . . . . . . . . . . . . . . .
Tabela 23 – Tabela verdade de um circuito NAND . . . . . . . . . . . . . . . .
Tabela 24 – Tabela verdade de um circuito NOR . . . . . . . . . . . . . . . . .
Tabela 25 – Possibilidades de agrupamentos de bits . . . . . . . . . . . . . . . .
Tabela 26 – Tabela ASCII - Caracteres não imprimíveis
. . . . . . . . . . . . .
Tabela 27 – Tabela ASCII - Caracteres imprimíveis . . . . . . . . . . . . . . . .
Tabela 28 – Tabela ASCII - Caracteres imprimíveis (Continuação)
Tabela 29 – Tabela ASCII - Caracteres imprimíveis (Continuação)

33
33
34
35
36
37
38
38
39
50
52
55
55
57
57
65
65
66
66
68
69
70
71
71
76
98
99
. . . . . . . 100
. . . . . . . 101

Sumário

1
1.1
1.2

2
2.1
2.2
2.3
2.4
2.4.1
2.4.2
2.4.3
2.4.4

3
3.1
3.2
3.2.1
3.2.2
3.2.3
3.3
3.3.1
3.4
3.4.1
3.4.2
3.5
3.5.1
3.5.2
3.6
3.6.1
3.6.2

4
4.1
4.1.1

INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Objetivos
Organização . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

OS NÚMEROS BINÁRIOS . . . . . . . . . . . . . . . . . . . . .
Contexto Histórico . . . . . . . . . . . . . . . . . . . . . . . . . . .
Expansão Relativa a uma Base b . . . . . . . . . . . . . . . . . . .
Relação entre os Números Binários e os Decimais . . . . . . . . .
. . . . . . . . . . . . . . .
Operações Fundamentais nos Binários
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Adição
Subtração . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Multiplicação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Divisão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

A ÁLGEBRA DE BOOLE . . . . . . . . . . . . . . . . . . . . . .
Contexto Histórico . . . . . . . . . . . . . . . . . . . . . . . . . . .
A Álgebra Formal . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Operador OR (OU) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Operador AND (E) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Operador Complemento . . . . . . . . . . . . . . . . . . . . . . . . .
Deﬁnições Básicas e Propriedades . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . .
Propriedades Fundamentais da Álgebra de Boole
Expressões e Funções Booleanas . . . . . . . . . . . . . . . . . . .
Expressões Booleanas . . . . . . . . . . . . . . . . . . . . . . . . . . .
Funções booleanas . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Derivação de Expressões Booleanas . . . . . . . . . . . . . . . . .
Soma de Produtos (SdP) . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
Produdo de Somas (PdS)
Simpliﬁcação de Expressões Booleanas . . . . . . . . . . . . . . .
Fatoração . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Mapas de Veitch-Karnaugh . . . . . . . . . . . . . . . . . . . . . . . .

CIRCUITOS LÓGICOS E APLICAÇÕES . . . . . . . . . . . . .
Circuitos Lógicos . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Portas Lógicas

13
14
14

16
16
18
21
24
24
26
27
28

29
29
30
32
34
35
36
41
47
47
48
49
50
51
52
53
54

59
59
60

4.1.2
4.2
4.3
4.3.1

4.3.1.1

4.3.1.2

4.3.1.3

4.3.1.4

4.3.1.5

4.3.2
4.3.3

5
5.1
5.1.1
5.1.2
5.2
5.2.1
5.2.2
5.3
5.3.1
5.4
5.5

6

Exemplos de Circuitos Lógicos . . . . . . . . . . . . . . . . . . . . . .
Outros Operadores Lógicos . . . . . . . . . . . . . . . . . . . . . .
Aplicações . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Circuitos Elétricos
Circuitos em Série . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Circuito em Paralelo . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Circuito Misto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Circuito Inversor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Circuitos NAND e NOR . . . . . . . . . . . . . . . . . . . . . . . . . .
Busca do Google . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Jogos Boole . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

INTRODUÇÃO AOS COMPUTADORES . . . . . . . . . . . . .
Conceitos Elementares . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bit
Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Os Processadores . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Contexto Histórico . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Funcionamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
O Código ASCII
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Arte ASCII
Unicode e Padrão UTF-8 . . . . . . . . . . . . . . . . . . . . . . .
Aplicações . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

60
64
67
67

67

68

69

69

70

71
72

75
75
75
77
78
80
84
85
87
88
89

CONCLUSÕES . . . . . . . . . . . . . . . . . . . . . . . . . . . .

91

REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . .

94

ANEXOS

97

ANEXO A – TABELA ASCII - 128 CÓDIGOS (7 BITS) . . . .

98

ANEXO B – TABELA ASCII ESTENDIDA - 128 CÓDIGOS (8

BITS) . . . . . . . . . . . . . . . . . . . . . . . . . 102

ANEXO C – TABELA UNICODE - PADRÃO UTF-8 . . . . . . 105

1 Introdução

13

Para que serve a Matemática? Essa é uma pergunta recorrente entre os alunos do
Ensino Fundamental ao Superior. Claro que, no mundo tecnológico de hoje em dia,
não temos dúvidas da importância que a matemática tem nos cálculos de estruturas da
engenharia, nos modelos de propagação da biologia e nos vários recursos computacionais
presentes no nosso dia a dia, como os computadores, celulares, impressoras, entre tantos
outros.

Mas, se tratando de modelos computacionais, como uma máquina consegue executar
operações matemáticas como o cérebro humano e o que, de fato, os computadores leem e
executam quando os programas que criam as rotinas e instruções de algumas operações
computacionais estão sendo processados? Naturalmente, os computadores necessitam
de instruções para realizarem as suas tarefas, mas qual é a linguagem que eles entendem
e permitem com que vários programas, aplicativos e rotinas sejam processados com
sucesso?

A linguagem que os computadores entendem é a dos números, mais precisamente, a
dos números binários 0 e 1. Isso ocorre porque, na verdade, os transistores que formam
as placas dos computadores constituem uma chave do tipo liga e desliga, de acordo
com a voltagem operada de 0 a 5 volts. Então, esse pulso elétrico, ou a ausência dele,
pode ser interpretado como o sim ou o não, o verdadeiro ou o falso, ou seja, a opção
entre dois estados pode ser compreendida unicamente por zeros e uns da linguagem
binária.

Sendo assim, tudo que precisamos “falar” para o computador em termos de instru-
ções pode ser “lido” pela máquina como zeros e uns. Mas a nossa linguagem de textos
do dia a dia e o nosso sistema de numeração que usamos, o decimal, não podem ser
entendidos pelo computador. Por isso, se faz necessário converter a nossa linguagem
de textos e números decimais para a linguagem binária dos computadores.

Mas como tudo isso é feito? Neste trabalho, responderemos a essa e a outras
questões interessantes envolvendo o sistema de numeração na base 2, ou seja, o sistema
binário, além de mostrarmos como essa linguagem puramente matemática é convertida
e entendida pelos computadores. Antes, porém, é importante destacar que aqui estare-
mos utilizando o termo "números binários", em alguns casos, para fazer referência ao
sistema de numeração binário, dependendo do contexto que se está inserido.

Diante do exposto, este Trabalho de Conclusão de Curso do PROFMAT - UFCG
se dará através de uma pesquisa do tipo qualitativa, onde também se fará presente a
pesquisa bibliográﬁca, cujo objeto central de estudo foi motivado a partir da curiosidade
em entender como funciona a programação das máquinas, tão úteis no nosso cotidiano.

Capítulo 1.

Introdução

14

Outro fator que também motivou a escolha do tema de pesquisa envolvendo os números
binários foi o fato de que 1 + 1, aqui, não é 2, e, sim 10, fato que deixa muitas pessoas
curiosas e sem entender o porquê disso acontecer, o que desperta, nelas, o interesse
em compreender um pouco mais sobre o assunto e, consequentemente, em querer saber
alguma aplicação desses conceitos.

1.1 Objetivos

Este trabalho tem como objetivo geral compreender como funciona a programação
dos computadores através do sistema de numeração na base 2, onde buscaremos, através
de um levantamento bibliográﬁco, atingi-lo, destacando os seguintes objetivos especíﬁ-
cos:

• Estudar a história, a aritmética e algumas propriedades dos números binários;

• Mostrar que todo número pode ser escrito na base 2;

• Apresentar a Álgebra de Boole, incluindo importantes deﬁnições, axiomas, pro-

priedades e teoremas;

• Expor aplicações desta álgebra;

• Compreender o funcionamento dos processadores;

• Tratar do código ASCII e do Unicode, com ênfase no padrão UTF-8;

• Descrever como acontece a comunicação entre humanos e máquinas.

1.2 Organização

Para podermos alcançar os objetivos apresentados anteriormente, este trabalho es-

tará estruturado da seguinte maneira:

De início, a Introdução, que também podemos considerá-la como o Capítulo 1,
trará, de forma rápida e resumida, como funciona a linguagem e a programação dos
computadores, a metodologia de pesquisa utilizada, a motivação da escolha do objeto
de estudo, os objetivos a serem alcançados e a estrutura de todo este Trabalho de
Conclusão de Curso.

No Capítulo 2, intitulado “A Aritmética Binária”, vamos nos familiarizar com o
sistema de numeração posicional na base 2 e suas propriedades. Além disso, provaremos
que todo inteiro positivo pode ser escrito na base 2 e, por ﬁm, mostraremos como os
sistemas binário e decimal se relacionam.

Capítulo 1.

Introdução

15

O Capítulo 3 apresentará a Álgebra de Boole, que constitui o sistema lógico cons-
truído a partir da linguagem binária, enfatizando, sobretudo, o contexto histórico e
importantes deﬁnições, axiomas, propriedades e teoremas, com suas respectivas de-
monstrações. Também mostraremos a relação desta álgebra com a teoria dos conjuntos
e com a álgebra tradicional, onde são utilizados conceitos já estudados e conhecidos
aplicados a essa “nova” álgebra, bem como algumas de suas aplicações, destacando seu
uso nos circuitos lógicos, circuito elétricos, no buscador de Google e em jogos de lógica.
O Capítulo de número 4 trata dos circuitos lógicos, que são construídos através
de portas lógicas; de outros operadores, além dos básicos; por ﬁm, mostra algumas
aplicações da Álgebra de Boole.

No quinto Capítulo, Introdução aos Computadores, trataremos dos conceitos de
bit e byte; falaremos também dos processadores de computadores e como se dá seu
funcionamento; em seguida, apresentaremos o código ASCII e o Unicode, destacando
o padrão UTF-8 e como eles são utilizados na linguagem computacional, a partir do
sistema binário.

Por ﬁm, apresentaremos as Conclusões obtidas ao ﬁnal desta pesquisa, as referên-
cias utilizadas na construção deste trabalho e os anexos, onde encontra-se a tabela
ASCII e a tabela do Unicode/Padrão UTF-8.

2 Os Números Binários

16

Neste capítulo, vamos apresentar um pouco da história dos números binários, onde
será mostrado como e por quem esses números foram utilizados no passado; como
funciona a expansão relativa a uma base b, b ∈ N, com a enunciação de propriedades
e suas respectivas demonstrações; algumas propriedades existentes entre os números
decimais e binários, incluindo a conversão entre números nessas bases; e, por ﬁm,
traremos as ideias de soma, subtração, multiplicação e divisão com números binários,
com exemplos numéricos de cada uma dessas operações.

2.1 Contexto Histórico

Nos primórdios da existência humana na terra, os homens viviam em cavernas e
obtinham o seu próprio alimento através da caça e da pesca. No entanto, com o passar
do tempo, foi-se percebendo a importância de produzir sua alimentação através da
agricultura e do pastoreio e, com isso, surgiu a necessidade de contar.

Nesse sentido, o homem “desenvolveu a capacidade de comparar conjuntos e esta-
belecer entre eles uma correspondência de noções quantitativas como pouco e muito,
pequeno e grande”. (MARTINES, 2019, p. 13)

De acordo com (EVES, 2004, p. 23),

As pessoas comerciavam entre si e havia a necessidade de anotar
a parte de cada família na caçada, ambas as atividades dependiam
da ideia de contar, um prelúdio de pensamentos cientíﬁcos. Alguns
povos da Idade da Pedra, como a tribo Sioux, tinham calendários
pictográﬁcos que registravam várias décadas de história. Todavia,
afora os sistemas de contagem primitivos, tudo o mais teve de esperar
o desenvolvimento da agricultura, intensiva em grande escala, que
requeria uma aritmética mais soﬁsticada.

Assim, com a necessidade de contagem começando a se difundir nas sociedades,
surgiu também uma espécie de agrupamentos, ou seja, um conjunto de particulari-
dades comuns que iriam classiﬁcar grupos e subgrupos. Nesse sentido, temos o que
chamamos de Sistema de Numeração, que é um método utilizado para representar
quantidades, onde cada número tem representação única. Segundo (MIYASCHITA,
2002), “os primeiros sistemas de escrita numéricas que se conhece são os dos egípcios
e os dos sumérios, surgidos por volta de 3.500 a.C. ”.

Esses sistemas podem ter diferentes bases, que são, de uma forma geral, a quan-
tidade de algarismos distintos que o compõem. Atualmente, o sistema de numeração
que utilizamos tem base 10, também chamado base decimal, que é composto por 10

Capítulo 2. Os Números Binários

17

dígitos, que vão de 0 a 9. Assim, nesse sistema, a partir da quantidade 10 não há novos
dígitos, ou seja, para representar números maiores ou iguais a 10, são utilizados os
algarismos já existentes. Esse fato é de extrema importância visto que estamos diante
de um sistema de numeração posicional.

Com o desenvolvimento tecnológico, sistemas começaram a ser estudados em busca
de maior facilidade de representação interna codiﬁcada. Dentre os mais comuns, pode-
mos citar os sistemas binários, octal, decimal e hexadecimal, que se adequam às es-
peciﬁcidades dos equipamentos a serem utilizados.

Podemos ter um sistema de numeração em qualquer base desejada, digamos, base
b, onde os algarismos irão de 0 a b − 1, se b ≤ 10. Se b > 10, então utilizam-se
dígitos alfanuméricos adicionais tais como A, B, C, D. No entanto, neste trabalho,
iremos nos deter apenas ao sistema de numeração de base 2, que também é chamado
de sistema de numeração binário, que é composto apenas de dois algarismos: 0 e 1. Este
sistema de numeração foi proposto pelo matemático alemão Gottfried Leibniz devido à
sua simplicidade, pois emprega a menor base possível de numeração (MIYASCHITA,
2002).

Navegando pela história, os primeiros vestígios de uso desse sistema de numera-
ção aconteceu por volta do século III a.C., pelo indiano Pingala, que representou os
números de 1 a 8, na nossa base usual, como 001, 010, 011, 100, 101, 110, 111, 1000,
sequencialmente e na linguagem dos algarismos indo-arábicos (SANTOS, 2020).

Há registros de que um matemático chinês chamado Shao Yong, no século XI, que
usava uma representação sequencial de 0 a 63, tenha utilizado uma aritmética binária
com essa representação, mas como existe pouca bibliograﬁa desse fato, há controvérsias
nesta história. (SANTOS, 2020).

No entanto, foi com o matemático alemão Gottfried Wilhelm Leibniz, nascido em
1646, que o sistema binário foi aperfeiçoado e efetivamente aplicado. Leibniz escreveu
um dos primeiros artigos relacionados ao tema, intitulado Explication de l’Arithmétique
Binaire.

Mais do que toda sua ﬁlosoﬁa, mais do que sua Monadologia, que
tanto prezava, seu Explication de l’Arithmétique Binaire apresenta,
de forma simples e vibrante, as bases da moderna ciência da com-
putação, do funcionamento dos computadores e dos onipresentes tele-
fones celulares. (LOPES, 2011, p. 90)

Ainda segundo (SANTOS, 2020), também é do autor a teoria de que todo raciocínio
lógico por ser reduzido a uma combinação ordenada de elementos como números,
palavras, sons ou cores, teoria esta que se tornou a base teórica dos computadores
modernos.

Portanto, para muitos autores, é atribuído a Leibniz a criação do sistema de nu-

meração na base 2.

Capítulo 2. Os Números Binários

18

Figura 1 – Leibniz (1646 – 1716)

Fonte: http://ecalculo.if.usp.br/historia/leibniz.htm

2.2 Expansão Relativa a uma Base b

Vejamos, agora, um importante teorema da matemática, talvez o mais importante
deste capítulo, que diz que qualquer número inteiro pode ser escrito de maneira única
em qualquer base b desejada. Aqui nos deteremos, de modo particular, à base 2, tema
central deste trabalho.

Teorema 2.1. Sejam dados os números inteiros a > 0 e b > 1. Existem números
inteiros n ≥ 0 e 0 ≤ r0, r1, · · · , rn < b, com rn 6= 0, univocamente determinados, tais
que a = r0 + r1 · b + r2 · b2 + · · · + rn · bn.

Demonstração. Vamos demonstrar o Teorema 2.1 por Indução Completa sobre a.

Existência:

Se 0 < a < b, basta tomar n = 0 e r0 = a.

Suponhamos o resultado válido para todo natural menor do que a, onde a ≥ b.

Vamos prová-lo para a. Pela divisão euclidiana, existem q e r, únicos, tais que

a = b · q + r, com 0 ≤ r < b.

(2.1)

Como 0 < q < a, pela hipótese de indução segue-se que existem números inteiros
n0 ≥ 0 e 0 ≤ r1, r2, · · · , rn0+1 < b, com rn0+1 6= 0, univocamente determinados, tais que

q = r1 + r2 · b + · · · + rn0+1 · bn0.

Levando em conta as igualdades entre as equações 2.1 e 2.2, temos que

a = b · q + r = b ·

(cid:16)

r1 + r2 · b + · · · + rn0+1 · bn0(cid:17) + r,

(2.2)

(2.3)

de onde o resultado segue, pondo r0 = r e n0 + 1 = n.

Capítulo 2. Os Números Binários

19

Unicidade:

Para 0 < a < b, o resultado é trivial. Seja, então, a ≥ b e suponha que o resultado
seja válido para todo natural menor do que a, digamos q, onde 0 < q < a. Queremos
provar que o resultado vale para q = a.

Para isto, consideremos as seguintes representações para a:

a = rn · bn + rn−1 · bn−1 + . . . r1 · b + r0

e

a = r0

n · bn + r0

n−1 · bn−1 + . . . r0

1 · b + r0
0.

(2.4)

(2.5)

Então, como se trata do mesmo inteiro positivo a, podemos escrever

(cid:16)

a = b

rn · bn−1 + · · · + r1

(cid:17) + r0 = b

(cid:16)

n · bn−1 + · · · + r0
r0

1

(cid:17) + r0
0.

Agora, pondo q = rn · bn−1 + · · · + r1 e q0 = r0

é fácil ver que q < a
e q0 < a e, portanto, a hipótese de indução nos diz que as representações q e q0 são
univocamente determinadas. Por outro lado, como 0 ≤ r0, r0
0 < b, segue que 2.4 e 2.5
expressam a divisão euclidiana de a, com divisor b, e restos respectivamente iguais a
r0 e a r0
0

; daí, a unicidade do quociente e do resto nos garante que

n · bn−1 + · · · + r0

1

q = q0 e r0 = r0
0

e as representações são indistintas.

(cid:4)

De acordo com a expansão acima, b é a base do sistema de numeração e ri será
cada um dos dígitos do número a, sendo que o índice i indica a posição relativa de cada
dígito, ou seja,

a = rn · bn + rn−1 · bn−1 + rn−2 · bn−2 + · · · + r1 · b + r0 = rnrn−1rn−2 · · · r2r1r0.

Na verdade, esse teorema nos permite escrever qualquer número inteiro utilizando
um sistema posicional, onde “os algarismos têm um valor dependendo de qual posição
ocupam no número” (SANTOS; SANTANA, 2013, p. 2). De modo particular, temos
que todo número natural pode ser escrito como soma de potências de 2, conforme
provado no Teorema 2.1, ou seja,

N = an · 2n + an−1 · 2n−1 + an−2 · 2n−2 + · · · + a2 · 22 + a1 · 21 + a0 · 20

onde cada dígito ai é igual a 0 ou a 1.

A mesma ideia pode ser estendida aos números racionais, onde utilizaríamos as

potências negativas da base. (MARTINES, 2019)
Como consequência do Teorema 2.1, temos:

Capítulo 2. Os Números Binários

20

Corolário 2.2. Duas expressões escritas numa mesma base b, digamos a = anan−1 · · · a1a0
e a0 = a0
para todo i, 0 ≤ i ≤ n.

, representam o mesmo número inteiro se, e somente se, ai = a0
i

n−1 · · · a0

1a0
0

na0

,

Demonstração. Decorre imediatamente da unicidade de representação de um inteiro
(cid:4)
numa base b qualquer.

Corolário 2.3. Se a = anan−1 · · · a1a0 e a0 = 0anan−1 · · · a1a0, então a = a0.

Demonstração. a0 = 0anan−1 · · · a1a0 = 0 · bn+1 + an · bn + · · · + a1 · b + a0 = 0 + an ·
(cid:4)
bn + · · · + a1 · b + a0 = an · bn + · · · + a1 · b + a0 = anan−1 · · · a1a0 = a.

Em virtude do Corolário 2.3, costuma-se dizer que o zero, ao ser escrito na extrema
esquerda de uma expressão, é um algarismo não signiﬁcativo, pois sua omissão não
altera o valor da expressão considerada. Isto nos diz que, dados a e a0 distintos, sempre
podemos considerar ambos com o mesmo número de algarismos, bastando, para isso,
que completemos com zeros não signiﬁcativos a expressão decimal com menor número
de dígitos. (LUNA, 2013)

Vimos, portanto, que qualquer número pode ser escrito na base que se queira. Logo,

ﬁca provado que podemos escrever qualquer número na base 2.

É importante enfatizar a questão dos números negativos nesta base, pois, diferente
de como acontece na decimal, que é necessário e suﬁciente apenas acrescentar o sinal
de menos (−) antes de escrever o número, nos binários trabalha-se com o chamado
complemento de um número, ou seja, o que falta nesse número para atingir o valor da
base, que é 2. Nos racionais, a ideia é trabalhar com a mesma expansão, no entanto,
algumas potências receberão expoentes negativos.

Não iremos aprofundar o nosso estudo a respeito dos números negativos e racionais,
visto que foge dos nossos objetivos, mas é de extrema importância ressaltar a existência
deles. Portanto, aqui nos deteremos apenas aos números inteiros positivos, ou seja, aos
números naturais.

Trataremos agora de um algoritmo que permite fazer a expansão de qualquer
número relativamente à base b, que consiste em aplicar a divisão euclidiana sucessivas
vezes, como segue:

a = b · q0 + r0 com r0 < b,
q0 = b · q1 + r1 com r1 < b,
q1 = b · q2 + r2 com r2 < b

e assim sucessivamente.
Como a > q0 > q1 > · · · , deveremos, em um certo ponto, ter que qn−1 < b e, assim,

de

qn−1 = b · qn + rn com rn < b,

Capítulo 2. Os Números Binários

21

decorre que qn = 0, o que implica 0 = qn = qn+1 = qn+2 = · · · , e, portanto, 0 = rn+1 =
rn+2 = · · · .

Logo, temos

a = r0 + r1 · b + · · · + rn−1 · bn−1 + rn · bn.

Nesse sentido, a expansão dada na base b nos fornece um método para representar
os números naturais. Quando, por exemplo, a expansão é de acordo com a base b = 10,
que é a base decimal, os números são representados a partir de uma sequência de
números que vão de 0 a 9; já quando esta se dá na base b = 2, o número é dito binário
e todo número é representado, consequentemente, por uma sequência de 0 e 1.

2.3 Relação entre os Números Binários e os Decimais

O sistema de numeração usual é o decimal, e o tema central deste trabalho são
os números binários. Portanto, vamos apresentar como se faz a conversão números
de decimais para binários e vice-versa, apresentando, também, exemplos numéricos de
cada um.

Para converter de decimais para binários, devemos utilizar as divisões sucessivas por
2 e prestar atenção nos restos que elas deixam, em seguida, pegar o “novo” quociente
(resultado da divisão anterior) e dividi-lo novamente por 2, focando sempre nos restos.
Este procedimento deve ser repetido até que o quociente seja 0. O número binário
procurado será a junção de todos os restos, dispostos lado a lado, em ordem contrária
em relação à qual foram encontrados, ou seja, do último para o primeiro.

Exemplo 1. Vamos transformar o número 39, que está na base decimal, para a base
binária, através de divisões sucessivas:

39 = 2 · 19 + 1,

19 = 2 · 9 + 1,

9 = 2 · 4 + 1,

4 = 2 · 2 + 0,

2 = 2 · 1 + 0,

1 = 2 · 0 + 1.

Focando nos valores dos restos encontrados, do último para o primeiro, temos

ou, simplesmente,

(39)

10

= (100111)

2 ,

39 = (100111)

2 .

Capítulo 2. Os Números Binários

22

É importante levar em consideração que, como a base padrão é 10, não há necessi-
dade de destacá-la. Sendo assim, sempre que um número não tiver uma base especíﬁca,
consideraremos que ela será a decimal.

Para o procedimento inverso, ou seja, para converter de binários para decimais,
basta pegar o número e desenvolvê-lo, individualmente, como um produto entre ele e
uma potência de 2, que terão expoentes 0, 1, 2, . . . , quando acompanhar o valor que
corresponder à unidade, à dezena, à centena, . . ., respectivamente. Para encontrar o
número em decimal, deve-se somar cada resultado obtido.

Exemplo 2. Agora, iremos converter o número (100111)
2

para base decimal.

1 · 25 = 1 · 32 = 32,

0 · 24 = 0 · 16 = 0,

0 · 23 = 0 · 8 = 0,

1 · 22 = 1 · 4 = 4,

1 · 21 = 1 · 2 = 2,

1 · 20 = 1 · 1 = 1.

O número procurado será o resultado da soma 32 + 0 + 0 + 4 + 2 + 1, que é 39.
Logo, temos que (100111)
2

= 39.

Outra importante relação que existe entre o sistema binário e o decimal é a corres-
= 2n, que pode ser facilmente demons-

pondência entre as progressões, onde [(10)n]
trado utilizando indução completa sobre n.

2

Demonstração. Com efeito, para n = 0, o resultado é óbvio, isto é, h(10)0i
1 = 20.

2

= (1)

=

2

Supondo que a aﬁrmação seja válida para todo número natural menor que ou igual

a n, para n + 1 teremos

h(10)n+1i

2

= h(10)n · (10)1i

= [(10)n]

2

2 ·

h(10)1i
2

= 2n · 21 = 2n · 2 = 2n+1.

Portanto, pelo princípio de indução completa, a propriedade é válida para todo
(cid:4)

número natural n.

Numericamente, esta relação funciona da seguinte maneira:

h(10)0i
2

h(10)1i

2

= (1)
2

= 1 = 20,

= (10)
2

= 2 = 21,

Capítulo 2. Os Números Binários

23

h(10)2i

2

= (100)
2

= 4 = 22,

h(10)3i

h(10)4i

2

= (1000)
2

2
= (10000)
2

= 8 = 23,

= 16 = 24,

h(10)5i
2

h(10)6i

h(10)7i

2

= (100000)
2

= 32 = 25,

= (1000000)
2

2
= (10000000)
2

= 64 = 26,

= 128 = 27

e assim sucessivamente.
Esta relação também pode ser um mecanismo utilizado para conversão de decimais
para binários e vice-versa, por meio da decomposição do número e do valor equivalente
entre estas bases.

Assim, por exemplo, para converter o número decimal 39 para base 2, devemos

transformá-lo numa soma de potências de 2, isto é,

39 = 32 + 4 + 2 + 1 = 25 + 22 + 21 + 20,

e, pegando os correspondentes binários, temos que

39 = 32 + 4 + 2 + 1 = 25 + 22 + 21 + 20 = (100000)
2

+ (100)
2

+ (10)
2

+ (1)
2

= (100111)

2 .

De modo análogo, para transformar o número (100111)
2

para a base 10, partimos

da decomposição de 100111 em termos de potências de 10, ou seja,

100111 = 100000 + 100 + 10 + 1,

onde, pegando os correspondentes decimais, temos

(100111)
2

= (100000)
2

+ (100)
2

+ (10)
2

+ (1)
2

= (32)

10

+ (4)

10

+ (2)

10

+ (32)
1

= (39)

10 .

Conforme veriﬁca (MARTINES, 2019, p. 33),

Uma diferença básica e fundamental entre esse sistema [binário] e o
sistema decimal é a quantidade de algarismos utilizados para repre-
sentar um número [...]. Veriﬁcamos que, de maneira geral, quanto
menor a base, mais algarismos são necessários, tornando-se menos
prático quando se trata da representação de números grandes. Por
outro lado, o fato de trabalhar com essa base torna-se mais ágil
quando realizamos as operações, pelo fato de não utilizarmos outros
dígitos, senão 0 e 1.

Capítulo 2. Os Números Binários

24

2.4 Operações Fundamentais nos Binários

Tendo compreendido um pouco da história dos números binários, de provarmos que
todo número pode ser escrito na base 2 e de ter visto como acontece a conversão entre a
base decimal e binária e algumas relações importantes, vamos agora ver como acontece
as operações elementares (adição, subtração, multiplicação e divisão) nesta base.

De acordo com (MARTINES, 2019, p. 41)

As operações aritméticas no sistema de numeração posicional de qual-
quer base b são análogas àquelas que estamos acostumados na base
decimal. Assim, as mesmas regras que usamos para adição e mul-
tiplicação no sistema decimal são válidas para números escritos em
qualquer outro sistema de uma base b qualquer.

Nesta seção, sempre que estivermos considerando números e/ou operações, estare-

mos sempre nos referindo à base binária, a menos que seja explicitado outra base.

2.4.1 Adição

(FRANZON, 2015, p. 156) aﬁrma que

O Explication de l’Arithmétique Binaire lembra que, no sistema deci-
mal, utilizamos os algarismos de 0 a 9 e diz que, quando chegamos ao
dez, iniciamos novamente a contagem escrevendo dez como 10, dez
vezes dez, ou cem, como 100, e dez vez cem, ou mil, como 1000. No
sistema binário, utilizamos os algarismos 0 e 1 e, quando chegamos
ao dois, recomeçamos a contagem, escrevendo dois como 10, e dois
vezes dois, ou quatro, como 100, e dois vez quatro, ou oito, como
1000.

Assim, no sistema decimal, não existe um algarismo único para representar a dezena
e, nele, escrevemos o algarismo 1(um) seguido do 0(zero) para representá-la. Em outras
palavras, o algarismo 1 signiﬁca que há um grupo de uma dezena e o 0 que não há
unidades. No sistema binário, a ideia é análoga. Para representar o dois, que, nesse
sistema, representa a dezena, vamos usar os algarismos 1(um) e 0(zero). Essa será a
ideia fundamental para a realização de somas envolvendo números binários.

Nesse sistema, contamos de dois em dois, onde cada 2 unidades de primeira ordem,
equivalem a 1 unidade da segunda ordem; cada 2 unidades da segunda ordem equiva-
lem a 1 unidade da terceira ordem e assim sucessivamente (MARTINES, 2019). Em
outras palavras, consideramos o “0” como dígito da unidade e transportamos o “1”,
que, na verdade, representa o 10 (dois), para ordem imediamente superior, no caso, a
das dezenas. O mesmo aconteceria se estivéssemos tratando de outras ordens. Este
algoritmo também pode ser interpretado como a ideia do “vai um”, muito estudado e
já conhecido nas operações com decimais.

Capítulo 2. Os Números Binários

25

Temos apenas quatro possibilidades de somas nos binários. São elas:

0 + 0 = 0,

0 + 1 = 1,

1 + 0 = 1 e

1 + 1 = 10.

Neste último caso, o transporte do 1 é imediato para próxima ordem.

Exemplo 3. Vamos realizar a operação 1001 + 0110.

Para facilitar visualmente nosso cálculo, vamos reescrever a operação da seguinte

forma, respeitando a posição ordinal de cada algarismo:

1
+ 0

0
1

0
1

1
0

Em geral, começamos o cálculo pela operação de menor ordem, depois a de ordem
imediatamente superior, e assim sucessivamente até o término da soma. Em outras
palavras, a operação é efetuada de direita para esquerda.

Assim, somando sem complicações, obtemos:

1
+ 0

1

0
1

1

0
1

1

1
0

1

Portanto, temos 1001 + 0110 = 1111. No sistema decimal, isso signiﬁca que 9 + 6 =

15.

Neste exemplo, também poderíamos considerar a soma 1001+110, que chegaríamos
ao mesmo resultado, pois, como já foi provado no Corolário 2.3, o 0 da exterma esquerda
é não signiﬁcativo. Colocamos-no-lo, apenas, com o intuito de igualar o número de
dígitos de cada parcela.

Exemplo 4. Somar 1011 a 1010.

Primeiramente, vamos representar cada parcela com os números um abaixo do

outro, de modo que os algarismos de mesma ordem ﬁquem alinhados.

1
+ 1

0
0

1
1

1
0

Capítulo 2. Os Números Binários

26

Da direita para esquerda, temos 1 + 0 = 1 e 1 + 1 = 10, onde colocar-se-á o 0
na mesma posição ordinal e o 1 vai para ordem imediatamente superior (ideia do “vai
um”), que será acrescido à próxima soma; na terceira adição, temos 0+0+1, sendo que
esta última parcela refere-se ao 1 da soma anterior, que tem como resultado 1; e, por
ﬁm, temos 1 + 1 = 10, onde ﬁcará o 0 na ordem desta soma e o 1 irá ocupar a próxima
ordem, sendo que não existem mais algarismos a serem somados, o que implica que o
1 ocupará, imediatamente, tal posição. Em termos matemáticos, teremos:

1

1
+ 1

10 1
1
0

1

0

1

0

1
0

1

Portanto, 1011 + 1010 = 10101, ou seja, 11 + 10 = 21.

2.4.2 Subtração

Nosso foco agora será a operação de subtração.
A maneira de se realizar uma subtração utilizando números binários é semelhante
àquela com os números decimais. O cálculo é feito normalmente através de simples
operações e, quando houver necessidade de “empréstimos”, esse será feito na casa ime-
diatamente à esquerda (ou na mais próxima à esquerda cujo dígito for 1), respeitando,
obviamente, a ideia de que só temos dois algarismos para utilizar.

É importante salientar que aqui estamos considerando os casos onde minuendo é
maior do que o subtraendo, o que gera resultados positivos. Não mostramos casos onde
o inverso acontece, ou seja, quando o minuendo é menor do que o subtraendo, pois, se
assim for, o resultado será um número negativo, que não é o foco do nosso trabalho,
tendo em vista que estamos nos detendo apenas aos números naturais.

Analogamente à adição, na subtração também só existem quatro possibilidades de

operações. São elas:

0 − 0 = 0,

1 − 0 = 1,

1 − 1 = 0 e

0 − 1 = 1.

Neste último caso, a operação será compreendida como 10 − 1 = 1, já considerando

um possível empréstimo de 1.

Exemplo 5. Vejamos, agora, dois exemplos de subtrações com números binários, onde
já vamos colocar da maneira visualmente prática:

Capítulo 2. Os Números Binários

27

1
1

1
0

0
0

1
0

–

e

–

1
1

1
0

0
1

1
0.

No primeiro caso, com pequenas e simples subtrações, o cálculo é realizado sem

diﬁculdades, tendo como resultado 101:

–

1
1

0

1
0

1

0
0

0

1
0

1.

Já para o segundo exemplo, devemos proceder com um pouco mais de atenção, visto
que nem todas as operações estão óbvias, como aconteceu no exemplo anterior. As-
sim, vamos efetuar, individualmente, cada uma das subtrações, respeitando as posições
ordinais de cada algarismo, e começando sempre da direita para esquerda.

De início, 1 − 0 = 1; depois temos 0 − 1, que não é imediata. É aí que vamos
recorrer ao que usualmente chamamos de “pegar emprestado”, e esse empréstimo é
feito ao algarismo de ordem imediatamente superior, que, nesse caso, é o 1, e, cedendo
este valor, passará a ser 0. Esse valor cedido, que é uma ordem superior a que o 0
está, se juntará com o 0, tornando-se 10. Assim, o 0 − 1 passará a ser visto como
10 − 1 = 1, pois, nos binários, o 10 equivale ao 2. Prosseguindo, tínhamos 1 − 0, mas
esse 1 foi cedido à ordem anterior, logo, restou apenas 0 − 0, que é 0; por ﬁm, temos
1 − 1 = 0. Ou seja,

–

1
1

0

0(cid:1)1
0

0

10
1

1

1
0

1.

Portanto, 1101 − 1010 = 11. Isso signiﬁca que 1310 = 3.

2.4.3 Multiplicação

Na multiplicação, procedemos de forma análoga à que realizamos com os números
decimais, começando sempre da direita para esquerda e multiplicando todos os fatores,
individualmente, entre si, seguindo os casos mais simples:

0 · 0 = 0,

0 · 1 = 0,

1 · 0 = 0 e

1 · 1 = 1.

Exemplo 6. Vejamos os seguintes exemplos, já com seus respectivos resultados e es-
critos na forma conveniente.

Capítulo 2. Os Números Binários

28

1

0

1

0

1
0
× 1
0
1

e

1

0

0
0

0

0
1

1

1
0

0

1
0
× 1
0
0
1
0

0

1

0.

+ 1

1

Notemos que não há necessidade de usar o “vai um”, visto que a maior possibilidade

de resultado é 1, proveniente do 1 · 1.

2.4.4 Divisão

A divisão também terá o mesmo algoritmo que é utilizado na divisão com decima-
is, onde, de início, no dividendo, escolhe-se, de forma conveniente, a “parte” que seja
maior ou igual ao divisor e, em seguida, realiza-se a divisão, sendo que o resultado desta
operação irá para o quociente, que deverá ser multiplicado pelo divisor e o resultado
subtraído do número “escolhido” na primeira parte da operação, resultando num valor
que, posteriormente, será unido ao próximo número que ﬁcou no dividendo sem ter sido
utilizado. Este procedimento deverá ser repetido até que o resto seja 0, resultando,
assim, uma divisão exata.

Vale salientar que não vamos tratar de casos onde as divisões não são exatas, uma

vez que estamos nos detendo somente aos números inteiros positivos.

Exemplo 7. Vejamos um exemplo prático de como acontece a divisão nos números
binários:

Portanto, o resultado da divisão de 111100 por 1100 é 101. No sistema decimal,

isso equivale a aﬁrmar que o resultado da divisão de 60 por 12 é igual a 5.

3 A Álgebra de Boole

29

Neste capítulo, iremos discursar sobre uma parte da matemática aplicada que é
utilizada na programação de computadores e de outros equipamentos eletrônicos, como
celulares e videogames. Para isto, será abordado o contexto histórico desta álgebra;
em seguida, será apresentada sua formalização matemática, com ênfase nos operadores
básicos “ou”, “e” e “não”, seus axiomas e propriedades; também tratar-se-á comentado
sobre expressões e funções booleanas, incluindo o processo de derivação e simpliﬁcação
de expressões; a questão dos circuitos lógicos; outros operadores lógicos, além dos
básicos, também serão abordados; e, por ﬁm, serão mostradas algumas aplicações da
Álgebra de Boole.

3.1 Contexto Histórico

Autodidata, George Boole, nascido na Inglaterra no dia 02 de novembro de 1815,

foi o responsável pela invenção desse tipo de álgebra.

Mesmo quase sem formação acadêmica, Boole, incentivado pelo seu pai, dedicou-
se a estudar línguas e Matemática, tornou-se professor aos 16 anos numa escola em
Lincoln e chegou até a abrir sua própria no ano de 1835. Boole dedicou-se também a
escrever trabalhos na área, baseando-se em obras de Laplace e de Lagrange para escrita
do seu primeiro trabalho, publicado em 1840.

Em 1844, foi condecorado com a medalha de ouro Royal Society por seu trabalho
sobre métodos algébricos para a solução de equações diferenciais, publicado no Jour-
nal of Mathematics of Cambrige. Em 1847, publicou uma obra curta chamada The
Mathematical Analysis of Logic, onde defendia que a lógica deveria estar associada à
Matemática numa visão mais ampla, visto que, até então, essa era tida apenas como
a ciência das grandezas e dos números. Ainda nesta obra, Boole introduz os conceitos
de lógca simbólica, apresentando-os como traduções para equações algébricas.

Foi nomeado professor de Matemática no Queens College em 1849, na Irlanda, onde

permaneceu até o ﬁnal da sua vida.

Sua principal obra foi publicada no ano de 1854, intitulada Investigation of the
Laws of thought. Nela, Boole amplia e esclarece as ideias apresentadas em 1847, se
fundamentando, simultaneamente, numa lógica formal e na nova álgebra, denominada
Álgebra de Boole, Álgebra Booleana, Álgebra Proposicional ou, ainda, Álgebra da
Lógica. Nesta obra,

Boole usou as letras x, y e z para representar subconjuntos de coisas,
números, pontos, ideias, ou outras entidades escolhidas de um con-

Capítulo 3. A Álgebra de Boole

30

junto universal ou universo de discurso, cuja totalidade ele designa-
va pelo símbolo ou número; e mostrou que sua álgebra fornecia um
algoritmo simples para raciocínios silogísticos.
(MELLO, 2010, p.
181–182)

Nesse sentido, Boole defendia a ideia de que os processos de raciocínio utilizados na
vida cotidiana poderiam ser representados através de termos de lógica matemática, ou
seja, ele acreditava que era possível exprimir o raciocínio humano em termos matemáti-
cos. Por este motivo, a álgebra de Boole também é conhecida como a Álgebra do
Pensamento. Com isso, Boole, mais tarde, tornar-se-ia um dos gênios que dariam sua
contribuição para a invenção dos computadores.

Em 1855, casou-se com Mary Everest, com quem teve cinco ﬁlhas. Em 1857, tornou-
se membro da Royal Society. Boole também recebeu títulos das Universidades de
Oxford e de Dublin.

Além disso, o matemático publicou outros trabalhos, tais como um tratado so-
bre equações diferenciais e um tratado em cálculo de diferenças ﬁnitas. Também es-
tudou métodos gerais de probabilidades e foi um dos pioneiros na investigação das
propriedades básicas dos números.

Sendo considerado um gênio, sua ideia central com a álgebra booleana era formular
a linguagem do pensamento através de símbolos. O próprio autor, em uma das suas
obras, escreveu que pretendia estabelecer o cálculo da lógica através do uso de símbolos,
cujas leis de combinação são conhecidas e gerais, onde os resultados admitem uma
interpretação consistente. (BOOLE, 1847) Assim, “Boole viu a lógica de um modo
novo e chegou a uma álgebra mais simples”. (RIZZATO; RINALDI, 2005)

Segundo (MELLO, 2010, p. 182),

a álgebra booleana é largamente usada não só por matemáticos puros,
mas também por outros que a aplicam a problemas de teoria da
informação. As notações mudaram um pouco desde os dias de Boole,
mas os princípios fundamentais são os estabelecidos por ele há mais
de um século.

George Boole teve sua carreira encerrada muito cedo, quando em 1864, aos 49 anos
de idade, veio a falecer na Irlanda, vítima de pneumonia. Antes disso, ele disse a um
amigo que a lógica booleana poderia ser a contribuição mais valiosa, senão a única, que
ele havia feito ou que, provavelmente, faria à ciência, e era o motivo pelo qual desejaria
ser lembrado postumamente (NEWS, 2015). E assim aconteceu, pois, sem suas ideias,
os computadores modernos não teriam as características que tem hoje.

3.2 A Álgebra Formal

Diferentemente da álgebra tradicional, onde as variáveis podem assumir um in-
ﬁnidade de valores, na álgebra de Boole há apenas dois possíveis valores para as vari-

Capítulo 3. A Álgebra de Boole

31

Figura 2 – George Boole (1815 – 1864)

Fonte: https://www.techtudo.com.br/artigos/noticia/2012/08/uma-algebra-diferente.html

áveis: 0 e 1. Logo, a base utilizada neste tipo de álgebra é a binária.

A álgebra booleana pode ser deﬁnida como uma estrutura matemática que incorpora
as propriedades básicas do cálculo proposicional e da teoria dos conjuntos, ou seja, é
um outro modelo de uma mesma estrutura matemática. (ABAR, 2004)

A linguagem de programação utilizada pelos computadores é composta unicamente
por números, mais especiﬁcamente, pelos número 0 e 1, que são os números binários. No
entanto, estes valores não exprimem quantidades, mas apenas, e só, estados do sistema.
Nesse sentido, o que esses números transmitem para as placas dos computadores são
pulsos elétricos (1) ou a ausência deles (0), o que pode ser interpretado como uma
chave do tipo liga/desliga, ou ideias como o sim ou o não, o verdadeiro ou o falso, o
tudo ou o nada. Teoricamente, o 1 é como se fosse o universo e o 0, o nada.

Assim, a álgebra de Boole, ou álgebra booleana,

é uma estrutura algébrica que esquematiza as operações lógicas, e
está presente em todas as partes, desde a programação por trás dos
videogames até o código dos aplicativos que usamos. Pode-se dizer
que os tijolos que formam a programação, que são os comandos ou
instruções dadas a um sistema informático, são todos baseados na
lógica de Boole. (NEWS, 2015, p.01)

(BARANAUSKAS, 2012) nos traz algumas importantes deﬁnições quando diz que
existem apenas duas constantes booleanas 0(zero) e 1(um) e que as variáveis booleanas
são representadas por letras e podem assumir apenas dois valores lógicos, também 0 ou
1. O autor ainda acrescenta que uma expressão booleana é uma expressão matemática
envolvendo constantes e/ou variáveis booleanas e seu resultado só pode assumir dois
valores: 0 ou 1.

Capítulo 3. A Álgebra de Boole

32

(GÜNTZEL; NASCIMENTO, 2001, p. 01) aﬁrmam que,

como o número de valores que cada variável pode assumir é ﬁnito
(e pequeno), o número de estados que uma função booleana pode
assumir também será ﬁnito, o que signiﬁca que podemos descrever
completamente as funções booleanas utilizando tabelas. Devido a
este fato, uma tabela que descreva uma função booleana recebe o
nome de tabela verdade, e nela são listadas todas as combinações de
valores que as variáveis de entrada podem assumir e os correspon-
dentes valores da função (saídas).

(VIEIRA, 2000) ressalta que, como uma função de n variáveis possui apenas 2
conjuntos possíveis de valores de entrada, a função pode ser descrita completamente
através de uma tabela de 2n linhas, onde cada linha mostra o valor da função para uma
combinação diferente dos valores de entrada.

Nesse sentido, a partir do uso desta tabela, é possível deﬁnir o valor lógico de uma
proposição booleana, isto é, saber se esta é verdadeira ou falsa, quando esta vale 1 ou
0, respectivamente. No decorrer deste trabalho, iremos utilizá-la em várias situações
para encontrar valores lógicos.

Em sua teoria, Boole utilizou o conceito de operadores, ou perguntas, que traduzem
um enunciado. Há três operadores básicos, que, quando combinados, podem traduzir
todos os enunciados booleanos, inclusivem os mais complexos. São eles: “ou”, “e” e
“não”, que são equivalentes a “or”, “and” e “not”, respectivamente, no inglês, língua
materna de Boole.

Veremos, agora, como funcionam estes operadores básicos.

3.2.1 Operador OR (OU)

O operador “ou”, cuja escrita original é “or”, também pode ser chamada de adição
lógica. (GÜNTZEL; NASCIMENTO, 2001) aﬁrmam que, como uma expressão booleana
ou vale 0 ou vale 1, basta que esta seja deﬁnida quando a operação valer 1, pois, auto-
maticamente, a operação resultará 0 nos demais casos. Nesse contexto, por deﬁnição,
esta operação resulta 1 se pelo menos uma das constantes de entrada for 1, isto é, a
operação resulta 0 somente quando todas elas forem 0.

O símbolo mais utilizado para representar esta operação é +, o mesmo que é em-
pregado nas adições algébricas. Vale destacar, por outro lado, que a adição em questão
não é a algébrica, mas a lógica. Em outras biograﬁas também é muito encontrado o
símbolo ∨ para representá-la.

Listando todas as possíveis combinações para soma lógica boolenana, tem-se:

0 + 0 = 0,

0 + 1 = 1,

Capítulo 3. A Álgebra de Boole

33

1 + 0 = 1 e

1 + 1 = 1.

Como o operador “ou” é binário, é necessário que haja pelo menos duas variáveis

envolvidas, não sendo possível realizar uma adição se houver apenas uma variável.

Em geral, nas expressões não se faz uso de todas as possibilidades de valores, e,
sim, faz-se uso de letras para designar as variáveis. Então, supondo a análise do
comportamento da expressão A + B (lê-se “A ou B”), fazendo uso de uma tabela
verdade, temos:

Tabela 1 – Soma lógica com duas variáveis

A B A+B
0
0
1
1

0
1
0
1

0
1
1
1

Fonte: Autora

Analogamente aconteceria se houvesse mais de duas variáveis. Vejamos, por ex-
emplo, uma tabela verdade para 3 variáveis, digamos A + B + C, pois A + B + C =
(A + B) + C:

Tabela 2 – Soma lógica com três variáveis

A B C A+B+C
0
0
0
0
1
1
1
1

0
0
1
1
0
0
1
1

0
1
0
1
0
1
0
1

0
1
1
1
1
1
1
1

Fonte: Autora

Assim, para 2, 3 ou, generalizando, para n variáveis, poderia ser aplicada direta-
mente a deﬁnição do operador “ou”, que diz que o valor de saída será 1 se pelo menos
um dos valores de entrada for 1, sendo 0 apenas no caso em que todos eles forem iguais
a 0.

Capítulo 3. A Álgebra de Boole

34

3.2.2 Operador AND (E)

O operador originalmente escrito and, cuja tradução é “e”, também pode ser chamado
de multiplicação lógica. (GÜNTZEL; NASCIMENTO, 2001, p.3) aﬁrmam que a ope-
ração “e” resulta 0 se pelo menos uma das constantes de entrada for 0. Assim, pela
deﬁnição dada, o resultado de uma operação “e”, ou seja, de uma multiplicação lógica,
será 1 se, e somente se, todas as entradas forem 1.

O símbolo ·, muito utilizado na multiplicação algébrica, também é usado na multi-
plicação lógica para representar o operador “e”. Também é muito comum encontrar o
símbolo ∧ como outra notação.

Listanto as possíveis combinações para a multiplicação lógica envolvendo valores

booleanos, temos:

0 · 0 = 0,

0 · 1 = 0,

1 · 0 = 0 e

1 · 1 = 1.

Análogo ao operador “ou”, o operador “e” também é binário, sendo necessário,
portanto, a existência de pelo menos duas variáveis de entrada para que a operação
possa ser realizada.

A tabela verdade que mostra o comportamento de A·B (lê-se “A e B”), é a seguinte:

Tabela 3 – Multiplicação lógica com duas variáveis

A B A ·B
0
0
1
1

0
1
0
1

0
0
0
1

Fonte: Autora

Para três variáveis de entrada, a ideia seria semelhante, uma vez que A · B · C =

(A · B) · C:

Capítulo 3. A Álgebra de Boole

35

Tabela 4 – Multiplicação lógica com três variáveis

A B C A ·B · C
0
0
0
0
1
1
1
1

0
1
0
1
0
1
0
1

0
0
0
0
0
0
0
1

0
0
1
1
0
0
1
1

Fonte: Autora

Portanto, com duas ou três variáveis, vimos que o resultado é 1 unicamente quando
todas as constantes de entrada são 1. Generalizando para n variáveis, o resultado
será 1 se, e somente se, todas as constantes forem 1, ou seja, se pelo menos uma das
constantes for 0, o resultado de saída também será 0.

3.2.3 Operador Complemento

O operador complemento, que também pode ser chamado de negação ou inversão,
tem a função de valor complementar ou valor inverso ao que a variável original apresen-
ta (GÜNTZEL; NASCIMENTO, 2001). Então, como as constantes booleanas podem
apenas assumir os valores 0 e 1, a operação complementar aplicada a estes valores
resultam em 1 e 0, respectivamente.

Os símbolos mais utilizados para representar esta operação em relação, por exemplo,
a uma variável A são ∼ A, A0 ou ainda uma barra horizontal acima da variável (lê-se
“A negado” ou “não A”).

Listanto os possíveis resultados desta operação, temos:

00 = 1 e

10 = 0.

Diferentemente do que acontece nas operações “ou” e “e”, a operação complemen-
tação, para estar deﬁnida, há necessidade de apenas uma variável de entrada, sendo,
portanto, uma operação unitária.

A tabela verdade, nesse caso, é:

Capítulo 3. A Álgebra de Boole

36

Tabela 5 – Negação lógica com uma variável

A A’
1
0
0
1

Fonte: Autora

3.3 Deﬁnições Básicas e Propriedades

Diante do exposto, por álgebra booleana entende-se um conjunto A = {a, b, c, . . .}
junto com duas operações binárias, + (também denotada por ∨ e chamada “ou”) e ·
(também denotada ∧ e conhecida por “e”), uma operação unitária 0 (também escrita
como (cid:118) ou uma barra superior acima da variável, e chamada de operação complemento,
inversão ou negação) e dois únicos elementos 0 e 1, também chamados de zero ou falso
ou de um ou verdadeiro, respectivamente, se, e somente se, satisfazem os seguintes
postulados (Postulados de Huntington): (OLIVEIRA, 2017)

Axioma 3.1. As operações + e · são comutativas. Isto é, para todo a e b em A,

a + b = b + a

e

a · b = b · a

Axioma 3.2. Cada operação é distributiva sobre a outra. Ou seja, para todo a, b e c
em A,

a · (b + c) = (a · b) + (a · c)

e

a + (b · c) = (a + b) · (a + c)

Axioma 3.3. Existem em A elementos identidades 0 e 1, distintos, com relação as
operações + e ·, respectivamente. Isto é, para todo a em A,

a + 0 = a

e

a · 1 = a

Axioma 3.4. Há um elemento a0, denominado complemento de a, tal que, para cada
elemento a de A, existe um elemento a0, também em A, tal que

a + a0 = 1

e

a · a0 = 0

Assim, a álgebra booleana pode ser deﬁnida como uma sextupla ordenada hA, +, ·, 0, 0, 1i,

onde são satisfeitos os axiomas referidos anteriormente.

Alguns autores incorporam outros axiomas como parte da deﬁnição
de uma álgebra booleana. Vale registrar que os postulados de Hun-
tington correspondem a um conjunto minimal de postulados, isto é,
nenhum deles pode ser derivado a partir dos demais. Mais ainda,
é um conjunto completo no sentido de que qualquer propriedade de
uma álgebra Booleana pode ser derivada/provada a partir desses pos-
tulados. (HIRATA, 2005, p. 30)

Capítulo 3. A Álgebra de Boole

37

Os axiomas 3.1, 3.3 e 3.4 são aceitos por deﬁnição. Já o 3.2 não é tão óbvio, por
isso vamos provar a veracidade dele através de tabelas-verdade. Iremos fazer o mesmo
com os demais axiomas.

Antes, porém, é importante acrescentar o que diz (LIPSCHUTZ; LIPSON, 1976),
quando aﬁrmam que devemos, em geral, adotar que a negação tem precedência sob a
multiplicação, e que a multiplicação tem precedência em relação a adição, a menos que
as operações estejam entre parenteses, que tem prioridade sobre os demais operadores.
Por exemplo, a + b · c signiﬁca a + (b · c) e não (a + b) · c, e a · b0 representa a · (b0)

e não (a · b)0.

Analogamente à álgebra nos reais, quando a + b · c é escrito como a + bc, há uma

equivalência entre as expressões.

Agora, vejamos, através de tabelas-verdade, a validade dos axiomas apresentados,
onde será destacado com um ∗ as colunas que deverão ter os mesmos valores de saída,
representando a igualdade das expressões.

• Axioma 3.1 :

Tabela 6 – Tabelas verdades do axioma da comutatividade

a + b = b + a

a · b = b · a

a b
0
0
1
0
0
1
1
1

a+b b+a

0
1
1
1
∗

0
1
1
1
∗

e

a b
0
0
1
0
0
1
1
1

a ·b b ·a
0
0
0
0
0
0
1
1
∗
∗

Fonte: Autora

• Axioma 3.2 :

Capítulo 3. A Álgebra de Boole

38

Tabela 7 – Tabelas verdades do axioma da distributividade

a · (b + c) = (a · b) + (a · c)

a b c
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1

b + c
0
1
1
1
0
1
1
1

a ·b
0
0
0
0
0
0
1
1

a ·c
0
0
0
0
0
1
0
1

(a · b) + (a · c)
0
0
0
0
0
1
1
1
∗

a · (b + c)
0
0
0
0
0
1
1
1
∗

e

a + (b · c) = (a + b) · (a + c)

a b c
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1

b ·c
0
0
0
1
0
0
0
1

a + (b · c)
0
0
0
1
1
1
1
1
∗

a + b a + c

0
0
1
1
1
1
1
1

0
1
0
1
1
1
1
1

(a + b) · (a + c)
0
0
0
1
1
1
1
1
∗

Fonte: Autora

• Axioma 3.3 :

Tabela 8 – Tabelas verdades dos elementos identidade

a + 0 = a
a+0
a
0
0
1
1
∗
∗

0
0
0

e

a ·1 = a
1
1
1

a ·1
0
1
∗

a
0
1
∗

Fonte: Autora

• Axioma 3.4 :

Capítulo 3. A Álgebra de Boole

39

Tabela 9 – Tabelas verdades do complemento

a
0
1

a + a0 = 1
a + a’
a’
1
1
1
0
∗

1
1
1
∗

a
0
1

a · a’ = 0
a ·a0
a’
0
1
0
0
∗

0
0
0
∗

e

Fonte: Autora

Vejamos alguns exemplos de como essa álgebra é utilizada.

Exemplo 8. O conjunto dos bits (dígitos binários) A = {0, 1} com as operações
binárias + e · e a operação unitária 0 deﬁnidas da maneira usual é uma álgebra booleana,
isto é,

0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 1

0 · 0 = 0
0 · 1 = 0
1 · 0 = 0
1 · 1 = 1

00 = 1
1’ = 0

Demonstração. A demonstração da validade dos axiomas neste exemplo encontra-se
(cid:4)
nas tabelas verdades já apresentadas.

Exemplo 9. Seja A = {1, 2, 5, 7, 10, 14, 35, 70}, ou seja, o conjunto de divisores de
70. As operações binárias + e · e a operação unitária a0 deﬁnidas como segue, para
quaisquer a1, a2 ∈ A,

• a1 + a2 : o mínimo múltiplo comum entre a1 e a2;

• a1 · a2: o maior divisor comum entre a1 e a2; e

• a0 =

70

a

Temos que A é uma álgebra booleana, com 1 o elemento zero e 70 o elemento unitário.

Demonstração. O Axioma 3.1 segue da propriedade já conhecida que diz que mmc =
(a, b) = mmc (b, a) e mdc = (a, b) = mdc (b, a) .

Para o Axioma 3.2, faremos uso de um importante resultado, que também será

demonstrado.

Aﬁrmação 3.1. mdc (a, mmc (b, c)) = mmc (mdc (a, b) , mdc (a, c)).

Capítulo 3. A Álgebra de Boole

40

Demonstração. Sejam a, b, c ∈ N e p1, p2, . . . , pn números primos tais que

a = pα1

1 pα2

2 . . . pαk

k . . . pαn
n ,

b = pβ1

1 pβ2

2 . . . pβk

k . . . pβn
n ,

c = pγ1

1 pγ2

2 . . . pγk

k . . . pγn
n ,

onde αi, βi, γi ∈ N para todo i. Não há perda de generalidade em supor os mesmos
primos em cada decomposição, uma vez que podemos ter expoentes nulos. Lembrando
agora que

mdc (a, b) = pmin(α1,β1)

1

pmin(α2,β2)
2

. . . pmin(αk,βk)

k

. . . pmin(αn,βn)

n

e

mmc (a, b) = pmax(α1,β1)

1

pmax(α2,β2)
2

. . . pmax(αk,βk)

k

. . . pmax(αn,βn)

n

vamos determinar a potência de pk em mdc (a, mmc (b, c)) e também em mmc (mdc (a, b) , mdc (a, c)).

Temos 6 casos a considerar:

• Caso 1: αk ≤ βk ≤ γk

• Caso 2: αk ≤ γk ≤ βk

• Caso 3: βk ≤ αk ≤ γk

• Caso 4: βk ≤ γk ≤ αk

• Caso 5: γk ≤ αk ≤ βk

• Caso 6: γk ≤ βk ≤ αk

No caso 1, αk ≤ βk ≤ γk e daí a potência de pk em mmc (b, c) é pmax(βk,γk)

= pγk
k

.

Portanto, a potência de pk em mdc (a, mmc (b, c)) é igual a pmin(αk,γk)

k

k
= pαk
k

.

Considerando ainda o caso 1, as potências de pk em mdc (a, b) e em mdc (a, c) são
ambas iguais a pαk. Logo, a potência de pk em mmc (mdc (a, b) , mdc (a, c)) é dada por
mmc (pαk

.

k , pαk

k

) = pαk
k

O mesmo vale para os outros casos 2, 3, · · · , 6: a potência de pk em mdc (a, mmc (b, c))

coincide com a de mmc (mdc (a, b) , mdc (a, c)).

Portanto, as potências de pk em mdc (a, mmc (b, c)) e em mmc (mdc (a, b) , mdc (a, c))

coincidem para todo k = 1, 2, · · · , n. Concluímos, dessa forma, que

mdc (a, mmc (b, c)) = mmc (mdc (a, b) , mdc (a, c)) .

(cid:4)

Capítulo 3. A Álgebra de Boole

41

Assim, temos

a·(b + c) = mdc (a, b + c) = mdc (a, mmc (b, c)) = mmc (mdc (a, b) , mdc (a, c)) = a·b+a·c

e

e

e

a + (b · c) = mmc (a, b · c) = mdc (mmc (a, b) , mmc (a, c)) = (a + b) · (a + c) .

O Axioma 3.3 segue de que 1 é o elemento zero e 70, o elemento unitário. Assim,

a + 0 = mmc (a, 0) = mmc (a, 1) = a, pois a = 1 · a = a · 1

a · 1 = mdc (a, 1) = mdc (a, 70) = a pois a ∈ A, A conjunto dos divisores de 70.

O Axioma 3.4 segue do fato que a0 =

70

a

, logo:

a + a0 = mmc (a, a0) = mmc

(cid:18)

a,

70

(cid:19)

a

= 70 = 1

a · a0 = mdc (a, a0) = mdc

(cid:18)

a,

70

(cid:19)

a

= 1 = 0.

(cid:4)

3.3.1 Propriedades Fundamentais da Álgebra de Boole

1. Princípio de dualidade

Cada expressão ou identidade algébrica dedutível a partir dos postulados de uma
álgebra booleana continua válida se todas as ocorrências dos operadores + e · e
os elementos identidade 0 e 1 são trocados um pelo outro. (HIRATA, 2005, p.
32)

O termo utilizado para designar a nova expressão booleana após as trocas corres-
pondentes é “dual”. Por exemplo, o dual de (1 + a)·(b + 0) = b é (0 · a)+(b · 1) =
b.

Nos axiomas já apresentados, o dual de cada um deles também é um axioma,
tendo em vista a simetria existente entre eles, ou seja, no axioma 3.2, temos
a · (b + c) = (a · b) + (a · c), cujo dual é a + (b · c) = (a + b) · (a + c), onde este
último continua válido, como visto, anteriomente, na tabela 7.

Assim, de uma forma geral,

Capítulo 3. A Álgebra de Boole

42

O dual de qualquer teorema em uma álgebra booleana tam-
bém é um teorema. Em outras palavras, se qualquer aﬁrmação
é uma consequência dos axiomas de uma Álgebra Booleana,
então o dual também é uma consequência desses axiomas, uma
vez que a aﬁrmação dual pode ser provada usando o dual de
cada etapa da prova da expressão original. (LIPSCHUTZ; LIP-
SON, 1976, p. 369)

2. Unicidade do 0 e do 1

Os elementos 0 (zero) e 1 (um) são únicos.

Demonstração. Sejam a1 e a2 elementos quaisquer em A. Supondo, por absurdo,
que existam dois elementos zeros, distintos, digamos 01 e 02, pelo axioma 3.3,

a1 + 01 = a1

e

a2 + 02 = a2.

Sem perda de generalidade, podemos tomar a1 = 02 e a2 = 01. Assim,

02 + 01 = 02

e

01 + 02 = 01.

Pelo Axioma 3.1 e a transtividade de igualdades, resulta que 01 = 02, o que
mostra a unicidade do 0.

Para a unicidade do 1, podemos considerá-la como a dual do 0, ou seja, a de-
(cid:4)
monstração desta decorre imediatamente do princípio da dualidade

3. Idempotência

Para todo elemento a ∈ A, tem-se que a + a = a e a · a = a.

Demonstração. Para a + a = a, temos

a + a = (a + a) · 1

= (a + a) · (a + a0)
= a + (a · a0)
= a + 0
= a

(Axioma 3.3)
(Axioma 3.4)
(Axioma 3.2)
(Axioma 3.4)
(Axioma 3.3).

Para a · a = a, basta tomar o dual do item anterior.

(cid:4)

4. Identidade

Para todo a ∈ A, tem-se que a + 1 = 1 e a · 0 = 0.

Demonstração. Para a + 1 = 1, temos

43

(cid:4)

Capítulo 3. A Álgebra de Boole

a + 1 = 1 · (a + 1)

= (a + a0) (a + 1)
= a + (a0 · 1)
= a + a0
= 1

(Axioma 3.3)
(Axioma 3.4)
(Axioma 3.2)
(Axioma 3.3)
(Axioma 3.4).

Para a · 0 = 0, basta tomar o dual do item anterior.

5. Absorção

Para quaisquer a, b ∈ A, tem-se que a + (a · b) = a e a · (a + b) = a.

Demonstração. Para a + (a · b) = a, temos

a + (a · b) = a · 1 + a · b

= a (1 + b)
= a · 1
= a

(Axioma 3.3)
(Axioma 3.2)
(Propriedade 4)
(Axioma 3.3).

Para a (a + b) = a, basta tomar o dual do item anterior.

(cid:4)

6. Associatividade

Para quaisquer a, b, c ∈ A, tem-se que a + (b + c) = (a + b) + c e a · (b · c) =
(a · b) · c.

Demonstração. Antes de provar as propriedades associativas, é necessário enun-
ciar a seguinte aﬁrmação (que também será demonstrada):

Aﬁrmação 3.2. Para quaisquer a, b, c ∈ A, a [(a + b) + c] = [(a + b) + c] a = a.

Demonstração. Com efeito,

a [(a + b) + c] = [(a + b) + c] a (Axioma 3.1)
(Axioma 3.2)
= a (a + b) + ac
(Propriedade 5)
= a + ac
(Propriedade 5).
= a

(cid:4)

Agora, utilizando a aﬁrmação acima, provaremos a associatividade na álgebra
booleana. De fato,

Capítulo 3. A Álgebra de Boole

44

Z = [(a + b) + c] [a + (b + c)]

= [(a + b) + c] a + [(a + b) + c] (b + c)
= a + [(a + b) + c] (b + c)
= a + [(a + b) + c] b + [(a + b) + c] c
= a + [(b + a) + c] b + [(a + b) + c] c
= a + b + [(a + b) + c] c
= a + (b + c) .

De maneira análoga,

Z = [(a + b) + c] [a + (b + c)]
Z = (a + b) [a + (b + c)] + c [a + (b + c)]

= (a + b) [a + (b + c)] + c
= a [a + (b + c)] + b [a + (b + c)] + c
= a [a + (b + c)] + b + c
= (a + b) + c.

Portanto, a + (b + c) = (a + b) + c.

(Axioma 3.2)
(Aﬁrmação 3.2)
(Axioma 3.2)
(Axioma 3.1)
(Aﬁrmação 3.2 e Propriedade 5)

(Axioma 3.2)
(Aﬁrmação 3.2)
(Axioma 3.2)
(Aﬁrmação 3.2 e Propriedade 5)

A demonstração de a · (b · c) = (a · b) · c segue pelo dual da anterior.

(cid:4)

7. Complemento do 0 e do 1

Tem-se 00 = 1 e 10 = 0.

Demonstração. Temos

00 = 00 + 0 (Axioma 3.3)
(Axioma 3.4).

= 1

Para 10 = 0, basta tomar o dual do item anterior.

(cid:4)

8. Unicidade do complemento

O inverso de qualquer elemento a ∈ A é único, isto é, se a + x = 1 e a · x = 0
para algum x ∈ A, então x = a0.

Demonstração. Por absurdo, suponhamos que há dois elementos a0
1
distintos, tais que

e a0
2

em A,

a + a0
1

= 1;

a + a0
2

= 1;

a · a0
1

= 0

e

a · a0
2

= 0.

Capítulo 3. A Álgebra de Boole

45

Assim, temos

Analogamente,

a0
1

a0
2

= 1 · a0
1
= (a + a0
2
+ a0
= a · a0
1
= 0 + a0
2 · a0
1
= a0
2 · a0
1

) · a0
1
2 · a0
1

(Axioma 3.3)
(Hipótese)
(Axioma 3.3)
(Axioma 3.4)
(Axioma 3.3).

= 1 · a0
2
= (a + a0
1
+ a0
= a · a0
2
= 0 + a0
1 · a0
2
= a0
1 · a0
2

) · a0
2
1 · a0
2

(Axioma 3.3)
(Hipótese)
(Axioma 3.3)
(Axioma 3.4)
(Axioma 3.3).

Portanto, pelo Axioma 3.1, segue que a0
1

= a0
2

.

9. Involução

Para todo a ∈ A, (a0)0 = a.

Demonstração. Seja (a0)0 = b. Temos, pelo axioma 3.4,

a0 · b = 0

e

e a0 + b = 1.

Ainda, por 3.4,

a0 · a = 0

e

e a0 + a = 1.

Devido a unicidade do complemento, (a0)0 = b = a.

(cid:4)

(cid:4)

10. Teorema de DeMorgan

(GÜNTZEL; NASCIMENTO, 2001, p. 2) aﬁrmam que “o primeiro teorema
de DeMorgan diz que a complementação de um produto (lógico) equivale a soma
(lógica) das negações de cada variável do referido produto”. Em termos matemáti-
cos, para quaisquer elementos a1, a2, a3, . . . ∈ A,

(a1 · a2 · a3 · · · · )0 = a0
1

+ a0
2

+ a0
3

+ · · ·

Capítulo 3. A Álgebra de Boole

46

Analogamente, “o segundo teorema é o dual (i.e., o espelho) do primeiro, ou
seja, a complementação de uma soma (lógica) equivale ao produto das negações
individuais das variáveis” (GÜNTZEL; NASCIMENTO, 2001, p. 2). Isto é,

(a1 + a2 + a3 + · · · )0 = a0

1 · a0

2 · a0

3 · · · ·

O resultado geral segue por indução, para isto, basta motrarmos que o resul-
tado vale para a1 e a2. Particularizando para duas incógnitas, temos que, para
quaisquer a, b ∈ A,

(a + b)0 = a0 · b0

e

(a · b)0 = a0 + b0

Demonstração. Antes de provar o Teorema, vamos anunciar e demonstrar duas
aﬁrmações:

Aﬁrmação 3.3. (a + b) + a0 · b0 = 1

Demonstração. Com efeito,

(a + b) + a0 · b0 = [(a + b) + a0] · [(a + b) + b0]
= [a0 + (a + b)] · [b0 + (a + b)]
= [(a0 + a) + b] · [a + (b0 + b)]
= 1 · 1
= 1

(Axioma 3.2)
(Axioma 3.1)
(Propriedade 6 e Axioma 3.1)
(Axioma 3.4 e Propriedade 4)
(Axioma 3.3).

Aﬁrmação 3.4. (a + b) · a0 · b0 = 0

Demonstração. De fato,

(a + b) · a0 · b0 = a · (a0 · b0) + b · (b0 · a0)
= (a · a0) · b0 + (b · b0) · a0
= 0 + 0
= 0

(Axiomas 3.1 e 3.2)
(Propriedade 6)
(Axioma 3.4 e Propriedade 4)
(Axioma 3.3).

(cid:4)

(cid:4)

Logo, pela unicidade do complemento, conclui-se que (a + b)0 = a0 · b0.

A demonstração da igualdade (a · b)0 = a0 + b0, dual de (a + b)0 = a0 · b0, pode
ser demonstrada através do princípio da dualidade. Portanto, tem-se (a · b)0 =
(cid:4)
a0 + b0.

Capítulo 3. A Álgebra de Boole

47

11. Expressões elementares

Além das propriedades, leis e teoremas apresentados até aqui, ainda existem
outras expressões que, por vezes, são utilizadas. São elas:

a) a0 + a · b0 = a0 + b0

b) a0 + a · b = a0 + b

c) a + a0 · b = a + b

d) a + a0 · b0 = a + b0

e) (a + b) (a + c) = a + b · c

A validade dessas expressões pode ser comprovada a partir de manipulações al-
gébricas com as propriedades já anunciadas e demonstradas. No entanto, aqui
omitiremos tais demonstrações.

É importante salientar que as demonstrações, aqui realizadas na forma algébrica,
também poderiam ter sido realizadas através de tabelas verdades e/ou de Dia-
gramas de Venn.

3.4 Expressões e Funções Booleanas

3.4.1 Expressões Booleanas

(LIPSCHUTZ; LIPSON, 1976) dizem que, ao considerar um conjunto de variáveis
(letras e/ou símbolos), digamos a1, a2, · · · , an, uma expressão booleana nestas variáveis
é deﬁnida como qualquer variável ou qualquer expressão construída a partir dessas,
utilizando as operações +, · ou 0. Obviamente, as expressões booleanas devem ser bem
formadas, isto é, as operações + e · são binárias, enquando a operação 0 é unitária.

Por exemplo,

(a + b0 · c)0 + (a · b · c0 + a0 · b)0

e

h(a · b0 · c + b)0 + a0 · c

i0

são expressões booleanas nas variáveis a, b e c.

(GÜNTZEL; NASCIMENTO, 2001, p. 13) aﬁrmam que “um literal é uma variável
negada ou um variável não negada”. Assim, por exemplo, o literal pode ser a variável
booleana a ou o seu complemento a0.

(LIPSCHUTZ; LIPSON, 1976) deﬁnem um produto fundamental como um produto
de dois ou mais literais, em que dois dos quais não envolvem a mesma variável. Assim,

a · b0,

a · b0c,

a,

b0

e

a ·0 b · c

Capítulo 3. A Álgebra de Boole

48

são exemplos de produtos fundamentais, enquanto a · b · a0 · c e a · b · c · b não são.

No entanto, qualquer produto que envolva literais pode ser reduzido a 0 ou a um
produto fundamental, utilizando as propriedades da álgebra booleana. Isso justiﬁca-se
com base no Axioma 3.4 e na Propriedade 3, pois, caso exista um produto da mesma
variável na forma negada e não negada, recorremos ao Axioma 3.4, que resultará aquele
produto em 0, e, se existir um produto de uma variável na mesma forma, recorremos
a propriedade de Idempotência (propriedade 3), que nos resultará apenas em uma
variável, resultando, assim, num produto fundamental.

Vejamos os exemplos a seguir:

Exemplo 10. a · b · a0 · c

a · b · a0 · c = a · a0 · b · c

(Axioma 3.1)

= (a · a0) · b · c (Propriedade 6)
= 0 · b · c
= 0

(Axioma 3.4)
(Propriedade 4)

Exemplo 11. a · b · c · b

a · b · c · b = a · b · b · c

(Axioma 3.1)

= a · (b · b) · c (Propriedade 6)
(Propriedade 3)
= a · b · c

Portanto, vimos, nestes exemplos, que podemos reduzir as expressões a 0 ou a
um produto fundamental. Raciocínio análogo seria utilizado para reduzir qualquer
expressão a 0 ou a um produto fundamental que envolva variáveis booleanas. O caso
onde a expressão é 0 ou é um produto que já encontra-se na forma reduzida, o resultado
é óbvio.

3.4.2 Funções booleanas

Dada uma álgebra booleana hA, +, ·,0 , 0, 1i e uma expressão booleana em n variáve-
is a1, a2, · · · , an, tem-se que uma função booleana é deﬁnida como f : An → A, onde o
valor da função f para um elemento b = (b1, b2, · · · , bn) ∈ An é calculado substituindo
cada ocorrência de ai na expressão por bi, para i = 1, 2, · · · , n. (HIRATA, 2005)

Exemplo 12. A função f : A2 → A, deﬁnida pela expressão f (a1, a2) = a1 + a2 pode
ser representada pela tabela verdade a seguir:

Capítulo 3. A Álgebra de Boole

49

a1
0

0

1

1

a2
0

1

0

1

a1 + a2
0

1

1

1

∗

Exemplo 13. Outro exemplo de função booleana é g : A2 → A, onde g (a1, a2) =
a1 + a0

1 · a2, cuja tabela verdade é a seguinte:

a1
0

0

1

1

a2
0

1

0

1

a’1
1

a’1 · a2
0

1 · a2

a1 + a0
0

1

0

0

1

0

0

1

1

1

∗

Notemos que as tabelas-verdade dos Exemplos 12 e 13 são iguais (destaque para ∗,
1 · a2 são equivalentes, isto é, deﬁnem

isto implica que as expressões a1 + a2 e a1 + a0
uma mesma função).

Algumas formas para descrever/representar funções booleanas são:

• expressões booleanas;

• tabelas verdades;

• diagramas;

• circuitos.

3.5 Derivação de Expressões Booleanas

(GÜNTZEL; NASCIMENTO, 2001, p. 9) aﬁrmam que, frente a uma tabela verdade
que descreva uma função booleana, “derivar uma expressão booleana para esta função
é encontrar uma equação que a descreva”.

Há basicamente duas maneiras de se deﬁnir (ou descrever) uma função
booleana: descrevendo-se todas as situações das variáveis de entrada
para as quais a função vale 1 ou, alternativamente, todas as situ-
ações em que a função vale 0. O primeiro método é conhecido por
Soma de Produtos (SdP), enquanto o segundo é chamado Produto de
Somas (PdS). Qualquer função booleana pode ser descrita por meio
de soma de produtos ou por meio de produtos de somas. Como as
funções booleanas só podem assumir um dentro dois valores (0 ou 1),
basta usar-se um dos dois métodos para se encontrar uma equação
para uma função. (GÜNTZEL; NASCIMENTO, 2001, p. 9)

Capítulo 3. A Álgebra de Boole

50

Vejamos como eles acontecem.

3.5.1 Soma de Produtos (SdP)

A derivação de uma expressão de termos usando soma de produtos acontece por

meio do que, na Álgebra Booleana, é chamado de mintermos.

(HIRATA, 2005) deﬁne mintermos (ou produto canônico) em n variáveis, a1, a2, · · · , an,

como uma expressão booleana formada pelo produto de cada uma das n variáveis ou
dos respectivos complementos, mas não de ambas. A notação para o mintermo é mn,
n ∈ {0, 2n − 1}, onde n é a linha na tabela-verdade que descreve a função correspon-
dente.

A lógica utilizada no minterno é a do 1, ou seja, na tabela verdade, os valores de
saída analisados são os que forem 1. Para as variáveis de entrada, aquelas que valerem
1, terão sua representação na forma normal, caso contrário, ou seja, se for 0, a variável
será negada.

Como estamos derivando uma expressão por meio de somas de produtos, cada linha
cuja variável de saída for 1, terá aqueles literais sendo multiplicados (operação “e” :
·); no ﬁnal, os mintermos serão somados (operação “ou” : +) a ﬁm de encontrar a
expressão de soma de produtos correspondente.

A tabela verdade seguinte apresenta todos os mintermos com 3 variáveis.

Tabela 10 – Tabela verdade de mintermos com 3 variáveis

a b c
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1

ma,b,c = mn
a’ ·b0 · c0 = m0
a’ ·b0 · c = m1
a’ ·b · c0 = m2
a’ ·b · c = m3
a ·b0 · c0 = m4
a ·b0 · c = m5
a ·b · c0 = m6
a ·b · c = m7

Fonte: Autora

Vejamos um exemplo de como derivar uma expressão booleana através de soma de

produtos:

Exemplo 14. Encontrar uma expressão em soma de produtos (SdP) para função f
que está descrita na seguinte tabela verdade:

Capítulo 3. A Álgebra de Boole

51

a
0

0

0

0

1

1

1

1

b

0

0

1

1

0

0

1

1

c

0

1

0

1

0

1

0

1

f

0

0

1

1

0

1

1

0

Os valores de saída que tem valor 1 são correspondentes aos mintermos m2, m3,
m5 e m6, sendo que, pela tabela 10, m2 = a0 · b · c0, m3 = a0 · b · c, m5 = a · b0 · c e
m6 = a · b · c0. Logo, a expressão de soma de produtos equivalente a esta função será a
soma destes mintermos, isto é f = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0.

3.5.2 Produdo de Somas (PdS)

A derivação de uma expressão usando produto de somas é o método inverso ao de

soma de produtos, ou seja, o dual, e ela acontece por meio do chamado maxtermo.

(HIRATA, 2005) deﬁne maxtermo, ou soma canônica, em n variáveis, a1, a2, · · · , an,
como uma soma de n literais, cada um correspondendo a uma variável. A notação para
o maxtermo é Mn = n ∈ {0, 2n − 1}, onde n é a linha na tabela verdade que descreve
a função correspondente.

Mintermos e maxtermos diferem em um se referir a produtos e o outro a somas,

nesta ordem.

A lógica utilizada no maxtermo é a do 0, ou seja, na tabela verdade, os valores
de saída analisados serão os que forem 0. Para as variáveis de entrada, aquelas que
valerem 0 terão sua representação na forma original, caso contrário, isto é, se for 1, a
variável será negada.

Como estamos derivando uma expressão por meio de produtos de somas, cada linha,
cuja variável de saída for 0, terá aqueles literais sendo somados (operação “ou”: +) e,
no ﬁnal, os maxtermos serão multiplicados (operação “e” : ·), para, assim, encontrar a
expressão de produto de somas correspondente.

É importante chamar a atenção para o fato de que a soma, neste caso, terá pre-
Isto signiﬁca que o uso dos parenteses em torno de cada

cedência sob o produto.
maxtermo se torna obrigatório.

A tabela seguinte traz todos os maxtermos possíveis com 3 variáveis.

Capítulo 3. A Álgebra de Boole

52

Tabela 11 – Tabela verdade de maxtermos com 3 variáveis

a b c
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1

Ma,b,c = Mn
a + b + c = M0
a + b + c’ = M1
a + b’ + c = M2
a + b’ + c’ = M3
a’ + b + c = M4
a’ + b + c’ = M5
a’ + b’ + c = M6
a’ + b’ + c’ = M7

Fonte: Autora

Vejamos um exemplo de como derivar uma expressão booleana através de produto

de somas.

Exemplo 15. Encontrar uma expressão em produto de somas (PdS) para a função que
está descrita na seguinte tabela verdade:

a
0

0

0

0

1

1

1

1

b

0

0

1

1

0

0

1

1

c

0

1

0

1

0

1

0

1

f

0

0

1

1

0

1

1

0

Os valores de saída que tem valor 0 correspondem aos maxtermos M0, M1, M4 e
M7, sendo que, pela tabela 11, M0 = a + b + c, M1 = a + b + c0, M4 = a0 + b + c e
M7 = a0+b0+c0. Logo, a expressão de produto de somas equivalente a esta função será o
produto destes maxtermos, isto é, f = (a + b + c) (a + b + c0) (a0 + b + c) (a0 + b0 + c0).

3.6 Simpliﬁcação de Expressões Booleanas

Há algumas expressões que trazem consigo muitos elementos (produtos, somas e/ou
negações envolvendo as variáveis), então, é normal que se deseje reduzir, ao máximo,
o número de operações contidas na expressão. Assim, este “processo de redução de
literais (ou de redução de operações, equivalentemente) é denominado simpliﬁcação”.
(GÜNTZEL; NASCIMENTO, 2001, p. 13)
(HIRATA, 2005, p. 45) ressalta que

Capítulo 3. A Álgebra de Boole

53

se uma expressão pode ser derivada a partir de outra aplicando-se
um número ﬁnito de vezes as regras (leis/propriedades) da álgebra
booleana, então elas são ditas equivalentes. O valor de expressões
equivalentes, para cada atribuição de valores às variáveis booleanas,
é o mesmo”.

(BARANAUSKAS, 2012, p. 14) aﬁrma que “há duas formas para simpliﬁcar ex-
pressões booleanas: fatoração e mapas de Veitch-Karnaugh”. Vejamos como funciona
cada uma delas.

3.6.1 Fatoração

Este método consiste em manipulações algébricas, com sucessivas aplicações dos
axiomas e propriedades da álgebra booleana, com o objetivo de simpliﬁcar, ao máximo,
a expressão.

Exemplo 16. Vamos simpliﬁcar a expressão booleana S = a · b · c + a · c0 + a · b0.

S = a · b · c + a · c0 + a · b0
= a (b · c + c0 + b0)
= a (b · c + (c0 + b0))
= a

(cid:18)

b · c + (cid:16)(c0 + b0)0(cid:17)0(cid:19)
(cid:18)(cid:16)(c · b)0(cid:17)0(cid:19)0(cid:19)

= a

(cid:18)

b · c +
b · c + (c · b)0(cid:17)
b · c + (b · c)0(cid:17)

(cid:16)

(cid:16)

= a
= a
= a · 1
= a

(Axioma 3.2)
(Propriedade 6)

(Propriedade 9)

(Teorema 10)

(Propriedade 9)

(Axioma 3.1)

(Axioma 3.4)
(Axioma 3.3)

Vimos, neste exemplo, como uma expressão pode ser simpliﬁcada através de apli-
cações sucessivas das propriedades da álgebra booleana. Nele, percebemos que, para
simpliﬁcar um expressão, o primeiro passo é identiﬁcar os termos de produtos que se
diferenciam apenas por um literal, a ﬁm de aplicar a propriedade distributiva. Na ver-
dade, este é sempre a primeira etapa em qualquer simpliﬁcação que envolva variáveis
booleanas.

Executada esta etapa, as próximas consistem em aplicar sucessivas vezes axiomas
e propriedades já conhecidas da álgebra booleana até que a expressão seja reduzida o
máximo possível.

Vejamos outro exemplo.

Exemplo 17. Simpliﬁcar a expressão S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0.

Identiﬁcando os produtos que diferem apenas por um literal, temos a0 · b · c0 e a0 · b · c.

Seguindo os passos já descritos para simpliﬁcação, teremos:

Capítulo 3. A Álgebra de Boole

54

S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0
= a0 · b (c + c0) + a · b0 · c + a · b · c0
= a0 · b · 1 + a · b0 · c + a · b · c0
= a0 · b + a · b0 · c + a · b · c0
= a0 · b + a · c0 · b + a · b0 · c
= b (a0 + a · c0) + a · b0 · c
= b (a0 + c0) + a · b0 · c
= a0 · b + b · c0 + a · b0 · c

(Axioma 3.2)
(Axioma 3.4)
(Axioma 3.3)
(Axioma 3.1)
(Axioma 3.2)
(Axiomas 3.2, 3.3 e 3.4)
(Axioma 3.2)

Notemos que na expresão a0 · b + a · b0 · c + a · b · c0 já obtemos uma simpliﬁcação em
relação à expressão original, uma vez que houve redução no número de operações e de
literais. Assim, essa expressão pode ser dita como uma soma de produtos simpliﬁcada,
porém não é mínima, visto que ainda seria possível realizar manipuções algébricas, a
ﬁm de reduzir ainda mais a expressão dada.

Em a0 · b + b · c0 + a · b0 · c, foram feitas todas as simpliﬁcações possíveis, pois
foram agrupados e simpliﬁcados todos os termos que diferiam apenas por uma variável.
Quando isso acontece, a expressão chega a sua máxima simpliﬁcação. As expressão
b (a0 + c0) + a · b0 · c, por sua vez, é dita expressão na forma fatorada.

3.6.2 Mapas de Veitch-Karnaugh

Conforme acrescenta (BARANAUSKAS, 2012, p. 28)

alternativamente ao método de simpliﬁcação algébrico por fatoração,
há outro método de simpliﬁcação baseado na identiﬁcação visual de
grupos de mintermos que podem ser simpliﬁcados. Para tanto, é
necessário que os mintermos seja dispostos, de maneira conveniente,
em tabelas conhecidas como diagramas ou mapas de Veitc-Karnaugh.

Nesse sentido, o mapa de Karnaugh, idealizado em 1952 por Edward Veitch e aper-
feiçoado por Maurice Karnaugh, é um método de simpliﬁcação de expressões booleanas,
utilizando representações gráﬁcas. (ABAR, 2004)

O modo mais prático para a aplicação deste método é utilizando a tabela verdade
determinada pela expressão que se deseja simpliﬁcar. Feito isso, devemos distribuir
estes valores, de modo conveniente, no mapa de Karnaugh.

Para isto, consideremos Sn, n ∈ {0, 2n − 1}, onde n é o número de variáveis da
expressão, o valor ﬁnal da n-ésima linha na tabela verdade. Por exemplo, para 2 e 3
variáveis temos, respectivamente, as seguintes tabelas verdades:

Capítulo 3. A Álgebra de Boole

55

Tabela 12 – Tabela verdade apresentando o valor ﬁnal Sn com 2 variáveis

a b
0
0
1
0
0
1
1
1

Sn
S0
S1
S2
S3

Fonte: Autora

Tabela 13 – Tabela verdade apresentando o valor ﬁnal Sn com 3 variáveis

a b c
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1

Sn
S0
S1
S2
S3
S4
S5
S6
S7

Fonte: Autora

Esses valores Sn, n ∈ {0, 2n − 1} devem ser aplicados no mapa da seguinte forma:

Figura 3 – Distribuição no mapa para 2 variáveis

Fonte: Autora

Figura 4 – Distribuição no mapa para 3 variáveis

Fonte: Autora

Capítulo 3. A Álgebra de Boole

56

É importante enfatizar a questão de todos os valores Sn sejam dispostos exatamente
como está no mapa, onde, de um quadro para o outro, há a menor mudança possível
das constantes.

Na distribuição da ﬁgura 3 está claro os valores de entrada em relação as suas
variáveis, já na da 4, onde na primeira linha estão dispostos as possíveis entradas para
bc, os valores das demais linhas correspondem aos valores de b e c, respectivamente.

Estamos mostrando exemplos para duas e três variáveis. No entanto, para mais

variáveis a ideia seria a mesma.

Assim, como os valores possíveis para Sn são 0 ou 1, esse método de simpliﬁcação
consiste em fazer agrupamentos, quando possível, de todos os “1” existentes no mapa.
Esses agrupamentos, por sua vez, devem ser feitos traçando grupos de múltiplos de 2
“1” adjacentes, onde nenhum “1” pode ﬁcar de fora dos grupos formados, sendo que,
se necessário, ele pode ser agrupado mais de uma vez, mas nunca sem necessidade.
(ABAR, 2004) No entanto, “é importante ressaltar que o conceito de adjacência é
aplicável na horizontal e na vertical, mas nunca na diagonal”. (GÜNTZEL; NASCI-
MENTO, 2001, p. 19)

Vejamos, na ﬁgura seguinte, os possíveis agrupamentos para uma expressão de três

variáveis, visto que, na de duas, todos são agrupáveis, exceto na diagonal.

Figura 5 – Possíveis agrupamentos para 3 variáveis

Fonte: Autora

Após a identiﬁcação de todos os grupos de “1” adjacentes entre si, cada um deles
originará um produto, onde as variáveis deste serão as que correspondem aos valores
de entrada comuns a todos os componentes do grupo. É importante ressaltar que, se o
valor comum for 1, a variável ﬁcará na sua forma original, no entanto, se for 0, estará
na forma complementar ou negada.

O resultado ﬁnal será a soma de todos os produtos obtidos na junção dos grupos.
Em termos operacionais da álgebra booleana, os grupos formados estão munidos
através da operação · (“e”) e, os diferentes grupos, serão somados (+, operação “ou”).
Vejamos como essa forma de simpliﬁcação funciona com as expressões já simpliﬁ-

cadas anteriormente.

Exemplo 18. Simpliﬁcar a função S = a · b · c + a · c0 + a · b0.

Capítulo 3. A Álgebra de Boole

57

Tabela verdade:

Tabela 14 – Tabela verdade da função S = a · b · c + a · c0 + a · b0
S = a ·b · c + a · c0 + a · b0
a b c b’
0
1
0
0
1
0
0
0
0
0
0
0
1
1
1
1
1
1
1
0
1
1
0
1

a ·b · c
0
0
0
0
0
0
0
1

a ·c0
0
0
0
0
1
0
1
0

a ·b0
0
0
0
0
1
1
0
0

c’
1
0
1
0
1
0
1
0

0
0
1
1
0
0
1
1

0
1
0
1
0
1
0
1

Fonte: Autora

Figura 6 – Mapa de Karnaugh para função S = a · b · c + a · c0 + a · b0

Fonte: Autora

Portanto, extraindo os valores de saída da tabela 14 e colocando-os no mapa da
ﬁgura 6, temos que o conjunto de “1” encontrado são os quatro que encontram-se na
última linha. Nela, o único valor comum a todos ele é o 1, que está fazendo referência
a variável a. Portanto, a simpliﬁcação resulta em S = a.

Exemplo 19. Simpliﬁcar a função S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0.

Tabela 15 – Tabela verdade da função S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0

a b c
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1

a’ b’
1
1
1
1
0
1
0
1
1
0
1
0
0
0
0
0

c’
1
0
1
0
1
0
1
0

a’ ·b · c0
0
0
1
0
0
0
0
0

a’ ·b · c
0
0
0
1
0
0
0
0

a ·b0 · c
0
0
0
0
0
1
0
0

a ·b · c0
0
0
0
0
0
0
1
0

S
0
0
1
1
0
1
1
0

Fonte: Autora

Capítulo 3. A Álgebra de Boole

58

Figura 7 – Mapa de Karnaugh para função S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0

Fonte: Autora

Extraindo os valores de saída da tabela 15 e colocando-os no mapa da ﬁgura 7,
temos que os conjuntos de “1” encontrados são os que encontram-se na última coluna,
onde as constantes comuns são o 1 e 0, representando b e c, respectivamente, que
resulta no produto entre b e c negado, visto que a constante do c é 0; encontramos
também a junção de dois “1” na quarta e quinta coluna da segunda linha, onde as
constantes comuns são 0 e 1, que representam o a e o b, respectivamente, que resultará
em a0 · b; e, por ﬁm, há um único 1 no valor correspondente à terceira linha, terceira
coluna, que tem como constantes 1, 0 e 1, que implica no produto a · b0 · c. Portanto,
fazendo a soma de cada produto encontrado, temos que a simpliﬁcação para função
S = a0 · b · c0 + a0 · b · c + a · b0 · c + a · b · c0 é S = a0 · b + b · c0 + a · b0 · c.

Vimos nesta seção, portanto, duas formas distintas de simpliﬁcar expressões booleanas:

a fatoração, onde a simpliﬁcação é feita algebricamente por meio da manipulação e/ou
aplicações de axiomas e propriedades da álgebra booleana, e o processo de simpliﬁcação
fazendo uso do mapa de Karnaugh, que é uma técnica onde, através de uma tabela
verdade e de um mapa que irá utilizar, convenientemente, valores da tabela verdade,
obtém-se, ao ﬁnal do processo, a menor expressão possível.

4 Circuitos Lógicos e Aplicações

59

Neste capítulo, iremos comentar sobre os circuitos lógicos, que são construídos
através de portas lógicas; outros operadores lógicos, além dos básicos, também serão
abordados; e, por ﬁm, serão mostradas algumas aplicações da Álgebra de Boole.

4.1 Circuitos Lógicos

Já vimos que uma função booleana pode ser representada por uma
equação ou detalhada por sua tabela verdade. Mas uma função
booleana também pode ser representada de forma gráﬁca, onde cada
operador está associado a um símbolo especíﬁco, permitindo o imedi-
ato reconhecimento visual. Tais símbolos são reconhecidos por portas
lógicas. (GÜNTZEL; NASCIMENTO, 2001, p. 6)

Como também já visto, um conjunto de operadores, juntamente com variáveis, dão
origem a uma expressão booleana. Voltado para um contexto de símbolos, quando
os operadores algébricos são substituídos por portas lógicas, um conjunto de portas
lógicas dão origem aos circuitos lógicos. As portas lógicas, por sua vez, podem ser
vistas como circuitos elementares.

Cada circuito lógico pode ser visto como uma máquina L que contém um ou mais
dispositivos de entrada e exatamente um dispositivo de saída. Cada dispositivo de
entrada em L envia um sinal, especiﬁcamente, um bit (dígito binário), 0 ou 1, para o
circuito L e este processa o conjunto de bits para gerar um bit de saída. Por conseguinte,
uma sequência de n bits pode ser atribuída a cada dispositivo de entrada e L processa
as sequências de entrada, um bit de cada vez, para produzir uma sequência de saída
de n bits.

A introduçao da álgebra booleana no estudo dos circuitos lógicos ocorreu somente
em 1938, com o matemático americano Claude Elwood Shannon (1916 − 2001), quando
ele percebeu o paralelo entre lógica poposicional e a lógica de circuitos, e compreendeu
que esta álgebra poderia ter um papel fundamental na sistematização de um novo ramo
da eletrônica. (SANTOS; OLIVEIRA, 2016)

Portanto, “a álgebra booleana descreve os circuitos que podem ser construídos pela
combinação de portas lógicas em que as variáveis e funções pode ter apenas valores 0
e 1”. (VIEIRA, 2000, p. 11)

Veremos como funcionam as portas lógicas para, em seguida, investigar os circuitos

lógicos.

Capítulo 4. Circuitos Lógicos e Aplicações

60

4.1.1 Portas Lógicas

“As portas lógicas representam mais do que símbolos de operadores, elas represen-
tam circuitos físicos, como, por exemplo, os circuitos eletrônicos, sendo 0 a ausência de
tensão (0 volt) e 1 a presença de tensão (normalmente 5 volts).” (OLIVEIRA, 2017, p.
26)

Há três portas lógicas fundamentais, cada uma para representar os operadores lógi-
cos “ou”, “e” e “não”. Neste trabalho, vamos adotar a convenção de que as linhas que
entram à esquerda da porta são as de entrada e, à direita, será a de saída, que é única.

Vejamos cada uma dessas portas lógicas:

Figura 8 – Portas lógicas

Fonte: Autora

As portas “ou” e “e” necessitam de pelo menos duas entradas, pois representam
a adição e a multiplicação lógica, respectivamente, e têm exatamente uma saída. Já
a porta “not”, também chamada de porta inversora, que representa a negação ou
complemento, só pode ser realizada com uma variável por vez, tendo, portanto, apenas
uma única entrada e uma única saída.

É importante acrescentar que a porta “not” também pode ser representada por
meio de uma aplicação direta da variável a ser negada na operação seguinte, como na
ﬁgura 9.

Figura 9 – Portas lógicas com o inversor aplicados diretamente na operação

Fonte: Autora

4.1.2 Exemplos de Circuitos Lógicos

Dada uma função booleana qualquer, é possível desenhar o circuito lógico que a
representa, sendo que este circuito é composto das portas lógicas relacionadas às ope-

Capítulo 4. Circuitos Lógicos e Aplicações

61

rações que são realizadas sobre as variáveis de entrada. Os resultados das operações
são conduzidos por ﬁos, os quais, no desenho, são representados por linhas simples.
(GÜNTZEL; NASCIMENTO, 2001)

Para construir um circuito lógico, a ordem é similar à seguida no processo de sim-
pliﬁcação de uma função booleana: complemento, parenteses, produto e soma. Para
cada variável de entrada, traça-se uma linha saindo delas até as portas necessárias para
representar cada uma das subexpressões.

Exemplo 20. Vejamos como ﬁca o circuito lógico da função D = A + B · C 0.

Figura 10 – Circuito lógico D = A + B · C 0

Fonte: Autora

Exemplo 21. Fazendo o procedimento inverso, porém na mesma linha de raciocínio,
vejamos como, frente a um circuito lógico, podemos encontrar a função que o determi-
nou.

Capítulo 4. Circuitos Lógicos e Aplicações

62

Figura 11 – Circuito lógico

Fonte: Autora

Esse circuito também poderia ser repesentado como segue abaixo, que nos levaria à

mesma função booleana.

Figura 12 – Circuito lógico

Fonte: Autora

Nesse caso, o método mais prático é começar analisando as portas da direita para
esquerda, acompanhando as linhas que as geraram, até chegar às variáveis. Assim, a
primeira porta encontrada é a “ou”, o que signiﬁca que teremos uma soma, que foi
gerada por duas portas “e”, ou seja, esta será uma soma de dois produtos. O primeiro
produto é entre a variável A, que passou pela porta inversora, e a variável B, ou seja,
A0·B; já o segundo é o produto é entre as variáveis A e B, sendo que esta última também

Capítulo 4. Circuitos Lógicos e Aplicações

63

passou pela porta inversora, logo A · B0. Portanto, este circuito pode ser expresso pela
função C = A0 · B + A · B0.

Conforme aﬁrmam (GÜNTZEL; NASCIMENTO, 2001, p. 13),

o número de elementos (portas lógicas e conexões) de um circuito
lógico depende diretamente do número de operações booleanas (in-
versão, “e” e “ou”) contidas na expressão associada. Desta forma, é
normal que se deseje reduzir o número de operações contidas numa
função de modo a poder-se implementá-la com circuitos lógicos mais
simples e, portanto, de menos custo.

Assim, “no contexto de circuitos, uma das questões mais importantes é saber de-
terminar o melhor circuito (em termos de custo, eﬁciência, etc) que realiza uma dada
função” (HIRATA, 2005, p. 52). Esses circuitos mais simples podem ser obtidos através
da simpliﬁcação da expressão da função original, conforme visto na seção 3.6.

Logo, ao invés de construir o circuito lógico da função booleana F = A0 · B · C 0 + A0 ·
B · C + A · B0 · C + A · B · C 0, poderíamos construir o circuito equivalente da expressão
reduzida F = A0 · B + B · C 0 + A · B0 · C, que seria o seguinte:

Figura 13 – Circuito lógico F = A0 · B + B · C 0 + A · B0 · C

Fonte: Autora

É importante chamar atenção para o fato de que, na imagem, ﬁos que se cruzam,
onde aqueles que não tem o pontinho preto não possuem conexão entre si. Caso
fossémos fazer o circuito da função F = A0 · B · C 0 + A0 · B · C + A · B0 · C + A · B · C 0,
teríamos

Capítulo 4. Circuitos Lógicos e Aplicações

64

Figura 14 – Circuito lógico F = A0 · B · C 0 + A0 · B · C + A · B0 · C + A · B · C 0

Fonte: Autora

onde é notório a redução do tamanho do circuito da ﬁgura 13 em relação ao da 14.

4.2 Outros Operadores Lógicos

Além dos operadores já vistos até aqui, existem outros não muito utilizados, que
são formados pela combinação dos operadores básicos (OU, E e NOT). Estes são NOR
(a + b)0, que é o complemento da operação OU; NAND (a · b)0, ou seja, o complementar
da operação E; XOR (a ⊕ b), que signiﬁca a ou b, mas não ambos, ou seja, o OU exclu-
sivo; e, por ﬁm, XNOR (a ⊕ b)0, que é o NOR exclusivo. (GÜNTZEL; NASCIMENTO,
2001)

Conforme ressalta (LIPSCHUTZ; LIPSON, 1976), as operações NOR, NAND, XOR

e XNOR, analogamente às básicas OU e AND, podem ter duas ou mais entradas.

Vejamos a tabela verdade de cada um desses operadores para duas variáveis, e suas

respectivas portas lógicas.

Capítulo 4. Circuitos Lógicos e Aplicações

65

Figura 15 – Porta lógica do operador NOR

Fonte: Autora

Tabela 16 – Tabela verdade do operador NOR com 2 variáveis

A B (A + B)’
0
0
1
1

1
0
0
0

0
1
0
1

Fonte: Autora

Figura 16 – Porta lógica do operador NAND

Fonte: Autora

Tabela 17 – Tabela verdade do operador NAND com 2 variáveis

A B (A ·B)0
0
0
1
1

1
1
1
0

0
1
0
1

Fonte: Autora

Capítulo 4. Circuitos Lógicos e Aplicações

66

Figura 17 – Porta lógica do operador XOR

Fonte: Autora

Tabela 18 – Tabela verdade do operador XOR com 2 variáveis

A B A ⊕B
0
0
1
1

0
1
1
0

0
1
0
1

Fonte: Autora

Figura 18 – Porta lógica do operador XNOR

Fonte: Autora

Tabela 19 – Tabela verdade do operador XNOR com 2 variáveis

A B (A ⊕B)0
0
0
1
1

1
0
0
1

0
1
0
1

Fonte: Autora

Observemos que a única diferença entre as portas OU E NOR, E e NAND e XOR
e XNOR é que NOR, NAND e XNOR são seguidas por um círculo logo após o símbolo
original.

Capítulo 4. Circuitos Lógicos e Aplicações

67

É importante ressaltar que alguns textos também utilizam esse círculo após a porta
para indicar a inversão, que também poderia ser feita através da porta exclusiva para
negação da Figura 8, pois, como visto nesta seção, estes operadores são formadas
através de combinações dos operadores básicos OU, E e NOT.

4.3 Aplicações

O sistema algébrico apresentado neste capítulo dá origem, dentre outras aplicações,
ao que se convencionou chamar-se de Lógica Digital, que toma por base o sistema con-
ceitual da álgebra de Boole, sendo que a simbologia e as características dos elementos
com que opera modiﬁcam-se no sentido de operacionalizar máquinas elétricas, onde os
impulsos elétricos representam os valores lógicos (DIAS, 1994). Nesse sentido, iremos
mostrar que a álgebra booleana, muito utilizada para projetos de circuitos elétricos,
também se faz presente na programação do buscador Google, além de ter sido estímulo
para desenvolver jogos que despertam o desenvolvimento do raciocínio lógico.

4.3.1 Circuitos Elétricos

Analogamente ao já visto até aqui, na lógica digital também vamos contar com a
presença de duas constantes (0 e 1), que aqui vão representar os estados lógicos, isto
é, o estado lógico 0 e o estado lógico 1. Segundo (DIAS, 1994, p. 51),

ﬁsicamente, entretanto, tais estados estão associados à posição de
um interruptor ligado a um ponto de um dado circuito elétrico. Ou
seja, o estado lógico 1 passa a indicar o correspondente ao interruptor
fechado, isto é, quando o interruptor encontra-se fechado, o mesmo
permite que a corrente ﬂua através do ponto onde este se encontra.
Por outro lado, o estado lógico 0 relaciona-se ao interruptor aberto
e, consequentemente, nenhuma corrente pode passar pelo ponto con-
siderado.

Estabelecida essa relação, vamos ver como as funções booleanas, até aqui escritas
na forma algébrica, através de tabelas verdades ou de circuitos lógicos, podem ser
associadas, ﬁsicamente, aos circuitos elétricos.

4.3.1.1 Circuitos em Série

Os circuitos em série são os mais simples dos circuitos elétricos (OLIVEIRA, 2017)
e é aquele onde há um único percurso para a corrente de energia passar. Para efeitos de
ilustração, consideremos o seguinte circuito, onde U representa uma fonte de energia,
L uma lâmpada que se queira acender e A e B dois interruptores.

Capítulo 4. Circuitos Lógicos e Aplicações

68

Figura 19 – Circuito em Série

Fonte: Autora

Nela, L se acenderá se, e somente se, A e B estiverem ambos ligados, levando L ao
estado lógico 1. No entanto, se ao mesmo um dos interruptores estiver desligado L não
acenderá, o que implica o estado lógico 0.

Essa ideia pode ser transcrita pela seguinte tabela:

Tabela 20 – Tabela verdade de um circuito em série

A B L
0
0
0
0
1
0
0
0
1
1
1
1

Fonte: Autora

Neste exemplo, temos uma clara aplicações do operador AND, ou seja, de uma
multiplicação lógica. Assim, este circuito, que também pode ser chamado de circuito
AND, está associado a função booleana L = A · B.

4.3.1.2 Circuito em Paralelo

Vamos agora observar um exemplo de circuito que os interruptores estão conectados

em paralelo, onde a corrente elétrica tem dois caminhos a seguir.

Figura 20 – Circuito em Paralelo

Fonte: Autora

Capítulo 4. Circuitos Lógicos e Aplicações

69

Nesse caso, para que a lâmpada esteja acesa (estado lógico 1), é necessário e suﬁ-
ciente que pelo menos um dos interruptores esteja ligado, ou seja, a lâmpada só não
acenderá (estado lógico 0) se ambos os interruptores estiverem desligados. Podemos
traduzir esses fatos, na seguinte tabela:

Tabela 21 – Tabela verdade de um circuito em série

A B L
0
0
0
1
1
0
1
0
1
1
1
1

Fonte: Autora

Agora, é fácil ver que se trata de uma aplicação do operador OU, que resulta no

circuito OU, e L pode ser escrito algebricamente como L = A + B.

4.3.1.3 Circuito Misto

Neste caso, teremos aplicações dos operadores OU e E simultaneamente, como será

o caso do circuito a seguir:

Figura 21 – Circuito Misto

Fonte: Autora

Aqui, a lâmpada L se acenderá se o interruptor A estiver ligado e se um dos in-
terruptores B e C também estiver. Algebricamente, poderíamos traduzir este circuito
para L = A · (B + C).

4.3.1.4 Circuito Inversor

Teremos, agora, um aplicação do operador NOT. Para isto, consideremos o seguinte

circuito.

Capítulo 4. Circuitos Lógicos e Aplicações

70

Figura 22 – Circuito Inversor

Fonte: Autora

Nesse caso, quando A está ligado, L está apagado, pois o circuito inversor muda a
passagem da corrente elétrica. Já quando A está desligado, L se encontrará acesa, o
que dá origem a seguinte tabela verdade:

Tabela 22 – Tabela verdade de um circuito inversor

A L
1
0
0
1

Fonte: Autora

Em termos de álgebra booleana, temos uma aplicação do operador NOT, e, alge-

bricamente, este circuito pode ser traduzido por L = A0.

4.3.1.5 Circuitos NAND e NOR

Este circuito podem ser criados a partir da combinação dos circuitos OU, AND
e NOT, similar ao que aconteceu com os operadores. Vejamos exemplos de cada um
deles:

Figura 23 – Circuito NAND

Fonte: Autora

Capítulo 4. Circuitos Lógicos e Aplicações

71

Figura 24 – Circuito NOR

Fonte: Autora

Estes circuitos podem também ser expressos pelas tabelas verdades a seguir:

Tabela 23 – Tabela verdade de um circuito NAND
A B A ·B L
1
0
1
0
1
1
0
1

0
0
0
1

0
1
0
1

Fonte: Autora

Tabela 24 – Tabela verdade de um circuito NOR

A B A + B L
1
0
0
0
0
1
0
1

0
1
1
1

0
1
0
1

Fonte: Autora

Ou, de forma algébrica, L = (A · B)0 e L = (A + B)0, respectivamente.

4.3.2 Busca do Google

O Google, também chamado de Gigante das Buscas, é um site utilizado por milhares
de pessoas no mundo para buscas e pesquisas nos diversos segmentos. No entanto,
apesar dessa grande quantidade de usuários utilizá-lo, poucos sabem que, por trás de
sua base de programação, encontra-se a álgebra de Boole.

A busca do Google funciona com a utilização implícita do operador E. Por exemplo,
se é feito uma busca direta como “Números Binários”, o Google usa o comando E para
combinar as palavras “Números” e “Binários”. Em outros buscadores antigamente, ou
até mesmo no início do próprio Google as últimas páginas não traziam exatamente

Capítulo 4. Circuitos Lógicos e Aplicações

72

o resultado esperado, isso acontecia devido a presença do operador OU. No exemplo
“Números Binários”, as últimas páginas trariam resultados “Números” ou “Binários”,
mas o Google já inovou ao atualizar sua programação e hoje em dia só se faz uso do
operador E”. (OLIVEIRA, 2017)

É importante chamar atenção para o sinal de adição na barra de endereço, onde ﬁca

o link da pesquisa, que está separando as palavras chaves introduzidas no buscador.

Figura 25 – Barra de endereço de uma busca no Google

Fonte: Autora

“Vale ressaltar que o nome Google é um amálgama com o nome George Boole. Em
linguística amálgama é a mistura de duas palavras com o objetivo de formar um nova”
(OLIVEIRA, 2017, p. 35), inclusive o Google homenageou o 200◦ aniversário de seu
precursor George Boole com um Google Doodle, que simulava as portas lógicas, já
estudadas na subseção 4.1.1.

Figura 26 – Barra de endereço de uma busca no Google

Fonte:

(OLIVEIRA, 2017)

4.3.3 Jogos Boole

“Os jogos de Boole se constituem em um elemento motivador de aprendizagem,
principalmente entre alunos que demonstram diﬁculdades em realizar cálculos abstratos
por não terem o raciocínio lógico bem desenvolvido” (GIRELLI; BEZERRA, 2014, p.

Capítulo 4. Circuitos Lógicos e Aplicações

73

01) e é resultado de um projeto realizado há mais de 20 anos por Procópio Mendonça
Mello, com o objetivo de desenvolver formas de raciocínio matemático.

As histórias apresentadas nos jogos Boole têm como solução ver-
dadeiras matrizes, no sentido matemático do termo, isto é, quadros
de ﬁleiras e colunas conexas. As colunas correspondendo aos critérios
característicos da estrutura predeterminada e as linhas correspon-
dendo aos objetos de mesmas categorias (ou signiﬁcações). Os jo-
gos consistem na aplicação das operações booleanas aos enunciados
verbais, transformando estes em equações lógicas por intermédio da
simbologia da álgebra booleana. (MELLO, 2010, p. 183)

Estes jogos também são chamados de Problemas de Lógica.
A imagem que segue é um exemplo deste jogo.

Figura 27 – Jogo Boole - Diﬁculdade Normal

Fonte: Autora

Nele, as linhas e as colunas têm que ser correlacionadas entre si de modo que todas

as dicas ﬁquem verdadeiras.
Vejamos o jogo resolvido:

Capítulo 4. Circuitos Lógicos e Aplicações

74

Figura 28 – Jogo Boole Resolvido - Diﬁculdade Normal

Fonte: Autora

Veja que, quando o jogo está resolvido, as dicas estão riscadas, isso
signiﬁca que o jogo está dizendo que aquela dica foi preenchida cor-
retamente, ou seja, uma dica verdadeira. Se olharmos a resolução
do jogo e resolvêssemos mudar algo de lugar, uma dessas dicas não
ﬁcaria mais riscada, pois ela se tornaria uma dica falsa. Com isso,
percebe-se que cada jogo desse tipo possui apenas uma resolução
correta. É aí que está a álgebra proposicional, as dicas podem ser
interpretadas como proposições, e devem ser todas as verdadeiras
quando a operação de E for realizada entre elas. (OLIVEIRA, 2017,
p. 37)

Num contexto voltado para sala de aula, estes jogos são frequentemente utilizados

com cartas, tendo em vista que

ao considerar a ludicidade como um processo de ensino aprendizagem,
o educador favorece seu foco de atuação, pois o trabalho em grupo
enriquece as relações grupais caracterizando um contexto propício
para a utilização de atividades lúdicas. Essas atividades são meios
de comunicações que permitem ressigniﬁcar o real, permitindo que
o educando se envolva interagindo em situações lógicas, afetivas e
sociais. (DIDáTICO-PEDAGóGICAS, 2013, p. 02)

5 Introdução aos Computadores

75

Neste capítulo, apresentaremos alguns conceitos elementares pertinentes ao tema
em questão, e, em seguida falaremos dos processadores ou CPU’s dos computadores,
enfatizando, sobretudo, como se dá seu funcionamento através da linguagem binária.
Falaremos também do código ASCII, que é conhecido e utilizado em todo mundo, bem
como do Unicode, com ênfase do Padrão UTF-8 e, por ﬁm, mostraremos, de fato, como
essas ferramentas se interligam para facilitar nossa comunicação com os computadores.

5.1 Conceitos Elementares

Já vimos que, numa perspectiva voltada para o mundo digital, existem apenas dois
algarismos (0 ou 1), que indicam, na verdade, estados do sistema, tais como desligado
ou ligado, fechado ou aberto, não ou sim, entre outros. Estes algarismos, são, na
verdade, a linguagem que os computadores utilizam para armazenar e processar os
dados, onde toda informação é convertida para linguagem binária, isto é, zeros e uns.

5.1.1 Bit

Essa ideia de 0 e 1 nos remete a um termo denominado Bit, cujo símbolo é b, que,
por deﬁnição, é a menor unidade utilizada na computação para medir a transferência
ou armazenamento de informações digitais. O termo é uma abreviação da expressão
dígito binário ou binary digit, em inglês. (GOGONI, 2019)

Sendo binário, eles só podem assumir os valores 1 e 0, que representam, respectiva-

mente, a passagem, ou não, de corrente elétrica.

Fisicamente, um bit pode ser representado de várias formas: via
eletricidade (dois valores de voltagem aplicados num ﬁo), via luz
(em ﬁbras ópticas), via ondas eletromagnéticas (redes sem ﬁo), en-
ﬁm, em tudo que seja possível identiﬁcar dois estados diferentes.
(TEDESCO, 2020)

Assim, um computador, ao processar dados, ele estará, na verdade, processando
bit, ou seja, dizer esse bit é 0 ou 1, onde, ao ﬁnal do processamento, teremos uma
informação mais completa, isto é, agrupamentos de bits zeros e uns.

É importante chamar atenção para o fato de que esses agrupamentos de bits rep-
resentam todo e qualquer dado que estiver armazenado no computador, tais como
imagens, textos, músicas, áudios, vídeos, entre outros.

Capítulo 5.

Introdução aos Computadores

76

Para realizar o cálculo das possibilidades do agrupamento dos bits, iremos utilizar
sempre a base 2, visto que estamos tratando da base binária, elevado ao número de
bits agrupados.

Por exemplo,

Tabela 25 – Possibilidades de agrupamentos de bits

1 bit
21 = 2
2 possibilidades

2 bits
22 = 4
4 possibilidades

8 bits
28 = 256
256 possibilidades

n bits
2n
2n possibilidades

Fonte: Autora

Neste sentido, para 3 bits, há 8 possibilidades de agrupamentos, o que signiﬁca que

o computador pode armazenar até 8 informações por vez.

(CANDIDO, 2013, p. 3) ressalta que

Em nossa linguagem, a menor unidade de informação é o caractere,
que, isoladamente, não serveria como uma informação útil. Em com-
putação, o bit seria da mesma forma que o caractere. Por essa razão,
as informações manipuladas por um computador são codiﬁcadas em
grupos ordenados de bits, para poder terem um signiﬁcado útil.

A ilustração seguinte exibe um sinal digital, onde 1 indica a presença de tensão

(5V ), enquanto sua ausência (0V ) é representada por 0.

Figura 29 – Imagem Bit

Fonte: https://tecnoblog.net/303263/bit-ou-byte/

É assim que um computador “fala”. O bit é geralmente utilizado para medir veloci-
dades de conexão e transferência de dados, embora, no passado, também tenha sido
usado como unidade básica para armazenamento. (GOGONI, 2019)

No entanto, não podemos armazenar menos de 8 bits. Nesse sentido, dá-se origem

a um novo termo, como veremos a seguir.

Capítulo 5.

Introdução aos Computadores

77

5.1.2 Byte

O “byte é a menor unidade de armazenamento utilizada pelos computadores”
(TEDESCO, 2020). (GOGONI, 2019) aﬁrma que “um byte (símbolo B) ou octeto,
é um pacote que agrupa oito bits”. Assim, o byte é o termo binário, enquanto bit é
o dígito binário. Nesse sentido, temos a seguinte equivalência que nos diz que 1 byte
equivale a 8 bits agrupados.

1 byte = 8 bits

(CANDIDO, 2013, p.5) acrescenta que, na utilização do termo byte como capaci-
dade de armazenamento em uma memória de computadores, veriﬁcamos a inclusão de
caracteres, tais como K(Kilo), M (Mega), G(Giga), etc.

Nos computadores, onde todas as indicações numéricas referem-se à potências de
2, podemos resumir algumas dessas conversões de armazenamento na seguinte tabela:

Figura 30 – Grandezas usadas para abreviar valores em computação

Fonte: (CANDIDO, 2013)

Ainda segundo (CANDIDO, 2013, p.4),

como os principais códigos de representação de caracteres utilizam
grupos de 8 bits por caractere, os conceitos de byte e caractere
tornam-se semelhantes e, as palavras, quase sinônimas. O byte, pode
representar um caractere no computador, não tendo a ﬁnalidade de
representar qualquer tipo de informação, sendo tão somente uma
unidade de armazenamento e transferência.

A conversão entre bits e bytes é realizada através de multiplicações e divisões por

8, utlizando o seguinte esquema:

Capítulo 5.

Introdução aos Computadores

78

Figura 31 – Conversão de Bit para Byte

Fonte: (CANDIDO, 2013)

Assim, a ﬁgura 31 nos diz que para converter um determinado valor de bit para
byte, divide-se por 8, e reciprocamente, isto é, de byte para bit, multiplica-se pelo
mesmo número, como é feito no exemplo a seguir:

Exemplo 22.

800b = 100B pois 800 ÷ 8 = 100.

15B = 120b

pois 15 × 8 = 120.

Na prática, encontramos o uso de bytes, entre outras aplicações, num Pen Drive,
onde tem-se uma determinada capacidade de armazenamento seguida de GB, (32GB,
por exemplo), onde o G signiﬁca giga e o B, byte.

Já na conexão de internet, encontramos uma utilização do conceito de bit, onde
tempos, por exemplo, uma conexão de 100M bps, que signiﬁca 100 mega bits por se-
gundo.

(TEDESCO, 2020) aﬁrma que

Existe uma confusão bastante comum entre os consumidores de inter-
net em relação a unidade de medida da velocidade de transferência.
Quando você contrata aquela internet de ﬁbra óptica de 100M B,
que você lê que poderá baixar a “100 mega por segundo”, pode pare-
cer que será possível baixar um arquivo de 100 mega bytes em 1
segundo, mas isso não é verdade. Velocidade de transferência é me-
dida em bits por segundo e não em bytes. Portanto, um download a
100M bps signiﬁca 100 mega bits por segundo e não 100 mega bytes.
Para se chegar no valor em mega bytes, é preciso dividir por 8. Ou
seja, quando você baixa a 100M bps, você está na prática baixando
100
8

= 12, 5 mega bytes por segundo.

5.2 Os Processadores

Também chamado de Unidade Central de Processamentos, do inglês Central Pro-
cessing Unit (CPU ou UPC), o processador é uma poderosa máquina de calcular com

Capítulo 5.

Introdução aos Computadores

79

números binários e vale destacar que seu uso não se restringe apenas a computadores.
Equipamentos como celulares, videogames, smartphones, tablets, etc, também pre-
cisam de processadores para trabalhar, sendo que nenhum dispositivo eletrônico con-
segue funcionar sem a famosa CPU. (ARRUDA, 2011)

Nos computadores, ele é o chip responsável pela execução de cálculos, aceleração,
endereçamento e também por tomar todas as decisões lógicas que basicamente resultam
em todas as tarefas do computador, por este motivo, o processador é conhecido como
o cérebro do computador.

Em relação a este equipamento, (SOUZA, 2012, p. 1) aﬁrma que

esse chip sofreu transformações tecnológicas ao longo dos anos, pro-
porcionando aos computadores um aumento considerável em seu poder
computacional e na sua ﬂexibilidade de uso. Paralelamente à evolução
das CPU’s, os computadores passaram a ser utilizados por um número
cada vez maior de pessoas, pois, à medida que as máquinas passaram
a ter uma alta demanda, o preço sofreu considerável redução, sendo
essa uma tendência seguida até os dias atuais. Neste processo evo-
lutivo dos processadores, nada mais é que um pedaço de silício com
inúmeros condutores complexamente ligados a dimensões microscópi-
cas.

Essa evolução ao longo do tempo fez com que estes dispositivos deixassem de ser
programados com números decimais e passassem a usar a base binária como linguagem
padrão, bem como evoluíssem no sentido de deixarem de ser mecânicos e lentos e
tornassem rápidos e de fácil acesso, com a utilização de transistores chaveados no lugar
de relés e válvulas, que eram complicadas e consumiam uma grande quantidade de
energia. (SOUZA, 2012)

Figura 32 – Processador moderno

Fonte: https://www.reibatuta.com.br/processador-intel-core-i5-2400-3-10-ghz-lga-1155-oem

Capítulo 5.

Introdução aos Computadores

80

5.2.1 Contexto Histórico

A principal diferença entre os primeiros computadores e os atuais é que os antigos
não eram capazes de armazenar dados. Podemos destacar o computador ENIAC (Elec-
tronic Numerical Integrator Analyzer and Computer), que teve seu desenvolvimento
iniciado em 1943 pelos cientistas norte americando John Eckert e John Mauchly, en-
trando em funcionamento em 1946, sendo que, toda vez que era necessário realizar uma
tarefa diferente, ele tinha sua estrutura física modiﬁcada, onde cabos eram repostos e
chaves ligadas ou desligadas para que uma nova função pudesse ser executada.

Vale destacar que, no projeto inicial, tinha-se um plano de armazenamento de soft-
wares em seu interior. No entanto, para agilizar o trabalho da construção da máquina,
a ideia acabou ﬁcando para trás.

Figura 33 – Computador ENIAC

Fonte:

(SALES, 2018)

Este computador tinha capacidade de processamento de 5000 operações por se-
gundo, sendo todas decimais, e possuia cerca de 1800 válvulas, que baseavam-se no
princípio termiônico, utilizando o ﬂuxo de elétrons no vácuo. O ENIAC foi utilizado
para propósitos militares em cálculos de trajetórias de mísseis e codiﬁcação de men-
sagens secretas; era extremamente caro, consumia muita energia e ocupava muito es-
paço. Na verdade, suas funções assimilavam-se as que uma calculadora simples hoje
realiza.

Capítulo 5.

Introdução aos Computadores

81

Figura 34 – Válvula termiônica

Fonte: https://pt.wikipedia.org/wiki/VC3A1lvula_termiC3B4nica

Outro computador dos primórdios que marcou foi o Electronic Discrete Variable
Automatic Computer - EDVAC, que foi projetado para usar códigos binários e manter
programas armazenados na memória. Sendo construído pela Ballistic Research Labora-
tory U.S. Universidade da Pensilvânia com base na arquitetura dos matemáticos John
Eckert, John Mauchly e Jonh von Neumann entre os anos de 1946 e 1949, o EDVAC
foi pensado buscando resolver problemas encontrados no ENIAC.

Figura 35 – Computador EDVAC

Fonte:

(SALES, 2018)

De acordo com (SALES, 2018)

Capítulo 5.

Introdução aos Computadores

82

o computador foi concebido para ser a adição binária, subtração e
multiplicação, divisão programada e automática. Também possuia
um veriﬁcador automático para até mil palavras.
[...] Fisicamente,
o computador foi construído pelos seguintes componentes: um leitor
gravador, uma unidade de controle com o osciloscópio, uma unidade
para receber instruções de controle e de memória e encaminhá-los
para outras unidades, uma unidade computacional para realizar op-
erações aritméticas um par de números em um tempo e mantê-
los na memória após conﬁrmação com outra unidade idêntica, um
cronômetro e uma unidade de memória dual.

No EDVAC, o programa ou software que estava sendo executado poderia ser mod-
iﬁcado sem que fosse necessário alterações físicas no computador. Essa foi a ideia que
impulsionou a criação de uma unidade central de processamentos e deu origem aos
modelos primitivos de processadores. Essa foi a ideia que marcou o ínicio da era dos
computadores modernos.

Esses equipamentos baseados em válvulas são chamados de Computadores de Primeira

Geração. No período que ﬁcaram em uso, provaram ser altamente conﬁáveis e produ-
tivos, no entanto, não muito duradoures, quebrando, geralmente, após poucas horas de
uso.

Os equipamentos de segunda geração tem a válvula substituída por transistores,
que tinham um tamanho menor, consumiam menos energia e realizavam a mesma
tarefa com maior velocidade. O primeiro deles “foi criado em dezembro de 1947 pelos
pesquisadores da empresa Bell Laboratory, anunciando uma nova era da eletrônica.”
(ALMEIDA, 2012, p. 2)

Nessa geração, temos como destaque o computador da IBM denominado 1401, que

entrou em funcionamento no ano de 1959.

Figura 36 – Computador IBM 1401

Fonte: https://pt.wikipedia.org/wiki/IBM_1401

Outra grande evolução veio durante os anos 60 com a tecnologia dos circuitos in-
tegrados, que são compostos por resistores, transistores e capacitores miniaturizados e

Capítulo 5.

Introdução aos Computadores

83

montados num único chip. Para colocá-los em prática, a IBM desenvolveu um com-
putador virtual conhecido por System/360, ou, simplesmente, S/360. Podemos pensar
nesse sistema como um conjunto de instruções e capacidades que todos os computadores
da família S/360 teriam em comum. (ARRUDA, 2011)

Com isso, programas seriam compatíveis entre todos esses modelos e não mais
dependentes de máquinas. Essa evolução marcou a terceira geração de computadores.

Figura 37 – Computador System/360

Fonte: http://denglecomp.blogspot.com/2009/03/360-ibm-primeira-linha-de-produto.html

A quarta e atual geração começou na década de 70 e usa o mesmo argumento da
anterior, mas ainda mais desenvolvido, sobretudo no que se refere à diminuição do
tamanho dos chips, implicando o surgimento dos microprocessadores e dos microcom-
putadores.

Figura 38 – Microprocessador

Fonte: http://www.anisio.eti.br/index.php/hardware-menuvertical/item/32-microprocessador

(ALMEIDA, 2012) aﬁrma que o primeiro microprocessador produzido no mundo
foi o Intel 4004, desenvolvido no ano de 1971, pelos cientistas Federico Faggin, Ted

Capítulo 5.

Introdução aos Computadores

84

Hoﬀ e Stanley Mazor. Até então, os dispostivos eletrônicos possuiam diversos chips
separados para controle de teclado, display, impressora, etc, e o Intel 4004 continha
todas esses acessórios interligados por um único chip. Com 4 bits e cerca de 2300
transistores, tinha tanto poder quanto o ENIAC, que ocupava mais de 900m3, com
suas quase 18.000 válvulas.

A Intel e a ADM são as duas grandes empresas que desenvolvem esses equipa-
mentos desde a criação dos primeiros deles, sendo que, com o passar dos anos, houve
grandes evoluções nos processadores, que diminuíram de tamanho, ﬁcaram mais rápi-
dos e tiveram um grande aumento na quantidade de bits e de transistores, bem como a
introdução de núcleos, que possibilitam ainda mais resultados positivos. Atualmente,
o processador mais desenvolvido em termos de suas funcionalidades é o Intel Core
i9 − 10900.

5.2.2 Funcionamento

(FáVERO, 2011, p. 57) ressalta que o processador “é resposável pelo processamento
e execução de programas armazenados na memória principal, buscando instruções,
examinando-as e, então, executando uma após a outra.” Na verdade, este equipamento
executa três funções básicas: receber, processar e fornecer dados de saída. É importante
chamar atenção para o fato de que “eles processam apenas a linguagem booleana”
(SOUZA, 2012, p. 3), já estudada no capítulo anterior. Assim, tudo que o processador
entende é apenas 0 e 1.

O processador é composto de três partes: uma unidade aritmética e lógica (ULA),
que é a unidade central, responsável por executar as operações aritméticas e lógicas;
uma unidade de controle (UC), responsável por armazenar a posição de memória que
contém a instrução que o computador está executando; e os registradores, que são
elementos de armazenamento temporário. Num trabalho coletivo, a UC irá informar
à ULA qual operação e informação ela deverá executar, e, em seguida, transfere esse
resultado de volta para o local apropriado do registrador. Este ciclo repete-se para
toda ação feita no computador. (MEYER, 2015)
Chamaremos a atenção para a ULA, que é

um aglomerado de circuitos lógicos e componentes eletrônicos simples
que, integrados, realizam as operações aritméticas e lógicas. São
exemplos de operações executadas pela ULA: soma, multiplicação,
operações lógicas (AND, OR, NOT, XOR, entre outras), incremento,
decremento e operação complemento). (FáVERO, 2011, p. 60)

Já vimos que os computadores e demais equipamentos eletrônicos apenas interpre-
tam 0 e 1, isto é, o sistema binário, e cabe aos processadores fazer uma espécie de
tradução da nossa linguagem para binária, e vice-versa. Para que ele consiga fazer

Capítulo 5.

Introdução aos Computadores

85

isso, são utilizados transistores, onde a quantidade deles num processador implica di-
retamente na velocidade de execução das funções do equipamento.

Figura 39 – Transistor

Fonte: https://www.vidadesilicio.com.br/transistor-tip122-npn

(MEYER, 2015) chama atenção para as três “perninhas” que tem no transistor,
como no da ﬁgura 39, onde uma delas é para base, outra é o coletor e a terceira é
o emissor de dados. Quando a base é carregada, diz-se que ela tem valor 1, o que
permite que a corrente ﬂua para o coletor. O inverso acontece quando a base não tem
carga (valor 0), onde a corrente faz o caminho contrário, ﬂuindo para o emissor. Neste
estado, o transistor funcionará como um interruptor fechado.

Assim, os estados 0 e 1 são formados a partir de correntes elétricas que geram, ou

não, cargas para os pinos dos transistores.

Outro fator que é importante destacar é que, através de conexões de diferentes
transistores e pinos, as ligações lógicas acontecem, onde o computador irá interpretar
os comando lógicos “e”, “ou” e “não”, entre outros. (MEYER, 2015)

Portanto, concluímos que os processadores funcionam como uma espécie de conver-
sor de dados da nossa linguagem para a binária, e vice-versa, a partir do recebimento
ou não de correntes elétricas, que podem ser compreendidas como 1 ou 0, respectiva-
mente, além de realizarem todos os cálculos necessário para o bom funcionamento do
computadores e dos demais equipamentos eletrônicos.

5.3 O Código ASCII

Já vimos que tudo que os computadores compreendem são zeros e uns e que a
conversão da nossa linguagem para binária é feita através de processadores. No entanto,
essa conversão é feita seguindo padrões, onde, por exemplo, “para se codiﬁcar um texto,
é necessário que se adote um valor binário para cada caractere, letra ou número do
alfabeto.” (LIMA, 2020)

Capítulo 5.

Introdução aos Computadores

86

Um desses padrões, que é muito utilizado em todo mundo, é o código ASCII [lê-se

áski], que segundo (KARASINSKI, 2009)

é uma sigla para American Standard Code for Information Inter-
change (Código Padrão Norte-americano para Intercâmbio de Infor-
mações). Esse código foi proposto por Robert W. Bemer, visando
padronizar os códigos para caracteres alfa-numéricos (letras, sinais,
números e acentos).

O intuito principal desse código é padronizar a forma de programação dos com-
putadores, no sentido de haver uma linguagem comum a todos, visto que, até o ano de
1960, cada máquina utilizava uma regra diferente para programação, o que diﬁcultava
a comunicação entre elas.

O código ASCII utiliza apenas 7 bits para cada caractere, o que implica a existência
de 128 possíveis combinações, como visto na Tabela 25. Assim, com esses bits é possível
escrever 128 caracteres (de 0 a 127), onde 33 deles são sinais de controle (caracteres não
imprimíveis) e 95 são utilizados para representar sinais gráﬁcos, que correspondem a
letras, números, sinais de pontuação, entre outros (caracteres imprimíveis). Os carac-
teres não imprimíveis são aqueles que não produzem, necessariamente, um caractere na
tela no computador, e sim executa uma determinada função. Como o código é antigo,
alguns sinais não são mais utilizados (SUGAI, 2015).

No entanto, por convenção, cada caractere é representado por 8 bits, isto é, 1 byte,
sendo que o primeiro deles (dígito mais signiﬁcativo a esquerda) é sempre 0, sendo,
portanto, considerado um bit não utilizado. Mais adiante entenderemos o porquê
dessa adoção de 8 bits.

No estudo desse código, é importante sempre ter conhecimento da Tabela ASCII,
que mostra qual será o valor binário de cada caractere existente, conforme encontra-se
no Anexo A deste trabalho.

É importante chamar atenção para o fato de que o código ASCII segue a ordem do

alfabeto e uma sequência crescente de números binários.

Vale destacar que esse código foi concebido para língua inglesa, por isso ele não
contém caracteres acentuados. Para codiﬁcar esse tipo de caractere e outros especiais,
como o cedilha (Ç), foi necessário recorrer a alterações no código inicial, com a inclusão
de mais 1 bit, totalizando 8 bits signiﬁcativos, que equivale a 1 byte (perceba que a
modiﬁcação consiste na mudança do primeiro bit, que deixa de ser um bit não utilizado
e passa a ser utilizado, isto é, 1).

Esse “novo” código, que é a união do inicial acrescentado de 1 bit e passa a ter 256
(0 a 255) caracteres, é chamado de Código ASCII Completo, onde, de forma análoga
ao inicial, ele fornece a cada caractere (letras, números, marcas de pontuação e outros
caracteres, incluindo os acentuados) um valor binário especíﬁco. (MUXFELDT, 2017)

Capítulo 5.

Introdução aos Computadores

87

Os 128 bytes acrescidos ao código inicial (caracteres de 128 a 255) dão origem a

Tabela ASCII estendida, que encontra-se no Anexo B desta pesquisa.

A união da Tabela ASCII original (caracteres de 0 a 127) com a estendida (carac-

teres de 128 a 255) é chamada de Tabela ASCII Completa.

Vale destacar que há diferentes variações na tabela ASCII de 8 bits, sendo que
a apresentada neste trabalho está de acordo com o Windows-1252 (CP-1252), que é
um superconjunto da ISO 8859-1, também chamado de ISO Latin-1. A partir dela, é
possível escrever textos em quase todos os idiomas, visto que o Windows-1252 é um
dos codiﬁcadores de caracteres mais utilizados no mundo. (FERNANDES, 2020)

5.3.1 Arte ASCII

Através do código ASCII, também é possível criar desenhos. Assim, de acordo com
(KARASINSKI, 2009), a chamada arte ASCII, do termo original ASCII art “é baseada
justamente no uso de caracteres para criar desenhos e mensagens. Ela é bastante antiga,
pois sempre foi utilizada nos computadores. A arte pode ser construída da maneira
que o artista quiser: em preto-e-branco ou colorida.”

Logo, esse tipo de arte utiliza apenas os caracteres disponíveis no código ASCII

para expressão artística. Um exemplo de uma delas segue na ﬁgura 40.

Figura 40 – Arte ASCII com Mestre Yoda, de Star Wars

Fonte: (SUGAI, 2015)

Vale salientar que essa manifestação artística é compatível com todos os computa-
dores que utilizem um sistema de caracteres e que há vários artistas que dedicam-se à
criação de artes ASCII.

Capítulo 5.

Introdução aos Computadores

88

5.4 Unicode e Padrão UTF-8

O Unicode é um sistema de codiﬁcação de caracteres desenvolvido em 1991, que
permite representar qualquer caractere por um código, geralmente, em 16 bits, indepen-
dente de qualquer sistema operacional ou linguagem de programação que o computador
estiver utilizando. Ele reúne, assim, quase todos os alfabetos existentes e é compatível
com o código ASCII. (MUXFELDT, 2017)

É importante acrescentar que esse código contempla caracteres a mais do que foi
apresentado nas tabelas dos Anexos A e B, como, por exemplo, símbolos utilizados na
escrita de países orientais.

Nesse contexto, o Unicode, como o próprio nome sugere, é uma espécie de código
único para computadores, que é adotado mundialmente e visa padronizar a linguagem
utilizada pelas máquinas. Para isto, ele fornece um número diferente para cada car-
actere, seja ele letras do nosso alfabeto ou símbolos utilizados por outros idiomas,
números, sinais de pontuação, etc.

No padrão Unicode, a notação é feita através da utilização do preﬁxo U +, seguido

de números escritos na base hexadecimal (base 16).

O alfabeto Unicode tem mais de 1 milhão caracteres. Portanto, o
código de cada caractere precisaria de pelo menos 3 bytes se usásse-
mos notação binária. Usar um número ﬁxo de bytes por caractere
não seria eﬁciente, já que 1 byte é suﬁciente para codiﬁcar os carac-
teres mais comuns. A solução é recorrer a um código multibyte, que
emprega um número variável de bytes por caractere: alguns carac-
teres usam 1 byte, outros usam 2 bytes, e assim por diante. O código
multibyte mais usado é conhecido como UTF-8. Ele associa uma se-
quência de 1 a 4 bytes (8 a 32 bits) com cada caractere Unicode. Os
primeiros 128 caracteres usam o velho e bom código ASCII de 1 byte
por caractere. Os demais caracteres têm um código mais complexo.
(FEOFILOFF, 2018)

Nesse sentido, surge o UTF-8, criado em 1992 por Ken Thompson, que pode ter de
1 a 4 bytes e é o mais utilizado. No entanto, ainda existem o padrão UTF-16 (2 ou 4
bytes) e o UTF-32 (4 bytes). A deﬁnição de qual é mais eﬁciente depende diretamente
do contexto em que se está inserido, porém, as diferenças entre eles são mínimas, por
isso, em geral, usa-se o padrão UTF-8.

Conforme acrescenta (CHICONI, 2020),

em teoria, o Unicode é muito bom. Porém, na prática, a história
é outra. Normalmente, em Unicode, um caractere usa 2 bytes. Em
outras palavras, qualquer texto usa duas vezes mais espaço do que no
ASCII. É um desperdício. Além disso, se tomarmos como exemplo
um texto em português, a grande maioria dos caracteres só utiliza o
código ASCII. São raros os caracteres que requerem Unicode.

Capítulo 5.

Introdução aos Computadores

89

Assim, ao digitar, por exemplo, um texto em UTF-8, este será, simultaneamente,
digitado em ASCII e, caso haja um caracetere que não se encontre no ASCII, somente
esse fará uso do padrão UTF-8 para ser convertido.

A lista de alguns os códigos utilizados pelo padrão UTF-8 encontra-se no Anexo C.
Vale acrescentar que UTF é a sigla utilizada para Unicode Transformation Format,

cuja tradução é Formato de Transformação Unicode.

Nesse padrão, teríamos, por exemplo, as seguintes correspondências entre os carac-

teres e as notações do Unicode:

A: U + 0041

a: U + 0061

5: U + 0035

= : U + 003D.

5.5 Aplicações

Nesta seção iremos apresentar como, de fato, os comandos inseridos nos computa-
dores são processados, isto é, codiﬁcados e descodiﬁcados, resultando na operação
correta.

Como já foi mencionado na Seção 5.2, o equipamento responsável por realizar esta
tarefa é o processador ou, simplemente, CPU, que faz a conversão de dados da nossa
linguagem para binária e vice-versa, possibilitando, assim, uma comunicação rápida,
fácil e eﬁciente entre humanos e máquinas.

Mas como isso acontece? A resposta é simples: através de zeros e uns e baseado em
um dos padrões mencionados nas Seções 5.3 e 5.4. Vale salientar, no entanto, que os 0 e
1 não signiﬁcam necessariamente números, mas sim estados do sistema, que funcionam
e interpretam comandos através de correntes elétricas ou ausência delas que, por sua
vez, faz a comunicação direta com os processadores através da linguagem da álgebra
booleana.

Nesse contexto, ao digitar algum caractere do teclado do computador (seja ele
alguma letra, número, sinal de pontuação ou comando), a tecla pressionada irá enviar
pulsos elétricos para o computador, isto é, sequências de zeros e uns (sequências de
bits), e, a partir daí, o processador vai localizá-la de acordo com o código ASCII ou
com o padrão UTF-8 e, então, irá compreender qual foi a tecla pressionada, passará
a informação para o computador, que, por sua vez, dará como resposta a inserção do
caractere na tela ou execução do comando desejado. Vale salientar que tudo isso é feito
em fração de segundos, dependendo da potência do processador, sendo que, quanto

Capítulo 5.

Introdução aos Computadores

90

mais desenvolvido ele for, menos tempo gastará para executar determinada operação.
Este processo é repetido inúmeras vezes durante o uso da máquina.

Assim, por exemplo, o computador não entende a letra A. Para ele, esta letra será
apenas um desenho impresso na tela quando ele receber uma determinada sequência
numérica de bits.

Exemplo 23. Os bytes a seguir, apresentados em números binários, representam uma
palavra da forma original que foi armazenado na memória de um computador. Sabendo
que cada byte é um código ASCII, qual é a palavra?

0101 0000 0101 0010 0100 1111 0100 0110 0100 1101 0100 0001 0101 0100

Para decifrar qual a palavra, basta veriﬁcar, no Anexo A, qual letra corresponde
ao binário apresentado. Fazendo isso, constatamos que a palavra que está escrita em
binário é PROFMAT.

Exemplo 24. Usando a Tabela ASCII completa, qual seria a combinação de bits que
o computador receberia ao ser digitado a frase Números Binários?

De posse da tabela (que encontra-se nos Anexos A e B), a codiﬁcação binária para

o termo Números Binários seria:

0100 1110 1010 0011 0110 1101 0110 0101 0111 0010 0110 1111 0111 0011

0010 0000 0100 0010 0110 1001 0110 1110 1010 0000 0111 0010 0110 1001

0110 1111 0111 0011

6 Conclusões

91

Geralmente, no nosso cotidiano, utilizamos o sistema de numeração decimal, isto é,
na base 10, que, como o próprio nome sugere, é composto de 10 algarismos: 0, 1, 2, 3,
4, 5, 6, 7, 8 e 9. Ele consegue suprir quase todas as nossas necessidades de contagem,
no entanto, este sistema não é único.

Existem outros sistemas de numeração, que também são utilizados por nós, muitas
vezes sem percebermos. Por exemplo, ao ver as horas no relógio, nos deparamos com
um sistema na base 60 (sexagesimal), ou ao ir ao mercado comprar uma dúzia de algum
produto, onde encontramos o uso da base 12 (duodecimal), entre outros. Pela revisão
de literatura, ﬁcou constatado que a utilização de diferentes bases de numeração é
antiga, sendo encontrada desde os primeiros indícios da utilização da matemática e
varia de acordo com cada civilização.

Ainda nesse contexto, podemos citar o sistema binário (base 2), onde os únicos
algarismos existentes são o 0 e o 1, que começou a ser utilizado por volta do século
III a.C. e continua sendo até os dias atuais, tendo uma de suas principais aplicações
voltada para a programação dos equipamentos digitais.

Neste trabalho, que foi desenvolvido através de uma pesquisa qualitativa e de uma
revisão bibliográﬁca, foi dissertado sobre como os números binários são utilizados dentro
da computação, onde foi possível constatar como, de fato, esses números são úteis
dentro do nosso cotidiano e que, mesmo sem perceber, estamos diariamente em contato
com eles.

Os equipamentos eletrônicos, onde enfatizamos os computadores atuais, são capazes
de fazer coisas incríveis, mas um fato que chama muito a nossa atenção é que eles só
entendem 0 e 1, ou seja, a linguagem binária, no sentido de que toda programação
utilizada neles é feita através desses dois algarismos. Mas nem sempre foi assim. Na
invenção do primeiro computador, por exemplo, a linguagem utilizada era a decimal, no
entanto, com o passar do tempo, percebeu-se que utilizar um base menor, na verdade,
a menor possível (base binária), tornaria estes equipamentos mais rápidos e eﬁcazes,
visto que todo trabalho seria feito em cima de apenas dois algarismos. Essa ideia deu
muito certo e impulsinou nas máquinas potentes que temos hoje em dia.

Além dos números binários, para o bom funcionamento dos computadores, ele uti-
lizada a álgebra de Boole, que consiste na utilização de letras para traduzir o pensa-
mento humano. Um dos fatores que chama a atenção nesssa álgebra é que ela também
só faz uso dos algarismos 0 e 1. Munidas de deﬁnições, axiomas, propriedades e teo-
remas, ela apresenta grande semelhança com a tradicional, como foi visto no decorrer
desta pesquisa.

Capítulo 6. Conclusões

92

Embora seja fundamentada com base na linguagem binária, nesta álgebra os números
0 e 1 não exprimem quantidades, mas sim estados do sistema, que são transmitidos
para os computadores através de pulsos elétricos, onde o 1 indica a passagem da cor-
rente e 0, a ausência dela. Nos equipamentos eletrônicos, tudo isso é feito através de
operadores e portas lógicas, que, quando interligadas, dão origem aos circuitos lógicos.
Ideia semelhante é utilizada nos circuitos elétricos e na programação do buscador
“Google”, que utilizam, sobretudo, os conceitos dos conectores lógicos. Sem esta álge-
bra, os computadores e outros equipamentos digitais não teriam a mesma estrutura e
funcionalidade que têm atualmente.

Como os computadores só entendem 0 e 1, foi necessário a criação de um equipa-
mento que ﬁzesse essa “tradução” da nossa linguagem para binária, e vice-versa. A
este equipamento que é considerado o cérebro dos computadores, dá-se o nome de
processador.

Também chamado de CPU, ele sofreu grandes evoluções ao longo do tempo, que
impulsionaram grandes mudanças nos equipamentos eletrônicos, tanto físicas, quanto
em termos de programação e funcionalidades, uma vez que sua principal função é
processar dados e executá-los.

Vale lembrar que estes equipamentos também só entendem 0 e 1 e fazem uso da
ideia dos estados que esses números representam, sugerida pela álgebra de Boole, isto é,
eles interpretam os pulsos elétricos ou a ausência deles para compreender se o número
(bit - dígito binário) em questão é 0 ou 1. Esta tarefa é repetida inúmeras vezes e,
quando formam grupos de 8 bits, dão origem a um byte (termo binário).

Com a evolução tecnológica, os computadores foram ganhando cada vez mais espaço
em todo mundo. Este fato impulsionou a criação de uma linguagem padrão para que
fosse utilizados em todos os computadores, tendo em vista que, até então, cada um
tinha sua linguagem de programação especíﬁca, fato que diﬁcultava a comunicação
entre eles. Nessa visão, surgiu o código ASCII, com 7 bits, sendo que, em pouco tempo,
foi necessário ampliá-lo para 8 bits e, ainda não sendo suﬁciente para contemplar todos
os idiomas existentes, foi desenvolvido o Unicode, isto é, um código único, sendo o
padrão UTF-8 o mais utilizado deles.

O código ASCII, que também utiliza a linguagem binária, consiste na atribuição de
um byte, isto é, uma sequência de 8 bits, para cada caractere utilizado pelo computa-
dor, seja ele letras, números, sinais de pontuação, etc, ou, simplesmente, um comando.
O padrão UTF-8, que é uma expansão do código ASCII, porém, ainda assim, com-
patível com ele, tem funcionamento análogo ao do código, no entanto, utiliza a base
hexadecimal (base 16), tendo em vista que possui mais de um milhão de caracteres e,
se continuasse utilizando os binários, os números ﬁcariam muito extensos, com muitos
dígitos.

Capítulo 6. Conclusões

93

Na prática, cabe aos processadores desempenhar essa tarefa por repetidas vezes
e em fração de segundos, que consiste em identiﬁcar qual foi a tecla pressionada no
teclado através da sequência de bits recebida, e enviá-la ao computador, que desenhará
o caractere desejado na tela do computador ou executará o comando solicitado. Assim,
cabe ao processador fazer essa “tradução”, que possibilita nossa comunicação com as
máquinas.

Por ﬁm, e encerrando o texto, diante da pesquisa realizada e dos resultados obtidos,
podemos constatar que os objetivos foram alcançados, tendo em vista que conseguimos
mostrar como os números binários são aplicados à computação, atendendo, portanto,
todas as nossas expectativas diante do tema central.

Referências

94

ABAR, C. Noções de álgebra booleana. 2004. Disponível em: <https://www4.pucsp.
br/~logica/Booleana.htm>. Acesso em: 04 feb 2021. Citado 3 vezes nas páginas 31,
54 e 56.

ALMEIDA, R. B. Evolução dos processadores. Instituto de Computação - Unicamp,
2012. Citado 2 vezes nas páginas 82 e 83.

ARRUDA, F. A História dos Processadores. 2011. Disponível em: <https:
//www.tecmundo.com.br/historia/2157-a-historia-dos-processadores.htm#:~:text=
Em%201945%2C%20a%20ideia%20de,da%20forma%20como%20os%20conhecemos.>
Acesso em: 17 abr 2021. Citado 2 vezes nas páginas 79 e 83.

BARANAUSKAS, J. A. Álgebra de boole e simpliﬁcação de circuitos lógicos.
Depertamento de computação e matemática - FFCLRP - USP, Universidade de São
Paulo, 2012. Citado 3 vezes nas páginas 31, 53 e 54.

BOOLE, G. The mathematical analysis of logic. [S.l.]: Philosophical Library, 1847.
Citado na página 30.

CANDIDO, C. Sistemas numéricos – bit / byte. 2013. Citado 3 vezes nas páginas 76,
77 e 78.

CHICONI, N. O que é ASCII, Unicode e UTF-8? 2020. Disponível em:
<https://br.ccm.net/faq/9956-o-que-e-ascii-unicode-e-utf-8>. Acesso em: 03 mai
2021. Citado na página 88.

DIAS, C. M. C. Álgebra booleana e lógica digital uma aplicação da lógica matemática.
Revista Acadêmica, Curitiba, p. 47–56, 1994. Citado na página 67.

DIDáTICO-PEDAGóGICAS, P. Os desaﬁos da escola pública paranaense na
perspectiva do professor pde. 2013. Citado na página 74.

EVES, H. Introdução à história da matemática. Campinas - SP: Unicamp, 2004.
Citado na página 16.

FEOFILOFF, P. Unicode e UTF-8. 2018. Disponível em: <https://www.ime.usp.br/
~pf/algoritmos/apend/unicode.html>. Acesso em: 15 abr 2021. Citado na página 88.

FERNANDES, H. M. Código ASCII – Tabela ASCII Completa. 2020.
Disponível em: <https://marquesfernandes.com/desenvolvimento/
codigo-ascii-tabela-ascii-completa/>. Acesso em: 30 abr 2021. Citado na
página 87.

FRANZON, C. R. P. A característica universal de leibniz: contextos, trajetórias e
implicações. Tese (Doutorado) — Universidade Estadual Paulista, Rio Claro - SP,
2015. Citado na página 24.

Referências

95

FáVERO, E. M. de B. Organização e arquitetura de computadores. Universidade
Tecnológica Federal do Paraná, 2011. Citado na página 84.

GIRELLI, M.; BEZERRA, R. C. Matemática e raciocínio lógico: trabalhando e
discutindo os jogos de boole. 2014. Citado na página 72.

GOGONI, R. Bit ou Byte? 2019. Disponível em: <https://tecnoblog.net/303263/
bit-ou-byte/>. Acesso em: 15 abr 2021. Citado 3 vezes nas páginas 75, 76 e 77.

GÜNTZEL, J. L.; NASCIMENTO, F. A. do. Álgebra booleana e circuitos lógicos.
Introdução aos sistemas digitais, 2001. Citado 13 vezes nas páginas 32, 34, 35, 45,
46, 47, 49, 52, 56, 59, 61, 63 e 64.

HIRATA, N. S. T. Álgebra booleana e aplicações. Depto. de ciências da computação,
Universidade de São Paulo, 2005. Citado 7 vezes nas páginas 36, 41, 48, 50, 51, 52
e 63.

KARASINSKI, E. O que é Código ASCII? 2009. Disponível em: <https:
//www.tecmundo.com.br/imagem/1518-o-que-e-codigo-ascii.htm>. Acesso em: 30
abr 2021. Citado 2 vezes nas páginas 86 e 87.

LIMA, T. Tabela ASCII. 2020. Disponível em: <https://www.embarcados.com.br/
tabela-ascii/>. Acesso em: 30 abr 2021. Citado na página 85.

LIPSCHUTZ, S.; LIPSON, M. L. Theory and problems of discrate mathematics. [S.l.]:
Philosophical Library, 1976. Citado 4 vezes nas páginas 37, 42, 47 e 64.

LOPES, F. J. A. Leibniz e a aritmética binária. Revista Brasileira de História da
Matemática, Sociedade Brasileira de História da Matemática, 2011. Citado na página
17.

LUNA, J. E. L. O algoritmo do par binário. Dissertação (Mestrado) — Universidade
Federal de Alagoas, Maceió - AL, 2013. Citado na página 20.

MARTINES, V. M. Base de numeração e o sistema binário. Dissertação (Mestrado)
— Universidade Federal da Grande Dourados, Dourados - MS, 2019. Citado 4 vezes
nas páginas 16, 19, 23 e 24.

MELLO, A. M. Jogos boole: o desenvolvimento do raciocínio através de histórias
lógicas. 2010. Citado 2 vezes nas páginas 30 e 73.

MEYER, M. Como os processadores interpretam ﬁsicamente os coman-
2015. Disponível em: <https://www.oﬁcinadanet.com.br/post/
dos?
13472-como-os-processadores-interpretam-ﬁsicamente-os-comandos>. Acesso
em: 18 abr 2021. Citado 2 vezes nas páginas 84 e 85.

MIYASCHITA, W. Y. Sistemas de numeração: como funcionam e como são
estruturados os números binários. Bauru - SP: Unesp, 2002. Citado 2 vezes nas
páginas 16 e 17.

MUXFELDT, P. O código ASCII. 2017. Disponível em: <https://br.ccm.net/
contents/54-o-codigo-ascii>. Acesso em: 30 abr 2021. Citado 2 vezes nas páginas 86
e 88.

Referências

96

NEWS, B. Como matemático inventou há mais de 150 anos a fórmula de buscas usada
pelo Google. 2015. Disponível em: <https://www.bbc.com/portuguese/noticias/2015/
11/151102_boole_google_tg>. Acesso em: 20 feb 2021. Citado 2 vezes nas páginas
30 e 31.

OLIVEIRA, J. M. de. Álgebra booleana e suas utilizações. Seropédia - RJ, 2017.
Citado 5 vezes nas páginas 36, 60, 67, 72 e 74.

RIZZATO, F. B.; RINALDI, B. L. Álgebra: álgebra Booleana; métodos
álgébricos para a solução de equações diferenciais. 2005. Disponível em: <http:
//www.matematica.br/historia/boole.html#:~:text=Boole%20viu%20a%20l%C3%
B3gica%20de,%2C%20via%20linguagens%20de%20programa%C3%A7%C3%A3o)>.
Acesso em: 03 feb 2021. Citado na página 30.

SALES, G. Evolução dos computadores. 2018. Disponível em: <https://medium.
com/@gustavosales086/evolu%C3%A7%C3%A3o-dos-computadores-bd87102e01cf>.
Acesso em: 29 abr 2021. Citado 2 vezes nas páginas 80 e 81.

SANTOS, J. N.; SANTANA, J. R. O sistema de numeração decimal posicional e as
operações fundamentais: explorando os algoritmos com a manipulação do material
dourado. 2013. Citado na página 19.

SANTOS, R. Você sabe a história, entende como funciona o Sistema
Binário? 2020. Disponível em: <https://www.portalgsti.com.br/2020/02/
voce-sabe-a-historia-entende-como-funciona-o-sistema-binario.html>. Acesso em: 20
nov 2020. Citado na página 17.

SANTOS, V. R. dos; OLIVEIRA, C. G. de. A álgebra booleana presente nos circuitos
lógicos. Ciências exatas e tecnológicas, v. 3, n. 3, p. 63–72, 2016. Citado na página
59.

SOUZA, M. L. de. Evolução dos processadores e seu futuro. Univiersidade São
Francisco, 2012. Citado 2 vezes nas páginas 79 e 84.

SUGAI, A. O que é o código ASCII e para que serve?
Disponível em: <https://www.techtudo.com.br/noticias/noticia/2015/02/
o-que-e-o-codigo-ascii-e-para-que-serve-descubra.html>. Acesso em: 30 abr 2021.
Citado 2 vezes nas páginas 86 e 87.

2015.

TEDESCO, K. Bits, bytes e unidades de medida. 2020. Disponível em: <https:
//www.treinaweb.com.br/blog/bits-bytes-e-unidades-de-medida/>. Acesso em: 12
abr 2021. Citado 3 vezes nas páginas 75, 77 e 78.

VIEIRA, F. M. S. Álgebra booleana. Educ. Tecnol., v. 5, n. 1, p. 10–12, 2000. Citado
2 vezes nas páginas 32 e 59.

Anexos

ANEXO A – Tabela ASCII - 128 Códigos
(7 Bits)

98

Tabela 26 – Tabela ASCII - Caracteres não imprimíveis

Caractere Decimal Hexadecimal

NUL
SOH
STX
ETX
EOT
ENQ
ACK
BEL
BS
HT
LF
VT
FF
CR
SO
SI
DLE
D1
D2
D3
D4
NAK
SYN
ETB
CAN
EM
SUB
ESC
FS
GS
RS
US

00
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31

00
01
02
03
04
05
06
07
08
09
0A
0B
0C
0D
0E
0F
10
11
12
13
14
15
16
17
18
19
1A
1B
1C
1D
1E
1F

Comentário
Caractere Nulo

Binário
0000 0000
0000 0001 Começo de cabeçalho de transmissão
0000 0010
0000 0011
0000 0100
0000 0101
0000 0110
0000 0111
0000 1000
0000 1001
0000 1010
0000 1011
0000 1100
0000 1101
0000 1110
0000 1111
0001 0000
0001 0001
0001 0010
0001 0011
0001 0100
0001 0101
0001 0110
0001 0111
0001 1000
0001 1001
0001 1010
0001 1011
0001 1100
0001 1101
0001 1110
0001 1111

Começo de texto
Fim de texto
Fim de transmissão
Interroga
Conﬁrmação
Sinal sonoro
Volta um caractere
Tabulação horizontal
Próxima linha
Tabulação vertical
Próxima página
Início da linha
Shift-out
Shift-in
Data link escape
Controle de dispositivo
Controle de dispositivo
Controle de dispositivo
Controle de dispositivo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo
Caractere Nulo

Fonte: https://repositorio.ufu.br/bitstream/123456789/14443/4/SFOLima4DISSPRT.pdf

ANEXO A. Tabela ASCII - 128 Códigos (7 Bits)

99

Tabela 27 – Tabela ASCII - Caracteres imprimíveis

Caractere Decimal Hexadecimal

Espaço
!
"
#
$
%
&
’
(
)
*
+
,
-
.
/
0
1
2
3
4
5
6
7
8
9
:
;
<
=
>
?
@
A
B
C
D
E
F
G
H
I
J
K

32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75

20
21
22
23
24
25
26
27
28
29
2A
2B
2C
2D
2E
2F
30
31
32
33
34
35
36
37
38
39
3A
3B
3C
3D
3E
3F
40
41
42
43
44
45
46
47
48
49
4A
4B

Binário
0010 0000
0010 0001
0010 0010
0010 0011
0010 0100
0010 0101
0010 0110
0010 0111
0010 1000
0010 1001
0010 1010
0010 1011
0010 1100
0010 1101
0010 1110
0010 1111
0011 0000
0011 0001
0011 0010
0011 0011
0011 0100
0011 0101
0011 0110
0011 0111
0011 1000
0011 1001
0011 1010
0011 1011
0011 1100
0011 1101
0011 1110
0011 1111
0100 0000
0100 0001
0100 0010
0100 0011
0100 0100
0100 0101
0100 0110
0100 0111
0100 1000
0100 1001
0100 1010
0100 1011

Fonte: https://repositorio.ufu.br/bitstream/123456789/14443/4/SFOLima4DISSPRT.pdf

ANEXO A. Tabela ASCII - 128 Códigos (7 Bits)

100

Tabela 28 – Tabela ASCII - Caracteres imprimíveis (Continuação)

Caractere Decimal Hexadecimal

L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
[
\
]
ˆ
_
`
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x

76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120

4C
4D
4E
4F
50
51
52
53
54
55
56
57
58
59
5A
5B
5C
5D
5E
5F
60
61
62
63
64
65
66
67
68
69
6A
6B
6C
6D
6E
6F
70
71
72
73
74
75
76
77
78

Binário
0100 1100
0100 1101
0100 1110
0100 1111
0101 0000
0101 0001
0101 0010
0101 0011
0101 0100
0101 0101
0101 0110
0101 0111
0101 1000
0101 1001
0101 1010
0101 1011
0101 1100
0101 1101
0101 1110
0101 1111
0110 0000
0110 0001
0110 0010
0110 0011
0110 0100
0110 0101
0110 0110
0110 0111
0110 1000
0110 1001
0110 1010
0110 1011
0110 1100
0110 1101
0110 1110
0110 1111
0111 0000
0111 0001
0111 0010
0111 0011
0111 0100
0111 0101
0111 0110
0111 0111
0111 1000

Fonte: https://repositorio.ufu.br/bitstream/123456789/14443/4/SFOLima4DISSPRT.pdf

ANEXO A. Tabela ASCII - 128 Códigos (7 Bits)

101

Tabela 29 – Tabela ASCII - Caracteres imprimíveis (Continuação)

Caractere Decimal Hexadecimal

y
z
{
|
}
(cid:118)
DELETE

121
122
123
124
125
126
127

79
7A
7B
7C
7D
7E
7F

Binário
0111 1001
0111 1010
0111 1011
0111 1100
0111 1101
0111 1110
0111 1111

Fonte: https://repositorio.ufu.br/bitstream/123456789/14443/4/SFOLima4DISSPRT.pdf

ANEXO B – Tabela ASCII Estendida - 128
Códigos (8 Bits)

102

Figura 41 – Tabela ASCII Estendida

Fonte: https://www.matematica.pt/util/resumos/tabela-ascii.php (Adaptada)

ANEXO B. Tabela ASCII Estendida - 128 Códigos (8 Bits)

103

Figura 42 – Tabela ASCII Estendida

Fonte: https://www.matematica.pt/util/resumos/tabela-ascii.php (Adaptada)

ANEXO B. Tabela ASCII Estendida - 128 Códigos (8 Bits)

104

Figura 43 – Tabela ASCII Estendida

Fonte: https://www.matematica.pt/util/resumos/tabela-ascii.php (Adaptada)

ANEXO C – Tabela Unicode - Padrão
UTF-8

105

Segue algumas tabelas de alguns dos idiomas contemplados pelo Unicode. Para

isto, utilizaremos a seguinte legenda:

Figura 44 – Legenda Unicode

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

Figura 45 – Controles C0 e latim básico

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

ANEXO C. Tabela Unicode - Padrão UTF-8

106

Figura 46 – Controles C1 e suplemento de Latin-1

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

Figura 47 – Latim Extended-A

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

Figura 48 – Latim Extended-B

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

ANEXO C. Tabela Unicode - Padrão UTF-8

107

Figura 49 – Extensões IPA

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

Figura 50 – Arábico

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

Figura 51 – Grego e copta

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

ANEXO C. Tabela Unicode - Padrão UTF-8

108

Figura 52 – Armênio

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

Figura 53 – Hebraico

Fonte: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF

