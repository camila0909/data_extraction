UNIVERSIDADE FEDERAL DE MATO GROSSO DO SUL

INSTITUTO DE MATEM`TICA

PROGRAMA DE P(cid:211)S GRADUA˙ˆO

MATEM`TICA EM REDE NACIONAL

MESTRADO PROFISSIONAL

SILVIO ROG(cid:201)RIO ALVES ESQUINCA

ALGORITMOS: RESOLU˙ˆO DE PROBLEMAS
B`SICOS

CAMPO GRANDE

OUTUBRO DE 2014

UNIVERSIDADE FEDERAL DE MATO GROSSO DO SUL

INSTITUTO DE MATEM`TICA

PROGRAMA DE P(cid:211)S GRADUA˙ˆO

MATEM`TICA EM REDE NACIONAL

MESTRADO PROFISSIONAL

SILVIO ROG(cid:201)RIO ALVES ESQUINCA

ALGORITMOS: RESOLU˙ˆO DE PROBLEMAS
B`SICOS

“
Orientadora: Prof.

“

Dr.

Elisabete Sousa Freitas

Disserta(cid:231)ªo apresentada ao Programa de P(cid:243)s-Gradua(cid:231)ªo em
MatemÆtica em Rede Nacional do Instituto de MatemÆtica
IM/UFMS, como parte dos requisitos para obten(cid:231)ªo do t(cid:237)tulo
de Mestre.

CAMPO GRANDE

OUTUBRO DE 2014

ALGORITMOS: RESOLU˙ˆO DE PROBLEMAS
B`SICOS

SILVIO ROG(cid:201)RIO ALVES ESQUINCA

Disserta(cid:231)ªo submetida ao Programa de P(cid:243)s-Gradua(cid:231)ªo em Ma-
temÆtica em Rede Nacional, Instituto de MatemÆtica, da Univer-
sidade Federal de Mato Grosso do Sul, como parte dos requisitos
para obten(cid:231)ªo do t(cid:237)tulo de Mestre.

Aprovado pela Banca Examinadora:

Prof.“ Dr.“ Elisabete Souza Freitas - UFMS
Prof.“ Dr.“ Janete de Paula Ferrareze Silva- UFMS
Prof. Dr. Rui Seimetz - UNB

CAMPO GRANDE

OUTUBRO DE 2014

Dedico este trabalho aos meus pais, os quais,
mesmo com suas limita(cid:231)ıes (cid:28)nanceiras, (cid:28)zeram o
que estava em seu alcance, para que eu estudasse e
tentasse ter um futuro melhor e mais d(cid:237)gno. Agra-
de(cid:231)o por terem me mostrado que o caminho da ver-
dade, por mais Ærduo que seja, ainda Ø o melhor a
ser seguido, mesmo havendo muitos obstÆculos na
busca da realiza(cid:231)ªo dos sonhos pessoais. Que Deus
e nosso senhor Jesus Cristo os aben(cid:231)oe sempre.

Ep(cid:237)grafe

Mas os que esperam no senhor renovarªo as suas
for(cid:231)as, subirªo com asas como Æguias, correrªo e
nªo se cansarªo, caminharªo e nªo se fatigarªo.

(Isa(cid:237)as 40:31)

AGRADECIMENTOS

Primeiramente, agrade(cid:231)o a Deus e ao nosso Senhor Jesus Cristo, por terem me

concedido a gra(cid:231)a de ingressar e de prosseguir atØ o (cid:28)m neste mestrado.

Agrade(cid:231)o ainda a minha esposa Josiane Colombo Pedrini Esquinca, por ajudar-me

durante este curso, para que eu pudesse chegar atØ o (cid:28)m dele.

Aos meus pais, por acreditarem em mim e por suas ora(cid:231)ıes, as quais, com cer-
teza, surtiram efeito, no sentido de eu ser aprovado nas disciplinas do curso e no exame de
quali(cid:28)ca(cid:231)ªo.

A minha professora e orientadora, Elisabete Souza Freitas, que, com respeito,
determina(cid:231)ªo, dedica(cid:231)ªo e amparo, em todos os momentos da constru(cid:231)ªo deste trabalho,
dedicou-se, sem medir esfor(cid:231)os, em orientar-me, para que este trabalho fosse conclu(cid:237)do com
Œxito.

Ao professor Claudemir Aniz, por ter administrado este curso, conforme os prin-
c(cid:237)cpios que regem a administra(cid:231)ªo pœblica, garantido seriedade e respeito em todas as etapas
deste mestrado.

A todos os professores que (cid:28)zeram parte deste curso, por terem me transmitido
conhecimentos preciosos e importantes para o desempenho da fun(cid:231)ªo de professor de mate-
mÆtica.

Ao programa Profmat, por dar-me a oportunidade de adquir o t(cid:237)tulo de mestre,
almejado hÆ muito tempo, o qual, com certeza, ampliarÆ as oportunidades de trabalho, alØm
de proporcionar-me uma maior bagagem de conhecimento.

A Capes, pelo incentivo e (cid:28)nanciamento do curso.
Aos meus professores de gradua(cid:231)ªo, por terem dado-me o conhecimento que ga-
rantiu minha pro(cid:28)ssªo de professor e que me ajudou chegar atØ o Profmat. Em particular,
agrade(cid:231)o a Ant(cid:244)nio Carlos Tamarozzi, por ter acreditado em mim, orientando-me do in(cid:237)cio
ao (cid:28)m da gradua(cid:231)ªo, sem medir esfor(cid:231)os, incentivando-me a prosseguir nos estudos.

Aos colegas de turma de mestrado, pelo companheirismo e apoio nos momentos

dif(cid:237)ceis, que levou (cid:224) troca de experiŒncias.

Aos colegas de trabalho, lotados na Escola Estadual JosØ Ferreira Barbosa, Ma-
riomar Rezende Diniz Junior, Suely Oliveira de Assis, Eder RØgis e Johnny Mattos, por todo
o apoio prestado para que eu pudesse concluir este curso.

Aos colegas de trabalho, lotados na Escola Municipal Professor Pl(cid:237)nio Mendes dos
Santos, Osvaldo Alves Pinto, Ros(cid:226)ngela Cristina Ferreira Lino, MarinŒs, por todo o apoio
prestado para que eu pudesse concluir este curso.

Resumo

O objetivo deste trabalho Ø apresentar uma introdu(cid:231)ªo ao estudo de algoritmo. AtravØs de
exemplos, o custo de algoritmos serÆ analisado de forma simpli(cid:28)cada. Serªo discutidos o
algoritmo da divisªo, o algoritmo de Strassen, para a multiplica(cid:231)ªo de matrizes, e alguns
problemas clÆssicos da computa(cid:231)ªo.
Palavras-chave: Algoritmo. Algoritmo da divisªo. Algoritmo de Strassen.

Abstract

The objective of this work is to present an introduction to the study of algorithm. Th-
rough examples, cost algorithms will be discussed in simpli(cid:28)ed form. Discussed the division
algorithm, Strassen’s algorithm for matrix multiplication, and some classical problems of
computing.
Keywords: Algorithm. Division algorithm. Strassen algorithm.

SumÆrio

1 Introdu(cid:231)ªo

2 Algoritmos

2.1 Algoritmos para expansªo na base decimal e binÆria . . . . . . . . . . . . . .
2.2 Algoritmo para determina(cid:231)ªo dos subconjuntos de um conjunto . . . . . . .
2.3 Algoritmo para o cÆlculo do valor de uma potŒncia . . . . . . . . . . . . . .
2.4 Nota(cid:231)ªo Assint(cid:243)tica O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1 Propriedades da Nota(cid:231)ªo O . . . . . . . . . . . . . . . . . . . . . . .

3 Algoritmos na MatemÆtica BÆsica

3.1 Divisªo Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 MÆximo Divisor Comum de Dois Nœmeros Naturais . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Divisªo de Polin(cid:244)mios
3.3.1 Dispositivo PrÆtico de Briot-Ru(cid:30)ni . . . . . . . . . . . . . . . . . . .
3.4 Nœmeros Primos
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 Multiplica(cid:231)ªo de Matrizes Quadradas . . . . . . . . . . . . . . . . . . . . . .

4 Exemplos ClÆssicos de Algoritmos Computacionais

4.2.2 Ordena(cid:231)ªo Por Sele(cid:231)ªo

4.1 Localiza(cid:231)ªo de Item em uma Lista . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Ordena(cid:231)ªo dos Elementos (Nœmeros) de um Vetor . . . . . . . . . . . . . . .
4.2.1 Ordena(cid:231)ªo Bolha . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.1.1 Custo da Ordena(cid:231)ªo Bolha . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2.1 Custo da Ordena(cid:231)ªo Por Sele(cid:231)ªo . . . . . . . . . . . . . . .
4.2.3 Ordena(cid:231)ªo Por Inser(cid:231)ªo . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.3.1 Custo da Ordena(cid:231)ªo Por Inser(cid:231)ªo (Pior Caso) . . . . . . . .
. . . . . . . . . . . . . . . . . .
4.2.4.1 Custo da Ordena(cid:231)ªo Por Intercala(cid:231)ªo (Pior Caso) . . . . . .

4.2.4 Ordena(cid:231)ªo Por Intercala(cid:231)ªo (Merge)

5 Considera(cid:231)ıes Finais

1

2
6
12
13
18
20

23
23
29
33
33
35
37

47
47
51
51
53
53
55
55
57
58
66

68

1

Cap(cid:237)tulo 1

Introdu(cid:231)ªo

O objetivo principal desse trabalho Ø apresentar uma motiva(cid:231)ªo para o estudo da

MatemÆtica, atravØs de uma inicia(cid:231)ªo ao estudo de algoritmos.

JÆ no ensino bÆsico, aprende-se algoritmos para solucionar certos problemas. Por
exemplo, cÆlculo do quociente e do resto da divisªo de um inteiro por outro (algoritmo da
divisªo) ou cÆlculo do mÆximo divisor comum de dois inteiros (algoritmo euclidiano). Estes
dois algoritmos jÆ aparecem descritos nos Elementos de Euclides, escrito por volta de 300
a.C.

Um algoritmo representa os passos necessÆrios para realizar uma tarefa. Sua exe-
cu(cid:231)ªo pode ser feita por computadores, capazes de efetuar enormes cÆlculos, ou por pessoas.
Atualmente existem nas escolas laborat(cid:243)rios de computa(cid:231)ªo e alunos e profes-
sores sªo estimulados a usar programas ou softwares para auxiliar no processo de ensino-
aprendizagem. Um programa de computador Ø essencialmente um algoritmo que diz ao
computador os passos espec(cid:237)(cid:28)cos e em que ordem eles devem ser executados, como por exem-
plo, os passos a serem tomados para calcular o mÆximo divisor comum de dois inteiros. Outro
exemplo, os passos para calcular as mØdias (cid:28)nais dos alunos de uma escola.

Antes de executar um programa em um computador, o programa deve ser codi(cid:28)-
cado em uma linguagem de programa(cid:231)ªo da escolha do programador. E, antes de codi(cid:28)car o
programa, o programador deve ter escolhido (criado, descoberto) um algoritmo para a resolu-
(cid:231)ªo do problema. Portanto, a cria(cid:231)ªo de um algoritmo precede a pr(cid:243)pria escrita do programa
na linguagem de programa(cid:231)ªo. Antes de criar um algoritmo para resolver um problema, ou
escolher um algoritmo jÆ pronto, nªo hÆ como codi(cid:28)cÆ-lo numa linguagem de programa(cid:231)ªo,
muito menos como executÆ-lo em um computador.

Os algoritmos podem realizar a mesma tarefa, cada um gastando mais ou menos
tempo, espa(cid:231)o ou esfor(cid:231)o do que o outro. Para qualquer processo computacional, o algoritmo
precisa estar bem de(cid:28)nido, a corretividade do algoritmo precisa ser estudada matematica-
mente, a quantidade assint(cid:243)tica de tempo e espa(cid:231)o (custo) necessÆrios para a sua execu(cid:231)ªo
deve ser analisada.

Uma introdu(cid:231)ªo sobre algoritmos Ø apresentada no cap(cid:237)tulo 2, tratando do con-

ceito, representa(cid:231)ªo, custo de execu(cid:231)ªo e e(cid:28)ciŒncia de algoritmos.

No cap(cid:237)tulo 3, sªo discutidos, alØm de outros exemplos, o algoritmo da divisªo,

de dois nœmeros naturais e o algoritmo de Strassen, para a multiplica(cid:231)ªo de matrizes.
No cap(cid:237)tulo 4, sªo apresentados alguns problemas clÆssicos da computa(cid:231)ªo.

2

Cap(cid:237)tulo 2

Algoritmos

Informalmente, um algoritmo Ø uma sequŒncia precisa (sem dœvidas sobre o que
deve ser feito) de instru(cid:231)ıes que, se lida e executada por qualquer pessoa ou por um com-
putador, produz o resultado esperado, isto Ø, a solu(cid:231)ªo de um problema. Esta sequŒncia de
instru(cid:231)ıes Ø uma descri(cid:231)ªo da sequŒncia dos passos necessÆrios, os quais devem ser executa-
dos, para manipular informa(cid:231)ıes, ou dados, para se chegar na resposta do problema.

Mais formalmente, um algoritmo Ø uma sequŒncia (cid:28)nita A = (i1, i2, i3, ..., in) de

instru(cid:231)ıes ik, k ∈ {1, 2, ..., n}, tais que:

1. ik nªo apresenta ambiguidade, ∀k ∈ {1, 2, ..., n};

2. depois da execu(cid:231)ªo de ik, nªo haverÆ ambiguidade sobre ij, j ∈ {k + 1, k + 2, ..., n};

3. a instru(cid:231)ªo de parar Ø sempre alcan(cid:231)ada depois da execu(cid:231)ªo de um nœmero (cid:28)nito de

instru(cid:231)ıes; e

4. hÆ produ(cid:231)ªo de resultado correto para o problema a ser solucionado.

Exemplo 1. Abaixo estªo as instru(cid:231)ıes inscritas em uma placa de metal anexada (cid:224) frente
de um videogame:

Passo 1 (i1):

Insira vinte e cinco centavos na fenda para moedas ao lado da

mÆquina.

Passo 2 (i2): Pressione o botªo verde no topo da mÆquina quando estiver pronto

para iniciar.

Veja que existem duas instru(cid:231)ıes, i1 e i2, bem de(cid:28)nidas, sem ambiguidades. HÆ
clareza sobre o pr(cid:243)ximo passo a ser executado (i2). A instru(cid:231)ªo de parar foi omitida, pois
(cid:28)ca claro que cada instru(cid:231)ªo Ø executada apenas uma vez para cada jogo. Isto permite dizer,
conforme a de(cid:28)ni(cid:231)ªo, que tais passos representam um algoritmo para iniciar um jogo, sendo
este indicado por A(i1, i2).

Exemplo 2. Suponha que uma terceira instru(cid:231)ªo, i3, seja adicionada no exemplo 1, conforme
o que segue abaixo:

Passo 3 (i3): Quando cada jogo for (cid:28)nalizado, escreva suas iniciais e pressione o

botªo vermelho no topo da mÆquina para gravar seus pontos obtidos para a posteridade.

3

O passo 3 cumpre o papel de uma instru(cid:231)ªo de parada do jogo fornecido pela
mÆquina, para nªo durar para sempre, estando de acordo com a terceira propriedade da
de(cid:28)ni(cid:231)ªo formal de algoritmo, e mostra que vocŒ nªo poderÆ efetuar um segundo jogo com o
dinheiro pago inicialmente para o primeiro jogo.

Exemplo 3. Suponha ainda que seja inserida a seguinte instru(cid:231)ªo, i4, no exemplo 1:

Passo 4 (i4): Para cada 10.000 pontos que vocŒ acumular, ganharÆ um jogo
grÆtis. Quando o jogo em execu(cid:231)ªo (cid:28)nalizar, se vocŒ tem direito a um jogo grÆtis, vÆ para o
passo 2 (i2).

O passo 4 contraria a de(cid:28)ni(cid:231)ªo de algoritmo, pois seria poss(cid:237)vel obter a sequŒncia
in(cid:28)nita A = (i1, i2, i3, i4, i2, i3, i4, i2, i3, i4, ...). Portanto, A = (i1, i2, i3, i4) nªo
representa um algoritmo. O passo 4 Ø considerado como loop (la(cid:231)o condicional), por permitir
a execu(cid:231)ªo de um passo mais do que uma vez, toda vez que a a(cid:28)rma(cid:231)ªo dele for verdadeira.
Os exemplos 1 e 2 sªo chamados de algoritmos sequenciais, pois nªo permitem o retorno para
a execu(cid:231)ªo de uma instru(cid:231)ªo anterior, mais de uma vez.

Para transformar a inclusªo e permitir que A = (i1, i2, i3, i4) seja um algoritmo,

pode-se reescrevŒ-lo conforme o que segue abaixo.

Exemplo 4. Suponha que a instru(cid:231)ªo i4 tenha sido modi(cid:28)cada, conforme o que segue:

Passo 4 (i4): Para cada 10.000 pontos que acumular, vocŒ ganharÆ um jogo de
gra(cid:231)a, sendo o nœmero mÆximo de jogos gratuitos ganhos igual a 10 para cada jogo pago.
Quando o jogo em execu(cid:231)ªo (cid:28)nalizar, se vocŒ tem direito a um jogo grÆtis, vÆ para o passo
2.

Veja agora que o novo passo 4 (loop) serÆ executado uma quantidade (cid:28)nita de

vezes. Agora, nestas condi(cid:231)ıes, A = (i1, i2, i3, i4) Ø um algoritmo.

(cid:4)

A sequŒncia de instru(cid:231)ıes nªo serÆ um algoritmo correto se faltarem instru(cid:231)ıes

necessÆrias para a produ(cid:231)ªo da solu(cid:231)ªo do problema.

Suponha que x e y sejam duas variÆveis assumindo os respectivos valores 5 e 2. (cid:201)
uma tarefa comum trocar os valores das variÆveis, como se estivesse arranjando os nœmeros
2 e 5 para as posi(cid:231)ıes x e y, (cid:28)xadas. Neste caso, ap(cid:243)s a troca, tem-se que x = 2 e y = 5.

Exemplo 5. Os passos abaixo representam uma forma para se trocar os valores assumidos
pelas variÆveis x e y.
(cid:7) Passo 1: Fa(cid:231)a x assumir o valor de y.
(cid:7) Passo 2: Fa(cid:231)a y assumir o valor de x.
(cid:7) Passo 3: Pare.

SerÆ que o algoritmo deste exemplo estÆ correto? Veja como ele funcionarÆ para

a suposi(cid:231)ªo dada acima.

Instru(cid:231)ªo
Antes de i1
Depois de i1
Depois de i2

Valor assumido para x Valor assumido para y

5
2
2

2
2
2

4

Por que depois do passo 2 a variÆvel y nªo assumiu o valor 5? Acontece que depois
do passo 1 o valor 5 foi esquecido. Mas Ø preciso obter y = 5, depois do passo 2. PorØm,
como fazer isso se o velho valor de x, 5, foi regravado para o valor 2? Uma solu(cid:231)ªo para tal
problema Ø apresentada no pr(cid:243)ximo exemplo.

Exemplo 6. Segue abaixo uma sequŒncia de instru(cid:231)ıes que realizarÆ a troca dos valores
conforme desejado.

(cid:7) Entrada: x e y.
(cid:7) Sa(cid:237)da: x e y com valores trocados.
(cid:7) Passo 1: Atribua o valor de y a uma variÆvel auxiliar chamada y_velho.
(cid:7) Passo 2: Fa(cid:231)a y assumir o valor de x (y := x).
(cid:7) Passo 3: Fa(cid:231)a x assumir o valor de y_velho.
(cid:7) Passo 4: Pare.

(cid:4)

O resultado obtido Ø mostrado logo abaixo.

Passos Valor assumido para x Valor assumido para y
Passo 1
Passo 2
Passo 3
Passo 4

5
5
2
Pare.

2
5
5

Para solucionar um problema, um algoritmo precisa de uma entrada, representada
por uma ou mais variÆveis, relacionadas com o problema. Ap(cid:243)s a execu(cid:231)ªo de todas as
instru(cid:231)ıes, o algoritmo produz uma sa(cid:237)da que Ø a solu(cid:231)ªo para o problema.

Exemplo 7. (Conjectura de Lothar Collatz) Considere o seguinte procedimento:

(cid:7) Entrada: O nœmero positivo z.
(cid:7) Sa(cid:237)da: O nœmero 1.
(cid:7) Passo 1: Entre com um nœmero inteiro positivo z.
(cid:7) Passo 2: Se z for par, troque o valor de z por z
2 .
(cid:7) Passo 3: Se z = 1, entªo a sa(cid:237)da serÆ z e pare.
(cid:7) Passo 4: Se z for (cid:237)mpar, troque o valor de z por 3z + 1.
(cid:7) Passo 5: VÆ para i2.

Este Ø um problema proposto pelo alemªo Lothar Collatz para o qual nªo se
sabe ainda se a sequŒncia de nœmeros produzida (cid:28)ndarÆ em 1, para todo nœmero inteiro nªo
negativo. Ele s(cid:243) serÆ um algoritmo, se houver parada com produ(cid:231)ªo de resultado (cid:28)nal z = 1.

Exemplo 8. Executando a conjectura de Collatz para z = 1, z = 20 e z = 7, tem-se:

SequŒncia obtida para z = 1: (1).
SequŒncia obtida para z = 20: (20, 10, 5, 16, 8, 4, 2, 1).
SequŒncia obtida para z = 7: (7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4,

2, 1).

5

(cid:4)

Exemplo 9. A sequŒncia (1, 1, 2, 3, 5, 8, 13, 21, ...) Ø composta pelos nœmeros de Fibonacci,
obedecendo (cid:224) recorrŒncia an = an−1 + an−2, para a1 = a2 = 1 e n (cid:62) 3, ou seja, para se
obter o n-Øsimo termo desta sequŒncia, recorre-se aos dois termos anteriores a an, somando-
os para dar o valor de an. Segue abaixo um algoritmo que retorna os n primeiros nœmeros
da sequŒncia de Fibonacci, para n (cid:62) 3.

(cid:7) Entrada: O nœmero n, sendo n (cid:62) 3.
(cid:7) Sa(cid:237)da: Os n primeiros nœmeros da sequŒncia de Fibonacci.
(cid:7) Passo 1: Considere a1 = a2 = 1.
(cid:7) Passo 2: Para i := 3 atØ n, fa(cid:231)a ai
(cid:7) Passo 3: Para i := 1 atØ n, retorne ai.
(cid:7) Passo 4: Pare.

:= ai−1 + ai−2.

Exemplo 10. Uma sequŒncia (cid:28)nita de nœmeros inteiros (a1, a2, ..., an) serÆ crescente se
a1 (cid:54) a2 (cid:54) a3 (cid:54) ... (cid:54) an. O algoritmo a seguir lŒ os nœmeros de uma sequŒncia (cid:28)nita e diz se
ela Ø crescente ou nªo.

(cid:7) Entrada: A quantidade n de elementos da sequŒncia e os seus elementos: a1, a2, ..., an.
(cid:7) Sa(cid:237)da: Apenas uma das duas frases: (cid:16)Esta sequŒncia nªo Ø crescente(cid:17) ou (cid:16)Esta sequŒncia

Ø crescente(cid:17).
(cid:7) Passo 1: Para i

:= 1 atØ n − 1, se ai > ai+1 escreva: (cid:16)Esta sequŒncia nªo Ø crescente(cid:17).

Caso contrÆrio, escreva: (cid:16)Esta sequŒncia Ø crescente(cid:17).

(cid:7) Passo 2: Pare.

Para compreender melhor como sªo executadas as instru(cid:231)ıes do algoritmo, pode-
se efetuar o chamado teste de mesa, que consiste na execu(cid:231)ªo mental desse algoritmo, o
qual tambØm Ø chamado de c(cid:243)digo, sendo os passos anotados, em sequŒncia de execu(cid:231)ªo, no
papel. Nesse teste, a pessoa serÆ o processador e (cid:28)carÆ responsÆvel por executar cada linha
do c(cid:243)digo. O teste permite veri(cid:28)car se o c(cid:243)digo estÆ realmente executando a fun(cid:231)ªo para a
qual foi criado, e se existe algum erro de l(cid:243)gica nos passos apresentados.

O teste surgiu em uma Øpoca na qual programar um computador era extrema-
mente complicado. Apenas aceitar que um c(cid:243)digo estava correto era um desperd(cid:237)cio de tempo
e, portanto, era necessÆrio ter certeza de que aquele programa funcionaria. Munidos, entªo,
de papel e lÆpis, os programadores faziam simula(cid:231)ıes de execu(cid:231)ªo e corrigiam erros encontra-
dos antes mesmo de executar o c(cid:243)digo na mÆquina real. Essa prÆtica se perdeu com o tempo,
com o advento da programa(cid:231)ªo interativa, na qual o programador tem acesso (cid:224) mÆquina e
pode testar altera(cid:231)ıes.

A vantagem desse tipo de teste Ø que ele ajuda a desenvolver o racioc(cid:237)nio l(cid:243)gico
do programador, que, depois de um certo tempo de prÆtica, consegue identi(cid:28)car problemas
apenas olhando para o c(cid:243)digo impresso, sem necessitar executÆ-lo.

Exemplo 11. Dada uma lista de nœmeros reais: a1, a2, ..., an, a mØdia aritmØtica dos
a1 + a2 + ... + an
nœmeros desta lista Ø dada por M A =
. Veja abaixo, (cid:224) esquerda, o algoritmo
n
que calcula a mØdia aritmØtica de tal lista.

- Entrada: n e os valores de a1, a2, ..., an.
- Sa(cid:237)da: A mØdia aritmØtica dos n nœmeros.

- Passo 1: Considere x = 0.

- Passo 2: Para cada valor de i, variando de 1
atØ n, fa(cid:231)a x assumir o valor do antigo x so-

mado com ai (x := x + ai).

- Passo 3: Divida x por n e considere o resul-
(cid:16)
tado obtido como M A

M A =

(cid:17)

.

x
n

- Passo 4: Retorne M A e pare.

6

Veja os passos executados
logo abaixo:
- Passo 1: x := 0.
- Passo 2:
i := 1 e x := 0 + a1 = a1.
+ a2.
i := 2 e x := a1
(cid:124)(cid:123)(cid:122)(cid:125)
x velho

+ a3

+ an

i := 3 e x := a1 + a2
(cid:124) (cid:123)(cid:122) (cid:125)
x velho

...
i := n e x :=
= a1 + a2 + ... + an−1
(cid:125)
(cid:123)(cid:122)
x velho
x
n

- Passo 3: M A :=
- Passo 4: Retorne M A.

(cid:124)

.

Exemplo 12. Para calcular a dist(cid:226)ncia entre dois pontos do plano: A(x1, y1) e B(x2, y2),
utiliza-se a f(cid:243)rmula DA,B = (cid:112)(x1 − x2)2 + (y1 − y2)2, na qual DA,B indica a dist(cid:226)ncia entre
os pontos A e B. As instru(cid:231)ıes abaixo representam um algoritmo para calcular essa dist(cid:226)ncia:

(cid:7) Entrada: Considere os valores: x1, x2, y1 e y2 (entrada).
(cid:7) Sa(cid:237)da: A dist(cid:226)ncia entre os dois pontos do plano que possuem essas coordenadas.
(cid:7) Passo 1: a := x1 − x2
(cid:7) Passo 2: b := y1 − y2
(cid:7) Passo 3: a := a ∗ a (novo valor de a)
(cid:7) Passo 4: b := b ∗ b (novo valor de b)
(cid:7) Passo 5: m := a + b
(cid:7) Passo 6: DA,B := sqrt(m)
(cid:7) Passo 7: Escreva o valor de DA,B (sa(cid:237)da).
(cid:7) Passo 8: Pare.
Observa(cid:231)ªo 1. sqrt(m) signi(cid:28)ca

m.

√

2.1 Algoritmos para expansªo na base decimal e binÆria

O sistema decimal posicional Ø utilizado universalmente pelas pessoas para re-
presentar os nœmeros inteiros. Chama-se decimal por ser representado pelos dez algarismos:
0, 1, 2, 3, 4, 5, 6, 7, 8 e 9, chamados de algarismos indo-arÆbicos, pois foram desenvolvidos
pelo povo indiano e divulgados pelo povo Ærabe.

Existem outros sistemas de numera(cid:231)ªo em uso, como o sistema binÆrio ou em
bases potŒncias de 2, que Ø utilizado em computa(cid:231)ªo. Alguns computadores, para executar
um algoritmo, convertem as palavras deste algoritmo para c(cid:243)digo binÆrio. Veja a seguir a
tabela com alguns c(cid:243)digos binÆrios e suas representa(cid:231)ıes:

7

BinÆrio Glifo
0010 1011
0010 1111
0011 0000
0011 0001
0011 0010
0011 0011

+
/
0
1
2
3

BinÆrio Glifo
0011 0100
0011 0101
0011 0110
0011 0111
0011 1000
0011 1001

4
5
6
7
8
9

O sistema tambØm Ø chamado posicional, pois cada algarismo, alØm do seu valor
intr(cid:237)nseco, possui um peso que lhe Ø atribu(cid:237)do em fun(cid:231)ªo da posi(cid:231)ªo que ele ocupa no nœmero.
No caso do sistema decimal, esse peso, Ø uma potŒncia de dez e ele varia do seguinte modo:
O algarismo da extrema direita tem peso 100 (posi(cid:231)ªo 0); o seguinte, sempre da
direita para a esquerda, tem peso 101 (posi(cid:231)ªo 1); o seguinte tem peso 102 (posi(cid:231)ªo 2); o
seguinte tem peso 103 (posi(cid:231)ªo 3), etc.

Exemplo 13. Considere o nœmero 12019 na base 10. Assim,

12019 = 1 · 104 + 2 · 103 + 0 · 102 + 1 · 101 + 9 · 100 = 1 · 104 + 2 · 103 + 1 · 10 + 9

Os sistemas de numera(cid:231)ªo posicionais baseiam-se no teorema a seguir, que Ø uma

aplica(cid:231)ªo da divisªo euclidiana.

Teorema 1. Dados a, b ∈ N ∪ {0}, com b > 1, existem nœmeros naturais c0, c1, ..., cn,
menores do que b, univocamente determinados, tais que a = c0 + c1b + c2b2 + ... + cnbn.

Demonstra(cid:231)ªo:

O teorema serÆ demonstrado por meio da segunda forma do Princ(cid:237)pio de Indu(cid:231)ªo
MatemÆtica, sobre a. Se a = 0, ou se a = 1, basta tomar n = 0 e c0 = a, e vale a unicidade.
Supondo o resultado vÆlido para todo natural menor do que a (cid:62) 1, serÆ provado

sua validade tambØm para a. Pela divisªo euclidiana, existem q e r, œnicos, tais que

a = bq + r, com 0 (cid:54) r < b.

Tem-se:

b > 1 ⇒ ab > a ⇒ a < ab (cid:54) ab + r ⇒ bq + r < ab + r ⇒ q < a.

Como q < a, pela hip(cid:243)tese de indu(cid:231)ªo, segue que existem nœmeros naturais n(cid:48) e

d0, d1, ..., dn(cid:48) , com dj < b, para todo j , univocamente determinados, tais que

q = d0 + d1b + · · · + dn(cid:48)bn(cid:48)

.

Levando em conta as igualdades acima destacadas, tem-se que

a = bq + r = b(d0 + d1b + · · · + dn(cid:48)bn(cid:48)) + r.

O resultado segue tomando c0 = r, n = n(cid:48) + 1 e cj = dj=1 para j = 1, ..., n, os

quais sªo univocamente determinados.

8

(cid:4)

CorolÆrio 1. Todo nœmero natural se escreve de modo œnico como soma de potŒncias dis-
tintas de 2.

A representa(cid:231)ªo dada no teorema acima Ø chamada de expansªo relativa (cid:224) base
b. Quando b = 10, essa expansªo Ø chamada expansªo decimal, e quando b = 2, ela recebe o
nome de expansªo binÆria.

A demonstra(cid:231)ªo do Teorema tambØm fornece um algoritmo para determinar a

expansªo de um nœmero qualquer relativamente (cid:224) base b.

Trata-se de aplicar, sucessivamente, a divisªo euclidiana, como segue:

a = bq0 + r0,

r0 < b,

q0 = bq1 + r1,

r1 < b,

q1 = bq2 + r2,

r2 < b,

e assim por diante. Como a > q0 > q1 > · · ·, deve-se, em um certo ponto, ter qn=1 < b e,
portanto, de

decorre que qn = 0, o que implica 0 = qn = qn+1 = qn+2 = · · ·, e portanto

qn=1 = bqn + rn,

Tem-se entªo que

0 = rn+1 = rn+2 = · · ·.

a = r0 + r1b + · · · + rnbn.

A expansªo numa dada base b fornece um mØtodo para representar os nœmeros
naturais. Para tanto, escolha um conjunto S tal que S = {1, 2, 3, ..., (b − 1)}. Um nœmero
natural a na base b se escreve da forma xnxn=1...x1x0, com x0, ..., xn ∈ S, e n variando,
dependendo de a, representando o nœmero x0 + x1b + · · · + xnbn.

No sistema decimal, isto Ø, de base b = 10, usa-se S = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}.

Exemplo 14. A expansªo decimal do nœmero 23456 Ø dada por:

2 · 104 + 3 · 103 + 4 · 102 + 5 · 101 + 6 · 100.

Exemplo 15. No sistema de base b = 2, tem-se que S = {0, 1} e todo nœmero natural Ø
representado por uma sequŒncia de 0 e 1. Por exemplo, o nœmero 10, na base 2, representa
o nœmero 2 (na base 10). Tem-se tambØm que

100 = 1 × 22 + 0 × 21 + 0 × 20 = 22, 101 = 1 + 22, 111 = 1 + 2 + 22, 1011 = 1 + 2 + 23.

9

(cid:4)

A sequŒncia de instru(cid:231)ıes abaixo Ø um algoritmo para converter nœmero binÆrio

para a forma decimal equivalente.

BinÆrio para Decimal

(cid:7) Entrada: Nœmero binÆrio s = sjsj−1...s1s0.
(cid:7) Sa(cid:237)da: Nœmero decimal m equivalente (cid:224) s.
(cid:7) Passo 1: Comece considerando j = 0, representando a posi(cid:231)ªo do primeiro algarismo de s,

da direita para a esquerda.

(cid:7) Passo 2: Considere tambØm m = 0. Ele representarÆ o nœmero decimal equivalente aos

algarismos obtidos, da direita para a esquerda, atØ a posi(cid:231)ªo j.

(cid:7) Passo 3: Se a posi(cid:231)ªo j nªo possuir algarismo entªo pare e retorne o valor de m como

resposta. Caso contrÆrio, continue.

(cid:7) Passo 4: Se o algarismo da posi(cid:231)ªo j for 1 entªo o nœmero decimal m serÆ dado por

m
(cid:124)(cid:123)(cid:122)(cid:125)
Novo

= m
(cid:124)(cid:123)(cid:122)(cid:125)
Velho

+ 2j.

(cid:7) Passo 5: Incremente j, ou seja, aumente uma unidade no j anterior, para trabalhar com

mais algarismos de s.

(cid:7) Passo 6: Volte a executar o passo 3.

Exemplo 16. Convertendo o nœmero binÆrio s = 110 para a forma decimal equivalente,
seguindo os passos dados logo acima, tem-se:

(cid:7) Passo 1: j := 0.
(cid:7) Passo 2: m := 0.
(cid:7) Passo 3: Existe algarismo na posi(cid:231)ªo j = 0, o zero. Entªo continue.
(cid:7) Passo 4: O algarismo da posi(cid:231)ªo j = 0 nªo Ø 1 (s0 (cid:54)= 1).
(cid:7) Passo 5: j := 1.
(cid:7) Passo 6: Volte a executar o passo 3.
(cid:7) Passo 3: Existe algarismo na posi(cid:231)ªo j = 1, s1 = 1. Entªo continue.
(cid:7) Passo 4: O algarismo da posi(cid:231)ªo j = 1 Ø 1. Entªo m passa a valer m + 2j = 0 + 21 = 2,

ou seja, m := 2.
(cid:7) Passo 5: j := 2.
(cid:7) Passo 6: Volte a executar o passo 3.
(cid:7) Passo 3: Existe algarismo na posi(cid:231)ªo j = 2, s2 = 1. Entªo continue.
(cid:7) Passo 4: O algarismo da posi(cid:231)ªo j = 2 Ø 1. Entªo m := 6.
(cid:7) Passo 5: j := 3.
(cid:7) Passo 6: Volte a executar o passo 3.
(cid:7) Passo 3: Nªo existe s3. Entªo pare e a resposta procurada Ø m = 6, na forma decimal.

(cid:4)

Pode-se representar tais passos da seguinte forma simpli(cid:28)cada, chamada de pseu-

doc(cid:243)digo.

10

Algoritmo BinÆrio para Decimal
(cid:21)> Entrada: O nœmero binÆrio s = sjsj−1...s1s0, diferente de zero.
i1: j := 0.
i2: m := 0
i3: Se nªo existir sj entªo pare e retorne m como resposta.
i4: Se sj = 1 entªo m := m + 2j.
i5: j := j + 1.
i6: VÆ para i3.

Para converter um nœmero decimal para a forma binÆria equivalente, utilizando

o que foi comentado anteriormente, obtØm-se o seguinte esquema na tabela abaixo:

Conversªo de Nœmero Decimal para BinÆrio - Algoritmo

Nœmero a ser dividido por 2 Quociente obtido Resto obtido

m
q0
q1
q2
...
qn−2
qn−1

q0
q1
q2
q3
...
qn−1
0

r0
r1
r2
r3
...
rn−1
rn

Assim, os algarismos que formarªo o nœmero binÆrio serªo todos os restos obtidos
na terceira coluna da tabela acima, ou seja, tal nœmero binÆrio serÆ rnrn−1...r3r2r1r0, nessa
ordem de posi(cid:231)ªo.

Exemplo 17. Segue abaixo a conversªo do nœmero decimal 210 para a forma binÆria equi-
valente, conforme a tabela acima.

Nœmero a ser dividido por 2 Quociente obtido Resto obtido

210
105
52
26
13
6
3
1

105
52
26
13
6
3
1
0

0
1↑
0↑
0↑
1↑
0↑
1↑
1↑

Conforme a tabela deste exemplo, o nœmero binÆrio obtido Ø: 11010010.
A tabela dada antes deste exemplo permite a constru(cid:231)ªo de uma sequŒncia (cid:28)nita
de instru(cid:231)ıes ou passos, bem de(cid:28)nidos, que representam um algoritmo para converter nœmero
decimal para a forma binÆria equivalente, conforme o que segue abaixo.

Decimal para BinÆrio

(cid:7) Entrada: O nœmero decimal m.
(cid:7) Sa(cid:237)da: O nœmero binÆrio s = sjsj−1...s1s0.
(cid:7) Passo 1: Considere j = 0, o qual representa a posi(cid:231)ªo do primeiro algarismo do resultado,

11

da direita para a esquerda.

(cid:7) Passo 2: Divida m por 2, obtendo quociente qj e resto rj (0 ou 1).
(cid:7) Passo 3: Insira rj na posi(cid:231)ªo j de s, ou seja, fa(cid:231)a sj
(cid:7) Passo 4: Se qj = 0 entªo pare e retorne s como resposta. Caso contrÆrio, continue.
(cid:7) Passo 5: Fa(cid:231)a m assumir valor qj, ou seja, m := qj.
(cid:7) Passo 6: Incremente o valor de j, somando a ele uma unidade.
(cid:7) Passo 7: Volte a executar o passo 2.

:= rj.

Exemplo 18. Segue abaixo a conversªo do nœmero decimal m = 21 para a forma binÆria
equivalente, aplicando os passos do algoritmo logo acima.

(cid:7) Passo 1: Considere j = 0.
(cid:7) Passo 2: m = 21 dividido por 2 fornece quociente q0 = 10 e resto r0 = 1.
(cid:7) Passo 3: s0 assume valor r0 = 1, ou seja, s0 := 1.
(cid:7) Passo 4: q0 (cid:54)= 0. Entªo continue.
(cid:7) Passo 5: m assume o valor de q0, isto Ø, m := 10.
(cid:7) Passo 6: j Ø incrementado de modo que j := 1.
(cid:7) Passo 7: Volte a executar o passo 2.
(cid:7) Passo 2: m = 10 dividido por 2 fornece quociente q1 = 5 e resto r1 = 0.
(cid:7) Passo 3: s1 assume valor r1 = 0, ou seja, s1 := 0.
(cid:7) Passo 4: q1 (cid:54)= 0. Entªo continue.
(cid:7) Passo 5: m assume o valor de q1, isto Ø, m := 5.
(cid:7) Passo 6: j := 2.
(cid:7) Passo 7: Volte a executar o passo 2.
(cid:7) Passo 2: m = 5 dividido por 2 fornece quociente q2 = 2 e resto r2 = 1.
(cid:7) Passo 3: s2 := r2 = 1.
(cid:7) Passo 4: q2 (cid:54)= 0. Entªo continue.
(cid:7) Passo 5: m := q2 = 2.
(cid:7) Passo 6: j := 3.
(cid:7) Passo 7: Volte a executar o passo 2.
(cid:7) Passo 2: m = 2 dividido por 2 fornece quociente q3 = 1 e resto r3 = 0.
(cid:7) Passo 3: s3 := r3 = 0.
(cid:7) Passo 4: q3 (cid:54)= 0. Entªo continue.
(cid:7) Passo 5: m := q3 = 1.
(cid:7) Passo 6: j := 4.
(cid:7) Passo 7: Volte a executar o passo 2.
(cid:7) Passo 2: m = 1 dividido por 2 fornece quociente q4 = 0 e resto r4 = 1.
(cid:7) Passo 3: s4 := r4 = 1.
(cid:7) Passo 4: q4 = 0. Entªo a sa(cid:237)da Ø s = s4s3s2s1s0 = 10101.

(cid:4)

12

Tem-se abaixo o pseudoc(cid:243)digo para esse procedimento.

Procedimento BinÆrio para Decimal
i1: j := 0
i2: Divida m por 2, para obter o quociente qj e o resto rj (0 ou 1).
i3 : Coloque rj na posi(cid:231)ªo j de s = sjsj−1...s1s0.
i4: Se qj = 0, entªo pare e retorne s como resposta. Caso contrÆrio, continue.
i5: m := qj.
i6: j := j + 1.
i7: VÆ para i2.

2.2 Algoritmo para determina(cid:231)ªo dos subconjuntos de

um conjunto

Proposi(cid:231)ªo 1. Dado um conjunto A, com n elementos, entªo o nœmero de subconjuntos de
A Ø 2n.

Demonstra(cid:231)ªo:

Por Indu(cid:231)ªo Finita sobre n, tem-se:
P (n) : Se A possui n elementos, entªo o nœmero de subconjuntos de A Ø 2n. Dessa

forma, para n = 1, tem-se:

A = {a1} de modo que ∅ e {a1} sªo os subconjuntos de A. Como 2n = 21 = 2,

P (1) Ø verdadeira.

Supondo P (n) verdadeira para algum nœmero natural n (cid:62) 1, serÆ provado que
P (n + 1) tambØm Ø verdadeira, ou seja, que se A tem n + 1 elementos entªo A possuirÆ 2n+1
subconjuntos. Tem-se que:

A = {a1, a2, ..., an, an+1} = {a1, a2, ..., an}
(cid:125)

(cid:124)

(cid:123)(cid:122)
= B

∪ {an+1}.

Como o nœmero de elementos de B Ø igual a n, segue, por hip(cid:243)tese de indu(cid:231)ªo,
que B possui 2n subconjuntos: B1 = (cid:216), B2,..., B2n , os quais tambØm sªo subconjuntos de
A, jÆ que Bi ⊂ B ⊂ A, ∀i ∈ {1, 2, ..., 2n}. AlØm disso, an+1 /∈ Bi, ∀i ∈ {1, 2, ..., 2n}. Para
construir os subconjuntos restantes de A, basta inserir o elemento an+1 em cada subconjunto
Bi, obtendo-se 2n novos subconjuntos. Assim, o total de subconjuntos de A Ø 2n + 2n =
2n.(1 + 1) = 2n. 2 = 2n+1. Portanto P (n + 1) Ø verdadeira.

A demonstra(cid:231)ªo da proposi(cid:231)ªo 1 fornece uma sequŒncia (cid:28)nita de passos, bem

de(cid:28)nidos, para produzir os subconjuntos de A, escrita na forma de um pseudoc(cid:243)digo.

Algoritmo Subconjuntos
i1: Entrada: n e a1, a2, ..., an.
i2: B(1) = (cid:216)
i3: k := 1
i4: Para j := 1 atØ n, fa(cid:231)a
i5:

Para i := 1 atØ 2j−1, fa(cid:231)a

B(k + 1) := B(i) ∪ {a(j)}
k := k + 1

i6 :
i7 :
i7 :
i7 :FimPara
i8 : Pare.

FimPara

Exemplo 19. Fazendo o teste de mesa aplicando o Algoritmo Subconjuntos em A = {a1, a2},
para listar os subconjuntos de A, tem-se:

13

Instru(cid:231)ªo Executada
...
i2
i3
i4
i5
i6
i7
i4
i5
i6
i7
i5
i6
i8

k

j

i

Subconjunto Obtido

B(1) = (cid:216)

1
1
1
1
2
2
2
2
3
3
3
Pare

1
1
1
1
2
2
2
2
2
2

B(2) = B(1) ∪ {a(1)} = {a(1)}

1
1
1
1
1
1
1
2
2 B(4) = B(2) ∪ {a(2)} = {a(1), a(2)}

B(3) = B(1) ∪ {a(2)} = {a(2)}

2.3 Algoritmo para o cÆlculo do valor de uma potŒncia

Considerando que as opera(cid:231)ıes aritmØticas bÆsicas de um computador sªo: adi(cid:231)ªo,
subtra(cid:231)ªo, multiplica(cid:231)ªo e divisªo, segue abaixo um algoritmo para se obter o valor de uma
potŒncia de base x.

Algoritmo Exponencia(cid:231)ªo
i1: Entre com os valores de x (cid:54)= 0 e de n
(n uma variÆvel inteira nªo negativa).
i2: i := 1
i3: x(i − 1) := 1
i4: Enquanto i (cid:54) n, fa(cid:231)a

i7: Se n = 0 entªo retorne xn = 1.
i8: Senªo retorne: xn = x(i − 1).
i9: Pare.
Esse algoritmo considera x (cid:54)= 0 e n ∈ N ∪ {0}, iniciando com i = 1 e x(0) = 1.

i5: x(i) := x(i − 1) ∗ x
i6: i := i + 1

Depois, para cada valor assumido por i, de 1 atØ n, tem-se:

x(1) = 1

(cid:124)(cid:123)(cid:122)(cid:125)
x(0)

· x −→ x(2) = x

(cid:124)(cid:123)(cid:122)(cid:125)
x(1)

· x −→ x(3) = x2
(cid:124)(cid:123)(cid:122)(cid:125)
x(2)

· x

x(4) = x3
(cid:124)(cid:123)(cid:122)(cid:125)
x(3)

· x −→ · · · −→ x(n) = xn−1
(cid:124)(cid:123)(cid:122)(cid:125)
x(n−1)

· x,

sendo x(n) retornado como solu(cid:231)ªo.

Exemplo 20. Aplicando o algoritmo para x = 5 e n = 3, obtØm-se:

14

i1: x = 5 e n = 3
i2:
i = 1
i3: x(0) = 1
i4: Teste verdadeiro
i5: x(1) = x(0) · 5 = 1 · 5 = 5
i6:
i4: Teste verdadeiro
i5: x(2) = x(1) · 5 = 5 · 5 = 25

i = 2

i = 3

i6:
i4: Teste verdadeiro
i5: x(3) = x(2) · 5 = 25 · 5 = 125
i6:
i = 4
i4: Teste falso
i7: Teste falso
i8:
i9: Pare.

53 = 125

De(cid:28)ni(cid:231)ªo 1. Chama-se piso de um nœmero real x, e denota-se o piso de x por (cid:98)x(cid:99) o maior
inteiro menor do que ou igual a x.

Exemplo 21. Conforme a de(cid:28)ni(cid:231)ªo 1, tem-se:

(cid:98)7(cid:99) = 7; (cid:98)4, 23(cid:99) = 4 e (cid:98)−5, 23(cid:99) = −6.

De(cid:28)ni(cid:231)ªo 2. Dado um nœmero real x, o menor inteiro maior do que ou igual a x serÆ
representado por (cid:100)x(cid:101).

Exemplo 22. De acordo com a de(cid:28)ni(cid:231)ªo acima, tem-se:

(cid:100)7(cid:101) = 7; (cid:100)4, 23(cid:101) = 5 e (cid:100)−5, 23(cid:101) = −5.

(cid:4)

SerÆ visto a seguir um outro algoritmo, denominado exponencia(cid:231)ªo rÆpida, para
o cÆlculo de potŒncias. Ele Ø baseado em sucessivas divisıes de expoente pelo nœmero 2,
conforme as igualdades abaixo, para o cÆlculo de xn.

xn = x2q0+r0

= (x · x)q0 · xr0
= (x2)2q1+r1 · xr0
= (x2 · x2)q1 · (x2)r1 · xr0
= (x4)2q2+r2 · (x2)r1 · xr0
= (x4 · x4)q2 · (x4)r2 · (x2)r1 · xr0
...
=

(cid:16)

x2k−2(cid:17)2·1+rk−2
x2k−2 · x2k−2(cid:17)1
(cid:16)
x2k−1(cid:17)2·0+1

·

·

·

(cid:16)

(cid:16)
x2k−3(cid:17)rk−3
x2k−4(cid:17)rk−4
· ... · (x2)r1 · xr0
(cid:16)
x2k−2(cid:17)rk−2
· (cid:0)xk−3(cid:1)rk−3 · ... · (x2)r1 · xr0
(cid:16)
x2k−3(cid:17)rk−3

·
x2k−2(cid:17)rk−2

· ... · (x2)r1 · xr0

·

(cid:16)

(cid:16)

=

=

Mas, esse procedimento faz com que n seja escrito na forma binÆria, ou seja,
n = rk−1rk−2...r1r0, sendo rk−1 = 1, rj ∈ {0, 1}, ∀j ∈ {0, 1, 2, ..., (k − 2)} e k − 1 o nœmero
de restos produzidos na divisªo por 2.

Assim, tem-se que:

2k−1 (cid:54) 2k−1 + rk−22k−2 + ... + r12 + r0
(cid:125)

(cid:124)

(cid:123)(cid:122)
=n

15

(cid:54)

(cid:54) 2k−1 + 2k−2 + ... + 2 + 1
(cid:125)
(cid:123)(cid:122)
(cid:124)
Soma dos k termos da P G de raz˜ao 2

= 1 · 2k−1

2−1 = 2k − 1 < 2k.

Portanto, 2k−1 (cid:54) n < 2k e

2k−1 (cid:54) n < 2k ⇔ log22k−1 (cid:54) log2n < log22k ⇔

k − 1 (cid:54) log2n < k ⇔ k − 1 = (cid:98)log2n(cid:99) ⇔

k = 1 + (cid:98)log2n(cid:99),

sendo (cid:98)log2n(cid:99) o maior inteiro menor do que ou igual a log2n.

Para esse algoritmo, tem-se:

(cid:136) Total de divisıes = k.

(cid:136) Total de multiplica(cid:231)ıes = (k − 1) + (k − 1) = 2k − 2.

(cid:136) Total de opera(cid:231)ıes = 3k − 2.

HÆ portanto 3k − 2 = 3 (1 + (cid:98)log2n(cid:99)) − 2 (cid:54) 3 (1 + log2n) − 2 = 1 + 3 log2n = g(n)

multiplica(cid:231)ıes e divisıes, no total.

Algoritmo Exponencia(cid:231)ªo RÆpida
i1: Entre com os valores de x e n, considerando resp := 1.
i2: Divida n por 2 para obter o quociente q e o resto r.
i3: Se r = 1, considere resp := resp ∗ x.
i4: Se q = 0, entªo pare.
i5: n := q.
i6: x := x ∗ x.
i7: VÆ para i2.

Exemplo 23. A seguir Ø executado o teste de mesa para o cÆlculo de x25.

Instru(cid:231)ªo Executada

i1
i2
i3
i5
i6

VariÆveis
resp
n
1
25
1
25
x
25
x
12
x
12

q
-
12
12
12
12

r
-
1
1
1
1

x
x
x
x
x
x2

16

Instru(cid:231)ªo Executada

i2
i5
i6
i2
i5
i6
i2
i3
i5
i6
i2
i3
i4

VariÆveis
resp
n
x
12
x
6
x
6
x
6
x
3
x
3
x
3
x9
3
x9
1
x9
1
x9
1
x25
1

q
6
6
6
3
3
3
1
1
1
1
0
0

r
0
0
0
0
0
0
1
1
1
1
1
1

x
x2
x2
x4
x4
x4
x8
x8
x8
x8
x16
x16
x16
Pare

O algoritmo exponencia(cid:231)ªo requer n multiplica(cid:231)ıes para computar xn. Indica-se
por f (n) (fun(cid:231)ªo de n) esta quantia. Neste caso, f (n) = n. Tal algoritmo Ø portanto chamado
de linear.

O algoritmo exponencia(cid:231)ªo rÆpida requer nªo mais do que 1 + 3 log2n multipli-
ca(cid:231)ıes e divisıes para computar xn. Indica-se essa quantia pela fun(cid:231)ªo g(n) = 1 + 3log2n.
Este algoritmo Ø chamado de logar(cid:237)tmico.

Exemplo 24. No caso n = 4, tem-se f (4) = 4 e g(4) = 1 + 3 × log24 = 1 + 3 × log222 =
1 + 3 × 2 = 7. Agora para n = 211 = 2048, tem-se: f (n) = 2048 e g(n) = 1 + 3 · log2211 =
1 + 3 × 11 = 34.

O Lema a seguir fornece uma propriedade necessÆria para a demostra(cid:231)ªo da pr(cid:243)-

xima proposi(cid:231)ªo, a qual compara os algoritmos exponencia(cid:231)ªo e exponencia(cid:231)ªo rÆpida.

Proposi(cid:231)ªo 2. Para todo natural n (cid:62) 12, tem-se que 1 + 3 · log2n < n.

Demonstra(cid:231)ªo:

Basta provar, usando o Princ(cid:237)pio de Indu(cid:231)ªo, que para n (cid:62) 12 tem-se n3 < 2n−1.

De fato,

1 + 3 · log2n < n ⇔ log2n <

n − 1
3

⇔ n < 2 n−1

3 ⇔ n3 < 2n−1.

Para n = 12, obtØm-se n3 = 123 = 1728 e 2n−1 = 211 = 2048, portanto a

desigualdade Ø verdadeira.

Suponha a desigualdade ser verdadeira para um n, isto Ø, n3 < 2n−1, na qual
n (cid:62) 12 (hip(cid:243)tese de indu(cid:231)ªo). SerÆ provado que tambØm Ø verdadeira para n + 1, ou seja,
que (n + 1)3 < 2n.

Usando a hip(cid:243)tese de indu(cid:231)ªo, tem-se que:

(n + 1)3 = n3 + 3n2 + 3n + 1 < 2n−1 + 3n2 + 3n + 1.

AlØm disso, tem-se que:

2n−1 + 3n2 + 3n + 1 < 2n−1 + 3n2 + 3n2 + 3n2 = 2n−1 + 9n† .

Como n (cid:62) 12, segue que 9n2 < n3 < 2n−1, logo

(n + 1)3 < 2n−1 + 9n2 < 2n−1 + n3 < 2n−1 + 2n−1 = 2n.

Portanto, (n + 1)3 < 2n.

17

(cid:4)

A compara(cid:231)ªo de dois ou mais algoritmos que solucionarªo o mesmo problema, Ø

fundamental para a escolha do mais e(cid:28)ciente.

A e(cid:28)ciŒncia de um algoritmo pode ser medida, por exemplo, em termos do tempo
de execu(cid:231)ªo ou do espa(cid:231)o (ou mem(cid:243)ria) usado. O custo de um algoritmo, dado por algum
desses tipos de medi(cid:231)ªo, Ø tambØm chamado de complexidade.

Existe complexidade de tempo, de uso de mem(cid:243)ria, de comunica(cid:231)ªo, do nœmero
de processadores, entre outras. A complexidade de um algoritmo consiste na quantidade de
(cid:16)trabalho(cid:17) necessÆrio para a sua execu(cid:231)ªo. Este estudo (Complexidade de Algoritmos) Ø uma
Ærea ampla da teoria dos algoritmos.

A contagem de passos na execu(cid:231)ªo de um algoritmo fornece uma caracteriza(cid:231)ªo
simpli(cid:28)cada da e(cid:28)ciŒncia de um algoritmo. Neste trabalho, deseja-se apenas dar uma pequena
ideia sobre custo de um algoritmo.

Em geral, considera-se que cada execu(cid:231)ªo da linha i possui um custo ci > 0, sendo
ci a quantidade de passos executados implicitamente, pelo computador. Por exemplo, o custo
da adi(cid:231)ªo 11 + 14, escritos no sistema decimal, nªo serÆ apenas duas adi(cid:231)ıes, 1+4 (unidades)
e 1+1 (dezenas) pois, em termos computacionais trabalha-se com a expansªo binÆria. Assim,
11 Ø interpretado pelo computador como 1011 e o 14 como 1110 e serÆ realizada a soma desses
nœmeros binÆrios. Entªo o custo, nœmero total de adi(cid:231)ıes, Ø dado pela expressªo

+

1
0
0
1

1
1
1
1

1
0
1
0

1
1
0

,

1
0
1

na qual ocorre mais adi(cid:231)ıes do que no caso anterior.

c(cid:243)digo, obtØm-se a fun(cid:231)ªo f : N −→ R+
n (cid:55)−→ f (n)

Fazendo a contagem levando em considera(cid:231)ªo os custos de cada linha do pseudo-
, na qual f (n) Ø o custo da execu(cid:231)ªo do algoritmo,

para a entrada n. A Proposi(cid:231)ªo 2 mostra que o algoritmo exponencia(cid:231)ªo rÆpida Ø mais
e(cid:28)ciente do que o algoritmo exponencia(cid:231)ªo.

Se a fun(cid:231)ªo de custo for um polin(cid:244)mio, por exemplo, f (n) = an2 + bn + c, sendo
(cid:1), de
a, b e c constantes positivas, dadas em fun(cid:231)ªo de ci, entªo f (n) = an2 (cid:0)1 + b
modo que, para n (cid:55)→ ∞, tem-se (cid:0)1 + b
(cid:1) tendendo a 1. Isso quer dizer que, a partir de n
an + c
an2
su(cid:28)cientemente grande, a fun(cid:231)ªo f cresce com n2, podendo f (n) = an2 ser considerada como

an + c
an2

18

a fun(cid:231)ªo custo, pois os termos inferiores, de menor crescimento na fun(cid:231)ªo, e as constantes
multiplicativas contribuem pouco na compara(cid:231)ªo, podendo ser descartados.

Quando se observa o tamanho de entradas grandes o su(cid:28)ciente, para tornar rele-
vante apenas a ordem de crescimento do tempo de execu(cid:231)ªo, estÆ sendo estudada a e(cid:28)ciŒncia
assint(cid:243)tica do algoritmo. Assim, deseja-se saber como o tempo de execu(cid:231)ªo de um algoritmo
aumenta com o tamanho da entrada aumentando inde(cid:28)nidamente (sem limita(cid:231)ªo). Em ge-
ral, um algoritmo que Ø assint(cid:243)ticamente mais e(cid:28)ciente serÆ a melhor escolha para todas as
entradas, exceto talvez para as muito pequenas.

2.4 Nota(cid:231)ªo Assint(cid:243)tica O

De(cid:28)ni(cid:231)ªo 3. Dadas as fun(cid:231)ıes f : N −→ R+
, diz-se que f (n) Ø O(g(n)) se
n (cid:55)−→f (n)
existem uma constante positiva c e n0 ∈ N tais que 0 < f (n) (cid:54) c.g(n), para todo n (cid:62) n0.
Neste caso, usa-se a nota(cid:231)ªo f = O(g).

e g : N −→ R+
n (cid:55)−→g(n)

Em outras palavras, dada uma fun(cid:231)ªo g(n), indicando por O(g(n)) o conjunto das

fun(cid:231)ıes

{f (n) | existem constantes c > 0 e n0 ∈ N tais que 0 (cid:54) f (n) (cid:54) c · g(n), ∀n (cid:62) n0},

f = O(g) signi(cid:28)ca que f (n) ∈ O(g(n)).

Figura 2.4.1: f = O(g)

Tal nota(cid:231)ªo Ø utilizada para comparar algoritmos e Ø considerada como uma cota
superior para o nœmero de passos requeridos, signi(cid:28)cando que o custo do algoritmo nªo
ultrapassa O(g(n)), para entradas su(cid:28)cientemente grandes. Mas a cota superior de um
algoritmo pode mudar se alguØm descobrir um outro algoritmo melhor, como aconteceu

19

no caso do cÆlculo do valor de xn, x (cid:54)= 0. Antes, com o algoritmo exponencia(cid:231)ªo, o custo
nªo ultrapassava a cota superior O(n), agora com o exponencia(cid:231)ªo rÆpida este custo nªo
ultrapassa a cota superior O (log2n). Ou seja, a cota superior do problema do cÆlculo de xn
passou a ser O (log2n).

A cota superior para o custo de um problema Ø anÆloga ao record mundial de uma
modalidade de atletismo. Ele Ø estabelecido pelo melhor atleta (algoritmo) do momento.
Assim como o record mundial, a cota superior pode ser melhorada por um algoritmo (atleta)
mais veloz, [19].

Exemplo 25. Seja f (n) = adnd + ad−1nd−1 + ... + a1n + a0, d ∈ N, ai uma constante real,
∀i ∈ {0, 1, 2, ..., d}. Entªo, f (n) = O(nd).

Tem-se:

f (n) = adnd + an−1nd−1 + ... + a1n + a0 (cid:54)

(cid:54) |ad|nd + |an−1|nd−1 + ... + |a1|n + |a0| (cid:54)

(cid:54) |ad|nd + |an−1|nd + ... + |a1|nd + |a0|nd =

= (|ad| + |ad−1| + ... + |a0|
(cid:125)

(cid:124)

(cid:123)(cid:122)
>0

)nd = cnd

Portanto, f (n) = O(nd).

Observa(cid:231)ªo 2. |ad| signi(cid:28)ca m(cid:243)dulo ou valor absoluto de ad.

Assim, O(n2 + 2n − 1) = O(n2) e O(5n4 − 3n2 + n + 2) = O(n4).

Lema 1. Se r for um nœmero inteiro maior do que 5, entªo 2r > (r + 1)2.

Demonstra(cid:231)ªo:

Tal lema serÆ provado por indu(cid:231)ªo (cid:28)nita sobre r.
Observe que o lema serÆ falso para r = 1, 2, 3, 4, 5, na tabela abaixo.

r
1
2
3

2r
2
4
8

(r + 1)†
4
9
16

r
4
5
6

2r
16
32
64

(r + 1)†
25
36
49

Tem-se que P (6) Ø verdadeira.
Supondo que P (r) seja verdadeira para algum r (cid:62) 6, serÆ provado que P (r + 1)

tambØm Ø verdadeira, ou seja, que 2r+1 > (r + 2)2. Tem-se que

2 . 2r
2(r + 1)2
2r2 + 4r + 2

2r+1 =
>
=
= r2 + 4r + 4 + (r2 − 2)
=

(r + 2)2 + (r2 − 2)

(hip(cid:243)tese de indu(cid:231)ªo)

(1)

20

Como r (cid:62) 6, obtØm-se r2 − 2 > 0 (2).
De (1) e (2), segue que:

2r+1 > (r + 2)2 + (r2 − 2) > (r + 2)2.

Logo, 2r+1 > (r + 2)2, isto Ø, P (r + 1) Ø verdadeira.

Exemplo 26. log2n = O(

√

n).

De fato, suponha que k seja o maior inteiro tal que 2k (cid:54) n, ou seja, k = (cid:98)log2n(cid:99).

Tem-se:

2k+1 > n (cid:62) 2k ⇔ 2k+1 > n e n (cid:62) 2k ⇔

k + 1 > log2n e n (cid:62) 2k.

(1)

Seja n (cid:62) 64 = 26, tem-se, do Lema 1 e de (1), que:

k + 1 > log2n e n (cid:62) 2k > (k + 1)2,

k + 1 > log2n e

√

n > k + 1,

√

n > k + 1 > log2n,

√

n > log2n.

2.4.1 Propriedades da Nota(cid:231)ªo O

(i ) A nota(cid:231)ªo O Ø re(cid:29)exiva, ou seja, se f (n) Ø a fun(cid:231)ªo de custo entªo f (n) = O(f (n)).

(ii ) A nota(cid:231)ªo O Ø transitiva, ou seja, se f = O(g) e g = O(h) entªo f = O(h).

(iii ) Se f = O(g) entªo a.f = O(g), ∀a > 0.

(iv ) Se f = O(g1) e h = O(g2) entªo f + h = O(g1) + O(g2) = O (max{g1, g2}) e f.h =

O(g1) · O(g2) = O(g1.g2).

De fato,

(i ) f (n) (cid:54) 1 · f (n), ∀n (cid:62) 1.

(ii ) Sendo f = O(g) e g = O(h) entªo existirªo c1, c2 > 0 e n1, n2 ∈ N tais que:

f (n) (cid:54) c1g(n), ∀n (cid:62) n1 e g(n) (cid:54) c2h(n), ∀n (cid:62) n2

Tomando n0 = max{n1, n2}, tem-se:

f (n) (cid:54) c1g(n) (cid:54) c1c2h(n), ∀n (cid:62) n0.

21

(iii ) Existem c > 0 e n0 ∈ N tais que

f (n) (cid:54) cg(n), ∀n (cid:62) n0.

Como a > 0 entªo af (n) (cid:54) (ac)g(n), ∀n (cid:62) n0.

(iv ) Seja g = max{g1, g2}. Entªo g(n) (cid:62) g1(n) e g(n) (cid:62) g2(n), para toda entrada n.

Por hip(cid:243)tese, existem c1, c2 > 0 e n1, n2 ∈ N tais que f (cid:54) c1 · g1, para todo n (cid:62) n1, e
f (cid:54) c2 · g2, para todo n (cid:62) n2. Tomando n0 = max{n1, n2}, tem-se

f + g (cid:54) c1 · g1 + c2 · g2 (cid:54) c1 · g + c2 · g = (c1 + c2)g, para todo n (cid:62) n0.

Retomando a hip(cid:243)tese, tem-se:

0 (cid:54) f (n) (cid:54) c1g1(n) e 0 (cid:54) h(n) (cid:54) c2g2(n) ⇒ f (n).h(n) (cid:54) c1c2g1(n).g2(n) ⇒

f.h(n) (cid:54) c1c2(g1.g2)(n), (c1c2 > 0).

Portanto, f.h = O(g1.g2).

Observe que a nota(cid:231)ªo O nªo Ø simØtrica. De fato, n = O(n2) e n2 (cid:54)= O(n).

(cid:4)

Exemplo 27. Suponha que f (n) = log2n .
log2n = O(

n), tem-se:

√

√

n3. Entªo, f (n) = (log2n) · (n ·

√

n). Como

f (n) = O(

√

n) · O(n ·

√

√

n) = O(

√

n · n ·

n) = O(n2).

Proposi(cid:231)ªo 3. Para todo p ∈ N tem-se que:

1p + 2p + 3p + ... + np =

n
(cid:80)
kp Ø um polin(cid:244)mio de grau p + 1 em n.
k=1

Demonstra(cid:231)ªo:

Por indu(cid:231)ªo (cid:28)nita sobre p, tem-se:
Para p = 1, tem-se 1 + 2 + ... + n = n(n+1)
, que Ø um polin(cid:244)mio de grau 2 em n.
2
Suponha a a(cid:28)rma(cid:231)ªo verdadeira para todo p, 1 (cid:54) p (cid:54) s. SerÆ provado que Ø

vÆlida tambØm para s + 1.

Usando o Bin(cid:244)mio de Newton, tem-se que:

(k + 1)s+2 = ks+2 +

(cid:19)

(cid:18) s + 2
1

ks+1 +

(cid:19)

(cid:18) s + 2
2

ks + ... +

(cid:19)

(cid:18) s + 2
s + 1

k + 1.

Fazendo k variar de 1 atØ n e somando as equa(cid:231)ıes obtidas, obtØm-se:

n
(cid:80)
k=1

(k + 1)s+2 =

n
(cid:80)
k=1

ks+2 +

(cid:19)

(cid:18) s + 2
1

n
(cid:80)
k=1

ks+1 +

(cid:18) s + 2
2

(cid:19) n
(cid:80)
k=1

ks + ... +

(cid:18) s + 2
s + 1

(cid:19) n
(cid:80)
k=1

k + n.

22

Usando a hip(cid:243)tese de indu(cid:231)ªo obtØm-se:

n
(cid:80)
k=1

(k + 1)s+2 =

n
(cid:80)
k=1

ks+2 +

n
(cid:80)
k=1

(s + 2)ks+1 + F (n),

sendo F (n) um polin(cid:244)mio de grau s + 1 em n.

Como

n
(cid:80)
k=1

(k + 1)s+2 =

n+1
(cid:80)
k=2

ks+2, obtØm-se:

n+1
(cid:80)
k=2

ks+2 =

n
(cid:80)
k=1

ks+2 +

n
(cid:80)
k=1

(s + 2)ks+1 + F (n) e simpli(cid:28)cando,

(n + 1)s+2 = 1 + (s + 2)

n
(cid:80)
k=1

ks+1 + F (n), implicando em

n
(cid:80)
k=1

ks+1 = (n+1)s+2−F (n)−1

,

s+2

que Ø um polin(cid:244)mio de grau s + 2 em n.

CorolÆrio 2. Se F Ø um polin(cid:244)mio de grau p, entªo
em n.

n
(cid:80)
k=1

F (k) Ø um polin(cid:244)mio de grau p + 1,

Demonstra(cid:231)ªo:

Seja F (x) = a0 + a1x + ... + apxp, com ap (cid:54)= 0. Tem-se que:

n
(cid:80)
k=1

F (k) =

n
(cid:80)
k=1

a0 + a1k + ... + apkp =

n
(cid:80)
k=1

a0 + a1

n
(cid:80)
k=1

k + ... + ap

n
(cid:80)
k=1

kp,

que Ø um polin(cid:244)mio de grau p + 1 em n.

23

Cap(cid:237)tulo 3

Algoritmos na MatemÆtica BÆsica

Agora que jÆ se sabe o que Ø um algoritmo e como obter o seu custo, serªo
estudados alguns algoritmos da matemÆtica bÆsica e, para alguns deles, serÆ efetuada a
anÆlise de custo.

3.1 Divisªo Euclidiana

Teorema 2. (Divisªo Euclidiana)

Se a, b ∈ N, com b > 0, entªo existem dois œnicos naturais q e r tais que

a = b · q + r, com 0 (cid:54) r < b.

Demonstra(cid:231)ªo:

ExistŒncia:
Se a < b, existem q = 0 e r = a nas condi(cid:231)ıes exigidas, assim pode-se assumir

que a (cid:62) b > 0.

Considere o conjunto S = {a − by | y ∈ N} ∩ {N ∪ {0}}.
Como a − b (cid:62) 0, tem-se que a − b ∈ S, logo o conjunto S Ø nªo vazio. Como
S Ø limitado inferiormente, tem-se que S possui um menor elemento r = a − bq (cid:62) 0. SerÆ
mostrado que r < b.

Suponha por absurdo que r (cid:62) b. Segue que r = s + b com s ∈ N ∪ {0}, logo
s = r=b = a=bq=b = a=(q + 1)b ∈ S. Como r Ø o menor elemento de S, chega-se a uma
contradi(cid:231)ªo, jÆ que r = s + b ⇒ s < r e s ∈ S.

Unicidade:
Suponha a = bq + r = bq(cid:48) + r(cid:48), sendo 0 (cid:54) r e r(cid:48) < b. Sem perda de generalidade,
suponha r (cid:54) r(cid:48) . Da(cid:237) tem-se que 0 (cid:54) b(q=q(cid:48)) = r(cid:48)=r < b, o que s(cid:243) Ø poss(cid:237)vel se q = q(cid:48) e
consequentemente r = r(cid:48).

Nas condi(cid:231)ıes do Teorema os nœmeros q e r sªo chamados, respectivamente, de

quociente e resto da divisªo de a por b.

O tipo de demonstra(cid:231)ªo do Teorema da Divisªo Euclidiana Ø chamada de demons-
tra(cid:231)ªo algor(cid:237)tmica porque a prova da existŒncia fornece uma receita para o cÆlculo do resto
e do quociente da divisªo de a por b.

24

Exemplo 28. Determina(cid:231)ªo de q e r da divisªo de 17 por 3, usando o procedimento da
demonstra(cid:231)ªo do Teorema.

Tem-se que S = {17=3•1, 17=3•2, 17=3•3, 17=3•4, 17=3•5} = {14, 11, 8, 5, 2},

portanto r = 2 e q = 5.

Pode-se assim escrever um algoritmo para calcular o quociente e o resto da divisªo

de a por b.

Algoritmo da Divisªo

(cid:7) Entrada: Nœmeros naturais a e b.
(cid:7) Sa(cid:237)da: Nœmeros naturais q e r tais que a = bq + r, com 0 (cid:54) r < b.
(cid:7) Passo 1: Comece fazendo Q = 0 e R = a.
(cid:7) Passo 2: Se R < b retorne a frase (cid:16)O quociente Ø Q e o resto Ø R(cid:17) e pare. Caso contrÆrio,

vÆ para o passo 3.

(cid:7) Passo 3: Se R (cid:62) b fa(cid:231)a R
(cid:124)(cid:123)(cid:122)(cid:125)
Novo R

(cid:124)(cid:123)(cid:122)(cid:125)
Velho R

= R

− b, incremente Q de 1 e volte para o passo 2.

Ao (cid:28)nal da execu(cid:231)ªo do algoritmo, Q vai ser o quociente e R o valor do resto.
Para determinar estes valores deve-se executar os passos 2 e 3 vÆrias vezes. Chama-

se isso de la(cid:231)o (loop). Ao (cid:28)nal de cada la(cid:231)o, as variÆveis Q e R terªo valores diferentes.

A mudan(cid:231)a de valor Ø efetuada no passo 3. A instru(cid:231)ªo:

(cid:16)subtraia b de R(cid:17)
signi(cid:28)ca: (cid:224) variÆvel R serÆ atribuido um novo valor que corresponde ao valor que tinha no
(cid:28)nal do passo anterior, menos b. De modo anÆlogo, incremente Q de 1 signi(cid:28)ca: (cid:224) variÆvel
Q serÆ atribuido o valor que tinha no passo anterior, mais 1.

Por exemplo, se a > b, entªo passado uma vez pelo passo 3, obtØm-se Q = 1 e
R = a=b. Se a=b (cid:62) b entªo aplicando novamente o passo 3 tem-se Q = 2 e R = a=2b. E
assim por diante.

Observe que, aplicando o passo 3 vÆrias vezes serÆ gerada a seguinte sequŒncia de

valores para R:

a, a=b, a=2b, a=3b, a=4b · ··

Trata-se de uma sequŒncia decrescente de nœmeros naturais. Como existe apenas
um nœmero (cid:28)nito de naturais entre a e 0, a sequŒncia vai chegar a um valor menor do que
b. Neste momento, o algoritmo para de modo a ter os valores procurados. De fato, se r e
q sªo obtidos pelo algoritmo entªo tem-se r = a=bq e r < b. Assim, a = bq + r e r < b,
faltando provar que r (cid:62) 0. Como o la(cid:231)o parou quando r = a=bq, no passo anterior tem-se
a=(q=1)b (cid:62) b. Subtraindo b desta œltima desigualdade obtØm-se a=qb (cid:62) 0. Portanto o
algoritmo estÆ correto.

(cid:201) fÆcil perceber que o algoritmo apresentado Ø lento. O nœmero de la(cid:231)os executa-
dos Ø igual ao quociente. Por exemplo, ao ser dividido bk+1 por b, o passo 3 serÆ executado
bk vezes e o crescimento serÆ exponencial.
Observa(cid:231)ªo 3. Certamente ao se dividir a = 5712 por b = 75, usando lÆpis e papel, usa-se
outro mØtodo: em primeiro lugar escolhe-se o menor nœmero formado pelos algarismos 5712,
come(cid:231)ando pela esquerda, que Ø maior do que ou igual a 75, no caso 571. Em seguida, Ø
dividido 571 por 75, encontrando o quociente 7 e o resto 46 e depois Ø dividido 462 por 75,

25

obtendo o quociente 6 e resto 12. O resultado (cid:28)nal serÆ q = 76 e r = 12. Ao dividir 571 por
75, uma pergunta Ø feita: Qual o maior nœmero que pode ser multiplicado por 75 e ainda
assim obter um produto menor do que ou igual a 571? Se os nœmeros sªo pequenos, o valor
correto Ø obtido rapidamente. Se os nœmeros sªo grandes, a quantidade de possibidades pode
tornar imposs(cid:237)vel resolver o problema.

O processo da divisªo Ø feito por passos, cada um consistindo na divisªo de um
v < 10. Depois de cada passo

nœmero u = u0u1...un por outro nœmero v = v1v2...vn, tal que u
usa-se a quantidade 10r + (a outra parte do dividendo) como sendo o novo u.

5

7
4

1
6
1

2
2
2

7
7

5
6

A seguir serÆ estudado um algoritmo que resolverÆ este problema. Trabalha-se
usando o sistema decimal, mas poderia ser feito de modo inteiramente anÆlogo num sistema
qualquer de base b > 1.

Considere dois nœmeros escritos na base decimal, u, com n + 1 posi(cid:231)ıes, e v, com

n algarismos, tais que u < 10v, sendo

u = u0u1...un = u0 · 10n + u1 · 10n−1 + · · · + un e

v = v1v2 · · · vn = v1 · 10n=1 + v2 · 10n=2 + · · · + vn.

A condi(cid:231)ªo u < 10v signi(cid:28)ca que a parte inteira de u

v , representada por (cid:4) u

v

(cid:5) Ø

menor do que 10, ou ainda que

u0u1...un=1 < v1v2...vn.

Quando se dividiu 5712 por 75, a primeira etapa foi a divisªo de 571 por 75. Neste

caso u = 571, v = 75 e (cid:4) 571

(cid:5) < 10.

75

Se u = v · q + r, com 0 (cid:54) r < v, entªo deseja-se determinar q = (cid:4) u

(cid:5) , o quociente
da divisªo euclidiana de u por v. Uma aproxima(cid:231)ªo do valor de q serÆ determinada pelos
algarismos u0 e u1, de u, e do algarismo v1, de v.

v

Proposi(cid:231)ªo 4. Sejam u = u0u1...un e v = v1v2...vn tais que u < 10v. Se q Ø o quociente da
(cid:17)
divisªo de u por v e (cid:101)q := min

, entªo (cid:101)q (cid:62) q.

(cid:16)(cid:106) u0·10+u1
v1

, 9

(cid:107)

Demonstra(cid:231)ªo:

Como q (cid:54) 9, a proposi(cid:231)ªo Ø verdadeira quando (cid:101)q = 9.
(cid:16)(cid:106) u0·10+u1
Suponha que ˜q = min
v1

. Segue que ˜q > u0·10+u1

, 9

(cid:17)

(cid:107)

v1

− 1, e da(cid:237)

(cid:101)q · v1 > u0 · 10 + u1 − v1.

Como os algarismos sªo nœmeros inteiros, conclui-se que

(cid:101)q · v1 (cid:62) u0 · 10 + u1 − v1 + 1.

26

Calculando u − (cid:101)qv e usando a desigualdade anterior, tem-se que
u − (cid:101)qv = u0 · 10n + u1 · 10n−1 + ... + un − (cid:101)q(v1 · 10n−1 + v2 · 10n−2 + ... + vn)
u − (cid:101)qv (cid:54) u0 · 10n + u1 · 10n−1 + ... + un − (cid:101)q(v1 · 10n−1)
u − (cid:101)qv (cid:54) u0 · 10n + u1 · 10n−1 + ... + un − (u0 · 10 + u1 − v1 + 1)10n−1,
sendo u0 · 10n + u1 · 10n−1 + ... + un − (u0 · 10 + u1 − v1 + 1)10n−1 = u2 · 10n−2 + ... + un −
10n−1 + v1 · 10n−1.

Portanto, u − (cid:101)qv (cid:54) u2 · 10n−2 + ... + un − 10n−1 + v1 · 10n−1 < v1 · 10n−1 (cid:54) v.
Obteve-se u − (cid:101)qv < v. Portanto, (cid:101)q (cid:62) q.

Proposi(cid:231)ªo 5. Sejam u = u0u1...un e v = v1v2...vn tais que u < 10v, q o quociente da
(cid:17)
divisªo de u por v e (cid:101)q := min

. Se v1 (cid:62) 5 entªo q = (cid:101)q, (cid:101)q − 1 ou (cid:101)q − 2.

(cid:16)(cid:106) u0·10+u1
v1

, 9

(cid:107)

Demostra(cid:231)ªo:

Suponha q (cid:54)
(cid:101)q − 3.
= u0·10n+u1·10n−1
Tem-se entªo que (cid:101)q (cid:54) u0·10+u1
v1·10n−1
O caso v = 10n−1 implica u = u0 · 10n + u1 · 10n−1 + ... + un (cid:62) 10n = 10 · v, o que

u
v1·10n−1 .

(cid:54)

v1

nªo Ø poss(cid:237)vel.

Segue que v − 10n−1 = v1 · 10n−1 + v2 · 10n−2 + ... + vn − 10n−1 < v1 · 10n−1 e assim

Tem-se que q + 1 = (cid:4) u
Dessa forma,

v

v1·10n−1 <

u
v−10n−1 .

u

(cid:101)q (cid:54)
(cid:5) + 1 > u

v e (cid:101)q − 3 (cid:62) q > u

v − 1.

3 (cid:54)

(cid:101)q − q < (cid:101)q + 1 − u

v <

u

v−10n−1 + 1 − u

v =

=

u·v

v·(v−10n−1) + 1 − u

v = u

v

(cid:16) 10n−1
v−10n−1

(cid:17)

+ 1.

Da(cid:237), observando que v−10n−1
10n−1

(cid:62) v1 − 1, tem-se:

(cid:62) 2 ·

u
v

(cid:16) v−10n−1
10n−1

(cid:17)

(cid:62) 2(v1 − 1).

Finalmente,

6 (cid:62)

(cid:101)q − 3 (cid:62) q = (cid:4) u

v

(cid:5) (cid:62) 2(v1 − 1) = 2v1 − 2

e assim obtØm-se v1 (cid:54) 4.

Conclui-se portanto que se v1 (cid:62) 5 entªo q (cid:62)

(cid:101)q − 2.

Observa(cid:231)ªo 4. A condi(cid:231)ªo v1 (cid:62) 5 nªo serÆ uma restri(cid:231)ªo para se obter o quociente, porque se
forem multiplicados u e v por um mesmo inteiro positivo, o quociente permanece o mesmo:

u = vq + r, 0 (cid:54) r < v ⇔ ku = (kv) · q + kr, 0 (cid:54) kr < kv.

27

e v por

(cid:106) 10
v1+1

(cid:107)

.

Um modo de se obter v1, su(cid:28)cientemente grande, Ø fazendo a multiplica(cid:231)ªo de u

De fato, como 1 (cid:54) v1 < 10 serÆ mostrado que v1 ·

(cid:107)

(cid:106) 10
v1+1

, com (v1 +1)·

(cid:54) (v1 +1)· 10

v1+1 = 10.

(cid:107)

(cid:106) 10
v1+1

(cid:106) 10
v1+1

(cid:62) 5.
(cid:107)

(cid:107)

(cid:106) 10
v1+1

(cid:107)

(cid:106) 10
v1+1

< (v1 +1)·

(cid:62) v1 (cid:62) 5.

Tem-se que v1 ·
Se v1 (cid:62) 5 entªo v1
Suponha agora que 1 (cid:54) v1 < 5.
(cid:106) 10
(cid:17)
Tem-se que v1
v1+1 − 1
v1+1
(cid:62) 0, para 1 (cid:54) v1 (cid:54) 4, conclui-se que v1
(cid:107)

> v1

(cid:16) 10

(cid:107)

Portanto, v1

(cid:106) 10
v1+1

(cid:62) 5.

−v2

1+5v1−4
v1+1

. Observando que v1
(cid:17)
v1+1 − 1

(cid:106) 10
v1+1

(cid:16) 10

> v1

(cid:107)

(cid:16) 10

(cid:17)
v1+1 − 1

− 4 =

(cid:62) 4.

(cid:4)

Com base nos resultados apresentados acima, segue abaixo um outro algoritmo

da divisªo.

Algoritmo da Divisªo

(cid:7) Entrada: Nœmeros naturais u = u1u2...um+n e v = v1v2...vn, com n > 1.
(cid:7) Sa(cid:237)da: Nœmeros naturais q e r tais que u = vq + r, com 0 (cid:54) r < v.
(cid:7) Passo 1 (normaliza(cid:231)ªo): Comece fazendo d =
vamente. Os novos nœmeros serªo representados por u = u0u1u2...um+n e v = v1v2...vn.

e troque u e v por du e dv, respecti-

(cid:106) 10
v1+1

(cid:107)

Exemplo 29. u = 51247 e v = 32, sendo v1 = 3 e d = 2, a partir da(cid:237) u = 2 × 51247 = 102494
e v = 64.

Exemplo 30. u = 51247 e v = 61, sendo v1 = 6 e portanto d = 1, a partir da(cid:237) u =
1 × 51247 = 51247 e v = 1 × 61 = 61.

(cid:7) Passo 2: Inicie com j = 0.
Observa(cid:231)ªo 5. Este la(cid:231)o farÆ a divisªo de ujuj+1...uj+n por v1v2...vn, obtendo um quociente
qj. Come(cid:231)ando por j = 0, farÆ a divisªo de u0u1...un por v1v2...vn, obtendo quociente q0.
(cid:7) Passo 3: Se uj = v1 tome (cid:101)q = 9, caso contrÆrio, (cid:101)q =
. Em seguida, fa(cid:231)a o teste:
Se v2 · (cid:101)q > (uj · 10 + uj+1 − (cid:101)q · v1) · 10 + uj+2, diminua 1 de (cid:101)q, obtendo (cid:101)q − 1 como o novo (cid:101)q e
repita o teste

(cid:106) uj 10+uj+1
v1

(cid:107)

Observa(cid:231)ªo 6. O teste do passo 3 Ø baseado no seguinte fato:

Se v2 · (cid:101)q > (u0 · 10 + u1 − (cid:101)q · v1) · 10 + u2, entªo q < (cid:101)q.
De fato, na demostra(cid:231)ªo da Proposi(cid:231)ªo 4, repetindo os mesmos passos e trocando

−(cid:101)q(v1 · 10n−1) por −(cid:101)q(v2 · 10n−2) obtØm-se u − qv < 0. Portanto, (cid:101)q > q.
Exemplo 31. u = 631 e v = 67, (cid:101)q = 9 e depois do teste (cid:101)q = 9.

Exemplo 32. u = 631 e v = 54, (cid:101)q = (cid:4) 63

5

(cid:5) = 12 e depois do teste (cid:101)q = 11.

28

7

(cid:5) = 9 e depois do teste (cid:101)q = 9.

Exemplo 33. u = 631 e v = 72, (cid:101)q = (cid:4) 63
(cid:7) Passo 4: Troque ujuj+1...uj+n por (ujuj+1...uj+n) − (cid:101)q(v1v2...vn).
(cid:7) Passo 5: Fa(cid:231)a qj = (cid:101)q. Se o resultado do passo 4 for positivo vÆ para o passo 7, caso
contrÆrio vÆ para o passo 6.
(cid:7) Passo 6: Diminua 1 de (cid:101)q e adicione 0v1v2...vn (cid:224) ujuj+1...uj+n.
(cid:7) Passo 7: Acrescente 1 (cid:224) j. Se j (cid:54) n volte para o passo 3.
(cid:7) Passo 8: q = q0q1...qn Ø o quociente desejado e o resto r Ø obtido dividindo um+1...um+n
por d.

Exemplo 34. Efetuando o teste de mesa para u = 67121 e v = 46, tem-se:






r

E n
a
t
u1 u2 u3 u4 u5
1
1
6

7

2

d
|

a
v1 v2
6
4

−→






(cid:124)

(cid:107)

= 2

d =

N ormaliza¸c˜ao
(cid:106) 10
v1+1
u = d · u = 134242
v = d · v = 92
(cid:123)(cid:122)
P asso 1

(cid:125)

Passo 4

u 0 = j
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 2
1

u1

u2

u3

u4 u5

v1
9

v2
2

3

9

u1

4

4

2

u2

2

2

4

2

(cid:23)

1
(cid:22) 13
9

(cid:23)

4
(cid:22) 42
9

˜q =

˜q =

(cid:124)

(cid:125)

(cid:123)(cid:122)
P asso 3
= 1 = q0
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 5

(cid:124)

(cid:125)

(cid:123)(cid:122)
P asso 3
= 4 = q1
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 5

-

0 <
(cid:124)(cid:123)(cid:122)(cid:125)
P asso 5

u0

0

-

0 <
(cid:124)(cid:123)(cid:122)(cid:125)
P asso 5

Passo 4

u 1 = j
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 7
4
3
u1
0

u2

u3

2
6
u2
5

2
8
u3
4

Teste (P3)

v2 · (cid:101)q > (uj · 10 + uj+1 − (cid:101)q · v1) · 10 + uj+2
2 · 1 ≯ (13 − 1 · 9) · 10 + 4 = 44
2 · 4 ≯ (42 − 4 · 9) · 10 + 2 = 62

(cid:23)

9
(cid:22) 84
9

˜q =

(cid:124)

(cid:125)

(cid:123)(cid:122)
P asso 3
= 9 = q1
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 5

5
(cid:22) 54
9

˜q =

(cid:124)

(cid:123)(cid:122)
P asso 3
= 6

(cid:23)

(cid:125)

(cid:101)q = 5 =

q2
(cid:124)(cid:123)(cid:122)(cid:125)
P asso 5

29

2 · 6 > (54 − 6 · 9) · 10 + 4 = 4
2 · 5 ≯ (54 − 5 · 9) · 10 + 4 = 94

2 · 9 ≯ (84 − 9 · 9) · 10 + 2 = 32

-

0 <
(cid:124)(cid:123)(cid:122)(cid:125)
P asso 5

Passo 4

u 2 = j
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 7
5
4
u2
0

u3

4
6
u3
8

Passo 4
u 3 = j
(cid:124) (cid:123)(cid:122) (cid:125)
P asso 7
8
8
u3
0

j = 4 > m
(cid:123)(cid:122)
(cid:125)
(cid:124)
P asso 7

-

0 <
(cid:124)(cid:123)(cid:122)(cid:125)
P asso 5

u4

4
0
u4
4

u4

u5

4
2
u4
1

2
8
u5
4

(cid:40)

p8

q = q0q1q2q3 = 1459
r = um+1...um+n

= u4u5

d

2 = 14

2 = 7

3.2 MÆximo Divisor Comum de Dois Nœmeros Naturais

Lema 2. Se a = bq + r, entªo (a, b) = (b, r) (Lema de Euclides).

Observa(cid:231)ªo 7. O mÆximo divisor comum de dois nœmeros naturais a e de b Ø denotado por
(a, b). O leitor interessado em mais detalhes sobre este lema poderÆ ver [6] e [15].

O Algoritmo de Euclides consiste na aplica(cid:231)ªo reiterada do lema 2, no qual q
e r sªo respectivamente o quociente e o resto na divisªo euclidiana de a por b, para se
obter (a, b), supondo, sem perda de generalidade, que b (cid:54) a. A tabela abaixo faz essa
aplica(cid:231)ªo, mostrando que tal algoritmo Ø uma sequŒncia (cid:28)nita de instru(cid:231)ıes, bem de(cid:28)nidas,
para produzir corretamente o valor de (a, b), o mÆximo divisor comum de a e b.

Algoritmo de Euclides

Divisªo Euclidiana

SequŒncia de restos obtida

a = bq0 + r0

b = r0q1 + r1

r0 = r1q2 + r2
...
rn−1 = rnqn+1 + rn+1
(cid:124) (cid:123)(cid:122) (cid:125)
=0

0 (cid:54) r0 < b
0 (cid:54) r1 < r0 < b
0 (cid:54) r2 < r1 < r0 < b
...
0 (cid:54) rn < ... < r2 < r1 < r0 < b

Lema de Euclides

(a, b) = (b, r0)

(a, b) = (b, r0) = (r0, r1)

(a, b) = (b, r0) = (r0, r1) = (r1, r2)
...

(a, b) = (b, r0) = (r0, r1) = (r1, r2) = ... = (rn, rn+1
(cid:124) (cid:123)(cid:122) (cid:125)
=0

) = rn

Como os restos obtidos na segunda coluna da tabela acima formam uma sequŒncia
de nœmeros naturais, estritamente decrescente, existirÆ n ∈ N tal que rn+1 = 0 e assim
mdc(rn, rn+1) = mdc(rn, 0) = rn.

30

As divisıes sucessivas do algoritmo euclidiano costumam ser representadas do

seguinte modo:

q0
b
r2

q1
r1
r3

q2
r2
r4

· · ·
· · ·
· · ·

qn−2
rn−2
rn

qn−1
rn−1
0

a
r1

qn
rn

Exemplo 35. Calculando o mdc(1001, 109), usando o algoritmo de Euclides, tem-se:

9
109
9

5
20
2

2
9
1

4
2
0

2
1

1001
20

Portanto, (1001, 109) = 1.

(cid:4)

Retorne: (cid:16)(a, b) = 1.(cid:17)
Pare.

Algoritmo de Euclides (MDC)
1 Entrada: a e b.
2 Se a = 1 entªo
3
4
5 SenªoSe b = 1 entªo
6
7
8 FimSe
9 Se a (cid:54) b entªo
10
11 Senªo
12
13 FimSe

Retorne: (cid:16)(a, b) = 1.”
Pare.

x := a

x := b

b

(cid:5)

14 m := a
15 n := b
16 q := (cid:4) a
17 r := a − b · q
18 a := b
19 b := r
20 Enquanto r (cid:54)= 0 fa(cid:231)a
x := r
21
q := (cid:4) a
22
b
r := a − b · q
23
a := b
24
b := r
25
26 FimEnquanto
27 Retorne: (cid:16)(m, n) = x.(cid:17)

(cid:5)

No algoritmo de Euclides, a quantidade de restos Ø tambØm a quantidade de
divisıes efetuadas. O pior caso desse algoritmo ocorrerÆ para um nœmero mÆximo de divisıes
efetuadas, o que equivale a dizer que o pior caso ocorrerÆ para o maior nœmero de restos
obtidos. Mas, para se obter o maior nœmero de restos poss(cid:237)vel, deve-se obter a sequŒncia
r0 > r1 > r2 > r3 > ... > rn−2 > rn−1 > rn = 0, para n + 1 divisıes efetuadas, na qual
ri = ri+1 + 1, ∀i ∈ {1, 2, ..., (n − 1)}. Isso implica dizer que rn−1 = 1 e qi =
= 1
sempre. Assim,

(cid:106) ri
ri+1

(cid:107)

r1 = r2 + 1
r0 = r1 + 1
a = b + r0

1

rn−1 =
rn−2 = rn−1 + 1
rn−3 = rn−2 + 1
rn−4 = rn−3 + 1
...
r2

...
= r3 + 1

...

31

Somando membro a membro as equa(cid:231)ıes acima, obtØm-se: a = n + b ⇔ n = a − b.
= r0 < b ⇒

Mas, pela divisªo euclidiana de a por b, sob hip(cid:243)tese de ter q = 1, tem-se: a − b
(cid:124) (cid:123)(cid:122) (cid:125)
n

a − b < b. Assim, n < b ⇒ n + 1 (cid:54) b. Pode-se entªo dizer que o nœmero total de divisıes
nªo ultrapassa o valor de b. Isso quer dizer que o algoritmo de Euclides Ø linear.

(cid:4)

O algoritmo de Euclides pode ser estendido de forma a calcular, alØm do mÆximo

divisor comum d, de dois inteiros a e b, tambØm inteiros x e y tais que

ax + by = d.

A ideia Ø expressar cada resto ri, obtido no cÆlculo do (a, b), em fun(cid:231)ªo de a e b.
Por exemplo, para a = bq0 + r0, obtØm-se r0 = a · (1) + b · (−q0). Para b = r0q1 + r1, obtØm-se

r1 = b − r0q1 = b − (a − b · q0)q1 = a(−q1) + b(1 + q0q1)

e assim por diante, atØ chegar (cid:224) expressªo de d como combina(cid:231)ªo linear de a e b.

Escreve-se todas as divisıes efetuadas no cÆlculo do mdc(a, b) e ao lado de cada

equa(cid:231)ªo Ø colocada a expressªo dos restos, sendo xi e yi os inteiros procurados.

a
b
r0
r1

=
=
=
=
...

bq0 + r0
r0q1 + r1
r1q2 + r2
r2q3 + r3

rn−3 = rn−2qn−1 + rn−1
rn−2 =

rn−1qn + rn

e
e
e
e
...
e
e

r0
r1
r2
r3

=
=
=
=
...

ax0 + by0
ax1 + by1
ax2 + by2
ax3 + by3

rn−1 = axn−1 + byn−1
rn =

axn + byn

Agora as informa(cid:231)ıes sªo colocadas numa tabela, na qual as duas œltimas colunas
sªo as inc(cid:243)gnitas a determinar, observando que a = 1 · a + 0 · b, b = 0 · a + 1 · b e que x0 = 1,
y0 = −q0, x1 = −q1 e y1 = 1 + q0q1.

Restos Quocientes

a
b
r0
r1
...
rn−1
rn = d

*
*
q0
q1
...
qn−1
qn

x
1
0
x0
x1
...
xn−1
xn

y
0
1
y0
y1
...
yn−1
yn

As quatro primeiras linhas da tabela acima sªo conhecidas, assim Ø preciso preen-

cher a tabela e no (cid:28)nal surgirªo os valores procurados xn e yn.

Tomando trŒs linhas quaisquer da tabela, supondo que as duas primeiras sejam

conhecidas, para ser determinada a terceira, tem-se:

32

Restos Quocientes

rj−2
rj−1
rj

qj−2
qj−1
qj

x
xj−2
xj−1
xj

y
yj−2
yj−1
yj

na qual se sabe que rj = rj−2 − rj−1qj, rj−2 = xj−2a + yj−2b e rj−1 = xj−1a + yj−1b. Segue
da(cid:237) que

rj = xj−2a + yj−2b − (xj−1a + yj−1b)qj, obtendo

rj = (xj−2 − xj−1qj)a + (yj−2 − yj−1qj)b.

Portanto, a partir das duas primeiras linhas sabe-se preencher a tabela toda.

Exemplo 36. Considerando a = 1234 e b = 54, serªo determinados x e y tais que mdc(a, b) =
ax + by.

Restos Quocientes
1234
54
46
8
6
2

*
*
22
1
5
1

x
1
0
1
-1
6
-7

y
0
1
-22
23
-137
160

Portanto, mdc(1234, 54) = 2 = 1234 · (−7) + 54 · (160).

(cid:4)

Segue abaixo o algoritmo estendido de Euclides.

Algoritmo Euclidiano Estendido
Entrada: a e b, nªo simultaneamente
nulos, a (cid:62) b (cid:62) 0.
Sa(cid:237)da: mdc(a, b) = d, x e y tais que
ax + by = d.
i1: Se b = 0 entªo,

i2: d assume o valor de a.
i3: x assume valor 1.
i4: y assume valor 0.
i5: Retorne d, x e y.
i6 : Pare.

FimSe
i7: r1 assume o valor de a.
i8: r2 assume o valor de b.
i9: x1 assume valor 1.
i10: x2 assume valor 0.
i11: y1 assume valor 0.
i12: y2 assume valor 1.

i13: Se r2 > 0 entªo

.

(cid:107)

(cid:106) r1
i14: q assume o valor de
r2
i15: r assume o valor de r1.
i16: x assume o valor de x1.
i17: y assume o valor de y1.
i18: r1 assume o valor de r2.
i19: x1 assume o valor de x2.
i20: y1 assume o valor de y2.
i21: r2 assume o valor de r − r2q.
i22: x2 assume o valor de x − x2q.
i23: y2 assume o valor de y − y2q.
i24: VÆ para o passo 13.

FimSe
i25: d assume o valor de r1.
i26: x assume o valor de x1.
i27: y assume o valor de y1.
i28: Retorne d, x e y.
i29: Pare.

33

Por efetuar a mesma quantidade de divisıes produzidas pelo algoritmo de Eucli-

des, esse algoritmo estendido tambØm serÆ linear.

3.3 Divisªo de Polin(cid:244)mios

3.3.1 Dispositivo PrÆtico de Briot-Ru(cid:30)ni

Nesta se(cid:231)ªo, trabalha-se com divisªo de polin(cid:244)mios, sendo o divisor na forma
g(x) = x=a. Lembrando que dado um polin(cid:244)mio nªo nulo g(x) = b0 + b1x + ... + bmxm , com
bm (cid:54)= 0, denomina-se m o grau do polin(cid:244)mio e denota-se m = δg(x).

O algoritmo da divisªo euclidiana pode ser estendido para a divisªo de polin(cid:244)mios.

Teorema 3. Dados dois polin(cid:244)mios com coe(cid:28)cientes reais f (x) = a0 + a1x + ... + anxn e
g(x) = b0 + b1x + ... + bmxm, sendo g(x) (cid:54)= 0, com bm (cid:54)= 0, existem dois polin(cid:244)mios q(x) e
r(x), unicamente determinados, tais que

f (x) = q(x)g(x) + r(x),

no qual r(x) = 0 ou δr(x) < δg(x), sendo δp(x) o grau do polin(cid:244)mio p(x).
Demonstra(cid:231)ªo:

ExistŒncia:
Se f (x) = 0 basta tomar q(x) = r(x) = 0. Suponha entªo f (x) (cid:54)= 0 e assim

pode-se assumir δf (x) = n.

grau de f (x), sendo n (cid:62) m.

Se n < m, basta tomar q(x) = 0 e r(x) = f (x) e assim pode-se assumir n (cid:62) m.
SerÆ demonstrada a a(cid:28)rma(cid:231)ªo por indu(cid:231)ªo completa (segunda forma) sobre n, o

Se n = 0 entªo m = 0, f (x) = a0 (cid:54)= 0, g(x) = b0 (cid:54)= 0 e tem-se que f (x) =

a0b

=1
0 g(x), bastando tomar q(x) = a0b

=1
0
Considere o polin(cid:244)mio f1(x) de(cid:28)nido por f (x) = anb

e r(x) = 0.

=1
m xn−mg(x) + f1(x). Observe

que δf1(x) < δf (x).

Tem-se que f1(x) = f (x)=anb−1

m xn−mg(x) e, pela hip(cid:243)tese de indu(cid:231)ªo, existem

q1(x), r1(x) tais que

f1(x) = q1(x)g(x) + r1(x),

no qual r1(x) = 0 ou δr1(x) < δg(x).
Da(cid:237), segue que

f (x) = (q1(x) + anb

=1
m xn−m)g(x) + r1(x),

tal que r1(x) = 0 ou δr1(x) < δg(x). Portanto, tomando q(x) = (q1(x) + anb
r(x) = r1(x) a a(cid:28)rma(cid:231)ªo serÆ vÆlida para n.

=1
m xn−m) e

Unicidade:
Suponha que f (x) = q1(x)g(x)+r1(x) = q2(x)g(x)+r2(x), nas condi(cid:231)ıes exigidas.

34

Dai, (q1(x)=q2(x))g(x) = r2(x)=r1(x). Mas se q1(x)=q2(x) (cid:54)= 0, o grau do po-
lin(cid:244)mio da esquerda, da igualdade anterior, Ø maior do que ou igual a δg(x), enquanto que
o grau do polin(cid:244)mio da direita r2(x)=r1(x) Ø menor do que δg(x), o que Ø um contradi(cid:231)ªo.
Portanto, q1(x) = q2(x) e r1(x) = r2(x).

(cid:4)

Dados dois polin(cid:244)mios p(x) = a0xn+a1xn−1+...+an−1x+an, a0 (cid:54)= 0, e g(x) = x−a,
deseja-se construir um algoritmo cuja sa(cid:237)da sejam os polin(cid:244)mios q(x) e r(x) do Teorema 3.
Considere q(x) = q0xn−1 + q1xn−2 + q2xn−3 + ... + qn−2x + qn−1. Assim,

q(x) · g(x) = q0xn + q1xn−1 + q2xn−2 + ... + qn−2x2 + qn−1x − aq0xn−1−

−aq1xn−2 − ... − aqn−3x2 − aqn−2x − aqn−1 = q0xn + (q1 − aq0)xn−1+

+(q2 − aq1)xn−2 + ... + (qn−1 − aqn−2)x − aqn−1.

Tem-se δ (r(x)) = 0 ⇔ r(x) = k ∈ R − {0} e tambØm:

p(x) = q(x) · g(x) + r(x) ⇔

a0xn + a1xn−1 + ... + an−1x + an =

= q0xn + (q1 − aq0)xn−1 + (q2 − aq1)xn−2 + ... + (qn−1 − aqn−2)x − aqn−1 + k ⇔

a0 = q0

a1 = q1 − aq0 ⇒ q1 = aq0 + a1

a2 = q2 − aq1 ⇒ q2 = aq1 + a2

...

an−1 = qn−1 − aqn−2 ⇒ qn−1 = aqn−2 + an−1

an = −aqn−1k = r(x) − aqn−1 ⇒ r(x) = aqn−1 + an

Os cÆlculos efetuados acima representam uma sequŒncia (cid:28)nita de instru(cid:231)ıes, bem
de(cid:28)nidas, para produzir o quociente e o resto da divisªo de p(x) por g(x). Tal sequŒn-
cia representa o chamado dispositivo prÆtico de Briot-Ru(cid:30)ni. Esquematicamente, pode-se
representar esse dispositivo da seguinte forma:

Exemplo 37. Aplicando o dispositivo prÆtico de Briot-Ru(cid:30)ni para a divisªo de p(x) =
2x4 − 7x2 + 3x − 1 por g(x) = x − 3, obtØm-se:

35

3

2
↓
2

0

−7

3

-1

2 · 3 + 0
(cid:124) (cid:123)(cid:122) (cid:125)
6

6 · 3 − 7
(cid:124) (cid:123)(cid:122) (cid:125)
11

11 · 3 + 3
(cid:125)
(cid:123)(cid:122)
(cid:124)
36

36 · 3 − 1
(cid:125)
(cid:123)(cid:122)
(cid:124)
107

Logo, q(x) = 2x3 + 6x2 + 11x + 36 e r(x) = 107.

(cid:4)

q(i − 1) = a · q(i − 2) + a(i − 1)

Algoritmo Divisªo de p(x) por g(x) = x − a
1 Entrada: δ (p(x)), os coe(cid:28)cientes de p(x), ai, i ∈ {0, 1, 2, ..., n} , e a.
2 q0 = a0
3 Para i = 2 atØ n + 1, fa(cid:231)a
4
5 FimPara
6 Retorne: (cid:16)q(x) Ø dado pela soma dos seguintes mon(cid:244)mios:(cid:17)
7 Para j = 0 atØ n − 1, fa(cid:231)a
q(j)x^(n − 1 − j)
8
9 FimPara
10 Retorne: (cid:16)r(x) = q(n).(cid:17)

As instru(cid:231)ıes das linhas 3, 4, 7 e 8 serªo executadas, cada uma, n vezes. Portanto,

o custo do algoritmo serÆ dado por f (n) = 4n + 3.

3.4 Nœmeros Primos

De(cid:28)ni(cid:231)ªo 4. Diz-se que um nœmero natural p Ø um nœmero primo se p (cid:54)= 1 e seus œnicos
divisores sªo 1 e p. Um nœmero natural n > 1 que nªo Ø primo Ø denominado composto.

Exemplo 38. O nœmero 13 Ø primo. De fato, os poss(cid:237)veis divisores de 13, diferentes de 1 e
13, sªo 2, 3, . . . , 11, 12 e nenhum deles divide o nœmero 13.

O Lema seguinte a(cid:28)rma que para veri(cid:28)car se 13 Ø primo basta observar que 2 e 3

nªo dividem o nœmero 13.

Lema 3. Se um natural n > 1 Ø composto entªo n admite um divisor primo menor do que
ou igual a

n.

√

Demonstra(cid:231)ªo:

Se n Ø composto entªo n possui um divisor a com 1 < a < n. Logo n = a · b,
sendo 1 < b < n. Sem perda de generalidade suponha a (cid:54) b. Segue que a · a (cid:54) a · b = n, isto
Ø, a2 (cid:54) n, logo a (cid:54)
n. Agora, um divisor de n Ø primo ou tem um divisor primo q. Nos
dois casos n possui um divisor primo menor do que ou igual a

n.

√

√

(cid:4)

O Lema 3 diz que um inteiro n > 1 Ø primo se n nªo Ø divis(cid:237)vel por nenhum primo

menor do que ou igual a

√

n.

Tal Lema Ø usado no algoritmo seguinte, cuja entrada Ø um nœmero natural n > 1

e a sa(cid:237)da diz se n Ø primo ou se n Ø composto.

36

√

Algoritmo Teste de Primalidade
1 Entrada: n (cid:62) 2, (n ∈ Z)
2 F := 2
3 Se F >
4
5
6 FimSe

Retorne: (cid:16)n Ø primo.(cid:17)
Pare.

n entªo

7 Se n
8
9
10 Senªo
11
12
13 FimSe

F ∈ Z entªo
Retorne: (cid:16)F Ø fator de n.(cid:17)
Pare.

F := F + 1
Volte a executar a partir da linha 3.

O lema 3 tambØm permite criar um algoritmo (Crivo de Erat(cid:243)stenes) para listar
todos os nœmeros primos atØ um certo inteiro n. Por exemplo, listar todos os primos inferiores
a 200.

Come(cid:231)a-se escrevendo todos os nœmeros de 2 atØ 200. Em seguida, risca-se todos

os inteiros compostos que (cid:28)guram nesta lista segundo o roteiro abaixo.

(cid:7) 2 Ø primo, risque todos os nœmeros pares maiores do que 2, pois nªo sªo primos.
(cid:7) Todos os nœmeros nªo riscados inferiores a 22 = 4 sªo primos. Neste caso, obtØm-se o

primo 3. Risque todos os mœltiplos de 3.

(cid:7) Todos os nœmeros nªo riscados inferiores a 32 = 9 sªo primos. Neste caso, obtØm-se os

primos 2, 3, 5 e 7. Risque todos os seus mœltiplos que ainda nªo foram riscados.

(cid:7) Todos os nœmeros nªo riscados inferiores a 72 = 49 sªo primos. Neste caso, obtØm-se os

primos 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43 e 47.

(cid:7) Como 472 > 200, todos os nœmeros nªo riscados na tabela sªo primos.

Conforme comentado acima, observa-se que alguns nœmeros sªo riscados mais
de uma vez. Riscar os mœltiplos de um primo p, signi(cid:28)ca riscar de p em p, isto Ø, riscar
2p = p + p, 3p = p + p + p, · · · . Como os mœltiplos de p, que tambØm sªo mœltiplos de primos
menores do que p, jÆ foram riscados da lista, pode-se come(cid:231)ar a riscar de p em p, a partir do
menor mœltiplo de p, que nªo Ø mœltiplo de um primo menor do que p, isto Ø, a partir de p2.
Assim pode-se riscar de p em p, a partir de p2, diminuindo um pouco o trabalho.

Como o œnico primo par Ø o 2, deseja-se agora escrever um algoritmo que liste os
primos (cid:237)mpares menores do que ou iguais a um nœmero (cid:237)mpar n, de modo que um programador
possa transcrever para uma linguagem de mÆquina.

A lista dos (cid:237)mpares corresponderÆ a um vetor. A cada entrada do vetor estªo
associados dois nœmeros: o valor com que a entrada foi preenchida e o (cid:237)ndice que determina
sua posi(cid:231)ªo no vetor.

Come(cid:231)a-se criando um vetor com n−1

2 posi(cid:231)ıes. Essa expressªo indica o nœmero
de (cid:237)mpares entre 3 e n. A entrada do (cid:237)ndice j do vetor corresponde ao j -Øsimo nœmero (cid:237)mpar
2j + 1. No in(cid:237)cio todas as entradas sªo preenchidas com o nœmero 1 e riscar um nœmero
2j + 1 signi(cid:28)ca substituir o 1 por zero na posi(cid:231)ªo j do vetor.

Crivo de Erat(cid:243)stenes

(cid:7) Entrada: Inteiro positivo (cid:237)mpar n.
(cid:7) Sa(cid:237)da: lista dos primos (cid:237)mpares menores do que ou iguais a n.
(cid:7) Passo 1: Comece criando um vetor v de (cid:0) n−1
2
preenchida com o nœmero 1 e tomando P = 3.

(cid:1) posi(cid:231)ıes, cada uma das quais deve estar

(cid:7) Passo 2: Se P 2 > n escreva os nœmeros 2j + 1, para os quais a j -Øsima entrada do vetor Ø

37

1 e pare. Senªo vÆ para o passo 3.

(cid:7) Passo 3: Se a posi(cid:231)ªo P −1

passo 2. Senªo vÆ para o passo 4.

2 do vetor estÆ preenchida com 0, incremente P de 2 e volte ao

(cid:7) Passo 4: Atribua o valor P 2 a uma nova variÆvel T . Substitua por 0 o valor na posi(cid:231)ªo
T −1
2 do vetor v e incremente T de 2P . Repita estas duas instru(cid:231)ıes atØ ocorrer T > n.
Depois incremente P de 2 e volte ao passo 2.

Observa(cid:231)ªo 8. Como T e P sªo (cid:237)mpares tem-se que T + P Ø par. Como estÆ sendo riscado
de P em P , o (cid:237)mpar a ser riscado em seguida a T serÆ T + 2P .

O vetor inicial usado no Crivo de Erat(cid:243)stenes ocuparÆ muita mem(cid:243)ria se o nœ-
mero inteiro n for muito grande. Por outro lado, as opera(cid:231)ıes envolvidas sªo simples e sua
programa(cid:231)ªo Ø muito fÆcil. Isto possibilita usar o crivo como um exemplo de algoritmo a ser
implementado no ensino bÆsico.

3.5 Multiplica(cid:231)ªo de Matrizes Quadradas

De(cid:28)ni(cid:231)ªo 5. Dadas as matrizes quadradas A = [aij]n×n e B = [bij]n×n, de(cid:28)ne-se o produto
C = A × B, C = [cij]n×n, por meio da seguinte expressªo

cij =

n
(cid:80)
k=1

aik · bkj, 1 (cid:54) i, j (cid:54) n.

Esse procedimento representa uma sequŒncia (cid:28)nita de instru(cid:231)ıes, bem de(cid:28)nidas,

para produzir corretamente o valor de cij. Logo, trata-se de um algoritmo (clÆssico).

Analisando o custo desse algoritmo, por meio da quantidade de adi(cid:231)ıes e multi-
plica(cid:231)ıes efetuadas, veri(cid:28)ca-se que, para a descoberta do nœmero de cada cij, do algoritmo na
de(cid:28)ni(cid:231)ªo acima, sªo realizadas n multiplica(cid:231)ıes e n − 1 adi(cid:231)ıes. Assim, para preencher a ma-
triz C, com todos os seus elementos cij, serªo realizadas, no total, n × n2 = n3 multiplica(cid:231)ıes
e (n − 1) × n2 = n3 − n2 adi(cid:231)ıes. Entªo, tal algoritmo possui custo igual a O(n3).

No caso de matrizes de ordem 2, utilizando o algoritmo da De(cid:28)ni(cid:231)ªo 5, obtØm-se,
na produ(cid:231)ªo de C, um total de n3 = 23 = 8 multiplica(cid:231)ıes, mas, em 1969, o matemÆtico
Volker Strassen descobriu outro algoritmo, efetuando 7 multiplica(cid:231)ıes, conforme o que segue.

Algoritmo de Strassen (A2, B2)
p1 := (a11 + a22) × (b11 + b22)
p2 := (a21 + a22) × b11
p3 := a11 × (b12 − b22)
p4 := a22 × (b21 − b11)
p5 := (a11 + a12) × b22
p6 := (a21 − a11) × (b11 + b12)

p7 := (a12 − a22) × (b21 + b22)
c11 := p1 + p4 − p5 + p7
c12 := p3 + p5
c21 := p2 + p4
c22 := p1 + p3 − p2 + p6
Retorne: C = [cij]2×2.

38

No algoritmo da De(cid:28)ni(cid:231)ªo 5 eram realizadas no total n3−n2 = 23−22 = 4 adi(cid:231)ıes.
O algoritmo de Strassen realiza um total de 18 adi(cid:231)ıes algØbricas. Houve aumento no nœmero
de adi(cid:231)ıes. SerÆ que isso compromete o algoritmo de Strassen ao ponto de ser menos e(cid:28)ciente
do que o algoritmo clÆssico? Em termos de multiplica(cid:231)ªo de matrizes quadradas de ordem 2
sim, pois seriam um total de 12 opera(cid:231)ıes, no algoritmo clÆssico, contra 25, no algoritmo de
Strassen. Acontece que o algoritmo de Strassen tambØm serÆ utilizado no produto de matrizes
quadradas de ordem superior a 2, como serÆ visto adiante. Neste caso, serÆ veri(cid:28)cado que,
para n su(cid:28)cientemente grande, o algoritmo de Strassen Ø mais e(cid:28)ciente do que o algoritmo
clÆssico.

Considere duas matrizes quadradas, A = [aij]n×n e B = [bij]n×n, n > 2. Suponha
que n = 2k, k > 1, para que seja poss(cid:237)vel dividir tanto A quanto B em quatro blocos,
representados por Aij e Bij, todos com mesmo tamanho, como abaixo:





A =

| A12
A11
− − −
| A22
A21





 e B =



| B12
B11
− − −
| B22
B21



.

Sabe-se, da `lgebra Linear, que o produto de A por B pode ser realizado por

blocos, ou seja,

C = A × B =





| C12
C11
− − −
| C22
C21



,

que tambØm Ø um algoritmo, no qual o bloco Cij Ø tal que Cij = Ai1 × B1j + Ai2 × B2j.

Exemplo 39. Dadas as matrizes A =







1 0
2 1
2 1 −1 0
0 1
2 0
1 0
0 3







e B =







0 1
2
0
1 2 −1
2
0
0
1 1
0 −2
2 0







, calcula-

se C = A × B pelo algoritmo logo acima, da seguinte forma:
(cid:21)
(cid:20) 2 0
0 3
(cid:20) 1 1
2 0

(cid:20) 2 1
−1 0
(cid:20) 2 0
−1 2

(cid:20) 1 0
2 1
(cid:20) 0 1
1 2

(cid:21)
, A21 =

, A21 =

, A12 =

, A12 =

B11 =

A11 =

(cid:21)

(cid:21)

(cid:21)

(cid:21)

e A22 =

e A22 =

(cid:20) 0 1
1 0

(cid:21)

.

(cid:20) 0

0
0 −2

(cid:21)

.

Assim,

C11 = A11 × B11 + A12 × B21 =

C12 = A11 × B12 + A12 × B22 =

C21 = A21 × B11 + A22 × B21 =

(cid:21)

(cid:21)
.

(cid:20) 4 3
0 3
(cid:20) 2 −2
2
3
(cid:21)
(cid:20) 2 2
.
4 7

.

C22 = A21 × B12 + A22 × B22 =

(cid:20)

4 −2
6

−3

(cid:21)
.

39

Portanto, C =

(cid:20) C11 C12
C21 C22

(cid:21)

=







4 3
0 3
2 2
4 7 −3

2 −2
3
2
4 −2
6




.



De(cid:28)ni(cid:231)ªo 6. Um algoritmo de divisªo e conquista, tambØm chamado de recursivo, Ø
aquele que desmembra o problema em vÆrios subproblemas (dividir) semelhantes ao problema
original, mas menores em tamanho, retomando-os (conquista) para obter as solu(cid:231)ıes deles,
recursivamente, combinando-as com o objetivo de criar uma solu(cid:231)ªo para o problema original.

Em matrizes quadradas de ordem n = 2k, k > 1, o algorimto de Strassen pode
ser aplicado recursivamente de modo a produzir blocos (submatrizes quadradas) de ordem 2,
para que depois sejam feitas as multiplica(cid:231)ıes utilizando o procedimento Prodmat2. Assim,
na primeira divisªo ocorrida, A e B possuirªo blocos que sªo matrizes quadradas de ordem
n
2 cada. Na segunda divisªo, A e B possuirªo submatrizes quadradas de ordem
4 . O
processo de divisªo ocorrerÆ atØ que todos os blocos de A como os de B possuam ordem 2,
para que seja iniciada a multiplica(cid:231)ªo da matrizes menores, para retornar a matriz C = A×B.
Trata-se portanto de um algoritmo de divisªo e conquista.

= n

n
2
2

Segue abaixo o algoritmo, chamado Prodmat, que utiliza o algoritmo de Strassen,

recursivamente.

Prodmat

(cid:7) Entrada: A ordem n = 2k das matrizes quadradas, A e B, bem como seus elementos.
(cid:7) Sa(cid:237)da: A matriz C = A × B.
(cid:7) Passo 1: Se n = 2 entªo aplique o procedimento Prodmat2 em A e B. Mas se n > 2 entªo

fa(cid:231)a m := n
2 .

(cid:7) Passo 2: Construa a matriz A11, com as linhas de 1 a m e colunas de 1 a m, de A.
(cid:7) Passo 3: Construa A12, com as linhas de 1 a m e colunas de m + 1 a n.
(cid:7) Passo 4: Construa A21, com as linhas de m + 1 a n e colunas de 1 a m.
(cid:7) Passo 5: Construa A22, com as linhas de m + 1 a n e colunas de m + 1 a n.
(cid:7) Passo 6: Construa B11, com as linhas de 1 a m e colunas de 1 a m, de B.
(cid:7) Passo 7: Construa B12, com as linhas de 1 a m e colunas de m + 1 a n.
(cid:7) Passo 8: Construa B21, com as linhas de m + 1 a n e colunas de 1 a m.
(cid:7) Passo 9: Construa B22, com as linhas de m + 1 a n e colunas de m + 1 a n.
(cid:7) Passo 10: Construa a matriz P1 aplicando o algoritmo de Strassen para obter o produto

das matrizes (A11 + A22) e (B11 + B22).

(cid:7) Passo 11: Construa P2 aplicando o algoritmo de Strassen para obter o produto das matrizes

(A21 + A22) e B11.

(cid:7) Passo 12: Construa P3 aplicando o algoritmo de Strassen para obter o produto das matrizes

A11 e (B12 − B22).

(cid:7) Passo 13: Construa P4 aplicando o algoritmo de Strassen para obter o produto das matrizes

A22 e (B21 − B11).

(cid:7) Passo 14: Construa P5 aplicando o algoritmo de Strassen para obter o produto das matrizes

(A11 + A12) e B22.

(cid:7) Passo 15: Construa P6 aplicando o algoritmo de Strassen para obter o produto das matrizes

(A21 − A11) e (B11 + B12).

(cid:7) Passo 16: Construa P7 aplicando o algoritmo de Strassen para obter o produto das matrizes

40

(A12 − A22) e (B21 + B22).

(cid:7) Passo 17: Obtenha a matriz C11 = P1 + P4 − P5 + P7.
(cid:7) Passo 18: Obtenha a matriz C12 = P3 + P5.
(cid:7) Passo 19: Obtenha a matriz C21 = P2 + P4.
(cid:7) Passo 20: Obtenha a matriz C22 = P1 + P3 − P2 + P6.
(cid:7) Passo 21: Retorne C =

(cid:21)

.

(cid:20) C11 C12
C21 C22

AlØm da adi(cid:231)ªo algØbrica de nœmeros que Prodmat2 realiza, ocorrerªo tambØm

adi(cid:231)ıes algØbricas de matrizes por Prodmat, segundo o seguinte algoritmo.

(cid:136) Entrada: A ordem m das matrizes quadradas A e B, bem como seus elementos, e as

Adi(cid:231)ªo AlgØbrica de Matrizes

opera(cid:231)ıes de adi(cid:231)ªo e subtra(cid:231)ªo.

(cid:136) Sa(cid:237)da: A + B ou A − B.
(cid:136) Passo 1: i assume valor 1.

Observa(cid:231)ªo 9. i indica a linha da matriz.

(cid:136) Passo 2: Se i (cid:54) m entªo considere j = 1. Mas se i > m entªo execute o passo 6.

Observa(cid:231)ªo 10. j indica a coluna da matriz.

(cid:21) Passo 3: Se j > m entªo continue executando a partir do passo 5. Caso j (cid:54) m e
a opera(cid:231)ªo for de adi(cid:231)ªo entªo fa(cid:231)a cij = aij + bij. Mas se j (cid:54) m e a opera(cid:231)ªo for
de subtra(cid:231)ªo entªo fa(cid:231)a cij = aij − bij.
Observa(cid:231)ªo 11. j > m indica que todos os nœmeros da linha i, de A, jÆ foram
somados ou subtra(cid:237)dos com seus correspondentes na linha i, de B.

(cid:21) Passo 4: Incremente j e volte a executar a partir do passo 3.

(cid:136) Passo 5: Incremente i e volte a executar a partir do passo 2.

Observa(cid:231)ªo 12. Neste passo, avan(cid:231)a-se para a pr(cid:243)xima linha, tanto de A como de B,
para que seja trabalhada a adi(cid:231)ªo ou subtra(cid:231)ªo dos nœmeros correspondentes.

(cid:136) Passo 6: Retorne a matriz A + B ou A − B, para a opera(cid:231)ªo utilizada por Prodmat.
(cid:4)

Exemplo 40. Sejam A =















0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2
3 3 3 3 3 3 3 3
4 4 4 4 4 4 4 4
5 5 5 5 5 5 5 5
6 6 6 6 6 6 6 6
7 7 7 7 7 7 7 7















por Prodmat, da seguinte forma:

= B, o produto C = A × B Ø obtido,

A =

(cid:122)

(cid:124)













(cid:124)

=

P 1
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

=

C1
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

=

P2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

41

=




















(cid:125)

0
1
2
3
4
5
6
7

(cid:122)

(cid:124)



























(cid:124)

i6
(cid:122)(cid:125)(cid:124)(cid:123)
B11

i2
(cid:122)(cid:125)(cid:124)(cid:123)
A11 =
(cid:125)(cid:124)

0
1
2
3
4
5
6
7

0
1
2
3
4
5
6
7

(cid:123)

(cid:122)

0
1
2
3
4
5
6
7

0
1
2
3
4
5
6
7

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B12

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A12 =
(cid:125)(cid:124)

0
1
2
3
4
5
6
7

0
1
2
3
4
5
6
7

(cid:125)

(cid:124)

(cid:123)(cid:122)
=B21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

A21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:123)(cid:122)
=B22
(cid:124)(cid:123)(cid:122)(cid:125)
i9

A22
(cid:124)(cid:123)(cid:122)(cid:125)
i5

0
1
2
3
4
5
6
7

(cid:123)

(cid:125)



























(cid:125)

=

= B; P1
(cid:124)(cid:123)(cid:122)(cid:125)
i10




















(cid:124)

(cid:123)

(cid:122)

(cid:123)(cid:122)
i1
C1
12
(cid:125)(cid:124)

112
168
224
280

112
168
224
280

C1
11
(cid:125)(cid:124)

112
168
224
280

112
168
224
280

(cid:123)(cid:122)
C1
21

(cid:123)(cid:122)
C1
22

(cid:125)

(cid:124)

(cid:123)(cid:122)
i21

(cid:123)

(cid:125)













(cid:125)

=

; P 1
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10

(cid:20) 336
448

(cid:21)

336
448

(cid:124)
11+A1

(cid:123)(cid:122)
22)×(B1

(cid:125)
11+B1

22)

(A1

; P 1
2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

i2
(cid:122)(cid:125)(cid:124)(cid:123)
A1
11
(cid:122) (cid:125)(cid:124) (cid:123)

4
6
8
10

4
6
8
10

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A1
12
(cid:122) (cid:125)(cid:124) (cid:123)

4
6
8
10

4
6
8
10

(cid:125)

(cid:124)

(cid:124)

(cid:123)(cid:122)
A1
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:125)

(cid:123)(cid:122)
A1
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5




















×




















i6
(cid:122)(cid:125)(cid:124)(cid:123)
B1
11
(cid:122) (cid:125)(cid:124) (cid:123)

4
6
8
10

4
6
8
10

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B1
12
(cid:122) (cid:125)(cid:124) (cid:123)

4
6
8
10

4
6
8
10

(cid:125)

(cid:124)

(cid:124)

(cid:123)(cid:122)
B1
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:125)

(cid:123)(cid:122)
B1
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9

(cid:123)(cid:122)
(A11+A22)×(B11+B22)

(cid:20) 160
200

=

(cid:21)

160
200

(cid:124)
(A1

(cid:125)
(cid:123)(cid:122)
22)×B1
21+A1
11

=

; P 1
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

(cid:20) −32 −32
−48 −48
(cid:123)(cid:122)
12−B1
11×(B1

(cid:124)
A1

(cid:125)
22)

(cid:21)
;

(cid:20) 64
80

(cid:21)

64
80

(cid:124)
(cid:125)
(cid:123)(cid:122)
22×(B1
21−B1
A1
11)
3 +P 1
P 1
5
(cid:125)(cid:124)

(cid:122)
(cid:20) 112
168

112
168

; P 1
5
i14

(cid:123)
(cid:21)
; C1
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

(cid:20) 114
216

=

(cid:21)

114
216

(cid:124)
(A1

(cid:123)(cid:122)
(cid:125)
12)×B1
11+A1
22
2 +P 1
P 1
4
(cid:125)(cid:124)

(cid:123)
(cid:21)

(cid:122)
(cid:20) 224
280

=

224
280

=

; P 1
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

=

; C1
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20

=

(cid:21)

(cid:20) −144 −144
−144 −144
(cid:123)(cid:122)
22)×(B1

(cid:124)
12−A1
(A1

(cid:125)
21+B1
22)

; C1
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

=

1 +P 1
P 1
(cid:122)
(cid:20) 112
168

4 −P 1
(cid:125)(cid:124)

5 +P 1
7
(cid:123)
(cid:21)

112
168

;

; P 1
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

(cid:20) 80
80

(cid:21)

80
80

(cid:125)
11+B1

12)

(cid:123)(cid:122)
11)×(B1
2 +P 1
6
(cid:123)
(cid:21)

3 −P 1
(cid:125)(cid:124)

(cid:124)
21−A1
(A1
1 +P 1
P 1
(cid:122)
(cid:20) 224
280

224
280

.

i2
(cid:122)(cid:125)(cid:124)(cid:123)
A2
11
(cid:125)(cid:124)

(cid:123)

(cid:122)

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A2
12
(cid:125)(cid:124)

8
10
12
14

8
10
12
14

8
10
12
14

8
10
12
14

(cid:123)(cid:122)
A2
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:125)

(cid:124)

(cid:123)(cid:122)
A2
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5




















(cid:123)

(cid:125)

×




















i6
(cid:122)(cid:125)(cid:124)(cid:123)
B2
11
(cid:122) (cid:125)(cid:124) (cid:123)

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B2
12
(cid:122) (cid:125)(cid:124) (cid:123)

0
1
2
3

0
1
2
3

0
1
2
3

0
1
2
3

(cid:124) (cid:123)(cid:122) (cid:125)
B2
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:124) (cid:123)(cid:122) (cid:125)
B2
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9




















=

(cid:122)

(cid:124)













(cid:124)

C2
11
(cid:125)(cid:124)

C2
12
(cid:125)(cid:124)

(cid:123)

(cid:122)

48
60
72
84

48
60
72
84

48
60
72
84

(cid:123)(cid:122)
C2
21

(cid:123)(cid:122)
C2
22

(cid:125)

(cid:124)

(cid:123)(cid:122)
i21

(cid:122)

(cid:124)




















(cid:124)













; P 2
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10

(cid:123)

(cid:125)

=

(cid:20) 120
144

(cid:21)

120
144

;

(cid:124)
11+A2

(cid:123)(cid:122)
22)×(B2

(cid:125)
11+B2

22)

(A2

48
60
72
84

(cid:125)

(cid:21)

=

P 2
2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

(cid:20) 24
28

(cid:21)

24
28

(cid:123)(cid:122)
(cid:125)
(cid:124)
22)×B2
21+A2
(A2
11

=

; P 2
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

=

P 2
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

(cid:21)

(cid:20) −40 −40
−40 −40
(cid:123)(cid:122)
22)×(B2

(cid:124)
12−A2
(A2

(cid:125)
21+B2

22)

; C2
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

(cid:123)(cid:122)
(A21+A22)×B11

=

; P 2
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

(cid:21)

(cid:124)
A2

(cid:20) −32 −32
−40 −40
(cid:123)(cid:122)
11×(B2
12−B2
P 2
1 +P 2
(cid:122)
(cid:20) 48
60

(cid:125)
22)
4 −P 2
(cid:125)(cid:124)

48
60

=

5 +P 2
7
(cid:123)
(cid:21)

(cid:125)
(cid:20) 48
56

(cid:21)

48
56

(cid:125)
(cid:123)(cid:122)
(cid:124)
21−B2
22×(B2
A2
11)
P 2
3 +P 2
5
(cid:125)(cid:124)

(cid:123)
(cid:21)

(cid:122)
(cid:20) 48
60

48
60

=

; C2
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

=

; C2
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

=

(cid:20) 80
100

80
100

; P 2
5
i14

; P 2
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

(cid:124)
(A2

(cid:123)(cid:122)
(cid:125)
11+A2
12)×B2
22
P 2
2 +P 2
4
(cid:125)(cid:124)

(cid:122)
(cid:20) 72
84

72
84

(cid:123)
(cid:21)
; C2
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20

=

=

(cid:20) 8
8

(cid:21)

8
8

;

(cid:125)
11+B2

12)

(cid:124)
21−A2
3 −P 2
(cid:125)(cid:124)

(cid:123)(cid:122)
11)×(B2
2 +P 2
6
(cid:123)
(cid:21)

72
84

.

(A2
P 2
1 +P 2
(cid:122)
(cid:20) 72
84

=

P3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

=

P 3
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10

=

P 3
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

=

C3
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

=

P4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

=

P 4
2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

=

P 4
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

=

P5
(cid:124)(cid:123)(cid:122)(cid:125)
i14

i2
(cid:122)(cid:125)(cid:124)(cid:123)
A3
11
(cid:122) (cid:125)(cid:124) (cid:123)

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A3
12
(cid:122) (cid:125)(cid:124) (cid:123)

0
1
2
3

0
1
2
3

0
1
2
3

0
1
2
3

(cid:124) (cid:123)(cid:122) (cid:125)
A3
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:124) (cid:123)(cid:122) (cid:125)
A3
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5




















(cid:124)

(cid:20) −32 −32
−64 −64
(cid:123)(cid:122)
22)×(B3

(cid:124)
11+A3
(A3

(cid:125)
11+B3

22)

(cid:21)

(cid:21)

42




















×




















(cid:122)

(cid:124)

i6
(cid:122)(cid:125)(cid:124)(cid:123)
B3
11
(cid:125)(cid:124)
−4 −4
−4 −4
−4 −4
−4 −4
(cid:123)(cid:122)
B3
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:123)

(cid:122)

(cid:125)

(cid:124)

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B3
12
(cid:125)(cid:124)
−4 −4
−4 −4
−4 −4
−4 −4
(cid:123)(cid:122)
B3
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9

(cid:123)

(cid:125)




















=

(cid:122)

(cid:124)













(cid:124)

C3
11
(cid:125)(cid:124)

0

(cid:123)

(cid:122)

0

0

C3
12
(cid:125)(cid:124)

(cid:123)

0

−16 −16
−32 −32
−48 −48
(cid:123)(cid:122)
C3
21

(cid:125)

(cid:124)

(cid:123)(cid:122)
i21

−16 −16
−32 −32
−48 −48
(cid:123)(cid:122)
C3
22

(cid:125)







;






(cid:125)

(cid:123)(cid:122)
A11×(B12−B22)
; P 3
2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

=

(cid:21)

(cid:20) −32 −32
−48 −48
(cid:123)(cid:122)
(cid:125)
22)×B3
21+A3
11

(cid:124)
(A3

=

; P 3
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

(cid:125)
(cid:20) 0
0

(cid:21)

0
0

=

(cid:20) 0
0

(cid:21)

0
0

; P 3
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

(cid:20)

=

;P 3
5
i14

(cid:21)
;

0

0

−16 −16
(cid:123)(cid:122)
(cid:125)
12)×B3
11+A3
22

(cid:124)
(A3

A3

(cid:125)
(cid:124)
(cid:123)(cid:122)
12−B3
11×(B3
22)
4 −P 3
P 3
1 +P 3
(cid:122)
(cid:125)(cid:124)
(cid:20)

0

−16 −16

=

; C3
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

0

5 +P 3
7
(cid:123)
(cid:21)
; C3
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

A3

(cid:125)
(cid:123)(cid:122)
(cid:124)
21−B2
22×(B2
11)
3 +P 3
P 3
5
(cid:125)(cid:124)

(cid:122)
(cid:20)

=

0

0

−16 −16

(cid:123)
(cid:21)

;

(cid:20) −32 −32
−32 −32
(cid:123)(cid:122)
11)×(B3

(cid:124)
21−A3
(A3
2 +P 3
P 3
4
(cid:122)
(cid:125)(cid:124)
(cid:20) −32 −32
−48 −48

=

(cid:20) 32
32

(cid:21)

32
32

; P 3
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

(cid:125)
11+B3

12)

(cid:124)
12−A3

(cid:123)(cid:122)
22)×(B3

(cid:125)
21+B2

22)

(A3
3 −P 3
1 +P 3
P 3
(cid:122)
(cid:125)(cid:124)
(cid:20) −32 −32
−48 −48

2 +P 3
6
(cid:123)
(cid:21)

.

(cid:123)
(cid:21)

=

; C3
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20




















i2
(cid:122)(cid:125)(cid:124)(cid:123)
A4
11
(cid:122) (cid:125)(cid:124) (cid:123)

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A4
12
(cid:122) (cid:125)(cid:124) (cid:123)

4
5
6
7

4
5
6
7

4
5
6
7

4
5
6
7

(cid:124) (cid:123)(cid:122) (cid:125)
A4
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:124) (cid:123)(cid:122) (cid:125)
A4
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5







































×

i6
(cid:122)(cid:125)(cid:124)(cid:123)
B4
11
(cid:122) (cid:125)(cid:124) (cid:123)

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B4
12
(cid:122) (cid:125)(cid:124) (cid:123)

4
4
4
4

4
4
4
4

4
4
4
4

4
4
4
4

(cid:124) (cid:123)(cid:122) (cid:125)
B4
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:124) (cid:123)(cid:122) (cid:125)
B4
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9




















=













(cid:124)

C4
11
(cid:125)(cid:124)

(cid:122)

64
80
96
112

(cid:123)

64
80
96
112

C4
12
(cid:125)(cid:124)

(cid:122)

64
80
96
112

(cid:123)

64
80
96
112

(cid:124)

(cid:123)(cid:122)
C4
21

(cid:125)

(cid:124)

(cid:123)(cid:122)
C4
22

(cid:125)













; P 4
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10

(cid:125)

(cid:123)(cid:122)
A22×(B21−B11)

(cid:124)
(cid:20) 96
112

(cid:21)

96
112

(cid:124)
(A4

(cid:123)(cid:122)
(cid:125)
22)×B4
21+A4
11

=

; P 4
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

(cid:20) 0
0

(cid:21)

0
0

; P 4
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

A4

(cid:125)
(cid:123)(cid:122)
(cid:124)
11×(B4
12−B4
22)
1 +P 4
4 −P 4
P 4
(cid:125)(cid:124)
(cid:122)
(cid:20) 64
80

64
80

=

5 +P 4
7
(cid:123)
(cid:21)

(cid:125)
(cid:20) 64
80

=

(cid:21)

64
80

; P 4
5
i14

(cid:125)
(cid:123)(cid:122)
(cid:124)
21−B4
22×(B4
A4
11)
3 +P 4
P 4
5
(cid:125)(cid:124)

(cid:123)
(cid:21)

(cid:122)
(cid:20) 64
80

64
80

=

; C4
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

=

; C4
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

(cid:20) 64
80

(cid:21)

64
80

(cid:123)(cid:122)
(cid:125)
(cid:124)
11+A4
12)×B4
(A4
22
2 +P 4
P 4
4
(cid:125)(cid:124)

(cid:122)
(cid:20) 96
112

96
112

; P 4
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

(cid:123)
(cid:21)
; C4
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20

(cid:21)

(cid:20) −32 −32
−32 −32
(cid:123)(cid:122)
22)×(B4

(cid:124)
(A4
12−A4

(cid:125)
21+B4

22)

; C4
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

=

(cid:20) 160
192

(cid:21)

160
192

;

(cid:124)
11+A4

(cid:123)(cid:122)
22)×(B4

(cid:125)
11+B4

22)

(A4

=

(cid:20) 32
32

(cid:21)

32
32

;

(cid:125)
11+B4

12)

(cid:124)
21−A4

(cid:123)(cid:122)
11)×(B4
2 +P 4
6
(cid:123)
(cid:21)

3 −P 4
(cid:125)(cid:124)

(A4
1 +P 4
P 4
(cid:122)
(cid:20) 96
112

96
112

.

=




















i2
(cid:122)(cid:125)(cid:124)(cid:123)
A5
11
(cid:122) (cid:125)(cid:124) (cid:123)

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A5
12
(cid:122) (cid:125)(cid:124) (cid:123)

0
2
4
6

0
2
4
6

0
2
4
6

0
2
4
6

(cid:124) (cid:123)(cid:122) (cid:125)
A5
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:124) (cid:123)(cid:122) (cid:125)
A5
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5







































×

i6
(cid:122)(cid:125)(cid:124)(cid:123)
B5
11
(cid:122) (cid:125)(cid:124) (cid:123)

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B5
12
(cid:122) (cid:125)(cid:124) (cid:123)

4
5
6
7

4
5
6
7

4
5
6
7

4
5
6
7

(cid:124) (cid:123)(cid:122) (cid:125)
B5
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:124) (cid:123)(cid:122) (cid:125)
B5
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9




















=













(cid:124)

C5
11
(cid:125)(cid:124)

(cid:122)

0
44
88
132

(cid:123)

0
44
88
132

C5
12
(cid:125)(cid:124)

(cid:122)

0
44
88
132

(cid:123)

0
44
88
132

(cid:124)

(cid:123)(cid:122)
C5
21

(cid:125)

(cid:124)

(cid:123)(cid:122)
C5
22

(cid:125)













; P 5
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10

(cid:125)

=

(cid:20) 88
176

(cid:21)

88
176

;

(cid:124)
11+A5

(cid:123)(cid:122)
22)×(B5

(cid:125)
11+B5

22)

(A5

(cid:124)
(cid:20) 72
108

(cid:21)

72
108

(cid:124)
(A5

(cid:123)(cid:122)
(cid:125)
22)×B5
21+A5
11

=

P 5
2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

(cid:123)(cid:122)
(A11+A12)×B22
(cid:20) 0

=

; P 5
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

(cid:21)

0
−8 −8
(cid:123)(cid:122)
(cid:124)
12−B5
11×(B5
A5

(cid:125)
22)

; P 5
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

(cid:125)
(cid:20) 16
24

=

(cid:21)

16
24

(cid:124)
(cid:125)
(cid:123)(cid:122)
21−B5
22×(B5
A5
11)

; P 5
5
i14

(cid:20) 0
52

(cid:21)

0
52

(cid:124)
(cid:123)(cid:122)
(cid:125)
12)×B5
11+A5
(A5
22

=

; P 5
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

(cid:20) 72
72

(cid:21)

72
72

;

(cid:124)
21−A5

(cid:123)(cid:122)
11)×(B5

(cid:125)
11+B5

12)

(A5

(cid:123)(cid:122)
i21

=

(cid:123)(cid:122)
i21

=

(cid:21)

(cid:20) −104 −104
−104 −104
(cid:123)(cid:122)
22)×(B5

(cid:124)
12−A5
(A5

(cid:125)
21+B5
22)

; C5
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

=

4 −P 5
(cid:125)(cid:124)

5 +P 5
7
(cid:123)
(cid:21)

1 +P 5
P 5
(cid:122)
(cid:20) 0
44

0
44

=

; C5
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

3 +P 5
P 5
5
(cid:125)(cid:124)

0
44

(cid:122)
(cid:20) 0
44

(cid:123)
(cid:21)

=

; C5
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

2 +P 5
P 5
4
(cid:125)(cid:124)

(cid:122)
(cid:20) 88
132

88
132

43

.

1 +P 5
P 5
(cid:122)
(cid:20) 88
132

3 −P 5
(cid:125)(cid:124)

2 +P 5
6
(cid:123)
(cid:21)

88
132

(cid:123)
(cid:21)
; C5
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20

=

=

P 5
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

=

P6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

=

P7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

=

P 7
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10




















(cid:124)




















(cid:124)

i2
(cid:122)(cid:125)(cid:124)(cid:123)
A6
11
(cid:122) (cid:125)(cid:124) (cid:123)

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A6
12
(cid:122) (cid:125)(cid:124) (cid:123)

4
4
4
4

4
4
4
4

4
4
4
4

4
4
4
4

(cid:124) (cid:123)(cid:122) (cid:125)
A6
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:124) (cid:123)(cid:122) (cid:125)
A6
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5




















×




















i6
(cid:122)(cid:125)(cid:124)(cid:123)
B6
11
(cid:122) (cid:125)(cid:124) (cid:123)

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B6
12
(cid:122) (cid:125)(cid:124) (cid:123)

0
2
4
6

0
2
4
6

0
2
6
6

0
2
6
6

(cid:124) (cid:123)(cid:122) (cid:125)
B6
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:124) (cid:123)(cid:122) (cid:125)
B6
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9




















(cid:125)

=

(cid:122)

(cid:124)













(cid:124)

C6
11
(cid:125)(cid:124)

C6
12
(cid:125)(cid:124)

(cid:123)

(cid:122)

48
48
48
48

48
48
48
48

48
48
48
48

48
48
48
48

(cid:123)(cid:122)
C6
21

(cid:123)(cid:122)
C6
22

(cid:125)

(cid:124)

(cid:123)(cid:122)
i21













; P 6
1
(cid:124)(cid:123)(cid:122)(cid:125)
i10

(cid:123)

(cid:125)

(cid:125)

=

(cid:20) 96
96

(cid:21)

96
96

(cid:124)
11+A6

(cid:123)(cid:122)
22)×(B6

(cid:125)
11+B6

22)

(A6

; P 6
2
(cid:124)(cid:123)(cid:122)(cid:125)
i11

(cid:20) 16
16

(cid:21)

16
16

(cid:124)
(cid:123)(cid:122)
(cid:125)
22)×B6
21+A6
(A6
11

; P 6
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

(cid:20) 0
0

(cid:21)

0
0

(cid:124)
12−A6

(cid:123)(cid:122)
22)×(B6

(cid:125)
21+B6

22)

(A6

; P 6
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

(cid:21)

=

(cid:123)(cid:122)
(A21−A11)×(B11+B12)
(cid:20) −32 −32
−32 −32
(cid:123)(cid:122)
11×(B6
12−B6
1 +P 6
P 6
(cid:122)
(cid:20) 48
48

(cid:125)
22)
4 −P 6
(cid:125)(cid:124)

48
48

(cid:124)
A6

=

5 +P 6
7
(cid:123)
(cid:21)

; C6
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

=

(cid:20) 32
32

(cid:21)

32
32

=

(cid:20) 80
80

(cid:21)

80
80

; P 6
5
i14

(cid:125)
(cid:123)(cid:122)
(cid:124)
21−B6
22×(B6
A6
11)
3 +P 6
P 6
5
(cid:125)(cid:124)

(cid:122)
(cid:20) 48
48

48
48

(cid:123)(cid:122)
(cid:125)
(cid:124)
11+A6
12)×B6
(A6
22
2 +P 6
P 6
4
(cid:125)(cid:124)

(cid:122)
(cid:20) 48
48

=

48
48

(cid:123)
(cid:21)
; C6
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20

=

(cid:123)
(cid:21)
; C6
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

=

; C6
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

; P 6
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

; P 6
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

(cid:125)
11+B6

12)

=

(cid:20) 0
0

(cid:21)

0
0

(cid:124)
21−A6
3 −P 6
(cid:125)(cid:124)

(cid:123)(cid:122)
11)×(B6
2 +P 6
6
(cid:123)
(cid:21)

48
48

.

(A6
1 +P 6
P 6
(cid:122)
(cid:20) 48
48

=

=

(cid:122)

(cid:124)

i2
(cid:122)(cid:125)(cid:124)(cid:123)
A7
11
(cid:125)(cid:124)
−4 −4
−4 −4
−4 −4
−4 −4
(cid:123)(cid:122)
A7
21
(cid:124)(cid:123)(cid:122)(cid:125)
i4

(cid:123)

(cid:122)

(cid:125)

(cid:124)

i3
(cid:122)(cid:125)(cid:124)(cid:123)
A7
12
(cid:125)(cid:124)
−4 −4
−4 −4
−4 −4
−4 −4
(cid:123)(cid:122)
A7
22
(cid:124)(cid:123)(cid:122)(cid:125)
i5

(cid:123)

(cid:125)







































(cid:122)

(cid:124)

×

i7
(cid:122)(cid:125)(cid:124)(cid:123)
B7
12
(cid:125)(cid:124)

(cid:123)

(cid:122)

i6
(cid:122)(cid:125)(cid:124)(cid:123)
B7
11
(cid:125)(cid:124)

8
10
12
14

8
10
12
14

8
10
12
14

8
10
12
14

(cid:125)

(cid:124)

(cid:123)(cid:122)
B7
21
(cid:124)(cid:123)(cid:122)(cid:125)
i8

(cid:123)(cid:122)
B7
22
(cid:124)(cid:123)(cid:122)(cid:125)
i9




















(cid:123)

(cid:125)

=













(cid:124)

C7
11
(cid:125)(cid:124)
−176 −176
−176 −176
−176 −176
−176 −176
(cid:123)(cid:122)
C7
21

(cid:122)

(cid:124)

C7
12
(cid:125)(cid:124)
−176 −176
−176 −176
−176 −176
−176 −176
(cid:123)(cid:122)
C7
22

(cid:123)

(cid:125)

;













(cid:125)

(cid:123)

(cid:122)

(cid:125)

(cid:124)

(cid:123)(cid:122)
i21

(cid:21)

(cid:20) −352 −352
−352 −352
(cid:123)(cid:122)
22)×(B7

(cid:124)
(A7
11+A7

(cid:125)
11+B7
22)

(cid:123)(cid:122)
(A21−A11)×(B11+B12)
(cid:20) −144 −144
; P 7
2
−144 −144
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:123)(cid:122)
i11
21+A7
22)×B7
11

(A7

=

(cid:124)

(cid:21)

(cid:125)

; P 7
3
(cid:124)(cid:123)(cid:122)(cid:125)
i12

=

(cid:125)
(cid:20) 32
32

(cid:21)

32
32

=

; P 7
4
(cid:124)(cid:123)(cid:122)(cid:125)
i13

(cid:20) −32 −32
−32 −32
(cid:123)(cid:122)
22×(B7
21−B7

(cid:125)
11)

(cid:21)
; P 7
5
i14

=

(cid:20) −208 −208
−208 −208
(cid:123)(cid:122)
11+A7
12)×B7
22

(A7

(cid:124)

(cid:21)
;

(cid:125)

3 +P 7
P 7
5
(cid:122)
(cid:125)(cid:124)
(cid:20) −176 −176
−176 −176

=

(cid:123)
(cid:21)
; C7
21
(cid:124)(cid:123)(cid:122)(cid:125)
i19

=

(cid:123)
(cid:21)
; C7
12
(cid:124)(cid:123)(cid:122)(cid:125)
i18

(cid:125)
(cid:123)(cid:122)
(cid:124)
A7
11×(B7
12−B7
22)
1 +P 7
P 7

(cid:124)
A7
5 +P 7
4 −P 7
7
(cid:125)(cid:124)
(cid:122)
(cid:20) −176 −176
−176 −176

=

; C7
11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

P 7
6
(cid:124)(cid:123)(cid:122)(cid:125)
i15

=

(cid:20) 0
0

(cid:21)

0
0

(cid:124)
21−A7

(cid:123)(cid:122)
11)×(B7

(cid:125)
11+B7

; P 7
7
(cid:124)(cid:123)(cid:122)(cid:125)
i16

=

(cid:20) 0
0

(cid:21)

0
0

(cid:124)
12−A7

(cid:123)(cid:122)
22)×(B7

(cid:125)
21+B7

22)

(A7
2 +P 7
P 7
4
(cid:122)
(cid:125)(cid:124)
(cid:20) −176 −176
−176 −176

12)
1 +P 7
P 7

(A7
2 +P 7
3 −P 7
6
(cid:122)
(cid:125)(cid:124)
(cid:20) −176 −176
−176 −176

(cid:123)
(cid:21)
.

(cid:123)
(cid:21)

=

; C7
22
(cid:124)(cid:123)(cid:122)(cid:125)
i20







0
28
56
84

0
28
56
84

0
28
56
84







0
28
56
84

=

; C12
(cid:124)(cid:123)(cid:122)(cid:125)
i18







0
28
56
84

0
28
56
84

0
28
56
84

0
28
56
84



=





; C21
(cid:124)(cid:123)(cid:122)(cid:125)
i19







112
140
168
196

112
140
168
196

112
140
168
196

112
140
168
196



=





; C22
(cid:124)(cid:123)(cid:122)(cid:125)
i20







112
140
168
196

=

C11
(cid:124)(cid:123)(cid:122)(cid:125)
i17

112
140
168
196

112
140
168
196



.





112
140
168
196

44

C = A × B =

(cid:20) C11 C12
C21 C22

(cid:124)

(cid:123)(cid:122)
i21

=

(cid:21)

(cid:125)














0
28
56
84
112
140
168
196

0
28
56
84
112
140
168
196

0
28
56
84
112
140
168
196

0
28
56
84
112
140
168
196

0
28
56
84
112
140
168
196

0
28
56
84
112
140
168
196

0
28
56
84
112
140
168
196














.

0
28
56
84
112
140
168
196

Seja M (n) o nœmero de multiplica(cid:231)ıes utilizadas por Prodmat, para calcular
o produto de duas matrizes quadradas de ordem n = 2k (k = log2n). Se k = 1 entªo
ocorrerªo 7 multiplica(cid:231)ıes, pois chama-se diretamente Prodmat2. Caso k (cid:62) 2, Prodmat serÆ
chamado recursivamente para multiplicar matrizes quadradas de ordem n
2 , sete vezes, mais 7
multiplica(cid:231)ıes de Prodmat2, para cada ordem, sendo o nœmero total de multiplica(cid:231)ıes, nesta
etapa, igual a 7 · M (cid:0) n

= 7 · M (2k−1). Isso fornece a seguinte recorrŒncia

(cid:1) = 7 · M

(cid:17)

(cid:16) 2k
2

2

M (cid:0)2k(cid:1) =






7
(cid:124)(cid:123)(cid:122)(cid:125)
Chamadas recursivas
P1 at´e P7

×

7,
,

M (cid:0)2k−1(cid:1)
(cid:125)
(cid:123)(cid:122)
(cid:124)
Custo da chamada recursiva
para uma multiplica¸c˜ao

se k = 1
se k > 1 .

Assim,

M (cid:0)2k(cid:1) = 7M (cid:0)2k−1(cid:1) =

=
=
=

· · ·
7k−1 · 7
n

log

7

2

72M (cid:0)2k−2(cid:1)

= 73M (cid:0)2k−3(cid:1)
= 7k−1M (cid:0)2k−(k−1)(cid:1) = 7k−1M (21)
=

log
7

7k

=

n

2

log

7

2

Veja que o nœmero de multiplica(cid:231)ıes foi reduzido de n3 para n

, que Ø uma
economia considerÆvel, para n su(cid:28)cientemente grande. Mesmo havendo aumento no nœmero
de adi(cid:231)ıes algØbricas, Prodmat realizarÆ menos opera(cid:231)ıes de adi(cid:231)ªo algØbrica do que o al-
goritmo clÆssico faz, para n su(cid:28)cientemente grande. De fato, seja A(n) o nœmero de adi(cid:231)ıes
algØbricas que Prodmat realiza para matrizes quadradas de ordem n = 2k. Se n = 2 entªo
ocorrerªo 18 adi(cid:231)ıes algØbricas por meio de Prodmat2. Caso k > 1, Prodmat serÆ chamado
recursivamente sete vezes com matrizes quadradas de ordem n
2 , para P1, P2, ..., P6 e P7,
sendo A (cid:0) n
= A (cid:0)2k−1(cid:1) o nœmero total de adi(cid:231)ıes algØbricas de matrizes ocorridas
(cid:17)2
nessa chamada. AlØm disso, ocorrem ainda (cid:0) n
adi(cid:231)ıes algØbricas dos
2
elementos das matrizes A e B, do algoritmo (cid:16)Adi(cid:231)ªo AlgØbrica de Matrizes(cid:17), o qual Ø usado
18 vezes para cada chamada do prodmat. Isso fornece a seguinte recorrŒncia

= (cid:0)2k−1(cid:1)2

(cid:1) = A

(cid:1)2 =

(cid:16) 2k
2

(cid:16) 2k
2

(cid:17)

2

A(2k) =






7
(cid:124)(cid:123)(cid:122)(cid:125)
Chamadas recursivas
P1 at´e P7

×

A (cid:0)2k−1(cid:1)
(cid:124)
(cid:125)
(cid:123)(cid:122)
Custo de P rodmat
com adi¸c˜oes alg´ebricas
impl´ıcitas para
a produ¸c˜ao de (Pi)

+

18
(cid:124)(cid:123)(cid:122)(cid:125)
18 chamadas
para adi¸c˜ao
alg´ebrica

18,
,

× (cid:0)2k−1(cid:1)2
(cid:124) (cid:123)(cid:122) (cid:125)
Custo de uma
adi¸c˜ao expl´ıcita
de matrizes
de ordem n
2

se k = 1
se k > 1

.

Assim,
A (cid:0)2k(cid:1) =

= 7 · A (cid:0)2k−1(cid:1) + 18 · (cid:0)2k−1(cid:1)2
= 72 · A (cid:0)2k−2(cid:1) + 7 · 18 · (cid:0)2k−2(cid:1)2 + 18 · (cid:0)2k−1(cid:1)2
= 73 · A (cid:0)2k−3(cid:1) + 72 · 18 · (cid:0)2k−3(cid:1)2 + 7 · 18 · (cid:0)2k−2(cid:1)2 + 18 · (cid:0)2k−1(cid:1)2
= 74 · A (cid:0)2k−4(cid:1) + 73 · 18 · (cid:0)2k−4(cid:1)2 + 72 · 18 · (cid:0)2k−3(cid:1)2 + 7 · 18 · (cid:0)2k−2(cid:1)2 + 18 · (cid:0)2k−1(cid:1)2
...
= 7k−1 · A (cid:0)2k−(k−1)(cid:1) + 7k−2 · 18 · (cid:0)2k−(k−1)(cid:1)2 + ... + 73 · 18 · (cid:0)2k−4(cid:1) +

+72 · 18 · (cid:0)2k−3(cid:1)2 + 7 · 18 · (cid:0)2k−2(cid:1)2 + 18 · (cid:0)2k−1(cid:1)2

= 7k−1 · A (21) + 7k−2 · 18 · (21)2 + ... + 73 · 18 · (cid:0)2k−4(cid:1) + 72 · 18 · (cid:0)2k−3(cid:1)2 +

= 7k−1 · 18 + 7k−2 · 18 · (21)2 + ... + 73 · 18 · (cid:0)2k−4(cid:1) + 72 · 18 · (cid:0)2k−3(cid:1)2 +

+7 · 18 · (cid:0)2k−2(cid:1)2 + 18 · (cid:0)2k−1(cid:1)2

+7 · 18 · (cid:0)2k−2(cid:1)2 + 18 · (cid:0)2k−1(cid:1)2



45



= 18 ·


7k−1 + 7k−2 · (cid:0)21(cid:1)2 + ... + 73 · (cid:0)2k−4(cid:1)2
+ 72 · (cid:0)2k−3(cid:1)2


(cid:124)
(cid:123)(cid:122)
Soma dos termos da P G de raz˜ao 4
7

+ 7 · (cid:0)2k−2(cid:1)2

+ (cid:0)2k−1(cid:1)2
(cid:125)





= 18 · 7k−1 ( 4

−1

7 )k
4
7 −1

= 6 · (cid:0)7k − 4k(cid:1).

Portanto, A(n) = 6 · (cid:0)7k − 4k(cid:1) < 6 · 7k = 6 · 7log

2

n = 6 · nlog

2

7 < n3 − n2, para n

su(cid:28)cientemente grande.

Assim, M (n) + A(n) < nlog2 7 + 6 · nlog2 7 < n3 + (n3 − n2) = 2n3 − n2, sendo
M (n) + A(n) e 2n3 − n2 os respectivos totais de multiplica(cid:231)ıes e adi(cid:231)ıes algØbricas dos
algoritmos Prodmat e clÆssico.

Suponha agora que n nªo seja uma potŒncia de base 2. Entªo, existe k ∈ N tal
que 2k−1 < n < 2k. Para poder aplicar o Prodmat na multiplica(cid:231)ªo de matrizes quadradas
com essa ordem n, altera-se a ordem dessa matriz de n para 2k, preenchendo com zeros as
2k − n linhas e colunas extras criadas, segundo o esquema abaixo:












A(cid:48)

2k×2k =

An×n

− − −−
0
0
0

· · ·
· · ·
· · ·

0
0
0

|

−

|

0
0
· · ·

· · ·
· · ·
· · ·

0
0
· · ·

· · ·
· · ·
· · ·

− − − − −−

· · ·
· · ·
· · ·

· · ·
· · ·
· · ·

0
0
· · ·

0
0
· · ·












e B(cid:48)

2k×2k =












Bn×n

− − −−
0
0
0

· · ·
· · ·
· · ·

0
0
0

|

−

|

0
0
· · ·

· · ·
· · ·
· · ·

0
0
· · ·

· · ·
· · ·
· · ·

− − − − −−

· · ·
· · ·
· · ·

· · ·
· · ·
· · ·

0
0
· · ·

0
0
· · ·












.

Assim, C (cid:48) = A(cid:48) × B(cid:48). Ap(cid:243)s a multiplica(cid:231)ªo, as posi(cid:231)ıes acrescentadas estarªo
todas preenchidas com zero. Entªo, para se obter C = A × B, basta eliminar tais posi(cid:231)ıes.

Exemplo 41. Dadas as matrizes A =

A × B =









6 6 6
6 6 6
6 6 6

3×3





1 1 1
1 1 1
1 1 1





3×3

e B =





2 2 2
2 2 2
2 2 2





3×3

, tem-se C =

. Mas 21 < 3 < 22 e conforme o esquema acima, tem-se:

46







22×22

⇒

A(cid:48) =







1 1 1 0
1 1 1 0
1 1 1 0
0 0 0 0













e B(cid:48) =

22×22

2 2 2 0
2 2 2 0
2 2 2 0
0 0 0 0


C (cid:48) = A(cid:48) × B(cid:48) =







6 6 6 0
6 6 6 0
6 6 6 0
0 0 0 0





.

22×22

Removendo-se a quarta linha e a quarta coluna de C (cid:48), obtØm-se C.

47

Cap(cid:237)tulo 4

Exemplos ClÆssicos de Algoritmos
Computacionais

4.1 Localiza(cid:231)ªo de Item em uma Lista

Imagine um arquivo de uma escola contendo (cid:28)chas para cada aluno, identi(cid:28)cadas
pelos nomes e dispostas em ordem alfabØtica de sobrenomes, nas quais sªo registradas infor-
ma(cid:231)ıes. Cada (cid:28)cha contØm o nœmero de matr(cid:237)cula do aluno. Considere a situa(cid:231)ªo de ter que
localizar uma determinada (cid:28)cha conhecendo apenas o nœmero de matr(cid:237)cula do aluno, para
registrar tais informa(cid:231)ıes. Supondo haver n (cid:28)chas na gaveta, o nœmero m(cid:237)nimo de (cid:28)chas
veri(cid:28)cadas serÆ igual a 1 se o nœmero procurado for o da primeira (cid:28)cha. Caso tal nœmero
encontra-se na œltima (cid:28)cha, serªo realizadas n compara(cid:231)ıes no mÆximo.

Se a busca de uma determinada (cid:28)cha come(cid:231)a pela compara(cid:231)ªo com a primeira
(cid:28)cha da gaveta, passando para a sucessora, atØ encontrÆ-la, entªo a primeira (cid:28)cha exigirÆ
uma compara(cid:231)ªo de localiza(cid:231)ªo, a segunda duas, a terceira trŒs, e assim sucessivamente. O
n(n + 1)
2

.
Se sªo gastos dois segundos para fazer uma compara(cid:231)ªo e um minuto para registrar
todas as informa(cid:231)ıes em uma (cid:28)cha de arquivo, para que valor de n serÆ gasto mais tempo
fazendo compara(cid:231)ıes do que gravando novas informa(cid:231)ıes? O tempo total necessÆrio para

nœmero total de compara(cid:231)ıes, para todos os alunos, serÆ 1+2+3+...+k +...+n =

n(n + 1)
2

.2 = n(n + 1) segundos. O tempo total exigido para
todas as compara(cid:231)ıes serÆ
gravar as informa(cid:231)ıes em todas as (cid:28)chas serÆ de 60n segundos. Assim, gasta-se mais tempo
com a localiza(cid:231)ªo da (cid:28)cha do que com a grava(cid:231)ªo se n(n + 1) > 60n, isto Ø, n > 59.

Dada uma sequŒncia de nœmeros A = (a1, a2, ..., an), pode-se localizar a posi(cid:231)ªo
do nœmero S em A, isto Ø, encontrar um (cid:237)ndice i tal que ai = S, se tal i existir, por meio do
seguinte algoritmo.

Algoritmo Localizar em SequŒncia
i1: Entrada: n, os elementos de A e S.
i2: Para i = 1 atØ n, fa(cid:231)a

i3: Se ai = S entªo retorne i e pare.

i4: Retorne: (cid:16)S nªo Ø um elemento de A(cid:17) e pare.

48

Contando as compara(cid:231)ıes no passo i3, veri(cid:28)ca-se que o pior caso irÆ ocorrer tanto
se S nªo for elemento de A ou se S = an, requerendo, em ambos os casos, n compara(cid:231)ıes.
Assim, o custo desse algoritmo Ø O(n).

Se os nœmeros da sequŒncia A estiverem dispostos na ordem crescente,

a1 < a2 < ... < an,

pode-se criar um algoritmo de localiza(cid:231)ªo e(cid:28)ciente, o qual funcionarÆ conforme o seguinte
exemplo:

Exemplo 42. Na localiza(cid:231)ªo do nœmero 18, na sequŒncia A = (2, 4, 6, 8, 10, 12, 14, 16, 18),
ocorrerªo os seguintes passos:
(cid:7) A sequŒncia A Ø dividida em duas sequŒncias (2, 4, 6, 8, 10) e (12, 14, 16, 18).
(cid:7) Compara-se 18 com o primeiro nœmero da sequŒncia (12, 14, 16, 18). Como 18 > 12, divide-

se tal sequŒncia em duas sequŒncias (12, 14) e (16, 18).

(cid:7) Compara-se 18 com o primeiro nœmero da sequŒncia (16, 18). Como 18 > 16, divide-se

(16, 18) em duas sequŒncias (16) e (18).

(cid:7) Compara-se 18 com o nœmero da sequŒncia (18). Como sªo iguais, Ø retornada a posi(cid:231)ªo

9, na qual estÆ o nœmero procurado.

(cid:4)

Logo abaixo estÆ o algoritmo para esse procedimento.

Localiza(cid:231)ªo E(cid:28)ciente em SequŒncia Ordenada

(cid:136) Entrada: O nœmero procurado x e os nœmeros da sequŒncia A = (a1, a2, ..., an), sendo

a1 < a2 < ... < an.

(cid:136) Sa(cid:237)da: A posi(cid:231)ªo i ∈ {1, 2, ..., n} de x na sequŒncia ou x nªo estÆ na sequŒncia.

(cid:136) Passo 1: Considere i = 1, representando a posi(cid:231)ªo inicial na sequŒncia A.

(cid:136) Passo 2: Considere j = n, representando a posi(cid:231)ªo (cid:28)nal na sequŒncia A.

(cid:5), res-
Observa(cid:231)ªo 13. Os nœmeros i e j serªo utilizados para se obter a posi(cid:231)ªo (cid:4) i+j
ponsÆvel por dividir a sequŒncia em duas subsequŒncias de mesmo comprimento ou, se
nªo for poss(cid:237)vel, havendo apenas um elemento a mais em uma das duas.

2

2

2 (cid:99), a(cid:98) i+j

(cid:16)
ai, ai+1, ..., a(cid:98) i+j

(cid:136) Passo 3: Enquanto i < j fa(cid:231)a m := (cid:4) i+j

(cid:5).
Observa(cid:231)ªo 14. A condi(cid:231)ªo i < j se verdadeira, dirÆ que a sequŒncia analisada atØ o
momento,
, nªo Ø unitÆria. Da(cid:237), como os nœmeros
da sequŒncia estªo dispostos em ordem crescente, compara-se x com o termo am =
2 (cid:99) dessa sequŒncia. Se x pertence (cid:224) sequŒncia A e x > am entªo x estarÆ na
a(cid:98) i+j
(cid:17)
subsequŒncia C =
, nªo sendo necessÆrio o desperd(cid:237)cio de
(cid:17)

2 (cid:99)+2, ..., aj
a(cid:98) i+j
tempo fazendo buscas na subsequŒncia B =
(cid:17)

ai, ai+1, ..., a(cid:98) i+j
2 (cid:99)
, bastando efetuar buscas somente nesta

. Agora se x < am

2 (cid:99)+1, ..., aj

2 (cid:99)+1, a(cid:98) i+j

(cid:16)

(cid:16)

(cid:17)

(cid:16)

ai, ai+1, ..., a(cid:98) i+j
2 (cid:99)

entªo x estarÆ em B =
subsequŒncia.

(cid:21) Passo 4: Se x > am entªo fa(cid:231)a i assumir o valor numØrico da expressªo algØbrica

49

m + 1, isto Ø, i := m + 1.
Observa(cid:231)ªo 15. O passo 4 serÆ executado sempre dentro do passo 3 (loop). Como
x nªo estÆ em B, a busca serÆ realizada em C. O loop enquanto serÆ executado
novamente de modo a dividir C, se nªo for unitÆria, em duas novas subsequŒncias,
B =
, para buscas. Veja
que o nome da subsequŒncia C Ø mantido, sendo a nova subsequŒncia C uma
subsequŒncia da antiga subsequŒncia C, mas com menor tamanho, pois o (cid:237)ndice i
foi aumentado, consequentemente o (cid:237)ndice (cid:4) i+j

(cid:5) + 1 tambØm Ø aumentado.

ai, ai+1, ..., a(cid:98) i+j
2 (cid:99)

2 (cid:99)+2, ..., aj

2 (cid:99)+1, a(cid:98) i+j

a(cid:98) i+j

e C =

(cid:16)

(cid:17)

(cid:16)

(cid:17)

2

(cid:21) Passo 5: Senªo fa(cid:231)a j := m.

(cid:16)

Observa(cid:231)ªo 16. O passo 5 tambØm serÆ executado sempre dentro do passo 3.
Neste caso, como x nªo estÆ em C, a busca serÆ realizada em B. Novamente
o loop enquanto serÆ executado e a condi(cid:231)ªo i < j a(cid:28)rmarÆ que B tem pelo
menos dois elementos. Se a a(cid:28)rma(cid:231)ªo for verdadeira, B serÆ dividida em duas no-
(cid:17)
vas subsequŒncias, B =
,
para buscas. Aqui tambØm Ø mantido o nome da subsequŒncia B, sendo a nova
subsequŒncia B uma subsequŒncia da antiga subsequŒncia B, mas com menor ta-
(cid:5) tambØm Ø
manho, pois o (cid:237)ndice j foi diminu(cid:237)do, consequentemente o (cid:237)ndice (cid:4) i+j
diminu(cid:237)do.
O la(cid:231)o (loop) enquanto provocarÆ divisıes nas subsequŒncias atØ obter uma sub-
sequŒncia unitÆria (ai)

, na qual ocorrerÆ a busca (cid:28)nal.

ai, ai+1, ..., a(cid:98) i+j
2 (cid:99)

2 (cid:99)+2, ..., aj

2 (cid:99)+1, a(cid:98) i+j

a(cid:98) i+j

e C =

(cid:16)

(cid:17)

2

i∈{1,2,...,n}

(cid:136) Passo 6: Se x = ai retorne: (cid:16)x estÆ na posi(cid:231)ªo i. Caso contrÆrio, retorne: (cid:16)x nªo estÆ

na sequŒncia A(cid:17).

(cid:136) Passo 7: Pare.

Exemplo 43. Aplicando os passos logo acima na sequŒncia A = (
veri(cid:28)car se 9 estÆ em A, tem-se:

a1
1 ,

a2
2 ,

a3
2 ,

a4
3 ,

a5
5 ,

a6
6 ,

a7
8 ), para

(cid:136) Passo 1: i := 1.

(cid:136) Passo 2: j := 7.

(cid:136) Passo 3: Dos passos 1 e 2, as posi(cid:231)ıes i e j de A sªo tais que i < j. Portanto A nªo
(cid:5) = (cid:98) 4 (cid:99) = 4. Execute o passo 4, para
(cid:5) = (cid:4) 1+7

Ø uma sequŒncia unitÆria e m := (cid:4) i+j
dividir A em duas subsequŒncias.

2

2

(cid:21) Passo 4: x = 9 e am = a4 = 3, com x > am (9 > 3). Entªo, i assume o valor
numØrico da expressªo algØbrica m + 1, para m = 4 (m + 1 = 4 + 1 = 5), ou seja,
i := 5.
a4
3 ) e C =
Observa(cid:231)ªo 17. AtØ aqui, obtØm-se as subsequŒncias B = (
a7
a6
a5
(
8 ), pois
6 ,
5 ,
x > a4. Deve-se executar novamente o passo 3, para comparar i com j e veri(cid:28)car
se C tem pelo menos dois elementos.

a7
8 ). A busca de x = 9 serÆ efetuada na subsequŒncia C = (

a3
2 ,
a5
5 ,

a6
6 ,

a2
2 ,

a1
1 ,

50

(cid:136) Passo 3: Dos passos 2 e 4, anteriores, as posi(cid:231)ıes i e j de C sªo tais que i < j. Portanto
(cid:5) = (cid:98) 6 (cid:99) = 6. Execute o passo 4, para dividir C

(cid:5) = (cid:4) 5+7

2

C nªo Ø unitÆria e m := (cid:4) i+j
em duas subsequŒncias.

2

(cid:21) Passo 4: am = a6 = 6 e x > am (9 > 6). Agora, i assume o valor numØrico da
expressªo algØbrica m + 1, para m = 6 (m + 1 = 6 + 1 = 7), ou seja, i := 7.

Observa(cid:231)ªo 18. AtØ aqui, obtØm-se as subsequŒncias B = (
A busca de x = 9 serÆ efetuada em C = (
novamente o passo 3, para comparar i com j e veri(cid:28)car se C Ø unitÆria.

a7
8 ).
a7
8 ), pois x > a6. Deve-se executar

a6
6 ) e C = (

a5
5 ,

(cid:136) Passo 3: Do passo 4, imediatamente anterior a este passo, e do passo 2, tem-se i = 7 e
j = 7. JÆ que a condi(cid:231)ªo i < j assumiu valor falso (i ≮ j), a sequŒncia C, da observa(cid:231)ªo
13, Ø unitÆria. Entªo o passo 3 nªo serÆ mais executado. Execute o passo 6, para fazer
a compara(cid:231)ªo (cid:28)nal.

(cid:136) Passo 6: Como x = 9 e ai = a7 = 8 sªo diferentes, x nªo estÆ na sequŒncia A.
(cid:136) Passo 7: Nenhum passo do algoritmo serÆ executado novamente, pois o procedimento

acaba aqui.

Veja abaixo o pseudoc(cid:243)digo desse algoritmo:

Algoritmo Localizar item em SequŒn-
cia Ordenada (n, a1 < a2 < ... < an, S).
1 (cid:21)> (n, a1 < a2 < ... < an, S) Ø a entrada, i Ø
2 o (cid:237)ndice do primeiro termo da lista e j Ø o (cid:237)ndi-
3 ce do œltimo.
4 i := 1
5 j := n
6 Enquanto i < j, fa(cid:231)a
m := (cid:4) i+j
7
2
Se x > am, entªo
8
9

i := m + 1

(cid:5)

Senªo

FimSe

j := m

10
11
12
13 FimEnquanto
14 Se x = ai, entªo
15
16 Senªo
17
18 FimSe
19 FimProcedimento

localiza¸c˜ao := i

localiza¸c˜ao := 0

Deseja-se calcular o custo desse algoritmo quando n (cid:55)→ ∞. Para facilitar tal
cÆlculo, basta considerar n = 2k, pois a subsequŒncia (cid:0)2k(cid:1)
k∈N Ø tal que k (cid:55)→ ∞ ⇒ 2k (cid:55)→ ∞.
Assim, a quantidade de elementos da sequŒncia abaixo representarÆ a quantidade de vezes
em que o loop (cid:16)Enquanto(cid:17) serÆ executado (k + 1 vezes), jÆ que a fun(cid:231)ªo desse loop Ø sempre
trabalhar com uma (cid:16)metade(cid:17) da sequŒncia anterior. O primeiro elemento dessa sequŒncia
(cid:0)2k(cid:1) representa o tamanho da lista original, e cada elemento posterior a ele Ø o tamanho de
cada uma das sublistas menores obtidas, nas quais se procura o x.

(2k, 2k−1, ..., 2, 1).

Tem-se que n = 2k ⇔ k = log2n, logo
k + 1 = log2n + 1 = O (log2n) + O(1) = O (log2n). Portanto, o custo desse

algoritmo Ø O (log2n).

51

4.2 Ordena(cid:231)ªo dos Elementos (Nœmeros) de um Vetor

Nesta se(cid:231)ªo, objetiva-se organizar, em ordem crescente, os elementos de um vetor
A = [a1, a2, ..., an]. Assim, serªo apresentados alguns algoritmos que solucionam este mesmo
problema e, para cada um deles, serÆ feita a anÆlise de e(cid:28)ciŒncia, no pior caso.

SerÆ efetuado o teste de mesa de alguns dos algoritmos de ordena(cid:231)ªo, para que se

possa compreender melhor tais algoritmos.

4.2.1 Ordena(cid:231)ªo Bolha

A ordena(cid:231)ªo bolha, tambØm conhecida como bubble-sort ou ordena(cid:231)ªo por (cid:29)utua-
(cid:231)ªo, trata-se de um algoritmo que apresenta um procedimento de ordena(cid:231)ªo por permuta(cid:231)ªo
A[n]
de dois nœmeros de posi(cid:231)ıes consecutivas do vetor A = [
an ], come(cid:231)ando
pelas posi(cid:231)ıes A[1] e A[2], depois por A[2] e A[3], e assim sucessivamente atØ que o maior
nœmero ocupe a posi(cid:231)ªo A[n]. Esse procedimento Ø novamente executado no vetor alterado
A[n−1]
A[1]
[
an−1 ], atØ que o maior nœmero ocupe a posi(cid:231)ªo A[n − 1], e assim
a1 ,
sucessivamente de modo que todos os nœmeros de A estejam dispostos em ordem crescente.

A[4]
a4 , ...,

A[4]
a4 , ...,

A[1]
a1 ,

A[3]
a3 ,

A[3]
a3 ,

A[2]
a2 ,

A[2]
a2 ,

Exemplo 44. Na ordena(cid:231)ªo do vetor A = [
farÆ o seguinte:

A[1]
9 ,

A[2]
5 ,

A[3]
6 ,

A[4]
2 ], o algoritmo de ordena(cid:231)ªo bolha

1. Compara 9 com 5 e ordena-os, permutando-os.

2. Em [

3. Em [

A[1]
5 ,
A[1]
5 ,
A[1]
5 ,

A[2]
9 ,
A[2]
6 ,
A[2]
6 ,

A[4]
2 ], compara 9 com 6 e permuta-os.
A[4]
2 ], compara 9 com 2 e permuta-os.

A[3]
6 ,
A[3]
9 ,
A[3]
2 ], compara 5 com 6, nªo permutando-os, pois jÆ estªo ordenados.

4. Em [
5. Depois compara 6 com 2, permutando-os.

6. Em [

A[1]
5 ,

A[2]
2 ], compara 5 com 2, permutando-os.

7. Retorna o vetor A = [

A[1]
2 ,

A[2]
5 ,

A[3]
6 ,

A[4]
9 ].

Ordena(cid:231)ªo Bolha

(cid:136) Entrada: A quantidade n de nœmeros do vetor A e seus elementos a1, a2, ..., an.

(cid:136) Sa(cid:237)da: Os elementos de A dispostos em ordem crescente.

(cid:136) Passo 1: Comece considerando i = 1.

(cid:21) Passo 2: Comece considerando j = 1.

* Passo 3: Compare os termos aj e aj+1. Se aj > aj+1 entªo permute-os, para

disp(cid:244)-los em ordem crescente.

* Passo 4: Incremente j. Se j assumir valor n − i + 1 entªo pare. Mas se

j < n − i + 1 entªo volte a executar a partir do passo 3.

52

Observa(cid:231)ªo 19. A condi(cid:231)ªo de parada de execu(cid:231)ªo dos passos 2 e 3, j =
n − i + 1, se verdadeira, indica que todos os nœmeros do vetor A, usado para
cada i, foram percorridos.

A execu(cid:231)ªo completa dos passos 3 e 4, iniciando com j = 1, que
vai sendo incrementado gradativamente, atØ que se pare a execu(cid:231)ªo deles para
j = n−i+1, s(cid:243) garante que o maior nœmero de A ocuparÆ a sua œltima posi(cid:231)ªo,
sem poder saber se o novo vetor obtido jÆ estÆ totalmente ordenado. Entªo
outra anÆlise deve ser feita, mas no vetor obtido eliminando a œltima posi(cid:231)ªo,
A[n − i + 1], (cid:28)cando esta e seu nœmero reservados para compor a sa(cid:237)da do
algoritmo.

(cid:136) Passo 5: Incremente i. Se i assumir valor n entªo pare. Mas se i < n entªo volte a

executar a partir do passo 2.
Observa(cid:231)ªo 20. i Ø incrementado para que seja poss(cid:237)vel fazer a anÆlise do vetor A. A
condi(cid:231)ªo de parada de execu(cid:231)ªo do passo 5, i = n, se verdadeira, indica que A, cuja
ordena(cid:231)ªo de seus nœmeros deveria ser veri(cid:28)cada a partir do passo 2, jÆ estÆ ordenado,
podendo-se executar o passo 6.

(cid:136) Passo 6: Retorne o vetor A, com seus n nœmeros jÆ dispostos em ordem crescente.

Exemplo 45. Utilizando os passos acima, da ordena(cid:231)ªo bolha, para ordenar os elementos

do vetor A = [

A1
8 ,

A2
4 ,

A3
7 ,

A4
1 ], tem-se o esquema abaixo:

(a)

(b)

(c)

A[4]
1

A[3]
7

A[2]
A[1]
4
8
Permuta
A[3]
A[2]
A[1]
7
8
4
Permuta
A[3]
A[2]
A[4]
1
8
7
Permuta

A[1]
4

A[4]
1

(g)

A[1]
1

A[2]
4

A[3]
7

A[4]
8 (Sa(cid:237)da)

(d)

(e)

(f )

A[1]
4

A[2]
7

A[3]
1

A[4]
8

Nªo Permuta

A[1]
4

A[3]
A[2]
1
7
Permuta
A[3]
A[1]
A[2]
7
1
4
Permuta

A[4]
8

A[4]
8

Logo abaixo, segue a versªo desse algoritmo escrita por pseudoc(cid:243)digo.

(cid:4)

Procedimento Ordena(cid:231)ªo Bolha
1 Entrada: n e a1, a2, ..., an.
2 Para i = 1 atØ n − 1, fa(cid:231)a
3 Para j = 1 atØ n − i, fa(cid:231)a
4
5
6
7
Observa(cid:231)ªo 21. Na execu(cid:231)ªo desse algoritmo, feita pelo computador, haverÆ grava(cid:231)ªo e re-
grava(cid:231)ªo de nœmero em determinada posi(cid:231)ªo. Para nªo se perder o nœmero que estava
armazenado nesta posi(cid:231)ªo, antes da regrava(cid:231)ªo, utiliza-se a variÆvel auxiliar Temp. Na ex-
pressªo A[j] > A[j + 1], deseja-se veri(cid:28)car se o nœmero da posi(cid:231)ªo A[j] Ø maior do que o

8 FimSe
9 FimPara
10 FimPara
11 Para i = 1 atØ n, fa(cid:231)a
12 Retorne: (cid:16)O vetor na forma ordenada Ø:(cid:17)
13 Retorne: a[i] = A[i]
14 FimPara
15 FimProcedimento

Se (A[j] > A[j + 1]), entªo
T emp := A[j];
A[j]
A[j + 1]

:= A[j + 1];

:= T emp;

53

nœmero da posi(cid:231)ªo A[j + 1]. Na expressªo T emp := A[i], Ø atribu(cid:237)do (cid:224) variÆvel T emp o
:= A[j + 1], serÆ colocado o nœmero da
nœmero da posi(cid:231)ªo A[j + 1]. Na expressªo A[j]
:= T emp, coloca-se o nœmero
posi(cid:231)ªo A[j + 1] na posi(cid:231)ªo A[j]. Agora, na expressªo A[j + 1]
representado pela variÆvel auxiliar T emp na posi(cid:231)ªo A[j + 1].

4.2.1.1 Custo da Ordena(cid:231)ªo Bolha

Em qualquer caso, o loop interno (cid:16)Para(cid:17), desse algoritmo, serÆ executado n − i

vezes, para cada i ∈ {1, 2, ..., (n − 1)} do loop externo (cid:16)Para(cid:17). Assim,

n−1
(cid:88)

(n − i)
(cid:124) (cid:123)(cid:122) (cid:125)
P olinˆomio de grau 1
(cid:125)
(cid:123)(cid:122)
P olinˆomio de grau 2 em n−1 (Corol´ario 2)

i=1
(cid:124)

= b2(n − 1)2 + b1(n − 1) + b0 = O(n2)
(cid:125)
(cid:123)(cid:122)
Exemplo 25

(cid:124)

.

4.2.2 Ordena(cid:231)ªo Por Sele(cid:231)ªo

A[1]
a1 ,

A[2]
a2 ,

A[4]
a4 , ...,

Dado um vetor A = [

A[3]
A[n]
an ], para dispor seus nœmeros em
a3 ,
ordem crescente, o algoritmo de ordena(cid:231)ªo por sele(cid:231)ªo, tambØm conhecido como selection-
sort, irÆ localizar o menor nœmero ai, i ∈ {1, 2, 3, ..., n}, de A e colocarÆ ai na primeira
posi(cid:231)ªo A[1], permutando (trocando) os nœmeros das posi(cid:231)ıes A[i] e A[1], desde que a posi(cid:231)ªo
A[1] jÆ nªo esteja ocupada pelo menor nœmero. No novo vetor, representado pelas posi(cid:231)ıes
restantes: A[2], A[3],..., A[n], nenhuma delas ocupadas por ai, procurarÆ o menor nœmero
aj, j ∈ {1, 2, 3, ..., n}, j (cid:54)= i e colocarÆ aj na segunda posi(cid:231)ªo A[2], permutando os nœmeros
das posi(cid:231)ıes A[j] e A[2], desde que a posi(cid:231)ªo A[2] jÆ nªo esteja ocupada pelo menor nœmero.
Esse procedimento vai se repetindo em vetores cada vez menores atØ que se tenha os nœmeros
de A ordenados. Veja logo abaixo os passos desse algoritmo.

Exemplo 46. Na ordena(cid:231)ªo do vetor A = [
sele(cid:231)ªo farÆ o seguinte:

A[1]
9 ,

A[2]
5 ,

A[3]
6 ,

A[4]
2 ], o algoritmo de ordena(cid:231)ªo por

1. Compara 9 com 5 e ordena-os, permutando-os.

2. Em [

A[1]
5 ,

A[2]
9 ,

A[3]
6 ,

A[4]
2 ], compara 5 com 6, mas nªo os permuta pois 5 < 6.

3. Depois compara 5 com 2 e os permuta, fornecendo o vetor [

A[1]
2 ,

A[2]
9 ,

A[3]
6 ,

A[4]
5 ].

4. Em A1 = [

5. Em A1 = [
A1[1]=A[2]
5

A1 = [

A1[1]=A[2]
9
,
A1[1]=A[2]
6

,

A1[2]=A[3]
6
,
A1[2]=A[3]
,
9

A1[3]=A[4]
5
A1[3]=A[4]
5

A1[2]=A[3]
,
9
A2[1]=A[3]
9

,

A1[3]=A[4]
,
6
A2[2]=A[4]
6

].

6. Em A2 = [
A2[1]=A[3]
6

A2[2]=A[4]
9

,

[

].

], compara 9 com 6 e permuta-os.

], compara 6 com 5 e os permuta fornecendo o vetor

], compara 9 com 6 e permuta-os, fornecendo o vetor A2 =

7. Retorna o vetor A = [

A[1]
2 ,

A[2]
5 ,

A[3]
6 ,

A[4]
9 ].

Ordena(cid:231)ªo por Sele(cid:231)ªo

54

(cid:136) Entrada: O nœmero n de elementos do vetor A e os nœmeros a1, a2, ..., an.

(cid:136) Sa(cid:237)da: Os elementos de A dispostos em ordem crescente.

(cid:136) Passo 1: Considere i = 1.

Observa(cid:231)ªo 22. i representa a posi(cid:231)ªo na qual deseja-se colocar o menor nœmero do
vetor atual obtido ou do mais recente.

(cid:21) Passo 2: Considere j = i + 1.

Observa(cid:231)ªo 23. j representa a posi(cid:231)ªo dos nœmeros da direita, os quais serªo
comparados, um a um, com o nœmero de A[i].

* Passo 3: Se ai > aj entªo permute-os nas suas posi(cid:231)ıes.
* Passo 4: Incremente j e volte a executar a partir do passo 3, parando no caso

em que j assume valor n + 1.
Observa(cid:231)ªo 24. Na eminŒncia de executar o passo 5, o menor nœmero de A jÆ
estarÆ ocupando a posi(cid:231)ªo correta A[i].

(cid:136) Passo 5: Incremente i e volte a executar a partir do passo 2, parando no caso em que

i assume valor n, para executar o passo 6.

Observa(cid:231)ªo 25. i Ø incrementado para que j seja o responsÆvel pela varredura do vetor
atual Ai−1, composto pelas posi(cid:231)ıes A[i], A[i + 1],..., A[n], estando A[i − 1], com o seu
nœmero, reservados para a sa(cid:237)da.

(cid:136) Passo 6: Retorne o vetor A, com seus n nœmeros jÆ dispostos em ordem crescente.

Exemplo 47. Utilizando os passos acima, da ordena(cid:231)ªo por sele(cid:231)ªo, para ordenar os elementos

do vetor A = [

A1
8 ,

A2
4 ,

A3
7 ,

A4
1 ], obtØm-se o seguinte esquema:

(a)

(b)

(c)

A[2]
A[1]
4
8
Permuta

A[3]
7

A[4]
1

A[1]
A[3]
A[2]
4
7
8
Nªo Permuta

A[4]
1

A[1]
4

A[2]
A[3]
7
8
Permuta

A[4]
1

(d)

(e)

A[1]
1

A[1]
1

A[3]
A[2]
7
8
Permuta

A[2]
A[4]
7
8
Permuta

A[4]
4

A[3]
4

(f )

A[1]
1

A[2]
4

A[3]
A[4]
7
8
Permuta

(g)

A[1]
1

A[2]
4

A[3]
7

A[4]
8 (Sa(cid:237)da)

Esse algoritmo pode ser descrito por meio de pseudoc(cid:243)digo, conforme o que segue

abaixo.

1 Procedimento Selection-Sort (n, A)
2 Sa(cid:237)da: Os nœmeros de A dispostos em
3 ordem crescente.
4 Para i = 1 atØ n − 1, fa(cid:231)a
5 min := i
6 Para j := i + 1, atØ n, fa(cid:231)a

Se A[j] < A[min], entªo

min := j

7
8
9
10 FimPara
11 T emp := A[i];
12 A[i]

FimSe

:= A[min];

55

:= T emp;

13 A[min]
14 FimPara
15 Para i = 1 atØ n, fa(cid:231)a
16 Retorne: (cid:16)O vetor

17 na forma ordenada Ø:(cid:17)
18 Retorne: a[i] = A[i]
19 FimPara
20 FimProcedimento

4.2.2.1 Custo da Ordena(cid:231)ªo Por Sele(cid:231)ªo

O algoritmo de ordena(cid:231)ªo por sele(cid:231)ªo foi projetado de forma que, no loop duplo,
o loop interno seja executado n − (i + 1) + 1 = n − i vezes, para cada i ∈ {1, 2, ..., (n − 1)}
do loop externo. Dessa forma, obtØm-se a seguinte rela(cid:231)ªo:

n−1
(cid:88)

(n − i)
(cid:124) (cid:123)(cid:122) (cid:125)
P olinˆomio de grau 1
(cid:125)
(cid:123)(cid:122)
P olinˆomio de grau 2 em n−1 (Corol´ario 2)

i=1
(cid:124)

= b2(n − 1)2 + b1(n − 1) + b0 = O(n2)
(cid:125)
(cid:123)(cid:122)
Exemplo 25

(cid:124)

.

4.2.3 Ordena(cid:231)ªo Por Inser(cid:231)ªo

A[3]
a3 ,

A[1]
a1 ,

Para ordenar o vetor A = [

A[n]
A[2]
an ], o algoritmo de ordena(cid:231)ªo
a2 ,
por inser(cid:231)ªo, tambØm conhecido como insertion-sort, ordenarÆ primeiramente a1 e a2, depois
inserirÆ a3 na sua posi(cid:231)ªo ordenada com rela(cid:231)ªo aos dois primeiros elementos, jÆ ordenados.
Novamente, inserirÆ a4 na sua posi(cid:231)ªo ordenada com rela(cid:231)ªo aos trŒs primeiros elementos jÆ
ordenados. Este procedimento Ø repetido quantas vezes for necessÆrio, inserindo aj na sua
posi(cid:231)ªo ordenada com rela(cid:231)ªo aos j − 1 primeiros elementos, jÆ ordenados, atØ que todos os
elementos do vetor estejam ordenados de forma crescente.

A[4]
a4 , ...,

Exemplo 48. Na ordena(cid:231)ªo do vetor A = [
sele(cid:231)ªo farÆ o seguinte:

A[1]
9 ,

A[2]
5 ,

A[3]
6 ,

A[4]
2 ], o algoritmo de ordena(cid:231)ªo por

1. Compara 5 com 9 e ordena-os, permutando-os.

A[4]
2 ], compara 6 com 9, pemutando-os.
A[4]
2 ], compara 6 com 5, mas nªo os permuta, pois jÆ estªo ordenados.

2. Em A = [

A[1]
5 ,
A[1]
5 ,

A[2]
9 ,
A[2]
6 ,

A[3]
6 ,
A[3]
3. Em A = [
9 ,
4. Depois compara 2 com 9, permutando-os.
A[3]
2 ,
A[3]
6 ,

5. Em A = [

A[2]
6 ,
A[2]
2 ,

A[1]
5 ,
A[1]
5 ,

6. Em A = [

7. Retorna o vetor A = [

A[4]
9 ], compara 2 com 6, permutando-os.
A[4]
9 ], compara 2 com 5, permutando-os.
A[1]
2 ,

A[3]
6 ,

A[2]
5 ,

A[4]
9 ].

Ordena(cid:231)ªo por Inser(cid:231)ªo

(cid:136) Entrada: O tamanho n do vetor A e os elementos a1, a2, ..., an dele.

(cid:136) Sa(cid:237)da: Os elementos de A dispostos em ordem crescente.

(cid:136) Passo 1: Fa(cid:231)a a variÆvel j assumir o valor 2.

56

Observa(cid:231)ªo 26. j indica a posi(cid:231)ªo em A, tambØm representada por A[j], do nœmero
que serÆ inserido em alguma posi(cid:231)ªo da esquerda, (cid:28)cando ordenado com os nœmeros
que antes estavam a sua esquerda, jÆ ordenados.

(cid:21) Passo 2: Fa(cid:231)a a variÆvel i assumir o valor numØrico da expressªo algØbrica j − 1.
Observa(cid:231)ªo 27. i Ø uma variÆvel auxiliar, que tambØm indica a posi(cid:231)ªo no vetor,
encarregada de fazer o nœmero da posi(cid:231)ªo A[j], comentado na observa(cid:231)ªo anterior,
deslocar para a esquerda, por meio de uma permuta(cid:231)ªo com o seu antecessor
A[j − 1], segundo o passo 3, se necessÆrio for, ou seja, se nªo estiverem dispostos
em ordem crescente, para estabelecer tal ordem.

(cid:21) Passo 3: Compare o nœmero x, da posi(cid:231)ªo A[i], com o nœmero y, da posi(cid:231)ªo
A[i + 1] (sucessor), no vetor A atual. Se x > y entªo permute-os nas posi(cid:231)ıes A[i]
e A[i + 1].
Observa(cid:231)ªo 28. Neste passo serªo ordenados os nœmeros das posi(cid:231)ıes A[i] e A[i+1].

(cid:21) Passo 4: Decremente i, ou seja, diminua uma unidade de i. Se i for maior do que
0 entªo volte a executar a partir do passo 3, considerando o novo vetor obtido atØ
o presente momento. Mas se i = 0 entªo pare e execute o passo 5.
Observa(cid:231)ªo 29. A condi(cid:231)ªo de parada i = 0 indica que o nœmero da posi(cid:231)ªo A[j],
no vetor, utilizado no passo 2 anterior, jÆ ocupou sua posi(cid:231)ªo correta com rela(cid:231)ªo
aos nœmeros ordenados que estavam (cid:224) sua esquerda.

O pr(cid:243)ximo passo Ø reponsÆvel por indicar o sucessor do nœmero de A[j],
para que tal sucessor seja ordenado com os nœmeros a sua esquerda, jÆ ordenados.

(cid:136) Passo 5: Incremente j. Se j for menor do que o valor de n + 1 entªo volte a executar
a partir do passo 2. Mas se j assumir o valor de n + 1 entªo pare e execute o passo 6.

(cid:136) Passo 6: Retorne o vetor A, com seus n nœmeros jÆ dispostos em ordem crescente.

Exemplo 49. Utilizando os passos acima, da ordena(cid:231)ªo por inser(cid:231)ªo, para ordenar os

elementos do vetor A = [

A1
8 ,

A2
4 ,

A3
7 ,

A4
1 ], obtØm-se o esquema abaixo:

(a)

(b)

(c)

A[2]
A[1]
8
4
Permuta

A[3]
7

A[4]
1

A[1]
4

A[2]
A[3]
7
8
Permuta

A[4]
1

A[1]
4

A[2]
7

A[3]
8

A[4]
1

Nªo Permuta

(d)

(e)

(f )

A[1]
4

A[2]
7

A[4]
A[3]
1
8
Permuta

A[1]
4

A[2]
A[3]
1
7
Permuta

A[4]
8

A[2]
A[1]
1
4
Permuta

A[3]
7

A[4]
8

(g)

A[1]
1

A[2]
4

A[3]
7

A[4]
8 (Sa(cid:237)da)

O algoritmo de ordena(cid:231)ªo por inser(cid:231)ªo Ø escrito por pseudoc(cid:243)digo da seguinte

forma:

57

Procedimento Insertion-Sort (n, A)
(cid:21)> (n, A) representa a entrada, o valor de n e os nœmeros de A.
Para j = 2 atØ n, fa(cid:231)a
chave := A[j];
i := j − 1;
Enquanto i > 0 e A[i] > chave, fa(cid:231)a
:= A[i];

A[i + 1]
i := i − 1;
A[i + 1]

:= chave;

FimEnquanto

FimPara
FimProcedimento

Observa(cid:231)ªo 30. Na execu(cid:231)ªo desse algoritmo, feita pelo computador, haverÆ grava(cid:231)ªo e re-
grava(cid:231)ªo de nœmero em determinada posi(cid:231)ªo. Para nªo se perder o nœmero que estava
armazenado nesta posi(cid:231)ªo, antes da regrava(cid:231)ªo, utiliza-se a variÆvel auxiliar chave.

4.2.3.1 Custo da Ordena(cid:231)ªo Por Inser(cid:231)ªo (Pior Caso)

O pior caso para o algoritmo de ordena(cid:231)ªo por inser(cid:231)ªo ocorre se os seus elementos
formarem uma sequŒncia de nœmeros estritamente decrescente, pois aumentarÆ o nœmero de
permuta(cid:231)ıes necessÆrias para ordenar o vetor A.
Isso signi(cid:28)ca que as instru(cid:231)ıes do loop
(cid:16)Enquanto(cid:17) serªo executadas um nœmero maior de vezes. Ou seja, na ordena(cid:231)ªo, por
A[n]
an ], tal que a1 > a2 > a3 > a4 > ... > an,

inser(cid:231)ªo, do vetor A = [
tem-se o seguinte:
Etapa 1. Ocorre para j = 2, fazendo i assumir dois valores: 1 e 0, havendo uma permuta(cid:231)ªo.
Etapa 2. Ocorre para j = 3, fazendo i assumir trŒs valores: 2, 1 e 0, havendo duas
permuta(cid:231)ıes.

A[4]
a4 , ...,

A[1]
a1 ,

A[2]
a2 ,

A[3]
a3 ,

...

Etapa n − 1. Ocorre para j = n, fazendo i assumir n valores: (n − 1), (n − 2),..., 2, 1 e 0,
havendo n − 1 permuta(cid:231)ıes.

Na execu(cid:231)ªo completa do algoritmo de ordena(cid:231)ªo por inser(cid:231)ªo, o nœmero total de
vezes em que i assume um valor Ø superior ao nœmero total de vezes em que j assume um
valor e tambØm Ø superior ao nœmero total de permuta(cid:231)ıes.

Como o valor de j Ø a quantidade de valores que i assumirÆ, em cada etapa, pode
se dizer que o total de valores assumidos por i, na execu(cid:231)ªo completa desse algoritmo, para
o pior caso, Ø dado pela seguinte rela(cid:231)ªo:

n
(cid:80)
j=2

j =

2 + 3 + 4 + ... + n
(cid:125)
(cid:123)(cid:122)
(cid:124)
Soma dos termos da P A de raz˜ao 1

= (2+n)(n−1)
2

= O(n2).

4.2.4 Ordena(cid:231)ªo Por Intercala(cid:231)ªo (Merge)

58

dena o vetor C = [

O algoritmo de ordena(cid:231)ªo por intercala(cid:231)ªo, tambØm conhecido como merge, or-
A[2]
,
a2
=c2

C[n+m]
cn+m ], fazendo a jun(cid:231)ªo de seus dois vetores A = [

C[2]
c2 , ...,

A[1]
a1
=c1

C[1]
c1 ,

,

...,

A[n]
an
=cn

] e B = [

B[1]
b1
=cn+1

,

B[2]
b2
=cn+2

, ...,

B[m]
bm
=cn+m

], ambos jÆ ordenados, formando um novo vetor C,

cujos nœmeros estarªo dispostos em ordem crescente, da seguinte forma: ap(cid:243)s fornecer o
tamanho de cada vetor, bem como os seus nœmeros, como entrada, compara-se os primeiros
nœmeros de cada vetor, a1 com b1, sendo o menor deles reservado para a posi(cid:231)ªo C[1] de C.
Sem perda de generalidade, suponha que o menor nœmero seja b1. Entªo b1 serÆ colocado na

posi(cid:231)ªo C[1] (C[1]

:= b1). O novo vetor B serÆ B = [

B[1]
b2
=cn+2

,

B[2]
b3
=cn+3

, ...,

B[m−1]
bm
=cn+m

], com a exclusªo

,

,

],

primeiros nœmeros dos vetores A = [

de b1, pois ele jÆ foi reservado para primeira posi(cid:231)ªo da sa(cid:237)da. Novamente se compara os
A[2]
a2
=c2
a1 com b2, sendo o menor deles reservado para a posi(cid:231)ªo C[2]. Novamente sem perda de
:= a1. Agora o novo vetor
generalidade, suponha que o menor nœmero seja a1. Entªo C[2]
A[n−1]
an
=cn

], com a exclusªo de a1, pois ele jÆ foi reservado para a

B[m−1]
bm
=cn+m

A serÆ A = [

B[1]
b2
=cn+2

B[2]
b3
=cn+3

] e B = [

A[1]
a2
,
=c2

A[n]
an
=cn

A[1]
a1
=c1

A[2]
a3
=c3

, ...,

, ...,

, ...,

sa(cid:237)da. Esse procedimento Ø repetido nos vetores atuais A e B, cada vez mais reduzidos em
tamanho, sempre comparando os primeiros nœmeros de cada, atØ obter o vetor C ordenado
por completo. Se A tiver mais nœmeros do que B, signi(cid:28)ca que n > m, entªo os nœmeros
(cid:28)nais que sobrarªo em A, sem sofrerem compara(cid:231)ªo, serªo inseridos, na ordem em que estªo,
nas posi(cid:231)ıes (cid:28)nais de C, come(cid:231)ando pela posi(cid:231)ªo C[2m]. Mas se B tiver mais nœmeros do
que A, signi(cid:28)ca que n < m, entªo os nœmeros (cid:28)nais que sobrarªo em B, sem sofrerem com-
para(cid:231)ªo, serªo inseridos, na ordem em que estªo, nas posi(cid:231)ıes (cid:28)nais de C, come(cid:231)ando pela
posi(cid:231)ªo C[2n]. Finalmente, o novo vetor C serÆ retornado como solu(cid:231)ªo.

Exemplo 50. Para ordenar o vetor C = [
ordena(cid:231)ªo por intercala(cid:231)ªo farÆ o seguinte:

C[1]
5 ,

C[2]
6 ,

C[3]
7 ,

C[4]
8 ,

C[5]
1 ,

C[6]
6 ], o algoritmo de

A[3]=C[3]
1. Considerar o vetores A = [
7
2. Compara 5 com 1 e ocupa a posi(cid:231)ªo C[1] com 1.
A[2]=C[2]
6

A[1]=C[1]
,
5

A[4]=C[4]
8

A[1]=C[1]
5

A[3]=C[3]
7

A[2]=C[2]
6

,

,

,

,

] e B1 = [

3. Em A = [
C[2] com 5.

A[4]=C[4]
8

,

] e B = [

B[1]=C[5]
1

B[2]=C[6]
6

].

,

B1[1]=C[6]
6

], compara 5 com 6 e ocupa

4. Em A1 = [
com o 6 de C[2].

A1[1]=C[2]
6

A1[2]=C[3]
7

,

,

A1[3]=C[4]
8

] e B1 = [

B1[1]=C[6]
6

], compara 6 com 6 e ocupa C[3]

5. Em A2 = [

A2[1]=C[3]
7

,

6. Sobram 7 e 8, em A2 = [
C[1]
1 ,

7. Retorna o vetor C = [

] e B1 = [

A2[2]=C[4]
8
A2[1]=C[3]
7
C[2]
5 ,

,
C[3]
6 ,

B1[1]=C[6]
6
A2[2]=C[4]
8
C[4]
6 ,

C[5]
7 ,

C[6]
8 ].

], compara 7 com 6 e ocupa C[4] com 6.

]. Entªo 7 ocupa C[5] e 8 ocupa C[6].

Ordena(cid:231)ªo por Intercala(cid:231)ªo

59

(cid:136) Entrada: O tamanho n do vetor A, bem como seus nœmeros, o tamanho m do vetor B

e seus nœmeros.

(cid:136) Sa(cid:237)da: O vetor C, composto por todos os nœmeros de A e de B, ordenado por completo.

(cid:136) Passo 1: Considere i = 1, k = 1 e j = 1.

Observa(cid:231)ªo 31. i indicarÆ a posi(cid:231)ªo em A, k indicarÆ a posi(cid:231)ªo em C e j a posi(cid:231)ªo em
B.

(cid:21) Passo 2 (loop): Enquanto qualquer uma das posi(cid:231)ıes A[i] e B[j] nªo deixar de

existir, fa(cid:231)a:

* Passo 3: Se A[i] (cid:54) B[j] entªo

• Passo 4: Armazene o nœmero da posi(cid:231)ªo A[i] na posi(cid:231)ªo C[k].
• Passo 5: Incremente i e k e volte a executar a partir do passo 2.

* Passo 6: Senªo se A[i] > B[j] entªo

• Passo 7: Armazene o nœmero da posi(cid:231)ªo B[j] na posi(cid:231)ªo C[k].
• Passo 8: Incremente j e k e volte a executar a partir do passo 2.

(cid:21) Passo 9 (loop): Enquanto a posi(cid:231)ªo A[i] existir e a posi(cid:231)ªo B[j] nªo existir fa(cid:231)a:

* Passo 10: Armazene o nœmero da posi(cid:231)ªo A[i] na posi(cid:231)ªo C[k].
* Passo 11: Incremente i e k e volte a executar a partir do passo 9.

(cid:21) Passo 12 (loop): Enquanto a posi(cid:231)ªo A[i] nªo existir e a posi(cid:231)ªo B[j] existir fa(cid:231)a:

* Passo 13: Armazene o nœmero da posi(cid:231)ªo B[j] na posi(cid:231)ªo C[k].
* Passo 14: Incremente j e k e volte a executar a partir do passo 12.

(cid:136) Passo 15: Retorne o vetor C, com seus n + m nœmeros jÆ dispostos em ordem crescente.

Exemplo 51. Aplicando os passos do algoritmo acima no vetor C = [
obtØm-se:

C[1]
2 ,

C[2]
4 ,

C[3]
1 ,

C[4]
2 ,

C[5]
3 ],

(a)

(b)

(c)

A[1]
2

A[2]
4

B[1]
1
Levado a C[1]

B[2]
2

B[3]
3

C = [

C[1]
1 , C[2], C[3], C[4], C[5]]

B(cid:48)[2]
3

B(cid:48)[1]
2

A[2]
4

A[1]
2
Levado a C[2]
C[2]
C[1]
2 , C[3], C[4], C[5]]
1 ,

C = [

A(cid:48)[1]
4

B(cid:48)[1]
2
Levado a C[3]

B(cid:48)[2]
3

(d)

(e)

C = [

C[1]
1 ,

C[2]
2 ,

C[3]
2 , C[4], C[5]]

A(cid:48)[1]
4

C = [

C[1]
1 ,

B(cid:48)(cid:48)[1]
3
Levado a C[4]
C[3]
C[2]
2 ,
2 ,

C[4]
3 , C[5]]

A(cid:48)[1]
4
Levado a C[4]

C = [

C[1]
1 ,

C[2]
2 ,

C[3]
2 ,

C[4]
3 ,

C[5]
4 ]

Por pseudoc(cid:243)digo, tem-se:

60

1 Procedimento MERGE (n, A, m, B)
2 i := 1, j := 1 e k := 1.
3 Enquanto i (cid:54) n e j (cid:54) m fa(cid:231)a
Se ai (cid:54) bj entªo fa(cid:231)a
4
5
6
7
8Senªo fa(cid:231)a
9
10
11
12FimSe

ck := bj
j := j + 1
k := k + 1

ck := ai
i := i + 1
k := k + 1

Para p := j atØ m, fa(cid:231)a

FimPara

ck := bp
k := k + 1

13 FimEnquanto
14 Se i > n entªo fa(cid:231)a
15
16
17
18
19 Senªo fa(cid:231)a
20
21
22
23
24 FimSe

ck := ap
k := k + 1

FimPara

Para p := i atØ n, fa(cid:231)a

Ao serem executadas as instru(cid:231)ıes das linhas 3 e 4, do algoritmo acima, ocorrem
trŒs compara(cid:231)ıes. Se a instru(cid:231)ªo da linha 3 assumir valor falso, entªo ocorrerÆ apenas duas
compara(cid:231)ıes. Neste caso, pode-se obter a terceira compara(cid:231)ªo se for contada a instru(cid:231)ªo da
linha 14. A quantidade de vezes em que as instru(cid:231)ıes das linhas 3 e 4 ocorrem nªo supera
n. Entªo, no caso das linhas 3, 4 e 8, pode-se dizer que o nœmero mÆximo de compara(cid:231)ıes Ø
3n = O(n). Portanto, o custo desse algoritmo Ø O(n).

Para ordenar um vetor C, em ordem crescente, por intercala(cid:231)ªo, o qual possa
nªo apresentar dois vetores ordenados, A e B, utiliza-se o procedimento Merge-Sort, recur-
sivamente, para primeiramente dividir o vetor original em vÆrios vetores menores (etapa de
divisªo), depois vai combinando sempre dois a dois vetores (etapa de conquista), para neles
aplicar o procedimento de ordena(cid:231)ªo por intercala(cid:231)ªo (Merge).

Exemplo 52. Na ordena(cid:231)ªo dos elementos do vetor C = [
o procedimento merge-sort farÆ o seguinte:

C[1]
1 ,

C[2]
3 ,

C[3]
2 ,

C[4]
7 ,

C[5]
6 ,

C[6]
8 ,

C[7]
4 ],

1. Divide C em dois vetores, A = [

A[1]=C[1]
1

,

A[2]=C[2]
3

,

A[3]=C[3]
2

,

A[4]=C[4]
7

] e B = [

B[1]=C[5]
,
6

B[2]=C[6]
8

,

B[3]=C[7]
4

].

2. Divide A em dois vetores, A = [

A[1]=C[1]
1

A[2]=C[2]
3

,

] e B = [

B[1]=C[3]
2

,

3. Divide A = [
4. Veri(cid:28)ca que A e B sªo unitÆrios e os mescla, por meio do procedimento merge, retornando

] em dois vetores, A = [

] e B = [

].

,

A[1]=C[1]
1

A[2]=C[2]
3

A[1]=C[1]
1

o vetor ordenado A = [

A[2]
3 ].

A[1]
1 ,
B[1]=C[3]
2

B[2]=C[4]
7

5. Divide o vetor B = [
6. Veri(cid:28)ca que A e B sªo unitÆrios e os mescla, por meio do procedimento merge, retornando

] em dois vetores, A = [

] e B = [

].

,

o vetor ordenado B = [

B[1]
2 ,

B[2]
7 ].

7. Mescla os vetores A = [

A[1]
1 ,

A[2]
3 ] e B = [

fornecendo o vetor ordenado A = [

A[1]
1 ,

A[2]
2 ,

B[1]
2 ,
A[3]
3 ,

B[2]
7 ], por meio do procedimento merge,

A[4]
7 ].

A[1]=C[3]
2

B[1]=C[4]
7

B[2]=C[4]
].
7
B[1]=C[2]
3

8. Divide B = [

B[1]=C[5]
6

B[2]=C[6]
8

,

B[3]=C[7]
4

,

] em dois vetores, A = [

A[1]=C[5]
6

A[2]=C[6]
8

,

] e B =

B[1]=C[7]
4

11[

].

61

9. Divide A = [
10. Veri(cid:28)ca que A e B sªo unitÆrios e os mescla, por meio do procedimento merge, retornando

] em dois vetores, A = [

] e B = [

].

,

A[1]=C[5]
6

B[1]=C[6]
8

A[1]=C[5]
6

A[2]=C[6]
8

o vetor ordenado A = [

11. Veri(cid:28)ca que B = [

A[1]
6 ,
B[1]=C[7]
4

A[2]
8 ].

] Ø unitÆrio e o mescla com o vetor A = [

A[1]
6 ,

A[2]
8 ], por meio do

procedimento merge, retornando o vetor ordenado B = [
B[2]
6 ,

12. Mescla os vetores A = [

B[1]
4 ,

A[2]
2 ,

A[1]
1 ,

A[3]
3 ,

B[1]
4 ,

B[2]
6 ,

B[3]
8 ].

A[4]
7 ] e B = [
C[2]
C[1]
2 ,
1 ,

B[3]
8 ], por meio do procedimento

C[3]
3 ,

C[4]
4 ,

C[5]
6 ,

C[6]
7 ,

C[7]
8 ].

(cid:4)

merge, retornando o vetor ordenado C = [

Dando um carÆter mais formal para esse procedimento, obtØm-se o algoritmo

abaixo.

Merge-Sort

(cid:136) Entrada: O tamanho n do vetor C, bem como seus nœmeros.

(cid:136) Sa(cid:237)da: O vetor C ordenado.

(cid:136) Passo 1: Se C for unitÆrio (n = 1) entªo pare.

Observa(cid:231)ªo 32. Neste passo, (cid:28)naliza-se a etapa de divisªo do vetor atual, ao se obter
um vetor unitÆrio. Essa (cid:28)naliza(cid:231)ªo, se ocorrida para o vetor A, darÆ in(cid:237)cio (cid:224) nova
etapa de divisªo do vetor atual B. Agora se ocorrida para o vetor B, darÆ in(cid:237)cio ao
procedimento Merge, para mesclar A e B atuais, retornando um s(cid:243) vetor ordenado.

(cid:136) Passo 2: Mas se C nªo for unitÆrio, fa(cid:231)a m assumir o valor da expressªo (cid:6) n

2

(cid:7).

Observa(cid:231)ªo 33. m Ø uma variÆvel auxiliar usada para a divisªo do vetor que se quer
ordenar em dois vetores A e B.

(cid:21) Passo 3: Considere i = 0.

Observa(cid:231)ªo 34. i indica a posi(cid:231)ªo no vetor atual, que se deseja ordenar.

* Passo 4: Armazene o nœmero da posi(cid:231)ªo i em A[i].
* Passo 5: Incremente i. Se i < m entªo volte a executar a partir do passo 4.

Caso contrÆrio, execute o pr(cid:243)ximo passo.
Observa(cid:231)ªo 35. Os passos 4 e 5 sªo responsÆveis por fornecer o vetor A.

(cid:21) Passo 6: Considere i = m.

* Passo 7: Armazene o nœmero da posi(cid:231)ªo i em B[i − m].
* Passo 8: Incremente i. Se i < n entªo volte a executar a partir do passo 7.

Caso contrÆrio, execute o pr(cid:243)ximo passo.

62

Observa(cid:231)ªo 36. Os passos 7 e 8 sªo responsÆveis por fornecer o vetor B.

(cid:21) Passo 9: Aplique novamente o procedimento Merge-Sort no vetor A.

(cid:21) Passo 10: Aplique novamente o procedimento Merge-Sort no vetor B.

(cid:21) Passo 11: Aplique o procedimento Merge nos vetores atuais, A e B, jÆ ordenados,

para retornar um s(cid:243) vetor ordenado.

(cid:4)

O teste de mesa realizado no exemplo abaixo Ø longo, porØm necessÆrio, para que
se possa entender cada passo e como cada nœmero Ø organizado de forma a retornar o vetor
C totalmente ordenado.

Exemplo 53. Aplicando o procedimento Merge-Sort no vetor C = [
para ordenÆ-lo, obtØm-se:

C[0]
38 ,

C[1]
27 ,

C[2]
43 ,

C[3]
3 ,

C[4]
9 ],

(cid:136) (1) Entrada: n = 5 e c0 = 38, c1 = 27, c2 = 43, c3 = 3 e c4 = 9.

(cid:136) Sa(cid:237)da: O vetor C ordenado.

(cid:136) Passo 1: O vetor C nªo Ø unitÆrio. Entªo continue.
(cid:136) Passo 2: m assume o valor da expressªo (cid:6) n

(cid:7) = (cid:6) 5

2

2

(cid:7) = (cid:100) 2, 5 (cid:101) = 3.

(cid:21) Passo 3: i = 0.

* Passo 4: 38 Ø o nœmero da posi(cid:231)ªo i = 0. Este nœmero agora Ø armazenado

na posi(cid:231)ªo A[i] = A[0], do vetor A.

* Passo 5: i Ø incrementado e passa a valer 1, que Ø menor do que m = 3. Entªo

volte a executar a partir do passo 4.

* Passo 4: 27 Ø o nœmero da posi(cid:231)ªo i = 1. Este nœmero Ø armazenado na

posi(cid:231)ªo A[i] = A[1].

* Passo 5: i Ø incrementado e passa a valer 2, que Ø menor do que m = 3. Entªo

volte a executar a partir do passo 4.

* Passo 4: 43 Ø o nœmero da posi(cid:231)ªo i = 2. Este nœmero Ø armazenado na

posi(cid:231)ªo A[i] = A[2].

* Passo 5: i Ø incrementado e passa a valer 3, que Ø que Ø igual a m. Entªo

execute o pr(cid:243)ximo passo.

(cid:21) Passo 6: i = m = 3.

* Passo 7: 3 Ø o nœmero da posi(cid:231)ªo i = 3. Este nœmero Ø armazenado na posi(cid:231)ªo

B[i − m] = B[3 − 3] = B[0].

* Passo 8: i Ø incrementado e passa a valer 4, que Ø menor do que n = 5. Entªo

volte a executar a partir do passo 7.

* Passo 7: 9 Ø o nœmero da posi(cid:231)ªo i = 4. Este nœmero Ø armazenado na posi(cid:231)ªo

B[i − m] = B[4 − 3] = B[1].

* Passo 8: i Ø incrementado e passa a valer 5, que Ø igual a n. Entªo execute o

pr(cid:243)ximo passo.

Observa(cid:231)ªo 37. Vetores obtidos: A = [

A[0]
38 ,

A[1]
27 ,

A[2]
43 ] e B = [

B[0]
3 ,

B[1]
9 ].

63

(cid:21) (2) Passo 9: Volte a aplicar o procedimento Merge-Sort no vetor A = [
(cid:21) Entrada: n1 = 3 e a0 = 38, a1 = 27 e a2 = 43.
(cid:21) Sa(cid:237)da: O vetor A ordenado.
(cid:21) Passo 1: O vetor A nªo Ø unitÆrio. Entªo continue.
(cid:7) = (cid:6) 3
(cid:21) Passo 2: m1 assume o valor da expressªo (cid:6) n1

(cid:7) = (cid:100) 1, 5 (cid:101) = 2.

2

2

A[0]
38 ,

A[1]
27 ,

A[2]
43 ].

* Passo 3: i = 0.

• Passo 4: 38 Ø o nœmero da posi(cid:231)ªo i = 0. Este nœmero Ø armazenado na

posi(cid:231)ªo A[i] = A[0], de A.

• Passo 5: i Ø incrementado e passa a valer 1, que Ø menor do que m1 = 2.

Entªo volte a executar a partir do passo 4.

• Passo 4: 27 Ø o nœmero da posi(cid:231)ªo i = 1. Este nœmero Ø armazenado na

posi(cid:231)ªo A[i] = A[1], de A.

• Passo 5: i Ø incrementado e passa a valer 2, que Ø igual a m1. Entªo

execute o pr(cid:243)ximo passo.

* Passo 6: i = m1 = 2.

• Passo 7: 43 Ø o nœmero da posi(cid:231)ªo i = 2. Este nœmero Ø armazenado na

posi(cid:231)ªo B[i − m1] = B[2 − 2] = B[0].

• Passo 8:

i Ø incrementado e passa a valer 3, que Ø igual a n1. Entªo

execute o pr(cid:243)ximo passo.

Observa(cid:231)ªo 38. Vetores obtidos: A = [

A[0]
38 ,

A[1]
27 ] e B = [

B[0]
43 ].

* Passo 9: Volte a aplicar o procedimento Merge-Sort no vetor A = [
* Entrada: n2 = 2 e a0 = 38, a1 = 27.
* Sa(cid:237)da: O vetor A ordenado.
* Passo 1: O vetor A nªo Ø unitÆrio. Entªo continue.
(cid:7) = (cid:6) 2
* Passo 2: m2 assume o valor da expressªo (cid:6) n2

(cid:7) = (cid:100) 1 (cid:101) = 1.

2

2

A[0]
38 ,

A[1]
27 ].

. Passo 3: i = 0.

∗ Passo 4: 38 Ø o nœmero da posi(cid:231)ªo i = 0. Este nœmero Ø armazenado
na posi(cid:231)ªo A[i] = A[0], de A.
∗ Passo 5:
execute o pr(cid:243)ximo passo.

i Ø incrementado e passa a valer 1, que Ø igual a m2. Entªo

. Passo 6: i = m2 = 1.

∗ Passo 7: 27 Ø o nœmero da posi(cid:231)ªo i = 1. Este nœmero Ø armazenado
na posi(cid:231)ªo B[i − m2] = B[1 − 1] = B[0].
∗ Passo 8:
execute o pr(cid:243)ximo passo.

i Ø incrementado e passa a valer 2, que Ø igual a n2. Entªo

64

Observa(cid:231)ªo 39. Vetores obtidos: A = [

A[0]
38 ] e B = [

B[0]
27 ].

. Passo 9: Volte a aplicar o procedimento Merge-Sort no vetor A = [

A[0]
38 ].

- Entrada: n3 = 2 e a0 = 38.
- Sa(cid:237)da: O vetor A ordenado.
- Passo 1: O vetor A Ø unitÆrio. Entªo pare, pois ele jÆ estÆ ordenado.

. Passo 10: Volte a aplicar o procedimento Merge-Sort no vetor B = [

B[0]
27 ].

- Entrada: n4 = 1 e b0 = 27.
- Sa(cid:237)da: O vetor B ordenado.
- Passo 1: O vetor B Ø unitÆrio. Entªo pare, pois ele jÆ estÆ ordenado.

. Passo 11: O procedimento Merge Ø aplicado nos vetores A = [

A[0]
38 ] e B = [
A[0]
da observa(cid:231)ªo 39, mas jÆ ordenados, fornecendo o vetor ordenado A = [
27 ,
que serÆ utilizado pelo procedimento Merge do procedimento iniciado em (2).

B[0]
27 ],
A[1]
38 ],

* Passo 10: Volte a aplicar o procedimento Merge-Sort no vetor B = [

B[0]
43 ], da

observa(cid:231)ªo 38.

* Entrada: n5 = 1 e b0 = 43.
* Sa(cid:237)da: O vetor B ordenado.
* Passo 1: O vetor B Ø unitÆrio. Entªo pare, pois ele jÆ estÆ ordenado.
A[1]
38 ] e B =

* Passo 11: O procedimento Merge Ø aplicado nos vetores A = [

A[0]
27 ,

B[0]
43 ], da observa(cid:231)ªo 38, mas jÆ ordenados, fornecendo o vetor ordenado A =
[
A[0]
[
27 ,
iniciado em (1).

A[2]
43 ], que serÆ utilizado pelo procedimento Merge do procedimento

A[1]
38 ,

(cid:21) Passo 10: Volte a aplicar o procedimento Merge-Sort no vetor B = [

B[0]
3 ,

B[1]
9 ], da

observa(cid:231)ªo 37.

(cid:21) Entrada: n6 = 2 e b0 = 3 e b1 = 9.
(cid:21) Sa(cid:237)da: O vetor B ordenado.

(cid:21) Passo 1: O vetor B nªo Ø unitÆrio. Entªo continue.
* Passo 2: m3 assume o valor da expressªo (cid:6) n6

(cid:7) = (cid:6) 2

(cid:7) = (cid:100) 1 (cid:101) = 1.

2

2

. Passo 3: i = 0.

∗ Passo 4: 3 Ø o nœmero da posi(cid:231)ªo i = 0. Este nœmero Ø armazenado
na posi(cid:231)ªo A[i] = A[0], de A.
∗ Passo 5:
execute o pr(cid:243)ximo passo.

i Ø incrementado e passa a valer 1, que Ø igual a m3. Entªo

. Passo 6: i = m3 = 1.

∗ Passo 7: 9 Ø o nœmero da posi(cid:231)ªo i = 1. Este nœmero Ø armazenado
na posi(cid:231)ªo B[i − m3] = B[1 − 1] = B[0].
∗ Passo 8:
execute o pr(cid:243)ximo passo.

i Ø incrementado e passa a valer 2, que Ø igual a n6. Entªo

65

Observa(cid:231)ªo 40. Vetores obtidos: A = [

A[0]
3 ] e B = [

B[0]
9 ].

. Passo 9: Volte a aplicar o procedimento Merge-Sort no vetor A = [

A[0]
3 ].

. Entrada: n7 = 1 e a0 = 3.
. Sa(cid:237)da: O vetor A ordenado.
. Passo 1: O vetor A Ø unitÆrio. Entªo pare, pois ele jÆ estÆ ordenado.

. Passo 10: Volte a aplicar o procedimento Merge-Sort no vetor B = [

B[0]
9 ].

. Entrada: n8 = 1 e b0 = 9.
. Sa(cid:237)da: O vetor B ordenado.
. Passo 1: O vetor B Ø unitÆrio. Entªo pare, pois ele jÆ estÆ ordenado.

. Passo 11: O procedimento Merge Ø aplicado nos vetores A = [

A[0]
3 ] e B = [
B[0]
3 ,
da observa(cid:231)ªo 40, mas jÆ ordenados, fornecendo o vetor ordenado B = [
que serÆ utilizado pelo procedimento Merge do procedimento iniciado em (1).

B[0]
9 ],
B[1]
9 ],

(cid:21) Passo 11: O procedimento Merge Ø aplicado nos vetores A = [

A[0]
27 ,

A[1]
38 ,

A[2]
43 ] e B =

B[0]
3 ,
C[0]
3 ,

[

[

B[1]
9 ], da observa(cid:231)ªo 37, mas jÆ ordenados, fornecendo o vetor ordenado C =
C[1]
9 ,

C[1]
43 ], que Ø a sa(cid:237)da.

C[1]
27 ,

C[1]
38 ,

De forma simpli(cid:28)cada, tem-se:

Figura 4.2.1: Merge-Sort

(cid:4)

Por pseudoc(cid:243)digo, tem-se:

66

Pare, pois o vetor ou vetor jÆ estÆ ordenado.

2

(cid:7)

1 Procedimento Merge-Sort(n, C)
2 Se n = 1 entªo
3
4 Senªo Se n > 1, entªo
m := (cid:6) n
5
Para i = 0 atØ m − 1, fa(cid:231)a
6
: C[i]
7
Para i = m atØ n − 1, fa(cid:231)a
8
9
10
11
12
13FimSe

B[i − m]
Merge-Sort(m, A)
Merge-Sort(n − m, B)
Merge(m, A, n − m, B)

: C[i]

A[i]

4.2.4.1 Custo da Ordena(cid:231)ªo Por Intercala(cid:231)ªo (Pior Caso)

Dos procedimentos Merge e Merge-Sort, obtØm-se a seguinte recorrŒncia:

T (n) =

(cid:40)

O(1),
T (cid:0)(cid:6) n

2

(cid:7)(cid:1) + T (cid:0)(cid:4) n

2

(cid:5)(cid:1) + O(n),

se n = 1
se n > 1

,

(cid:7) e T (cid:4) n
na qual O(1) Ø o custo da instru(cid:231)ªo da linha 2 do procedimento Merge-Sort, T (cid:6) n
sªo os respectivos tempos de execu(cid:231)ªo das instru(cid:231)ıes posicionadas nas linhas 10 e 11, desse
algoritmo, e O(n) Ø o custo do procedimento Merge (linha 12).

(cid:5)

2

2

Para a anÆlise assint(cid:243)tica O, pode-se considerar n = 2k. Assim,

T (2k) =

(cid:40)

1,
2.T (cid:0)2k−1(cid:1) + 2k,

se k = 0
se k > 0

,

Logo, para k > 0, tem-se:

T (cid:0)2k(cid:1) = 2T (cid:0)2k−1(cid:1) + 2k

...

= 22T (cid:0)2k−2(cid:1) + 2 · 2k−1 + 2k = 22T (cid:0)2k−2(cid:1) + 2 · 2k
= 23T (cid:0)2k−3(cid:1) + 22 · 2k−2 + 2 · 2k = 23T (cid:0)2k−3(cid:1) + 3 · 2k
...
= 2kT (cid:0)2k−k(cid:1) + k · 2k
= 2kT (1) + k · 2k
= 2k + k · 2k
= 2kk + 2k

Logo,

T (n) = T (cid:0)2k(cid:1) = 2kk + 2k = n.log2n + n ⇒

67

T (n) = n.log2n + n.

Para n (cid:62) 2, tem-se:

nlog2n + n = n (log2n + 1) (cid:54) n. (log2n + log2n) = 2n · log2n.

Portanto,

T (n) = O (n.log2n).

68

Cap(cid:237)tulo 5

Considera(cid:231)ıes Finais

Um aluno sabendo construir um pseudoc(cid:243)digo e tendo habilidade com determi-
nada linguagem de programa(cid:231)ªo, pode ser estimulado, pelo professor, a implementar algo-
ritmos computacionais, para solucionar problemas da matemÆtica elementar. AlØm disso,
poderÆ analisar os algoritmos que criou para solucionar um mesmo problema, por meio de
fun(cid:231)ıes que calculam o nœmero de passos requeridos por cada algoritmo, sendo capaz de
escolher o que possuir a menor ordem de crescimento, para uma entrada su(cid:28)cientemente
grande.

Trabalhando com o teste de mesa para cada algoritmo implementado, e tentando
sempre descobrir mØtodos e(cid:28)cientes para solucionar problemas da matemÆtica bÆsica, o aluno
terÆ a oportunidade de desenvolver seu racioc(cid:237)nio, podendo assim abordar conteœdos mate-
mÆticos com agilidade.

O tema aqui abordado propıe a sua integra(cid:231)ªo com o curr(cid:237)culo da educa(cid:231)ªo bÆsica,
tanto por tratar de matemÆtica bÆsica como por apresentar uma aplica(cid:231)ªo da matemÆtica
num contexto real computacional.

69

ReferŒncias BibliogrÆ(cid:28)cas

[1] ALBERTSON, Michael O.; HUTCHINSON, Joan P.. DISCRETE MATHEMATICS

WITH ALGORITHMS. John Wiley & Sons, 1988.

[2] BARROSO, Le(cid:244)nidas Concei(cid:231)ªo; BARROSO, Magali Maria de Araœjo; FILHO, Frede-
rico Ferreira Campos; CARVALHO, MÆrcio Luiz Bunte de e MAIA, Miriam Louren(cid:231)o.
C`LCULO NUM(cid:201)RICO (COM APLICA˙(cid:213)ES), 2“ edi(cid:231)ªo. Editora Harbra LTDA,
1987.

[3] BOLDRINI, JosØ Luiz; COSTA, Sueli I. Rodrigues; FIGUEIREDO, Vera Lœcia e WETZ-

LER, Henry G. `LGEBRA LINEAR -3“ Edi(cid:231)ªo. Editora Harbra LTDA, 1986.

[4] COUTINHO, S. C. Nœmeros Inteiros e Criptogra(cid:28)a RSA, Cole(cid:231)ªo Computa(cid:231)ªo e Ma-

temÆtica, SBM e IMPA, 2000.

[5] DOMINGUES, Hygino H. e IEZZI, Gelson. `lgebra Moderna. Editora Atual, 1982.

[6] ESQUINCA, Josiane C. Pedrini. AritmØtica: C(cid:243)digo de Barras e Outras Aplica(cid:231)ıes de
CongruŒncias. Trabalho de Conclusªo de Curso, 2013. MatemÆtica em Rede Nacional -
Mestrado Pro(cid:28)ssional. Universidade Federal de Mato Grosso do Sul.

[7] GUIDORIZZI, Hamilton Luiz, UM CURSO DE C`LCULO, 5“ edi(cid:231)ªo, volume 1. Livros

TØcnicos e Cient(cid:237)(cid:28)cos Editora S.A., 1985.

[8]

IEZZI, Gelson. FUNDAMENTOS DE MATEM`TICA ELEMENTAR, 5“ edi(cid:231)ªo, vo-
lume 6. Atual Editora, 1985.

[9] JAMIL, George Leal e GOUV˚A, Bernardo Andrade. Linux Para Pro(cid:28)ssonais: Do
BÆsico (cid:224) Conexªo em Redes. Axcel Books do Brasil Editora LTDA, 2006. ISBN: 85-
7323-252-8.

[10] KNUTH, Donald Ervin. THE ART OF COMPUTER PROGRAMMING, 2d edition,

volume 2. ADDISON-WESLEY PUBLISHING COMPANY, 1938.

[11] LEITHOLD, Louis. O CÆlculo com Geometria Anal(cid:237)tica, 3“ edi(cid:231)ªo, volumes 1 e 2. Edi-

tora Harbra LTDA, 1994.

[12] LIMA, Elon Lages, Curso de AnÆlise (Projeto Euclides), volume 1, 11“ edi(cid:231)ªo. Associ-
a(cid:231)ªo Insituto Nacional de MatemÆtica Pura e Aplicada, 2004. ISBN: 85-244-0118-4.

70

[13] LUCCHESI, ClÆudio L.; SIMON, Imre Simon Istvan; SIMON, Janos; KOWALTOWSKI,
Tomasz. Aspectos Te(cid:243)ricos da Computa(cid:231)ªo (Projeto Euclides). Instituto de MatemÆtica
Pura e Aplicada, 1979.

[14] MOREIRA, Carlos Gustavo T. de Araœjo; MARTINEZ, Fabio E. Brochero e SALDA-
NHA, Nicolau Cor(cid:231)ªo. T(cid:211)PICOS DE TEORIA DOS N(cid:218)MEROS (Cole(cid:231)ªo Profmat).
Sociedade Brasileira de MatemÆtica, 1“ edi(cid:231)ªo, 2012.

[15] OLIVEIRA, Maykon Costa de. AritmØtica: Criptogra(cid:28)a e Outras Aplica(cid:231)ıes de Con-
gruŒncia. Trabalho de Conclusªo de Curso, 2013. MatemÆtica em Rede Nacional - Mes-
trado Pro(cid:28)ssional. Universidade Federal de Mato Grosso do Sul.

[16] ROSEN, Kenneth H. Discret Mathematics and its applications, 3rd ed. McGraw-Hill,

Inc., 1995.

[17] RUGGIERO, MÆrcia A. Gomes e LOPES, Vera Lœcia da Rocha. CÆlculo NumØrico -
Aspectos Te(cid:243)ricos e Computacionais, 2“ Edi(cid:231)ªo. MAKRON Books do Brasil Editora
Ltda, 1997. ISBN: 85-346-0204-2.

[18] VELOSO, Paulo A. S. e TOSCANI, Laira Vieira. Complexidade de Algoritmos: AnÆlise,

Projeto e MØtodos. Editora Sagra Luzzatto, 1“ edi(cid:231)ªo, 2001.

[19] http://www.ime.usp.br/~song/mac5710/slides/01complex.pdf,

acessado

em

25/09/2014.

[20] http://pt.wikipedia.org/wiki/Complexidade_computacional, acessado em 25/09/2014.

[21] http://www.cin.ufpe.br/~joa/menu_options/school/cursos/ppd/aulas/complexidade.pdf,

acessado em 25/09/2014.

[22] http://www.inf.ufrgs.br/~prestes/Courses/Complexity/aula1.pdf,

acessado

em

25/09/2014.

ApŒndice

A.1 Implementa(cid:231)ªo do algoritmo intercalar, para dois vetores de mesmo tamanho,
em linguagem shell

71

tamanho

echo "Digite
o nœmero da
posi(cid:231)ªo $i no segundo arranjo:"

nœmero da
o
echo "Digite
posi(cid:231)ªo $i no primeiro arranjo:"

com o

1 #!/bin/sh
2 echo "Entre
3 dos dois vetores:"
4 read n
5 for((i=0;i<n;i++))
6 do
7
8
9 read a[$i]
10 done
11 for((i=0;i<n;i++))
12 do
13
14
15 read b[$i]
16 done
17 echo "Merge Sort"
18 j=0
19 k=0
20 i=0
21 let num=n+n
22 for((x=0;x<num;x++))
23 do
24
25
26
27

i=$(expr $i+1)
j=$(expr $j+1)

if [ ${a[$j]} -le ${b[$k]} ]
then c[$i]=${a[$j]}

break

c[$i]=${b[$k]}
i=$(expr $i+1)
k=$(expr $k+1)

28 else
29
30
31
32 (cid:28)
33 if [ $j -eq $n -o $k -eq $n ]
34 then
35
36 (cid:28)
37 done
38 for((;j<n;))
39 do
40
41
42
43 done
44 for((;k<n;))
45 do
46
47
48
49 done
50 echo "Nœmeros ordenados:"
51 for((i=0;i<10;i++))
52 do
53
54 done

c[$i]=${b[$k]}
i=$(expr $i+1)
k=$(expr $k+1)

c[$i]=${a[$j]}
i=$(expr $i+1)
j=$(expr $j+1)

echo ${c[$i]}

A.2 Divisªo Euclidiana - Shell Script

1 #!/bin/bash
2 echo (cid:16)Digite o valor de a (dividendo):(cid:17);
3 read a
4 echo (cid:16)Digite o valor de b (divisor):(cid:17);
5 read b
6 q=‘expr $a / $b‘
7 r=‘expr $a - $b \* $q‘
8 echo (cid:16)O resto da divisªo de $a por $b Ø igual a $r.(cid:17);
9 if [ $r -eq 0 ] then
10

echo (cid:16)$b divide $a, pois o resto Ø igual a zero.(cid:17);

11 else
12
13 (cid:28)

echo (cid:16)$b nªo divide $a, pois o resto Ø diferente de zero.(cid:17);

A.3 Algoritmo de Euclides - Shell Script

72

echo (cid:16)($a, $b) = 1.(cid:17);
exit

1 #!/bin/bash
2 echo (cid:16)Procedimento: Algoritmo de Euclides - (a, b).(cid:17);
3 echo (cid:16)Digite o valor de a:(cid:17);
4 read a
5 echo (cid:16)Digite o valor de b:(cid:17);
6 read b
7 if [ $a == 1 ] then
8
9
10 elif [ $b == 1 ] then
11
12
13 (cid:28)
14 if [ $a -le $b ] then
15
x=$a
16 else
17

echo ($a, $b) = 1.(cid:17);
exit

x=$b

18 (cid:28)
19 m=$a
20 n=$b
21 q=‘expr $a / $b‘
22 r=‘expr $a - $b \* $q‘
23 a=$b
24 b=$r
25 while [ $r != 0 ];
26 do
27
28
29
30
31
32 done
33 echo (cid:16)($m, $n) = $x.(cid:17);

x=$r
q=‘expr $a / $b‘
r=‘expr $a - $b \* $q‘
a=$b
b=$r

A.4 Algoritmo Estendido de Euclides - Shell Script

1 #!/bin/bash
2 echo (cid:16)Algoritmo Estendido de Eucli-
3 des para o cÆlculo do mdc(a, b).(cid:17);
4 echo (cid:16)Digite o valor de a:(cid:17);
5 read a
6 echo (cid:16)Digite o valor de b:(cid:17);
7 read b
8 if [ $b == 0 ] then
9 d=$a
10 x=1;
11 y=0;
12 echo (cid:16)($a, $b) = $a, x = 1 e y = 0.(cid:17);
13 (cid:28)
14 r=$a
15 rr=$b
16 u=1;
17 v=0;
18 uu=0;

19 vv=1;
20 while [ $rr != 0 ];
21 do
22
23
24
25
26
27
28
29
30
31
32 done
33 c=‘expr $a \* $u + $b \* $v‘;
34 echo (cid:16)($a, $b) = $c.(cid:17);
35 echo (cid:16) x = $u e y = $v.(cid:17);

q=‘expr $r / $rr‘;
rs=$r
us=$u
vs=$v
r=$rr
u=$uu
v=$vv
rr=‘expr $rs - $q \* $rr‘;
uu=‘expr $us - $q \* $u‘;
vv=‘expr $vs - $q \* $vv‘;

