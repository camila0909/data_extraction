UNIVERSIDADE ESTADUAL DE PONTA GROSSA 

SETOR DE CIÊNCIAS EXATAS E NATURAIS 

PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA 

MESTRADO PROFISSIONAL - PROFMAT 

JOSÉ ROBYSON AGGIO MOLINARI 

NÚMEROS PRIMOS E A CRIPTOGRAFIA RSA 

PONTA GROSSA 

2016 

 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
JOSÉ ROBYSON AGGIO MOLINARI 

NÚMEROS PRIMOS E A CRIPTOGRAFIA RSA 

Dissertação 

apresentada 

ao 

Programa  de  Pós-Graduação  em 

Matemática  PROFMAT  -  UEPG 

como  parte  dos  requisitos  para 

obtenção  do  título  de  Mestre  em 

Matemática. 

Orientadora:  Prof.  Dra.  Fabiane 

de Oliveira 

PONTA GROSSA 

2016

 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
AGRADECIMENTOS 

À Deus pela oportunidade concedida. 

À minha mãe Ilda Aggio, pela educação e incentivo aos estudos. 

À minha noiva Franciéle Retslaff pelo amor, paciência e compreensão. 

Aos professores do PROFMAT por compartilhar seus conhecimentos. 

À minha orientadora Fabiane de Oliveira pelo apoio e orientação neste trabalho. 

Aos amigos do Mestrado pela troca de conhecimentos adquiridos.     

 
 
 
 
  
 
 
   
   
“Os encantos dessa sublime ciência se revelam 

apenas àqueles que tem coragem de irem a fundo nela” 

        Carl Friedrich Gauss 

 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

Este trabalho apresenta alguns métodos de criptografia utilizados na antiguidade e também 

o  avanço  na  maneira  de  criptografar.  O  objetivo  principal  é  o  estudo  do  Método  RSA: 

contextualização  histórica,  a  importância  dos  números  primos,  a  ineficiência  dos 

algoritmos  de  fatoração,  codificação,  decodificação,  a  segurança  e  um  estudo  sobre  a 

função  de  Euler.  Desenvolveu-se  algumas  atividades  com  conteúdos  matemáticos 

relacionadas  à  criptografia.  Desta  maneira,  espera-se  que  esta  pesquisa  possa  apresentar 

uma  metodologia  auxiliar  para  o  ensino  de  certos  conteúdos  da  matemática,  articulados 

com a utilização da criptografia.         

Palavras-chave: Criptografia RSA, Números Primos, Função de Euler.     

 
 
 
 
  
 
 
 
 
ABSTRACT 

This  study  presents  some  of  the  encryption  methods  used  in  antiquity  as  well  as  the 

advance  in  the  way  of  encrypting.  The  main  objective  of  this  work  is  the  study  of  RSA 

Method:  its  Historical  context,  the  importance  of  prime  numbers,  the  inefficiency  of 

factorization algorithms, coding, decoding, its security  and a study of the Euler function. 

Some  activities  with  mathematical  content  related  to  encryption  have  been  developed. 

Thus,  it  is  expected  that  this  research  can  present  an  auxiliary  methodology  for  teaching 

certain math content, linked to the utilization of cryptography. 

Keywords: RSA encryption, Prime Numbers, Euler function. 

 
 
 
 
  
 
 
 
SUMÁRIO 

INTRODUÇÃO ................................................................................................................. 10 
REVISÃO BIBLIOGRÁFICA ......................................................................................... 10 

CAPÍTULO 1 - NÚMEROS PRIMOS ............................................................................ 13 
1.1 NÚMEROS PERFEITOS ...................................................................................... 15 
1.2 A DISTRIBUIÇÃO DOS NÚMEROS PRIMOS .................................................. 18 
 .............................................................................. 19 
1.3 O CRESCIMENTO DE 

CAPÍTULO 2 - TEOREMAS FUNDAMENTAIS ......................................................... 20 
2.1 TEOREMA FUNDAMENTAL DA ARITMÉTICA ............................................. 20 
2.2 EXISTÊNCIA DA FATORAÇÃO ......................................................................... 20 
2.3 TEOREMA DE FERMAT ..................................................................................... 21 
2.4 TEOREMA DE WILSON (T.W.) .......................................................................... 23 

CAPÍTULO 3 - ALGORITMOS DE FATORAÇÃO .................................................... 25 
3.1 ALGORITMO DA FATORAÇÃO (MENOR FATOR) ......................................... 25 
3.2 ALGORITMO DOS FATORES (TODOS OS FATORES) ................................... 26 
3.3 INEFICIÊNCIA DOS ALGORITMOS ................................................................. 27 
3.4 FATORAÇÃO POR FERMAT .............................................................................. 27 
3.5 ALGORITMO EUCLIDIANO .............................................................................. 30 

CAPÍTULO 4 - CRIPTOGRAFIA RSA ......................................................................... 32 
4.1 A ORIGEM DO MÉTODO RSA .......................................................................... 32 
4.2 DESCRIÇÃO MATEMÁTICA DO MÉTODO .................................................... 33 
4.3 PRÉ-CODIFICAÇÃO ........................................................................................... 33 
4.4 CODIFICANDO E DECODIFICANDO .............................................................. 34 
4.5 UM CASO PARTICULAR DO RSA .................................................................... 35 
4.6 POR QUE O CASO PARTICULAR FUNCIONA? .............................................. 36 
4.7 POR QUE O RSA É SEGURO?............................................................................ 37 
4.8 ANÁLISE DA FUNÇÃO DE EULER NO MÉTODO RSA ................................ 37 
4.9 A FUNÇÃO 
 ................................................................... 38 
4.10 A ESCOLHA DOS NÚMEROS PRIMOS .......................................................... 39 
4.11 UMA ANÁLISE PARA QUEBRAR O RSA ...................................................... 39 

CAPÍTULO 5 - APLICAÇÕES EM SALA DE AULA.................................................. 41 
5.1 CRIPTOGRAFIA RSA REDUZIDA .................................................................... 41 
5.2 CRIPTOGRAFIA RSA E A FUNÇÃO DO SEGUNDO GRAU .......................... 43 
5.3 CRIPTOGRAFIA COM MATRIZES .................................................................... 45 
5.4 CRIPTOGRAFIA COM FUNÇÃO DO PRIMEIRO GRAU ................................ 46 
5.5 CRIPTOGRAFIA COM FUNÇÃO DO SEGUNDO GRAU ................................ 48 
5.6 CRIPTOGRAFIA COM FUNÇÃO EXPONENCIAL .......................................... 49 

CONSIDERAÇÕES FINAIS ............................................................................................ 52 
REFERÊNCIAS BIBLIOGRÁFICAS ............................................................................ 53 
APÊNDICE ........................................................................................................................ 54 

)(xnnmmf4)1()(2 
 
 
 
  
 
 
 
 
 
 
 
 
 
LISTA DE TABELAS 

Tabela 1: Aplicação da fórmula fatorial.............................................................................. 14 

Tabela 2: Tabela de conversão............................................................................................. 34 

Tabela 3: Código em blocos................................................................................................ 34 

Tabela 4: Código de conversão........................................................................................... 35 

Tabela 5: Código em blocos................................................................................................ 41   

Tabela 6: Código para conversão........................................................................................ 45 

Tabela 7: Alfabeto de conversão......................................................................................... 45 

 
 
 
 
  
 
 
 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1: Primos de Merssene............................................................................................. 14 

Figura 2: A função 

  no WxMáxima....................................................... 15 

Figura 3: Gráfico da função 

.................................................................. 16 

Figura 4: Valores para a função 

...................................................................... 17 

Figura 5: Valores para a função 

...................................................................... 17   

Figura 6: A função 

....................................................................... 39 

)(2)(nnnf)(2)(nnnf12)(nf56)(nfnnmmf4)1()(2 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 10   

INTRODUÇÃO 

Com  o  avanço  dos  meios  de  comunicação  e  tecnológicos,  tornou-se  necessário  o 

desenvolvimento de métodos seguros de transmissão de informações, ou seja, métodos de 

codificação  de  mensagens.  Com  isso  surgiu  a  criptografia  de  chave  pública,  também 

conhecida por criptografia assimétrica. Esse método possui duas chaves distintas que são 

utilizadas. Uma delas a chave pública, que está disponível para qualquer pessoa, ou seja, é 

de  conhecimento  de  todos  e  é  utilizada  para  codificar  as  mensagens,  que  só  poderão  ser 

decodificadas por quem possuir a chave privada correspondente. 

O  mais  conhecido  dos  métodos  de  criptografia  de  chave  pública  é  o  RSA.  Este 

método  foi  inventado  em  1977  por  R.L.  Rivest,  A.  Shamir  e  L.  Adleman,  que  na  época 

trabalhavam  no  Massachussets  Institute  of  Technology  (M.I.T.).  As 

letras  RSA 

correspondem  as  iniciais  de  cada  um  dos  inventores  do  código.  Para  o  entendimento  do 

funcionamento  do  método  RSA  serão  abordados  alguns  tópicos  de  teoria  dos  números 

relacionados a alguns problemas: como encontrar números primos; como calcular os restos 

da divisão de uma potência por um número dado; os algoritmos de fatoração; o estudo da 

teoria dos números e a descrição do Método RSA, é o principal foco deste estudo.   

REVISÃO BIBLIOGRÁFICA 

Criptografia  é  um  assunto  que  sofreu  muitas  mudanças  durante  a  civilização 

humana,  os  homens  inventavam  códigos  secretos  na  tentativa  de  transmitir  mensagens 

inteligíveis por um interceptador. 

O nome Criptografia, em grego, cryptos significa secreto, oculto e grafia significa 

escrita.  A  criptografia  estuda  os  métodos  para  codificar  uma  mensagem  de  modo  que  só 

seu destinatário legítimo consiga interpretá-la (COUTINHO, 2011), ou seja, através dela é 

possível  o  envio  de  mensagens  de  uma  forma  segura,  mesmo  uma  terceira  pessoa  tendo 

interceptado, não conseguirá ler a informação presente na mensagem. 

Um dos primeiros fatos presentes no que concerne a Criptografia, foi utilizado por 

Júlio César para comunicar-se com as legiões em combate pela Europa. A criptografia era 

feita pela substituição de uma letra pela seguinte, isto é, transladava uma casa para diante. 

Todo código necessariamente utiliza-se de duas propriedades, uma para codificar e 

 
 
 
 
 
 
     
 
 
 11   

outra para decodificar. Decodificar é o que o destinatário faz quando recebe a mensagem e 

possui a chave de decodificação. Decifrar é tentar ler a mensagem  sem  saber  a chave de 

decodificação. 

A criptografia utilizada por Júlio César era muito fácil de ser decifrada, ou qualquer 

outra forma de criptografia utilizando apenas substituição de letras por outras, “isto se deve 

ao fato  de que a  frequência média com  que cada letra  é usada em  uma língua é mais  ou 

menos constante” (COUTINHO, 2011). 

Uma maneira para contornar esse problema  foi dividir a mensagem em  grupos de 

letras  e  criptografar  a  mensagem  em  grupo,  criando  assim  um  sistema  poligráfico,  onde 

está presente as Cifras de Hill. Em 1929, Lester S. Hill publica seu livro Cryptography in 

an Algebraic Alphabet, no qual um bloco da mensagem é cifrado através de uma operação 

com matrizes. 

O procedimento com as Cifras de Hill para criptografar uma mensagem era simples, 

bastava  apenas saber  as  operações de Matrizes  (Multiplicação e o cálculo da  Inversa).  O 

remetente e o destinatário sabiam a chave (matriz), que codificava a mensagem. Com isso, 

ao receber  a mensagem  conseguiam lê-la,  caso uma terceira pessoa tivesse acesso  a essa 

mensagem era preciso saber a chave que a codificou. Mas ainda essa forma de criptografar 

não era totalmente segura, pois se fosse descoberto o significado de uma coluna da matriz 

as demais poderiam ser descobertas. 

Segundo  Iezzi  (2010),  as  matrizes  surgiram  na  escola  inglesa  Trinity  College,  em 

um artigo do Matemático Arthur Cayley (1821-1895), datado de 1858. No século III a.C.; 

os  chineses  já  desenvolviam  um  processo  de  resolução  de  sistemas  lineares  em  que 

aparecia implícita a ideia das matrizes. 

A  utilização  de  matrizes  foi  fundamental  para  o  desenvolvimento  e  agilidade  na 

análise  de  dados.  Segundo  Dante  (2010),  quando  você  preenche  um  cadastro  em  uma 

página da internet, seus dados vão imediatamente para um banco de dados, que nada mais 

é do que uma matriz que relaciona as suas informações e de todos os outros cadastrados, às 

respectivas pessoas de forma coerente e recuperável. 

A  criptografia  foi  se  aperfeiçoando  durante  os  anos  e  em  1977  foi  inventado  um 

método criado por R.L. Rivest, A. Shamir e L. Adleman conhecido por RSA. “Há vários 

outros  códigos  de  chave  pública,  mas  o  RSA  é  atualmente,  o  mais  usado  em  aplicações 

comerciais” (COUTINHO, 2011). 

O  método  RSA  é  muito  seguro,  utilizado  no  sistema  bancário  para  garantir  a 

segurança  em  transações  financeiras  pela  internet.  O  método  de  codificação  de  uma 

 
 
 
 
 
 12   

mensagem é muito simples, porém o processo inverso, o de decodificação é impossível de 

ser  resolvido  se  a  mensagem  for  interceptada  por  um  hacker,  mesmo  utilizando-se  da 

computação  algébrica  ou  da  programação  computacional.  Este  fato  de  decifração  da 

mensagem é um problema em aberto na Matemática até o presente momento, pois a única 

pessoa que consegue decodificar é o destinatário da mensagem. Segundo Coutinho (2011): 

“para implementar o RSA precisamos de dois parâmetros básicos: 

dois números primos que vamos chamar de p e q. Para codificar 

uma mensagem usando o RSA é suficiente conhecer o produto dos 

dois  primos,  que  vamos  chamar  de  n.  A  chave  de  codificação  do 

RSA  é  portanto  constituída  essencialmente  pelo  número  n=pq. 

Cada  usuário  do  método  tem  sua  própria  chave  de  codificação. 

Esta  chave  é  tornada  pública:  todos  ficam  sabendo  que,  para 

mandar  uma  mensagem  para  o  banco  Acme,  deve  ser  usada  a 

chave n. Por isso n também é conhecido como “chave pública”. Já 

a  chave  de  decodificação é  constituída  pelos  primos  p  e  q.  Cada 

usuário  tem  que  manter  sua chave de  decodificação  secreta  ou  a 
segurança do método estará comprometida”.  

Aparentemente fatorar o número n parece ser um processo teoricamente fácil, mas 

usando  como  chaves  de  codificação  RSA  números  muito  grandes  (de  200  algarismos  ou 

mais),  levaria  milhares  de  anos.  De  acordo  com  Coutinho  (2011),  é  disto  que  depende  a 

segurança do RSA, da ineficiência dos métodos de fatoração atualmente conhecidos. 

Na literatura pode-se encontrar alguns trabalhos sobre o estudo de criptografia com 

matrizes  e  criptografia  RSA.  Com  relação  as  matrizes,  Olgin  (2011)  comenta  sobre 

“Criptografia  para  o  desenvolvimento  de  atividades  didáticas  que  aliem  os  conteúdos 

matemáticos  do  Ensino  Médio  a  esse  tema,  que  incentivem  o  manuseio  de  calculadoras 

científicas  no  Ensino  de  Matemática”.  Com  relação  a  criptografia  RSA,  pelo  fato  da 

fatoração  de 

  ser  um  problema  em  aberto  na  Matemática,  há  diversos 

pesquisadores que comentam sobre o assunto, entre eles Coutinho (2011). 

Diante da importância do Método RSA utilizado constantemente nos dias atuais, o 

objetivo  deste  trabalha  visa  seu  estudo,  o  porquê  do  Método  ser  seguro,  além  de  propor 

uma alternativa para fatorar o valor de n por meio da função de Euler.   

pqn 
 
 
 
 
 
 
 13   

CAPÍTULO 1 - NÚMEROS PRIMOS 

O objetivo deste capítulo é comentar sobre os diferentes tipos de funções que geram 

números  primos,  a  relação  dos  números  perfeitos  com  os  primos  de  Merssene  e  a 

distribuição e crescimento dos números primos. 

O  estudo  dos  números  primos  é  muito  importante  na  Matemática,  pois 

desempenham  um  papel  fundamental  que  estão  associados  a  muitos  problemas  famosos 

cujas soluções até o presente momento são desconhecidas, entre eles a criptografia RSA. 

Um  número  natural  maior  que  1  e  que  só  é  divisível  por  1  e  por  si  próprio  é 

chamado  de  número  primo.  Um  número  maior  que  1  e  que  não  é  primo  é  denominado 

composto. 

Não  se  conhece  nenhuma  fórmula  que  gere  números  primos  arbitrariamente 

grandes. 

Algumas fórmulas que produzem números primos são: 

Fórmulas Polinomiais 

,  fornece  números  primos  em  sequência  para 

, 

mas para 

, tem-se 

, logo não é primo. 

Fórmulas Exponenciais 

,  chamado  de  primos  de  Fermat,  são  obtidos  a  partir  de  um  número 

natural 

.  Os  primeiros  quatro  números  de  Fermat,  obtidos  pela  função  a  partir  de 

  são: 

. Em 1640, o matemático Pierre de 

Fermat observou que esses primeiros quatro números eram primos e conjecturou que todos 

os  outros  números  naturais  para 

,  também  seriam  primos.  Mas  para 

,  tem-se 

que 

  e 

, logo não é primo. Não se 

sabe se existe algum primo de Fermat para 

. 

, chamado de primos de Mersenne, são obtidos a partir de um número 

primo 

.  Nem  todos  os  números 

,  com  primo 

,  são  primos.  A  Figura  1, 

mostra  um  exemplo  programado  no  software  WxMáxima,  dos  primeiros  200  números 

41)(2xxxf40,...,2,1,0x41x2241414141)41(f122nnF0n4,3,2,1n65537,257,17,54321FFFF5n5n429496729712525F670041764142949672975n12ppMp12ppMp 
 
 
 
 
 
 
 
primos aplicados à fórmula 

, resultando em apenas 14 números primos. 

 14   

Figura1: Primos de Merssene 

Fórmulas Fatoriais 

Seja 

  primo. Define-se a função 

  como sendo a função obtida somente pelo 

produto de primos menores que ou iguais a 

. Por exemplo, 

, se 

  são 

primos sucessivos então. 

Observe os números da forma 

, na Tabela 1. 

2 

2 

3 

3 

6 

7 

5 

30 

31 

7 

11 

13 

210 

2310 

30030 

211 

2311 

30031 

Tabela 1: Aplicação da fórmula fatorial 

Mas 

, logo não gera um número primo. 

12ppMp#pp6323#pqpqp##1#p5095930031113#p#p1#p 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 15   

1.1 NÚMEROS PERFEITOS 

São os números naturais 

  com a seguinte propriedade: 

  é igual a soma de seus 

divisores próprios. Esses números fascinaram os gregos, a ponto de serem denominados de 

números perfeitos.   

A função 

, que calcula a soma de todos os divisores positivos de um número 

natural 

, pode ser utilizada para o reconhecimento dos números perfeitos. Ao utilizar a 

função 

que  subtrai  de  cada  número  natural 

  a  soma  de  seus  divisores  positivos 

próprios,  ou  seja,  diferentes  de  0  e  do  próprio  número.  Assim,  esta  função  pode  ser 

calculada da seguinte maneira: 

,    

A função 

compara um número natural 

  com a soma de seus divisores próprios. 

Os elementos do conjunto dos zeros da função 

, são: 

Atualmente  os  elementos  conhecidos  desse  conjunto  são  números  pares  e  estes 

estão  relacionados  com  os  primos  de  Mersenne,  por  meio  de  um  teorema  devido  parte  a 

Euclides e parte a Euler.   

Teorema  1.1.1.  Um  número  natural 

  é  um  número  perfeito  par  se,  e  somente  se, 

, onde 

  é um primo de Mersenne. 

No WxMáxima o comando divsum calcula 

, para 

, conforme Figura 2. 

nn)(nnfnZNf*:)(2])([)(nnnnnnfnfn0]321[6)6(1]0[1)1(ff70]3731[111)111(12]12864321[24)24(fff...},33550336,8128,496,28,6{}0)(|{)0(*1nfNnfnppMn12pM)(n*Nn 
 
 
 
 
 
 
 
 
 
Figura 2: A função 

  no WxMáxima. 

Tem-se a dispersão dos pontos na Figura 3. 

 16   

Figura 3: Gráfico da função 

. 

A  dispersão  horizontal  dos  pontos 

  do  gráfico  da 

função 

  se  apresentam  alinhados  para  os 

  e 

,  mas  isso 

se deve às seguintes proposições. 

Proposição 1.1.1. Se 

com 

  primo distinto de 2 e 3, então 

. 

Demonstração: Como 

  é um primo distinto de 2 e 3, segue que 6 e 

  não possuem 

divisores comuns além do 1. Logo, os divisores de 

  são: 

A soma desses divisores é 

  e 

  e 

. 

. 

Com  o  auxílio  do  WxMáxima  pode-se  listar  alguns  números  com  alinhamentos 

horizontais: 

representado na Figura 4.   

, 

conforme 

)(2)(nnnf)(2)(nnnf))(,(nfn)(2)(nnnf12)(nf56)(nfpn6p12)(nfpppn6ppp3,2,,6,3,2,1p6pn1212)(12)1212(12)(2)(ppnnnf12)(nf...},,174,138,114,102,78,66,54,42,30,24{}12)(:{)12(1nfnf 
 
 
 
 
 
 
 17   

Figura 4: Valores para a função 

. 

Proposição 1.1.2. Se 

com 

  primo distinto de 2 e 7, então 

. 

Demonstração: Como 

  é um primo distinto de 2 e 7, segue que 14 e 

  não possuem 

divisores 

comuns 

além 

do 

1.  Logo, 

os 

divisores 

de 

  e 

.  A  soma  desses  divisores  é 

. 

  são: 

  e 

Com  o  auxílio  do  WxMáxima  pode-se  listar  alguns  números  com  alinhamentos 

horizontais 

, 

conforme Figura 5. 

Figura 5: Valores para a função 

. 

A generalização para os demais números perfeitos se encontra na Proposição 1.1.3. 

Proposição 1.1.3. Se 

é um número perfeito e se 

  com 

  primo não divisor de 

, então 

Demonstração: Como 

  é um primo distinto de 

, segue que 

  e 

  não 

possuem  divisores  comuns  além  do  1.  Logo,  os  divisores  de 

são: 

e 

. 

  e 

. A soma desses divisores é 

12)(nfpn28p56)(nfpppn28ppppp14,7,4,2,1,28,14,7,4,2,1p28pn5656)(56)5656(56)(2)(ppnnnf56)(nf...},,364,308,224,140,84{}56)(:{)56(1nfnf56)(nfKKpnpKKnf2)(pKnkkkK...21pKpnKppkpkpkKkkknn,...,,,,,...,,,12121pknKpKn22)(KKpKKpnnnf2)22(2)(2)( 
 
 
 
 
 
 
 
 
 
 
 18   

1.2 A DISTRIBUIÇÃO DOS NÚMEROS PRIMOS 

É  possível  estimar  com  boa  aproximação,  o  número  de  primos  inferiores  a 

, 

principalmente se 

  é grande, por outro lado a distribuição de números primos situados 

em pequenos intervalos  tem comportamento aleatório. Para todo número 

, designa-

se  por 

  o  número  de  primos 

  tais  que 

; 

  é  chamada  de  função  de 

contagem dos números primos. 

Há questões a considerar, segundo Ribenboim (2012): 

- O  crescimento  de 

:  sua ordem  de  grandeza e a comparação de 

  com 

funções contínuas. 

-  Os  resultados  sobre  o  enésimo  número  primo,  sobre  a  diferença  entre  dois:  sua 

ordem  de  grandeza,  sua  regularidade  ou  sua  irregularidade.  Isso  conclui  a  questão  dos 

espaçamentos  entre  números  primos  consecutivos  e  conduz  igualmente  a  um  grande 

número de problemas em aberto, a saber: 

- Os números primos em progressão aritmética. 

- A conjectura de GOLDBACH. 

- A distribuição dos números pseudoprimos e dos números de Carmichael. 

Um número composto ímpar 

  é um número de Carmichael se 

para  todo 

.  Portanto,  números  de  Carmichael  são  pseudoprimos  de  Fermat 

para todas as bases. Em 1899, uma caracterização para os números de Carmichael foi dada 

por KORSELT. 

Teorema  1.2.1.  Um  inteiro  positivo  ímpar  n  é  um  número  de  Carmichael  se,  e 

somente se, cada fator primo p de n satisfaz:   

  não divide n e 

  divide 

.   

O número 561 é o menor número de Carmichael. Tem-se que: 

, logo: 

  não divide 561, 

  não divide 561 e 

  não divide 561. 

  e 

  divide 560. 

  e 

  e 

  divide 560. 

  divide 560. 

NN0x)(xpxp)(x)(x)(x0n)(modnaan11na2p1p1n1711356123211217213210111101611716 
 
 
 
 
 
 
 19   

1.3 O CRESCIMENTO DE 

Uma ideia no estudo  da  função 

  ou de outras  funções ligadas à distribuição 

dos  números  primos  é  a  comparação  com  funções  clássicas  que  são  calculáveis,  cujos 

valores  sejam  próximos  aos  valores  de 

.  Considere 

  e 

  funções 

contínuas de valores reais positivos, definidas para 

. 

, significa que 

  e então 

  e 

  são assintoticamente iguais, quando 

  tende para o 

infinito.  Porém  isso  não  significa  que  a  diferença  entre  essa  funções  seja  pequena,  por 

exemplo, 

  é  assintótica  a 

,  mas  a  diferença  entre  elas  cresce  à  medida  que 

tende ao infinito. 

O  Teorema  dos  Números  Primos  descreve  a  distribuição  assintótica  dos  números 

primos,  ou  seja,  como  os  primos  estão  distribuídos  entre  os  números  inteiros  e 

  é 

uma boa aproximação para 

  uma vez que 

, ou seja, 

. 

A  função 

  ,  para  qualquer  constante  real 

,  pode  ser  utilizada  para 

aproximar 

.    No  Teorema  dos  Números  Primos  o  valor  de  a  é  igual  a  zero,  mas 

segundo  alguns  estudos  Ribenboin  (2012),  conclui  que 

  é  a  melhor  escolha  para  a 

aproximação. Sendo assim, pode-se aproximar 

  utilizando-se a função 

.   

)(x)(x)(x)(xf)(xg00xx)(~)(xgxf1)()(limxgxfx)(xf)(xgx2xxx2x)ln(xx)(x1)ln()(limxxxx)ln(~)(xxx)ln(axxa)(x1a)(x)1ln(xx 
 
 
 
 
 
 
 20   

CAPÍTULO 2 - TEOREMAS FUNDAMENTAIS 

O objetivo deste capítulo é mencionar alguns teoremas importantes para o decorrer 

da  pesquisa,  sendo  estes  o  Teorema  Fundamental  da  Aritmética,  Teorema  da  Fatoração 

Única, Teorema de Fermat e o Teorema de Wilson. 

2.1 TEOREMA FUNDAMENTAL DA ARITMÉTICA 

Todo número natural maior que 1 ou é primo ou se escreve de modo único (a menos 

da ordem dos fatores) como um produto de números primos. 

Demonstração: Se 

, o resultado é obviamente verificado. 

Suponha  o  resultado  válido  para  todo  número  natural  menor  que  n,  tem-se  que 

provar que vale para n. Se o número n é primo, nada a demonstrar. Suponha então, que n 

seja  composto.  Logo,  existem  números  naturais 

e 

  tais  que 

,  com 

e 

  e 

.  Pela  hipótese  de  indução,  tem-se  que  existem  números  primos 

, tais que 

  e 

. Portanto, 

Para  provar  a  unicidade  da  escrita,  suponha,  agora,  que 

. 

,  onde 

os 

  e os 

  são números primos. Se 

  são números primos e, se 

então 

  para algum 

. Como 

, tem-se que 

para algum 

que,  após  o 

reordenamento  de 

,  pode-se 

supor  que 

seja 

, 

, 

. 

Portanto,

.    Como

, a hipótese de indução acarreta que 

  e 

os 

  e 

  são iguais aos pares. 

2.2 EXISTÊNCIA DA FATORAÇÃO 

Para estudar a fatoração dos números primos é fundamental enunciar o Teorema da 

Fatoração Única. 

Teorema 2.2.1 (Teorema da Fatoração Única). Dado um inteiro positivo 

, 

pode-se  sempre  escrevê-lo,  de  modo  único,  na  forma: 

,  em  que 

2n1n2n21nnnnn11nn21rpp,...,1sqq,...,1rppn...11sqqn...12srqqppn......11srqqppn......11ipjqnppp,...,,1nppp...|1ippni,...,1sqqp...|11jqp1jsqq,...,11qsrqqpp......22nppr...2sripjq2nkekeppn...11 
 
 
 
 
 
 
 
 
 
 
  são números primos e 

  são inteiros positivos. 

Este teorema encontra-se demonstrado mediante duas proposições (Prop. 30 e 32) 

dadas por Euclides no Livro VII de seus Elementos.   

 21   

2.3 TEOREMA DE FERMAT 

O  Pequeno  Teorema  de  Fermat  afirma  que  se 

  é  um  número  primo  e 

  um 

inteiro  qualquer  então 

  divide 

.  Casos  particulares  desse  teorema  já  eram 

conhecidos desde a antiguidade. Segundo Coutinho (2011), os chineses sabiam que se 

é  primo  então 

  divide 

,  mas  foi  Fermat  quem  obteve  o  resultado  geral  e  o 

introduziu na Matemática européia do século XVII utilizando a linguagem de congruências. 

Teorema de Fermat I. Seja 

  um número primo e 

  um inteiro, então 

. 

Demonstração:  A  prova  deste  teorema  será  feita  por  indução  finita.  Para  isto  precisa 

encontrar uma proposição 

  para aplicar a indução. 

. 

É evidente que 

  é válido, pois 

. Suponha então que 

. A 

passagem de 

  para 

  é pelo binômio de Newton. Para essa passagem utiliza-

se o seguinte Lema 1. 

Lema 

1.  Seja 

  um 

número 

primo 

e 

  e 

  inteiros.  Então, 

. 

Demonstração do Lema 1: Utilizando a expressão usual do binômio de Newton, tem-se: 

.  Para  obter  o  lema  é  suficiente  mostrar  que  o  termo 

  é  congruente  a  zero  módulo 

.  Considere  o  número  binomial 

. Para que a  fração  corresponda a um  número inteiro é preciso 

que  o  denominador  seja  completamente  simplificado  por  termos  no  numerador.  Suponha 

que 

, então o denominador 

  não tem 

  como  um  de seus fatores  primos. 

kpppp...1321kee...1papaappp22ppa)(modpaap)(np)(mod:)(pnnnpp)1(p11p)(modpnnp)(np)1(nppab)(mod)(pbabappp11)(piiippppbaipbaba11piiipbaipp!)1)...(1(iipppip11pi!ip 
 
 
 
 
 
 
 
 
 22   

Assim  o  fator 

  que  aparece  no  numerador  não  é  cancelado  por  nenhum  fator  do 

denominador.  Portanto  o  número  inteiro     

  é  múltiplo  de 

  quando 

, 

consequentemente 

. 

Voltando à demonstração do Teorema de  Fermat,  supondo que 

deseja-se mostrar que 

. Utilizando o Lema 1, tem-se que: 

.  Como  a  hipótese  de  indução  é 

  e, 

, 

então, 

. Com isso, prova-se o enunciado do teorema para os 

números  naturais,  mas  este  foi  enunciado  para  qualquer  inteiro.  Então,  chamando  de 

um inteiro negativo, 

  é positivo, logo aplicando o teorema já provado, para 

. Tem-

se: 

.  

      (2.1.)   

Supondo  que 

  é 

ímpar, 

.  Substituindo 

em 

(2.1.), 

,  e  multiplicando  por  -1,  concluí-se  que 

,  restando 

apenas  o  caso  em  que 

.  Se 

  então 

.  O  que  recorre  no  teorema 

. 

Será  utilizado  a  ideia  do  Pequeno  Teorema  de  Fermat,  no  método  RSA  para 

justificar uma passagem Matemática na fórmula, mas sendo este o enunciado a seguir. 

Teorema  de  Fermat  II.  Seja 

  um  número  primo  e 

  um  inteiro  que  não  é  divisível 

por 

. Então 

. 

Demonstração:  Segundo  o  Teorema  de  Fermat  I,  se 

  é  primo  e 

  é  um  número 

inteiro qualquer, então 

. Suponha que 

  não divide 

. Neste caso 

  é 

invertível módulo 

, de acordo com o teorema de inversão. Seja 

  um inteiro positivo 

tal  que 

obtém-se: 

.  Multiplicando  ambos  os  membros  de 

  por 

, 

.  Com  a  substituição  de   

  nesta  equação, 

tem-se 

, o que conclui a demonstração. 

Um exemplo da aplicação direta do Teorema de Fermat é dado a seguir.   

pipp11pi)(mod011pbaippiiip)(modpnnp)(mod1)1(pnnp)(mod11)1(pnnnpppp)(modpnnp)(mod11)1(pnnnppaaa)(mod)(paappppaa)()(modpaap)(modpaap2p2pppaa)()(modpaappap)(mod11pappa)(modpaappaap'a)(mod1'paa)(modpaap'a)(mod''1paaaaap)(mod1'paa)(mod11pap 
 
 
 
 
 
 
 
 
 
 
 
 23   

Sejam 

  e 

  três inteiros positivos, dos quais sabe-se que 

  é primo e não 

divide 

. Seja 

  um número muito grande; deseja-se encontrar a forma reduzida de 

módulo 

. Basta apenas que o valor de 

, pois dividindo 

  por 

, obtém-se 

, em que o resto 

  satisfaz 

. Tem-se então que: 

,  mas  pelo  Teorema  de  Fermat  II,  tem-se  que 

. Então 

. 

Se  desejar  calcular 

  módulo  13.  Utiliza-se  desta  forma,  o  Teorema  de 

Fermat para calcular o resto da divisão de 5432675 por 12, resultando em 11. Assim: 

. Logo 

  é o menor resíduo positivo. 

2.4 TEOREMA DE WILSON (T.W.) 

Teorema 2.4.1. 

é um número primo se, e somente se, 

. 

Demonstração: 

  Se 

  é  primo,  então  todo  elemento  de 

,  exceto  [-1]  e  [1], 

possui um único inverso distinto de si. Logo: 

, mas 

. 

  Suponha  por  absurdo  que 

  seja  composto.  Então  existe  um  inteiro 

,  com 

,  que  divide 

.  Portanto, 

.  Por  outro  lado,  como 

, 

  é um divisor de 

  e 

, o que é uma contradição. Portanto, 

é primo, o que conclui a demonstração do teorema. 

Um  exemplo  da  aplicação  do  Teorema  de  Wilson.  Encontrar  o  menor  resíduo 

positivo de 

. 

É fácil observar que: 

Logo: 

. 

Pelo T.W., tem-se que 

, ou seja, 

. 

ka,ppakkap1pkk1prqpk)1(r20pr)(mod)(1)1(paaaarqprqpk)(mod11pap)(mod1paaarrqk54326752)13(mod7221154326757p)(mod1)!1(pp)(pp)(mod123)...3()2(ppp)(mod1112...)2()1()!1(ppppp)(mdmd1m)(mod1)!1(dmmdd)!1(m)(mod0)!1(dmm7mod)1312111098()7(mod613)7(mod512)7(mod411)7(mod310)7(mod29)7(mod18)7(mod654321)1312111098()(mod1)!1(pp)7(mod1!6 
 
 
 
 
 
 
 
 
 24   

Mas 

Se 

Porém 

  , logo:   

. 

, logo 

  e 

, 

então 

. 

Portanto, o menor resíduo positivo é igual a 6. 

123456!6)7(mod!6)1312111098()7(mod1!6)7(mod1)1312111098()7(mod16)7(mod6)1312111098( 
 
 
 
 25   

CAPÍTULO 3 - ALGORITMOS DE FATORAÇÃO 

O  objetivo  deste  capítulo  é  mencionar  sobre  alguns  algoritmos  de  fatoração,  a 

ineficiência dos algoritmos, a fatoração por Fermat e o algoritmo Euclidiano. 

O  processo  de  encontrar  os  fatores  primos  de  um  número  composto  denomina-se 

fatoração.  Existem  diversos  algoritmos  de  fatoração,  mas  não  existe  um  algoritmo  que 

funcione  perfeitamente,  em  que  o  computador  possa  executar  em  tempo  polinomial  para 

todos os números inteiros. Nesta pesquisa foram abordados alguns algoritmos de fatoração. 

Considere  o  seguinte  Problema:  tendo  por  entrada  o  valor 

,  determine  seus 

fatores primos e respectivos expoentes. 

Com foco apenas no primeiro fator de um inteiro dado. Tendo n como entrada, tente 

dividir n por cada um dos inteiros de 2 a n – 1, caso algum desses inteiros dividir n, então 

encontra-se um fator de n, onde é o menor fator e este fator é um número primo.   

Sabe-se  que  um  número  inteiro  não  pode  ter  um  fator  maior  que  ele  próprio  e 

também  pode-se  restringir  a  busca  em  um  intervalo  menor  que  2  a    n  –  1,  sendo  este 

intervalo  de  2  a 

.  Porém  se  n  é  primo  o  único  fator  será  o  próprio  n.  É  necessário 

verificar, entretanto, que se n é composto, seu menor fator é no máximo 

. 

Assim, se n é um número composto e se 

  é seu menor fator, existe um inteiro 

positivo a tal que n = f a . Como f é o menor fator, certamente 

. Mas 

, logo 

. Disso decorre que 

, que é equivalente a 

. 

O procedimento descrito é representado pelo Algoritmo 3.1. 

3.1 ALGORITMO DA FATORAÇÃO (MENOR FATOR) 

Entrada: Digite um inteiro positivo n. 

Saída : Inteiro positivo f que é o menor fator primo de n ou a indicação que n é primo. 

Etapa1: Comece fazendo 

. 

Etapa 2: Se 

  é inteiro escreva ' f é fator de n ' e pare; senão vá para a Etapa 3. 

nnn1faffnafnfnf2nf2ffn 
 
 
 
 
 
 
 
 
 26   

Etapa 3: incremente a f uma unidade e vá para a Etapa 4. 

Etapa 4: Se 

, escreva n é primo e pare. Caso contrário, retorne à Etapa 2. 

Logo, dado um inteiro 

, pode-se determinar se n é primo ou composto. Se n é 

primo encontra-se a sua fatoração, mas se n for composto, pode-se encontrar todos os seus 

fatores primos e suas respectivas multiplicidades aplicando o algoritmo da fatoração várias 

vezes, ou seja, aplicando o algoritmo a n encontra-se o fator q1. Então q1 é o menor fator 

primo  de  n.  Aplicando  o  algoritmo  da  fatoração  ao  co-fator 

  ,  determina-se  um 

segundo fator q2. Pode-se repetir esse procedimento aplicando ao co-fator 

, e assim 

por  diante.  Dessa  forma,  determina-se  uma  sequência  crescente  de  números  primos 

, em que cada um é um fator de n. 

O procedimento descrito é representado pelo Algoritmo 3.2. 

3.2 ALGORITMO DOS FATORES (TODOS OS FATORES) 

Entrada: Digite um inteiro positivo n. 

Saída:   

, são os fatores primos de n, ou indicativo de que n é primo. 

Etapa1: Comece fazendo

. 

Etapa 2: Se 

  é inteiro armazenar 

  e 

  . Vá para a Etapa 3. 

Etapa 3: Se for verdade a etapa 2, então efetuar o cálculo para o novo valor em n e para o 

mesmo 

  para 

. Enquanto houver o mesmo fator repetir a Etapa 2. Senão vá 

para a Etapa 4. 

Etapa 4: incremente a f uma unidade e vá para a Etapa 5. 

Etapa 5: Se 

, então escreva os fatores 

ou n é primo e pare. Senão volte a 

Etapa 2. 

nf0n1qn21qqnsqqq...21sqqq,...,,212ffnfqiiqnniqki,...,2,1nfsqq,...,1 
 
 
 
 
 
 
 
 
 27   

3.3 INEFICIÊNCIA DOS ALGORITMOS   

Apesar  da  facilidade  em  entender  e  programar  os  algoritmos  da  fatoração  e  dos 

fatores,  estes  algoritmos  são  muitos  ineficientes,  mesmo  com  a  tecnologia  atual.  O  pior 

caso  para  executar  o  algoritmo  é  aquele  em  que  o  algoritmo  executa  o  maior  número  de 

laços,  ou  seja, 

laços.  Para  uma  estimativa  do  tempo  de  execução,  considere  um 

número  n  primo,  de  100  ou  mais  algarismos,  ou  seja, 

e  portanto  o  número  de 

laços  será  igual  a 

.  Assim,  são  necessárias  pelo  menos 

divisões  para 

garantir  que  n  é  primo.  Segundo  Coutinho  (2011),  “Digamos  que  nosso  computador 

executa 

divisões  por  segundo.  Este  é  um  número  muito  alto,  que  não  é  atingido  no 

estado  atual  da  tecnologia”.  Para  estimar  o  tempo  basta  calcular 

  segundos 

para determinar que n é primo. 

Um ano tem 60 (segundos) 

(minutos) 

  (horas) 

  (dias) 

segundos, resulta em 

  anos.   

Portanto,  percebe-se  que  é  inviável  confirmar  que  um  número  de  100  ou  mais 

algarismos  é  primo  usando  esse  algoritmo.  Porém,  isso  também  não  significa  que  o 

algoritmo  é  inútil,  segundo  Coutinho  (2011),  “Se  vamos  fatorar  um  inteiro  sobre  o  qual 

nada  sabemos,  há  sempre  a  possibilidade  que  tenha  um  fator  primo  pequeno,  digamos 

menor que 

”, neste caso o algoritmo da fatoração pode ser utilizado. 

Segundo  Coutinho  (2011),  “É  muito  importante  entender  que  não  existe  um 

algoritmo de fatoração que funcione bem para todos os inteiros: disso depende a segurança 

do  método  RSA”.  Ninguém  sabe  se  a  inexistência  deste  algoritmo  geral  é  um  problema 

intrínseco ou tecnológico, ou seja, se um tal algoritmo pode existir ou se ainda ninguém foi 

esperto o suficiente para inventá-lo.   

3.4 FATORAÇÃO POR FERMAT 

A fatoração por Fermat é muito eficiente quando n tem um fator primo próximo de 

.  Supõe-se  n  ímpar,  pois  se  n  for  par  então  2  é  um  de  seus  fatores.  Fermat  teve  a 

brilhante  ideia  de  tentar  encontrar  inteiros  positivos 

  e 

  tais  que 

.  Se 

n10010n5010n501010104010501010106024365315360003240107645851709791983,33153600010610nxy22yxn 
 
 
 
 
 
 
 
 
 
encontrados  esses  números 

  e  por  consequência, 

  são fatores de n. 

 28   

  e 

Para  implementar  o  algoritmo  de  Fermat  primeiro  é  preciso  determinar  a  parte 

inteira   

de 

.  Se  n  é  um  quadrado  perfeito  então 

,  será  o  próprio  fator. 

Pela notação acima tem-se: 

  e 

.  Para 

,  então 

.  Logo  pode-se  elaborar  o 

seguinte algoritmo. 

Algoritmo de Fermat 

Entrada: Inteiro positivo ímpar n. 

Saída: Um fator de n ou uma mensagem que n é primo. 

Etapa 1: Inicie 

; Se 

, então 

  é fator de n e pode parar. Senão vá para a 

Etapa 2. 

Etapa 2: Incremente 

  de uma unidade e calcule 

. 

Etapa 3: Repita a Etapa 2 até encontrar um valor inteiro para 

  (1° caso) , ou até que 

seja  igual  a 

  (2°  caso):  No  1°  caso  n  tem  fatores 

  e 

,  no  2°  caso  n  é 

primo. 

Demonstração do Algoritmo de Fermat 

É necessário considerar separadamente o que ocorre quando n é composto e quando 

n é primo. No caso de n ser composto, é necessário mostrar que existe um inteiro 

, 

em  que  os  colchetes  representa  a  parte  inteira  da  raiz  quadrada,  tal  que 

  é  um 

inteiro menor que   

.  Isto  significa que se  n  é composto  então o algoritmo irá parar 

antes  de  chegar  em 

.  Se  n  é  primo,  então  é  necessário  mostrar  que  o  único  valor 

possível para 

  é 

. 

Suponha que n pode ser fatorado na forma 

, em que 

. Deseja-se obter 

inteiros positivos 

  e 

  tais que 

, ou seja, 

. 

Como 

, isto sugere que 

e 

. Desse sistema, obtém-

))((22yxyxyxnyxyxnnffx0y0ynynx2][nx2xnxxnxy2yx21nyxyx][nxnx221n21nx21npqnqpxy22yxn22))((yxyxyxpqnyxyxyxpyxq 
 
 
 
 
 
 
 
se: 

  e 

, e portanto 

 29   

. 

        (3.1.) 

Entretanto, 

  e 

  devem  ser  números  inteiros  e  por  hipótese  n  é  ímpar  então 

  e 

,  logo 

  e 

,  que  são  fatores  de  n  ,  têm  que  ser  ímpares.  Com 

isso, 

e 

  são  pares  e  consequentemente, 

  e 

  são  inteiros.  Agora 

se n é primo então 

  e 

. E, 

  é o único valor possível para 

  se n é 

primo. Resta agora considerar o caso em que n é composto. Se 

, o algoritmo obtém a 

resposta  na  Etapa  1.  Supondo  que  n  é  composto  e  não  é  um  quadrado  perfeito,  isto  é, 

.  Neste  caso,  o  algoritmo  vai  parar  se  forem  satisfeitas  as  desigualdades: 

.                           

A  desigualdade  da  direita  nos  diz  que 

.  Para 

,  nesta  última 

desigualdade,  e  subtraindo 

  de  ambos  os  membros,  obtém-se 

.   

Como 

, então 

. Logo 

  . 

Para  a  desigualdade  da  esquerda,  sabe-se  que 

,  e  basta  verificar  que 

. Logo esta desigualdade é válida se, e somente se, 

.   

Pela 

Equação 

(3.1.), 

tem-se: 

. 

Então 

. Como 

, logo 

. 

Este  algoritmo  de  Fermat  tem  uma  relação  muito  importante  com  a  criptografia 

RSA, lembrando que a segurança do método RSA está na dificuldade em se fatorar a chave 

pública  n,  que  é  o  produto  de  dois  números  primos.  Pensar  que  escolher  dois  primos 

grandes basta para a segurança do método RSA é errôneo, pois se estes dois primos forem 

muito  próximos,  o  seu  produto  irá  gerar  um  número  n,  onde  a  sua  raiz  quadrada  será 

próxima dos dois fatores primos, logo n é facilmente fatorável pelo algoritmo de Fermat. 

2qpx2pqynpqppqqqpqppqqp42222222222xy2qpx2pqypqqppq2qp2pq1pnq21nxxqpnqp1212][nqpn1nqppqn1q)1(1pqp1pqp1212nqpnn][2qpn4)(2qpnnpqqp22224)(4)(22pqnqp04)(2pq04)(2nqp 
 
 
 
 
 
 
 30   

3.5 ALGORITMO EUCLIDIANO 

De  acordo  com  Coutinho  (2011),    este  algoritmo  é  descrito  por  Euclides  nas 

Proposições 1 e 2 do Livro 7 dos Elementos de Euclides. 

O objetivo do algoritmo Euclidiano é calcular o máximo divisor comum 

entre  dois  números  inteiros.  Um  inteiro 

  divide  outro  inteiro 

,  se  existe  um  outro 

número inteiro 

, tal que   

. Também diz que 

  é um divisor ou fator de 

, ou 

ainda que 

  é múltiplo de 

. O número 

, definido acima, é denominado de co-fator de 

  em 

.  O 

  entre 

  e 

  é  o  maior  inteiro  positivo 

  que  é  divisor  de 

  e 

também é divisor de 

. Se 

  é o 

entre 

  e 

,escreve-se 

. Caso 

, então os números são primos entre si ou co-primos.   

Com 

  e 

  inteiros  positivos  e  tais  que 

,  o  algoritmo  Euclidiano 

consistem em dividir 

  por 

, encontrando o resto 

. Se 

, dividindo 

  por   

, 

obtém-se   

.  Se 

,  dividindo   

  por   

,  obtém-se  o  resto 

.  O  último  resto 

diferente de zero, desta sequência de divisões é o máximo divisor comum (MDC) comum 

entre 

  e 

. Para demonstrar o algoritmo Euclidiano, precisa-se do seguinte Lema 2. 

Lema 2. Sejam 

  e 

  números inteiros positivos. Suponha que existam inteiro 

  e 

tais que 

. Então 

. 

Demonstração:  O  lema  diz  que  assumindo  que 

  e 

  estão  relacionados  por 

conclui-se 

que 

.  Para 

  e 

, tem-se que mostrar que 

. Então, basta mostrar que 

  e em 

seguida 

. Provando que 

. 

Se 

,  então 

  divide 

  e 

  divide 

.  De  acordo  com  a 

definição,  isto  significa  que  existem  inteiros 

  e 

  tais  que: 

  e 

. 

Substituindo  na 

expressão 

,  obtém-se: 

,  ou 

seja, 

, logo 

  divide 

. Como o 

,    tem-se que 

divide 

.  Portanto 

  é  um  divisor  comum  entre 

  e 

,  mas   

  é  o  maior  divisor 

comum entre   

  e 

, logo 

. De modo análogo pode ser mostrado que 

  e 

consequentemente, 

. 

Será utilizado o Lema 2, para provar que o último resto não nulo da sequência de 

)(MDCbacbcabaabcbaMDCabdabdMDCab),(baMDCd1),(baMDCabbaab1r01rb1r2r02r1r2r3rababgssbga),(),(sbMDCbaMDCgba,,ssbga),(),(sbMDCbaMDC),(1baMDCd),(2sbMDCd21dd21dd12dd21dd),(1baMDCd1da1dbuvuda1vdb1sbgasvgdud11)(111vgudvgduds1ds),(1baMDCd1db1dbs2dbs21dd12dd21dd 
 
 
 
 
 
 
 
 
 
 
divisões  é  o 

.  Logo  aplicando  o  algoritmo  Euclidiano  a 

  e 

  e  supondo  que  o 

resto nulo ocorre após n divisões, tem-se: 

 31   

Da  última  divisão  tem-se  que 

  divide 

.    Logo,  o  maior  divisor  comum 

entre os dois é o próprio 

. Portanto 

. Com a aplicação do Lema 2 

à  penúltima  divisão,  conclui-se  que 

.  E,  com  o 

Lema 

2 

sob 

a 

ante 

penúltima 

divisão, 

tem-se 

que 

.  De  modo  análogo,  conclui-se 

que o MDC(a,b) = rn-1.   

MDCab00000001221112332223434443223332112221111nnnnnnnnnnnnnnnnreqrrrrerqrrrrerqrrrrerqrrrrerqrrrrerqrbbrerbqa1nr2nr1nr112),(nnnrrrMDC11223),(),(nnnnnrrrMDCrrMDC1122334),(),(),(nnnnnnnrrrMDCrrMDCrrMDC 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
 32   

CAPÍTULO 4 - CRIPTOGRAFIA RSA 

O objetivo deste capítulo trata-se da origem do Método RSA, descrição Matemática 

do  método,  pré-codificação,  como  codificar  e  decodificar  os  blocos,  caso  particular,  o 

porquê do método RSA ser seguro, relacionar a função de Euler no método RSA, apontar 

as possibilidades de quebrar o método RSA e a escolha dos números primos.     

Em  1976  Whitfield  Diffie  e  Martin  Hellman  publicaram  um  documento 

denominado “As novas direções da criptografia”, que sugeria o desenvolvimento de algum 

método  para  criptografar  as  informações  antes  de  serem  enviadas.  Os  dois  cientistas 

propuseram  um  novo  método  para  que  a  chave  fosse  enviada  de  forma  segura,  em  que 

todas as informações necessárias eram disponibilizadas publicamente. A ideia consiste em 

usar  uma  função  que  seja  fácil  de  calcular  mas  difícil  de  inverter  computacionalmente, 

caso a pessoa não possua a chave do segredo. Essa função é chamada de “função arapuca” 

(trap-door one-way function). 

Um  código  criptografado  de  chave  pública  deve  conter  um  esquema  público  de 

codificação 

  e um esquema privado de decodificação 

, em que 

  e 

  são fáceis 

de  calcular  e  para  uma  mensagem 

,  ou  seja,  o 

procedimento de codificação 

  gera a mensagem codificado, em que o receptor de posse 

da chave de decodificação 

, utilizando ela decodifique, resultando a mensagem original. 

4.1 A ORIGEM DO MÉTODO RSA 

Após  a  publicação  do  documento  de  Diffie  e  Hellman,  três  estudantes  do 

Massachusetts  Institute  of  Technology  (MIT),  começaram  a  pesquisar  e  desenvolver  um 

novo tipo de criptografia, satisfazendo às condições estabelecidas no artigo. Para isso, eles 

estabeleceram  um  jogo  de  adivinhações,  em  que  Rivest  e  Shamir  comentavam  algumas 

ideias  de  como  criptografavam  a  mensagem  e  Adleman  tentava  adivinhar  a  técnica 

utilizada,  mas  certo  dia  Rivest  trouxe  um  método  que  Adleman  não  conseguiu  quebrar. 

Esse método então ficou conhecido  por RSA em homenagem  aos seus criadores (Ronald 

Rivest, Adi Shamir e Leonard Adleman), permanecendo inviolado até o presente momento. 

É  claro  que  durante  esses  anos,  alguns  pesquisadores  encontraram  fraquezas  na 

implementação do método RSA, mas que foram corrigidas. Foram testadas várias chaves 

EDEDMMDEMEDM))(())((,ED 
 
 
 
 
 
 
 
 33   

RSA,  propostas  como  desafio  para  analisar  a  escolha  dos  números  primos  e  os  métodos 

utilizados  para  encontrá-los.  O  RSA  tornou-se  a  melhor  maneira  de  criptografar  as 

informações, como por exemplo, transações com cartão de crédito via internet. 

O RSA é o resultado de dois cálculos matemáticos, um para codificar e outro para 

decodificar,  em  que  se  utilizam  duas  chaves  criptográficas,  uma  chave  pública  e  uma 

privada. 

4.2 DESCRIÇÃO MATEMÁTICA DO MÉTODO 

Para codificar uma mensagem, precisa-se de 

, que é o produto de dois números 

primos 

  e 

,  logo 

  e  de  um  inteiro  positivo 

,  que  seja  invertível  módulo 

,  ou  seja,  o 

  ,  em  que 

.  Denomina-se  o  par 

  chave de codificação e o par 

  chave de decodificação do método RSA.   

-  Represente  a  mensagem  com  números  inteiros,  quebrando  em  bloco  de  maneira 

que esses blocos não ultrapassem o valor de 

  e não iniciem em zero. 

- Para  codificar a mensagem 

, eleva-se cada bloco 

  à 

  potência 

módulo 

,  ou  seja, 

  .  Então  cada  resultado  criptografado  é  o  valor  em 

.   

- Para decodificar a mensagem 

  criptografada, eleve-a a uma outra potência 

e  calcule  o  resto  da  divisão  por 

,  ou  seja, 

.  Então  o  resultado 

descriptografado é o valor em 

. 

O  valor  do 

  é  o  inverso  de 

,  ou  seja, 

4.3 PRÉ-CODIFICAÇÃO 

A  primeira  coisa  a  fazer  para  utilizar  o  método RSA  é  converter  a  mensagem  em 

uma  sequência  de  números  relacionados  em  uma  tabela  de  letras  com  seus  respectivos 

números.  Um  cuidado  na  hora  de  relacionar  as  letras  com  os  números  é  importante:  por 

exemplo, se escolher a letra A = 1, B = 2 e assim por diante, quando escrever o número 12, 

qual será a interpretação? Nesse sistema de conversão há uma ambiguidade, se 12 = AB ou 

se  12  =  L.  Como  alternativa,  será  utilizada  a  seguinte  tabela  de  conversão  de  letras  para 

npqpqn)(n1))(,(nMDC)1)(1()(qpn),(n),(dnnBiB""ésiman)(modnABiiiAAdn)(modnBAidiBd)]([mod)]1)(1([modnqp))((mod1nd 
 
 
 
 
 
 
 
 
 34   

números (Tabela 2). 

A  B 

C  D  E 

F  G  H 

I 

J  K 

L  M 

10  11 

12 

13  14  15  16  17  18  19  20  21  22 

N  O 

P  Q  R  S  T  U  V  W  X  Y 

Z 

23  24 

25 

26  27  28  29  30  31  32  33  34  35 

Tabela 2: Tabela de conversão. 

Para  aplicar  o  método  RSA,  será  pré-codificado  a  palavra 

  pela  Tabela  2. 

Com  a  conversão  da  mensagem  letra  a  letra,  obtém-se: 

,  assim  a 

mensagem codifica é dada pelo número: 27.28.10. 

4.4 CODIFICANDO E DECODIFICANDO 

Serão utilizados números primos “pequenos” para fins pedagógicos, afim de que os 

cálculos possam ser verificados facilmente. Porém para uma maior segurança recomenda-

se fatores grandes diante da dificuldade da fatoração.   

Considere 

  e 

,  tem-se  que 

    e 

, 

logo 

.Para  iniciar  o  processo  deve-se  quebrar  o  código  27.28.10  em  blocos 

menores que 

. 

B1 

27 

B2 

28 

B3 

10 

            Tabela 3: Código em blocos. 

Cada  um  dos  blocos  será  codificado  por 

,  em  que  o 

, então 

, escolhendo assim 

. Logo, codifica-se da 

seguinte maneira: 

RSA10,28,27ASR5p7q3575pqn)1)(1()(qpn24)(n35n)(modnABii1))(,(nMDC1)24,(MDC7)(modnABii)35(mod2717A)35(mod1348)8()6()8(64)8(])8[()8(27333277)35(mod2827A 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 35   

Os valores são: 

e 

, logo a mensagem codificada é: 13.7.10 

Mensagem Original 

27.28.10 

Mensagem Codificada 

13.7.10 

              Tabela 4: Código de conversão. 

A  informação  necessária  para  a  decodificação  consiste  no  par 

,  lembrando 

que 

e  o  valor 

é  o 

inverso  de 

  em 

,  ou  seja, 

.  Neste  caso, 

,  donde 

,  logo 

. 

Assim, decodifica-se 13.7.10, da seguinte maneira: 

Os valores são: 

e 

, logo a mensagem original é: 27.28.10, 

que corresponde às letras RSA. 

4.5 UM CASO PARTICULAR DO RSA 

Escolhendo números primos 

  e 

  da seguinte maneira: 

e 

, 

logo 

tem-se  que 

  e 

, 

então 

, 

pode-se 

escrever 

, ou seja, 

, logo: 

, multiplicando por 

, para que o resto seja 

. 

)35(mod7)3(21)7(14)7(49)7(])7[()7(28333277)35(mod1037A)35(mod10101510)125(10)5(10)10(1033277,1321AA103A),(dn)1)(1()(qpnd)(n))((mod1nd24)(,7n)24(mod17d7d)(modnBAidi)35(mod1317B)35(mod277813)6(13)6()6()13()13(132327)35(mod727B)35(mod281477141967147)7(73327)35(mod1037B)35(mod10101510)125(10)5(10)10(10332728,2721BB103Bpq)6(mod5p)6(mod5q)6mod(41p)6(mod41q)6mod(416)1)(1(qp13646)1)(1(kkqp1)12(3)1)(1(kqp)46(mod1)12(3kk11 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
   
 
 
 
 36   

, somando 

, obtém-se: 

. 

Por 

exemplo, 

considere 

  e 

, 

logo 

  e 

,  lembrando  que,  para  codificar,  utiliza-se  o  par 

,  em  que 

.  Neste  caso,  como 

  e 

  estão  no  caso  particular, 

pois ambos deixam resto 5 na divisão por 6, então pode ser utilizado 

, mas por que 

esse  valor  para 

?  Na  sequência  será  respondida  essa  pergunta,  mas  antes,  para 

decodificar, precisa-se conhecer o par 

.   

O  valor  de 

  é  calculado  por 

.  Como 

,  fazendo  uma 

relação com o caso particular desenvolvido, em que 

, tem-se que 

  e 

.  Esta  relação  justifica  o  porquê  de 

.  Nesse  exemplo, 

pode  ser  calculado  o  valor  de 

  em 

,  pois  sabe-se  o  valor  de 

assim 

então 

.  De  posse  do  valor  de 

,  calcula-se  o  valor 

.  Portanto  é  fácil  calcular  o  valor  de 

,  conhecendo-se  o 

, 

, 

, 

sem precisar aplicar o algoritmo de Euclides. 

4.6 POR QUE O CASO PARTICULAR FUNCIONA? 

O  método  RSA  só  será  útil  se,  decodificando  os  blocos  codificados,  obtém-se 

novamente o bloco correspondente da mensagem original. Considere que os blocos estejam 

no intervalo de 

  e 

  para codificar, em que 

, logo 

  é 

a codificação do bloco 

. Em seguida, para decodificar utiliza-se 

.   

Supondo  que  para  decodificar 

,  em  que 

,  assim 

  é  a 

decodificação  do  bloco  A.  Então, 

,  ou  seja, 

,  mas 

, 

ou 

seja, 

, 

e 

tem-se: 

Tem-se dois casos a considerar (

  e 

. Basta provar que 

  e 

). 

. 

Se 

, como 

  é um  número primo, logo 

  será múltiplo de 

, 

então 

, ou seja, 

, logo 

. 

Se 

, 

,  pelo  Teorema  de  Fermat 

)46(mod1)12(3kk46k)46(mod1)34(3kk5p11q55115n40)111)(15()1)(1()(qpn),(n1))(,(nMDCpq3),(dnd))((mod1nd3)46(mod1)34(3kk34kd46)(kn3k46)(kn40)(n64640kk6k34kd27364dd)(nnB1)(mod3nABnA0AB)(modnBAd)(modneAdne0e)(mod)(3nBAedd)(mod3nBed))1)(1(mod(13qpd)1)(1(13qpkd)1)(1()1)(1(13qpkqpkdBBBB)(mod3pBBd)(mod3qBBd1),(BpMDC1),(BpMDC1),(BpMDCpBppB)(mod0pB)(mod3pBBd1),(BpMDC)1(1)1)(1(3)(qkpqpkdBBBBB 
 
 
 
 
 
tem-se  que 

  e 

.  De  modo  análogo 

demonstra-se que 

. Considere o seguinte sistema de congruências: 

 37   

, então: 

e 

, 

como 

  e 

, então necessariamente a congruência implica a igualdade, portanto 

concluí-se que 

.   

4.7 POR QUE O RSA É SEGURO? 

Cabe ressaltar que o RSA é um método de chave pública, então sejam 

  e 

  os 

dois números primos do método, e 

. A chave de codificação corresponde à chave 

pública. Portanto  o par 

  é acessível  para qualquer usuário. O método RSA só será 

seguro se for difícil calcular 

, quando apenas se conhece os valores de 

. 

Para calcular o valor de 

, aplica-se o algoritmo Euclidiano estendido a 

  e 

,  pois 

.  Mas  para  se  calcular 

,  é  necessário  saber  quais  são  os 

primos 

e 

,  pois 

.  Portanto  para  decifrar  o  código  precisa-se 

fatorar 

.  Porém  se 

  é  um  número  muito  grande,  sabe-se  que  fatorar 

  é  um 

problema extremamente difícil, pois não se conhece um algoritmo rápido de fatoração. 

4.8 ANÁLISE DA FUNÇÃO DE EULER NO MÉTODO RSA 

Suponha  que 

  e 

  sejam  ambos  conhecidos.  Pode-se 

determinar 

  e 

  a partir deles. 

Para 

,  tem-se  que 

, portanto tem-se a soma dos dois números primos.   

logo 

logo: 

Sabe-se  que 

, 

, 

diferença dos dois números primos. 

  ou 

,  portanto 

tem-se  a 

)(mod11pBp)(mod1)()1()1(1pBBBBqkqkp)(mod3qBBqtBxqtBxqBxptBxptBxpBx2211)(mod)(mod)(mod)(mod3nBxpqBxpqtBx)(mod3pBBdne0nB1bepqpqn),(nd),(nd)(n))((mod1nd)(npq)1()1()(qpnnnnpqn)1()1()(qpnpq)1()1()(qpn1)(1)()(qpnqppqn1)(nnqp222222)(4)2(4)2(4)(qppqqpqpnqpqpnqpnqpqp4)(2nnnqp4)1)((2 
 
 
 
 
   
 
 
Sendo  conhecidos 

  e 

,  calcula-se  facilmente  o  valor  de 

  e 

  por 

meio da resolução de um sistema linear, ou seja, o procedimento fatora o valor em 

. 

 38   

4.9 A FUNÇÃO 

Seja a função f : 

, tal que

. Assim, tem-se ainda que 

, 

cujas 

raízes 

são: 

.  A  raiz 

  é  positiva,  basta  analisar 

.  Logo, 

  e 

, 

tem-se 

.  Elevando  ao  quadrado  ambos  os  membros  obtém-se 

.  Logo 

  que  é  equivalente  a 

  e 

; portanto ambas as raízes são positivas. 

Escolher dois números primos quaisquer 

, efetuar o produto deles para gerar 

o valor de 

  e efetuar a subtração de 

  por 

  para gerar o valor de 

, logo 

e 

  . Considere a função f : 

, tal que

. Substituir o 

resultado de 

  no lugar de 

  e resolver a equação em função de 

. Sendo assim, 

  ou 

.  As 

raízes  dessa 

equação  são 

  e 

.  O  importante  para  o  método 

RSA é apenas a menor raiz, sendo esta o 

. 

O  que  é  notável,  caso  alguém  invente  um  método  rápido  que  encontre  o  valor  de 

, fica fácil de encontrar os fatores primos 

  e 

. 

O  conceito  do  vértice  da  parábola  por  meio  das  raízes  é  a  média  aritmética  das 

raízes 

que 

resulta 

no 

  da 

função, 

ou 

seja, 

  e  também  o  conceito  do 

, 

calculado por meio de 

, ou seja, 

. 

Na  figura  6,  tem  um  esboço  do  gráfico  da  função 

,  que 

relaciona o vértice da parábola com o valor procurado de 

  que é a soma 

dos números primos p e q. 

qpqppqnnnmmf4)1()(2RRnnmmf4)1()(21222)(22nnmmnmmfnnm211nnm2121m2m0212nnmnn2122)2()1(nnnnn41220122nn0)1(1222nnnqpnqpgpqnpqgRRnnmmf4)1()(22g)(mfmnnmg4)1(22012222222pqqpmmpqmpqqpm)(11pqqpm12)1()1()(11qppqqpm22)(pqgpqvx122221)(1pqpqpqqppqqpxvvy)(vxfpqpqpqpqxfv44)11()(2nnmmf4)1()(2nnm212 
 
 
 
 
 
 
 
 39   

Figura 6: A função 

4.10 A ESCOLHA DOS NÚMEROS PRIMOS 

Um ponto muito importante no método RSA é a escolha dos dois números primos 

  e 

  que  serão  utilizados,  pois  se  ambos  forem  muito  pequenos  é  fácil  de  encontrá-

los.Entretanto  não  basta  que  ambos  sejam  muito  grandes  para  garantir  a  segurança  do 

método,  pois  se 

  é  pequeno,  é  fácil  fatorar 

,  utilizando  o  algoritmo  de 

Fermat. 

Segundo Coutinho (2011), em 1995 dois estudantes de uma universidade americana, 

quebraram a versão do RSA em uso público, pelo fato da escolha dos números primos ser 

totalmente inadequada.   

Para  implementar  o  RSA  com  chave  pública 

,  de  modo  que 

  tenha 

algarismos sugere-se que o primo 

  esteja no intervalo de 

  e 

  algarismos e em 

seguida, supor que o primo 

  seja próximo de 

, (COUTINHO, 2011). 

4.11 UMA ANÁLISE PARA QUEBRAR O RSA 

Na  área  de  estudos  em  algoritmos  de  fatoração  não  é  conhecido  um  algoritmo 

determinístico, em tempo polinomial, que encontre um fator de um inteiro composto n com 

muitos algarismos. Este fato está diretamente relacionado ao método RSA, pois caso este 

algoritmo  existisse,  seria  possível  encontrar  facilmente  os  fatores  primos  de  n,  e 

nnmmf4)1()(2pqqppqn),(nnrp104r10045rqpr10 
 
 
 
 
 
 
 
 
 
 
 40   

consequentemente  saber  o  valor  de 

  e  também  encontrar  o  expoente 

,  que  é  a 

chave de decodificação do par 

.   

Nota-se algumas possibilidades de decifrar o método RSA, sendo apenas conhecido 

o valor de n: fatorar n, encontrar 

  ou encontrar d sem fatorar n ou encontrar 

. 

Para  o  caso  de  encontrar 

,  conhecendo  apenas  n,  utilizando  a  função 

, no apêndice encontra-se o algoritmo implementado no Maple 12 

que calcula o 

. Observa-se que a busca pelo valor de 

, pode ser feita por meio 

da menor raiz na função, sendo verificado se a parte inteira da raiz é  múltiplo de quatro; 

caso  negativo,  deve-se  subtrair  um  até  encontrar  o  primeiro  valor  múltiplo  de  quatro. 

Substitui-se esse valor próximo da raiz, se o resultado for um  quadrado  perfeito, então o 

valor  é  o 

;  senão  subtrai-se  quatro  e  substitui  novamente  na  função  até  gerar  um 

quadrado perfeito. 

O  fato  de  verificar  se  o  número  é  um  múltiplo  de  quatro,  e  também  de  subtrair 

quatro  até  encontrar  um  quadrado  perfeito,  deve-se  a  característica  da  função 

,  pois  p  e  q  são  primos,  logo 

  será  o  produto  de  dois  números 

pares, resultando num múltiplo de quatro. 

Portanto,  se existisse um  método aplicado na função 

, que 

encontrasse  rapidamente  um  quadrado  perfeito  no  intervalo  de  0  a 

,  então  o 

valor 

aplicado 

na 

função 

seria 

o 

valor 

de 

.   

)(nd),(dn)(n)(n)(nnnmmf4)1()(2)(n)(n)(n)1()1()(qpn)(nnnmmf4)1()(2nn21)(n 
 
 
 
CAPÍTULO 5 - APLICAÇÕES EM SALA DE AULA 

O  objetivo  deste  capítulo  é  propor  atividades  motivadoras  que  possam  auxiliar  os 

professores no momento de ensinar determinados conteúdos. 

 41   

5.1 CRIPTOGRAFIA RSA REDUZIDA 

Tema: Criptografia RSA Reduzida 

Objetivo: Essa atividade propõe o estudo do método RSA apenas utilizando-se de 

um número primo para o valor em 

  e a função 

. 

Conteúdos  Relacionados:  Números  Primos,  Potenciação,  Congruências,  Divisão 

de Números Naturais. 

Série de Aplicação: 9º ano 

Duração: 6 aulas 

Recursos Pedagógicos: Lousa e giz, caderno, lápis e calculadora. 

Metodologia:  Os  alunos  deverão  sentar  em  duplas  e  um  deles  irá  criptografar  uma 

mensagem  e  o  outro  irá  tentar  decodificá-la.  Será  utilizado  a  chave 

  com  (

primo)  , 

  e  a  função 

  e 

.  Como  exemplo  será 

apresentado aos alunos a palavra “MESTRE”, utilizando como chave de codificação o par 

  e 

.  O  primeiro  passo  é  relacionar  a  mensagem  com  os  números,  como  na 

Tabela 2:  Tabela de conversão, que consta na seção 4.3. Sendo  assim,  a  mensagem  a ser 

criptografada  é  22.14.28.29.27.14  ,  logo  quebrando  a  mensagem  em  blocos  menores  que 

17, tem-se: 

2 

B1 

2 

B2 

14 

B3 

2 

B4 

8 

B5 

2 

B6 

9 

B7 

2 

B8 

7 

14 

B9 

B10 

Tabela 5: Código em blocos 

pn1)(pnpnp)6(mod5p1)(pn317n3 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 42   

Cada  um  desses  blocos  será  criptografado  por 

.  Durante  a 

codificação será explicado a relação do resto das divisões e a importância da congruência, 

utilizando a calculadora, lousa e giz. 

Calculando 

, tem-se: 

Sendo assim, a mensagem codificada é 8.8.7.8.2.8.15.8.3.7 .   

A  informação  necessária  para  poder  decodificar  consiste  no  par 

.  Em  que 

,  e  o  valor  do 

  é  o  inverso  de 

  em 

,  ou  seja, 

logo 

,  portanto  d  =  11.  Pelo  Capítulo  4.5,  se 

então 

  e 

.  Nesse  caso,  tem-se  que 

, 

e 

, 

pois 

.  Como 

  e 

,  então 

.  Assim 

,  e 

. 

Logo para a decodificação será explicado que 

  e 

, ficando 

a cargo do aluno que irá decodificar, efetuar os cálculos e encontrar o valor de 

. 

Para decodificar utiliza-se 

, logo: 

)(modnABii)(modnABii)17(mod823)17(mod823)17(mod7143)17(mod823)17(mod283)17(mod823)17(mod1593)17(mod823)17(mod373)17(mod7143),(dn1)(pnd)(n))((mod1nd)16(mod13d)6(mod5p)6(mod5q34kd46)(kn)6(mod5p17p46)(kn4616k2k34kd11324d46)(kn34kdd)(modnBAidi)17(mod2811)17(mod2811)17(mod14711)17(mod2811)17(mod8211 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 43   

Sendo assim a mensagem decodificada é 2.2.14.2.8.2.9.2.7.14. Como 

, basta 

unir os blocos com dois algarismos cada, e retornando nos números: 22.14.28.29.27.14 e a 

mensagem é decodificada. 

Após  todos  codificarem  e  decodificarem  as  mensagens,  será  proposta  uma 

mensagem  pelo  professor,  para  averiguar  se  todos  conseguiram  alcançar  o  objetivo  da 

atividade. 

Avaliação:  A  avaliação  será  da  seguinte  maneira:  o  aluno  que  codificou 

corretamente a mensagem terá pontuação máxima. O aluno que decodificou corretamente 

terá  pontuação  máxima;  o  aluno  que  decodificou  a  mensagem  do  professor  corretamente 

terá  a pontuação máxima na  atividade  e caso o  aluno  que  codificou  erre no momento  da 

codificação  esse  será  auxiliado  pelo  professor  para  que  possa  alcançar  o  objetivo;  assim, 

como o aluno que errou no momento de decodificar, ou no momento de calcular o valor de 

.   

5.2 CRIPTOGRAFIA RSA E A FUNÇÃO DO SEGUNDO GRAU 

Tema: Criptografia RSA e a Função do Segundo Grau. 

Objetivo: Essa atividade propõe o estudo da Função do Segundo Grau ,utilizando-

se do método RSA, para motivar o aprendizado, especificamente no cálculo das raízes. 

Conteúdos  Relacionados:  Função  do  Segundo  Grau,  Cálculo  do  Discriminante, 

Cálculo das Raízes e Números Primos. 

Série de Aplicação: 1º ano do Ensino Médio 

)17(mod2811)17(mod91511)17(mod2811)17(mod7311)17(mod1471117nd 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Duração: 6 aulas 

Recursos Pedagógicos: Lousa e giz, caderno, lápis e calculadora. 

 44   

Metodologia:  Será  abordado  o  estudo  da  Função  do  Segundo  Grau  por  meio  da 

criptografia  RSA.  Os  alunos  deverão  escolher  dois  números  primos  quaisquer 

, 

efetuar o produto deles para gerar o valor de 

  e efetuar a subtração de 

  por 

  para 

gerar  o  valor  de 

,  logo 

  e 

  .  Considere  a  função  f  : 

,  tal 

que

. Os alunos serão orientados a substituir o resultado de 

  no 

lugar  de 

  e 

resolver  a  equação  em 

função  de 

.  Sendo  assim, 

  ou 

.  As 

raízes  dessa 

equação  são 

  e 

.  O  importante  para  o  método 

RSA é apenas a menor raiz, sendo ela o 

  e 

. 

Os  valores  encontrados  nas  raízes  da  equação  do  segundo  grau  serão  discutidos 

com os alunos, investigando por parte deles uma relação da menor raiz com o valor de 

e será mostrado a importância dessa menor raiz no método RSA. Após os alunos terem o 

domínio do cálculo das raízes de uma Equação do Segundo Grau e perceberem a relação 

da menor raiz, será explorado os conceitos do vértice da parábola por meio das raízes, ou 

seja,  a  média  aritmética  das 

raízes 

resulta  no 

  da 

função,  ou 

seja, 

  e  também  o  conceito  do 

, 

calculado por meio de 

, ou seja, 

. 

Portanto,  nessa  função  específica  será  estudado  o  cálculo  das  raízes,  analisando  o 

padrão que acontece no cálculo do vértice da parábola. 

Avaliação: A avaliação será da seguinte maneira: O aluno que encontrou as raízes 

corretamente  e  analisou  a  relação  da  menor  raiz  com  o  valor  de 

  terá  a  pontuação 

máxima. O aluno que resolver corretamente todos os exercícios propostos terá a pontuação 

máxima.  Os  alunos  que  não  conseguiram  resolver  ou  resolveram  parcialmente  os 

exercícios, serão auxiliados para que possam compreender todo o conteúdo ministrado. 

qpnqpgpqnpqgRRnnmmf4)1()(22g)(mfmnnmg4)1(22012222222pqqpmmpqmpqqpm)(11pqqpm121m)1()1()(11qppqqpmnvx122221)(1pqpqpqqppqqpxvvy)(vxfpqpqpqpqxfv44)11()(2n 
 
 
 
 
 
 
 
 
 
 45   

5.3 CRIPTOGRAFIA COM MATRIZES 

Tema: Criptografia com Matrizes 

Objetivo:  Essa  atividade  propõe  o  estudo  da  multiplicação  e  o  cálculo  da  matriz 

inversa, utilizando-se da criptografia pelas Cifras de Hill. 

Conteúdos Relacionados: Produto de Matrizes e Cálculo da Matriz Inversa. 

Série de Aplicação: 2º ano do Ensino Médio 

Duração: 8 aulas 

Recursos Pedagógicos: Lousa e giz, caderno e lápis. 

Metodologia:  Para  codificar  uma  mensagem,  utiliza-se  uma  tabela  de  números 

referente ao alfabeto, escrever uma mensagem com esses números da tabela 6 em forma de 

uma matriz e multiplicar pela esquerda por uma outra matriz, desde que seja possível essa 

multiplicação, transformando a mensagem original em um código conforme abaixo:   

Código B: 

15 

24 

31 

38 

8 

19 

16 

25 

19 

14 

60 

40 

45 

21 

27 

12 

3 

2 

Tabela 7: Código 

para conversão. 

Dada a seguinte tabela:   

1 – A   

2 – B 

3 – C 

4 – D 

5 – E 

6 – F 

7 – G 

8 – H 

9 – I 

10 – J 

11 – K 

12 – L 

13 – M  14 – N 

15 – O  16 – P 

17 – Q  18 – R 

19 – S 

20 – T 

21 – U 

22 – V  23 – W  24 – Y  25 – X 

26 – Z 

27 - vazio 

  Tabela 8: Alfabeto de conversão.   

Decodifique o Código da Tabela 6, sabendo que a chave que os codificou é a matriz 

.   

Considerando  a  mensagem 

,  aplicando  a  matriz  chave 

  pela  esquerda, 

1112AMA 
 
 
 
 
 
 
 
 
 
 
 
obtém-se a mensagem codificada 

, ou seja, 

, para decodificar a mensagem 

aplica-se a matriz inversa 

  em ambos os membros, 

, logo 

 46   

, 

. 

Portanto para decodificar a mensagem basta calcular a matriz inversa de 

  e multiplicar 

pela esquerda o código recebido. 

Neste caso 

, multiplicando por 

  a mensagem 

:   

, obtém-se: 

  que corresponde a mensagem: 

  Após todos conseguirem decodificar a mensagem proposta, os alunos deverão 

entregar alguma mensagem codificando e decodificando. 

Avaliação:  A  avaliação  será  da  seguinte  maneira:  O  aluno  que  calculou 

corretamente  a  matriz  inversa  e  decodificou  corretamente  a  mensagem  terá  pontuação 

máxima. O aluno que não conseguiu calcular a matriz inversa ou que multiplicou a matriz 

inversa  incorretamente  no  momento  de  decodificação,  será  auxiliado  por  meio  de 

explicação no quadro e proposto um novo exercício de decodificação. 

5.4 CRIPTOGRAFIA COM FUNÇÃO DO PRIMEIRO GRAU 

Tema: Criptografia com Função do Primeiro Grau 

Objetivo: Essa atividade propõe o estudo da função do primeiro grau e da função 

inversa. 

Conteúdos Relacionados: Função do Primeiro Grau e Função Inversa. 

Série de Aplicação: 1º ano do Ensino Médio 

Duração: 4 aulas 

BBAMB1ABAAMA11BAM1A21111A1AB212274014251619832145601938312415.21111392091211411918205131557ACITILANAAIRTEMOEG 
 
 
 
 
 
 
 
 
 
 
 
 47   

Recursos Pedagógicos: Lousa e giz, caderno e lápis. 

Metodologia: Será abordado os conceitos de função do primeiro grau, escolhendo a 

função  f  : 

,  tal  que 

,  para  codificar  a  mensagem  “MESTRE”,  o 

primeiro passo é relacionar a mensagem com os números na Tabela 2: Tabela de conversão, 

que consta na seção 4.3. Logo a palavra “MESTRE” corresponde aos números: 22 14 28 

29 27 14, aplicando cada um dos pontos na função 

, tem-se: 

Sendo assim, a mensagem codificada é 45 29 57 59 55 29. 

Para  decodificar  a  mensagem,  precisa-se  encontrar  a  função 

inversa  de 

, logo: 

. Para decodificar utiliza-se 

, logo: 

Sendo  assim,  a  mensagem  decodificada  é  22  14  28  29  27  14,  que  corresponde  a 

palavra “MESTRE”. 

Avaliação:  A  avaliação  será  da  seguinte  maneira:  O  aluno  que  calculou 

RR12)(xxf12)(xxf451222)22(f291142)14(f571282)28(f591292)29(f551272)27(f291142)14(f12)(xxf21)(1xxf21)(1xxf222145)45(1f142129)29(1f282157)57(1f292159)59(1f272155)55(1f142129)29(1f 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
corretamente  a  função  inversa  e  decodificou  corretamente  a  mensagem  terá  pontuação 

máxima.  O  aluno  que  não  conseguiu  calcular  a  função  inversa  ou  que  calculou 

incorretamente  no  momento  de  decodificação,  será  auxiliado  por  meio  de  explicação  no 

quadro e proposto um novo exercício de decodificação. 

 48   

5.5 CRIPTOGRAFIA COM FUNÇÃO DO SEGUNDO GRAU 

Tema: Criptografia com Função do Segundo Grau 

Objetivo: Essa atividade propõe o estudo da função do segundo grau e da função 

inversa. 

Conteúdos Relacionados: Função do Segundo Grau e Função Inversa. 

Série de Aplicação: 1º ano do Ensino Médio 

Duração: 4 aulas 

Recursos Pedagógicos: Lousa e giz, caderno e lápis. 

Metodologia: Será abordado os conceitos de função do segundo grau, escolhendo a 

função  f  : 

,  tal  que 

,  para  codificar  a  mensagem  “MESTRE”,  o 

primeiro passo é relacionar a mensagem com os números na Tabela 2: Tabela de conversão, 

que consta na seção 4.3. Logo a palavra “MESTRE” corresponde aos números: 22 14 28 

29 27 14, aplicando cada um dos pontos na função 

, tem-se: 

Sendo assim, a mensagem codificada é 485 197 785 842 730 197. 

RR1)(2xxf1)(2xxf485122)22(2f197114)14(2f785128)28(2f842129)29(2f730127)27(2f197114)14(2f 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Para  decodificar  a  mensagem,  precisa-se  encontrar  a  função 

inversa  de 

, logo:   

. Para decodificar utiliza-se 

, logo: 

 49   

Sendo  assim,  a  mensagem  decodificada  é  22  14  28  29  27  14,  que  corresponde  a 

palavra “MESTRE”. 

Avaliação:  A  avaliação  será  da  seguinte  maneira:  O  aluno  que  calculou 

corretamente  a  função  inversa  e  decodificou  corretamente  a  mensagem  terá  pontuação 

máxima.  O  aluno  que  não  conseguiu  calcular  a  função  inversa  ou  que  calculou 

incorretamente  no  momento  de  decodificação,  será  auxiliado  por  meio  de  explicação  no 

quadro e proposto um novo exercício de decodificação. 

5.6 CRIPTOGRAFIA COM FUNÇÃO EXPONENCIAL 

  Tema: Criptografia com Função Exponencial 

Objetivo: Essa atividade propõe o  estudo da  Função Exponencial e  a sua Função 

Inversa. 

Conteúdos Relacionados: Função Exponencial e Função Logarítmica. 

Série de Aplicação: 1º ano do Ensino Médio 

Duração: 6 aulas 

1)(2xxf1)(1xxf1)(1xxf221485)485(1f141197)197(1f281785)785(1f291842)842(1f271730)730(1f141197)197(1f 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 50   

Recursos Pedagógicos: Lousa e giz, caderno e lápis. 

Metodologia:  Será  abordado  os  conceitos  de  função  exponencial,  escolhendo  a 

função f : 

, tal que 

, para codificar a mensagem “MESTRE”, o primeiro 

passo  é  relacionar  a  mensagem  com  os  números  na  Tabela  2:  Tabela  de  conversão,  que 

consta na seção 4.3. Logo a palavra “MESTRE” corresponde aos números: 22 14 28 29 27 

14, quebrando em bloco de apenas um algarismo para facilitar as contas, obtendo: 2 2 1 4 2 

8 2 9 2 7 1 4 e aplicando cada um dos pontos na função 

, tem-se: 

Sendo assim, a mensagem codificada é 4 4 2 16 4 256 4 512 4 128 2 16. 

Para decodificar a mensagem, precisa-se encontrar a função inversa de 

, 

logo: 

. Para decodificar utiliza-se 

, logo: 

RRxxf2)(xxf2)(42)2(2f42)2(2f22)1(1f162)4(4f42)2(2f2562)8(8f42)2(2f5122)9(9f42)2(2f1282)7(7f22)1(1f162)4(4fxxf2)()2log()log()(1xxf)2log()log()(1xxf2)2log()4log()4(1f2)2log()4log()4(1f1)2log()2log()2(1f 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 51   

Sendo  assim,  a  mensagem  decodificada  é  2  2  1  4  2  8  2  9  2  7  1  4,  reunindo  cada 

bloco  com  dois  algarismo  tem-se:  22  14  28  29  27  14  que  corresponde  a  palavra 

“MESTRE”. 

Avaliação:  A  avaliação  será  da  seguinte  maneira:  O  aluno  que  calculou 

corretamente  a  função  inversa  e  decodificou  corretamente  a  mensagem  terá  pontuação 

máxima.  O  aluno  que  não  conseguiu  calcular  a  função  inversa  ou  que  calculou 

incorretamente  no  momento  de  decodificação,  será  auxiliado  por  meio  de  explicação  no 

quadro e será proposto um novo exercício de decodificação. 

4)2log()16log()16(1f2)2log()4log()4(1f8)2log()256log()256(1f2)2log()4log()4(1f9)2log()512log()512(1f2)2log()4log()4(1f7)2log()128log()128(1f1)2log()2log()2(1f4)2log()16log()16(1f 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
CONSIDERAÇÕES FINAIS 

 52   

Inquestionavelmente, a criptografia é um assunto muito interessante que possibilita 

a  segurança  na  transmissão  de  informações  importantes.  O  presente  trabalho  teve  como 

objetivo estudar o método RSA e também articular o tema criptografia com os conteúdos 

da  Matemática.  Foram  abordadas  algumas  fórmulas  que  geram  números  primos,  assim 

como  alguns  algoritmos  de  fatoração,  destacando  o  algoritmo  de  Fermat,  que 

potencialmente  fatora  o  produto  de  dois  números  primos  em  tempo  polinomial,  se  esses 

dois números forem próximos. 

Foram citados três casos que podem ser estudados na tentativa de quebrar o método   

RSA  (fatorar  n,  encontrar 

  ou  encontrar  d  sem  fatorar  n  ou  encontrar 

)  e 

também  proposto  um  método  para  tentar  encontrar 

.  No  apêndice  encontra-se  o 

algoritmo  implementado  no  Maple12,  que  utiliza  a  função 

,  até 

gerar  o  quadrado  perfeito,  encontrando  assim 

  e  por  meio  da 

resolução de uma equação do segundo grau, encontram-se os fatores primos p e q. 

Por  meio  da  função 

,  foi  possível  encontrar  os  fatores 

primos com um menor número de repetições em relação ao algoritmo de Fermat, pois pelo 

método de Fermat, o incremento de 

  é de apenas uma unidade e calcula-se 

, 

até 

  gerar  um  número  inteiro,  enquanto  na  função 

,  subtrai-se 

quatro unidades e aplica-se o novo ponto até gerar um quadrado perfeito.   

RECOMENDAÇÕES PARA ESTUDOS FUTUROS 

Para a continuidade deste estudo sobre a criptografia RSA, recomenda-se a análise 

da  função 

,  tentando  delimitar  um  intervalo  mais  eficiente  de 

busca  do  quadrado  perfeito,  pois  no  algoritmo  que  se  encontra  no  apêndice,  o  critério 

utilizado para iniciar, foi pela parte inteira da menor raiz da função, avaliando se é múltiplo 

de quatro, sendo assim, a busca inicia na proximidade do quadrado perfeito 1, ou seja, para 

números com muitos algarismos, o quadrado perfeito na função será um número muito alto, 

visto que esse quadrado perfeito é a diferença dos números primos elevado ao quadrado, os 

quais não são próximos. Assim, sugere-se um estudo para delimitar melhor esse intervalo 

de busca ou algum método que identifique rapidamente os quadrados perfeitos na função.     

)(n)(n)(nnnmmf4)1()(2)1()1()(qpnnnmmf4)1()(2xnxy2ynnmmf4)1()(2nnmmf4)1()(2 
 
 
 
 
 
 
REFERÊNCIAS BIBLIOGRÁFICAS 

 53   

COUTINHO, S.C. Números Inteiros e Criptografia RSA. Rio de Janeiro, IMPA, 2011. 

226 páginas (Coleção Matemática e Aplicações).   

DANTE, L. R. Matemática: Contexto e aplicações. São Paulo: Ática , 2010. 

EUCLIDES. Os elementos. UNESP, 2009. Tradução brasileira por Irineu Bicudo. 

HEFEZ, A. Curso de  Álgebra, vol.  1, Coleção Matemática Universitária,  IMPA, Rio  de 

Janeiro, 2002. 

HEFEZ, A. Elementos de Aritmética. 2. ed. Rio de Janeiro: SBM, 2011. 176p.   

IEZZI, G. [et al.]. Matemática: ciência e aplicações, 2 : ensino médio. 6. ed. São Paulo: 

Saraiva, 2010. 

(OLGIN,  C.A.;GROENWALD,  C.L.O.  Engenharia  Didática:  Uma  experiência  com  o 

tema 

criptografia. 

Em: 

<http://periodicos.uniban.br/index.php/JIEEM/article/viewArticle/214>  Acesso  em:  27  de 

setembro de 2015.) 

RIBENBOIM,  P.  Números  Primos.  Velhos  Mistérios  e  novos  recordes.  1  ed.  Rio  de 

Janeiro: IMPA,2012. 328 p. 

RIVEST,  R.L.,  SHAMIR,  A.  E  ADLEMAN,  L.M.  A  Method  for  obtaining  digital 

signatures and public-key cryptosystems. Commun ACM 21, 2(1978), 120-126. 

ROUSSEAU, C.; AUBIN.Y.S. Matemática e Atualidade. Rio de Janeiro: SBM, 2015. 256 

páginas (Coleção PROFMAT). 

VOLOCH, J.F. A distribuição dos números primos. Matemática Universitária, número 06, 

71-82. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 54   

APÊNDICE 

ALGORITMO PROGRAMADO NO MAPLE 

> #N:= p*q;    # M:= (p-1)*(q-1); 

> p:= ; q:= ; N:=p*q; 
> Digits:= 600; 

> f:= x -> x^2 + (M - N - 1)*x + N; 

> Delta:= (M - N - 1)^2 - 4*N; 

> fDelta:= unapply(Delta,M); 

> expand(fDelta(M)); 

> Raizes_de_M:= solve(Delta,M); 

> M1:=floor(min(evalf(Raizes_de_M)))+1;    M2:=floor(max(evalf(Raizes_de_M))); 

> resid:=5; 
passo4ou1:=1; 
while passo4ou1 = 1 do 
      M1:= M1-passo4ou1; 
      if irem(M1,4) = 0 then 
            passo4ou1:=4; 
      end if: 
end do; 

> M1;fDelta(M1);sqrt(fDelta(M1)); 

> TempoIni:=time(); 
resid:=5; 
while resid > 0 do 
      M1:=M1-4;       
      resid:= frac(evalf(sqrt(fDelta(M1)))) 
end do: 
TempoFinal:=time()-TempoIni; 

> M1; 

 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
