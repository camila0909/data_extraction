TIAGO ROSSI DIAS

CRIPTOGRAFIA COM RESÍDUOS QUADRÁTICOS

Santo André, 2017

UNIVERSIDADE FEDERAL DO ABC

CENTRO DE MATEMÁTICA, COMPUTAÇÃO E COGNIÇÃO

TIAGO ROSSI DIAS

CRIPTOGRAFIA COM RESÍDUOS QUADRÁTICOS

Orientador: Prof. Dr. Jerônimo Cordoni Pellegrini

Dissertação de mestrado apresentada ao Centro de

Matemática, Computação e Cognição para

obtenção do título de Mestre

ESTE EXEMPLAR CORRESPONDE A VERSÃO FINAL DA DISSERTAÇÃO

DEFENDIDA PELO ALUNO TIAGO ROSSI DIAS,

E ORIENTADA PELO PROF. DR. JERÔNIMO CORDONI PELLEGRINI.

SANTO ANDRÉ, 2017

 
 
 
 
 
 
 
Dedico este trabalho a meu pai, que mesmo

longe ainda é meu herói, e a minha mãe, que

amo incondicionalmente.

iii

A G R A D E C I M E N T O S

Agradeço a Deus, por tudo que Ele possibilitou em minha vida, principalmente por

ter tido a dádiva de conhecer a todos que agradecerei a seguir.

Agradeço a meu pai e minha mãe, por mostrarem para mim o quão importante é o

estudo e especialmente incentivar o gosto que tenho pela Matemática.

Agradeço a minha irmã e todos os meus parentes e amigos, pelo apoio e suporte que

me deram.

Agradeço a equipe gestora da Escola Estadual Prefeito Domingos de Souza, pela

ajuda que deram para que eu pudesse cursar esse mestrado.

Por último, mas não menos importante, agradeço a todos os meus professores, pois

sempre me incentivaram a questionar e buscar o conhecimento.

v

“A Matemática, devidamente observada, possui não so-

mente a verdade, mas suprema beleza - uma beleza fria

e austera, como a de uma escultura.”

(Bertrand Russel)

vii

R E S U M O

Esse trabalho tem como objetivo mostrar como problemas de difícil solução, em

especial o problema dos resíduos quadráticos, podem ser usados para desenvolver

criptossistema com segurança demonstrável, com algumas aplicações que podem ser

desenvolvidas com alunos de ensino fundamental e médio. Faz-se um resumo da his-

tória da criptograﬁa, desde a Cifra de César e passando por diversos criptossistemas

historicamente famosos, até chegar ao sigilo perfeito do one-time pad. São trabalha-

dos também alguns conceitos matemáticos necessários, como as funções de mão única

e uma breve explicação de algumas funções conjecturadas de mão única, que podem

ser usadas em sistemas criptográﬁcos seguros. Em seguida, apresenta-se os gerado-

res de números pseudo-aleatórios, em especial o de Blum-Blum-Shub por empregar

resíduos quadráticos. A seguir, há uma breve apresentação das funções de hash e do

problema do aniversário associado a elas, com uma função de hash construída base-

ada no gerador de Blum-Blum-Shub. Também importante é a aplicação na encriptação

com chave pública, em especial o criptossistema de Rabin, que também é usado para

estabelecer um sistema de votação com base no homomorﬁsmo apresentado por esse

sistema. Para ﬁnalizar, fala-se sobre as provas de conhecimento zero e como as raízes

quadradas módulo N podem ser utilizadas para isso, em particular com o Protocolo de

Feige-Fiat-Shamir. Uma aplicação para a sala de aula é dada na forma de um leilão,

utilizando o conceito da diﬁculdade da raiz quadrada modular.

Palavras-chave: criptograﬁa, teoria dos números, resíduos quadráticos

ix

A B S T R A C T

The main objective of this work is to show how hard to solve problems, specially the

problem of quadratic residuality, can be used to create cryptographic algorithms with

provable security. Some applications could be done with students from elementary and

high school. We will start with a brief history of cryptography, from Cesar Cipher and

going through several famous cryptosystems until the perfect secrecy of the one-time

pad. We will work in a few basic concepts, such as one-way functions and a succinct

explanation on some functions that are conjectured to be one-way and can be used

in provably secure cryptographic systems. We choose the modular squaring to show

on the following chapters how one-way functions are used to build several algorithms

(pseudo-random number generators, hash functions, public key encryption, a voting

system based on a homomorphic cryptosystem and, at last, zero-knowledge proofs).

We will provide a classroom example in the ways of an auction, using the difﬁculty of

the modular square root.

Keywords: cryptography, number theory, quadratic residue

xi

C O N T E Ú D O

I N T R O D U Ç Ã O

1 H I S T Ó R I A D A C R I P T O G R A F I A

1.1 A Cifra de César . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 O Atbash Hebraico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.3 A Cítala Espartana . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.4 A Cifra de Vigenère . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.5 A Cifra de Hill . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.6 A Máquina Enigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.7 O Princípio de Kerckhoff . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.8 Sigilo Perfeito . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

3

3

4

4

5

7

8

8

9

1.9 One-time pad . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.10 Segurança Demonstrável . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

2 F U N Ç Õ E S D E M Ã O Ú N I C A

13

2.1 Função Desprezível . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.2 Função de Mão Única . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.2.1 Exponenciação Discreta . . . . . . . . . . . . . . . . . . . . . . . 15

2.2.2 Multiplicação de Inteiros . . . . . . . . . . . . . . . . . . . . . . . 15

2.2.3 Quadrado Modular . . . . . . . . . . . . . . . . . . . . . . . . . . 16

2.2.4 Soma de Subconjuntos . . . . . . . . . . . . . . . . . . . . . . . . 17

2.3 Predicado hard-core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3 G E R A D O R E S D E N Ú M E R O S P S E U D O - A L E AT Ó R I O S

19

3.1 Gerador de Números Pseudo-aleatórios de Blum-Blum-Shub . . . . . . . 20

4 F U N Ç Õ E S D E H A S H

23

4.1 Requisitos das Funções de Hash . . . . . . . . . . . . . . . . . . . . . . . 23

4.2 Problema do Aniversário . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

4.3 Construção de Função de Hash . . . . . . . . . . . . . . . . . . . . . . . 26

4.4 Resíduos Quadráticos como Função de Hash . . . . . . . . . . . . . . . . 26

xiii

xiv

Conteúdo

5 E N C R I P TA Ç Ã O C O M C H A V E P Ú B L I C A

29

5.1 Criptossistema de Rabin . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

5.2 Segurança do Criptossistema de Rabin . . . . . . . . . . . . . . . . . . . 32

5.3 Encriptação Homomórﬁca . . . . . . . . . . . . . . . . . . . . . . . . . . 33

5.3.1 Sistemas de Votação . . . . . . . . . . . . . . . . . . . . . . . . . 33

6 P R O VA D E C O N H E C I M E N T O Z E R O

37

6.1 Prova de Conhecimento Zero com Raízes Quadradas Módulo N . . . . . 38

6.2 Protocolo Feige-Fiat-Shamir . . . . . . . . . . . . . . . . . . . . . . . . . 39

7 A P L I C A Ç Ã O E M S A L A D E A U L A

Bibliograﬁa

43

47

I N T R O D U Ç Ã O

A criptograﬁa é um campo importante do conhecimento humano, principalmente

na era atual, onde tantas informações importantes trafegam diariamente pela internet.

Entre outros méritos, a criptograﬁa trouxe uma aplicação para a área da Teoria dos

Números que era considerada uma das áreas mais abstratas da Matemática. Mesmo

com a importância atual dessa parte da Matemática, ela é pouco trabalhada nas escolas,

que enfatizam o conjunto dos números reais para tratamento e solução de problemas.

Como veremos, questões importantes e de difícil solução podem ser encontradas

no campo da Matemática Discreta, podendo citar os resíduos quadráticos dentro das

classes de congruências módulo m. De maneira geral, dizemos que a é um resíduo
quadrático módulo p se a congruência X2 = a (mod p) tem solução; caso contrário,
dizemos que a não é resíduo quadrático módulo p.

Com esse trabalho, procuramos encontrar um sistema criptográﬁco simples o su-

ﬁciente para poder ser trabalhado com alunos de ensino médio mas com segurança

demonstrável a partir de conjecturas conﬁáveis, entre elas a diﬁculdade da fatoração

de inteiros e a raiz quadrada modular.

No decorrer deste trabalho, mostraremos como os resíduos quadráticos podem ser

usados em alguns criptossistemas, com exemplos práticos que podem ser adaptados

para outras situações. Certamente, existem outros meios de obter os resultados deseja-

dos com métodos computacionalmente mais rápidos, mas o conceito matemático serve

como base para aprofundar os conhecimentos sobre o tema proposto.

Esse trabalho tem como objetivo mostrar aplicações para a matemática modular,

em especial os resíduos quadráticos, por tratar-se de um campo meio esquecido nos

ensinos fundamental e médio que costumam priorizar a matemática com números

reais mesmo em situações onde faz mais sentido trabalhar com números inteiros.

Nesse estudo, veremos um método interessante para votação usando o problema da

raiz quadrada modular, utilizando para sua segurança um problema conjecturado de

difícil solução. Além disso, mostramos um estudo sobre outros sistemas criptográﬁcos

importantes que utilizam resíduos quadráticos para demonstrar sua segurança.

1

2

I N T R O D U Ç Ã O

Para desenvolver esse trabalho, foi feita uma pesquisa bibliográﬁca com diversas

fontes, buscando textos e artigos importantes da criptograﬁa, alguns ainda usados

atualmente para segurança de sistemas.

O trabalho está dividido em sete capítulos, começando com uma revisão histórica

da criptograﬁa e depois fazendo uma breve descrição sobre funções de mão única. Em

seguida, falamos sobre geradores pseudo-aleatórios, em especial o de Blum-Blum-Shub

e depois sobre funções de hash. Há um capítulo sobre sistemas de chave pública, onde

não poderia faltar o criptossistema de Rabin e em seguida uma aplicação interessante

dos resíduos quadráticos com provas de conhecimento zero. Finalizamos com uma

aplicação em sala de aula interessante, que pode ser usada com alunos de ensino

fundamental e médio após alguma preparação.

1

H I S T Ó R I A D A C R I P T O G R A F I A

É difícil dizer com certeza quando surgiu a criptograﬁa. Sabe-se que, com o advento

da escrita, surgiu a necessidade de impedir que determinados textos fossem lidos. Es-

ses textos provavelmente deveriam conter segredos de estado ou planos de batalha.

Podemos dividir a história da criptograﬁa em três fases [6]. Na primeira fase, mais

antiga, os textos a serem criptografados usavam apenas papel e tinta para serem cifra-

dos e decifrados. A segunda fase chega com a utilização de máquinas eletro-mecânicas

na criptograﬁa, na época da Segunda Guerra Mundial. A terceira fase é a atual, com

os computadores fazendo o trabalho criptográﬁco. Nesse último período, mais atual, a

Matemática passa a ter um papel importante devido ao conceito de segurança demons-

trável.

Nesse trabalho serão apresentados apenas alguns exemplos de cifras, pois uma des-

crição completa está fora do escopo desse trabalho. Para os interessados em uma

descrição mais detalhada, ver [6] ou [12].

1.1 A C I F R A D E C É S A R

Essa cifra, creditado ao imperador romano Júlio César, é relativamente simples de

cifrar e decifrar. Nele as letras do texto original (em minúsculas) eram trocadas pelo

texto criptografado (em maiúsculas) de acordo com a tabela:

a

(cid:108)

b

(cid:108)

c

(cid:108)

d

(cid:108)

e

(cid:108)

f

(cid:108)

g

(cid:108)

h

(cid:108)

i

(cid:108)

j

(cid:108)

k

(cid:108)

l m

(cid:108)

(cid:108)

D E F G H I

J K L M N O P

3

4

H I S T Ó R I A D A C R I P T O G R A F I A

n

(cid:108)

o

(cid:108)

p

(cid:108)

q

(cid:108)

r

(cid:108)

s

(cid:108)

t

(cid:108)

u

(cid:108)

v w x

(cid:108)

(cid:108)

(cid:108)

y

(cid:108)

z

(cid:108)

Q R S T U V W X Y

Z A B C

Por exemplo, o texto “hoje e segunda feira” seria transformado em “KRMH H VHJXQGD

IHLUD”. Os espaços estão aí apenas para melhorar a compreensão, em um texto crip-

tografado eles seriam retirados.

Esse tipo de cifra é chamado de cifra de deslocamento. Se cada letra de A a Z for

transformada em um número inteiro correspondente de 0 a 25, essa transformação é

análoga a operação de adição modular, onde o texto original d é transformado no texto

cifrado c usando a fórmula c = d + k (mod 26). No exemplo da cifra de César, temos

que a chave k vale 3, mas poderia ser qualquer outro número inteiro. Isso fornece 25

chaves diferentes (excluindo-se o 0, que tornaria o texto cifrado igual ao original).

1.2 O AT B A S H H E B R A I C O

No atbash, a substituição é feita substituindo a primeira letra do alfabeto pela última,

a segunda pela penúltima e assim sucessivamente. Em nosso alfabeto, teríamos a

seguinte tabela de substituição:

a

(cid:108)

z

b

(cid:108)

y

c

(cid:108)

d

(cid:108)

e

(cid:108)

f

(cid:108)

x w v u

g h

(cid:108)

t

(cid:108)

s

i

(cid:108)

r

j

(cid:108)

q

k

(cid:108)

(cid:108)

p o

l m

(cid:108)

n

Duas coisas chamam a atenção nessa cifra. A primeira delas é que o processo de

cifragem e decifragem são iguais, um tipo de cifra chamada de involutiva. O segundo

fato que chama a atenção é a ausência de chave. Veremos mais adiante o porquê de

um método onde não há chave ser desaconselhável. Para exempliﬁcar o uso desse

método, a cifragem de “atbash hebraico” seria “ZGYZHS SVYIZRXL” e ao cifrarmos o

texto “zgyzhs svyizrxl” obtemos de volta “ATBASH HEBRAICO”.

1.3 A C Í TA L A E S PA R TA N A

Esse método, atribuído aos gregos, consiste em um bastão no qual enrolava-se uma

tira de pergaminho, de maneira a cobrir o bastão todo e sem haver sobreposição do

1.4 A C I F R A D E V I G E N È R E

5

pergaminho. A mensagem era quebrada em blocos de letras que eram escritos ao

longo do eixo do cilindro, na vertical, cada letra em um setor diferente da mesma

tira. Quando o pergaminho era desenrolado, o texto estava cifrado. Para decifrar a

mensagem, o receptor precisava ter um outro bastão, de mesmo diâmetro, para enrolar

a tira e ler a mensagem original.

Nesse método, não havia troca de letras, mas sim uma transposição na posição das

letras. Exempliﬁcando, vamos cifrar o texto “loucura isso e esparta”. Escrevendo em

colunas com 4 letras, teríamos:

l

o

u

r

s

s

e

s

r

t

u a

o p a

c

i

e

a

E lendo as linhas, ﬁcaríamos com “LUSERORSSTUAOPACIEA”.

1.4 A C I F R A D E V I G E N È R E

Essa cifra, atribuída a Blaise Vigenère (1523-1596). O melhor método para trabalhar

com ele é relacionar cada letra do alfabeto com os números de 0 a 25 e operando com

os números módulo 26.

A ideia dessa cifra é escolher uma chave, que pode ser uma palavra ou uma sequên-

cia qualquer de letras. Teoricamente, quanto maior o tamanho da chave (até o tama-

nho da mensagem a ser cifrada) mais difícil de decifrar o código. Aumentar o tamanho

da chave além do tamanho da mensagem não inﬂuencia na segurança da cifra. O me-

lhor jeito de entender o método é transformar as letras da chave e do texto original

nos números de 0 a 25 e fazer a adição das letras do texto original com a chave, uma

de cada vez.

Como exemplo, vamos escolher a chave k =“CRIPTO” para cifrar o texto m =“matemática”.

Fazendo a transformação das letras nos números, teremos como chave “2 17 8 15 19

14” e como texto “12 0 19 4 12 0 19 8 2 0”. Para descobrir o texto cifrado, usamos

ci = Ek(mi) = (mi + ki) (mod 26) temos:

6

H I S T Ó R I A D A C R I P T O G R A F I A

Chave:

Texto:

2

12

17

0

Cifra:

14 17

8

19

1

15 19 14

0

4

19

12

5

2

19

17

8

8

2

15

0

14 21 25 10 15

E, transformando os números de volta em letras, temos “ORBTFOVZKP”. Na cifra de

César, as letras iguais seriam transformadas sempre em letras iguais e isso nem sempre

ocorre na cifra de Vigenère. Como exemplo, “matemática” possui a letra “a” três vezes,

que foi transformada em “R”, “O” e “P”.

As transformações das letras eram realizadas por meio da tabula recta, uma tabela

que indicava a letra a ser substituída de acordo com a letra da chave correspondente.

Na ﬁgura abaixo, podemos ver um exemplo dela.

Figura 1: Tabula Recta

Com efeito, a cifra de César pode ser trabalhada como uma cifra de Vigenère, onde

a chave tem tamanho 1.

O número de variações dessa cifra é abundante. Para os interessados em maiores

1.5 A C I F R A D E H I L L

7

informações, ver [6].

1.5 A C I F R A D E H I L L

Essa cifra foi inventada em 1929 por Lester S. Hill. A ideia consiste em escolher um

número inteiro positivo m e criar m transformações lineares para transformar m letras

do texto original em m letras do texto cifrado.

Novamente, trabalharemos com o conjunto Z26. Se tivermos o texto x = x1x2x3 . . . xn
ele será transformado no texto cifrado y = y1y2y3 . . . yn. Se n > m, dividimos o texto
x em quantos blocos de m letras forem necessários e juntamos os textos cifrados y ao

ﬁnal. A transformação será feita com as operações

(cid:104)

y1 y2

. . . ym

(cid:104)

(cid:105)

=

x1 x2

. . . xm

(cid:105)

.K

onde K é uma matriz quadrada inversível módulo 26 de ordem m. Precisamos que K

seja inversível pois para decifrar faremos

(cid:104)

x1 x2

. . . xm

(cid:104)

(cid:105)

=

y1 y2

. . . ym

(cid:105)

· K−1

Para exempliﬁcar, pegaremos m = 2 e usaremos a chave K =

texto “café”. Temos x = (2, 0, 5, 4), logo

(cid:34)

3

(cid:35)

5

4 13

para cifrar o

(cid:104)

(cid:104)

(cid:104)

(cid:105)

=

(cid:105)

·

2 0

y1 y2

(cid:104)

(cid:105)

=

(cid:105)

·

5 4

y3 y4

(cid:34)

3

(cid:35)

5

4 13

(cid:34)

3

(cid:35)

5

4 13

(cid:104)

=

6 10

(cid:104)

=

5 25

(cid:105)

(cid:105)

portanto y = (6, 10, 5, 25), ou seja, o texto cifrado é “GKFZ”. Para decifrar, usaríamos a

matriz K−1 =

(cid:34)

(cid:35)

.

13 23

8

7

A matriz inversa K−1 é encontrada resolvendo K · K−1 = I (mod 2)6, onde I é a

matriz identidade de ordem m.

8

H I S T Ó R I A D A C R I P T O G R A F I A

1.6 A M Á Q U I N A E N I G M A

Com o avanço tecnológico, foram criadas máquinas para cifrar e decifrar textos.

Uma das mais famosas é a máquina Enigma, usada pelos alemães durante a Segunda

Guerra Mundial.

Criada pelo engenheiro alemão Scherbius, é um mecanismo eletromecânico que con-

sistia de um teclado de 26 letras e um painel luminoso com 26 letras. Ao apertar uma

tecla, uma corrente elétrica percorria o mecanismo e fazia acender uma das letras no

painel luminoso, que seria a letra cifrada. O caminho percorrido dependia da posição

inicial dos discos que compunham a máquina, sendo difícil a quebra do código sem o

conhecimento dessa posição inicial.

A máquina foi decifrada por criptoanalistas poloneses e ingleses, entre eles, notavel-

mente, estava Alan Turing (1912 - 1954), que por volta de 1943, em Bletchley Park,

construíram dispositivos eletro-eletrônicos denominados Colossos para decodiﬁcar as

mensagens alemãs. Essas máquinas seriam os percursores dos computadores moder-

nos.

1.7 O P R I N C Í P I O D E K E R C K H O F F

Auguste Kerckhoff, em 1883, escreveu um tratado intitulado La Cryptographie Mili-

taire. Nele discutiu princípios para cifras militares e um dos mais importantes desses

princípios leva seu nome que diz:

O funcionamento interno de um criptossistema não pode ser secreto; deve-se presumir

que o adversário conhece como o criptossistema funciona, e a segurança do sistema deve

estar na escolha das chaves

Esse princípio é de fundamental importância para a criptograﬁa moderna e diz que

não podemos assumir que um sistema é seguro com base no método de cifragem,

ele deve manter-se seguro mesmo se o algoritmo for conhecido por todos. Existem

diversos argumentos a favor do princípio de Kerckhoff.

Em primeiro lugar, é muito mais fácil manter em segredo uma chave relativamente

pequena que um algoritmo. Na computação moderna, uma cadeia de bits é mais fácil

de armazenar e compartilhar em segredo que um programa ou algoritmo, muitas vezes

maior. Além disso, detalhes sobre o algoritmo podem se tornar conhecidos, talvez

1.8 S I G I L O P E R F E I T O

9

por alguém que ajudou a criar o método divulgando a informação ou por engenharia

reversa.

Outro ponto em favor do princípio é que, caso uma chave seja exposta, é muito mais

fácil trocar a chave do que trocar o algoritmo sendo usado. Existem vários pontos

em favor do algoritmo ser necessariamente público para melhorar a segurança do

criptossistema [8].

Além desses pontos, um algoritmo público pode ter sua segurança veriﬁcada por

diversas pessoas, sendo possível ter uma maior conﬁança no sistema do que se a vali-

dação fosse feita por um número pequeno de pessoas.

Um caso famoso que exempliﬁca a importância desse princípio é o do protocolo GSM,

usado por grande parte dos celulares atuais. O design da criptograﬁa desse algoritmo

não foi publicado e isso não é suﬁciente para manter sua segurança. Na verdade, há

numerosos casos de clonagem e até algoritmos para quebra de mensagens [1].

1.8 S I G I L O P E R F E I T O

Em 1949, Claude Shannon (1916-2001) publica seu artigo Communication Theory of

Secrecy Systems. Nesse artigo, Shannon discute a segurança de mensagens e introduz

o conceito de sigilo perfeito.

Uma cifra tem sigilo perfeito se o conhecimento do texto cifrado não fornece informa-

ção alguma sobre o texto original [11], ou seja, ele resiste a todos os ataques baseados

apenas no texto cifrado, mesmo que o observador possua recursos computacionais e

tempo inﬁnitos.

Mais precisamente, sendo Pr(m) a probabilidade que a mensagem enviada seja m e
Pr(m|c) a probabilidade condicional de que a mensagem seja m sabendo-se que o texto
criptografado é c, isso é o mesmo que dizer

Pr(m|c) = Pr(m).

Ou seja, a probabilidade de um texto qualquer ser m é a mesma não importando

qual o texto encriptado.

Um exemplo de criptograﬁa perfeitamente segura é o one-time pad de Vernam [5].

10

H I S T Ó R I A D A C R I P T O G R A F I A

1.9 O N E - T I M E PA D

O one-time pad tem um funcionamento similar à cifra de Vigenère, mas a chave pre-

cisa ser completamente aleatória e ter tamanho igual ao da mensagem. Para exempliﬁ-

car, vamos usar como mensagem a frase “hoje tem café”, uma frase com 11 caracteres

(desconsiderando os espaços). Usaremos como chave uma sequência aleatória de 11

letras, por exemplo “wnfqspotfph”. Fazendo a adição módulo 26, temos:

Mensagem 1:

h o j e t e m c a f e

7

14

Chave 1:

w n f q s p o t f p h

22 13

9

5

4

19

4

12

2

0

5

16 18 15 14 19 5 15

4

7

Cifra:

D B O U L T A V F U L

3

1

14 20 11 19

0

21 5 20 11

Como a chave é completamente aleatória, alguém que intercepte o texto cifrado “D B

O U L T A V F U L” só tem como opção “chutar” uma chave e esperar que o resultado dê

uma mensagem coerente. Digamos que a chave testada seja “pzophtyvegr”. Fazendo a

subtração módulo 26, temos:

Cifra:

D B O U L T A V F U L

3

1

14 20 11 19

0

21 5 20 11

Chave 2:

p z o p h t y v e g r

15 25 14 15

Mensagem 2:

o c a f e a c a b o u

14

2

0

5

7

4

19 24 21 4

6

17

0

2

0

1 14 20

A mensagem alternativa que obtemos é “o café acabou”, que faz sentido o suﬁciente

mas que possui signiﬁcado completamente oposto ao original. Qualquer mensagem

original de 11 letras possui uma chave (única) tal que o texto cifrado será “D B O

U L T A V F U L”, pois a chave é aleatória e poderia ser qualquer sequência, logo

qualquer conjunto de 11 caracteres pode ter gerado essa cifra e o observador não

ganha informação alguma estudando o texto cifrado.

Outra maneira de trabalhar o one-time pad é com bits e a operação ﬁca muito mais

fácil de ser efetuada. Suponha uma mensagem m com n bits e uma chave k, aleatória
e também com n bits. O texto cifrado c é obtido por ci = mi ⊕ ki, sendo i a posição do
bit, com i = 1, 2, ..., n e ⊕ representando a operação ou exclusivo, ou seja, realizando
a operação ou exclusivo bit a bit entre a mensagem e a chave. Note que para realizar

a inversa, basta aplicar o mesmo algoritmo novamente.

Para exempliﬁcar, tomemos n = 8 e a mensagem m = 01100010. Com a chave k =
10010011, temos como texto cifrado c = m ⊕ k = 11110001. Para termos a mensagem

1.10 S E G U R A N Ç A D E M O N S T R Á V E L

11

original, basta fazer m = c ⊕ k = 01100010. É possível demonstrar que o one-time pad
tem sigilo perfeito, o que será feito na proposição abaixo.

Proposição 1. O one-time pad tem sigilo perfeito.

Demonstração. Seja C um bit qualquer da chave. Por hipótese, a chave do one-time

pad é completamente aleatória, logo

Pr(C = 0) = Pr(C = 1) =

1
2

Considere uma mensagem onde M seja um bit qualquer da mensagem, temos que

Pr(M = 0) = 1 − Pr(M = 1) = x

Ao calcularmos o bit do texto cifrado B = M ⊕ C, temos como probabilidade de B as

seguintes opções:

Pr(B = 0) = Pr(M = 0) · Pr(C = 0) + Pr(M = 1) · Pr(C = 1) =

Pr(B = 1) = Pr(M = 0) · Pr(C = 1) + Pr(M = 1) · Pr(C = 0) =

Ou seja, o bit B do texto cifrado é completamente aleatório.

x
2

x
2

+

+

1 − x
2
1 − x
2

=

=

1
2

1
2

A demonstração dessa proposição no conjunto Z26, que corresponde ao nosso alfa-

beto, é análoga, mas a probabilidade de cada letra será 1
26 .

Infelizmente, há grandes desvantagens em usar o one-time pad, entre elas a chave

que precisa ser de tamanho igual ao da mensagem, aleatória e não reutilizada e que

precisa ser comunicada por um canal completamente seguro [12]. Logicamente que, se

um canal completamente seguro para passar a chave estivesse disponível, seria muito

mais fácil passar a mensagem por ele, pois tanto a chave quanto a mensagem possuem

o mesmo tamanho.

Nesse ponto, existem vantagens em trabalhar com sistemas que não sejam perfeita-

mente seguros, mas que mesmo assim possam ter sua segurança demonstrada.

1.10 S E G U R A N Ç A D E M O N S T R Á V E L

Na Criptograﬁa Moderna usamos a noção de segurança demonstrável, que signiﬁca

que um sistema criptográﬁco qualquer deve ter sua segurança demonstrada rigoro-

12

H I S T Ó R I A D A C R I P T O G R A F I A

samente, pressupondo hipóteses de segurança e enunciando claramente conclusões,

como uma demonstração de teorema.

No contexto da segurança demonstrável, buscam-se provas rigorosas que assegurem

que um criptossistema resiste a certos tipos de ataque [5]. Para saber se um sistema é

demonstravelmente seguro, devem ser feitas considerações reais sobre as capacidades

do oponente, considerando-se somente ataques possíveis. Normalmente, são usados

algoritmos probabilísticos para modelar os atacantes e os tipos de ataques a serem

utilizados.

A segurança de um sistema é baseada em problemas computacionais de difícil so-

lução. Por exemplo, se computar os fatores primos de um número inteiro fosse um

problema de fácil solução (se houvesse um algoritmo de tempo polinomial que o ﬁ-

zesse), seria relativamente fácil descobrir as chaves do sistema RSA. A prova que um

sistema de chave pública é seguro normalmente depende do fato de uma certa função

ser de mão única [5], que será explicado no próximo capítulo.

2

F U N Ç Õ E S D E M Ã O Ú N I C A

Estudaremos nesse capítulo algumas bases necessárias para o desenvolvimento do

trabalho, deﬁnindo as funções de mão única e fornecendo algumas bases teóricas para

seu uso.

Primeiramente, começamos deﬁnindo o que é uma função desprezível.

2.1 F U N Ç Ã O D E S P R E Z Í V E L

Deﬁnição 2.1 (Função Desprezível). Uma função f é desprezível se, para qualquer
polinômio p(.) existe N tal que para todos os inteiros n > N temos f (n) < 1

p(n) .

Podemos dizer que uma função é desprezível se ela cresce mais lentamente que o

recíproco de qualquer polinômio.

Como, para qualquer polinômio p(x) de grau n existe um monômio xc, c > n, que
cresce mais rapidamente, para mostrar que uma função f é desprezível, basta provar
que para cada c existe N tal que para todos os inteiros n > N temos f (n) < 1
nc .

É importante notar que f (n) = 1

2n é uma função desprezível. A importância desse re-
sultado é devido ao fato de, ao se trabalhar com um alfabeto binário, contendo apenas
0, 1, a quantidade de palavras possíveis com n caracteres é 2n, logo a probabilidade de
se escolher uma em particular é 1
2n , sendo essa a probabilidade de descobrir a chave

ao selecionar um valor aleatoriamente.

Para manter coerência com a literatura, utilizaremos a notação em inglês para fun-

ção desprezível, negl.

A seguir, encontram-se duas proposições interessantes sobre as funções desprezíveis.

13

14

F U N Ç Õ E S D E M Ã O Ú N I C A

Teorema 2.2. Sejam f e g duas funções desprezíveis. Então f + g é uma função desprezí-

vel.

Demonstração. Se f e g são desprezíveis, então existem N1, N2 ∈ Z tal que ∀n1 >
N1, f (n1) < 1
nc
11

e ∀n2 > N2, g(n2) < 1
nc
22

.

Seja N = max(2, N1, N2) e c = max(c1, c2), então, para n > N, temos

f (n) + g(n) <

=

≤

=

∴ f (n) + g(n) <

1
nc =

1
nc +
2
≤
nc
n
nc =
1
nc−1
1
nc−1

Teorema 2.3. Sejam p(.) um polinômio positivo qualquer e f uma função desprezível.
Então, o produto p · f é uma função desprezível.

Demonstração. Seja xc um monômio de grau c qualquer, logo xc · p(x) é um polinômio.
Como f é uma função desprezível, temos que existe N tal que ∀n > N,

f (n) <

1
nc · p(n)

=⇒ p(n) · f (n) <

1
nc

∴ p. f é uma função desprezível

2.2 F U N Ç Ã O D E M Ã O Ú N I C A

Uma função de mão única é uma espécie de função fácil de calcular mas cuja inversa

é difícil de ser calculada.

Deﬁnição 2.4 (Função de Mão Única). Uma função f é dita de mão única se ela possui

os seguintes requisitos:

1. Fácil de calcular: Existe um algoritmo que calcule f em tempo polinomial;

2. Difícil de inverter: Qualquer algoritmo aleatório A de tempo polinomial deve ter

probabilidade desprezível de encontrar x dado f (x), ou seja, ∀p(n),

(cid:104)

Pr

A( f (x)) ∈ f −1( f (x))

(cid:105)

<

1
p(n)

2.2 F U N Ç Ã O D E M Ã O Ú N I C A

15

Infelizmente, não sabemos se tais funções existem. Aquelas que consideramos serem

boas candidatas para serem funções de mão única, se baseiam em conjecturas. [5]

Exemplos dessas funções são a exponenciação modular, que se baseia na conjectura

de que não existe maneira eﬁciente de se calcular o logaritmo discreto, e a soma

de subconjuntos, cuja inversa é um problema N P-completo e portanto depende da
conjectura que N P (cid:54)= P.

Estudaremos agora algumas funções que são candidatas a serem funções de mão

única.

2.2.1 Exponenciação Discreta

Para falar da exponenciação discreta, precisamos primeiramente deﬁnir o que é uma

raiz primitiva módulo n. Dizemos que g é uma raiz primitiva módulo n se, para cada
inteiro a coprimo com n, existe um inteiro k tal que gk = a (mod n). Podemos dizer
também que g é um gerador do grupo multiplicativo dos inteiros módulo n.

Seja p um número primo e g uma raiz primitiva de Zp. A função exponenciação

discreta é deﬁnida por

dexp : Z∗

p → Z∗

p

x (cid:55)→ dexp(x) = gx

(mod p)

Essa função pode ser calculada em tempo polinomial [5] mas todos os algoritmos

que se conhecem para calcular x dado dexp(x) exigem uma quantidade de operações

que aumenta exponencialmente com o tamanho de x [5]. Realmente, conjectura-se

que não exista função que calcule a inversa de dessa função - esse problema é conhe-

cido como “problema do logaritmo discreto”.

É interessante notar que essa função também é uma bijeção, visto que g é uma raiz
p é um sistema reduzido de resíduos módulo p, logo a inversa

primitiva de Zp e Z∗
sempre existe e é única - ainda que difícil de ser calculada.

2.2.2 Multiplicação de Inteiros

A função multiplicação de inteiros é deﬁnida por

· : Z × Z → Z

16

F U N Ç Õ E S D E M Ã O Ú N I C A

x, y (cid:55)→ x · y

A multiplicação de números inteiros é uma função relativamente fácil de realizar,

existindo vários algoritmos que a calculam em tempo polinomial. Se não houver res-

trições, ela também pode ser invertida de maneira relativamente fácil, pois há uma

grande probabilidade que x · y tenha um fator primo p pequeno que possa ser encon-
trado e então (p, xy
p ) é uma pré imagem de x · y. Mas, ao restringir x e y de maneira
que ambos sejam números primos, grandes e de tamanhos aproximadamente iguais,

a função multiplicação de inteiros torna-se uma função que conjectura-se ser de mão

única [8].

De fato, não se conhece algoritmo que descubra x e y dado x · y em tempo polino-

mial, se x e y forem primos.

2.2.3 Quadrado Modular

Seja a função

Sqn : Z∗

n → Z∗

n

Essa função não é injetora e nem sobrejetora. Por exemplo, em Z3, temos

x (cid:55)→ x2

02 = 0

(mod 3)

12 = 1

(mod 3)

22 = 1

(mod 3)

Calcular x2 (mod n) pode ser feito em tempo polinomial e existem algoritmos proba-
bilísticos polinomiais que calculam a raiz quadrada módulo p, se p for um número

primo. Mas, se n = pq e a fatoração de n é conhecida, é relativamente fácil calcular a

raiz quadrada módulo n pelo Teorema Chinês do Resto.

Na verdade, o problema de calcular a raiz quadrada módulo n é análogo ao de

fatorar n = pq, se p e q forem primos [5].

2.3 P R E D I C A D O H A R D - C O R E

17

2.2.4 Soma de Subconjuntos

Sejam n inteiros x1, x2, . . . , xn e um subconjunto S deles, temos a função

somaS(x1, x2, . . . , xn, S) = (x1, x2, . . . , xn, ∑
i∈S

xi)

Essa função é fácil de calcular, mas descobrir o subconjunto S a partir da soma é
um problema N P-completo e não se conhecem algoritmos eﬁcientes para a resolução

desse problema [8].

2.3 P R E D I C A D O H A R D - C O R E

Como dito anteriormente, em uma função de mão única f , deve ser difícil calcular a

pré-imagem x dado y = f (x), mas algumas propriedades de x podem ser obtidas com

facilidade. Um dos exemplos mais conhecidos disso ocorre na exponenciação discreta,

no qual a paridade de x pode ser calculada usando o critério de Euler [5].

Um predicado hard-core de x relativo a f é uma das propriedades da pré-imagem x

que é muito difícil de ser descoberta dada a imagem f (x).

Deﬁnição 2.5 (Predicado Hard-Core). H : {0, 1}∗ → {0, 1} é um predicado hard-core
de uma função f se, para cada algoritmo probabilístico em tempo polinomial A, existe

uma função desprezível negl tal que

Pr[A( f (x)) = H(x)] ≤

1
2

+ negl(n)

onde n é o número de bits de x.

3

G E R A D O R E S D E N Ú M E R O S

P S E U D O - A L E AT Ó R I O S

A geração de números aleatórios é um assunto importante no ramo da criptograﬁa,

com diversas aplicações - como o one-time pad mencionado anteriormente. Mas a ver-

dadeira aleatoriedade é difícil de se encontrar, se é que pode-se encontrá-la de verdade.

Usando computadores, podemos gerar grandes sequências numéricas usando fórmulas

e outros métodos aritméticos, mas esses números não são realmente aleatórios. Como

disse o matemático Von Neumann, "qualquer um que pense em métodos aritméticos

para produzir números aleatórios está, obviamente, cometendo pecados" [14].

Por isso usamos sequências numéricas que são pseudo-aleatórias, isso é, são sequên-

cias de números que podem ser consideradas como se fossem geradas por um evento

aleatório, como o lançar de uma moeda ou de um dado.

Idealmente, um gerador pseudo-aleatório deve pegar uma sequência s aleatória de

tamanho n e retornar uma sequência G(s) de tamanho l(n). Para considerar G um

gerador de números pseudo-aleatórios, usaremos a seguinte deﬁnição:

Deﬁnição 3.1 (Gerador Pseudo-Aleatório). Seja l um polinômio e G um algoritmo
determinístico de tempo polinomial que com uma entrada s, com s ∈ {0, 1}n, retorne
G(s) de tamanho l(n). G é um gerador pseudo-aleatório se:

1. ∀n, l(n) > n. Dizemos que l é o fator de expansão do gerador.

2. Para qualquer função probabilística de tempo polinomial que veriﬁque se um nú-

mero vem de um sequência aleatória uniforme D, existe uma função desprezível
negl tal que |P(D(r) = 1) − P(D(G(s) = 1)|≤ negl(n), onde r é um número de
tamanho l(n) escolhido aleatoriamente e s é a semente escolhida aleatoriamente

e de tamanho n.

19

20

G E R A D O R E S D E N Ú M E R O S P S E U D O - A L E AT Ó R I O S

Um dos principais problemas dos geradores pseudo-aleatórios é que, da mesma

forma das funções de mão única, não se sabe se eles existem de fato [8]. De fato,

a maioria dos geradores existentes baseia-se em funções de mão única [13], inclusive

um dos mais populares,o Gerador de Blum-Blum-Shub [2], que veremos adiante.

Cabe ressaltar que, se um gerador pseudo-aleatório é indistinguível em tempo po-

linomial de uma sequência aleatória, como deﬁnido acima, ele pode ser usado para

criptografar de maneira demonstravelmente segura usando o princípio do one-time

pad visto em 1.9 com chave de segurança s, pois não é possível para um observador

distinguir G(s) de uma sequência aleatória em tempo polinomial [8].

De maneira geral, um gerador de números pseudo-aleatório pode ser construído de

maneira segura usando uma função de mão única com um predicado hard-core [5] [3].

3.1 G E R A D O R D E N Ú M E R O S P S E U D O - A L E AT Ó R I O S D E B L U M - B L U M - S H U B

Esse gerador, também chamado de Gerador x2 (mod N) usa a operação de quadrado
modular que conjecturamos ser uma função de mão única anteriormente em 2.2.3.
Para usá-lo, precisamos de dois números primos p e q, com p (cid:54)= q e p = q = 3 (mod 4).
Calculamos então N = p.q. É importante que p e q sejam de mesmo tamanho, para

diﬁcultar a fatoração de N.

Como semente para esse gerador, tomamos um número aleatório s, com s (cid:54)= 0
(mod N) e s2 (cid:54)= 1 (mod N). Para que s2 tenha essa restrição, obviamente temos que
s (cid:54)= ±1 (mod N), mas também é necessário que s (cid:54)= ±1 (mod p) e s (cid:54)= ±1 (mod q).

Esse gerador calcula G(s) = b1b2b3...bn onde





s0 = s
si = s2
bi = si

i−1

(mod N)

(mod 2), i = 1, 2, . . . , n

Para usar um exemplo, tomemos p = 83 e q = 79, ou seja, N = 6557. Como semente,

usaremos s = 42. A tabela abaixo ilustra o valor de mi e bi com 0 ≤ i ≤ 16.

3.1 G E R A D O R D E N Ú M E R O S P S E U D O - A L E AT Ó R I O S D E B L U M - B L U M - S H U B

21

i

0

1

2

3

4

5

6

7

8

9

si

42

1764

3678

593

4128

5298

4844

3390

4236

3744

10 5227

11 5067

12 3834

13 5319

14 4863

15 4227

16 6261

bi

0

0

1

0

0

0

0

0

0

1

1

0

1

1

1

1

Logo, G(42) = 0010000001101111 . . .

É importante notar que após um certo valor n, começa a haver uma repetição nos

dígitos de G(s), ou seja, G é periódica. É possível calcular o período de G(s) [2], mas

isso não sera abordado nesse trabalho.

4

F U N Ç Õ E S D E H A S H

As funções de hash, também conhecidas como resumos criptográﬁcos, são usadas

para transformar cadeias longas de informação em um valor de tamanho ﬁxo, usual-

mente menor que a informação inicial. Um dos principais usos para essas funções é o

de checar a integridade de mensagens, chaves e arquivos. Nesse sentido, a função de

hash funciona como uma impressão digital da informação. Idealmente, se a mensagem

for alterada, mesmo que somente em um bit, a impressão digital também deverá ser

alterada de uma maneira “difícil de ser prevista”.

Seja m uma mensagem arbitrariamente longa e h uma função de hash. A imagem

h(m) terá sempre um tamanho ﬁxo n. A escolha desse tamanho n será importante

para determinar a segurança da função, como veremos adiante. Atualmente, costuma-

se usar o tamanho n entre 128 e 512 bits [5]. Como a função de hash possui um

domínio inﬁnito e um contradomínio ﬁnito, certamente haverá um número (inﬁnito)

de mensagens diferentes que possuirão a mesma imagem. Na prática, o domínio de

uma função de hash não é inﬁnito, pois há um limite no tamanho das mensagens a

serem enviadas, mas possui um número de elementos arbitrariamente grande.

Uma função de hash deve cumprir alguns requisitos de segurança para ser eﬁciente.

4.1 R E Q U I S I T O S D A S F U N Ç Õ E S D E H A S H

Para que uma função de hash seja segura, é necessário que alguns problemas sejam

de difícil solução.

A princípio, queremos que a mensagem m, dado o resumo h(m), seja difícil de ser en-

contrada. Podemos dizer também que há probabilidade desprezível de um algoritmo

23

24

F U N Ç Õ E S D E H A S H

que funcione em tempo polinomial de, dado uma imagem y da função de hash, encon-

trar m tal que h(m) = y. Se esse requisito for cumprido, diz-se que a função de hash

possui resistência de pré-imagem, ou ainda, que ela é de mão única.

Outro problema a ser tratado já foi mencionado anteriormente, o de que há mensa-
gens m (cid:54)= m(cid:48) tal que h(m) = h(m(cid:48)). Se, dado m, encontrar m(cid:48) (cid:54)= m tal que h(m(cid:48)) = h(m)
for um problema de difícil solução, dizemos que a função de hash possui resistência

de segunda pré-imagem.

Por último, se, em uma função de hash h qualquer, for difícil encontrar duas mensa-
gens m e m(cid:48), com m (cid:54)= m(cid:48) e h(m) = h(m(cid:48)), a função de hash será resistente à colisão.
Essas três propriedades são essenciais para a segurança de uma função de hash.

É possível mostrar que a resistência a colisão engloba a resistência à segunda pré-

imagem e a resistência à pré-imagem, como faremos a seguir.

Proposição 4.1. Uma função de hash que tenha resistência à segunda pré-imagem tam-

bém é resistente à pré-imagem.

Demonstração. Suponha que a função de hash h não possua resistência a pré-imagem,

ou seja, dada uma imagem y da função, há uma probabilidade não-desprezível de se

encontrar algum m tal que h(m) = y.

Como já foi dito antes, a função de hash possui um número inﬁnito de mensagens

diferentes que possuirão a mesma imagem.

Dado uma mensagem m qualquer, calcula-se y = h(m). Como a função de hash h não
possui resistência a pré-imagem, há uma grande probabilidade de se calcular m(cid:48) onde
y = h(m(cid:48)), mas como existem um número inﬁnito de mensagens que possuem imagem
y, a probabilidade de que m (cid:54)= m(cid:48) é alta, logo foi possível encontrar m(cid:48)
(cid:54)= m dado m
tal que h(m) = h(m(cid:48)), ou seja, a função de hash h não possui resistência a segunda
pré-imagem, o que demonstra a proposição por contraposição.

Proposição 4.2. Uma função de hash que tenha resistência à colisão também é resistente

à segunda pré-imagem.

Demonstração. Novamente, por contraposição, suponha que a função de hash h não

possua resistência à segunda pré-imagem, ou seja, dado uma mensagem m há uma
probabilidade não-desprezível de se encontrar m(cid:48) (cid:54)= m tal que h(m) = h(m(cid:48)).

Seja m uma mensagem aleatória qualquer. Como a função de hash h não possui
(cid:54)= m tal que h(m) = h(m(cid:48)),

resistência à segunda pré-imagem, é possível encontrar m(cid:48)

4.2 P R O B L E M A D O A N I V E R S Á R I O

25

logo é possível encontrar duas mensagens m e m(cid:48), com m (cid:54)= m(cid:48) onde h(m) = h(m(cid:48)), logo
a função de hash h não possui resistência à colisão.

Com essas duas proposições, podemos concluir que a resistência à colisão é uma

condição de segurança mais forte que as outras duas anteriores, pois as engloba.

4.2 P R O B L E M A D O A N I V E R S Á R I O

O problema do aniversário é um problema clássico em probabilidade. Em um grupo

de n pessoas, qual a probabilidade p(n) de que ao menos duas delas façam aniversário

no mesmo dia?

Como um ano possui 365 dias, precisamos resolver o problema para n ≤ 365, pois
se n > 365, pelo Princípio da Casa dos Pombos, sempre haverá duas pessoas que
nasceram no mesmo dia.

É relativamente fácil calcular a probabilidade de que todos os n aniversários sejam

diferentes, o complementar de p(n), que será

¯p(n) =

365
365

·

364
365

· · ·

365 − n + 1
365

=

365!
365n · (365 − n)!

logo p(n) é

p(n) = 1 −

365!
365n · (365 − n)!

Com essa fórmula, podemos perceber que, em um grupo de 23 pessoas, há uma

probabilidade de aproximadamente 50, 7% de que ao menos duas possuam a mesma

data de aniversário e que em um grupo de 50 pessoas, essa probabilidade chega a 97%.

Agora, imagine uma função de hash onde N é o número de elementos do conjunto

imagem. Qual a probabilidade p(n) de que, ao calcular o hash de n mensagens diferen-

tes, elas possuam a mesma imagem? Do jeito que foi enunciado, é possível perceber

que esse problema é um caso genérico do problema do aniversário, mas ao invés de

termos 365 dias de aniversário diferentes, possuímos N resumos diferentes. Essa pro-

babilidade será calculada por

p(n) = 1 −

N!
Nn · (N − n)!

Esse resultado leva ao chamado "ataque do aniversário", pois é possível deduzir que

N [5] a probabilidade de encontrar ao menos uma colisão

1+8 ln 2·N+1
2

≈ 1, 18

√

√

se n ≥
é de 1
2 .

26

F U N Ç Õ E S D E H A S H

4.3 C O N S T R U Ç Ã O D E F U N Ç Ã O D E H A S H

O exemplo a seguir descreve uma função de hash devida a Chaum, van Heijst e

Pﬁtzmann [4], também chamada de função de hash do logaritmo discreto. Apesar

de ser muito lenta para ser usada na prática, ela ilustra como uma função de hash

funciona.

É necessário escolher um número primo grande p tal que q = p−1
2
primo. Em seguida, escolhemos duas raízes primitivas de p, sejam elas α e β.

também seja

Em seguida, seja m a mensagem a ser resumida, escrevemos m = x0 + x1q, com
0 ≤ x0, x1 ≤ q − 1. A função de hash h é deﬁnida por h(m) = αx0 βx1 (mod p). É
importante notar que a mensagem m deve ser um menor que q2 devido às restrições
dadas a x1 anteriormente.

Como exemplo, vamos escolher p = 503, pois q = 503−1

2

= 251 é também um número

primo. Como raízes primitivas de p, escolhemos α = 10 e β = 30 como raízes primitivas

de 503. Como mensagem, escolhemos m = 5200.

Temos que 5200 = 180 + 20 · 251, logo x0 = 180 e x1 = 20, então h(5200) = 10180 · 3020

(mod 503) e efetuando os cálculos teremos h(5200) = 336

Um método bem usado para construir uma função de hash é a construção de Merkle-

Damgård. Esse método transforma uma função de compressão, um tipo de função de

mão única, em uma função de hash que obedecerá a especiﬁcações de segurança como

resistência à colisão se a função de compressão também a possuir. [12]

4.4 R E S Í D U O S Q U A D R ÁT I C O S C O M O F U N Ç Ã O D E H A S H

Essa construção usa como ideia básica o gerador de números pseudo-aleatórios de

Blum-Blum-Shub [2].

Para isso, é necessário encontrar um número N = p · q, onde p = q = 3 (mod 4) e
p (cid:54)= q. A mensagem m deve ter um tamanho ﬁxo, m < N. Se m ≥ N, podemos usar
a construção de Merkle-Damgård para dividir m de maneira a termos um tamanho

adequado.

4.4 R E S Í D U O S Q U A D R ÁT I C O S C O M O F U N Ç Ã O D E H A S H

27

Deﬁnimos f (m) = b0b1b2 . . . bn, onde bi é a paridade de mi e mi+1 = m2

i (mod N),
com m = m0. O valor de n, o tamanho em bits da imagem de f é arbitrário e nesse
exemplo vamos ﬁxá-lo como n = 16.

Por exemplo, tomemos p = 83 e q = 79, logo N = 6557. Vamos pegar como mensa-

gem m = 123. A tabela abaixo ilustra o valor de mi e bi com 0 ≤ i ≤ 15.

i

0

1

2

3

4

5

6

7

8

9

mi

123

15129

4060225

2079364

632025

6517809

22801

9796900

550564

40106889

10 18292729

11 27625536

12

13

801025

1147041

14 37491129

15 22657600

mi (mod N)

bi

123

2015

1442

795

2553

151

3130

742

6333

4277

5256

895

1071

6123

4760

3165

1

1

0

1

1

1

0

0

1

1

0

1

1

1

0

1

Logo f (123) = 1101110011011101. A escolha dos primos e da mensagem tem apenas

função de exempliﬁcar, os primos usados na prática são muito maiores, assim como o

tamanho da imagem f .

Para encontrar uma segunda pré-imagem da mensagem, seria necessário obter um
outro elemento x (cid:54)= 123 tal que f (x) = 1101110011011101. Como visto anteriormente,
temos chance de 1
N ≈ 96,

2 de achar uma segunda pré-imagem ao testar cerca de 1, 18

√

o que pode ser obtido rapidamente devido ao pequeno valor de N.

5

E N C R I P TA Ç Ã O C O M C H A V E P Ú B L I C A

Em 1976, Whitﬁeld Difﬁe e Martin Hellman publicam o artigo "New Directions in

Cryptography", onde sugerem as bases do método criptográﬁco de chave pública, de

grande utilidade nos tempos de internet.

Imagine que Alice e Bob querem trocar uma mensagem, mas eles estão distantes e

não há um canal seguro através do qual eles possam concordar em uma chave. Alice

então escolhe uma chave pública pk e uma chave secreta sk. Qualquer um que queira

comunicar-se com ela, utiliza a chave pública ao fazer a encriptação e apenas Alice

deve ser capaz de decifrar a mensagem usando sua chave secreta.

Para compreender o processo, podemos pensar na chave pública como um cadeado

aberto e a chave secreta como a chave que abre o cadeado. Qualquer um pode pegar

o cadeado aberto e travar a mensagem com ele, mas apenas Alice que tem a chave

secreta correspondente a esse cadeado pode destravá-lo.

Antes de 1976, James Ellis já havia proposto sobre a criptograﬁa de chave pública

em seu artigo intitulado "The possibility of non-secret encryption", mas esse documento

era segredo do governo britânico e só foi liberado em 1997 [12].

Em 1977, Ronald Rivest, Adi Shamir e Leonard Adleman inventaram o criptosistema

RSA, um dos mais famosos criptossistemas de chave pública, usado ainda nos dias de

hoje.

Existem vários métodos de encriptação com chave pública. Trataremos agora sobre

o criptossistema de Rabin.

29

30

E N C R I P TA Ç Ã O C O M C H A V E P Ú B L I C A

5.1 C R I P T O S S I S T E M A D E R A B I N

O criptossistema de Rabin tem como base os resíduos quadráticos e tem segurança

demonstrável, sendo tão difícil de decifrar quanto a fatoração de grandes números

[10].

Ele foi criado por Michael Rabin em 1979 e é considerado um dos primeiros criptos-

sistemas de chave pública. O processo de encriptação é relativamente simples, como

será explicado a seguir.

Sejam n = p · q, onde p e q são dois números primos tais que p = q = 3 (mod 4), e
m uma mensagem tal que m < n. A encriptação consiste em calcular y tal que y = m2
(mod n). A chave pública nesse sistema é n, o que permite a qualquer um que escreva

a mensagem calcular y, mas só quem possui a chave privada p, q pode descriptografar.

Para decifrar a mensagem, precisamos lembrar do Critério de Euler, que por ser um

resultado muito conhecido aceitaremos sem demonstração:

Critério de Euler. Se p é um número primo ímpar e a ∈ Z é coprimo com p, então:

• a

p−1
2 = 1 (mod p) se, e somente se, a é resíduo quadrático módulo p.

• a

p−1
2 = −1 (mod p) se, e somente se, a não é resíduo quadrático módulo p.

Como y é um resíduo quadrático módulo n, e portanto resíduo quadrático módulo

p e módulo q, temos:

1 = y

p−1
2

(mod p)

p−1
2

y = y · y
p−1
2 +1

= y

(mod p)

(mod p)

p+1
2

= y

(mod p)

= (y

p+1

4 )2

(mod p)

Como p = 3 (mod 4), p+1

4 é um número inteiro, logo

√

±

y = ±y

p+1
4

(mod p)

Analogamente, temos

√

±

y = ±y

q+1
4

(mod q)

5.1 C R I P T O S S I S T E M A D E R A B I N

31

Para encontrar a mensagem m, precisamos resolver o sistema

(cid:40)

m = ±y
m = ±y

p+1
4

q+1
4

(mod p)

(mod q)

As soluções desse sistema podem ser obtidas facilmente pelo Teorema Chinês dos

Restos:






p+1
4

m = q · y
m = −q · y
m = q · y
m = −q · y

p+1
4

· a + p · y

q+1
4

p+1
4

· a + p · y

· b
q+1
4

· b

q+1
4

· a − p · y
p+1
4

· a − p · y

· b
q+1
4

· b

(mod n)

(mod n)

(mod n)

(mod n)

Onde a e b são tais que a · q = 1 (mod p) e b · p = 1 (mod q)

A desvantagem desse criptossistema é que ao decifrar a mensagem podemos ter

quatro soluções (teremos duas soluções apenas se p|m ou q|m) e, a não ser que o

contexto diga qual das soluções é a correta, mais informação deve ser transmitida de

maneira a não deixar dúvidas quanto a mensagem original. O motivo de ter quatro
soluções diferentes é que, sendo ω tal que ω2 = 1 (mod n) e ω (cid:54)= ±1 (mod n), temos
que

m2 = (−m)2 = (ωm)2 = (−ωm)2

(mod n)

Como exemplo, tomemos como números primos p = 7 e q = 11 e a mensagem
original é m = 48. Criptografando com a chave pública n = 77, temos y = 482
(mod 77) = 71. Para decifrar a mensagem, temos que a = 2 e b = 8, logo as men-

sagens possíveis são:






7+1
4

m1 = 11 · 48
m2 = −11 · 48
m3 = 11 · 48
m4 = −11 · 48

7+1
4

· 2 + 7 · 48

11+1
4

· 8

(mod 77) = 15

7+1
4

· 2 + 7 · 48

11+1
4

· 8

(mod 77) = 48

· 2 − 7 · 48

11+1
4

· 8

(mod 77) = 29

7+1
4

· 2 − 7 · 48

11+1
4

· 8

(mod 77) = 62

Apenas o contexto ou alguma outra informação deixaria claro qual dos quatro valo-

res é a mensagem original.

É importante notar que ﬁxamos p e q como sendo da forma 4k + 3 por existir um

método determinístico de encontrar

y (mod p), como mostrado acima. Existe um al-

goritmo aleatório também de tempo polinomial para calcular as raízes quadradas para

primos da forma 4k + 1 [12]. Usando esse algoritmo, é possível selecionar qualquer

primo ímpar para p e q.

√

32

E N C R I P TA Ç Ã O C O M C H A V E P Ú B L I C A

5.2 S E G U R A N Ç A D O C R I P T O S S I S T E M A D E R A B I N

É possível demonstrar que esse criptossistema é tão seguro quanto é difícil o pro-

blema da fatoração de números inteiros.

Imagine que exista um algoritmo que, em tempo polinomial, retorne uma das raízes

de uma mensagem criptografada y qualquer apenas com a chave pública n. Note que

n = pq, mas os números primos que compõem a chave são desconhecidos. Escolhemos
então uma mensagem m qualquer e calculamos y = m2 (mod n). Inserimos no algo-
ritmo acima y e n e então o algoritmo retorna x que é um dos quatro valores possíveis

abaixo:






x1 = m (mod n)
x2 = −m (mod n)
x3 = ωm (mod n)
x4 = −ωm (mod n)

onde ω2 = 1 (mod n) e ω (cid:54)= ±1 (mod n).

Teremos com probabilidade 1

2 , uma raiz x (cid:54)= ±m (mod n) na qual

m2 = x2

(mod n)

m2 − x2 = 0

(mod n)

(m + x)(m − x) = 0 (mod pq)

Como m + x (cid:54)= 0 (mod n) e m − x (cid:54)= 0 (mod n), temos que m + x = 0 (mod p) e
m − x = 0 (mod q) (ou vice versa), pois se isso não ocorresse, teríamos como opção
que m + x = 0 (mod n) ou m − x = 0 (mod n), hipóteses já descartadas de princípio.

Assim, mdc(m + x, n) = p e mdc(m − x, n) = q.

Podemos concluir que, se existisse um algoritmo para descriptografar o criptossis-
2 e em tempo polinomial,

tema de Rabin, poderíamos fatorar n = pq com probabilidade 1
o que contradiz a conjectura proposta em 2.2.2.

5.3 E N C R I P TA Ç Ã O H O M O M Ó R F I C A

33

5.3 E N C R I P TA Ç Ã O H O M O M Ó R F I C A

Homomorﬁsmo é um termo comumente usado na Matemática para indicar algum

tipo de função que preserve a estrutura algébrica, ou seja, podemos operar com os

elementos antes ou depois de aplicar o homomorﬁsmo pois a estrutura se mantém. A

deﬁnição abaixo ajudará a explicar esse conceito.

Deﬁnição 5.1 (Encriptação Homomórﬁca). Um esquema de encriptação E(k, m), onde
k é uma chave e m a mensagem, é homomórﬁco se E(k, x) · E(k, y) = E(k, x ∗ y), onde ·
e ∗ são operações quaisquer.

Usando uma encriptação homomórﬁca, é possível para alguém operar com os da-

dos criptografados e fornecer um resultado sem ter conhecimento dos dados. Abaixo

veremos um exemplo de uso usando sistemas de votação, mas existem outras possibi-

lidades.

Teorema 5.2. O criptossistema de Rabin é homomórﬁco.

Demonstração. Seja n a chave pública do criptossistema de Rabin descrito anterior-

mente e sejam a e b duas mensagens quaisquer. Então,

E(a) = a2

(mod n)

E(b) = b2

(mod n)

E(a) · E(b) = a2 · b2

(mod n)

E(a) · E(b) = (a · b)2
∴ E(a) · E(b) = E(a · b)

(mod n)

(5.1)

5.3.1 Sistemas de Votação

Para utilizar o criptossistema de Rabin na votação, vamos modiﬁcá-lo um pouco.

Para simpliﬁcar, vamos considerar que cada voto vi só poderá adquirir dois valores:
vi = 1, ou seja, "sim"e vi = 0, "não".

Não conhecemos modo de criar um sistema de votação homomórﬁco usando ape-

nas resíduos quadráticos, então usaremos também outra função conjecturada de mão

única que é o logaritmo discreto.

34

E N C R I P TA Ç Ã O C O M C H A V E P Ú B L I C A

Como no Rabin, precisaremos de dois números primos secretos p e q para obtermos
n = p · q e de g, uma raiz primitiva de p. Além disso, precisaremos também de uma
chave secreta k. As restrições usuais para p e q se aplicam, mas além disso precisamos
que t < p − 1, onde t é o total de votantes. O motivo para isso é que g é uma raiz
primitiva de p, logo {g, g2, · · · , gp−1} forma um sistema reduzido de resíduos módulo
p, com p − 1 elementos diferentes. Logicamente, pode ser que gt (mod n) tenha um
período maior que gt (mod p), mas usaremos o menor número como segurança.

Para a encriptação, deve ser escolhido um número aleatório ri, co-primo com p e q.

Para encriptar cada voto vi, fazemos então

E(vi) = (r2

i , gvi+k · ri), 1 ≤ i ≤ t

A contagem de votos é feita ao multiplicar todos E(vi) termo a termo, ou seja

E(v) = (r2

1 · r2

2 · · · · · r2

t , gv1+k · r1 · gv2+k · r2 · · · · · gvt+k · rt) = (r2, gv+t·k · r)

(mod n)

Ao decifrar E(v) e obter v, que é o total de votos sim, precisamos calcular r com
o método descrito em 5.1, e achar r−1 (mod n) e g−kt para ﬁnalmente descobrir
gv+kt · r · r−1 · g−kt = gv (mod n) ·

Com o intuito de saber o valor de v, devemos utilizar uma tabela para comparar
gv com os valores possíveis. Por esse motivo, v, e consequentemente t, não pode ser
um número muito grande pois encontrar v de outra maneira relaciona-se ao problema

já discutido em 2.2.1, o problema do logaritmo discreto, que conjectura-se ser uma

função de mão única e portanto de difícil solução.

Como exemplo prático, consideremos os números primos p = 7 e q = 11, com g = 5

sendo uma raiz primitiva de p e k = 4. Nessa votação, teremos t = 5 eleitores. A tabela
abaixo sumariza os votos vi de cada um e ri, um número aleatório. Após a votação,
serão conhecidos apenas os pares ordenados E(vi).

i

1

2

3

4

5

vi
1

1

0

0

1

ri
36

75

51

47

26

E(vi) = (r2

i , gvi · ri)

(64,3)

(4,64)

(60,74)

(53,38)

(60,15)

5.3 E N C R I P TA Ç Ã O H O M O M Ó R F I C A

35

Para contar os votos, fazemos

E(v) = (64 · 4 · 60 · 53 · 60, 3 · 64 · 74 · 38 · 15)

(mod 77) = (4, 8)

A partir de r2 = 4, obtemos como raízes r1 = 9, r2 = 2, r3 = 68, r4 = 75, cujos
2 = 39, r−1
inversos módulo 77 são r−1
4 = 38 e como conhecemos a
chave secreta k e o total de votos t, fazemos gkt (mod 77) = 67, cujo inverso é g−kt
(mod 77) = 23.

1 = 60, r−1

3 = 17, r−1

Multiplicando x = gv+kt · r · r−1 · g−kt (mod 77), obtemos quatro valores, x1 = 29, x2 =
15, x3 = 48, x4 = 62. Comparando com a tabela dos valores de 5v (mod 77) abaixo,
temos que o único valor existente na tabela é 48 que fornece v = 3 votos sim. Há

métodos para distinguir qual raiz usar, mas nesse caso é bem claro qual o único valor

possível.

v

0

1

2

3

4

5

5v (mod 77)
1

5

25

48

9

45

Alguém que queira descobrir algum voto E(vi) qualquer sem conhecer os segredos
p, q, k deverá descobrir o valor de r a partir de r2 e o valor de gk, dois problemas de
difícil solução.

6

P R O VA D E C O N H E C I M E N T O Z E R O

Imagine que, para acessar um certo lugar, seja necessário conhecer uma palavra

secreta. Ao entrar no lugar, o porteiro pergunta a você qual é a palavra secreta, mas

se você falar a palavra secreta todos ao seu redor, inclusive o porteiro, conhecerão o

segredo para entrar no lugar. O ideal seria um método para que você mostre que tem

o segredo necessário para entrar no lugar, mas sem realmente contar o segredo para

ninguém. Uma prova de conhecimento zero é essencialmente isso.

Essa situação é melhor ilustrada por um exemplo criado por Quisquater, Guillou e

Berson [9] e que será adaptado a seguir.

Imagine que existe uma caverna conforme a ﬁgura a seguir com uma porta na ex-

tremidade oposta a entrada que só pode ser aberta com uma palavra secreta. Peggy

quer provar para Victor, o veriﬁcador, que conhece a palavra secreta, mas sem contar

a ele qual é esse segredo. Para tal, eles usam o seguinte mecanismo. Peggy entra na

caverna e escolhe ir para um lado, aguardando em frente a porta. Victor então entra

na caverna, sem ter visto para que lado Peggy foi, e escolhe entre esquerdo e direito

para que Peggy saia por esse lado. Se Victor escolher o lado oposto àquele que Peggy

entrou, ela usa a palavra secreta, atravessando a porta e saindo pelo lado escolhido,

caso contrário ela apenas volta pelo mesmo caminho. De qualquer maneira, Peggy

sempre é capaz de sair da caverna pelo lado desejado por Victor.

Victor pode pensar que é uma grande coincidência Peggy ter saído pelo lado esco-

lhido, pois ela pode ter entrado justo pelo lado que Victor escolheu e não precisou
passar pela porta. Isso ocorreria com uma probabilidade de 1
2 . Para se convencer que
Peggy possui o segredo, ele pede para que o experimento seja repetido n vezes. Como

Peggy conhece o segredo, ela sempre consegue voltar pelo caminho escolhido e a pro-
babilidade que ela o tenha feito por pura sorte é de 1
2n e Victor se convence que ela

37

38

P R O VA D E C O N H E C I M E N T O Z E R O

conhece a palavra secreta pois percebe a probabilidade de que Peggy tenha passado

no teste por sorte é desprezível.

Suponha que Eva estava observando Victor de maneira secreta. Eva não descobre

o segredo de Peggy e se for tentar provar para Victor que conhece o segredo ela só

conseguirá se, por coincidência, Victor escolher o lado que ela entrou na caverna, o
que só acontecerá em 1
2 das vezes. Após repetir o teste n vezes, espera-se que Eva não
seja capaz de voltar pelo lado escolhido em n
2 vezes, o que não convencerá Victor que

ela possui o segredo.

Existem diversas maneiras de executar esse procedimento matematicamente [13], a

seguir será descrita uma usando resíduos quadráticos.

6.1 P R O VA D E C O N H E C I M E N T O Z E R O C O M R A Í Z E S Q U A D R A D A S M Ó D U L O N

Como já foi visto antes em 5.2, calcular a raiz quadrada módulo N, quando N = p · q
com p e q primos, é tão difícil como fatorar N. Seja y algum quadrado módulo N, co-

primo com N, e Peggy quer provar para Victor que ela conhece o segredo que é a raiz
quadrada de y módulo N, ou seja, que ela conhece s tal que s2 = y (mod N), mas ela
não quer que Victor descubra s.

Peggy então escolhe um número aleatório r1 e encontra r2 tal que r1 · r2 = s (mod N),
2 (mod N)

· s (mod N). Em seguida, calcula x1 = r2

1 (mod N) e x2 = r2

ou seja, r2 = r−1
1
e envia a Victor x1 e x2.

6.2 P R O T O C O L O F E I G E - F I AT- S H A M I R

39

Victor veriﬁca que x1 · x2 = y (mod N) e escolhe x1 ou x2 para que Peggy forneça
sua raiz e veriﬁca que a raiz fornecida é a correta. O procedimento é repetido até que

Victor seja convencido que Peggy conhece a raiz s.

Se Peggy conhecer a raiz, ela sempre é capaz de fornecer r1 e r2, tomando o cuidado
de não repetir os valores de r1 pois se ela fornecer a Victor duas vezes o mesmo valor x1
e x2, ele pode pedir a Peggy as duas raízes e descobrir s = r1 · r2 (mod N), justamente
o que Peggy está evitando.

Supondo que Peggy não conhece a raiz de y, ela ainda é capaz de enviar a Victor x1
e x2 tal que x1 · x2 = y (mod N). Ela pode tentar prever qual das duas raízes Victor
pedirá, por exemplo x2 e calcular x2 = r2
2 (mod N) e calcular x1 para que x1 · x2 = y
(mod N). Ela não é capaz de calcular r1, pois se fosse poderia calcular s e nesse caso
ela é capaz de enganar Victor em 1
2 das vezes. Após n tentativas, a probabilidade de

Victor ser convencido se Peggy não conhece s é desprezível.

Caso tenha alguém observando, por exemplo Eva, ela irá apenas conhecer algumas

raízes quadradas aleatórias. Ela será capaz de enganar Victor se ele perguntar a mesma

sequência de números x1 e x2. Se a ordem for mudada, Eva não é capaz de usar a
informação obtida para calcular novas raízes. Essa é a característica importante de

uma prova de conhecimento zero, já que o veriﬁcador ou qualquer outro observador

não conseguem nenhum conhecimento adicional a partir da resposta de Peggy.

Obviamente, todos tem o conhecimento de N mas não dos primos p e q que o

originaram. Caso contrário, é relativamente simples calcular as raízes quadradas de

qualquer y, como visto anteriormente em 5.1.

6.2 P R O T O C O L O F E I G E - F I AT- S H A M I R

Esse protocolo foi desenvolvido por Uriel Feige, Amos Fiat e Adi Shamir em 1988 [7]

e usa uma ideia similar ao capítulo anterior, diminuindo o número de comunicações
necessárias. Para isso precisamos novamente de N = p · q, o produto de dois números
primos desconhecidos.

Peggy tem como segredo os números s1, . . . , sk, todos co-primos com N. Victor re-
cebe os números vi = s−2
(mod N), 1 ≤ i ≤ k, os inversos módulo N de s2 (mod N) e
deve veriﬁcar se Peggy realmente possui o segredo. Para tal, são executados os seguin-

i

tes passos:

40

P R O VA D E C O N H E C I M E N T O Z E R O

1. Peggy escolhe um inteiro aleatório r e envia a Victor x = r2 (mod N).

2. Victor escolhe e manda para Peggy uma cadeia de números b1, . . . , bk, onde bi ∈

{0, 1}.

3. Peggy devolve a Victor o número y tal que y = r · sb1

1 · sb2

2 . . . sbk

k

(mod N).

4. Victor veriﬁca que x = y2 · vb1

1 · vb2

2 . . . vbk

k

(mod N)

Repete-se a sequência quantas vezes forem necessárias, sempre escolhendo-se um r

diferente.

Percebe-se que, para k = 1, Peggy deve informar r ou r · s1, dois números cujo
quociente é uma raiz quadrada módulo N de v1, a mesma ideia do processo anterior
mas com quocientes ao invés de produto.

Para k maior, é fácil para Peggy calcular y se ela possui o segredo e o único conheci-
2 . . . vbk

mento que Victor consegue é uma raiz de um número da forma x = y2 · vb1
(mod N), o que não é suﬁciente para descobrir o segredo s1, . . . , sk.

1 · vb2

k

Se Eva, que não possui o segredo, quiser se passar por Peggy, precisará adivinhar

qual a sequência de números b1, . . . , bk Victor pedirá antes de enviar x, pois como não
sabe calcular o inverso módulo N das raízes quadradas de v1, . . . , vk, ela precisará
escolher x = y2 · vb1

k e retornar a Victor o valor y, que passará no teste.

2 . . . vbk

1 · vb2

Como há 2k possíveis valores de bi, ao repetir esse esquema t vezes, a probabilidade

que Eva engane Victor será de 1

2kt , que é desprezível.

Numericamente, vamos pegar como exemplo N = 16637. Os primos 127 e 131 são

os fatores de N mas são secretos.

Peggy tem como segredo 5 números S = (3994, 2670, 3419, 8487, 2944) e Victor recebe

como veriﬁcador os números V = (3290, 7479, 10842, 15785, 9138). Podemos verﬁcar
que vi · s2

i = 1 (mod 1)6637 com 1 ≤ i ≤ 5.

Victor então pede a Peggy para veriﬁcar se ela possui a senha. Os seguintes passos

são executados:

1. Peggy escolhe um número aleatoriamente, r = 1042, e informa a Victor o valor

x = 4359 que é o resultado de r2 (mod 16637).

2. Victor escolhe uma cadeia de 5 bits bi e envia a Peggy. Nesse exemplo, bi =

(0, 1, 1, 1, 0).

6.2 P R O T O C O L O F E I G E - F I AT- S H A M I R

41

3. Peggy calcula y = 1042 · 39940 · 26701 · 34191 · 84871 · 29440 (mod 16637) e de-

volve a Victor o resultado y = 6365.

4. Victor veriﬁca que de fato x = 63652 · 32900 · 74791 · 108421 · 157851 · 91380 (mod 16637) =

4359.

Se Victor não ﬁcou contente e acha que pode ter sido enganado, uma probabilidade
25 conforme visto anteriormente, ele pode pedir uma nova veriﬁcação. Peggy só

de 1

precisa escolher um novo número r e repetir o processo.

7

A P L I C A Ç Ã O E M S A L A D E A U L A

Como aplicação em sala de aula, decidi trabalhar de forma lúdica um leilão. O

objetivo dessa aula é motivar os alunos e mostrar uma aplicação da álgebra abstrata
discreta para alunos de 8o e 9o anos do ensino fundamental.

O processo descrito abaixo funciona para leilões e licitações. A diferença é que,

enquanto no leilão ganha quem der o maior lance, na licitação ganha quem ofertar o

menor preço.

Antes do jogo ser feito, é necessário explicar aos alunos alguns conceitos de aritmé-

tica modular, mostrar como funciona o resto das divisões de números inteiros e que

esse resto é importante em um grande número de situações, visto que a maioria dos

alunos tem por hábito efetuar a divisão de números racionais (utilizando a vírgula)

mesmo quando não convém ao problema.

Os alunos são divididos em grupos e a cada grupo é dado um mesmo número arbi-

trário C de créditos. Esses créditos poderão ser usados para comprar pontos por meio

de um leilão aberto. Após um número R de rodadas, a equipe que tiver mais pontos

ganhará o jogo.

A tática deve ser que cada grupo dê o maior lance possível, mas se gastar todos os

seus créditos de início não terá como ganhar os lances posteriores. Cada grupo deverá

apresentar seu lance de forma pública, mas se os outros grupos souberem o lance dos

concorrentes antes de divulgar o seu, podem alterar seu lance. Para evitar isso, cada

grupo irá criptografar seu lance usando o seguinte processo:

1. Cada grupo escolhe seu lance L em segredo.

43

44

A P L I C A Ç Ã O E M S A L A D E A U L A

2. Os grupos calculam Hi = L2

i (mod N), sendo i o número de cada grupo, onde N
é um número fornecido previamente pelo professor e N = p · q, onde p e q são
números primos desconhecidos pelos alunos.

3. Cada grupo apresenta Hi para os demais.

4. Após todos conhecerem Hi, todos revelam Li e podem veriﬁcar que Hi = L2
i

(mod N).

Alguns cuidados devem ser tomados com a escolha dos números. Por exemplo,
N > 2.C, pois algum grupo poderia dar uma lance L e dizer que seu lance original era
N − L pois L2 = (N − L)2 (mod N).

Também pode acontecer de um grupo testar vários valores para descobrir qual lance

seu oponente mandou. Para evitar isso, considere que o lance máximo L tem M casas
decimais. O grupo escolhe um número Y e calcula H = (Y · 10M + L)2 (mod N). Esse
processo aumenta um pouco os cálculos, mas torna quase impossível descobrir por
tentativa e erro o valor L escolhido. Ao apresentar o valor Y · 10M + L para veriﬁcação,
os M últimos dígitos corresponderão ao lance L.

Vamos exempliﬁcar usando N = 437. A fatoração desse número é 19 · 23 mas não

será fornecida aos alunos.

Serão feitos quatro grupos e cada grupo receberá C = 100 créditos para gastar em

R = 4 rodadas. Cada um dos grupos deverá criar uma estratégia para vencer. Após a

primeira rodada, os lances pensados por cada grupo e os valores H calculados são:

Grupo 1 Grupo 2 Grupo 3 Grupo 4

L

Y
Y.103 + L

25

0

25

35

0

35

H

188

351

10

3

3010

216

40

0

40

289

Note que apenas o grupo 3 viu necessidade de usar o método alternativo pois
102 = 100 (mod 437) e seria fácil para os demais descobrirem seu lance. Quando todos
revelarem seus lances, o grupo 4 ganhará essa rodada e a segunda rodada começará.

Lembrando que após essa rodada, todos os grupos ainda dispõem de 100 créditos para

a compra com exceção do grupo 4 que possui apenas 60 créditos.

A P L I C A Ç Ã O E M S A L A D E A U L A

45

É interessante mencionar aos alunos que calcular as raízes módulo N, sendo N um

número composto, é difícil se seus fatores forem grandes, mas que há métodos de

calcular as raízes módulo p, sendo p um número primo.

Dependendo do andamento da atividade, pode ser interessante que o professor mos-

tre, após o leilão, que ele (e só ele, que conhece os fatores p e q de N) consegue

obter as raízes, sendo necessária uma autoridade conﬁável (no caso, o professor) para

escolher p e q de forma a fornecer um N cuja fatoração seja desconhecida por todos.

B I B L I O G R A F I A

[1] BARKAN, E.; BIHAM, E.; KELLER, N. Instant ciphertext-only cryptanalysis of GSM

encrypted communication. In: ANNUAL INTERNATIONAL CRYPTOLOGY CONFE-

RENCE, 23., 2003, Santa Barbara. Proceedings... Berlin: Springer, 2003. p. 600-

616.

[2] BLUM, L.; BLUM M.; SHUB M. A simple unpredictable pseudo-random number

generator. SIAM Journal on Computing, v. 15, n. 2, p. 364-383, 1986.

[3] BLUM, M.; MICALI, S. How to generate cryptographically strong sequences of

pseudorandom bits. SIAM Journal on Computing, v. 13, n. 4, p. 850-864, 1984.

[4] CHAUM, D.; VAN HEIJST, E.; PFITZMANN, B. Cryptographically strong undeni-

able signatures, unconditionally secure for the signer. Advances in Cryptology -

CRYPTO 91, p. 470-484, 1992.

[5] DELFS, H.; KNEBL, H. Introduction to Cryptography: Principles ans Applications.

2. ed. Berlin Heidelberg: Springer, 2007. 367 p.

[6] FALEIROS, A. C. Criptograﬁa. São Carlos: Sociedade Brasileira de Matemática

Aplicada e Computacional, 2011. 138 p.

[7] FEIGE, U.; FIAT, A.; SHAMIR, A. Zero-knowledge proofs of identity. Journal of

Cryptology, v. 1, n. 2, p. 77-94, 1988.

[8] KATZ, J.; LINDELL, Y. Introduction to Modern Cryptography. 1 ed. CRC Press,

2007. 498 p.

[9] QUISQUATER, J. J.; GUILLOU, L. C.; BERSON, T. A. How to explain zero-

knowledge protocols to your children. Advances in Cryptology - CRYPTO 89,

p. 628-631, 1990.

[10] RABIN, M. O. Digitalized signatures and public-key functions as intractable

as factorization. MIT Laboratory for Computer Science, 1979. 16 p.

[11] SHANNON, C. E. Communication theory of secrecy systems. Bell System Tech-

nical Journal, v. 28, n. 4, p. 656-715, 1949.

47

48

BIBLIOGRAFIA

[12] STINSON, D. R. Cryptography: Theory and Practice. 3 ed. Chapman Hall/CRC,

2006. 593 p.

[13] TRAPPE, W; WASHINGTON, L. C. Introduction to Cryptography with Coding

Theory. 2. ed. Pearson Education International, 2006. 577 p.

[14] VON NEUMANN, J. Various techniques used in connection with random digits.

National Bureau of Standards Applied Mathematics Series, n. 12, p. 36-38.

1961.

