UNIVERSIDADE FEDERAL DO ESTADO DO RIO DE JANEIRO

CENTRO DE CIÊNCIAS EXATAS E TECNOLOGIA

CURSO DE PÓS-GRADUAÇÃO EM MATEMÁTICA

Solução Numérica da Equação da Onda

Alcebíades de Calazans Barbosa

Rio de Janeiro

2019

Alcebíades de Calazans Barbosa

Solução Numérica da Equação da Onda

Trabalho de Conclusão de Curso apre-

sentado ao Programa de Pós-graduação

em Matemática PROFMAT da UNI-

RIO, como requisito para a obtenção

do grau de MESTRE em Matemática.

Área de Concentração: Métodos Numéricos

Orientador: Prof. Dr. Adriano Maurício de Almeida Côrtes

Rio de Janeiro

2019

Barbosa, Alcebíades de Calazans

B238

Solução Numérica da Equação da Onda / Alcebíades de

Calazans Barbosa. -- Rio de Janeiro, 2019.

199

Orientador: Adriano Maurício de Almeida Côrtes.

Dissertação (Mestrado) - Universidade Federal do

Estado do Rio de Janeiro, Programa de Pós-Graduação

em Matemática, 2019.

1. Matemática. 2. Métodos Numéricos. I. Côrtes,

Adriano Maurício de Almeida, orient. II. Título.

Dedico este trabalho aos meus pais, Raimundo (in me-

moriam) e Clarisse, cujo esforço possibilitou que eu atin-

gisse o nível de educação que possuo hoje em dia.

Agradecimentos

Este trabalho representa uma conquista importante na vida do seu autor. Muitas

pessoas foram importantes na sua realização.

Agradeço aos familiares a compreensão pelos momentos de ausência em que foi

necessária a dedicação a esta dissertação para poder concluí-la.

Agradeço aos professores da UniRio pela dedicação e interesse no aprendizado dos

seus alunos, mesmo que tenha havido momentos de cobrança necessários ao aprendi-

zado. Agradeço também aos colegas de curso pelo companheirismo.

Realizei o curso de mestrado em paralelo ao trabalho em uma empresa. Para isso,

foi preciso conciliar os horários. Nisso, agradeço aos colegas e gerentes da empresa.

Agradeço em especial à colega Ana Paula pelo apoio na adequação dos horários e

atividades, permitindo conciliar o curso de mestrado com as atividades proﬁssionais.

Agradeço aos membros da banca pelo interesse e pelas contribuições para este tra-

balho. Agradeço em especial ao orientador Adriano Maurício, que desde o início acre-

ditou que um trabalho interessante poderia ser realizado, prestou os esclarecimentos

necessários e dedicou-se na sua revisão.

Agradeço a todos que, de alguma forma, contribuíram para a realização deste tra-

balho.

Resumo

Modelos matemáticos envolvendo equações diferenciais são usadas em diversas áreas

da ciência e da engenharia. Há métodos analíticos que permitem encontrar soluções

exatas para esse tipo de equação. Na prática, porém, pouco problemas podem ser

resolvidos através de métodos analíticos. Uma alternativa é usar métodos numéricos,

os quais não permitem encontrar a solução exata, mas levam a uma solução aproximada

em que o nível de precisão pode ser estimado com segurança. Este trabalho concentra-

se em métodos numéricos destinados à solução da equação da onda, que é uma das

equações mais importantes da Física. A equação da onda encontra aplicações em

diversas áreas. Por exemplo, podemos citar as ondas acústicas, as ondas de água, as

ondas eletromagnéticas e as ondas sísmicas. Adotamos aqui o método das diferenças

ﬁnitas para a solução numérica da equação da onda. Além de meios homogêneos,

abordamos a transmissão de ondas em meios com diversas camadas. Apresentamos

exemplos de utilização dos métodos na linguagem de programação Python.

3

Palavras-chave

Equação da onda, Métodos numéricos, Diferenças ﬁnitas, Python, Equações dife-

renciais.

4

Abstract

Mathematical models involving diﬀerential equations are used in several areas of

science and engineering. There are analytical methods that allow us to ﬁnd exact

solutions for this type of equation. In practice, however, few problems can be solved

through analytical methods. An alternative is to use numerical methods, those not

allow us to ﬁnd an exact solution, but lead to an approximate solution in which the

level of accuracy can be safely estimated. This work focuses on numerical methods for

solving the wave equation, which is one of the most important equations in physics. The

wave equation ﬁnds applications in several areas. For example, we can mention acoustic

waves, water waves, electromagnetic waves and seismic waves. We have adopted here

the ﬁnite diﬀerence method for the numerical solution of the wave equation. In addition

to the homogeneous media, we discuss the transmission of waves in media with several

layers. We present examples of using the method in the Python programming language.

5

Keywords

Wave equation, Numerical methods, Finite diﬀerences, Python, Diﬀerential equa-

tions.

6

Lista de Figuras

2.1 Gráﬁco de u(x, t) no instante t = t0 . . . . . . . . . . . . . . . . . . . .

2.2 Sistema massa-mola.

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.3 Gráﬁcos correspondentes às três primeiras parcelas do somatório dado

pela equação 2.16. As curvas tracejadas representam as variações de

amplitude que ocorrem com o tempo. . . . . . . . . . . . . . . . . . . .

2.4 Solução de d’Alembert: duas “ondas em movimento”.

. . . . . . . . . .

3.1 Valores usados na Fórmula de Diferenças Centradas . . . . . . . . . . .

3.2 Solução pelo método de Euler Progressivo . . . . . . . . . . . . . . . .

3.3 Tanques interconectados . . . . . . . . . . . . . . . . . . . . . . . . . .

17

19

25

27

31

41

51

3.4 Solução numérica do problema do exemplo 3.10 pelo método Trapezoidal. 53

3.5 Solução numérica do exemplo 3.11 pelo Método do Ponto Médio. . . . .

55

4.1 Estêncil do método direto . . . . . . . . . . . . . . . . . . . . . . . . .

4.2 Aproximação da Equação da Onda . . . . . . . . . . . . . . . . . . . .

4.3 Equação da Onda, posição em diversos instantes . . . . . . . . . . . . .

4.4 Domínio de Dependência do Problema . . . . . . . . . . . . . . . . . .

4.5 Domínio de Dependência da Solução Numérica . . . . . . . . . . . . . .

60

62

63

64

65

7

4.6 Equação da onda em um meio com duas camadas, mostrando a conﬁgu-

ração da onda em diversos instantes . . . . . . . . . . . . . . . . . . . .

74

5.1 Regiões de estabilidade de alguns métodos numéricos . . . . . . . . . .

99

6.1 Estêncil da primeira abordagem para equação da advecção . . . . . . . 111

6.2 Estêncil do método Leapfrog . . . . . . . . . . . . . . . . . . . . . . . . 112

6.3 Curva característica da equação da advecção. (a) caso em que v > 0 (b)

caso em que v < 0.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

6.4 Método das Linhas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

6.5 Equação da Advecção - Solução Numérica . . . . . . . . . . . . . . . . 117

6.6 Autovalores da matriz obtida utilizando o Método das Linhas para a

equação de advecção, comparando com a região de estabilidade do mé-

todo de Euler Progressivo.

. . . . . . . . . . . . . . . . . . . . . . . . . 119

6.7 Autovalores da matriz obtida utilizando o Método das Linhas para a

equação de advecção, comparando com a região de estabilidade do mé-

todo do ponto médio. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

A.1 Discos de Gershgorin da matriz de exemplo . . . . . . . . . . . . . . . . 150

B.1 Gráﬁco da função periódica conhecida como função “dente de serra”. . . 160

8

Sumário

Lista de Figuras

Sumário

1 Introdução

2 A equação da onda

2.1 Sobre Condições Iniciais e de Contorno . . . . . . . . . . . . . . . . . .

2.2 Solução Analítica da Equação da Onda . . . . . . . . . . . . . . . . . .

2.3 Propagação de Ondas em Meios com Diversas Camadas . . . . . . . . .

3 Aproximações por Diferenças Finitas

3.1 Fórmulas Para Aproximação da Derivada de uma Função . . . . . . . .

3.2 Erro de Aproximação . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.3 Método dos Coeﬁcientes Indeterminados

. . . . . . . . . . . . . . . . .

3.4 Problemas de Valor Inicial

. . . . . . . . . . . . . . . . . . . . . . . . .

3.5 Existência e Unicidade . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.6 Métodos para Problemas de Valor Inicial

. . . . . . . . . . . . . . . . .

3.7 Sistemas de Equações Diferenciais . . . . . . . . . . . . . . . . . . . . .

4 Solução Numérica da Equação da Onda

9

7

9

11

15

21

24

28

30

30

32

35

38

41

43

48

57

4.1 Discretização da Equação da Onda . . . . . . . . . . . . . . . . . . . .

4.2 A Condição CFL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.3 Calculando os Erros . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.4 Propagação de Ondas em Meios com Diversas Camadas . . . . . . . . .

5 Convergência e Estabilidade

5.1 Consistência . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.2 Convergência . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.3 Estabilidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.3.1 Métodos de passo múltiplo . . . . . . . . . . . . . . . . . . . . .

5.4 Estabilidade Absoluta . . . . . . . . . . . . . . . . . . . . . . . . . . .

6 O Método das Linhas

57

61

66

68

75

75

79

84

90

94

108

6.1 A Equação da Advecção . . . . . . . . . . . . . . . . . . . . . . . . . . 108

6.2 Apresentando o Método das Linhas . . . . . . . . . . . . . . . . . . . . 112

6.3 MDL Aplicado à Equação da Onda . . . . . . . . . . . . . . . . . . . . 121

7 Considerações Finais

Referências Bibliográﬁcas

A Alguns Conceitos de Álgebra Linear

132

135

139

B Solução da Equação da Onda pelo Método de Separação de Variáveis153

B.1 Autofunções . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

B.2 Séries de Fourier

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

B.3 O método de separação de variáveis . . . . . . . . . . . . . . . . . . . . 165

C Códigos de Programação

171

10

Capítulo 1

Introdução

Ao escolhermos o tema para este trabalho, levamos em conta a experiência do autor

com programação de computadores. Buscávamos um tema que permitisse aplicar con-

ceitos matemáticos a algum problema prático. Assim, escolhemos a área de métodos

numéricos, que permite aplicar soluções computacionais a problemas matemáticos. Em

particular, escolhemos a equação da onda, que é uma das mais importantes da Física.

A equação da onda encontra aplicações em diversas áreas. Por exemplo, podemos

citar as ondas acústicas, as ondas de água, as ondas eletromagnéticas e as ondas sís-

micas. Destacamos a simulação computacional da propagação de ondas sísmicas. Esse

tipo de simulação é utilizado para o entendimento da formação geológica do subsolo,

com aplicação na Geologia e na Geofísica. Estão disponíveis, atualmente, diversas

técnicas numéricas para solucionar equações diferenciais. Torna-se importante encon-

trarmos exemplos de como aplicar essas técnicas à equação da onda. Por essas razões,

escolhemos o tema da solução numérica da equação da onda.

Consideramos que este tema pode ser útil, inclusive, para professores do ensino

médio. O conceito de ondas é um assunto avançado, em termos teóricos, para os

alunos de ensino médio. Porém, até certo ponto, é um assunto intuitivo, pois as ondas

11

estão presentes na nossa experiência cotidiana.

A linguagem de programação Python, que adotamos neste trabalho, é de fácil apren-

dizagem e bastante adequada para a programação matemática:

“Escolhemos usar a linguagem de programação Python porque combina

poder notável com sintaxe muito limpa, simples e compacta. O Python é

fácil de aprender e muito adequado para uma introdução à programação de

computadores. O Python também é bastante semelhante ao Matlab e uma

boa linguagem para fazer computação matemática” [LANGTANGEN, 2011,

p.v].

Consultando a literatura, veriﬁcamos que há diversas técnicas numéricas para so-

lucionar equações diferenciais. Podemos citar os métodos de diferenças ﬁnitas, de ele-

mentos ﬁnitos e de volumes ﬁnitos. Neste trabalho, optamos pelo método de diferenças

ﬁnitas, por sua relativa simplicidade e versatilidade.

“Uma grande quantidade de modelos computacionais é baseada em equa-

ções diferenciais ordinárias e parciais.

(...) Um tema chave é resolver

equações diferenciais numericamente em um computador. Muitos méto-

dos estão disponíveis para este propósito, mas o foco aqui é em méto-

dos de diferenças ﬁnitas, porque estes são simples, mas versáteis, para

resolver uma ampla gama de equações diferenciais ordinárias e parciais”

[LANGTANGEN, 2016, p.1].

A hipótese que adotamos é que o método das diferenças ﬁnitas pode ser aplicado

à solução numérica da equação da onda com bons resultados práticos. No decorrer

do trabalho, apresentaremos exemplos de aplicação do método para veriﬁcarmos se a

12

hipótese é verdadeira. Por uma questão de simplicidade de implementação dos méto-

dos limitamos os exemplos à equação da onda em uma dimensão espacial, o que não

representa nenhuma perda do ponto de vista teórico, uma vez que a extrapolação para

dimensões maiores é direta.

Assim, trabalharemos com o objetivo geral de apresentar exemplos de utilização

do método das diferenças ﬁnitas para a solução numérica da equação da onda. Nossos

objetivos especíﬁcos serão:

• apresentar o conceito de equação diferencial;

• apresentar o conceito de diferenças ﬁnitas;

• apresentar métodos para solução de problemas de valor inicial, exemplos de uti-

lização e comparar esses métodos.

• apresentar o Método das Linhas, que é um método que permite aplicar, para

equações diferenciais parciais, métodos numéricos destinados a equações diferen-

ciais ordinárias.

• apresentar exemplos de solução numérica da equação da onda pelo método direto

e pelo Método das Linhas.

• apresentar exemplos da solução numérica da equação da onda, para meios com

diversas camadas.

O trabalho foi realizado através de investigação de literatura existente, a respeito do

tema estudado. Esses conceitos são tanto matemáticos como de métodos numéricos e

computacionais. Além disso, desenvolvemos exemplos de código de programação para

exempliﬁcar os conceitos estudados e testar os métodos. O restante desta monograﬁa

está organizado conforme descrito a seguir.

13

No Capítulo 2, apresentamos a equação da onda, sua solução analítica e alguns

conceitos de equações diferenciais.

No Capítulo 3, apresentamos o conceito de diferenças ﬁnitas e alguns métodos

numéricos que utilizam esse conceito.

No Capítulo 4, apresentamos a solução numérica da equação da onda.

No Capítulo 5, apresentamos os conceitos de convergência e estabilidade, que serão

importante para determinar a precisão de diversos métodos numéricos.

No Capítulo 6, apresentamos o Método das Linha (MDL) e mostramos como aplicá-

lo à equação da onda.

No Apêndice A, apresentamos alguns conceitos e teoremas de Álgebra Linear utili-

zados no trabalho.

No Apêndice B, apresentamos a solução da equação da onda, pelo método de sepa-

ração de variáveis.

No Apêndice C, apresentamos os códigos de programação de exemplo, na linguagem

Python.

Esperamos que este trabalho contribua para um melhor entendimento dos métodos

numéricos aplicados a equações diferenciais e, em particular, à equação da onda. Nossa

expectativa, em termos mais amplos, é contribuir para a divulgação da Matemática,

mostrando sua utilidade, seu potencial e ferramentas para facilitar a sua utilização e

aprendizado.

14

Capítulo 2

A equação da onda

Segundo [BOYCE e DIPRIMA, 2017, p. 1], “Muitos dos princípios, ou leis, que regem

o comportamento do mundo físico são proposições, ou relações, envolvendo a taxa

segundo a qual as coisas acontecem”. Essas relações são representadas em linguagem

matemática através de equações e as taxas de variação das grandezas envolvidas são

representadas pelas derivadas das funções. Equações contendo derivadas são equações

diferenciais.

Dessa forma o estudo dos fenômenos físicos pode ser realizado através da elaboração

de modelos matemáticos. Esses modelos frequentemente envolvem equações diferen-

ciais. Segundo [ASCHER e GREIF, 2011, p.481]:

“Um grande número de modelos

matemáticos em diversas áreas da ciência e da engenharia envolvem equações diferen-

ciais”. Segundo [NAGLE, SAFF e SNIDER, 2012, p.1], “Estes modelos frequentemente

geram uma equação que contém algumas derivadas de uma função desconhecida. Tal

equação é chamada de equação diferencial.”

Existem métodos analíticos para encontrar soluções para equações diferenciais, que

podem ser encontrados em livros sobre Equações Diferenciais. Em alguns casos es-

ses métodos permitem encontrar soluções exatas para as equações. Mas, segundo

15

[BURDEN et al., 2017, p.284]: “Na prática, porém, poucos dos problemas que se ori-

ginam do estudo de fenômenos físicos podem ser resolvidos exatamente”. Segundo

[LEVEQUE, 2007, p. 3]: “Em geral, este é um problema difícil, e raramente pode ser

encontrada uma fórmula analítica para a solução”. O método das diferenças ﬁnitas, que

abordaremos neste trabalho, pode ser utilizado para encontrar soluções aproximadas

para equações diferenciais.

Considere, por exemplo, uma corda esticada horizontalmente, em que uma das

extremidades está ﬁxa e a outra está sendo balançada para cima e para baixo em um

movimento periódico. Nesse caso será produzido um movimento ondulatório que irá

se deslocar através da corda. Segundo [YOUNG e FREEDMAN, 2008b, p. 104], “O

movimento ondulátório é produzido por uma perturbação do estado de equilíbrio que

se propaga de uma região para outra do meio”. Quando a perturbação transmitida

através do meio é periódica temos uma onda. Segundo [JEWETT e JOHN, 2017, p.

104], “A onda é uma perturbação periódica se movendo através de um meio”.

Exemplo 2.1. Para analisar ondas vamos considerar uma função u(x, t) chamada

função de onda que nos fornece o deslocamento u (a partir do equilíbrio) de uma

partícula na posição x e no instante t. A função u(x, t) obedece à seguinte equação:

∂2u(x, t)

∂x2 =

1
v2

∂2u(x, t)
∂t2

(2.1)

Sua dedução pode ser encontrada em [BOYCE e DIPRIMA, 2017], na página 556.

“A Equação (2.1), denominada equação de onda, é uma das mais im-

portantes da física. Quando ela ocorre, sabemos que existe uma onda se pro-

pagando ao longo do eixo Ox com velocidade v.” [YOUNG e FREEDMAN, 2008b,

p. 112].

16

Figura 2.1: Gráﬁco de u(x, t) no instante t = t0

Na ﬁgura 2.1, podemos ver um exemplo do gráﬁco da função u(x, t), no instante

t = t0. Vamos considerar que t0 é o instante inicial em que estamos analisando a função

u(x, t).

Quando ocorre um movimento ondulatório em uma corda esticada horizontalmente,

cada elemento perturbado (partículas da corda) se move verticalmente. Por isso a onda

é chamada de onda transversal, que é o caso em que os elementos do meio perturbado

se movem perpendicularmente à direção de propagação da onda. Há outro tipo de

onda no qual os elementos do meio se movem paralelamente à direção da propagação,

chamada onda longitudinal. É o caso, por exemplo, de ondas de som, nas quais a

perturbação do meio se dá por variações de pressão. Há ainda ondas que exibem uma

combinação de movimentos longitudinais e transversais, como por exemplo ondas que

se movem em eventos sísmicos.

“A equação (2.1) se aplica, em geral, aos vários tipos de ondas que

se propagam. Para ondas em cordas, y representa a posição vertical dos

elementos da corda. Para ondas de som se propagando através de um gás,

y correponde à posição longitudinal dos elementos do gás, do equilíbrio

17

xxux=Lu(x,t0)x=0ou de variações de qualquer pressão ou densidade do gás. No caso das

ondas eletromagnéticas, y corresponde a componentes do campo elétrico

ou magnético” [JEWETT e JOHN, 2017, p. 49].

A equação (2.1) aparece com frequência quando é necessário analisar fenômenos

ondulatórios:

“Alguma forma dessa equação, ou uma de suas generalizações, aparece

quase que inevitavelmente em qualquer análise matemática de fenômenos

envolvendo a propagação de ondas em um meio contínuo. Por exemplo,

estudos de ondas acústicas, ondas de água, ondas eletromagnéticas e ondas

sísmicas baseiam-se todos nessa equação” [BOYCE e DIPRIMA, 2017, p.

532].

A equação da onda pode ser classiﬁcada como uma Equação Diferencial Parcial

(EDP), que é o tipo de equação diferencial em que a função desconhecida depende de

mais de uma variável independente e assim as derivadas que aparecem são derivadas

parciais.

Já para as equações diferenciais ordinárias, a função e suas derivadas dependem

de uma única variável independente e assim aparecem apenas derivadas simples na

equação diferencial.

Um exemplo de equação diferencial ordinária é a equação do movimento harmônico

simples. Segundo [LANGTANGEN, 2016, p.80], este é o sistema mecânico vibracional

mais fundamental.

Exemplo 2.2. Considere que um corpo de massa m está sobre um trilho horizontal e

pode se mover horizontalmente ao longo do trilho sem atrito, conforme representado

na ﬁgura 2.2. Há uma mola de massa desprezível com a extremidade esquerda mantida

18

Figura 2.2: Sistema massa-mola.

ﬁxa e a extremidade direita presa ao corpo. A força da mola é a única força horizontal

que atua sobre o corpo.

Deﬁnimos o sistema de coordenadas com a origem O na posição de equilíbrio para a

qual a mola não está esticada nem comprimida. Quando o corpo é deslocado da posição

de equilíbrio da mola, a força da mola tende a fazer o corpo voltar para a posição de

equilíbrio. Segundo [JEWETT e JOHN, 2017, p. 1], “O movimento harmônico simples

também forma a base de nossa compreensão de ondas mecânicas. Ondas sonoras,

sísmicas, em cordões esticados e na água são todas produzidas por alguma fonte de

oscilação”.

Se x(t) representa o deslocamento horizontal do corpo em relação à origem, então

temos a seguinte equação:

m

d2x(t)
dt2 = −kx(t),

(2.2)

que representa uma relação entre a função x(t) e a sua derivada segunda, x(cid:48)(cid:48)(t). A

dedução desta equação pode ser encontrada em [JEWETT e JOHN, 2017, p. 4].

Outra classiﬁcação importante das equações diferenciais é quanto à ordem. A

ordem de uma equação diferencial é a ordem da derivada de maior ordem que aparece

19

xmFmna equação. Por exemplo, as equações (2.2) e (2.1) são de segunda ordem.

Outra classiﬁcação importante das equações diferenciais é quanto à linearidade.

Deﬁnição 2.1. Uma equação diferencial ordinária linear de ordem n é uma equa-

ção que pode ser escrita na forma

an(t)y(n) + an−1(t)y(n−1) + ... + a1(t)y(cid:48) + a0(t)y = g(t)

(2.3)

onde a0(t), a1(t), ..., an(t) e g(t) dependem somente de t e não de y.

Por exemplo, a equação (2.2) é uma equação diferencial ordinária linear, assim como

a equação

sen (t)y(cid:48)(cid:48) = cos t

Quando uma equação diferencial ordinária não pode ser escrita na forma da equação

(2.3), dizemos que ela é não linear. Por exemplo, a equação

y2y(cid:48)(cid:48) = cos t

é não linear.

Para o caso das equações diferenciais parciais, vamos nos limitar a equações de

segunda ordem com duas variáveis independentes. Porém este conceito pode ser extra-

polado para equações de ordem mais alta e mais variáveis independentes.

Deﬁnição 2.2. Uma EDP linear de segunda ordem, com duas variáveis independentes,

é uma equação que pode ser escrita na forma:

a(x, y)

∂2u
∂x2 + 2b(x, y)

∂2u
∂x∂y

+ c(x, y)

∂2u
∂y2 + d(x, y)

∂u
∂x

+ e(x, y)

∂u
∂y

+ f (x, y)u = δ(x, y)

(2.4)

Por exemplo, a equação (2.1) se enquadra no formato da equação (2.4) e portanto

é uma equação diferencial parcial linear.

20

2.1 Sobre Condições Iniciais e de Contorno

Uma equação diferencial geralmente possui um número inﬁnito de soluções.

Exemplo 2.3. Se considerarmos a equação diferencial

y(cid:48)(t) = y(t),

(2.5)

temos que y(t) = et é uma solução, pois a derivada dessa função é igual à própria

função. Porém, a função y(t) = 2et também é uma solução. Podemos ver isso derivando

a função diretamente. Na verdade, qualquer função da forma

y(t) = Cet,

(2.6)

onde C é uma constante, também é uma solução. Assim, podemos pensar em (2.6)

como uma família de soluções, com uma solução especíﬁca para cada valor de C.

Para conseguirmos determinar a solução de um determinado problema, precisamos

de mais algumas informações além da própria equação diferencial. Assim, o problema

poderá ser acompanhado das chamadas condições iniciais.

Exemplo 2.4. A equação (2.5) pode ser acompanhada da seguinte condição inicial:

y(0) = 1.

(2.7)

De posse dessa condição inicial, basta substituir na equação (2.6):

y(0) = Ce0 = 1,

e concluímos que C = 1, donde y(t) = et é a solução do problema que atende à

condição (2.7).

Deﬁnição 2.3 (Problema de Valor Inicial). Um problema composto de uma equação

diferencial acompanhada de condições iniciais é chamado problema de valor inicial.

21

Exemplo 2.5. A equação diferencial do sistema massa-mola, equação (2.2), acompa-

nhada das condições iniciais

x(0) = A,

x(cid:48)(0) = 0,

determina um problema de valor inicial. Podemos pensar que essas condições deter-

minam que a mola encontra-se inicialmente com o deslocamento máximo A e com a

velocidade 0. A solução a seguir atende às duas condições iniciais fornecidas:

x(t) = A cos

(cid:32)(cid:114)

(cid:33)
t

k
m

(2.8)

Condições iniciais fornecem o valor da função (e possivelmente da uma ou mais de

suas derivadas) em um ponto. Porém as aplicações físicas muitas vezes levam a outro

tipo de problema, onde o valor da função é especiﬁcado em dois pontos diferentes.

Essas condições são chamadas condições de contorno ou condições de fronteira.

Exemplo 2.6. Poderíamos ter a equação diferencial

y(cid:48)(cid:48)(x) = Ky(x),

acompanhada das condições de contorno:

y(α) = y0,

y(β) = y1.

Deﬁnição 2.4 (Problema de Valor de Contorno). Uma equação diferencial junto com

uma condição de contorno apropriada forma um problema de valores de contorno.

Exemplo 2.7. Vamos considerar que a equação (2.1) modela uma onda em uma corda.

Nesse caso a função u(x, t) representa o deslocamento vertical da corda na posição x e

22

no instante t. Se considerarmos que a corda encontra-se ﬁxa nas duas extremidades,

podemos ter as seguintes condições de contorno:

u(0, t) = 0,

u(L, t) = 0,

(2.9)

que nos indicam que o deslocamento vertical da corda é igual a zero nos pontos x = 0

e x = L, em qualquer instante t.

Poderíamos especiﬁcar qual a forma da corda no instante t = 0. Nesse caso, a corda

poderia começar com uma forma senoidal, por exemplo, f (x) = sen

(cid:17)

(cid:16)π x
L

. Nesse caso,

a condição inicial seria especiﬁcada por

u(x, 0) = sen

(cid:16) π x
L

(cid:17)

.

(2.10)

Na ﬁgura 2.1, vemos que a onda de exemplo possui uma forma senoidal no instante

t = t0. Considerando t0 como o instante inicial, esse seria o gráﬁco da função que nos

dá a condição inicial do problema. Nos pontos x = 0 e x = L, a função assume o valor

0, respeitando à condição de contorno que deﬁne que o deslocamento vertical da corda

é igual a zero nos extremos do intervalo.

Nos caso da equação da onda, por se tratar de uma equação de segunda ordem,

precisamos também especiﬁcar uma velocidade inicial para a corda. Por exemplo,

suponha que a corda encontra-se imóvel no instante t = 0, ou seja, a velocidade é igual

a 0. Assim, a derivada parcial da função u(x, t) em relação à variável t será nula no

instante inicial. Teremos a seguinte condição inicial:

∂u(x, 0)
∂t

= 0.

(2.11)

Neste caso, o problema é composto da equação diferencial 2.1, das condições de

contorno 2.9 e das condições iniciais 2.10 e 2.11. Assim teremos um problema de

valor inicial e de contorno.

23

2.2 Solução Analítica da Equação da Onda

Vamos considerar o seguinte problema de valores iniciais e de contorno:

Exemplo 2.8. Considere que uma corda encontra-se esticada horizontalmente, com

as extremidades ﬁxas. Pode ser, por exemplo, a corda de um violão ou violino. Essa

corda tem comprimento L. A função u(x, t) irá representar o deslocamento vertical da

corda, na posição x e no instante de tempo t. Assim, a variável x pertence ao intervalo

[0, L]. Vamos considerar o tempo entre os instantes 0 e T , assim a variável t pertence

ao intervalo [0, T ].

Conforme discutimos no início deste capítulo, a função u(x, t) obedece à equação

da onda:

∂2u(x, t)
∂t2

= c2 ∂2u(x, t)

∂x2

para x ∈ (0, L), t ∈ (0, T ]

(2.12)

Como as extremidades da corda estão ﬁxas, teremos as seguintes condições de

contorno

u(0, t) = 0 para t ∈ (0, T ],

u(L, t) = 0 para t ∈ (0, T ].

(2.13)

Suponha também que o formato da corda no instante t = 0 é dado pela função

f (x). Assim, teremos a seguinte condição inicial

u(x, 0) = f (x) para x ∈ [0, L].

(2.14)

Além disso, consideramos que a corda encontra-se parada no instante t = 0. Assim,

a velocidade da corda será nula nesse instante, e teremos mais uma condição inicial

para velocidade:

∂u(x, 0)
∂t

= 0 para x ∈ [0, L].

(2.15)

A solução da equação da onda pode ser calculada pelo método de separação de

variáveis. No apêndice B, apresentamos a solução por esse método. Chegamos à

24

Figura 2.3: Gráﬁcos correspondentes às três primeiras parcelas do somatório dado pela

equação 2.16. As curvas tracejadas representam as variações de amplitude que ocorrem

com o tempo.

seguinte solução:

u(x, t) =

∞
(cid:88)

n=1

bn sen

(cid:17)

(cid:16)nπx
L

cos

(cid:18)nπct
L

(cid:19)
.

(2.16)

Os bn são os coeﬁcientes da série de Fourier em senos, que deﬁnimos no apêndice

B, e são dados pela expressão

bn =

2
L

(cid:90) L

0

fI(x) sen

(cid:16)nπx
L

(cid:17)

dx, n = 1, 2, 3, ...,

onde fI é a extensão ímpar de f , com período 2L.

Intuitivamente, podemos pensar que esta solução corresponde à superposição (soma)

de várias funções que representam movimentos vibratórios na corda. Cada uma das fun-
(cid:19)

ções sen

representa um modo do movimento vibratório. A função cos

(cid:18) nπct
L

(cid:17)

(cid:16)nπx
L

está associada à frequência do movimento, para um determinado modo. São várias on-

das imóveis que vibram com frequências diferentes. Os gráﬁcos apresentados na ﬁgura

2.3 representam as três primeiras parcelas do somatório, para n = 1, 2 e 3.

Vamos apresentar a seguir mais uma solução para a equação da onda. Esta solução,

na verdade, é equivalente à solução obtida pelo método de separação de variáveis.

25

0L0L0Ln = 1n = 2n = 3Se considerarmos a equação da onda deﬁnida sobre um domínio ilimitado, −∞ <

x < ∞ e 0 ≤ t < ∞, com a condição inicial (2.14) e a condição inicial não-homogênea

para velocidade

teremos como solução

∂u(x, 0)
∂t

= g(x),

u(x, t) =

f (x − ct) + f (x + ct)
2

+

1
2c

(cid:90) x+ct

x−ct

g(s)ds.

Este resultado é conhecido como fórmula de d’Alembert. A demonstração pode ser

encontrada em [FARLOW, 1993, p.129].

Observe que, para o problema do exemplo 2.8, temos g(x) = 0. Se considerarmos

este problema com domínio ilimitado, teremos a solução:

u(x, t) =

1
2

(f (x − ct) + f (x + ct)).

Podemos observar que a equação acima é composta da soma das funções 1

2f (x − ct)

e a função 1

2f (x + ct). A primeira representa uma translação horizontal da função

1
2f (x), em ct unidades, para a direita; a segunda representa uma translação horizontal

da função 1

2f (x), em ct unidades, para a esquerda. A ﬁgura 2.4 ilustra o que acontece:

a metade do valor inicial da função u(x, t), dados pela condição inicial u(x, 0) = f (x),

move-se para a direita com velocidade c, enquanto a outra metade move-se para a

esquerda. Tratam-se de duas “ondas em movimento”.

As duas soluções apresentadas representam duas maneiras distintas de pensar na

equação da onda: a primeira, como superposição de ondas imóveis. Já a segunda seria

como “ondas em movimento”.

Mencionamos anteriormente que a solução para o problema da corda

vibrante (...) consistia em uma superposição de ondas imóveis. Há também

26

Figura 2.4: Solução de d’Alembert: duas “ondas em movimento”.

‘ondas em movimento’ associadas com a equação da onda. Tais ondas

surgem naturalmente pela solução de d’Alembert para a equação de onda

para uma corda ‘inﬁnita’.” [NAGLE, SAFF e SNIDER, 2012, pag.496].

Observamos que as duas soluções apresentadas não se contradizem. Para ilus-

trar este fato, observamos que podemos expressar uma onda no formato da solu-

ção obtida pelo método de separação de variáveis como uma superposição de duas

funções, no formato da fórmula de d’Alembert. O exemplo a seguir encontra-se em

[NAGLE, SAFF e SNIDER, 2012, pag. 499]:

Exemplo 2.9. Expresse a onda imóvel cos

(cid:19)

(cid:18) nπct
L

sen

(cid:17)

(cid:16)nπx
L

como uma superposição

de ondas em movimento.

Solução:

27

xtu(x,t)1/2 f(x-ct)1/2 f(x+ct)Utilizando identidades trigonométricas, podemos concluir que

cos

(cid:19)

(cid:18) nπct
L

sen

(cid:17)

(cid:16) nπx
L

=

1
2

sen

π(x − ct)
L

+

1
2

sen

π(x + ct)
L

= f (x − ct) + f (x + ct)

onde

f (x) =

1
2

sen

πx
L

2.3 Propagação de Ondas em Meios com Diversas Ca-

madas

Nas seções anteriores, abordamos a equação da onda considerando a propagação com

uma velocidade c constante. Porém, em problemas práticos, essa velocidade pode não

ser constante. A velocidade pode variar de acordo com a posição em que a onda se

encontra. Isso ocorre porque a velocidade de propagação da onda depende de carac-

terísticas físicas do meio. Segundo [LANGTANGEN e LINGE, 2016, p.160]: “Quando

o meio difere em propriedades físicas como densidade ou porosidade, a velocidade de

onda c é afetada e dependerá da posição no espaço.”

Quando as ondas se propagam através da fronteira entre dois meios com proprieda-

des físicas diferentes, ocorrem os fenômenos de reﬂexão e refração. Através da reﬂexão,

uma parte da onda retorna em sentido contrário ao da onda inicial. Já a refração faz

com que outra parte da onda prossiga no sentido original. Esses fenômenos possibili-

tam que seja realizado o imageamento sísmico, com a ﬁnalidade de obter informações

a respeito da formação geológica em subsuperfície.

“O imageamento sísmico se faz, basicamente, com a propagação de on-

das através das camadas geológicas no interior da Terra. Essas ondas ao

encontrarem a superfície de separação de dois meios cujas impedâncias

28

acústicas são diferentes, sofrem reﬂexões e refrações. As reﬂexões nas ca-

madas geológicas são registradas na superfície, esse registro (sismograma)

será o principal dado de entrada para a etapa do processamento sísmico.”

[MARTINS et al., 2007, p.1]

Apresentaremos a seguir um exemplo da equação da onda em um meio com diversas

camadas.

Exemplo 2.10. Considere que uma onda se desloca em um meio com diversas camadas.

Vamos considerar apenas uma dimensão espacial, assim vamos considerar que a onda

estará sobre uma reta de comprimento L. A função u(x, t) irá representar a intensidade

desta onda na posição x e no instante de tempo t. A variável x irá pertencer ao

intervalo [0, L]. Vamos considerar o tempo entre os instantes 0 e T , assim a variável t

irá pertencer ao intervalo [0, T ].

Vamos considerar que a função q(x) = c2(x) fornece o quadrado da velocidade de

propagação da onda, em função da posição x. A equação da onda passa a ser escrita

da seguinte forma

∂2u(x, t)
∂t2

=

∂
∂x

(cid:18)

q(x)

∂u(x, t)
∂x

(cid:19)

.

(2.17)

Essa forma da equação da onda é mais geral do que aquela apresentada através

da equação (2.1). Naquela equação, consideramos que a função q(x) = c2 era uma

constante.

Esta forma da equação da onda encontra-sem em [LANGTANGEN e LINGE, 2016,

p. 160]. Segundo o autor: “Esta é a forma mais frequente da equação do onda com

velocidade variável”.

29

Capítulo 3

Aproximações por Diferenças Finitas

3.1 Fórmulas Para Aproximação da Derivada de uma

Função

Neste capítulo, falaremos sobre as aproximações por diferenças ﬁnitas. Além de serem

usadas em métodos numéricos para solucionar equações diferenciais, essas aproximações

permitem calcular aproximações da derivada de uma função.

“Embora todos nos lembremos, do Cálculo, como estimar analiticamente

derivadas de uma função f (x), há razões para fazer isso numericamente.

Uma delas é que pode ser necessário derivar funções muito complicadas

e o processo para obtê-las manualmente pode estar sujeito a erros. Ou-

tra razão é que a função f (x) pode não ser conhecida explicitamente.”

[ASCHER e GREIF, 2011, p.409]

Temos que a derivada de uma função f em um ponto x0 é dada por:

f (cid:48)(x0) = lim
h→0

f (x0 + h) − f (x0)
h

.

(3.1)

30

Figura 3.1: Valores usados na Fórmula de Diferenças Centradas

Uma escolha natural para aproximar f (cid:48)(x0) seria usar a fórmula deﬁnida a seguir:

Deﬁnição 3.1 (Fórmula de Diferenças Progressivas). Suponha que são conhecidos os

valores da função f (x) nos pontos x0 e x0 + h, com h > 0. A fórmula de diferenças

progressivas é deﬁnida como

D+f (x0) =

f (x0 + h) − f (x0)
h

.

(3.2)

Esta fórmula utiliza os valores mostrados na ﬁgura 3.1. Intiuitivamente, podemos

pensar que o quociente entre (f (x0 + h) − f (x0)) e h se aproxima da derivada f (cid:48)(x0), à

medida que h se aproxima de zero, pois no limite este quociente é a própria derivada.

A equação (3.2) pode ser utilizada para realizar uma aproximação de f (cid:48)(x0) baseada

em pontos x tais que x ≥ x0, por isso é chamada de aproximação lateral. Outro tipo

de aproximação lateral seria:

Deﬁnição 3.2 (Fórmula de Diferenças Regressivas). Suponha que são conhecidos os

31

x0xyx0+hf(x0+h)f(x0 )y=f(x )hf(x0+h) - f(x0 )valores da função f (x) nos pontos x0 e x0 − h, com h > 0. A fórmula de diferenças

regressivas é deﬁnida como

D−f (x0) =

f (x0) − f (x0 − h)
h

,

(3.3)

nesse caso a aproximação é realizada utilizando pontos tais que x ≤ x0.

As duas fórmulas acima são aproximações da derivada da função f (x), uma pelo

lado direito e outra pelo lado esquerdo. Se calcularmos a média das duas fórmulas

anteriores, obteremos uma nova fórmula:

Deﬁnição 3.3 (Fórmula de Diferenças Centradas). Suponha que são conhecidos os

valores da função f (x) nos pontos x0 + h e x0 − h, com h > 0. A fórmula de

diferenças centradas é deﬁnida como

D0f (x0) =

f (x0 + h) − f (x0 − h)
2h

=

1
2

(D+f (x0) + D−f (x0)).

(3.4)

3.2 Erro de Aproximação

Segundo [LEVEQUE, 2007, p.5], a abordagem padrão para analisar o erro na aproxi-

mação da derivada de uma função em um ponto, por diferenças ﬁnitas, é realizar a

expansão da função em torno desse ponto através da série de Taylor. A série de Taylor

é uma série de potências que permite calcular um valor aproximado de uma função em

determinado ponto.

Apresentaremos a seguir o teorema que será fundamental para a nossa análise:

Teorema 3.1 (Teorema de Taylor). Suponha que f ∈ C n[a, b], que f (n+1) exista em

[a, b] e que x0 ∈ [a, b]. Para todo x ∈ [a, b], existe um número ξ(x) entre x0 e x com

f (x) = Pn(x) + Rn(x),

32

onde

e

Pn(x) = f (x0) + f (cid:48)(x0)(x − x0) +

=

n
(cid:88)

k=0

f (k)(x0)
k!

(x − x0)k

f (cid:48)(cid:48)(x0)
2!

(x − x0)2 + ... +

f (n)(x0)
n!

(x − x0)n

Rn(x) =

f (n+1)(ξ(x))
(n + 1)!

(x − x0)n+1

Este teorema nos fornece uma fórmula para calcular o valor de f (x), composta pela

soma das funções Pn(x) e Rn(x). A parcela Pn(x) é um polinômio construído utilizando

potências de (x − x0). Já a parcela Rn(x) é denominada resto de ordem n e nos

permite estimar o erro na aproximação de f (x) pelo polinômio Pn(x). A demonstração

do teorema 3.1 pode ser encontrada em [THOMAS, WEIR e HASS, 2012, p.61].

Exemplo 3.1. Sabemos que sen (0) = 0 e queremos calcular um valor aproximado para

sen ( π

100). Podemos aplicar o teorema 3.1, considerando x0 = 0, x = π

100 e f (x) = sen x.

Assim:

sen

(cid:17)

(cid:16) π
100

= P2

(cid:17)

(cid:16) π
100

+ R2

(cid:17)

(cid:16) π
100
(cid:16) π
100
(cid:17)3

,

= sen (0) + cos (0)

=

π
100

−

cos ξ
6

(cid:16) π
100

(cid:17)

−

sen (0)
2

(cid:16) π
100

(cid:17)2

−

cos (ξ)
6

(cid:16) π
100

(cid:17)3

para algum ξ entre 0 e π

100. Como | cos (ξ)| ≤ 1, temos um limite para o módulo da

última parcela:

(cid:12)
(cid:12)
(cid:12)
(cid:12)

cos (ξ)
6

(cid:16) π
100

(cid:17)3(cid:12)
(cid:12)
(cid:12)
(cid:12)

≤

(cid:17)3

1
6

(cid:16) π
100

Portanto, podemos considerar que π

cometendo um erro de aproximação de no máximo 1
6

100 é uma aproximação para sen ( π
(cid:0) π
100

(cid:1)3.

100) e estamos

Vamos em seguida apresentar uma deﬁnição que nos ajudará a comparar os erros

cometidos em aproximações por diferenças ﬁnitas utilizando diferentes fórmulas:

33

Deﬁnição 3.4 (Notação O Grande). Suponha que limh→0 G(h) = 0 e limh→0 F (h) = L.

Se existir uma constante positiva K tal que |F (h) − L| ≤ K|G(h)|, para h suﬁciente-

mente pequeno, então escrevemos F (h) = L + O(G(h)).

Exemplo 3.2. Por exemplo, utilizando o teorema 3.1 aplicado à função f (h) = sen h,

teremos

sen (h) = sen (0) + cos (0)h −

sen (0)
2

h2 −

cos (ξ)
6

h3,

para algum ξ entre 0 e h. Donde segue que

sen (h) = h −

cos (ξ)
6

h3 ⇒ | sen (h) − h| ≤

(cid:12)h3(cid:12)
(cid:12)
(cid:12) ,

1
6

e portanto sen (h) = h + O(h3). Ou seja, ao aproximarmos o valor da função sen (h)

utilizando o valor h, estamos cometendo um erro da ordem de h3.

Agora estamos em condições de estimar os erros cometidos nas aproximações usando

as fórmulas (3.2), (3.3), (3.4). Utilizando o teorema 3.1 concluímos que

f (x0 + h) = f (x0) + f (cid:48)(x0)h +

f (cid:48)(cid:48)(x0)
2

h2 +

f (cid:48)(cid:48)(cid:48)(x0)
6

h3 + O(h4),

(3.5)

passando f (x0) para o lado esquerdo e dividindo a equação por h, ﬁcamos com

f (x0 + h) − f (x0)
h

= f (cid:48)(x0) +

f (cid:48)(cid:48)(x0)
2

h +

f (cid:48)(cid:48)(cid:48)(x0)
6

h2 + O(h3).

O termo à esquerda na equação acima é D+f (x0), e concluímos que

D+f (x0) − f (cid:48)(x0) =

f (cid:48)(cid:48)(x0)
2

h +

f (cid:48)(cid:48)(cid:48)(x0)
6

h2 + O(h3).

Esse é o erro cometido na aproximação por diferenças ﬁnitas utilizando a fórmula

de diferenças progressivas. Para h suﬁcientemente pequeno, o erro será representado

principalmente pela parcela f (cid:48)(cid:48)(x0)

2 h, sendo que as demais parcelas serão desprezíveis

em relação à primeira, por se tratarem de potências em h maiores do que um. Assim

34

podemos concluir que o erro cometido na aproximação da derivada utilizando D+f (x0)

será da ordem de h.

Observe que o erro foi obtido comparando a fórmula de diferenças ﬁnitas com o

desenvolvimento da função em série de Taylor. O erro corresponde aos termos da

série que foram desprezados, ou seja, truncados. Dessa forma, o erro que calculamos

denomina-se erro de truncamento. Segundo [BURDEN et al., 2017, p. 9]: “O termo

erro de truncamento no polinômio de Taylor refere-se ao erro envolvido na utilização

de uma adição truncada ou ﬁnita para aproximar a soma de uma séria inﬁnita”.

Utilizando novamente o teorema 3.1 temos que

f (x0 − h) = f (x0) − f (cid:48)(x0)h +

f (cid:48)(cid:48)(x0)
2

h2 −

f (cid:48)(cid:48)(cid:48)(x0)
6

h3 + O(h4)

(3.6)

e concluímos, de forma análoga, que o erro de truncamento para D−f (x0) é

D−f (x0) − f (cid:48)(x0) = −

f (cid:48)(cid:48)(x0)
2

h +

f (cid:48)(cid:48)(cid:48)(x0)
6

h2 + O(h3).

Assim o erro cometido na aproximação por D−f (x0) também é da ordem de h.

Combinando as equações (3.5) e (3.6) concluímos que

f (x0 + h) − f (x0 − h) = 2f (cid:48)(x0)h +

f (cid:48)(cid:48)(cid:48)(x0)
3

h3 + O(h4)

e daí temos que

D0f (x0) − f (cid:48)(x0) =

f (cid:48)(cid:48)(cid:48)(x0)
6

h2 + O(h3),

portanto o erro cometido na aproximação da derivada primeira dado por D0f (x0) é da

ordem de h2.

3.3 Método dos Coeﬁcientes Indeterminados

Nesta seção, veremos como determinar os coeﬁcientes para uma fórmula de diferenças

ﬁnitas. Para isso podemos usar o método dos coeﬁcientes indeterminados.

35

Exemplo 3.3. Suponha que queremos uma fórmula para aproximar a derivada f (cid:48)(x)

utilizando os valores da função nos pontos x0, x0 + h e x0 + 2h. Ou seja, temos os

valores de f (x0), f (x0 − h) e f (x0 − 2h). Vamos chamar essa aproximação de D2f (x0).

Então precisamos calcular os coeﬁcientes a, b e c de forma que

D2f (x0) = af (x0) + bf (x0 − h) + cf (x0 − 2h).

Na equação acima, podemos substituir os valores de f (x0 − h) e f (x0 − 2h) por

aqueles determinados nas equações (3.6) e (??). Ficamos com a seguinte expressão

D2f (x0) = af (x0) + b

(cid:20)

f (x0) − f (cid:48)(x0)h +

f (cid:48)(cid:48)(x0)
2

h2 −

f (cid:48)(cid:48)(cid:48)(x0)
6

h3 + O(h4)

(cid:21)

+

(cid:20)

c

f (x0) − f (cid:48)(x0)2h +

f (cid:48)(cid:48)(x0)
2

(2h)2 −

f (cid:48)(cid:48)(cid:48)(x0)
6

(2h)3 + O(h4)

(cid:21)

,

que nos leva a

D2f (x0) = (a + b + c)f (x0) − (b + 2c)hf (cid:48)(x0)+

1
2

(b + 4c)h2f (cid:48)(cid:48)(x0) −

1
6

(b + 8c)h3f (cid:48)(cid:48)(cid:48)(x0) + (b + c)O(h4),

Nosso objetivo é que D2f (x0) concorde com a derivada f (cid:48)(x0) para os termos mais

signiﬁcativos. Então precisamos que:






a + b + c = 0,

b + 2c

= −

1
h

,

b + 4c

= 0.

Resolvendo o sistema encontramos os valores dos coeﬁcientes:

a =

3
2h

,

b = −

2
h

, c =

1
2h

.

Portanto a fórmula será

D2f (x0) =

1
2h

[3f (x0) − 4f (x0 − h) + f (x0 − 2h)] .

36

Vamos apresentar mais um exemplo do método aﬁm de obtermos uma fórmula para

calcular um valor aproximado para a derivada segunda de uma função.

Exemplo 3.4. Suponha que estamos buscando uma fórmula para aproximar f (cid:48)(cid:48)(x0).

Chamaremos essa aproximação de D2f (x0). Vamos deduzir uma fórmula usando os

valores da função nos pontos x0 − h, x0 e x0 + h. Teremos a expressão

D2f (x0) = af (x0 − h) + bf (x0) + cf (x0 + h).

Utilizando as equações (3.5) e (3.6), concluímos que

D2f (x0) = a

(cid:20)
f (x0) − f (cid:48)(x0)h +

(cid:20)
f (x0) + f (cid:48)(x0)h +

c

que nos leva a

f (cid:48)(cid:48)(x0)
2
f (cid:48)(cid:48)(x0)
2

h2 −

h2 +

f (cid:48)(cid:48)(cid:48)(x0)
6
f (cid:48)(cid:48)(cid:48)(x0)
6

(cid:21)
h3 + O(h4)

+ bf (x0)+

(cid:21)
h3 + O(h4)

,

D2f (x0) = (a + b + c)f (x0) + (−a + c)hf (cid:48)(x0)+

(a + c)

h2
2

f (cid:48)(cid:48)(x0) + (−a + c)

h3
6

f (cid:48)(cid:48)(cid:48)(x0) + (a + c)O(h4).

(3.7)

Para que D2f (x0) concorde com a derivada f (cid:48)(cid:48)(x0) para os termos mais signiﬁcati-

vos, precisamos que






a + b + c = 0,

−a + c

= 0,

a + c

=

2
h2 .

Resolvendo o sistema encontramos os valores dos coeﬁcientes:

a =

1
h2 ,

b = −

2
h2 , c =

1
h2 ,

portanto podemos deﬁnir a seguinte fórmula:

Deﬁnição 3.5 (Fórmula de diferenças centradas para derivada segunda).

D2f (x0) =

1
h2 [f (x0 − h) − 2f (x0) + f (x0 + h)]

(3.8)

37

Como última observação sobre a fórmula acima, equação (3.8), que será usada no

capítulo 4, ela nos fornece uma aproximação para segunda derivada da ordem de h2.

Com efeito, observe que o último termo da equação (3.7) é (a + c)O(h4), porém como

a + c = 2

h2 , teremos que o termo anterior é portanto da ordem de h2.

3.4 Problemas de Valor Inicial

Nesta seção, veremos alguns métodos numéricos utilizados para encontrar soluções

aproximadas para problemas de valor inicial. Os métodos que serão apresentados nos

permitirão calcular as aproximações de uma função em um conjunto discreto de pontos.

“Os métodos (...) não produzem uma aproximação contínua para a so-

lução do problema de valor inicial. Em vez disso, as aproximações são

encontradas em determinados pontos especiﬁcados e, muitas vezes, igual-

mente espaçados.” [BURDEN et al., 2017, p.284]

A solução aproximada será composta por um número ﬁnito de valores.

“O propósito de um método numérico é formular um problema discreto

correspondente cuja solução é caracterizada por um número ﬁnito de va-

lores, que podem ser computados em um número ﬁnito de passos em um

computador.” [LANGTANGEN, 2016, p.3]

Suponha que temos um problema de valor inicial composto por uma equação dife-

rencial da forma

acompanhada da condição inicial

u(cid:48)(t) = f (u(t), t),

u(t0) = η.

38

(3.9)

(3.10)

Frequentemente iremos utilizar t0 = 0 por simplicidade. Na seção anterior, vimos

como calcular o valor aproximado da derivada de uma função em determinado ponto.

Vimos algumas fórmulas que permitem calcular o valor aproximado dessa derivada,

como nas equações (3.2), (3.3) e (3.4). A ideia é usarmos fórmulas de diferenças ﬁnitas

como essas para achar o valor da função em um conjunto de pontos.

Suponha que queremos achar os valores aproximados de u(t) para t ∈ [0, T ]. Ini-

cialmente dividimos o intervalo em N partes iguais. Digamos que cada parte tem o

comprimento k, doravante dito o tamanho do passo de tempo.

Assim, o nosso intervalo [0, T ] terá os pontos 0, k, 2k, ..., N k = T . Chamaremos

cada um desses pontos de tn, assim teremos t0 = 0, t1 = k, t2 = 2k , ..., tN = N k.

Genericamente teremos tn = nk. Vamos tentar calcular os valores aproximados de u(tn)

para n = 1, 2, . . . , N . Chamaremos de U n ao valor aproximado do valor da função u(t)

no ponto tn, assim, temos

U n ≈ u(tn).

Para o valor referente ao primeiro ponto, atribuímos o valor da condição inicial.

Assim, consideramos que U 0 = η. Para calcular os demais valores, ou seja, U 1, U 2,

etc., utilizaremos alguma fórmula de diferenças ﬁnitas. Por exemplo, usando a fórmula

D+f (tn), equação (3.2), temos que

D+f (tn) =

u(tn + k) − u(tn)
k

=

u(tn+1) − u(tn)
k

,

que é uma aproximação para u(cid:48)(tn). Mas, da equação (3.9), temos que u(cid:48)(tn) =

f (u(tn), tn). Assim podemos deﬁnir:

Deﬁnição 3.6. (Método de Euler Progressivo)

Suponha que temos um problema de valor inicial composto por uma equação di-

ferencial, equação (3.9), acompanhada de uma condição inicial, equação (3.10). O

39

Método de Euler Progressivo (ou simplesmente Método de Euler) consiste em

utilizar a fórmula

ou, de forma equivalente:

f (U n, tn) =

U n+1 − U n
k

U n+1 = U n + kf (U n, tn)

para calcular aproximações da solução do problema.

(3.11)

(3.12)

Exemplo 3.5. Encontrar soluções aproximadas para o problema composto pela equa-

ção diferencial

com a condição inicial

u(cid:48)(t) = u(t) cos t,

(3.13)

u(0) = 1.

Devido à condição inicial, temos que U 0 = 1. Para calcular a aproximação no

próximo ponto, utilizamos a equação (3.12):

U 1 = U 0 + kf (U 0, t0) = 1 + k(cos 1),

e prosseguimos calculando:

U 2 = U 1 + k(U 1 cos (t1)).

E assim calculamos U 1, U 2, etc., até chegarmos a U N , obtendo valores aproximados

da função em um conjunto de pontos.

Podemos utilizar uma linguagem de programação para resolver o problema acima.

Incluímos no Apêndice C um exemplo de código na linguagem de programação Python.

É o exemplo C.1. Nesse exemplo, consideramos u(t) ∈ [0, 8π] e o tamanho de passo

k = 0.001. Podemos visualizar o resultado na ﬁgura 3.2.

40

Figura 3.2: Solução pelo método de Euler Progressivo

3.5 Existência e Unicidade

Ao tentarmos resolver um problema de valor inicial numericamente, será importante ve-

riﬁcar se o problema possui solução e se essa solução é única. Segundo [LEVEQUE, 2007,

p.116], há sempre solução única para EDO’s lineares, porém estaremos interessados

muitas vezes em problemas não-lineares, para os quais, em muitos casos, não haverá

nem mesmo uma fórmula explícita para a solução. O autor aﬁrma ainda que: “Para

garantir que existe uma solução única, é necessário exigir uma certa quantidade de

suavidade na função f (u, t)”. Essa suavidade será fornecida pela condição deﬁnida a

seguir:

Deﬁnição 3.7 (Condição de Lipschitz). Uma função f (u, t) satisfaz uma condição

de Lipschitz na variável u em um conjunto D ⊂ R2 se existir uma constante L > 0

41

05101520250.51.01.52.02.5Solução aproximada para: u'(t) = u(t) cos ttal que

|f (u, t) − f (u∗, t)| ≤ L|u − u∗|

sempre que (u, t) e (u∗, t) estiverem em D. A constante L é chamada de constante

de Lipschitz para f .

Exemplo 3.6. No caso da função

f (u, t) = u cos t

temos que

|f (u, t) − f (u∗, t)| = |u cos t − u∗ cos t| = | cos t||u − u∗| ≤ |u − u∗|

uma vez que | cos t| ≤ 1. Assim podemos dizer que a função f (u, t) = u cos t satisfaz

uma condição de Lipschitz na variável u, no conjunto D = R2, com constante de

Lipschitz igual a 1.

A seguir, apresentamos um teorema que poderá ser usado para veriﬁcar se deter-

minado problema de valor inicial tem solução única. Segundo [BURDEN et al., 2017,

p.286], este teorema “é uma versão do teorema fundamental de existência e unicidade

para equações diferenciais ordinárias de primeira ordem”.

Teorema 3.2. Suponha que D = {(u, t) | −∞ < u < ∞ e t0 ≤ t ≤ t1} e que f(u,t) seja

contínua em D. Se f satisﬁzer uma condição de Lipschitz em D na variável u, então o

problema de valor inicial

u(cid:48)(t) = f (u(t), t), t0 ≤ t ≤ t1 e u(t0) = η

tem uma única solução u(t) para t0 ≤ t ≤ t1.

Segundo [BURDEN et al., 2017, p.286], “a demonstração do teorema, aproxima-

damente nesta forma, pode ser encontrada em [apud BIRKHOFF e ROTA, 1989, p.

142-155.]”

42

Exemplo 3.7. Vimos que a função f (u, t) = u cos t satisfaz uma condição de Lipschitz

na variável u, no conjunto D = R2. Assim, de acordo com o teorema 3.2, o problema

de valor inicial

u(cid:48)(t) = u cos t, 0 ≤ t ≤ t1 e u(0) = 1

tem uma única solução u(t) para 0 ≤ t ≤ t1.

3.6 Métodos para Problemas de Valor Inicial

Há vários métodos para encontrar soluções aproximadas para problemas de valor ini-

cial. Cada um desses métodos pode ter diferentes propriedades que os tornam mais

adequados para determinados tipos de problemas. Estudaremos a seguir algumas des-

sas propriedades. Já apresentamos o método de Euler Progressivo, através da Deﬁnição

3.6.

“O método de Euler, que é também conhecido como o método de Eu-

ler progressivo (para distingui-lo do método de Euler regressivo, a ser

discutido posteriormente), é o método numérico mais simples para resol-

ver, aproximadamente, EDO’s de valor inicial.”[ASCHER e GREIF, 2011,

p.485]

Se utilizarmos a fórmula de diferenças regressivas, equação (3.3), podemos deﬁnir

o seguinte método:

Deﬁnição 3.8 (Método de Euler Regressivo). Suponha que temos um problema de

valor inicial composto por uma equação diferencial da forma 3.9 acompanhada de uma

condição inicial da forma 3.10. O Método de Euler Regressivo consiste em utilizar

a fórmula

f (U n+1, tn+1) =

U n+1 − U n
k

43

(3.14)

ou, de forma equivalente:

U n+1 = U n + kf (U n+1, tn+1)

(3.15)

para calcular aproximações da solução do problema.

No método de Euler progressivo, a aproximação U n+1 é calculada utilizando a apro-

ximação U n, calculada no passo anterior. Métodos desse tipo, que calculam a apro-

ximação atual utilizando somente aproximações dos passos anteriores, são chamados

métodos explícitos.

Deﬁnição 3.9 (Método Explícito). Um método numérico para aproximar soluções de

problemas de valor inicial em que cada aproximação é calculada utilizando somente

aproximações calculadas nos passos anteriores é chamado método explícito.

Já no método de Euler regressivo, a aproximação U n+1 é calculada baseada em

uma expressão que inclui a própria aproximação U n+1, pois a cada passo do método

calculamos U n+1 = U n + kf (U n+1, tn+1). A cada passo será necessário resolver uma

equação envolvendo a incógnita U n+1. Métodos desse tipo são chamados métodos

implícitos.

Deﬁnição 3.10 (Método Implícito). Um método numérico para aproximar soluções

de problemas de valor inicial em que cada aproximação é calculada através de uma

fórmula que envolve o próprio valor dessa aproximação é chamado método implícito.

Apesar da aparente desvantagem dos métodos implícitos, devido à necessidade de

resolver uma equação a cada passo do método, que pode ser inclusive não-linear, ve-

remos que eles apresentam uma vantagem em questões de estabilidade. Conceito que

veremos adiante.

44

“Então, métodos implícitos são mais custosos do que explícitos, uma vez

que, se a função f em 3.9 não é linear, a cada passo no tempo tn+1 precisa-

remos resolver um problema não-linear para computar un+1. De qualquer

forma, veremos que métodos implícitos apresentam melhores propriedades

de estabilidade do que os explícitos”

[QUARTERONI, SALERI e GERVASIO, 2014, p. 276].

Calculando a média dos métodos de Euler progressivo e regressivo, obtemos o mé-

todo trapezoidal:

Deﬁnição 3.11 (Método Trapezoidal). O Método Trapezoidal consiste em utilizar

a fórmula

1
2

(f (U n, tn) + f (U n+1, tn+1)) =

U n+1 − U n
k

ou, de forma equivalente:

U n+1 = U n +

k
2

(f (U n, tn) + f (U n+1, tn+1))

(3.16)

para calcular aproximações da solução do problema.

O método trapezoidal também é um método implícito, pois utiliza o próprio valor da

aproximação U n+1 no seu cálculo. Usando a fórmula de diferenças centradas, equação

(3.4), obtemos o método do ponto médio:

Deﬁnição 3.12 (Método do Ponto Médio). O Método do Ponto Médio consiste

em utilizar a fórmula

ou, de forma equivalente:

f (U n, tn) =

U n+1 − U n−1
2k

U n+1 = U n−1 + 2kf (U n, tn)

para calcular aproximações da solução do problema.

45

(3.17)

(3.18)

O método do ponto médio também é um método explícito, uma vez que só utiliza

as aproximações dos passos anteriores para calcular a aproximação do passo atual.

Os métodos de Euler progressivo e regressivo utilizam apenas as aproximações de

um passo anterior para calcular a aproximação no passo atual. Métodos desse tipo são

chamados métodos de passo simples.

Deﬁnição 3.13 (Método de Passo Simples). Um método numérico para aproximar

soluções de problemas de valor inicial em que cada aproximação é calculada utilizando

somente a aproximação calculada no passo anterior é chamado método de passo

simples.

Já o método do ponto médio utiliza as aproximações U n e U n−1 para calcular a

aproximação U n+1. Métodos desse tipo são chamados métodos de passo múltiplo.

Deﬁnição 3.14 (Método de Passo Múltiplo). Um método numérico para aproximar

soluções de problemas de valor inicial em que cada aproximação é calculada utilizando

aproximações calculadas em mais de um passo anterior é chamado método de passo

múltiplo.

Uma forma de melhorar a acurácia das aproximações é utilizar métodos multies-

tágio. Veremos mais adiante como estimar a acurácia dos métodos.

Deﬁnição 3.15 (Métodos Multiestágio). São métodos numéricos para aproximação de

soluções de problemas de valor inicial em que a aproximação em cada ponto é calculada

a partir da aproximação no ponto anterior em várias etapas (estágios).

Como exemplo da deﬁnição acima, podemos citar o seguinte método:

46

Exemplo 3.8. Um método de Runge-Kutta explícito de dois estágios1 para um pro-

blema autônomo 2 é dado pela fórmula

U ∗ = U n +

1
2

kf (U n),

U n+1 = U n + kf (U ∗).

(3.19)

No primeiro estágio, calculamos U ∗, que é uma aproximação da função u(t) pelo

método de Euler progressivo no ponto tn + 1

2k, ou seja, no ponto médio entre tn e tn+1.

No segundo estágio, calculamos f (U ∗), que será um valor aproximado da inclinação da

função u(t) no ponto médio do intervalo entre tn e tn+1, e utilizamos esse valor para

calcular U n+1.

O método da equação (3.19) pode ser estendido a problemas não-autônomos, da

forma u(cid:48)(t) = f (u(t), t), ﬁcando com a seguinte fórmula:

U ∗ = U n +

1
2

kf (U n, tn),

U n+1 = U n + kf

(cid:16)

U ∗, tn+ 1

2

(cid:17)

,

onde introduzimos a notação tn+ 1

2

para designar o instante de tempo tn +

(3.20)

k
2

, ou seja,

1Esse método é também conhecido como método do ponto médio, como é apresentado em

[BURDEN et al., 2017, p. 313]. Porém estamos chamando de método do ponto médio o método

da equação 3.18. Essa nomenclatura é usada em [LEVEQUE, 2007]. Assim iremos nos referir ao

método da equação (3.19) somente como um método de Runge-Kutta de dois estágios.

2Problemas autônomos são aqueles em que a variável independente não aparece explicitamente na

equação diferencial. Nesse caso, a equação diferencial possui a forma

No caso dos problemas não-autônomos, a equação diferencial possui a forma

dy
dt

= f (y).

dy
dt

= f (y, t).

47

tn+ 1

= tn +

k
2
Por exemplo:

2

. Há outros métodos de Runge-Kutta com um número maior de estágios.

Exemplo 3.9. O método descrito pela equação a seguir é um método de Runge-Kutta

de quatro estágios:

Y1 = U n,

Y2 = U n +

Y3 = U n +

1
2
1
2

Y4 = U n + kf

(cid:16)

kf (Y1, tn),

(cid:16)

kf

Y2, tn+ 1
2
(cid:17)

Y3, tn+ 1

2

(cid:17)

,

,

(3.21)

U n+1 = U n +

(cid:104)
f (Y1, tn) + 2f

(cid:16)

Y2, tn+ 1

2

(cid:17)

+ 2f

(cid:16)

(cid:17)

Y3, tn+ 1

2

+ f (Y4, tn+1)

(cid:105)

.

k
6

3.7 Sistemas de Equações Diferenciais

Vimos como aplicar o método de Euler progressivo para uma EDO (Equação Diferencial

Ordinária) escalar, ou seja, que envolve uma função que representa um único valor.

Mas em geral esse problema pode ser composto de um sistema de equações diferenciais

acompanhado de condições iniciais. Na verdade, esse é o tipo de problema mais comum.

Segundo [ASCHER e GREIF, 2011, p.482]: “Nós devemos notar que as EDO’s escalares

raramente aparecem na prática. As EDO’s quase sempre surgem como sistemas, e esses

sistemas às vezes podem ser grandes.”.

Deﬁnição 3.16. Um sistema de ordem m de problemas de valor inicial de primeira

48

ordem tem a forma

du1
dt
du2
dt

...
dum
dt

= f1(t, u1, u2, ..., un),

= f2(t, u1, u2, ..., un),

= fm(t, u1, u2, ..., un),

(3.22)

para a ≤ t ≤ b, com as condições iniciais

u1(t0) = α1, u2(t0) = α2, ... , um(t0) = αm.

(3.23)

No caso de um sistema linear, teremos






u(cid:48)
1(t) = a11u1(t) + a12u2(t) + . . . + a1mum(t),

u(cid:48)
2(t) = a21u1(t) + a22u2(t) + . . . + a2mum(t),
...

u(cid:48)
n(t) = am1u1(t) + am2u2(t) + . . . + ammum(t).

(3.24)

Se considerarmos o vetor

u(t) =












u1(t)

u2(t)
...

um(t)












,

então teremos o seguinte problema de valor inicial:

u(cid:48)(t) = Au(t),

(3.25)

onde A é a matriz












A =

a12

. . . a1m

a22

. . . a2m

a11

a21
...

am1 am2

. . . amm












,

49

com a condição inicial

onde

u(t0) = α,

α =












.












α1

α2
...

αm

De forma equivalente ao caso escalar, podemos calcular um conjunto de pontos U 1,

U 2, ..., U n, onde esses pontos são vetores da forma

sendo que

U n =












,












U n
1

U n
2
...

U n
m

U n ≈ u(tn) =












u1(tn)

u2(tn)
...

um(tn)












,

utilizando alguma fórmula para solução numérica de equações diferenciais ordinárias.

Por exemplo, se utilizarmos o método de Euler progressivo, teremos a fórmula:

U n+1 = U n + kAU n,

ou se usarmos o método do Ponto Médio, teremos a fórmula:

U n+1 = U n−1 + 2kAU n.

A seguir apresentaremos um exemplo de sistema de equações diferenciais. Este

exemplo encontra-se em [LEON, 2011, p.277].

50

Exemplo 3.10. Dois tanques estão conectados como mostra a ﬁgura 3.3.

Figura 3.3: Tanques interconectados

Inicialmente o tanque A contém 200 litros de água na qual foram dissolvidos 60

gramas de sal e o tanque B contém 200 litros de água pura. O líquido é bombeado

para dentro e para fora dos tanques nas taxas mostradas no diagrama. O problema

consiste em determinar a quantidade de sal em cada tanque no tempo t.

Sejam u1(t) e u2(t) as quantidades de gramas de sal nos tanques A e B, respecti-

vamente, no instante t. Inicialmente,

U (0) =











 =







 .

60

0

u1(0)

u2(0)

(3.26)

A quantidade total de líquido em cada tanque permanece 200 litros, já que a quan-

tidade bombeada para dentro é igual à bombeada para fora. A taxa de variação na

quantidade de sal em cada tanque é igual à taxa na qual ele está sendo adicionado

51

Água15 l/minMistura5 l/minMistura15 l/minMistura20 l/minTanque ATanque Bmenos a taxa na qual ele está sendo bombeado para fora.

Para o tanque A, estão sendo adicionados 5 litros de água por minuto. Cada litro

de água adicionado contém a quantidade total de sal do tanque B, u2(t), dividida pelo

volume do tanque B, 200 l. Ou seja, estão sendo adicionados

5u2(t)
200

=

u2(t)
40

g/min

de sal.

Já a quantidade de água que está sendo bombeada para fora do tanque A é de

20 l/min, sendo que cada litro contém a quantidade total de sal do tanque A, u1(t),

dividida por 200. Ou seja, a quantidade de sal que está sendo retirada do tanque A é

de

20u1(t)
200

=

u1(t)
10

g/min.

Assim, a taxa de variação da quantidade de sal no tanque A é de

u(cid:48)
1(t) =

u2(t)
40

−

u1(t)
10

.

De forma similar, veriﬁcamos que a taxa de variação da quantidade de sal no tanque

B é de

u(cid:48)
2(t) =

20u1(t)
200

−

20u2(t)
200

=

u1(t)
10

−

u2(t)
10

.

Assim, ﬁcamos com o seguinte sistema de equações diferenciais:




10u1(t) + 1
10u1(t) − 1
que pode ser representado de forma matricial por

1(t) = − 1
u(cid:48)

2(t) = 1
u(cid:48)



40u2(t),

10u2(t),

U (cid:48)(t) = AU (t)

(3.27)

(3.28)

onde A é a matriz



− 1
10

1
40

A =







 .

10 − 1
A equação (5.27), acompanhada da condição inicial na equação (3.26), constitui

10

1

um problema de valor inicial. Podemos aplicar algum dos métodos estudados para

resolvê-lo.

52

Figura 3.4: Solução numérica do problema do exemplo 3.10 pelo método Trapezoidal.

No exemplo C.2 apresentamos o código de programação contendo um conjunto de

métodos numéricos para solução numérica de sistemas de equações diferenciais ordiná-

rias.

No exemplo C.4, apresentamos o código de programação utilizando o método Tra-

pezoidal para resolver este problema numericamente. Na ﬁgura 3.4, apresentamos um

gráﬁco obtido através desse programa. O gráﬁco contém duas curvas, uma corresponde

à quantidade de sal no primeiro tanque e a outra à quantidade no segundo.

O método de Euler progressivo, e outros métodos numéricos para solução de pro-

blemas de valor inicial, se aplicam a problemas envolvendo equações diferenciais de

primeira ordem. Mas, na verdade, estamos considerando uma classe de problemas

mais gerais, pois equações diferenciais de ordem mais alta podem ser reduzidas a um

sistema de equações de primeira ordem. Segundo [LANGTANGEN e LINGE, 2016,

p.32], “Uma técnica padrão para resolver EDO’s de segunda ordem é reescrevê-las

53

010203040500102030405060Solução Numérica pelo Método Trapezoidalcomo um sistema de EDO’s de primeira ordem, e então encontrar uma estratégia de

solução da vasta coleção de métodos para sistemas de EDO’s de primeira ordem.”

Exemplo 3.11. A equação (2.2), do movimento harmônico simples, pode ser escrita

da seguinte forma:

u(cid:48)(cid:48)(t) = −

k
m

u(t),

onde u(t) representa a posição do corpo que está preso à mola no instante t. Se

deﬁnirmos a função:

teremos que

E assim teremos o sistema:

v(t) = u(cid:48)(t),

v(cid:48)(t) = −

k
m

u(t).






u(cid:48)(t) = v(t),

v(cid:48)(t) = −

k
m

u(t),

que pode ser escrito da seguinte forma:






d
dt

u(t)

v(t)






 =







 ,

v(t)
k
m

u(t)

−

ou ainda













u(t)

0
k
m
E o problema ﬁca no formato da equação (3.25), assim podemos também calcular


 =

d
dt


 .

u(t)

v(t)

v(t)













−

0

1

uma solução numérica utilizando algum dos métodos estudados. No exemplo C.5,

apresentamos o código de programação utilizando o método do Ponto Médio para

resolver este problema numericamente. Na ﬁgura 3.5, apresentamos o gráﬁco obtido

através desse programa. O gráﬁco contém duas curvas. Uma delas corresponde à

54

Figura 3.5: Solução numérica do exemplo 3.11 pelo Método do Ponto Médio.

função u(t), que representa a posição da mola, e a outra corresponde à função v(t),

que representa a velocidade da mola.

De maneira análoga à que ﬁzemos para problemas de valor inicial contendo uma

única equação diferencial, podemos enunciar um teorema de existência e unicidade para

sistemas de equações diferenciais. Antes disso, vamos apresentar uma nova deﬁnição,

mais geral, para condição de Lipschitz:

Deﬁnição 3.17. A função f (t, y1, ..., ym), deﬁnida no conjunto

D = {(t, u1, ..., um) | a ≤ t ≤ b e − ∞ < ui < ∞, para cada i = 1, 2, ..., m},

satisfaz uma condição de Lipschitz em D nas variáveis u1, u2, ...,um se existir uma

constante L > 0 tal que

|f (t, u1, ..., um) − f (t, z1, ..., zm)| ≤ L

m
(cid:88)

j=1

|uj − zj|,

para todo (t, u1, ..., um) e (t, u1, ..., um) em D.

55

0246810121.000.750.500.250.000.250.500.751.00Solução Numérica pelo Método do Ponto MédioExemplo 3.12. No sistema de equações 3.27, a primeira equação pode ser escrita

como u(cid:48)

1(t) = f (t, u1, u2), onde

f (t, u1, u2) = −

1
10

u1(t) +

1
40

u2(t)

Se considerarmos o tempo variando no intervalo [0, 60], teremos a função f deﬁnida

no conjunto

D = {(t, u1, u2) | 0 ≤ t ≤ 60 e − ∞ < ui < ∞, para i = 1, 2}.

A função f deﬁnida acima satisfaz uma condição de Lipschitz em D nas variáveis

u1, u2, com a constante L = 1/10, pois
1
10

|f (t, u1, u2) − f (t, z1, z2)| =

−

u1(t) +

1
40

(cid:19)

(cid:18)

u2(t)

−

−

1
10

z1(t) +

1
40

z2(t)

(cid:19)(cid:12)
(cid:12)
(cid:12)
(cid:12)

1
10
1
10

−

(cid:18)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
1
10
1
10

−

=

≤

=

<

(u1 − z1) +

(u2 − z2)

1
40
(cid:12)
1
(cid:12)
(cid:12)
40
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(u2 − z2)

|u2 − z2|

+

(cid:12)
(cid:12)
(u1 − z1)
(cid:12)
(cid:12)
1
40

|u1 − z1| +

(|u1 − z1| + |u2 − z2|).

Podemos agora enunciar o teorema que estabelece condições suﬁcientes para a exis-

tência e unicidade da solução de sistemas de problemas de valor inicial.

Teorema 3.3. Considere D o conjunto

D = {(t, u1, ..., um) | a ≤ t ≤ b e − ∞ < ui < ∞, para cada i = 1, 2, ..., m},

Suponha que o sistema de equações diferenciais de primeira ordem (3.22), sujeito

às condições iniciais (3.23), possua cada função fi(t, u1, ..., um), para i = 1, 2, ..., m,

contínua em D e satisfazendo uma condição de Lipschitz em D. Então esse sistema

de problemas de valor inicial possui uma solução única u1(t), u2(t), ...,um(t).

Segundo [BURDEN et al., 2017, p.364], a demonstração deste teorema pode ser

encontrada em [apud BIRKHOFF e ROTA, 1989, p. 152-154].

56

Capítulo 4

Solução Numérica da Equação da

Onda

4.1 Discretização da Equação da Onda

Nesta seção, voltaremos nossa atenção para a equação da onda, que foi apresentada

através da equação (2.1). Vamos considerar, inicialmente, o problema de valor de

contorno e inicial apresentado no capítulo 2 (exemplo 2.8):

Exemplo 4.1. Consideramos que uma corda encontra-se esticada horizontalmente,

com as extremidades ﬁxas. A função u(x, t) representa o deslocamento vertical da

corda, na posição x e no instante t.

A função u(x, t) obedece à equação da onda:

∂2u(x, t)
∂t2

= c2 ∂2u(x, t)

∂x2

para x ∈ (0, L), t ∈ (0, T ]

(4.1)

Teremos as seguintes condições de contorno

u(0, t) = 0 para t ∈ (0, T ],

u(L, t) = 0 para t ∈ (0, T ].

57

(4.2)

E as condições iniciais:

e

u(x, 0) = f (x) para x ∈ [0, L].

∂u(x, 0)
∂t

= 0 para x ∈ [0, L].

(4.3)

(4.4)

O procedimento para calcularmos aproximações para a solução desse problema será

similar ao que ﬁzemos no capítulo anterior, para problemas de valor inicial. Estamos

trabalhando com um domínio contínuo e precisaremos trabalhar com um domínio dis-

creto. A diferença é que, no capítulo anterior, discretizamos apenas a variável de tempo

t. Para o problema em questão, precisaremos discretizar também a posição x.

Inicialmente dividimos o intervalo de tempo em N partes iguais. Digamos que cada

parte tem o comprimento k, que será o nosso tamanho de passo de tempo. Chamaremos

cada instante no tempo de tn, assim teremos t0 = 0, t1 = k, t2 = 2k, ..., tN = N k.

Genericamente teremos tn = nk.

Da mesma forma, dividiremos o intervalo espacial em M partes iguais. Essas partes

terão comprimento h, que será o nosso espaço de malha. Assim, teremos x0 = 0, x1 = h,

x2 = 2h, ..., xM = M h. Assim teremos xj = jh.

Nosso objetivo será calcular aproximações para a solução do problema, nos pontos

(xj, tn). Assim, iremos calcular os valores U n

j , tais que

U n

j ≈ u(xj, tn).

A primeira abordagem que iremos adotar é utilizar a fórmula de diferenças centradas

para derivada segunda, equação (3.8), para aproximar ambas as derivadas que aparecem

na equação (4.1).

Assim, vamos aproximar a derivada em relação à posição por

∂2u(x, t)

∂x2 ≈

u(x − h, t) − 2u(x, t) + u(x + h, t)
h2

,

58

e a derivada em relação ao tempo por

∂2u(x, t)
∂t2

≈

u(x, t − k) − 2u(x, t) + u(x, t + k)
k2

.

Portanto, vamos utilizar a seguinte equação para o método:

U n−1

j − 2U n
k2

j + U n+1
j

= c2 U n

j−1 − 2U n
h2

j + U n

j+1

.

(4.5)

Iremos nos referir a este método como método direto1. Segundo [ASCHER, 2008,

p.218], trata-se de um método muito simples obtido através de uma abordagem di-

reta. O autor aﬁrma ainda, na página 219, que “o esquema Leapfrog é compacto e

natural para a equação da onda clássica”. Assim, para calcular o valor em cada ponto,

utilizaremos a seguinte expressão:

U n+1
j = 2U n

j − U n−1

j + C 2(U n

j−1 − 2U n

j + U n

j+1),

onde utilizamos o parâmetro

C =

ck
h

,

conhecido como número de Courant.

Segundo [LANGTANGEN e LINGE, 2016, p.115]: “Vemos que na versão discreta

da EDP ﬁgura somente um parâmetro, C, que é consequentemente o parâmetro chave,

junto com (M ), que governa a qualidade da solução numérica”. Falaremos mais sobre

o número de Courant na seção 4.2.

A equação do método pode ser escrita como

U n+1
j = (2 − C 2)U n

j + C 2(U n

j−1 + U n

j+1) − U n−1

j

,

j = 1, ..., M − 1.

(4.6)

Observamos que, para calcular U n+1

j

, precisamos das aproximações somente nos

pontos vizinhos U n

j±1, U n

j e U n−1
j

. A ﬁgura 4.1 ilustra os pontos utilizados nesse cál-

culo. Podemos interpretar a equação (4.6) como um estêncil, em uma analogia a um

1Alguns autores chamam este método de Leapfrog. Iremos nos referir a ele como método direto e

chamaremos de Leapfrog ao método que será apresentado para solução da equação da advecção.

59

Figura 4.1: Estêncil do método direto

processo gráﬁco. Segundo [LANGTANGEN e LINGE, 2016, p.114]: “O termo estêncil

é utilizado frequentemente para a equação algébrica em um ponto de malha”.

Para os pontos de fronteira, utilizaremos a equação (4.2). Assim, teremos

U n

0 = 0 e U n

M = 0,

n = 1, ..., N.

Para as aproximações no instante t0 = 0, iremos utilizar a primeira condição inicial

do problema, dada pela equação (4.3). Assim, iremos considerar

U 0

j = f (xj),

j = 0, ..., M.

Para calcularmos os valores no passo inicial, teremos um problema. Para aplicar o

método, precisamos sempre das aproximações em dois instantes anteriores, e só teremos

o valor no instante inicial. No passo inicial, precisaremos calcular os valores de U 1
j ,

para j = 1, ..., M − 1. Esses valores seriam dados pela equação

U 1

j = 2U 0

j − U −1

j + C 2(U 0

j−1 − 2U 0

j + U 0

j+1),

j = 1, ..., M − 1,

(4.7)

60

Índice espacialÍndice temporalj-2j-1jj+1j+2j+3n-2n-1nn+1n+2n+2porém a-priori não temos o valor de U −1

j

. Para resolver esse problema, vamos utilizar

a segunda condição inicial, dada pela equação (4.4). Essa condição inicial nos fornece o

valor da derivada parcial da função u, em relação à variável t, no instante t0 = 0. Vamos

utilizar a fórmula de diferenças centradas, dada pela equação (3.4), para discretizar a

equação. Assim, teremos

∂u(x, 0)
∂t

≈

U −1

j − U 1
j
2k

= 0.

Daí chegamos que U −1

j = U 1

j . Substituindo na equação (4.7), ﬁcamos com

U 1

j = U 0

j +

C 2
2

(U 0

j−1 − 2U 0

j + U 0

j+1),

j = 1, ..., M − 1.

(4.8)

Já estamos em condições de aplicar o método para discretizar a equação da onda

do exemplo 4.1. Vamos considerar que L = 6π, T = 3 e que a primeira condição inicial

é dada pela seguinte equação:

u(x, 0) =






1 − cos x,

se x ∈ [2π, 4π],

0,

caso contr´ario.

Para a aplicação do método a esse problema, o código de programação encontra-se

no Apêndice C, no exemplo C.6. O resultado pode ser visto na ﬁgura 4.2.

Na ﬁgura 4.3, podemos observar a conﬁguração da onda em diversos instantes. No

instante inicial, a onda tem o formato da condição inicial. Podemos observar que a

curva inicial divide-se em duas, uma trafegando para a direita e outra para a esquerda.

4.2 A Condição CFL

Se considerarmos a equação (4.1) deﬁnida sobre um domínio ilimitado, −∞ < x < ∞

e 0 ≤ t < ∞, e as condições iniciais dadas pelas equações (4.3) e (4.4), utilizando a

fórmula de d’Alembert, podemos concluir que a solução analítica da equação da onda

é dada pela equação

61

Figura 4.2: Aproximação da Equação da Onda

u(x, t) =

f (x − ct) + f (x + ct)
2

(4.9)

Podemos observar que a equação (4.9) é composta da soma das funções 1

2f (x − ct)

e a função 1

2f (x + ct). A primeira representa uma translação horizontal da função

1
2f (x), em ct unidades, para a direita; a segunda representa uma translação horizontal

da função 1

2f (x), em ct unidades, para a esquerda. Observando a ﬁgura 4.3, podemos

entender o que acontece com a solução. À medida que o tempo aumenta, há uma curva

que se desloca para a direita e outra para a esquerda. Uma dessas curvas corresponde

à função 1

2f (x − ct) e a outra a 1

2f (x + ct).

A partir da equação (4.9), podemos observar que o valor da função u em um ponto

(x, t) depende de informações em dois pontos do domínio no instante inicial, a saber,

os pontos x−ct e x+ct. A ﬁgura 4.4 ilustra a dependência da função u(x, t) em relação

aos seus valores iniciais. A região triangular é chamada domínio de dependência

62

tempo0.00.51.01.52.02.53.0espaço0.02.55.07.510.012.515.017.50.000.250.500.751.001.251.501.752.00Equação da OndaFigura 4.3: Equação da Onda, posição em diversos instantes

63

0.02.55.07.510.012.515.017.50.000.250.500.751.001.251.501.752.00Equação da Onda, t=0.00.02.55.07.510.012.515.017.50.00.20.40.60.81.01.21.4Equação da Onda, t=0.60.02.55.07.510.012.515.017.50.00.20.40.60.81.0Equação da Onda, t=0.90.02.55.07.510.012.515.017.50.00.20.40.60.81.0Equação da Onda, t=1.50.02.55.07.510.012.515.017.50.00.20.40.60.81.0Equação da Onda, t=1.20.02.55.07.510.012.515.017.50.00.20.40.60.81.0Equação da Onda, t=3.0do problema. Podemos observar que os valores da função u fora dessa região não

inﬂuenciam o valor da função no ponto (x, t).

Figura 4.4: Domínio de Dependência do Problema

Ao observarmos o estêncil do método direto na ﬁgura 4.1, veriﬁcamos que há tam-

bém uma dependência da solução numérica em relação aos valores em instantes ante-

riores, a cada ponto. Como cada valor nos instantes anteriores também irá depender

de outros valores anteriores, podemos considerar também o domínio de dependência

da solução numérica. Na ﬁgura 4.5 podemos observar o domínio de dependência da

solução numérica obtida através do método direto.

Ao analisarmos os domínios de dependência, podemos observar que é necessário

que o triângulo do domínio de dependência do problema esteja no interior do triângulo

do domínio de dependência numérico ou no máximo seja igual a ele. Caso contrário,

a solução numérica não irá utilizar os valores iniciais da solução exata no cálculo da

64

xtu(x,t)1/2 f(x-ct)1/2 f(x+ct)Figura 4.5: Domínio de Dependência da Solução Numérica

aproximação. Isso signiﬁcaria que as condições iniciais poderiam ser alteradas, inﬂu-

enciando a solução exata, mas sem nenhum efeito sobre a solução aproximada. Isso

certamente não deve acontecer. Assim, obtemos uma restrição para o tamanho de

passo k e o espaço de malha h utilizados no problema.

Observamos que o domínio de dependência do problema, para um ponto u(x, t) é

dado por um triângulo base 2ct e altura t. Já o domínio de dependência numérico,

para uma aproximação U n

k , é dado por um triângulo com base base 2nh e altura nk.

A razão entre a base e a altura no primeiro caso é 2c e no segundo caso é

2h
k

. Para

atendermos à restrição descrita, a razão entre a base e altura para o primeiro triângulo

deverá ser menor ou igual a essa razão para o segundo triângulo. Assim teremos:

2c ≤

2h
k

⇐⇒ ck ≤ h ⇐⇒

ck
h

≤ 1.

(4.10)

Observamos, sem perda de generalidade que na dedução acima supusemos c > 0.

No caso geral basta usarmos |c| no lugar de c. Dessa forma, a grandeza C =

|c|k
h

é

o número de Courant a que nos referimos na seção 4.1. A partir da análise anterior,

65

Índice espacialÍndice temporalj-3j-2j-1jj+1j+2n-2n-1nn+1n+2n+3j+3concluímos que é necessário que seja atendida a restrição

C =

|c|k
h

≤ 1,

(4.11)

para que o método direto funcione corretamente.

Essa restrição é conhecida como condição CFL, pois foi derivada por Courant,

Friedrichs e Lewy em 1928. Podemos enunciar a condição CFL da seguinte forma: “Um

método numérico só pode ser convergente se seu domínio de dependência numérico

contém o domínio de dependência real da EDP, pelo menos no limite quando k e h vão

para zero.” [LEVEQUE, 2007, p.217].

4.3 Calculando os Erros

Nesta seção vamos apresentar uma comparação da solução numérica com a solução

analítica da equação da onda.

Conforme vimos no capítulo 2, a solução analítica é dada pela expressão

u(x, t) =

f (x − ct) + f (x + ct)
2

.

que é obtida através da fórmula de d’Alembert. Porém, a fórmula de d’Alembert é

deﬁnida sobre um domínio ilimitado, enquanto a nossa solução numérica é calculada

sobre um domínio limitado.

No exemplo 4.1, a função f (x) está deﬁnida somente no intervalo [0, L]. Assim,

vamos usar o recurso de estender a função f (x) à reta real, de forma periódica. As

extensões de funções são descritas no apêndice B.

Vamos então considerar a função F (x) a extensão ímpar de período 2L da função

posição inicial f (x). Este tipo de extensão está na deﬁnição B.5. Suponha então que

estamos resolvendo o problema da equação da onda com domínio ilimitado, −∞ < x <

66

∞ e 0 ≤ t < ∞, e as condições iniciais dadas pelas equações

e

u(x, 0) = F (x)

∂u(x, 0)
∂t

= 0

Neste caso podemos aplicar a fórmula de d’Alembert e concluir que

u(x, t) =

F (x − ct) + F (x + ct)
2

.

Os erros, em cada ponto, serão dados pelo módulo da diferença entre a solução

numérica e a solução analítica.

O cálculo dos erros costuma ser realizado utilizando o conceito de norma de vetor (ou

de função de grid). Não utilizaremos esta forma de cálculo, pois não estamos abordando

estes conceitos neste trabalho. Assim, apenas a título de ilustração, calculamos os erros

para alguns pontos, mostrados nas tabelas 4.1, 4.2 e 4.3, no instante t = 3. Utilizamos

os tamanhos de passo k = 0.1, k = 0.01 e k = 0.001 em cada tabela, respectivamente.

Os espaços de malha h foram mantidos proporcionais a k, utilizando o número de

Courant C = 0.9.

Conﬁrmando a nossa expectativa, observamos que os valores absolutos dos erros

diminuem à medida que utilizamos valores menores para k. Temos um indicativo de

que o método se aproxima da solução analítica quando usamos tamanhos de passo

menores.

O código de programação usado para gerar as informações para as tabelas 4.1, 4.2

e 4.3 encontra-se no apêndice, no exemplo C.7.

67

x

Sol. Analítica Sol. Numérica Erro Absoluto

0.000

+0.0000e+00

+0.0000e+00

0.0000e+00

1.996

+5.7069e-01

+5.6349e-01

7.2009e-03

3.992

+9.2179e-01

+9.2589e-01

4.1053e-03

6.209

+3.1544e-02

+3.3933e-02

2.3895e-03

8.205

+0.0000e+00

-3.2454e-04

3.2454e-04

10.423

+0.0000e+00

+4.7980e-04

4.7980e-04

12.419

+4.5726e-03

+4.9471e-03

3.7447e-04

14.636

+8.5240e-01

+8.5753e-01

5.1281e-03

16.632

+6.7783e-01

+6.7048e-01

7.3441e-03

18.850

+0.0000e+00

+0.0000e+00

0.0000e+00

Tabela 4.1: Comparando alguns valores das soluções no instante t = 3, para k = 0.1.

4.4 Propagação de Ondas em Meios com Diversas Ca-

madas

Na seção 2.3, falamos sobre a transmissão de ondas em meios com diversas camadas.

Quando as ondas se propagam através da fronteira entre dois meios com propriedades

físicas diferentes, ocorrem os fenômenos de reﬂexão e refração.

Nesta seção, resolveremos numericamente a equação da onda, considerando que o

meio possui diversas camadas com propriedades físicas diferentes. Assim, iremos con-

siderar que a velocidade de deslocamento da onda irá alterar-se quando ela se deslocar

entre duas camadas.

Para discretizarmos o problema, vamos inicialmente deﬁnir a função

φ(x, t) = q(x)

∂u
∂x

,

68

x

Sol. Analítica Sol. Numérica Erro Absoluto

0.000

+0.0000e+00

+0.0000e+00

0.0000e+00

2.089

+6.1665e-01

+6.1743e-01

7.8053e-04

4.179

+8.6443e-01

+8.6388e-01

5.4912e-04

6.268

+2.2038e-02

+2.1803e-02

2.3465e-04

8.358

+0.0000e+00

-4.3463e-07

4.3463e-07

10.470

+0.0000e+00

-5.0891e-07

5.0891e-07

12.559

+1.8893e-02

+1.8675e-02

2.1797e-04

14.648

+8.5673e-01

+8.5617e-01

5.6301e-04

16.738

+6.2743e-01

+6.2820e-01

7.7392e-04

18.850

+0.0000e+00

+0.0000e+00

0.0000e+00

Tabela 4.2: Comparando alguns valores das soluções no instante t = 3, para k = 0.01.

assim, a equação (2.17) se torna

∂2u(x, t)
∂t2

=

∂φ(x, t)
∂x

.

Teremos as seguintes condições de contorno:

u(0, t) = 0 para t ∈ (0, T ],

u(L, t) = 0 para t ∈ (0, T ],

e as seguintes condições iniciais:

u(x, 0) = f (x) para x ∈ [0, L],

∂u(x, 0)
∂t

= 0 para x ∈ [0, L].

Podemos discretizar o lado direito dessa equação utilizando a fórmula de diferenças

centradas, equação (3.4). Neste caso, vamos utilizar a distância de h/2 em relação ao

69

x

Sol. Analítica Sol. Numérica Erro Absoluto

0.000

+0.0000e+00

+0.0000e+00

0.0000e+00

2.093

+6.1857e-01

+6.1868e-01

1.0302e-04

4.187

+8.6172e-01

+8.6164e-01

7.3223e-05

6.282

+2.0018e-02

+1.9989e-02

2.9695e-05

8.376

+0.0000e+00

+1.6715e-09

1.6715e-09

10.471

+0.0000e+00

-2.9761e-09

2.9761e-09

12.565

+1.9708e-02

+1.9679e-02

2.9471e-05

14.661

+8.6095e-01

+8.6087e-01

7.3395e-05

16.754

+6.1965e-01

+6.1975e-01

1.0297e-04

18.850

+0.0000e+00

+0.0000e+00

0.0000e+00

Tabela 4.3: Comparando alguns valores das soluções no instante t = 3, para k = 0.001.

ponto central. Assim, ﬁcaremos com

∂φ(x, t)
∂x

≈

φ(x + h

2 , t) − φ(x − h

2 , t)

h

.

Dividiremos o intervalo de tempo em N partes iguais, de comprimento k. Chama-

remos cada instante no tempo de tn, com n = 0, 1, 2, ..., N , onde tn = nk. Além disso,

dividiremos o intervalo espacial em M partes iguais, de comprimento h. As posições

no espaço serão chamadas de xj, com j = 0, 1, 2, ..., M , onde xj = jh. Vamos calcular

as aproximações nos pontos (xj, tn), de forma que:

U n

j ≈ u(xj, tn).

Para discretizarmos as funções φ(x + h

2 , t) e φ(x − h

2 , t), vamos utilizar também as

fórmulas de diferenças centradas. Assim, ﬁcaremos com

(cid:18)

φ

xj +

h
2

(cid:19)

(cid:18)

, tn

≈ q

xj +

(cid:19) U n

j+1 − U n
j
h

h
2

70

e

(cid:18)

φ

xj −

h
2

(cid:19)

(cid:18)

, tn

≈ q

xj −

h
2

e usaremos as notações

(cid:19) U n

j − U n
h

j−1

,

qj = q(xj),

(cid:18)

qj+ 1

2

= q

xj +

(cid:18)

qj− 1

2

= q

xj −

(cid:19)

(cid:19)

,

.

h
2
h
2

Os valores de qj+ 1

2

e qj− 1

2

poderão ser desconhecidos, porque em muitos casos,

teremos q(x) como uma função discreta, cujos valores serão conhecidos somente nos

pontos de malha xj.

“Em muitos casos, c e, portanto, q, é conhecido apenas como uma função

discreta, frequentemente nos pontos de malha xj. A avaliação de q entre

dois pontos de malha xj e xj+1 deve ser feita por técnicas de interpolação.”

[LANGTANGEN e LINGE, 2016, p.163].

Assim, vamos calcular os valores de qj+ 1

2

e qj− 1

2

como médias aritméticas. Então

teremos

e

qj+ 1

2

≈

qj + qj+1
2

qj− 1

2

≈

qj−1 + qj
2

.

Para a derivada segunda em relação ao tempo, vamos utilizar a fórmula de diferenças

centradas para derivada segunda, equação (3.8). Assim, iremos discretizar a equação

(2.17) da seguinte forma:

U n+1

j − 2U n
k2

j + U n−1
j

=

(qj + qj+1)(U n

j+1 − U n

j ) − (qj−1 + qj)(U n

j − U n

j−1)

2h2

71

o que nos leva a

j = −U n−1
U n+1

j + 2U n

j +

(cid:18) k
h

(cid:19)2 (cid:18) 1
2

(qj + qj+1)(U n

j+1 − U n

j ) −

(qj−1 + qj)(U n

j − U n

j−1)

(cid:19)

1
2

para j = 1, ..., M − 1.

Para j = 0 e j = M , utilizaremos as condições de contorno, assim teremos

(4.12)

U n

0 = 0 e U n

M = 0,

n = 1, ..., N.

Para as aproximações no instante t0 = 0, iremos utilizar a primeira condição inicial

do problema. Assim, iremos considerar

U 0

j = f (xj),

j = 0, ..., M.

Para calcular os valores U 1

j , vamos utilizar a segunda condição inicial. Vamos

utilizar a fórmula de diferenças centradas, dada pela equação (3.4), para discretizar a

equação, obtendo

∂u(x, 0)
∂t

≈

U −1

j − U 1
j
2k

= 0

Daí chegamos que U −1

j = U 1

j . Utilizando a equação (4.12), ﬁcamos com

U 1

j = U 0

j +

(cid:18) k
h

(cid:19)2 (cid:18) 1
4

(qj + qj+1)(U 0

j+1 − U 0

j ) −

1
4

(qj−1 + qj)(U 0

j − U 0

j−1)

(cid:19)

.

Na seção 4.2, apresentamos a condição CFL para a equação da onda, que é um

critério importante para estabilidade da solução numérica.

C =

ck
h

≤ 1

Porém, no caso da propagação de ondas em um meio com diversas camadas, teremos

a velocidade c variável. Precisamos garantir que o critério será atendido para todos os

pontos da malha.

72

“O critério de estabilidade (Condição CFL) determina que (k ≤ h/c).

E se c = c(x), o critério dependerá da localização espacial. Nós devemos,

portanto, escolher um (k) que seja pequeno o suﬁciente para que nenhuma

célula de malha tenha (h/c(x) < k).”

[LANGTANGEN e LINGE, 2016,

p.164].

Assim, iremos adotar o critério

β = max
x∈[0,L]

(c(x))

k
h

≤ 1.

Já estamos em condições de aplicar o método para discretizar a equação da onda

do exemplo 2.10. Vamos considerar que L = 10π, T = 3 e que a primeira condição

inicial é dada pela seguinte equação

u(x, 0) =






1 − cos x,

se x ∈ [4π, 6π]

0,

caso contr´ario

Para a aplicação do método a esse problema, o código de programação encontra-se

no Apêndice C, no exemplo C.10.

Nesse exemplo, estamos considerando que o meio possui duas camadas. A primeira

camada, para x ≤ 3π, possui velocidade de propagação da onda de 2.8. Já a segunda

camada, para x > 3π, possui velocidade de propagação da onda de 4.5. A função q(x)

retorna o quadrado dessas velocidades.

Na ﬁgura 4.6, podemos observar o resultado da aplicação do método em diversos

instantes. A curva que se desloca para a esquerda, quando atinge a fronteira entre as

camadas, localizada na posição x = 3π, começa a dividir-se em duas curvas. Uma delas

corresponde à onda reﬂetida e desloca-se para a direita. A outra curva corresponde à

onda refratada e continua se deslocando para a esquerda.

73

Figura 4.6: Equação da onda em um meio com duas camadas, mostrando a conﬁguração

da onda em diversos instantes

74

0510152025300.00.20.40.60.81.0Equação da onda em meio com camadas, t=0.90510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=1.70510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=1.80510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=1.90510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=2.00510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=2.10510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=2.40510152025300.00.20.40.60.81.01.2Equação da onda em meio com camadas, t=3.0Capítulo 5

Convergência e Estabilidade

5.1 Consistência

Será importante compararmos a acurácia obtida utilizando diversos métodos numéricos,

para sabermos qual método utilizar em determinado problema. Uma ferramenta que

temos para realizar essa comparação é o erro de truncamento local.

“Já que o objetivo das técnicas numéricas é determinar aproximações

precisas com o mínimo esforço, precisamos de meios para comparar a eﬁciên-

cia de vários métodos de aproximação. A primeira ferramenta que conside-

ramos é chamada erro de truncamento local do método.” [BURDEN et al., 2017,

p.301]

Podemos determinar o erro de truncamento local calculando o erro de truncamento

a cada passo do método. No capítulo 3, vimos como calcular o erro de truncamento na

aproximação de uma derivada. Segundo [ASCHER e GREIF, 2011, p.488]: “O erro de

truncamento local é o montante pelo qual a solução exata deixa de satisfazer a equação

de diferenças, escrita em forma de diferença dividida, no passo de integração i.”

75

A vantagem em utilizar o erro de truncamento é que essa é uma quantidade facil-

mente computável, em comparação a outras medidas de erro.

“O erro de truncamento é uma medida de erro usada com frequência

para métodos de diferença. É deﬁnido como o erro na equação da diferença

que surge ao inserir a solução exata. Ao contrário de várias outras medidas

de erro, (...) o erro de truncamento é uma quantidade que é facilmente

computável.” [LANGTANGEN, 2016, p.63]

Para calcular o erro de truncamento local, procedemos da seguinte forma:

inici-

almente substituímos o valor exato da função na fórmula do método. Em seguida

expandimos a função pela série de Taylor e calculamos a diferença em relação à deri-

vada, para descobrir os termos desprezados (truncados). Denotaremos por τ n o erro

de truncamento local cometido no passo n de um método de diferenças ﬁnitas.

Exemplo 5.1. Para o método de Euler (progressivo), deﬁnido pela equação (3.11), τ n

é calculado da seguinte forma:

τ n =

u(tn+1) − u(tn)
k

− f (u(tn), tn),

(5.1)

que é equivalente a

τ n =

u(tn+1) − u(tn)
k

− u(cid:48)(tn).

Mas pelo teorema de Taylor, temos que

u(tn+1) = u(tn + k) = u(tn) + ku(cid:48)(tn) +

k2
2

u(cid:48)(cid:48)(tn) + O(k3).

(5.2)

Substituindo na equação (5.1) ﬁcamos com a seguinte expressão

u(tn) + ku(cid:48)(tn) +

k2
2

τ n =

u(cid:48)(cid:48)(tn) + O(k3) − u(tn)

k

76

− u(cid:48)(tn),

resultando em

τ n =

1
2

ku(cid:48)(cid:48)(tn) + O(k2).

(5.3)

Assim temos que o erro de truncamento local no método de Euler (progressivo) é

O(k).

Exemplo 5.2. Para o método de Euler regressivo, substituímos o valor exato da função

u(t) na fórmula 3.14. Procedendo de forma análoga ao exemplo anterior, concluímos

que

τ n = −

1
2

ku(cid:48)(cid:48)(tn) + O(k2).

De forma que o erro de truncamento local desse método é O(k).

Exemplo 5.3. No caso do método do ponto médio, substituindo o valor exato de u(t)

na equação (3.17) e procedendo de forma análoga aos exemplo anteriores, concluímos

que o erro de truncamento local para esse método é dado por

τ n = −

1
6

k2u(cid:48)(cid:48)(cid:48)(tn) + O(k4).

De forma que o erro de truncamento local desse método é O(k2).

Exemplo 5.4. Vamos estimar a ordem do erro de truncamento para o método de

Runge-Kutta de dois estágios, dado pela equação (3.19). Para esse método, temos que

que é equivalente a

U n+1 = U n + kf

(cid:18)

U n +

1
2

(cid:19)

kf (U n)

U n+1 − U n
k

(cid:18)

U n +

= f

(cid:19)

kf (U n)

1
2

,

.

Para calcular o erro de truncamento, procedemos da mesma forma que ﬁzemos para

o método de Euler: substituímos o valor da aproximação pelo valor exato da função

na fórmula do método, obtendo

τ n =

u(tn+1) − u(tn)
k

(cid:18)

− f

u(tn) +

(cid:19)

kf (u(tn))

.

1
2

(5.4)

77

Podemos aplicar o teorema de Taylor para obter a expressão

(cid:18)

f

u(tn) +

1
2

(cid:19)

kf (u(tn))

(cid:19)

ku(cid:48)(tn)

(cid:18)

= f

u(tn) +

= f (u(tn)) +

1
2
1
2

ku(cid:48)(tn)f (cid:48)(u(tn)) +

1
8

k2(u(cid:48)(tn))2f (cid:48)(cid:48)(u(tn)) + ...

Temos que f (u(tn)) = u(cid:48)(tn) e a derivada dessa expressão é f (cid:48)(u(tn))u(cid:48)(tn) = u(cid:48)(cid:48)(tn).

Substituindo na expressão anterior, chegamos em

(cid:18)

f

u(tn) +

1
2

(cid:19)

kf (u(tn))

= u(cid:48)(tn) +

1
2

ku(cid:48)(cid:48)(tn) + O(k2).

Usando a expressão acima e a expressão (5.2) em (5.4), obtemos

τ n =

1
k

(cid:18)

ku(cid:48)(tn) +

1
2

k2u(cid:48)(cid:48)(tn) + O(k3)

(cid:19)

−

(cid:18)

u(cid:48)(tn) +

1
2

ku(cid:48)(cid:48)(tn) + O(k2)

(cid:19)

= O(k2).

De forma que o erro de truncamento é O(k2).

Nos exemplos anteriores, vemos que os erros de truncamento local são múltiplos de

k, no caso em que são O(k), ou de k2, para o caso O(k2). Assim vemos que esses erros

tendem a zero, à medida que k tende a zero. Essa é uma qualidade importante em

métodos numéricos, denominada consistência. Apresentaremos a deﬁnição de consis-

tência para métodos de passo único. Falaremos sobre métodos de passo múltiplo mais

adiante.

Deﬁnição 5.1 (Consistência para Métodos de Passo Simples). Um método de equação

de diferença de passo único com erro de truncamento local τ n no n-ésimo passo é dito

consistente com a equação diferencial que aproxima se

|τ n| = 0,

lim
k→0

para cada passo n do método. Dizemos que um método é consistente com ordem p se

τ n = O(kp).

78

A consistência nos garante que, no limite, o método irá calcular uma solução que

se aproxima da solução da equação diferencial.

“Consistência signiﬁca que o erro na equação da diferença, medido atra-

vés do erro de truncamento, vai para zero à medida que ∆t → 0. Uma

vez que o erro de truncamento mede quão bem a solução exata preenche a

equação de diferença, e já que a solução exata satisfaz a equação diferencial,

a consistência garante que a equação de diferença se aproxima da equação

diferencial no limite.” [LANGTANGEN, 2016, p.65]

Um ponto importante da deﬁnição é a ordem de consistência. Por exemplo, vimos

que o método de Euler progressivo possui erro de truncamento O(k), assim dizemos

que o método é consistente com ordem 1. Analogamente, o método de Euler regressivo

é consistente com ordem 1 e o método do ponto médio é consistente com ordem 2. A

ordem de consistência mais alta nos indica que o método nos trará aproximações mais

precisas para o valor da derivada presente na equação diferencial.

5.2 Convergência

Embora o erro de truncamento local nos dê um bom indicativo para a precisão do

método, será importante estimarmos o erro da aproximação calculada pelo método,

em relação à solução exata. Esse erro, chamado erro global, é mais difícil de calcular,

pois depende dos erros acumulados em todos os passos anteriores do método. Segundo

[LANGTANGEN, 2016, p.60]: “O erro real em um ponto, de qualquer forma, depende

do desenvolvimento do erro sobre todos do passos de tempo anteriores. Esse erro,

En = U n − u(tn), é conhecido como o erro global” 1.

1Uma vez que a notação matemática utilizada pelo autor é ligeiramente diferente da que temos

utilizado neste trabalho, substituímos a notação da fórmula citada.

79

Deﬁnição 5.2 (Erro Global). O erro global cometido após a execução de n passos

de um método de equação de diferenças, denotado por En, será dado pela diferença

entre a solução exata e a solução aproximada, ou seja

En = U n − u(tn).

A ordem de precisão do método será a ordem do erro global.

Para exempliﬁcar a análise do erro global de um método numérico, iremos estimar

um limite para o erro global do método de Euler progressivo, aplicado a um problema

que iremos deﬁnir a seguir. Segundo [BURDEN et al., 2017, p.294]:

“Apesar de o

método de Euler não ser preciso o suﬁciente para justiﬁcar seu uso na prática, ele é

suﬁcientemente elementar para que a análise do erro produzido em sua aplicação seja

simples.” Iniciaremos com um lema:

Lema 5.0.1. Se m ≥ 0 é um inteiro e x um real então

(1 + x)m ≤ em|x|.

(5.5)

Prova: Seja x ∈ R e m ≥ 0 um inteiro. Pelo teorema 3.1 (Teorema de Taylor),

considerando f (x) = ex e x0 = 0, temos que existe um número ξ(x) entre 0 e x tal que

onde

e

ex = P1(x) + R1(x),

P1(x) = e0 + e0x = 1 + x

R1(x) =

eξ(x)
2

x2.

Este resultado vale para qualquer x ∈ R+. Em particular, para x ∈ R−, repetimos

o raciocínio para |x|. Assim, podemos considerar que existe um número ξ(|x|) entre 0

80

e |x| e aplicar a desigualdade triangular para concluir que

e|x| = 1 + |x| +

eξ(|x|)
2

|x|2 ≥ 1 + |x| ≥ |1 + x|.

Assim teremos,

(1 + x)m ≤ |1 + x|m ≤ e|x|m.

O problema de valor inicial que iremos deﬁnir a seguir é denominado “problema

teste”. Embora seja um problema relativamente simples, será útil para analisar vários

aspectos dos métodos que estamos estudando. Segundo [LEVEQUE, 2007, p.138]:

“Grande parte da teoria apresentada abaixo é baseada em examinar o que acontece

quando um método é aplicado a uma simples equação linear escalar”.

Exemplo 5.5. Suponha que temos um problema de valor inicial, dado pela equação

diferencial

com a condição inicial

u(cid:48)(t) = λu(t) + g(t),

u(t0) = η.

(5.6)

(5.7)

Vamos calcular um valor máximo para o erro global do método de Euler progressivo

aplicado a este problema, em todos os passos do método. Vamos considerar que estamos

iniciando no instante t0 = 0 e indo até o instante ﬁnal T . Utilizaremos um tamanho

de passo k > 0, assim teremos

t0 = 0, t1 = k, ..., tn = nk.

Quando aplicamos o método de Euler à equação (5.6), obtemos:

U n+1 = U n + k(λU n + g(tn)),

e portanto

U n+1 = (1 + kλ)U n + kg(tn).

(5.8)

81

O erro de truncamento, que é dado pela equação (5.1), ﬁca da seguinte forma:

τ n =

(cid:18) u(tn+1) − u(tn)
k

(cid:19)

− (λu(tn) + g(tn)).

Daí obtemos que:

e concluímos que:

kτ n = u(tn+1) − u(tn) − k(λu(tn) + kg(tn)),

u(tn+1) = (1 + kλ)u(tn) + kg(tn) + kτ n.

(5.9)

Sendo os erros globais no passo n e n + 1 dados pelas diferenças En = U n − u(tn)

e En+1 = U n+1 − u(tn+1), e calculando a diferença entre a equação (5.8) e a equação

(5.9) obtemos

[U n+1 − u(tn+1)] = (1 + kλ)[U n − u(tn)] − kτ n.

Assim, concluímos que

En+1 = (1 + kλ)En − kτ n.

(5.10)

Podemos ver então que

E1 = (1 + kλ)E0 − kτ 0,

E2 = (1 + kλ)E1 − kτ 1 = (1 + kλ)2E0 − (1 + kλ)kτ 0 − kτ 1,

E3 = (1 + kλ)3E0 − (1 + kλ)2kτ 0 − (1 + kλ)kτ 1 − kτ 2,

. . .

Por indução podemos veriﬁcar que

En = (1 + kλ)nE0 − k

n
(cid:88)

i=1

(1 + kλ)n−iτ i−1.

(5.11)

Observe que alguns dos termos que estão sobrescritos na expressão acima são ex-

poentes e outros são índices (caso dos τ ’s). Utilizando o Lema 5.0.1, temos que

(1 + kλ)n ≤ enk|λ| ≤ e|λ|T ,

82

uma vez que estamos nos restrigindo ao intervalo de tempo ﬁnito 0 ≤ t ≤ T , de forma

que nk ≤ T . O inteiro i foi deﬁnido no somatório da equação (5.11), de forma que

1 ≤ i ≤ n. Assim temos que n ≥ (n − i) ≥ 0, e podemos novamente aplicar o Lema

5.0.1 e concluir que

(1 + kλ)n−i ≤ e(n−i)k|λ| ≤ enk|λ| ≤ e|λ|T .

Assim, segue da equação (5.11) que

(cid:32)

|En| ≤ e|λ|T

|E0| + k

(cid:33)

|τ i−1|

≤ e|λ|T

(cid:18)

|E0| + nk max
1≤i≤n

(cid:19)

|τ i−1|

.

n
(cid:88)

i=1

(5.12)

Seja N = T /k o número de passos necessários para atingir o instante T . Vamos

deﬁnir

||τ ||∞ = max

0≤n≤N −1

|τ n|.

(5.13)

Utilizando a equação (5.3), podemos concluir que

||τ ||∞ ≈

1
2

k||u(cid:48)(cid:48)||∞ = O(k),

onde ||u(cid:48)(cid:48)||∞ é o valor máximo da função u(cid:48)(cid:48) no intervalo [0, T ]. Como t = nk ≤ T ,

segue da desigualdade (5.12) que

|En| ≤ e|λ|T (cid:0)|E0| + T ||τ ||∞

(cid:1) .

Para aplicar o método de Euler progressivo, consideramos U 0 = u(0) = η. Então

teremos E0 = 0, e

|En| ≤ e|λ|T T ||τ ||∞.

(5.14)

De forma que o erro é limitado por um múltiplo de ||τ ||∞. Como ||τ ||∞ = O(k),

podemos concluir que |En| = O(k).

Assim como ocorre com o erro de truncamento local, é desejável que o erro global

diminua à medida que diminuirmos o tamanho do passo k. Quando isso ocorre, dizemos

que o método é convergente. Apresentamos a seguir a deﬁnição de convergência.

83

Deﬁnição 5.3 (Convergência). Um método de equação de diferença, com tamanho de

passo k, é dito convergente com relação à equação diferencial que aproxima se

lim
k→0

max
1≤n≤N

|U n − u(tn)| = 0,

onde u(tn) é o valor exato da solução da equação diferencial avaliada no tempo tn,

U n é a aproximação obtida a partir do método de diferença no n-ésimo passo e N é o

número de passos do método aplicados na solução numérica do problema.

Exemplo 5.6. Vamos veriﬁcar se o método de Euler progressivo, aplicado ao problema

do exemplo anterior, é convergente. Utilizando a equação (5.14), temos que

lim
k→0

max
1≤n≤N

|U n − u(tn)| =

lim
k→0

max
1≤n≤N

|En| ≤ lim
k→0

e|λ|T T ||τ ||∞.

Temos que ||τ ||∞ = O(k), e portanto limk→0 ||τ ||∞ = 0. Como λ e T são constantes,

podemos concluir que

lim
k→0

max
1≤n≤N

|U n − u(tn)| = 0

e portanto o método, aplicado ao problema em questão, é convergente.

5.3 Estabilidade

Uma outra qualidade importante para métodos numéricos é a noção de estabilidade.

Como estamos trabalhando com valores aproximados, que possuem erros em relação

aos valores exatos, os métodos podem apresentar problemas devido à propagação desses

erros.

“Na prática, nem as condições iniciais nem a aritmética que é subse-

quentemente executada são representadas exatamente por causa do erro de

84

arredondamento associada à aritmética com um número ﬁnito de algaris-

mos.

Para analisarmos esta situação, pelo menos parcialmente, tentaremos

determinar quais métodos são estáveis, no sentido de que pequenas varia-

ções ou perturbações nas condições iniciais produzem mudanças correspon-

dentemente pequenas nas aproximações subsequentes.”

[BURDEN et al., 2017, p.374]

Via de regra, para determinarmos se um método é convergente, será mais fácil

determinarmos primeiro se ele é consistente e estável.

“Convergência é difícil de estabelecer teoricamente, exceto em alguns

problemas simples (...). Um grande avanço na compreensão de métodos de

valores numéricos para equações diferenciais veio em 1956, quando Lax e

Richtmeyer estabeleceram uma equivalência entre a convergência, por um

lado, e consistência e estabilidade do outro (o teorema da equivalência de

Lax). Na prática, isso signiﬁca que é possível estabelecer primeiro que um

método é estável e consistente, e então concluir que é automaticamente

convergente (o que é muito mais difícil de estabelecer).”

[LANGTANGEN, 2016, p.65]:

Assim, geralmente será mais simples demonstrar que um método é estável e consis-

tente, para em seguida concluir que é convergente usando os resultados estabelecidos

por Lax e Ritchmyer. Encontramos ainda em [LANGTANGEN, 2016, p.65] a observa-

ção de que esses resultados valem somente para problemas lineares, e que no caso não

linear é mais difícil estabelecer a relação entre consistência, convergência e estabilidade.

“De um modo geral, quando falamos sobre a estabilidade de um es-

quema numérico, estamos nos referindo à capacidade de manter sob con-

85

trole os efeitos causados na solução numérica por perturbações de dados.”

[QUARTERONI, SALERI e GERVASIO, 2014, p.284]

Segundo [BURDEN et al., 2017, p.374], “um método estável é aquele cujos resulta-

dos dependem continuamente dos dados iniciais”. Para ilustrarmos a propriedade de

estabilidade de um método, apresentaremos um exemplo.

Exemplo 5.7. Vamos mostrar que o método de Euler progressivo, aplicado ao pro-

blema apresentado no exemplo 5.5, é estável.

Suponha que o método de Euler progressivo seja aplicado a este problema duas

vezes. Em uma delas iniciamos o método com o valor V 0, e na outra com o valor W 0.

Um deles seria o valor inicial alterado, ou “perturbado”. Considere que as sequências

{V n}N

n=0 e {W n}N

n=0 são resultantes das duas aplicações do método de Euler progressivo

ao problema acima, iniciando com os valores V 0 e W 0, respectivamente.

Mostraremos que existe uma constante K > 0 tal que

|V n − W n| ≤ K|V 0 − W 0|,

para n = 1, . . . , N , sempre que as sequências de aproximações V n e W n satisﬁzerem a

equação de diferença U n+1 = U n + kλ(U n) + g(tn). Assim, teremos um limite para a

perturbação das aproximações em função da perturbação dos valores iniciais, e portanto

poderemos concluir que o método de Euler progressivo aplicado ao problema em questão

é estável. Temos que

|V n − W n| = |V n−1 + kλV n−1 + g(tn−1) − W n−1 − kλW n−1 − g(tn−1)|

= |V n−1 − W n−1 + kλ(V n−1 − W n−1)|

= |V n−1 − W n−1| + |kλ(V n−1 − W n−1)|

= (1 + k|λ|) |V n−1 − W n−1|.

86

Aplicando o mesmo procedimento a |V n−1 − W n−1|, obtemos que

|V n−1 − W n−1| ≤ (1 + k|λ|) |V n−2 − W n−2|

e portanto

|V n − W n| ≤ (1 + k|λ|)2 |V n−2 − W n−2|.

Aplicando o procedimento recursivamente, obtemos que2

|V n − W n| ≤ (1 + k|λ|)n |V 0 − W 0| ≤ (1 + k|λ|)N |V 0 − W 0|.

Portanto, se considerarmos K = (1 + k|λ|)N , teremos a constante K satisfazendo

|V n − W n| ≤ K|V 0 − W 0|,

e assim o método aplicado ao problema em questão será estável, como queríamos de-

monstrar.

Apresentaremos a seguir um teorema que irá relacionar a estabilidade com a con-

vergência e a consistência, para métodos de passo simples.

Teorema 5.1. Suponha que o problema de valor inicial

u(cid:48)(t) = f (u(t), t),

a ≤ t ≤ b

u(a) = α

seja aproximado por um método de diferença de passo único na forma

U0 = α

U n+1 = U n + kφ(tn, U n, k)

2Observe que os valores de n nas expressões V n e W n correspondem às posições desses elementos

nas sequências, enquanto o valor n em (1 + k|λ|)n é um expoente.

87

Suponha também que exista um número k0 > 0 e que φ(t, U, k) seja contínua e satisfaça

uma condição de Lipschitz na variável U com a constante de Lipschitz L no conjunto

D = {(t, U, k) | a ≤ t ≤ b e − ∞ < U < ∞, 0 ≤ k ≤ k0}

Então:

(i) O método é estável;

(ii) O método de diferença é convergente se, e somente se, for consistente, o que é

equivalente a

φ(t, U, 0) = f (U, t), para todo a ≤ t ≤ b;

(iii) Se ||τ ||∞ for deﬁnido conforme a equação (5.13), então teremos:

|u(tn) − U n| ≤

||τ ||∞
L

eL(tn−a)

Este teorema encontra-se em [BURDEN et al., 2017, p. 375]. O autor informa

que a parte (i) do teorema diz respeito à estabilidade do método de passo único, que

a sua demonstração não é difícil e a deixa como exercício.

Informa ainda que “as

demonstrações das partes (ii) e (iii) são mais difíceis que a da parte (i) e podem ser

encontradas no material apresentado em [apud GEAR, 1971, p. 57-58]”.

A seguir apresentamos um exemplo de aplicação do teorema, o qual foi obtido em

[LEVEQUE, 2007, p.142]:

Exemplo 5.8. Para o método de Runge-Kutta de dois estágios deﬁnido pela equação

(3.19), teremos:

(cid:18)

φ(t, u, k) = f

u +

(cid:19)

kf (u)

1
2

Suponha que f (u) seja contínua e satisfaça uma condição de Lipschitz na variável

u, sobre o conjunto

D = {(t, u) | a ≤ t ≤ b e − ∞ < u < ∞}

88

com constante Lipschitz L.

A função φ(t, u, k) é uma função composta. Temos que φ(t, u, k) = f ◦ g, onde

g(u) = u + 1

2kf (u) e que g(u) é contínua sobre D, e portanto φ(t, u, k) é contínua sobre

o conjunto

D(cid:48) = {(t, u, k) | a ≤ t ≤ b e − ∞ < u < ∞, 0 ≤ k ≤ k0}.

Temos também que

|f (u1) − f (u2)| ≤ L|u1 − u2|

portanto, teremos

|φ(u1, t, k) − φ(u2, t, k)| =

(cid:12)
(cid:12)
(cid:12)
(cid:12)

f

≤ L

= L

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:18)

u1 +

(cid:18)

u1 +

(cid:19)

(cid:18)

kf (u1)

− f

u2 +

1
2

kf (u2)

(cid:19)(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:19)

(cid:18)

kf (u1)

−

u2 +

1
2

kf (u2)

(cid:19)(cid:12)
(cid:12)
(cid:12)
(cid:12)

1
2
1
2

(u1 − u2) +

≤ L|u1 − u2| +

≤ L|u1 − u2| +

1
2
1
2

(cid:12)
(cid:12)
k(f (u1) − f (u2))
(cid:12)
(cid:12)

1
2

kL|f (u1) − f (u2)|
(cid:18)

kL2|u1 − u2| =

L +

(cid:19)

1
2

kL2

|u1 − u2|

Concluímos assim que φ(u, t, k) satisfaz uma condição de Lipschitz na variável u,

sobre o conjunto D(cid:48), com a constante Lipschitz L(cid:48) = L+

1
2

kL2. Assim, pela condição (i)

do teorema 5.1, o método é estável. No exemplo 5.4, vimos que o erro de truncamento

local é O(k2), assim concluímos que o método é consistente com ordem 2. Pela condição

(ii), temos que o método de diferença é convergente se, e somente se, for consistente,

assim concluímos que o método é convergente. Podemos então considerar que ||τ ||∞ é

O(k2) e pela condição (iii), concluímos que o método é convergente com ordem 2.

89

5.3.1 Métodos de passo múltiplo

Para os métodos de passo múltiplo, cada aproximação é calculada utilizando aproxi-

mações calculadas em mais de um passo anterior. Um método de passo múltiplo linear

de r passos pode ser escrito no formato:

r
(cid:88)

j=0

αjU n+j = k

r
(cid:88)

j=0

βjf (U n+j, tn+j).

(5.15)

Exemplo 5.9. O método do ponto médio, deﬁnido através da equação (3.17), pode

ser escrito também como

U n+2 = U n + 2kf (U n+1, tn+1).

(5.16)

Observamos que o método do ponto médio pode ser escrito no formato da equação

(5.15). Com efeito, basta considerar r = 2 e os seguintes coeﬁcientes:

α0 = −1, α1 = 0, α2 = 1, β0 = 0, β1 = 2, β2 = 0.

Para iniciarmos um método de passo múltiplo, precisaremos de vários valores inici-

ais, em vez de somente um valor inicial, como é o caso dos métodos de passo simples.

Essa é uma diﬁculdade ao utilizar métodos de passo múltiplo. Geralmente, apenas

um valor inicial será conhecido e os demais valores precisarão ser gerados por outro

método.

“Uma diﬁculdade com o uso de (Métodos de Passo Múltiplo Lineares)

se r > 1 é que precisamos dos valores U 0, U 1, ..., U r−1 antes que possamos

começar a aplicar o método de várias etapas. O valor U 0 = η é conhe-

cido a partir do dados iniciais para o problema, mas os outros valores não

são, e geralmente devem ser gerados por algum outro método ou métodos

numéricos” [LEVEQUE, 2007, p. 134].

90

O conceito de convergência para métodos de passo múltiplo é o mesmo dos métodos

de passo simples. Porém, para a consistência, temos uma condição adicional, que

ocorre por conta do número de valores iniciais exigidos por esses métodos. Segundo

[BURDEN et al., 2017, p. 378]:

“Como geralmente apenas o primeiro valor inicial,

(U 0 = η), é exato, é necessário exigir que os erros em todos os valores iniciais (...)

aproximem-se de zero à medida que o tamanho do passo tenda a zero”. Assim, temos

a deﬁnição:

Deﬁnição 5.4 (Consistência para Métodos de Passo Múltiplo). Um método de equação

de diferença de passo múltiplo de r passos, iniciado usando os valores

U 0 = η, U 1 = η1, ..., U r−1 = ηr−1,

com erro de truncamento local τ n no n-ésimo passo é dito consistente com a equação

diferencial que aproxima se

para cada passo n do método, e além disso

|τ n| = 0

lim
k→0

lim
k→0

|ηn − u(tn)| = 0,

(5.17)

(5.18)

para todos n = 1, 2, ..., r − 1. Além disso, dizemos que o método é consistente com

ordem p se τ n = O(kp).

Segundo [BURDEN et al., 2017, p.378], a equação (5.18) implica que um método

de passo múltiplo não será consistente a menos que o método de passo único que gera os

valores iniciais também seja consistente. Temos uma ferramenta muito útil para avaliar

a consistência, convergência e estabilidade de métodos de passo múltiplo. Tratam-se

dos polinômios característicos, que deﬁniremos a seguir.

91

Deﬁnição 5.5 (Polinômios característicos). Dado um método de passo múltiplo linear

de r passos no formato da equação (5.15), os polinômios característicos do método

são deﬁnidos por

ρ(ζ) =

r
(cid:88)

j=0

αjζ j

e σ(ζ) =

r
(cid:88)

j=0

βjζ j.

(5.19)

Exemplo 5.10. Para o método do ponto médio, deﬁnido pela equação (5.16), os

polinômios característicos são dados por

ρ(ζ) = −1 + ζ 2,

σ(ζ) = 2ζ 2.

Exemplo 5.11. O método de Adams-Moulton de dois passos possui a equação

a seguir:

U n+2 = U n+1 +

k
12

(−f (U n) + 8f (U n+1) + 5f (U n+2)).

(5.20)

Os polinômios característicos para este método são dados por

ρ(ζ) = −ζ + ζ 2,

σ(ζ) =

1
12

(−1 + 8ζ + 5ζ 2).

O teorema a seguir nos permitirá veriﬁcar se um método de passo múltiplo linear é

consistente:

Teorema 5.2. Um método de passo múltiplo linear de r passos no formato da equação

(5.15) será consistente se

ρ(1) = 0

e ρ(cid:48)(1) = σ(1).

A demonstração pode ser encontrada em [LEVEQUE, 2007, p.132].

Exemplo 5.12. Para o método de Adams-Moulton de dois passos, deﬁnido pela equa-

ção (5.20), temos

ρ(ζ) = −ζ + ζ 2 ⇒ ρ(1) = 0

ρ(cid:48)(ζ) = −1 + 2ζ ⇒ ρ(cid:48)(1) = 1

σ(ζ) =

1
12

(−1 + 8ζ + 5ζ 2) ⇒ σ(1) = 1 = ρ(cid:48)(1)

92

portanto o método é consistente.

A seguir, apresentaremos um teorema que irá associar as raízes dos polinômios

característicos a algumas propriedades dos métodos de passo múltiplo lineares. Segundo

[LEVEQUE, 2007, p.133]: “A localização das raízes de certos polinômios relacionados

a ρ e σ desempenha um papel fundamental na teoria da estabilidade”.

Deﬁnição 5.6. Dizemos que um método de passo múltiplo linear de r passos, no

formato da equação (5.15), satisfaz à condição de raiz, se as raízes ζj (j = 1, 2, . . . , r),

do polinômio característico ρ(ζ) deﬁnido pela equação (5.19), satisﬁzerem às seguintes

condições:

i) |ζj| ≤ 1 para j = 1, 2, . . . , r;

ii) Se ζj é uma raiz repetida, então |ζj| < 1.

Teorema 5.3. Um método de passo múltiplo linear de r passos, no formato da equação

(5.15), é estável se, e somente se, satisﬁzer a condição de raiz. Além do mais, se o

método de diferença for consistente com a equação diferencial, então o método será

estável se, e somente se, for convergente.

Segundo [BURDEN et al., 2017, p. 380]: “Para a demonstração desse resultado e a

teoria sobre a qual ele se baseia, veja [apud ISSACSON e KELLER, 1966, p. 410-417.]”

Exemplo 5.13. Para o método de Adams-Moulton de dois passos, deﬁnido pela equa-

ção 5.20, temos que

ρ(ζ) = ζ 2 − ζ

As raízes de ρ(ζ) são ζ1 = 1 e ζ2 = 0. Portanto, pelo teorema 5.3, o método é

estável. No exemplo 5.12, vimos que o método é consistente, portanto, pelo mesmo

teorema, concluímos que ele é convergente.

93

Não entraremos em detalhes referentes à consistência, convergência e estabilidade

para sistemas de equações diferenciais. Porém, o estudo é análogo ao que realiza-

mos para uma única equação diferencial. Basicamente, o que muda é que passa-

mos a tratar dos limites para os erros em termos de normas de vetores. Segundo

[BURDEN et al., 2017, p.370]: “Teoremas de convergência e estimativas de erro para

sistemas são análogos àqueles considerados (...) para uma única equação, exceto que

os limitantes são dados em termos de normas de vetores”.

Quanto ao método direto apresentado para solução da equação da onda, é um mé-

todo de segunda ordem de precisão em relação ao tempo e ao espaço, desde que a equa-

ção diferencial possua uma solução com regularidade suﬁciente. A demonstração dessa

propriedade está além do escopo do nosso trabalho. Segundo [ASCHER e GREIF, 2011,

p.530]: “O esquema Leapfrog é simples e de segunda ordem de precisão no tempo e

espaço, desde que a solução que está sendo aproximada seja suave.”

5.4 Estabilidade Absoluta

Em seções prévias, analisamos a acurácia de métodos numéricos, de acordo com o ta-

manho de passo k utilizado. Veriﬁcamos quais métodos são convergentes, no sentido

de que o erro global tende a zero à medida que k tende a zero. Assim, utilizando mé-

todos convergentes, podemos melhorar a acurácia das nossas aproximações diminuindo

o tamanho do passo utilizado. Porém, à medida que diminuímos o tamanho de passo

utilizado, aumentamos a quantidade de passos e por conseguinte a quantidade de ope-

rações computacionais realizadas para resolver determinado problema. Teremos um

custo computacional mais alto à medida que utilizarmos um tamanho de passo menor.

Então seria desejável escolher um tamanho de passo pequeno o suﬁciente para obter

um nível de precisão razoável e ao mesmo tempo que não fosse pequeno demais, para

94

manter o custo computacional em níveis aceitáveis.

Veremos que há uma propriedade dos métodos numéricos, denominada estabili-

dade absoluta, relacionada ao tamanho de passo escolhido. Enquanto a convergência

nos determina que a acurácia do método será maior à medida que diminuímos o tama-

nho do passo, a estabilidade absoluta está relacionada ao comportamento do método

para um determinado tamanho de passo.

“Existe uma diferença fundamental entre os conceitos de erro introduzi-

dos anteriormente e o requisito de estabilidade absoluta: os primeiros per-

guntam o que acontece quando (k → 0) para um problema ﬁxo de EDO,

enquanto o segundo se preocupa com a situação para um passo ﬁxo e não

necessariamente pequeno.” [ASCHER e GREIF, 2011, p.492]

Para ilustrar a propriedade de estabilidade absoluta para o tamanho de passo es-

colhido, vamos apresentar alguns exemplos.

Exemplo 5.14. Vamos considerar o seguinte problema de valor inicial:

u(cid:48)(t) = λu(t)

u(0) = 1

onde λ < 0 é uma constante real.

A solução exata é u(t) = eλt. Podemos veriﬁcar isso derivando diretamente. Como

λ < 0, o módulo da solução exata irá diminuir quando aumentarmos o valor de t.

Assim, é razoável esperar que a solução aproximada, calculada pelo método numérico

não possua comportamento contrário à solução exata, ou seja, que não cresça à medida

que avançarmos no tempo. Para isso, temos a seguinte condição:

|U n+1| ≤ |U n|

95

(5.21)

Aplicando o método de Euler progressivo a este problema, o valor das aproximações

será dado por

U n+1 = U n + kλU n = (1 + kλ)U n

Para que o método atenda à condição dada pela equação 5.21, precisamos ter

|1 + kλ| ≤ 1 ⇒ k ≤

2
|λ|

(5.22)

Este é um requisito de estabilidade absoluta. Segundo [ASCHER e GREIF, 2011,

p.491]: “Independentemente das considerações de precisão, o tamanho do passo cons-

tante (k) não deve exceder um certo limite que depende do problema que está sendo

aproximadamente resolvido.”

Apresentaremos a seguir um exemplo que irá ilustrar os potenciais problemas quando

não são atendidos requisitos de estabilidade absoluta:

Exemplo 5.15. Vamos considerar o seguinte problema de valor inicial:

u(cid:48)(t) = −1500(u(t) − cos (t)) − sen (t)

u(0) = 1

(5.23)

A solução deste problema é u(t) = cos (t) (podemos veriﬁcar derivando direta-

mente). A função f satisfaz a uma condição de Lipschitz sobre a variável u, no conjunto

D = R2, com constante de Lipschitz L = 1500. Pelo teorema 5.1, o método é conver-

gente. Aplicamos o método de Euler progressivo a este problema, até o instante T = 2.

Na tabela 5.1 podemos ver os valores do erro global no instante T = 2 utilizando o

método com diversos valores de k.

Utilizando tamanho de passo 0.0013, obtemos um erro global de −1.8000 × 10−7.

Porém, utilizando o tamanho de passo 0.0014, o erro é de −5.9946 × 1052, ou seja, um

valor bem maior do que o anterior. Intuitivamente, percebemos que deve haver uma

96

k

Erro Global

0.0012 −1.6607 × 10−7

0.0013 −1.8000 × 10−7

0.0014 −5.9946 × 1052

0.0015

7.5860 × 10122

Tabela 5.1: Comparativo dos erros cometidos nas aproximações usando o método de

Euler progressivo para diferentes valores de k

mudança signiﬁcativa ocorrendo entre o tamanho de passo k = 0.0013 e o tamanho

k = 0.0014.

Observamos que a equação a equação (5.23) está no mesmo formato da equa-

ção (5.6), apresentada no exemplo 5.5. Basta considerarmos λ = −1500 e g(t) =

1500 cos (t) − sen (t). Assim, podemos aplicar a mesma análise realizada naquele exem-

plo. Relembramos então da equação (5.10), que deduzimos na análise daquele exemplo:

En+1 = (1 + kλ)En − kτ n.

Essa equação revela a fonte do crescimento do erro: utilizando o tamanho de passo

k = 0.0014 e sendo λ = −1500, temos que (1 + kλ) = −1.1. Assim, o erro é sempre

multiplicado por um fator com módulo maior do que 1, de forma que será ampliado

exponencialmente.

Assim, ﬁca claro que a condição |1 + kλ| ≤ 1 precisa ser satisfeita, para que o erro

não cresça exponencialmente. Assim, temos o mesmo requisito de estabilidade absoluta

que deduzimos no exemplo 5.14, de forma que é necessário escolher um tamanho de

passo k ≤ 2/|λ|. Observamos que os erros observados acima não contradizem o fato do

método ser convergente. O erro de truncamento local do método de Euler progressivo

é dado pela equação (5.3), assim, podemos veriﬁcar que ||τ ||∞ = 1

2k. Assim, a cota

97

superior do erro global é dado por

|En| ≤ e|λ|T T ||τ ||∞ = e|λ|T T k
2

.

O erro de fato converge para zero à medida que k se aproxima de zero, mas a cota

superior que obtivemos permite um crescimento exponencial do erro com o tempo.

Nos exemplos, observamos que temos dois parâmetros, k e λ, que interferem na

estabilidade absoluta e que o produto z ≡ kλ é o que de fato é usado para determinar

se o método é absolutamente estável. O método de Euler será absolutamente estável

quando −2 ≤ z ≤ 0 e dizemos que o intervalo de estabilidade absoluta do método de

Euler é [−2, 0].

Geralmente consideramos z como um número complexo, por isso é mais comum

falarmos da região de estabilidade absoluta, que é a região no plano complexo para a

qual um método é absolutamente estável.

Assim, a região de estabilidade absoluta para o método de Euler progressivo será

dada pelo conjunto de números z = kλ, onde |1 + kλ| ≤ 1. Ou seja, é o disco de raio

1 centrado no ponto −1. Poderemos visualizar a região de estabilidade absoluta do

método de Euler progressivo na ﬁgura 5.1-a.

“É mais comum falar da região de estabilidade absoluta como uma re-

gião no plano complexo, admitindo a possibilidade de λ ser um número

complexo (é claro que o tamanho de passo k precisa ser real e positivo).

(...) Admitir λ complexo vem do fato de que na prática estaremos geral-

mente resolvendo um sistema de equações diferenciais ordinárias. No caso

linear, são os autovalores da matriz de coeﬁcientes que são importantes na

determinação da estabilidade. No caso não-linear, tipicamente linearizamos

(...) e consideramos autovalores da matriz jacobiana. Por conseguinte, λ

98

Figura 5.1: Regiões de estabilidade de alguns métodos numéricos

representa um autovalor típico e estes podem ser complexos mesmo se a

matriz for real.” [LEVEQUE, 2007, p. 152].

Os polinômios característicos, deﬁnidos na seção 5.3.1, serão usados também para

determinar as regiões de estabilidade dos métodos de passo múltiplo lineares. Con-

forme havíamos citado, de [LEVEQUE, 2007, p.133]: “A localização das raízes de cer-

tos polinômios relacionados a ρ e σ desempenha um papel fundamental na teoria da

estabilidade”. Assim, iremos deﬁnir o seguinte polinômio:

Deﬁnição 5.7 (Polinômio de Estabilidade). Dado um método de passo múltiplo linear

de r passos no formato da equação (5.15), deﬁnimos o polinômio de estabilidade

99

a) Método de Euler Progressivob) Método de Euler Regressivod) Método do Ponto Médioc) Método Trapezoidaldesse método como

π(ζ; z) = ρ(ζ) − zσ(ζ),

(5.24)

onde ρ(ζ) e σ(ζ) são os polinômios característicos deﬁnidos na equação (5.19).

Exemplo 5.16. Para o método de Adams-Moulton de dois passos, deﬁnido pela equa-

ção (5.20), os polinômios característicos são dados por

ρ(ζ) = ζ 2 − ζ,

σ(ζ) =

1
12

(−1 + 8ζ + 5ζ 2),

e o polinômio de estabilidade é dado por

π(ζ; z) = ζ 2 − ζ −

z
12

(−1 + 8ζ + 5ζ 2).

A deﬁnição a seguir nos permitirá determinar a região de estabilidade absoluta para

métodos de passo múltiplo:

Deﬁnição 5.8 (Região de Estabilidade para métodos de passo múltiplo lineares). Dado

um método de passo múltiplo linear de r passos no formato da equação (5.15), a região

de estabilidade para esse método é o conjunto de pontos z no plano complexo para a

qual o polinômio de estabilidade π(ζ; z) deﬁnido pela equação (5.24) satisfaz à condição

de raiz descrita pelos itens

i) |ζj| ≤ 1 para j = 1, 2, . . . , r;

ii) Se ζj é uma raiz repetida, então |ζj| < 1.

Esta deﬁnição é apresentada em [LEVEQUE, 2007, p.153]. Na referência, o autor

explica por que os métodos de passo múltiplo possuem estabilidade absoluta quando

z = kλ se encontra dentro da região de estabilidade deﬁnida acima.

Os dois exemplos a seguir encontram-se em [LEVEQUE, 2007, p.153].

100

Exemplo 5.17. O método de Euler progressivo pode ser considerado um método de

passo múltiplo de um passo. Para esse método temos

portanto

ρ(ζ) = −1 + ζ,

σ(ζ) = 1,

π(ζ; z) = −1 + ζ − z.

O polinômio π(ζ; z) possui apenas a raiz ζ1 = 1 + z. Os pontos do plano complexo

que satisfazem à condição de raiz são aqueles em que

|1 + z| ≤ 1

que são os pontos dados pela ﬁgura 5.1-a.

Exemplo 5.18. Para o método de Euler regressivo temos

portanto

ρ(ζ) = −1 + ζ,

σ(ζ) = ζ,

π(ζ; z) = −1 + ζ − zζ.

O polinômio π(ζ; z) possui apenas a raiz

ζ1 =

1
1 − z

.

Os pontos do plano complexo que satisfazem à condição raiz são aqueles em que

(cid:12)
(cid:12)
(cid:12)
(cid:12)

1
1 − z

(cid:12)
(cid:12)
(cid:12)
(cid:12)

≤ 1 ⇐⇒ |1 − z| ≥ 1.

que são os pontos dados pela ﬁgura 5.1-b.

Os dois exemplos a seguir encontram-se em [LEVEQUE, 2007, p.154].

101

Exemplo 5.19. Para o método trapezoidal temos

portanto

ρ(ζ) = −1 + ζ,

σ(ζ) =

1
2

+

ζ
2

,

π(ζ; z) = −1 + ζ − z

(cid:18) 1
2

−

(cid:19)

.

ζ
2

O polinômio π(ζ; z) possui apenas a raiz

ζ1 =

1 + z
2
1 − z
2

.

Denotando z = a + bi, observamos portanto que

|ζ1| ≤ 1,
(cid:12)
(cid:12)
(cid:12)
z
(cid:12)
(cid:12)
(cid:12)
(cid:12)1 −
(cid:12) ≤
(cid:12)1 +
2
(cid:12)
(cid:12)
(cid:12)
z
(cid:12)
(cid:12)
(cid:12)
(cid:12)1 −
(cid:12)1 +
(cid:12)
2
(cid:19)2
(cid:18) b
(cid:16)
2

≤

≤

2

+

1 −

2

(cid:12)
(cid:12)
(cid:12) ,
(cid:12)
(cid:12)
(cid:12)
(cid:17)2

,

z
2
z
2
a
2

+

(cid:19)2

,

(cid:18) b
2

(cid:16)

1 +

(cid:17)2

a
2

2a ≤ 0,

a ≤ 0.

De onde segue a equivalência |ζ1| ≤ 1 ⇐⇒ Re(z) ≤ 0. Portanto a região de

estabilidade é o semi-plano esquerdo conforme mostrado na ﬁgura 5.1-c.

Exemplo 5.20. Para o método do ponto médio temos

portanto

ρ(ζ) = ζ 2 − 1,

σ(ζ) = 2ζ,

π(ζ; z) = ζ 2 − 2zζ − 1.

O polinômio π(ζ; z) possui as raízes

ζ1,2 = z ±

√

z2 + 1.

102

Pode ser mostrado que se z é um imaginário puro da forma z = iα com |α| < 1,

então |ζ1| = |ζ2| = 1 e ζ1 (cid:54)= ζ2, e portanto a condição raiz é satisfeita. Para qualquer

outro valor de z a condição raiz não é satisfeita. Em particular, se z = ±i, então

|ζ1| = |ζ2| é uma raiz repetida de módulo 1. Portanto, a região de estabilidade consiste

do intervalo aberto de −i até i no eixo imaginário, como mostrado na ﬁgura (5.1-d).

Região de Estabilidade para Sistemas de Equações Diferenciais Lineares

A seguir, vamos considerar as regiões de estabilidade para sistemas de equações dife-

renciais lineares. Nesse caso, os autovalores da matriz do sistema serão importantes

para determinar a região de estabilidade. Este é mais um motivo por que a região de

estabilidade é considerada no plano complexo: porque os autovalores de um sistema

real podem ser números complexos.

Vamos considerar um sistema linear da forma

u(cid:48)(t) = Au(t),

(5.25)

onde A é uma matriz m × m constante.

Por simplicidade, suponha que a matriz A é diagonalizável. Pelo teorema A.2,

A tem um conjunto completo de autovetores linearmente independentes, denotados

por r1, r2, . . . , rm, isto é satisfazendo Arp = λprp, para p = 1, 2, ..., m. Seja R =

[r1, r2, ..., rm] a matriz cujas colunas são os autovetores e Λ = diag(λ1, λ2, ..., λm) a

matriz diagonal de autovalores, então

A = RΛR−1 e Λ = R−1AR.

Agora, seja v(t) = R−1u(t). Multiplicando ambos os lados da equação (5.25) por

R−1, ﬁcamos com

R−1u(cid:48)(t) = R−1Au(t).

103

Temos que RR−1 = I, e portanto u(t) = RR−1u(t). Assim, ﬁcamos com

R−1u(cid:48)(t) = (R−1AR)(R−1u(t)),

R−1u(cid:48)(t) = ΛR−1u(t),

e ﬁnalmente

v(cid:48)(t) = Λv(t).

(5.26)

Ou seja, obtermos outro sistema de equações diferenciais lineares com uma matriz

diagonal, da forma

v(cid:48)(t) =

λ1












λ2

. . .












v(t),

λm

onde os termos omitidos da matriz Λ são todos nulos. Se considerarmos

v(t) =























v1(t)

v2(t)
...

vm(t)

então o sistema pode ser desacoplado em m equações diferenciais independentes da

forma

v(cid:48)
1(t) = λ1v1(t),

v(cid:48)
2(t) = λ2v2(t),
...

v(cid:48)
m(t) = λmvm(t).

104

Um método de passo múltiplo linear aplicado ao sistema pode ser desacoplado da

mesma forma. Por exemplo, se aplicarmos o método de Euler, teremos

U n+1 = U n + kAU n,

que, pelas mesmas transformações, pode ser reescrito como

V n+1 = V n + kΛV n,

onde V n = R−1U n. O método aplicado ao sistema pode ser desacoplado em m métodos

numéricos independentes, um para cada componente de V n, que tomam a forma

V n+1
p = (1 + kλp)V n
p ,

para p = 1, 2, . . . , m. Após calcular as aproximações V n, em cada passo do método,

podemos recuperar U n usando a fórmula U n = RV n.

Observamos que será necessário que kλp esteja na região de estabilidade do método

de Euler para todos os valores de p, para que o método completo aplicado ao sistema

seja estável.

No nosso exemplo, estamos considerando que a matriz A é diagonalizável. Po-

rém, o resultado vale para métodos de passo múltiplo lineares em geral. Segundo

[LEVEQUE, 2007, p. 159]: “Essa mesma técnica pode ser usada de forma genérica

para mostrar que um método de passo múltiplo linear só pode ser absolutamente está-

vel se kλp estiver na região de estabilidade do método para cada autovalor λp da matriz

A.”

Exemplo 5.21. No exemplo 3.10, consideramos dois tanques interconectados, con-

forme mostrado na ﬁgura 3.3. Temos a condição inicial:

U (0) =











 =







 .

60

0

u1(0)

u2(0)

105

O problema é representado de forma matricial por

U (cid:48)(t) = AU (t),

(5.27)

onde A é a matriz






A =




 .

− 1
10

1
40

1

10 − 1

10

Os autovalores da matriz A são λ1 = − 3

20 e λ2 = − 1

20. Se utilizarmos um tamanho

de passo k = 1

10, por exemplo, teremos os valores de z1 = kλ1 = − 3

200 e z2 = kλ2 =

− 1

200.

Para o método de Euler progressivo, a região de estabilidade é composta pelos

pontos z tais que |1 + z| ≤ 1. Portanto, para esse problema, com o tamanho de passo

k = 1

10, o método de Euler progressivo será absolutamente estável.

Já para o método de Euler regressivo, a região de estabilidade é dada pelos pontos

z tais que |1 − z| ≥ 1. Assim, o método será absolutamente estável para o tamanho de

passo k = 1

10, mais ainda para qualquer tamanho de passo utilizado.

Para o método trapezoidal a região de estabilidade é dada pelos pontos z tais que

Re(z) ≤ 0. Assim, o método será absolutamente estável para k = 1

10 e para qualquer

tamanho de passo utilizado.

Já para o método do ponto médio a região de estabilidade consiste do intervalo

aberto de −i até i no eixo imaginário (ﬁgura 5.1-d). Portanto o método não será

absolutamente estável para esse problema independente do tamanho de passo que uti-

lizarmos.

Exemplo 5.22. No exemplo 3.11 vimos que a equação do movimento harmônico sim-

ples

u(cid:48)(cid:48)(t) = −

k
m

u(t)

106

pode ser escrita na forma matricial como






u(cid:48)(t)

v(cid:48)(t)






 =




0
k
m

−











1

0

u(t)

v(t)






onde v(t) = u(cid:48)(t).

Os autovalores da matriz do problema são λ1 = i

(cid:113) k

m e λ2 = −i

(cid:113) k
m .

O método de Euler progressivo não será absolutamente estável, independente do

tamanho de passo utilizado, pois a região de estabilidade não contém o eixo imagi-

nário. Já os métodos de Euler regressivo e trapezoidal serão absolutamente estável,

independente do tamanho de passo.

Para o método do ponto médio ser absolutamente estável, se chamarmos de ∆t ao

tamanho de passo, precisaremos que

(cid:114)

|z| = ∆t

k
m

≤ 1 ⇐⇒ ∆t ≤

(cid:114) m
k

.

No capítulo seguinte, veremos que o conhecimento das regiões de estabilidade de

métodos numéricos para equações diferenciais ordinárias, conforme estudamos nesta

seção, será útil para desenvolver métodos para aproximar soluções de equações dife-

renciais parciais.

107

Capítulo 6

O Método das Linhas

Neste capítulo, apresentaremos o Método das Linhas. Veremos que este método poderá

ser aplicado à equação da onda.

Inicialmente veremos uma outra equação diferencial parcial importante, que utili-

zaremos para apresentar o método das linhas.

6.1 A Equação da Advecção

Apresentaremos a seguir outra equação diferencial parcial, intimamente relacionada

com a equação da onda, que será importante no nosso estudo. Trata-se da equação da

advecção. O fenômeno da advecção consiste no transporte de matéria ou de alguma

propriedade realizado pelo movimento de um ﬂuido. Por exemplo, podemos citar o

transporte de contaminantes pelo ﬂuxo da água de um rio ou a transferência de calor

pelo movimento do ar.

“É comum referir-se ao movimento de um ﬂuido como convecção, en-

quanto advecção é o transporte de algum material dissolvido ou suspenso

no ﬂuido. Vamos escolher principalmente a palavra advecção aqui, mas

108

ambos os termos são de uso frequente, e para o transporte de massa em

uma substância a EDP possui um termo referente à advecção, enquanto

o termo semelhante para a equação do calor é o termo de convecção.”

[LANGTANGEN e LINGE, 2016, p.385].

Exemplo 6.1. Vamos deﬁnir uma função u(x, t), que representa a densidade de um

contaminante ao longo de um córrego ou tubo de comprimento L. A concentração

é considerada constante através de um corte transversal no tubo. Iremos considerar

o tempo t variando no intervalo [0, T ]. A variável x representa a posição (da seção

transversal) no tubo e t o tempo.

A equação a seguir representa a advecção dessa densidade

∂u
∂t

+ v

∂u
∂x

= 0 para x ∈ (0, L), t ∈ (0, T ].

(6.1)

Vamos considerar que a equação (6.1) está acompanhada da condição inicial

u(x, 0) = f (x),

(6.2)

onde f (x) representa a distribuição de densidades ao longo do tubo no instante inicial

t = 0. Além da condição inicial, vamos considerar a seguinte condição de contorno

u(0, t) = u(L, t) para t ∈ [0, T ].

Essa condição de contorno é chamada condição de contorno periódica. A densidade

ao longo da fronteira x = 0 é a mesma ao longo da fronteira x = L em qualquer

instante t ∈ [0, T ]. Podemos pensar nessa condição de fronteira nos indicando que

os contaminantes que ﬂuem para dentro do tubo por uma das fronteiras ﬂuem para

fora com a mesma densidade, na outra fronteira.

Isso nos indica que a solução se

mantém periódica e precisamos modelar apenas um período 0 ≤ x ≤ L. No apêndice

de [LEVEQUE, 2007], na página 313, podemos encontrar uma dedução da equação da

advecção.

109

Se considerarmos a equação da advecção deﬁnida no domínio −∞ < x < ∞ e

0 < t ≤ T , a solução exata é dada por

u(x, t) = f (x − vt),

(6.3)

que pode ser veriﬁcada derivando diretamente.

Essa solução representa uma translação horizontal da função f (x), em vt unidades.

Essa translação irá ocorrer para a direita se v > 0 e para a esquerda se v < 0.. É seme-

lhante à solução da equação da onda, cuja solução era composta de duas translações,

uma para a direita e outra para a esquerda. Por este motivo, a equação da advecção

às vezes é referenciada como a equação da onda de uma via, enquanto a equação (4.1)

é referenciada como a equação da onda de duas vias1.

A primeira abordagem para discretizar a equação da advecção será usar a fórmula

de diferencas centradas (equação (3.4)) no espaço e de diferenças progressivas (equação

(3.2)) no tempo. Ficaremos com a seguinte equação:

U n+1
j − U n
j
k

= −

v
2h

(U n

j+1 − U n

j−1),

que pode ser reescrita como

U n+1
j = U n

j −

vk
2h

(U n

j+1 − U n

j−1)

(6.4)

(6.5)

Apresentamos o estêncil desse método na ﬁgura 6.1. Veremos adiante que esse

método não será muito útil por problemas de estabilidade.

Outra abordagem que podemos utilizar é aplicar a fórmula de diferenças centradas

(equação (3.4)) tanto no tempo como no espaço. Assim obtemos o método Leapfrog:

j = U n−1
U n+1

j −

vk
h

(U n

j+1 − U n

j−1).

(6.6)

O estêncil do método Leapfrog é apresentado na ﬁgura 6.2.

1Na literatura em língua inglesa, é comum aparecerem os termos “one-way wave equation” e “two-

way wave equation”.

110

Figura 6.1: Estêncil da primeira abordagem para equação da advecção

A solução exata da equação da advecção é dada pela equação (6.3), a partir dela

podemos derivar a seguinte relação

u(xj, tn+1) = f (xj − vtn+1)

= f (xj − v(tn + k))

= f ((xj − vk) − vtn)

= u(xj − vk, tn).

(6.7)

A curva característica de u(x, t) é uma reta. A solução se mantém constante ao

longo dessa reta. Na ﬁgura 6.3, podemos observar a curva característica entre os

instantes tn e tn+1. Na ﬁgura 6.3.a, temos o caso em que v > 0, e na ﬁgura 6.3.b, o

caso em que v < 0.

Portanto observando o estêncil do método Leapfrog na ﬁgura 6.2 percebemos que

para o esquema numérico preservar a dependência de dados imposta pelas curvas carac-

terísticas, ou seja, pelo domínio de dependência da solução (que nesse caso é unilateral),

111

Índice espacialÍndice temporalj-2j-1jj+1j+2j+3n-2n-1nn+1n+2n+2Figura 6.2: Estêncil do método Leapfrog

é necessário que tenhamos |v|k ≤ h, isto é,

C =

|v|k
h

≤ 1,

(6.8)

que já sabemos se tratar da condição CFL, porém agora no contexto da equação da

advecção.

6.2 Apresentando o Método das Linhas

A seguir apresentaremos o Método das Linhas. Uma das razões para usar o método das

linhas é que este método nos permitirá reduzir equações diferenciais parciais (EDPs) a

equações diferenciais ordinárias (EDOs).

“Os autores enfocam o Método das Linhas (MDL), um procedimento nu-

mérico bem estabelecido para todas as principais classes de EDPs em que

as derivadas parciais do problema de valor de contorno são aproximadas

112

Índice espacialÍndice temporalj-2j-1jj+1j+2j+3n-2n-1nn+1n+2n+2Figura 6.3: Curva característica da equação da advecção. (a) caso em que v > 0 (b)

caso em que v < 0.

algebricamente por diferenças ﬁnitas. Isto reduz as EDPs a equações dife-

renciais ordinárias (EDOs) e assim torna o código de computador fácil de

entender, implementar e modiﬁcar.” [SCHIESSER e GRIFFITHS, 2009, p.

ix]

Outra razão para estudarmos o Método das Linhas é que o estudo deste método

permite analisar a estabilidade de métodos destinados a EDPs dependentes do tempo,

com base na teoria de estabilidade de métodos destinados a EDOs dependentes do

tempo que estudamos na seção 3.4.

“Para entender como a teoria da estabilidade para equações diferenciais

parciais dependentes do tempo se relaciona com a teoria da estabilidade

que já desenvolvemos para equações diferenciais ordinárias dependentes do

tempo, é mais fácil considerar o chamado método da discretização por li-

nhas (MDL) da equação diferencial parcial. Nessa abordagem nós primeiro

discretizamos no espaço somente, o que nos dará um grande sistema de

equações diferenciais ordinárias onde cada componente do sistema corres-

ponde à solução em algum ponto da grade, como uma função do tempo. O

113

tn+1tnxj-1xjxj+1xj-1xjxj+1vk-vk(a)(b)hhsistema de equações diferenciais ordinárias pode então ser resolvido usando

um dos métodos para equações diferenciais ordinárias que estudamos pre-

viamente” [LEVEQUE, 2007, p. 184].

Vamos aplicar o MDL inicialmente à equação da advecção, deﬁnida no exemplo 6.1.

Inicialmente iremos discretizar o domínio do problema apenas no espaço. Dividiremos

o intervalo espacial em M partes iguais. Cada uma dessas partes terá o tamanho

h = L/M . Teremos os pontos x0, x1, x2, ..., xM , onde xj = jh.

Para cada posição no espaço, vamos considerar a função densidade como uma função

do tempo. Assim, a densidade na posição xj será dada pela função Uj(t). Teremos

então

Uj(t) ≈ u(xj, t)

Figura 6.4: Método das Linhas

Assim, teremos as funções U0(t), U1(t), U2(t), ..., UM (t), que irão fornecer as densi-

dades nas posições x0, x1, x2, ..., xM , conforme representado na ﬁgura 6.4. Vamos então

considerar a função U (t), deﬁnida a seguir, que será um vetor contendo as densidades

114

x0x1x2x3x4xM-2xM-1xMxtU1(t)U0(t)U2(t)U3(t)U4(t)UM-2(t)UM-1(t)UM(t)...nas posições x1, x2, ..., xM :

U (t) =























U1(t)

U2(t)
...

UM (t)

Note que, neste vetor, não estamos incluindo a função U0(t). A função U0(t) cor-

responde à densidade na posição x0. Devido às condições de contorno periódicas, a

densidade na posição x0 é igual à densidade na posição xM , e portanto, temos que

U0(t) = UM (t). Assim, só precisamos calcular UM (t).

Vamos então discretizar a equação (6.1) somente no espaço, utilizando a fórmula de

diferenças centradas (equação (3.4)) e manter a derivada no tempo contínua. Assim,

ﬁcaremos com

U (cid:48)

j(t) =

v
2h

(Uj+1(t) − Uj−1(t)),

j = 2, ..., M − 1,

Para j = 1, teríamos

U (cid:48)

1(t) =

v
2h

(U2(t) − U0(t))

mas, devido à condição de contorno periódica, temos que U0(t) = UM (t) e a equação

ﬁca

U (cid:48)

1(t) =

v
2h

(U2(t) − UM (t)).

Para j = M , podemos também usar a periodicidade na condição de contorno para

obter

U (cid:48)

M (t) =

v
2h

(U1(t) − UM −1(t)).

Assim, ﬁcamos com o sistema

U (cid:48)(t) = AU (t),

(6.9)

115

onde

A =

v
2h



















0

−1

1

0

−1

1

0
. . .

1

−1

1
. . .

. . .

−1

0

−1

1

0



















∈ RM ×M .

(6.10)

Ficamos então com um sistema de equações diferenciais ordinárias. Na seção 3.4,

estudamos vários métodos para resolver sistemas desse tipo. O próximo passo será

aplicar um desses métodos para discretizar o sistema (6.9).

Vamos considerar que L = 4π, T = 1.3 e que a condição inicial é dada pela seguinte

equação:

u(x, 0) =






1 − cos x,

se x ∈ [2π, 4π]

0,

caso contr´ario

No exemplo C.8, apresentamos o código de programação que aplica o MDL para

resolver a equação da advecção numericamente. Nesse programa utilizamos o método

trapezoidal. Na ﬁgura 6.5 apresentamos o resultado do programa. Observe que, nesse

programa, estamos utilizando o módulo edosist, que contém funções para resolver sis-

temas de equações diferenciais ordinárias. Essa é uma vantagem da aplicação do MDL:

podemos utilizar métodos prontos, destinados a sistemas de equações diferenciais or-

dinárias, para solucionar numericamente equações diferenciais parciais.

Outra vantagem da utilização do MDL é que facilita a análise da estabilidade ab-

soluta dos métodos. Na seção 5.4, apresentamos o conceito de estabilidade absoluta

para sistemas de equações diferenciais ordinárias. Na abordagem do MDL, discretiza-

mos a equação diferencial parcial como um sistema de equações diferenciais ordinárias.

Assim, podemos aplicar o conceito de estabilidade absoluta a esses sistemas.

116

Figura 6.5: Equação da Advecção - Solução Numérica

Conforme veriﬁcamos na seção 5.4, precisaremos analisar os autovalores da matriz

do sistema, para analisar a estabilidade absoluta do método. Para que o método possua

estabilidade absoluta, será necessário que os autovalores dessa matriz estejam na região

de estabilidade do método. No caso em análise, a matriz do sistema é a matriz A da

equação (6.10). Ela é uma matriz circulante (veja a deﬁnição A.8) e pode ser denotada

por A = C(0, − v

2h , 0, ..., 0, v

2h).

De acordo com o teorema A.4, os autovalores de A são dados por

λp = −

v
2h

rp +

v
2h

rM −1
p

para p = 0, ..., M − 1,

onde

rp = exp

(cid:19)

(cid:18) 2pπ
M

i

= cos

(cid:19)

(cid:18) 2pπ
M

+ i sen

(cid:18) 2pπ
M

(cid:19)

.

117

tempo0.00.20.40.60.81.01.2espaço0246810120.000.250.500.751.001.251.501.75Equação da AdvecçãoTeremos então

rp +

v
2h
2pπi(M −1)
M

v
2h
(cid:16)
e
(cid:18)(cid:18)

rM −1
p

(cid:17)

2pπi
M

− e

λp = −

v
2h
v
2h

=

=

como

cos

2pπ(M − 1)
M

+ i sen

2pπ(M − 1)
M

(cid:19)

(cid:18)

−

cos

2pπ
M

+ i sen

(cid:19)(cid:19)

,

2pπ
M

cos

2pπ(M − 1)
M

= cos

2pπ
M

e

sen

2pπ(M − 1)
M

= − sen

2pπ
M

,

temos que os autovalores de A são da forma

λp = −

iv
h

sen

(cid:19)

(cid:18) 2pπ
M

para

p = 0, 1, ..., M − 1.

Exemplo 6.2. Vamos aplicar o método de Euler progressivo ao sistema (6.9). Vamos

dividir o intervalo de tempo em passos de tamanho k. Teremos a seguinte expressão

para as aproximações

ou, de maneira equivalente

U n+1 − U n
k

= AU n

U n+1 = U n + kAU n,

onde

U n =























U n
1

U n
2
...

U n
M












≈

u(x1, tn)

u(x2, tn)
...

u(xM , tn)












.

Vamos iniciar no instante t0 = 0, onde utilizaremos a condição inicial para obter

U 0 =












f (x0)

f (x1)
...

f (xM )












.

118

Figura 6.6: Autovalores da matriz obtida utilizando o Método das Linhas para a equa-

ção de advecção, comparando com a região de estabilidade do método de Euler Pro-

gressivo.

Esse método é equivalente ao método da equação (6.5). Como vimos, os autovalores

da matriz A são dados pela expressão

λp = −

iv
h

sen

(cid:19)

(cid:18) 2pπ
M

para

p = 0, 1, ..., M − 1,

ou seja, todos os autovalores estão localizados sobre o eixo imaginário, entre os valores

−iv/h e iv/h. A região de estabilidade do método de Euler progressivo é dada pelo

círculo unitário centrado no ponto −1 no plano complexo. Portanto o produto kλp

estará fora da região de estabilidade para a grande maioria dos autovalores λp da matriz

A e assim o método não terá estabilidade absoluta. Na ﬁgura 6.6, podemos observar

a conﬁguração do produto kλp, onde λp são os autovalores da matriz A, e a região

de estabilidade do método de Euler progressivo, na conﬁguração de um determinado

problema, e constatar a aﬁrmação anterior.

Exemplo 6.3. Vamos aplicar o método do ponto médio ao sistema (6.9). Ficaremos

119

                                    com a seguinte expressão para as aproximações:

U n+1 = U n−1 + 2kAU n,

que é equivalente a

U n+1
j = U n−1

j −

vk
h

(U n

j+1 − U n

j−1).

Assim, obtemos o método Leapfrog. Observe que trata-se do mesmo método

apresentado na equação (6.6). Conforme vimos no exemplo 5.20, a região de estabi-

lidade do método do ponto médio é dada pelo intervalo aberto de −i até i no eixo

imaginário. Na ﬁgura 6.7, podemos observar a conﬁguração do produto kλp, onde λp

são os autovalores da matriz A, e a região de estabilidade do método do ponto mé-

dio. Precisamos que os valores de z = kλp estejam todos na região do eixo imaginário

compreendida entre os pontos −i e i. Como os autovalores de A estão todos no eixo

imaginário entre os valores −iv/h e iv/h, precisamos da seguinte condição para que o

método seja estável:

|v|k
h

≤ 1,

que é a condição CFL, equação (6.8), já obtida anteriormente para o método Leap-

frog (direto) aplicado a equação da advecção.

O método de Euler regressivo possui a sua região de estabilidade representada pela

ﬁgura 5.1-b. Podemos observar que o produto kλp estará na região de estabilidade

absoluta para todos os autovalores λp e passos de tempo k, donde se concluí que o

método de Euler regressivo terá estabilidade absoluta para este problema. O mesmo

ocorre para o método Trapezoidal, cuja região de estabilidade é representada pela ﬁgura

5.1-c.

Não entraremos em detalhes referentes à análise de convergência dos métodos obti-

dos com a aplicação do MDL, que baseia-se na teoria para sistemas de equações dife-

renciais. Como dissemos na seção 3.4, a teoria para sistemas de equações diferenciais é

120

Figura 6.7: Autovalores da matriz obtida utilizando o Método das Linhas para a equa-

ção de advecção, comparando com a região de estabilidade do método do ponto médio.

análoga à teoria apresentada para equações diferenciais ordinárias, porém utiliza o con-

ceito de normas de vetor. Uma discussão pode ser encontrada em [LEVEQUE, 2007,

p.189].

6.3 MDL Aplicado à Equação da Onda

Nesta seção, veremos como aplicar o Método das Linhas à equação da onda, começando

pelo exemplo 4.1.

O exemplo no qual nos baseamos para aplicar o MDL à equação da onda encontra-se

na referência [CELLIER e KOFMAN, 2006], a partir da página 211.

Da mesma forma que ﬁzemos para a equação de advecção, iremos primeiro discreti-

zar o problema somente em relação à variável espacial x, mantendo contínua a derivada

em relação à variável t. Dividiremos o intervalo espacial em M partes iguais. Cada

uma dessas partes terá o tamanho h = L/M , e com isso os pontos da malha x0, x1, x2,

121

                                                 5 H J L m R  G H  ( V W D E L O L G D G H  G R  0 p W R G R  G R  3 R Q W R  0 p G L R..., xM , onde xj = jh, e a aproximação

Uj(t) ≈ u(xj, t).

Vamos utilizar a fórmula de diferenças centradas para derivada segunda (equação

(3.8)) para discretizar a derivada em relação à variável espacial x. Assim, ﬁcamos com

a equação

∂2Uj(t)

∂t2 =

c2
h2 (Uj−1(t) − 2Uj(t) + Uj+1(t)),

j = 1, ..., M − 1 e t ∈ (0, T ].

Para evitar trabalharmos com a derivada segunda da função Uj(t), vamos deﬁnir,

para cada j, a função

de forma que

Vj(t) =

∂Uj(t)
∂t

,

∂Vj(t)
dt

=

∂2Uj(t)
∂t2

.

Assim, ﬁcaremos com o sistema de equações diferenciais de primeira ordem

∂Uj(t)
∂t

= Vj(t),






∂Vj(t)
∂t

c2
h2 (Uj−1(t) − 2Uj(t) + Uj+1(t)),
Considerando as condições iniciais do exemplo, ﬁcaremos com

=

j = 1, ..., M − 1 e t ∈ (0, T ].

Uj(0) = f (xj),
∂Uj(0)
∂t

∂f (xj)
∂t

=

= 0,

Vj(0) =

para j = 0, 1, 2, ..., M . Além disso, considerando as condições de contorno, ﬁcaremos

com

U0(t) = 0,

UM (t) = 0,

122

e

V0(t) =

VM (t) =

para t ∈ (0, T ].

Assim, se considerarmos o vetor

∂U0(t)
∂t
∂UM (t)
∂t

= 0,

= 0,

U (t) =



















































U1(t)

U2(t)
...

UM −1(t)

V1(t)

V2(t)
...

VM −1(t)

ﬁcaremos com o sistema

onde

U (cid:48)(t) = AU (t),

(6.11)






A =

0(M −1)

I (M −1)

A21

0(M −1)




 ,

e 0(M −1) é a matriz identicamente nula de tamanho (M − 1) × (M − 1), I (M −1) é

a matriz identidade de tamanho (M − 1) × (M − 1), e A21 é a matriz de tamanho

123

(M − 1) × (M − 1) deﬁnida por

A21 =

c2
h2
















−2

1

1 −2
. . .

1
. . .

. . .

1 −2

1

1 −2
















.

Se considerarmos ainda o valor inicial para U(t) como

U (0) =


























f (x1)

f (x2)
...

f (xM −1)

0

0
...

0


























,

(6.12)

teremos então um problema de valor inicial, composto pelo sistema (6.11) e a condição

inicial da equação (6.12). Poderemos então aplicar um dos métodos estudados na seção

3.4 para discretizar esse sistema.

Para veriﬁcarmos qual método para problema de valor inicial terá estabilidade ab-

soluta, precisaremos analisar os autovalores da matriz A, conforme ﬁzemos na seção

5.4, para outros sistemas de equações diferenciais.

Inicialmente, observamos que a matriz A21 é uma matriz de Toeplitz tridiagonal,

de acordo com a deﬁnição A.10. Chamando de ˜λp aos autovalores de A21, teremos, de

acordo com o teorema A.4 que

˜λp =

2c2
h2

(cid:16)

cos

(cid:17)

(cid:16)pπ
M

(cid:17)

− 1

para p = 1, 2, ..., M − 1.

(6.13)

124

Por sua vez, a matriz A é uma matriz composta por blocos, de acordo com a

deﬁnição A.11. Chamando de λ aos autovalores de A, teremos

A − λI (2M −2) =






−λI (M −1)

I (M −1)

A21

−λI (M −1)




 ,

onde I (2M −2) é a matriz identidade de tamanho (2M − 2) × (2M − 2). Como o produto

de A21 por λI (M −1) é comutativo, podemos aplicar o teorema A.7 e concluir que o

polinômio característico de A será

pA(λ) = det (A − λI (2M −2))

= det (λ2I (M −1) − A21)

= (−1)M −1 det (A21 − λ2I (M −1))

= (−1)M −1pA21(λ2),

onde pA21 é o polinômio característico de A21. Portanto, se deﬁnirmos ˜λ = λ2, teremos
do teorema A.1, que as raízes de pA21(˜λ) são os autovalores de A21. Quando tivermos
p(˜λ) = 0, teremos também p(λ) = 0, e portanto os valores de λ tais que ˜λ = λ2 serão

autovalores de A. Assim, os autovalores de A serão da forma

λ = ±

(cid:112)˜λ,

(6.14)

onde ˜λ são os autovalores de A21. Aplicando a equação (6.13), temos ﬁnalmente que

os autovalores de A são

λp = ±i

(cid:114)

(cid:16)

2

(cid:18) c
h

1 − cos

(cid:17)(cid:17) (cid:19)

(cid:16) pπ
M

para p = 1, 2, ..., M − 1.

(6.15)

Como cos (pπ/M ) varia entre −1 e 1, concluímos que os autovalores de A encontram-

se todos sobre o eixo imaginário, entre os pontos −

2c
h

i e

2c
h

i.

O próximo passo será veriﬁcar quais métodos, aplicados a este problema, possuem

estabilidade absoluta. Conforme vimos na seção 5.4, um método terá estabilidade

125

absoluta quando z = kλp estiver dentro da região de estabilidade do método, para

cada autovalor λp da matriz A.

A região de estabilidade do método de Euler progressivo é dada pelo círculo unitário

centrado no ponto −1 no plano complexo. Portanto o produto z = kλp estará, para

a maior parte dos autovalores, fora da região de estabilidade. O método de Euler

progressivo não é indicado para este problema.

Já a região de estabilidade do método do ponto médio é dada pelo intervalo aberto

de −i até i no eixo imaginário. Assim, precisaremos da seguinte condição para que o

método possua estabilidade absoluta:

2|c|
h

k < 1 ⇐⇒

|c|k
h

<

1
2

Os métodos de Euler regressivo e Trapezoidal possuem as suas regiões de estabi-

lidade representadas nas ﬁguras 5.1-b e 5.1-c. Esses métodos, quando aplicados ao

problema apresentado, possuem estabilidade absoluta para qualquer valor de k e h.

No exemplo C.9, apresentamos o código de programação que aplica o MDL para

resolver a equação da onda numericamente. Nesse programa utilizamos o método

trapezoidal. O resultado é praticamente idêntico àquele apresentado na ﬁgura 4.2, que

foi obtido pela discretização da equação da onda sem utilização do método MDL.

Podemos também aplicar o Métodos das Linhas (MDL) para discretizar o problema

do exemplo 2.10, de propagação de ondas em meios com diversas camadas. Para apli-

car o MDL, inicialmente iremos discretizar o problema somente em relação à variável

espacial x, mantendo contínua a derivada em relação à variável t. Dividiremos o inter-

valo espacial em M partes iguais. Teremos os pontos x0, x1, x2, ..., xM , onde xj = jh.

Vamos considerar as funções

Uj(t) ≈ u(xj, t).

126

Teremos então a seguinte equação

∂2Uj(t)

∂t2 =

(qj + qj+1)(Uj+1(t) − Uj(t)) − (qj−1 + qj)(Uj(t) − Uj−1(t))
2h2

para j = 1, 2, ..., M − 1 e t ∈ (0, T ]. Para evitar trabalharmos com a derivada segunda

da função Uj(t), vamos deﬁnir, para cada j, a função

de forma que

Vj(t) =

∂Uj(t)
∂t

,

dVj(t)
dt

=

∂2Uj(t)
∂t2

.

Assim, ﬁcaremos com o sistema de equações diferenciais a seguir






∂Uj(t)
∂t

= Vj(t),

∂Vj(t)
∂t

=

(qj + qj+1)(Uj+1(t) − Uj(t)) − (qj−1 + qj)(Uj(t) − Uj−1(t))
2h2

,

para j = 1, ..., M − 1. Considerando as condições iniciais do exemplo,

Uj(0) = f (xj),
∂Uj(0)
∂t

∂f (xj)
∂t

=

= 0,

Vj(0) =

para j = 0, 1, 2, ..., M , e as condições de contorno para U , ﬁcaremos com

U0(t) = 0,

UM (t) = 0,

para t ∈ (0, T ]. Temos ainda as condições de contorno para V ,

V0(t) =

VM (t) =

∂U0(t)
∂t
∂UM (t)
∂t

= 0,

= 0,

127

para t ∈ (0, T ]. Assim, se considerarmos o vetor

U (t) =


























U1(t)

U2(t)
...

UM −1(t)

V1(t)

V2(t)
...

VM −1(t)


























,

ﬁcaremos com o sistema

onde

U (cid:48)(t) = AU (t),

(6.16)






A =

0(M −1)

I (M −1)

A21

0(M −1)




 .

Nesse sistema, consideramos 0(M −1) a matriz identicamente nula de tamanho (M −

1) × (M − 1), I (M −1) a matriz identidade de tamanho (M − 1) × (M − 1) e A21 a matriz

de tamanho (M − 1) × (M − 1) deﬁnida por



















−(q0+2q1+q2)
2h2

q1+q2
2h2

q1+q2
2h2

−(q1+2q2+q3)
2h2

q2+q3
2h2

q2+q3
2h2

. . .

−(q2+2q3+q4)
2h2

. . .

q3+q4
2h2

. . .

qM −3+qM −2
2h2

−(qM −3+2qM −2+qM −1)
2h2

qM −2+qM −1
2h2

qM −2+qM −1
2h2

−(qM −2+2qM −1+qM )
2h2

128



















.

Se considerarmos ainda o valor inicial para U (t) como

U (0) =


























f (x1)

f (x2)
...

f (xM −1)

0

0
...

0


























,

teremos então um problema de valor inicial, composto pelo sistema (6.16) e as condições

iniciais. Poderemos então aplicar um dos métodos para sistemas de EDO’s estudados

na seção 3.4 para discretizar esse sistema.

Para sabermos os métodos mais indicados para este problema, precisaremos analisar

os autovalores da matriz A. Conforme vimos na seção 5.4, um método terá estabilidade

absoluta quando z = kλp estiver dentro da região de estabilidade do método, para

cada autovalor λp da matriz A. Inicialmente, podemos observar que a matriz A21 é

real simétrica. De acordo com o teorema A.3, seus autovalores são todos reais.

Iremos utilizar o Teorema Gershgorin (A.6) para analisar o sinal dos autovalores de

A21, e concluir que são todos negativos. Com efeito, para j = 2, 3, ..., M − 2, teremos

os discos:

(cid:26)

z ∈ C :

Dj =

(cid:12)
(cid:12)
(cid:12)
(cid:12)

z +

qj−1 + 2qj + qj+1
2h2

(cid:12)
(cid:12)
(cid:12)
(cid:12)

≤

qj−1 + 2qj + qj+1
2h2

(cid:27)

.

Agora para j = 1, teremos o disco

(cid:26)

z ∈ C :

D1 =

(cid:12)
(cid:12)
(cid:12)
(cid:12)

z +

q0 + 2q1 + q2
2h2

(cid:12)
(cid:12)
(cid:12)
(cid:12)

≤

q1 + q2
2h2

(cid:27)

,

129

e ﬁnalmente para j = M − 1, teremos o disco

DM −1 =

(cid:26)

z ∈ C :

(cid:12)
(cid:12)
(cid:12)
(cid:12)

z +

qM −2 + 2qM −1 + qM
2h2

(cid:12)
(cid:12)
(cid:12)
(cid:12)

≤

qM −2 + qM −1
2h2

(cid:27)

.

De acordo com o teorema Gershgorin, todos os autovalores de A21 se encontram

na união do interior dos discos Dj acima, para j = 1, 2, ..., M − 1. Porém como os

autovalores são reais podemos restringir nossas estimativas a intervalos na reta real.

Com efeito, temos

(cid:20)

(cid:20)

(cid:20)

Dj ∩ R =

D1 ∩ R =

DM −1 ∩ R =

−

qj−1 + 2qj + qj+1
h2

(cid:21)

, 0

para j = 2, 3, ..., M − 2,

−

q0 + 3q1 + 2q2
2h2

, −

q0 + q1
2h2

(cid:21)

,

−

2qM −2 + 3qM −1 + qM
2h2

, −

qM −1 + qM
2h2

(cid:21)

.

Se deﬁnirmos Q = max qj, j = 0, 1, ..., M , então teremos

(cid:32)M −1
(cid:91)

j=1

(cid:33)

Dj

∩ R ⊂

(cid:20)

−

(cid:21)
4Q
h2 , 0

.

Portanto, os autovalores de A21 estão sobre a reta real, entre os pontos −4Q/h2 e

0 (aberto), ou seja, os autovalores são negativos, e o valor máximo em módulo será

menor do que 4Q/h2.

Se considerarmos λ como um autovalor da matriz A, podemos aplicar a mesma

análise que utilizamos na seção anterior, para concluir que

λ = ±

(cid:112)˜λ,

onde ˜λ é um autovalor de A21. Assim, concluímos que os autovalores da matriz A estão

todos sobre o eixo imaginário, entre os pontos 2i

√

√

Q/h e −2i

Q/h. Como Q = max qj

e q(x) = c2(x), os autovalores λ de A estarão restritos a:

−

2i
h

max c(x) ≤ λ ≤

2i
h

max c(x).

130

Conforme vimos anteriormente, um método terá estabilidade absoluta quando z =

kλp estiver dentro da região de estabilidade do método, para cada autovalor λp da

matriz A.

A região de estabilidade do método de Euler progressivo é dada pelo círculo unitário

centrado no ponto −1 no plano complexo. Portanto o produto z = kλp estará, para

a maior parte dos autovalores, fora da região de estabilidade. O método de Euler

progressivo não é indicado para este problema.

Já a região de estabilidade do método do ponto médio é dada pelo intervalo aberto

de −i até i no eixo imaginário. Assim, a condição abaixo será suﬁciente para que o

método do ponto médio, aplicado a este problema, possua estabilidade absoluta:

2k
h

max |c(x)| < 1 ⇐⇒

k
h

max |c(x)| <

1
2

Os métodos de Euler regressivo e Trapezoidal possuem as suas regiões de estabi-

lidade representadas nas ﬁguras 5.1-b e 5.1-c. Esses métodos, quando aplicados ao

problema apresentado, possuem estabilidade absoluta para qualquer valor de k e h.

No exemplo C.11, apresentamos o código de programação que aplica o MDL para

resolver o problema do exemplo 2.10, utilizando o método Trapezoidal.

131

Capítulo 7

Considerações Finais

No presente trabalho, apresentamos diversos métodos que utilizam o conceito de dife-

renças ﬁnitas para resolver equações diferenciais numericamente.

Na seção 3.4, vimos métodos para solução de problemas de valor inicial. Vimos

como estimar a acurácia desses métodos, utilizando os conceitos de erro de trunca-

mento e convergência. Vimos também como escolher métodos mais adequados para

determinados problemas, baseados no conceito de estabilidade absoluta, apresentado

na seção 5.4.

No capítulo 4, vimos a solução da onda pelo método direto, que é um método muito

simples obtido através de uma abordagem direta. O exemplo de programação realizado

com esse método apresentou um bom resultado prático. Na seção 4.2, vimos que a

condição CFL precisa ser atendida para que o método direto apresente um resultado

adequado. Na seção 6.2, introduzimos o Método das Linhas (MDL), que nos permitiu

utilizar métodos destinados a equações diferenciais ordinárias na solução numérica de

equações diferenciais parciais. Vimos como aplicar esse método à equação da onda na

seção 6.3. Apresentamos também métodos para solucionar numericamente a equação

da onda em meios com diversas camadas. Vimos a solução pelo método direto e pelo

132

Método das Linhas.

Assim, concluímos que podemos aplicar o método das diferenças ﬁnitas para so-

lução da equação da onda e podemos obter resultados satisfatórios, de acordo com

os requisitos de precisão do problema. Vimos que há métodos que possuem níveis de

acurácia melhores do que outros, de acordo com a ordem de convergência de cada um.

Em particular, o Método das Linhas mostrou-se bastante prático, pois permite

utilizar diversos métodos destinados a problemas de valor inicial na solução da equação

da onda. O método aplica-se também à propagação de ondas em meios contendo

diversas camadas.

Podemos dizer que atingimos o objetivo de apresentar exemplos de utilização do

método das diferenças ﬁnitas para a solução numérica da equação da onda. O presente

trabalho foi muito importante, no sentido de permitir aplicar conceitos matemáticos

na solução numérica de um problema da Física. Por exemplo, vimos que o teorema

de Taylor e a condição de Lipschitz foram muito úteis na análise dos métodos. Outro

conceito fundamental foi o de autovalores e autovetores.

Uma das diﬁculdades que vivenciamos inicialmente é que veriﬁcamos que o assunto

envolvia vários conceitos de Álgebra Linear. Tivemos que rever muitos desses concei-

tos, o que nos levou a elaborar o apêndice A, com alguns conceitos de Álgebra Linear.

A banca examinadora nos sugeriu detalhar melhor a solução analítica, assim acrescen-

tamos o apêndice B, com a apresentação da solução da equação da onda pelo método

de separação de variáveis.

Outra diﬁculdade que vivenciamos neste trabalho é que o assunto era bastante

extenso e envolveu a leitura de uma boa quantidade de literatura. Havia muitos as-

suntos a abordar e tivemos que limitar a quantidade de informações a ser apresentada.

Veriﬁcamos que havia outros métodos que poderíamos ter utilizado, mas não os abor-

133

damos para não tornar o trabalho demasiadamente extenso. Procuramos nos focar nos

métodos mais básicos e naqueles mais adequados para a equação da onda.

Há alguns pontos em aberto que podem ser abordados em uma continuação deste

trabalho, como por exemplo o importante fenômeno da dispersão numérica. Apresen-

tamos aqui a equação da onda em uma dimensão espacial. Uma continuação poderia

abordar a equação da onda em duas ou mais dimensões espaciais. Poderia ser feita a

análise de consistência, convergência e estabilidade para estes métodos, considerando

normas de vetores. Outra possibilidade seria utilizar métodos de elementos ﬁnitos ou

de volumes ﬁnitos para a solução numérica da equação da onda. Podem ser utilizados

também outros tipos de métodos de diferenças ﬁnitas, como métodos de tamanho de

passo variável ou métodos previsores-corretores.

134

Referências Bibliográﬁcas

[ASCHER, 2008] Ascher, Uri M., Numerical Methods for Evolutionary Diﬀerential

Equations, Philadelphia: SIAM - Society for Industrial and Applied Mathematics,

2008.

[ASCHER e GREIF, 2011] Ascher, Uri M., Greif, Chen, A First Course in Nu-

merical Methods, Philadelphia: SIAM - Society for Industrial and Applied Mathe-

matics, 2011.

[BOYCE e DIPRIMA, 2017] Boyce, William E.; DiPrima, Richard C., Equa-

ções Diferenciais Elementares e Problemas de Valores de Contorno, Tradução e

revisão técnica: Valéria de Magalhães Iorio, 10. ed., Rio de Janeiro: LTC, 2017.

[BURDEN et al., 2017] Burden, Richard L.; Faires, J. Douglas; Burden, An-

nette M., Análise Numérica, Tradução: All Tasks e Helena Maria Ávila de Cas-

tro; Revisão Técnica Helena Maria Ávila de Castro, 3. ed., São Paulo: Cengage

Learning, 2017.

[CELLIER e KOFMAN, 2006] Cellier, François E.; Kofman, Ernesto, Conti-

nuous System Simulation, New York: Springer, 2006.

[EDWARDS e PENNEY, 1995] Edwards, Jr., C.H.; Penney, David E., Equações

Diferenciais Elementares, Tradução: Celso Wilmer e Lafayette Bezerra de Castro;

135

Revisão Técnica Paulo Viana, 3. ed., Rio de Janeiro: EDITORA PRENTICE

HALL DO BRASIL LTDA, 1995.

[FARLOW, 1993] Farlow, Stanley J., Partial Diﬀerential Equations for Scientists

and Engineers, New York: DOVER PUBLICATIONS, INC, 1993.

[KRA e SIMANCA, 2012] Kra,

Irwin; Simanca, Santiago R., On Circu-

lant Matrices, Notices of AMS, Volume 59, Number 3, 2012. Disponí-

vel em <https://www.ams.org/notices/201203/rtx120300368p.pdf>. Acesso em

04/08/2018.

[JEWETT e JOHN, 2017] Jewett Jr., John W., Física para cientistas e engenhei-

ros: volume 2: oscilações, ondas e termodinâmica, Tradução: Solange Aparecida

Visconde; Revisão técnica: Carlos Roberto Grandini, São Paulo: Cengage Lear-

ning, 2017.

[LANGTANGEN, 2011] Langtangen, Hans Petter, A Primer on Scientiﬁc Pro-

gramming with Python, 2nd Edition, Oslo: Springer, 2011.

[LANGTANGEN, 2016] Langtangen,

Hans

Petter,

Finite Diﬀerence

Computing with Exponential Decay Models, Oslo:

2016. Disponível

em:

<https://hplgit.github.io/decay-book/doc/pub/book/pdf/decay-book-

4print.pdf>. Acesso em 07/09/2018.

[LANGTANGEN e LINGE, 2016] Langtangen, Hans Petter; Linge, Svein, Fi-

nite Diﬀerence Computing with PDEs - A Modern Software Approach, Oslo: 2016.

Disponível em: <https://hplgit.github.io/fdm-book/doc/pub/book/pdf/fdm-

book-4screen.pdf>. Acesso em 07/09/2018.

136

[LEON, 2011] Leon, Steven J., Álgebra linear com aplicações, Tradução e Revisão

técnica: Sérgio Gilberto Taboada, Rio de Janeiro: LTC, 2011.

[LEVEQUE, 2007] LeVeque, Randall J., Finite diﬀerence methods for ordinary

and partial diﬀerential equations : steady-state and time-dependent problems, Phi-

ladelphia: SIAM, 2007.

[MARTINS et al., 2007] Martins, Márcio de Araújo; Silva, Josias José

da; Filho, Djalma M. S.; Landau, Luiz, EXTRAPOLAÇÃO E

IMAGEAMENTO SÍSMICO EM MEIOS COMPLEXOS ASSOCIADO

À TÉCNICA CFP, Campinas:

4o PDPETRO, 2007. Disponível

em:

<http://www.portalabpg.org.br/PDPetro/4/resumos/4PDPETRO_1_2_0251-

1.pdf>. Acesso em 03/11/2018.

[MEYER, 2000] Meyer, Carl D., Matrix Analysis and Applied Linear Algebra, Phi-

ladelphia: SIAM, 2000.

[NAGLE, SAFF e SNIDER, 2012] Nagle, R. Kent; Saff, Edward B.; Snider,

Arthur D., Equações Diferenciais, Tradução: Daniel Vieira; Revisão Técnica:

Marcos A. Botelho, 8. ed., São Paulo: Pearson Education do Brasil, 2012.

[POOLE, 2017] Poole, David, Álgebra linear: uma introdução moderna, Tradução

técnica Martha Salerno Monteiro, Celia Mendes Carvalho Lopes, 2. ed. , São Paulo:

Cengage Learning, 2017.

[QUARTERONI, SALERI e GERVASIO, 2014] Quarteroni, A.; Saleri, F.; Ger-

vasio, P., Scientiﬁc computing with MATLAB and Octave, 4. ed., Berlin: Sprin-

ger, 2014.

137

[SCHIESSER e GRIFFITHS, 2009] Schiesser, William E.; Griffiths, Graham

W., A COMPENDIUM OF PARTIAL DIFFERENTIAL EQUATION MODELS,

Cambridge: Cambridge University Press, 2009.

[SILVESTER, 1999] Silvester, J. R., Determinants of Block Matrices, Lon-

don: Department of Mathematics - King’s College, 1999. Disponível em:

<http://www.ee.iisc.ac.in/new/people/faculty/prasantg/downloads/blocks.pdf>.

Acesso em 10/11/2018.

[THOMAS, WEIR e HASS, 2012] Thomas, George B.; Weir, Maurice D.;

Hass, Joel, Cálculo, volume 2, Tradução: Carlos Scalici; Revisão Técnica: Clau-

dio Hirofume Asano, 12. ed., São Paulo: Pearson Education do Brasil, 2012.

[YOUNG e FREEDMAN, 2008a] Young, Hugh D.; Freedman, Roger A., Física

I, Tradução: Sonia Midori Yamamoto; Revisão Técnica: Adir Moysés Luiz, 12.

ed., São Paulo: Addison Wesley, 2008a.

[YOUNG e FREEDMAN, 2008b] Young, Hugh D.; Freedman, Roger A., Fí-

sica II: Termodinâmica e Ondas, Tradução: Cláudia Santana Martins; Revisão

Técnica: Adir Moysés Luiz, 12. ed., São Paulo: Addison Wesley, 2008b.

138

Apêndice A

Alguns Conceitos de Álgebra Linear

Os conceitos de autovalores e autovetores (ou valores e vetores característicos) desem-

penham uma papel muito importante nos métodos de diferenças ﬁnitas destinados à

solução numérica de equações diferenciais.

“A análise de equações diferenciais e de métodos de diferenças ﬁnitas

para sua solução depende muito da ‘análise espectral’, baseada nos auto-

valores e autofunções de operadores diferenciais ou nos autovalores e auto-

vetores de matrizes que aproximam esses operadores”.

[LEVEQUE, 2007,

p.269]

Veremos que um autovalor é um escalar1 associado a uma matriz, enquanto um

autovetor é um vetor associado a essa matriz. São chamados também de valores e

vetores característicos da matriz, uma vez que contêm informações importantes sobre

ela. Segundo [POOLE, 2017, p.254]:

“Autovalores e autovetores são característicos

de uma matriz no sentido de conterem informações importantes sobre a natureza da

matriz.”.

1Um valor escalar pode ser um número real, complexo ou ainda um elemento de um corpo.

139

Deﬁnição A.1 (Autovalores e autovetores). Seja A uma matriz n × n. Um escalar λ

é dito um autovalor ou um valor característico de A se existe um vetor não nulo

x tal que Ax = λx. O vetor x é dito um autovetor ou um vetor característico

associado a λ.

Associado a uma matriz, teremos um polinômio característico, que nos permitirá

calcular os autovalores e autovetores com maior facilidade:

Deﬁnição A.2 (Polinômio Característico). Se A for uma matriz n × n, o polinômio

característico de A é deﬁnido por

p(λ) = det (A − λI)

Temos também o seguinte teorema:

Teorema A.1. Se p for o polinômio característico da matriz A, os zeros de p são os

autovalores, ou valores próprios, da matriz A.

Se λ for um autovalor de A e x satisﬁzer (A − λI)x = 0, então x é um autovetor,

ou vetor próprio, de A correspondente ao autovalor λ.

A demonstração deste teorema e discussões a seu respeito podem ser encontradas

em [LEON, 2011, p.266] ou [POOLE, 2017, p.292].

Exemplo A.1. Encontrar os autovalores e autovetores da matriz






2 1

2 3






A =

Inicialmente determinamos o polinômio caracterísico de A, que será

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

2 − λ

1

2

3 − λ

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

p(λ) = det (A − λI) =

140

Os autovalores de A serão os zeros de p(λ), assim teremos:

o que corresponde a

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

3 − λ

2

3

−2 − λ

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

= 0

λ2 − 5λ + 4 = 0

Resolvendo a equação concluímos que os autovalores de A são λ1 = 4 e λ2 = 1.

Para encontrar os autovetores associados a λ1 = 4, devemos resolver:

(A − 4I)x = 0

se x = (x1, x2)T , o problema corresponde a






2 − 4

1

2

3 − 4
















 =









0

0

x1

x2

Resolvendo o sistema, obtemos que

x = (x1, 2x1)T

portanto qualquer múltiplo não nulo de (1, 2)T será um autovetor associado a λ1.

Resolvendo da mesma forma para λ2 = 1, concluímos que qualquer múltiplo não

nulo de (1, −1)T será um autovetor associado a λ2.

Uma matriz A ∈ Rm×n pode ser representada pela notação:

A =












a11

a21
...

a12

. . . a1n

a22
...

. . . a2n
...

am1 am2

. . . amn












141

(A.1)

Podemos também usar a notação

A = (aij), com 1 ≤ i ≤ m e 1 ≤ j ≤ n

Um tipo de matriz importante que irá aparecer neste trabalho é a matriz diagonal,

cuja deﬁnição apresentaremos a seguir:

Deﬁnição A.3 (nais). Uma matriz A = (aij), n × n, é dita diagonal se aij = 0 para

i (cid:54)= j.

Os elementos aij tais que i = j constituem a diagonal principal da matriz. Podemos

denotar uma matriz diagonal por diag(a11, a22, ..., ann).

Exemplo A.2. A matriz a seguir é diagonal:

A =












2

0

0

0

3 0

0

0

0
√

0

0

0

0

0












0 − 1
3

Ela pode ser denotada por diag(2,

√

3, 0, −1/3).

A matriz identidade n × n é uma matriz diagonal que contém o valor 1 para todos

os elementos da diagonal principal.

A matriz identidade 4 × 4 é:

I =























1 0 0 0

0 1 0 0

0 0 1 0

0 0 0 1

Como vemos neste trabalho, na seção 5.4, será mais fácil trabalhar com matrizes

diagonais em alguns problemas. Nesses momentos, será útil converter uma matriz em

outra matriz diagonal. Este procedimento é denominado diagonalização.

142

Deﬁnição A.4 (Matriz Diagonalizável). Uma matriz n × n, A, é dita diagonalizável

se existe uma matriz não singular X e uma matriz diagonal D tais que

X −1AX = D

(A.2)

Dizemos que X diagonaliza A. A matriz X é dita matriz diagonalizante.

Exemplo A.3. A matriz A, do exemplo A.1, é diagonalizável, pois se considerarmos:

X =






1

1

2 −1


 , X −1 =












 e D =









4 0

0 1

1
3

2
3

1
3

−1
3

teremos

X −1AX = D

Uma pergunta que surge é: quando uma matriz é diagonalizável? O teorema a

seguir nos fornece a resposta a essa pergunta:

Teorema A.2. Uma matriz n × n, A, é diagonalizável se, e somente se, tem n auto-

vetores linearmente independentes.

Se A é diagonalizável, satisfazendo à equação A.2, então os vetores coluna da matriz

diagonalizante X são autovetores de A e os elementos diagonais de D são os autovalores

correspondentes de A.

A demonstração desse teorema encontra-se em [POOLE, 2017, p.304]. Observe que

as matrizes do exemplo A.3 estão nas condições do teorema A.2: os vetores coluna da

matriz diagonalizante X são autovetores de A e os elementos diagonais de D são os

autovalores correspondentes de A.

Dada uma matriz A, m × n, muitas vezes é útil formar uma nova matriz n × m,

cujas colunas são as linhas de A. Essa matriz é denominada matriz transposta de A.

143

Deﬁnição A.5 (Matriz Transposta). A transposta de uma matriz A = (aij), m × n,

é a matriz B = (bji), n × m, deﬁnida por

bji = aij

(A.3)

para j = 1, ..., n e i = 1, ..., m.

A transposta de A é denotada como AT . Segue-se de A.3 que a j-ésima linha de

AT tem os mesmos elementos respectivamente que a j-ésima coluna de A.

Exemplo A.4. Se temos a matriz

então






A =






1 2 3

4 5 6

AT =









1 4

2 5

3 6









E mais um exemplo:

Exemplo A.5. Se temos a matriz

A transposta é dada por

















B =

BT =

















1

2

2

0

3 −2

0 −2

2

1

2

2

0

3 −2

0 −2

2

Note que no último exemplo, a transposta BT é igual à própria matriz B. Esse caso

tem um nome especial:

144

Deﬁnição A.6 (Matriz Simétrica). Uma matriz A, n×n, é dita simétrica se AT = A.

Observe que, para uma matriz simétrica, os elementos da matriz são “espelhados”

em relação à diagonal principal, ou seja, os elementos obedecem à regra: aij = aji.

Segundo [POOLE, 2017, p.152]: “Uma matriz simétrica tem a propriedade de ser a sua

própria ‘imagem espelhada’ na diagonal principal”.

O resultado a seguir, que utiliza o conceito de matriz simétrica, será útil para este

trabalho:

Teorema A.3. Se A é uma matriz real simétrica, então seus autovalores são reais.

A demonstração desse teorema pode ser encontrada em [POOLE, 2017, p.401].

A seguir falaremos sobre as matrizes circulantes e de Toeplitz. Essas matrizes são

importantes no estudo de métodos de diferenças ﬁnitas.

“As matrizes de Toeplitz surgem naturalmente no estudo dos métodos

de diferenças ﬁnitas (...) e é útil ter expressões de formato fechado para

seus autovalores e autovetores. Isso geralmente é possível por causa de sua

estrutura simples” [LEVEQUE, 2007, p. 275] .

Deﬁnição A.7 (Matriz de Toeplitz). Uma matriz de Toeplitz ou matriz de dia-

gonais constantes é uma matriz em que cada diagonal descendente da esquerda para

a direita tem valor constante.

De modo geral, uma matriz de Toeplitz n × n é da forma

145



















T =

a0

a−1

a−2

a−(n−2)

a1

a0

a−1
. . .

. . .

. . . an−3 an−2 an−1

. . .

an−3 an−2

a1

a0
. . .

a1
. . .

a−2

a−1



















. . .
. . .

a0

an−3

a1

a0

a−(n−1) a−(n−2)

. . .

a−2

a−1

Exemplo A.6. A matriz a seguir é de Toeplitz

T =












2

4

−1

3

2

4

0 2

3 0

2 3

6 −1 4 2












As matrizes circulantes são um caso especial das matrizes de Toeplitz.

Deﬁnição A.8 (Matriz Circulante). Uma matriz circulante C é uma matriz qua-

drada, n × n, com elementos reais, em que cada linha i é formada por um deslocamento

cíclico de i − 1 posições, para a direita, de um mesmo vetor a0, a1, a2, ..., an−1.

C =



















a0

an−1

a1

a0

an−2 an−1

. . . an−3 an−2 an−1

a1

a0
. . .

. . .

an−3 an−2

an−3

a1
. . .

. . .
. . .

a2

a1

a3

a2

. . . an−1

a0

a3

. . .

an−1

a1

a0



















Denotamos uma matriz circulante C por C(a0, a1, a2, ..., an−1), onde a0, a1, a2, ...,

an−1 são os elementos da sua primeira linha.

146

Exemplo A.7. A matriz circulante C(2, 3, 4, 1) é

C =























2 3 4 1

1 2 3 4

4 1 2 3

3 4 1 2

Teorema A.4. Sejam a0, a1, a2, ..., an−1 ∈ R e C = C(a0, a1, a2, ..., an−1) uma matriz

n × n circulante. Então os autovalores de C são da forma:

λp = a0 + a1rp + a2r2

p + ... + an−1rn−1

p

e seus autovetores são da forma

xp = (1, rp, r2

p, ..., rn−1

p

)T

onde

para p = 0, 1, ..., n − 1.

rp = e

2pπi
n = cos

2pπ
n

+ i sen

2pπ
n

A demonstração do teorema A.4 pode ser encontrada em [KRA e SIMANCA, 2012].

A seguir a deﬁnição de uma matriz especial:

Deﬁnição A.9 (Matriz Tridiagonal). Uma matriz tridiagonal é uma matriz qua-

drada cujos únicos elementos não nulos estão na diagonal principal e nas diagonais

imediatamente acima e abaixo da principal.

Exemplo A.8. A matriz a seguir é tridiagonal:

C =












2

3 0 0

−2 5 0 0

0

0

1 1

3 9

0 3 4












147

Temos outro caso especial de matriz de Toeplitz:

Deﬁnição A.10 (Matriz de Toeplitz Tridiagonal). Uma matriz de Toeplitz tridi-

agonal é uma matriz tridiagonal cujos elementos em cada uma das três diagonais não

nulas são constantes, da forma



















C =

a0

a−1

a1

a0

a1

a−1 a0
. . .

a1
. . .

. . .

a−1

a0

a1

a−1 a0



















onde a0, a1 e a−1 são números reais ou complexos.

Temos fórmulas para calcular os autovalores e autovetores das matrizes de Toeplitz

tridiagonais:

Teorema A.5. Se A é uma matriz de Toeplitz tridiagonal n × n que possui o valor a0

na diagonal principal, a1 (cid:54)= 0 na diagonal acima da principal e a−1 (cid:54)= 0 na diagonal

abaixo desta, então os autovalores de A são da forma:

λp = a0 + 2

√

a1a−1 cos

pπ
n + 1

e os seus autovetores são da forma:

xp =

(cid:19)1/2

(cid:32)(cid:18)a−1
a1

sen

1pπ
n + 1

,

(cid:18) a−1
a1

(cid:19)2/2

sen

2pπ
n + 1

, ... ,

(cid:18) a−1
a1

(cid:19)n/2

sen

npπ
n + 1

(cid:33)T

para p = 1, ..., n.

A demonstração do teorema A.5 pode ser encontrada em [MEYER, 2000], na página

514.

148

Vimos fórmulas para calcular autovalores e autovetores de algumas matrizes es-

peciais. A seguir, veremos um teorema que nos permitirá estimar a localização dos

autovalores de qualquer matriz n × n.

“Felizmente, há um modo de se estimar a localização dos autovalores de

qualquer matriz. O Teorema dos Discos de (Gershgorin) aﬁrma que todos

os autovalores de uma matriz (real ou complexa) n × n estão dentro da

união de n discos circulares do plano complexo.” [POOLE, 2017, p.319]

Teorema A.6 (Teorema dos Discos de Gershgorin). Seja A ∈ Cn×n e seja Di o
disco fechado no plano complexo centrado em aii com raio ri = (cid:80)

j(cid:54)=i |aij|, a soma dos

módulos dos elementos não diagonais na i-ésima linha de A,

Di = {z ∈ C : |z − aii| ≤ ri}.

Então,

1. todos os autovalores de A se encontram no interior dos discos Di para i = 1, 2, ..., n.

2. se algum conjunto de k discos sobrepostos é disjunto dos outros discos, então exa-

tamente k autovalores se encontram no interior desses k discos.

A demonstração pode ser encontrada em [POOLE, 2017, p.321].

Exemplo A.9. Estimar a localização dos autovalores da matriz abaixo, utilizando o

Teorema dos Discos de Gershgorin:

Teremos

A =









−3 1

0

0

1

2 −1

1
2

0









D1 = {z ∈ C : |z + 3| ≤ 1},

149

Figura A.1: Discos de Gershgorin da matriz de exemplo

e

D2 = {z ∈ C : |z − 2| ≤ 1}

D3 = {z ∈ C : |z| ≤ 1.5}.

Os discos de Gershgorin da matriz A estão representados no plano complexo, na

ﬁgura A.1.

Observe que os conjuntos de discos {D1} e {D3, D2} são disjuntos dos demais discos.

Pelo parte (1) do teorema A.6, os autovalores de A se encontram no interior dos

discos D1, D2 e D3. Pela parte (2) do teorema, temos um autovalor dentro do disco

D1 e outros dois dentro dos discos D3 e D2.

Calculando os autovalores de A, obtemos: λ1 ≈ −3.062, λ2 ≈ 0.534 e λ3 ≈ 1.528,

conﬁrmando o resultado do teorema.

150

D3D2D1Neste trabalho usaremos também o conceito de matrizes compostas por blocos.

Segundo [POOLE, 2017, p.145]: “Muitas vezes é conveniente olhar uma matriz como

sendo composta por um número de submatrizes menores. Traçando-se linhas horizon-

tais e verticais em uma matriz podemos particioná-la em blocos.”

Deﬁnição A.11 (Matriz composta por blocos). Uma matriz composta por blocos con-

siste em uma matriz cujos elementos matriciais são matrizes. Esses elementos matriciais

são denominadas blocos.

Exemplo A.10. Se considerarmos a matriz

Podemos vê-la como

M =

M =
























1 2 1 0

3 4 0 1

1 1 0 1

1 1 1 0

1 2 1 0

3 4 0 1

1 1 0 1

1 1 1 0
























Assim, podemos particionar a matriz em quatro blocos, onde

A11 =






1 2

3 4














 , A12 =




1 0

0 1


 , A21 =




1 1

1 1


 e A22 =









0 1

1 0

E teremos






M =






A11 A12

A21 A22

151

Teorema A.7. Seja

M =






A B

C D






uma matriz composta por blocos, onde os blocos A, B, C e D são matrizes n × n e

CD = DC. Então

det M = det (AD − BC)

A demonstração deste teorema encontra-se em [SILVESTER, 1999].

152

Apêndice B

Solução da Equação da Onda pelo

Método de Separação de Variáveis

B.1 Autofunções

Para aplicarmos o método de separação de variáveis, precisaremos utilizar o conceito

de autofunções. Assim, falaremos sobre esse conceito, apresentando alguns exemplos.

Exemplo B.1. Vamos tentar encontrar soluções para a equação diferencial

y(cid:48)(cid:48) + y = 0.

(B.1)

Podemos observar que a equação

y(x) = sen x

é uma solução desta equação diferencial, pois derivando diretamente, vemos que y(cid:48)(x) =

cos x e y(cid:48)(cid:48)(x) = − sen x.

Da mesma forma, podemos ver que

y(x) = cos x

153

é uma solução.

Na verdade, qualquer função da forma

y(x) = c1 cos x + c2 sen x

(B.2)

é uma solução da equação B.1. Podemos observar isso derivando diretamente.

Se forem fornecidas condições de contorno, como

y(0) = a,

(cid:17)

y

(cid:16)π
2

= b.

(B.3)

podemos determinar os valores das constantes c1 e c2. Para fazer isso, usamos a equação

B.2 para calcular os valores de y(0) e de y

(cid:17)

(cid:16)π
2

. Depois comparamos com os valores

dados pelas condições de contorno.

Para x = 0, ﬁcamos com

y(0) = c1 cos 0 + c2 sen 0 = a.

Sabemos que cos 0 = 1 e sen 0 = 0, assim concluímos que c1 = a.

Para x =

π
2

, ﬁcamos com

(cid:17)

y

(cid:16)π
2

= c1 cos

(cid:17)

(cid:16) π
2

+ c2 sen

(cid:17)

(cid:16) π
2

= b.

Como cos

(cid:17)

(cid:16) π
2

= 0 e sen

(cid:17)

(cid:16)π
2

= 1, concluímos que c2 = b. Portanto, a função

y(x) = a cos x + b sen x

é uma solução da equação diferencial B.1 que atende às condições de contorno B.3.

Exemplo B.2. Vamos tentar achar soluções para a equação diferencial

y(cid:48)(cid:48) + λy = 0.

(B.4)

154

sujeita à condições de contorno

y(0) = 0,

y(π) = 0.

(B.5)

Podemos observar que a função y(x) = 0 é uma solução desta equação. Essa

é a função identicamente nula, que chamamos de solução trivial. Porém, estamos

interessados em outras soluções, que não a trivial.

Além de tentarmos achar soluções para esta equação, queremos também determinar

os valores de λ para os quais existem soluções não triviais.

Vamos precisar analisar separadamente os casos em que λ > 0, λ = 0 e λ < 0, já

que a forma da solução é diferente para cada um desses casos.

Caso 1: λ > 0

Uma solução para esta equação é dada por

y(x) = c1 cos (

λx) + c2 sen (

λx),

√

√

o que pode ser veriﬁcado derivando diretamente.

Utilizando a primeira condição de contorno, temos que

y(0) = c1 sen 0 + c2 cos 0 = 0,

daí concluímos que c2 = 0.

Utilizando a segunda condição de contorno, ﬁcamos com

y(π) = c1 sen

√

λπ = 0.

(B.6)

Ou seja, precisamos saber os valores de λ para os quais sen (

λπ) = 0. Sabemos

√

que os valores de sen π, sen (2π), ..., sen (nπ) são nulos, para qualquer inteiro n. Assim,

escolhemos os valores de λ tais que

√

λ = 1, 2, 3, .... Teremos então

λ1 = 1, λ2 = 4,

..., λ3 = 9,

..., λn = n2,

...

(B.7)

155

Observe que a equação B.6 será satisfeita para estes valores de λ, independente do

valor de c1. As soluções para a equação B.4 são dadas por

y1(x) = sen x, y2(x) = sen (2x),

..., yn(x) = sen (nx),

...,

(B.8)

ou pelo produto de qualquer dessas funções por uma constante, já que a solução inde-

pende da constante c1.

Caso 2: λ < 0

Uma solução para este caso é dada por

y(x) = c1e

√

√
−λx + c2e−

−λx

o que pode ser veriﬁcado derivando diretamente.

Utilizando a primeira condição de contorno, temos que

y(0) = c1 + c2 = 0,

daí concluímos que c1 = −c2.

Utilizando a segunda condição de contorno, temos que

y(π) = c1e

√

√
−λπ + c2e−

−λπ = 0.

Como c1 = −c2, ﬁcamos com

e ﬁnalmente

√

c1(e

−λπ − e−

√

−λπ) = 0,

√

(cid:18)
e

c1

−λπ −

(cid:19)

1
√
−λπ

e

= 0,

√
c1(e2

−λπ − 1) = 0.

Como λ < 0, temos que e2

√

−λπ > 1. Para que o produto acima seja zero, precisa-

remos ter c1 = 0. Consequentemente, c2 = −c1 = 0. Portanto, neste caso, ambas as

constantes serão nulas e teremos somente a solução trivial.

156

Caso 3: λ = 0

Neste caso, ﬁcamos somente com a equação

y(cid:48)(cid:48) = 0.

Podemos achar a solução integrando a expressão acima duas vezes. Ficamos com

y(x) = c1 + c2x

Utilizando a primeira condição de contorno, temos que

y(0) = c1 = 0.

Utilizando a segunda condição de contorno, temos que

y(π) = c2π = 0,

o que implica em c2 = 0.

Portanto as duas constantes serão nulas e teremos somente a solução trivial.

Concluímos assim que existem soluções não triviais somente no caso em que λ > 0.

Essas soluções são dadas pelas funções B.8 (e pelo produto dessas funções por uma

constante), associadas aos valores de λ dados pela equação B.7.

As funções dadas pela equação B.8 são chamadas autofunções. Podemos fazer uma

analogia das autofunções com os autovetores da Álgebra Linear. Lembrando que o

produto de um autovetor por uma constante é ainda é um autovetor. O mesmo ocorre

com as autofunções: uma autofunção multiplicada por uma constante continua sendo

uma autofunção (como vimos no exemplo). Associado a cada autofunção, temos o

respectivo autovalor λ, de forma análoga aos autovalores associados a autovetores.

Discussões sobre autofunções podem ser encontradas em [BOYCE e DIPRIMA, 2017,

pag.488-493] e em [NAGLE, SAFF e SNIDER, 2012, pag.456].

157

Um problema mais geral, análogo ao que acabamos de estudar, é dado por

y(cid:48)(cid:48) + λy = 0,

y(0) = 0,

y(L) = 0,

(B.9)

em que a única diferença em relação ao problema dado pelas equações B.4 e B.5 é que

a segunda condição de contorno é imposta em um ponto arbitrário x = L, em vez de

x = π. O processo de solução é o mesmo que adotamos, até o passo em que se aplica

a segunda condição de contorno. Ficamos com a condição

√

c2 sen (

λL) = 0

em vez da equação B.6. Para satisfazermos essa condição, precisamos ter

√

λL =

π, 2π, 3π, .... Assim, os autovalores e as autofunções do problema B.9 são dados por:

λn =

n2π2
L2 ,

yn(x) = sen

(cid:16) nπx
L

(cid:17)

,

n = 1, 2, 3, ....

B.2 Séries de Fourier

Apresentaremos agora um conceito de suma importância. Tratam-se das séries de

funções trigonométricas denominadas séries de Fourrier.

Mais adiante, iremos discutir a solução da equação da onda pelo método de sepa-

ração de variáveis. Veremos que, para isso, será necessário expressar uma função como

uma série de funções trigonométricas.

“Usando a separação de variáveis, em geral é preciso que se expresse de-

terminada função como uma série trigonométrica. Tais séries são chamadas

séries de Fourier.” [NAGLE, SAFF e SNIDER, 2012, p.454].

As séries de Fourier são úteis em diversas situações:

158

“Além de sua associação ao método de separação de variáveis e às equa-

ções diferenciais parciais, as séries de Fourier sao úteis também de muitas

outras maneiras, como na análise de sistemas mecânicos ou elétricos sob a

ação de forças externas periódicas” [BOYCE e DIPRIMA, 2017, p.494].

As séries de Fourier serão aplicadas frequentemente para funções períodicas.

Deﬁnição B.1. Uma função f é dita periódica com período T > 0 se o domínio de

f contém x + T sempre que contiver x, e se

f (x + T ) = f (x)

para todo valor de x.

sen

(cid:17)

Por exemplo, as funções sen(x) e cos(x) são periódicas com período 2π. As funções
(cid:16) nπx
L
A função

, n = 1, 2, 3, ..., são periódicas com período T =

(cid:16) nπx
L

2L
n

e cos

(cid:17)

.

f (x) = x, −1 ≤ x ≤ 1,

f (−1) = f (1) = 0,

f (x + 2) = f (x)

(B.10)

é periódica com período 2. Essa função é conhecida como função “dente de serra”. Seu

gráﬁco é apresentado na ﬁgura B.1.

A deﬁnição a seguir será importante na nossa análise.

Deﬁnição B.2. Uma função f é dita seccionalmente contínua em um intervalo

a ≤ x ≤ b se o intervalo pode ser dividido por um número ﬁnito de pontos a = x0 <

x1 < ... < xn = b de modo que

1. f é contínua em cada subintervalo aberto xi−1 < x < xi.

2. f tende a um limite ﬁnito nas extremidades de cada subintervalo, quando apro-

ximadas do interior do subintervalo.

159

Figura B.1: Gráﬁco da função periódica conhecida como função “dente de serra”.

Apresentaremos uma deﬁnição para a série de Fourier, mas ainda não iremos esta-

belecer as condições para a sua convergência.

Deﬁnição B.3. Considere que f seja uma função seccionalmente contínua no intervalo

[−L, L] e periódica de período 2L. A série de Fourier de f é a série trigonométrica

f (x) ∼

a0
2

+

∞
(cid:88)

(cid:16)

n=1

an cos

(cid:17)

(cid:16)nπx
L

+ bn sen

(cid:16)nπx
L

(cid:17)(cid:17)

,

onde os an e bn são dados pelas fórmulas

an =

1
L

(cid:90) L

−L

f (x) cos

(cid:16)nπx
L

(cid:17)

dx, n = 0, 1, 2, 3, ...,

(B.11)

(B.12)

e

bn =

1
L

(cid:90) L

−L

f (x) sen

(cid:17)

(cid:16)nπx
L

dx, n = 1, 2, 3, ...,

(B.13)

Observe que a fórmula para os an vale para n iniciando em zero, ou seja, vale para

a0, enquanto a fórmula para os bn vale somente para n a partir de 1.

160

42024432101234Exemplo B.3. Calcular a série de Fourier para a função “dente de serra”:

f (x) = x, −1 ≤ x ≤ 1,

f (−1) = f (1) = 0,

f (x + 2) = f (x)

Usando a fórmula B.12, teremos:

a0 =

(cid:90) 1

−1

xdx =

(cid:20)x2
2

(cid:21)1

−1

= 0,

an =

(cid:90) 1

−1

x cos (nπx)dx, n = 1, 2, 3, ....

Usando integração por partes, teremos

an =

(cid:20) x sen (nπx)
nπ

(cid:21)1

+ cos (nπx)

= 0

−1

Usando a fórmula B.13, teremos

bn =

(cid:90) 1

−1

x sen (nπx)dx, n = 1, 2, 3, ....

Novamente, usando integração por partes, teremos

(cid:20)

bn =

sen (nπx) −

x cos (nπx)
nπ

(cid:21)1

−1

=

−2cos(nπ)
nπ

,

e portanto teremos

f (x) ∼ −

2
π

∞
(cid:88)

n=1

(cid:18)cos(nπ)
n

sen

(cid:16) nπx
L

(cid:17)(cid:19)

, n = 1, 2, 3, ....

que pode ser expressa também por

f (x) ∼ −

2
π

∞
(cid:88)

n=1

(cid:18) (−1)n
n

sen

(cid:16)nπx
L

(cid:17)(cid:19)

, n = 1, 2, 3, ....

161

O resultado a seguir nos garante que a série de Fourier é convergente sob determi-

nadas condições. Usaremos a notação f (c+) para representar o limite de f (x) quando

x → c pela direita; analogamente, f (c−) denota o limite de f (x) quando x → c pela

esquerda.

Teorema B.1. Suponha que f e f (cid:48) são seccionalmente contínuas no intervalo −L ≤

x < L. Suponha, além disso, que f está deﬁnida fora do intervalo −L ≤ x < L, de

modo a ser periódica com período 2L. Então f tem uma série de Fourier

f (x) =

a0
2

+

∞
(cid:88)

(cid:16)

n=1

an cos

(cid:17)

(cid:16)nπx
L

+ bn sen

(cid:16)nπx
L

(cid:17)(cid:17)
,

cujos coeﬁcientes são dados pelas equações B.12 e B.13. A série de Fourier converge

para f (x) em todos os pontos em que f é contínua e converge para [f (x+) + f (x−)]/2

em todos os pontos em que f é descontínua.

Por exemplo, a função “dente de serra” apresentada através da equação B.10, tem a

série de Fourier calculada no exemplo B.3. Esta série converge nos pontos em que f é

contínua, por exemplo, −1 ≤ x ≤ 1 e 1 ≤ x ≤ 3. Nos pontos em que f é descontínua,

a série converge para 0.

O teorema B.1 é apresentado em [BOYCE e DIPRIMA, 2017, pag. 504]. O autor

informa que demonstrações de convergência de uma série de Fourier podem ser en-

contradas em [apud KAPLAN, 2003, capítulo 7] ou em [apud BUCK, 1978, capítulo

6].

Uma função f é dita uma função par se o seu domínio contém o ponto −x sempre

que contém o ponto x e se

para cada x no domínio de f .

f (−x) = f (x)

162

Por exemplo, as funções f (x) = |x|, f (x) = x2 e f (x) = cos(x), com domínio R,

são pares.

Analogamente, uma função f é dita uma função ímpar se o seu domínio contém

o ponto −x sempre que contém o ponto x e se

f (−x) = −f (x)

para cada x no domínio de f .

Por exemplo, as funções f (x) = x, f (x) = x3 e f (x) = sen (x), com domínio R, são

ímpares. A função dada pela equação B.10, chamada função “dente de serra”, é ímpar.

Háverá um interesse especial pelas funções pares e ímpares, pois suas séries de

Fourier serão dadas por fórmulas especiais.

A série de Fourier de qualquer função par será formada, apenas, pelas funções

trigonométricas pares cos

(cid:17)

(cid:16) nπx
L

e pelo termo constante (a0):

Teorema B.2 (Série de Fourier em cossenos). Considere que f e f (cid:48) são seccionalmente

contínuas no intervalo −L ≤ x < L e que f é uma função periódica par com período

2L. Então f tem a série de Fourrier

f (x) =

a0
2

+

∞
(cid:88)

n=1

an cos

(cid:17)

(cid:16)nπx
L

(B.14)

e os coeﬁcientes de Fourier de f são dados por

an =

2
L

(cid:90) L

0

f (x) cos

(cid:17)

(cid:16) nπx
L

dx, n = 0, 1, 2, 3, ....

(B.15)

Já a série de Fourier de qualquer função ímpar será formada apenas pelas funções

trigonométricas ímpares sen

(cid:16) nπx
L

(cid:17)

.

Teorema B.3 (Série de Fourier em senos). Considere que f e f (cid:48) são seccionalmente

contínuas no intervalo −L ≤ x < L e que f é uma função periódica ímpar com período

163

2L. Então f tem a série de Fourrier

f (x) =

∞
(cid:88)

n=1

bn sen

(cid:17)

(cid:16)nπx
L

(B.16)

e os coeﬁcientes de Fourier de f são dados por

bn =

2
L

(cid:90) L

0

f (x) sen

(cid:17)

(cid:16)nπx
L

dx, n = 1, 2, 3, ....

(B.17)

Em [BOYCE e DIPRIMA, 2017, p.510], podemos encontrar as demonstrações dos

dois teoremas acima.

Observamos que a função apresentada no exemplo B.3 é uma função ímpar e por

isso sua série de Fourier contém apenas os termos contendo sen

também calcular sua série de Fourrier utilizando a fórmula B.16.

(cid:17)

(cid:16)nπx
L

. Podemos

Em muitas situações práticas, teremos uma função f deﬁnida em um intervalo

0 < x < L e desejaremos calcular a série de Fourier em senos ou em cossenos desta

função. Porém, para calcular uma dessas séries, precisaremos de uma função periódica

par ou ímpar. Nesses casos, podemos usar o recurso de estender a função f a uma

função periódica par ou ímpar.

“Em muitas situações práticas, entretanto, começa-se com uma função

f deﬁnida apenas num intervalo da forma 0 < t < L (...). O primeiro

passo é a necessária extensão de f ao intervalo −L < t < 0. Assegurado

isto, podemos estender f à reta real toda pela condição de periodicidade

f (t + 2L) = f (t)” [EDWARDS e PENNEY, 1995, p.506].

Teremos então:

Deﬁnição B.4. A extensão par de período 2L de f é a função fP , deﬁnida

fP (x) =






f (x),

se 0 ≤ x ≤ L;

f (−x)

se − L < x < 0

e por fP (x + 2L) = fP (x) para todo x.

164

Teremos também:

Deﬁnição B.5. A extensão ímpar de período 2L de f é a função fI, deﬁnida

fI(x) =






f (x),

se 0 < x < L;

0,

se x = 0, L;

−f (−x)

se − L < x < 0

e por fI(x + 2L) = fI(x) para todo x.

B.3 O método de separação de variáveis

Apresentaremos a seguir a solução da equação da onda pelo método de separação de

variáveis. Trata-se de um método que vem sendo utilizado há muito tempo para resol-

ver equações diferenciais. Segundo [BOYCE e DIPRIMA, 2017, p. 516]: “O método

de separação de variáveis é o método sistemático mais antigo, tendo sido usado por

D’Alembert, Daniel Bernoulli e Euler em torno de 1750 em suas investigações sobre

ondas e vibrações”.

Vamos considerar o seguinte problema de valores iniciais e de contorno:

Exemplo B.4. Considere que uma corda encontra-se esticada horizontalmente, com

as extremidades ﬁxas. Pode ser, por exemplo, a corda de um violão ou violino. Essa

corda tem comprimento L. A função u(x, t) irá representar o deslocamento vertical da

corda, na posição x e no instante de tempo t. Assim, a variável x pertence ao intervalo

[0, L]. Vamos considerar o tempo entre os instantes 0 e T , assim a variável t pertence

ao intervalo [0, T ].

Conforme discutimos no início deste capítulo, a função u(x, t) obedece à equação

da onda:

∂2u(x, t)
∂t2

= c2 ∂2u(x, t)

∂x2

para x ∈ (0, L), t ∈ (0, T ]

(B.18)

165

Como as extremidades da corda estão ﬁxas, teremos as seguintes condições de

contorno

u(0, t) = 0 para t ∈ (0, T ],

u(L, t) = 0 para t ∈ (0, T ].

(B.19)

Suponha também que o formato da corda no instante t = 0 é dado pela função

f (x). Assim, teremos a seguinte condição inicial

u(x, 0) = f (x) para x ∈ [0, L].

(B.20)

Além disso, consideramos que a corda encontra-se parada no instante t = 0. Assim,

a velocidade da corda será nula nesse instante, e teremos mais uma condição inicial

para velocidade:

∂u(x, 0)
∂t

= 0 para x ∈ [0, L].

(B.21)

Podemos observar que a solução trivial, u(x, t) = 0, satisfaz à equação diferencial

B.18 e às condições de contorno, mas não satisfaz à condição inicial B.20, exceto no

caso em que f (x) é identicamente nula. Nosso objetivo será encontrar outras soluções,

não nulas, deste problema, ou seja, soluções não triviais.

Para utilizar o método de separação de variáveis, será necessário fazermos uma

hipótese básica sobre a forma da solução. A hipótese é que u(x, t) é um produto de

duas outras funções, uma dependendo só de x e a outra dependendo só de t. Assim,

u(x, t) = X(x)T (t).

(B.22)

Vamos simpliﬁcar a dedução omitindo as variáveis independentes x e t.

Iremos

considerar que a função X depende apenas de x e a função T depende apenas de t.

Substituindo a função u(x, t), dada pela equação B.22, na equação B.18, ﬁcamos

com

c2X (cid:48)(cid:48)T = XT (cid:48)(cid:48)

166

(B.23)

onde X (cid:48)(cid:48) e T (cid:48)(cid:48) são as derivadas em relação à variável independente, seja ela x ou t. A

equação B.23 é equivalente a

X (cid:48)(cid:48)
X

=

1
c2

T (cid:48)(cid:48)
T

,

(B.24)

onde as variáveis estão separadas, ou seja, a expressão à esquerda do sinal de igualdade

depende só de x e a expressão à direita depende só de t.

Observado a equação B.24, chegamos a uma conclusão importante. Como o lado

direito depende somente de x e o lado esquerdo depende somente de t, é necessário

que ambos os lados sejam iguais a uma constante. Caso contrário, um lado poderia

variar independente do outro, e não haveria igualdade. Para ver isso, suponha que

temos a igualdade f (x) = g(y). Se f (x) ou g(y) não forem constantes, essas funções

poderão variar de forma independente e não poderiam ser iguais. Assim, precisaremos

ter f (x) = g(y) = c, onde c é uma constante.

Pensando desta forma, teremos

X (cid:48)(cid:48)
X

=

1
c2

T (cid:48)(cid:48)
T

= −λ.

Escolhemos a constante −λ negativa para facilitar os cálculos.

Da equação B.25, obtemos duas equações diferenciais ordinárias:

e

X (cid:48)(cid:48) + λX = 0,

T (cid:48)(cid:48) + c2λT = 0,

Utilizando a condição de contorno em x = 0, ﬁcamos com

u(0, t) = X(0)T (t) = 0.

(B.25)

(B.26)

(B.27)

Se escolhêssemos T (t) = 0 para todo t, teríamos u(x, t) = 0 para todo x e t.

Como estamos procurando soluções não triviais, iremos rejeitar essa hipótese. Assim,

167

precisaremos ter

De forma análoga, teremos

X(0) = 0.

X(L) = 0.

(B.28)

(B.29)

Observe que a equação B.26, acompanhada das condições de contorno B.28 e B.29

compõem o mesmo problema B.9, que vimos no início deste capítulo. Já vimos que a

solução deste problema é dada pelas autofunções

Xn(x) = sen

(cid:16) nπx
L

(cid:17)

,

n = 1, 2, 3, ....

associadas aos autovalores

λn =

n2π2
L2 ,

n = 1, 2, 3, ....

Podemos agora substituir o valor de λn na equação B.27, ﬁcando com

T (cid:48)(cid:48) +

c2n2π2

L2 T = 0,

Esta equação se enquadra no formato da equação B.4, para o caso em que λ > 0.

A solução é dada por

T (t) = k1 cos

(cid:19)

(cid:18) nπct
L

+ k2 sen

(cid:19)

(cid:18) nπct
L

(B.30)

Utilizando a segunda condição inicial, dada pela equação B.21, vemos que

daí concluímos que

∂u(x, 0)
∂t

= X(x)T (cid:48)(0) = 0,

T (cid:48)(0) = 0.

Derivando a equação B.30, ﬁcamos com

T (cid:48)(t) = −k1

nπc
L

sen

(cid:19)

(cid:18) nπct
L

+ k2

nπc
L

cos

(cid:18)nπct
L

(cid:19)
,

168

assim

T (cid:48)(0) = k2

nπc
L

cos

(cid:19)

(cid:18) nπct
L

= 0,

donde concluímos que k2 = 0.

Assim, ﬁcamos com

Concluímos que as funções

T (t) = k1 cos

(cid:19)

(cid:18) nπct
L

u(x, t) = sen

(cid:17)

(cid:16) nπx
L

cos

(cid:19)

(cid:18) nπct
L

(B.31)

e o produto dessas funções por constantes, satisfazem à equação diferencial B.18, às

condições de contorno B.19 e à segunda condição inicial em B.21.

Vamos então considerar uma sobreposição (soma) de funções, no formato da equa-

ção B.31, multiplicadas por constantes. Teremos, assim:

u(x, t) =

∞
(cid:88)

n=1

bn sen

(cid:17)

(cid:16)nπx
L

cos

(cid:18)nπct
L

(cid:19)
,

(B.32)

onde os bn são constantes.

Para satisfazer à primeira condição inicial, dada pela equação B.20, precisaremos

ter

u(x, 0) =

∞
(cid:88)

n=1

bn sen

(cid:17)

(cid:16)nπx
L

= f (x),

assim precisamos escolher adequadamente as constantes bn, para que a igualdade se

veriﬁque.

Observe que esta é a mesma expressão para a série de Fourier em senos que apre-

sentamos através da equação B.16. Portanto, os coeﬁcientes devem ser o mesmos que

apresentamos para aquela série, através da equação B.17. Só precisamos ter o cuidado

de utilizar a função fI, a extensão ímpar de f , com período 2L. Assim, teremos

bn =

2
L

(cid:90) L

0

fI(x) sen

(cid:16)nπx
L

169

(cid:17)

dx, n = 1, 2, 3, ....

(B.33)

Assim, concluímos que a solução do problema formado pelas equações B.18,B.19,

B.20 e B.21 é dada pela equação B.32, onde os coeﬁcientes são calculados pela equação

B.33.

170

Apêndice C

Códigos de Programação

A seguir apresentamos códigos de programação em linguagem Python para ilustrar os

métodos utilizados no trabalho. Alguns dos programas a seguir foram adaptados a

partir de programas presentes nas referências [LANGTANGEN e LINGE, 2016] e

[LANGTANGEN, 2016].

Exemplo C.1. Código de programação na linguagem Python, para aproximar soluções

para o problema

com a condição inicial

u(cid:48)(t) = u(t) cos t

u(0) = 1

utilizando o método de Euler Progressivo.

import numpy as np

import math

import matplotlib.pyplot as plt

def resolver(I, T, dt):

171

"""

Resolve numericamente u’(t) = u(t)cos(t) para t em [0,T]

com condição inicial u(0)=I,

utilizando o método de Euler Progressivo.

Retorna o vetor u com as soluções aproximadas

e o vetor t com os instantes de tempo

"""

Nt = int(T/dt) # número de intervalos

T = Nt*dt # ajusta T para acomodar o passo de temp dt

u = np.zeros(Nt+1) # array de valores u[n]

t = np.linspace(0, T, Nt+1) # malha de tempo

u[0] = I #atribui condição inicial

for n in range(0, Nt): # n=0,1,...,Nt-1

u[n+1] =u[n]+dt*u[n]*math.cos(t[n])

return u, t

u, t = resolver(1, 8*math.pi, 0.001)

plt.plot(t,u)

plt.grid()

plt.title("Solução aproximada para: u’(t) = u(t) cos t")

plt.show()

Exemplo C.2. Módulo contendo algumas funções para solucionar numericamente sis-

temas de equações diferenciais ordinárias. Salvamos o módulo como edosist.py, para

poder importá-lo e utilizar os métodos numéricos em outros programas.

172

import numpy as np

from numpy.linalg import solve

def resolver_ep(I, A, T, dt):

"""Resolve o sistema u’= A*u, u(0)=I, para t em (0,T] com passos

de tamanho dt, utilizando o método de Euler Progressivo"""

Nt = int(T/dt) # numero de intervalos de tempo

T = Nt*dt # ajusto T para se acomodar ao passo de tempo dt

u = np.zeros((Nt+1,len(I))) # matriz com as solucoes aproximadas

t = np.linspace(0, T, Nt+1) # malha temporal

u[0] = I # condicao inicial

for n in range(0, Nt): # n=0,1,...,Nt-1

u[n+1] = u[n] + dt*(A@u[n])

return u, t

def resolver_er(I, A, T, dt):

"""Resolve o sistema u’= A*u, u(0)=I, para t em (0,T] com passos

de tamanho dt, utilizando o método de Euler Regressivo"""

Id = np.identity(len(I))

Nt = int(T/dt) # numero de intervalos de tempo

T = Nt*dt # ajusto T para se acomodar ao passo de tempo dt

u = np.zeros((Nt+1,len(I))) # matriz com as solucoes aproximadas

t = np.linspace(0, T, Nt+1) # malha temporal

u[0] = I # condicao inicial

for n in range(0, Nt): # n=0,1,...,Nt-1

173

u[n+1] =

solve(Id - dt*A, u[n])

return u, t

def resolver_trap(I, A, T, dt):

"""Resolve o sistema u’= A*u, u(0)=I, para t em (0,T] com passos

de tamanho dt, utilizando o método Trapezoidal"""

Id = np.identity(len(I))

M1 = Id - (dt/2) * A

M2 = Id + (dt/2) * A

Nt = int(T/dt) # numero de intervalos de tempo

T = Nt*dt # ajusto T para se acomodar ao passo de tempo dt

u = np.zeros((Nt+1,len(I))) # matriz com as solucoes aproximadas

t = np.linspace(0, T, Nt+1) # malha temporal

u[0] = I # condicao inicial

for n in range(0, Nt): # n=0,1,...,Nt-1

u[n+1] =

solve(M1,M2 @ u[n])

return u, t

def resolver_pm(I1, I2, A, T, dt):

"""Resolve o sistema u’= A*u, u(0)=I, para t em (0,T] com passos

de tamanho dt, utilizando o método do ponto médio"""

Nt = int(T/dt) # numero de intervalos de tempo

T = Nt*dt # ajusto T para se acomodar ao passo de tempo dt

u = np.zeros((Nt+1,len(I1))) # matriz com as solucoes aproximadas

t = np.linspace(0, T, Nt+1) # malha temporal

174

u[0] = I1 # condicao inicial

u[1] = I2

for n in range(1, Nt): # n=0,1,...,Nt-1

u[n+1] = u[n-1] + ((2 * dt) * A) @ u[n]

return u, t

def resolver_rk_2est(I, A, T, dt):

"""Resolve o sistema u’= A*u, u(0)=I, para t em (0,T] com passos de

tamanho dt, utilizando um método de Runge Kutta de dois estágios"""

Nt = int(T/dt) # numero de intervalos de tempo

T = Nt*dt # ajusto T para se acomodar ao passo de tempo dt

u = np.zeros((Nt+1,len(I))) # matriz com as solucoes aproximadas

t = np.linspace(0, T, Nt+1) # malha temporal

u[0] = I # condicao inicial

for n in range(0, Nt): # n=0,1,...,Nt-1

u[n+1] = u[n] + dt*(A@ (u[n] + 0.5*dt*(A@u[n])))

return u, t

Exemplo C.3. Módulo contendo algumas funções auxiliares para utilização nos pro-

gramas do trabalho. Salvamos o módulo como util.py, para poder importá-lo e utilizar

essas funções em outros programas.

import numpy as np

import matplotlib.pyplot as plt

from mpl_toolkits.mplot3d import Axes3D

from matplotlib.animation import ArtistAnimation

175

def imprimir2D(y,x,tit,arq=None):

’’’Função para imprimir um gráfico em 2 dimensões’’’

fig, ax = plt.subplots( nrows=1, ncols=1 )

ax.plot(x,y)

plt.grid()

plt.title(tit)

plt.show()

if arq is not None:

fig.savefig(arq, bbox_inches=’tight’)

plt.close(fig)

def imprimir3D(u,x,t,tit,arq=None):

’’’Função para imprimir um gráfico em 3 dimensões’’’

mx,mt = np.meshgrid(x,t)

fig = plt.figure()

ax = fig.add_subplot(1,1,1,projection=’3d’)

ax.set_xlabel(’tempo’)

ax.set_ylabel(’espaço’)

ax.plot_surface(mt,mx,u, rstride=1, cstride=1,

cmap=’viridis’, edgecolor=’none’)

ax.set_title(tit);

plt.show()

176

if arq is not None:

fig.savefig(arq, bbox_inches=’tight’)

plt.close(fig)

Exemplo C.4. Código de programação para resolver numericamente o sistema de

equações diferenciais do exemplo 3.10. Observe que estamos importando os módulos

edosist e util, deﬁnidos nos exemplos C.2 e C.3.

import edosist as es

import util as ut

para importar o módulo edosist, deﬁnido no exemplo C.2, e o módulo util, deﬁnido no

exemplo C.3.

import numpy as np

import edosist as es

import util as ut

A = np.array([[-1/10,1/40],[1/10,-1/10]])

I = np.array([60,0])

T = 50

dt = 0.01

u,t = es.resolver_trap(I,A,T,dt)

ut.imprimir2D(u,t,"Solução Numérica pelo Método Trapezoidal")

177

Exemplo C.5. Código de programação para resolver numericamente o sistema de

equações diferenciais do exemplo 3.11. Observe que estamos importando os módulos

edosist e util, deﬁnidos nos exemplos C.2 e C.3.

import numpy as np

import math

import edosist as es

import util as ut

A = np.array([[0,1],[-1,0]])

I = np.array([1,0])

T = 4*math.pi

dt = 0.01

#Para o método do ponto médio, precisamos de dois valores iniciais.

#uso o método trapezoidal para calcular o segundo

u,t = es.resolver_trap(I,A,dt,dt)

u,t = es.resolver_pm(I,u[1],A,T,dt)

ut.imprimir2D(u,t,"Solução Numérica pelo Método do Ponto Médio")

Exemplo C.6. Código de programação na linguagem Python, para aproximar soluções

para o problema do exemplo 4.1, com a seguinte condição inicial:






u(x, 0) = 1 − cos x,

se x ∈ [2π, 4π]

u(x, 0) = 0,

caso contr´ario

178

utilizando o método direto descrito na seção 4.1. Observe que estamos importando o

módulo util, deﬁnido no exemplo C.3.

import numpy as np

import math

import util as ut

def resolver(I, c, L, dt, C, T):

"""

Resolve numericamente o problema:

u_tt=c^2*u_xx

no domínio:

x pertence a (0,L) e t pertence a (0,T].

Sujeita às condições iniciais:

u(x,0)=I(x) e u_t(x,0)=0

E às condições de contorno:

u(0,t)=0 e u(L,t)=0

Recebe o tamanho de passo dt e o número de Courant C.

O espaço de malha dx é calculado usando os valores c e C fornecidos.

"""

Nt = int(round(T/dt))

179

t = np.linspace(0, Nt*dt, Nt+1) # Pontos de malha no tempo

dx = dt*c/float(C)

Nx = int(round(L/dx))

x = np.linspace(0, L, Nx+1) # Pontos de malha no espaço

C2 = C**2 # Variável auxiliar

# Asseguro que dx e dt são compatíveis com x e t

dx = x[1] - x[0]

dt = t[1] - t[0]

u = np.zeros((Nt+1,Nx+1)) # matriz para as solucoes aproximadas

# Carrega condicao inicial

for i in range(0,Nx+1):

u[0,i] =

I(x[i])

# Formula especial para o primeiro passo de tempo

for i in range(1, Nx):

u[1,i] = u[0,i] + \

0.5*C2 * (u[0,i-1] - 2*u[0,i] + u[0,i+1])

#condições de fronteira no passo 1

u[1,0] = 0; u[1,Nx] = 0

for n in range(1, Nt):

# Calcula aproximacoes no instante atual

180

for i in range(1, Nx):

u[n+1,i] = - u[n-1,i] + 2*u[n,i] + \

C2*(u[n,i-1] - 2*u[n,i] + u[n,i+1])

# Insere condicoes de fronteira

u[n+1,0] = 0; u[n+1,Nx] = 0

return u,x,t

#Valores iniciais

def I(x):

if(x>=2*math.pi and x<=4*math.pi):

return 1-math.cos(x)

else:

return 0

c = 2.0

L = 6*math.pi

dt = 0.05

C = 0.9

T = 3

u,x,t = resolver(I, c, L, dt, C, T)

ut.imprimir3D(u,x,t,’Equação da Onda’)

181

Exemplo C.7. Código de programação na linguagem Python, para calcular os erros

cometidos na solução numérica da equação da onda pelo método direto, comparando

com a solução de d’Alembert.

import numpy as np

import math

def resolver(I, c, L, dt, C, T):

"""

Resolve numericamente o problema:

u_tt=c^2*u_xx

no domínio:

x pertence a (0,L) e t pertence a (0,T].

Sujeita às condições iniciais:

u(x,0)=I(x) e u_t(x,0)=0

E às condições de contorno:

u(0,t)=0 e u(L,t)=0

Recebe o tamanho de passo dt e o número de Courant C.

O espaço de malha dx é calculado usando os valores c e C fornecidos.

"""

Nt = int(round(T/dt))

182

t = np.linspace(0, Nt*dt, Nt+1) # Pontos de malha no tempo

dx = dt*abs(c)/float(C)

Nx = int(round(L/dx))

x = np.linspace(0, L, Nx+1) # Pontos de malha no espaço

C2 = C**2 # Variável auxiliar

# Asseguro que dx e dt são compatíveis com x e t

dx = x[1] - x[0]

dt = t[1] - t[0]

u = np.zeros((Nt+1,Nx+1)) # matriz para as solucoes aproximadas

# Carrega condicao inicial

for i in range(0,Nx+1):

u[0,i] =

I(x[i])

# Formula especial para o primeiro passo de tempo

for i in range(1, Nx):

u[1,i] = u[0,i] + \

0.5*C2 * (u[0,i-1] - 2*u[0,i] + u[0,i+1])

#condições de fronteira no passo 1

u[1,0] = 0; u[1,Nx] = 0

for n in range(1, Nt):

# Calcula aproximacoes no instante atual

183

for i in range(1, Nx):

u[n+1,i] = - u[n-1,i] + 2*u[n,i] + \

C2*(u[n,i-1] - 2*u[n,i] + u[n,i+1])

# Insere condicoes de fronteira

u[n+1,0] = 0; u[n+1,Nx] = 0

return u,x,t

#Valores iniciais

def I(x):

if(x>=2*math.pi and x<=4*math.pi):

return 1-math.cos(x)

else:

return 0

#extensão periódica ímpar da função f

def epi(f,x,L):

#calculo xc, o valor correspondente a x, dentro do intervalo [-L,L]

xc = x;

while(xc > L):

xc = xc - 2*L

while(xc < -L):

xc = xc + 2*L

if(xc >= 0):

184

return f(xc)

else:

return -f(-xc)

def imprime_erros(I, c, L, dt, C, T):

u,x,t = resolver(I, c, L, dt, C, T)

#posição final do vetor t, para o último instante de tempo do

#intervalo [0,T]

n = len(t)-1

print()

print("Valores no instante t = %.1f" % T, " para k = %.3f" % dt)

print()

print("x

Sol. Analit. Sol. Num. Erro Abs.")

print("========================================")

# para 10 posições na malha espacial, distribuídas uniformemente no

#intervalo [0,L]

for pos in range(0, 10):

i = int( pos*(len(x)-1)/9 )

# posição i correspondente, na malha

#solução analítica na posição (n,i), pela fórmula de d’Alembert

v = 0.5* epi(I,x[i] - c*t[n],L) + 0.5* epi(I,x[i] + c*t[n],L)

185

#imprimo as soluções e os erros

print(’%6.3f’ % x[i], ’%+1.4e’ % v, ’%+1.4e’ % u[n,i],

’%1.4e’ % abs(v-u[n,i]) )

c = 2.0

L = 6*math.pi

C = 0.9

T = 3

dt = 0.1

imprime_erros(I, c, L, dt, C, T)

dt = 0.01

imprime_erros(I, c, L, dt, C, T)

dt = 0.001

imprime_erros(I, c, L, dt, C, T)

Exemplo C.8. Código de programação para resolver numericamente a equação 6.1

(equação da advecção) acompanhada das seguintes condições iniciais:






u(x, 0) = 1 − cos x,

se x ∈ [2π, 4π]

u(x, 0) = 0,

caso contr´ario

e condições de contorno periódicas. Utilizo o ML com o método Trapezoidal.

import numpy as np

186

import math

import util as ut

import edosist as es

def f(x):

if(x>=2*math.pi and x<=4*math.pi):

return 1-math.cos(x)

else:

return 0

L = 4 * math.pi

T = 1.3

v = -5.0

dt = 0.01

dx = abs(dt*v)

Nx = int(round(L/dx))

x = np.linspace(0, L, Nx+1) # pontos de malha no espaço

# Asseguro que dx é compatível com x

dx = x[1] - x[0]

I = np.zeros(Nx)

#preencho os valores iniciais, sem o primeiro valor,

187

#que corresponde à densidade na fronteira x=0.

#Não utilizo o primeiro valor no cálculo pois a condição de

#fronteira é periódica, e assim os valores das densidades para x=0

#serão iguais àqueles para a fronteira x=L

for i in range(Nx):

I[i]=f(x[i+1])

A = np.zeros((Nx,Nx))

#preencho a matriz

for i in range(Nx):

A[i,(i+1)%(Nx)]=-v/(2*dx)

A[i,(i-1)%(Nx)]=v/(2*dx)

#utilizo o método para problema de valor inicial

u,t = es.resolver_trap(I,A,T,dt)

#obtenho um vetor u0 com os valores da densidade pra a fronteira x=0

#esses valores são iguais aos valores para a fronteira x=L,

# que estão na última coluna de u

u0 = u[:,Nx-1].reshape(len(u),1)

#para a matriz de resultado concateno u0 com a matriz u

#ou seja, concateno com as densidades na fronteira x=0

#que não estava sendo utilizada

188

uf = np.concatenate((u0,u),axis=1)

ut.imprimir3D(uf,x,t,’Equação da Advecção’)

Exemplo C.9. Código de programação para resolver numericamente a equação da

onda utilizando o Método das Linhas (ML). Nesse programa utilizamos o método tra-

pezoidal.

import numpy as np

import math

import edosist as es

import util as ut

#valores iniciais

def f(x):

if(x>=2*math.pi and x<=4*math.pi):

return 1-math.cos(x)

else:

return 0

c = 2.0

L = 6*math.pi

dt = 0.05

C = 0.9

T = 3

dx = dt*c/float(C)

189

Nx = int(round(L/dx))

x = np.linspace(0, L, Nx+1) # Pontos de malha no espaço

#O vetor I conterá os valores iniciais correspondentes à função U_j(t)

#e à função V_j(t), por isso terá dimensão Nx-1.

I = np.zeros(2*(Nx-1))

#preencho os valores iniciais, sem os valores para x=0 e x=L,

#pois não uso os valores de fronteira no cálculo

for i in range(Nx-1):

I[i]=f(x[i+1])

A21 = np.zeros((Nx-1,Nx-1))

#preencho a matriz A21

for i in range(Nx-1):

A21[i,i]=-2*c**2/dx**2

if(i+1 <= Nx-2): A21[i,(i+1)]=c**2/dx**2

if(i-1 >= 0): A21[i,(i-1)]=c**2/dx**2

#crio a matriz do problema

zero = np.zeros((Nx-1,Nx-1))

ident = np.identity(Nx-1)

A1 = np.concatenate((zero,ident),axis=1)

A2 = np.concatenate((A21,zero),axis=1)

190

A = np.concatenate((A1,A2))

#utilizo o método para problema de valor inicial

u,t = es.resolver_trap(I,A,T,dt)

#crio matriz com os valores de fronteira que são todos nulos

f = np.zeros(len(t)).reshape(len(t),1)

#para a matriz de resultado concateno os valores de fronteira

#com as colunas da matriz u que correspondem às funções U_j(t)

#ou seja, sem as colunas que correspondem às funções V_j(t)

uf = np.concatenate((f,u[:,0:Nx-1],f),axis=1)

ut.imprimir3D(uf,x,t,’Equação da Onda’)

Exemplo C.10. Código de programação na linguagem Python, para aproximar solu-

ções para o problema do exemplo 2.10. Estamos considerando L = 10π e T = 3, além

da seguinte condição inicial:

u(x, 0) =






1 − cos x,

se x ∈ [4π, 6π]

= 0,

caso contr´ario

Neste exemplo utilizamos o primeiro método descrito na seção 4.4.

Além disso, estamos considerando que o meio possui duas camadas. A primeira

camada, para x ≤ 3π, possui velocidade de propagação da onda de 2.8 e a segunda

camada, para x > 3, possui velocidade de propagação da onda de 4.5. A função q(x)

retorna o quadrado dessa velocidade.

191

import numpy as np

import math

import util as ut

def resolver(I, fq, L, dx, b, T):

"""

Resolve numericamente o problema:

u_tt=c^2*u_xx

no domínio:

x pertence a (0,L) e t pertence a (0,T].

Sujeita às condições iniciais:

u(x,0)=I(x) e u_t(x,0)=0

E às condições de contorno:

u(0,t)=0 e u(L,t)=0

Em um meio com diversas camadas.

fq é a função que devolve o quadrado da velocidade

de propagação da onda no ponto x.

Recebe o espaço de malha dx

b é um parametro para ajustar o passo dt em função de dx.

b deve ser menor ou igual a 1.

192

"""

Nx = int(round(L/dx))

x = np.linspace(0, L, Nx+1) # Pontos de malha no espaço

q = np.linspace(0, L, Nx+1) #parametros da malha

# Calculo os parametros da malha

for i in range(0,Nx+1):

q[i] = fq(x[i])

#calculo o passo de tempo utilizando o parametro b

dt = b*dx/math.sqrt(q.max())

Nt = int(round(T/dt))

t = np.linspace(0, Nt*dt, Nt+1) # Pontos de malha no tempo

# Asseguro que dx e dt são compatíveis com x e t

dx = x[1] - x[0]

dt = t[1] - t[0]

C2 = (dt/dx)**2

u = np.zeros((Nt+1,Nx+1)) # matriz com as solucoes aproximadas

193

# Carrega condicao inicial

for i in range(0,Nx+1):

u[0,i] = I(x[i])

# Formula especial para o primeiro passo de tempo

for i in range(1, Nx):

u[1,i] = u[0,i] + \

0.5*C2 * (0.5*(q[i+1]+q[i])*(u[0,i+1]-u[0,i]) - \

0.5*(q[i]+q[i-1])*(u[0,i]-u[0,i-1]))

u[1,0] = 0; u[1,Nx] = 0

for n in range(1, Nt):

# Calcula aproximacoes no instante atual

for i in range(1, Nx):

u[n+1,i] = - u[n-1,i] + 2*u[n,i] + \

C2*(0.5*(q[i+1]+q[i])*(u[n,i+1]-u[n,i]) - \

0.5*(q[i]+q[i-1])*(u[n,i]-u[n,i-1]))

# Insere condicoes de fronteira

u[n+1,0] = 0; u[n+1,Nx] = 0

return u,x,t

#Valores iniciais

194

def I(x):

if(x>=4*math.pi and x<=6*math.pi):

return 1-math.cos(x)

else:

return 0

#Parâmetros das camadas.

#Retorna o quadrado da velocidade no ponto x

def fq(x):

c1 = 2.8

c2 = 4.5

if(x<=3*math.pi):

return c1**2

else:

return c2**2

L = 10*math.pi

dx = 0.05

b = 0.9

T = 3.0

u,x,t = resolver(I, fq, L, dx, b, T)

ut.imprimir3D(u,x,t,’Equação da Onda’)

Exemplo C.11. Código de programação na linguagem Python, para aproximar so-

195

luções para o problema do exemplo 2.10, considerando L = 10π e T = 3, além da

seguinte condição inicial:

u(x, 0) =






1 − cos x,

se x ∈ [4π, 6π]

= 0,

caso contr´ario

Neste exemplo utilizamos o Método das Linhas (ML).

Estamos considerando que o meio possui duas camadas. A primeira camada, para

x ≤ 3π, possui velocidade de propagação da onda de 2.8 e a segunda camada, para

x > 3, possui velocidade de propagação da onda de 4.5. A função q(x) retorna o

quadrado dessa velocidade.

import numpy as np

import math

import util as ut

import edosist as es

#valores iniciais

def f(x):

if(x>=4*math.pi and x<=6*math.pi):

return 1-math.cos(x)

else:

return 0

#Parâmetros das camadas.

#Retorna o quadrado da velocidade no ponto x

def fq(x):

c1 = 2.8

196

c2 = 4.5

if(x<=3*math.pi):

return c1**2

else:

return c2**2

L = 10*math.pi

dx = 0.05

b = 0.9

T = 3.0

Nx = int(round(L/dx))

x = np.linspace(0, L, Nx+1) # Pontos de malha no espaço

q = np.linspace(0, L, Nx+1) #parametros da malha

# Calculo os parametros da malha

for i in range(0,Nx+1):

q[i] = fq(x[i])

#calculo o passo de tempo utilizando o parametro b

dt = b*dx/math.sqrt(q.max())

#O vetor I conterá os valores iniciais correspondentes à função U_j(t)

#e à função V_j(t), por isso terá dimensão Nx-1.

197

I = np.zeros(2*(Nx-1))

#preencho os valores iniciais, sem os valores para x=0 e x=L,

#pois não uso os valores de fronteira no cálculo

for i in range(Nx-1):

I[i]=f(x[i+1])

A21 = np.zeros((Nx-1,Nx-1))

#preencho a matriz A21

for i in range(Nx-1):

A21[i,i] = -(q[i]+2*q[i+1]+q[i+2])/(2*dx**2)

if(i+1 <= Nx-2): A21[i,(i+1)] = (q[i+1]+q[i+2])/(2*dx**2)

if(i-1 >= 0): A21[i,(i-1)]=(q[i]+q[i+1])/(2*dx**2)

#crio a matriz do problema

zero = np.zeros((Nx-1,Nx-1))

ident = np.identity(Nx-1)

A1 = np.concatenate((zero,ident),axis=1)

A2 = np.concatenate((A21,zero),axis=1)

A = np.concatenate((A1,A2))

#utilizo o método para problema de valor inicial

u,t = es.resolver_trap(I,A,T,dt)

198

#crio matriz com os valores de fronteira que são todos nulos

f = np.zeros(len(t)).reshape(len(t),1)

#para a matriz de resultado concateno os valores de fronteira

#com as colunas da matriz u que correspondem às funções U_j(t)

#ou seja, sem as colunas que correspondem às funções V_j(t)

uf = np.concatenate((f,u[:,0:Nx-1],f),axis=1)

ut.imprimir3D(uf,x,t,’Equação da Onda’)

199

