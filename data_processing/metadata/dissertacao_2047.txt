Universidade de Brasília
Instituto de Ciências Exatas
Departamento de Matemática
Programa de Mestrado Profissional
em Matemática em Rede Nacional

Avaliação de Algoritmos Ensinados no Ensino
Fundamental e Médio Sob a Perspectiva da
Análise de Complexidade

Bruno Macedo Alves

Brasília

2018

Bruno Macedo Alves

Avaliação de Algoritmos Ensinados no Ensino

Fundamental e Médio Sob a Perspectiva da Análise de

Complexidade

Dissertação apresentada ao Departamento
de Matemática da Universidade de Brasí-
lia, como parte dos requisitos do “Programa”
de Mestrado Profissional em Matemática em
Rede Nacional - PROFMAT, para obtenção
do grau de Mestre.

Universidade de Brasília - UnB

Departamento de Matemática - MAT

PROFMAT - SBM

Orientador: Prof. Dr. Edson Alves da Costa Júnior

Brasília

2018

Posição vertical

Bruno Macedo Alves

Avaliação de Algoritmos Ensinados no Ensino Fundamental e Médio Sob a
Perspectiva da Análise de Complexidade/ Bruno Macedo Alves. – Brasília, 2018-

79 p. : il. (algumas color.) ; 30 cm.

Orientador: Prof. Dr. Edson Alves da Costa Júnior

Dissertação de Mestrado – Universidade de Brasília - UnB
Departamento de Matemática - MAT
PROFMAT - SBM, 2018.
1. Algoritmos. 2. Complexidade. I. Edson Alves da Costa Júnior. II. Universi-
dade de Brasília. III. PROFMAT - SBM. IV. Avaliação de Algoritmos Ensinados
nos Ensinos Fundamental e Médio Sob a Perspectiva da Análise de Complexidade

CDU XYZ 02:141:005.7

Universidade de Brasília
Instituto de Ciências Exatas
Departamento de Matemática

Avaliação de Algoritmos Ensinados no
Ensino Fundamental e Médio Sob a
Perspectiva da Análise de Complexidade

por

Bruno Macedo Alves

Dissertação apresentada ao Departamento de Matemática da Universidade de Brasília,
como parte dos requisitos do “Programa” de Mestrado Profissional em Matemática em
Rede Nacional - PROFMAT, para obtenção do grau de

MESTRE

Brasília, 11 de junho de 2018

Comissão Examinadora:

Prof. Dr. Edson Alves da Costa Júnior- FGA/UnB (Orientador)

Prof. Dr. Vinícius de Carvalho Ríspoli - FGA/UnB (Membro)

Prof. Dr. Fábio Macedo Mendes - FGA/UnB (Membro)

Dedico este trabalho a todos os professores de Matemática que, incansavelmente,
esforçam-se para fazer com que seus alunos aprendam este incrível conhecimento, apesar
de todas as dificuldades.

Agradecimentos

A Deus. Aos meus pais, por terem me ajudado a ser quem sou e por todo o amor
dispendido comigo. À minha esposa Raíza, pela compreensão, suporte e carinho nas horas
em que mais precisei. À minha irmã Carolina, por ter sido sempre uma referência para
mim. Ao meu irmão Marcelo, por ser meu melhor amigo e por ouvir sempre as ideias
que quis colocar neste trabalho. À minha família e amigos, por me darem apoio e ficarem
sempre ao meu lado.

Agradecimentos especiais ao meu orientador, professor Edson, por todo o suporte
dado durante o trabalho com dicas e com soluções geniais para problemas que, sozinho,
eu não conseguiria resolver. Sem sua ajuda não teria terminado este trabalho. Agradeço
também a meus amigos do MAT 2/2004 pelo encorajamento nestes dois árduos anos,
especialmente aos amigos Henrique Zannata, Thiago Wiliams e Matheus Bernardini pelo
tempo gasto me ajudando a resolver problemas relacionados a essa dissertação.

Não posso deixar de mencionar também meus colegas e amigos da turma do PROF-
MAT 2016, que me inspiraram com experiências, modos de agir e pensar, os quais fizeram-
me crescer muito como professor e como estudante de matemática. Agradeço também a
meus professores, os quais abriram minha mente para novas ideias e novos modos de
pensar matemática.

Ao IMPA e à SBM pela iniciativa do PROFMAT. Este curso tem contribuído de

forma significativa para a melhoria do ensino da matemática no Brasil.

Por fim, agradeço ao meu amigo Bruno Henrique por ter disponibilizado seu tempo
e sua casa para me ajudar com os algoritmos contidos neste trabalho, ao Vinícius Ran-
gel, pela disponibilidade para me ajudar com os bugs do sistema, ao professor Julwaity
Quaresma, pela ajuda com as traduções para o inglês e ao Dhiego Loyola pela ajuda com
o Latex.

“Não podemos decidir quando nascemos. Tudo o que podemos decidir é o que fazer com
o tempo que nos é dado. ”
J. R. R. Tolkien

Resumo

Este trabalho faz uma comparação entre algoritmos ensinados na escola para a poten-
ciação, o máximo divisor comum e os determinantes, do ponto de vista da análise de
complexidade. O trabalho busca determinar qual o algoritmo mais eficiente dentre aque-
les comumente apresentados. A análise é feita primeiramente escrevendo os algoritmos em
pseudocódigo, para em seguida descrever o comportamento da função que dá o tempo de
execução do algoritmo em função do tamanho da entrada.

Palavras-chaves: Algoritmos. Complexidade.

Abstract

This work compares the algorithms teached at school to the exponentiation, the greatest
comon divisor and the determinants, from the point of view of the complexity analysis. The
work intends to determine which is the most efficient algorithm among those commonly
presented. The analysis is done by firstly writing the algorithms in a pseudocode, then
describing the behavior of the function that gives the time of execution of the algorithm
based on the input size.

Key-words: Algorithms. Complexity.

Lista de ilustrações

Figura 1 – Algoritmos de potenciação . . . . . . . . . . . . . . . . . . . . . . . . . 53
Figura 2 – Algoritmos de máximo divisor comum . . . . . . . . . . . . . . . . . . 56
Figura 3 – Algoritmos de determinantes . . . . . . . . . . . . . . . . . . . . . . . . 63

Lista de tabelas

Tabela 1 – Coordenadorias Regionais de Ensino (CRE) com maior número de ma-

trículas – Ensino Fundamental II (6o ao 9o ano) . . . . . . . . . . . . . 40

Tabela 2 – Coordenadorias Regionais de Ensino (CRE) com maior número de ma-

trículas – Ensino Médio . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Tabela 3 – Escolas com maior número de matrículas no Ensino Fundamental II –

CRE Ceilândia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Tabela 4 – Escolas com maior número de matrículas no Ensino Fundamental II –

CRE Planaltina . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Tabela 5 – Escolas com maior número de matrículas no Ensino Fundamental II –

CRE Plano Piloto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

Tabela 6 – Escolas com maior número de matrículas no Ensino Médio – CRE

Ceilândia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

Tabela 7 – Escolas com maior número de matrículas no Ensino Médio – CRE

Taguatinga . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

Tabela 8 – Escolas com maior número de matrículas no Ensino Médio - CRE Plano

Piloto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
Tabela 9 – Quantidade de adições do Algoritmo 7 . . . . . . . . . . . . . . . . . . 48
Tabela 10 – Número médio de multiplicações para os Algoritmos 1 e 2 . . . . . . . 52
Tabela 11 – Número médio de divisões para os Algoritmos 3 e 4 . . . . . . . . . . . 55
Tabela 12 – Número médio de multiplicações os Algoritmos 7 e 8 . . . . . . . . . . 62

Sumário

1
1.1
1.2
1.3
1.4

2
2.1
2.2
2.3
2.3.1
2.3.2
2.3.3

3
3.1
3.2
3.3

4

Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

FUNDAMENTAÇÃO TEÓRICA . . . . . . . . . . . . . . . . . . . . 23
Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Análise de Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
Notação Assintótica . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
Conceitos Elementares . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

METODOLOGIA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Escolha dos Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Escolha e Verificação dos Livros Didáticos . . . . . . . . . . . . . . . 39
Problemas Escolhidos
. . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Potenciação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Máximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Determinantes

RESULTADOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
Algoritmos de Potenciação . . . . . . . . . . . . . . . . . . . . . . . . 51
Algoritmos de MDC . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
Algoritmos de Determinantes . . . . . . . . . . . . . . . . . . . . . . . 56

CONSIDERAÇÕES FINAIS . . . . . . . . . . . . . . . . . . . . . . . 65

REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

APÊNDICES

69

A.1
A.2
A.3

APÊNDICE A – ALGORITMOS DOS EXPERIMENTOS . . . . . . 71
Potenciação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
Máximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . . . . 73
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
Determinantes

Introdução

21

O aprendizado de matemática passa pela execução de algoritmos. Desde crian-
ças, aprendemos algoritmos para somar e subtrair, por exemplo. Contudo, durante muito
tempo, as pessoas tem sido ensinadas, de geração em geração, a executarem os mesmos
algoritmos. Mas será que esses algoritmos são os mais eficientes, dentre aqueles que po-
deriam ser ensinados aos estudantes?

Estudando os algoritmos para efetuar uma potenciação com base e expoente natu-
rais, para determinar o máximo divisor comum entre dois números naturais e para calcular
determinantes de matrizes, busca-se avaliar, neste trabalho, a eficiência destes algoritmos.
Será que os professores de matemática tem ensinado os melhores algoritmos que existem,
do ponto de vista da análise de complexidade assintótica?

Por isso, acreditamos que há uma necessidade imediata de rever tais algoritmos
e de propor sugestões de mudanças. Para que isto ocorra, entretanto, temos que fazer
uma análise da complexidade assintótica desses algoritmos. Esta análise descreve o com-
portamento do tempo de execução do algoritmo em função da quantidade de operações
realizadas à medida que o tamanho da entrada aumenta. A entrada varia conforme o pro-
blema: o expoente, no caso da potenciação, o tamanho dos números, no caso do máximo
divisor comum e a dimensão da matriz, no caso do determinante.

Analisando a literatura disponível, encontramos o trabalho de Esquinca (2014).
Neste trabalho, Esquinca analisa a complexidade de diversos algoritmos e os escreve em
pseudocódigo. Contudo, seus objetivos são um pouco diferentes, pois são mais voltados
para a apresentação dos algoritmos e o ensino de programação na escola básica. Nosso
objetivo neste trabalho será o de comparar os algoritmos e verificar, por meios indiretos,
quais os que são comumente adotados nas escolas.

O trabalho busca responder à seguinte pergunta de pesquisa: Os algoritmos en-
sinados no ensino médio e fundamental para o cálculo de potenciações, máximo divisor
comum e determinantes são computacionalmente eficientes?

Objetivos

Este trabalho tem o objetivo de avaliar os algoritmos usualmente ensinados na
escola para o cálculo de potenciações, máximo divisor comum e determinantes, sugerindo,
ao final, que sejam adotados os métodos que forem computacionalmente mais eficiente.

Para isto, iremos fazer um estudo da análise de complexidade assintótica, consul-
tando a literatura básica sobre o assunto. Depois, iremos aplicar os conceitos da análise de

22

Introdução

complexidade assintótica no caso dos algoritmos de potenciações, máximo divisor comum
e determinantes. Em seguida, faremos uma revisão dos livros didáticos comumente ado-
tados no 6a ano do ensino fundamental e no 2o ano do ensino médio para verificar quais
algoritmos são apresentados nestes livros. Por fim, escreveremos os algoritmos em Python
e, por meio de amostras aleatórias, confirmaremos os resultados obtidos na análise.

Estrutura do Trabalho

O trabalho está dividido em 4 capítulos. No Capítulo 1, faz-se uma exposição dos
conceitos teóricos básicos necessários ao entendimento do trabalho. Serão abordados o
conceito de algoritmo, de complexidade assintótica, bem como resultados básicos relacio-
nados à potenciação, ao máximo divisor comum e aos determinantes.

O Capítulo 2 discute a metodologia utilizada para a escolha dos algoritmos e
dos exemplos didáticos abordados ao longo do trabalho. Nele também são apresentados
os algoritmos escolhidos. Após a sua apresentação, faz-se uma análise de complexidade
baseada na contagem das operações e no tempo de execução. O tempo de execução é
considerado constante para cada operação do mesmo tipo, o que simplifica a análise.
Busca-se, portanto, determinar não uma função específica, mas sim uma classe de funções
que represente o tempo de execução de cada algoritmo.

O Capítulo 3 cuida da aplicação dos algoritmos em exemplos de livros didáticos
comumente adotados nos ensinos médio e fundamental e computacionais, com entradas
aleatórias geradas em linguagem Python. Estes exemplos mostram a grande diferença que
faz a escolha por um algoritmo eficiente. Segue-se uma análise das escolhas de algoritmos
feitas no contexto escolar.

O Capítulo 4 apresenta a opinião do autor, respondendo a pergunta de pesquisa

proposta na introdução, a qual defende a escolha pelos algoritmos mais eficientes.

1 Fundamentação Teórica

23

Neste capítulo iremos apresentar os conceitos relacionados a algoritmos. Faremos
também uma breve exposição sobre o uso da notação assintótica no estudo do crescimento
de funções e suas aplicações à análise da eficiência de algoritmos. Na Seção 1.1 estabele-
ceremos o conceito de algoritmo e apresentaremos a linguagem que será utilizada para a
descrição dos mesmos. Na Seção 1.2 trataremos da análise de algoritmos e dos critérios
fundamentais para esta análise. Um desenvolvimento sobre a notação assintótica e seu
uso na análise de algoritmos é feito na Seção 1.3. O capítulo termina com uma revisão
de conceitos e resultados relacionados à potenciação, ao máximo divisor comum e aos
determinantes.

1.1 Algoritmos

Um algoritmo é qualquer procedimento computacional bem definido que toma
algum valor ou conjunto de valores como entrada e produz algum valor ou conjunto de
valores como saída. O valor ou conjunto de valores de entrada é denominado instância
do problema. Por exemplo, um algoritmo que some dois inteiros transforma os valores de
entrada (25, 57) no valor de saída 82, que é o resultado da soma.

Dizemos que um algoritmo é correto se, para toda instância de entrada, ele produzir
a saída correta. Logo, um algoritmo é incorreto se, para uma certa instância, não parar
(um computador pode não concluir um algoritmo ou demorar mais tempo do que estamos
dispostos a esperar) ou se produzir uma resposta incorreta (CORMEN et al., 2012).

Mesmo que um algoritmo esteja correto, é importante analisar o seu desempenho
mediante determinados critérios de eficiência. O motivo para tal análise é que algoritmos
utilizam espaço em memória para armazenar dados enquanto operam, e seus procedimen-
tos levam um determinado intervalo de tempo para serem executados. Ora, a memória
disponível em um computador não é infinita e, tampouco, gratuita. Além disso, não se
pode esperar indefinidamente para que um algoritmo produza a resposta certa para uma
instância de um problema. Daí a importância de se medir a eficiência de um algoritmo,
eficiência esta, em geral, medida pelo seu tempo de execução. Dois algoritmos distin-
tos, mesmo que sejam ambos corretos, podem levar tempos diferentes para resolver uma
mesma instância de um problema.

Ao longo deste trabalho iremos utilizar um pseudocódigo semelhante a algumas
linguagens de programação, como C, Python, Java ou Pascal. Um pseudocódigo é uma
lista de comandos escrita em linguagem comum para descrever um algoritmo, mas que

24

Capítulo 1. Fundamentação Teórica

incorpora algumas das principais funções de uma linguagem de programação padrão, como
as citadas acima. Iremos utilizar as convenções usadas em (CORMEN et al., 2012):

(a) o recuo indica estrutura de bloco. Assim, as linhas de comando dentro de uma
estrutura qualquer devem ter um recuo maior. Uma nova estrutura deve receber um
recuo igual ao que iniciou a estrutura anterior;

(b) os laços for, while, if-else, repeat-until tem a mesma interpretação das lin-

guagens de programação C, C++, Pascal, Java ou Python;

(c) o símbolo = tem o sentido de atribuição. Por exemplo, se escrevemos 𝑖 = 𝑖 + 1

significa que à variável 𝑖 será atribuído o valor 𝑖 + 1;

(d) elementos de um vetor serão acessados especificando-se o nome do vetor, seguido
pelo índice entre colchetes. Por exemplo, 𝐴[𝑖] indica o 𝑖-ésimo elemento do vetor A;

(e) os atributos de um objeto serão indicados por pontos. Por exemplo, 𝐴.𝑛 significa

que o vetor 𝐴 tem 𝑛 elementos;

(f) se um dado valor de saída é nulo ou vazio, usaremos o valor especial NIL.

1.2 Análise de Algoritmos

Analisar um algoritmo significa prever os recursos de que o algoritmo necessita.
Recursos como memória ou hardware podem fazer parte desta análise, mas frequentemente
o tempo de computação é o principal parâmetro considerado. Neste trabalho, iremos uti-
lizar um modelo de computação genérico de máquina com memória de acesso aleatório
(Random Access Machine - RAM) com um único processador como tecnologia de im-
plementação. Além disso, iremos considerar que cada instrução é executada em tempo
constante.

A análise do tempo que um algoritmo leva para ser executado, em geral, depende
do tamanho n da entrada. Para fazer esta análise, contamos o número de operações
primitivas para uma dada entrada de tamanho n. Cada linha no código do algoritmo,
por hipótese, leva um tempo constante para ser executada e o número de vezes em que
a linha é executada é uma função de n. Somando-se o tempo de execução de cada passo,
obtemos o tempo de execução total do algoritmo, o qual, consequentemente, também será
uma função de n.

É fácil ver que o tempo de execução de um algoritmo também depende da instância,
em particular, que está sendo processada. Por exemplo, um algoritmo que ordene um
vetor de números pode levar um tempo menor para ser executado quando a entrada está
parcialmente ordenada do que quando a entrada está completamente desordenada.

1.3. Notação Assintótica

25

Deste modo, a análise de algoritmos contempla o pior caso, o melhor caso e o caso
médio. O pior caso representa a situação na qual o tempo de execução é o maior possível,
e o melhor caso a situação na qual o tempo de execução é o menor possível. Já o caso
médio é definido como a média sobre o número de etapas executadas pelo algoritmo em
cada entrada, ponderadas pela probabilidade de ocorrência de cada entrada (DROZDEK,
2002).

O estudo do pior caso é o mais importante por três motivos: em primeiro lugar,
o tempo de execução do pior caso de um algoritmo estabelece um limite superior para
o tempo de execução de qualquer instância. Conhecê-lo nos dá uma garantia de que
o algoritmo nunca demorará mais do que esse tempo. Em segundo lugar, para alguns
algoritmos, o pior caso ocorre com bastante frequência. Por exemplo, na pesquisa de um
banco de dados em busca de determinada informação, o pior caso do algoritmo de busca
ocorre quando a informação não está presente no banco de dados. Por fim, muitas vezes,
o tempo de execução do caso médio tende a ser igual ao do pior caso.

1.3 Notação Assintótica

Para dar ênfase à ordem de crescimento do tempo de execução de um algoritmo em
função do tamanho da entrada n, iremos estudar a eficiência assintótica dos algoritmos,
ou seja, estaremos preocupados em como o tempo de execução aumenta quando tomamos
o limite desta função com n tendendo a infinito.

Como vimos, o tempo de execução é uma função do tamanho da entrada n. Iremos

considerar que tais funções tem como domínio o conjunto dos números naturais.

Definição 1. (Notação Θ) Dizemos que uma função 𝑓 é Θ(𝑔(𝑛)) se existirem constantes
positivas 𝑐1, 𝑐2 e 𝑛0 tais que 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓 (𝑛) ≤ 𝑐2𝑔(𝑛) para todo 𝑛 > 𝑛0.

Por exemplo, a função definida por 𝑓 (𝑛) = 3𝑛2 − 2 é Θ(𝑛2) pois, dados 𝑐1 = 4 e
𝑐2 = 2, tem-se que 2𝑛2 ≤ 𝑓 (𝑛) ≤ 4𝑛2 para todo 𝑛 ≥ 𝑛0 = 2. Neste caso, cometendo um
abuso de notação, escrevemos 𝑓 (𝑛) = Θ(𝑛2) e lemos 𝑓 é Θ(𝑛2).

Dizer que uma função 𝑓 é Θ(𝑔(𝑛)) significa dizer que, para valores de 𝑛 suficien-
temente grandes, os valores de 𝑓 estarão limitados pelos valores das funções 𝑐1𝑔 e 𝑐2𝑔.
Embora estes valores de 𝑔 dependam das constantes 𝑐1 e 𝑐2 escolhidas, em geral não nos
preocupamos com os valores destas constantes, mas sim com a existência delas.

Definição 2. (Notação 𝑂) Dizemos que 𝑓 é 𝑂(𝑔(𝑛)) se existem constantes positivas 𝑐 e
𝑛0 tais que 0 ≤ 𝑓 (𝑛) ≤ 𝑐𝑔(𝑛) para todo 𝑛 > 𝑛0.

Enquanto a notação Θ(𝑔(𝑛)) dá limites assintóticos acima e abaixo para a função

26

Capítulo 1. Fundamentação Teórica

𝑓 (𝑛), a notação 𝑂(𝑛) dá um limite assintótico superior apenas. Se 𝑓 (𝑛) representar o
tempo de execução de um algoritmo para uma instância de tamanho 𝑛, dizer que 𝑓 (𝑛)
é 𝑂(𝑛2), por exemplo, significa dizer que o tempo de execução do pior caso cresce como
uma função quadrática, isto é, proporcional a 𝑛2.

De modo semelhante, a notação Ω nos dá um limite assintótico inferior para uma

dada função 𝑓 (𝑛).

Definição 3. (Notação Ω) Uma função 𝑓 é dita Ω(𝑔(𝑛)) se existirem constantes positivas
𝑐 e 𝑛0 tais que 0 ≤ 𝑐𝑔(𝑛) ≤ 𝑓 (𝑛) para todo 𝑛 > 𝑛0.

As notações Θ, O e Ω se relacionam por meio do importante teorema a seguir.

Teorema 1. Para quaisquer duas funções 𝑓 (𝑛) e 𝑔(𝑛), temos 𝑓 (𝑛) = Θ(𝑔(𝑛)) se, e
somente se, 𝑓 (𝑛) = 𝑂(𝑔(𝑛)) e 𝑓 (𝑛) = Ω(𝑔(𝑛)).

Demonstração: Suponha que 𝑓 (𝑛) = Θ(𝑔(𝑛)). Isto implica que existem constan-
tes positivas 𝑐1 e 𝑐2 tais que 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓 (𝑛) ≤ 𝑐2𝑔(𝑛). Logo, 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓 (𝑛) e
0 ≤ 𝑓 (𝑛) ≤ 𝑐2𝑔(𝑛), ou seja, 𝑓 (𝑛) = Ω(𝑔(𝑛)) e 𝑓 (𝑛) = 𝑂(𝑔(𝑛)).

Por outro lado, suponha que 𝑓 (𝑛) = 𝑂(𝑔(𝑛)) e 𝑓 (𝑛) = Ω(𝑔(𝑛)). Por definição,
existem constantes positivas 𝑐1 e 𝑐2 tais que 0 ≤ 𝑓 (𝑛) ≤ 𝑐2𝑔(𝑛) e 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓 (𝑛),
respectivamente. Logo, 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓 (𝑛) ≤ 𝑐2𝑔(𝑛), o que mostra que 𝑓 (𝑛) = Θ(𝑔(𝑛)).

(cid:3)

1.4 Conceitos Elementares

Potenciação

A potenciação é a operação que escreve uma multiplicação de fatores iguais de

forma resumida.

Definição 4. (Potenciação) Dados dois números naturais a e n, a expressão 𝑎𝑛 representa
um produto de n fatores iguais a a, ou seja,

𝑎𝑛 = 𝑎 · 𝑎 · . . . · 𝑎

.

⏟

 ⏞
𝑛 fatores

Neste caso, dizemos que a é a base e n é o expoente da potenciação. Além disso, definimos
os casos especiais 𝑎1 = 𝑎 e 𝑎0 = 1.

A Definição 4 nos diz que 74, por exemplo, é igual a 7 × 7 × 7 × 7. Para computar
este número, devemos multiplicar os dois primeiros fatores, obtendo 49. Este resultado

 
1.4. Conceitos Elementares

27

deve ser multiplicado pelo próximo fator, donde se tem 343. Por fim, multiplicamos 343
pelo quarto e último fator, obtendo o resultado 2401.

Algumas propriedades da potenciação são bem conhecidas e estão enumeradas a

seguir.

Proposição 1. Dados os números naturais 𝑎, 𝑏, 𝑚 e 𝑛, temos que

1. 𝑎𝑚 · 𝑎𝑛 = 𝑎𝑚+𝑛

2.

𝑎𝑚
𝑎𝑛 = 𝑎𝑚−𝑛, se 𝑚 ≥ 𝑛

3. (𝑎𝑚)𝑛 = 𝑎𝑚·𝑛

4. 𝑎𝑚 · 𝑏𝑚 = (𝑎 · 𝑏)𝑚

Demonstração

1. 𝑎𝑚 · 𝑎𝑛 =

⎛
⎝𝑎 · 𝑎 · . . . · 𝑎
 ⏞
𝑚 fatores

⏟

⎞
⎠ ·

⎛
⎝𝑎 · 𝑎 · . . . · 𝑎
 ⏞
𝑛 fatores

⏟

⎞
⎠ = 𝑎 · 𝑎 · . . . · 𝑎
 ⏞
𝑚+𝑛 fatores

⏟

= 𝑎𝑚+𝑛.

2. Se 𝑚 ≥ 𝑛, então 𝑎𝑚

𝑎𝑛 =

. Os fatores 𝑎 do denominador cancelarão os

fatores 𝑎 do numerador. Restarão, no máximo, 𝑚 − 𝑛 fatores. Logo,

𝑎 · 𝑎 · . . . · 𝑎
⏟
 ⏞
𝑚 fatores
𝑎 · 𝑎 · . . . · 𝑎
 ⏞
⏟
𝑛 fatores

𝑎𝑚
𝑎𝑛 = 𝑎𝑚−𝑛.

𝑚 + 𝑚 + . . . + 𝑚
 ⏞
⏟
𝑛 parcelas

= 𝑎

= 𝑎𝑚𝑛;

3. (𝑎𝑚)𝑛 = 𝑎𝑚 · 𝑎𝑚 · . . . · · · 𝑎𝑚

⏟

 ⏞
𝑛 fatores

4. 𝑎𝑚 · 𝑏𝑚 = 𝑎 · 𝑎 · . . . · 𝑎
⏟

 ⏞
𝑚 fatores

· 𝑏 · 𝑏 · . . . · 𝑏
 ⏞
⏟
𝑚 fatores

= (𝑎𝑏) · (𝑎𝑏) · . . . · (𝑎𝑏)

= (𝑎𝑏)𝑚.

⏟

 ⏞
𝑚 fatores

(cid:3)

Máximo Divisor Comum

Quando dividimos um número 𝑎 por 𝑏, obtemos um quociente 𝑞 e um resto 𝑟, com
0 ≤ 𝑟 < 𝑞. Sabe-se que, para 𝑎 e 𝑏 quaisquer, com 𝑏 ̸= 0, 𝑞 e 𝑟 existem e são únicos e

 
 
 
 
 
 
 
 
 
 
28

Capítulo 1. Fundamentação Teórica

podemos escrever 𝑎 = 𝑏𝑞 + 𝑟, o que é garantido pelo Teorema 3. Antes de demonstrá-
lo, porém, precisamos do princípio da boa ordenação, uma propriedade fundamental dos
números naturais.

Teorema 2.
possui um menor elemento.

(Princípio da Boa Ordenação) Todo subconjunto dos números naturais

A demonstração foge do escopo deste trabalho e será omitida. Para mais detalhes,

consulte (LIMA, 2007).

Teorema 3. (Divisão Euclidiana) Dados os números naturais 𝑎 e 𝑏, 𝑏 ̸= 0, existem únicos
𝑞 e 𝑟, também naturais, tais que 𝑎 = 𝑏𝑞 + 𝑟, com 0 ≤ 𝑟 < 𝑏.

Demonstração:

(Existência) Se 𝑎 < 𝑏, basta tomar 𝑞 = 0 e 𝑟 = 𝑏. Por outro lado, se 𝑎 = 𝑏, basta

tomar 𝑞 = 1 e 𝑟 = 0. Finalmente, se 𝑎 > 𝑏, considere o conjunto

𝑆 = {𝑥 = 𝑎 − 𝑏𝑞 tais que 𝑎 − 𝑏𝑞 ≥ 0},

o qual está contido no conjunto dos números naturais. Note que 𝑏 − 𝑎 > 0 implica que
𝑆 ̸= ∅. Logo, pelo princípio da boa ordenação, 𝑆 possui um menor elemento, digamos 𝑟.

Por definição, 𝑟 = 𝑎 − 𝑏𝑞 ≥ 0 para algum 𝑞 ∈ N. Afirmamos que 𝑟 < 𝑏 pois,
caso contrário, teríamos 𝑟 = 𝑎 − 𝑏𝑞 ≥ 𝑏, donde 𝑎 − 𝑞(𝑏 + 1) ≥ 0, o que implica que
𝑦 = 𝑎 − 𝑞(𝑏 + 1) ∈ 𝑆. Mas 𝑦 = 𝑎 − 𝑞(𝑏 + 1) < 𝑎 − 𝑏𝑞, o que contradiz o fato de que 𝑟 é o
menor elemento de 𝑆. Portanto, 0 ≤ 𝑟 < 𝑏.

(Unicidade) Se 𝑎 = 𝑏𝑞1 + 𝑟1 e 𝑎 = 𝑏𝑞2 + 𝑟2, com 0 ≤ 𝑟1, 𝑟2 < 𝑏, então

𝑏𝑞1 + 𝑟1 = 𝑏𝑞2 + 𝑟2

𝑏(𝑞1 − 𝑞2) = 𝑟2 − 𝑟1

Sendo assim, 𝑟2 − 𝑟1 é múltiplo de 𝑏. Mas, como |𝑟2 − 𝑟1| < 𝑏, o único valor que 𝑟2 − 𝑟1
pode assumir é zero. Logo, 𝑟2 = 𝑟1, donde segue que 𝑞2 = 𝑞1

(cid:3)

Um dos conceitos centrais da divisão é o de máximo divisor comum de dois números
ou, abreviadamente, MDC. O máximo divisor comum nos é apresentado no 6o ano do
ensino fundamental. Na escola, este conceito é utilizado na simplificação de frações ou de
equações.

Definição 5. (Máximo Divisor Comum) Dados dois números naturais 𝑎 e 𝑏, dizemos que
o número natural 𝑑 é o máximo divisor comum (MDC) entre 𝑎 e 𝑏 se:

1.4. Conceitos Elementares

29

1. 𝑑|𝑎 e 𝑑|𝑏

2. se 𝑚 ∈ N é tal que 𝑚|𝑎 e 𝑚|𝑏, então 𝑚|𝑑.

A primeira propriedade da Definição 5 diz que, para um número 𝑑 ser o MDC
entre 𝑎 e 𝑏, 𝑑 tem que dividir 𝑎 e 𝑏, isto é, ser um divisor comum de 𝑎 e 𝑏. A segunda
propriedade diz que qualquer divisor comum de 𝑎 e 𝑏 divide o MDC, ou seja, o MDC é o
maior dentre os divisores comuns.

Por exemplo, o MDC entre 12 e 8 é 4, pois 4 é divisor comum entre 12 e 8 e

qualquer outro divisor comum positivo entre 12 e 8 (no caso, 1 e 2) divide 4.

Apresentamos, no Teorema 4, um importante resultado acerca da divisão entre

dois números naturais.

Teorema 4. Sejam 𝑎 e 𝑏 dois números naturais com 𝑎 ≥ 𝑏 > 0. Se 𝑎 = 𝑏𝑞 + 𝑟, com 𝑞,
𝑟 ∈ N e 0 ≤ 𝑟 < 𝑏, então 𝑟 <

.

𝑎
2

Demonstração:

Consideremos dois casos: 𝑎 < 2𝑏 e 𝑎 ≥ 2𝑏. No primeiro caso, se 𝑎 ≥ 2𝑏, temos que
.

. Como, por hipótese, 𝑟 < 𝑏, então 𝑟 <

𝑎
2

𝑏 ≤

𝑎
2

𝑟 ∈ N. Como 𝑎 < 2𝑏, segue que 𝑞 = 1. Logo, 𝑟 = 𝑎 − 𝑏. Observe que 𝑎 < 2𝑏 ⇒ 𝑏 >

No segundo caso, se 𝑎 < 2𝑏 então, por hipótese, 𝑎 = 𝑏𝑞 +𝑟, onde 𝑞 ∈ N e 0 ≤ 𝑟 < 𝑏,
𝑎
.
2

Portanto, 𝑟 = 𝑎 − 𝑏 < 𝑎 −

=

𝑎
2

𝑎
2

(cid:3)

Muitas vezes, nos preocupamos apenas com o resto da divisão de um número

natural por outro. A Definição 6 apresenta o conceito de congruência módulo 𝑛.

Definição 6. Dados os números naturais 𝑎, 𝑏 e 𝑛, dizemos que 𝑎 é congruente a 𝑏 módulo
𝑛 se a divisão de 𝑎 por 𝑛 deixa resto 𝑏. Neste caso, escrevemos 𝑎 ≡ 𝑏 mod 𝑛.

Outro importante conceito da Teoria dos Números é o de número primo. Os nú-

meros primos formam a base multiplicativa dos números naturais.

Definição 7.
dois divisores positivos distintos.

(Número primo) Um número natural é dito primo se possui exatamente

Os números primos se distribuem irregularmente no conjunto dos números natu-
rais. Até o presente momento, não foi descoberto um padrão para essa distribuição, mas
existem ferramentas que nos ajudam a entender melhor seu comportamento. Embora haja

30

Capítulo 1. Fundamentação Teórica

infinitos números primos (GONçALVES, 2006), podemos usar uma função para contar a
quantidade de primos menores que ou iguais a um número natural dado.

Definição 8. Denotamos por 𝜋(𝑛) a quantidade de números primos menores ou iguais
ao número natural 𝑛.

Determinante

Conceito central da álgebra linear, os determinantes desempenham papel funda-
mental quando queremos analisar a existência de soluções de um sistema linear, bem como
a determinação de tais soluções. A todo sistema está associada uma matriz.

Definição 9.
colunas.

(Matriz) Uma matriz é uma tabela de elementos dispostos em linhas e

Um elemento qualquer de uma matriz 𝐴 ocupa uma posição em uma linha e em
uma coluna. Denotaremos o elemento da linha 𝑖 e coluna 𝑗 por 𝑎𝑖𝑗. Quando uma matriz 𝐴
possui o mesmo número 𝑛 de linhas e de colunas, dizemos que 𝐴 é uma matriz quadrada de
ordem 𝑛. Uma matriz que possua apenas uma linha é chamada vetor-linha. Analogamente,
uma matriz que possua apenas uma coluna é chamada vetor-coluna.

Um tipo especial de matriz é a matriz identidade, representada pela letra 𝐼. Esta
consiste de uma matriz quadrada na qual todos os elementos da diagonal principal são
iguais a 1 e todos os elementos restantes são iguais a zero. Uma matriz identidade que
possua 𝑛 linhas e 𝑛 colunas é chamada matriz identidade de ordem 𝑛 e representada por
𝐼𝑛. A toda matriz quadrada está associado um número, chamado determinante da matriz.
A Definição 10 foi extraída de (STRANG, 2010).

Definição 10. (Determinante) Dada uma matriz quadrada 𝐴𝑛×𝑛, o determinante de A
é um número real que satisfaz as seguintes propriedades:

1. o determinante da matriz identidade 𝐼 é igual a 1;

2. o sinal do determinante de uma matriz muda quando há uma troca de linhas;

3. o determinante de uma matriz é linear em cada linha separadamente.

A propriedade 3 da Definição 10 pode ser descrita em duas partes:

(a) det

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 + 𝑏11 𝑎12 + 𝑏12

𝑎21
...
𝑎𝑛1

𝑎22
...
𝑎𝑛2

. . . 𝑎1𝑛 + 𝑏1𝑛
. . .
. . .
. . .

𝑎2𝑛
...
𝑎𝑛𝑛

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎠

1.4. Conceitos Elementares

31

⎛

⎞

⎛

⎞

+ det

= det

⎜
⎜
⎜
⎜
⎜
⎜
⎝

⎟
⎟
⎟
⎟
⎟
⎟
⎠

⎜
⎜
⎜
⎜
⎜
⎜
⎝

. . . 𝑎1𝑛
. . . 𝑎2𝑛
...
. . .
. . . 𝑎𝑛𝑛

𝑎11 𝑎12
𝑎21 𝑎22
...
...
𝑎𝑛1 𝑎𝑛2

𝑏11
𝑏12
𝑎21 𝑎22
...
...
𝑎𝑛1 𝑎𝑛2
ou seja, somando-se um vetor linha à primeira linha de uma matriz, o seu deter-
minante será igual à soma do determinante da matriz original com o determinante
da matriz obtida pela substituição da primeira linha da matriz original pelo vetor
linha, mantendo-se as demais linhas inalteradas.

. . .
𝑏1𝑛
. . . 𝑎2𝑛
...
. . .
. . . 𝑎𝑛𝑛

⎟
⎟
⎟
⎟
⎟
⎟
⎠

,

(b) det

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11
𝑎21
...
𝑐𝑎𝑖1
...
𝑎𝑛1

𝑎12
𝑎22
...
𝑐𝑎𝑖2
...
𝑎𝑛2

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

. . . 𝑎1𝑛
. . . 𝑎2𝑛
...
. . .
. . . 𝑐𝑎𝑖𝑛
...
. . .
. . . 𝑎𝑛𝑛

= 𝑐 · det

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11
𝑎21
...
𝑐𝑎𝑖1
...
𝑎𝑛1

𝑎12
𝑎22
...
𝑐𝑎𝑖2
...
𝑎𝑛2

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
,
⎟
⎟
⎟
⎟
⎟
⎟
⎠

. . . 𝑎1𝑛
. . . 𝑎2𝑛
...
. . .
. . . 𝑐𝑎𝑖𝑛
...
. . .
. . . 𝑎𝑛𝑛

isto é, multiplicar uma das linhas de uma matriz por um número real 𝑐 implica que
o seu determinante é igual a 𝑐 vezes o determinante da matriz original.

Observe que uma consequência imediata da parte (b) acima é que, se uma matriz

possui uma linha nula, então seu determinante é igual a zero.

Algumas fórmulas para o cálculo de determinantes são bem conhecidas, como é o

caso dos determinantes de matrizes 2 × 2.

Teorema 5. (Determinante de matrizes 2 × 2) Dada uma matriz

𝐴 =

temos que det 𝐴 = 𝑎𝑑 − 𝑏𝑐

⎛

⎝

𝑎 𝑏
𝑐 𝑑

⎞
⎠ ,

Demonstração: Para comprovar isto, vamos verificar as 3 propriedades da defi-

nição de determinantes:

1. Para a matriz 𝐼 =

1 é válida.

⎛

⎝

1 0
0 1

⎞
⎠, temos que det 𝐼 = 1·1−0·0 = 1. Portanto, a propriedade

2. Caso as linhas sejam trocadas, obteremos a matriz 𝐵 =

⎛

⎝

𝑐 𝑑
𝑎 𝑏

⎞
⎠. Seu determinante

será

det 𝐵 = 𝑐𝑏 − 𝑎𝑑 = −(𝑎𝑑 − 𝑏𝑐) = − det 𝐴

3. Vamos verificar que o determinante é linear na 1a linha.

32

Capítulo 1. Fundamentação Teórica

a) det

⎛

⎝

𝑎 + 𝑒 𝑏 + 𝑓

𝑐

𝑑

⎞
⎠ = (𝑎 + 𝑒)𝑑 − (𝑏 + 𝑓 )𝑐

= 𝑎𝑑 − 𝑏𝑐 + 𝑒𝑑 − 𝑐𝑓 = det

⎛

⎝

⎞
⎠ + det

𝑎 𝑏
𝑐 𝑑

⎛

⎝

𝑒 𝑓
𝑐 𝑑

⎞

⎠

b) det

⎛

⎝

𝑘𝑎 𝑘𝑏
𝑑
𝑐

⎞
⎠ = 𝑘𝑎𝑑 − 𝑘𝑏𝑐 = 𝑘(𝑎𝑑 − 𝑏𝑐) = 𝑘 · det

⎛

⎝

⎞

⎠

𝑎 𝑏
𝑐 𝑑

O caso de determinantes de matrizes 3 × 3 é apresentado no Teorema 6.

(cid:3)

Teorema 6. (Regra de Sarrus) Dada uma matriz 𝐴 =

⎛

⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

⎞

⎟
⎟
⎟
⎠

, temos que

det 𝐴 = 𝑎11𝑎22𝑎33 + 𝑎12𝑎23𝑎31 + 𝑎13𝑎21𝑎32 − 𝑎31𝑎22𝑎13 − 𝑎32𝑎23𝑎11 − 𝑎33𝑎21𝑎12.

Demonstração: De fato,

1. det 𝐼 = det

⎛

⎜
⎜
⎜
⎝

2. Dada a matriz

⎞

⎟
⎟
⎟
⎠

1 0 0
0 1 0
0 0 1

= 1 · 1 · 1 + 0 · 0 · 0 + 0 · 0 · 0 − 0 · 1 · 0 − 0 · 0 · 1 − 1 · 0 · 0 = 1.

𝐴 =

⎛

⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

⎞

⎟
⎟
⎟
⎠

,

há 3! = 6 maneiras de permutar as suas linhas. Vamos permutar a primeira linha
com a segunda. Os outros casos são análogos.

det 𝐴 = 𝑎21𝑎12𝑎33 + 𝑎22𝑎13𝑎31 + 𝑎23𝑎11𝑎32 − 𝑎31𝑎12𝑎23 − 𝑎32𝑎13𝑎21 − 𝑎33𝑎11𝑎22

= −(𝑎11𝑎22𝑎33 + 𝑎12𝑎23𝑎31 + 𝑎13𝑎21𝑎32 − 𝑎31𝑎22𝑎13 − 𝑎32𝑎23𝑎11 − 𝑎33𝑎21𝑎12)

= − det 𝐴,

ou seja, o determinante da matriz 𝐴 muda de sinal quando trocamos duas linhas.

3. Provemos agora a linearidade do determinante com relação à primeira linha. Seja

⎛

⎜
⎜
⎜
⎝

𝑎11 + 𝑏 𝑎12 + 𝑐 𝑎13 + 𝑑
𝑎22
𝑎32

𝑎21
𝑎31

𝑎23
𝑎33

⎞

⎟
⎟
⎟
⎠

𝐵 =

Daí,

1.4. Conceitos Elementares

33

a)

det 𝐵 = (𝑎11 + 𝑏)𝑎22𝑎33 + (𝑎12 + 𝑐)𝑎23𝑎31 + (𝑎13 + 𝑑)𝑎21𝑎32

− 𝑎31𝑎22(𝑎13 + 𝑑) − 𝑎32𝑎23(𝑎11 + 𝑏) − 𝑎33𝑎21(𝑎12 + 𝑐)

= (𝑎11𝑎22𝑎33 + 𝑎12𝑎23𝑎31 + 𝑎13𝑎21𝑎32 − 𝑎31𝑎22𝑎13 − 𝑎32𝑎23𝑎11 − 𝑎33𝑎21𝑎12)

+ (𝑏𝑎22𝑎33 + 𝑐𝑎23𝑎31 + 𝑑𝑎21𝑎32 − 𝑎31𝑎22𝑑 − 𝑎32𝑎23𝑏 − 𝑎33𝑎21𝑐)
⎛

⎞

⎞

⎛

= det

⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

⎟
⎟
⎟
⎠

+ det

⎜
⎜
⎜
⎝

𝑏
𝑑
𝑐
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

.

⎟
⎟
⎟
⎠

b) det

⎛

⎜
⎜
⎜
⎝

𝑘𝑎11 𝑘𝑎12 𝑘𝑎13
𝑎23
𝑎22
𝑎21
𝑎33
𝑎32
𝑎31

⎞

⎟
⎟
⎟
⎠

= 𝑘𝑎11𝑎22𝑎33 + 𝑘𝑎12𝑎23𝑎31 + 𝑘𝑎13𝑎21𝑎32 − 𝑎31𝑎22𝑘𝑎13 − 𝑎32𝑎23𝑘𝑎11 − 𝑎33𝑎21𝑘𝑎12

= 𝑘(𝑎11𝑎22𝑎33 + 𝑎12𝑎23𝑎31 + 𝑎13𝑎21𝑎32 − 𝑎31𝑎22𝑎13 − 𝑎32𝑎23𝑎11 − 𝑎33𝑎21𝑎12)

= 𝑘 · det

⎜
⎜
⎜
⎝

⎛

⎞

𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

⎟
⎟
.
⎟
⎠

(cid:3)

Para o cálculo de determinantes de matrizes de ordens superiores, utiliza-se o
Teorema 7, enunciado e demonstrado por Laplace. Contudo, é necessário antes algumas
definições.

Definição 11. Seja 𝐴𝑛×𝑛. Seja 𝑀𝑖𝑗 a submatriz (𝑛−1)×(𝑛−1) obtida pela eliminação da
𝑖-ésima linha e da 𝑗-ésima coluna de A. O determinante de 𝑀𝑖𝑗 é chamado determinante
menor de 𝑎𝑖𝑗. O cofator 𝑏𝑖𝑗 de 𝑎𝑖𝑗 é definido como

𝑏𝑖𝑗 = (−1)𝑖+𝑗 · det(𝑀𝑖𝑗)

Teorema 7. (Laplace) Seja 𝐴 uma matriz 𝑛×𝑛. Então, para cada linha 𝑖, com 1 ≤ 𝑖 ≤ 𝑛,
temos:

det 𝐴 = 𝑎𝑖1𝑏𝑖1 + 𝑎𝑖2𝑏𝑖2 + · · · 𝑎𝑖𝑛𝑏𝑖𝑛,

ou ainda, para cada coluna 𝑗, com 1 ≤ 𝑗 ≤ 𝑛,

det 𝐴 = 𝑎1𝑗𝑏1𝑗 + 𝑎2𝑗𝑏2𝑗 + · · · 𝑎𝑛𝑗𝑏𝑛𝑗.

A demonstração foge do escopo deste trabalho e será omitida.

34

Capítulo 1. Fundamentação Teórica

Existe um outro método para calcular determinantes de ordens superiores. Este
método, atribuído a Gauss, se baseia no escalonamento de matrizes. Diz-se que uma matriz
está na forma escalonada reduzida por linhas quando ela cumpre os critérios da Definição
12.

Definição 12.
forma escalonada reduzida por linhas se ela satisfaz as seguintes propriedades:

(Forma Escalonada Reduzida por Linhas) Uma matriz 𝐴𝑚×𝑛 está na

1. todas as linhas nulas, se existirem, ocorrem abaixo de todas as linhas não-nulas;

2. o primeiro elemento diferente de zero a partir da esquerda de uma linha não-nula é

igual a 1. Este elemento é chamado de um inicial desta linha;

3. para cada linha não-nula, o um inicial aparece à direita e abaixo dos uns iniciais das

linhas precedentes;

4. se uma coluna contém o um inicial, então todos os outros elementos naquela coluna

são iguais a zero.

Para transformar uma matriz qualquer em uma matriz escalonada reduzida por

linhas, fazemos uso de operações elementares.

Definição 13. Uma operação elementar nas linhas de uma matriz 𝐴𝑚×𝑛 é uma das
seguintes operações:

1. permuta de duas linhas de 𝐴;

2. multiplicação de uma linha de 𝐴 por uma constante real não-nula;

3. adição de 𝑚 vezes a 𝑖-ésima linha de 𝐴 à 𝑗-ésima linha de 𝐴;

Outra definição importante é a de equivalência de duas matrizes com relação a

estas operações elementares.

Definição 14. (Equivalência por Linhas) Dizemos que uma matriz 𝐴𝑚×𝑛 é equivalente
por linhas a uma matriz 𝐵𝑚×𝑛 quando 𝐵 pode ser obtida aplicando-se uma sequência
finita de operações elementares nas linhas de 𝐴.

As matrizes escalonadas reduzidas por linhas fazem parte de uma classe mais geral

de matrizes, chamada matrizes triangulares.

Definição 15. (Matriz Triangular) Uma matriz triangular superior é uma matriz na qual
todos os elementos abaixo da diagonal principal são iguais a zero. Analogamente, chama-

1.4. Conceitos Elementares

35

se matriz triangular inferior a qualquer matriz na qual os elementos acima da diagonal
principal sejam iguais a zero.

É sempre possível transformar uma dada matriz em uma matriz triangular. Isto é

garantido pelo Teorema 8.

Teorema 8. Toda matriz é equivalente por linhas a uma matriz triangular.

Demonstração: Mostraremos como transformar uma matriz em uma matriz tri-

angular superior. O caso de matriz triangular inferior é análogo. Dada uma matriz

𝐴 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎12
𝑎11
𝑎22
𝑎21
...
...
𝑎𝑚1 𝑎𝑚2

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎠

,

· · · 𝑎1𝑛
· · · 𝑎2𝑛
...
. . .
· · · 𝑎𝑚𝑛

temos que transformá-la em uma matriz escalonada reduzida fazendo uso apenas de ope-
rações elementares.

Começamos identificando o primeiro elemento não-nulo da primeira coluna. Tal
elemento é chamado pivô. Encontrado tal elemento, permutamos a linha onde ele se
encontra com a primeira.

Assim, sem perda de generalidade, suponhamos que a permuta já foi realizada e
que o elemento 𝑎11 é não-nulo. Temos que fazer com que todos os elementos abaixo dele
na primeira coluna sejam iguais a zero. Isto pode ser feito substituindo-se, para todo
𝑎𝑖1
2 ≤ 𝑖 ≤ 𝑛, cada elemento 𝑎𝑖𝑗 por 𝑎𝑖𝑗 − 𝑎1𝑗 ·
, com 1 ≤ 𝑗 ≤ 𝑛. Após fazer esta operação,
𝑎11
o primeiro elemento da 𝑟-ésima linha será zero, para todo 2 ≤ 𝑟 ≤ 𝑛. Chegamos a uma
nova matriz

𝐵 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 𝑎12
𝑏22
0
...
...
𝑏𝑚2
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · · 𝑎1𝑛
𝑏2𝑛
· · ·
...
. . .
𝑏𝑚𝑛
· · ·

Agora, olhando apenas da segunda linha em diante, identificamos o primeiro ele-
mento não-nulo da segunda coluna, o qual será o novo pivô. Caso ele não esteja na segunda
linha, permutamos a linha onde ele se encontra com a segunda. Em seguida, para todo

3 ≤ 𝑖 ≤ 𝑛 cada elemento 𝑏𝑖𝑗 será substituído por 𝑏𝑖𝑗 − 𝑏2𝑗
fazer esta operação, o segundo elemento da 𝑝-ésima linha será zero para todo 3 ≤ 𝑝 ≤ 𝑛.

, com 2 ≤ 𝑗 ≤ 𝑛. Após

𝑏𝑖2
𝑏22

36

Capítulo 1. Fundamentação Teórica

Chegamos, portanto, a uma nova matriz

𝐶 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑏23
𝑏22
0
𝑐33
0
0
...
...
...
𝑐𝑚3
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · · 𝑎1𝑛
𝑏2𝑛
· · ·
𝑐3𝑛
· · ·
...
. . .
𝑏𝑚𝑛
· · ·

Repetindo este processo para todas as linhas restantes, chegamos à matriz

𝑇 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑏23
𝑏22
0
𝑐33
0
0
...
...
...
0
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · · 𝑎1𝑛
𝑏2𝑛
· · ·
𝑐3𝑛
· · ·
...
. . .
𝑡𝑛𝑛
· · ·

,

que é uma matriz triangular superior, obtida de 𝐴 apenas por meio de operações elemen-
tares.

(cid:3)

O processo descrito na demonstração do Teorema 8 é conhecido como método de

escalonamento de Gauss-Jordan.

Após a matriz ser transformada em uma matriz triangular superior, o determi-
nante será dado pelo produto dos elementos da diagonal principal, o que é garantido pelo
Teorema 9.

Teorema 9. O determinante de uma matriz triangular é igual ao produto dos elementos
da diagonal principal.

Demonstração: Vamos verificar que as três propriedades da definição de deter-

minantes são satisfeitas.

1. Na matriz identidade

𝐼𝑛 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

1 0 0 · · · 0
0 1 0 · · · 0
0 0 1 · · · 0
...
...
...
0 0 0 · · · 1

. . .

...

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

,

todos os elementos da diagonal principal são iguais a 1. Portanto, det 𝐼𝑛 = 1.

1.4. Conceitos Elementares

37

2. Considere uma matriz triangular

𝑇 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎22 𝑎23
0
𝑎33
0
0
...
...
...
0
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · · 𝑎1𝑛
· · · 𝑎2𝑛
· · · 𝑎3𝑛
...
. . .
· · · 𝑎𝑛𝑛

.

Sem perda de generalidade, vamos permutar as linhas 1 e 2. Os outros casos

são análogos. Após a permuta, obtemos a matriz

𝑇1 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

0
𝑎22 𝑎23
𝑎11 𝑎12 𝑎13
𝑎33
0
0
...
...
...
0
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · · 𝑎2𝑛
· · · 𝑎1𝑛
· · · 𝑎3𝑛
...
. . .
· · · 𝑎𝑛𝑛

Substituindo cada elemento 𝑎1𝑗 por 𝑎1𝑗 − 𝑎2𝑗, temos:

𝑇2 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

−𝑎11 𝑎22 − 𝑎12 𝑎23 − 𝑎13
𝑎11
0
...
0

𝑎13
𝑎33
...
0

𝑎12
0
...
0

· · · 𝑎2𝑛 − 𝑎1𝑛
· · ·
· · ·
. . .
· · ·

𝑎1𝑛
𝑎3𝑛
...
𝑎𝑛𝑛

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

Agora, somamos a primeira linha à segunda, substituindo cada elemento 𝑎2𝑗

por 𝑎2𝑗 + 𝑎1𝑗, donde obtém-se a matriz

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑇3 =

−𝑎11 𝑎22 − 𝑎12 𝑎23 − 𝑎13

0
0
...
0

𝑎22
0
...
0

𝑎23
𝑎33
...
0

· · · 𝑎2𝑛 − 𝑎1𝑛
· · ·
· · ·
. . .
· · ·

𝑎2𝑛
𝑎3𝑛
...
𝑎𝑛𝑛

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

A matriz 𝑇3 é uma matriz triangular superior. Seu determinante é dado por:

det 𝑇3 = −𝑎11𝑎22𝑎33 · · · 𝑎𝑛𝑛 = − det 𝑇

38

Capítulo 1. Fundamentação Teórica

3. Somando o vetor

(︁

𝑏11

𝑏12

· · ·

𝑏1𝑛

)︁

à matriz T, obtemos a matriz

𝑇1 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 + 𝑏11 𝑎12 + 𝑏12 𝑎13 + 𝑏13
𝑎22
0
...
0

𝑎23
𝑎33
...
0

0
0
...
0

· · · 𝑎1𝑛 + 𝑏1𝑛
· · ·
· · ·
. . .
· · ·

𝑎2𝑛
𝑎3𝑛
...
𝑎𝑛𝑛

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

𝑇1 é uma matriz triangular superior. Seu determinante é dado por:

det 𝑇1 = (𝑎11 + 𝑏11)𝑎22 · · · 𝑎𝑛𝑛 = 𝑎11𝑎22 · · · 𝑎𝑛𝑛 + 𝑏11𝑎22 · · · 𝑎𝑛𝑛

= det

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎22 𝑎23
0
𝑎33
0
0
...
...
...
0
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · · 𝑎1𝑛
· · · 𝑎2𝑛
· · · 𝑎3𝑛
...
. . .
· · · 𝑎𝑛𝑛

+ det

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑏11
0
0
...
0

𝑏13
𝑏12
𝑎22 𝑎23
𝑎33
0
...
...
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

𝑏1𝑛
· · ·
· · · 𝑎2𝑛
· · · 𝑎3𝑛
...
. . .
· · · 𝑎𝑛𝑛

Multiplicando-se a 𝑟-ésima linha de 𝑇 por uma constante 𝑘, obtemos a matriz

triangular superior

𝑇2 =

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎14
𝑎22 𝑎23
0
𝑎24
...
...
...
...
· · · 𝑘𝑎𝑟𝑟
0
0
...
...
...
...
· · ·
0
0
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

· · ·
𝑎1𝑛
· · ·
𝑎2𝑛
...
. . .
· · · 𝑘𝑎𝑟𝑛
...
. . .
𝑎𝑛𝑛
· · ·

donde det 𝑇2 = 𝑎11𝑎22 · · · 𝑘𝑎𝑟𝑟 · · · 𝑎𝑛𝑛 = 𝑘 · det 𝑇2

(cid:3)

2 Metodologia

39

Neste capítulo iremos descrever a metodologia utilizada para a escolha dos algo-
ritmos a serem analisados, para a escolha dos livros didáticos e para a implementação dos
algoritmos, bem como a contagem das operações.

2.1 Escolha dos Algoritmos

Os problemas escolhidos foram o do cálculo de potências com expoente natural, o
do cálculo do máximo divisor comum de dois números naturais e o do cálculo de determi-
nantes de matrizes 𝑛 × 𝑛. A escolha desses problemas se deu pelo fato de existirem mais
de um algoritmo com uso difundido entre professores e alunos para a solução dos mesmos.
O trabalho tem como objetivo, em primeiro lugar, a comparação entre esses algoritmos do
ponto de vista da análise de complexidade assintótica. Logo, não seria possível fazer esta
comparação no caso de haver somente um algoritmo para a resolução de um problema.

No caso da potenciação, há dois algoritmos amplamente utilizados: o da potencia-
ção por definição e o da potenciação por meio de divisão e conquista. Já para o problema
do máximo divisor comum, utiliza-se o algoritmo por decomposição em fatores primos ou
o algoritmo de Euclides. Por fim, para o cálculo de determinantes, em geral, aprendemos
na escola a utilizar fórmulas fechadas para os casos de matrizes 2 × 2 e 3 × 3 (regra de
Sarrus). Já para determinantes de ordens superiores, comumente faz-se uso do cálculo
por meio de cofatores. Alternativamente, podemos usar um algoritmo de escalonamento
e produto dos elementos da diagonal principal.

Estes problemas estão presentes em toda a matemática escolar. Por isso, conside-
ramos de suma importância fazer uma comparação de tais algoritmos, para que possamos
escolher o ensino daqueles que forem mais eficientes. Estas escolhas não se devem apenas
a uma melhoria do cálculo escrito. Há uma tendência crescente por se adotar o ensino de
programação básica no currículo escolar. Sendo assim, a compreensão de um algoritmo
não passa somente por sua construção, mas também pela sua análise de eficiência.

2.2 Escolha e Verificação dos Livros Didáticos

Para a escolha dos livros didáticos, fizemos uma pesquisa no banco de dados da
Secretaria de Estado de Educação do Distrito Federal (SEEDF) e verificamos quais as
três Coordenadorias Regionais de Ensino (CRE) com maior número de alunos. Os dados
estão disponíveis em (FEDERAL, 2017).

40

Capítulo 2. Metodologia

Tabela 1 – Coordenadorias Regionais de Ensino (CRE) com maior número de matrículas

– Ensino Fundamental II (6o ao 9o ano)

CRE

Matrículas

Ceilândia
Planaltina
Plano Piloto

22.868
11.519
10.895

Tabela 2 – Coordenadorias Regionais de Ensino (CRE) com maior número de matrículas

– Ensino Médio

CRE

Matrículas

Ceilândia
Taguatinga
Plano Piloto

13.195
9.409
8.273

Feito isto, procuramos, em cada regional de ensino, as 5 escolas com o maior
número de matrículas nos anos finais do ensino fundamental e no ensino médio. Os dados
estão disponíveis em (FEDERAL, 2018a) e em (FEDERAL, 2018b).

Tabela 3 – Escolas com maior número de matrículas no Ensino Fundamental II – CRE

Ceilândia

Escola

Matrículas

CEF 25 de Ceilândia
CEF 27 de Ceilândia
CEF 28 de Ceilândia
CEF 26 de Ceilândia
CEF 07 de Ceilândia

1.632
1.506
1.169
1.059
1.052

Tabela 4 – Escolas com maior número de matrículas no Ensino Fundamental II – CRE

Planaltina

Escola

CEF 04 de Planaltina
CED Dona América Guimarães
CEF 01 de Planaltina
CED Pompílio Marques de Souza
CED Stella dos Cherubins Guimarães Trois

Matrículas

1.173
1.020
999
930
907

Em seguida, pesquisamos quais os livros adotados em matemática no 6o ano nas
escolas das Tabelas 3, 4 e 5 e no 2o ano do ensino médio nas escolas das Tabelas 6, 7 e 8.

De posse dos livros, analisamos cuidadosamente os exercícios e os algoritmos de
potências e máximo divisor comum apresentados nos livros de 6o ano e os exercícios e
algoritmos de determinantes nos livros de 2o ano.

2.2. Escolha e Verificação dos Livros Didáticos

41

Tabela 5 – Escolas com maior número de matrículas no Ensino Fundamental II – CRE

Plano Piloto

Escola

Matrículas

CEF Polivalente
CEF CASEB
CEF Athos Bulcão
CEF 07 de Brasília
CEF 01 do Cruzeiro

1.103
994
735
723
699

Tabela 6 – Escolas com maior número de matrículas no Ensino Médio – CRE Ceilândia

Escola

Matrículas

CEM 02 de Ceilândia
CEM 12 de Ceilândia
CED 15 de Ceilândia
CEM 04 de Ceilândia
CED 06 de Ceilândia

2.132
1.583
1.484
1.399
1.246

Tabela 7 – Escolas com maior número de matrículas no Ensino Médio – CRE Taguatinga

Escola

Matrículas

CEM Ave Branca
CEM Taguatinga Norte
CED EIT
CEM 03 de Taguatinga
CED 04 de Taguatinga

2.414
1.525
1.377
1.399
1.246

Tabela 8 – Escolas com maior número de matrículas no Ensino Médio - CRE Plano Piloto

Escola

Matrículas no Ensino Fundamental II

CEM Setor Leste
CEM Elefante Branco
CEM Setor Oeste
CEM Paulo Freire
CED GISNO

1.636
1.582
1.156
904
716

Os livros de ensino fundamental adotados pelas escolas das Tabelas 3, 4 e 5 são
Bianchini (2016), Dante (2016b), Chavante (2016), Andrini e Vasconcelos (2015), Silveira
(2016) e Centúrion e Jakubovic (2015).

Todos os livros apresentam somente o cálculo da potenciação por definição. Na
verdade, apenas Silveira (2016) tem uma seção onde são apresentadas as propriedades
da potenciação. Com relação ao cálculo do máximo divisor comum, os livros Centúrion e
Jakubovic (2015) e Chavante (2016) mostram como calcular o máximo divisor comum so-
mente via definição. Já os demais livros apresentam também o algoritmo da decomposição

42

Capítulo 2. Metodologia

em fatores primos. Nenhum deles apresenta o algoritmo de Euclides.

Com relação ao ensino médio, os livros adotados pelas escolas das Tabelas 6, 7 e

8 são Dante (2016a), Iezzi et al. (2016) e Leonardo (2016).

Em todos eles é apresentado somente o cálculo de determinantes de matrizes 2 × 2
e 3 × 3 utilizando as conhecidas fórmulas dos Teoremas 5 e 6. Curiosamente, Leonardo
(2016) mostra um recurso de softwares de planilhas eletrônicas que calcula determinantes
de matrizes 2×2, mas não comenta sobre como seriam as programações de fórmulas nestes
tipos de softwares.

2.3 Problemas Escolhidos

Nesta seção, descreveremos os problemas selecionados para este trabalho e os al-
goritmos ensinados na escola para a solução dos mesmos. A escolha dos problemas se deu
de acordo com a existência de mais de um algoritmo para os mesmos e que pudessem ser
ensinados nos ensinos fundamental e médio. Os problemas escolhidos foram: a potenciação
com base e expoente naturais, o máximo divisor comum entre dois números naturais e o
determinante de matrizes quadradas.

Em cada uma das subseções, escreveremos os algoritmos em linguagem de pseudo-
código e, em seguida, faremos uma análise do tempo gasto para a execução do algoritmo
em função do tamanho da instância. Conforme discutido no Capítulo 1, iremos considerar
que cada operação do mesmo tipo leva um tempo constante para ser executada.

Na Subseção 2.3.1, descrevemos os algoritmos para a potenciação. Iremos com-
parar um algoritmo que calcula uma potenciação por definição com outro que calcula
utilizando propriedades da potenciação. Na Subseção 2.3.2, serão abordados os algorit-
mos para a determinação do MDC entre dois números naturais. Faremos a comparação
de um algoritmo que calcula o máximo divisor comum por decomposição dos números
em fatores primos com o algoritmo de Euclides. Por fim, na Subseção 2.3.3, faremos uma
análise de dois algoritmos para o cálculo de determinantes: um deles que calcula por meio
de cofatores e do teorema de Laplace e outro que calcula por meio do escalonamento de
Gauss-Jordan.

2.3.1 Potenciação

O primeiro algoritmo que iremos analisar é o da potenciação. O Algoritmo 1 com-

puta uma potenciação nos moldes da Definição 4.

No Algoritmo 1, para calcular qualquer potência, partimos do número natural 1.
Em seguida, multiplicamo-o pela base 𝑎. O resultado é, então, multiplicado por 𝑎, e assim
sucessivamente. Este procedimento é iterado um número de vezes igual ao expoente 𝑛.

2.3. Problemas Escolhidos

43

Algoritmo 1 Potenciação por definição
Entrada: dois números naturais a e n
Saída: um número natural b tal que 𝑎𝑛 = 𝑏
1: 𝑏 = 1
2: for 𝑖 = 1 do 𝑛
𝑏 = 𝑏 · 𝑎
3:
4: end for
5: return 𝑏

Neste algoritmo, portanto, o número de multiplicações feitas é exatamente igual a
𝑛. O laço for da linha 2 é iterado 𝑛 vezes, cada vez com um tempo constante 𝑐. Portanto,
a função que descreve o tempo de execução do Algoritmo 1 é dada por

𝑓 (𝑛) = 𝑐𝑛 = Θ(𝑛)

Um algoritmo alternativo para a potenciação é apresentado no Algoritmo 2. Ele
utiliza como base de construção as propriedades da potenciação, descritas na Seção 1.4.

Algoritmo 2 Potenciação por divisão e conquista
Entrada: dois números naturais a e n
Saída: um número natural b tal que 𝑎𝑛 = 𝑏
1: function Pot2(𝑎, 𝑛)
if 𝑛 = 1 then
2:
return 𝑎
3:
4:

else if 𝑛 ≡ 0 mod 2 then
)︂2

(︂

5:

6:

7:

return Pot2

𝑎,

else

return Pot2

𝑛
2

)︂2

(︂

𝑎,

𝑛 − 1
2

· 𝑎

end if
return 𝑏

8:
9:
10: end function

O Algoritmo 2 calcula uma potenciação por meio de uma recorrência. Se o expoente
for igual a 1, o valor da potência é o próprio 𝑎, que é a base da potenciação. Caso contrário,
separa-se o cálculo de acordo com a paridade de 𝑛, o expoente da potenciação: se 𝑛 for
par, faz-se a potenciação

. Caso contrário, faz-se a potenciação

𝑎 𝑛

𝑛−1
2

𝑎.

)︁2

)︁2

𝑎

(︁

(︁

2

Logo, após 𝑘 iterações, teremos que o expoente 𝑛𝑘 será menor que

Observe que, a cada iteração do algoritmo, o expoente se reduz pela metade.
𝑛
2𝑘 . Assim, em algum
𝑛
momento, teremos 𝑛𝑘 = 1 (pois a sequência 𝑎𝑘 =
2𝑘 → 0 quando 𝑘 → ∞). Isto ocorre
quando 𝑘 = log2 𝑛. Daí, se cada multiplicação leva um tempo constante 𝑐1 para ser
executada e cada divisão um tempo 𝑐2, então a função que dá o tempo de execução do
Algoritmo 2 é

𝑓 (𝑛) = (𝑐1 + 𝑐2) log2 𝑛 = Θ(log 𝑛)

44

Capítulo 2. Metodologia

2.3.2 Máximo Divisor Comum

Na escola, aprendemos alguns métodos para obter o MDC entre dois números. O

método da decomposição em fatores primos está descrito no Algoritmo 3.

Algoritmo 3 MDC por decomposição em fatores primos
Entrada: Dois naturais 𝑎 e 𝑏, com 𝑎 ≥ 𝑏 e 𝑃 = {𝑝𝑖 : 𝑝𝑖 é o i-ésimo número primo}.
Saída: Um número natural 𝑑 tal que 𝑀 𝐷𝐶(𝑎, 𝑏) = 𝑑.

1: 𝑑 = 1
2: 𝑖 = 1
3: while 𝑎 > 1 and 𝑏 > 1 and 𝑝𝑖 ≤ 𝑏 do
4:
5:

if 𝑎 ≡ 0 mod 𝑝𝑖 and 𝑏 ≡ 0 mod 𝑝𝑖 then

else if 𝑎 ≡ 0 mod 𝑝𝑖 then

else if 𝑏 ≡ 0 mod 𝑝𝑖 then

6:

7:

8:

9:

10:

11:

𝑎 =

𝑑 = 𝑑 · 𝑝𝑖
𝑏
𝑝𝑖
𝑏
𝑝𝑖

𝑏 =

𝑎 =

𝑏 =

𝑎
𝑝𝑖

𝑏
𝑝𝑖

𝑖 = 𝑖 + 1

else

12:
13:
end if
14:
15: end while
16: return 𝑑

O Algoritmo 3 calcula o MDC (𝑎, 𝑏) como um produto de números primos. Ini-
cialmente, o algoritmo considera o valor de 𝑑 = MDC (𝑎, 𝑏) como sendo 1. Na primeira
iteração, 𝑎 e 𝑏 são divididos por 𝑝1 = 2. Se ambas as divisões forem exatas, 𝑑 é multi-
plicado por 2 e 𝑎 e 𝑏 tem seus valores atualizados para 𝑎
2, respectivamente. Caso a
divisão seja exata apenas para 𝑎, apenas o valor de 𝑎 será atualizado e 𝑑 permanece igual
a 1. O mesmo ocorre se a divisão for exata apenas para 𝑏. Caso a divisão seja inexata para
ambos, o algoritmo passa a dividir 𝑎 e 𝑏 pelo próximo primo, que é 𝑝2 = 3. O algoritmo
prossegue enquanto 𝑝𝑖 for menor ou igual a 𝑏.

2 e 𝑏

Suponha que 𝑎 = 2𝛼1 · 3𝛼2 · . . . · 𝑝𝛼𝑘
𝑘

𝑗 , com 𝑎 ≥ 𝑏, onde
𝑝𝑖 representa o 𝑖-ésimo número primo e 𝛼𝑖 ≥ 0 e 𝛽𝑖 ≥ 0. O Teorema Fundamental da
Aritmética garante que tal representação sempre é possível para 𝑏 ≥ 2 (GONçALVES,
2006). Aplicando o logaritmo em base 2 dos dois lados de cada igualdade, temos que

e 𝑏 = 2𝛽1 · 3𝛽2 · . . . · 𝑝𝛽𝑗

log2 𝑎 = 𝛼1 · log2 2 + 𝛼2 · log2 3 + . . . + 𝛼𝑘 · log2 𝑝𝑘 ≥ 𝛼1 + 𝛼2 + . . . + 𝛼𝑘

e

log2 𝑏 = 𝛽1 · log2 2 + 𝛽2 · log2 3 + . . . + 𝛽𝑗 · log2 𝑝𝑗 ≥ 𝛽1 + 𝛽2 + . . . + 𝛽𝑗

2.3. Problemas Escolhidos

45

pois log2 𝑛 ≥ 1 para todo 𝑛 ≥ 2. Assim, 𝛼1+𝛼2+. . .+𝛼𝑘 ≤ log2 𝑎 e 𝛽1+𝛽2+. . .+𝛽𝑗 ≤ log2 𝑏.

O Algoritmo 3 faz, no mínimo, 2 · 𝜋(𝑏) testes, dividindo os números 𝑎 e 𝑏 por todos
os primos menores ou iguais a 𝑏. Além disso, se 𝑎 e 𝑏 são escritos como na decomposição
acima, pode acontecer de serem feitos 𝛾1 = max{𝛼1, 𝛽1} testes para o primeiro primo,
𝛾2 = max{𝛼2, 𝛽2} testes para o segundo primo, e assim sucessivamente. Daí, o número
de divisões realizadas seria, na pior das hipóteses, 2 · (𝛾1 + 𝛾2 + . . . + 𝛾𝑛) · 𝜋(𝑏), onde
𝛾𝑖 = max{𝛼𝑖, 𝛽𝑖} e 𝑛 = max{𝑘, 𝑗}. Como 𝛾1 + 𝛾2 + . . . + 𝛾𝑛 ≤ (𝛼1 + 𝛽1) + (𝛼2 + 𝛽2) + . . . +
𝛼𝑘 + 𝛽𝑗 ≤ log2 𝑎 + log2 𝑏 ≤ 2 log2 𝑎 então, se cada divisão leva um tempo constante 𝑐 para
ser executada, temos que o tempo de execução do Algoritmo 3 é limitado superiormente
pela função

𝑓 (𝑛) = 𝑐 · 4 · log2 𝑎 · 𝜋(𝑏) = 𝑂(log 𝑎 · 𝜋(𝑏))

Observe que a análise feita acima coloca um limite superior para o tempo de exe-
cução do Algoritmo 3. Por este motivo escrevemos 𝑓 (𝑛) como uma função 𝑂(log(𝑎)𝜋(𝑏)),
e não Θ(log(𝑎)𝜋(𝑏)).

Podemos calcular o MDC utilizando outro algoritmo. O algoritmo de Euclides para
a determinação do MDC entre dois números é conhecido desde a idade antiga e, surpre-
endentemente, é mais eficiente que o da decomposição em fatores primos. O Algoritmo
4 descreve um procedimento computacional que executa o algoritmo de Euclides para a
determinação do MDC entre dois números.

Algoritmo 4 Algoritmo de Euclides Estendido
Entrada: dois números naturais 𝑎 e 𝑏, com 𝑎 ≥ 𝑏
Saída: um número natural 𝑑 tal que MDC (𝑎, 𝑏) = 𝑑

1: if 𝑏 = 0 then
𝑑 = 𝑎
2:
3: else
4:
5:
6: end if
7: return 𝑑

𝑟 = 𝑎 % 𝑏
𝑑 = MDC (𝑏, 𝑟)

O Algoritmo 4 se baseia no fato de que MDC (𝑎, 𝑏) = MDC (𝑏, 𝑟), onde 𝑟 é o resto
da divisão de 𝑎 por 𝑏 (HEFEZ, 2014). Em cada iteração do algoritmo, 𝑎 é dividido por 𝑏,
obtendo-se um resto 𝑟. O número 𝑏 é, então, dividido por 𝑟 e as definições de 𝑎 e 𝑏 são
atualizadas para 𝑏 e 𝑟, respectivamente.

Seja 𝑟𝑖 o resto da 𝑖-ésima iteração do Algoritmo 4. Ora, o Teorema 4 garante que
𝑎
2

. Na segunda iteração do algoritmo, 𝑟2 <

. Na terceira e quarta iterações do

𝑏
2

𝑟1 <

𝑟1
2

𝑟2
2

𝑏
4

algoritmo, tem-se 𝑟3 <
, e assim sucessivamente. Observe que, a cada
duas iterações do algoritmo, o resto cai pela metade. Logo, após 2𝑘 iterações, teremos
𝑏
2𝑘 . Como a sequência (𝑟𝑛) tende para zero quando 𝑛 tende para infinito, em

que 𝑟2𝑘 <

e 𝑟4 <

<

46

Capítulo 2. Metodologia

algum momento devemos ter 𝑟𝑘 < 1, momento este em que o algoritmo para. Isto ocorre
quando 𝑏 < 22𝑘, isto é, quando 𝑘 >

.

log2 𝑏
2

O raciocínio acima, explicitado também em (SCHEINERMAN, 2011), mostra que

log2 𝑏
2

são necessárias
divisões para que o Algoritmo 4 dê o MDC entre 𝑎 e 𝑏. Se cada
divisão leva um tempo constante 𝑐 para ser executada, temos que a função que dá o tempo
de execução do Algoritmo 4 é dada por

𝑓 (𝑏) = 𝑐 ·

log2 𝑏
2

= Θ(log 𝑏)

2.3.3 Determinantes

É comum, ao aprendermos determinantes, aplicarmos métodos diferentes de cálculo
para cada tamanho de matriz quadrada. O caso 2 × 2 é o mais simples. O Algoritmo 5
é um procedimento computacional que executa a fórmula obtida no Teorema 5 da Seção
1.6.

Algoritmo 5 Matrizes 2 × 2

Entrada: uma matriz 𝐴 =

)︃

(︃𝑎 𝑏
𝑒 𝑓

Saída: um número real 𝑑 tal que det 𝐴 = 𝑑

1: 𝑑 = 𝑎 · 𝑓 − 𝑏 · 𝑒
2: return 𝑑

O Algoritmo 5 traduz uma fórmula fechada. A contagem de operações é, portanto,
fixa. Uma matriz 2 × 2 tem sempre 4 elementos e faremos sempre 2 multiplicações a um
tempo constante 𝑐1 e 1 adição a um tempo constante 𝑐2, totalizando 3 operações, ou seja,
a função que dá o tempo de execução do algoritmo 5 é constante, conforme mostra a
função abaixo:

𝑓 (𝑛) = 2𝑐1 + 𝑐2 = Θ(1)

Para o caso de matrizes 3 × 3, em geral utiliza-se a regra de Sarrus, descrita no
Teorema 6. O Algoritmo 6 descreve um procedimento computacional para se calcular o
determinante de uma matriz 3 × 3 por meio da regra de Sarrus.

Algoritmo 6 Determinantes de matrizes 3 × 3

Entrada: uma matriz 𝐴 =

⎛

⎜
⎝

𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

⎞

⎟
⎠

Saída: um número real 𝑑 tal que 𝑑 = det 𝐴
1: 𝑑 = 𝑎11𝑎22𝑎33 + 𝑎12𝑎23𝑎31 + 𝑎13𝑎21𝑎32 − 𝑎31𝑎22𝑎13 − 𝑎32𝑎23𝑎11 − 𝑎33𝑎21𝑎12
2: return 𝑑

Novamente, por ser uma fórmula fechada, a regra de Sarrus é sempre um proce-
dimento operacional com um número de operações fixo. Neste caso, sabemos que uma

2.3. Problemas Escolhidos

47

matriz 3 × 3 tem 9 elementos. Para aplicar a regra de Sarrus, fazemos 12 multiplicações
a um tempo constante 𝑐1 e 5 adições a um tempo constante 𝑐2. Logo, a função que dá o
tempo de execução do Algoritmo 6 é igual a

𝑓 (𝑛) = 12𝑐1 + 5𝑐2 = Θ(1)

Para o cálculo de determinantes de ordens quaisquer, temos duas possibilidades:
podemos usar o teorema de Laplace (Teorema 4 da Seção 1.6), que é o método dos co-
fatores, ou aplicar o escalonamento de Gauss para transformar a matriz em uma matriz
triangular e, em seguida, multiplicar os números da diagonal principal. O Algoritmo 7
descreve um procedimento computacional para o cálculo do determinante através de co-
fatores e o Algoritmo 8, um procedimento para o cálculo por meio do escalonamento de
Gauss.

Algoritmo 7 Determinantes por cofatores
Entrada: Uma matriz quadrada 𝐴𝑛×𝑛, com 𝑛 ∈ 𝑁
Saída: Um número real 𝑑 tal que 𝑑 = det 𝐴
1: function Det(𝐴, 𝑛)
2:

if 𝑛 = 1 then
return 𝑎11
else

3:
4:
5:
6:

7:

𝑑 = 0
for 𝑗 = 𝑖 do 𝑛

𝑖 = 1

⎛

⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

𝑎11
𝑎21
...

𝑎12
𝑎22
...

...
𝑎𝑛1

...
𝑎𝑛2

𝑀𝑖𝑗 =

𝑎(𝑖−1)1 𝑎(𝑖−1)2
𝑎(𝑖+1)1 𝑎(𝑖+1)2

𝑎1(𝑗−1)
𝑎2(𝑗−1)
...

𝑎1(𝑗+1)
𝑎2(𝑗+1)
...

· · ·
· · ·
. . .
· · · 𝑎(𝑖−1)(𝑗−1) 𝑎(𝑖−1)(𝑗+1)
· · · 𝑎(𝑖+1)(𝑗−1) 𝑎(𝑖+1)(𝑗+1)
. . .
· · ·

...
𝑎𝑛(𝑗−1)

...
𝑎𝑛(𝑗+1)

· · ·
· · ·

𝑎1𝑛
𝑎2𝑛
...

· · ·
· · · 𝑎(𝑖−1)𝑛
· · · 𝑎(𝑖+1)𝑛
· · ·
· · ·

...
𝑎𝑛𝑛

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

end for
𝑑 = (−1)𝑖+𝑗𝑎𝑖𝑗· Det(𝑀𝑖𝑗, 𝑛 − 1)
return 𝑑

8:
9:
10:
11:
12: end function

end if

No Algoritmo 7, começamos pela linha 1. Nesta linha, há 𝑛 cofatores. Como eles
serão multiplicados pelos determinantes menores, teremos 𝑛 multiplicações. Os determi-
nantes menores são determinantes de matrizes (𝑛 − 1) × (𝑛 − 1). Para cada determinante
menor, inicia-se com a 1a linha. Ela terá 𝑛 − 1 cofatores, o que implica que serão feitas
𝑛 − 1 multiplicações. Logo, o total de multiplicações, por enquanto, é 𝑛 · (𝑛 − 1). Prosse-
guindo com este raciocínio, temos que o número de multiplicações para o cálculo de um
determinante por este método é igual a

𝑛(𝑛 − 1)(𝑛 − 2) · · · 3 · 2 · 1 = 𝑛!

48

Capítulo 2. Metodologia

Com relação ao número de adições, observe que, se matriz tem dimensão 1, não
há adições a fazer. O número de adições é, portanto, igual a zero. No caso de matrizes
2 × 2, há 2 determinantes 1 × 1 com zero adições cada, mais uma adição entre eles. Para
matrizes 3 × 3, há 3 determinantes 2 × 2, cada um com 1 adição, mais duas adições entre
os resultados. Prosseguindo com este raciocínio, podemos construir a Tabela 9.

Tabela 9 – Quantidade de adições do Algoritmo 7

Tamanho da matriz Quantidade de adições

1 × 1
2 × 2
3 × 3
4 × 4
...
𝑛 × 𝑛

𝑎1 = 0
𝑎2 = 2 · 𝑎1 + 1
𝑎3 = 3 · 𝑎2 + 2
𝑎4 = 4 · 𝑎3 + 3
...
𝑎𝑛 = 𝑛 · 𝑎𝑛−1 + 𝑛 − 1

Observe que, para determinar a quantidade de adições realizadas pelo Algoritmo

7, chegamos à recorrência

⎧
⎪⎨

𝑎1 = 0

⎪⎩

𝑎𝑛 = 𝑛 · 𝑎𝑛−1 + 𝑛 − 1

Lema 1. A solução da recorrência

⎧
⎪⎨

𝑎1 = 0

⎪⎩

𝑎𝑛 = 𝑛 · 𝑎𝑛−1 + 𝑛 − 1

,

se 𝑛 ≥ 1 é 𝑎𝑛 = 𝑛! − 1.

Demonstração: por indução sobre 𝑛. Para 𝑛 = 1, é válida, pois 𝑎1 = 1! − 1 = 0.

Supondo a recorrência válida para algum 𝑛 ∈ N, temos

𝑎𝑛+1 = (𝑛 + 1)𝑎𝑛 + 𝑛 = (𝑛 + 1)(𝑛! − 1) + 𝑛 = (𝑛 + 1)𝑛! − 𝑛 − 1 + 𝑛 = (𝑛 + 1)! − 1

Pelo princípio da indução, a solução 𝑎𝑛 = 𝑛! − 1 é válida para todo 𝑛 natural.

(cid:3)

A discussão acima mostra que, se cada multiplicação for feita a um tempo 𝑐1 e
cada adição a um tempo 𝑐2, então a função que dá o tempo de execução do Algoritmo 7
é dada por

𝑓 (𝑛) = 𝑐1𝑛! + 𝑐2(𝑛! − 1) = Θ(𝑛!)

2.3. Problemas Escolhidos

49

O Algoritmo 8 apresenta um método alternativo para o cálculo de determinantes

de matrizes de ordem 𝑛, baseado no escalonamento de Gauss.

Algoritmo 8 Determinantes por escalonamento
Entrada: Uma matriz quadrada 𝐴𝑛×𝑛, com 𝑛 ∈ 𝑁
Saída: Um número real 𝑑 tal que 𝑑 = det 𝐴

1: for 𝑘 = 1 do 𝑛
𝑚 = 𝑘
2:
while 𝑎𝑚𝑘 = 0 do
3:
𝑚 = 𝑚 + 1
4:
5:
6:

end while
if 𝑚 > 𝑛 then
return 0
end if
swap(𝐴𝑚, 𝐴𝑘)
for 𝑖 = 𝑘 + 1 do 𝑛
for 𝑗 = 𝑘 do 𝑛
𝑎𝑖𝑗 = 𝑎𝑖𝑗 −

7:
8:
9:
10:

11:

end for

end for

12:
13:
14: end for
15: 𝑑 = 1
16: for 𝑖 = 1 do 𝑛
17:
18: end for
19: return 𝑑

𝑑 = 𝑑 · 𝑎𝑖𝑖

(︂ 𝑎𝑖𝑘
𝑎𝑘𝑘

)︂

· 𝑎𝑘𝑗

No Algoritmo 8, iniciamos pelo elemento da 1a linha e da 1a coluna da matriz A.
Caso ele seja zero, permutamos com a 1a linha com a 2a, e assim sucessivamente, até
que apareça um elemento não-nulo. Observe que se todos os elementos forem nulos, o
determinante será zero. Para cada linha 𝑖, com 2 ≤ 𝑖 ≤ 𝑛, substituímos o elemento 𝑎𝑖𝑗
por 𝑎𝑖𝑗 − 𝑎1𝑗 ·

.

𝑎𝑖1
𝑎11

O processo descrito acima faz com que todos os elementos da 1a coluna abaixo
da 1a linha se tornem nulos. Repetindo o procedimento para a 2a linha, zeramos todos
os elementos da 2a coluna abaixo da 2a linha, e assim por diante, até que a matriz A é
transformada em uma matriz triangular superior. Finalmente, multiplicamos os elementos
da diagonal principal, obtendo um número real 𝑑, que é o determinante de A.

)︂

(︂ 𝑎𝑖1
𝑎11

No Algoritmo 8, como cada linha possui 𝑛 elementos, a substituição 𝑎𝑖𝑗 ← 𝑎𝑖𝑗 −
na primeira iteração do laço while tem um custo de uma divisão a um tempo

𝑎1𝑗 ·
constante 𝑐1, uma multiplicação a um tempo constante 𝑐2 e uma adição a um tempo
constante 𝑐3. Logo, em cada linha são feitas 3𝑛 operações, no máximo, a um tempo
constante 𝑐 para algum 𝑐 ∈ R. Como esta operação é feita em 𝑛 − 1 linhas, temos um

50

Capítulo 2. Metodologia

custo de tempo da ordem de

3𝑛(𝑛 − 1) · 𝑐,

com 𝑐 ∈ R.

Na segunda iteração do laço while, as operações para cada elemento são feitas 𝑛−1

vezes, ao longo de 𝑛 − 2 linhas. O tempo gasto é, portanto, uma função da forma

3(𝑛 − 1)(𝑛 − 2) · 𝑐,

com 𝑐 ∈ R

Logo, o custo de tempo total é dado pelo somatório

𝑓 (𝑛) = 3𝑐[𝑛(𝑛 − 1) + (𝑛 − 1)(𝑛 − 2) + · · · + 2 · 1] = 3𝑐

𝑛
∑︁

= 3𝑐

(𝑛2 − 2𝑛𝑘 + 𝑛 + 𝑘2 − 𝑘)

= 3𝑐

𝑘=1
[︃

𝑛2

𝑛
∑︁

𝑘=1

1 − (2𝑛 + 1)

𝑛
∑︁

𝑘=1

𝑘 + 𝑛

𝑛
∑︁

𝑘=1

1 +

]︃

𝑘2

𝑛
∑︁

𝑘=1

𝑛
∑︁

(𝑛 − 𝑘)[𝑛 − (𝑘 − 1)]

𝑘=1

Usando a conhecida fórmula

𝑛
∑︁

𝑘=1

𝑘2 =

𝑛(𝑛 + 1)(2𝑛 + 1)
6

,

, a qual pode ser consultada em (LIMA et al., 2006), temos que o custo das operações é:

[︃

𝑓 (𝑛) = 3𝑐

𝑛3 − (2𝑛 + 1)

𝑛(𝑛 + 1)
2

+ 𝑛2 +

𝑛(𝑛 + 1)(2𝑛 + 1)
6

]︃

= 3𝑐

[︃ 6𝑛3 − 6𝑛3 − 6𝑛 − 3𝑛2 − 3𝑛 + 6𝑛2 + 2𝑛3 + 𝑛2 + 2𝑛2 + 𝑛
6

]︃

= 𝑐

2𝑛3 + 6𝑛2 − 8𝑛
2

= 𝑐(𝑛3 + 3𝑛2 − 4𝑛)

Portanto,

𝑓 (𝑛) = Θ(𝑛3).

Este é o custo para triangularizar a matriz A. Em seguida, faz-se apenas 𝑛 − 1
multiplicações com os números da diagonal principal. Como este número é acrescentado
ao número anterior, ainda tem-se a função custo do cálculo do determinante por escalo-
namento da ordem de 𝑛3.

3 Resultados

51

Neste capítulo, iremos aplicar os algoritmos em exemplos conhecidos, de modo
a comparar sua eficiência. Aplicaremos tanto em exemplos extraídos de livros didáticos
quanto em exemplos numéricos com números de ordem elevada. Esta última análise tem
o propósito de mostrar o comportamento assintótico dos algoritmos à medida que cresce
o tamanho da amostra.

3.1 Algoritmos de Potenciação

O primeiro algoritmo a ser analisado é o da potenciação. Vamos testá-lo primeira-
mente em um exemplo didático, extraído de (IMENES; LELLIS, 2012), com adaptações.

Exemplo 1. Calcule o valor da potência 43.

Solução Temos que 𝑎 = 4 e 𝑛 = 3.

De acordo com o Algoritmo 1, seguem-se os seguintes passos.

1. iniciamos com o valor 1;

2. em seguida, multiplicamo-no por 4, obtendo 1 · 4 = 4;

3. multiplicamos o resultado por 4, obtendo 4 · 4 = 16;

4. multiplicamos o resultado por 4, obtendo 16 · 4 = 64.

Após fazer as multiplicações, obtemos a resposta: 64. O número de multiplicações

realizadas utilizando este algoritmo é igual 3.

Agora, aplicando o Algoritmo 2:

1. separamos a potência em 42 · 41;

2. atribui-se 41 = 4;

3. depois, calculamos 42 = 4 · 4 = 16;

4. por último, utilizamos os valores de 42 e 41 para concluir o cálculo, obtendo 42 · 41 =

16 · 4 = 64.

Embora os dois métodos sejam bastante parecidos, aplicando o Algoritmo 2 exe-

cutamos apenas 2 multiplicações.

52

Capítulo 3. Resultados

(cid:3)

Para comparar os dois algoritmos de forma mais transparente, utilizamos um sor-
teador de bases e expoentes. Em linguagem Python, escrevemos os dois algoritmos. Em
seguida, inserimos um comando de geração aleatória de números naturais nos intervalos
fechados [1, 10], [1, 100], [1, 1 000] e [1, 10 000]. Para cada intervalo, o código sorteou
100 valores para a base e o expoente dentro dos limites do intervalo e, partindo desses
valores, calculou-se as potenciações. Por fim, o código incluiu um contador do número de
multiplicações realizadas por cada algoritmo. O código retorna como valores de saída um
par ordenado (𝑥, 𝑦), onde 𝑥 representa o limite superior do intervalo e 𝑦, o número médio
de multiplicações feitas considerando as 100 amostras. Os códigos em Python podem ser
consultados no Apêndice 1.

Por exemplo, no intervalo [1, 10], o programa sorteou 100 valores para a base e
o expoente. Após calcular as 100 potências, o programa contou o número de multipli-
cações realizadas em cada uma e calculou a média aritmética desses valores. No nosso
experimento, o número médio de multiplicações foi 5,02 para o Algoritmo 1 e 2,65 para o
Algoritmo 2. A Tabela 10 mostra o número médio de multiplicações realizadas por cada
algoritmo em cada intervalo, com 100 amostras por intervalo.

Tabela 10 – Número médio de multiplicações para os Algoritmos 1 e 2

Intervalo Algoritmo 1 Algoritmo 2

[1, 10]
[1, 100]
[1, 1000]
[1, 10000]

5,02
47,36
507,06
5.717,72

2,65
6,97
11,92
16,71

A Tabela 10 mostra, de forma evidente, que o Algoritmo 2, que calcula a potenci-
ação por divisão e conquista, utilizando propriedades de potência, é muito mais eficiente
que o Algoritmo 1, que calcula uma potenciação por definição. Por exemplo, para expo-
entes variando de 1 a 100, o Algoritmo 1 fez, em média, 47,36 multiplicações para calcular
cada potenciação, contra 6,97 multiplicações no Algoritmo 2. Observe que mesmo para
instâncias de valor baixo, isto é, no intervalo [1, 10], já há uma grande diferença entre
o número médio de multiplicações efetuadas pelos dois algoritmos, já que o Algoritmo 1
faz, em média, o dobro de multiplicações em relação ao Algoritmo 2.

Estes resultados estão de acordo com a análise de complexidade feita no Capítulo
3. Lá, verificamos que o custo operacional do Algoritmo 1 era uma função Θ(𝑛), enquanto
a do Algoritmo 2, Θ(lg 𝑛). Deste modo, com expoentes variando de 1 a 100, temos 50
como valor médio. Daí, o número médio de multiplicações para o Algoritmo 1 seria 50 e,
do Algoritmo 2, lg 50 ≈ 5, 64.

3.2. Algoritmos de MDC

53

Figura 1 – Algoritmos de potenciação

A Figura 1 compara os dois experimentos realizados com o código Python para os
Algoritmos 1 e 2. O gráfico mostra o número de multiplicações em função do expoente
𝑛 nos dois casos. Observe que, dada a escala utilizada, o gráfico para o Algoritmo 2
é praticamente uma reta horizontal, o que mostra sua enorme vantagem em termos de
custo operacional.

3.2 Algoritmos de MDC

Nesta seção, iremos comparar os algoritmos para o cálculo do MDC, apresentados
na Seção 3.2. Vamos começar com um exemplo retirado do livro didático (BARROSO;
MATHEUS; NANI, 2010), com adaptações.

Exemplo 2. Calcule o MDC entre 180 e 150.

Solução Aplicando o Algoritmo 3 com 𝑎 = 180, 𝑏 = 150 e 𝑛 = 6, temos:

1. o teste 𝑎 > 1 e 𝑏 > 1 é feito sempre no início da cada iteração. Caso um dos dois
seja igual a 1, o algoritmo pára e dá a resposta. Nenhum dos dois é igual a 1. Logo,
podemos executar o laço while, dividindo 𝑎 e 𝑏 pelo menor número primo, 𝑝1 = 2,
obtendo

= 90 e

= 75;

180
2

150
2

54

Capítulo 3. Resultados

2. prosseguimos, dividindo 90 e 75 por 2.

(Observe que 75 ≡ 1 mod 2);

90
2

= 45, mas 75 não é divisível por 2.

3. é necessário dividir 45 mais uma vez por 2, o que não é possível, pois 45 ≡ 1 mod 2;

4. agora, passamos a dividir ambos os números pelo próximo primo, que é 𝑝2 = 3,

obtendo

= 15 e

= 25;

45
3

75
3

5. prosseguimos com a divisão por 3.

mod 3);

15
3

= 5, mas 25 não é divisível por 3. (25 ≡ 1

6. a divisão de 5 por 3 não é possível, pois 5 ≡ 2 mod 3. Daí, passamos a dividir pelo

próximo primo, 𝑝3 = 5, obtendo

= 1 e

= 5;

5
5

25
5

7. um dos números 𝑎 ou 𝑏 é 1. Logo, o MDC (180, 150), será o resultado da multiplicação
de todos os números primos que dividiram ambos 𝑎 e 𝑏, logo MDC (180, 150) =
2 · 3 · 5 = 30;

8. portanto, MDC (180, 150) = 30.

Contando as operações, realizamos 12 divisões (entre exatas e não exatas) e 2
multiplicações, totalizando 14 operações. Se considerarmos apenas o número de divisões,
foram 12.

Agora vamos aplicar o Algoritmo de Euclides (Algoritmo 4).

1. primeiramente, faz-se o teste para saber se um dos dois números é zero. Como

nenhum dos dois é zero, prosseguimos com o algoritmo como se segue;

2. dividimos 180 por 150, de modo a obter o quociente e o resto, obtendo 180 =

1 · 150 + 30;

3. agora, faz-se o MDC entre 150 e 30. Como nenhum dos dois é zero, dividimos 150

por 30, obtendo 150 = 5 · 30 + 0;

4. agora, faz-se o MDC entre 30 e 0. Como um dos dois é zero, conclui-se que o MDC

(180, 150) = 30.

Contando o número de operações neste algoritmo, temos apenas 2 divisões.

(cid:3)

3.2. Algoritmos de MDC

55

Semelhantemente ao que fizemos para a potenciação, escrevemos um código em
Python para calcular o MDC (𝑎, 𝑏) por meio dos Algoritmos 3 e 4 e contar o número
de divisões realizadas. Os intervalos de amostragem foram do tipo [1, 10𝑘], com 𝑘 ∈
{1, 2, . . . , 12}. Em cada intervalo, foram geradas 100 amostras com 𝑎 e 𝑏 variando aleato-
riamente no intervalo. Em cada amostra, registrou-se o número de divisões realizadas e,
em seguida, calculou-se o número médio de divisões realizadas.

Para o Algoritmo 3, necessitou-se de uma lista de primos. Utilizamos uma lista
com os primeiros 1 milhão de primos. A Tabela 11 mostra o número médio de divisões
realizadas por cada algoritmo em cada intervalo, com 100 amostras por intervalo.

Tabela 11 – Número médio de divisões para os Algoritmos 3 e 4

Intervalo Algoritmo 3 Algoritmo 4

[1, 10]
[1, 102]
[1, 103]
[1, 106]
[1, 109]
[1, 1012]

8,95
29,01
111,84
23.125,36
112.620,67
144.298,78

1,73
3,94
5,81
12,23
17,58
23,62

Novamente, os dados obtidos no experimento mostram uma enorme diferença entre
os algoritmos. Observando a Tabela 11, vemos que o Algoritmo 4 é muito mais eficiente
que o Algoritmo 3. Por exemplo, para números aleatórios no intervalo [1, 106], o número
médio de divisões realizadas pelo Algoritmo 4 é 12,23 contra 23.125,36 do Algoritmo 3.

A Figura 2 compara os Algoritmos 3 e 4 com base nos experimentos realizados
em linguagem Python. O gráfico mostra o número de divisões em função da ordem de
grandeza dos números 𝑎 e 𝑏. O eixo horizontal está na escala logarítmica, para facilitar a
leitura. Observe que o gráfico relativo ao Algoritmo 4 é praticamente uma reta horizontal,
o que mostra sua vantagem em termos de custo operacional.

É importante notar que a escala dos eixos na Figura 2 pode levar a falsas conclu-
sões. Aparentemente, para valores de 𝑎 e 𝑏 da ordem de 102 não há muita diferença entre
os algoritmos. Contudo, enquanto o Algoritmo 3 efetua em média 29 divisões, aproxima-
damente, o Algoritmo 4 efetua pouco menos de 4, o que representa 7 vezes mais divisões
no Algoritmo 3 do que no Algoritmo 4. Analisando os livros didáticos adotados nas es-
colas consultadas, vemos que a maioria absoluta dos exemplos utilizados para o cálculo
de máximo divisor comum são de números no intervalo [1, 103], onde o Algoritmo 4 já se
mostra muito mais eficiente.

56

Capítulo 3. Resultados

Figura 2 – Algoritmos de máximo divisor comum

3.3 Algoritmos de Determinantes

Nesta seção, iremos aplicar os algoritmos desenvolvidos para calcular determinan-
tes. Iniciaremos com os determinantes de matrizes de ordem 2, com um exemplo do livro
didático (IEZZI et al., 2011), com adaptações.

Exemplo 3. Calcule o determinante da matriz 𝐴 =

⎛

⎝

⎞

⎠

1 −1
2
2

Solução Primeiramente, aplicaremos o Algoritmo 5. Basta substituir os valores

na fórmula.

det 𝐴 =

⎛

⎝

⎞
⎠ = 1 · 2 − 2 · (−1) = 2 + 2 = 4

1 −1
2
2

Por se tratar de uma fórmula fechada, o número de operações realizadas é sem-
pre igual a 3: duas multiplicações e uma adição. Se observarmos apenas o número de
multiplicações, foram duas.

3.3. Algoritmos de Determinantes

57

Pelo Algoritmo 7, começamos com a primeira linha da matriz. Temos, então, que

𝑀11 = 2 e 𝑀12 = 2.

Logo, pela fórmula, tem-se que det 𝐴 = (−1)1+1 · 1 · det 𝑀11 + (−1)1+2 · (−1) ·

det 𝑀12 = (−1)2 · 1 · 2 + (−1)3 · (−1) · 2 = 2 + 2 = 4.

Contando as operações, foram feitas 2 multiplicações e 1 adição, totalizando 3

operações. Se observarmos apenas o número de multiplicações, foram 2.

Agora vamos utilizar o escalonamento de Gauss, descrito no Algoritmo 8. Como
o elemento 𝑎11 é não-nulo, o escolhemos como pivô. Em seguida, multiplicamos a linha 1
e somamos o resultado à linha 2, substituindo-a pelos valores obtidos. Assim,
por

−𝑎21
𝑎11

os elementos da linha 2 passam a ser:

e

𝑎21 = 𝑎11 ·

)︂

(︂ −𝑎21
𝑎11

+ 𝑎21 = 1 ·

)︂

(︂ −2
1

+ 2 = 0

𝑎22 = 𝑎12 ·

)︂

(︂ −𝑎21
𝑎11

+ 𝑎22 = −1 ·

)︂

(︂ −2
1

+ 2 = 4

Isto é, obtemos a matriz triangular superior

⎛

1 −1
⎝
4
0

⎞

⎠

Agora, o determinante é dado pelo produto dos elementos da diagonal principal,

ou seja, det 𝐴 = 1 · 4 = 4

Fazendo a contagem de operações, vemos que foram utilizadas 3 multiplicações e
2 adições, num total de 5 operações. Se contarmos apenas o número de multiplicações,
foram 3.

(cid:3)

Para analisar a aplicação dos algoritmos em matrizes 3×3, utilizaremos no exemplo

4 um problema do livro (DANTE, 2014), com adaptações.

Exemplo 4. Aplicando a regra de Sarrus, calcule o determinante da matriz

⎛

⎜
⎜
⎜
⎝

𝐴 =

Solução:

2 −1
3
4
0
5
1
2 −3

⎞

⎟
⎟
⎟
⎠

58

Capítulo 3. Resultados

Primeiro vamos obedecer ao comando do exemplo e utilizar a regra de Sarrus,
descrita no Algoritmo 6, para calcular o determinante. Basta substituir os valores na
fórmula.

det 𝐴 =

⎛
2 −1
3
⎜
⎜
4
0
5
⎜
⎝
1
2 −3

⎞

⎟
⎟
⎟
⎠

= 3 · 0 · 1 + 2 · 4 · 2 + (−1) · 5 · (−3) − 2 · 0 · (−1) − (−3) · 4 · 3 − 1 · 5 · 2

= 0 + 16 + 15 − 0 + 36 − 10 = 57

Por se tratar de uma fórmula fechada, o número de multiplicações e adições é fixo,
sendo 12 multiplicações e 5 adições, totalizando 17 operações. Observando apenas o nú-
mero de multiplicações, são 12 (estamos aqui contando também as adições e multiplicações
por zero).

Agora, usando o Algoritmo 7, escolhe-se uma linha da matriz aleatoriamente, di-

gamos, a segunda. Temos, então, que:

⎛

⎝

𝑀21 =

⎞
⎠ ; 𝑀22 =

2 −1
1
−3

⎛

⎝

⎞
⎠ e𝑀23 =

3 −1
1
2

⎛
3
2
⎝
2 −3

⎞

⎠

Apenas para efeito de organização, calcularemos os determinantes de 𝑀21, 𝑀22 e
𝑀23 separadamente, inserindo-os posteriormente na fórmula. Sem perda de generalidade,
escolheremos a primeira linha de cada uma das matrizes para o cálculo dos determinantes.

det 𝑀21 = (−1)2 · 2 · 1 + (−1)3 · (−1) · (−3) = −1
det 𝑀22 = (−1)2 · 3 · 1 + (−1)3 · (−1) · 2 = 5
det 𝑀23 = (−1)2 · 3 · (−3) + (−1)3 · 2 · 2 = −13

Feito isto, aplicamos a fórmula explicitada no Algoritmo 7.

det 𝐴 = (−1)2+1 · 5 · det 𝑀21 + (−1)2+2 · 0 · det 𝑀22 + (−1)2+3 · 4 · det 𝑀23

= (−1) · 5 · (−1) + 1 · 0 · 5 + (−1) · 4 · (−13) = 5 + 52 = 57

Contando o número de operações, temos 6 multiplicações e 5 adições, totalizando

11 operações. Se contarmos apenas o número de multiplicações, são 6.

Aplicando o Algoritmo 8, temos que o primeiro elemento da primeira linha é não-
e somamos o resultado com a linha 𝑖,

nulo. Logo, multiplicamos a primeira linha por −𝑎𝑖1
𝑎11
com 2 ≤ 𝑖 ≤ 3, substituindo os resultados na linha 𝑖. Temos que cada 𝑎𝑖𝑗 será:

3.3. Algoritmos de Determinantes

59

𝑎21 = −

𝑎22 = −

𝑎23 = −

𝑎31 = −

𝑎32 = −

𝑎33 = −

5
3
5
3
5
3
2
3
2
3
2
3

· 3 + 5 = 0

· 2 + 0 = −

· (−1) + 4 =

· 3 + 2 = 0

· 2 − 3 = −

· (−1) + 1 =

10
3

17
3

13
3

5
3

A matriz passa a ser

⎛

⎜
⎜
⎜
⎝

.

3
0 − 10
3
0 − 13
3

2 −1
17
3
5
3

⎞

⎟
⎟
⎟
⎠

Agora, a segunda linha será multiplicada por

13
3
− 10
3
linha, substituindo os resultados na terceira linha. Logo:

= − 13

10 e somada com a terceira

𝑎32 = −

𝑎33 = −

10
3
17
3

(︂

−

(︂

−

·

·

)︂

)︂

13
10
13
10

−

+

13
3
5
3

= 0

= −

57
10

Donde obtemos a matriz

⎛

⎜
⎜
⎜
⎝

−1
17
3

2
3
0 − 10
3
0 − 57
0
10

⎞

⎟
⎟
⎟
⎠

.

A matriz acima é triangular superior. Deste modo:

det 𝐴 = 3 ·

(︂

−

10
3

)︂

(︂

−

·

)︂

57
10

= 57

Para o Algoritmo 8, realizamos 10 multiplicações, 8 adições e 1 divisão, totalizando

19 operações. Contando apenas o número de multiplicações, foram 10.

(cid:3)

60

Capítulo 3. Resultados

Agora chegou a vez de aplicar os algoritmos no cálculo de determinantes de or-
dens superiores. Embora seja pouco comum a sua aplicação em sala de aula do ensino
médio, encontra-se nos livros didáticos exercícios envolvendo o cálculo de determinantes
de matrizes 4 × 4. Vamos comparar o algoritmo por escalonamento com o algoritmo por
cofator. o exemplo 5 encontra-se no livro (PAIVA, 2010), com adaptações.

Exemplo 5. Calcule o determinante da matriz

𝐴 =

⎞

⎛
2 −1 0
1
⎟
⎜
⎟
⎜
2
4
1
0
⎟
⎜
⎟
⎜
⎟
⎜
0 −3 −1 2
⎟
⎜
⎠
⎝
3
2

1

0

Solução:

Vamos aplicar o Algoritmo 7. Escolhendo a primeira linha da matriz, temos que:

𝑀11 =

𝑀12 =

𝑀13 =

𝑀14 =

⎛

⎜
⎜
⎜
⎝

0
4
1
−3 −1 2
3
1
0
⎞

⎟
⎟
⎟
⎠

⎛
2
4
1
⎜
⎜
0 −1 2
⎜
⎝
3
1
2
⎛
2
4
0
⎜
⎜
0 −3 2
⎜
⎝
3
0
2
⎛
1
0
2
⎜
⎜
0 −3 −1
⎜
⎝
1
0
2

⎟
⎟
⎟
⎠

⎞

⎞

⎟
⎟
⎟
⎠

⎞

⎟
⎟
⎟
⎠

Para não gerar confusão, vamos usar a letra N para denotar os determinantes
menores das matrizes acima. Em cada uma delas, escolheremos a primeira linha para a
determinação dos menores e cofatores. No caso da matriz 𝑀11, tem-se que:

𝑁11 =

𝑁12 =

𝑁13 =

⎛

⎝

−1 2
3
1

⎛

⎝

−3 2
3
0

⎞

⎠

⎞

⎠

⎛

⎝

−3 −1
1
0

⎞

⎠

3.3. Algoritmos de Determinantes

61

Escolhendo agora a segunda linha para a determinação dos menores e cofatores de

cada matriz, temos que:

det 𝑁11 = (−1)3 · 1 · 2 + (−1)4 · 3 · (−1) = −2 − 3 = −5
det 𝑁12 = (−1)3 · 0 · 2 + (−1)4 · 3 · (−3) = −9
det 𝑁13 = (−1)3 · 0 · (−1) + (−1)4 · 1 · (−3) = −3

Deste modo, temos que:

det 𝑀11 = (−1)2 · 0 · (−5) + (−1)3 · 1 · (−9) + (−1)4 · 4 · (−3) = 9 − 12 = −3

Repetindo o procedimento acima para as outras matrizes, temos que:

det 𝑀12 = 2

det 𝑀13 = 6

det 𝑀14 = 0

Portanto,

det 𝐴 = (−1)2 · 1 · (−3) + (−1)3 · 2 · 2 + (−1)4 · (−1) · 6 + (−1)5 · 0 · 0 = −3 − 4 − 6 = −13

Utilizando o Algoritmo 7, realizamos 24 multiplicações e 23 adições, totalizando 47 ope-
rações. Se contarmos apenas o número de multiplicações, foram 24.

Pelo Algoritmo 8, o primeiro elemento da primeira linha é não nulo. Multiplicamos
para todo 𝑖, com 2 ≤ 𝑖 ≤ 4, e somamos o resultado à linha 𝑖,

a primeira linha por − 𝑎𝑖1
𝑎11
substituindo-a pelos valores encontrados. Assim:

𝑎21 = −2·1+2 = 0; 𝑎22 = −2·2+0 = −4; 𝑎23 = −2·(−1)+1 = 3; 𝑎24 = −2·0+4 = 4;

Repetindo o procedimento acima para as outras linhas, temos que a terceira linha

permanece inalterada, pois o primeiro elemento já é nulo e:

𝑎41 = 0; 𝑎42 = −4; 𝑎43 = 3; 𝑎44 = 3;

Assim, obtemos a matriz

𝐴1 =

⎛
2 −1 0
1
⎜
⎜
0 −4
4
3
⎜
⎜
⎜
0 −3 −1 2
⎜
⎝
3
0 −4

3

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎠

A próxima iteração do laço for multiplicará a segunda linha por − 3

4, somando-a

com a terceira linha, substituindo os resultados na própria linha 3. Daí:

62

Capítulo 3. Resultados

𝑎32 = − 3

4 · (−4) − 3 = 0; 𝑎33 = − 3

4 · 3 − 1 = − 13
A operação de multiplicar a segunda linha por −1 e somar com a quarta linha,

4 · 4 + 2 = −1;

4 ; 𝑎34 = − 3

substituindo os valores na linha 4 resulta em:

𝑎42 = 0; 𝑎43 = 0; 𝑎41 = −1;

Como consequência, obtemos a matriz

𝐴2 =

⎛
1
⎜
⎜
0 −4
⎜
⎜
⎜
0
⎜
⎝
0

0
2 −1
3
4
0 − 13
4 −1
0 −1
0

⎞

⎟
⎟
⎟
⎟
⎟
⎟
⎠

A matriz 𝐴2 é uma matriz triangular superior. Seu determinante é igual ao deter-

minante de 𝐴. O algoritmo é concluído com a multiplicação

𝑑 = 1 · (−4) ·

)︂

(︂

−

13
4

· (−1) = −13

Aplicando o Algoritmo 8, realizamos 17 multiplicações e 14 adições, totalizando

31 operações. Contando apenas as multiplicações, foram 17.

(cid:3)

Para complementar a análise dos algoritmos, escrevemos um código em Python
para implementar os Algoritmos 7 e 8. O código sorteia aleatoriamente matrizes 𝑛 × 𝑛
com 𝑛 variando de 1 a 8. Para cada valor de 𝑛, foram obtidas dez amostras de matrizes
formadas por números inteiros no intervalo [−10, 10]. O código contém também instruções
para a contagem do número de multiplicações realizadas pelo algoritmo, que retorna
um par ordenado (𝑥, 𝑦), onde 𝑥 é o determinante da matriz e 𝑦 é o número médio de
multiplicações realizadas. A Tabela 12 o número médio de multiplicações realizadas por
cada algoritmo, com 𝑛 variando no intervalo [1, 8] com 10 amostras para cada 𝑛.

Tabela 12 – Número médio de multiplicações os Algoritmos 7 e 8

𝑛 Algoritmo 7 Algoritmo 8

2
3
4
6
8

6
27
120
3.708
207.840

2
8
20
70
168

Os dados da Tabela 12 mostram, de forma contundente, que o Algoritmo 7 é muito
mais eficiente que o Algoritmo 8. Por exemplo, para matrizes 6 × 6, o número médio de

3.3. Algoritmos de Determinantes

63

Figura 3 – Algoritmos de determinantes

multiplicações realizadas pelo Algoritmo 7 no experimento realizado foi 3.708 contra 70
do Algoritmo 8.

A Figura 3 compara o desempenho dos Algoritmos 7 e 8. Os gráficos mostram o
número de multiplicações realizadas em função do tamanho da matriz no experimento
realizado em linguagem Python. Novamente, observamos que um dos gráficos, no caso a
contagem de multiplicações para o Algoritmo 8, é praticamente uma reta horizontal. Isto
siginifica que a taxa de crescimento da quantidade de operações realizadas pelo Algoritmo
8 e, consequentemente, do tempo de execução, com relação ao tamanho da matriz é muito
pequeno, se comparado ao do Algoritmo 7, cujo gráfico tem um crescimento acentuado
para 𝑛 ≥ 6, ou seja, para 𝑛 suficientemente grande, o Algoritmo 8 faz menos operações
que o Algoritmo 7.

4 Considerações Finais

65

Este trabalho buscou comparar, sob o ponto de vista da análise de complexidade
assintótica, os algoritmos disponíveis para a solução de três problemas típicos da ma-
temática escolar: o cálculo de potenciações com base e expoente naturais; o cálculo do
máximo divisor comum de dois números naturais e o determinante de matrizes de ordem
𝑛. As análises dos algoritmos feitas nos Capítulos 2 e 3 revelaram que o Algoritmo para a
potenciação por divisão e conquista é mais eficiente que o Algoritmo por definição, que o
Algoritmo para o máximo divisor comum de Euclides é mais que eficiente que o Algoritmo
por decomposição em fatores primos e que o Algoritmo para o cálculo de determinantes
por escalonamento é mais eficiente que o de cofatores. A pergunta de pesquisa que motivou
o trabalho foi: Os algoritmos ensinados no ensino médio e fundamental para o cálculo de
potenciações, máximo divisor comum e determinantes são computacionalmente eficientes?

Após fazer uma análise dos livros didáticos adotados nas escolas públicas das
regionais de ensino do Distrito Federal com maior número de alunos, inferimos que são
adotados os algoritmos menos eficientes para a solução dos problemas escolhidos. Os livros
apresentam apenas o cálculo de potenciações por definição e do máximo divisor comum
por decomposição em fatores primos. Com relação ao cálculo de determinantes, os livros
de ensino médio cobrem apenas as matrizes de tamanho 2 × 2 ou 3 × 3.

Isto nos leva a concluir que os algoritmos mais eficientes, como o da potenciação
por divisão e conquista, o algoritmo de Euclides e o de determinantes por escalonamento,
são deixados de lado no ensino destes temas na escola.

Acreditamos não haver empecilho para apresentar tais algoritmos aos alunos. Su-
pondo que um aluno do 6o ano saiba efetuar as quatro operações fundamentais, fazer
uma potenciação agrupando os fatores aos pares não representa nenhuma dificuldade ex-
tra. Por outro lado, o algoritmo de Euclides exige apenas que a pessoa saiba efetuar uma
divisão, registrando resto e quociente. O caso do cálculo de determinantes é mais emble-
mático. Ora, os alunos, no 2o ano do ensino médio, já aprendem a fazer escalonamento
de sistemas. Por que não aplicar o escalonamento para o cálculo de determinantes?

Não queremos de forma alguma ampliar o conteúdo programático baseados apenas
em opiniões pessoais. Queremos reforçar que nossa opinião é a de que se deve priorizar os
algoritmos mais eficientes. Isto não impede a apresentação dos conteúdos da forma como
o professor achar melhor. O conceito a ser apresentado é uma coisa, o algoritmo escolhido
para efetuar um cálculo, é outra.

Em relação aos aspectos didáticos e pedagógicos relacionados a este trabalho, não
fizemos uma pesquisa aprofundada sobre a temática, deixando em aberto para trabalhos

66

Capítulo 4. Considerações Finais

futuros. Sabemos que as estratégias de ensino muito influenciam o aprendizado dos alunos
e não apenas o conteúdo. Portanto, embora tenhamos verificado quais algoritmos são
mais eficientes para resolver os problemas abordados, é necessário construir estratégias
adequadas para ensiná-los. Contudo, saber qual algoritmo é mais eficiente muda o olhar
do professor para a questão, tornando importante a escolha dos mais eficientes.

Para finalizar, entendemos que é importante dar um direcionamento para traba-
lhos futuros dentro do tema de pesquisa abordado neste trabalho. Uma possibilidade é
fazer uma busca por mais algoritmos escolares que possam ser comparados com outros
utilizados para o mesmo fim. Poderíamos, inclusive, estudar algoritmos típicos da mate-
mática superior, como os algoritmos numéricos para encontrar a raiz de um polinômio, por
exemplo. Uma outra possibilidade, esta bem mais difícil, é tentar escrever um algoritmo
para o cálculo de determinantes com complexidade inferior a 𝑛3.

Outro aspecto importante a ressaltar é a da possibilidade de se ensinar lógica
de programação ainda na educação básica. Para isso, podemos aproveitar fórmulas que
os alunos já utilizam, como a fórmula de Bháskara ou a regra de Sarrus, por exemplo,
para escrever programas simples que calculem as raízes reais de uma equação do 2o grau
(quando existirem) e o determinante de uma matriz 3 × 3 com entradas conhecidas ou
escrever, em pseudocódigo, algoritmos para problemas contemplados no currículo. Este
trabalho pode servir como uma ponte para abordar essas ideias.

Esperamos que este trabalho tenha sido útil para dar um novo olhar para os algo-
ritmos que usamos comumente e para dar ao professor de matemática um embasamento
teórico para a escolha dos algoritmos a serem ensinados nos casos da potenciação, máximo
divisor comum e determinantes.

Referências

67

ANDRINI Álvaro; VASCONCELOS, M. J. Praticando Matemática. 4a. ed. São Paulo:
Editora do Brasil, 2015. v. 6. Citado na página 41.

BARROSO, J. M.; MATHEUS, A. dos R.; NANI, A. P. S. Araribá Matemática. 3a. ed.
São Paulo: Editora Moderna, 2010. v. 6. Citado na página 53.

BIANCHINI, E. Matemática. 8a. ed. São Paulo: Editora Moderna, 2016. v. 6. Citado na
página 41.

CENTúRION, M.; JAKUBOVIC, J. Matemática na Medida Certa. 1a. ed. São Paulo:
Editora Leya, 2015. v. 6. Citado na página 41.

CHAVANTE, E. Série Convergências Matemática. 1a. ed. São Paulo: Editora SM, 2016.
v. 6. Citado na página 41.

CORMEN, T. H. et al. Algoritmos: teoria e prática. 3a. ed. São Paulo: Editora Campus,
2012. Citado 2 vezes nas páginas 23 e 24.

DANTE, L. R. Matemática. 1a. ed. São Paulo: Editora Ática, 2014. Citado na página 57.

DANTE, L. R. Matemática contexto e aplicações. 3a. ed. São Paulo: Editora Ática, 2016.
v. 2. Citado na página 42.

DANTE, L. R. Projeto Teláris Matemática. 2a. ed. São Paulo: Editora Ática, 2016. v. 6.
Citado na página 41.

DROZDEK, A. Estrutura de dados e algoritmos em C++. 1a. ed. São Paulo: CENGAGE
Learning, 2002. Citado na página 25.

ESQUINCA, S. R. A. Algoritmos: resolução de problemas básicos. Dissertação (Mestrado)
— Universidade Federal de Mato Grosso do Sul, 2014. Citado na página 21.

FEDERAL, G. do D. Censo Escolar do DF. 2017. Disponível em: <http://www.cre.se.df.
gov.br/ascom/documentos/censo/2017/2017_qd_pub_df_mat_ef_201_cre.pdf>. Ci-
tado na página 39.

FEDERAL, G. do D. Matrículas no Ensino Fundamental. 2018. Disponível em: <http:
//www.cre.se.df.gov.br/ascom/documentos/dados/2017/ii_d_escola.pdf>. Citado na
página 40.

FEDERAL, G. do D. Matrículas no Ensino Médio. 2018. Disponível em: <http://www.
cre.se.df.gov.br/ascom/documentos/dados/2017/ii_d_medio_escola.pdf>. Citado na
página 40.

GONçALVES, A. Introdução à Álgebra. 5. ed. Rio de Janeiro: IMPA, 2006. Citado 2
vezes nas páginas 30 e 44.

HEFEZ Ábramo. Aritmética. 1a. ed. Rio de Janeiro: Sociedade Brasileira Matemática,
2014. Citado na página 45.

68

Referências

IEZZI, G. et al. Matemática. 5a. ed. São Paulo: Editora Atual, 2011. Citado na página
56.

IEZZI, G. et al. Matemática: ciência e aplicações. 9a. ed. São Paulo: Editora Saraiva,
2016. v. 2. Citado na página 42.

IMENES, L. M.; LELLIS, M. Matemática Imenes & Lellis. 2a. ed. São Paulo: Editora
Moderna, 2012. v. 7. Citado na página 51.

LEONARDO, F. M. de. Conexões com a matemática. 3a. ed. São Paulo: Editora Moderna,
2016. v. 2. Citado na página 42.

LIMA, E. L. Analise Real. 9a. ed. Rio de Janeiro: IMPA, 2007. v. 1. Citado na página
28.

LIMA, E. L. et al. A Matemática do Ensino Médio. 6a. ed. Rio de Janeiro: Sociedade
Brasileira de Matemática, 2006. v. 2. Citado na página 50.

PAIVA, M. Matemática. 2a. ed. São Paulo: Editora Moderna, 2010. v. 2. Citado na
página 60.

SCHEINERMAN, E. R. Matemática Discreta. 2a. ed. São Paulo: CENGAGE Learning,
2011. Citado na página 46.

SILVEIRA Ênio. Matemática: Compreensão e Prática. 3a. ed. São Paulo: Editora Mo-
derna, 2016. v. 6. Citado na página 41.

STRANG, G. Álgebra Linear e Suas Aplicações. 4a. ed. São Paulo: CENGAGE Learning,
2010. Citado na página 30.

Apêndices

APÊNDICE A – Algoritmos dos
experimentos

71

No apêndice, mostramos os códigos escritos em linguagem Python para executar

os algoritmos do Capítulo 3.

A.1 Potenciação

Segue abaixo os códigos em Python para os Algoritmos 1 e 2. Em cada um deles
foi definido um contador do número de multiplicações executadas. Além disso, gerou-se,
de forma aleatória, uma base fixa 𝑎 ∈ N no intervalo de 1 a 100 e uma amostra com 100
valores aleatórios para o expoente 𝑛 ∈ N nos intervalos [1, 10], [1, 100], [1, 1000] e [1,
10000]. Por fim, para cada intervalo, o programa retornou dois valores: o limite superior
do intervalo e o número médio de multiplicações realizadas em cada amostra. Isto nos deu
uma base para confirmar as previsões da função de complexidade assintótica e também
para comparar os dois algoritmos.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

import random
# import matplotlib . pyplot as pl

def potenciacao (a , n , _ ) :

x = 1
mults = 0

for i in xrange ( n ) :

x = x * a
mults += 1

return (x , mults )

def potenciacao2 (a , n , mults ) :

if n == 1:

return (a , mults )

elif n % 2 == 0:

pot , m = potenciacao2 (a , n /2 , mults )
return ( pot * pot , m + mults + 1)

else :

pot , m = potenciacao2 (a , ( n - 1) /2 , mults )
return ( pot * pot * a , m + mults + 2)

72

APÊNDICE A. Algoritmos dos experimentos

25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69

limits = [10 , 100 , 1000 , 10000]
samples = 100
max_a = 1000

def exp ( f ) :
data = []

for limit in limits :

total = 0

for sample in xrange ( samples ) :
a = random . randint (1 , max_a )
n = random . randint (1 , limit )

_ , mults = f (a , n , 0)
total += mults

mean = 1.0* total / samples
data . append (( limit , mean ) )

return data

data1 = exp ( potenciacao )
data2 = exp ( potenciacao2 )

x1 = [ x for x , y in data1 ]
y1 = [ y for x , y in data1 ]

print data1
print x1
print y1

x2 = [ x for x , y in data2 ]
y2 = [ y for x , y in data2 ]

print data2
print x2
print y2

# pl . plot ( x1 , y1 )
# pl . plot ( x2 , y2 )
# pl . savefig ( ’ teste . png ’)
# pl . show ()

A.2. Máximo Divisor Comum

73

A.2 Máximo Divisor Comum

A seguir, apresentamos os códigos em Python para os Algoritmos 3 e 4. Em cada

um deles foi inserido um contador do número de divisões realizadas pelos algoritmos.

# !/ usr / bin / python
# -* - coding : utf -8 -* -
import sys
import math
import random
import matplotlib . pyplot as plt

def load_primes () :

with open ( ’ primes . txt ’) as f :

primes = [ int ( x ) for x in f . readlines () ]

return primes

def MDC (a , b , primes ) :

if b == 0:

return (a , 0)

else :

d , m = MDC (b , a % b , primes )
return (d , m + 1)

def MDC2 (a , b , primes ) :

d = 1
i = 0
total = 0

if a == 0:

return (b , 0)

if b == 0:

return (a , 0)

while i < len ( primes ) :

p = primes [ i ]

if p > a and p > b :
return (d , total )

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

74

APÊNDICE A. Algoritmos dos experimentos

44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80

81
82
83
84
85
86
87
88
89

ra = a % p
rb = b % p

total += 2

if ra == 0 and rb == 0:

a /= p
b /= p
d *= p
total += 2
elif ra == 0:

a /= p
total += 1
elif rb == 0:

b /= p
total += 1

else :

i += 1

return (d , total )

def experimento (f , g ) :

primes = load_primes ()
limits = [10 ** x for x in xrange (13) ]
samples = 100

data_f = []
res_f = []

data_g = []
res_g = []

for limit in limits :

inputs = [( random . randint (0 , limit ) , random . randint (0 , limit )

) for x in xrange ( samples ) ]

scenario = [( f , data_f , res_f ) , (g , data_g , res_g ) ]

for func , data , res in scenario :

total = 0

for a , b in inputs :

if a == 0 and b == 0:

a = 1

A.2. Máximo Divisor Comum

75

90
91

92
93
94
95
96
97
98
99
100
101
102
103

104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122

123

124
125
126
127
128
129
130
131

#

print ’ calculando mdc ({} ,{}) , funcao {} ’. format (a , b ,

func )

d , divs = func (a , b , primes )
total += divs
res . append (( a , b , d ) )

mean = 1.0 * total / samples
data . append (( limit , mean ) )

for i in xrange ( len ( res_f ) ) :
if res_f [ i ] != res_g [ i ]:

a , b , d = res_f [ i ]
A , B , D = res_g [ i ]
print " Erro no calculo do MDC ! a = {} , b = {} , d = {} , A =

{} , B = {} , D = {} " . format (a , b , d , A , B , D )

sys . exit ( -1)

return ( data_f , data_g )

if __name__ == ’ __main__ ’:

data1 , data2 = experimento ( MDC , MDC2 )

x1 = [ math . log10 ( x ) for x , y in data1 ]
y1 = [ y for x , y in data1 ]

x2 = [ math . log10 ( x ) for x , y in data2 ]
y2 = [ y for x , y in data2 ]

print data1
print data2

euclides = plt . plot ( x1 , y1 , ’ -- ’ , label = u ’ Pelo Algoritmo de

Euclides ’)

decomposicao = plt . plot ( x2 , y2 , label = u ’ Por decomposicao em

fatores primos ’)

plt . xlabel ( ’ Log ( a ) ’ , fontsize =12)
plt . ylabel ( u ’ Numero de divisoes ’ , fontsize =12)
plt . legend ( bbox_to_anchor =(0.05 , 1) , loc =2 , borderaxespad =1.3)
axes = plt . gca ()
axes . set_xlim ([ -0.5 , 12.5])
axes . set_ylim ([ -1000 , 150000])
plt . savefig ( ’ euclides2 . png ’)
plt . show ()

76

APÊNDICE A. Algoritmos dos experimentos

A.3 Determinantes

Por fim, apresentamos os códigos em Python para os Algoritmos 7 e 8. Em cada
código foi inserido um contador do número de multiplicações realizadas pelos algoritmos.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

# !/ usr / bin / python
# -* - coding : utf -8 -* -
import sys
import math
import random
import numpy as np
import matplotlib . pyplot as pl

def random_matrix (n , limit = 10) :

A = np . zeros (( n , n ) )

for x in xrange ( n ) :

for y in xrange ( n ) :

A [ x ][ y ] = random . randint ( - limit , limit )

return A

def cofatores ( A ) :

if A . size == 1:

# Matriz 1 x 1

return ( A [0][0] , 0)

else :

n , _ = A . shape

i = 0

# Linha 0

det = 0
mults = 0

for j in xrange ( n ) :

B = np . zeros (( n - 1 , n - 1) )

s = 0
r = 0

for x in xrange ( n ) :

if x == i :
continue

A.3. Determinantes

77

44
45
46
47
48
49
50
51
52

53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89

for y in xrange (0 , n ) :

if y == j :
continue

# print ’B = ’ , B
# print ’A = ’ , A
# print ’i = {} , j = {} , Copiando elemento A [{}][{}]

para B [{}][{}] ’. format (i , j , x , y , s , r )

B [ s ][ r ] = A [ x ][ y ]
r += 1

s += 1
r = 0

d , m = cofatores ( B )
mults += m
det += (1 - 2 * (( i + j ) % 2) ) * A [ i ][ j ] * d
mults += 3

return ( det , mults )

def gauss ( A ) :

n , _ = A . shape
total = 0

for x in xrange ( n ) :

pivot = -1
k = x

while k < n and pivot == -1:

if A [ k ][ x ] != 0:

pivot = k
break

else :

k += 1

if pivot == -1:

return (0 , total )

if pivot != x :

for y in xrange (x , n ) :

78

APÊNDICE A. Algoritmos dos experimentos

90
91
92
93
94

95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135

A [ x ][ y ] , A [ pivot ][ y ] = A [ pivot ][ y ] , A [ x ][ y ]

for z in xrange ( x + 1 , n ) :

for y in xrange ( n - 1 , x - 1 , -1) :

# print ’ Atualizando A [{}][{}] a partir de A [{}][{}] , pivo

A [{}][{}] ’. format (z , y , x , y , x , x )

A [ z ][ y ] -= ( A [ x ][ y ] * A [ z ][ x ]) / A [ x ][ x ]
total += 1

det = 1

for x in xrange ( n ) :
det *= A [ x ][ x ]

# print ’U = ’ , A
return ( round ( det ) , total )

def experimento (f , g ) :

limits = range (1 , 9)
samples = 10

data_f = []
res_f = []

data_g = []
res_g = []

for limit in limits :

inputs = [ random_matrix ( limit ) for x in xrange ( samples ) ]
scenario = [( f , data_f , res_f ) , (g , data_g , res_g ) ]

for func , data , res in scenario :

total = 0

for A in inputs :

det , mults = func ( A )
total += mults
res . append (( det , A ) )

mean = 1.0 * total / samples
data . append (( limit , mean ) )

# for i in xrange ( len ( res_f ) ) :
if res_f [ i ] != res_g [ i ]:
#

A.3. Determinantes

79

136
137
138

139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168

#
#
#

#

d , A = res_f [ i ]
c , B = res_g [ i ]
print " Erro no calculo do determinante ! d = {} , A = {} , c

= {} , B = {}". format (d , A , c , B )

sys . exit ( -1)

return ( data_f , data_g )

if __name__ == ’ __main__ ’:

random . seed (1)

data1 , data2 = experimento ( cofatores , gauss )

x1 = [ x for x , y in data1 ]
y1 = [ y for x , y in data1 ]

x2 = [ x for x , y in data2 ]
y2 = [ y for x , y in data2 ]

print data1
print data2

cofatores = pl . plot ( x1 , y1 , ’ -- ’ , label = ’ Por cofatores ’)
escalonamento = pl . plot ( x2 , y2 , label = ’ Por escalonamento ’)
pl . xlabel ( u ’ Dimensao da matriz ’ , fontsize =14)
pl . ylabel ( u ’ Numero de multiplicacoes ’ , fontsize =14)
pl . legend ( bbox_to_anchor =(0.05 , 1) , loc =2 , borderaxespad =1.5)
axes = pl . gca ()
axes . set_xlim ([0 , 8.5])
axes . set_ylim ([ -2000 , 200000])
pl . savefig ( ’ matrizes . png ’)
pl . show ()

