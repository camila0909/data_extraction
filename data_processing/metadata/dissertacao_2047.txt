Universidade de BrasÃ­lia
Instituto de CiÃªncias Exatas
Departamento de MatemÃ¡tica
Programa de Mestrado Profissional
em MatemÃ¡tica em Rede Nacional

AvaliaÃ§Ã£o de Algoritmos Ensinados no Ensino
Fundamental e MÃ©dio Sob a Perspectiva da
AnÃ¡lise de Complexidade

Bruno Macedo Alves

BrasÃ­lia

2018

Bruno Macedo Alves

AvaliaÃ§Ã£o de Algoritmos Ensinados no Ensino

Fundamental e MÃ©dio Sob a Perspectiva da AnÃ¡lise de

Complexidade

DissertaÃ§Ã£o apresentada ao Departamento
de MatemÃ¡tica da Universidade de BrasÃ­-
lia, como parte dos requisitos do â€œProgramaâ€
de Mestrado Profissional em MatemÃ¡tica em
Rede Nacional - PROFMAT, para obtenÃ§Ã£o
do grau de Mestre.

Universidade de BrasÃ­lia - UnB

Departamento de MatemÃ¡tica - MAT

PROFMAT - SBM

Orientador: Prof. Dr. Edson Alves da Costa JÃºnior

BrasÃ­lia

2018

PosiÃ§Ã£o vertical

Bruno Macedo Alves

AvaliaÃ§Ã£o de Algoritmos Ensinados no Ensino Fundamental e MÃ©dio Sob a
Perspectiva da AnÃ¡lise de Complexidade/ Bruno Macedo Alves. â€“ BrasÃ­lia, 2018-

79 p. : il. (algumas color.) ; 30 cm.

Orientador: Prof. Dr. Edson Alves da Costa JÃºnior

DissertaÃ§Ã£o de Mestrado â€“ Universidade de BrasÃ­lia - UnB
Departamento de MatemÃ¡tica - MAT
PROFMAT - SBM, 2018.
1. Algoritmos. 2. Complexidade. I. Edson Alves da Costa JÃºnior. II. Universi-
dade de BrasÃ­lia. III. PROFMAT - SBM. IV. AvaliaÃ§Ã£o de Algoritmos Ensinados
nos Ensinos Fundamental e MÃ©dio Sob a Perspectiva da AnÃ¡lise de Complexidade

CDU XYZ 02:141:005.7

Universidade de BrasÃ­lia
Instituto de CiÃªncias Exatas
Departamento de MatemÃ¡tica

AvaliaÃ§Ã£o de Algoritmos Ensinados no
Ensino Fundamental e MÃ©dio Sob a
Perspectiva da AnÃ¡lise de Complexidade

por

Bruno Macedo Alves

DissertaÃ§Ã£o apresentada ao Departamento de MatemÃ¡tica da Universidade de BrasÃ­lia,
como parte dos requisitos do â€œProgramaâ€ de Mestrado Profissional em MatemÃ¡tica em
Rede Nacional - PROFMAT, para obtenÃ§Ã£o do grau de

MESTRE

BrasÃ­lia, 11 de junho de 2018

ComissÃ£o Examinadora:

Prof. Dr. Edson Alves da Costa JÃºnior- FGA/UnB (Orientador)

Prof. Dr. VinÃ­cius de Carvalho RÃ­spoli - FGA/UnB (Membro)

Prof. Dr. FÃ¡bio Macedo Mendes - FGA/UnB (Membro)

Dedico este trabalho a todos os professores de MatemÃ¡tica que, incansavelmente,
esforÃ§am-se para fazer com que seus alunos aprendam este incrÃ­vel conhecimento, apesar
de todas as dificuldades.

Agradecimentos

A Deus. Aos meus pais, por terem me ajudado a ser quem sou e por todo o amor
dispendido comigo. Ã€ minha esposa RaÃ­za, pela compreensÃ£o, suporte e carinho nas horas
em que mais precisei. Ã€ minha irmÃ£ Carolina, por ter sido sempre uma referÃªncia para
mim. Ao meu irmÃ£o Marcelo, por ser meu melhor amigo e por ouvir sempre as ideias
que quis colocar neste trabalho. Ã€ minha famÃ­lia e amigos, por me darem apoio e ficarem
sempre ao meu lado.

Agradecimentos especiais ao meu orientador, professor Edson, por todo o suporte
dado durante o trabalho com dicas e com soluÃ§Ãµes geniais para problemas que, sozinho,
eu nÃ£o conseguiria resolver. Sem sua ajuda nÃ£o teria terminado este trabalho. AgradeÃ§o
tambÃ©m a meus amigos do MAT 2/2004 pelo encorajamento nestes dois Ã¡rduos anos,
especialmente aos amigos Henrique Zannata, Thiago Wiliams e Matheus Bernardini pelo
tempo gasto me ajudando a resolver problemas relacionados a essa dissertaÃ§Ã£o.

NÃ£o posso deixar de mencionar tambÃ©m meus colegas e amigos da turma do PROF-
MAT 2016, que me inspiraram com experiÃªncias, modos de agir e pensar, os quais fizeram-
me crescer muito como professor e como estudante de matemÃ¡tica. AgradeÃ§o tambÃ©m a
meus professores, os quais abriram minha mente para novas ideias e novos modos de
pensar matemÃ¡tica.

Ao IMPA e Ã  SBM pela iniciativa do PROFMAT. Este curso tem contribuÃ­do de

forma significativa para a melhoria do ensino da matemÃ¡tica no Brasil.

Por fim, agradeÃ§o ao meu amigo Bruno Henrique por ter disponibilizado seu tempo
e sua casa para me ajudar com os algoritmos contidos neste trabalho, ao VinÃ­cius Ran-
gel, pela disponibilidade para me ajudar com os bugs do sistema, ao professor Julwaity
Quaresma, pela ajuda com as traduÃ§Ãµes para o inglÃªs e ao Dhiego Loyola pela ajuda com
o Latex.

â€œNÃ£o podemos decidir quando nascemos. Tudo o que podemos decidir Ã© o que fazer com
o tempo que nos Ã© dado. â€
J. R. R. Tolkien

Resumo

Este trabalho faz uma comparaÃ§Ã£o entre algoritmos ensinados na escola para a poten-
ciaÃ§Ã£o, o mÃ¡ximo divisor comum e os determinantes, do ponto de vista da anÃ¡lise de
complexidade. O trabalho busca determinar qual o algoritmo mais eficiente dentre aque-
les comumente apresentados. A anÃ¡lise Ã© feita primeiramente escrevendo os algoritmos em
pseudocÃ³digo, para em seguida descrever o comportamento da funÃ§Ã£o que dÃ¡ o tempo de
execuÃ§Ã£o do algoritmo em funÃ§Ã£o do tamanho da entrada.

Palavras-chaves: Algoritmos. Complexidade.

Abstract

This work compares the algorithms teached at school to the exponentiation, the greatest
comon divisor and the determinants, from the point of view of the complexity analysis. The
work intends to determine which is the most efficient algorithm among those commonly
presented. The analysis is done by firstly writing the algorithms in a pseudocode, then
describing the behavior of the function that gives the time of execution of the algorithm
based on the input size.

Key-words: Algorithms. Complexity.

Lista de ilustraÃ§Ãµes

Figura 1 â€“ Algoritmos de potenciaÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . . 53
Figura 2 â€“ Algoritmos de mÃ¡ximo divisor comum . . . . . . . . . . . . . . . . . . 56
Figura 3 â€“ Algoritmos de determinantes . . . . . . . . . . . . . . . . . . . . . . . . 63

Lista de tabelas

Tabela 1 â€“ Coordenadorias Regionais de Ensino (CRE) com maior nÃºmero de ma-

trÃ­culas â€“ Ensino Fundamental II (6o ao 9o ano) . . . . . . . . . . . . . 40

Tabela 2 â€“ Coordenadorias Regionais de Ensino (CRE) com maior nÃºmero de ma-

trÃ­culas â€“ Ensino MÃ©dio . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Tabela 3 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino Fundamental II â€“

CRE CeilÃ¢ndia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Tabela 4 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino Fundamental II â€“

CRE Planaltina . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Tabela 5 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino Fundamental II â€“

CRE Plano Piloto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

Tabela 6 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino MÃ©dio â€“ CRE

CeilÃ¢ndia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

Tabela 7 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino MÃ©dio â€“ CRE

Taguatinga . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

Tabela 8 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino MÃ©dio - CRE Plano

Piloto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
Tabela 9 â€“ Quantidade de adiÃ§Ãµes do Algoritmo 7 . . . . . . . . . . . . . . . . . . 48
Tabela 10 â€“ NÃºmero mÃ©dio de multiplicaÃ§Ãµes para os Algoritmos 1 e 2 . . . . . . . 52
Tabela 11 â€“ NÃºmero mÃ©dio de divisÃµes para os Algoritmos 3 e 4 . . . . . . . . . . . 55
Tabela 12 â€“ NÃºmero mÃ©dio de multiplicaÃ§Ãµes os Algoritmos 7 e 8 . . . . . . . . . . 62

SumÃ¡rio

1
1.1
1.2
1.3
1.4

2
2.1
2.2
2.3
2.3.1
2.3.2
2.3.3

3
3.1
3.2
3.3

4

IntroduÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

FUNDAMENTAÃ‡ÃƒO TEÃ“RICA . . . . . . . . . . . . . . . . . . . . 23
Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
AnÃ¡lise de Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
NotaÃ§Ã£o AssintÃ³tica . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
Conceitos Elementares . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

METODOLOGIA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Escolha dos Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Escolha e VerificaÃ§Ã£o dos Livros DidÃ¡ticos . . . . . . . . . . . . . . . 39
Problemas Escolhidos
. . . . . . . . . . . . . . . . . . . . . . . . . . . 42
PotenciaÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
MÃ¡ximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Determinantes

RESULTADOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
Algoritmos de PotenciaÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . 51
Algoritmos de MDC . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
Algoritmos de Determinantes . . . . . . . . . . . . . . . . . . . . . . . 56

CONSIDERAÃ‡Ã•ES FINAIS . . . . . . . . . . . . . . . . . . . . . . . 65

REFERÃŠNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

APÃŠNDICES

69

A.1
A.2
A.3

APÃŠNDICE A â€“ ALGORITMOS DOS EXPERIMENTOS . . . . . . 71
PotenciaÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
MÃ¡ximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . . . . 73
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
Determinantes

IntroduÃ§Ã£o

21

O aprendizado de matemÃ¡tica passa pela execuÃ§Ã£o de algoritmos. Desde crian-
Ã§as, aprendemos algoritmos para somar e subtrair, por exemplo. Contudo, durante muito
tempo, as pessoas tem sido ensinadas, de geraÃ§Ã£o em geraÃ§Ã£o, a executarem os mesmos
algoritmos. Mas serÃ¡ que esses algoritmos sÃ£o os mais eficientes, dentre aqueles que po-
deriam ser ensinados aos estudantes?

Estudando os algoritmos para efetuar uma potenciaÃ§Ã£o com base e expoente natu-
rais, para determinar o mÃ¡ximo divisor comum entre dois nÃºmeros naturais e para calcular
determinantes de matrizes, busca-se avaliar, neste trabalho, a eficiÃªncia destes algoritmos.
SerÃ¡ que os professores de matemÃ¡tica tem ensinado os melhores algoritmos que existem,
do ponto de vista da anÃ¡lise de complexidade assintÃ³tica?

Por isso, acreditamos que hÃ¡ uma necessidade imediata de rever tais algoritmos
e de propor sugestÃµes de mudanÃ§as. Para que isto ocorra, entretanto, temos que fazer
uma anÃ¡lise da complexidade assintÃ³tica desses algoritmos. Esta anÃ¡lise descreve o com-
portamento do tempo de execuÃ§Ã£o do algoritmo em funÃ§Ã£o da quantidade de operaÃ§Ãµes
realizadas Ã  medida que o tamanho da entrada aumenta. A entrada varia conforme o pro-
blema: o expoente, no caso da potenciaÃ§Ã£o, o tamanho dos nÃºmeros, no caso do mÃ¡ximo
divisor comum e a dimensÃ£o da matriz, no caso do determinante.

Analisando a literatura disponÃ­vel, encontramos o trabalho de Esquinca (2014).
Neste trabalho, Esquinca analisa a complexidade de diversos algoritmos e os escreve em
pseudocÃ³digo. Contudo, seus objetivos sÃ£o um pouco diferentes, pois sÃ£o mais voltados
para a apresentaÃ§Ã£o dos algoritmos e o ensino de programaÃ§Ã£o na escola bÃ¡sica. Nosso
objetivo neste trabalho serÃ¡ o de comparar os algoritmos e verificar, por meios indiretos,
quais os que sÃ£o comumente adotados nas escolas.

O trabalho busca responder Ã  seguinte pergunta de pesquisa: Os algoritmos en-
sinados no ensino mÃ©dio e fundamental para o cÃ¡lculo de potenciaÃ§Ãµes, mÃ¡ximo divisor
comum e determinantes sÃ£o computacionalmente eficientes?

Objetivos

Este trabalho tem o objetivo de avaliar os algoritmos usualmente ensinados na
escola para o cÃ¡lculo de potenciaÃ§Ãµes, mÃ¡ximo divisor comum e determinantes, sugerindo,
ao final, que sejam adotados os mÃ©todos que forem computacionalmente mais eficiente.

Para isto, iremos fazer um estudo da anÃ¡lise de complexidade assintÃ³tica, consul-
tando a literatura bÃ¡sica sobre o assunto. Depois, iremos aplicar os conceitos da anÃ¡lise de

22

IntroduÃ§Ã£o

complexidade assintÃ³tica no caso dos algoritmos de potenciaÃ§Ãµes, mÃ¡ximo divisor comum
e determinantes. Em seguida, faremos uma revisÃ£o dos livros didÃ¡ticos comumente ado-
tados no 6a ano do ensino fundamental e no 2o ano do ensino mÃ©dio para verificar quais
algoritmos sÃ£o apresentados nestes livros. Por fim, escreveremos os algoritmos em Python
e, por meio de amostras aleatÃ³rias, confirmaremos os resultados obtidos na anÃ¡lise.

Estrutura do Trabalho

O trabalho estÃ¡ dividido em 4 capÃ­tulos. No CapÃ­tulo 1, faz-se uma exposiÃ§Ã£o dos
conceitos teÃ³ricos bÃ¡sicos necessÃ¡rios ao entendimento do trabalho. SerÃ£o abordados o
conceito de algoritmo, de complexidade assintÃ³tica, bem como resultados bÃ¡sicos relacio-
nados Ã  potenciaÃ§Ã£o, ao mÃ¡ximo divisor comum e aos determinantes.

O CapÃ­tulo 2 discute a metodologia utilizada para a escolha dos algoritmos e
dos exemplos didÃ¡ticos abordados ao longo do trabalho. Nele tambÃ©m sÃ£o apresentados
os algoritmos escolhidos. ApÃ³s a sua apresentaÃ§Ã£o, faz-se uma anÃ¡lise de complexidade
baseada na contagem das operaÃ§Ãµes e no tempo de execuÃ§Ã£o. O tempo de execuÃ§Ã£o Ã©
considerado constante para cada operaÃ§Ã£o do mesmo tipo, o que simplifica a anÃ¡lise.
Busca-se, portanto, determinar nÃ£o uma funÃ§Ã£o especÃ­fica, mas sim uma classe de funÃ§Ãµes
que represente o tempo de execuÃ§Ã£o de cada algoritmo.

O CapÃ­tulo 3 cuida da aplicaÃ§Ã£o dos algoritmos em exemplos de livros didÃ¡ticos
comumente adotados nos ensinos mÃ©dio e fundamental e computacionais, com entradas
aleatÃ³rias geradas em linguagem Python. Estes exemplos mostram a grande diferenÃ§a que
faz a escolha por um algoritmo eficiente. Segue-se uma anÃ¡lise das escolhas de algoritmos
feitas no contexto escolar.

O CapÃ­tulo 4 apresenta a opiniÃ£o do autor, respondendo a pergunta de pesquisa

proposta na introduÃ§Ã£o, a qual defende a escolha pelos algoritmos mais eficientes.

1 FundamentaÃ§Ã£o TeÃ³rica

23

Neste capÃ­tulo iremos apresentar os conceitos relacionados a algoritmos. Faremos
tambÃ©m uma breve exposiÃ§Ã£o sobre o uso da notaÃ§Ã£o assintÃ³tica no estudo do crescimento
de funÃ§Ãµes e suas aplicaÃ§Ãµes Ã  anÃ¡lise da eficiÃªncia de algoritmos. Na SeÃ§Ã£o 1.1 estabele-
ceremos o conceito de algoritmo e apresentaremos a linguagem que serÃ¡ utilizada para a
descriÃ§Ã£o dos mesmos. Na SeÃ§Ã£o 1.2 trataremos da anÃ¡lise de algoritmos e dos critÃ©rios
fundamentais para esta anÃ¡lise. Um desenvolvimento sobre a notaÃ§Ã£o assintÃ³tica e seu
uso na anÃ¡lise de algoritmos Ã© feito na SeÃ§Ã£o 1.3. O capÃ­tulo termina com uma revisÃ£o
de conceitos e resultados relacionados Ã  potenciaÃ§Ã£o, ao mÃ¡ximo divisor comum e aos
determinantes.

1.1 Algoritmos

Um algoritmo Ã© qualquer procedimento computacional bem definido que toma
algum valor ou conjunto de valores como entrada e produz algum valor ou conjunto de
valores como saÃ­da. O valor ou conjunto de valores de entrada Ã© denominado instÃ¢ncia
do problema. Por exemplo, um algoritmo que some dois inteiros transforma os valores de
entrada (25, 57) no valor de saÃ­da 82, que Ã© o resultado da soma.

Dizemos que um algoritmo Ã© correto se, para toda instÃ¢ncia de entrada, ele produzir
a saÃ­da correta. Logo, um algoritmo Ã© incorreto se, para uma certa instÃ¢ncia, nÃ£o parar
(um computador pode nÃ£o concluir um algoritmo ou demorar mais tempo do que estamos
dispostos a esperar) ou se produzir uma resposta incorreta (CORMEN et al., 2012).

Mesmo que um algoritmo esteja correto, Ã© importante analisar o seu desempenho
mediante determinados critÃ©rios de eficiÃªncia. O motivo para tal anÃ¡lise Ã© que algoritmos
utilizam espaÃ§o em memÃ³ria para armazenar dados enquanto operam, e seus procedimen-
tos levam um determinado intervalo de tempo para serem executados. Ora, a memÃ³ria
disponÃ­vel em um computador nÃ£o Ã© infinita e, tampouco, gratuita. AlÃ©m disso, nÃ£o se
pode esperar indefinidamente para que um algoritmo produza a resposta certa para uma
instÃ¢ncia de um problema. DaÃ­ a importÃ¢ncia de se medir a eficiÃªncia de um algoritmo,
eficiÃªncia esta, em geral, medida pelo seu tempo de execuÃ§Ã£o. Dois algoritmos distin-
tos, mesmo que sejam ambos corretos, podem levar tempos diferentes para resolver uma
mesma instÃ¢ncia de um problema.

Ao longo deste trabalho iremos utilizar um pseudocÃ³digo semelhante a algumas
linguagens de programaÃ§Ã£o, como C, Python, Java ou Pascal. Um pseudocÃ³digo Ã© uma
lista de comandos escrita em linguagem comum para descrever um algoritmo, mas que

24

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

incorpora algumas das principais funÃ§Ãµes de uma linguagem de programaÃ§Ã£o padrÃ£o, como
as citadas acima. Iremos utilizar as convenÃ§Ãµes usadas em (CORMEN et al., 2012):

(a) o recuo indica estrutura de bloco. Assim, as linhas de comando dentro de uma
estrutura qualquer devem ter um recuo maior. Uma nova estrutura deve receber um
recuo igual ao que iniciou a estrutura anterior;

(b) os laÃ§os for, while, if-else, repeat-until tem a mesma interpretaÃ§Ã£o das lin-

guagens de programaÃ§Ã£o C, C++, Pascal, Java ou Python;

(c) o sÃ­mbolo = tem o sentido de atribuiÃ§Ã£o. Por exemplo, se escrevemos ğ‘– = ğ‘– + 1

significa que Ã  variÃ¡vel ğ‘– serÃ¡ atribuÃ­do o valor ğ‘– + 1;

(d) elementos de um vetor serÃ£o acessados especificando-se o nome do vetor, seguido
pelo Ã­ndice entre colchetes. Por exemplo, ğ´[ğ‘–] indica o ğ‘–-Ã©simo elemento do vetor A;

(e) os atributos de um objeto serÃ£o indicados por pontos. Por exemplo, ğ´.ğ‘› significa

que o vetor ğ´ tem ğ‘› elementos;

(f) se um dado valor de saÃ­da Ã© nulo ou vazio, usaremos o valor especial NIL.

1.2 AnÃ¡lise de Algoritmos

Analisar um algoritmo significa prever os recursos de que o algoritmo necessita.
Recursos como memÃ³ria ou hardware podem fazer parte desta anÃ¡lise, mas frequentemente
o tempo de computaÃ§Ã£o Ã© o principal parÃ¢metro considerado. Neste trabalho, iremos uti-
lizar um modelo de computaÃ§Ã£o genÃ©rico de mÃ¡quina com memÃ³ria de acesso aleatÃ³rio
(Random Access Machine - RAM) com um Ãºnico processador como tecnologia de im-
plementaÃ§Ã£o. AlÃ©m disso, iremos considerar que cada instruÃ§Ã£o Ã© executada em tempo
constante.

A anÃ¡lise do tempo que um algoritmo leva para ser executado, em geral, depende
do tamanho n da entrada. Para fazer esta anÃ¡lise, contamos o nÃºmero de operaÃ§Ãµes
primitivas para uma dada entrada de tamanho n. Cada linha no cÃ³digo do algoritmo,
por hipÃ³tese, leva um tempo constante para ser executada e o nÃºmero de vezes em que
a linha Ã© executada Ã© uma funÃ§Ã£o de n. Somando-se o tempo de execuÃ§Ã£o de cada passo,
obtemos o tempo de execuÃ§Ã£o total do algoritmo, o qual, consequentemente, tambÃ©m serÃ¡
uma funÃ§Ã£o de n.

Ã‰ fÃ¡cil ver que o tempo de execuÃ§Ã£o de um algoritmo tambÃ©m depende da instÃ¢ncia,
em particular, que estÃ¡ sendo processada. Por exemplo, um algoritmo que ordene um
vetor de nÃºmeros pode levar um tempo menor para ser executado quando a entrada estÃ¡
parcialmente ordenada do que quando a entrada estÃ¡ completamente desordenada.

1.3. NotaÃ§Ã£o AssintÃ³tica

25

Deste modo, a anÃ¡lise de algoritmos contempla o pior caso, o melhor caso e o caso
mÃ©dio. O pior caso representa a situaÃ§Ã£o na qual o tempo de execuÃ§Ã£o Ã© o maior possÃ­vel,
e o melhor caso a situaÃ§Ã£o na qual o tempo de execuÃ§Ã£o Ã© o menor possÃ­vel. JÃ¡ o caso
mÃ©dio Ã© definido como a mÃ©dia sobre o nÃºmero de etapas executadas pelo algoritmo em
cada entrada, ponderadas pela probabilidade de ocorrÃªncia de cada entrada (DROZDEK,
2002).

O estudo do pior caso Ã© o mais importante por trÃªs motivos: em primeiro lugar,
o tempo de execuÃ§Ã£o do pior caso de um algoritmo estabelece um limite superior para
o tempo de execuÃ§Ã£o de qualquer instÃ¢ncia. ConhecÃª-lo nos dÃ¡ uma garantia de que
o algoritmo nunca demorarÃ¡ mais do que esse tempo. Em segundo lugar, para alguns
algoritmos, o pior caso ocorre com bastante frequÃªncia. Por exemplo, na pesquisa de um
banco de dados em busca de determinada informaÃ§Ã£o, o pior caso do algoritmo de busca
ocorre quando a informaÃ§Ã£o nÃ£o estÃ¡ presente no banco de dados. Por fim, muitas vezes,
o tempo de execuÃ§Ã£o do caso mÃ©dio tende a ser igual ao do pior caso.

1.3 NotaÃ§Ã£o AssintÃ³tica

Para dar Ãªnfase Ã  ordem de crescimento do tempo de execuÃ§Ã£o de um algoritmo em
funÃ§Ã£o do tamanho da entrada n, iremos estudar a eficiÃªncia assintÃ³tica dos algoritmos,
ou seja, estaremos preocupados em como o tempo de execuÃ§Ã£o aumenta quando tomamos
o limite desta funÃ§Ã£o com n tendendo a infinito.

Como vimos, o tempo de execuÃ§Ã£o Ã© uma funÃ§Ã£o do tamanho da entrada n. Iremos

considerar que tais funÃ§Ãµes tem como domÃ­nio o conjunto dos nÃºmeros naturais.

DefiniÃ§Ã£o 1. (NotaÃ§Ã£o Î˜) Dizemos que uma funÃ§Ã£o ğ‘“ Ã© Î˜(ğ‘”(ğ‘›)) se existirem constantes
positivas ğ‘1, ğ‘2 e ğ‘›0 tais que 0 â‰¤ ğ‘1ğ‘”(ğ‘›) â‰¤ ğ‘“ (ğ‘›) â‰¤ ğ‘2ğ‘”(ğ‘›) para todo ğ‘› > ğ‘›0.

Por exemplo, a funÃ§Ã£o definida por ğ‘“ (ğ‘›) = 3ğ‘›2 âˆ’ 2 Ã© Î˜(ğ‘›2) pois, dados ğ‘1 = 4 e
ğ‘2 = 2, tem-se que 2ğ‘›2 â‰¤ ğ‘“ (ğ‘›) â‰¤ 4ğ‘›2 para todo ğ‘› â‰¥ ğ‘›0 = 2. Neste caso, cometendo um
abuso de notaÃ§Ã£o, escrevemos ğ‘“ (ğ‘›) = Î˜(ğ‘›2) e lemos ğ‘“ Ã© Î˜(ğ‘›2).

Dizer que uma funÃ§Ã£o ğ‘“ Ã© Î˜(ğ‘”(ğ‘›)) significa dizer que, para valores de ğ‘› suficien-
temente grandes, os valores de ğ‘“ estarÃ£o limitados pelos valores das funÃ§Ãµes ğ‘1ğ‘” e ğ‘2ğ‘”.
Embora estes valores de ğ‘” dependam das constantes ğ‘1 e ğ‘2 escolhidas, em geral nÃ£o nos
preocupamos com os valores destas constantes, mas sim com a existÃªncia delas.

DefiniÃ§Ã£o 2. (NotaÃ§Ã£o ğ‘‚) Dizemos que ğ‘“ Ã© ğ‘‚(ğ‘”(ğ‘›)) se existem constantes positivas ğ‘ e
ğ‘›0 tais que 0 â‰¤ ğ‘“ (ğ‘›) â‰¤ ğ‘ğ‘”(ğ‘›) para todo ğ‘› > ğ‘›0.

Enquanto a notaÃ§Ã£o Î˜(ğ‘”(ğ‘›)) dÃ¡ limites assintÃ³ticos acima e abaixo para a funÃ§Ã£o

26

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

ğ‘“ (ğ‘›), a notaÃ§Ã£o ğ‘‚(ğ‘›) dÃ¡ um limite assintÃ³tico superior apenas. Se ğ‘“ (ğ‘›) representar o
tempo de execuÃ§Ã£o de um algoritmo para uma instÃ¢ncia de tamanho ğ‘›, dizer que ğ‘“ (ğ‘›)
Ã© ğ‘‚(ğ‘›2), por exemplo, significa dizer que o tempo de execuÃ§Ã£o do pior caso cresce como
uma funÃ§Ã£o quadrÃ¡tica, isto Ã©, proporcional a ğ‘›2.

De modo semelhante, a notaÃ§Ã£o Î© nos dÃ¡ um limite assintÃ³tico inferior para uma

dada funÃ§Ã£o ğ‘“ (ğ‘›).

DefiniÃ§Ã£o 3. (NotaÃ§Ã£o Î©) Uma funÃ§Ã£o ğ‘“ Ã© dita Î©(ğ‘”(ğ‘›)) se existirem constantes positivas
ğ‘ e ğ‘›0 tais que 0 â‰¤ ğ‘ğ‘”(ğ‘›) â‰¤ ğ‘“ (ğ‘›) para todo ğ‘› > ğ‘›0.

As notaÃ§Ãµes Î˜, O e Î© se relacionam por meio do importante teorema a seguir.

Teorema 1. Para quaisquer duas funÃ§Ãµes ğ‘“ (ğ‘›) e ğ‘”(ğ‘›), temos ğ‘“ (ğ‘›) = Î˜(ğ‘”(ğ‘›)) se, e
somente se, ğ‘“ (ğ‘›) = ğ‘‚(ğ‘”(ğ‘›)) e ğ‘“ (ğ‘›) = Î©(ğ‘”(ğ‘›)).

DemonstraÃ§Ã£o: Suponha que ğ‘“ (ğ‘›) = Î˜(ğ‘”(ğ‘›)). Isto implica que existem constan-
tes positivas ğ‘1 e ğ‘2 tais que 0 â‰¤ ğ‘1ğ‘”(ğ‘›) â‰¤ ğ‘“ (ğ‘›) â‰¤ ğ‘2ğ‘”(ğ‘›). Logo, 0 â‰¤ ğ‘1ğ‘”(ğ‘›) â‰¤ ğ‘“ (ğ‘›) e
0 â‰¤ ğ‘“ (ğ‘›) â‰¤ ğ‘2ğ‘”(ğ‘›), ou seja, ğ‘“ (ğ‘›) = Î©(ğ‘”(ğ‘›)) e ğ‘“ (ğ‘›) = ğ‘‚(ğ‘”(ğ‘›)).

Por outro lado, suponha que ğ‘“ (ğ‘›) = ğ‘‚(ğ‘”(ğ‘›)) e ğ‘“ (ğ‘›) = Î©(ğ‘”(ğ‘›)). Por definiÃ§Ã£o,
existem constantes positivas ğ‘1 e ğ‘2 tais que 0 â‰¤ ğ‘“ (ğ‘›) â‰¤ ğ‘2ğ‘”(ğ‘›) e 0 â‰¤ ğ‘1ğ‘”(ğ‘›) â‰¤ ğ‘“ (ğ‘›),
respectivamente. Logo, 0 â‰¤ ğ‘1ğ‘”(ğ‘›) â‰¤ ğ‘“ (ğ‘›) â‰¤ ğ‘2ğ‘”(ğ‘›), o que mostra que ğ‘“ (ğ‘›) = Î˜(ğ‘”(ğ‘›)).

(cid:3)

1.4 Conceitos Elementares

PotenciaÃ§Ã£o

A potenciaÃ§Ã£o Ã© a operaÃ§Ã£o que escreve uma multiplicaÃ§Ã£o de fatores iguais de

forma resumida.

DefiniÃ§Ã£o 4. (PotenciaÃ§Ã£o) Dados dois nÃºmeros naturais a e n, a expressÃ£o ğ‘ğ‘› representa
um produto de n fatores iguais a a, ou seja,

ğ‘ğ‘› = ğ‘ Â· ğ‘ Â· . . . Â· ğ‘

.

âŸ

 â
ğ‘› fatores

Neste caso, dizemos que a Ã© a base e n Ã© o expoente da potenciaÃ§Ã£o. AlÃ©m disso, definimos
os casos especiais ğ‘1 = ğ‘ e ğ‘0 = 1.

A DefiniÃ§Ã£o 4 nos diz que 74, por exemplo, Ã© igual a 7 Ã— 7 Ã— 7 Ã— 7. Para computar
este nÃºmero, devemos multiplicar os dois primeiros fatores, obtendo 49. Este resultado

 
1.4. Conceitos Elementares

27

deve ser multiplicado pelo prÃ³ximo fator, donde se tem 343. Por fim, multiplicamos 343
pelo quarto e Ãºltimo fator, obtendo o resultado 2401.

Algumas propriedades da potenciaÃ§Ã£o sÃ£o bem conhecidas e estÃ£o enumeradas a

seguir.

ProposiÃ§Ã£o 1. Dados os nÃºmeros naturais ğ‘, ğ‘, ğ‘š e ğ‘›, temos que

1. ğ‘ğ‘š Â· ğ‘ğ‘› = ğ‘ğ‘š+ğ‘›

2.

ğ‘ğ‘š
ğ‘ğ‘› = ğ‘ğ‘šâˆ’ğ‘›, se ğ‘š â‰¥ ğ‘›

3. (ğ‘ğ‘š)ğ‘› = ğ‘ğ‘šÂ·ğ‘›

4. ğ‘ğ‘š Â· ğ‘ğ‘š = (ğ‘ Â· ğ‘)ğ‘š

DemonstraÃ§Ã£o

1. ğ‘ğ‘š Â· ğ‘ğ‘› =

â›
âğ‘ Â· ğ‘ Â· . . . Â· ğ‘
 â
ğ‘š fatores

âŸ

â
â  Â·

â›
âğ‘ Â· ğ‘ Â· . . . Â· ğ‘
 â
ğ‘› fatores

âŸ

â
â  = ğ‘ Â· ğ‘ Â· . . . Â· ğ‘
 â
ğ‘š+ğ‘› fatores

âŸ

= ğ‘ğ‘š+ğ‘›.

2. Se ğ‘š â‰¥ ğ‘›, entÃ£o ğ‘ğ‘š

ğ‘ğ‘› =

. Os fatores ğ‘ do denominador cancelarÃ£o os

fatores ğ‘ do numerador. RestarÃ£o, no mÃ¡ximo, ğ‘š âˆ’ ğ‘› fatores. Logo,

ğ‘ Â· ğ‘ Â· . . . Â· ğ‘
âŸ
 â
ğ‘š fatores
ğ‘ Â· ğ‘ Â· . . . Â· ğ‘
 â
âŸ
ğ‘› fatores

ğ‘ğ‘š
ğ‘ğ‘› = ğ‘ğ‘šâˆ’ğ‘›.

ğ‘š + ğ‘š + . . . + ğ‘š
 â
âŸ
ğ‘› parcelas

= ğ‘

= ğ‘ğ‘šğ‘›;

3. (ğ‘ğ‘š)ğ‘› = ğ‘ğ‘š Â· ğ‘ğ‘š Â· . . . Â· Â· Â· ğ‘ğ‘š

âŸ

 â
ğ‘› fatores

4. ğ‘ğ‘š Â· ğ‘ğ‘š = ğ‘ Â· ğ‘ Â· . . . Â· ğ‘
âŸ

 â
ğ‘š fatores

Â· ğ‘ Â· ğ‘ Â· . . . Â· ğ‘
 â
âŸ
ğ‘š fatores

= (ğ‘ğ‘) Â· (ğ‘ğ‘) Â· . . . Â· (ğ‘ğ‘)

= (ğ‘ğ‘)ğ‘š.

âŸ

 â
ğ‘š fatores

(cid:3)

MÃ¡ximo Divisor Comum

Quando dividimos um nÃºmero ğ‘ por ğ‘, obtemos um quociente ğ‘ e um resto ğ‘Ÿ, com
0 â‰¤ ğ‘Ÿ < ğ‘. Sabe-se que, para ğ‘ e ğ‘ quaisquer, com ğ‘ Ì¸= 0, ğ‘ e ğ‘Ÿ existem e sÃ£o Ãºnicos e

 
 
 
 
 
 
 
 
 
 
28

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

podemos escrever ğ‘ = ğ‘ğ‘ + ğ‘Ÿ, o que Ã© garantido pelo Teorema 3. Antes de demonstrÃ¡-
lo, porÃ©m, precisamos do princÃ­pio da boa ordenaÃ§Ã£o, uma propriedade fundamental dos
nÃºmeros naturais.

Teorema 2.
possui um menor elemento.

(PrincÃ­pio da Boa OrdenaÃ§Ã£o) Todo subconjunto dos nÃºmeros naturais

A demonstraÃ§Ã£o foge do escopo deste trabalho e serÃ¡ omitida. Para mais detalhes,

consulte (LIMA, 2007).

Teorema 3. (DivisÃ£o Euclidiana) Dados os nÃºmeros naturais ğ‘ e ğ‘, ğ‘ Ì¸= 0, existem Ãºnicos
ğ‘ e ğ‘Ÿ, tambÃ©m naturais, tais que ğ‘ = ğ‘ğ‘ + ğ‘Ÿ, com 0 â‰¤ ğ‘Ÿ < ğ‘.

DemonstraÃ§Ã£o:

(ExistÃªncia) Se ğ‘ < ğ‘, basta tomar ğ‘ = 0 e ğ‘Ÿ = ğ‘. Por outro lado, se ğ‘ = ğ‘, basta

tomar ğ‘ = 1 e ğ‘Ÿ = 0. Finalmente, se ğ‘ > ğ‘, considere o conjunto

ğ‘† = {ğ‘¥ = ğ‘ âˆ’ ğ‘ğ‘ tais que ğ‘ âˆ’ ğ‘ğ‘ â‰¥ 0},

o qual estÃ¡ contido no conjunto dos nÃºmeros naturais. Note que ğ‘ âˆ’ ğ‘ > 0 implica que
ğ‘† Ì¸= âˆ…. Logo, pelo princÃ­pio da boa ordenaÃ§Ã£o, ğ‘† possui um menor elemento, digamos ğ‘Ÿ.

Por definiÃ§Ã£o, ğ‘Ÿ = ğ‘ âˆ’ ğ‘ğ‘ â‰¥ 0 para algum ğ‘ âˆˆ N. Afirmamos que ğ‘Ÿ < ğ‘ pois,
caso contrÃ¡rio, terÃ­amos ğ‘Ÿ = ğ‘ âˆ’ ğ‘ğ‘ â‰¥ ğ‘, donde ğ‘ âˆ’ ğ‘(ğ‘ + 1) â‰¥ 0, o que implica que
ğ‘¦ = ğ‘ âˆ’ ğ‘(ğ‘ + 1) âˆˆ ğ‘†. Mas ğ‘¦ = ğ‘ âˆ’ ğ‘(ğ‘ + 1) < ğ‘ âˆ’ ğ‘ğ‘, o que contradiz o fato de que ğ‘Ÿ Ã© o
menor elemento de ğ‘†. Portanto, 0 â‰¤ ğ‘Ÿ < ğ‘.

(Unicidade) Se ğ‘ = ğ‘ğ‘1 + ğ‘Ÿ1 e ğ‘ = ğ‘ğ‘2 + ğ‘Ÿ2, com 0 â‰¤ ğ‘Ÿ1, ğ‘Ÿ2 < ğ‘, entÃ£o

ğ‘ğ‘1 + ğ‘Ÿ1 = ğ‘ğ‘2 + ğ‘Ÿ2

ğ‘(ğ‘1 âˆ’ ğ‘2) = ğ‘Ÿ2 âˆ’ ğ‘Ÿ1

Sendo assim, ğ‘Ÿ2 âˆ’ ğ‘Ÿ1 Ã© mÃºltiplo de ğ‘. Mas, como |ğ‘Ÿ2 âˆ’ ğ‘Ÿ1| < ğ‘, o Ãºnico valor que ğ‘Ÿ2 âˆ’ ğ‘Ÿ1
pode assumir Ã© zero. Logo, ğ‘Ÿ2 = ğ‘Ÿ1, donde segue que ğ‘2 = ğ‘1

(cid:3)

Um dos conceitos centrais da divisÃ£o Ã© o de mÃ¡ximo divisor comum de dois nÃºmeros
ou, abreviadamente, MDC. O mÃ¡ximo divisor comum nos Ã© apresentado no 6o ano do
ensino fundamental. Na escola, este conceito Ã© utilizado na simplificaÃ§Ã£o de fraÃ§Ãµes ou de
equaÃ§Ãµes.

DefiniÃ§Ã£o 5. (MÃ¡ximo Divisor Comum) Dados dois nÃºmeros naturais ğ‘ e ğ‘, dizemos que
o nÃºmero natural ğ‘‘ Ã© o mÃ¡ximo divisor comum (MDC) entre ğ‘ e ğ‘ se:

1.4. Conceitos Elementares

29

1. ğ‘‘|ğ‘ e ğ‘‘|ğ‘

2. se ğ‘š âˆˆ N Ã© tal que ğ‘š|ğ‘ e ğ‘š|ğ‘, entÃ£o ğ‘š|ğ‘‘.

A primeira propriedade da DefiniÃ§Ã£o 5 diz que, para um nÃºmero ğ‘‘ ser o MDC
entre ğ‘ e ğ‘, ğ‘‘ tem que dividir ğ‘ e ğ‘, isto Ã©, ser um divisor comum de ğ‘ e ğ‘. A segunda
propriedade diz que qualquer divisor comum de ğ‘ e ğ‘ divide o MDC, ou seja, o MDC Ã© o
maior dentre os divisores comuns.

Por exemplo, o MDC entre 12 e 8 Ã© 4, pois 4 Ã© divisor comum entre 12 e 8 e

qualquer outro divisor comum positivo entre 12 e 8 (no caso, 1 e 2) divide 4.

Apresentamos, no Teorema 4, um importante resultado acerca da divisÃ£o entre

dois nÃºmeros naturais.

Teorema 4. Sejam ğ‘ e ğ‘ dois nÃºmeros naturais com ğ‘ â‰¥ ğ‘ > 0. Se ğ‘ = ğ‘ğ‘ + ğ‘Ÿ, com ğ‘,
ğ‘Ÿ âˆˆ N e 0 â‰¤ ğ‘Ÿ < ğ‘, entÃ£o ğ‘Ÿ <

.

ğ‘
2

DemonstraÃ§Ã£o:

Consideremos dois casos: ğ‘ < 2ğ‘ e ğ‘ â‰¥ 2ğ‘. No primeiro caso, se ğ‘ â‰¥ 2ğ‘, temos que
.

. Como, por hipÃ³tese, ğ‘Ÿ < ğ‘, entÃ£o ğ‘Ÿ <

ğ‘
2

ğ‘ â‰¤

ğ‘
2

ğ‘Ÿ âˆˆ N. Como ğ‘ < 2ğ‘, segue que ğ‘ = 1. Logo, ğ‘Ÿ = ğ‘ âˆ’ ğ‘. Observe que ğ‘ < 2ğ‘ â‡’ ğ‘ >

No segundo caso, se ğ‘ < 2ğ‘ entÃ£o, por hipÃ³tese, ğ‘ = ğ‘ğ‘ +ğ‘Ÿ, onde ğ‘ âˆˆ N e 0 â‰¤ ğ‘Ÿ < ğ‘,
ğ‘
.
2

Portanto, ğ‘Ÿ = ğ‘ âˆ’ ğ‘ < ğ‘ âˆ’

=

ğ‘
2

ğ‘
2

(cid:3)

Muitas vezes, nos preocupamos apenas com o resto da divisÃ£o de um nÃºmero

natural por outro. A DefiniÃ§Ã£o 6 apresenta o conceito de congruÃªncia mÃ³dulo ğ‘›.

DefiniÃ§Ã£o 6. Dados os nÃºmeros naturais ğ‘, ğ‘ e ğ‘›, dizemos que ğ‘ Ã© congruente a ğ‘ mÃ³dulo
ğ‘› se a divisÃ£o de ğ‘ por ğ‘› deixa resto ğ‘. Neste caso, escrevemos ğ‘ â‰¡ ğ‘ mod ğ‘›.

Outro importante conceito da Teoria dos NÃºmeros Ã© o de nÃºmero primo. Os nÃº-

meros primos formam a base multiplicativa dos nÃºmeros naturais.

DefiniÃ§Ã£o 7.
dois divisores positivos distintos.

(NÃºmero primo) Um nÃºmero natural Ã© dito primo se possui exatamente

Os nÃºmeros primos se distribuem irregularmente no conjunto dos nÃºmeros natu-
rais. AtÃ© o presente momento, nÃ£o foi descoberto um padrÃ£o para essa distribuiÃ§Ã£o, mas
existem ferramentas que nos ajudam a entender melhor seu comportamento. Embora haja

30

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

infinitos nÃºmeros primos (GONÃ§ALVES, 2006), podemos usar uma funÃ§Ã£o para contar a
quantidade de primos menores que ou iguais a um nÃºmero natural dado.

DefiniÃ§Ã£o 8. Denotamos por ğœ‹(ğ‘›) a quantidade de nÃºmeros primos menores ou iguais
ao nÃºmero natural ğ‘›.

Determinante

Conceito central da Ã¡lgebra linear, os determinantes desempenham papel funda-
mental quando queremos analisar a existÃªncia de soluÃ§Ãµes de um sistema linear, bem como
a determinaÃ§Ã£o de tais soluÃ§Ãµes. A todo sistema estÃ¡ associada uma matriz.

DefiniÃ§Ã£o 9.
colunas.

(Matriz) Uma matriz Ã© uma tabela de elementos dispostos em linhas e

Um elemento qualquer de uma matriz ğ´ ocupa uma posiÃ§Ã£o em uma linha e em
uma coluna. Denotaremos o elemento da linha ğ‘– e coluna ğ‘— por ğ‘ğ‘–ğ‘—. Quando uma matriz ğ´
possui o mesmo nÃºmero ğ‘› de linhas e de colunas, dizemos que ğ´ Ã© uma matriz quadrada de
ordem ğ‘›. Uma matriz que possua apenas uma linha Ã© chamada vetor-linha. Analogamente,
uma matriz que possua apenas uma coluna Ã© chamada vetor-coluna.

Um tipo especial de matriz Ã© a matriz identidade, representada pela letra ğ¼. Esta
consiste de uma matriz quadrada na qual todos os elementos da diagonal principal sÃ£o
iguais a 1 e todos os elementos restantes sÃ£o iguais a zero. Uma matriz identidade que
possua ğ‘› linhas e ğ‘› colunas Ã© chamada matriz identidade de ordem ğ‘› e representada por
ğ¼ğ‘›. A toda matriz quadrada estÃ¡ associado um nÃºmero, chamado determinante da matriz.
A DefiniÃ§Ã£o 10 foi extraÃ­da de (STRANG, 2010).

DefiniÃ§Ã£o 10. (Determinante) Dada uma matriz quadrada ğ´ğ‘›Ã—ğ‘›, o determinante de A
Ã© um nÃºmero real que satisfaz as seguintes propriedades:

1. o determinante da matriz identidade ğ¼ Ã© igual a 1;

2. o sinal do determinante de uma matriz muda quando hÃ¡ uma troca de linhas;

3. o determinante de uma matriz Ã© linear em cada linha separadamente.

A propriedade 3 da DefiniÃ§Ã£o 10 pode ser descrita em duas partes:

(a) det

â›

âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 + ğ‘11 ğ‘12 + ğ‘12

ğ‘21
...
ğ‘ğ‘›1

ğ‘22
...
ğ‘ğ‘›2

. . . ğ‘1ğ‘› + ğ‘1ğ‘›
. . .
. . .
. . .

ğ‘2ğ‘›
...
ğ‘ğ‘›ğ‘›

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

1.4. Conceitos Elementares

31

â›

â

â›

â

+ det

= det

âœ
âœ
âœ
âœ
âœ
âœ
â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

âœ
âœ
âœ
âœ
âœ
âœ
â

. . . ğ‘1ğ‘›
. . . ğ‘2ğ‘›
...
. . .
. . . ğ‘ğ‘›ğ‘›

ğ‘11 ğ‘12
ğ‘21 ğ‘22
...
...
ğ‘ğ‘›1 ğ‘ğ‘›2

ğ‘11
ğ‘12
ğ‘21 ğ‘22
...
...
ğ‘ğ‘›1 ğ‘ğ‘›2
ou seja, somando-se um vetor linha Ã  primeira linha de uma matriz, o seu deter-
minante serÃ¡ igual Ã  soma do determinante da matriz original com o determinante
da matriz obtida pela substituiÃ§Ã£o da primeira linha da matriz original pelo vetor
linha, mantendo-se as demais linhas inalteradas.

. . .
ğ‘1ğ‘›
. . . ğ‘2ğ‘›
...
. . .
. . . ğ‘ğ‘›ğ‘›

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

,

(b) det

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11
ğ‘21
...
ğ‘ğ‘ğ‘–1
...
ğ‘ğ‘›1

ğ‘12
ğ‘22
...
ğ‘ğ‘ğ‘–2
...
ğ‘ğ‘›2

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

. . . ğ‘1ğ‘›
. . . ğ‘2ğ‘›
...
. . .
. . . ğ‘ğ‘ğ‘–ğ‘›
...
. . .
. . . ğ‘ğ‘›ğ‘›

= ğ‘ Â· det

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11
ğ‘21
...
ğ‘ğ‘ğ‘–1
...
ğ‘ğ‘›1

ğ‘12
ğ‘22
...
ğ‘ğ‘ğ‘–2
...
ğ‘ğ‘›2

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
,
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

. . . ğ‘1ğ‘›
. . . ğ‘2ğ‘›
...
. . .
. . . ğ‘ğ‘ğ‘–ğ‘›
...
. . .
. . . ğ‘ğ‘›ğ‘›

isto Ã©, multiplicar uma das linhas de uma matriz por um nÃºmero real ğ‘ implica que
o seu determinante Ã© igual a ğ‘ vezes o determinante da matriz original.

Observe que uma consequÃªncia imediata da parte (b) acima Ã© que, se uma matriz

possui uma linha nula, entÃ£o seu determinante Ã© igual a zero.

Algumas fÃ³rmulas para o cÃ¡lculo de determinantes sÃ£o bem conhecidas, como Ã© o

caso dos determinantes de matrizes 2 Ã— 2.

Teorema 5. (Determinante de matrizes 2 Ã— 2) Dada uma matriz

ğ´ =

temos que det ğ´ = ğ‘ğ‘‘ âˆ’ ğ‘ğ‘

â›

â

ğ‘ ğ‘
ğ‘ ğ‘‘

â
â  ,

DemonstraÃ§Ã£o: Para comprovar isto, vamos verificar as 3 propriedades da defi-

niÃ§Ã£o de determinantes:

1. Para a matriz ğ¼ =

1 Ã© vÃ¡lida.

â›

â

1 0
0 1

â
â , temos que det ğ¼ = 1Â·1âˆ’0Â·0 = 1. Portanto, a propriedade

2. Caso as linhas sejam trocadas, obteremos a matriz ğµ =

â›

â

ğ‘ ğ‘‘
ğ‘ ğ‘

â
â . Seu determinante

serÃ¡

det ğµ = ğ‘ğ‘ âˆ’ ğ‘ğ‘‘ = âˆ’(ğ‘ğ‘‘ âˆ’ ğ‘ğ‘) = âˆ’ det ğ´

3. Vamos verificar que o determinante Ã© linear na 1a linha.

32

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

a) det

â›

â

ğ‘ + ğ‘’ ğ‘ + ğ‘“

ğ‘

ğ‘‘

â
â  = (ğ‘ + ğ‘’)ğ‘‘ âˆ’ (ğ‘ + ğ‘“ )ğ‘

= ğ‘ğ‘‘ âˆ’ ğ‘ğ‘ + ğ‘’ğ‘‘ âˆ’ ğ‘ğ‘“ = det

â›

â

â
â  + det

ğ‘ ğ‘
ğ‘ ğ‘‘

â›

â

ğ‘’ ğ‘“
ğ‘ ğ‘‘

â

â 

b) det

â›

â

ğ‘˜ğ‘ ğ‘˜ğ‘
ğ‘‘
ğ‘

â
â  = ğ‘˜ğ‘ğ‘‘ âˆ’ ğ‘˜ğ‘ğ‘ = ğ‘˜(ğ‘ğ‘‘ âˆ’ ğ‘ğ‘) = ğ‘˜ Â· det

â›

â

â

â 

ğ‘ ğ‘
ğ‘ ğ‘‘

O caso de determinantes de matrizes 3 Ã— 3 Ã© apresentado no Teorema 6.

(cid:3)

Teorema 6. (Regra de Sarrus) Dada uma matriz ğ´ =

â›

âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘21 ğ‘22 ğ‘23
ğ‘31 ğ‘32 ğ‘33

â

âŸ
âŸ
âŸ
â 

, temos que

det ğ´ = ğ‘11ğ‘22ğ‘33 + ğ‘12ğ‘23ğ‘31 + ğ‘13ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘13 âˆ’ ğ‘32ğ‘23ğ‘11 âˆ’ ğ‘33ğ‘21ğ‘12.

DemonstraÃ§Ã£o: De fato,

1. det ğ¼ = det

â›

âœ
âœ
âœ
â

2. Dada a matriz

â

âŸ
âŸ
âŸ
â 

1 0 0
0 1 0
0 0 1

= 1 Â· 1 Â· 1 + 0 Â· 0 Â· 0 + 0 Â· 0 Â· 0 âˆ’ 0 Â· 1 Â· 0 âˆ’ 0 Â· 0 Â· 1 âˆ’ 1 Â· 0 Â· 0 = 1.

ğ´ =

â›

âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘21 ğ‘22 ğ‘23
ğ‘31 ğ‘32 ğ‘33

â

âŸ
âŸ
âŸ
â 

,

hÃ¡ 3! = 6 maneiras de permutar as suas linhas. Vamos permutar a primeira linha
com a segunda. Os outros casos sÃ£o anÃ¡logos.

det ğ´ = ğ‘21ğ‘12ğ‘33 + ğ‘22ğ‘13ğ‘31 + ğ‘23ğ‘11ğ‘32 âˆ’ ğ‘31ğ‘12ğ‘23 âˆ’ ğ‘32ğ‘13ğ‘21 âˆ’ ğ‘33ğ‘11ğ‘22

= âˆ’(ğ‘11ğ‘22ğ‘33 + ğ‘12ğ‘23ğ‘31 + ğ‘13ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘13 âˆ’ ğ‘32ğ‘23ğ‘11 âˆ’ ğ‘33ğ‘21ğ‘12)

= âˆ’ det ğ´,

ou seja, o determinante da matriz ğ´ muda de sinal quando trocamos duas linhas.

3. Provemos agora a linearidade do determinante com relaÃ§Ã£o Ã  primeira linha. Seja

â›

âœ
âœ
âœ
â

ğ‘11 + ğ‘ ğ‘12 + ğ‘ ğ‘13 + ğ‘‘
ğ‘22
ğ‘32

ğ‘21
ğ‘31

ğ‘23
ğ‘33

â

âŸ
âŸ
âŸ
â 

ğµ =

DaÃ­,

1.4. Conceitos Elementares

33

a)

det ğµ = (ğ‘11 + ğ‘)ğ‘22ğ‘33 + (ğ‘12 + ğ‘)ğ‘23ğ‘31 + (ğ‘13 + ğ‘‘)ğ‘21ğ‘32

âˆ’ ğ‘31ğ‘22(ğ‘13 + ğ‘‘) âˆ’ ğ‘32ğ‘23(ğ‘11 + ğ‘) âˆ’ ğ‘33ğ‘21(ğ‘12 + ğ‘)

= (ğ‘11ğ‘22ğ‘33 + ğ‘12ğ‘23ğ‘31 + ğ‘13ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘13 âˆ’ ğ‘32ğ‘23ğ‘11 âˆ’ ğ‘33ğ‘21ğ‘12)

+ (ğ‘ğ‘22ğ‘33 + ğ‘ğ‘23ğ‘31 + ğ‘‘ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘‘ âˆ’ ğ‘32ğ‘23ğ‘ âˆ’ ğ‘33ğ‘21ğ‘)
â›

â

â

â›

= det

âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘21 ğ‘22 ğ‘23
ğ‘31 ğ‘32 ğ‘33

âŸ
âŸ
âŸ
â 

+ det

âœ
âœ
âœ
â

ğ‘
ğ‘‘
ğ‘
ğ‘21 ğ‘22 ğ‘23
ğ‘31 ğ‘32 ğ‘33

.

âŸ
âŸ
âŸ
â 

b) det

â›

âœ
âœ
âœ
â

ğ‘˜ğ‘11 ğ‘˜ğ‘12 ğ‘˜ğ‘13
ğ‘23
ğ‘22
ğ‘21
ğ‘33
ğ‘32
ğ‘31

â

âŸ
âŸ
âŸ
â 

= ğ‘˜ğ‘11ğ‘22ğ‘33 + ğ‘˜ğ‘12ğ‘23ğ‘31 + ğ‘˜ğ‘13ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘˜ğ‘13 âˆ’ ğ‘32ğ‘23ğ‘˜ğ‘11 âˆ’ ğ‘33ğ‘21ğ‘˜ğ‘12

= ğ‘˜(ğ‘11ğ‘22ğ‘33 + ğ‘12ğ‘23ğ‘31 + ğ‘13ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘13 âˆ’ ğ‘32ğ‘23ğ‘11 âˆ’ ğ‘33ğ‘21ğ‘12)

= ğ‘˜ Â· det

âœ
âœ
âœ
â

â›

â

ğ‘11 ğ‘12 ğ‘13
ğ‘21 ğ‘22 ğ‘23
ğ‘31 ğ‘32 ğ‘33

âŸ
âŸ
.
âŸ
â 

(cid:3)

Para o cÃ¡lculo de determinantes de matrizes de ordens superiores, utiliza-se o
Teorema 7, enunciado e demonstrado por Laplace. Contudo, Ã© necessÃ¡rio antes algumas
definiÃ§Ãµes.

DefiniÃ§Ã£o 11. Seja ğ´ğ‘›Ã—ğ‘›. Seja ğ‘€ğ‘–ğ‘— a submatriz (ğ‘›âˆ’1)Ã—(ğ‘›âˆ’1) obtida pela eliminaÃ§Ã£o da
ğ‘–-Ã©sima linha e da ğ‘—-Ã©sima coluna de A. O determinante de ğ‘€ğ‘–ğ‘— Ã© chamado determinante
menor de ğ‘ğ‘–ğ‘—. O cofator ğ‘ğ‘–ğ‘— de ğ‘ğ‘–ğ‘— Ã© definido como

ğ‘ğ‘–ğ‘— = (âˆ’1)ğ‘–+ğ‘— Â· det(ğ‘€ğ‘–ğ‘—)

Teorema 7. (Laplace) Seja ğ´ uma matriz ğ‘›Ã—ğ‘›. EntÃ£o, para cada linha ğ‘–, com 1 â‰¤ ğ‘– â‰¤ ğ‘›,
temos:

det ğ´ = ğ‘ğ‘–1ğ‘ğ‘–1 + ğ‘ğ‘–2ğ‘ğ‘–2 + Â· Â· Â· ğ‘ğ‘–ğ‘›ğ‘ğ‘–ğ‘›,

ou ainda, para cada coluna ğ‘—, com 1 â‰¤ ğ‘— â‰¤ ğ‘›,

det ğ´ = ğ‘1ğ‘—ğ‘1ğ‘— + ğ‘2ğ‘—ğ‘2ğ‘— + Â· Â· Â· ğ‘ğ‘›ğ‘—ğ‘ğ‘›ğ‘—.

A demonstraÃ§Ã£o foge do escopo deste trabalho e serÃ¡ omitida.

34

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

Existe um outro mÃ©todo para calcular determinantes de ordens superiores. Este
mÃ©todo, atribuÃ­do a Gauss, se baseia no escalonamento de matrizes. Diz-se que uma matriz
estÃ¡ na forma escalonada reduzida por linhas quando ela cumpre os critÃ©rios da DefiniÃ§Ã£o
12.

DefiniÃ§Ã£o 12.
forma escalonada reduzida por linhas se ela satisfaz as seguintes propriedades:

(Forma Escalonada Reduzida por Linhas) Uma matriz ğ´ğ‘šÃ—ğ‘› estÃ¡ na

1. todas as linhas nulas, se existirem, ocorrem abaixo de todas as linhas nÃ£o-nulas;

2. o primeiro elemento diferente de zero a partir da esquerda de uma linha nÃ£o-nula Ã©

igual a 1. Este elemento Ã© chamado de um inicial desta linha;

3. para cada linha nÃ£o-nula, o um inicial aparece Ã  direita e abaixo dos uns iniciais das

linhas precedentes;

4. se uma coluna contÃ©m o um inicial, entÃ£o todos os outros elementos naquela coluna

sÃ£o iguais a zero.

Para transformar uma matriz qualquer em uma matriz escalonada reduzida por

linhas, fazemos uso de operaÃ§Ãµes elementares.

DefiniÃ§Ã£o 13. Uma operaÃ§Ã£o elementar nas linhas de uma matriz ğ´ğ‘šÃ—ğ‘› Ã© uma das
seguintes operaÃ§Ãµes:

1. permuta de duas linhas de ğ´;

2. multiplicaÃ§Ã£o de uma linha de ğ´ por uma constante real nÃ£o-nula;

3. adiÃ§Ã£o de ğ‘š vezes a ğ‘–-Ã©sima linha de ğ´ Ã  ğ‘—-Ã©sima linha de ğ´;

Outra definiÃ§Ã£o importante Ã© a de equivalÃªncia de duas matrizes com relaÃ§Ã£o a

estas operaÃ§Ãµes elementares.

DefiniÃ§Ã£o 14. (EquivalÃªncia por Linhas) Dizemos que uma matriz ğ´ğ‘šÃ—ğ‘› Ã© equivalente
por linhas a uma matriz ğµğ‘šÃ—ğ‘› quando ğµ pode ser obtida aplicando-se uma sequÃªncia
finita de operaÃ§Ãµes elementares nas linhas de ğ´.

As matrizes escalonadas reduzidas por linhas fazem parte de uma classe mais geral

de matrizes, chamada matrizes triangulares.

DefiniÃ§Ã£o 15. (Matriz Triangular) Uma matriz triangular superior Ã© uma matriz na qual
todos os elementos abaixo da diagonal principal sÃ£o iguais a zero. Analogamente, chama-

1.4. Conceitos Elementares

35

se matriz triangular inferior a qualquer matriz na qual os elementos acima da diagonal
principal sejam iguais a zero.

Ã‰ sempre possÃ­vel transformar uma dada matriz em uma matriz triangular. Isto Ã©

garantido pelo Teorema 8.

Teorema 8. Toda matriz Ã© equivalente por linhas a uma matriz triangular.

DemonstraÃ§Ã£o: Mostraremos como transformar uma matriz em uma matriz tri-

angular superior. O caso de matriz triangular inferior Ã© anÃ¡logo. Dada uma matriz

ğ´ =

â›

âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘12
ğ‘11
ğ‘22
ğ‘21
...
...
ğ‘ğ‘š1 ğ‘ğ‘š2

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

,

Â· Â· Â· ğ‘1ğ‘›
Â· Â· Â· ğ‘2ğ‘›
...
. . .
Â· Â· Â· ğ‘ğ‘šğ‘›

temos que transformÃ¡-la em uma matriz escalonada reduzida fazendo uso apenas de ope-
raÃ§Ãµes elementares.

ComeÃ§amos identificando o primeiro elemento nÃ£o-nulo da primeira coluna. Tal
elemento Ã© chamado pivÃ´. Encontrado tal elemento, permutamos a linha onde ele se
encontra com a primeira.

Assim, sem perda de generalidade, suponhamos que a permuta jÃ¡ foi realizada e
que o elemento ğ‘11 Ã© nÃ£o-nulo. Temos que fazer com que todos os elementos abaixo dele
na primeira coluna sejam iguais a zero. Isto pode ser feito substituindo-se, para todo
ğ‘ğ‘–1
2 â‰¤ ğ‘– â‰¤ ğ‘›, cada elemento ğ‘ğ‘–ğ‘— por ğ‘ğ‘–ğ‘— âˆ’ ğ‘1ğ‘— Â·
, com 1 â‰¤ ğ‘— â‰¤ ğ‘›. ApÃ³s fazer esta operaÃ§Ã£o,
ğ‘11
o primeiro elemento da ğ‘Ÿ-Ã©sima linha serÃ¡ zero, para todo 2 â‰¤ ğ‘Ÿ â‰¤ ğ‘›. Chegamos a uma
nova matriz

ğµ =

â›

âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 ğ‘12
ğ‘22
0
...
...
ğ‘ğ‘š2
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â· ğ‘1ğ‘›
ğ‘2ğ‘›
Â· Â· Â·
...
. . .
ğ‘ğ‘šğ‘›
Â· Â· Â·

Agora, olhando apenas da segunda linha em diante, identificamos o primeiro ele-
mento nÃ£o-nulo da segunda coluna, o qual serÃ¡ o novo pivÃ´. Caso ele nÃ£o esteja na segunda
linha, permutamos a linha onde ele se encontra com a segunda. Em seguida, para todo

3 â‰¤ ğ‘– â‰¤ ğ‘› cada elemento ğ‘ğ‘–ğ‘— serÃ¡ substituÃ­do por ğ‘ğ‘–ğ‘— âˆ’ ğ‘2ğ‘—
fazer esta operaÃ§Ã£o, o segundo elemento da ğ‘-Ã©sima linha serÃ¡ zero para todo 3 â‰¤ ğ‘ â‰¤ ğ‘›.

, com 2 â‰¤ ğ‘— â‰¤ ğ‘›. ApÃ³s

ğ‘ğ‘–2
ğ‘22

36

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

Chegamos, portanto, a uma nova matriz

ğ¶ =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘23
ğ‘22
0
ğ‘33
0
0
...
...
...
ğ‘ğ‘š3
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â· ğ‘1ğ‘›
ğ‘2ğ‘›
Â· Â· Â·
ğ‘3ğ‘›
Â· Â· Â·
...
. . .
ğ‘ğ‘šğ‘›
Â· Â· Â·

Repetindo este processo para todas as linhas restantes, chegamos Ã  matriz

ğ‘‡ =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘23
ğ‘22
0
ğ‘33
0
0
...
...
...
0
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â· ğ‘1ğ‘›
ğ‘2ğ‘›
Â· Â· Â·
ğ‘3ğ‘›
Â· Â· Â·
...
. . .
ğ‘¡ğ‘›ğ‘›
Â· Â· Â·

,

que Ã© uma matriz triangular superior, obtida de ğ´ apenas por meio de operaÃ§Ãµes elemen-
tares.

(cid:3)

O processo descrito na demonstraÃ§Ã£o do Teorema 8 Ã© conhecido como mÃ©todo de

escalonamento de Gauss-Jordan.

ApÃ³s a matriz ser transformada em uma matriz triangular superior, o determi-
nante serÃ¡ dado pelo produto dos elementos da diagonal principal, o que Ã© garantido pelo
Teorema 9.

Teorema 9. O determinante de uma matriz triangular Ã© igual ao produto dos elementos
da diagonal principal.

DemonstraÃ§Ã£o: Vamos verificar que as trÃªs propriedades da definiÃ§Ã£o de deter-

minantes sÃ£o satisfeitas.

1. Na matriz identidade

ğ¼ğ‘› =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

1 0 0 Â· Â· Â· 0
0 1 0 Â· Â· Â· 0
0 0 1 Â· Â· Â· 0
...
...
...
0 0 0 Â· Â· Â· 1

. . .

...

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

,

todos os elementos da diagonal principal sÃ£o iguais a 1. Portanto, det ğ¼ğ‘› = 1.

1.4. Conceitos Elementares

37

2. Considere uma matriz triangular

ğ‘‡ =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘22 ğ‘23
0
ğ‘33
0
0
...
...
...
0
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â· ğ‘1ğ‘›
Â· Â· Â· ğ‘2ğ‘›
Â· Â· Â· ğ‘3ğ‘›
...
. . .
Â· Â· Â· ğ‘ğ‘›ğ‘›

.

Sem perda de generalidade, vamos permutar as linhas 1 e 2. Os outros casos

sÃ£o anÃ¡logos. ApÃ³s a permuta, obtemos a matriz

ğ‘‡1 =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

0
ğ‘22 ğ‘23
ğ‘11 ğ‘12 ğ‘13
ğ‘33
0
0
...
...
...
0
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â· ğ‘2ğ‘›
Â· Â· Â· ğ‘1ğ‘›
Â· Â· Â· ğ‘3ğ‘›
...
. . .
Â· Â· Â· ğ‘ğ‘›ğ‘›

Substituindo cada elemento ğ‘1ğ‘— por ğ‘1ğ‘— âˆ’ ğ‘2ğ‘—, temos:

ğ‘‡2 =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

âˆ’ğ‘11 ğ‘22 âˆ’ ğ‘12 ğ‘23 âˆ’ ğ‘13
ğ‘11
0
...
0

ğ‘13
ğ‘33
...
0

ğ‘12
0
...
0

Â· Â· Â· ğ‘2ğ‘› âˆ’ ğ‘1ğ‘›
Â· Â· Â·
Â· Â· Â·
. . .
Â· Â· Â·

ğ‘1ğ‘›
ğ‘3ğ‘›
...
ğ‘ğ‘›ğ‘›

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Agora, somamos a primeira linha Ã  segunda, substituindo cada elemento ğ‘2ğ‘—

por ğ‘2ğ‘— + ğ‘1ğ‘—, donde obtÃ©m-se a matriz

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘‡3 =

âˆ’ğ‘11 ğ‘22 âˆ’ ğ‘12 ğ‘23 âˆ’ ğ‘13

0
0
...
0

ğ‘22
0
...
0

ğ‘23
ğ‘33
...
0

Â· Â· Â· ğ‘2ğ‘› âˆ’ ğ‘1ğ‘›
Â· Â· Â·
Â· Â· Â·
. . .
Â· Â· Â·

ğ‘2ğ‘›
ğ‘3ğ‘›
...
ğ‘ğ‘›ğ‘›

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

A matriz ğ‘‡3 Ã© uma matriz triangular superior. Seu determinante Ã© dado por:

det ğ‘‡3 = âˆ’ğ‘11ğ‘22ğ‘33 Â· Â· Â· ğ‘ğ‘›ğ‘› = âˆ’ det ğ‘‡

38

CapÃ­tulo 1. FundamentaÃ§Ã£o TeÃ³rica

3. Somando o vetor

(ï¸

ğ‘11

ğ‘12

Â· Â· Â·

ğ‘1ğ‘›

)ï¸

Ã  matriz T, obtemos a matriz

ğ‘‡1 =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 + ğ‘11 ğ‘12 + ğ‘12 ğ‘13 + ğ‘13
ğ‘22
0
...
0

ğ‘23
ğ‘33
...
0

0
0
...
0

Â· Â· Â· ğ‘1ğ‘› + ğ‘1ğ‘›
Â· Â· Â·
Â· Â· Â·
. . .
Â· Â· Â·

ğ‘2ğ‘›
ğ‘3ğ‘›
...
ğ‘ğ‘›ğ‘›

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

ğ‘‡1 Ã© uma matriz triangular superior. Seu determinante Ã© dado por:

det ğ‘‡1 = (ğ‘11 + ğ‘11)ğ‘22 Â· Â· Â· ğ‘ğ‘›ğ‘› = ğ‘11ğ‘22 Â· Â· Â· ğ‘ğ‘›ğ‘› + ğ‘11ğ‘22 Â· Â· Â· ğ‘ğ‘›ğ‘›

= det

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘22 ğ‘23
0
ğ‘33
0
0
...
...
...
0
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â· ğ‘1ğ‘›
Â· Â· Â· ğ‘2ğ‘›
Â· Â· Â· ğ‘3ğ‘›
...
. . .
Â· Â· Â· ğ‘ğ‘›ğ‘›

+ det

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11
0
0
...
0

ğ‘13
ğ‘12
ğ‘22 ğ‘23
ğ‘33
0
...
...
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

ğ‘1ğ‘›
Â· Â· Â·
Â· Â· Â· ğ‘2ğ‘›
Â· Â· Â· ğ‘3ğ‘›
...
. . .
Â· Â· Â· ğ‘ğ‘›ğ‘›

Multiplicando-se a ğ‘Ÿ-Ã©sima linha de ğ‘‡ por uma constante ğ‘˜, obtemos a matriz

triangular superior

ğ‘‡2 =

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘14
ğ‘22 ğ‘23
0
ğ‘24
...
...
...
...
Â· Â· Â· ğ‘˜ğ‘ğ‘Ÿğ‘Ÿ
0
0
...
...
...
...
Â· Â· Â·
0
0
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

Â· Â· Â·
ğ‘1ğ‘›
Â· Â· Â·
ğ‘2ğ‘›
...
. . .
Â· Â· Â· ğ‘˜ğ‘ğ‘Ÿğ‘›
...
. . .
ğ‘ğ‘›ğ‘›
Â· Â· Â·

donde det ğ‘‡2 = ğ‘11ğ‘22 Â· Â· Â· ğ‘˜ğ‘ğ‘Ÿğ‘Ÿ Â· Â· Â· ğ‘ğ‘›ğ‘› = ğ‘˜ Â· det ğ‘‡2

(cid:3)

2 Metodologia

39

Neste capÃ­tulo iremos descrever a metodologia utilizada para a escolha dos algo-
ritmos a serem analisados, para a escolha dos livros didÃ¡ticos e para a implementaÃ§Ã£o dos
algoritmos, bem como a contagem das operaÃ§Ãµes.

2.1 Escolha dos Algoritmos

Os problemas escolhidos foram o do cÃ¡lculo de potÃªncias com expoente natural, o
do cÃ¡lculo do mÃ¡ximo divisor comum de dois nÃºmeros naturais e o do cÃ¡lculo de determi-
nantes de matrizes ğ‘› Ã— ğ‘›. A escolha desses problemas se deu pelo fato de existirem mais
de um algoritmo com uso difundido entre professores e alunos para a soluÃ§Ã£o dos mesmos.
O trabalho tem como objetivo, em primeiro lugar, a comparaÃ§Ã£o entre esses algoritmos do
ponto de vista da anÃ¡lise de complexidade assintÃ³tica. Logo, nÃ£o seria possÃ­vel fazer esta
comparaÃ§Ã£o no caso de haver somente um algoritmo para a resoluÃ§Ã£o de um problema.

No caso da potenciaÃ§Ã£o, hÃ¡ dois algoritmos amplamente utilizados: o da potencia-
Ã§Ã£o por definiÃ§Ã£o e o da potenciaÃ§Ã£o por meio de divisÃ£o e conquista. JÃ¡ para o problema
do mÃ¡ximo divisor comum, utiliza-se o algoritmo por decomposiÃ§Ã£o em fatores primos ou
o algoritmo de Euclides. Por fim, para o cÃ¡lculo de determinantes, em geral, aprendemos
na escola a utilizar fÃ³rmulas fechadas para os casos de matrizes 2 Ã— 2 e 3 Ã— 3 (regra de
Sarrus). JÃ¡ para determinantes de ordens superiores, comumente faz-se uso do cÃ¡lculo
por meio de cofatores. Alternativamente, podemos usar um algoritmo de escalonamento
e produto dos elementos da diagonal principal.

Estes problemas estÃ£o presentes em toda a matemÃ¡tica escolar. Por isso, conside-
ramos de suma importÃ¢ncia fazer uma comparaÃ§Ã£o de tais algoritmos, para que possamos
escolher o ensino daqueles que forem mais eficientes. Estas escolhas nÃ£o se devem apenas
a uma melhoria do cÃ¡lculo escrito. HÃ¡ uma tendÃªncia crescente por se adotar o ensino de
programaÃ§Ã£o bÃ¡sica no currÃ­culo escolar. Sendo assim, a compreensÃ£o de um algoritmo
nÃ£o passa somente por sua construÃ§Ã£o, mas tambÃ©m pela sua anÃ¡lise de eficiÃªncia.

2.2 Escolha e VerificaÃ§Ã£o dos Livros DidÃ¡ticos

Para a escolha dos livros didÃ¡ticos, fizemos uma pesquisa no banco de dados da
Secretaria de Estado de EducaÃ§Ã£o do Distrito Federal (SEEDF) e verificamos quais as
trÃªs Coordenadorias Regionais de Ensino (CRE) com maior nÃºmero de alunos. Os dados
estÃ£o disponÃ­veis em (FEDERAL, 2017).

40

CapÃ­tulo 2. Metodologia

Tabela 1 â€“ Coordenadorias Regionais de Ensino (CRE) com maior nÃºmero de matrÃ­culas

â€“ Ensino Fundamental II (6o ao 9o ano)

CRE

MatrÃ­culas

CeilÃ¢ndia
Planaltina
Plano Piloto

22.868
11.519
10.895

Tabela 2 â€“ Coordenadorias Regionais de Ensino (CRE) com maior nÃºmero de matrÃ­culas

â€“ Ensino MÃ©dio

CRE

MatrÃ­culas

CeilÃ¢ndia
Taguatinga
Plano Piloto

13.195
9.409
8.273

Feito isto, procuramos, em cada regional de ensino, as 5 escolas com o maior
nÃºmero de matrÃ­culas nos anos finais do ensino fundamental e no ensino mÃ©dio. Os dados
estÃ£o disponÃ­veis em (FEDERAL, 2018a) e em (FEDERAL, 2018b).

Tabela 3 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino Fundamental II â€“ CRE

CeilÃ¢ndia

Escola

MatrÃ­culas

CEF 25 de CeilÃ¢ndia
CEF 27 de CeilÃ¢ndia
CEF 28 de CeilÃ¢ndia
CEF 26 de CeilÃ¢ndia
CEF 07 de CeilÃ¢ndia

1.632
1.506
1.169
1.059
1.052

Tabela 4 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino Fundamental II â€“ CRE

Planaltina

Escola

CEF 04 de Planaltina
CED Dona AmÃ©rica GuimarÃ£es
CEF 01 de Planaltina
CED PompÃ­lio Marques de Souza
CED Stella dos Cherubins GuimarÃ£es Trois

MatrÃ­culas

1.173
1.020
999
930
907

Em seguida, pesquisamos quais os livros adotados em matemÃ¡tica no 6o ano nas
escolas das Tabelas 3, 4 e 5 e no 2o ano do ensino mÃ©dio nas escolas das Tabelas 6, 7 e 8.

De posse dos livros, analisamos cuidadosamente os exercÃ­cios e os algoritmos de
potÃªncias e mÃ¡ximo divisor comum apresentados nos livros de 6o ano e os exercÃ­cios e
algoritmos de determinantes nos livros de 2o ano.

2.2. Escolha e VerificaÃ§Ã£o dos Livros DidÃ¡ticos

41

Tabela 5 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino Fundamental II â€“ CRE

Plano Piloto

Escola

MatrÃ­culas

CEF Polivalente
CEF CASEB
CEF Athos BulcÃ£o
CEF 07 de BrasÃ­lia
CEF 01 do Cruzeiro

1.103
994
735
723
699

Tabela 6 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino MÃ©dio â€“ CRE CeilÃ¢ndia

Escola

MatrÃ­culas

CEM 02 de CeilÃ¢ndia
CEM 12 de CeilÃ¢ndia
CED 15 de CeilÃ¢ndia
CEM 04 de CeilÃ¢ndia
CED 06 de CeilÃ¢ndia

2.132
1.583
1.484
1.399
1.246

Tabela 7 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino MÃ©dio â€“ CRE Taguatinga

Escola

MatrÃ­culas

CEM Ave Branca
CEM Taguatinga Norte
CED EIT
CEM 03 de Taguatinga
CED 04 de Taguatinga

2.414
1.525
1.377
1.399
1.246

Tabela 8 â€“ Escolas com maior nÃºmero de matrÃ­culas no Ensino MÃ©dio - CRE Plano Piloto

Escola

MatrÃ­culas no Ensino Fundamental II

CEM Setor Leste
CEM Elefante Branco
CEM Setor Oeste
CEM Paulo Freire
CED GISNO

1.636
1.582
1.156
904
716

Os livros de ensino fundamental adotados pelas escolas das Tabelas 3, 4 e 5 sÃ£o
Bianchini (2016), Dante (2016b), Chavante (2016), Andrini e Vasconcelos (2015), Silveira
(2016) e CentÃºrion e Jakubovic (2015).

Todos os livros apresentam somente o cÃ¡lculo da potenciaÃ§Ã£o por definiÃ§Ã£o. Na
verdade, apenas Silveira (2016) tem uma seÃ§Ã£o onde sÃ£o apresentadas as propriedades
da potenciaÃ§Ã£o. Com relaÃ§Ã£o ao cÃ¡lculo do mÃ¡ximo divisor comum, os livros CentÃºrion e
Jakubovic (2015) e Chavante (2016) mostram como calcular o mÃ¡ximo divisor comum so-
mente via definiÃ§Ã£o. JÃ¡ os demais livros apresentam tambÃ©m o algoritmo da decomposiÃ§Ã£o

42

CapÃ­tulo 2. Metodologia

em fatores primos. Nenhum deles apresenta o algoritmo de Euclides.

Com relaÃ§Ã£o ao ensino mÃ©dio, os livros adotados pelas escolas das Tabelas 6, 7 e

8 sÃ£o Dante (2016a), Iezzi et al. (2016) e Leonardo (2016).

Em todos eles Ã© apresentado somente o cÃ¡lculo de determinantes de matrizes 2 Ã— 2
e 3 Ã— 3 utilizando as conhecidas fÃ³rmulas dos Teoremas 5 e 6. Curiosamente, Leonardo
(2016) mostra um recurso de softwares de planilhas eletrÃ´nicas que calcula determinantes
de matrizes 2Ã—2, mas nÃ£o comenta sobre como seriam as programaÃ§Ãµes de fÃ³rmulas nestes
tipos de softwares.

2.3 Problemas Escolhidos

Nesta seÃ§Ã£o, descreveremos os problemas selecionados para este trabalho e os al-
goritmos ensinados na escola para a soluÃ§Ã£o dos mesmos. A escolha dos problemas se deu
de acordo com a existÃªncia de mais de um algoritmo para os mesmos e que pudessem ser
ensinados nos ensinos fundamental e mÃ©dio. Os problemas escolhidos foram: a potenciaÃ§Ã£o
com base e expoente naturais, o mÃ¡ximo divisor comum entre dois nÃºmeros naturais e o
determinante de matrizes quadradas.

Em cada uma das subseÃ§Ãµes, escreveremos os algoritmos em linguagem de pseudo-
cÃ³digo e, em seguida, faremos uma anÃ¡lise do tempo gasto para a execuÃ§Ã£o do algoritmo
em funÃ§Ã£o do tamanho da instÃ¢ncia. Conforme discutido no CapÃ­tulo 1, iremos considerar
que cada operaÃ§Ã£o do mesmo tipo leva um tempo constante para ser executada.

Na SubseÃ§Ã£o 2.3.1, descrevemos os algoritmos para a potenciaÃ§Ã£o. Iremos com-
parar um algoritmo que calcula uma potenciaÃ§Ã£o por definiÃ§Ã£o com outro que calcula
utilizando propriedades da potenciaÃ§Ã£o. Na SubseÃ§Ã£o 2.3.2, serÃ£o abordados os algorit-
mos para a determinaÃ§Ã£o do MDC entre dois nÃºmeros naturais. Faremos a comparaÃ§Ã£o
de um algoritmo que calcula o mÃ¡ximo divisor comum por decomposiÃ§Ã£o dos nÃºmeros
em fatores primos com o algoritmo de Euclides. Por fim, na SubseÃ§Ã£o 2.3.3, faremos uma
anÃ¡lise de dois algoritmos para o cÃ¡lculo de determinantes: um deles que calcula por meio
de cofatores e do teorema de Laplace e outro que calcula por meio do escalonamento de
Gauss-Jordan.

2.3.1 PotenciaÃ§Ã£o

O primeiro algoritmo que iremos analisar Ã© o da potenciaÃ§Ã£o. O Algoritmo 1 com-

puta uma potenciaÃ§Ã£o nos moldes da DefiniÃ§Ã£o 4.

No Algoritmo 1, para calcular qualquer potÃªncia, partimos do nÃºmero natural 1.
Em seguida, multiplicamo-o pela base ğ‘. O resultado Ã©, entÃ£o, multiplicado por ğ‘, e assim
sucessivamente. Este procedimento Ã© iterado um nÃºmero de vezes igual ao expoente ğ‘›.

2.3. Problemas Escolhidos

43

Algoritmo 1 PotenciaÃ§Ã£o por definiÃ§Ã£o
Entrada: dois nÃºmeros naturais a e n
SaÃ­da: um nÃºmero natural b tal que ğ‘ğ‘› = ğ‘
1: ğ‘ = 1
2: for ğ‘– = 1 do ğ‘›
ğ‘ = ğ‘ Â· ğ‘
3:
4: end for
5: return ğ‘

Neste algoritmo, portanto, o nÃºmero de multiplicaÃ§Ãµes feitas Ã© exatamente igual a
ğ‘›. O laÃ§o for da linha 2 Ã© iterado ğ‘› vezes, cada vez com um tempo constante ğ‘. Portanto,
a funÃ§Ã£o que descreve o tempo de execuÃ§Ã£o do Algoritmo 1 Ã© dada por

ğ‘“ (ğ‘›) = ğ‘ğ‘› = Î˜(ğ‘›)

Um algoritmo alternativo para a potenciaÃ§Ã£o Ã© apresentado no Algoritmo 2. Ele
utiliza como base de construÃ§Ã£o as propriedades da potenciaÃ§Ã£o, descritas na SeÃ§Ã£o 1.4.

Algoritmo 2 PotenciaÃ§Ã£o por divisÃ£o e conquista
Entrada: dois nÃºmeros naturais a e n
SaÃ­da: um nÃºmero natural b tal que ğ‘ğ‘› = ğ‘
1: function Pot2(ğ‘, ğ‘›)
if ğ‘› = 1 then
2:
return ğ‘
3:
4:

else if ğ‘› â‰¡ 0 mod 2 then
)ï¸‚2

(ï¸‚

5:

6:

7:

return Pot2

ğ‘,

else

return Pot2

ğ‘›
2

)ï¸‚2

(ï¸‚

ğ‘,

ğ‘› âˆ’ 1
2

Â· ğ‘

end if
return ğ‘

8:
9:
10: end function

O Algoritmo 2 calcula uma potenciaÃ§Ã£o por meio de uma recorrÃªncia. Se o expoente
for igual a 1, o valor da potÃªncia Ã© o prÃ³prio ğ‘, que Ã© a base da potenciaÃ§Ã£o. Caso contrÃ¡rio,
separa-se o cÃ¡lculo de acordo com a paridade de ğ‘›, o expoente da potenciaÃ§Ã£o: se ğ‘› for
par, faz-se a potenciaÃ§Ã£o

. Caso contrÃ¡rio, faz-se a potenciaÃ§Ã£o

ğ‘ ğ‘›

ğ‘›âˆ’1
2

ğ‘.

)ï¸2

)ï¸2

ğ‘

(ï¸

(ï¸

2

Logo, apÃ³s ğ‘˜ iteraÃ§Ãµes, teremos que o expoente ğ‘›ğ‘˜ serÃ¡ menor que

Observe que, a cada iteraÃ§Ã£o do algoritmo, o expoente se reduz pela metade.
ğ‘›
2ğ‘˜ . Assim, em algum
ğ‘›
momento, teremos ğ‘›ğ‘˜ = 1 (pois a sequÃªncia ğ‘ğ‘˜ =
2ğ‘˜ â†’ 0 quando ğ‘˜ â†’ âˆ). Isto ocorre
quando ğ‘˜ = log2 ğ‘›. DaÃ­, se cada multiplicaÃ§Ã£o leva um tempo constante ğ‘1 para ser
executada e cada divisÃ£o um tempo ğ‘2, entÃ£o a funÃ§Ã£o que dÃ¡ o tempo de execuÃ§Ã£o do
Algoritmo 2 Ã©

ğ‘“ (ğ‘›) = (ğ‘1 + ğ‘2) log2 ğ‘› = Î˜(log ğ‘›)

44

CapÃ­tulo 2. Metodologia

2.3.2 MÃ¡ximo Divisor Comum

Na escola, aprendemos alguns mÃ©todos para obter o MDC entre dois nÃºmeros. O

mÃ©todo da decomposiÃ§Ã£o em fatores primos estÃ¡ descrito no Algoritmo 3.

Algoritmo 3 MDC por decomposiÃ§Ã£o em fatores primos
Entrada: Dois naturais ğ‘ e ğ‘, com ğ‘ â‰¥ ğ‘ e ğ‘ƒ = {ğ‘ğ‘– : ğ‘ğ‘– Ã© o i-Ã©simo nÃºmero primo}.
SaÃ­da: Um nÃºmero natural ğ‘‘ tal que ğ‘€ ğ·ğ¶(ğ‘, ğ‘) = ğ‘‘.

1: ğ‘‘ = 1
2: ğ‘– = 1
3: while ğ‘ > 1 and ğ‘ > 1 and ğ‘ğ‘– â‰¤ ğ‘ do
4:
5:

if ğ‘ â‰¡ 0 mod ğ‘ğ‘– and ğ‘ â‰¡ 0 mod ğ‘ğ‘– then

else if ğ‘ â‰¡ 0 mod ğ‘ğ‘– then

else if ğ‘ â‰¡ 0 mod ğ‘ğ‘– then

6:

7:

8:

9:

10:

11:

ğ‘ =

ğ‘‘ = ğ‘‘ Â· ğ‘ğ‘–
ğ‘
ğ‘ğ‘–
ğ‘
ğ‘ğ‘–

ğ‘ =

ğ‘ =

ğ‘ =

ğ‘
ğ‘ğ‘–

ğ‘
ğ‘ğ‘–

ğ‘– = ğ‘– + 1

else

12:
13:
end if
14:
15: end while
16: return ğ‘‘

O Algoritmo 3 calcula o MDC (ğ‘, ğ‘) como um produto de nÃºmeros primos. Ini-
cialmente, o algoritmo considera o valor de ğ‘‘ = MDC (ğ‘, ğ‘) como sendo 1. Na primeira
iteraÃ§Ã£o, ğ‘ e ğ‘ sÃ£o divididos por ğ‘1 = 2. Se ambas as divisÃµes forem exatas, ğ‘‘ Ã© multi-
plicado por 2 e ğ‘ e ğ‘ tem seus valores atualizados para ğ‘
2, respectivamente. Caso a
divisÃ£o seja exata apenas para ğ‘, apenas o valor de ğ‘ serÃ¡ atualizado e ğ‘‘ permanece igual
a 1. O mesmo ocorre se a divisÃ£o for exata apenas para ğ‘. Caso a divisÃ£o seja inexata para
ambos, o algoritmo passa a dividir ğ‘ e ğ‘ pelo prÃ³ximo primo, que Ã© ğ‘2 = 3. O algoritmo
prossegue enquanto ğ‘ğ‘– for menor ou igual a ğ‘.

2 e ğ‘

Suponha que ğ‘ = 2ğ›¼1 Â· 3ğ›¼2 Â· . . . Â· ğ‘ğ›¼ğ‘˜
ğ‘˜

ğ‘— , com ğ‘ â‰¥ ğ‘, onde
ğ‘ğ‘– representa o ğ‘–-Ã©simo nÃºmero primo e ğ›¼ğ‘– â‰¥ 0 e ğ›½ğ‘– â‰¥ 0. O Teorema Fundamental da
AritmÃ©tica garante que tal representaÃ§Ã£o sempre Ã© possÃ­vel para ğ‘ â‰¥ 2 (GONÃ§ALVES,
2006). Aplicando o logaritmo em base 2 dos dois lados de cada igualdade, temos que

e ğ‘ = 2ğ›½1 Â· 3ğ›½2 Â· . . . Â· ğ‘ğ›½ğ‘—

log2 ğ‘ = ğ›¼1 Â· log2 2 + ğ›¼2 Â· log2 3 + . . . + ğ›¼ğ‘˜ Â· log2 ğ‘ğ‘˜ â‰¥ ğ›¼1 + ğ›¼2 + . . . + ğ›¼ğ‘˜

e

log2 ğ‘ = ğ›½1 Â· log2 2 + ğ›½2 Â· log2 3 + . . . + ğ›½ğ‘— Â· log2 ğ‘ğ‘— â‰¥ ğ›½1 + ğ›½2 + . . . + ğ›½ğ‘—

2.3. Problemas Escolhidos

45

pois log2 ğ‘› â‰¥ 1 para todo ğ‘› â‰¥ 2. Assim, ğ›¼1+ğ›¼2+. . .+ğ›¼ğ‘˜ â‰¤ log2 ğ‘ e ğ›½1+ğ›½2+. . .+ğ›½ğ‘— â‰¤ log2 ğ‘.

O Algoritmo 3 faz, no mÃ­nimo, 2 Â· ğœ‹(ğ‘) testes, dividindo os nÃºmeros ğ‘ e ğ‘ por todos
os primos menores ou iguais a ğ‘. AlÃ©m disso, se ğ‘ e ğ‘ sÃ£o escritos como na decomposiÃ§Ã£o
acima, pode acontecer de serem feitos ğ›¾1 = max{ğ›¼1, ğ›½1} testes para o primeiro primo,
ğ›¾2 = max{ğ›¼2, ğ›½2} testes para o segundo primo, e assim sucessivamente. DaÃ­, o nÃºmero
de divisÃµes realizadas seria, na pior das hipÃ³teses, 2 Â· (ğ›¾1 + ğ›¾2 + . . . + ğ›¾ğ‘›) Â· ğœ‹(ğ‘), onde
ğ›¾ğ‘– = max{ğ›¼ğ‘–, ğ›½ğ‘–} e ğ‘› = max{ğ‘˜, ğ‘—}. Como ğ›¾1 + ğ›¾2 + . . . + ğ›¾ğ‘› â‰¤ (ğ›¼1 + ğ›½1) + (ğ›¼2 + ğ›½2) + . . . +
ğ›¼ğ‘˜ + ğ›½ğ‘— â‰¤ log2 ğ‘ + log2 ğ‘ â‰¤ 2 log2 ğ‘ entÃ£o, se cada divisÃ£o leva um tempo constante ğ‘ para
ser executada, temos que o tempo de execuÃ§Ã£o do Algoritmo 3 Ã© limitado superiormente
pela funÃ§Ã£o

ğ‘“ (ğ‘›) = ğ‘ Â· 4 Â· log2 ğ‘ Â· ğœ‹(ğ‘) = ğ‘‚(log ğ‘ Â· ğœ‹(ğ‘))

Observe que a anÃ¡lise feita acima coloca um limite superior para o tempo de exe-
cuÃ§Ã£o do Algoritmo 3. Por este motivo escrevemos ğ‘“ (ğ‘›) como uma funÃ§Ã£o ğ‘‚(log(ğ‘)ğœ‹(ğ‘)),
e nÃ£o Î˜(log(ğ‘)ğœ‹(ğ‘)).

Podemos calcular o MDC utilizando outro algoritmo. O algoritmo de Euclides para
a determinaÃ§Ã£o do MDC entre dois nÃºmeros Ã© conhecido desde a idade antiga e, surpre-
endentemente, Ã© mais eficiente que o da decomposiÃ§Ã£o em fatores primos. O Algoritmo
4 descreve um procedimento computacional que executa o algoritmo de Euclides para a
determinaÃ§Ã£o do MDC entre dois nÃºmeros.

Algoritmo 4 Algoritmo de Euclides Estendido
Entrada: dois nÃºmeros naturais ğ‘ e ğ‘, com ğ‘ â‰¥ ğ‘
SaÃ­da: um nÃºmero natural ğ‘‘ tal que MDC (ğ‘, ğ‘) = ğ‘‘

1: if ğ‘ = 0 then
ğ‘‘ = ğ‘
2:
3: else
4:
5:
6: end if
7: return ğ‘‘

ğ‘Ÿ = ğ‘ % ğ‘
ğ‘‘ = MDC (ğ‘, ğ‘Ÿ)

O Algoritmo 4 se baseia no fato de que MDC (ğ‘, ğ‘) = MDC (ğ‘, ğ‘Ÿ), onde ğ‘Ÿ Ã© o resto
da divisÃ£o de ğ‘ por ğ‘ (HEFEZ, 2014). Em cada iteraÃ§Ã£o do algoritmo, ğ‘ Ã© dividido por ğ‘,
obtendo-se um resto ğ‘Ÿ. O nÃºmero ğ‘ Ã©, entÃ£o, dividido por ğ‘Ÿ e as definiÃ§Ãµes de ğ‘ e ğ‘ sÃ£o
atualizadas para ğ‘ e ğ‘Ÿ, respectivamente.

Seja ğ‘Ÿğ‘– o resto da ğ‘–-Ã©sima iteraÃ§Ã£o do Algoritmo 4. Ora, o Teorema 4 garante que
ğ‘
2

. Na segunda iteraÃ§Ã£o do algoritmo, ğ‘Ÿ2 <

. Na terceira e quarta iteraÃ§Ãµes do

ğ‘
2

ğ‘Ÿ1 <

ğ‘Ÿ1
2

ğ‘Ÿ2
2

ğ‘
4

algoritmo, tem-se ğ‘Ÿ3 <
, e assim sucessivamente. Observe que, a cada
duas iteraÃ§Ãµes do algoritmo, o resto cai pela metade. Logo, apÃ³s 2ğ‘˜ iteraÃ§Ãµes, teremos
ğ‘
2ğ‘˜ . Como a sequÃªncia (ğ‘Ÿğ‘›) tende para zero quando ğ‘› tende para infinito, em

que ğ‘Ÿ2ğ‘˜ <

e ğ‘Ÿ4 <

<

46

CapÃ­tulo 2. Metodologia

algum momento devemos ter ğ‘Ÿğ‘˜ < 1, momento este em que o algoritmo para. Isto ocorre
quando ğ‘ < 22ğ‘˜, isto Ã©, quando ğ‘˜ >

.

log2 ğ‘
2

O raciocÃ­nio acima, explicitado tambÃ©m em (SCHEINERMAN, 2011), mostra que

log2 ğ‘
2

sÃ£o necessÃ¡rias
divisÃµes para que o Algoritmo 4 dÃª o MDC entre ğ‘ e ğ‘. Se cada
divisÃ£o leva um tempo constante ğ‘ para ser executada, temos que a funÃ§Ã£o que dÃ¡ o tempo
de execuÃ§Ã£o do Algoritmo 4 Ã© dada por

ğ‘“ (ğ‘) = ğ‘ Â·

log2 ğ‘
2

= Î˜(log ğ‘)

2.3.3 Determinantes

Ã‰ comum, ao aprendermos determinantes, aplicarmos mÃ©todos diferentes de cÃ¡lculo
para cada tamanho de matriz quadrada. O caso 2 Ã— 2 Ã© o mais simples. O Algoritmo 5
Ã© um procedimento computacional que executa a fÃ³rmula obtida no Teorema 5 da SeÃ§Ã£o
1.6.

Algoritmo 5 Matrizes 2 Ã— 2

Entrada: uma matriz ğ´ =

)ï¸ƒ

(ï¸ƒğ‘ ğ‘
ğ‘’ ğ‘“

SaÃ­da: um nÃºmero real ğ‘‘ tal que det ğ´ = ğ‘‘

1: ğ‘‘ = ğ‘ Â· ğ‘“ âˆ’ ğ‘ Â· ğ‘’
2: return ğ‘‘

O Algoritmo 5 traduz uma fÃ³rmula fechada. A contagem de operaÃ§Ãµes Ã©, portanto,
fixa. Uma matriz 2 Ã— 2 tem sempre 4 elementos e faremos sempre 2 multiplicaÃ§Ãµes a um
tempo constante ğ‘1 e 1 adiÃ§Ã£o a um tempo constante ğ‘2, totalizando 3 operaÃ§Ãµes, ou seja,
a funÃ§Ã£o que dÃ¡ o tempo de execuÃ§Ã£o do algoritmo 5 Ã© constante, conforme mostra a
funÃ§Ã£o abaixo:

ğ‘“ (ğ‘›) = 2ğ‘1 + ğ‘2 = Î˜(1)

Para o caso de matrizes 3 Ã— 3, em geral utiliza-se a regra de Sarrus, descrita no
Teorema 6. O Algoritmo 6 descreve um procedimento computacional para se calcular o
determinante de uma matriz 3 Ã— 3 por meio da regra de Sarrus.

Algoritmo 6 Determinantes de matrizes 3 Ã— 3

Entrada: uma matriz ğ´ =

â›

âœ
â

ğ‘11 ğ‘12 ğ‘13
ğ‘21 ğ‘22 ğ‘23
ğ‘31 ğ‘32 ğ‘33

â

âŸ
â 

SaÃ­da: um nÃºmero real ğ‘‘ tal que ğ‘‘ = det ğ´
1: ğ‘‘ = ğ‘11ğ‘22ğ‘33 + ğ‘12ğ‘23ğ‘31 + ğ‘13ğ‘21ğ‘32 âˆ’ ğ‘31ğ‘22ğ‘13 âˆ’ ğ‘32ğ‘23ğ‘11 âˆ’ ğ‘33ğ‘21ğ‘12
2: return ğ‘‘

Novamente, por ser uma fÃ³rmula fechada, a regra de Sarrus Ã© sempre um proce-
dimento operacional com um nÃºmero de operaÃ§Ãµes fixo. Neste caso, sabemos que uma

2.3. Problemas Escolhidos

47

matriz 3 Ã— 3 tem 9 elementos. Para aplicar a regra de Sarrus, fazemos 12 multiplicaÃ§Ãµes
a um tempo constante ğ‘1 e 5 adiÃ§Ãµes a um tempo constante ğ‘2. Logo, a funÃ§Ã£o que dÃ¡ o
tempo de execuÃ§Ã£o do Algoritmo 6 Ã© igual a

ğ‘“ (ğ‘›) = 12ğ‘1 + 5ğ‘2 = Î˜(1)

Para o cÃ¡lculo de determinantes de ordens quaisquer, temos duas possibilidades:
podemos usar o teorema de Laplace (Teorema 4 da SeÃ§Ã£o 1.6), que Ã© o mÃ©todo dos co-
fatores, ou aplicar o escalonamento de Gauss para transformar a matriz em uma matriz
triangular e, em seguida, multiplicar os nÃºmeros da diagonal principal. O Algoritmo 7
descreve um procedimento computacional para o cÃ¡lculo do determinante atravÃ©s de co-
fatores e o Algoritmo 8, um procedimento para o cÃ¡lculo por meio do escalonamento de
Gauss.

Algoritmo 7 Determinantes por cofatores
Entrada: Uma matriz quadrada ğ´ğ‘›Ã—ğ‘›, com ğ‘› âˆˆ ğ‘
SaÃ­da: Um nÃºmero real ğ‘‘ tal que ğ‘‘ = det ğ´
1: function Det(ğ´, ğ‘›)
2:

if ğ‘› = 1 then
return ğ‘11
else

3:
4:
5:
6:

7:

ğ‘‘ = 0
for ğ‘— = ğ‘– do ğ‘›

ğ‘– = 1

â›

âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
âœ
â

ğ‘11
ğ‘21
...

ğ‘12
ğ‘22
...

...
ğ‘ğ‘›1

...
ğ‘ğ‘›2

ğ‘€ğ‘–ğ‘— =

ğ‘(ğ‘–âˆ’1)1 ğ‘(ğ‘–âˆ’1)2
ğ‘(ğ‘–+1)1 ğ‘(ğ‘–+1)2

ğ‘1(ğ‘—âˆ’1)
ğ‘2(ğ‘—âˆ’1)
...

ğ‘1(ğ‘—+1)
ğ‘2(ğ‘—+1)
...

Â· Â· Â·
Â· Â· Â·
. . .
Â· Â· Â· ğ‘(ğ‘–âˆ’1)(ğ‘—âˆ’1) ğ‘(ğ‘–âˆ’1)(ğ‘—+1)
Â· Â· Â· ğ‘(ğ‘–+1)(ğ‘—âˆ’1) ğ‘(ğ‘–+1)(ğ‘—+1)
. . .
Â· Â· Â·

...
ğ‘ğ‘›(ğ‘—âˆ’1)

...
ğ‘ğ‘›(ğ‘—+1)

Â· Â· Â·
Â· Â· Â·

ğ‘1ğ‘›
ğ‘2ğ‘›
...

Â· Â· Â·
Â· Â· Â· ğ‘(ğ‘–âˆ’1)ğ‘›
Â· Â· Â· ğ‘(ğ‘–+1)ğ‘›
Â· Â· Â·
Â· Â· Â·

...
ğ‘ğ‘›ğ‘›

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

end for
ğ‘‘ = (âˆ’1)ğ‘–+ğ‘—ğ‘ğ‘–ğ‘—Â· Det(ğ‘€ğ‘–ğ‘—, ğ‘› âˆ’ 1)
return ğ‘‘

8:
9:
10:
11:
12: end function

end if

No Algoritmo 7, comeÃ§amos pela linha 1. Nesta linha, hÃ¡ ğ‘› cofatores. Como eles
serÃ£o multiplicados pelos determinantes menores, teremos ğ‘› multiplicaÃ§Ãµes. Os determi-
nantes menores sÃ£o determinantes de matrizes (ğ‘› âˆ’ 1) Ã— (ğ‘› âˆ’ 1). Para cada determinante
menor, inicia-se com a 1a linha. Ela terÃ¡ ğ‘› âˆ’ 1 cofatores, o que implica que serÃ£o feitas
ğ‘› âˆ’ 1 multiplicaÃ§Ãµes. Logo, o total de multiplicaÃ§Ãµes, por enquanto, Ã© ğ‘› Â· (ğ‘› âˆ’ 1). Prosse-
guindo com este raciocÃ­nio, temos que o nÃºmero de multiplicaÃ§Ãµes para o cÃ¡lculo de um
determinante por este mÃ©todo Ã© igual a

ğ‘›(ğ‘› âˆ’ 1)(ğ‘› âˆ’ 2) Â· Â· Â· 3 Â· 2 Â· 1 = ğ‘›!

48

CapÃ­tulo 2. Metodologia

Com relaÃ§Ã£o ao nÃºmero de adiÃ§Ãµes, observe que, se matriz tem dimensÃ£o 1, nÃ£o
hÃ¡ adiÃ§Ãµes a fazer. O nÃºmero de adiÃ§Ãµes Ã©, portanto, igual a zero. No caso de matrizes
2 Ã— 2, hÃ¡ 2 determinantes 1 Ã— 1 com zero adiÃ§Ãµes cada, mais uma adiÃ§Ã£o entre eles. Para
matrizes 3 Ã— 3, hÃ¡ 3 determinantes 2 Ã— 2, cada um com 1 adiÃ§Ã£o, mais duas adiÃ§Ãµes entre
os resultados. Prosseguindo com este raciocÃ­nio, podemos construir a Tabela 9.

Tabela 9 â€“ Quantidade de adiÃ§Ãµes do Algoritmo 7

Tamanho da matriz Quantidade de adiÃ§Ãµes

1 Ã— 1
2 Ã— 2
3 Ã— 3
4 Ã— 4
...
ğ‘› Ã— ğ‘›

ğ‘1 = 0
ğ‘2 = 2 Â· ğ‘1 + 1
ğ‘3 = 3 Â· ğ‘2 + 2
ğ‘4 = 4 Â· ğ‘3 + 3
...
ğ‘ğ‘› = ğ‘› Â· ğ‘ğ‘›âˆ’1 + ğ‘› âˆ’ 1

Observe que, para determinar a quantidade de adiÃ§Ãµes realizadas pelo Algoritmo

7, chegamos Ã  recorrÃªncia

â§
âªâ¨

ğ‘1 = 0

âªâ©

ğ‘ğ‘› = ğ‘› Â· ğ‘ğ‘›âˆ’1 + ğ‘› âˆ’ 1

Lema 1. A soluÃ§Ã£o da recorrÃªncia

â§
âªâ¨

ğ‘1 = 0

âªâ©

ğ‘ğ‘› = ğ‘› Â· ğ‘ğ‘›âˆ’1 + ğ‘› âˆ’ 1

,

se ğ‘› â‰¥ 1 Ã© ğ‘ğ‘› = ğ‘›! âˆ’ 1.

DemonstraÃ§Ã£o: por induÃ§Ã£o sobre ğ‘›. Para ğ‘› = 1, Ã© vÃ¡lida, pois ğ‘1 = 1! âˆ’ 1 = 0.

Supondo a recorrÃªncia vÃ¡lida para algum ğ‘› âˆˆ N, temos

ğ‘ğ‘›+1 = (ğ‘› + 1)ğ‘ğ‘› + ğ‘› = (ğ‘› + 1)(ğ‘›! âˆ’ 1) + ğ‘› = (ğ‘› + 1)ğ‘›! âˆ’ ğ‘› âˆ’ 1 + ğ‘› = (ğ‘› + 1)! âˆ’ 1

Pelo princÃ­pio da induÃ§Ã£o, a soluÃ§Ã£o ğ‘ğ‘› = ğ‘›! âˆ’ 1 Ã© vÃ¡lida para todo ğ‘› natural.

(cid:3)

A discussÃ£o acima mostra que, se cada multiplicaÃ§Ã£o for feita a um tempo ğ‘1 e
cada adiÃ§Ã£o a um tempo ğ‘2, entÃ£o a funÃ§Ã£o que dÃ¡ o tempo de execuÃ§Ã£o do Algoritmo 7
Ã© dada por

ğ‘“ (ğ‘›) = ğ‘1ğ‘›! + ğ‘2(ğ‘›! âˆ’ 1) = Î˜(ğ‘›!)

2.3. Problemas Escolhidos

49

O Algoritmo 8 apresenta um mÃ©todo alternativo para o cÃ¡lculo de determinantes

de matrizes de ordem ğ‘›, baseado no escalonamento de Gauss.

Algoritmo 8 Determinantes por escalonamento
Entrada: Uma matriz quadrada ğ´ğ‘›Ã—ğ‘›, com ğ‘› âˆˆ ğ‘
SaÃ­da: Um nÃºmero real ğ‘‘ tal que ğ‘‘ = det ğ´

1: for ğ‘˜ = 1 do ğ‘›
ğ‘š = ğ‘˜
2:
while ğ‘ğ‘šğ‘˜ = 0 do
3:
ğ‘š = ğ‘š + 1
4:
5:
6:

end while
if ğ‘š > ğ‘› then
return 0
end if
swap(ğ´ğ‘š, ğ´ğ‘˜)
for ğ‘– = ğ‘˜ + 1 do ğ‘›
for ğ‘— = ğ‘˜ do ğ‘›
ğ‘ğ‘–ğ‘— = ğ‘ğ‘–ğ‘— âˆ’

7:
8:
9:
10:

11:

end for

end for

12:
13:
14: end for
15: ğ‘‘ = 1
16: for ğ‘– = 1 do ğ‘›
17:
18: end for
19: return ğ‘‘

ğ‘‘ = ğ‘‘ Â· ğ‘ğ‘–ğ‘–

(ï¸‚ ğ‘ğ‘–ğ‘˜
ğ‘ğ‘˜ğ‘˜

)ï¸‚

Â· ğ‘ğ‘˜ğ‘—

No Algoritmo 8, iniciamos pelo elemento da 1a linha e da 1a coluna da matriz A.
Caso ele seja zero, permutamos com a 1a linha com a 2a, e assim sucessivamente, atÃ©
que apareÃ§a um elemento nÃ£o-nulo. Observe que se todos os elementos forem nulos, o
determinante serÃ¡ zero. Para cada linha ğ‘–, com 2 â‰¤ ğ‘– â‰¤ ğ‘›, substituÃ­mos o elemento ğ‘ğ‘–ğ‘—
por ğ‘ğ‘–ğ‘— âˆ’ ğ‘1ğ‘— Â·

.

ğ‘ğ‘–1
ğ‘11

O processo descrito acima faz com que todos os elementos da 1a coluna abaixo
da 1a linha se tornem nulos. Repetindo o procedimento para a 2a linha, zeramos todos
os elementos da 2a coluna abaixo da 2a linha, e assim por diante, atÃ© que a matriz A Ã©
transformada em uma matriz triangular superior. Finalmente, multiplicamos os elementos
da diagonal principal, obtendo um nÃºmero real ğ‘‘, que Ã© o determinante de A.

)ï¸‚

(ï¸‚ ğ‘ğ‘–1
ğ‘11

No Algoritmo 8, como cada linha possui ğ‘› elementos, a substituiÃ§Ã£o ğ‘ğ‘–ğ‘— â† ğ‘ğ‘–ğ‘— âˆ’
na primeira iteraÃ§Ã£o do laÃ§o while tem um custo de uma divisÃ£o a um tempo

ğ‘1ğ‘— Â·
constante ğ‘1, uma multiplicaÃ§Ã£o a um tempo constante ğ‘2 e uma adiÃ§Ã£o a um tempo
constante ğ‘3. Logo, em cada linha sÃ£o feitas 3ğ‘› operaÃ§Ãµes, no mÃ¡ximo, a um tempo
constante ğ‘ para algum ğ‘ âˆˆ R. Como esta operaÃ§Ã£o Ã© feita em ğ‘› âˆ’ 1 linhas, temos um

50

CapÃ­tulo 2. Metodologia

custo de tempo da ordem de

3ğ‘›(ğ‘› âˆ’ 1) Â· ğ‘,

com ğ‘ âˆˆ R.

Na segunda iteraÃ§Ã£o do laÃ§o while, as operaÃ§Ãµes para cada elemento sÃ£o feitas ğ‘›âˆ’1

vezes, ao longo de ğ‘› âˆ’ 2 linhas. O tempo gasto Ã©, portanto, uma funÃ§Ã£o da forma

3(ğ‘› âˆ’ 1)(ğ‘› âˆ’ 2) Â· ğ‘,

com ğ‘ âˆˆ R

Logo, o custo de tempo total Ã© dado pelo somatÃ³rio

ğ‘“ (ğ‘›) = 3ğ‘[ğ‘›(ğ‘› âˆ’ 1) + (ğ‘› âˆ’ 1)(ğ‘› âˆ’ 2) + Â· Â· Â· + 2 Â· 1] = 3ğ‘

ğ‘›
âˆ‘ï¸

= 3ğ‘

(ğ‘›2 âˆ’ 2ğ‘›ğ‘˜ + ğ‘› + ğ‘˜2 âˆ’ ğ‘˜)

= 3ğ‘

ğ‘˜=1
[ï¸ƒ

ğ‘›2

ğ‘›
âˆ‘ï¸

ğ‘˜=1

1 âˆ’ (2ğ‘› + 1)

ğ‘›
âˆ‘ï¸

ğ‘˜=1

ğ‘˜ + ğ‘›

ğ‘›
âˆ‘ï¸

ğ‘˜=1

1 +

]ï¸ƒ

ğ‘˜2

ğ‘›
âˆ‘ï¸

ğ‘˜=1

ğ‘›
âˆ‘ï¸

(ğ‘› âˆ’ ğ‘˜)[ğ‘› âˆ’ (ğ‘˜ âˆ’ 1)]

ğ‘˜=1

Usando a conhecida fÃ³rmula

ğ‘›
âˆ‘ï¸

ğ‘˜=1

ğ‘˜2 =

ğ‘›(ğ‘› + 1)(2ğ‘› + 1)
6

,

, a qual pode ser consultada em (LIMA et al., 2006), temos que o custo das operaÃ§Ãµes Ã©:

[ï¸ƒ

ğ‘“ (ğ‘›) = 3ğ‘

ğ‘›3 âˆ’ (2ğ‘› + 1)

ğ‘›(ğ‘› + 1)
2

+ ğ‘›2 +

ğ‘›(ğ‘› + 1)(2ğ‘› + 1)
6

]ï¸ƒ

= 3ğ‘

[ï¸ƒ 6ğ‘›3 âˆ’ 6ğ‘›3 âˆ’ 6ğ‘› âˆ’ 3ğ‘›2 âˆ’ 3ğ‘› + 6ğ‘›2 + 2ğ‘›3 + ğ‘›2 + 2ğ‘›2 + ğ‘›
6

]ï¸ƒ

= ğ‘

2ğ‘›3 + 6ğ‘›2 âˆ’ 8ğ‘›
2

= ğ‘(ğ‘›3 + 3ğ‘›2 âˆ’ 4ğ‘›)

Portanto,

ğ‘“ (ğ‘›) = Î˜(ğ‘›3).

Este Ã© o custo para triangularizar a matriz A. Em seguida, faz-se apenas ğ‘› âˆ’ 1
multiplicaÃ§Ãµes com os nÃºmeros da diagonal principal. Como este nÃºmero Ã© acrescentado
ao nÃºmero anterior, ainda tem-se a funÃ§Ã£o custo do cÃ¡lculo do determinante por escalo-
namento da ordem de ğ‘›3.

3 Resultados

51

Neste capÃ­tulo, iremos aplicar os algoritmos em exemplos conhecidos, de modo
a comparar sua eficiÃªncia. Aplicaremos tanto em exemplos extraÃ­dos de livros didÃ¡ticos
quanto em exemplos numÃ©ricos com nÃºmeros de ordem elevada. Esta Ãºltima anÃ¡lise tem
o propÃ³sito de mostrar o comportamento assintÃ³tico dos algoritmos Ã  medida que cresce
o tamanho da amostra.

3.1 Algoritmos de PotenciaÃ§Ã£o

O primeiro algoritmo a ser analisado Ã© o da potenciaÃ§Ã£o. Vamos testÃ¡-lo primeira-
mente em um exemplo didÃ¡tico, extraÃ­do de (IMENES; LELLIS, 2012), com adaptaÃ§Ãµes.

Exemplo 1. Calcule o valor da potÃªncia 43.

SoluÃ§Ã£o Temos que ğ‘ = 4 e ğ‘› = 3.

De acordo com o Algoritmo 1, seguem-se os seguintes passos.

1. iniciamos com o valor 1;

2. em seguida, multiplicamo-no por 4, obtendo 1 Â· 4 = 4;

3. multiplicamos o resultado por 4, obtendo 4 Â· 4 = 16;

4. multiplicamos o resultado por 4, obtendo 16 Â· 4 = 64.

ApÃ³s fazer as multiplicaÃ§Ãµes, obtemos a resposta: 64. O nÃºmero de multiplicaÃ§Ãµes

realizadas utilizando este algoritmo Ã© igual 3.

Agora, aplicando o Algoritmo 2:

1. separamos a potÃªncia em 42 Â· 41;

2. atribui-se 41 = 4;

3. depois, calculamos 42 = 4 Â· 4 = 16;

4. por Ãºltimo, utilizamos os valores de 42 e 41 para concluir o cÃ¡lculo, obtendo 42 Â· 41 =

16 Â· 4 = 64.

Embora os dois mÃ©todos sejam bastante parecidos, aplicando o Algoritmo 2 exe-

cutamos apenas 2 multiplicaÃ§Ãµes.

52

CapÃ­tulo 3. Resultados

(cid:3)

Para comparar os dois algoritmos de forma mais transparente, utilizamos um sor-
teador de bases e expoentes. Em linguagem Python, escrevemos os dois algoritmos. Em
seguida, inserimos um comando de geraÃ§Ã£o aleatÃ³ria de nÃºmeros naturais nos intervalos
fechados [1, 10], [1, 100], [1, 1 000] e [1, 10 000]. Para cada intervalo, o cÃ³digo sorteou
100 valores para a base e o expoente dentro dos limites do intervalo e, partindo desses
valores, calculou-se as potenciaÃ§Ãµes. Por fim, o cÃ³digo incluiu um contador do nÃºmero de
multiplicaÃ§Ãµes realizadas por cada algoritmo. O cÃ³digo retorna como valores de saÃ­da um
par ordenado (ğ‘¥, ğ‘¦), onde ğ‘¥ representa o limite superior do intervalo e ğ‘¦, o nÃºmero mÃ©dio
de multiplicaÃ§Ãµes feitas considerando as 100 amostras. Os cÃ³digos em Python podem ser
consultados no ApÃªndice 1.

Por exemplo, no intervalo [1, 10], o programa sorteou 100 valores para a base e
o expoente. ApÃ³s calcular as 100 potÃªncias, o programa contou o nÃºmero de multipli-
caÃ§Ãµes realizadas em cada uma e calculou a mÃ©dia aritmÃ©tica desses valores. No nosso
experimento, o nÃºmero mÃ©dio de multiplicaÃ§Ãµes foi 5,02 para o Algoritmo 1 e 2,65 para o
Algoritmo 2. A Tabela 10 mostra o nÃºmero mÃ©dio de multiplicaÃ§Ãµes realizadas por cada
algoritmo em cada intervalo, com 100 amostras por intervalo.

Tabela 10 â€“ NÃºmero mÃ©dio de multiplicaÃ§Ãµes para os Algoritmos 1 e 2

Intervalo Algoritmo 1 Algoritmo 2

[1, 10]
[1, 100]
[1, 1000]
[1, 10000]

5,02
47,36
507,06
5.717,72

2,65
6,97
11,92
16,71

A Tabela 10 mostra, de forma evidente, que o Algoritmo 2, que calcula a potenci-
aÃ§Ã£o por divisÃ£o e conquista, utilizando propriedades de potÃªncia, Ã© muito mais eficiente
que o Algoritmo 1, que calcula uma potenciaÃ§Ã£o por definiÃ§Ã£o. Por exemplo, para expo-
entes variando de 1 a 100, o Algoritmo 1 fez, em mÃ©dia, 47,36 multiplicaÃ§Ãµes para calcular
cada potenciaÃ§Ã£o, contra 6,97 multiplicaÃ§Ãµes no Algoritmo 2. Observe que mesmo para
instÃ¢ncias de valor baixo, isto Ã©, no intervalo [1, 10], jÃ¡ hÃ¡ uma grande diferenÃ§a entre
o nÃºmero mÃ©dio de multiplicaÃ§Ãµes efetuadas pelos dois algoritmos, jÃ¡ que o Algoritmo 1
faz, em mÃ©dia, o dobro de multiplicaÃ§Ãµes em relaÃ§Ã£o ao Algoritmo 2.

Estes resultados estÃ£o de acordo com a anÃ¡lise de complexidade feita no CapÃ­tulo
3. LÃ¡, verificamos que o custo operacional do Algoritmo 1 era uma funÃ§Ã£o Î˜(ğ‘›), enquanto
a do Algoritmo 2, Î˜(lg ğ‘›). Deste modo, com expoentes variando de 1 a 100, temos 50
como valor mÃ©dio. DaÃ­, o nÃºmero mÃ©dio de multiplicaÃ§Ãµes para o Algoritmo 1 seria 50 e,
do Algoritmo 2, lg 50 â‰ˆ 5, 64.

3.2. Algoritmos de MDC

53

Figura 1 â€“ Algoritmos de potenciaÃ§Ã£o

A Figura 1 compara os dois experimentos realizados com o cÃ³digo Python para os
Algoritmos 1 e 2. O grÃ¡fico mostra o nÃºmero de multiplicaÃ§Ãµes em funÃ§Ã£o do expoente
ğ‘› nos dois casos. Observe que, dada a escala utilizada, o grÃ¡fico para o Algoritmo 2
Ã© praticamente uma reta horizontal, o que mostra sua enorme vantagem em termos de
custo operacional.

3.2 Algoritmos de MDC

Nesta seÃ§Ã£o, iremos comparar os algoritmos para o cÃ¡lculo do MDC, apresentados
na SeÃ§Ã£o 3.2. Vamos comeÃ§ar com um exemplo retirado do livro didÃ¡tico (BARROSO;
MATHEUS; NANI, 2010), com adaptaÃ§Ãµes.

Exemplo 2. Calcule o MDC entre 180 e 150.

SoluÃ§Ã£o Aplicando o Algoritmo 3 com ğ‘ = 180, ğ‘ = 150 e ğ‘› = 6, temos:

1. o teste ğ‘ > 1 e ğ‘ > 1 Ã© feito sempre no inÃ­cio da cada iteraÃ§Ã£o. Caso um dos dois
seja igual a 1, o algoritmo pÃ¡ra e dÃ¡ a resposta. Nenhum dos dois Ã© igual a 1. Logo,
podemos executar o laÃ§o while, dividindo ğ‘ e ğ‘ pelo menor nÃºmero primo, ğ‘1 = 2,
obtendo

= 90 e

= 75;

180
2

150
2

54

CapÃ­tulo 3. Resultados

2. prosseguimos, dividindo 90 e 75 por 2.

(Observe que 75 â‰¡ 1 mod 2);

90
2

= 45, mas 75 nÃ£o Ã© divisÃ­vel por 2.

3. Ã© necessÃ¡rio dividir 45 mais uma vez por 2, o que nÃ£o Ã© possÃ­vel, pois 45 â‰¡ 1 mod 2;

4. agora, passamos a dividir ambos os nÃºmeros pelo prÃ³ximo primo, que Ã© ğ‘2 = 3,

obtendo

= 15 e

= 25;

45
3

75
3

5. prosseguimos com a divisÃ£o por 3.

mod 3);

15
3

= 5, mas 25 nÃ£o Ã© divisÃ­vel por 3. (25 â‰¡ 1

6. a divisÃ£o de 5 por 3 nÃ£o Ã© possÃ­vel, pois 5 â‰¡ 2 mod 3. DaÃ­, passamos a dividir pelo

prÃ³ximo primo, ğ‘3 = 5, obtendo

= 1 e

= 5;

5
5

25
5

7. um dos nÃºmeros ğ‘ ou ğ‘ Ã© 1. Logo, o MDC (180, 150), serÃ¡ o resultado da multiplicaÃ§Ã£o
de todos os nÃºmeros primos que dividiram ambos ğ‘ e ğ‘, logo MDC (180, 150) =
2 Â· 3 Â· 5 = 30;

8. portanto, MDC (180, 150) = 30.

Contando as operaÃ§Ãµes, realizamos 12 divisÃµes (entre exatas e nÃ£o exatas) e 2
multiplicaÃ§Ãµes, totalizando 14 operaÃ§Ãµes. Se considerarmos apenas o nÃºmero de divisÃµes,
foram 12.

Agora vamos aplicar o Algoritmo de Euclides (Algoritmo 4).

1. primeiramente, faz-se o teste para saber se um dos dois nÃºmeros Ã© zero. Como

nenhum dos dois Ã© zero, prosseguimos com o algoritmo como se segue;

2. dividimos 180 por 150, de modo a obter o quociente e o resto, obtendo 180 =

1 Â· 150 + 30;

3. agora, faz-se o MDC entre 150 e 30. Como nenhum dos dois Ã© zero, dividimos 150

por 30, obtendo 150 = 5 Â· 30 + 0;

4. agora, faz-se o MDC entre 30 e 0. Como um dos dois Ã© zero, conclui-se que o MDC

(180, 150) = 30.

Contando o nÃºmero de operaÃ§Ãµes neste algoritmo, temos apenas 2 divisÃµes.

(cid:3)

3.2. Algoritmos de MDC

55

Semelhantemente ao que fizemos para a potenciaÃ§Ã£o, escrevemos um cÃ³digo em
Python para calcular o MDC (ğ‘, ğ‘) por meio dos Algoritmos 3 e 4 e contar o nÃºmero
de divisÃµes realizadas. Os intervalos de amostragem foram do tipo [1, 10ğ‘˜], com ğ‘˜ âˆˆ
{1, 2, . . . , 12}. Em cada intervalo, foram geradas 100 amostras com ğ‘ e ğ‘ variando aleato-
riamente no intervalo. Em cada amostra, registrou-se o nÃºmero de divisÃµes realizadas e,
em seguida, calculou-se o nÃºmero mÃ©dio de divisÃµes realizadas.

Para o Algoritmo 3, necessitou-se de uma lista de primos. Utilizamos uma lista
com os primeiros 1 milhÃ£o de primos. A Tabela 11 mostra o nÃºmero mÃ©dio de divisÃµes
realizadas por cada algoritmo em cada intervalo, com 100 amostras por intervalo.

Tabela 11 â€“ NÃºmero mÃ©dio de divisÃµes para os Algoritmos 3 e 4

Intervalo Algoritmo 3 Algoritmo 4

[1, 10]
[1, 102]
[1, 103]
[1, 106]
[1, 109]
[1, 1012]

8,95
29,01
111,84
23.125,36
112.620,67
144.298,78

1,73
3,94
5,81
12,23
17,58
23,62

Novamente, os dados obtidos no experimento mostram uma enorme diferenÃ§a entre
os algoritmos. Observando a Tabela 11, vemos que o Algoritmo 4 Ã© muito mais eficiente
que o Algoritmo 3. Por exemplo, para nÃºmeros aleatÃ³rios no intervalo [1, 106], o nÃºmero
mÃ©dio de divisÃµes realizadas pelo Algoritmo 4 Ã© 12,23 contra 23.125,36 do Algoritmo 3.

A Figura 2 compara os Algoritmos 3 e 4 com base nos experimentos realizados
em linguagem Python. O grÃ¡fico mostra o nÃºmero de divisÃµes em funÃ§Ã£o da ordem de
grandeza dos nÃºmeros ğ‘ e ğ‘. O eixo horizontal estÃ¡ na escala logarÃ­tmica, para facilitar a
leitura. Observe que o grÃ¡fico relativo ao Algoritmo 4 Ã© praticamente uma reta horizontal,
o que mostra sua vantagem em termos de custo operacional.

Ã‰ importante notar que a escala dos eixos na Figura 2 pode levar a falsas conclu-
sÃµes. Aparentemente, para valores de ğ‘ e ğ‘ da ordem de 102 nÃ£o hÃ¡ muita diferenÃ§a entre
os algoritmos. Contudo, enquanto o Algoritmo 3 efetua em mÃ©dia 29 divisÃµes, aproxima-
damente, o Algoritmo 4 efetua pouco menos de 4, o que representa 7 vezes mais divisÃµes
no Algoritmo 3 do que no Algoritmo 4. Analisando os livros didÃ¡ticos adotados nas es-
colas consultadas, vemos que a maioria absoluta dos exemplos utilizados para o cÃ¡lculo
de mÃ¡ximo divisor comum sÃ£o de nÃºmeros no intervalo [1, 103], onde o Algoritmo 4 jÃ¡ se
mostra muito mais eficiente.

56

CapÃ­tulo 3. Resultados

Figura 2 â€“ Algoritmos de mÃ¡ximo divisor comum

3.3 Algoritmos de Determinantes

Nesta seÃ§Ã£o, iremos aplicar os algoritmos desenvolvidos para calcular determinan-
tes. Iniciaremos com os determinantes de matrizes de ordem 2, com um exemplo do livro
didÃ¡tico (IEZZI et al., 2011), com adaptaÃ§Ãµes.

Exemplo 3. Calcule o determinante da matriz ğ´ =

â›

â

â

â 

1 âˆ’1
2
2

SoluÃ§Ã£o Primeiramente, aplicaremos o Algoritmo 5. Basta substituir os valores

na fÃ³rmula.

det ğ´ =

â›

â

â
â  = 1 Â· 2 âˆ’ 2 Â· (âˆ’1) = 2 + 2 = 4

1 âˆ’1
2
2

Por se tratar de uma fÃ³rmula fechada, o nÃºmero de operaÃ§Ãµes realizadas Ã© sem-
pre igual a 3: duas multiplicaÃ§Ãµes e uma adiÃ§Ã£o. Se observarmos apenas o nÃºmero de
multiplicaÃ§Ãµes, foram duas.

3.3. Algoritmos de Determinantes

57

Pelo Algoritmo 7, comeÃ§amos com a primeira linha da matriz. Temos, entÃ£o, que

ğ‘€11 = 2 e ğ‘€12 = 2.

Logo, pela fÃ³rmula, tem-se que det ğ´ = (âˆ’1)1+1 Â· 1 Â· det ğ‘€11 + (âˆ’1)1+2 Â· (âˆ’1) Â·

det ğ‘€12 = (âˆ’1)2 Â· 1 Â· 2 + (âˆ’1)3 Â· (âˆ’1) Â· 2 = 2 + 2 = 4.

Contando as operaÃ§Ãµes, foram feitas 2 multiplicaÃ§Ãµes e 1 adiÃ§Ã£o, totalizando 3

operaÃ§Ãµes. Se observarmos apenas o nÃºmero de multiplicaÃ§Ãµes, foram 2.

Agora vamos utilizar o escalonamento de Gauss, descrito no Algoritmo 8. Como
o elemento ğ‘11 Ã© nÃ£o-nulo, o escolhemos como pivÃ´. Em seguida, multiplicamos a linha 1
e somamos o resultado Ã  linha 2, substituindo-a pelos valores obtidos. Assim,
por

âˆ’ğ‘21
ğ‘11

os elementos da linha 2 passam a ser:

e

ğ‘21 = ğ‘11 Â·

)ï¸‚

(ï¸‚ âˆ’ğ‘21
ğ‘11

+ ğ‘21 = 1 Â·

)ï¸‚

(ï¸‚ âˆ’2
1

+ 2 = 0

ğ‘22 = ğ‘12 Â·

)ï¸‚

(ï¸‚ âˆ’ğ‘21
ğ‘11

+ ğ‘22 = âˆ’1 Â·

)ï¸‚

(ï¸‚ âˆ’2
1

+ 2 = 4

Isto Ã©, obtemos a matriz triangular superior

â›

1 âˆ’1
â
4
0

â

â 

Agora, o determinante Ã© dado pelo produto dos elementos da diagonal principal,

ou seja, det ğ´ = 1 Â· 4 = 4

Fazendo a contagem de operaÃ§Ãµes, vemos que foram utilizadas 3 multiplicaÃ§Ãµes e
2 adiÃ§Ãµes, num total de 5 operaÃ§Ãµes. Se contarmos apenas o nÃºmero de multiplicaÃ§Ãµes,
foram 3.

(cid:3)

Para analisar a aplicaÃ§Ã£o dos algoritmos em matrizes 3Ã—3, utilizaremos no exemplo

4 um problema do livro (DANTE, 2014), com adaptaÃ§Ãµes.

Exemplo 4. Aplicando a regra de Sarrus, calcule o determinante da matriz

â›

âœ
âœ
âœ
â

ğ´ =

SoluÃ§Ã£o:

2 âˆ’1
3
4
0
5
1
2 âˆ’3

â

âŸ
âŸ
âŸ
â 

58

CapÃ­tulo 3. Resultados

Primeiro vamos obedecer ao comando do exemplo e utilizar a regra de Sarrus,
descrita no Algoritmo 6, para calcular o determinante. Basta substituir os valores na
fÃ³rmula.

det ğ´ =

â›
2 âˆ’1
3
âœ
âœ
4
0
5
âœ
â
1
2 âˆ’3

â

âŸ
âŸ
âŸ
â 

= 3 Â· 0 Â· 1 + 2 Â· 4 Â· 2 + (âˆ’1) Â· 5 Â· (âˆ’3) âˆ’ 2 Â· 0 Â· (âˆ’1) âˆ’ (âˆ’3) Â· 4 Â· 3 âˆ’ 1 Â· 5 Â· 2

= 0 + 16 + 15 âˆ’ 0 + 36 âˆ’ 10 = 57

Por se tratar de uma fÃ³rmula fechada, o nÃºmero de multiplicaÃ§Ãµes e adiÃ§Ãµes Ã© fixo,
sendo 12 multiplicaÃ§Ãµes e 5 adiÃ§Ãµes, totalizando 17 operaÃ§Ãµes. Observando apenas o nÃº-
mero de multiplicaÃ§Ãµes, sÃ£o 12 (estamos aqui contando tambÃ©m as adiÃ§Ãµes e multiplicaÃ§Ãµes
por zero).

Agora, usando o Algoritmo 7, escolhe-se uma linha da matriz aleatoriamente, di-

gamos, a segunda. Temos, entÃ£o, que:

â›

â

ğ‘€21 =

â
â  ; ğ‘€22 =

2 âˆ’1
1
âˆ’3

â›

â

â
â  eğ‘€23 =

3 âˆ’1
1
2

â›
3
2
â
2 âˆ’3

â

â 

Apenas para efeito de organizaÃ§Ã£o, calcularemos os determinantes de ğ‘€21, ğ‘€22 e
ğ‘€23 separadamente, inserindo-os posteriormente na fÃ³rmula. Sem perda de generalidade,
escolheremos a primeira linha de cada uma das matrizes para o cÃ¡lculo dos determinantes.

det ğ‘€21 = (âˆ’1)2 Â· 2 Â· 1 + (âˆ’1)3 Â· (âˆ’1) Â· (âˆ’3) = âˆ’1
det ğ‘€22 = (âˆ’1)2 Â· 3 Â· 1 + (âˆ’1)3 Â· (âˆ’1) Â· 2 = 5
det ğ‘€23 = (âˆ’1)2 Â· 3 Â· (âˆ’3) + (âˆ’1)3 Â· 2 Â· 2 = âˆ’13

Feito isto, aplicamos a fÃ³rmula explicitada no Algoritmo 7.

det ğ´ = (âˆ’1)2+1 Â· 5 Â· det ğ‘€21 + (âˆ’1)2+2 Â· 0 Â· det ğ‘€22 + (âˆ’1)2+3 Â· 4 Â· det ğ‘€23

= (âˆ’1) Â· 5 Â· (âˆ’1) + 1 Â· 0 Â· 5 + (âˆ’1) Â· 4 Â· (âˆ’13) = 5 + 52 = 57

Contando o nÃºmero de operaÃ§Ãµes, temos 6 multiplicaÃ§Ãµes e 5 adiÃ§Ãµes, totalizando

11 operaÃ§Ãµes. Se contarmos apenas o nÃºmero de multiplicaÃ§Ãµes, sÃ£o 6.

Aplicando o Algoritmo 8, temos que o primeiro elemento da primeira linha Ã© nÃ£o-
e somamos o resultado com a linha ğ‘–,

nulo. Logo, multiplicamos a primeira linha por âˆ’ğ‘ğ‘–1
ğ‘11
com 2 â‰¤ ğ‘– â‰¤ 3, substituindo os resultados na linha ğ‘–. Temos que cada ğ‘ğ‘–ğ‘— serÃ¡:

3.3. Algoritmos de Determinantes

59

ğ‘21 = âˆ’

ğ‘22 = âˆ’

ğ‘23 = âˆ’

ğ‘31 = âˆ’

ğ‘32 = âˆ’

ğ‘33 = âˆ’

5
3
5
3
5
3
2
3
2
3
2
3

Â· 3 + 5 = 0

Â· 2 + 0 = âˆ’

Â· (âˆ’1) + 4 =

Â· 3 + 2 = 0

Â· 2 âˆ’ 3 = âˆ’

Â· (âˆ’1) + 1 =

10
3

17
3

13
3

5
3

A matriz passa a ser

â›

âœ
âœ
âœ
â

.

3
0 âˆ’ 10
3
0 âˆ’ 13
3

2 âˆ’1
17
3
5
3

â

âŸ
âŸ
âŸ
â 

Agora, a segunda linha serÃ¡ multiplicada por

13
3
âˆ’ 10
3
linha, substituindo os resultados na terceira linha. Logo:

= âˆ’ 13

10 e somada com a terceira

ğ‘32 = âˆ’

ğ‘33 = âˆ’

10
3
17
3

(ï¸‚

âˆ’

(ï¸‚

âˆ’

Â·

Â·

)ï¸‚

)ï¸‚

13
10
13
10

âˆ’

+

13
3
5
3

= 0

= âˆ’

57
10

Donde obtemos a matriz

â›

âœ
âœ
âœ
â

âˆ’1
17
3

2
3
0 âˆ’ 10
3
0 âˆ’ 57
0
10

â

âŸ
âŸ
âŸ
â 

.

A matriz acima Ã© triangular superior. Deste modo:

det ğ´ = 3 Â·

(ï¸‚

âˆ’

10
3

)ï¸‚

(ï¸‚

âˆ’

Â·

)ï¸‚

57
10

= 57

Para o Algoritmo 8, realizamos 10 multiplicaÃ§Ãµes, 8 adiÃ§Ãµes e 1 divisÃ£o, totalizando

19 operaÃ§Ãµes. Contando apenas o nÃºmero de multiplicaÃ§Ãµes, foram 10.

(cid:3)

60

CapÃ­tulo 3. Resultados

Agora chegou a vez de aplicar os algoritmos no cÃ¡lculo de determinantes de or-
dens superiores. Embora seja pouco comum a sua aplicaÃ§Ã£o em sala de aula do ensino
mÃ©dio, encontra-se nos livros didÃ¡ticos exercÃ­cios envolvendo o cÃ¡lculo de determinantes
de matrizes 4 Ã— 4. Vamos comparar o algoritmo por escalonamento com o algoritmo por
cofator. o exemplo 5 encontra-se no livro (PAIVA, 2010), com adaptaÃ§Ãµes.

Exemplo 5. Calcule o determinante da matriz

ğ´ =

â

â›
2 âˆ’1 0
1
âŸ
âœ
âŸ
âœ
2
4
1
0
âŸ
âœ
âŸ
âœ
âŸ
âœ
0 âˆ’3 âˆ’1 2
âŸ
âœ
â 
â
3
2

1

0

SoluÃ§Ã£o:

Vamos aplicar o Algoritmo 7. Escolhendo a primeira linha da matriz, temos que:

ğ‘€11 =

ğ‘€12 =

ğ‘€13 =

ğ‘€14 =

â›

âœ
âœ
âœ
â

0
4
1
âˆ’3 âˆ’1 2
3
1
0
â

âŸ
âŸ
âŸ
â 

â›
2
4
1
âœ
âœ
0 âˆ’1 2
âœ
â
3
1
2
â›
2
4
0
âœ
âœ
0 âˆ’3 2
âœ
â
3
0
2
â›
1
0
2
âœ
âœ
0 âˆ’3 âˆ’1
âœ
â
1
0
2

âŸ
âŸ
âŸ
â 

â

â

âŸ
âŸ
âŸ
â 

â

âŸ
âŸ
âŸ
â 

Para nÃ£o gerar confusÃ£o, vamos usar a letra N para denotar os determinantes
menores das matrizes acima. Em cada uma delas, escolheremos a primeira linha para a
determinaÃ§Ã£o dos menores e cofatores. No caso da matriz ğ‘€11, tem-se que:

ğ‘11 =

ğ‘12 =

ğ‘13 =

â›

â

âˆ’1 2
3
1

â›

â

âˆ’3 2
3
0

â

â 

â

â 

â›

â

âˆ’3 âˆ’1
1
0

â

â 

3.3. Algoritmos de Determinantes

61

Escolhendo agora a segunda linha para a determinaÃ§Ã£o dos menores e cofatores de

cada matriz, temos que:

det ğ‘11 = (âˆ’1)3 Â· 1 Â· 2 + (âˆ’1)4 Â· 3 Â· (âˆ’1) = âˆ’2 âˆ’ 3 = âˆ’5
det ğ‘12 = (âˆ’1)3 Â· 0 Â· 2 + (âˆ’1)4 Â· 3 Â· (âˆ’3) = âˆ’9
det ğ‘13 = (âˆ’1)3 Â· 0 Â· (âˆ’1) + (âˆ’1)4 Â· 1 Â· (âˆ’3) = âˆ’3

Deste modo, temos que:

det ğ‘€11 = (âˆ’1)2 Â· 0 Â· (âˆ’5) + (âˆ’1)3 Â· 1 Â· (âˆ’9) + (âˆ’1)4 Â· 4 Â· (âˆ’3) = 9 âˆ’ 12 = âˆ’3

Repetindo o procedimento acima para as outras matrizes, temos que:

det ğ‘€12 = 2

det ğ‘€13 = 6

det ğ‘€14 = 0

Portanto,

det ğ´ = (âˆ’1)2 Â· 1 Â· (âˆ’3) + (âˆ’1)3 Â· 2 Â· 2 + (âˆ’1)4 Â· (âˆ’1) Â· 6 + (âˆ’1)5 Â· 0 Â· 0 = âˆ’3 âˆ’ 4 âˆ’ 6 = âˆ’13

Utilizando o Algoritmo 7, realizamos 24 multiplicaÃ§Ãµes e 23 adiÃ§Ãµes, totalizando 47 ope-
raÃ§Ãµes. Se contarmos apenas o nÃºmero de multiplicaÃ§Ãµes, foram 24.

Pelo Algoritmo 8, o primeiro elemento da primeira linha Ã© nÃ£o nulo. Multiplicamos
para todo ğ‘–, com 2 â‰¤ ğ‘– â‰¤ 4, e somamos o resultado Ã  linha ğ‘–,

a primeira linha por âˆ’ ğ‘ğ‘–1
ğ‘11
substituindo-a pelos valores encontrados. Assim:

ğ‘21 = âˆ’2Â·1+2 = 0; ğ‘22 = âˆ’2Â·2+0 = âˆ’4; ğ‘23 = âˆ’2Â·(âˆ’1)+1 = 3; ğ‘24 = âˆ’2Â·0+4 = 4;

Repetindo o procedimento acima para as outras linhas, temos que a terceira linha

permanece inalterada, pois o primeiro elemento jÃ¡ Ã© nulo e:

ğ‘41 = 0; ğ‘42 = âˆ’4; ğ‘43 = 3; ğ‘44 = 3;

Assim, obtemos a matriz

ğ´1 =

â›
2 âˆ’1 0
1
âœ
âœ
0 âˆ’4
4
3
âœ
âœ
âœ
0 âˆ’3 âˆ’1 2
âœ
â
3
0 âˆ’4

3

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

A prÃ³xima iteraÃ§Ã£o do laÃ§o for multiplicarÃ¡ a segunda linha por âˆ’ 3

4, somando-a

com a terceira linha, substituindo os resultados na prÃ³pria linha 3. DaÃ­:

62

CapÃ­tulo 3. Resultados

ğ‘32 = âˆ’ 3

4 Â· (âˆ’4) âˆ’ 3 = 0; ğ‘33 = âˆ’ 3

4 Â· 3 âˆ’ 1 = âˆ’ 13
A operaÃ§Ã£o de multiplicar a segunda linha por âˆ’1 e somar com a quarta linha,

4 Â· 4 + 2 = âˆ’1;

4 ; ğ‘34 = âˆ’ 3

substituindo os valores na linha 4 resulta em:

ğ‘42 = 0; ğ‘43 = 0; ğ‘41 = âˆ’1;

Como consequÃªncia, obtemos a matriz

ğ´2 =

â›
1
âœ
âœ
0 âˆ’4
âœ
âœ
âœ
0
âœ
â
0

0
2 âˆ’1
3
4
0 âˆ’ 13
4 âˆ’1
0 âˆ’1
0

â

âŸ
âŸ
âŸ
âŸ
âŸ
âŸ
â 

A matriz ğ´2 Ã© uma matriz triangular superior. Seu determinante Ã© igual ao deter-

minante de ğ´. O algoritmo Ã© concluÃ­do com a multiplicaÃ§Ã£o

ğ‘‘ = 1 Â· (âˆ’4) Â·

)ï¸‚

(ï¸‚

âˆ’

13
4

Â· (âˆ’1) = âˆ’13

Aplicando o Algoritmo 8, realizamos 17 multiplicaÃ§Ãµes e 14 adiÃ§Ãµes, totalizando

31 operaÃ§Ãµes. Contando apenas as multiplicaÃ§Ãµes, foram 17.

(cid:3)

Para complementar a anÃ¡lise dos algoritmos, escrevemos um cÃ³digo em Python
para implementar os Algoritmos 7 e 8. O cÃ³digo sorteia aleatoriamente matrizes ğ‘› Ã— ğ‘›
com ğ‘› variando de 1 a 8. Para cada valor de ğ‘›, foram obtidas dez amostras de matrizes
formadas por nÃºmeros inteiros no intervalo [âˆ’10, 10]. O cÃ³digo contÃ©m tambÃ©m instruÃ§Ãµes
para a contagem do nÃºmero de multiplicaÃ§Ãµes realizadas pelo algoritmo, que retorna
um par ordenado (ğ‘¥, ğ‘¦), onde ğ‘¥ Ã© o determinante da matriz e ğ‘¦ Ã© o nÃºmero mÃ©dio de
multiplicaÃ§Ãµes realizadas. A Tabela 12 o nÃºmero mÃ©dio de multiplicaÃ§Ãµes realizadas por
cada algoritmo, com ğ‘› variando no intervalo [1, 8] com 10 amostras para cada ğ‘›.

Tabela 12 â€“ NÃºmero mÃ©dio de multiplicaÃ§Ãµes os Algoritmos 7 e 8

ğ‘› Algoritmo 7 Algoritmo 8

2
3
4
6
8

6
27
120
3.708
207.840

2
8
20
70
168

Os dados da Tabela 12 mostram, de forma contundente, que o Algoritmo 7 Ã© muito
mais eficiente que o Algoritmo 8. Por exemplo, para matrizes 6 Ã— 6, o nÃºmero mÃ©dio de

3.3. Algoritmos de Determinantes

63

Figura 3 â€“ Algoritmos de determinantes

multiplicaÃ§Ãµes realizadas pelo Algoritmo 7 no experimento realizado foi 3.708 contra 70
do Algoritmo 8.

A Figura 3 compara o desempenho dos Algoritmos 7 e 8. Os grÃ¡ficos mostram o
nÃºmero de multiplicaÃ§Ãµes realizadas em funÃ§Ã£o do tamanho da matriz no experimento
realizado em linguagem Python. Novamente, observamos que um dos grÃ¡ficos, no caso a
contagem de multiplicaÃ§Ãµes para o Algoritmo 8, Ã© praticamente uma reta horizontal. Isto
siginifica que a taxa de crescimento da quantidade de operaÃ§Ãµes realizadas pelo Algoritmo
8 e, consequentemente, do tempo de execuÃ§Ã£o, com relaÃ§Ã£o ao tamanho da matriz Ã© muito
pequeno, se comparado ao do Algoritmo 7, cujo grÃ¡fico tem um crescimento acentuado
para ğ‘› â‰¥ 6, ou seja, para ğ‘› suficientemente grande, o Algoritmo 8 faz menos operaÃ§Ãµes
que o Algoritmo 7.

4 ConsideraÃ§Ãµes Finais

65

Este trabalho buscou comparar, sob o ponto de vista da anÃ¡lise de complexidade
assintÃ³tica, os algoritmos disponÃ­veis para a soluÃ§Ã£o de trÃªs problemas tÃ­picos da ma-
temÃ¡tica escolar: o cÃ¡lculo de potenciaÃ§Ãµes com base e expoente naturais; o cÃ¡lculo do
mÃ¡ximo divisor comum de dois nÃºmeros naturais e o determinante de matrizes de ordem
ğ‘›. As anÃ¡lises dos algoritmos feitas nos CapÃ­tulos 2 e 3 revelaram que o Algoritmo para a
potenciaÃ§Ã£o por divisÃ£o e conquista Ã© mais eficiente que o Algoritmo por definiÃ§Ã£o, que o
Algoritmo para o mÃ¡ximo divisor comum de Euclides Ã© mais que eficiente que o Algoritmo
por decomposiÃ§Ã£o em fatores primos e que o Algoritmo para o cÃ¡lculo de determinantes
por escalonamento Ã© mais eficiente que o de cofatores. A pergunta de pesquisa que motivou
o trabalho foi: Os algoritmos ensinados no ensino mÃ©dio e fundamental para o cÃ¡lculo de
potenciaÃ§Ãµes, mÃ¡ximo divisor comum e determinantes sÃ£o computacionalmente eficientes?

ApÃ³s fazer uma anÃ¡lise dos livros didÃ¡ticos adotados nas escolas pÃºblicas das
regionais de ensino do Distrito Federal com maior nÃºmero de alunos, inferimos que sÃ£o
adotados os algoritmos menos eficientes para a soluÃ§Ã£o dos problemas escolhidos. Os livros
apresentam apenas o cÃ¡lculo de potenciaÃ§Ãµes por definiÃ§Ã£o e do mÃ¡ximo divisor comum
por decomposiÃ§Ã£o em fatores primos. Com relaÃ§Ã£o ao cÃ¡lculo de determinantes, os livros
de ensino mÃ©dio cobrem apenas as matrizes de tamanho 2 Ã— 2 ou 3 Ã— 3.

Isto nos leva a concluir que os algoritmos mais eficientes, como o da potenciaÃ§Ã£o
por divisÃ£o e conquista, o algoritmo de Euclides e o de determinantes por escalonamento,
sÃ£o deixados de lado no ensino destes temas na escola.

Acreditamos nÃ£o haver empecilho para apresentar tais algoritmos aos alunos. Su-
pondo que um aluno do 6o ano saiba efetuar as quatro operaÃ§Ãµes fundamentais, fazer
uma potenciaÃ§Ã£o agrupando os fatores aos pares nÃ£o representa nenhuma dificuldade ex-
tra. Por outro lado, o algoritmo de Euclides exige apenas que a pessoa saiba efetuar uma
divisÃ£o, registrando resto e quociente. O caso do cÃ¡lculo de determinantes Ã© mais emble-
mÃ¡tico. Ora, os alunos, no 2o ano do ensino mÃ©dio, jÃ¡ aprendem a fazer escalonamento
de sistemas. Por que nÃ£o aplicar o escalonamento para o cÃ¡lculo de determinantes?

NÃ£o queremos de forma alguma ampliar o conteÃºdo programÃ¡tico baseados apenas
em opiniÃµes pessoais. Queremos reforÃ§ar que nossa opiniÃ£o Ã© a de que se deve priorizar os
algoritmos mais eficientes. Isto nÃ£o impede a apresentaÃ§Ã£o dos conteÃºdos da forma como
o professor achar melhor. O conceito a ser apresentado Ã© uma coisa, o algoritmo escolhido
para efetuar um cÃ¡lculo, Ã© outra.

Em relaÃ§Ã£o aos aspectos didÃ¡ticos e pedagÃ³gicos relacionados a este trabalho, nÃ£o
fizemos uma pesquisa aprofundada sobre a temÃ¡tica, deixando em aberto para trabalhos

66

CapÃ­tulo 4. ConsideraÃ§Ãµes Finais

futuros. Sabemos que as estratÃ©gias de ensino muito influenciam o aprendizado dos alunos
e nÃ£o apenas o conteÃºdo. Portanto, embora tenhamos verificado quais algoritmos sÃ£o
mais eficientes para resolver os problemas abordados, Ã© necessÃ¡rio construir estratÃ©gias
adequadas para ensinÃ¡-los. Contudo, saber qual algoritmo Ã© mais eficiente muda o olhar
do professor para a questÃ£o, tornando importante a escolha dos mais eficientes.

Para finalizar, entendemos que Ã© importante dar um direcionamento para traba-
lhos futuros dentro do tema de pesquisa abordado neste trabalho. Uma possibilidade Ã©
fazer uma busca por mais algoritmos escolares que possam ser comparados com outros
utilizados para o mesmo fim. PoderÃ­amos, inclusive, estudar algoritmos tÃ­picos da mate-
mÃ¡tica superior, como os algoritmos numÃ©ricos para encontrar a raiz de um polinÃ´mio, por
exemplo. Uma outra possibilidade, esta bem mais difÃ­cil, Ã© tentar escrever um algoritmo
para o cÃ¡lculo de determinantes com complexidade inferior a ğ‘›3.

Outro aspecto importante a ressaltar Ã© a da possibilidade de se ensinar lÃ³gica
de programaÃ§Ã£o ainda na educaÃ§Ã£o bÃ¡sica. Para isso, podemos aproveitar fÃ³rmulas que
os alunos jÃ¡ utilizam, como a fÃ³rmula de BhÃ¡skara ou a regra de Sarrus, por exemplo,
para escrever programas simples que calculem as raÃ­zes reais de uma equaÃ§Ã£o do 2o grau
(quando existirem) e o determinante de uma matriz 3 Ã— 3 com entradas conhecidas ou
escrever, em pseudocÃ³digo, algoritmos para problemas contemplados no currÃ­culo. Este
trabalho pode servir como uma ponte para abordar essas ideias.

Esperamos que este trabalho tenha sido Ãºtil para dar um novo olhar para os algo-
ritmos que usamos comumente e para dar ao professor de matemÃ¡tica um embasamento
teÃ³rico para a escolha dos algoritmos a serem ensinados nos casos da potenciaÃ§Ã£o, mÃ¡ximo
divisor comum e determinantes.

ReferÃªncias

67

ANDRINI Ãlvaro; VASCONCELOS, M. J. Praticando MatemÃ¡tica. 4a. ed. SÃ£o Paulo:
Editora do Brasil, 2015. v. 6. Citado na pÃ¡gina 41.

BARROSO, J. M.; MATHEUS, A. dos R.; NANI, A. P. S. AraribÃ¡ MatemÃ¡tica. 3a. ed.
SÃ£o Paulo: Editora Moderna, 2010. v. 6. Citado na pÃ¡gina 53.

BIANCHINI, E. MatemÃ¡tica. 8a. ed. SÃ£o Paulo: Editora Moderna, 2016. v. 6. Citado na
pÃ¡gina 41.

CENTÃºRION, M.; JAKUBOVIC, J. MatemÃ¡tica na Medida Certa. 1a. ed. SÃ£o Paulo:
Editora Leya, 2015. v. 6. Citado na pÃ¡gina 41.

CHAVANTE, E. SÃ©rie ConvergÃªncias MatemÃ¡tica. 1a. ed. SÃ£o Paulo: Editora SM, 2016.
v. 6. Citado na pÃ¡gina 41.

CORMEN, T. H. et al. Algoritmos: teoria e prÃ¡tica. 3a. ed. SÃ£o Paulo: Editora Campus,
2012. Citado 2 vezes nas pÃ¡ginas 23 e 24.

DANTE, L. R. MatemÃ¡tica. 1a. ed. SÃ£o Paulo: Editora Ãtica, 2014. Citado na pÃ¡gina 57.

DANTE, L. R. MatemÃ¡tica contexto e aplicaÃ§Ãµes. 3a. ed. SÃ£o Paulo: Editora Ãtica, 2016.
v. 2. Citado na pÃ¡gina 42.

DANTE, L. R. Projeto TelÃ¡ris MatemÃ¡tica. 2a. ed. SÃ£o Paulo: Editora Ãtica, 2016. v. 6.
Citado na pÃ¡gina 41.

DROZDEK, A. Estrutura de dados e algoritmos em C++. 1a. ed. SÃ£o Paulo: CENGAGE
Learning, 2002. Citado na pÃ¡gina 25.

ESQUINCA, S. R. A. Algoritmos: resoluÃ§Ã£o de problemas bÃ¡sicos. DissertaÃ§Ã£o (Mestrado)
â€” Universidade Federal de Mato Grosso do Sul, 2014. Citado na pÃ¡gina 21.

FEDERAL, G. do D. Censo Escolar do DF. 2017. DisponÃ­vel em: <http://www.cre.se.df.
gov.br/ascom/documentos/censo/2017/2017_qd_pub_df_mat_ef_201_cre.pdf>. Ci-
tado na pÃ¡gina 39.

FEDERAL, G. do D. MatrÃ­culas no Ensino Fundamental. 2018. DisponÃ­vel em: <http:
//www.cre.se.df.gov.br/ascom/documentos/dados/2017/ii_d_escola.pdf>. Citado na
pÃ¡gina 40.

FEDERAL, G. do D. MatrÃ­culas no Ensino MÃ©dio. 2018. DisponÃ­vel em: <http://www.
cre.se.df.gov.br/ascom/documentos/dados/2017/ii_d_medio_escola.pdf>. Citado na
pÃ¡gina 40.

GONÃ§ALVES, A. IntroduÃ§Ã£o Ã  Ãlgebra. 5. ed. Rio de Janeiro: IMPA, 2006. Citado 2
vezes nas pÃ¡ginas 30 e 44.

HEFEZ Ãbramo. AritmÃ©tica. 1a. ed. Rio de Janeiro: Sociedade Brasileira MatemÃ¡tica,
2014. Citado na pÃ¡gina 45.

68

ReferÃªncias

IEZZI, G. et al. MatemÃ¡tica. 5a. ed. SÃ£o Paulo: Editora Atual, 2011. Citado na pÃ¡gina
56.

IEZZI, G. et al. MatemÃ¡tica: ciÃªncia e aplicaÃ§Ãµes. 9a. ed. SÃ£o Paulo: Editora Saraiva,
2016. v. 2. Citado na pÃ¡gina 42.

IMENES, L. M.; LELLIS, M. MatemÃ¡tica Imenes & Lellis. 2a. ed. SÃ£o Paulo: Editora
Moderna, 2012. v. 7. Citado na pÃ¡gina 51.

LEONARDO, F. M. de. ConexÃµes com a matemÃ¡tica. 3a. ed. SÃ£o Paulo: Editora Moderna,
2016. v. 2. Citado na pÃ¡gina 42.

LIMA, E. L. Analise Real. 9a. ed. Rio de Janeiro: IMPA, 2007. v. 1. Citado na pÃ¡gina
28.

LIMA, E. L. et al. A MatemÃ¡tica do Ensino MÃ©dio. 6a. ed. Rio de Janeiro: Sociedade
Brasileira de MatemÃ¡tica, 2006. v. 2. Citado na pÃ¡gina 50.

PAIVA, M. MatemÃ¡tica. 2a. ed. SÃ£o Paulo: Editora Moderna, 2010. v. 2. Citado na
pÃ¡gina 60.

SCHEINERMAN, E. R. MatemÃ¡tica Discreta. 2a. ed. SÃ£o Paulo: CENGAGE Learning,
2011. Citado na pÃ¡gina 46.

SILVEIRA ÃŠnio. MatemÃ¡tica: CompreensÃ£o e PrÃ¡tica. 3a. ed. SÃ£o Paulo: Editora Mo-
derna, 2016. v. 6. Citado na pÃ¡gina 41.

STRANG, G. Ãlgebra Linear e Suas AplicaÃ§Ãµes. 4a. ed. SÃ£o Paulo: CENGAGE Learning,
2010. Citado na pÃ¡gina 30.

ApÃªndices

APÃŠNDICE A â€“ Algoritmos dos
experimentos

71

No apÃªndice, mostramos os cÃ³digos escritos em linguagem Python para executar

os algoritmos do CapÃ­tulo 3.

A.1 PotenciaÃ§Ã£o

Segue abaixo os cÃ³digos em Python para os Algoritmos 1 e 2. Em cada um deles
foi definido um contador do nÃºmero de multiplicaÃ§Ãµes executadas. AlÃ©m disso, gerou-se,
de forma aleatÃ³ria, uma base fixa ğ‘ âˆˆ N no intervalo de 1 a 100 e uma amostra com 100
valores aleatÃ³rios para o expoente ğ‘› âˆˆ N nos intervalos [1, 10], [1, 100], [1, 1000] e [1,
10000]. Por fim, para cada intervalo, o programa retornou dois valores: o limite superior
do intervalo e o nÃºmero mÃ©dio de multiplicaÃ§Ãµes realizadas em cada amostra. Isto nos deu
uma base para confirmar as previsÃµes da funÃ§Ã£o de complexidade assintÃ³tica e tambÃ©m
para comparar os dois algoritmos.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

import random
# import matplotlib . pyplot as pl

def potenciacao (a , n , _ ) :

x = 1
mults = 0

for i in xrange ( n ) :

x = x * a
mults += 1

return (x , mults )

def potenciacao2 (a , n , mults ) :

if n == 1:

return (a , mults )

elif n % 2 == 0:

pot , m = potenciacao2 (a , n /2 , mults )
return ( pot * pot , m + mults + 1)

else :

pot , m = potenciacao2 (a , ( n - 1) /2 , mults )
return ( pot * pot * a , m + mults + 2)

72

APÃŠNDICE A. Algoritmos dos experimentos

25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69

limits = [10 , 100 , 1000 , 10000]
samples = 100
max_a = 1000

def exp ( f ) :
data = []

for limit in limits :

total = 0

for sample in xrange ( samples ) :
a = random . randint (1 , max_a )
n = random . randint (1 , limit )

_ , mults = f (a , n , 0)
total += mults

mean = 1.0* total / samples
data . append (( limit , mean ) )

return data

data1 = exp ( potenciacao )
data2 = exp ( potenciacao2 )

x1 = [ x for x , y in data1 ]
y1 = [ y for x , y in data1 ]

print data1
print x1
print y1

x2 = [ x for x , y in data2 ]
y2 = [ y for x , y in data2 ]

print data2
print x2
print y2

# pl . plot ( x1 , y1 )
# pl . plot ( x2 , y2 )
# pl . savefig ( â€™ teste . png â€™)
# pl . show ()

A.2. MÃ¡ximo Divisor Comum

73

A.2 MÃ¡ximo Divisor Comum

A seguir, apresentamos os cÃ³digos em Python para os Algoritmos 3 e 4. Em cada

um deles foi inserido um contador do nÃºmero de divisÃµes realizadas pelos algoritmos.

# !/ usr / bin / python
# -* - coding : utf -8 -* -
import sys
import math
import random
import matplotlib . pyplot as plt

def load_primes () :

with open ( â€™ primes . txt â€™) as f :

primes = [ int ( x ) for x in f . readlines () ]

return primes

def MDC (a , b , primes ) :

if b == 0:

return (a , 0)

else :

d , m = MDC (b , a % b , primes )
return (d , m + 1)

def MDC2 (a , b , primes ) :

d = 1
i = 0
total = 0

if a == 0:

return (b , 0)

if b == 0:

return (a , 0)

while i < len ( primes ) :

p = primes [ i ]

if p > a and p > b :
return (d , total )

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

74

APÃŠNDICE A. Algoritmos dos experimentos

44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80

81
82
83
84
85
86
87
88
89

ra = a % p
rb = b % p

total += 2

if ra == 0 and rb == 0:

a /= p
b /= p
d *= p
total += 2
elif ra == 0:

a /= p
total += 1
elif rb == 0:

b /= p
total += 1

else :

i += 1

return (d , total )

def experimento (f , g ) :

primes = load_primes ()
limits = [10 ** x for x in xrange (13) ]
samples = 100

data_f = []
res_f = []

data_g = []
res_g = []

for limit in limits :

inputs = [( random . randint (0 , limit ) , random . randint (0 , limit )

) for x in xrange ( samples ) ]

scenario = [( f , data_f , res_f ) , (g , data_g , res_g ) ]

for func , data , res in scenario :

total = 0

for a , b in inputs :

if a == 0 and b == 0:

a = 1

A.2. MÃ¡ximo Divisor Comum

75

90
91

92
93
94
95
96
97
98
99
100
101
102
103

104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122

123

124
125
126
127
128
129
130
131

#

print â€™ calculando mdc ({} ,{}) , funcao {} â€™. format (a , b ,

func )

d , divs = func (a , b , primes )
total += divs
res . append (( a , b , d ) )

mean = 1.0 * total / samples
data . append (( limit , mean ) )

for i in xrange ( len ( res_f ) ) :
if res_f [ i ] != res_g [ i ]:

a , b , d = res_f [ i ]
A , B , D = res_g [ i ]
print " Erro no calculo do MDC ! a = {} , b = {} , d = {} , A =

{} , B = {} , D = {} " . format (a , b , d , A , B , D )

sys . exit ( -1)

return ( data_f , data_g )

if __name__ == â€™ __main__ â€™:

data1 , data2 = experimento ( MDC , MDC2 )

x1 = [ math . log10 ( x ) for x , y in data1 ]
y1 = [ y for x , y in data1 ]

x2 = [ math . log10 ( x ) for x , y in data2 ]
y2 = [ y for x , y in data2 ]

print data1
print data2

euclides = plt . plot ( x1 , y1 , â€™ -- â€™ , label = u â€™ Pelo Algoritmo de

Euclides â€™)

decomposicao = plt . plot ( x2 , y2 , label = u â€™ Por decomposicao em

fatores primos â€™)

plt . xlabel ( â€™ Log ( a ) â€™ , fontsize =12)
plt . ylabel ( u â€™ Numero de divisoes â€™ , fontsize =12)
plt . legend ( bbox_to_anchor =(0.05 , 1) , loc =2 , borderaxespad =1.3)
axes = plt . gca ()
axes . set_xlim ([ -0.5 , 12.5])
axes . set_ylim ([ -1000 , 150000])
plt . savefig ( â€™ euclides2 . png â€™)
plt . show ()

76

APÃŠNDICE A. Algoritmos dos experimentos

A.3 Determinantes

Por fim, apresentamos os cÃ³digos em Python para os Algoritmos 7 e 8. Em cada
cÃ³digo foi inserido um contador do nÃºmero de multiplicaÃ§Ãµes realizadas pelos algoritmos.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

# !/ usr / bin / python
# -* - coding : utf -8 -* -
import sys
import math
import random
import numpy as np
import matplotlib . pyplot as pl

def random_matrix (n , limit = 10) :

A = np . zeros (( n , n ) )

for x in xrange ( n ) :

for y in xrange ( n ) :

A [ x ][ y ] = random . randint ( - limit , limit )

return A

def cofatores ( A ) :

if A . size == 1:

# Matriz 1 x 1

return ( A [0][0] , 0)

else :

n , _ = A . shape

i = 0

# Linha 0

det = 0
mults = 0

for j in xrange ( n ) :

B = np . zeros (( n - 1 , n - 1) )

s = 0
r = 0

for x in xrange ( n ) :

if x == i :
continue

A.3. Determinantes

77

44
45
46
47
48
49
50
51
52

53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89

for y in xrange (0 , n ) :

if y == j :
continue

# print â€™B = â€™ , B
# print â€™A = â€™ , A
# print â€™i = {} , j = {} , Copiando elemento A [{}][{}]

para B [{}][{}] â€™. format (i , j , x , y , s , r )

B [ s ][ r ] = A [ x ][ y ]
r += 1

s += 1
r = 0

d , m = cofatores ( B )
mults += m
det += (1 - 2 * (( i + j ) % 2) ) * A [ i ][ j ] * d
mults += 3

return ( det , mults )

def gauss ( A ) :

n , _ = A . shape
total = 0

for x in xrange ( n ) :

pivot = -1
k = x

while k < n and pivot == -1:

if A [ k ][ x ] != 0:

pivot = k
break

else :

k += 1

if pivot == -1:

return (0 , total )

if pivot != x :

for y in xrange (x , n ) :

78

APÃŠNDICE A. Algoritmos dos experimentos

90
91
92
93
94

95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135

A [ x ][ y ] , A [ pivot ][ y ] = A [ pivot ][ y ] , A [ x ][ y ]

for z in xrange ( x + 1 , n ) :

for y in xrange ( n - 1 , x - 1 , -1) :

# print â€™ Atualizando A [{}][{}] a partir de A [{}][{}] , pivo

A [{}][{}] â€™. format (z , y , x , y , x , x )

A [ z ][ y ] -= ( A [ x ][ y ] * A [ z ][ x ]) / A [ x ][ x ]
total += 1

det = 1

for x in xrange ( n ) :
det *= A [ x ][ x ]

# print â€™U = â€™ , A
return ( round ( det ) , total )

def experimento (f , g ) :

limits = range (1 , 9)
samples = 10

data_f = []
res_f = []

data_g = []
res_g = []

for limit in limits :

inputs = [ random_matrix ( limit ) for x in xrange ( samples ) ]
scenario = [( f , data_f , res_f ) , (g , data_g , res_g ) ]

for func , data , res in scenario :

total = 0

for A in inputs :

det , mults = func ( A )
total += mults
res . append (( det , A ) )

mean = 1.0 * total / samples
data . append (( limit , mean ) )

# for i in xrange ( len ( res_f ) ) :
if res_f [ i ] != res_g [ i ]:
#

A.3. Determinantes

79

136
137
138

139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168

#
#
#

#

d , A = res_f [ i ]
c , B = res_g [ i ]
print " Erro no calculo do determinante ! d = {} , A = {} , c

= {} , B = {}". format (d , A , c , B )

sys . exit ( -1)

return ( data_f , data_g )

if __name__ == â€™ __main__ â€™:

random . seed (1)

data1 , data2 = experimento ( cofatores , gauss )

x1 = [ x for x , y in data1 ]
y1 = [ y for x , y in data1 ]

x2 = [ x for x , y in data2 ]
y2 = [ y for x , y in data2 ]

print data1
print data2

cofatores = pl . plot ( x1 , y1 , â€™ -- â€™ , label = â€™ Por cofatores â€™)
escalonamento = pl . plot ( x2 , y2 , label = â€™ Por escalonamento â€™)
pl . xlabel ( u â€™ Dimensao da matriz â€™ , fontsize =14)
pl . ylabel ( u â€™ Numero de multiplicacoes â€™ , fontsize =14)
pl . legend ( bbox_to_anchor =(0.05 , 1) , loc =2 , borderaxespad =1.5)
axes = pl . gca ()
axes . set_xlim ([0 , 8.5])
axes . set_ylim ([ -2000 , 200000])
pl . savefig ( â€™ matrizes . png â€™)
pl . show ()

