         Mestrado Profissional em Matemática em Rede Nacional                   PROFMAT                      DISSERTAÇÃO DE MESTRADO                 O Estudo da Criptografia RSA no Ensino Básico               com Auxílio de Softwares Computacionais                  Marcel Cavalcante Cerqueira                            Maceió, Abril de 2016 UNIVERSIDADE FEDERAL DE ALAGOAS
INSTITUTO DE MATEMÁTICA
MESTRADO PROFISSIONAL EM MATEMÁTICA EM REDE NACIONAL

MARCEL CAVALCANTE CERQUEIRA

O Estudo da Criptograﬁa RSA no Ensino
Básico com Auxílio de Softwares
Computacionais

Maceió
2016

MARCEL CAVALCANTE CERQUEIRA

O Estudo da Criptograﬁa RSA no Ensino Básico com Auxílio
de Softwares Computacionais

Dissertação de Mestrado apresentada ao Mes-
trado Proﬁssional em Matemática em Rede Na-
cional do Instituto de Matemática da Universi-
dade Federal de Alagoas como requisito parcial
para obtenção do grau de Mestre em Matemá-
tica.

Orientador: Prof. Dr. Fernando Pereira Micena

Maceió
2016

                                                                                                                                                                Catalogação na fonte Universidade Federal de Alagoas Biblioteca Central Divisão de Tratamento Técnico Bibliotecária Responsável: Helena Cristina Pimentel do Vale                         C416e      Cerqueira, Marcel Cavalcante.                                     O estudo da criptografia RSA no ensino básico com auxilio de softwares                                 computacionais / Marcel Cavalcante  Cerqueira. – 2016.                                     61f. ; il.                                                                     Orientador: Fernando Pereira Micena.                                     Dissertação (Mestrado Profissional em Matemática) – Universidade Federal                                 de  Alagoas. Instituto de Matemática. Programa de Pós Graduação de Mestrado                                 Profissional em Matemática em Rede Nacional, 2016.                                                                                     Bibliografia: f. 61.                                                                                                                                                                                                                                                                                   1. Matemática – Estudo ensino. 2. Criptografia RSA. 3. Matemática – Ensino                                 auxiliado por computador. . I. Título.                                                                                                                                                                                                                                                                                                                                                                                                                    CDU: 51:371.315    Ao meu orientador, prof. Dr. Fernando Micena,
aos meus pais, irmãos, esposa, ﬁlha e amigos.

AGRADECIMENTOS

À Deus, por ser o autor principal das páginas da minha vida e presente em todos os mo-

mentos de angústia, alegria e evidentemente pela sua divina providência.

À minha mãe, ﬁnada durante esta caminhada.
À minha ﬁlha, nascida durante esta caminhada.
À minha esposa, pelo amor.
Aos meus familiares a homenagem da mais profunda gratidão pelo apoio e renúncia, im-
prescindível nos momentos valorosos e especiais. Por terem incentivado a não desistirmos e a
prosseguirmos na certeza da realização deste grande sonho.

Aos amigos Profmat, principalmente André Carlos e Aldo, pela contribuição na colobora-

ção e socialização do aprendizado.

Aos professores e a Instituição porque foram, são e serão marcos signiﬁcativos de referên-

cia.

À CAPES e ao Profmat.

Eu Acredito, que ás vezes são as pessoas que ninguém espera nada que
fazem as coisas que ninguém consegue imaginar.
—ALAN TURING

RESUMO

O objetivo deste trabalho é apresentar uma proposta didática para o ensino da criptograﬁa RSA
no ensino básico com o auxílio de softwares computacionais como o GeoGebra, o Python,
e software online. Para que a proposta se concretize com sucesso é preciso trabalhar alguns
conceitos elementares da aritmética e do uso de tais softwares no ensino deste tema.

Palavras-chave: Criptograﬁa RSA. Aritmética modular. GeoGebra. Python.

ABSTRACT

The goal of this work is to present a didactic proposal for the teaching of RSA encryption in
basic education with the help of computer softwares GeoGebra, Python, and online software.
So the proposal is successfully materialize it takes work some basic concepts of arithmetic and
software use of the softwares in teaching of this subject.

Keywords: RSA encryption . Modular arithmetic. GeoGebra. Python.

SUMÁRIO

1

INTRODUÇÃO

11

.

.
.

.
.

.
.

.
.

.
.

2.2.1 Algoritmo de Euclides

CONCEITOS PRELIMINARES
2
2.1
.
. .
Introdução .
2.2 Divisão Euclidiana .

12
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
. . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Teorema fundamental da aritmética . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.3.1 Teorema da Fatoração Única . . . . . . . . . . . . . . . . . . . . . . . 15
. . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.2 O crivo de Eratóstenes
2.4 A inﬁnitude dos números primos . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4.1 A demonstração de Euclides . . . . . . . . . . . . . . . . . . . . . . . 18
2.4.2 A demonstração de Thue . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.4.3 A demonstração de Euler . . . . . . . . . . . . . . . . . . . . . . . . . 19
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
Princípio da Indução Matemática . . . . . . . . . . . . . . . . . . . . . 20

Princípio da indução ﬁnita .

2.5.1

2.5

.

.

.

3
3.1
.
3.2 Aritmética dos restos .
3.3 Congruência Linear .
.
3.4
3.5 Teorema de Euler .

.
.
.
Pequeno Teorema de Fermat
.

ARITMÉTICA MODULAR
.
. .
Introdução .
.
.
.
.
3.5.1 A função φ de Euler

.
.
.

.
.
.

.

.

.

.

21
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
. . . . . . . . . . . . . . . . . . . . . . . . . . . 26

.
.
.

.
.
.

.
.
.

.
.
.

4
. .
4.1
4.2 Criptograﬁa .
.
.
4.3 Criptograﬁa RSA .

CRIPTOGRAFIA RSA
.
Introdução . .
.
.
.

30
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
.
4.3.1 A ideia por trás do RSA . . . . . . . . . . . . . . . . . . . . . . . . . . 32
4.3.2 Assinando uma mensagem . . . . . . . . . . . . . . . . . . . . . . . . 35
4.3.3 Transmitindo uma mensagem assinada . . . . . . . . . . . . . . . . . . 36
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.3.4 Aplicações
. . . . . . . . . . . . . . . . . . . . . . . 37
4.3.5 Construindo primos grandes

.

.

.

9

5

5.1
5.2 O GeoGebra

. .
.
.

O USO DE SOFTWARES COMPUTACIONAIS NO ESTUDO DA CRIPTO-
GRAFIA
.
Introdução . .
.
.
5.2.1 Cifra de Cesar .
.
.

38
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
.
5.3.1
Fatorar um número com o Python . . . . . . . . . . . . . . . . . . . . 44
5.3.2 Calculadora com o Python . . . . . . . . . . . . . . . . . . . . . . . . 46

.
.
.
.

.
.

.
.

.
.

.

.

.

.

.

.

5.3 O Python .

. .

6
6.1
6.2
6.3 Momento 1 .
6.4 Momento 2 .
6.5 Momento 3 .
6.6 Momento 4 .
6.7 Momento 5 .

MOMENTOS DE APRENDIZAGENS
Introdução . .
.
.
Proposta Pedagógica .
.
.
.
.
.

47
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

7

CONSIDERAÇÕES FINAIS

60

1.

INTRODUÇÃO

Este trabalho foi motivado em minha prática de ensino da matemática ao perceber que muitos
estudantes concluiam o ensino básico sem conseguir resolver algumas propriedades aritméticas
básicas. Juntamente com uma necessidade pessoal, de conhecer sobre o tema criptograﬁa,
nascida com a perda de arquivos pessoais, pelo roubo de meu notebook . Daí veio a ideia
de criar uma proposta didática que propicie a percepção de que os conteúdos de criptograﬁa,
aritmética básica (como a divisão euclidiana) e conceitos aritméticos mais soﬁsticados (como a
aritmética modular). E com o uso de software, fazer com que os alunos tenham um aprendizado
sobre o tema.

Tais temas são de suma importância para o desenvolvimento de um cidadão, assim como
retrata os parâmetros curriculares nacionais na disciplina de matemática: à medida que vamos
nos integrando ao que se denomina uma sociedade da informação crescentemente globalizada,
é importante que a Educação se volte para o desenvolvimento das capacidades de comunica-
ção, de resolver problemas, de tomar decisões, de fazer inferências, de criar, de aperfeiçoar
conhecimentos e valores, de trabalhar cooperativamente.

Como fazer para que essa fragmentação do conhecimento seja superada? Como o uso da

tecnologia computacional pode ser útil para essa ﬁnalidade?

A estruturação deste trabalho se encontra do seguinte modo. No Capítulo 1, intitulado Con-
ceitos Preliminares, apresentamos uma síntese de alguns conceitos inerentes a aritmética. No
Capítulo 2, intitulado Aritmética Modular, apresentamos os conceitos da aritmética modular.
No Capítulo 3, Criptograﬁa RSA, introduzimos os conceitos básicos de criptograﬁa e cons-
truimos a criptograﬁa RSA. No Capítulo 4, O uso de softwares computacionais no ensino de
criptograﬁa, mostramos alguns caminhos do uso dos softwares GeoGebra e Python, sobretudo
no ensino da criptograﬁa. No Capitulo 5, Momentos de Aprendizagens, temos uma proposta
para implementação em sala de aula que leva ao aluno entender a criptograﬁa RSA com o uso
de softwares.

2. CONCEITOS PRELIMINARES

2.1.

Introdução

Apresentaremos algumas noções sobre números primos e fatorações, destacamos o algo-
ritmo de Euclides e o teorema da fatoração única. Em seguida, a inﬁnitude dos números primos,
e o princípio da indução ﬁnita.

2.2. Divisão Euclidiana

Teorema 2.2.1 (Divisão Euclidiana). Sejam a e b dois números inteiros positivos com 0 < b <
a. Existem dois únicos inteiros positivos q e r tais que

Demonstração. Suponha que b > a e considere, enquanto ﬁzer sentido, os números

a = bq + r, com r < b.

a, a − b, a − 2b, ..., a − nb, ...

O conjunto S formado pelos elementos acima tem um menor elemento r = a − qb. Vamos

provar que r < b.

Se b | a, então r = 0 e nada mais temos a provar. Se, por outro lado, b (cid:45) a, então r (cid:54)= b,
e, portanto, basta mostrar que não pode ocorrer r > b. De fato, se isto ocorresse, existiria um
inteiro positivo c < r tal que r = c + b. Consequentemente, sendo r = c + b = a − qb, teríamos

c = a − (q + 1)b ∈ S, com c < r,

contradição com o fato de r ser o menor elemento de S.

Portanto, temos que a = bq + r com r < b, o que prova a existência de q e r.
Agora, vamos provar a unicidade. Note que, dados dois elementos distintos de S, a diferença
entre o maior e o menor deses elementos, sendo um múltiplo de b, é pelo menos b. Logo, se
r = a − bq e r(cid:48) = a − bq(cid:48), com r < r(cid:48) < b, teríamos r(cid:48) − r ≥ b, o que acarretaria r(cid:48) ≥ r + b ≥ b,
absurdo. Portanto, r = r(cid:48).

Daí segue-se que a − bq = a − bq(cid:48), o que implica que bq = bq(cid:48) e, portanto, q = q(cid:48).

Deﬁnição 2.2.1. Diremos que o número natural d, não nulo, é um máximo divisor comum
(mdc) dos números naturais a e b se possuir as seguintes propriedades:

i) d é um divisor comum de a e de b, e

ii) d é divisível por todo divisor comum de a e b.

O algoritmo de Euclides permite-nos encontrar o mdc, (a, b), de dois inteiros a e b. Os

detalhes deste algoritmo serão discutidos na proposição seguinte.

12

13

2.2.1 Algoritmo de Euclides

Proposição 2.2.1. Sejam a e b dois inteiros positivos com a ≥ b e seja {ri} a sequencia de
inteiros construídos da seguinte maneira: divida a por b; chamamos de q1 o quociente desta
divisão e r1 seu resto, de forma que

Da mesma maneira, dividimos b por r1, levando-nos a

a = bq1 + r1, 0 ≤ r1 < b.

b = r1q2 + r2, 0 ≤ r2 < r1.

Iteramos de forma que

ri−1 = riqi+1 + ri+1, 0 ≤ ri+1 < ri.
A sequência {ri} é estritamente decrescente. Portanto, deve haver um natural n tal que rn+1 = 0.
Segue que rn = (a, b).

Demonstração. Começamos mostrando que rn | a e rn | b. Como rn+1 = 0, a última equação
pode ser escrita como rn−1 = qn+1rn. Logo, rn | rn−1. A penúltima equação é rn−2 = qnrn−1 +
rn. Como rn | rn−1, segue que rn | qnrn−1 + rn. Logo, rn | rn−2. Iteramos pelas equações uma a
uma, obtendo que rn | ri para todo i. Assim, rn | q2r1 + r2 = b. Finalmente, como rn | b e rn | r1,
temos que rn | bq1 + r1 = a. Portanto, rn | a e rn | b, o que implica imediatamente que rn | (a, b).
Seja d um divisor de a e b. Devemos mostrar que d divide rn. Agora, a iteração pelo sistema
será para baixo. Como d | a e d | b, então d | r1 = a − bq1. Na segunda equação, temos que d | b
e d | r1; logo, d | r2 = b − r1q2. Iterações mostram que d | ri para todo i. Em particular, d | rn.

Podemos concluir que rn = (a, b).

Corolário 2.2.1. Sejam a e b inteiros e seja c = (a, b). Existem x, y ∈ Z tais que c = ax + by.

Demonstração. Nossa demonstração faz uso da proposição logo acima. Sabemos que c = rn.
Novamente iteramos para cima pelas equações. Como rn−2 = qnrn−1 + rn,

Substituindo rn−1 = rn−3 − qn−1rn−2, (2.1) torna-se

rn = rn−2 − qnrn−1.

(2.1)

rn = rn−2(1 + qn−1qn)) − qnrn−3.
Agora, substituímos rn−2 = rn−4 − qn−2rn−3. Continuando essas substituições iteradas, somos
levados a rn = r1x1 + r2y1, com x1, y1 ∈ Z. Substituímos r2 = b − r1q2, levando-nos a

(2.2)

Finalmente, substituímos r1 = a − bq1, obtemos o resultado ﬁnal

rn = r1(x1 − q2y1) + by1.

rn = a(x1 − q2y1) + b(−q1x1 + q1q2y1 + y1) = ax + by,

onde x = x1 − q2y1 e y = −q1x1 + q1q2y1 + y1.

14

2.3. Teorema fundamental da aritmética

Deﬁnição 2.3.1 (Número Primo). Um número inteiro n (n > 1) possuindo somente dois divi-
sores positivos n e 1 é chamado de número primo.

Se n > 1 não é primo será chamado composto, assim, sendo n um número composto, existirá

um divisor n1 de n tal que n1 (cid:54)= 1 e n1 (cid:54)= n. Portanto, existirá um número inteiro n2 tal que

n = n1n2, com 1 < n1 < n e 1 < n2 < n

.

Por exemplo, 2, 3, 5, 7, 11 e 13 são primos, enquanto que 4, 6, 8, 9, 10 e 12 são compostos.
O lema abaixo será usado na demonstração de uma propriedade chamada propriedade fun-
damental dos números primos e para a sua demonstração nos basearemos na divisão euclidiana
estendida.

Lema 2.3.1. Sejam a, b e c inteiros positivos e suponhamos que a e b são primos entre si.

(1) Se b divide o produto ac então b divide c.

(2) Se a e b dividem c então o produto ab divide c.

Demonstração.

(1) Temos por hipótese que a e b são primos entre si; isto é, que o mdc(a, b) = 1. O algoritmo

euclidiano estendido nos garante que existem inteiros α e β tais que

multiplicando esta equação por c

α.a + β .b = 1.

α.a.c + β .b.c = c.

(2.3)

É evidente que a segunda parcela da soma de 2.3 é divisível por b. Mas a primeira também
é divisível por b pela hipótese inicial. Portanto, c é divisível por b, como queríamos
mostrar.

(2) A segunda aﬁrmação pode ser provada a partir da primeira. De fato, se a divide c, pode-
mos escrever c = at, para algum t. Mas b também divide c. Como a e b são primos entre
si, segue da aﬁrmação (1) que b dividir t. Assim teremos que t = bk, para algum inteiro
k. Portanto

é divisível por ab, assim mostramos a aﬁrmação (2).

c = at = a(bk) = (ab)k

Existem muitas oportunidades de usar as duas partes desse lema, começando pela demons-
tração de uma propriedade importante dos números primos. Já conhecida pelos gregos antigos,
esta propriedade aparece como a Proporção 30 do livro VII dos Elementos de Euclides.

15

Proposição 2.3.1 (Propriedade Fundamental dos Números Primos). Seja p um número primo
e a e b inteiros positivos. Se p divide o produto ab então p divide a ou p divide b.

Demonstração. Para provar isto usaremos o Lema 2.3.1. Se p dividir a, está demonstrado.
Digamos, então, que p não divide a. Neste ponto usaremos o fato de que p é primo, para
concluir que se p não divide a então p e a são primos entre si. Isto ocorre porque qualquer
divisor comum a p e a divide p; mas os únicos divisores de p é 1 e p. Portanto, se p não divide
a, então mdc(a, p) = 1. Daí podemos aplicar o lema: como p e a são primos entre si e como p
divide ab temos que p divide b.

2.3.1 Teorema da Fatoração Única

Teorema 2.3.1 (Teorema Fundamental da Aritmética). Dado um inteiro positivo n ≥ 2 pode-
mos sempre escrevê-lo, de modo único, na forma

onde 1 < p1 < p2 < p3 < ... < pk são número primos e e1, ..., ek são inteiros positivos.

n = pe1

1 ...pek
k ,

Os expoentes e1, ..., ek no teorema são chamados de multiplicidades. Assim a multiplicidade
de p1 na fatoração de n é e1. Em outras palavras, a multiplicidade de p1 é o maior expoente
e1 tal que pe1
1 divide n. Observe também que n tem k fatores primos distintos, mas que a
quantidade total de fatores primos (distintos ou não) é a soma das multiplicidades e1 + ... + ek.

Demonstração. Vamos dividir a demonstração em duas partes: a parte (i) com o objetivo de
mostrar a existência da fatoração e a parte (ii) para mostrar que esta tal fatoração é única.

Parte (i):

Temos nesta primeira parte que, dado um inteiro n ≥ 2, podemos escrevê-lo como produto
de primos. A melhor maneira de fazer isto é explicando um algoritmo que, tendo por entrada
n, determina seus fatores primos e respectivos expoentes.

Começaremos descrevendo um algoritmo mais simples, para determinar apenas um fator
de um inteiro dado. Dado n inteiro, tentemos dividir n por cada um dos inteiros de 2 a n − 1.
Se algum destes inteiros dividir n, então achamos um fator de n. E mais, o menor fator que
acharmos desta maneira tem que ser primo.

Vejamos porque esta última aﬁrmação é verdadeira. Seja f um inteiro tal que 2 ≤ f ≤ n − 1.
Suponhamos que f é o menor fator de n e que f (cid:48) é um fator (maior que 1) de f . Pela deﬁnição
de divisibilidade, existem inteiros a e b tais que

n = f .a e

f = f (cid:48).b.

Logo n = f (cid:48).ab. Portanto f (cid:48) também é fator de n. Como estamos supondo que f é o menor
fator de n, concluímos que f ≤ f (cid:48). Por outro lado, f (cid:48) é fator de f , o que só pode acontecer se
f (cid:48) ≤ f . Das duas desigualdades segue que f = f (cid:48). Sendo assim, o único fator de f maior que
1 é o próprio f . Logo f é primo, que é a aﬁrmação original.

16

Há ainda uma outra observação que precisamos fazer antes de descrever o algoritmo em
detalhes. Pelo que vimos o algoritmo consiste em fazer uma busca, começando de 2, para achar
um fator de n. Evidentemente nossa busca não vai ultrapassar de n − 1 passos: um número
inteiro não pode ter um fator maior que ele próprio. Na verdade, não precisamos procurar
n. Lembre-se que o algoritmo que estamos descrevendo determina o
fatores maiores que
menor fator de n maior que 1. Portanto basta veriﬁcar que o menor fator de n, maior que 1,
n. Mas cuidado: há um caso em que isto é falso: Se n é primo,
é sempre menor ou igual a
então seu menor fator maior que 1 é o próprio n. Portanto o que temos que veriﬁcar é que se n
é composto e se f > 1 é seu menor fator então f ≤

√

√

√

n.

Seja, portanto, n um número composto e f > 1 seu menor fator. Então, existe um inteiro
positivo a tal que n = f .a . Como f é o menor fator, certamente f ≤ a. Mas a = n/ f , logo
f ≤ n/ f . Disto segue que f 2 ≤ n, que é equivalente a f ≤

n, como queríamos mostrar.

√

Resumindo o que vimos até agora: o algoritmo deve buscar um número que divida n, co-
n. Se n for composto, vamos encontrar o menor fator de n por
meçando de 2 e avançando até
este método, e este fator é necessariamente primo. Se nenhum dos números pesquisados é fator
de n, isto signiﬁca que n é primo. Vamos ao algoritmo:

√

Algoritmo de fatoração
Entrada: inteiro positivo n.
Saída: inteiro positivo f que é o menor fator primo de n ou uma mensagem indicando que n é
primo.

Etapa 1: comece fazendo f = 2.
Etapa 2: se n
Etapa 3: incremente f de uma unidade e vá para Etapa 4.
Etapa 4: se f >

√

n escreva n é primo e pare; senão volte à Etapa 2.

f é inteiro escreva “ f é fator de n” e pare; senão vá para Etapa 3.

Dado um inteiro n > 0, temos assim uma maneira de determinar se n é primo e, se não for,
achar um fator de n. Caso n seja primo, já achamos a sua fatoração. Mas se n for composto,
queremos achar todos os seus fatores primos e respectivas multiplicidades. Para isto basta
aplicar o algoritmo várias vezes.

Digamos que, aplicando o algoritmo a n achamos o fator q1. Então q1 é o menor fator
primo de n. A seguir aplicando o algoritmo ao co-fator n
, determinando assim um segundo
q1
fator primo de n, que vamos chamar de q2. É claro que q1 ≤ q2, mas pode acontecer que sejam
iguais, basta que q2
1 divida n. Continuando, aplicamos o algoritmo ao co-fator
e assim por
diante. Com isso determinamos uma sequência não decrescente de números primos

n
q1q2

cada uma dos quais é fator de n. A esta sequência corresponde uma outra, formada pelos

co-fatores,

q1 ≤ q2 ≤ q3 ≤ ... ≤ qs

n >

n
q1

>

n
q1q2

>

n
q1q2q3

> ... > 0.

Observe que esta última é uma sequência estritamente decrescente de números inteiros po-
sitivos. Como há apenas n inteiros entre n e 0, o algoritmo tem que parar depois de no máximo

17

n laços. O que pode-se veriﬁcar é que o menor elemento da sequência de co-fatores é sempre
1. Para poder escrever a fatoração na forma do enunciado do teorema, basta contar quantos
fatores primos iguais ocorrem entre os q(cid:48)s. Isto nos permitirá determinar as multiplicidades dos
diversos fatores primos.

Parte (ii):

Tendo mostrado a existência da fatoração, é chegada a hora de mostrar que esta fatoração
é única. Suponhamos que existe algum inteiro que admite mais de uma fatoração na forma
estabelecida no teorema, mostraremos que esta é única. Vamos chamar de n um inteiro positivo
entre aqueles que têm duas fatorações distintas. Podemos escrever

(2.4)

n = pe1

k = qr1
onde p1 < ... < pk e q1 < ... < qs são primos e e1, e2, ..., ek, r1, ..., rs são inteiros positi-
vos. Mas estamos supondo que estas fatorações são diferentes. Isto pode acontecer por duas
razões. Os primos da fatoração à direita podem não ser os mesmos da esquerda; ou, se forem
os mesmos, podem ter multiplicidades diferentes.

1 ...qrs
s

1 ...pek

De acordo com a fatoração da esquerda, p1 é um primo que divide n. Mas n = qr1
1 ...qrs
s ,
segundo a fatoração a direita. A propriedade fundamental dos primos nos garante então que p1
deve dividir um dos fatores do produto à direita. Isto signiﬁca, em última análise, que p1 divide
um dos primos da fatoração da direita. Mas um primo só pode dividir outro se forem iguais.
Logo p1 tem que ser um dos primos q1, q2, ... ou qk. Suponhamos sem perda de generalidade,
que p1 = q1. Fazendo interativamente tal processo, chegamos a

p1 = q1, p2 = q2, ..., pk = qk onde k ≤ s

Por outro lado, fazendo-se o mesmo, partindo-se da fatoração a direita, obtemos

q1 = p1, q2 = p2, ..., qS = pS onde s ≤ k

Logo temos k = s.

Agora, basta mostramos que coincidem as multiplicidades, isto é, ei = ri, onde i = 1, 2, ..., k.
Suponhamos sem perda de generalidade, que pi = qi onde i = 1, 2, ..., k. Como pe1
1 divide
n e mdc(pr1
1 divide pr1
1 , logo e1 menor ou igual a r1, analoga-
mente r1 menor ou igual a e1, portanto e1 = r1. Da mesma forma para os demais fatores,
e2 = r2, ...., ek = rk (ei = ri, i = 1, ..., k).

k ) = 1, segue que pe1

2 ...prk

1 ,pr2

2.3.2 O crivo de Eratóstenes

Como já dito, é possível veriﬁcar se um inteiro N é primo tentando-se simplesmente dividi-

lo por todos os números n tais que n2 ≤ N.

Eratóstenes, no século III a.E.C., teve a ideia de organizar os cálculos sob a forma do
crivo bem conhecido, que leva o seu nome. O crivo serve para determinar todos os números
primos e também os fatores primos dos números compostos inferiores a um número N dado
arbitrariamente.

18

Vamos ilustrar o processo tomando como exemplo N = 101.
Opera-se da maneira seguinte: escrevem-se todos os inteiros até 101; riscam-se todos os
múltiplos de 2, superiores a 2; em cada nova etapa, são riscados todos os múltiplos do menor
inteiro p ainda não riscado e que são maiores do que p. Basta chegar-se ao número p tal que
p2 já ultrapassa 101.

Figura 2.1 Números primos

Fonte: Autor (2015)

Assim, todos os múltiplos de 2, 3, 5, 7 <

√

101 são cortados. O número 53 é primo porque

não foi riscado. Então, os números primos não superiores a 101 são:

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 e 101.

O processo constitui a base da teoria do crivo, que foi desenvolvida com o objetivo de

fornecer estimativas da quantidade de números primos satisfazendo dadas condições.

2.4. A inﬁnitude dos números primos

Uma pergunta natural que pode ser feita é quantos números primos existem? Da qual a

resposta é: “Existe uma inﬁnidade de números primos".

Daremos três demonstrações para esta aﬁrmação, no entanto, existem muitas outras como

podemos ver em [RIBENBOIM, 2012].

2.4.1 A demonstração de Euclides

Demonstração. Suponhamos que a sucessão p1 = 2, p2 = 3, ..., pr dos r números primos seja
ﬁnita. Façamos P = p1.p2...pr + 1 e seja p um número primo que divide P. Esse número p não

pode ser igual a qualquer um dos números p1, p2, ...pr porque então ele dividiria a diferença
P − p1.p2...pr = 1, o que é impossível. Assim p é um número primo que não pertence à
sucessão e, por consequência, p1, p2, ..., pr não pode formar o conjunto de todos os números
primos.

19

Demonstração. Suponha que existam ﬁnitos primos

2.4.2 A demonstração de Thue

Sabendo-se que

p1 = 2 < ... < pr.

2n → ∞ para n → ∞ e

2n

(n + 1)r → ∞ para n → ∞,

considere n ≥ 1 tal que

2n > pr

e

(n + 1)r < 2n.

Seja m inteiro positivo, tal que

1 ≤ m ≤ 2n.

Os possíveis valores de m percorrem o conjunto {1, ..., 2n}, que possui 2n elementos.
Pelo (T.F.A.), m = 2e13e2...per

r , com 0 ≤ ei ≤ n e 1 ≤ i ≤ r. Fazendo a análise combinatória

dos expoentes, segue que existem exatamente (n + 1)r números escritos em tal forma.

Porém a quantidade 2n de elementos do conjunto do qual m pertence, não pode ser superior

a quantidade (n + 1)r dos possíveis m avaliada na combinatória de sua fatoração. Ou seja

Absurdo, pois

(n + 1)r ≥ 2n.

(n + 1)r < 2n.

2.4.3 A demonstração de Euler

Esta prova se baseia na famosa identidade de Euler:

∞
∑
n=1

1
n

=

(cid:32) ∞
∑
k=0

∞
∏
i=1

1
pk
i

(cid:33)

,

onde pi é o i-ésimo primo.

20

Demonstração. Suponha que tenhamos apenas um número ﬁnito de primos 2 = p1 < p2 <
... < pr. Então a identidade de Euler toma a forma

∞
∑
n=1

1
n

=

r
∏
i=1

(cid:32) ∞
∑
k=0

1
pk
i

(cid:33)

.

converge, pois trata-se de uma série geométrica. A saber, vale que

Agora a série ∑ 1
pk
i
= 1
∑ 1
pk
i
Voltando para a identidade de Euler, temos

1−p−1
i

.

1
pk
i
Portanto a série harmônica converge, o que é um absurdo.

1
1 − p−1

1
1 − p−1

∑

=

=

i

i

r
∏
i=1

< +∞.

2.5. Princípio da indução ﬁnita

Há uma propriedade adicional que só os números naturais (inteiros positivos) possuem, que

é o Axioma de Indução que passamos a descrever.

2.5.1 Princípio da Indução Matemática

Teorema 2.5.1. Seja P(n) a proposição que queremos provar. Para que P(n) seja verdadeira
para todo n natural, basta que:

(i) p(1) seja verdadeira;

(ii) e se P(k) for verdadeira para algum número natural k, então P(k + 1) também seja ver-

dadeira.

Não vamos demonstrar que o método funciona. Para fazer a demonstração é preciso um
valioso axioma e que não vemos a necessidade do mesmo para apenas esta demonstração. Ao
invés disto, vamos nos convencer de que o método é razoável. Começamos sabendo que P(1)
é verdade. Mas, de acordo com (ii), se P(1) é verdade, então P(2) é verdade. Por (ii) de novo,
se P(2) é verdade, então P(3) é verdade; e assim por diante.

É como a queda de dominó. Ponha cada peça do dominó, de pé, do lado de outro, a uma
pequena distância. Neste caso, a aﬁrmação P(n) é: a n-ésima peça do dominó cai. De fato, se
derrubamos a primeira peça (isto é, se P(1) é verdadeira) e se a queda da k-ésima peça derruba
a k + 1-ésima (isto é, se P(k) verdadeira implica que P(k + 1) é verdadeira) então caem todas
as peças do dominó.

3. ARITMÉTICA MODULAR

3.1.

Introdução

Apresentaremos uma das noções mais fecundas da aritmética, introduzida por Gauss. Trata-
se da realização de uma aritmética com os restos da divisão Euclidiana por um número ﬁxado.

3.2. Aritmética dos restos

Deﬁnição 3.2.1. Se a, b e m > 1 são inteiros, dizemos que a é congruente a b módulo m se
m | (a − b). Denotamos isto por

Se m (cid:45) (a − b) dizemos que a é incongruente a b módulo m e denotamos

a ≡ b (mod m).

a (cid:54)≡ b (mod m).

Exemplo 3.2.1.

a) 11 ≡ 3 mod 2 pois 2 | (11 − 3).

b) como 5 (cid:45) 6 e 6 = (17 − 11) temos que 17 (cid:54)≡ 11 mod 5.

Proposição 3.2.1. Dados a, b e m > 0 inteiros tem-se:

a) Se r é o resto da divisão Euclidiana de a por m, então a ≡ r (mod m). Além disso, para
todo inteiro a, existe r ≥ 0 tal que a ≡ r (mod m) onde r ∈ {0, 1, 2, ..., m − 1} que forma
o que chamamos de sistema completo de resíduos módulo m.

b) Se a ≡ b (mod m), então a e b tem o mesmo resto quando divididos por m.

Demonstração.

a) Pela divisão Euclidiana dos inteiros a e m existem q e r tais que a = mq+
r, onde r < m. Temos mq = a − r o que implica m | a − r ou seja, a ≡ r(mod m). Como
0 ≤ r < m, então qualquer inteiro a quando dividido por m terá o r ∈ {0, 1, 2, ..., m − 1},
logo a ≡ r (mod m).

b) Suponha que a e b tenham restos r1 e r2, respectivamente, na divisão por m e que a ≡

b (mod m). Deste modo,

subtraindo as equações, temos

(cid:40)

a = mq1 + r1
b = mq2 + r2

21

22

mas a ≡ b (mod m), assim, a − b = mq3. Logo,

a − b = m(q1 − q2) + (r1 − r2),

m(q1 − q2) + (r1 − r2) = mq3 ⇔ m(q1 + q3 − q2) = r2 − r1 ⇔

⇔ m | |r2 − r1| < m ⇔ r2 − r1 = 0 ⇔ r1 = r2.

O teorema a seguir mostra que as congruências são uma classe muito importante em mate-

mática e que chamamos de relação de equivalência.

Teorema 3.2.1. Sejam a, b, c e m > 0 inteiros, tem-se:

i) a ≡ a mod m (reﬂexiva);

ii) se a ≡ b mod m, então b ≡ a mod m (simétrica);

iii) se a ≡ b mod m e b ≡ c mod m, então a ≡ c mod m (transitiva).

Demonstração.

i) m | 0 ⇒ m | (a − a) ⇒ a ≡ a mod m.

ii) Se a ≡ b mod m ⇒ m | (a − b) ⇒ m | [−(b − a)] ⇒ m | (b − a) ⇒ b ≡ a mod m.

iii) Se a ≡ b mod m e b ≡ c mod m, então m | (a − b) e m | (b − c), respectivamente, assim:

m | [(a − b) + (b − c)] ⇒ m | (a − c) ⇒ a ≡ c mod m.

Proposição 3.2.2. Se a, b, c e m > 0 são inteiros tais que a ≡ b mod m, então:

i) a + c ≡ b + c mod m;

ii) a − c ≡ b − c mod m;

ii) ac ≡ bc mod m.

Demonstração.

i) Como a ≡ b mod m, temos que m | (a − b), e portanto, m | [(a + c) −

(b + c)] = (a − b), logo a + c ≡ b + c mod m.

ii) Como (a − c) − (b − c) = a − b, e m | (a − b), segue que a − c ≡ b − c mod m.

iii) Como m | (a − b), então a − b = mq, assim ac − bc = mcq, logo m | (ac − bc), portanto

ac ≡ bc mod m.

Proposição 3.2.3. Se a, b, c, d e m > 0 são inteiros tais que a ≡ b mod m e c ≡ d mod m,
então,

23

i) a + c ≡ b + d mod m;

ii) a − c ≡ b − d mod m;

iii) ac ≡ bd mod m.

As demonstrações seguem diretamente da deﬁnição.

Proposição 3.2.4. Se a, b, c e m > 0 são inteiros e ac ≡ bc mod m, então a ≡ b mod m
d = mdc(c, m).

d com

Demonstração. De ac ≡ bc mod m temos ac − bc = c(a − b) = qm. Se dividirmos por d,
d ; logo ( m
d ) | [( c
d )(a − b) = q. m
teremos ( c
d ) |
(a − b) o que implica a ≡ b mod m
d .

d )(a − b)] e, como mdc( m

d ) = 1, segue que, ( m

d , c

Proposição 3.2.5. Se a, b, k > 0 e m > 0 são inteiros e a ≡ b mod m, então ak ≡ bk mod m.

Demonstração. Segue imediatamente da identidade

ak − bk = (a − b)(ak−1 + ak−2b + ... + abk−2 + bk−1).

Proposição 3.2.6. Se a ≡ b mod m1, a ≡ b mod m2, ... , a ≡ b mod mk onde a, b, m1, m2, ... mk
são inteiros com mi positivos para i = 1, 2..., k, então

onde [m1, m2, ..., mk] é o mínimo múltiplo comum de m1, m2, ... mk.

a ≡ b mod [m1, m2, ..., mk]

Demonstração. Se a ≡ b mod mi, para todo i = 1, 2, ..., k, então, mi | (a−b) para todo 1 ≤ i ≤ k.
Sendo a − b múltiplo de cada mi, segue-se que [m1, m2, ..., mk] | (a − b) o que nos mostra que
a ≡ b mod [m1, m2, ..., mk].

3.3. Congruência Linear

Chamamos de congruência linear em uma variável a uma congruência da forma ax ≡

b mod m onde x é uma incógnita.

É fácil de se veriﬁcar que se x0 é uma solução, i.e., ax0 ≡ b mod m e x1 ≡ x0 mod m então

x1 também é solução. Isto é óbvio pois se x1 ≡ x0 mod m então ax1 ≡ ax0 ≡ b mod m.

Uma equação da forma ax + by = c, onde a, b e c são inteiros é chamada equação diofantina

linear. (o nome vem do matemático grego Diofanto).

24

Teorema 3.3.1. Sejam a e b inteiros e d = (a, b). Se d (cid:45) c então a equação ax + by = c não
possui nenhuma solução inteira. Se d | c ela possui inﬁnitas soluções e se x = x0 e y = y0 é uma
solução particular, então todas as soluções são dadas por

x = x0 + (b/d)k

y = y0 − (a/d)k

onde k é um inteiro.

Demonstração. Se d (cid:45) c, então a equação ax + by = c, não possui solução pois, como d | a e
d | b, d deveria dividir c, o qual é uma combinação linear de a e b. Suponhamos, pois, que d | c.
Pelo corolário 2.2.1 existem inteiros n0 e m0, tais que

an0 + bm0 = d

(3.1)

Como d | c, existe um inteiro k tal que c = kd. Se multiplicarmos ambos os lados de (3.1)
Isto nos diz que o par (x0, y0) com x0 = n0k e

por k, teremos a(n0k) + b(m0k) = kd = c.
y0 = m0k é uma solução de ax + by = c. É fácil a veriﬁcação de que os pares da forma

x = x0 +

y = y0 −

b
d
a
d

k

k

são soluções, uma vez que

ax + by = a(x0 +

b
d

k) + b(y0 −

a
d

k) =

ab
d

= ax0 +

k + by0 −

ab
d
O que acabamos de mostrar é que, conhecida uma solução particular (x0, y0) podemos, a
partir dela, gerar inﬁnitas soluções. Precisamos, agora, mostrar que toda solução da equação
d k, y = y0 − a
ax + by = c é da forma x = x0 + b
d k. Vamos supor que (x, y) seja solução, i.e.,
ax + by = c. Mas, como ax0 + by0 = c, obtemos, subtraindo membro a membro, que

k = ax0 + by0 = c

ax + by − a0 − by0 = a(x − x0) + b(y − y0) = 0,

o que implica a(x − x0) = b(y0 − y). Como d = (a, b) temos,

(cid:19)

(cid:18) a
d

,

b
d

= 1.

Portanto, dividindo-se os dois membros da última igualdade por d, teremos

a
d

(x − x0) =

b
d

(y0 − y).

25

Logo, pela parte 1 do lema 2.3.1, (cid:0) b
d

x − x0 = k (cid:0) b
y = y0 − (cid:0) a

(cid:1), ou seja x = x0 + (cid:0) b
d
(cid:1) k, o que conclui a demonstração.

d

d

(cid:1) (x − x0) e portanto existe um inteiro k satisfazendo
(cid:1) k. Substituindo-se este valor de x na equação 3.3 temos

Teorema 3.3.2. Sejam a, b e m inteiros tais que m > 0 e (a, m) = d. No caso em que d (cid:45) b a
congruência ax ≡ b mod m não possui nenhuma solução e quando d | b, possui exatamente d
soluções incongruentes módulo m.

Demonstração. Pela própria deﬁnição de congruência dizemos que o inteiro x é solução de
ax ≡ b mod m se, e somente se, existe um inteiro y tal que ax = b + my, ou, o que equivalente,
ax − my = b. Do teorema anterior sabemos que esta equação não possui nenhuma solução caso
d (cid:45) b, e que se d | b ela possui inﬁnitas soluções dadas por x = x0 − (m/d)k e y = y0 − (a/d)k
onde (x0, y0) é uma solução particular de ax − my = b. Logo a congruência ax ≡ b mod m
possui inﬁnitas soluções dadas por x = x0 − (m/d)k. Como estamos interessados em saber
o números de soluções incongruentes, vamos tentar sob que condições x1 = x0 − (m/d)k1 e
x2 = x0 − (m/d)k2 são congruentes módulo m. Isto implica (m/d)k1 ≡ (m/d)k2 mod m, e
como (m/d) | m, temos (m/d, m) = m/d, o que permite o cancelamento de m/d resultando,
pela Proposição 3.2.4, k1 ≡ k2 mod d. Observe que m foi substituído por d = m/(m/d). Isto
nos mostra que soluções incongruentes serão obtidas ao tomarmos x = x0 − (m/d)k, onde k
percorre um sistema completo de resíduos módulo d, o que conclui a demonstração.

3.4. Pequeno Teorema de Fermat

Teorema 3.4.1 (Fermat). Se p é um número primo e a um inteiro qualquer, então

Além disso, se p (cid:45) a, então

ap ≡ a mod p.

ap−1 ≡ 1 mod p.

Demonstração. Para p = 2, temos que a2 ≡ a mod 2, pois 2 | (a2 − a) = a(a − 1), números
consecutivos.

Agora seja p > 2. Faremos uma prova por indução sobre a. Para a = 1, tem-se 1p ≡
1 mod p, pois p | 0. Agora suponhamos que ap ≡ a mod p, para a > 1 iremos provar que
(a + 1)p ≡ (a + 1) mod p.

Pelo binômio de Newton,

(a + 1)p − (a + 1) = ap − a +

(cid:19)

ap−1 + ... +

(cid:18)p
1

(cid:18) p

p − 1

(cid:19)
a

como p | (cid:0)p
i
1)], então

(cid:1) para 1 ≤ i ≤ p − 1 e p | (ap − a) por hipótese de indução, logo p | [(a + 1)p − (a +

26

(a + 1)p ≡ (a + 1) mod p.

Portanto a relação é verdadeira pelo princípio de indução ﬁnita para todo a > 1.
Para a = 0 a relação é direta pois 0p ≡ 0 mod p.
Agora se a < 0, então −a > 0 ou seja,

como p é ímpar pois o único primo par é p = 2 que já vimos, então

(−a)p ≡ −a mod p

−ap ≡ −a mod p

logo pela propriedade de produto por um inteiro, por exemplo, −1, temos,

ap ≡ a mod p.

Caso p (cid:45) a, como ap ≡ a mod p e p | (ap − a) = a(a − 1), então p | (ap−1 − 1), ou seja,

ap−1 ≡ 1 mod p.

Exemplo 3.4.1. Encontrar o resto da divisão de 23728 por 13.

Sabemos que 237 ≡ 3 mod 13, assim 2374 ≡ 34 ≡ 3 mod 13.
Por Fermat temos que 23712 ≡ 1 mod 13, logo 23724 = (23712)2 ≡ (1)2 ≡ 1 mod 13 .
Multiplicando 2374 ≡ 3 mod 13 por 23724 ≡ 1 mod 13 temos:

23728 ≡ 3 mod 13.

3.5. Teorema de Euler

3.5.1 A função φ de Euler

Deﬁnição 3.5.1. Seja m um inteiro positivo. Dizemos que φ (m) corresponde a quantidade de
inteiros positivos menores que m e primos com m. Por convenção, φ (1) = 1.

Exemplo 3.5.1.

φ (15) = 8, pois (1, 15) = (2, 15) = (4, 15) = (7, 15) = (8, 15) = (11, 15) = (13, 15) =

(14, 15) = 1

Com a função φ : N∗ −→ N estabelecida algumas relações como veremos abaixo.

Teorema 3.5.1. Sejam m e m(cid:48) inteiros positivos com m > 1, m(cid:48) > 1 e (m, m(cid:48)) = 1. Então,

φ (m.m(cid:48)) = φ (m).φ (m(cid:48)).

27

Observação: a demonstração foge do desígnio do trabalho.

Proposição 3.5.1. Se p é um número primo e r um inteiro positivo, então tem-se que

φ (pr) = pr − pr−1 = pr−1(p − 1).

Demonstração. De 1 até pr, temos pr números naturais que não são primos com pr, ou seja,
todos os múltiplos de p, que são precisamente

cujo número é pr−1. Portanto,

1.p, 2.p, ... pr−1.p

φ (pr) = pr − pr−1 = pr−1(p − 1).

Lema 3.5.1. Se m = pα1

1 .pα2

2 ...pαn

n é a decomposição de m em fatores primos, então

φ (m) = pα1−1

1

(p1 − 1)pα2−1

2

(p2 − 1)...pαn−1

n

(pn − 1).

A demonstração segue diretamente do Teorema (3.5.1) e da Proposição (3.5.1).

Observação: Se p e q são primos e m = pq temos que φ (m) = (p − 1)(q − 1).

Exemplo 3.5.2. Calcule φ (34).

Como 34 = 21.171

Teorema 3.5.2 (Euler). Se m é um inteiro positivo e a um inteiro com (a, m) = 1, então

φ (34) = (2 − 1)(17 − 1) = 16.

aφ (m) ≡ 1 mod m.

Demonstração. Vamos considerar p primo sendo um dos fatores primos da decomposição de
m e para k > 0 vamos fazer a prova por indução sobre k para expressão

aφ (pk) ≡ 1 mod pk
inicialmente, considerando k = 1 temos aφ (p) ≡ 1 mod p , mas φ (p) = p − 1 pois p é primo,
como (a.p) = 1. Temos que ap−1 ≡ 1 mod p é o próprio teorema de Fermat e portanto verda-
deiro.

Agora, iremos admitir por hipótese de indução que aφ (pk) ≡ 1 mod pk é válido para k > 1.

Devemos provar que a aﬁrmação é verdadeira para k + 1.

Por hipótese, pk | aφ (pk) − 1. Logo,

28

para algum q inteiro. Além disso,

aφ (pk) = pkq + 1

φ (pk+1) = pk(p − 1) = p.pk−1(p − 1)

e φ (pk) = pk−1(p − 1)

assim temos,

φ (pk+1) = p.φ (pk)

[aφ (pk+1)] − 1 =3.3 ap.φ (pk) − 1 = [aφ (pk)]p − 1 =3.2 [pk.q + 1]p − 1 =

(3.2)

(3.3)

=

(cid:18)p
1

(cid:19)

.pk.q +

p
∑
j=2

(cid:18)p
j

(cid:19)

(pk.q) j = pk+1.q +

p
∑
j=2

(cid:18)p
j

(cid:19)

(pk.q) j.

Como,

temos,

sabendo que,

concluimos que,

p |

(cid:19)

(cid:18)p
j

e

pk | (pk.q) j, 2 ≤ j ≤ p

pk+1 |

(cid:19)

(cid:18)p
j

(pk.q) j

pk+1 | pk+1.q

pk+1 | (aφ (pk+1) − 1) ⇒ aφ (pk+1) ≡ 1 mod pk+1.

Assim, pelo princípio de indução ﬁnita

aφ (pk) ≡ 1 mod pk.

Adotaremos a decomposição de m em fatores primos seja, m = pα1

1 .pα2

2 ...pαn

n , denotando

m = pα j

j .m j onde m j = pα1

1 ...pα2

2 ...pα j

j ...pαn

n é a decomposição com a exclusão do fator pα j
j .

Observe que (pα j

j , m j) = 1, sabemos do caso anterior

α j
j ) ≡ 1 mod pα j
aφ (p

j , 1 ≤ j ≤ n

(3.4)

Elevando a equação (3.4) acima, por φ (m j).

(cid:20)
aφ (p

α j
j )

(cid:21)φ (m j)

≡ 1 mod pα j
j

29

assim,

que equivale,

assim,

α j
aφ (p
j

. m j) ≡ 1 mod pα j
j

aφ (m) ≡ 1 mod pα j

j , 1 ≤ j ≤ n

pα j
j

| [aφ (m) − 1], 1 ≤ j ≤ n.

Deste modo, como (pi, p j) = 1 para i (cid:54)= j obtemos um sistema de congruências




Portanto pela Proposição (3.2.6), temos

aφ (m) ≡ 1 mod pα1
1
aφ (m) ≡ 1 mod pα2
2
...
aφ (m) ≡ 1 mod pαn
n

aφ (m) ≡ 1 mod [pα1

1 , . . . , pαn
n ],

e como m = [pα1

1 , . . . , pαn

n ], então

aφ (m) ≡ 1 mod m.

O próximo teorema é um teste de primalidade muito impotante, no entanto, não tão eﬁciente

pela grande necessidade de eﬁciência computacional.

Teorema 3.5.3 (Wilson). Será p um número primo se, e somente se, (p − 1)! ≡ −1 mod p

Demonstração. .
(⇒) Como (2 − 1)! ≡ 1 ≡ −1 mod 2 o resultado é válido para p = 2. Pelo teorema 3.3.2, a
congruência ax ≡ 1 mod p tem uma única solução para todo a no conjunto {1, 2, ... , p − 1}
e como, destes elementos, somente 1 e p − 1 são seus próprios inversos módulo p, podemos
agrupar os números 2, 3, ..., p − 2 em (p−3)
pares cujo produto seja congruente a 1 módulo p.
Se multiplicarmos estes congruencias, membro a membro, teremos:

2

e multiplicando ambos os lados desta congruência por p − 1 obtemos:

2 × 3 × ... × (p − 2) ≡ 1 mod p

2 × 3 × ... × (p − 2) × (p − 1) ≡ (p − 1) mod p

isto é,

(p − 1)! ≡ −1 mod p, pois (p − 1) ≡ −1 mod p.

(⇐) Suponha que p composto, ou seja, p = a.b, 1 < a < p e satisfaz a relação (p − 1)! ≡
−1 mod p, então p | [(p − 1)! + 1], mas como, a | p, logo a | [(p − 1)! + 1] e, além disso,
a | (p − 1)!, pois 1 < a < p. Concluimos que a | 1 o que implica que a = 1 (absurdo).

4. CRIPTOGRAFIA RSA

4.1.

Introdução

Neste capítulo falaremos um pouco sobre a criptograﬁa de uma forma geral e construiremos

todos os aspectos ligado a criptograﬁa RSA.

4.2. Criptograﬁa

Em grego, cryptos signiﬁca secreto, oculto. A criptograﬁa estuda métodos para codiﬁcar
uma mensagem de modo que só seu destinatário legítimo consiga interpretá-la. É a arte dos
“código secretos", que todos já praticamos quando criança. O mais simples destes códigos
consiste em substituir uma letra pela seguinte; isto é transladar o alfabeto uma casa para diante.

Na criptograﬁa, o texto normalmente é chamado de mensagem e uma pessoa autorizada a
ler a mensagem é chamada destinatário. O autor da mensagem pode ser chamado de remetente
e a ação de criptograr uma mensagem é chamada de codiﬁcação da mensagem. Utiliza-se a
expressão decodiﬁcar para o ato que deve ser realizado pelo destinatário para conversão da
mensagem criptografada para a mensagem original, enquanto a expressão decifrar é utilizada
para a conversão realizada por outra pessoa não autorizada. Para alguns processos de cripto-
graﬁa, se um não destinatário decifra uma mensagem codiﬁca por algum método ele é capaz
de decifrar qualquer mensagem codiﬁcada pelo tal método. Dizemos então que “o código foi
quebrado", código aí sendo utilizado no sentido do método utilizado para a codiﬁcação.

Hoje, a comunicação entre computadores pela internet vem criando novos desaﬁos para
criptograﬁa. Como é relativamente fácil interceptar mensagens enviadas por linha telefônica,
torna-se necessário codiﬁcá-las, sempre que contenham informações sensíveis. Isto inclui tran-
sações bancárias ou comerciais, ou até mesmo uma compra feita com cartão de crédito.

Podemos imaginar um banco que deseja fazer uma transação com milhões de reais para um
outro banco. Ele precisa ter certeza que ninguém vai interceptar esta mensagem. Por outro
lado, ele precisa ter a certeza que o outro banco recebeu a quantia com sucesso, para isto a
mensagem precisa estar assinada.

Por isso tornou-se necessario a invenção de novos códigos, de tal forma que fossem difí-
ceis de ser decifrados, mesmo que uma pessoa possuisse um computador. Tais códigos foram
criados justamente para esses tipos de transações ﬁnanceiras. Por isso os códigos modernos,
chamados de criptograﬁa de chave pública, são formados por duas chaves distintas, a pública
e a privada, uma para codiﬁcar e outra para decodiﬁcar mensagens. Neste método cada pessoa
ou entidade mantém duas chaves: uma pública, que pode ser divulgada livremente, e outra pri-
vada, que deve ser mantida em segredo. Esta é a ideia introduzida em 1976 por W. Difﬁe e M.E.
Hellman da Universidade de Stanford e, independentemente, por R.C. Merkle da Universidade
de Califórnia.

30

31

4.3. Criptograﬁa RSA

O método de criptograﬁa RSA foi inventado em 1978 por R.L.Rivest, A. Shamir e L. Adle-
man, que na época trabalhavam no Massachussets Institute of Techonology (M.I.T). As letras
RSA correspodem às iniciais dos inventores do código.

Suponhamos, por simplicidade, que a mensagem original é um texto onde não há números,
apenas palavras, e os espaços entre as palavras. Então a primeira coisa a se fazer na criptograﬁa
RSA é transformar a mensagem em uma sequência de números.

Utilizaremos 99 para os espaços entre as palavras, e para as letras, a tabela abaixo. Tal es-
colha é boa, pois estamos sempre associando cada elemento à um único número de exatamente
dois dígitos. Assim, quando retornarmos para texto, haverá um único caracter associado.

Figura 4.1 Pré-codiﬁcação

Fonte: Autor (2015)

Portanto, em última análise a mensagem é constituída pelas letras que formam as palavras e
pelos espaços entre palavras. Esta primeira parte é chamada de pré-codiﬁcação, para distingui-
la do processo de codiﬁcação (encriptação) e decodiﬁcação (desencriptação) propriamente dito.

Exemplo 4.3.1. Para ilustração, pré-codiﬁcando a frase ’Aprendendo a criptograﬁa RSA’, ob-
temos o número

10252714231314231324991099122718252924162710.

Ocorre também que o número encontrado deverá ser separado em blocos, os quais devem
seguir os seguintes critérios: não coincidir com alguma unidade linguística (letra, palavra, ou
qualquer outra), para evitar a decodiﬁcação por contagem de frequencia; não iniciar com zero,
para não trazer problemas na decodiﬁcação; ser menor do que n, onde este é o produto de dois
números primos (p e q) que são escolhidos para a criação de um sistema de criptograﬁa RSA
(como veremos mais a frente).

Exemplo 4.3.2. Escolhidos dois números primos, sejam p = 11 e q = 97, assim como n = pq,
então n = 1067. Realizando a separação em blocos do número encontrado no exemplo anterior,
seguindo-se os devidos critérios, teriamos:

1025, 271, 423, 131, 423, 132, 499, 109, 912, 271, 82, 52, 924, 162, 710.

Dentre vários outros possíveis.

32

A propriedade abaixo é levada em consideração para o processo de codiﬁcação e decodiﬁ-

cação.

Proposição 4.3.1. Sejam a e n dois inteiros com a < n. Se (a, n) = 1, existe um único x ∈
{1, 2, ..., n − 1} tal que

ax ≡ 1 mod n

A demonstração segue diretamente da Proposição 3.3.2.

4.3.1 A ideia por trás do RSA

Um sistema de criptograﬁa de chave pública é inicialmente estabecido pela pessoa (ou
organização), este chamaremos de receptor, que deseja receber mensagens de uma maneira
segura. É o receptor que estabelece o sistema e publica como enviar mensagens.

Vamos fazer um exemplo para ilustrar o processo RSA, apresentado em etapas.

Exemplo 4.3.3. Bob (receptor) deseja receber uma mensagem de Alice (emissor). Eles irão
utilizar o processo de criptograﬁa RSA. Para isto, realizam as etapas abaixo.

1ª etapa:

Bob escolhe dois números primos, sejam p = 3 e q = 5, e então calcula n = pq, obtendo n = 15.

2ª etapa:

Bob aplica n = 15 na função de Euler φ (n = pq) = (p − 1)(q − 1), assim obtém φ (15) =
(3 − 1)(5 − 1) = 2.4 = 8.

3ª etapa:

Bob escolhe a chave de encriptação e ∈ {1, ..., 14}, da qual (e, φ (15)) = 1 , como por exemplo
e = 3. Esta será usada por Alice para a encriptação.

4ª etapa:

Bob calcula a chave de desencriptação d ∈ {1, ..., 14}, a qual 3d ≡ 1 mod φ (15), assim d =
11. Esta permanece secreta em poder de Bob, que a utilizará para desencriptar a mensagem
recebida.

5ª etapa:

Alice recebe de Bob a chave pública n = 15 e e = 3, para então criptografar a mensagem 13, e
envia-la para Bob. Assim, obtém a = 7 de a ≡ 133 mod 15. Alice envia o número 7 para Bob.

6ª etapa:

Bob recebe a mensagem encriptada a = 7 de Alice. Para desencriptografar , usa a sua chave
secreta d = 11. Então faz m ≡ 711 mod 15, e encontra a mensagem m = 13.

Daremos o algoritmo de uma forma mais geral e detalhando alguns pontos importantes no

processo de encriptação e desencriptação.

Passo 1

33

O receptor escolhe dois números primos p e q, e calcula n = pq que é a “chave pública". Por
questão de vulnerabilidade do sistema, os números escolhidos não deverão ser consecultivos,
e terem aproximadamente cem dígitos cada. Assim, n terá aproximadamente 200 dígitos, diﬁ-
cultando que computadores recuperem p e q numa quantidade de tempo razoável.

Passo 2

O receptor calcula φ (n), onde φ é a função de Euler deﬁnida como segue: φ (n) é o número de
inteiros em {1, 2, ..., n − 1} relativamente primos com n, para n > 1. Por convenção, deﬁnimos
φ (1) = 1. Na observação do Lema 3.5.1 vimos φ (n) = (p − 1)(q − 1). Note que esta fórmula
requer conhecimento sobre p e q. Logo, calcular φ (n) sem conhecer a fatoração de n parece
tão difícil quanto fatorar n.

Passo 3: escolhendo a chave de encriptação.

O receptor escolhe e ∈ {1, ..., n − 1} relativamente primo com φ (n). O número e é a chave de
encriptação. Este número é público e é usado pelo emissor para codiﬁcar a mensagem seguindo
instruções publicadas pelo receptor.

Passo 4: construindo a chave de desencriptação.

Existe d ∈ {1, ..., n − 1} tal que ed ≡ 1 mod φ (n). A existência de d segue da Proposição
4.3.1. Esta chave, a “chave privada", permanece secreta em poder do receptor e permite ao
mesmo desencriptar suas mensagens recebidas.

Passo 5: encriptando uma mensagem.

O emissor quer enviar uma mensagem que consiste num inteiro m ∈ {1, ..., n − 1}. Para
encriptá-la, o emissor calcula o resto a da divisão de me por n. Assim, temos me ≡ a mod n,
com a ∈ {1, ..., n − 1}. O inteiro calculado a é a mensagem encriptada. O emissor envia a.

Passo 6: desencriptando uma mensagem.

O receptor recebe uma mensagem encriptada a. Para desencriptá-la, o receptor calcula m ≡
ad mod n. Mostraremos mais a frente, na Proposição 4.3.2, que isto sempre levará precisamente
à mensagem original m.

Para acompanhar os resultados apresentados nos próximos exemplos, recomendo o uso de

uma calculadora cientíﬁca.

Exemplo 4.3.4. Bob (o receptor) escolhe dois números primos, sejam p = 641 e q = 109, faz
o produto dos mesmos

n = (641).(109) = 69869.

Aplica n = 69869 na função de Euler

φ (69869) = (641 − 1)(109 − 1) = 640.108 = 69120.

34

Bob escolhe a chave de encriptação e ∈ {1, ..., 69868}, a qual (e, φ (69869)) = (e, 69120) = 1.
Seja então

e = 169.

Calcula a chave de decriptação d ∈ {1, ..., 69868}, da qual 169d ≡ 1 mod φ (69869) = 69120,
assim temos

d = 409.

Alice (a emisora) recebe de Bob, a chave pública n = 69869 e e = 169, e a utiliza para enviar
a mensagem numérica m = 4875 para Bob. Para encripta-la, calcula a ≡ 4875169 mod 69869,
e obtém

a = 39331.

Bob recebe a mensagem encriptada a = 39331 de Alice e deseja decifrá-la. Assim utiliza-se

da sua chave secreta d = 409, para calcular m ≡ 39331409 mod 69869. E encontra

que é a real mensagem que Alice queria passar para Bob.

m = 4875.

Proposição 4.3.2. Encriptação e desencriptação RSA são inversas uma da outra: se encripta-
mos uma mensagem m como a, onde me ≡ a mod n, a desincriptação sempre leva à mensagem
original m. Isto é, ad ≡ m mod n.

Demonstração. Se (m, p) = 1, o pequeno teorema de Fermat nos dá que

ad ≡ med = mk(p−1).(q−1)+1 = (mp−1)

k(q−1)

.m = 1k(q−1).m = m mod p.

Se, por outro lado, (m, p) (cid:54)= 1, temos que p | m ou, em outras palavras, m ≡ mod p. Desse

modo,

ad ≡ med ≡ 0 ≡ m mod p.

Portanto, ad ≡ m mod p em qualquer caso, isto é, ad − m é múltiplo de p. Contas análogas
nos são que ad ≡ m mod q e, portanto, ad − m também é múltiplo de q. Como p e q são primos
distintos, temos que n = pq | (ad − m), isto é, ad ≡ m mod n.

Exemplo 4.3.5. Alice ao receber de Bob, a chave pública e = 529 e n = 1067, resolve enviar a
frase “Aprendendo a criptograﬁa RSA". Sabe-se que para a pré-codiﬁcação é utilizada a tabela
abaixo, e que espaços em branco é 99.

Figura 4.2 Pré-codiﬁcação

Fonte: Autor (2015)

35

Pré-codiﬁcando, ela obtém o número

10252714231314231324991099122718252924162710.

Que separando em blocos, seguindo os critérios, ela obtém

1025, 271, 423, 131, 423, 132, 499, 109, 912, 271, 82, 52, 924, 162, 710.

Encriptando, cada um dos blocos, utilizando-se da relação a ≡ m529 mod 1067, onde m é o
valor do bloco e a é o bloco encriptado. Obteve

721, 602, 229, 1033, 229, 132, 762, 109, 252, 602, 306, 821, 143, 744, 904.

E então enviou para Bob.

Bob ao receber de Alice a mensagem encriptada, vai em busca de desencripta-la. Como
ele detém que d = 49 e n = 1067, então para cada um dos blocos, utilizando-se da relação
m ≡ a49 mod 1067 (onde m é o valor numérico do bloco), obtém

1025, 271, 423, 131, 423, 132, 499, 109, 912, 271, 82, 52, 924, 162, 710.

Que quebrando os blocos, temos

10252714231314231324991099122718252924162710.

E agora quebrando a pré-decodiﬁcação, a real mensagem é

Aprendendo a criptogra f ia RSA

4.3.2 Assinando uma mensagem

Até agora, vimos como uma pessoa, chamemos de Bob, poderia estabelecer um sistema
de criptograﬁa de chave pública, permitindo receber seguramente mensagens de qualquer um.
Suponha que Bob receba uma mensagem de sua amiga Alice, pedindo-o para transferir uma
grande quantia de dinheiro para sua conta. Isto prova que a mensagem realmente veio de Alice,
e não de alguém passando-se por ela. Então torna-se necessário a Alice provar que ela é, de
fato, a autora da mensagem enviada a Bob. Isto é o que chamamos de assinar uma mensagem.
Neste caso, ambos o emissor e o receptor, constroem um sistema de criptograﬁa de chave

pública, consistindo na tripla (n, e, d). Duas chaves públicas são necessárias.

• O emissor (Alice) compartilha nA e eA, mantendo dA secreto.

• O receptor (Bob) publica nB e eB, mantendo dB secreto.

36

4.3.3 Transmitindo uma mensagem assinada

• Para enviar uma mensagem m, o emissor começa pondo sua assinatura ao calcular

m1 ≡ mdA mod nA.

Ela então codiﬁca m1 com a chave pública do receptor:

m2 ≡ meB

1 mod nB.

O emissor então envia m2.

• Para desencriptar a mensagem assinada, o receptor começa por recuperar m1, desencriptando-

a com a sua chave secreta dB:

m1 ≡ mdB

2 mod nB.

Com efeito, pela Proposição 4.3.2,

mdB
2 ≡ meBdB

1

≡ m1 mod nB.

Em seguida, ele recupera a mensagem original usando a chave pública do emissor:

m ≡ meA

1 mod nA.

De fato, usando a Proposição 4.3.2

meA
1 ≡ mdAeA ≡ m mod nA.

Se a mensagem for enviada por um impostor, isto ﬁcará óbvio ao receptor após a desen-
criptação.

4.3.4 Aplicações

O sistema de criptograﬁa RSA é extensivamente usado na internet para transmitir dados
sensíveis como informações de cartões de crédito. O sistema bancário também é protegido por
encriptação RSA. Assim são aplicações de segurança que utilizam como base os algoritmos
de criptograﬁa RSA, entre elas: Certiﬁcados de Segurança, Assinaturas Digitais, S/Mime e
PGP; protocolo SSL, TLS e IPSec. No entanto, os algoritmos RSA requerem cálculos longos e
complexos.

37

4.3.5 Construindo primos grandes

O Teorema do número primo, nos diz, em termos simples, a probabilidade de um número
aleatório de N dígitos ser um número primo. Para construir um número primo de cem dígitos,
simplesmente geramos aleatoriamente números de cem dígitos e testamos se são primos. Tal
Teorema nos assegura que depois de uma média de 115 tentativas, obteríamos um número
primo (assumindo que gerássemos apenas números ímpares).

Teorema 4.3.1 (Teorema do número primo). Seja π(N) = #{p ≤ N : p primo} (isto é, π(N)
é a quantidade de números primos menores ou iguais a N). Desde que N seja relativamente
grande, temos

π(N) ≈

N
lnN

Observação 4.3.1. A prova deste teorema foge ao escopo deste trabalho, e não será discutida
aqui.

Observação 4.3.2. Para construir um número primo de cem dígitos, simplesmente geramos
aleatoriamente números de cem dígitos e testamos se são primos. O que pode ser feito pelo
Teorema dos números primos por

10101
ln10101 e π(10100) ≈
Assim, chamando de Q a quantidade de primos de cem dígitos e de I a quantidade de

10100
ln10100

π(10101) ≈

números ímpares com cem dígitos, temos:

Q =

10101
ln10101 −

10100
ln10100 =

100.10101 − 101.10100
100.101ln10

e

Fazendo a probalidade,

I =

1
2

.9.10100

100.10101−101.10100
100.101ln10
1
2 .9.10100
O que nos assegura que depois de uma média de 115 tentativas, obteríamos um número

P(Q/I) =

≈ 0, 0087

primo (assumindo que gerássemos apenas números ímpares).

5. O USO DE SOFTWARES COMPUTACIO-

NAIS NO ESTUDO DA CRIPTOGRAFIA

5.1.

Introdução

O uso das novas tecnologias de informação e comunicação no ensino deve ter um contexto
do processo de ensino-aprendizagem. Assim devemos ter o cuidado ao fazermos o plano de
aula e elaborar as atividade de tal forma que se construa um conhecimento em nosso caso
matemático no uso dos software computacionais.

Utilizaremos os softwares GeoGebra e Python, porém nosso intuito não é de apresentarmos
um curso sobre tais softwares, e sim de utilizarmos arquivos destes como um recurso didá-
tico. Apresentaremos elementos necessários para se obter os arquivos a serem utilizados, assim
como também uma apresentação dos arquivos. O Python, também será utilizado como uma
calculadora.

Recomendamos que se faça o atalho (na área de trabalho) de cada um dos softwares e de
cada arquivo indicado, para facilitar a realização dos momentos de aprendizagens (Capítulo 6)
.

5.2. O GeoGebra

O GeoGebra é um software de matemática dinâmica para todos os níveis de ensino que
reúne Geometria, Álgebra, Planilha de Cálculo, Gráﬁcos, Probabilidade, Estatística e Cálcu-
los Simbólicos em um único pacote fácil de se usar. Possui uma comunidade de milhões de
usuários em praticamente todos os países. Líder na área de softwares de matemática dinâmica,
apoiando o ensino e a aprendizagem em Ciência, Tecnologia, Engenharia e Matemática.

Apesar da facilidade de uso que o software possui, não iremos aqui apresentar um curso
sobre o GeoGebra, e sim dar orientações para que se tenham os arquivos necessários para as
aplicações no Capítulo 6.

Podemos encontrar o software no site www.geogebra.org . Na página principal do site,
temos várias janelas de navegação, todas com o intuito de auxiliar no uso e instalação do soft-
ware. As principais janelas são “materiais” onde dispõe de boa base para o uso, “downloads”
onde tem o instalador do software para diversos sistemas operacionais, com todas instruções
possíveis para instalação, e “comunidade” onde existem diversas comunidades no mundo com
implementações no GeoGebra de variados temas em matemática, física, entre outras ciências.

Ao abrir o site, podemos clicar com o botão direito do mouse, e então selecionar a opção

de traduzir para o português. Desta forma teremos como ilustra a ﬁgura.

38

Figura 5.1 Janela de visualização do site do GeoGebra

39

Fonte: Adaptado de http://www.geogebra.org/ pelo Autor (2015)

Para utilizarmos o software, precisamos baixa-lo clicando no link downloads, em seguida
no link que corresponde ao sistema operacional da máquina em trabalho, e então executa-lo.
Abrindo-se o arquivo temos a janela de visualização representada como na ﬁgura.

Figura 5.2 Janela de visualização do GeoGebra

Fonte: Autor (2015)

40

Quanto ao uso de materiais disponibilizados no site, podemos acessa-los clicando no link
Materiais. Em seguida, fazendo-se a busca com uma palavra chave, da qual aparecerá algumas
estruturas prontas do GeoGebra. Ao clicar em um dos resultados da busca, aparecerá na tela, a
escolha, para que seja utilizada online. Podendo-se também ser feito o seu download, clicando-
se no último link superior direito, no qual aparecerá uma lista, e então escolhe-se a opção
baixar.

5.2.1 Cifra de Cesar

Dentre os materiais implementado no GeoGebra, temos alguns com inspiração na cifra de
Cesar, que tem uma grande vantagem de facilitar o uso a encriptação e desencriptação com uma
maior agilidade. Um deles é a Roleta de Cesar, o qual adaptamos dando origem aos materiais
Cifra 1, Cifra 2 e Cifra 3.

O arquivo Cifra 1, quando aberto, se apresenta conforme a ﬁgura.

Figura 5.3 Janela de visualização do Cifra 1

Fonte: Autor (2015)

O arquivo Cifra 2, se apresenta como ilustra a ﬁgura.

Figura 5.4 Janela de visualização do Cifra 2

41

Fonte: Autor (2015)

Já o arquivo Cifra 3, conforme a ﬁgura.

Figura 5.5 Janela de visualização do Cifra 3

Fonte: Autor (2015)

Cada arquivo possue duas coroas circulares. A maior, que é ﬁxa, tem disposta o alfabeto
em sua ordem natural. Já a menor, possui o alfabeto em uma determinada ordem (a depender

42

do arquivo), e é movimentada (pelo usuário) através do controle deslizante que se encontra ao
seu lado.

Comparando-se os arquivo, abertos no GeoGebra, observemos que os arquivos são dife-
rentes. O Cifra 1, além de na coroa menor o alfabeto estar disposto em sua ordem natural, o
controle deslizante varia de (0) à (25) (não permitinto haver repetições de cifragens). O Cifra
3 em relação ao Cifra 1 só muda que o controle deslizante varia de (-52) à (52) (permitindo
haver repetições de cifragens). Já o Cifra 2 em relação ao Cifra 1 só muda que na coroa menor
o alfabeto estar disposto em uma ordem aleatória.

Estes arquivos devem ser baixados, e então salvos na área de trabalho. Daremos os nomes

de “Cifra 1.ggb” , “Cifra 2.ggb” e “Cifra 3.ggb”, respctivamente.

5.3. O Python

Python é uma linguagem de programação criada por Guido van Rossum em 1991. Os ob-
jetivos do projeto da linguagem eram produtividade e legibilidade. Em outras palavras, Python
é uma linguagem que foi criada para produzir código bom e fácil de manter de maneira rápida.

Para iniciantes, a linguagem oferece a simplicidade, interatividade e várias bibliotecas in-
clusas. Permitindo que seja possível criar algo interessante e utilizável com grande facilidade.
Porém, apesar desta facilidade, não iremos aqui ensinar programação, e sim utilizaremos os
programas como recurso didático. Daremos orientações para que se tenha os arquivos neces-
sários para as aplicações no Capítulo 5. Como também daremos orientações para utilização do
Python como uma calculadora, para as aplicações no Capítulo 5.

Podemos encontrar o software no site www.python.org/download , que ao se solicitar a
tradução para português (através do navegador), e se colocar o cursor sobre o link “transferên-
cia” aparecerá opções de downloads para diversas plataformas (sistemas operacionais). Veja a
ilustração na ﬁgura.

Figura 5.6 Janela de visualização do site do Python

43

Fonte: Autor (2015)

O IDLE (Integrated DeveLopment Environment) é o ambiente de desenvolvimento Python
padrão, que deverá ter vindo junto no pacote do download do Python. Para localizar o IDLE,
podemos realizar uma pesquisa por “IDLE” através do recurso pesquisa da plataforma (sis-
tema). Após localizado, é interessante criar um atalho na área de trabalho, para facilitar o
trabalho.

Para criar um arquivo em Python, primeiro se deve abrir o IDLE, então ir em “File” e
escolher a opção “New File”. Após digitados os comandos do programa, para salvar deve-se ir
em “File” e escolher a opção “Save As...”. Para abrir um arquivo, basta ir em “File” e escolher
“Open...”. Veja na ﬁgura.

44

Figura 5.7 Janela de visualização do IDLE do Python

Fonte: Autor (2015)

Agora, para o arquivo rodar, é necessário pressionar simultaneamente no teclado “Ctrl” e

“F5”.

5.3.1 Fatorar um número com o Python

Apresentaremos um programa que implentamos em Python que mostrou-se enﬁciente para
fatorar um número com até 8 dígitos. O algoritmo criado para este programa está apresentado
na ﬁgura abaixo.

Figura 5.8 Algoritmo

45

Fonte: Autor (2015)

Como utilizaremos este programa, para cria-lo é necessário digitar no IDLE, os dados con-
tidos no algoritmo da ﬁgura acima, passados para a linguagem do Python, conforme a ﬁgura
abaixo.

Figura 5.9 Fatorar um número com o Python

Fonte: Autor (2015)

46

Agora é importante não esquecer de salva-lo como fatoracao, na área de trabalho, assim

aparecerá “fatoracao.py”.

5.3.2 Calculadora com o Python

Este recurso é utilizado através do IDLE do Python. É necessário, apenas abri-lo, não
devendo ir no “File” abrir mais nada. Agora é necessário conhecer algumas operações. Como
mostra a ﬁgura.

Figura 5.10 Operações em Python

Fonte: Autor (2015)

Para calcular é necessário digitar a expressão numérica dentro dos parenteses do comando
“print( )”, e então pressionar a tecla enter, assim será apresentado o resultado na linha logo
abaixo. Vejamos alguns exemplos na ﬁgura abaixo.

Figura 5.11 Calculadora com o Python

Fonte: Autor (2015)

6. MOMENTOS DE APRENDIZAGENS

6.1.

Introdução

Iremos apresentar em cada momento de aprendizagem alguns conceitos sobre criptograﬁa

para o uso de codiﬁcação e decodiﬁcação no ensino básico.

A abordagem de conteúdos que estimulem a curiosidade e que despertem o processo de
ensino-aprendizagem e a construção de novos conhecimentos é importantíssimo no ensino de
matemática, sobretudo com o uso de novas tecnologias, pois esta metodologia vem despertando
o aluno a cada dia e de forma eﬁcaz.

Algumas reﬂexões podem ser feitas a respeito da importância do tema criptograﬁa no currí-
culo de matemática do ensino médio e para nos apoiarmos veremos o que diz a Lei de Diretrizes
e Bases da Educação Nacional [BRASIL, lei 9394/96] que apresenta o ensino médio com as
seguintes ﬁnalidades:

• a consolidação e o aprofundamento dos conhecimentos adquiridos no ensino fundamen-

tal, possibilitando o prosseguimento de estudos;

• a preparação básica para o trabalho e a cidadania do educando, para continuar apren-
dendo, de modo a ser capaz de se adaptar com ﬂexibilidade a novas condições de ocupa-
ção ou aperfeiçoamento posteriores;

• o aprimoramento do educando como pessoa humana, incluindo a formação ética e o

desenvolvimento da autonomia intelectual e do pensamento crítico;

• a compreensão dos fundamentos cientíﬁco-tecnológicos dos processos produtivos, rela-

cionando a teoria com a prática, no ensino de cada disciplina.

Assim na etapa ﬁnal da educação básica, espera-se que o estudante esteja preparado para
atuar na sociedade, na qual está inserido, de forma efetiva, sabendo se comunicar claramente,
resolver problemas do dia a dia e do trabalho, tomar decisões, trabalhar com eﬁciência e em
cooperação.

6.2. Proposta Pedagógica

Nas últimas décadas surgiu uma tendência denominada de formação de professores reﬂexi-
vos, que visa analisar a atual situação da formação docente. Nessa perspectiva, a do professor
reﬂexivo, as reﬂexões a respeito da prática educativa e da criação de novas metodologias, de-
vem ir ao encontro de novas possibilidades de formação proﬁssional.

Muitos proﬁssionais acreditam que, para serem bons professores, é necessário apenas que
conheçam o conteúdo a ser ensinado, sem preocupação com outras dimensões de um processo
tão complexo que é o de ensino e aprendizagem.

Para ter sucesso em nossa proposta usaremos o ensino construtivista, este inspirado nas
ideias do suíço Jean Piaget (1896 − 1980). O método procura instigar a curiosidade, fazendo

47

48

a aprendizagem realiza-se por meio da resolução de problemas, de questões desaﬁadoras ou
motivadoras.

O objetivo do construtivismo é que o aluno adquira autonomia, dando ênfase ao aspecto
cognitivo do tema abordado, ou seja, faz-se com que o aluno tenha entusiasmo em aprender
determinado assunto e com isso obtenha avanço no ensino-aprendizagem.

Para motivar o tema, vamos solicitar a intervenção do professor de história. Sugerindo a
ele, que coloque a turma para assistir o ﬁlme “The imitation game". Após, discuta sobre as
principais guerras da humanidade, destacado a questão da criptograﬁa.

PLANO DE AULA

IDENTIFICAÇÃO
COMPONENTE CURRICULAR: Matemática.
CONTEÚDO: Criptograﬁa.
DURAÇÃO: 10 horas/aulas.
PÚBLICO ALVO: Educandos do terceiro ano do ensino médio público.
OBJETIVO GERAL
Criar condições, para que o educando possa compreender os aspectos fundamentais do estudo
de criptograﬁa.
OBJETIVO ESPECÍFICO
Incentivar o educando a buscar o conhecimento necessário, para manipular com segurança, as
propriedades que concerne a codiﬁcação e decodiﬁcação de informações, propiciando a este um
novo instrumento matemático capaz de compor soluções de situações-problemas encontrados
em seu cotidiano.
DISCRIMINAÇÃO DOS CONTEÚDOS

a) contexto histórico;

b) cifra de César;

c) conceitos iniciais de criptograﬁa e aritmética modular;

d) GeoGebra e softwares online, no ensino de criptograﬁa;

e) criptograﬁa RSA;

f) Python, auxiliando o ensino de aritmética modular.

METODOLOGIA

• Momento 1 (2 horas/aulas)

Tendo já ocorrido a intervenção do professor de história, com o ﬁlme “The imitation game",
a aula iniciará com a aplicação da situação problema 1. Logo após inicia-se um debate entre
alunos e professor a respeito do problema. Deve-se dar destaque à importância do resto na
divisão euclidiana, assim como quociente, correlacionando com o efeito cíclico.

Feito o debate a respeito do problema 1, o professor aplica cada um dos demais problemas,

seguido da socialização os alunos.

A aula termina com uma exposição sobre o uso de tecnologias na criptograﬁa, sobretudo

do uso do GeoGebra na criptograﬁa, dando preparo para a ocorrência do Momento 2.

49

• Momento 2 (2 horas/aulas)

Utilizaremos os arquivos: ´´Cifra 1.ggb", ´´Cifra 2.ggb"e ´´Cifra 3.ggb". Estes devem ser

baixados conforme orienta o Capítulo 5, e então, salvos na área de trabalho.

A aula iniciará com a aplicação da situações problema 1, que utiliza os arquivos citato
logo acima. Terminada da ativitidade, vem a socialização entre professor e alunos. Nesta, o
professor além de fazer correlação com o Momento 1, deve aprensenta-los a decodiﬁcação por
frequência.

Após o término do debate sobre o Problema 1, o professor faz uma exposição (com o data

show) do vídeo “Demonstração Máquina Enigma", disponível em

www.u f rgs.br/museu/comunicacao/divulgacao/audiovisual/maquina − enigma − 1

Aplica-se a situação problema 2 com o auxílio do site www.amenigma.com, e então, faz-se

mais uma rodada de socialização.

• Momento 3 (2horas/aulas)

A aula iniciará com a aplicação da situação problema 1, que foi retirado das Olimpíadas Bra-
sileiras das Escolas Públicas (OBMEP), e que tem um papel importantíssimo para introduzir
o tema de congruências modulares. Terminado o tempo para a realização do problema, há a
solialização, onde o professor deve orienta-la correlacionando com os Momentos 1 e 2.

Após a discussão do problema 1, o professor inicia uma apresentação (com o data show),
onde mostrará alguns aspectos inerentes à congruencia modular, como: deﬁnição, proprieda-
des, relação com números relativamente primos e exemplos.

Aplica-se o problema 2. Com o momento de reﬂexão dos alunos ﬁndado, culmina-se com

a socialização de todos.

Segue-se com a aplicação a situação problema 3, e sua rodada de socialização.
Propõe-se uma atividade extra para casa.

• Momento 4 (2horas/aulas)

A aula iniciará com a aplicação do problema 1, este com intuito de apresentar o matemático
Leonard Euler e a função φ de euler. Assim como ﬁxar o aprendizado quanto a função φ
de Euler, e convencer que é possível fatorar n, conhecendo-se n e φ (n). Terminado, há a
socialização.

Vem a aplicação do problema 2, que introduz para o aluno uma relação importante do
processo de encriptação e desencriptação. Essa relação guarda o segredo do por que o processo
de criptograﬁa RSA funcionar tão bem. Socializa-se

No problema 3 o aluno irá fazer a encriptação, usando a linha pedida no problema. Há a

socialização.

Já no problema 4, o aluno irá fazer a desencriptação do exercício anterior, usando para tal a

chave encontrada no problema 2. Socializa-se.

O professor apresenta (com o data show) o processo de criptograﬁa RSA, através de um
exemplo. E então depois entra-se em debate com todas as atividades do momento em questão.

50

• Momento 5 (2horas/aulas)

Utilizaremos o arquivo f atoracao.py e o Software IDLE (Python), orientados no Capítulo

4, e então, salvos na área de trabalho.

O professor iniciará a aula apresentando (com data show) como abrir e manusear o arquivo

f atoracao.py. O mesmo para a calculadora no Python.

Segue-se com a aplicação do problema 1, que utiliza o software Python para auxiliar em
fatorações, e mostra que o processar da fatoração é duradouro a depender do número. Socializa-
se.

Logo depois vem a aplicação do problema 2 que contextualiza o processo de criptograﬁa

RSA, utilizando o software Python. Socializa-se

Propõe-se a atividade extra para casa.
RECURSOS

a) Quadro branco e pincel;

b) data show;

c) lista de exercício;

d) computador com software GeoGebra e Python instalado.

AVALIAÇÃO
Os educandos estarão sendo avaliados quanto:

a) Ao envolvimento com a aula;;

b) A coerência ou não, das ideias e conceitos por eles apresentados a respeito do tema em

discussão;

c) Participação em grupo para resolução de listas de exercícios.

6.3. Momento 1

Aqui será apresentado alguns conceitos iniciais para o uso de codiﬁcação no dia a dia, tais
conceitos vão ser abordados seguindo a teoria construtivista. Os alunos irão inicialmente tentar
resolver cada problema e logo depois de cada problema o professor entra em cena com alguns
conceitos extras e uma socialização com todos.

Problema 1

O primeiro código secreto que se tem notícia foi utilizado pelo militar e governante romano
Júlio César (100 a.E.C. - 44 a.E.C.), na época da transição do ﬁnal do período republicano da
Roma Antiga. Tal metodogia de criptograﬁa ﬁcou conhecida como a cifra de Cesar, na qual
cada letra do alfabeto é substituida por uma letra subsequente. Seguindo a mesma ideia a tabela
abaixo cada letra minúscula da primeira linha esta associada a uma letra maiúscula da segunda

linha, sendo a letra a da primeira linha associada a letra D da segunda linha, a b com a F e
assim sucessivamente.

51

Figura 6.1 tabela

Fonte: Autor (2015)

Figura 6.2 tabela

Fonte: Autor (2015)

i) A letra f mudou em quantas posições comparada com a primeira e segunda linha?

ii) O que ocorre se a letra a mudar em 26 posições? E se for 52? E sendo 28?

iii) Para cada um dos valores dados no item anterior, realize a divisão euclidiana por 26. O

que se pode concluir ao se comparar com a sua resposta do item (ii)?

Problema 2

Use a tabela da Figura 5.2 e faça a codiﬁcação da frase“estou aprendendo matematica".

52

Problema 3

Use 99 para espaço em palavras e a tabela abaixo para fazer a codiﬁcação da frase
“estudar é importante"

Figura 6.3 tabela

Fonte: Autor (2015)

Problema 4

Com a mesma tabela do problema anterior, decifre
“1428292430991025271423131423132499122718252924162710151810"

6.4. Momento 2

Dando continuidade ao tema, nesta aula 2, podemos observar a importância do ensino de
criptograﬁa com o uso do software computacional GeoGebra e perbecemos que desta forma
aumentamos o grau de ensino-aprendizagem.

53

Problema 1

Abra o arquivo “Cifra 1"na área de trabalho de seu computador. Faça a codiﬁcação do nome
de sua escola usando o software GeoGebra. Caso use o ícone “Cifra 2"qual seria a nova codi-
ﬁcação do nome de sua escola e sendo com o ícone “Cifra 3"? Qual a diferença entre os três
casos?

Figura 6.4 CIFRA 1

Fonte: Autor (2015)

54

Figura 6.5 CIFRA 2

Fonte: Autor (2015)

Figura 6.6 CIFRA 3

Fonte: Autor (2015)

Problema 2

Codiﬁque o seu nome, utilizando a Máquima Enigma online, disponível em:

htt p : //www.amenigma.com

55

Figura 6.7 Máquina Enigma

Fonte: Autor (2015)

6.5. Momento 3

Este momento tem o objetivo de introduzir e ﬁxar as ideias de aritmética modular, assim

como inteligar o tema ao estudo de criptograﬁa.

Vamos apresentar inicialmente uma questão retirada do banco de questões do site da OB-

MEP (Olimpíadas Brasileira de Matemática das Escola Públicas).

Problema 1

A, B, C, D, E, F, G e H são os ﬁos de apoio que uma aranha usa para construir sua teia,
conforme mostra a ﬁgura. A aranha continua seu trabalho.

56

Figura 6.8 teia de aranha

Fonte: Autor (2015)

Sobre qual ﬁo de apoio estará o número 118?

Problema 2

Ache o resto da divisão

a) de 710 por 50;

b) de 2100 por 11;

c) de 521 por 127;

O próximo problema que foi uma adaptação de um retirado de [Rousseau & Saint-Aubin,
2015], tem um caráter considerável para o ensino-aprendizagem de criptograﬁa interligada a
aritmética modular.

Problema 3

Apresentamos um sistema de criptograﬁa simples. O espaço entre as palavras é representado
pelo número 0, enquanto 27 corresponde ao ponto e 28 à vírgula. As letras A, ..., Z são repre-
sentadas pelos números 1, ..., 26, conforme organizada na seguinte tabela:

Figura 6.9 tabela

57

Fonte: Autor (2015)

Eis como codiﬁcar uma palavra:

• substituimos os símbolos pelos números associados;

• multiplicamos cada número por 2;

• reduzimos cada resultado módulo 29;

• mapeamos cada número de volta a seu símbolo correspondente, resultando numa palavra

codiﬁcada.

Por exemplo, para codiﬁcar a palavra “PAR", primeiro a mapeamos para a sequência 16,1,18.
Dobramos estes números, obtemos 32,2,36, restando 3,2,5 após a redução módulo 29. Substi-
tuindo os inteiros pelos símbolos associados leva à codiﬁcação ﬁnal de “CBE".

a) Codiﬁque a palavra “SIM".

b) Explique por que esta codiﬁcação é reversível, e como proceder para decodiﬁcá-la.

c) Decodiﬁque a palavra “IAZB".

Problema Extra

O objetivo desta questão é mostrar que nenhum número da forma 4n + 3 pode ser escrito como
a soma dos quadrados de dois inteiros.

(1) Mostre que o quadrado de qualquer inteiro só ser pode congruente a 0 ou 1 módulo 4.

(2) Use (1) para mostrar que se x e y são inteiros então x2 + y2 só pode ser congruente a 0, 1

ou 2 módulo 4.

(3) Use (2) para mostrar que um inteiro da forma 4n + 3 não pode ser escrito como soma de

dois quadrados de inteiros.

Este resultado é um caso particular de um teorema comunicado por Fermat em uma carta a
Roberval datada de 1640. Fermat também sabia que qualquer primo da forma 4n + 1 pode ser
escrito como soma de dois quadrados de inteiros.

58

6.6. Momento 4

O momento presente tem um papel central para o entendimento do funcionamento do sis-

tema de criptograﬁa RSA.

Problema 1

A função φ (n) foi desenvolvida pelo matemático e físico suiço Leonhard Euler (1707-1783),
é deﬁnida como a quantidade de números naturais 0, 1, ..., n − 1 que são primos com natural n.
Por exemplo, para n = 10, temos φ (10) = 4, pois os números 1, 3, 7 e 9 são menores que 10 e
primos com 10. Sabe-se que para n = p.q, ou seja, o produto de dois números primos, tem-se
que φ (n) = (p − 1).(q − 1). Diante disso, para n = 851, sendo o produto de dois primos, com
φ (851) = 792. Determine a forma fatorada de 851.

Problema 2

Um sistema de criptograﬁa de chave pública é inicialmente estabelecido pela pessoa (ou orga-
nização), que chamaremos de receptor, que quer receber mensagens de uma maneira segura. É
o receptor que estabelece o sistema e publica como enviar suas mensagens.
Considere que Bob deseja receber uma informação sigilosa de Alice. Estabelecido um sistema
de criptograﬁa RSA com n = 5×13 = 65 e com a chave encriptação e = 29 (pública) . Encontre
a chave de desencriptação d (privada) que satisfaça e.d ≡ 1 mod φ (n).

Problema 3

A chave de desencriptação d encontrada por Bob será mantida em seu poder, assim como, a
fatoração de n. O que é uma grande diﬁculdade, pois no meio real os primos usados na fatoração
de n são muito grandes e dessa forma ﬁca impossível em tempo hábil calcular a chave d.
Bob (receptor) pública então as chaves n = 65 e e = 29. Alice (emissora) deseja enviar a
mensagem m = 24 para Bob e irá usar as chaves publicada por ele. Ajude Alice, calculando a
mensagem criptografada “a"tal que a ≡ me mod n.

Problema 4

Alice envia a mensagem “a"para Bob. Para ele conseguir voltar para mensagem real “m "vai
precisar de sua chave de desincriptação d. Ajude Bob, calculando a desincriptação da mensa-
gem, ou seja, encontrar m tal que m ≡ ad mod n.

6.7. Momento 5

O momento presente tem um papel de concretizar o aprendizado de fatoração e da cripto-

graﬁa RSA com o uso do software Python.

Problema 1

Utilizando-se do arquivo “fatoracao.py” , encontre os fatores primos de:

59

a) 7927001

b) 353093680447

c) 14371749415924438039

Em algum caso ocorreu algum problema? Se sim, descreva o problema, e explique o por
quê.

O próximo problema foi adaptado de [COUTINHO, S.C, 2011], tem um papel central no

entendimento do sistema de criptograﬁa RSA.

Problema 2

A chave pública utilizada pelo banco de Toulouse para codiﬁcar suas mensagens é a se-
guinte: n = 10403 e e = 8743. Recentemente os computadores do banco receberam, de local
indeterminado, a seguinte mensagem:

4746 − 8214 − 9372 − 9009 − 4453 − 8198

Usando as ferramentas do Python para facilitar os cálculos, responda:

a) Qual a fatoração do número 10403?

b) Quanto vale φ (n)?

c) Calcule a chave de desencriptação.

d) Desencripte a mensagem recebida pelo banco.

Problema Extra

Escreva sobre o sistema criptográﬁco RSA.

7. CONSIDERAÇÕES FINAIS

Este trabalho teve como objetivo mostrar que a criptograﬁa RSA pode ser trabalhada no ensino
básico. A maneira diferente como são trabalhadas as sequencias do tema caracterizam um
ensino motivador que contribuirá para o sucesso no ensino da Matemática.

Essa proposta, é importante, pois incentiva o professor trabalhar a realidade dos alunos,
ensinando-os a desenvolver habilidades com o seu cotidiano de maneira excepcional pois usa
ferramentas computacionais, assim, permite aos alunos a criticidade, tão diferente da abstração,
porém também importante. Saber trabalhar essas questões é de fundamental importância para
o sucesso no ensino de criptograﬁa no ensino básico.

Acreditamos que esta pesquisa contribuirá para uma melhor exposição das práticas de mui-
tos proﬁssionais envolvidos com o ensino da Matemática e servirá para discutimos qual o me-
lhor caminho para fazer com que os alunos diminuam as diﬁculdades nesta disciplina.

60

61  REFERÊNCIAS   BRASIL, P.C.N. Parâmetros Curriculares Nacionais: Ensino Médio. Matemática. Brasília: MEC/SEF, 1999.  COUTINHO, S.C. Números Inteiros e Criptografia RSA. 2ª Ed. Rio de Janeiro: IMPA, 2011.   EVARISTO, J. \& PERDIGÃO, E. Introdução à Álgebra Abstrata. 1ª Ed. Maceió: edufal, 2002.   HEFEZ, A. Elementos de Aritmética. 2ª edição: Rio de Janeiro, SBM 2011.   LEMOS, M. Criptografia, números primos e algoritmos (publicações matemáticas do impa). 4ª Ed. Rio de Janeiro: IMPA, 2010.   OLGIN, C.A. Currículo no Ensino Médio: uma experiência com o tema criptografia. Dissertação. Canoas- RS, 2011.   RIBENBOIM, P. Números Primos: Velhos Mistérios e Novos Recordes. 1ª edição: Rio de Janeiro, IMPA, 2012.   ROUSSEAU, C. \& SAINT-AUBIN, Y. Matemática e Atualidade: volume 1. 1ª edição: Rio de Janeiro, SBM, 2015.   SANTOS, J.P.O. Introdução à Teoria dos Números. 3ª edição: Rio de Janeiro, IMPA, 2005.     