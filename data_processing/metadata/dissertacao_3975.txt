UNIVERSIDADE FEDERAL DO MATO GROSSO DO SUL
INSTITUTO DE MATEM ´ATICA
PROGRAMA DE P ´OS-GRADUA ¸C ˜AO
MATEM ´ATICA EM REDE NACIONAL

MESTRADO PROFISSIONAL

FATORA ¸C ˜AO DE INTEIROS

Nivaldo Alves de Souza Marques

CAMPO GRANDE - MS

29 de outubro de 2015

UNIVERSIDADE FEDERAL DO MATO GROSSO DO SUL
INSTITUTO DE MATEM ´ATICA
PROGRAMA DE P ´OS-GRADUA ¸C ˜AO
MATEM ´ATICA EM REDE NACIONAL

MESTRADO PROFISSIONAL

FATORA ¸C ˜AO DE INTEIROS

Nivaldo Alves de Souza Marques

Orientadora: Profa. Dra. Elisabete Sousa Freitas

Disserta¸c˜ao apresentada ao Programa de P´os-Gradua¸c˜ao em Matem´atica em

Rede Nacional do Instituto de Matem´atica da Universidade Federal de Mato

Grosso do Sul, como parte dos requisitos para obten¸c˜ao do t´ıtulo de Mestre.

CAMPO GRANDE - MS

29 de outubro de 2015

FATORA ¸C ˜AO DE INTEIROS

Nivaldo Alves de Souza Marques

Disserta¸c˜ao submetida ao Programa de P´os-Gradua¸c˜ao em Matem´atica

em Rede Nacional do Instituto de Matem´atica da Universidade Federal

de Mato Grosso do Sul, como parte dos requisitos para obten¸c˜ao do t´ıtulo

de Mestre.

Banca examinadora:

Profa. Dra. Elisabete Sousa Freitas - UFMS (orientadora)

Prof. Dr. Fabr´ıcio S´ergio de Paula - UEMS

Profa. Dra. Lilian Milena Ramos Carvalho - UFMS

CAMPO GRANDE - MS

29 de outubro de 2015

Dedico aos meus pais Noel Marques e Magn´oria

Alves de Souza Marques, que sempre me apoiaram

para que eu alcan¸casse meus objetivos, que deixa-

ram muitas vezes os seus sonhos para realizarem os

meus e que ﬁzeram de tudo para me proporcionar

um futuro melhor.

Agradecimentos

Agrade¸co primeiramente a Deus, que nos momentos de maiores diﬁculdades segurou

em minhas m˜aos, e quando pensei em desistir, levantou a minha cabe¸ca e me deu for¸cas

para continuar. Al´em de ter me dado sabedoria e conhecimento, porque tudo isso vem

Dele.

A meus pais Noel e Magn´oria que s˜ao os meus her´ois, que sempre estiveram ao meu

lado, sempre me apoiaram e que mesmo em meio `as diﬁculdades, `as vezes tendo que

acordar as trˆes horas da madrugada para me levar para estudar, nunca reclamaram e

sempre ﬁzeram de tudo para me dar o direito de aprender, ter uma boa educa¸c˜ao e um

futuro melhor. E se hoje cheguei aqui, devo muito a eles.

A mulher mais linda desse mundo, minha esposa Kauany, minha companheira que

me apoiou muito e entendeu toda minha falta de aten¸c˜ao, minhas preocupa¸c˜oes, meus

nervosismos, minhas ang´ustias e passou junto comigo essa caminhada, e que mesmo em

pouco tempo de casados, j´a ´e o meu alicerce, o meu bra¸co forte.

A meus irm˜aos Valber e Vanessa, meu cunhado Lucas, meu sobrinho Douglas e a

toda minha fam´ılia, que sempre entenderam minha ausˆencia no meio familiar por estar

ocupado com minhas atividades de estudo e sempre me deram for¸ca.

Aos meus colegas de mestrado, em especial, Everton, Elton e Mˆonica, pela grande

contribui¸c˜ao no nosso grupo de estudos, com os lanchinhos na casa da Mˆonica, e pelas

broncas que me deram quando quis desanimar, me ajudando a conseguir chegar at´e o ﬁm.

Aos meus irm˜aos da igreja, principalmente ao meu pastor Luiz Carlos Lopes Martinez

que me ajudou muito em ora¸c˜ao e com palavras de f´e e apoio que me ﬁzeram acreditar em

mim, e aos meus amigos Max e Dayana que nesses ´ultimos dias, foram usados por Deus

com palavras que me deram muita for¸ca e conﬁan¸ca.

Aos diretores Silmara e K´assio e `as coordenadoras Rita e Adriana, que foram anjos

que Deus colocou em minha vida, que me encontraram, acreditaram em mim e me ﬁzeram

crescer como professor e que em toda essa correria sempre me deram apoio para terminar

o meu mestrado, entendendo minhas faltas em reuni˜oes importantes e nas aulas nas quais

tive que enviar substitutos.

E um muito obrigado super especial a minha professora orientadora Dra. Elisabete

Sousa Freitas que n˜ao desistiu de mim, mesmo quando eu pensei em desistir, que ﬁcou

at´e de madrugada trocando mensagens e me ajudando a corrigir meu trabalho e que

conseguiu fazer um rapaz `as vezes desanimado com os estudos crescer muito em dedica¸c˜ao

e conhecimento, que me fez gostar ainda mais do que fa¸co.

Um muito obrigado a todos.

Resumo

Neste trabalho estudaremos Fatora¸c˜ao de N´umeros Inteiros. Nos dois primeiros cap´ıtulos

apresentaremos conceitos e resultados b´asicos da teoria dos N´umeros necess´arios para o

entendimento dos cap´ıtulos seguintes. Nos cap´ıtulos 3 e 4 ser˜ao estudados testes de prima-

lidade e m´etodos de fatora¸c˜ao, come¸cando pelo crivo de Erat´ostenes e o Algoritmo Usual

de Fatora¸c˜ao (uma prova da existˆencia da fatora¸c˜ao enunciada no Teorema Fundamental

da Aritm´etica). No ´ultimo cap´ıtulo falaremos sobre o sistema de criptograﬁa RSA, um

importante exemplo de aplica¸c˜ao dos conceitos estudados no trabalho.

Palavras-chave: N´umeros Inteiros. Congruˆencia. Primalidade. Fatora¸c˜ao. Cripto-

graﬁa.

Abstract

In this work we study integer Factorization. In the ﬁrst two chapters present basic

concepts and results of number theory required for the understanding of the following

chapters. In chapters 3 and 4 will be studied primality testing and factorization methods,

starting with the sieve of Eratosthenes and the Usual factorization Algorithm (a proof

of the existence of the factoring set out in the Fundamental Theorem of arithmetic). In

the last chapter we will talk about the RSA encryption system, an important example of

application of the concepts studied in the work.

Keywords: Integers. Congruence. Primality. Factoring. Encryption.

Sum´ario

Introdu¸c˜ao

1 Conceitos e resultados b´asicos

p. 9

p. 10

1

2

Divisibilidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 10

Divis˜ao Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 11

3 M´aximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 11

4 M´ınimo M´ultiplo Comum . . . . . . . . . . . . . . . . . . . . . . . . . . p. 12

5

6

7

N´umeros primos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 13

Teorema Fundamental da Aritm´etica . . . . . . . . . . . . . . . . . . . . p. 14

Algoritmo Euclidiano . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 14

2 Inteiros m´odulo n

p. 19

1

2

Congruˆencia e classes de equivalˆencia . . . . . . . . . . . . . . . . . . . . p. 19

Teorema de Euler e Teorema de Fermat . . . . . . . . . . . . . . . . . . . p. 23

3 Fatora¸c˜ao

p. 27

1

2

3

Crivo de Erat´ostenes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 27

Teorema Fundamental da Aritm´etica . . . . . . . . . . . . . . . . . . . . p. 31

2.1

Algoritmo Usual de Fatora¸c˜ao . . . . . . . . . . . . . . . . . . . . p. 31

Algoritmo de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 33

4 Testes de primalidade e m´etodos de fatora¸c˜ao

p. 38

1

Pseudoprimos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 38

1.1

1.2

Pseudoprimos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 38

N´umeros de Carmichael

. . . . . . . . . . . . . . . . . . . . . . . p. 39

2

Teste de Miller

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 41

3 Mersenne e Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 44

3.1

3.2

N´umeros de Mersenne

. . . . . . . . . . . . . . . . . . . . . . . . p. 44

N´umeros de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . p. 46

4

Teste de Lucas

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 48

4.1

4.2

4.3

Teste de Lucas

. . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 48

Teste de Pepin . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 50

Outro teste determin´ıstico de primalidade

. . . . . . . . . . . . . p. 51

5 M´etodos de Pollard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 53

5.1

5.2

M´etodo Rho de Pollard . . . . . . . . . . . . . . . . . . . . . . . . p. 53

M´etodo p-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 54

5 Criptograﬁa RSA

p. 60

1

2

3

4

Pr´e-codiﬁca¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 60

Codiﬁca¸c˜ao e decodiﬁca¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . p. 61

Funcionamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 63

Seguran¸ca do RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 64

Conclus˜ao

Referˆencias

p. 68

p. 69

9

Introdu¸c˜ao

A fatora¸c˜ao de n´umeros inteiros em primos ´e um problema simples de compreender e ´e
abordado no 6o ano do ensino fundamental. Mas quando trabalhamos com n´umeros muito
grandes, determinar se um certo n´umero ´e primo ou composto e, no caso composto, obter
a fatora¸c˜ao completa s˜ao problemas complexos. ´E claro que existem n´umeros grandes que
podem ser rapidamente fatorados dependendo de suas caracter´ısticas, mas em geral, essa
tarefa n˜ao ´e f´acil. Por exemplo os n´umeros 100! e 10100 s˜ao f´aceis de serem fatorados, mas
se somarmos 1 a cada um deles, a fatora¸c˜ao se torna dif´ıcil.

O objetivo deste trabalho ´e estudar Fatora¸c˜ao de N´umeros Inteiros. Atrav´es da apresen-
ta¸c˜ao de alguns testes de primalidade e m´etodos de fatora¸c˜ao, e tamb´em do sistema de
criptograﬁa RSA, daremos uma id´eia de conceitos e aplica¸c˜oes ligados a esse assunto.

Come¸cando com o Algoritmo Usual da Fatora¸c˜ao e o Crivo de Erat´ostenes, que ´e o mais
antigo m´etodo para se encontrar primos, estudaremos outros m´etodos de primalidade e
de fatora¸c˜ao de n´umeros inteiros.

Existem testes de primalidade chamados testes probabil´ısticos, os quais n˜ao nos permite
aﬁrmar, com certeza, que determinado n´umero ´e primo mas que nos dar˜ao como resposta
que o n´umero ´e composto ou provavelmente primo. Os testes de primalidade chamados
testes determin´ısticos, nos dar˜ao a resposta exata. Os testes determin´ısticos de primali-
dade s˜ao, em geral, muito mais lentos e dif´ıceis de aplicar do que os testes probabil´ısticos.

A eﬁciˆencia dos algoritmos de fatora¸c˜ao depende do tipo de fator que tem o n´umero que
queremos fatorar e n˜ao existe um algoritmo de fatora¸c˜ao que funcione bem para todos os
n´umeros inteiros. Finalizaremos nosso trabalho com a descri¸c˜ao do sistema de criptograﬁa
RSA, cuja seguran¸ca depende da diﬁculdade da fatora¸c˜ao de n´umeros grandes.

10

1 Conceitos e resultados b´asicos

Neste cap´ıtulo apresentaremos conceitos e resultados b´asicos da aritm´etica dos in-
teiros necess´arios para a compreens˜ao dos testes de primalidade e m´etodos de fatora¸c˜ao
que estudaremos neste trabalho. Demonstraremos apenas o Teorema Fundamental da
Aritm´etica, que estabelece a fatora¸c˜ao de n´umeros inteiros. No ﬁnal deste cap´ıtulo apre-
sentaremos o Algorimo Euclidiano para o c´alculo do m´aximo divisor comum (mdc) entre
dois inteiros e o Algoritmo Euclidiano Estendido.

1 Divisibilidade

Deﬁni¸c˜ao 1. (Divisibilidade) Sejam a e b inteiros. Dizemos que a divide b, se
existir um inteiro c tal que b = a.c. Neste caso, dizemos tamb´em que a ´e um divisor de
b, ou que b ´e um m´ultiplo de a, ou ainda, que b ´e divis´ıvel por a. Quando a divide b,
denotamos por a|b e caso contr´ario por a (cid:45) b.

Proposi¸c˜ao 1. Sejam a, b, c, d, b1, ..., bn, c1, ..., cn n´umeros inteiros quaisquer. S˜ao

v´alidas as seguintes propriedades:

i) a|0 e a|a

ii) Se a|b e b|c, ent˜ao a|c

iii) Se a|b e c|d, ent˜ao a.c|b.d

iv) Se a|(b + c) e a|b, ent˜ao a|c

v) Se a|b1, ..., a|bn, ent˜ao a|(c1 · b1 + ... + cn · bn).

vi) Se a|b e b|a, ent˜ao a = ±b.

Proposi¸c˜ao 2. Sejam a, b ∈ Z e n ∈ N. Temos que a − b|an − bn.

Proposi¸c˜ao 3. Sejam a, b ∈ Z e n ∈ N. Temos que a + b|a2n+1 + b2n+1.

Proposi¸c˜ao 4. Sejam a, b ∈ Z e n ∈ N. Temos que a + b|a2n − b2n.

11

2 Divis˜ao Euclidiana

Teorema 5. (Divis˜ao Euclidiana) Sejam a e b inteiros com b (cid:54)= 0. Existem dois

n´umeros inteiros q e r, tais que

a = b · q + r e 0 ≤ r < |b|

onde q e r que satisfazem a rela¸c˜ao s˜ao ´unicos, e ser˜ao chamados, respectivamente de
quociente e resto da divis˜ao de a por b. Observamos que b|a se, e somente se, r = 0.

Corol´ario 6. Dados dois n´umeros inteiros a e b com b (cid:54)= 0, existe um ´unico inteiro

n (o quociente da divis˜ao de a por b) tal que

n · b ≤ a < (n + 1) · b.

Observa¸c˜ao. O inteiro q, quociente da divis˜ao euclidiana de a por b, pode ser inter-
, ´e denotado por

pretado como o maior inteiro menor ou igual do que o n´umero racional
(cid:104) a
b

e chamado de parte inteira do n´umero racional

a
b

a
b

(cid:105)

.

3 M´aximo Divisor Comum

Deﬁni¸c˜ao 2. Dizemos que um inteiro c ´e um divisor comum de dois inteiros a e b,

se c|a e c|b.

Deﬁni¸c˜ao 3. Um m´aximo divisor de dois inteiros a e b, ´e um inteiro d tal que

1. d ´e um divisor comum de a e b;

2. d ´e divis´ıvel por todo divisor comum de a e b.

Teorema 7. Sejam a e b inteiros, n˜ao ambos nulos. Existe um ´unico natural d,

denotado por (a, b), tal que d ´e um m´aximo divisor comum (mdc) de a e b.

Deﬁni¸c˜ao 4. Dizemos que dois inteiros a e b s˜ao primos entre si, ou primos relativos,

se (a, b) = 1.

Proposi¸c˜ao 8. Sejam a e b n´umeros inteiros e a = b · q + r, onde q e r s˜ao inteiros,

ent˜ao (a, b) = (b, r).

Proposi¸c˜ao 9. Sejam a e b n´umeros inteiros. Temos que,

12

1. se (a, b) = d, ent˜ao existem inteiros x e y tais que d = a · x + b · y.

2. (a, b) = 1 se, e somente se, existem existem inteiros x e y tais que 1 = a · x + b · y.

Corol´ario 10. Sejam a e b inteiros. Se d = (a, b), ent˜ao (

a
d

,

b
d

) = 1.

Proposi¸c˜ao 11. (Lema de Gauss) Sejam a, b e c n´umeros inteiros. Se a|bc e

(a, b) = 1, ent˜ao a|c.

Proposi¸c˜ao 12. Sejam a, m, n ∈ Z. Teremos que (a, m.n) = 1 se, e somente se,

(a, m) = (a, n) = 1.

A no¸c˜ao de mdc pode ser generalizada como a seguir.

Deﬁni¸c˜ao 5. Um n´umero natural d ser´a dito mdc de dados inteiros a1, ..., an, n˜ao

todos nulos, se possuir as seguintes propriedades:

i) d ´e um divisor comum de a1, ..., an;

ii) Se c ´e um divisor comum de a1, ..., an ent˜ao c|d.

Proposi¸c˜ao 13. Dados inteiros a1, . . . , an, n˜ao todos nulos, existe o seu mdc, deno-

tado por (a1, . . . , an), e

(a1, . . . an) = (a1, . . . , (an−1, an)).

Deﬁni¸c˜ao 6. Os inteiros a1, ..., an ser˜ao ditos primos entre si, ou coprimos, quando

(a1, ..., an) = 1.

4 M´ınimo M´ultiplo Comum

Deﬁni¸c˜ao 7. Dizemos que um n´umero inteiro c ´e um m´ultiplo comum de dois n´umeros

inteiros a e b, se a|c e b|c.

Deﬁni¸c˜ao 8. Dizemos que um inteiro m ≥ 0 ´e um m´ınimo m´ultiplo comum (mmc)

dos inteiros a e b, se possuir as seguintes propriedades

i) m ´e um m´ultiplo comum de a e b;

ii) Se c ´e um m´ultiplo comum de a e b, ent˜ao m|c.

13

Proposi¸c˜ao 14. Dados dois inteiros a e b, existe seu m´ınimo m´ultiplo comum, de-

notado por [a, b] e

[a, b] · (a, b) = |ab|.

Corol´ario 15. Se a e b s˜ao n´umeros inteiros primos entre si, ent˜ao mmc(a, b) = |ab|.

Deﬁni¸c˜ao 9. Diremos que um n´umero natural m ´e um mmc dos inteiros n˜ao nulos
a1, ..., an, se m ´e um m´ultiplo comum de a1, ..., an, e, se para todo m´ultiplo comum m(cid:48)
desses n´umeros, tem-se que m|m(cid:48).

Proposi¸c˜ao 16. Dados a1, . . . , an n´umeros inteiros n˜ao nulos, temos que existe o seu

m´ınimo m´ultiplo comum, denotado por [a1, . . . an], e

[a1, . . . an] = [a, . . . [an−1, an]].

5 N´umeros primos

Deﬁni¸c˜ao 10. Diz-se que um n´umero positivo p > 1 ´e um n´umero primo ou apenas
um primo se, e somente se, 1 e p s˜ao seus ´unicos divisores positivos. Um inteiro maior
que 1 e que n˜ao ´e primo diz-se composto.

Proposi¸c˜ao 17. Sejam p e q dois n´umeros primos e a um inteiro qualquer. Temos

que:

i) Se p|q, ent˜ao p = q.

ii) Se p (cid:45) a, ent˜ao (p, a) = 1.

Proposi¸c˜ao 18. Sejam a, b e c n´umeros inteiros, tais que a e b s˜ao primos entre si.

Temos que:

i) Se b|a · c, ent˜ao b|c.

ii) Se a|c e b|c, ent˜ao a · b|c.

Proposi¸c˜ao 19. (Propriedade Fundamental dos Primos)Se p ´e um primo tal

que p|a · b, ent˜ao p|a ou p|b (podendo ser fator de ambos, a e b).

Corol´ario 20. Se p, p1, ..., pn s˜ao n´umeros primos e, se p|p1 · · · pn, ent˜ao p = pi para

algum i = 1, ..., n.

Teorema 21. (Teorema de Euclides) Existem inﬁnitos n´umeros primos.

14

6 Teorema Fundamental da Aritm´etica

Do ponto de vista da estrutura multiplicativa dos inteiros, os n´umeros primos s˜ao os
mais simples e ao mesmo tempo s˜ao suﬁcientes para gerar todos os n´umeros inteiros n˜ao
nulos, como veremos no Teorema da Fatora¸c˜ao ´Unica, tamb´em conhecido como Teorema
Fundamental da Aritm´etica, enunciado pela primeira vez por Gauss em seu famoso livro
Disquisitiones arithmeticae.

Teorema 22. (Teorema Fundamental da Aritm´etica) Todo n´umero inteiro
positivo maior do que 1 ou ´e primo ou se escreve de modo ´unico (a menos da ordem dos
fatores) como um produto de n´umeros primos.

Demonstra¸c˜ao. Vamos usar a segunda forma do Princ´ıpio de Indu¸c˜ao. Se n = 2, o
resultado ´e obviamente veriﬁcado. Agora vamos supor que o resultado ´e v´alido para todo
inteiro positivo menor que n e vamos provar que ser´a v´alido para n. ´E claro que se n
´e primo, nada temos a demonstrar. Ent˜ao, suponhamos que n seja composto. assim,
existem n´umeros naturais n1 e n2 tais que n = n1 · n2, onde 1 < n1 < n e 1 < n2 < n.
Pela hip´otese de indu¸c˜ao, temos que existem n´umeros primos p1, ..., pr e q1, ..., qs tais que
n1 = p1 · · · pr e n2 = q1 · · · qs. Portanto n = p1 · · · pr · q1 · · · qs.

Agora, vamos provar a unicidade dessa escrita. Vamos supor que n = p1 · · · pr =
s pelo
1, ..., p(cid:48)
s,

j para algum j, que reordenando os primos p(cid:48)

s, onde cada um dos termos pi e p(cid:48)

j s˜ao n´umeros primos. Como p1|p(cid:48)

1 · · · p(cid:48)

1 · · · p(cid:48)
p(cid:48)
Corol´ario 20, temos que p1 = p(cid:48)
podemos supor que seja p(cid:48)

1. Portanto,

p2 · · · pr = p(cid:48)

2 · · · p(cid:48)
s.

Como p2 · · · pr < n, a hip´otese de indu¸c˜ao acarreta que r = s e os pi e p(cid:48)

j s˜ao iguais

aos pares. Assim, est´a provada a unicidade da escrita.

7 Algoritmo Euclidiano

A seguir, vamos descrever dois algoritmos: um (Algoritmo Euclidiano) para calcular
o mdc de dois inteiros a e b, n˜ao ambos nulos; e o outro (Algoritmo Euclidiano Estendido)
para determinar inteiros x e y tais que (a, b) = a · x + b · y.

Algoritmo de Euclides: Sejam a e b inteiros tais que a ≥ b. Se b = 1 ou b = a,
ou ainda b|a, temos que (a,b)=a. Ent˜ao, vamos supor 1 < b < a e que b (cid:45) a. Da´ı, pela

15

divis˜ao euclidiana, podemos escrever

a = b · q1 + r1,

com 0 < r1 < b.

Aqui teremos duas possibilidades:

a) r1|b. Nesse caso, r1 = (b, r1) e, pela Proposi¸c˜ao 8, temos que

r1 = (b, r1) = (b, a) = (a, b),

e o algoritmo termina.

b) r1 (cid:45) b. Nesse caso, podemos efetuar a divis˜ao euclidiana de b por r1, obtendo

b = r1 · q2 + r2,

com 0 < r2 < r1.

Novamente, teremos duas possibilidades:

a(cid:48)) r2|r1. Em tal situa¸c˜ao, r2 = (r1, r2) e outra vez, pela Proposi¸c˜ao 8, teremos

r2 = (r1, r2) = (r1, b) = (a, b).

b(cid:48)) r2 (cid:45) r1. Em tal situa¸c˜ao, podemos efetuar a divis˜ao euclidiana de r1 por r2, obtendo

r1 = r2 · q3 + r3,

com 0 < r3 < r2.

Prosseguimos dessa maneira at´e que o algoritmo pare. Isso sempre ocorre, pois caso
contr´ario, ter´ıamos uma sequˆencia de n´umeros naturais b > r1 > r2 > ... sem menor
elemento, o que n˜ao ´e poss´ıvel. Logo, para algum n, temos que rn|rn−1, donde (a, b) = rn.

Portanto, o algoritmo da divis˜ao ´e sucessivamente aplicado obtendo rj = rj+1 · qj+2 +
rj+2, com 0 ≤ rj+2 < rj+1 e quando chegarmos `a rn+1 = 0 teremos (a, b) = rn =
rn−2 − rn−1 · qn, onde rn ´e o ´ultimo resto n˜ao nulo.

Exemplo 1. Utilizando o Algoritmo de Euclides, vamos mostrar que mdc(1001, 780) =

13. Fazendo as divis˜oes sucessivas, obtemos

1001 = 1 · 780 + 221

780 = 3 · 221 + 117

16

221 = 1 · 117 + 104

117 = 1 · 104 + 13

104 = 8 · 13 + 0

Podemos representar essas divis˜oes utilizando o seguinte diagrama

q1 = 1

q2 = 3

q3 = 1

q4 = 1

q5 = 8

a = 1001

b = 780

r1 = 221

r2 = 117

r3 = 104

r4 = 13

r1 = 221

r2 = 117

r3 = 104

r4 = 13

r5 = 0

Portanto, como r5 = 0, r4 = 13 ´e o mdc de 1001 e 780.

17

Algoritmo de Euclides Estendido: Sejam a e b inteiros positivos, com a > b.
Temos, com as nota¸c˜oes do Algoritmo Euclidiano, que a = b · q1 + r1, b = r1 · q2 + r2 e
ri = ri+1 · qi+2 + ri+2, para i ≥ 1.

Tomando r−1 = a e r0 = b, temos que ri = ri+1 · qi+2 + ri+2, para i ≥ −1.

Observando que r−1 = a = 1 · a + 0 · b, r0 = b = 0 · a + 1 · b, r1 = 1 · a + (−q1) · b

temos que

r2 = b − r1 · q2 = b − (a − b · q1) · q2 = (−q2) · a + (1 + q1 · q2) · b.

Supondo agora que j´a calculamos ri−1 = si−1 · a + ti−1 · b e ri = si · a + ti · b, como

ri−1 = ri · qi+1 + ri+1 obtemos

ri+1 = ri−1 − ri

· qi+1 = si−1 · a + ti−1 · b − qi+1(si

· a + ti

· b) =

(si−1 − qi+1 · si)
(cid:123)(cid:122)
(cid:125)
(cid:124)
si+1

·a + (ti−1 − qi+1 · ti)
(cid:125)

(cid:124)

(cid:123)(cid:122)
ti+1

·b.

Portanto, temos uma recorrˆencia para calcularmos x, y tais que

(a, b) = rn = x · a + y · b.

Come¸camos com s−1 = 1, t−1 = 0, s0 = 0, t0 = 1 e a partir da´ı usamos a recorrˆencia

si+1 = si−1 − qi+1 · si e ti+1 = ti−1 − qi+1 · ti para i ≥ 0

para obter x = sn e y = tn.

Exemplo 2. Vimos, utilizando o algoritmo de Euclides que (1001, 780) = 13. Agora,
vamos utilizar o Algoritmo de Euclides estendido, e os valores de qj encontrados no Exem-
plo 1 para encontrar s4 e t4 tais que 1001 · s4 + 780 · t4 = 13.

Procedemos da seguinte maneira

18

s−1 = 1, t−1 = 0,

s0 = 0, t0 = 1,

s1 = s−1 − q1s0 = 1 − 1 · 0 = 1, t1 = t−1 − q1t0 = 0 − 1 · 1 = −1

s2 = s0 − q2s1 = 0 − 3 · 1 = −3, t2 = t0 − q2t1 = 1 − 3 · (−1) = 4

s3 = s1 − q3s2 = 1 − 1 · (−3) = 4, t3 = t1 − q3t2 = −1 − 1 · 4 = −5

s4 = s2 − q4s3 = −3 − 1 · 4 = −7, t4 = t2 − q4t3 = 4 − 1 · (−5) = 9

Portanto s4 = −7 e t4 = 9. De fato, teremos que 1001·(−7)+780·9 = −7007+7020 =

13

Podemos organizar as informa¸c˜oes contidas acima em uma tabela, da seguinte ma-

neira.

restos

quocientes

r−1=1001

r0 = 780

*

*

s

1

0

t

0

1

r1 = 221

q1 = 1

1 − 1 · 0 = 1

0 − 1 · 1 = −1

r2 = 117

q2 = 3

0 − 3 · 1 = −3

1 − 3 · (−1) = 4

r3 = 104

q3 = 1

1 − 1 · (−3) = 4 −1 − 1 · 4 = −5

r4 = 13

q4 = 1

−3 − 1 · 4 = −7

4 − 1 · (−5) = 9

19

2

Inteiros m´odulo n

Neste cap´ıtulo, al´em de estudarmos alguns conceitos e propriedades de congruˆencia,
apresentaremos a fun¸c˜ao phi de Euler e os Teoremas de Euler e Fermat, assuntos que
ser˜ao de grande importˆancia para o desenvolvimento dos cap´ıtulos 4 e 5.

1 Congruˆencia e classes de equivalˆencia

Deﬁni¸c˜ao 11. Seja um n´umero inteiro n > 1. Dizemos que dois inteiros a e b s˜ao
congruentes m´odulo n se os restos da divis˜ao de a por n e de b por n forem os mesmos,
e escrevemos

a ≡ b(mod n).

Decorre, imediatamente, da deﬁni¸c˜ao a seguinte proposi¸c˜ao.

Proposi¸c˜ao 23. Sejam a, b, c, de n inteiros com n > 1. Temos que:

i) a ≡ a (mod n);

ii) Se a ≡ b (mod n), ent˜ao b ≡ a (mod n);

iii) Se a ≡ b (mod n) e b ≡ c (mod n), ent˜ao a ≡ c (mod n).

Portanto, temos que a rela¸c˜ao de congruˆencia m´odulo n, com n > 1, ´e uma rela¸c˜ao de
equivalˆencia.

Proposi¸c˜ao 24. Sejam a, b, n ∈ Z, com n > 1. Tem-se que a ≡ b (mod n) se, e

somente se, n|(a − b).

Demonstra¸c˜ao. Sejam a = nq + r, com 0 ≤ r < n e b = nq(cid:48) + r(cid:48), com 0 ≤ r(cid:48) < n, as
divis˜oes euclidianas de a e b por n. Teremos que

b − a = n(q(cid:48) − q) + (r(cid:48) − r), com |r − r(cid:48)| < n.

Portanto, n|(a − b) se, e somente se, r(cid:48) − r = 0, ou seja, r(cid:48) = r, o que, em vista da
igualdade acima, ´e equivalente a dizer que a ≡ b (mod n).

Proposi¸c˜ao 25. Sejam a, b, c, d, m e n inteiros com n > 1 e m ≥ 1. Temos que:

20

i) Se a ≡ b (mod n) e c ≡ d (mod n), ent˜ao a + c ≡ b + d (mod n).

ii) Se a ≡ b (mod n) e c ≡ d (mod n), ent˜ao a · c ≡ b · d (mod n).

iii) Se a ≡ b (mod n), ent˜ao am ≡ bm (mod n).

Demonstra¸c˜ao.

i) Se a ≡ b (mod n) e c ≡ d (mod n), temos, pela proposi¸c˜ao 24, que n|(b−a) e n|(d−c).
Da´ı n|((b − a) + (d − c)) e, portanto, n|((b + d) − (a + c)), o que prova o resultado.

ii) Note que bd − ac = d(b − a) + a(d − c). Pela Proposi¸c˜ao 24, temos que n|(b − a) e

n|(d − c). Logo n|(bd − ac), e o resultado est´a provado.

iii) Este item ser´a demonstrado utilizando indu¸c˜ao sobre m. Se m = 1, a congruˆencia
´e obviamente veriﬁcada. Ent˜ao, vamos supor que o resultado seja v´alido para m e
iremos prov´a-lo para m + 1. Assim, devemos mostrar que am+1 ≡ bm+1 (mod n).
Note que am+1 = am · a. Como por hip´otese, a ≡ b (mod n) e am ≡ bm (mod n),
podemos concluir, pelo item anterior, que a · am = am+1 ≡ b · bm = bm+1 (mod n).

Proposi¸c˜ao 26. Sejam a, b, c, n ∈ Z, com n > 1. Temos que

a + c ≡ b + c mod n ⇐⇒ a ≡ b mod n.

Demonstra¸c˜ao. A volta segue-se imediatamente pelo item i) da Proposi¸c˜ao 25, pois c ≡
c (mod n).

Reciprocamente, se a + c ≡ b + c (mod n), ent˜ao n|((b + c) − (a + c)), donde n|(b − a),

ou seja, a ≡ b (mod n).

Proposi¸c˜ao 27. Sejam a, b, c, n ∈ Z, com n > 1. Tem-se que

ac ≡ bc mod n ⇐⇒ a ≡ b mod

n
(c, n)

.

Demonstra¸c˜ao. Como

n
(c, n)

e

c
(c, n)

s˜ao coprimos, temos que

ac ≡ bc ⇐⇒ n|(b−a)c ⇐⇒

n
(c, n)

|(b−a)

c
(c, n)

⇐⇒

n
(c, n)

|b−a ⇐⇒ a ≡ b (mod

n
(c, n)

).

21

O corol´ario a seguir ´e um caso particular da proposi¸c˜ao anterior.

Corol´ario 28. Sejam a, b, c, n ∈ Z, com n > 1 e (c, m) = 1. Segue que

ac ≡ bc mod n ⇐⇒ a ≡ b mod n.

Observa¸c˜ao. Segue da deﬁni¸c˜ao de congruˆencia m´odulo n que todo n´umero inteiro a
´e congruente m´odulo n ao seu resto pela divis˜ao Euclidiana por n e, portanto, ´e congruente
m´odulo n a um dos n´umeros 0, 1, . . . , n − 1. Al´em disso, dois desses n´umeros distintos
n˜ao s˜ao congruentes m´odulo n.

Portanto, para encontrar o resto da divis˜ao de um n´umero a por n, basta achar o

n´umero natural r dentre os n´umeros 0, 1, . . . , n − 1 que seja congruente a a m´odulo n.

Deﬁni¸c˜ao 12. Seja dado um n´umero inteiro n > 1. Deﬁnimos como a classe residual
m´odulo n do elemento a de Z como sendo a classe de equivalˆencia de a segundo a rela¸c˜ao
de equivalˆencia dada pela congruˆencia m´odulo n:

a = {x ∈ Z; x ≡ a (mod n)}.

O conjunto de todas as classes residuais m´odulo n ´e representado por Zn. Esse con-
junto possui n elementos que podem ser representados por 0, 1, ..., n − 1. As classes resi-
duais transformam a congruˆencia a ≡ b (mod n) na igualdade a = b.

Algumas vezes, em vez de escrevermos Zn = {0, 1, 2, ..., n − 1}, escrevemos apenas

Zn = {0, 1, 2, ..., n − 1}.

Em Zn deﬁnimos as seguintes opera¸c˜oes:

Adi¸c˜ao:

a + b = a + b.

Multiplica¸c˜ao:

a · b = a · b.

Pela proposi¸c˜ao 25, estas opera¸c˜oes est˜ao bem deﬁnidas, isto ´e, n˜ao dependem dos

representantes das classes.

As opera¸c˜oes que deﬁnimos acima gozam das seguintes propridades:

22

Propriedades da Adi¸c˜ao

Para todos a, b, c ∈ Zn, temos:

A1) Associatividade (a + b) + c = a + (b + c);

A2) Comutatividade a + b = b + a;

A3) Existˆencia de zero a + 0 = a para todo a ∈ Zn;

A4) Existˆencia de oposto a + −a = 0.

Propriedades da Multiplica¸c˜ao

Para todos a, b, c ∈ Zn, temos:

A1) Associatividade (a · b) · c = a · (b · c);

A2) Comutatividade a · b = b · a;

A3) Existˆencia de unidade a · 1 = a para todo a ∈ Zn;

AM) Distributividade a · (b + c)= a · b + a · c .

As propriedades acima seguem diretamente das propriedades dos n´umeros inteiros.

Deﬁni¸c˜ao 13. Dizemos que um elemento a ∈ Zn ´e invert´ıvel, quando existe b ∈ Zn

tal que a · b = 1.

Observa¸c˜ao. Se a ´e invert´ıvel em Zn existe um ´unico b tal que a · b = 1 e ´e denotado
por a−1. De fato, supondo a · b = 1 = a · b1., segue que (a, n) = 1 e a · b ≡ a · b1 (mod n),
donde b ≡ b1 (mod n). Portanto b = b1

Proposi¸c˜ao 29. Sejam a ∈ Zn e n > 1. Ent˜ao existe b ∈ Zn com a · b = 1 se e

somente se (a, n) = 1.

Demonstra¸c˜ao. Se a · b = 1 temos a · b ≡ 1 (mod n), da´ı n · k = 1 − a · b para algum inteiro
k, donde a · b + n · k = 1, e portanto (a, n) = 1. Se (a, n) = 1 temos a · x + n · y = 1 para
certos inteiros x e y, donde a · x ≡ 1 (mod n). Portanto a · x = 1.

Deﬁni¸c˜ao 14. Denotaremos por U(n) o conjunto dos elementos invers´ıveis de Zn,

isto ´e,

U (n) = {a ∈ Zn : a ´e invers´ıvel }

Pela Proposi¸c˜ao 29, temos que U (n) = {a ∈ Zn|mdc(a, n) = 1}.

23

2 Teorema de Euler e Teorema de Fermat

Deﬁni¸c˜ao 15. (Fun¸c˜ao de Euler) Para n > 1, seja φ(n) o n´umero de inteiros do
intervalo [1, n] que s˜ao primos relativos com n. A fun¸c˜ao φ que a cada natural n associa
φ(n) ´e chamada de fun¸c˜ao φ de Euler, onde deﬁnimos φ(1) = 1.

Observa¸c˜ao. Podemos concluir que o n´umero de elementos de U (n) ´e dado por φ(n),

onde n > 1.

Deﬁni¸c˜ao 16. Um conjunto com n n´umeros inteiros a1, a2, ..., an ´e dito um sistema
completo de res´ıduos (s.c.r.) m´odulo n se {a1, a2, ..., an} = {0, 1, ..., n − 1}, isto ´e, se os
a(cid:48)
is representam todas as classes de congruˆencia m´odulo n.

Deﬁni¸c˜ao 17. Um conjunto com φ(n) n´umeros inteiros {b1, b2, ..., bφ(n)} ´e dito um
sistema completo de invert´ıveis (s.c.i.) m´odulo n se {b1, b2, ..., bφ(n)} = U (n) , isto ´e, se
os b(cid:48)

is representam todas as classes invert´ıveis m´odulo n.

Proposi¸c˜ao 30. Sejam k, b, n ∈ Z, n > 0 tal que (k, n) = 1. Se {a1, a2, ..., an} ´e um

s.c.r. (m´odulo n), ent˜ao {ka1 + b, ka2 + b, ..., kan + b} formam um s.c.r. (m´odulo n).

Demonstra¸c˜ao. Basta provar que se kai + b ≡ kaj + b (mod n), ent˜ao i = j, pois nesse
caso teremos n classes de congruˆencias distintas m´odulo n, que devem ser todas as classes
de Zn. Note que, como kai + b ≡ kaj + b (mod n) , teremos que kai ≡ kaj (mod n). Da´ı,
como (k, n) = 1 teremos que ai ≡ aj (mod n) donde i = j.

Proposi¸c˜ao 31. Sejam n > 1, k ∈ Z e {b1, b2, ..., bφ(n)} um sistema completo de
invert´ıveis (s.c.i.) m´odulo n. Se (k, n) = 1, ent˜ao {kb1, kb2, ..., kbφ(n)} tamb´em ser´a um
sistema completo de invert´ıveis (s.c.i).

Demonstra¸c˜ao. Para cada i = 1, 2, ..., φ(n), como (bi, n) = 1 e (k, n) = 1, temos que
(bik, n) = 1, logo bik ´e invert´ıvel. Al´em disso, supondo bik ≡ bjk (mod n), segue que
bi ≡ bj(mod n) o que implica que i = j, e portanto {qb1, qb2, ..., qbφ(n)} ´e um s.c.i. (m´odulo
n).

Proposi¸c˜ao 32. (Propriedades da fun¸c˜ao φ de Euler)

(i) p ´e primo ⇐⇒ φ(p) = p − 1.

(ii) A fun¸c˜ao φ de Euler ´e multiplicativa, isto ´e, se mdc(m, n) = 1, ent˜ao φ(mn) =

φ(m).φ(n).

24

Demonstra¸c˜ao.

(i) Se p ´e primo qualquer um dos n´umeros 1, 2, 3, ..., p − 1 ´e primo
relativo com n, portanto φ(n) = p−1. Reciprocamente, se φ(n) = p−1, o n´umero de
elementos do intervalo [1, p] que s˜ao primos relativos com p ´e p−1, ent˜ao 1, 2, 3, ..., p−
1 s˜ao primos com p, e portanto p ´e primo.

(ii) O resultado ´e trivial se m = 1 ou n = 1. Portanto, vamos supor que m > 1 e n > 1.

Considere a seguinte tabela formada pelos n´umeros naturais de 1 a m.n

1

2

n + 1

n + 2

...

...

...

...

k

n + k

...

...

...

n

2n

...

(m − 1)n + 1

(m − 1)n + 2

...

(m − 1)n + k

... m.n

Como temos que (t, m.n) = 1 se, e somente se, (t, m) = (t, n) = 1, temos que para
calcular φ(m.n), devemos encontrar dentre os inteiros da tabela acima, aqueles que
s˜ao primos simultaneamente com m e n.

Se o primeiro elemento de uma coluna qualquer n˜ao for primo com n, ent˜ao todos
os outros elementos dessa mesma coluna n˜ao ser˜ao primos com n. Portanto, os
elementos primos com n est˜ao necessariamente nas colunas que restaram, que s˜ao
em quantidade φ(n), e cujos elementos s˜ao primos com n. Agora, vamos ver quais
s˜ao os elementos primos com m em cada uma dessas colunas. Como (m, n) = 1, a
sequˆencia

k, n + k, ..., (m − 1)n + k

forma um sistema completo de res´ıduos m´odulo m (veja Proposi¸c˜ao 30), e portanto,
φ(m) desses elementos s˜ao primos com m. Logo, o n´umero de elementos simultane-
amente primos com m e n ´e φ(m).φ(n).

Proposi¸c˜ao 33. Se p ´e primo, ent˜ao φ(pr) = pr − pr−1.

Demonstra¸c˜ao. De 1 at´e pr, temos um total de pr n´umeros naturais. Para obter φ(pr)
temos que excluir, desses, os n´umeros que n˜ao s˜ao primos relativos com pr, ou seja, todos
os m´ultiplos de p, que s˜ao exatamente os n´umeros p, 2p, . . . , pr−1p, que s˜ao num total de
pr−1 n´umeros. Portanto, φ(pr) = pr − pr−1.

25

Proposi¸c˜ao 34. Seja n > 1 e n = pα1
1 − pα1−1
r − pαr−1
r

Ent˜ao φ(n) = (pα1

) · · · (pαr

1 · · · pαr
).

1

r a decomposi¸c˜ao de n em fatores primos.

Demonstra¸c˜ao. Como pα1

1 , . . . , pαr
r

s˜ao primos entre si, temos que

φ(n) = φ(pα1

1 ) · φ(pα2

2 ) · · · (pαr

r ).

Da´ı, o resultado segue da proposi¸c˜ao anterior.

Teorema 35. (Teorema de Euler) Seja n ≥ 2 um inteiro. Se a ∈ Z e (a, n) = 1

ent˜ao, aφ(n) ≡ 1 (mod n).

Demonstra¸c˜ao. Seja r1, r2, ..., rφ(n) um sistema completo de invert´ıveis(s.c.i.) m´odulo n ,
pela Proposi¸c˜ao 31, ar1, ar2, ..., arφ(n) tamb´em ´e, j´a que (a, n) = 1. Da´ı chegamos em

ar1ar2 · · · arφ(n) ≡ r1r2 · · · rφ(n) (mod n)

ou seja

aφ(n)r1r2 · · · rφ(n) ≡ r1r2 · · · rφ(n) (mod n).

Logo, temos, pelo Corol´ario 28, que

aφ(n) ≡ 1 (mod n).

Os dois corol´arios a seguir ser˜ao, assim como o Teorema anterior, de grande impor-
tˆancia para o estudo de alguns testes de primalidade e m´etodos de fatora¸c˜ao que ser˜ao
estudados nos cap´ıtulos posteriores.

Corol´ario 36. (Pequeno Teorema de Fermat) Se p ´e um n´umero primo e a ´e

um inteiro n˜ao ´e divis´ıvel por p, ent˜ao ap−1 ≡ 1 (mod p).

Demonstra¸c˜ao. Basta notar que, sendo p primo, teremos que (a, p) = 1 e φ(p) = p − 1, e
da´ı a congruˆencia ´e valida pelo Teorema de Euler.

Corol´ario 37. (Teorema de Fermat) Seja p um n´umero primo e a um n´umero

inteiro, ent˜ao ap ≡ a (mod p).

Demonstra¸c˜ao. Se (a, p) = 1, o resultado segue do corol´ario acima multiplicando ambos
os membros da congruˆencia ap−1 ≡ 1 (mod p) por a.

No caso em que (a, p) (cid:54)= 1, segue-se, como p ´e primo, que p|a, e da´ı, p|(ap − a), donde

ap ≡ a (mod p).

26

Proposi¸c˜ao 38. Sejam a, n ∈ Z, com n ≥ 2. Existe um inteiro positivo k tal que

ak ≡ 1 (mod n) se, e somente se (a, n) = 1.

Demonstra¸c˜ao. Se mdc(a, n) = 1, temos, pelo Teorema de Euler, que aφ(n) ≡ 1 (mod n),
mostrando a existˆencia do expoente desejado. Reciprocamente, suponhamos ak ≡ 1 (mod
n) para algum inteiro positivo k. Se k = 1, temos a ≡ 1 (mod n), logo existe x tal que
a − xn = 1, o que implica que mdc(a, n) = 1. Se k > 1, temos que ak = aak−1 ≡
1 (mod n) ⇐⇒ aak−1 − 1 = qn (com q inteiro) ⇐⇒ aak−1 − qn = 1, o que nos d´a,
pelo item 2 da Proposi¸c˜ao 9, que mdc(a, n) = 1.

A partir da proposi¸c˜ao acima, podemos deﬁnir a ordem do elemento a com respeito a

n.

Deﬁni¸c˜ao 18. Sejam a, n ∈ Z,com n > 1 e mdc(a, n) = 1 . A ordem de a, denotada

por on(a), ´e o menor inteiro positivo t tal que at ≡ 1 (mod n).

Proposi¸c˜ao 39. Sejam a, n, s ∈ Z,com n > 1, s ≥ 1 e mdc(a, n) = 1. Temos que

as ≡ 1 (mod n) se, e somente se, on(a)|s. Em particular on(a)|φ(n).

Demonstra¸c˜ao. Seja t = on(a)

Suponhamos que t|s . Logo s = q · t, donde,

as = aq·t = (at)q ≡ 1q = 1 (mod n).

Reciprocamente, suponhamos as ≡ 1 (mod n). Queremos provar que t|s. Pela divis˜ao
euclidiana podemos escrever que s = tq + r, onde 0 ≤ r < t. Suponhamos por absurdo
que r (cid:54)= 0. Ent˜ao,

1 ≡ as ≡ atq+r ≡ (at)qar ≡ ar,

o que ´e um absurdo, pois 0 < r < t e on(a) = t. Portanto devemos ter r = 0, o que
signiﬁca que t|s.

27

3 Fatora¸c˜ao

Neste cap´ıtulo, come¸caremos com o Crivo de Erat´ostenes, que ´e o mais antigo m´etodo
para se encontrar n´umeros primos e logo depois vamos para o Teorema Fundamental da
Aritm´etica, fazendo uma prova algor´ıtmica da existˆencia da fatora¸c˜ao e assim j´a teremos
um m´etodo para encontrar os fatores primos de um n´umero natural n. Esse m´etodo ´e
conhecido como Algoritmo Usual de Fatora¸c˜ao. A partir da´ı, estudaremos o algoritmo de
Fermat.

1 Crivo de Erat´ostenes

Proposi¸c˜ao 40. O menor divisor, maior do que 1, de qualquer n´umero inteiro n (cid:54)= 0

´e necessariamente primo.

Demonstra¸c˜ao. Seja p o menor inteiro, maior do que 1, tal que p|n. Suponhamos d > 1
tal que d|p. Da´ı, temos que d ≤ p e d|n, logo d = p. Portanto p ´e primo.

Proposi¸c˜ao 41. Seja n um n´umero natural. Se n ´e composto, ent˜ao seu menor fator,

maior do que 1, ´e necessariamente menor ou igual a

n.

√

Demonstra¸c˜ao. Seja f > 1 o menor fator de n. Segue que existe um natural a tal que
n = f ·a. Como f ´e o menor fator de n, temos que f ≤ a. Multiplicando esta desigualdade
por f , temos f 2 ≤ f · a, f 2 ≤ n. Portanto f ≤

n.

√

O crivo de Erat´ostenes ´e o mais antigo dos m´etodos para achar primos. Esse m´etodo
n˜ao envolve nenhuma f´ormula expl´ıcita, mas funciona como uma peneira de n´umeros
primos. Nicˆomaco em sua Aritm´etica, publicada por volta de 100 d.C., introduz o crivo
de Erat´ostenes da seguinte forma:

“O m´etodo para obtˆe-los[os n´umeros primos] ´e chamado por Erat´ostenes
uma peneira, porque tomamos os n´umeros ´ımpares misturados de maneira in-

28

discriminada e, por esse m´etodo, como se fosse pelo uso de um instrumento
ou peneira, separamos os primos ou indecompon´ıveis dos secund´arios ou com-
postos”.

O que signiﬁca que o crivo funciona como uma peneira que s´o deixa os n´umeros primos.
Vejamos como proceder para encontrar primos utilizando esse m´etodo.

Primeiramente escolhemos um inteiro positivo n. Listamos todos os n´umeros ´ımpares
de 3 a n, j´a que o ´unico primo par ´e o n´umero 2. Agora vamos aplicar o crivo na
lista de n´umeros obtida. O primeiro n´umero da nossa lista ´e 3, que ´e primo; riscamos,
contando de 3 em 3, todos m´ultiplos de 3 que fazem parte da lista, pois esses n˜ao ser˜ao
primos. Em seguida procuramos o primeiro elemento da lista, maior que 3, que n˜ao foi
riscado; que nesse caso ´e 5. Procedemos da mesma maneira que ﬁzemos para o n´umero
3, riscando, contando de 5 em 5, todos os m´ultiplos de 5, pois os mesmos s˜ao compostos.
E prosseguimos assim, at´e chegar a n.

Por exemplo, se n = 39, a lista de n´umeros ser´a

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39.

Ap´os a primeira passagem do crivo (de 3 em 3), ﬁcamos com

3 5 7 (cid:54) 9 11 13 (cid:54) 15 17 19 (cid:54) 21 23 25 (cid:54) 27 29 31 (cid:54) 33 35 37 (cid:54) 39.

Ap´os a segunda passagem (de 5 em 5), teremos

3 5 7 (cid:54) 9 11 13 (cid:54) 15 17 19 (cid:54) 21 23 (cid:54) 25 (cid:54) 27 29 31 (cid:54) 33 (cid:54) 35 37 (cid:54) 39.

Ap´os a terceira passagem do crivo (de 7 em 7), a lista continuar´a a mesma. E novamente,
na quarta passagem, que seria de 11 em 11, nada mudaria na lista. Isso, na verdade, vai
ocorrer para todas as seguintes passagens do crivo, o que signiﬁca que, al´em do 2 que n˜ao
inclu´ımos na lista, os n´umeros primos menores que 39 s˜ao

3 5 7 11 13 17 19 23 29 31 37.

Atrav´es do exemplo anterior podemos observar algumas caracter´ısticas importantes do
crivo de Erast´otenes. Primeiramente a quest˜ao de que alguns n´umeros s˜ao riscados da
lista em mais de uma passagem, como foi o caso do 15. Al´em disso, podemos observar
que para o exemplo acima, na segunda passagem, j´a haviamos riscado todos os n´umeros
compostos da lista e as passagens posteriores seriam redundantes, isto ´e, o crivo poderia
parar ainda na segunda passagem.

29

A segunda observa¸c˜ao nos indica que possivelmente podemos parar de riscar os n´ume-
ros muito antes de se chegar a n. De fato, se m ´e um inteiro da lista, temos que m ≤ n.
n.
Se m for composto, ele ter´a um fator menor ou igual a
Portanto, qualquer n´umero composto da lista ter´a um fator menor ou igual a
n. As-
sim podemos parar de riscar n´umeros de r em r quando r >
n. No exemplo anterior
√
39] = 6; por esse motivo foi suﬁciente riscar de 3 em 3 e de 5 em 5 para obter todos os
[
primos da lista.

m. No entanto,

m ≤
√

√

√

√

√

Sobre a primeira observa¸c˜ao, n˜ao conseguimos evitar completamente que alguns n´u-
meros sejam riscados v´arias vezes, mas podemos melhorar um pouco o crivo. Vamos dizer
que queremos encontrar primos at´e n, e que vamos riscar os n´umeros de p em p para um
certo primo p. Claramente, todos os m´ultiplos de p que tamb´em s˜ao m´ultiplos de primos
menores que p j´a foram riscados da lista. Portanto, nessa etapa, podemos come¸car a riscar
de p em p a partir do menor m´ultiplo de p que n˜ao seja m´ultiplo de um primo menor que
p, ou seja, a partir de p2. De fato, se s < p, tomando o n´umero s.p, m´ultiplo de p, temos
que s.p tamb´em ´e m´ultiplo de s. Como supomos que s < p, esse n´umero j´a ter´a sido
riscado com os m´ultiplos de s. Ent˜ao, o menor m´ultiplo de p que n˜ao ser´a m´ultiplo de
outro primo menor que p ´e p2. Logo, para evitar algumas duplica¸c˜oes e assim tornar o
crivo um pouco mais econˆomico, podemos riscar de p em p a come¸car de p2.

Digamos que escolhemos um inteiro positivo n e que queremos determinar todos os
primos menores ou iguais a n. Para isso vamos criar uma lista com todos os n´umeros
´ımpares de 3 a n, o que nos dar´a uma lista com (n − 1)/2 n´umeros. A posi¸c˜ao j, ´e a
posi¸c˜ao do j-´esimo n´umero ´ımpar positivo, que ´e 2j + 1. Por exemplo, o primeiro n´umero
´e 3 = 2.1 + 1, na posi¸c˜ao 2 est´a o n´umero 2.2 + 1 = 5 e assim por diante. Obtemos assim,
o seguinte algoritmo:

Crivo de Erast´otenes

Entrada: inteiro positivo ´ımpar n.

Sa´ıda: lista de primos ´ımpares ≤ n.

Etapa 1:Comece criando uma lista com (n − 1)/2 posi¸c˜oes, cada uma das quais deve

ter um n´umero de 3 a n; e tome p = 3.

Etapa 2: Se p2 > n escreva todos os n´umeros menores que n que n˜ao foram riscados

e pare; sen˜ao v´a para a Etapa 3.

Etapa 3: Se o n´umero que est´a na posi¸c˜ao (p − 1)/2 foi riscado, incremente p de 2

unidades e volte `a Etapa 2; sen˜ao v´a para a Etapa 4.

30

Etapa 4: Atribua o valor de p2 a uma nova vari´avel T : Risque o n´umero da posi¸c˜ao
(T − 1)/2 da lista e incremente T de 2p, at´e que T > n; quando isto acontecer incremente
p de 2 unidades e volte `a Etapa 2.

Observe que na ´ultima Etapa incrementamos T de 2p, e n˜ao de p, como esper´avamos.
Mas, lembremos que s´o estamos listando os n´umeros ´ımpares. Se T e p s˜ao ´ımpares, ent˜ao
T + p ´e par. Portanto, quando estamos riscando de p em p,o pr´oximo ´ımpar a ser riscado
depois de T , ´e T + 2p.

Para entender melhor o funcionamento do crivo, vamos fazer outro exemplo.

Se n = 55, a lista de n´umeros ser´a

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55.

Na primeira passagem do crivo, tomamos o n´umero p = 3. Vamos direto para a Etapa
4. Ent˜ao riscamos o n´umero 9 e vamos aumentando de 6 em 6 at´e que obtenhamos um
n´umero maior que 55, que nesse caso ser´a 51 + 6 = 57 e obtemos a seguinte lista

3 5 7 (cid:54) 9 11 13 (cid:54) 15 17 19 (cid:54) 21 23 25 (cid:54) 27 29 31 (cid:54) 33 35 37 (cid:54) 39 41 43 (cid:54) 45 47 49 (cid:54) 51 53 55.

Agora voltamos para a Etapa 2, com p = 5. Novamente vamos direto para a Etapa 4.
Ent˜ao vamos para o n´umero 25 e aumentaremos de 10 em 10 at´e chegar num n´umero
maior que 55. Ent˜ao riscaremos 35, 45 e 55 e chegaremos na seguinte lista

3 5 7 (cid:54) 9 11 13 (cid:54) 15 17 19 (cid:54) 21 23 (cid:54) 25 (cid:54) 27 29 31 (cid:54) 33 (cid:54) 35 37 (cid:54) 39 41 43 (cid:54) 45 47 49 (cid:54) 51 53 (cid:54) 55.

Agora, voltamos para a Etapa 2, com p = 7. Mais uma vez vamos direto para a Etapa 4.
Vamos para o n´umero 49, que ser´a o ´unico a ser riscado nessa passagem. Da´ı chegaremos
`a lista

3 5 7 (cid:54) 9 11 13 (cid:54) 15 17 19 (cid:54) 21 23 (cid:54) 25 (cid:54) 27 29 31 (cid:54) 33 (cid:54) 35 37 (cid:54) 39 41 43 (cid:54) 45 47 (cid:54) 49 (cid:54) 51 53 (cid:54) 55.

Nessa passagem, voltaremos para a Etapa 2, com p = 11, pois 9 j´a est´a riscado, mas
112 > 55, ent˜ao n˜ao temos mais n´umeros a riscar e agora ´e s´o copiar os n´umeros que n˜ao
foram riscados que ser˜ao os primos ´ımpares menores que n. Nesse caso esses n´umeros s˜ao

3 5 7 11 13 17 19 23 29 31 37 41 43 47 53.

31

2 Teorema Fundamental da Aritm´etica

Teorema 42. (Teorema Fundamental da Aritm´etica)Dado um inteiro n ≥ 2

podemos sempre escrevˆe-lo de modo ´unico, na forma

n = p1

e1 · · · pk

ek,

onde 1 < p1 < p2 < p3 < . . . < pk s˜ao n´umeros primos e e1, . . . , ek s˜ao inteiros positivos.

2.1 Algoritmo Usual de Fatora¸c˜ao

Dado um n´umero inteiro n ≥ 2, vamos procurar os divisores de n, maiores do que 1.
Se d > 1 e d|n ent˜ao d ≤ n. Se n for composto, o menor fator de n ´e primo e al´em disso
´e menor do que ou igual a [

n].

√

Assim, come¸camos dividindo n por cada n´umero de 2 a [

n]. Se nenhum deles for

√

fator de n, ent˜ao n ´e primo.

Caso contr´ario, tomamos o menor fator de n, encontrado de 2 a [

√

n]. Indicando este

menor fator por q1, temos que q1 ´e primo e n = q1 · n1.

Agora repetimos o procedimento para o n´umero n1, determinando assim um segundo
fator primo de n que chamaremos de q2, assim n = q1 · n1 = q1 · q2 · n2, onde q1 ≤ q2,
podendo ocorrer o caso q1 = q2, e n1 > n2.

Continuando o processo, teremos uma sequˆencia de n´umeros primos

cada um fator de n. A esta sequˆencia corresponde uma outra, formada pelos cofatores

q1 ≤ q2 ≤ . . . ≤ qi ≤ . . .

n > n1 > n2 > . . . > 0

Esta ´ultima sequˆencia ´e estritamente decrescente de n´umeros inteiros positivos. Como
h´a apenas n − 1 inteiros positivos entre n e 0, o processo vai parar depois de no m´aximo
n passos e da´ı obtemos

n = q1 · q2 · · · qs

O algoritmo na primeira etapa do procedimento acima pode ser descrito do seguinte

modo:

32

Algoritmo de fatora¸c˜ao

Entrada: inteiro positivo n

Sa´ıda: Inteiro positivo f que ´e o menor fator primo de n ou uma mensagem indicando

que n ´e primo.

Etapa 1: Comece fazendo f = 2.

Etapa 2: Se n/f ´e inteiro escreva f ´e fator de n e pare; sen˜ao v´a para a Etapa 3.

Etapa 3: Agora v´a para o pr´oximo primo depois de f e v´a para a etapa 4.

Etapa 4: Se F >

√

n escreva n ´e primo e pare; sen˜ao volte `a Etapa 2.

Dessa maneira, dado um inteiro n conseguimos determinar atrav´es do algoritmo se n ´e
primo ou composto, e no segundo caso, achar um fator de n. Se n for primo, j´a temos sua
fatora¸c˜ao. Agora, caso n seja composto, devemos encontrar todos os seus fatores primos
com suas multiplicidades. Para tal objetivo, aplicamos o algoritmo acima sucessivamente
at´e obter um n´umero que n˜ao pode mais ser decomposto, ou seja, primo.

Exemplo 3. Vamos fatorar o n´umero 429, utilizando o algoritmo usual da fatora¸c˜ao.
Primeiramente, vamos tomar f = 2. Mas 429 = 214 · 2 + 1, isto ´e, 2 (cid:54) |429. Ent˜ao, vamos
tomar f como sendo o pr´oximo primo depois de 2, que ´e o n´umero 3. Teremos que 429 = 3·
143, ent˜ao 3 ´e o menor fator de 429. Mas, ainda n˜ao sabemos se fatoramos completamente
o n´umero 429, pois apenas encontramos seu menor fator. Agora, vamos aplicar novamente
o algoritmo no n´umero 143. Prosseguindo, vemos que 143 n˜ao ´e divis´ıvel 5 e nem por 7,
mas 11|143 = 11 · 13. Assim, os fatores de 143 s˜ao 11 e 13 e portanto 429 = 3 · 11 · 13

Exemplo 4. Vamos considerar o n´umero 173 e tentar fator´a-lo usando o Algoritmo
Usual da fatora¸c˜ao. Fazendo as divis˜oes, veremos que 173 n˜ao ´e divis´ıvel por 2, 3, 5, 7, 11
173, conclu´ımos que 173
e nem por 13, e como 17 que ´e o pr´oximo primo ´e maior que
´e primo.

√

√

Esse algoritmo ´e simples, mas n˜ao ´e eﬁciente se estivermos trabalhando com n´umeros
muito grandes. Por exemplo, seja n um n´umero primo com 100 ou mais algarismos. Logo,
n ≥ 1050. Logo ser˜ao necess´arios 1050 la¸cos para determinar que
n ≥ 10100 e portanto
1050
n ´e primo. Se o computador executa 1010 divis˜oes por segundo, levaremos
1010 = 1040
segundos, ou seja 1031 anos, sendo que o tempo estimado de existˆencia do universo ´e
de 2 · 1011 anos. Portanto, se um n´umero ´ımpar ´e muito grande pode ser imposs´ıvel
determinar se ele ´e primo ou n˜ao utilizando esse algoritmo.

33

Por outro lado, se vamos fatorar um inteiro, h´a sempre a possibilidade que tenha um

fator primo pequeno e o algoritmo acima encontrar´a tal fator rapidamente.

Existem outros m´etodos de fatora¸c˜ao, alguns dos quais estudaremos neste trabalho.
A eﬁciˆencia destes algoritmos depende do tipo de fator que tem o n´umero a ser fatorado.
N˜ao existe um algoritmo de fatora¸c˜ao que funcione bem para todo n´umero inteiro.

Apresentaremos agora o m´etodo de Fermat, que acha rapidamente fatores pr´oximos

`a raiz quadrada do n´umero a se fatorado.

3 Algoritmo de Fermat

Proposi¸c˜ao 43. Se n > 1 ´e um inteiro n´umero ´ımpar e n˜ao ´e um quadrado, ent˜ao

existem naturais x e y com [

n] ≤ x <

tais que n = x2 − y2.

√

n + 1
2

Demonstra¸c˜ao. Suponha n um primo composto ´ımpar e n˜ao quadrado, isto ´e, n = a · b
com 1 < a < b < n, com a e b ´ımpares. Para se ter n = x2 − y2 = (x − y) · (x + y) tomamos
a = x − y e b = x + y.

Da´ı, obtemos n´umeros naturais x =

a + b
2

e y =

b − a
2

.

De fato, expandindo os produtos not´aveis

(cid:19)2

(cid:18) a + b
2

(cid:19)2

−

(cid:18) a − b
2

= a · b = n.

Como

n + 1
2

x <

⇐⇒ a+b < n+1 ⇐⇒ a+b < a·b+1 ⇐⇒ a−1 < a·b−b ⇐⇒ a−1 < b·(a−1)

x <

n + 1
2

⇐⇒ a − 1 < b · (a − 1) ⇐⇒ 1 < b

temos que x <

n + 1
2

.

Al´em disso, temos que

√

n] ≤

[

√

n =

(cid:112)

x2 − y2 ≤

√

x2 = x.

34

Proposi¸c˜ao 44. Se n > 1 ´e um primo ´ımpar e n = x2 − y2, com x, y ∈ N, ent˜ao
n + 1
2

n − 1
2

e y =

.

x =

Demonstra¸c˜ao. Suponha n um primo ´ımpar e n = x2 −y2 = (x−y)·(x+y), com x, y ∈ N.
n − 1
2

Como n ´e primo, segue que x − y = 1 e x + y = n, donde obtemos x =

1 + n
2

e y =

.

As proposi¸c˜oes acima nos fornecem um algoritmo, que ´e muito eﬁciente quando n tem
√
n.

um fator primo que n˜ao ´e muito menor que

Para come¸car vamos supor que n ´e ´ımpar, j´a que se n for par, 2 ser´a um de seus
fatores. A id´eia do algoritmo de Fermat ´e tentar achar n´umeros inteiros positivos x e y
tais que n = x2 − y2. Se encontrarmos esses n´umeros, teremos que

n = x2 − y2 = (x + y).(x − y).

Precisamos considerar separadamente o que acontece na situa¸c˜ao em que n ´e com-

posto e na situa¸c˜ao em que n ´e primo.

Se n ´e primo, a ´unica possibilidade ´e x =

(n + 1)
2

e y =

(n − 1)
2

.
√

Se n ´e um quadrado perfeito teremos n = x2 − 02 e assim x =

n e y = 0.

Portanto, vamos supor que n seja um n´umero ´ımpar composto que n˜ao seja um qua-

drado perfeito. Nesse caso, existem naturais x e y com [
n = x2 − y2 e s´o precisamos encontr´a-los.

√

n] ≤ x <

tais que

n + 1
2

√

Como y =

x2 − n, come¸camos fazendo x = [

√

n], vamos incrementando 1 `a vari´avel

x e calculando o respectivo valor y.

Este procedimento para, antes de x =

n + 1
2

, quando obteremos y natural.

Observe, no exemplo a seguir, como utilizar essa estrat´egia para encontrar fatores de

um n´umero inteiro n.

35

Exemplo 5. Seja n = 5959.

Iniciamos nossa tentativa com a raiz quadrada de
n] = 77. Mas
5959, mas como a raiz quadrada n˜ao ´e exata, come¸caremos com x = [
x2 = 772 = 5929 < 5959. Ent˜ao agora vamos passar a incrementar x de uma unidade at´e

√

√

x2 − n seja inteiro, ou x seja igual a

que
resumir o processo em uma tabela:

que nesse caso ´e igual a 2980. Vamos

(n + 1)
2

√

x2 − n

11, 18

16, 79

21

x

78

79

80

Observe que quando x = 80, obtemos um valor inteiro para

x2 − n que nesse caso ´e
21. Portanto x = 80 e y = 21 s˜ao os valores que queremos e os fatores correspondentes
de n s˜ao x + y = 101 e x − y = 59.

√

√

x = [

Exemplo 6. Seja n = 1197397 o n´umero que queremos fatorar.

Iniciamos com
n] = 1094. Mas x2 = 10942 = 1196836 < 1197397. Ent˜ao agora vamos passar
(n + 1)
2

a incrementar x de uma unidade at´e que
que nesse caso ´e igual a 598699. Vamos resumir o processo em uma tabela:

x2 − n seja inteiro, ou x seja igual a

√

√

x2 − n

x

1095

40, 34

1096

61, 79

1097

77, 53

1098

90, 59

1099

102

Observe que obtemos um inteiro no quinto la¸co. Portanto x = 1099 e y = 102 s˜ao os
valores que queremos e os fatores correspondentes de n s˜ao x + y = 1201 e x − y = 997.

36

Exemplo 7. Como vimos, quando o n´umero for primo, o algoritmo s´o p´ara quando
n + 1
2

x =
n] = 6.
. Vamos veriﬁcar o que acontece para n = 41. Iniciamos com x = [
Mas x2 = 62 = 36 < 41. Ent˜ao agora vamos passar a incrementar x de uma unidade

√

x2 − n seja inteiro, ou x seja igual a

at´e que
Construindo uma tabela como a do exemplo anterior, observe o que ocorre:

que nesse caso ´e igual a 21.

(n + 1)
2

√

√

x2 − n

2, 82

4, 79

6, 32

7, 68

8, 94

10, 14

11, 31

12, 44

13, 56

14, 66

15, 74

16, 82

17, 88

18, 94

20

x

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

Conseguimos, facilmente, descobrir que 41 ´e primo usando o algoritmo usual de fa-
tora¸c˜ao, mas aqui mostramos que quando n ´e primo o algoritmo n˜ao para at´e que x seja

(n + 1)
igual a
2
x + y = 41 e x − y = 1.

que nesse caso ´e 21. O que nos d´a que 41 ´e primo e que seus fatores s˜ao

37

O algoritmo de Fermat pode ser descrito do seguinte modo:

Algoritmo de Fermat

Entrada: inteiro positivo n.

Sa´ıda: um fator de n ou uma mensagem indicando que n ´e primo.

Etapa 1: Comece com x = [

n]; se n = x2 ent˜ao x ´e fator de n e podemos parar.

√

Etapa 2: Caso contr´ario incremente x de uma unidade e calcule y =

√

x2 − n.

Etapa 3: Repita a Etapa 2 at´e encontrar um valor inteiro para y, ou at´e que x seja

igual a (n+1)/2; no primeiro caso n tem fatores x + y e x − y, no segundo n ´e primo.

38

4 Testes de primalidade e
m´etodos de fatora¸c˜ao

1 Pseudoprimos

1.1 Pseudoprimos

O Pequeno Teorema de Fermat nos fornece um teste de n˜ao primalidade, isto ´e, que
nos permite determinar se um n´umero ´e composto, sem precisar descobrir seus fatores. O
teste pode ser escrito da seguinte forma:

Teste: Se n > 0 e 1 < b < n − 1 s˜ao n´umeros inteiros e bn−1 (cid:54)≡ 1 (mod n), ent˜ao
n ´e um n´umero composto. O n´umero b ´e conhecido como uma testemunha de que n ´e
composto.

Exemplo 8. Consideremos n = 2049. Queremos saber se ´e um n´umero primo. Va-
mos calcular 22048 m´odulo 2049. Com c´alculos simples, utilizando as propriedades de
congruˆencia obtemos que 211 = 2048 ≡ −1 (mod 2049). Como 2048 = 11 · 186 + 2, segue
que 22048 = (211)186 · 22 ≡ 4 (mod 2049). Assim

22048 ≡ 4 (cid:54)= 1 (mod 2049).

Portanto 2049 ´e composto.

A rec´ıproca do pequeno teorema de Fermat n˜ao ´e verdadeira. De fato, temos, por
exemplo, que 2340 ≡ 1 (mod 341) e 341(31 · 11) ´e composto. Muitos matem´aticos usaram
a rec´ıproca como verdadeira, tanto que Leibniz, famoso pela inven¸c˜ao do c´alculo, usou isto
como um crit´erio de primalidade. Estes ‘falsos primos’ s˜ao conhecidos como pseudoprimos.

Deﬁni¸c˜ao 19. Um n´umero positivo n, ´ımpar e composto, ´e um pseudoprimo para a

base b, com 1 < b < n − 1, quando bn−1 ≡ 1 (mod n).

39

Exemplo 9. O n´umero 341 ´e um pseudoprimo para a base 2.

Observa¸c˜ao. Como vimos, o teste utilizado por Leibniz `as vezes pode dar errado,
mas esse teste n˜ao deixa de ser eﬁciente. Para n´umeros pequenos, ele mais acerta do que
erra. Por exemplo, entre 1 e 109 temos 50847534 primos e apenas 5597 pseudoprimos para
a base 2. Logo se tomarmos um n´umero inteiro ´ımpar menor que um milh˜ao e este passar
no teste de Leibniz, tem-se uma grande probabilidade desse n´umero ser primo.

Podemos melhorar o teste usado por Leibniz utilizando outras bases diferentes de 2.
Por exemplo, 3340 ≡ 56 (mod 341). Logo 3 ´e testemunha de que 341 ´e composto. Para as
bases 2 e 3, existem apenas 1272 pseudoprimos entre 1 e 109.

Podemos observar que se o n´umero inteiro ´ımpar n ´e muito grande, testar todas as
bases no intervalo de 1 a n − 1 se torna invi´avel no ponto de vista pr´atico. No entanto
esse problema nos levar´a a algumas quest˜oes de interesse pr´atico.

1.2 N´umeros de Carmichael

Proposi¸c˜ao 45. Seja n um n´umero inteiro composto e b > 1 um n´umero inteiro. Se

b|n, ent˜ao n n˜ao ser´a pseudoprimo para a base b.

Demonstra¸c˜ao. Como mdc(b, n) = b (cid:54)= 1, teremos (pela Proposi¸c˜ao 29) que b n˜ao ´e
invers´ıvel m´odulo n, donde bn−1 (cid:54)≡ 1 (mod n).

Pela proposi¸c˜ao acima, vemos que n˜ao h´a n´umeros que sejam pseudoprimos para todas
as bases. Mas, um n´umero composto n pode ser pseudoprimo para todas as bases que s˜ao
primas a n.

Deﬁni¸c˜ao 20. (N´umeros de Carmichael) Um n´umero composto n > 0 ´e um
n´umero de Carmichael quando bn ≡ b (mod n) para todo 1 < b < n − 1. Neste caso, se
(b, n) = 1, teremos bn−1 ≡ 1 (mod n).

O menor n´umero de Carmichael ´e 561, mas para chegar `a essa conclus˜ao, utilizando
a deﬁni¸c˜ao, ter´ıamos que veriﬁcar que b561 ≡ b (mod 561) para b = 2, 3, 4, ..., 559, isto
´e, um total de 558 bases. Existem inﬁnitos n´umeros de Carmichael, e isso signiﬁca que
esses n´umeros podem ser t˜ao grandes que at´e mesmo um computador ter´a diﬁculdade de
veriﬁcar, utilizando a deﬁni¸c˜ao, se o mesmo ´e um n´umero de Carmichael. Por exemplo, o
n´umero 349407515342287435050603204719587201 ´e um n´umero de Carmichael.

Existe uma maneira mais f´acil de se veriﬁcar se um certo n´umero composto ´e um

n´umero de Carmichael. Esse m´etodo ´e baseado no seguinte teorema:

Teorema 46. (Teorema de Korselt) Um inteiro positivo ´ımpar n ´e um n´umero

de Carmichael se cada fator primo p de n satisfaz as duas condi¸c˜oes seguintes:

40

(1) p2 n˜ao divide n;

(2) p − 1 divide n − 1.

Demonstra¸c˜ao. Nosso objetivo ´e mostrar que se n satisfaz as condi¸c˜oes (1) e (2), ent˜ao
bn ≡ b (mod n) para todo 1 < b < n − 1, isto ´e, que n divide bn − b.

Como a condi¸c˜ao (1) equivale a dizer que n n˜ao tem fatores primos repetidos, pelo
item ii) da Proposi¸c˜ao 18, basta mostrar que cada fator primo de n divide bn − b. Ent˜ao,
seja p um fator primo de n, vamos mostrar que

bn ≡ b (mod p).

Se b ´e divis´ıvel por p, ent˜ao bn e b s˜ao congruentes a zero m´odulo p e a congruˆencia
´e imediatamente veriﬁcada. Ent˜ao, vamos considerar que p n˜ao divide b. Da´ı, o pequeno
Teorema de Fermat nos garante que bp−1 ≡ 1 (mod p). Pela condi¸c˜ao (2), p − 1 divide
n − 1, isto signiﬁca que n − 1 = (p − 1)q, para algum inteiro q. Donde segue que

n = (n − 1)q + 1.

Assim

bn ≡ (bp−1)q · b ≡ 1 · b ≡ b (mod p).

Logo bn ≡ b (mod p) para qualquer fator primo p de n. Portanto, se n = p1...pk
onde p1 < ... < pk s˜ao primos distintos, teremos que bn ≡ b (mod p1 · · · pk), ou seja,bn ≡
b (mod n).

Pelo teorema acima, vemos que um n´umero inteiro n ´e um n´umero de Carmichael
se ele n˜ao tem fatores primos repetidos e se cada um de seus fatores diminu´ıdo de uma
unidade divide n diminu´ıdo de uma unidade.

Exemplo 10. Consideremos o n´umero 561. Esse n´umero pode ser facilmente fatorado

561 = 3 · 11 · 17.

Note que os fatores de 561 s˜ao todos distintos e 3 − 1 = 2, 11 − 1 = 10 e 17 − 1 = 16
dividem 561 − 1 = 560. Portanto 561 ´e um n´umero de Carmichael.

41

2 Teste de Miller

A existˆencia dos n´umeros de Carmichael pode nos fazer tomar v´arias bases que satisfa-
zem a equa¸c˜ao bn ≡ b (mod n) e mesmo assim, n n˜ao ser primo. Isso pode diﬁcultar muito
o nosso trabalho em concluir se o n´umero estudado ´e primo ou composto utilizando o teste
fornecido no in´ıcio da se¸c˜ao anterior. O teste pode ser melhorado com uma modiﬁca¸c˜ao
simples. Este novo teste foi introduzido em 1976 por G.L.Miller.

Proposi¸c˜ao 47. (Teste de Miller) Sejam n (cid:54)= 2 um n´umero primo e 1 < b < n−1.

Escrevendo n − 1 = 2k · q com k ≥ 1 e q ´ımpar. Ent˜ao pelo menos uma das potˆencias

bq, b2q, ..., b2k−1·q

deve ser congruente a −1 m´odulo n ou bq ≡ 1 (mod n).

Demonstra¸c˜ao. Considere a sequˆencia

Como n ´e primo temos que

bq, b2q, ..., b2k−1·q, b2k·q.

bn−1 ≡ b2k·q ≡ 1 (mod n).

Considere j ≥ 0 o menor expoente de 2 tal que b2j ·q ≡ 1 (mod n). Temos dois casos

a considerar, j = 0 ou 1 ≤ j ≤ k.

No caso em que j = 0 obtemos bq ≡ 1 (mod n).

Suponhamos ent˜ao 1 ≤ j ≤ k. Assim b2j ·q ≡ 1 (mod n), ou equivalentemente,

n|b2j ·q − 1 = (b2j−1q)2 − 1 = (b2j−1·q + 1).(b2j−1·q − 1).

Como n ´e primo e n (cid:54) |b2j−1·q − 1(j ´e o menor expoente tal que n|b2j ·q − 1), conclu´ımos

que n|b2j−1·q + 1, isto ´e, b2j−1·q ≡ −1 (mod n) com 0 ≤ j − 1 ≤ k − 1.

Portanto, um dos termos da sequˆencia bq, b2q, ..., b2k−1·q ´e congruente a −1 m´odulo

n.

42

Devemos tomar cuidado, pois a rec´ıproca n˜ao ´e verdadeira, como ser´a mostrado num

exemplo dessa se¸c˜ao.

Esta proposi¸c˜ao s´o nos permite concluir que, se nada disso ocorre, ent˜ao n ´e composto.

Observe, no exemplo a seguir, como utilizar essa estrat´egia para veriﬁcar se um n´umero

inteiro n ´e composto.

Exemplo 11. Vimos que, atrav´es do teste da se¸c˜ao anterior n˜ao conseguimos detectar
que 341 ´e composto usando apenas 2 como base. Agora vamos aplicar o teste de Miller
para 341. Primeiramente, veriﬁquemos que 341 − 1 = 340 = 22 · 85. Ent˜ao vamos calcular
as potˆencias de 2 m´odulo 341 para os expoentes 20 · 85 = 85 e 21 · 85 = 170. Teremos que

e

285 ≡ 32 (cid:54)≡ 1 (mod 341)

285 ≡ 32 (cid:54)≡ −1 (mod 341)

2170 = (285)2 ≡ 322 ≡ 1 (cid:54)≡ −1 (mod 341).

Portanto 341 ´e composto.

A seguir, apresentaremos o algoritmo do teste de Miller, que tem como grande vanta-
gem sobre o teste do in´ıcio da se¸c˜ao anterior, o fato de que podemos encontrar n´umeros
compostos mesmo entre os pseudoprimos.

Teste de Miller

Entrada: um inteiro ´ımpar n, que se quer testar, e a base b, onde 1 < b < n − 1.

Sa´ıda: uma das mensagens:‘n ´e composto ou teste inconclusivo’.

Etapa 1: Divida n − 1 sucessivamente por 2 at´e encontrar q(um n´umero ´ımpar) e k

tais que n − 1 = 2k.q.

Etapa 2: Comece fazendo i = 0 e r = resto de bqpor n.

Etapa 3: Se i = 0 e r = 1 ou se i ≥ 0 e r = n − 1 a sa´ıda ´e ‘teste inconclusivo’.

Etapa 4: Incremente i de 1 unidade e substitua r pelo resto da divis˜ao de r2 por n.

Etapa 5: Se i < k volte `a Etapa 3, sen˜ao a sa´ıda ´e ‘n ´e composto’.

Quando a sa´ıda do teste for inconclusivo, n pode ser primo, ou n pode ser composto.

Mas, infelizmente, a segunda hip´otese acontece na pr´atica. Vejamos alguns exemplos:

Exemplo 12. Vamos mostrar outro exemplo interessante, o n´umero de Carmichael
561. Atrav´es do teste de Miller, chegamos a conclus˜ao que 561 ´e composto, testando
apenas para a menor base poss´ıvel, isto ´e, para base 2. De fato, com c´alculos simples
podemos veriﬁcar que 561 − 1 = 560 = 24 · 35. Calculando os restos m´odulo 561 das
potˆencias de 2 obtemos

43

235 ≡ 263 (mod 561)

22·35 = (235)2 ≡ 2632 ≡ 166 (mod 561)

222·35 = 22·(2·35) = (22·35)2 ≡ 1662 ≡ 67 (mod 561)

223·35 = 22·(22·35) = (222·35)2 ≡ 672 ≡ 1 (mod 561)

Portanto 561 tem que ser composto.

Exemplo 13. Vamos agora a um exemplo ruim. O mais simples ´e o n´umero 25.
Sabemos que 24 = 23 · 3. Tomando como base o n´umero 7, obtemos os seguintes resultados

73 ≡ 18 (mod 25)

72·3 = (73)2 ≡ 182 ≡ 24 ≡ −1 (mod 25)

Assim, o teste ´e inconclusivo para a base 7 e o expoente 2.3, embora 25 seja composto.

Entretanto se escolhessemos a base 2, chegar´ıamos facilmente que 25 ´e composto.

Deﬁni¸c˜ao 21. Quando um n´umero composto n tem resultado inconclusivo para o
teste de Miller com respeito a uma base b, dizemos que n ´e um pseudoprimo forte para a
base b. Isto signiﬁca que se pelo menos uma das potˆencias bq, b2q, ..., b2k−1·q for congruente
a −1 m´odulo n ou bq ≡ 1 (mod n) e n for composto, n ´e dito pseudoprimo forte para b.

No exemplo anterior, 25 ´e um pseudoprimo forte para a base 7.

Proposi¸c˜ao 48. Todo pseudoprimo forte para uma certa base ´e pseudoprimo para

aquela base.

Demonstra¸c˜ao. Se n ´e pseudoprimo forte para uma certa base, utilizando os elementos
deﬁnidos no in´ıcio da se¸c˜ao, teremos que bq ≡ 1 (mod n) ou alguma das potˆencias b2i·q
com i = 0, 1, ..., k − 1 (n − 1 = 2k · q, q ´ımpar), ´e congruente a −1 (mod n). Se ocorrer o
primeiro caso teremos que bq ≡ 1 (mod n). Elevando ambos os membros por 2k obtemos
b2k·q = bn−1 ≡ 1 (mod n), donde bn ≡ b (mod n) e n ´e pseudoprimo para a base b. Se o
segundo caso ocorre, teremos que b2i·q ≡ −1 (mod n) para algum 0 ≤ i ≤ k − 1. Elevando

44

ambos os membros por 2k−i, obtemos b2k·q = bn−1 ≡ 1 (mod n), donde bn ≡ b (mod n) e
novamente n ´e pseudoprimo para a base b.

Observa¸c˜ao. Como j´a foi dito, 25 n˜ao ´e um pseudoprimo forte para a base 2. O
menor pseudoprimo forte forte para a base 2 ´e o n´umero 2047. E mais, existem apenas
1282 pseudoprimos fortes entre 1 e 109, o que nos d´a uma id´eia da eﬁciˆencia do Teste de
Miller, que pode ser testado para v´arias bases.

3 Mersenne e Fermat

A melhor maneira de se encontrar n´umeros primos grandes ´e atrav´es de f´ormulas
exponenciais. Para isso, vamos utilizar aqui, os n´umeros de Fermat e Mersenne para
procurar primos entre n´umeros da forma 2n ± 1.

3.1 N´umeros de Mersenne

Proposi¸c˜ao 49. Seja n um n´umero natural maior do que 1. Se n ´e composto, ent˜ao

2n − 1 ´e composto.

Demonstra¸c˜ao. Se n = r · s,com 1 < r, s < n, temos que

2n − 1 = (2r)s − 1 e, pela proposi¸c˜ao 2, 2r − 1|2r·s − 1 = 2n − 1.

Como 2r − 1 (cid:54)= 1 e 2r − 1 (cid:54)= 2n − 1, conclu´ımos que 2n − 1 ´e composto.

Deﬁni¸c˜ao 22. (n´umeros de Mersenne). Os n´umeros de Mersenne s˜ao os n´ume-

ros da forma

M (p) = 2p − 1, onde p ´e um n´umero primo.

Observa¸c˜ao. O fato de p ser primo n˜ao nos garante que M(p) tamb´em seja. Observe

que M(11) ´e composto

M (11) = 2047 = 23 · 89.

Deﬁni¸c˜ao 23. Os n´umeros de Mersenne que s˜ao primos s˜ao conhecidos como primos

de Mersenne.

45

No intervalo 2 ≥ p ≥ 5000, os primos de Mersenne s˜ao os correspondentes aos seguin-
tes valores de p: 2, 3, 5, 7, 13, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253 e
4423. At´e hoje, o maior n´umero primo conhecido ´e o n´umero de Mersenne M (57885161),
descoberto em janeiro de 2013, e que possui, no sistema decimal, 17425170 d´ıgitos.

Vamos descrever agora, um m´etodo relativamente eﬁciente para encontrar fatores
primos para n´umeros de Mersenne n˜ao muito grandes. Esse m´etodo ´e devido `a Fermat e
utiliza uma f´ormula geral para os n´umeros primos que podem ser fatores de um n´umero
de Mersenne.

Proposi¸c˜ao 50. (M´etodo de Fermat). Seja p (cid:54)= 2 um primo e q um fator primo

de M (p). Ent˜ao q = 1 + 2rp para algum inteiro positivo r.

Demonstra¸c˜ao. Suponhamos que p (cid:54)= 2 ´e um n´umero primo e que q ´e um fator primo de
M (p) = 2p − 1. Ent˜ao

2p ≡ 1 (mod q).

O que signiﬁca que em U (q) = Zq\{0} temos a seguinte identidade

2p = 1.

Pela Proposi¸c˜ao 39, temos que oq(2) deve dividir p. Como p ´e primo e oq(2) (cid:54)= 1,
conclu´ımos que oq(2) = p. Por outro lado, como q ´e ´ımpar, temos tamb´em, pelo teorema
de Fermat

2q−1 = 1 em U (q).

Outra vez pela Proposi¸c˜ao 39, a ordem de 2, que nesse caso ´e p, divide q − 1. Isto

signiﬁca que existe um inteiro k tal que q − 1 = kp.

Podemos observar ainda, que M (p) = 2p − 1 ´e um n´umero ´ımpar e consequentemente
todo fator de M (p) ´e ´ımpar, inclusive q. Donde q − 1 ´e par. Como q − 1 ´e par e p ´e
´ımpar, o n´umero k, da f´ormula acima, deve ser obrigatoriamente par. Assim, conclu´ımos
que q − 1 = 2rp para algum inteiro r. O que equivale a dizer que q = 1 + 2rp, para algum
inteiro positivo r.

A proposi¸c˜ao nos diz que, dado um inteiro n, para aplicar o m´etodo, substituimos
o valor de n na f´ormula geral dos fatores de n e vamos substituindo valores inteiros,
come¸cando por 1, para r, at´e encontrar um q primo e que divida n. Se n˜ao encontrarmos
tal valor de q, ent˜ao n ´e primo.

Exemplo 14. Vamos usar o m´etodo de Fermat para achar um fator de M (29)

Como 29 ´e primo, segue pelo m´etodo de Fermat, que os fatores primos de 229 − 1
s˜ao da forma 1 + 2 · r · 29 = 1 + 58r. Vamos tabelar estes fatores para valores de r ≥ 1
e calcular o resto da divis˜ao de M (29) = 229 − 1 por q = 1 + 58r, quando q ´e primo.
Obtemos

46

r

1

2

3

4

q = 1 + 58r

primo ou composto?

resto de 2p − 1 por q

59

117

175

233

primo

m´ultiplo de 3

m´ultiplo de 5

primo

58

*

*

0

Logo 233 ´e o menor fator primo de M (29)

3.2 N´umeros de Fermat

Proposi¸c˜ao 51. Se 2n + 1 ´e primo, ent˜ao n = 2m, com m > 0.

Demonstra¸c˜ao. Suponhamos que exista p (cid:54)= 2 tal que p|n. Segue que n = p · n(cid:48) com
n(cid:48) (cid:54)= n. Como p ´e ´ımpar, temos, pela Proposi¸c˜ao 3 do Cap´ıtulo 1, que

2n(cid:48) + 1|2p·n(cid:48) + 1 = 2n + 1.

com 2n(cid:48) + 1 (cid:54)= 1 e 2n(cid:48) + 1 (cid:54)= 2n + 1. O que ´e uma contradi¸c˜ao, pois por hip´otese 2n + 1 ´e
primo. Portanto n n˜ao possui fatores primos diferentes de 2, isto ´e, n = 2m(m > 0).

Deﬁni¸c˜ao 24. Um n´umero inteiro positivo ´e dito um n´umero de Fermat quando esse

n´umero ´e da forma

Fn = 22n + 1, n = 0, 1, 2, ...

Em 1640, Fermat sugeriu que estes n´umeros fossem sempre primos. ´E verdade que
os n´umeros Fk ´e sempre primo quando k varia de 0 a 4. De fato, F0 = 1, F1 = 5, F2 =
17, F3 = 257 e F4 = 65537. Por´em, F5 ´e composto.
Isso foi provado, em 1732, pelo
matem´atico sui¸co Leonhard Euler, utilizando um m´etodo baseado no m´etodo da se¸c˜ao
anterior, inventado pelo pr´oprio Fermat.

47

Deﬁni¸c˜ao 25. Os n´umeros de Fermat que s˜ao primos s˜ao conhecidos como primos

de Fermat.

Vamos enunciar agora o m´etodo utilizado por Euler para encontrar um fator primo

de um n´umero de Fermat, encontrando a f´ormula geral desse fator.

Proposi¸c˜ao 52. (M´etodo de Euler) Se q ´e um fator primo de Fk ent˜ao existe um

n´umero inteiro positivo r tal que q = 1 + 2k+1r.

Demonstra¸c˜ao. Digamos que q ´e um fator primo de Fk. Ent˜ao

22k

= −1 em U (q).

Donde, 22k·2 = 22k+1
= 1 em U (q). Da´ı, pela Proposi¸c˜ao 39, teremos que a ordem de
2 divide 2k+1; mas como 22k
= −1 em U (q), temos tamb´em que a ordem n˜ao pode ser
uma potˆencia menor que 2k+1. Logo a ordem de 2 em U (q) ´e exatamente 2k+1. Mas, o
teorema de Fermat nos garante que a ordem de 2 divide q − 1, donde q − 1 = 2k+1r, isto
´e, q = 1 + 2k+1r para um n´umero inteiro positivo r.

Para aplicar esse m´etodo para descobrir se um determinado n´umero n ´e primo ou
composto, e no segundo caso encontrar um fator de n, basta substituirmos o valor de n na
f´ormula geral dos seus fatores e depois substituir valores inteiros, come¸cando por 1, para
r, at´e encontar um q primo e que divida n. Se n˜ao encontrarmos tal valor de q, ent˜ao n
´e primo.

Exemplo 15. Vejamos como utilizar o m´etodo de Euler para encontrar um fator de F5
e assim, mostrar que esse n´umero ´e composto. Vamos tomar F5 = 225 + 1 = 232 + 1. Pelo
m´etodo de Euler, um fator primo q de F5 tem que ser da forma q = 1 + 25+1r = 1 + 64r.
Precisamos veriﬁcar se q ´e um fator de F5 para os valores de r onde

√

232 + 1 ≤ 66000.

q <

Isto nos d´a r < 1031, um n´umero bem grande. O menor valor de r para o qual q ´e

primo ´e r = 3, que d´a q = 193.

232 ≡ (28)4 ≡ 634 ≡ 108 (mod 193).

Portanto 193 n˜ao ´e fator de F5. Para r = 4 temos q = 257 que ´e primo, mas

232 ≡ 1 (mod 257).

48

Logo 257 tamb´em n˜ao ´e fator de F5. O pr´oximo valor de r em que q ´e primo ´e r = 7,

onde obtemos q = 449, mas

232 ≡ (216)2 ≡ 4312 ≡ 324 (mod 449).

Logo 449 n˜ao ´e fator de F5. Prosseguindo, o pr´oximo valor de r que gera q primo ´e

r = 9, para o qual q = 577.

Neste caso,

232 ≡ 287 (mod 577).

Donde 577 tamb´em n˜ao ´e fator de F5. Quando tomamos r = 10, temos q = 641 que

´e ﬁnalmente um fator de F5.

Por sorte, o fator ´e pequeno, assim, podemos encontr´a-lo utilizando o m´etodo de Euler
e uma m´aquina de calcular, mas essa tarefa pode se tornar muito mais complexa se o fator
for muito grande.

4 Teste de Lucas

4.1 Teste de Lucas

Aqui vamos apresentar um teste que nos permite veriﬁcar se um n´umero ´e primo sem

tentar achar seus fatores.

Proposi¸c˜ao 53. (Teste de Lucas) Seja n um inteiro positivo ´ımpar e b um inteiro

tal que 2 ≤ b ≤ n − 1. Se

bn−1 ≡ 1 (mod n) e b

(n−1)
p

(cid:54)≡ 1 (mod n),

para cada fator primo p de n − 1, ent˜ao n ´e primo.

Demonstra¸c˜ao. Como bn−1 ≡ 1 (mod n) (n ≥ 2), temos que (b, n) = 1.

Seja k a ordem de b com respeito a n. Queremos mostrar que k = n − 1.

Como bn−1 ≡ 1 (mod n), pela Proposi¸c˜ao 39, k|n − 1. Digamos que n − 1 = k.t, onde

t ´e um inteiro positivo. Nosso objetivo ´e mostrar que t = 1.

Ent˜ao, vamos supor por absurdo, que t > 1. Assim, t deve ser divis´ıvel por algum q

49

primo. Mas se q|t, ent˜ao q|n − 1. Portanto

(n − 1)
q

e

t
q

s˜ao inteiros e

n − 1
q

= k.

t
q

.

Da´ı, k| (n−1)

q

.

Novamente pela Proposi¸c˜ao 39, deduzimos que

(n−1)

q ≡ 1 (mod n);

b

o que contradiz a hip´otese.

Com isso, conclu´ımos que t = 1 e, consequentemente, k = n − 1.

Assim, on(b) = n − 1 e n − 1 divide n − 1|φ(n). Da´ı

n − 1 ≤ φ(n) ≤ n − 1

Logo φ(n) = n − 1 e da´ı n ´e primo.

Este teste determina com certeza se um dado n´umero ´e primo.

Observe que para aplic´a-lo com sucesso precisamos ser capazes de fatorar n − 1.

Vamos mostrar agora, atrav´es de um exemplo, como o teste funciona para descobrir

se um n´umero ´e primo.

Exemplo 16. Pegue n = 71. Ent˜ao n − 1 = 70 e os fatores primos de 70 s˜ao 2, 5 e

7. Vamos escolher aleatoriamente um b = 17 < n. Notemos que: 1770 ≡ 1 mod 71.

Temos que

bn−1 ≡ 1 (mod n) se, e somente se, o(b)|(n − 1).

Mas, a ordem de 17(mod 71) n˜ao ´e, necessariamente, 70 porque algum fator de 70
pode tamb´em satisfazer a congruˆencia. Ent˜ao vamos conferir para 70 dividido por seus
fatores primos:

1735 ≡ 70 (cid:54)≡ 1 (mod 71)

1714 ≡ 25 (cid:54)≡ 1 (mod 71)

1710 ≡ 1 ≡ 1 (mod 71).

Infelizmente, temos que 1710 ≡ 1 (mod 71). Portanto, ainda n˜ao sei se 71 ´e primo

50

ou n˜ao.

Tentamos outra forma aleat´oria, desta vez escolhendo b = 11. Chegamos que:

1170 ≡ 1 (mod 71).

Novamente, isto n˜ao indica que a ordem de 11(mod 71) ´e 70, porque algum fator de

70 tamb´em pode funcionar. Ent˜ao conﬁra 70 dividido por seus fatores primos:

1135 ≡ 70 (cid:54)≡ 1 (mod 71)

1114 ≡ 54 (cid:54)≡ 1 (mod 71)

1110 ≡ 32 (cid:54)≡ 1 (mod 71).

Portanto, a ordem de 11(mod 71) ´e 70, portanto 71 , ´e primo.

Na pr´atica h´a v´arios primos interessantes para os quais est´a condi¸c˜ao ´e facilmente
veriﬁcada. Por exemplo, este teste ´e excelente para os n´umeros de Fermat Fn = 22n + 1,
pois Fn − 1 tem apenas um fator primo, que ´e o n´umero 2.

4.2 Teste de Pepin

Proposi¸c˜ao 54. (Teste de Pepin) O n´umero de Fermat Fk = 22K + 1 ´e primo para

k > 1 se 5

Fk −1

2 ≡ −1 (mod Fk).

Demonstra¸c˜ao. Suponhamos que 5

Fk −1

2 ≡ −1 (mod 22K + 1).

Da´ı

5Fk−1 ≡ 1 (mod 22K + 1).

Como por hip´otese 5

Fk −1
2 ≡ −1 (cid:54)≡ 1 (mod 22K + 1) e 2 ´e o ´unico fator primo de Fk − 1,

teremos pelo Teste de Lucas que Fk ´e primo.

Observa¸c˜ao. Vale a rec´ıproca e sua prova depende da lei de reciprocidade quadr´atica,

mas n˜ao iremos prov´a-la aqui.

Exemplo 17. Vamos aplicar o teste de Pepin ao n´umero de Fermat F4, para veriﬁcar

se o mesmo ´e primo.

Temos que F4 = 224 + 1 = 216 + 1 = 65537, da´ı

F4 − 1
2

= 215.

51

Fazendo os c´alculos teremos que

5215 ≡ 532768 ≡ 65536 ≡ −1 (mod F4).

Logo, pelo teste de Pepin, F4 ´e primo.

Exemplo 18. Vamos utilizar o Teste de Pepin para veriﬁcar que F5 ´e composto.

Temos que F5 = 225 + 1 = 232 + 1 = 4294967, da´ı

F5 − 1
2

= 231

Fazendo os c´alculos obtemos

5231 ≡ 2405788 (mod F5)

Portanto F5 n˜ao passa no teste de Pepin, donde F5 ´e composto.

Observa¸c˜ao. Poderemos ter muita diﬁculdade em aplicar o teste de Lucas para
alguns inteiros, pois, dado um inteiro n, o teste requer que uma ´unica base satisfa¸ca todas
as equa¸c˜oes para os fatores de n − 1.

Existe um teste que enunciaremos a seguir, baseado no teste de Lucas, s´o que mais

eﬁciente, pois utiliza bases distintas para fatores distintos de n − 1.

4.3 Outro teste determin´ıstico de primalidade

Proposi¸c˜ao 55. (Teste de primalidade)Seja n > 0 um inteiro tal que

n − 1 = pe1

1 · · · per
r

onde p1 < ... < pr s˜ao primos. Se para cada i = 1, ..., r existirem inteiros positivos
bi(2 ≤ b ≤ n − 1) que satisfa¸cam

bi

n−1 ≡ 1 (mod n) e bi

(n−1)
pi

(cid:54)≡ 1 (mod n)

ent˜ao n ´e primo.

Demonstra¸c˜ao. Vamos considerar o caso em que i = 1.

Suponhamos que s1 seja a ordem de b1 com respeito a n. Assim, pela Proposi¸c˜ao 39,
teremos que s1|n − 1. Logo s1 n˜ao pode ter fatores primos diferentes dos de n, isto ´e, seus

52

fatores est˜ao entre os primos p1 < ... < pr. Assim

s1 = p1

k1 · · · pr

kr, onde 0 ≤ k1 ≤ e1, ..., 0 ≤ kr ≤ er

Mas, sabemos que bi

(n−1)
p1

(cid:54)≡ 1 (mod n), donde (n−1)

p1

n˜ao ´e divis´ıvel por s1. Por outro

lado,

(n − 1)
p1

= p1

e1−1 · p2

e2 · · · per
r .

e1|φ(n). De modo an´alogo, p2

devemos ter k1 = e1. Isto signiﬁca que p1

Assim, para que s1 n˜ao divida (n−1)
p1

e1 divide
s1. Como s1 ´e a ordem de b1 com respeito a n, temos, pela Proposi¸c˜ao 39, que s1|φ(n).
r dividem φ(n). Al´em disso, como estas
Da´ı, p1
potˆencias s˜ao formadas por primos distintos, elas s˜ao primas entre si. Ent˜ao, pelo item
ii) da Proposi¸c˜ao 18, podemos concluir que o produto pe1
r = n − 1 divide φ(n). A
partir disso, chegamos `a conclus˜ao que

e2, . . . , per

1 · · · per

n − 1 ≤ φ(n) ≤ n − 1.

Donde, φ(n) = n − 1 e portanto, n ´e primo.

Observa¸c˜ao. Na proposi¸c˜ao acima n˜ao ´e necess´ario que os b(cid:48)

is sejam todos distintos.

O teste acima nos diz que, se aplicando o teste de Lucas, uma base falhar em alguma
das equa¸c˜oes para os fatores do inteiro n, podemos mudar essa base e continuar o teste
para as equa¸c˜oes dos fatores que ainda restaram.

Vamos entender isso melhor atrav´es de um exemplo.

Exemplo 19. Quando utilizamos o teste de Lucas para provar que o n´umero 41 ´e
primo, fatoramos n − 1 = 40, obtendo n − 1 = 23.5. Da´ı, precisamos encontrar uma base
inteira b tal que 2 ≤ b ≤ 40 e que satisfa¸ca as equa¸c˜oes:

b40 ≡ 1 (mod 41)

b20 (cid:54)≡ 1 (mod 41)

b8 (cid:54)≡ 1 (mod 41).

Come¸cando com b = 2, logo veriﬁcamos que 220 ≡ 1 (mod 41). Passamos a b = 3,
onde obtemos 320 ≡ 40 (mod 41), mas 38 ≡ 1 (mod 41). Al´em disso, podemos observar
que 28 ≡ 10 (mod 41). No entanto, nenhuma dessas bases serve para o teste de Lucas.
A primeira base que satisfaz todas as equa¸c˜oes para o teste de Lucas seria o n´umero

7. Em contrapartida, se aplicarmos o teste anterior, bastaria observar que 2 40
10 (mod 41) e 3 40

2 = 320 ≡ 40 (mod 41) e j´a provamos que 41 ´e primo.

5 = 28 ≡

53

5 M´etodos de Pollard

Em 1974 e 1975, John Pollard anunciou dois novos algoritmos para se obter fatores
de n´umeros inteiros grandes. Esses dois algoritmos s˜ao probabil´ısticos e na pr´atica, com
esses m´etodos, encontraremos um fator do n´umero dado, bem mais r´apido do que se
utiliz´assemos um algoritmo determin´ıstico.

5.1 M´etodo Rho de Pollard

Seja n um n´umero inteiro grande, composto, e p o menor fator primo de n. Vamos
considerar uma sequˆencia de inteiros x0, x1, ..., xs n˜ao congruentes 2 a 2, m´odulo n. Se
xi ≡ xj (mod p), com i (cid:54)= j, ent˜ao (xi − xj, n) ´e um divisor n˜ao trivial de n. De fato,
p|xi − xj e n (cid:45) xi − xj. Al´em disso, se (xi − xj, n) = d, ent˜ao d|n e d|xi − xj. Como
p|xi − xj e n (cid:45) xi − xj, teremos que d (cid:54)= n e d ≥ p. Donde d ´e um divisor n˜ao trivial de n.

Proposi¸c˜ao 56. Dados n inteiro e p o menor fator primo de n. Considere x0 um

valor aleat´orio e deﬁna (xk)k≥0 recursivamente como

xk+1 ≡ f (xk) (mod n), com 0 ≤ xk+1 ≤ n − 1.

onde f (x) ´e uma fun¸c˜ao polinomial arbitr´aria com coeﬁcientes inteiros e grau maior que
1. Se xi ≡ xj (mod p)(i, j > 1) ent˜ao a sequˆencia xk se torna peri´odica mod p com um
per´ıodo j − i.

Demonstra¸c˜ao. Utilizando a deﬁni¸c˜ao recursiva de xk temos que se

onde p ´e um inteiro positivo, ent˜ao

xi ≡ xj (mod p),

xi+1 ≡ f (xi) ≡ f (xj) ≡ xj+1 (mod p).

e assim por diante. O que signiﬁca que dois termos sempre ser˜ao congruentes quando a
diferen¸ca de seus ´ındices for j − i, o que prova nossa tese.

54

Corol´ario 57. Se a sequˆencia deﬁnida acima ´e peri´odica mod p com per´ıodo j − i,

ent˜ao xs ≡ x2s (mod p), onde s ´e o menor m´ultiplo de j − i.

Demonstra¸c˜ao. Da hip´otese segue que dois termos de xk sempre s˜ao congruentes mod p,
quando a diferen¸ca entre seus ´ındices for j − i. Assim, teremos que xq ≡ xr (mod p)
sempre que q ≡ r (mod j − i) e q ≥ i e r ≥ j. O que signiﬁca que dois termos da
sequˆencia xk sempre ser˜ao congruentes m´odulo p quando a diferen¸ca de seus ´ındices for
um m´ultiplo de j − i. Disto, podemos ver que sendo s o menor m´ultiplo de j − i, ent˜ao
xs ≡ x2s (mod p).

Para encontrar um fator de um inteiro n, utilizando o m´etodo Rho de Pollard, esco-
lhemos um valor para x0 e uma fun¸c˜ao como a deﬁnida na Proposi¸c˜ao 56, depois achamos
os termos da sequˆencia deﬁnida, segundo a f´ormula recursiva dada na mesma proposi¸c˜ao
e por ´ultimo calculamos o mdc de x2k − xk e n para k = 1, 2, 3, .... O fator de n ser´a
encontrado quando ocorrer um valor de k para o qual 1 < (x2k − xk, n) < n.

Exemplo 20. Vamos encontrar um fator n˜ao trivial do n´umero n = 8051 utilizando
m´etodo Rho, tomando valor inicial x0 = 2 e polinˆomio gerador f (x) = x2 + 1. Nesse caso,
encontraremos a sequˆencia

x1 = 5, x2 = 26, x3 = 677, x4 = 7474, x5 = 2839, x6 = 871, ...

Utilizando o algoritmo de Euclides para calcular o (x2k − xk, n) obtemos (x2 − x1, 8051) =
(26 − 5, 8051) = (21, 8051) = 1; (x4 − x2, 8051) = (7474 − 26, 8051) = (7448, 8051) = 1;
(x6 − x3, 8051) = (871 − 677, 8051) = (194, 8051) = 97. Ent˜ao, encontramos nesse passo
um fator n˜ao trivial de 8051, que ´e o n´umero 97.

A sequˆencia gerada no exemplo anterior ser´a peri´odica m´odulo p e ter´a per´ıodo 6−3 =
3. Note que x0 ≡ x3 (mod 97); x1 ≡ x4 (mod 97); x2 ≡ x5 (mod 97) e assim por diante.

Observa¸c˜ao. Na pr´atica, o polinˆomio f (x) = x2 + 1 e o valor inicial x0 = 2 s˜ao

frequentemente escolhidos para gerar a sequˆencia de inteiros xo, x1, x2, ..., xk, ....

O m´etodo Rho ´e pr´atico quando o inteiro a ser fatorado tem fatores primos n˜ao muito

grandes.

5.2 M´etodo p-1

Este m´etodo de fatora¸c˜ao, que tˆem como base o Pequeno Teorema de Fermat, nos
permite encontar um fator n˜ao trivial de um inteiro n que tem um fator primo p tal que

55

os fatores de p − 1 s˜ao relativamente pequenos. O m´etodo de Pollard n˜ao funciona bem
para qualquer inteiro n, como a maioria dos m´etodos, mas quando ele funciona, ´e muito
eﬁciente. A ideia na qual esse m´etodo se baseia ´e dada pela seguinte proposi¸c˜ao.

Proposi¸c˜ao 58. Sejam n um n´umero inteiro positivo ´ımpar composto e p um fator
primo de n. Sejam a e k n´umeros inteiros tais que mdc(a, p) = 1 e p − 1|k. Ent˜ao,
p|mdc(ak − 1, n).

Demonstra¸c˜ao. Por hip´otese, p − 1|k, donde k = k(cid:48)(p − 1), para algum inteiro k(cid:48). Como
p ´e primo e p (cid:45) a, segue do Pequeno Teorema de Fermat que ap−1 ≡ 1 (mod p). Elevando
ambos os termos da congruˆencia ao expoente k(cid:48) e usando a rela¸c˜ao entre k e k(cid:48) obtemos
ak ≡ 1 (mod p), que ´e equivalente a p|ak − 1. Assim, p ´e fator comum de ak − 1 e n.
Portanto p|mdc(ak − 1, n).

Para utilizar o m´etodo de Pollard, baseado na proposi¸c˜ao acima, e tentar encontrar
um fator primo p de um inteiro composto n, escolhemos inteiros positivos a e k de modo
que mdc(a, n) = 1 (o que signiﬁca que mdc(a, p) = 1 para todo fator primo p de n) e k
seja divis´ıvel por potˆencias de primos pequenos (por exemplo k = mmc(1, 2, 3, ..., B) ou
k = B!, para um certo inteiro B). Em seguida, calculamos d = mdc(ak −1, n) e esperamos
encontrar um fator n˜ao trivial de n, conforme a proposi¸c˜ao anterior. Como mdc(a, b) =
mdc(b, a mod b), ent˜ao n˜ao ´e necess´ario calcular ak − 1; basta calcular (ak − 1) mod n.
Uma vez calculado d, temos 3 possibilidades.

1. 1 < d < n. Neste caso, d ´e um fator n˜ao trivial de n.

2. d = 1. Este caso ocorre quando p − 1 n˜ao divide k. Devemos ent˜ao aumentar o

valor de k e aplicar novamente o m´etodo.

3. d = n. Quando isso ocorre, devemos escolher outro valor para a e come¸car nova-

mente.

Portanto, podemos enunciar o m´etodo de Pollard na forma de algoritmo da seguinte
maneira.

Algoritmo 59. (Algoritmo p-1 de Pollard) Seja n ≥ 2 um inteiro composto para o
qual desejamos achar um fator primo.

1. Escolha um n´umero k sendo um produto primos pequenos elevados a potˆencias pe-

quenas. Por exemplo, considere

k = mmc(2, 3, ..., B)

56

para um certo inteiro B.

2. Escolha um inteiro qualquer a tal que 0 < a < n.

3. Calcule mdc(a, n). Se ele ´e estritamente maior que 1, ent˜ao ele ´e um fator n˜ao

trivial de n. Da´ı pare. Caso contr´ario v´a para a etapa 4.

4. Calcule d = mdc(ak − 1, n). Se 1 < d < n, ent˜ao d ´e um fator n˜ao trivial de n.
Ent˜ao pare. Se d = 1, volte para a etapa 1 e tome um k maior. Se d = n, volte para
a etapa 2 e escolha outro valor para a.

1
2

Observa¸c˜ao. Note que o algoritmo de Pollard certamente ir´a parar, pois em certo

momento, teremos no passo 1, um valor de B tal que B =
(p − 1) para algum primo
p que divide n, e portanto p − 1 certamente dividir´a k, donde ak − 1 = a(p−1)q − 1 que,
pelo Pequeno Teorema de Fermat, ´e divis´ıvel por p e da´ı d = mdc(ak − 1, n) ser´a igual a p
que nesse caso ´e fator de n . Por exemplo, dado n = 143, pelo m´etodo p − 1, come¸cando
com k = 2 e tomando a = 2, obteremos at´e a quarta tentativa mdc(2k − 1, 143) = 1,
s´o que quando chegamos em k = mmc(2, 3, ..., 5) = 60 teremos mdc(260 − 1, 143) = 11,
pois 11 ´e um fator de 143, e como 11 − 1 = 10 divide 60, temos tamb´em que 260 − 1 ´e
divis´ıvel por 11. No entanto, este processo pode gastar muito tempo e o algoritmo n˜ao
ser´a pr´atico para valores grandes de k. O algoritmo s´o roda numa quantidade de tempo
razo´avel quando n tem um divisor primo p tal que p − 1 ´e produto de primos pequenos
elevados a potˆencias pequenas.

Exemplo 21. Vamos calcular, utilizando o m´etodo p − 1 de Pollard, um fator de

n = 35318303.

Primeiramente, vamos supor o n´umero 35318303 composto. Agora vamos encontrar

um fator desse n´umero.

Inicialmente, vamos tomar a = 2 e k = mmc(2, 3, ..., 5) = 60. Para facilitar os

c´alculos, escrevemos 60 na base 2, obtendo

60 = 25 + 24 + 23 + 22

Calculamos, ent˜ao, os valores 22i (mod n), 0 ≤ i ≤ 5 , e apresentamo-los na tabela a
seguir:

57

i

0

1

2

3

4

5

22i mod 35318303

2

4

16

256

65536

21452633

A partir da tabela calculamos

260 = 225+24+23+22 = 225 · 224 · 223 · 222 ≡ 30748919 (mod 35318303)

Utilizando o algoritmo euclidiano obteremos

mdc(260 − 1, 35318303) = mdc(30748918, 35318303) = 1

Portanto, para esses valores o teste falha. Isso se deve ao fato de que para nenhum fator
primo p de 35318303, teremos que p − 1 divide 60. O que fazemos ent˜ao ´e aumentar
o valor de k e esperar que exista um fator primo p de 35318303 tal que p − 1 divida o
novo valor de k. Ent˜ao, tomemos k = mmc(2, 3, ..., 7) = 420. Escrevendo 420 na base 2
obtemos

Calculando, os valores de 22i (mod n) para i = 6, 7, 8 obtemos

420 = 28 + 27 + 25 + 22

i

6

7

8

22i mod 35318303

32844765

24017239

26510038

Da´ı

2420 = 228+27+25+22 = 228 · 227 · 225 · 222 ≡ 2502093 (mod 35318303)

58

Utilizando o algoritmo euclidiano obteremos

mdc(260 − 1, 35318303) = mdc(2502092, 35318303) = 1

e novamente o teste falha.

Vamos tomar agora k = mmc(2, 3, ..., 11) = 27720. Ent˜ao escrevemos esse novo valor

de k na base 2 obtendo

27720 = 214 + 213 + 211 + 210 + 26 + 23

Agora, estendemos a tabela, calculando os valores de 22i (mod n) de que precisamos ob-
tendo

i

9

10

11

12

13

14

22i mod 35318303

14876672

5160260

13402447

16450291

22433108

15795689

Utilizando esses valores obtidos podemos calcular 227720 = 2214+213+211+210+26+23 =

2214 · 2213 · 2211 · 2210 · 226 · 223 ≡ 14301996 (mod 35318303)

Agora, usando o algoritmo euclidiano obtemos

mdc(227720 − 1, 35318303) = mdc(14301995, 35318303) = 4621

E assim, encontramos, como quer´ıamos um fator n˜ao trivial de 35318303. Al´em disso,
fatoramos 35318303 como 4621 · 7643 e cada um destes fatores ´e primo, e assim fatoramos
n completamente.

Tivemos sucesso em encontrar um fator n˜ao trivial de n nessa passagem, pelo fato
de que o fator p = 4621 encontrado ´e tal que p − 1 = 4620 = 22 · 3 · 5 · 7 · 11 divide
k = 27720 = 23 · 32 · 5 · 7 · 11. Observe tamb´em que como 4621, que ´e um fator de
35318303, diminuido de uma unidade ´e produto de primos pequenos elevados a expoentes

59

pequenos, isso nos permitiu fatorar esse n´umero em um tempo razo´avel utilizando esse
m´etodo.

Observa¸c˜ao. Existe um outro m´etodo de fatora¸c˜ao de inteiros baseado no M´etodo
p − 1. Esse m´etodo ´e devido a H. W. Lenstra, e utiliza curvas el´ıticas. O m´etodo de
Lenstra ´e mais vantajoso e eﬁciente em rela¸c˜ao a qualquer um dos m´etodos estudados
nesse trabalho, mas n˜ao ser´a estudado aqui pois exige outros conhecimentos, al´em dos
tratados neste trabalho.

60

5 Criptograﬁa RSA

Nesse cap´ıtulo, iremos descrever o m´etodo de criptograﬁa RSA que ´e muito importante
e muito utilizado na cria¸c˜ao de senhas codiﬁcadas. A seguran¸ca do RSA ´e baseada na
ineﬁciˆencia dos m´etodos de fatora¸c˜ao atualmente conhecidos.

1 Pr´e-codiﬁca¸c˜ao

Primeiramente, vamos entender as caracter´ısticas iniciais para se criar uma mensagem
codiﬁcada atrav´es do m´etodo RSA, o que chamamos de pr´e-codiﬁca¸c˜ao. A mensagem
inicial ser´a um texto com palavras e o espa¸co entre elas. Na pr´e codiﬁca¸c˜ao convertemos
as letras em n´umeros usando, por exemplo, a seguinte tabela:

A B C D E F G H I

J K L M

10

11

12

13

14

15

16

17

18

19

20

21

22

N O P Q R S T U V W X Y Z

23

24

25

26

27

28

29

30

31

32

33

34

35

O espa¸co entre duas palavras ser´a substituido pelo n´umero 99, quando for feita a

convers˜ao. Por exemplo, a frase “Estudar ´e bom”´e convertida no n´umero

14282829131027991499112422.

Cada letra corresponde a um n´umero a partir de 10, isto ´e, de dois algarismos, pois
isso evita que hajam ambiguidades. Se come¸cassemos do 1, poderia ocorrer que 13 poderia
ser AC ou M, que ´e a d´ecima terceira letra do alfabeto.

61

Na pr´e-codiﬁca¸c˜ao do RSA, vamos utilizar dois n´umeros inteiros primos p e q, os quais
chamaremos de parˆametros e que ser˜ao multiplicados resultando num n´umero n = p · q. A
parte ﬁnal da pr´e-codiﬁca¸c˜ao consiste em quebrar o longo n´umero, obtido quando ﬁzemos
a convers˜ao da frase utilizando a tabela, em blocos que devem ser n´umeros menores que
n. Por exemplo, se os n´umeros primos escolhidos forem p = 11 e q = 13, ent˜ao teremos
n = 143. Neste caso, a frase convertida pode ser quebrada em blocos da seguinte maneira:

14 − 28 − 28 − 29 − 13 − 102 − 79 − 91 − 49 − 91 − 124 − 22

A maneira de se escolher esses blocos n˜ao ´e ´unica, mas devemos tomar certos cuidados.
Por exemplo, se tomarmos um bloco come¸cando pelo n´umero 0, isto pode nos trazer
problemas na hora de decodiﬁcar a mensagem, ent˜ao isso deve ser evitado. Al´em disso,
devemos evitar tomar blocos que depois de decodiﬁcados formem alguma palavra ou letra,
pois isso melhora a seguran¸ca da mensagem, sendo que torna praticamente imposs´ıvel a
decodiﬁca¸c˜ao por contagem de frequˆencia ou por adivinha¸c˜ao da frase antes que a mesma
seja toda decodiﬁcada.

2 Codiﬁca¸c˜ao e decodiﬁca¸c˜ao

Agora, vamos entender como codiﬁcar e decodiﬁcar uma mensagem utilizando o sis-
tema RSA. Para codiﬁcar a mensagem por este sistema precisamos de um n´umero inteiro
n, que seja produto de dois n´umeros primos, como vimos na pr´e-codiﬁca¸c˜ao, e tamb´em
de um inteiro positivo e, que seja invers´ıvel m´odulo φ(n). O que signiﬁca que devemos ter
(e, φ(n)) = 1. ´E claro que se conhecermos os fatores p e q de n, ´e f´acil encontrar φ(n) j´a
que

φ(n) = φ(p · q) = φ(p) · φ(q) = (p − 1) · (q − 1).

O par (n; e) ser´a chamado de chave de codiﬁca¸c˜ao do sistema RSA que estamos uti-
lizando. Codiﬁcaremos a mensagem, codiﬁcando separadamente cada um dos blocos de
n´umeros menores que n obtidos na pr´e-codiﬁca¸c˜ao, utilizando a chave de codiﬁca¸c˜ao. ´E
muito importante frisar que ap´os codiﬁcarmos a mensagem n˜ao podemos reunir os blo-
cos formando um ´unico e longo n´umero, porque isso torna a imposs´ıvel decodiﬁcar a
mensagem, como veremos adiante.

Vamos ver agora, como proceder para codiﬁcar a mensagem utilizando a chave de

codiﬁca¸c˜ao (n, e).

62

Vamos tomar um certo bloco b da mensagem, onde b ´e um inteiro positivo menor que

n. Denotando por C(b) o bloco codiﬁcado, encontraremos C(b) da seguinte maneira:

C(b) = resto da divis˜ao de be por n.

O que signiﬁca que C(b) ´e a forma reduzida de be m´odulo n. Vamos ver como ﬁcaria
a codiﬁca¸c˜ao no exemplo que estamos considerando. Temos que p = 11 e q = 13, donde
n = 143, ent˜ao φ(n) = (11 − 1) · (13 − 1) = 120. Agora, nos falta escolher e de modo que
(e, 120) = 1. Neste caso, o menor valor poss´ıvel para e ´e 7, que ´e o menor primo que n˜ao
divide 120. Assim, por exemplo, para codiﬁcar o bloco 124 da mensagem, encontraremos
o resto da divis˜ao de 1247 por 143. Fazendo as contas, teremos

1247 ≡ (−19)7 ≡ −197 ≡ 25 · (−19) ≡ −46 ≡ 97 (mod 143).

Portanto C(124) = 97.

Codiﬁcando toda a mensagem, otemos:

53 − 63 − 63 − 94 − 117 − 119 − 40 − 130 − 36 − 130 − 97 − 22

Vamos ver agora, como decodiﬁcar uma mensagem codiﬁcada pelo m´etodo RSA.

Para decodiﬁcar uma mensagem precisamos de duas informa¸c˜oes: o n´umero n e um
n´umero que denotaremos por d, que ´e o inverso de e m´odulo φ(n). O par (n, d) ser´a a
nossa chave de decodiﬁca¸c˜ao. Utilizando a chave de decodiﬁca¸c˜ao, decodiﬁcaremos um
bloco a da mensagem codiﬁcada, calculando o resto da divis˜ao de ad por n. Ent˜ao, sendo
D(a) o resultado da decodiﬁca¸c˜ao de um bloco a, teremos que

D(a) = resto da divis˜ao de ad por n.

Nesse caso, D(a) ´e a forma reduzida de ad m´odulo n.

No exemplo temos que n = 143 e e = 7. Para encontrar d vamos aplicar o Algoritmo
Euclidiano Estendido. Nesse exemplo, o c´alculo ´e simples, pois dividindo φ(143) = 120
por 7, obtemos

120 = 7 · 17 + 1, donde 1 = 120 + (−17) · 7.

Assim, o inverso de 7 m´odulo 120 ´e −17. Mas, como d ser´a usado como expoente de
potˆencias, vamos tomar d positivo. Logo d = 120 − 17 = 103. Assim, para decodiﬁcar

63

o bloco 97 da mensagem codiﬁcada, calculamos a forma reduzida de 97103 m´odulo 143.
Utilizando uma calculadora, obtemos

97103 ≡ 97100.47 ≡ 11450.47 ≡ 5610.47 ≡ 100.47 ≡ 124 (mod 143).

Portanto D(97) = 124.

Podemos perceber que o m´etodo funciona para este bloco, mas ser´a que isso sempre

acontece? Isso ´e o que vamos ver na pr´oxima se¸c˜ao.

3 Funcionamento

Para que o m´etodo funcione, esperamos que, decodiﬁcando um bloco da mensagem co-
diﬁcada, encontremos o bloco correspondente da mensagem original. Em outras palavras,
dadas as f´ormulas de codiﬁca¸c˜ao e decodiﬁca¸c˜ao do RSA:

C(b) ≡ be (mod n);

D(a) ≡ ad (mod n);

sendo a um bloco codiﬁcado e b um bloco da mensagem original e d ´e o inverso de e
m´odulo φ(n). Esperamos que sempre ocorra que D(C(b)) = b. Vamos provar que isso
sempre ´e v´alido e assim provar o funcionamento do RSA. Para isso vamos enunciar essa
propriedade em forma de proposi¸c˜ao e demonstr´a-la.

Proposi¸c˜ao 60. D(C(b)) = b.

Demonstra¸c˜ao. Temos que D(C(b)) ≡ C(b)d ≡ bed (mod n). Mas, como d ´e inverso de e
m´odulo φ(n), ed = 1 + kφ(n). Da´ı, segue que D(C(b)) ≡ b1+kφ(n) ≡ (bφ(n))kb (mod n).
Como n = pq, temos que φ(n) = (p − 1)(q − 1) o que implica que D(C(b)) ≡ (bp−1)(q−1)kb
(mod p). Se p n˜ao divide b, ent˜ao

D(C(b)) ≡ b (mod p)

pelo Pequeno Teorema de Fermat. Se p divide b, ent˜ao b ≡ 0 (mod n) ou seja D(C(b)) ≡
(bp−1)(q−1)kb ≡ 0 (mod p). Analogamente, ´e poss´ıvel mostrar que D(C(b)) ≡ b (mod q) e
como p e q s˜ao primos,

D(C(b)) ≡ b (mod n)

Como b e D(C(b)) s˜ao menores do que n, temos a igualdade

D(C(b)) = b.

64

4 Seguran¸ca do RSA

O RSA ´e um sistema de chave p´ublica, isto signiﬁca que a chave de codiﬁca¸c˜ao (n, e)
´e p´ublica, isto ´e, ela ´e acess´ıvel para qualquer usu´ario do sistema. Portanto, a seguran¸ca
do RSA depende da diﬁculdade de se calcular d conhecendo n e e.

Na pr´atica, s´o conseguimos calcular d, conhecendo e e φ(n). Mas, devemos lembrar
que os parˆametros p e q n˜ao s˜ao p´ublicos, e para calcular φ(n), temos que saber fatorar n
para obter esses parˆametros. Assim, a seguran¸ca do RSA ´e baseada na diﬁculdade de se
fatorar um n´umero utilizando os algoritmos de fatora¸c˜ao atualmente conhecidos.

De fato, podemos veriﬁcar que, se fatoramos n, ent˜ao podemos encontrar φ(n) e
utilizar as opera¸c˜oes da se¸c˜ao anterior para decifrar a mensagem. Por outro lado, se for
inventado um algoritmo eﬁciente para se calcular φ(n) sem conhecer os parˆametros p e q,
teremos n = p.q e φ(n) = (p − 1) · (q − 1) conhecidos. Da´ı,

φ(n) = (p − 1) · (q − 1) = pq − (p + q) + 1 = n − (p + q) + 1,

portanto, p + q = n − φ(n) + 1 . Em contrapartida, temos que

(p + q)2 − 4n = (p2 + q2 + 2pq) − 4n = (p2 + q2 − 2pq) = (p − q)2

logo

p − q = (cid:112)(n − φ(n) + 1)2 − 4n

e destas duas equa¸c˜oes segue que

e

p =

(cid:112)(n − φ(n) + 1)2 − 4n + n − φ(n) + 1
2

q = −

(cid:112)(n − φ(n) + 1)2 − 4n + n − φ(n) + 1
2

E portanto, temos uma fatora¸c˜ao do n´umero n.

65

Isso signiﬁca que n˜ao adianta pensarmos que algu´em possa ter inventado um algoritmo
para encontrar φ(n), sem encontrar fatores de n, pois conhecendo n e φ(n) encontramos
os fatores de n.

Por tudo que vimos nesta se¸c˜ao, conclu´ımos que quanto mais dif´ıcil de se fatorar o
inteiro escolhido, mais dif´ıcil quebrar o sistema RSA. Ent˜ao, ´e claro que n˜ao podemos
escolher n de qualquer maneira, pois se esse n´umero for f´acil de ser fatorado, o RSA
ser´a quebrado facilmente. Primeiramente, podemos veriﬁcar que em v´arios momentos,
frisou-se que se “n ´e grande”, ´e praticamente imposs´ıvel fator´a-lo. Ent˜ao n˜ao podemos
escolher primos pequenos. Um exemplo disso ´e a escolha do valor de n do exemplo que
trabalhamos, pois 143 ´e um primo pequeno e podemos facilmente encontrar sua fatora¸c˜ao
e consequentemente descobrir a mensagem codiﬁcada. Estudiosos desse m´etodo sup˜oem
que o indicado sejam n´umeros com aproximadamente 231 algarismos. Mas ´e claro que,
n˜ao basta tamb´em escolhermos inteiros grandes, mas que podem ser facilmente fatorados
utilizando alguns m´etodos de fatora¸c˜ao. Por exemplo, se escolhermos um inteiro que tem
fatores p e q relativamente pr´oximos, o mesmo pode ser facilmente fatorado pelo algoritmo
de Fermat, ou quando os fatores p e q diminu´ıdos de uma unidade tem fatores pequenos
podemos utilizar o m´etodo p−1 de Pollard e fator´a-lo sem muita diﬁculdade. Isto signiﬁca
que, a seguran¸ca do RSA depende muito da escolha do inteiro n, pois est´a intimamente
ligada `a diﬁculdade de fatorar esse n´umero.

Exemplo 22. A chave p´ublica utilizada por um banco para codiﬁcar suas mensagens
´e a seguinte: n = 10403 e e = 8743. Recentemente os computaderes do banco receberam,
de local indeterminado, a seguinte mensagem:

4746 − 8214 − 9372 − 9009 − 4453 − 8198

Vamos descobrir o que diz a mensagem mandada ao banco.

A primeira coisa a se fazer ´e fatorar n para encontrar φ(n). Pelo teorema de Fermat,

obtemos:

√

x2 − n Inteiro?

x

102

1

sim

Ent˜ao, os fatores de 10403 s˜ao p = 103 e q = 101 e φ(n) = (103 − 1) · (101 − 1) = 10200.

Agora, j´a podemos encontrar o valor do inverso de e m´odulo φ(n), que ser´a usado

66

para decodiﬁcar a mansagem juntamente com n. Basta encontrar d, de modo que

d.8743 ≡ 1 (mod φ(n))

Da congruˆencia acima, temos que existe um k inteiro tal que

8743d − 1 = kφ(n) ⇐⇒ 8743d − k10200 = 1

Aplicando o algoritmo Euclidiano estendido teremos

restos

quocientes

10200

8743

1457

1

*

*

1

6

k

1

0

d

0

1

1 − 1.0 = 1

0 − 1.1 = −1

0 − 6.1 = −6

1 − 6.(−1) = 7

Assim, encontramos d = 7. Agora, para decodiﬁcar cada bloco a da mensagem, calculamos
o resto da divis˜ao de a7 por n = 10403, isto ´e, encontraremos os valores de b, que s˜ao
os blocos da mensagem origiginal, em que cada b ´e a forma reduzida de a7 m´odulo 143.
Ent˜ao, vamos `a decodiﬁca¸c˜ao de cada bloco. Fazendo os c´aculos obtemos que

47467 ≡ 1514 (mod 10403)

82147 ≡ 2722 (mod 10403)

93727 ≡ 1029 (mod 10403)

90097 ≡ 9931 (mod 10403)

44537 ≡ 1831 (mod 10403)

81987 ≡ 14 (mod 10403)

Portanto, decodiﬁcando os blocos chegamos na seguinte situa¸c˜ao

1514 − 2722 − 1029 − 9931 − 1831 − 14

Juntando os blocos teremos o n´umero

1514272210299931183114

67

E, portanto, a mensagem ´e “FERMAT VIVE”

Podemos notar que a seguran¸ca do sistema do exemplo ´e fraca, pois o n´umero 10403 ´e
fatorado com uma facilidade incr´ıvel utilizando o Algoritmo de Fermat. Ent˜ao, a escolha
do primo para codiﬁcar a mensagem, neste caso, foi infeliz.

Exemplo 23. Seja (35318303, 299) uma chave p´ublica do RSA. Vamos utilizar essa

chave para decodiﬁcar a seguinte mensagem, que foi codiﬁcada com esses parˆametros.

34619207 − 27434838

Primeiramente, devemos encontrar os fatores de n, para calcular φ(n).

Os fatores de 35318303 n˜ao s˜ao calculados t˜ao facilmente, pelo Algoritmo de Fermat,
como no n´umero do exemplo anterior. Mas, j´a calculamos os fatores desse n´umero utili-
zando o m´etodo p − 1 de Pollard, na se¸c˜ao anterior. Ent˜ao, a partir disso vamos calcular
φ(n).

Temos que n = 35318303 = 4621 · 7643. Da´ı, φ(n) = 4620 · 7642 = 35306040. Agora,
vamos calcular o valor de d, encontrando o inverso de 299 m´odulo φ(n). Para isso, vamos
aplicar o algoritmo Euclidiano estendido.

Realizando os c´alculos, chegamos que d = 17357819. Ent˜ao para decodiﬁcar a men-
sagem, encontraremos a forma reduzida de 3461920717357819 e 2743483817357819 m´odulo
35318303.

Executando os c´aculos chegamos que

3461920717357819 ≡ 272 (mod 35318303) e 2743483817357819 ≡ 810 (mod 35318303)

Portanto, decodiﬁcando os blocos e juntando teremos

272810

Logo, utilizando a tabela de convers˜ao, conclu´ımos que a mensagem ´e RSA

Como vimos neste trabalho, fatorar um n´umero inteiro ´e um grande problema da
matem´atica. Ent˜ao at´e que se crie um m´etodo que fatore qualquer n´umero com facilidade,
o RSA continua sendo um sistema seguro.

68

Conclus˜ao

Neste trabalho desenvolvemos a base matem´atica necess´aria para se entender alguns
m´etodos de fatora¸c˜ao e testes de primalidade probabil´ısticos e determin´ısticos (tanto os
mais usuais, quanto outros menos conhecidos). Na educa¸c˜ao b´asica, a fatora¸c˜ao de inteiros
se limita a n´umeros bem pequenos, o que pode passar uma id´eia falsa do problema. ´E
claro que muitos resultados estudados aqui n˜ao s˜ao aplic´aveis no Ensino B´asico, mas
seria importante que professores estudassem mais sobre esse assunto, para entender os
problemas e aplica¸c˜oes, como por exemplo, o sistema RSA apresentado no ´ultimo cap´ıtulo.

Os testes determin´ısticos que estudamos em nosso trabalho tem um custo exponencial,
isto ´e, conforme o valor de n aumenta, o tempo de execu¸c˜ao, para determinar se dado
n´umero ´e primo ou composto, aumenta exponencialmente.

Em agosto de 2002, com a publica¸c˜ao de seu artigo original, os indianos Manindra
Agrawal, Neeraj Kayal e Nitin Saxena impactaram a comunidade matem´atica com a
publica¸c˜ao do algoritmo AKS, o primeiro teste de primalidade determin´ıstico e de tempo
polinomial, isto ´e, alem de determinar com certeza se o n´umero ´e primo, o tempo que esse
algoritmo gasta para chegar a tal conclus˜ao pode ser bem menor do que se utiliz´assemos
outros testes. Eles resolveram, de maneira brilhante, um problema que durava milˆenios e
para entender a solu¸c˜ao precisaremos apenas de conhecimentos estudados numa gradua¸c˜ao
de matem´atica ou da ciˆencia em computa¸c˜ao.

Esse algoritmo ´e de grande importˆancia para a hist´oria da matem´atica e poder´a ser

um bom tema para um novo trabalho.

69

Referˆencias

[1] S.C. Coutinho, N´umeros inteiros e Criptograﬁa RSA, Cole¸c˜ao Matem´atica e Aplica-

¸c˜oes, IMPA, Segunda edi¸c˜ao, 2014.

[2] A. Hefes, Aritm´etica, Cole¸c˜ao PROFMAT, IMPA, 2013.

[3] C. Cardoso, Fatora¸c˜ao de n´umeros inteiros usando curvas el´ıticas, Disserta¸c˜ao de
Mestrado, Departamento de Computa¸c˜ao e Estat´ıstica - CCET - UFMS, 2003.

[4] A. Hefes, Curso de ´Algebra, Cole¸c˜ao Matem´atica Universit´aria, IMPA, 2010.

[5] M. C. Oliveira, Aritm´etica: Criptograﬁa e outras aplica¸c˜oes de congruˆencia, Disser-

ta¸c˜ao de Mestrado, PROFMAT - UFMS, 2013.

Http://bit.profmat-sbm.org.br/xmlui/handle/123456789/372

[6] C. M. Antunes, M´etodos de Fatora¸c˜ao de N´umeros Inteiros, Disserta¸c˜ao de Mestrado,

PPGMAp da UFRGS, 2002.

http://www.lume.ufrgs.br/handle/10183/1626

[7] A. C. Campelo e I. Leal, Teoria Aritm´etica dos N´umeros e Criptograﬁa RSA, Mono-

graﬁa, IME - UNICAMP, 2007.

Http://www.ime.unicamp.br/∼ftorres/ENSINO/MONOGRAFIAS/antonio
RSA.pdf

[8] S.C. Coutinho, Primalidade em Tempo Polinomial: Uma introdu¸c˜ao ao Algoritmo

AKS, Cole¸c˜ao Inicia¸c˜ao Cient´ıﬁca, SBM, 2004.

[9] A. B. Chagas, Testes de Primalidade: Uma Vis˜ao Computacional, Trabalho de Gra-

dua¸c˜ao do curso de Ciˆencia da Computa¸c˜ao, UFPE, 2009.

Http://www.cin.ufpe.br/∼tg/2009-2/abc.pdf

[10] N.C. Saldanha, Ordens e ra´ızes primitivas, PUC - RIO, 1999.

Http://www.mat.puc-rio.br/∼nicolau/papers/mersenne/node13.html.

[11] M. A. Faria e S. Serconek, N´umeros Primos: Testes de primalidade e aplica¸c˜oes,

Mini curso XXIII semana do IMPE, UFG, 2008.

Https://semanadoime.mat.ufg.br/up/34/o/min Cida.pdf

[12] F. F. Nunes,Uma an´alise comparativa entre os testes de primalidade AKS e Miller-

Rabin, Trabalho de conclus˜ao do curso de Matem´atica, UCB, 2007.

Https://www.ucb.br/sites/100/103/TCC/22007/FernandodeFarias.pdf

