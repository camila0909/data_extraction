UNIVERSIDADE ESTADUAL DO MARANHÃƒO â€“ UEMA 

PRÃ“-REITORIA DE PÃ“S-GRADUAÃ‡ÃƒO â€“ PPG 

PROGRAMA DE MESTRADO PROFISSIONAL EM MATEMÃTICA EM REDE 

NACIONAL/PROFMAT 

MARLON MAIKO BARROS MARTINS 

TESTES DE PRIMALIDADE: 

dos mÃ©todos tradicionais aos computacionais 

SÃ£o LuÃ­s 

2021

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
MARLON MAIKO BARROS MARTINS 

TESTES DE PRIMALIDADE: 

dos mÃ©todos tradicionais aos computacionais 

DissertaÃ§Ã£o  apresentada  ao  Programa  de 
Mestrado  em  MatemÃ¡tica  em  Rede  Nacional 
(PROFMAT)  da  Universidade  Estadual  do 
MaranhÃ£o (UEMA), como requisito parcial para 
obtenÃ§Ã£o do tÃ­tulo de Mestre em MatemÃ¡tica.  

Orientador: Prof. Dr. Raimundo JosÃ© Barbosa 
BrandÃ£o. 

SÃ£o LuÃ­s 

2021

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Martins, Marlon Maiko Barros. 

Testes de primalidade: dos mÃ©todos tradicionais aos computacionais / Marlon 

Maiko Barros Martins. â€“ SÃ£o LuÃ­s, 2021. 

     86 f. 

DissertaÃ§Ã£o  (Mestrado  Profissional)  â€“  Curso  de  MatemÃ¡tica  em  Rede 

Nacional, Universidade Estadual do MaranhÃ£o, 2021. 

Orientador: Prof. Dr. Raimundo JosÃ© Barbosa BrandÃ£o. 

1.Testes de primalidade. 2.NÃºmeros primos. 3.Era PrÃ©-computacional. 4.Era 

Computacional. 5.Algoritmo Computacional. I.TÃ­tulo. 

CDU: 511                                                                        

CDU: 511                                                                        

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                                                                                 
 
 
 
 
 
 
 
Dedico  este  trabalho  ao  meu  filho  Marlon 

Lorenzo de Oliveira Martins, por sua vinda ao 

mundo 

ter  servido  de 

reavivamento  e 

fortalecimento de minhas aÃ§Ãµes de trabalho e 

estudo.

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Aos meus honrados pais, Rafael Bispo Martins e Beatriz de AraÃºjo Barros, 

pelo apoio constante e estrutura de estudo que me ofertaram ao longo de minha vida; 

Ã€  minha  querida  esposa,  Ida  ValÃ©ria  Nunes  de  Oliveira,  pelo  apoio 

constante  em  meus  estudos  e  compreensÃ£o  nos  momentos  de  distanciamento 

necessÃ¡rio ao alcance de minhas metas estudantis; 

Aos  meus  amados  filhos,  Iasmim  Rafaele  de  Oliveira  Martins  e  Marlon 

Lorenzo de Oliveira Martins, pela companhia e alegrias obtidas dos felizes momentos 

convividos; 

Ao  Prof.  Dr.  JoÃ£o  Coelho  Silva  Filho,  pela  sua  incansÃ¡vel  luta  na 

CoordenaÃ§Ã£o  do  Programa  de  Mestrado  Profissional  em  MatemÃ¡tica  em  Rede 

Nacional  (PROFMAT-UEMA),  em  prol  do  bom  desenvolvimento  e  constante 

aprimoramento do programa; 

Ao  corpo  administrativo  do  PROFMAT-UEMA,  em  especial  Ã   Annanda 

Crystina  Chagas  Santos,  pelo  seu  empenho  e  prestatividade  no  atendimento  das 

demandas dos alunos;  

Ao  Prof.  Dr.  Raimundo  JosÃ©  Barbosa  BrandÃ£o,  pela  sua  eficiente 

orientaÃ§Ã£o  e  disponibilizaÃ§Ã£o  de  atenÃ§Ã£o  em  todos  os  momentos  necessÃ¡rios, 

atributos estes indispensÃ¡veis para a produÃ§Ã£o e conclusÃ£o da presente pesquisa; 

Ao  corpo  diretivo,  docente  e  administrativo  da  Universidade  Estadual  do 

MaranhÃ£o  (UEMA),  pela  firme  e  competente  atuaÃ§Ã£o  durante  a  execuÃ§Ã£o  de  cada 

etapa do PROFMAT; 

Aos meus companheiros de mestrado, pelos bons momentos vividos e pela 

cooperaÃ§Ã£o nos estudos que, mesmo em face ao momento pandÃªmico vivido durante 

a disseminaÃ§Ã£o do coronavÃ­rus (SARS-COV-2), entre os anos de 2020 e 2021, nÃ£o 

deixaram de manter a coesÃ£o e companheirismo no transcurso do PROFMAT; 

E a todos aqueles que, de alguma forma, colaboraram com a realizaÃ§Ã£o do 

curso e com a concretizaÃ§Ã£o do presente trabalho.

 
 
 
â€œUm problema da teoria dos nÃºmeros Ã© tÃ£o 

atemporal quanto uma verdadeira obra de 

arteâ€.  

David Hilbert 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

O  presente estudo  teve  como  finalidade apresentar alguns  dos  principais testes de 

primalidade  desenvolvidos  ao  longo  da  histÃ³ria,  com  detalhamento  de  suas 

caracterÃ­sticas  gerais,  custos  computacionais,  tempos  de  execuÃ§Ã£o,  dentre  outros 

aspectos.  A  metodologia  utilizada  foi  a  pesquisa  bibliogrÃ¡fica  e  o  objetivo  geral 

consistiu  em  analisar  o  funcionamento  dos  testes  de  primalidade  desde  sua 

concepÃ§Ã£o  mais  simples  atÃ©  os  modernos  mecanismos  de  localizaÃ§Ã£o  de  nÃºmeros 

primos.  A  dissertaÃ§Ã£o  do  assunto  modulou-se  na  apresentaÃ§Ã£o  dos  primos, 

abordando  conceitos  bÃ¡sicos,  quantidade  destes  e  fÃ³rmulas  para  sua  localizaÃ§Ã£o. 

Estudou-se,  ainda,  os  aspectos  bÃ¡sicos  dos  testes  de  primalidade,  em  seguida 

comparou-se as capacidades humanas com as computacionais e entÃ£o apontou-se 

caracterÃ­sticas necessÃ¡rias para sua classificaÃ§Ã£o. Os testes foram divididos em dois 

grupos,  conforme  duas  grandes  eras:  a  prÃ©-computacional  e  a  computacional.  A 

anÃ¡lise dos testes incluiu aspectos como tempo de execuÃ§Ã£o, grau de determinaÃ§Ã£o 

e tipo de nÃºmero testado. Por fim, tratou-se das principais aplicaÃ§Ãµes dos testes de 

primalidade no campo da criptografia. Por efeito da anÃ¡lise dos resultados, inferiu-se 

que  os  testes  de  primalidade  constituem  um  relevante  mÃ©todo  de  localizaÃ§Ã£o  de 

primos,  cuja  evoluÃ§Ã£o  resultou  em  algoritmos  mais  Ã¡geis  e  eficientes,  apoiados  no 

grande  avanÃ§o  computacional  das  Ãºltimas  dÃ©cadas,  com 

tendÃªncia  ao 

desenvolvimento contÃ­nuo e produÃ§Ã£o de formas de identificar primos cada vez mais 

hÃ¡beis.  

Palavras-chave: Testes de Primalidade. NÃºmeros Primos. Era PrÃ©-computacional. Era 

Computacional. Algoritmo Computacional. 

 
 
 
 
 
ABSTRACT 

The  present  study  aimed  to  introduce  some  of  the  main  primality  tests  developed 

throughout  history,  with  details  of  their  general  characteristics,  computational  costs, 

execution  times,  among  other  aspects.  The  methodology  used  was  bibliographical 

research  and  the  general  objective  was  to  analyze  the  functioning  of  primality  tests 

from their simplest conception to modern mechanisms of location of prime numbers. 

The dissertation of the subject was modulated in the presentation of primes, presenting 

basic concepts, quantity of these and formulas for their location. The basic aspects of 

primality  tests  were  also  studied,  then  human  and  computational  capacities  were 

compared and the characteristics necessary for their classification were pointed out. 

The tests were divided into two groups, according to two major eras: pre-computational 

and computational. The analysis of the tests included aspects such as runtime, degree 

of  determination,  and  type  of  number  tested.  Finally,  were  presented  the  main 

applications of primality tests in the field of cryptography. In reason of the analysis of 

the results, it was inferred that primality tests constitute a relevant method of  primes 

locating, whose evolution resulted in more agile and efficient algorithms, supported by 

the  great  computational  advance  of  recent  decades,  with  a  tendency  to  continuous 

development and production of ways to identify increasingly skilled primes. 

Keywords:  Primality  Tests.  Prime  Numbers.  Pre-Computational  Age.  Computational 

Age. Computational Algorithm. 

 
 
 
 
 
LISTA DE TABELAS 

Tabela 1 â€“ ComparaÃ§Ã£o entre as funÃ§Ãµes ğ¿ğ‘–(ğ‘¥) e ğ‘…(ğ‘¥) ao serem relacionadas com os 

valores de ğœ‹(ğ‘¥) .......................................................................................................... 28 

Tabela 2 â€“ Valores de (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘ para alguns primos ğ‘ ........................................ 51 

Tabela 3 â€“ Valores de (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘ para alguns valores de ğ‘ composto ................. 51 

Tabela 4 â€“ Crivo de Sundaram .................................................................................. 58 

Tabela 5 â€“ CÃ³digos de ordem invertida do alfabeto .................................................. 68 

 
 
 
 
 
SUMÃRIO 

1 INTRODUÃ‡ÃƒO ....................................................................................................... 12 

2 PROCEDIMENTOS METODOLÃ“GICOS............................................................... 14 

3 SOBRE OS NÃšMEROS PRIMOS .......................................................................... 16 

3.1 NÃºmeros naturais ................................................................................................ 16 

3.2 Conceitos iniciais sobre primos ........................................................................... 18 

3.3 NÃºmeros primos e sua infinitude ......................................................................... 19 

3.4 FÃ³rmulas para nÃºmeros primos ........................................................................... 23 

3.5 Outras funÃ§Ãµes sobre os nÃºmeros primos ........................................................... 24 

4 EVOLUÃ‡ÃƒO DOS TESTES DE PRIMALIDADE .................................................... 30 

4.1 Era prÃ©-computacional ........................................................................................ 30 

4.2 Era computacional ............................................................................................... 33 

5 ASPECTOS BÃSICOS DOS TESTES DE PRIMALIDADE ................................... 38 

5.1 Capacidade mental versus capacidade computacional ....................................... 38 

5.2 Custo de um algoritmo ........................................................................................ 39 

5.3 Testes de primalidade determinÃ­sticos e nÃ£o determinÃ­sticos ............................. 43 

5.4 Formas de classificaÃ§Ã£o ...................................................................................... 43 

6 TESTES CLÃSSICOS ........................................................................................... 45 

6.1 DivisÃ£o por tentativa ............................................................................................ 45 

6.2 Crivo de EratÃ³stenes ........................................................................................... 46 

6.3 Teste de Fermat .................................................................................................. 50 

6.4 Teste de Proth ..................................................................................................... 53 

6.5 Teste de PÃ©pin .................................................................................................... 54 

6.6 Teste de Lucas-Lehmer....................................................................................... 55 

6.7 Crivo de Sundaram ............................................................................................. 57 

7 TESTES COMPUTACIONAIS ............................................................................... 60 

7.1 Teste de Solovay-Strassen ................................................................................. 60 

 
 
 
7.2 Teste de Miller-Rabin .......................................................................................... 61 

7.3 Teste AKS ........................................................................................................... 64 

7.4 Outros mÃ©todos computacionais ......................................................................... 65 

8 APLICAÃ‡Ã•ES ........................................................................................................ 67 

9 CONCLUSÃƒO ........................................................................................................ 72 

REFERÃŠNCIAS ......................................................................................................... 75 

APÃŠNDICE A â€“ MÃXIMO DIVISOR COMUM E DEMONSTRAÃ‡Ã•ES ..................... 80 

APÃŠNDICE B â€“ NÃšMEROS PRIMOS E DEMONSTRAÃ‡Ã•ES ................................. 82 

ANEXO C â€“ CONGRUÃŠNCIAS E DEMONSTRAÃ‡Ã•ES ........................................... 83 

 
 
 
 
 
12 

1 INTRODUÃ‡ÃƒO  

Os nÃºmeros, quando concebidos em sua forma mais comum, remontam Ã  

ideia  de  contagem,  um  raciocÃ­nio  natural  para  quem  inicia  seu  processo  de 

aprendizado em matemÃ¡tica. Na medida que o conhecimento se expande, o indivÃ­duo 

passa a perceber que o ato de contar pode ser realizado de diversas formas, como o 

natural raciocÃ­nio de agrupar elementos de um conjunto para computar a quantidade 

destes de maneira mais Ã¡gil.  

A atividade de juntar membros de um grupo para dar maior celeridade Ã  

sua  contagem  pode  parecer  relativamente  simples,  entretanto  a  aÃ§Ã£o  inversa,  em 

diversos  casos,  Ã©,  contrariamente,  complexa.  Dessa  maneira,  para  conjuntos  com 

grandes quantidades de elementos, a tarefa de encontrar todos os subconjuntos de 

mesmo  tamanho  que  dividem  exatamente  aqueles  pode  representar  um  ato  bem 

complicado, especialmente quando nÃ£o se dispÃµe de ferramentas adequadas.   

Neste  raciocÃ­nio,  destacamos  os  nÃºmeros  primos,  um  tipo  peculiar  de 

conjunto que nÃ£o pode ser repartido em grupos menores, com exceÃ§Ã£o do unitÃ¡rio e 

daqueles com iguais nÃºmeros de elementos, ou seja, sÃ³ podem ser divididos por um 

e por eles mesmos.  

Logo, diante da necessidade de apresentar e esclarecer o funcionamento 

dos  mÃ©todos  de  localizaÃ§Ã£o  de  primos,  realizamos  o  presente  estudo,  por meio  de 

pesquisa  bibliogrÃ¡fica,  apoiado  nos  avanÃ§os  obtidos  no  estudo  destes  nÃºmeros  ao 

longo da histÃ³ria, o qual buscarÃ¡ identificar os testes de primalidade jÃ¡ desenvolvidos 

e analisar o desempenho destes, desde sua concepÃ§Ã£o mais simples atÃ© suas formas 

mais aprimoradas. 

O trabalho buscou apresentar as propriedades dos primos e sua forma de 

localizaÃ§Ã£o;  analisar  os  resultados  de  pesquisas  sobre  estes  nÃºmeros  e  suas 

implicaÃ§Ãµes  na  produÃ§Ã£o  de  mÃ©todos  para  sua 

localizaÃ§Ã£o;  esclarecer  as 

caracterÃ­sticas de funcionamento dos testes de primalidade, bem como sua evoluÃ§Ã£o; 

detalhar aspectos bÃ¡sicos dos algoritmos de localizaÃ§Ã£o de primos; apresentar testes 

de  primalidade  desenvolvidos  ao  longo  da  histÃ³ria;  discorrer  sobre  os  modernos 

processos computacionais voltados Ã  procura de primos cada vez maiores e, por fim, 

exibir as principais aplicaÃ§Ãµes dos testes de primalidade.  

 
 
13 

O  trabalho  estruturou-se  primeiramente  na  apresentaÃ§Ã£o  dos  nÃºmeros 

primos,  com  sua  conceituaÃ§Ã£o,  propriedades  e  teoremas.  Posteriormente,  foram 

apontadas algumas formas de localizÃ¡-los e exibir determinadas fÃ³rmulas e funÃ§Ãµes 

geradoras destes nÃºmeros.  

No 

intuito  de  detalhar  os 

testes  de  primalidade,  adotou-se  uma 

apresentaÃ§Ã£o por meio de uma linha histÃ³rica, delineando sua evoluÃ§Ã£o deste a Ã©poca 

da antiga GrÃ©cia atÃ© os tempos dos modernos computadores, com abordagem  aos 

sofisticados conceitos matemÃ¡ticos.  

Detalhou-se  caracterÃ­sticas  bÃ¡sicas  dos  testes  de  primalidade,  expondo 

sua evoluÃ§Ã£o de acordo com a capacidade do ser humano e da mÃ¡quina. Destacou-

se, tambÃ©m, seus custos computacionais e sua classificaÃ§Ã£o de acordo com a garantia 

de identificaÃ§Ã£o de primos.  

Abordou-se  diversos  testes  atrelados  Ã   linha  evolutiva  do  progresso 

tecnolÃ³gico.  Neste  sentido,  reunimos  alguns  dos  principais  testes  apresentados  ao 

longo da histÃ³ria, a saber: a DivisÃ£o por Tentativa, o Crivo de EratÃ³stenes, o Teste de 

Fermat, o Teste de Proth, o Teste de PÃ©pin, o Teste de Lucas-Lehmer e o Crivo de 

Sundaram,  todos  da  era  prÃ©-computacional.  Em  seguida,  expusemos  os  testes 

modernos da Ã©poca computacional, entre eles o Teste de Solovay-Strassen, o Teste 

de  Miller-Rabin  e  o  Teste  AKS,  alÃ©m  de  outros  mÃ©todos  computacionais  tambÃ©m 

recentes, como o Teste de Baillie â€“ PSW, o Teste APR e o Teste ECPP (Eliptic Curve 

Primality Proving). 

Por fim,  discorremos sobre as  principais aplicaÃ§Ãµes  encontradas para os 

testes  de  primalidade  atuais,  que  se  apoiam  no  fato  da  difÃ­cil  tarefa  de  fatoraÃ§Ã£o 

continuar sendo um desafio para os estudiosos da contemporaneidade. 

 
 
 
 
14 

2 PROCEDIMENTOS METODOLÃ“GICOS 

O  processo  de  compreensÃ£o  conceitual  e  procedimental  para  identificar 

nÃºmeros  primos  representa  um  grande  desafio  no  ramo  da  Teoria  dos  NÃºmeros. 

Quem inicia o estudo dos nÃºmeros primos precisa compreender suas caracterÃ­sticas 

e  saber  identificar  detalhes  da matÃ©ria,  aprofundando-se em  aritmÃ©tica,  de  forma a 

explorar argumentaÃ§Ãµes, demonstraÃ§Ãµes, provas e usos especÃ­ficos. 

Da  antiguidade  ao  mundo  moderno,  foram  muitos  os  estudos  buscando 

testes que comprovem a primalidade de um nÃºmero natural. ApÃ³s a seleÃ§Ã£o dos testes 

de primalidade a serem investigados, escolheu-se o tema deste trabalho, seguido pelo 

levantamento  bibliogrÃ¡fico  por  meio  de  leituras  de  livros,  artigos  fÃ­sicos  e  online, 

periÃ³dicos, dentre outros.  

Este trabalho modulou-se em obras de autores renomados, como Coutinho 

e Ribenboim, que tratam de testes de primalidade sob diversos pontos de vista, como 

os mÃ©todos com uso de exponenciaÃ§Ã£o, necessidade ou nÃ£o de fatoraÃ§Ã£o, algoritmos 

determinÃ­sticos e nÃ£o determinÃ­sticos etc. Representa tambÃ©m uma continuidade das 

pesquisas com temas direcionados Ã  localizaÃ§Ã£o de primos, encontradas em bancos 

de trabalhos acadÃªmicos, incluindo o repositÃ³rio de dissertaÃ§Ãµes do PROFMAT.  

A  metodologia  utilizada  foi  a  pesquisa  bibliogrÃ¡fica,  que  representa  uma 

etapa essencial  de  todo trabalho  cientÃ­fico e  exerce grande  influÃªncia  nas fases  de 

uma investigaÃ§Ã£o, ao passo que fundamenta teoricamente o objeto de estudo. 

A pesquisa bibliogrÃ¡fica, na visÃ£o de Fonseca (2002):  

Ã‰  feita  a  partir  do  levantamento  de  referÃªncias  teÃ³ricas  jÃ¡  analisadas,  e 
publicadas por meios escritos e eletrÃ´nicos, como livros, artigos cientÃ­ficos, 
pÃ¡ginas  de  web  sites.  Qualquer  trabalho  cientÃ­fico  inicia-se  com  uma 
pesquisa  bibliogrÃ¡fica,  que  permite  ao  pesquisador  conhecer  o  que  jÃ¡  se 
estudou  sobre  o  assunto.  Existem,  porÃ©m,  pesquisas  cientÃ­ficas  que  se 
baseiam  unicamente  na  pesquisa  bibliogrÃ¡fica,  procurando  referÃªncias 
informaÃ§Ãµes  ou 
teÃ³ricas  publicadas  com  o  objetivo  de 
conhecimentos  prÃ©vios  sobre  o  problema  a  respeito  do  qual  se  procura  a 
resposta (FONSECA, 2002, p. 32). 

recolher 

A  fim  de  garantir  uma  sÃ³lida  base  referencial,  procurou-se  fazer  um 

levantamento  de  literatura  de  autores  reconhecidos  na  temÃ¡tica,  tanto  no  cenÃ¡rio 

nacional quanto internacional. Nas consultas de publicaÃ§Ãµes na internet, fez-se uma 

seleÃ§Ã£o criteriosa de dissertaÃ§Ãµes, revistas, teses, livros digitalizados, dentre outros. 

Para assegurar a qualidade da pesquisa bibliogrÃ¡fica, as teses e dissertaÃ§Ãµes foram 

buscadas  no  banco  de  dados  da  CoordenaÃ§Ã£o  de  AperfeiÃ§oamento  de  Pessoal  de 

 
 
NÃ­vel  Superior  (CAPES),  no  sÃ­tio  eletrÃ´nico  do  PROFMAT,  na  Biblioteca  Digital 

Brasileira de Teses e DissertaÃ§Ãµes (BDTD), entre outros. 

15 

 
 
 
 
16 

3 SOBRE OS NÃšMEROS PRIMOS 

3.1 NÃºmeros naturais 

A  fim  de  estudar  detalhadamente  os  primos  e  os  mÃ©todos  para  sua 

localizaÃ§Ã£o,  vamos  conhecer  um  pouco  sobre  o  conjunto  dos  naturais.  A  aparente 

simplicidade  destes  nÃºmeros  pode  esconder  importantes  questÃµes  com  elevados 

nÃ­veis de complexidade. Nesse sentido, destacamos o estudo da Teoria dos NÃºmeros 

que, resumidamente, discorre acerca da propriedade dos nÃºmeros inteiros positivos. 

Sobre essa matÃ©ria, Stewart (2014) relata que: 

Os nÃºmeros naturais 1, 2, 3, 4, 5... sÃ£o claros, sem enfeites. Pode haver algo 
mais simples? Mas o exterior de simplicidade esconde profundezas ocultas, 
e  muitas  das  mais  desconcertantes  questÃµes  em  matemÃ¡tica  abordam  as 
propriedades  aparentemente  diretas  dos  nÃºmeros  inteiros.  Essa  Ã¡rea  Ã© 
conhecida como teoria dos nÃºmeros, e acaba se mostrando difÃ­cil exatamente 
porque seus ingredientes sÃ£o tÃ£o bÃ¡sicos (STEWART, 2014, p. 88). 

O conjunto dos nÃºmeros naturais Ã© intuitivamente um dos conceitos mais 

triviais do estudo da matemÃ¡tica. Associados Ã  ideia de contagem, estes algarismos 

proporcionam uma imediata noÃ§Ã£o de quantidade ao relacionar os elementos deste 

conjunto com os objetos quantificados. Vejamos sua representaÃ§Ã£o: 

â„• = {1,2,3,4,5, â€¦ } 

O conjunto dos naturais foi caracterizado com precisÃ£o no inÃ­cio do sÃ©culo 

passado,  conforme  exposto  por  Lima  (2013,  p.  23):  â€œDecorridos  muitos  milÃªnios, 

podemos hoje descrever concisa e precisamente o conjunto â„• dos nÃºmeros naturais, 

valendo-nos  da  notÃ¡vel  sÃ­ntese  feita  pelo  matemÃ¡tico  italiano  Giuseppe  Peano  no 

limiar do sÃ©culo 20â€.  

Assistamos, agora, os quatro axiomas de Peano: 

1. Seja ğ‘› um nÃºmero natural, entÃ£o ğ‘› possui um Ãºnico sucessor; 

2. Dados ğ‘š e ğ‘› naturais, se ğ‘› â‰  ğ‘š, entÃ£o o sucessor de ğ‘› Ã© diferente do sucessor de 

ğ‘š; 

3. O nÃºmero natural ğ‘š, representado por 1, Ã© o Ãºnico natural que nÃ£o Ã© sucessor de 

nenhum outro; 

4. Dado o conjunto ğ´, com ğ´ âŠ‚ â„•. Se 1 âˆˆ ğ´ e se o sucessor de todo elemento de ğ´ 

pertence a ğ´, entÃ£o ğ´ = â„•. 

 
 
17 

O axioma da induÃ§Ã£o, largamente utilizado em demonstraÃ§Ãµes, Ã© baseado 

no  quarto  axioma  de  Peano.  Este  mÃ©todo  Ã©  capaz  de  provar  que  no  conjunto  dos 

nÃºmeros  naturais estÃ£o  definidas  as  operaÃ§Ãµes  de  adiÃ§Ã£o  e  multiplicaÃ§Ã£o,  ou  seja, 

para ğ‘ e ğ‘ naturais, temos (ğ‘, ğ‘) â†¦ ğ‘ + ğ‘ e (ğ‘, ğ‘) â†¦ ğ‘ âˆ™ ğ‘.  

As  operaÃ§Ãµes  de  adiÃ§Ã£o  e  multiplicaÃ§Ã£o  possuem  as  seguintes 

propriedades, tambÃ©m provadas pelo axioma da induÃ§Ã£o1:  

1. Comutatividade: se ğ‘ e ğ‘ sÃ£o nÃºmeros naturais, entÃ£o ğ‘ + ğ‘ = ğ‘ + ğ‘ e ğ‘ âˆ™ ğ‘ = ğ‘ âˆ™ ğ‘ 

2. Associatividade: se ğ‘, ğ‘ e ğ‘ sÃ£o nÃºmeros naturais, entÃ£o ğ‘ + (ğ‘ + ğ‘) = (ğ‘ + ğ‘) + ğ‘ 

e ğ‘ âˆ™ (ğ‘ âˆ™ ğ‘) = (ğ‘ âˆ™ ğ‘) âˆ™ ğ‘ 

3. Distributividade: se ğ‘, ğ‘ e ğ‘ sÃ£o nÃºmeros naturais, entÃ£o ğ‘ âˆ™ (ğ‘ + ğ‘) = ğ‘ âˆ™ ğ‘ + ğ‘ âˆ™ ğ‘ 

4. Lei de Corte para AdiÃ§Ã£o: se ğ‘, ğ‘ e ğ‘ sÃ£o nÃºmeros naturais e ğ‘ + ğ‘ = ğ‘ + ğ‘, entÃ£o 

ğ‘ = ğ‘ 

5. Lei de Corte para AdiÃ§Ã£o: se ğ‘, ğ‘ e ğ‘ sÃ£o nÃºmeros naturais e ğ‘ + ğ‘ = ğ‘ + ğ‘, entÃ£o 

ğ‘ = ğ‘ 

Outra importante propriedade do conjunto dos nÃºmeros naturais Ã© a relaÃ§Ã£o 

de ordem, assim definida: dados ğ‘ e ğ‘ naturais, diz-se que ğ‘ â‰¤ ğ‘ (ğ‘ Ã© menor do que 

ou igual a ğ‘) para indicar que existe um ğ‘ natural, tal que ğ‘ = ğ‘ + ğ‘.  

A partir desta relaÃ§Ã£o, verifica-se as propriedades a seguir, provadas mais 

uma vez com ou auxÃ­lio do axioma da induÃ§Ã£o: 

1. Tricotomia: para ğ‘ e ğ‘ naturais, somente uma das possibilidades Ã© verdadeira:  

ğ‘ < ğ‘ 

ğ‘ < ğ‘ 

ğ‘ = ğ‘ 

2.  Transitividade  da  RelaÃ§Ã£o  de  Ordem:  sejam  ğ‘,  ğ‘  e  ğ‘  naturais,  se  ğ‘ < ğ‘  e  ğ‘ < ğ‘, 

entÃ£o ğ‘ < ğ‘ 

3. Monotonicidade: sejam ğ‘, ğ‘ e ğ‘ naturais, se ğ‘ < ğ‘, entÃ£o ğ‘ + ğ‘ < ğ‘ + ğ‘ e ğ‘ âˆ™ ğ‘ < ğ‘ âˆ™ ğ‘ 

4. Lei de Corte para Desigualdades: 

1 As demonstraÃ§Ãµes podem ser verificadas no capÃ­tulo 2 da obra de Lima (2013). 

 
 
 
18 

4.1. Se ğ‘, ğ‘ e ğ‘ sÃ£o nÃºmeros naturais e ğ‘ + ğ‘ < ğ‘ + ğ‘ entÃ£o ğ‘ < ğ‘  

4.2. Se ğ‘, ğ‘ e ğ‘ sÃ£o nÃºmeros naturais e ğ‘ âˆ™ ğ‘ < ğ‘ âˆ™ ğ‘ entÃ£o ğ‘ < ğ‘  

5. PrincÃ­pio da Boa OrdenaÃ§Ã£o: dado um conjunto nÃ£o vazio ğ‘‹ âŠ‚ â„•. Todo conjunto ğ‘‹ 

possui um menor elemento.  

3.2 Conceitos iniciais sobre primos 

No conjunto dos nÃºmeros naturais, um importante conjunto Ã© notadamente 

importante,  os  nÃºmeros  primos,  representantes  da  base  de  formaÃ§Ã£o  dos  demais 

elementos.  Um  nÃºmero  primo  Ã©  aquele  que  sÃ³  pode  ser  dividido  por  um  e  por  si 

mesmo, conforme destacado por Hefez (2014, p. 140), ao definir que: 

DefiniÃ§Ã£o  1.  â€œUm  nÃºmero  natural  maior  do  que  1  que  sÃ³  possui  como  divisores 

positivos 1 e ele prÃ³prio Ã© chamado de nÃºmero primo.â€ 

Se um natural ğ‘› > 1 nÃ£o Ã© primo, dizemos que ğ‘› Ã© composto. A partir da 

definiÃ§Ã£o de primo, um resultado bÃ¡sico, mas nÃ£o menos importante, Ã© o lema exposto 

abaixo: 

Lema 1. Todo nÃºmero par maior que 2 Ã© composto. 

DemonstraÃ§Ã£o. Se ğ‘› Ã© um nÃºmero par, entÃ£o pode ser escrito na forma 2ğ‘˜, com ğ‘˜ âˆˆ

â„•, como ğ‘› Ã© maior que 2, entÃ£o ğ‘› > 2 â‡’ 2ğ‘˜ > 2 â‡’ ğ‘˜ > 1, entÃ£o 2ğ‘˜ possui no mÃ­nimo 

os divisores 1, 2 e 2ğ‘˜, logo, por definiÃ§Ã£o, Ã© composto. 

Os primos sÃ£o costumeiramente chamados de Ã¡tomos da aritmÃ©tica, jÃ¡ que 

representam  o  seu  sustentÃ¡culo,  posto  que  a  construÃ§Ã£o  dos  nÃºmeros  naturais 

depende  de  fatores  primÃ¡rios.  Sautoy  (2007)  relata  que  este  fato,  hÃ¡  milÃªnios,  foi 

provado pelos gregos, conforme trecho a seguir: 

Os  gregos  da  Antiguidade  [...]  descobriram,  no  quarto  sÃ©culo  a.C.,  a 
capacidade dos primos de servir como blocos de construÃ§Ã£o para todos os 
nÃºmeros.  Eles  perceberam  que  todo  nÃºmero  podia  ser  gerado  pela 
multiplicaÃ§Ã£o  de  nÃºmeros  primos.  Embora  os  gregos  acreditassem 
erroneamente que fogo, ar, Ã¡gua e terra fossem os elementos constitutivos 
da matÃ©ria, foram precisos ao identificar os Ã¡tomos da aritmÃ©tica (SAUTOY, 
2007, p. 31). 

Este pensamento nos leva a um dos mais importantes resultados da Teoria 

dos NÃºmeros, o Teorema Fundamental da AritmÃ©tica, que afirma o seguinte: 

Teorema  1.  Todo  nÃºmero  inteiro  maior  do  que  1  Ã©  escrito  de  forma  Ãºnica  (com 

exceÃ§Ã£o da ordem dos fatores) como um produto de fatores primos. 

 
 
19 

DemonstraÃ§Ã£o. Dado um nÃºmero natural ğ‘› maior do que 1, se ğ‘› for primo, nÃ£o hÃ¡ o 

que se provar. Se ğ‘› for composto e ğ‘š1 > 1 for o menor fator positivo de ğ‘›, portanto 

primo, entÃ£o ele pode ser decomposto em ğ‘› = ğ‘š1 Â· ğ‘1. Se ğ‘1 for primo, a prova estarÃ¡ 

completa,  se  for  composto,  entÃ£o  ele  possui  ğ‘š2  como  menor  fator  positivo  primo, 

assim  ğ‘1 = ğ‘š2 âˆ™ ğ‘2,  logo  ğ‘› = ğ‘š1 âˆ™ ğ‘š2 âˆ™ ğ‘2.  Mantendo  o  raciocÃ­nio  e  sabendo  que  ğ‘› 

possui  um  nÃºmero  de  fatores  finitos,  temos  ğ‘› = ğ‘š1 Â· ğ‘š2 Â· ğ‘š3 Â· ğ‘š4 Â· â€¦ Â· ğ‘šğ‘›,  e  como 
ğ‘˜1 Â·

estes  fatores  nÃ£o  sÃ£o  essencialmente  distintos,  representamos  ğ‘›  como  ğ‘› = ğ‘š1
ğ‘˜ğ‘›, logo ğ‘› Ã© formado por um produto de fatores primos.  

ğ‘˜4 Â· â€¦ Â· ğ‘šğ‘›

ğ‘˜3 Â· ğ‘š4

ğ‘˜2 Â· ğ‘š3

ğ‘š2

Quanto Ã  unicidade, podemos provÃ¡-la por induÃ§Ã£o, da seguinte maneira: 

para  ğ‘› = 2,  prova-se  claramente  a  unicidade.  Supondo  sua  validade  para  inteiros 

maiores que 1 e menores que ğ‘›, vamos provar sua validade para valores iguais Ã  ğ‘›. 

Se ğ‘›  Ã© primo,  a  prova se  verifica  claramente.  Se  ğ‘›  Ã©  composto,  consideremos  que 

tenha  duas  fatoraÃ§Ãµes,  a  saber,  ğ‘› = ğ‘š1 Â· ğ‘š2 Â· ğ‘š3 Â· ğ‘š4 Â· â€¦ Â· ğ‘šğ‘ = ğ‘Ÿ1 Â· ğ‘Ÿ2 Â· ğ‘Ÿ3 Â· ğ‘Ÿ4 Â· â€¦ Â· ğ‘Ÿğ‘ , 

com ğ‘šğ‘ e ğ‘Ÿğ‘  primos. Devemos provar que ğ‘ = ğ‘  e que ğ‘šğ‘– = ğ‘Ÿğ‘— sÃ£o iguais, um a um. 

Como ğ‘š1|ğ‘Ÿ1 Â· ğ‘Ÿ2 Â· ğ‘Ÿ3 Â· ğ‘Ÿ4 Â· â€¦ Â· ğ‘Ÿğ‘ , entÃ£o ğ‘š1|ğ‘Ÿğ‘—. Sem perda de generalidade, iremos supor 

ğ‘š1|ğ‘Ÿ1. Como ğ‘š1 e ğ‘Ÿ1 sÃ£o primos, entÃ£o ğ‘š1 = ğ‘Ÿ1. Reordenando os termos, temos ğ‘š2 Â·

ğ‘š3 Â· ğ‘š4 Â· â€¦ Â· ğ‘šğ‘ = ğ‘Ÿ2 Â· ğ‘Ÿ3 Â· ğ‘Ÿ4 Â· â€¦ Â· ğ‘Ÿğ‘ .  Visto  que  1 < ğ‘š2 Â· ğ‘š3 Â· ğ‘š4 Â· â€¦ Â· ğ‘šğ‘ < ğ‘›,  entÃ£o  a 

hipÃ³tese demonstra que ğ‘ = ğ‘  e que, um a um, ğ‘šğ‘› = ğ‘Ÿğ‘ .  

Conforme afirmado por Hefez (2005, p.82), â€œdo ponto de vista da estrutura 

multiplicativa dos naturais, os nÃºmeros primos sÃ£o os mais simples e ao mesmo tempo 

sÃ£o  suficientes  para  gerar  todos  os  nÃºmeros  naturaisâ€.  Dessa  forma,  se  percebe  a 

importÃ¢ncia destes nÃºmeros, uma vez que sÃ£o a base de formaÃ§Ã£o na construÃ§Ã£o dos 

naturais e, portanto, servem de estudo na concepÃ§Ã£o de outros conjuntos numÃ©ricos.  

3.3 NÃºmeros primos e sua infinitude 

Ao longo dos anos, muito se descobriu acerca dos primos, como o fato de 

sua quantidade ser infinita, provado por Euclides em sua obra Os Elementos, segundo 

narrado por Boyer (1974, p. 84), que nos apresenta a ProposiÃ§Ã£o 20: â€œnÃºmeros primos 

sÃ£o mais do que qualquer quantidade fixada de nÃºmeros primos. Isto Ã©, Euclides dÃ¡ 

aqui a prova elementar bem conhecida do fato que hÃ¡ infinitos nÃºmeros primos.â€ A 

prova apresentada por Euclides, para esta notÃ¡vel descoberta, foi a seguinte:  

ProposiÃ§Ã£o 1. Os nÃºmeros primos sÃ£o infinitos.  

 
 
20 

DemonstraÃ§Ã£o.  Vamos  considerar  que  o  nÃºmero  de  primos  seja  finito.  Temos, 

portanto a seguinte sequÃªncia de primos: ğ‘›1, ğ‘›2, ğ‘›3, ğ‘›4, â€¦ , ğ‘›ğ‘Ÿ. Seja, agora, o nÃºmero 

ğ‘ = ğ‘›1 âˆ™   ğ‘›2 âˆ™  ğ‘›3 âˆ™ ğ‘›4 âˆ™ â€¦ âˆ™ ğ‘›ğ‘Ÿ + 1. Se ğ‘ for primo, entÃ£o evidentemente nÃ£o pertence ao 

conjunto  dos  elementos  da  sequÃªncia  considerada,  pois  supomos  existir  apenas  ğ‘Ÿ 

deles. Agora, se ğ‘ for composto, considerando o Teorema Fundamental da AritmÃ©tica, 

entÃ£o  ğ‘  possui  como  um  de  seus 

fatores  um  elemento  do  conjunto 

{ğ‘›1, ğ‘›2, ğ‘›3, ğ‘›4, â€¦ , ğ‘›ğ‘Ÿ}, porÃ©m 1 nÃ£o pode ser dividido por nenhum deles. Em ambos os 

casos a suposiÃ§Ã£o se mostra falsa, logo existe um nÃºmero primo maior que ğ‘›ğ‘Ÿ. 

Posteriormente,  outras  demonstraÃ§Ãµes  foram  apresentadas  sobre  a 

infinitude dos nÃºmeros primos. Exibiremos uma formulada por Leonhard Euler2, para 

a qual precisaremos apresentar, primeiramente, dois importantes resultados.  

Lema 2. A sÃ©rie harmÃ´nica 

âˆ

ğ‘›=1

Ã© divergente. 

âˆ‘ (

1
ğ‘›

)

= 1 +

1
2

+

1
3

+

1
4

+ â‹¯ +

1
ğ‘›

+ â‹¯ 

(1) 

Sua  primeira  demonstraÃ§Ã£o  foi  dada  pelo  francÃªs  Nicole  Oresme  (1325-

1382), que atravÃ©s do agrupamento dos termos da sÃ©rie (1), comparou-a com outra 

sÃ©rie, a fim de se chegar ao resultado (ÃVILA, 1995), conforme apresentaÃ§Ã£o a seguir: 

DemonstraÃ§Ã£o (Lema 2). Seja a sÃ©rie 

âˆ
âˆ‘(ğ‘ğ‘›)
ğ‘›=1

= 1 +

1
2

+

1
3

+

1
4

+

1
5

+

1
6

+

1
7

+

1
8

+

1
9

â€¦ +

1
ğ‘›

+ â‹¯ 

(2) 

Com ğ‘ğ‘› = 1/ğ‘›, 

Apesar da sÃ©rie parecer convergente, afinal  

1
ğ‘¥

lim
ğ‘¥â†’âˆ

= 0 

2  MatemÃ¡tico  suÃ­Ã§o  que  viveu  entre  os  anos  de  1707  e  1783.  Foi  autor  de  diversos  trabalhos 
matemÃ¡ticos e realizou importantes estudos a respeito da Teoria dos NÃºmeros, incluindo os nÃºmeros 
primos,  sobre  os  quais  fez  descobertas  que  influenciaram  grandes  avanÃ§os  no  estudo  destes 
(BOYLER, 1974). 

 
 
 
 
 
21 

Vamos demonstrar que Ã© divergente, 

Dada a sÃ©rie  

âˆ‘ ğ‘ğ‘š = 1 +

1
2

+

1
4

+

1
4

+

1
8

+

1
8

+

1
8

+

1
8

+ â‹¯ 

(3) 

Na qual cada termo Ã© formado a partir da seguinte relaÃ§Ã£o: 

ğ‘1 = ğ‘1, ğ‘2 = ğ‘2, ğ‘3 = ğ‘4, ğ‘4 = ğ‘4, ğ‘5 = ğ‘8, ğ‘6 = ğ‘8, ğ‘7 = ğ‘8, ğ‘8 = ğ‘8,  

Mantendo esse raciocÃ­nio indefinidamente, temos: 

âˆ‘ ğ‘ğ‘› = 1 +

1
2

+ (

1
4

+

1
4

) + (

1
8

+

1
8

+

1
8

+

1
8

) + â‹¯ = 1 +

1
2

+

1
2

+

1
2

+ â‹¯ 

(4) 

Como ğ‘ğ‘› = ğ‘ğ‘š, para ğ‘› = ğ‘š e ğ‘ğ‘› < ğ‘ğ‘š, para ğ‘› â‰  ğ‘š, temos 

âˆ‘ ğ‘ğ‘› < âˆ‘ (

âˆ

ğ‘›=1

1
ğ‘ğ‘›

)

Como  âˆ‘ ğ‘ğ‘›  Ã©  claramente  divergente,  conclui-se  que  âˆ‘

âˆ
ğ‘›=1

(

1
ğ‘ğ‘›

)

  tambÃ©m  Ã© 

divergente. Logo a sÃ©rie harmÃ´nica Ã© divergente.  

Agora, vamos provar o segundo resultado. 

Seja um nÃºmero primo ğ‘, entÃ£o 

1
ğ‘

< 1 

Dada, agora,  a  sÃ©rie geomÃ©trica â€“  soma dos  termos  de uma  progressÃ£o 

geomÃ©trica â€“ cuja razÃ£o Ã© 1/ğ‘ e primeiro termo Ã© 1, temos: 

âˆ

âˆ‘

ğ‘›=0

1
ğ‘ğ‘›

=

1

1 âˆ’

1
ğ‘

De forma anÃ¡loga, seja ğ‘ outro primo, com ğ‘ â‰  ğ‘, temos 

âˆ

âˆ‘

ğ‘›=0

1
ğ‘ğ‘›

=

1

1 âˆ’

1
ğ‘

(5) 

(6) 

 
 
 
 
 
 
 
 
 
22 

Assim, multiplicando os membros de (5) por (7), respectivamente, temos 

âˆ

âˆ‘

ğ‘›=0

1
ğ‘ğ‘›

âˆ

âˆ™ âˆ‘

ğ‘›=0

1
ğ‘ğ‘›

= (

1

1 âˆ’

1
ğ‘

1

) (

1 âˆ’

) 

1
ğ‘

(1 +

1
ğ‘

+

1
ğ‘2 +

1
ğ‘3 + â‹¯ +

1
ğ‘ğ‘› + â‹¯ ) (1 +

1
ğ‘

+

1
ğ‘2 +

1
ğ‘3 + â‹¯ +

1
ğ‘ğ‘› + â‹¯ ) = (

1

1 âˆ’

1

) (

1 âˆ’

1
ğ‘

) 

1
ğ‘

1 +

1
ğ‘

+

1
ğ‘

+

1
ğ‘ğ‘

+

1
ğ‘2 +

1
ğ‘2 + â‹¯ = (

1

1 âˆ’

1
ğ‘

1

) (

1 âˆ’

) 

1
ğ‘

(7) 

DaÃ­, sobrevÃ©m o seguinte fato: 

O primeiro membro representa a soma de todas as formas possÃ­veis dos 

inversos  de  ğ‘ğ‘ğ‘ğ‘,  com  ğ‘ â‰¥ 0 ğ‘’ ğ‘ â‰¥ 0,  os  quais,  pelo  Teorema  Fundamental  da 

AritmÃ©tica, sÃ£o contados uma Ãºnica vez, a menos da ordem dos fatores.  

Por fim, apresentaremos a prova de Euler sobre a infinidade dos nÃºmeros 

primos. 

DemonstraÃ§Ã£o  (ProposiÃ§Ã£o  1).  Vamos  supor  que  ğ‘1, ğ‘2, ğ‘3, ğ‘4, â€¦ , ğ‘ğ‘Ÿ  sejam  todos  os 

nÃºmeros primos, em nÃºmero finito, e considerar a seguintes igualdades 

âˆ

âˆ‘

ğ‘›=0

1
ğ‘›
ğ‘1

âˆ

âˆ‘

ğ‘›=0

1
ğ‘›
ğ‘2

âˆ

âˆ‘

ğ‘›=0

1
ğ‘›
ğ‘ğ‘Ÿ

=

1

1 âˆ’

1
ğ‘1

=

â‹® 

=

1

1 âˆ’

1
ğ‘2

1

1 âˆ’

1
ğ‘ğ‘Ÿ

Para ğ‘– = 1, 2, 3, â€¦ , ğ‘Ÿ 

Agora,  multiplicando  os  respectivos  membros  das  igualdades  formadas 

para todos os ğ‘Ÿ, obtemos 

 
 
 
 
 
 
ğ‘Ÿ

âˆ

âˆ (âˆ‘

ğ‘–=1

ğ‘›=0

1
ğ‘›
ğ‘ğ‘–

ğ‘Ÿ

)

= âˆ (

1

ğ‘–=1

1 âˆ’

)

1
ğ‘ğ‘–

23 

(8) 

De  onde  conclui-se,  pelo  resultado  (7)  e  pelo  Teorema  Fundamental  da 

AritmÃ©tica, que o primeiro membro Ã© composto pela soma dos inversos de todos os 

nÃºmeros naturais. 

Deste modo, pelo resultado (1) e como a ordem dos termos nÃ£o alterarÃ¡ o 

resultado,  jÃ¡  que  todos  sÃ£o  positivos,  resulta  que  o  primeiro  membro  Ã©  divergente, 

logo, Ã© infinito, contudo, o segundo membro Ã© finito, um absurdo.  

Conclui-se, portanto, que os nÃºmeros primos sÃ£o infinitos. 

3.4 FÃ³rmulas para nÃºmeros primos 

A  notabilidade  dos  nÃºmeros  primos  reside,  em  grande  parte,  na  sua 

localizaÃ§Ã£o imprevisÃ­vel, ou seja, na cadeia de sucessÃ£o de nÃºmeros naturais, e por 

nÃ£o ter sido encontrada, ainda, uma forma precisa de se identificar indefinidamente o 

prÃ³ximo  primo.  Esta  lacuna  na  compreensÃ£o  destes  nÃºmeros  fora  constatada  hÃ¡ 

sÃ©culos, conforme percebido nas palavras de Euler, comentadas por Sautoy (2007): 

PorÃ©m, atÃ© para o grande Euler foi difÃ­cil encontrar uma fÃ³rmula simples que 
gerasse  todos  os  primos.  Em  1751,  ele  escreveu  que  â€œhÃ¡  alguns  mistÃ©rios 
nos quais a mente humana jamais penetrarÃ¡. Para nos convencermos desse 
fato, basta fitarmos as tabelas de primos e perceberemos que ali nÃ£o reina 
qualquer  ordem  ou  regraâ€.  Parece  paradoxal  que  os  objetos  fundamentais 
sobre  os  quais  construÃ­mos  nosso  organizado  mundo  matemÃ¡tico  se 
comportem de maneira tÃ£o irregular e imprevisÃ­vel (SAUTOY, 2007, p. 55). 

Na  tentativa  de  localizar  primos,  foram  propostas  algumas  fÃ³rmulas 

capazes  de  identificÃ¡-los,  como  a  de  Pierre  de  Fermat3,  que,  erroneamente,  foi 

admitida  por  seu  autor  como  capaz  de  encontrar  infinitos  primos.  Os  NÃºmeros  de 
Fermat, provenientes da fÃ³rmula ğ¹ğ‘› =   22ğ‘›
0, ğ‘› = 1, ğ‘› = 2, ğ‘› = 3  ğ‘’  ğ‘› = 4,  contudo,  ela  falha  para  ğ‘› = 5,  dado  que  este  valor 

+ 1, de fato sÃ£o primos para valores de ğ‘› =

representa  um  nÃºmero  composto,  pois  ğ¹5 =  4.294.967.297 = 641 âˆ™ 6.700.417,  fato 

provado, em 1732 por Euler (HEFEZ, 2005).  

3 Jurista e pesquisador matemÃ¡tico que viveu entre os anos de 1601 e 1665. Fermat, assim como Euler, 
realizou importantes pesquisas em diversas Ã¡reas da matemÃ¡tica, contudo foi na Teoria dos NÃºmeros 
que deixou sua maior influÃªncia (STEWART, 2014). 

 
 
 
 
 
24 

Aliada Ã  capacidade desta ferramenta de encontrar nÃºmeros primos para 

os  primeiros  quatro  valores  de  ğ‘›,  existe  a  frustraÃ§Ã£o  de  nunca  ter  sido  encontrado 

outros alÃ©m destes, pois, atualmente, o maior primo conhecido gerado pela fÃ³rmula 

de Fermat Ã© ğ¹4 = 65537 (RIBENBOIM, 2014). 

Outra forma de localizar primos tambÃ©m foi considerada pelo francÃªs Marin 

Mersenne (1588-1648), que propÃ´s nÃºmeros na forma 2ğ‘š âˆ’ 1, com ğ‘š primo, capazes 

de gerar primos, como ocorre com ğ‘š = 2, ğ‘š =  3 e ğ‘š =  5, contudo isso nÃ£o ocorre 

indefinidamente,  jÃ¡  que,  por  exemplo,  para  ğ‘š = 11,  obtÃªm-se  2047 = 89 âˆ™ 23. 
Portanto,  define-se  como  NÃºmero de  Mersenne  nÃºmeros na forma  ğ‘€ğ‘ = 2ğ‘ âˆ’ 1,  no 

qual ğ‘ Ã© primo. Se ğ‘€ğ‘ for primo, entÃ£o serÃ¡ denominado Primo de Mersenne.  

Diversos primos de Mersenne jÃ¡ foram identificados, contudo ainda nÃ£o se 

tÃªm provas sobre sua infinidade. Os maiores primos jÃ¡ localizados sÃ£o de Mersenne 

e detÃ©m o recorde do maior primo conhecido, registrado em janeiro de 2019, o qual 

bateu seu antecessor, que tambÃ©m era do mesmo tipo. O nÃºmero pode ser escrito 

como 282589933 âˆ’ 1, com 24.862.048 dÃ­gitos (IMPA, 2019).  

As tentativas de localizar primos por intermÃ©dio de fÃ³rmulas nÃ£o findaram 

com  Fermat  e  Mersenne.  Alguns  grandes estudiosos  propuseram  mÃ©todos  para  se 

chegar Ã queles, como Euler, que apresentou o seguinte teorema: 

Seja  a  funÃ§Ã£o  ğ‘“: â„¤+ â†’ â„¤,  definida  por  ğ‘“(ğ‘¥) = ğ‘¥2 + ğ‘¥ + 41.  Se  0 < ğ‘¥ < 39, 

entÃ£o ğ‘“ assumirÃ¡ valores primos.  

De 

fato,  para  ğ‘¥ = 0, 1, 2, 3, 4, â€¦ ,39, 

temos,  respectivamente,  ğ‘“(ğ‘¥) =

41, 43, 47, 53, 61, â€¦ , 1601,  os  quais  sÃ£o  primos.  A  funÃ§Ã£o  falha  para  ğ‘¥ = 40,  pois 

ğ‘“(40) = 1681 = 41Â². 

PolinÃ´mios da forma ğ‘¥2 + ğ‘¥ + ğ‘, onde ğ‘ Ã© um nÃºmero primo, possui como 

melhor resultado o de Euler, apresentado anteriormente, em termos de quantidades 

de valores primos iniciais sucessivos (RIBENBOIM, 2014). 

3.5 Outras funÃ§Ãµes sobre os nÃºmeros primos 

Os esforÃ§os voltados Ã  procura de funÃ§Ãµes definidoras de primos ainda nÃ£o 

revelaram  resultados  proeminentes,  no  entanto  um  tipo  especial  de  funÃ§Ã£o  tem 

mostrado grande progresso. A funÃ§Ã£o ğœ‹(ğ‘¥), que representa a quantidade de nÃºmeros 

 
 
25 

primos entre 1 e ğ‘¥, tem sido estudada hÃ¡ sÃ©culos, desde a inovadora forma de lidar 

com os primos, iniciada pelo matemÃ¡tico alemÃ£o Carl Friedrich Gauss.  

Gauss  estimou  que  a  quantidade  de  primos  entre  1  e  ğ‘¥  seria  ğ‘¥ log ğ‘¥

â„

  e 

posteriormente refinou-a por meio da funÃ§Ã£o.  

ğ‘¥

Li(ğ‘¥) = âˆ«
2

ğ‘‘ğ‘¡
log ğ‘¡

Em seguida, a partir desta ideia, desenvolveu-se o Teorema dos NÃºmeros 

Primos. 

lim
ğ‘¥â†’âˆ

ğœ‹(ğ‘¥)
ğ‘¥
ln ğ‘¥

= 1 

No  qual  o  limite  entre  o  quociente  de  ğœ‹(ğ‘¥)  e  ğ‘¥/ln ğ‘¥,  quando  ğ‘¥  tende  ao 

infinito, Ã© 1, ou seja, ğœ‹(ğ‘¥) tende a se aproximar de ğ‘¥/ln ğ‘¥ Ã  medida que o valor de ğ‘¥ 

aumenta. Este teorema foi provado por Jacques Hadamard4 e Charles de La VallÃ©e 

Poussin5, de forma independente, em 1896 (MOREIRA, MARTINEZ, 2010). 

Outro  importante  resultado  relacionado  aos  nÃºmeros  primos  foi  revelado 

pelo  estudo  da  funÃ§Ã£o  zeta  (ğœ),  representada  pela  letra  grega  que  leva  seu  nome. 

Euler foi um dos primeiros a apresentar importantes aspectos dessa funÃ§Ã£o, a qual 

recebe a designaÃ§Ã£o de FunÃ§Ã£o Zeta de Euler (Dâ€™AMBROSIO, 2008). 

A funÃ§Ã£o ğœ: â„ â†’ â„, Ã© definida por: 

ğœ(ğ‘¥) = 1 +

1
2ğ‘¥ +

1
3ğ‘¥ +

1
4ğ‘¥ + â‹¯ +

1
ğ‘›ğ‘¥ + â‹¯ = âˆ‘

1
ğ‘›ğ‘¥

(9) 

âˆ

ğ‘›=1

Os primeiros registros do desenvolvimento destas somas infinitas vÃªm da 

Ã©poca dos gregos, na qual PitÃ¡goras descobriu uma relaÃ§Ã£o harmÃ´nica entre as notas 

musicais e os nÃºmeros 1, 1 2â„ , 1 3â„  e 1 4â„  (SAUTOY, 2007).  

4 Jacques Hadamard (1865-1963) foi um matemÃ¡tico francÃªs cujo resultado mais conhecido Ã© a prova 
do  Teorema  dos  NÃºmeros  Primos,  apresentada  em  1896,  paralelamente  Ã   demonstrada  por  VallÃ©e 
Poussin, no mesmo ano (O'CONNOR, ROBERTSON, 2003). 
5 Charles Jean Gustave Nicolas Baron de la VallÃ©e Poussin (1866-1962) foi um matemÃ¡tico belga, mais 
conhecido por sua obra principal, Curso de AnÃ¡lise, e por sua prova do Teorema dos NÃºmeros Primos, 
apresentada  em  1896,  que  tambÃ©m  foi  provada  por  Hadamard,  no  mesmo  ano,  mas  de  forma 
independente (O'CONNOR, ROBERTSON, 2001). 

 
 
 
 
 
 
26 

Para  ğ‘¥ = 1,  provou-se  por  (1)  que  a  funÃ§Ã£o  tende  ao  infinito,  contudo  o 

mesmo  nÃ£o  ocorre  para  valores  acima  de  1,  fato  observado  por  Euler.  Este 

matemÃ¡tico  tambÃ©m  mostrou  que  para  ğ‘¥ = 2,  ela  converge  para  ğœ‹Â²/6  e,  de  forma 

generalizada, que para todo ğ‘¥ > 1, a sÃ©rie âˆ‘

âˆ
ğ‘›=1

1
ğ‘›ğ‘¥

 Ã© convergente (RIBENBOIM, 2014). 

Ainda sobre a funÃ§Ã£o ğœ, Euler tambÃ©m percebeu uma notÃ¡vel conexÃ£o entre 

esta  e  os  nÃºmeros  primos,  ao  verificar  a  seguinte  relaÃ§Ã£o  entre  aquela  soma  e  o 

produto exposto abaixo. 

ğœ(ğ‘¥) = âˆ (

ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘šğ‘œ

1
1 âˆ’ ğ‘âˆ’ğ‘¥)

(10) 

Para ğ‘¥ > 1, denomina-se Produto de Euler.  

Este produto surge a partir da expansÃ£o das seguintes sÃ©ries: 

Dada a sÃ©rie geomÃ©trica  

âˆ

âˆ‘

ğ‘›=0

1
ğ‘ğ‘›ğ‘¥

Com ğ‘ primo e ğ‘¥ > 1. Temos, portanto 

âˆ

âˆ‘

ğ‘›=0

âˆ

âˆ‘

ğ‘›=0

âˆ

âˆ‘

ğ‘›=0

1
2ğ‘›ğ‘¥

1
3ğ‘›ğ‘¥

1
5ğ‘›ğ‘¥

âˆ

âˆ‘

ğ‘›=0

1
ğ‘ğ‘›ğ‘¥

= 1 +

1
2ğ‘¥ +

1
22ğ‘¥ +

1
23ğ‘¥ + â‹¯ +

1
2ğ‘›ğ‘¥ + â‹¯ =

1
1 âˆ’ 2âˆ’ğ‘¥ 

= 1 +

1
3ğ‘¥ +

1
32ğ‘¥ +

1
33ğ‘¥ + â‹¯ +

1
3ğ‘›ğ‘¥ + â‹¯ =

1
1 âˆ’ 3âˆ’ğ‘¥ 

= 1 +

1
5ğ‘¥ +

1
52ğ‘¥ +

1
53ğ‘¥ + â‹¯ +

1
5ğ‘›ğ‘¥ + â‹¯ =

1
1 âˆ’ 5âˆ’ğ‘¥ 

â‹® 

= 1 +

1
ğ‘ğ‘¥ +

1
ğ‘2ğ‘¥ +

1
ğ‘3ğ‘¥ + â‹¯ +

1
ğ‘ğ‘›ğ‘¥ + â‹¯ =

1
1 âˆ’ ğ‘âˆ’ğ‘¥ 

â‹® 

Dessa forma, por (8) e pelo Teorema Fundamental da AritmÃ©tica, tem-se, 

atravÃ©s do produto dos primeiros membros de cada uma das igualdades anteriores, a 

 
 
 
 
 
soma do inverso da enÃ©sima potÃªncia de todos os nÃºmeros naturais, que igualada ao 

produto do Ãºltimo membro das respectivas igualdades, obtÃ©m-se 

27 

1 +

1
2ğ‘¥ +

1
3ğ‘¥ +

1
4ğ‘¥ + â‹¯ +

1
ğ‘›ğ‘¥ + â‹¯ = (

1
1 âˆ’ 2âˆ’ğ‘¥) (

1
1 âˆ’ 3âˆ’ğ‘¥) (

1

1 âˆ’ 5âˆ’ğ‘¥) âˆ™ â€¦ âˆ™ (

1

1 âˆ’ ğ‘âˆ’ğ‘¥) âˆ™ â€¦ â‡’ 

âˆ

âˆ‘

ğ‘›=1

1
ğ‘›ğ‘¥

= âˆ (

ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘šğ‘œ

1
1 âˆ’ ğ‘âˆ’ğ‘¥)

â‡’ 

ğœ(ğ‘¥) = âˆ (

ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘šğ‘œ

1
1 âˆ’ ğ‘âˆ’ğ‘¥)

(11) 

Por fim, obtemos o produto de Euler, para ğ‘¥ > 1, o qual evidenciou que a 

funÃ§Ã£o ğœ relaciona-se com os nÃºmeros primos, percebidos em cada um dos fatores 

do produto formado.  

Em 1859, Bernard Riemann6 publicou um artigo intitulado Sobre o nÃºmero 

de  primos  menores  do  que  uma  dada  grandeza,  no  qual  realiza  uma  abordagem 

inovadora sobre os nÃºmeros primos. Ao examinar a funÃ§Ã£o ğœ, ele a considerou como 

definida  no  campo  dos  complexos,  resultando  na  designaÃ§Ã£o  de  FunÃ§Ã£o  Zeta  de 

Riemann. 

Riemann percebeu que os zeros desta funÃ§Ã£o estavam relacionados com 

os nÃºmeros primos. Verifiquemos a funÃ§Ã£o de Riemann, representada por. 

âˆ
ğ‘…(ğ‘¥) = âˆ‘
ğ‘›=1

ğœ‡(ğ‘›)
ğ‘›

ğ¿ğ‘–( âˆšğ‘¥ğ‘›

) 

Na qual ğœ‡(ğ‘›) Ã© a funÃ§Ã£o de MÃ¶bius, ğœ‡: â„• â†’ {âˆ’1,0,1}, definida como: 

ğœ‡(ğ‘›) = {

1, ğ‘ ğ‘’ ğ‘› = 1;                                                                                  
(âˆ’1)ğ‘, ğ‘ ğ‘’ ğ‘› Ã© ğ‘ğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘¡ğ‘œ ğ‘‘ğ‘’ ğ‘ ğ‘“ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘’ğ‘  ğ‘ğ‘Ÿğ‘–ğ‘šğ‘œğ‘  ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘–ğ‘›ğ‘¡ğ‘œğ‘ ;
  0, ğ‘ ğ‘’ ğ‘› ğ‘¡ğ‘’ğ‘š ğ‘¢ğ‘š ğ‘“ğ‘ğ‘¡ğ‘œğ‘Ÿ ğ‘ğ‘¢ğ‘ğ‘‘ğ‘Ÿğ‘ğ‘‘ğ‘œ.                                            

6 Georg Friedrich  Bernhard  Riemann foi  um matemÃ¡tico alemÃ£o  que viveu entre  os anos de 1826 e 
1866. Suas obras influenciaram significativamente a Geometria, AnÃ¡lise e Teoria dos NÃºmeros. Seus 
trabalhos sobre Geometria Diferencial e AnÃ¡lise MatemÃ¡tica serviram de base para relevantes estudos 
em diversas Ã¡reas da ciÃªncia, como a fÃ­sica moderna. Ã‰ de sua autoria o trabalho sobre primos que 
exerceu forte  impacto  na forma de pensar desses nÃºmeros, o  On  the  number of primes less than  a 
given magnitude (Sobre o nÃºmero de primos menores do que uma dada grandeza), publicado em 1859. 
Esta obra serviu como principal referÃªncia para o prova do a dos NÃºmeros Primos e como revelaÃ§Ã£o 
de um dos problemas mais importantes em Teoria dos NÃºmeros, a HipÃ³tese de Riemann (O'CONNOR 
e ROBERTSON, 1998). 

 
 
 
 
 
 
28 

A  funÃ§Ã£o  ğ‘…  aproxima  significativamente  o  resultado  de  ğ‘…(ğ‘¥)  ao  valor  de 

ğœ‹(ğ‘¥).  AtravÃ©s  desta  nova  funÃ§Ã£o,  Riemann  estimou  com  grande  aproximaÃ§Ã£o  o 

resultado da contagem dos primos atÃ© um dado nÃºmero, refinando expressivamente 

os valores encontrados pela funÃ§Ã£o de Gauss, conforme dados da tabela a seguir: 

Tabela 1 â€“ ComparaÃ§Ã£o entre as funÃ§Ãµes ğ¿ğ‘–(ğ‘¥) e ğ‘…(ğ‘¥) ao serem relacionadas com os valores de ğœ‹(ğ‘¥) 

ğ‘¥ 
108 
109 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 

ğœ‹(ğ‘¥) 
5 761 455 
50 847 534 
455 052 511 
4 118 054 813 
37 607 912 018 
346 065 536 839 
3 204 941 750 802 
29 844 570 422 669 
279 238 341 033 925 
2 623 557 157 654 233 
24 739 954 287 740 860 
234 057 667 276 344 607 
2 220 819 602 560 918 840 
21 127 269 486 018 731 928 
201 467 286 689 315 906 290 

ğ¿ğ‘–(ğ‘¥) âˆ’ ğœ‹(ğ‘¥) 
754 
1 701 
3 104 
11 588 
38 263 
108 971 
314 890 
1 052 619 
3 214 632 
7 956 589 
21 949 555 
99 877 775 
222 744 643 
597 394 254 
1 932 355 208 

ğ‘…(ğ‘¥) âˆ’ ğœ‹(ğ‘¥) 
97 
-79 
-1 828 
-2 318 
-1 476 
-5 773 
-19 200 
73 218 
327 052 
-598 255 
-3 501 366 
23 884 333 
-4 891 825 
-86 432 204 
-127 132 665 

Fonte: (RIBENBOIM, 2014) 

Apesar desta  ampla  aproximaÃ§Ã£o,  a  fÃ³rmula  de  Riemann  ainda  continha 

erros, entretanto os nÃºmeros complexos, para os quais a funÃ§Ã£o zeta resultava em 

zero, poderiam corrigi-los, os chamados zeros da funÃ§Ã£o zeta, conforme observado 

nas palavras de Sautoy (2007): 

Riemann  fez  a  descoberta  fascinante  de  que  o  modo  de  corrigir  sua 
estimativa  dos  nÃºmeros  de  primos  estava  codificado  nas  diferentes  alturas 
dessas ondas. A funÃ§Ã£o ğ‘…(ğ‘) lhe dava uma contagem razoavelmente boa do 
nÃºmero de primos atÃ© ğ‘. PorÃ©m, ele descobriu que, ao acrescentar a essa 
estimativa a altura de cada onda sobre o nÃºmero ğ‘, poderia obter o nÃºmero 
exato  de  primos.  O  erro  era  completamente  eliminado.  Assim,  Riemann 
descobriu o CÃ¡lice Sagrado que Gauss havia buscado: a fÃ³rmula exata para 
contar o nÃºmero de primos atÃ© ğ‘ (SAUTOY, 2007, p. 101). 

As  ondas  supramencionadas  caracterizam-se  pela  posiÃ§Ã£o  de  cada  zero 

da  funÃ§Ã£o  zeta.  A  expressÃ£o  de  ğœ‹(ğ‘¥)  em  relaÃ§Ã£o  Ã   ğ‘…(ğ‘¥),  com  o  termo  de  erro  de 

aproximaÃ§Ã£o, pode ser verificada a seguir. 

ğœ‹(ğ‘¥) = ğ‘…(ğ‘¥) âˆ’ âˆ‘ ğ‘…(ğ‘¥ğœŒ

) 

ğœŒ

 
 
29 

Cuja somaÃ§Ã£o estende-se a todos os zeros ğœŒ nÃ£o-triviais7 da funÃ§Ã£o zeta, 

contados com sua devida multiplicidade (RIBENBOIM, 2014). 

Riemann conjecturou que todos os zeros nÃ£o-triviais estavam na mesma 

linha,  ou  seja,  sobre  Re(ğ‘ ) =

1
,  portanto,  da  forma  ğœŒ =
2

1

2

+ ğ‘–ğ‘¡.  Esta  Ã©  a  conhecida 

HipÃ³tese de Riemann, problema nÃ£o provado atÃ© os dias atuais.  

7 A funÃ§Ã£o zeta possui zeros simples nos pontos âˆ’2, âˆ’4, âˆ’6, â€¦, os chamados zeros triviais, e os zeros 
no  domÃ­nio  crÃ­tico,  definido  como  o  conjunto  dos  nÃºmeros  complexos  ğ‘   tais  que  0 â‰¤ Re(ğ‘ ) â‰¤ 1,  os 
chamados zeros nÃ£o-triviais (RIBENBOIM, 2014). 

 
 
 
 
 
 
 
 
 
30 

4 EVOLUÃ‡ÃƒO DOS TESTES DE PRIMALIDADE 

Como  jÃ¡  salientado,  identificar  nÃºmeros  primos  pode  ser  um  trabalho 

excessivamente difÃ­cil, uma vez que Ã© preciso fazer sucessivas divisÃµes atÃ© concluir 

que  nÃ£o  Ã©  possÃ­vel  encontrar  fatores  menores  diferentes  da  unidade,  o  que 

implicaria  na  certeza  de  ser  primo.  Ante  a  relutante  incapacidade  de  encontrar 

primos, indefinidamente, atravÃ©s de fÃ³rmulas, adotou-se, de milÃªnios atrÃ¡s atÃ© os 

dias atuais, mÃ©todos capazes de identificar estes nÃºmeros, os conhecidos testes de 

primalidade, atravÃ©s dos quais adquiriu-se mecanismos facilitadores que reduziu os 

Ã¡rduos  trabalhos  de  divisÃµes  contÃ­nuas.  Estes  testes  podem  ser  definidos  como 

algoritmos capazes de definir um nÃºmero como primo ou composto a partir de uma 

sequÃªncia de aÃ§Ãµes prefixadas. 

Na medida em que o conhecimento sobre os primos evoluiu, os testes de 

primalidade tambÃ©m foram aprimorados. Nesta perspectiva, podemos inseri-los em 

dois grandes momentos da histÃ³ria, o primeiro anterior ao advento do computador 

moderno e o segundo a partir da criaÃ§Ã£o deste. Desta forma, este estudo trata dos 

testes desde suas formas tradicionais atÃ© os mÃ©todos computacionais.  

4.1 Era prÃ©-computacional 

Uma  forma  trivial  de  testar  a  primalidade  de  um  nÃºmero  Ã©  atravÃ©s  da 

realizaÃ§Ã£o  de  divisÃµes  sucessivas,  por  meio  das  quais  busca-se  verificar  a 

existÃªncia  de  fatores  primos  menor  que  o  nÃºmero  em  teste.  Quando  nÃ£o 

encontrados, teremos um primo, caso contrÃ¡rio, estaremos diante de um composto.  

Ocorre que o mÃ©todo descrito, apesar de funcionar eficientemente para 

nÃºmeros  relativamente  pequenos,  torna-se bastante  dispendioso Ã  medida  que a 

contagem aumenta. A quantidade de divisÃµes necessÃ¡rias para um nÃºmero acima 

da casa dos milhares, por exemplo, jÃ¡ seria uma tarefa Ã¡rdua para cÃ¡lculos sem uso 

de mÃ¡quinas modernas.  

 
 
31 

O  desenvolvimento  da  aritmÃ©tica  tornou  possÃ­vel  a  simplificaÃ§Ã£o  de 

tarefas de contagem, graÃ§as a descobertas como o lema descrito abaixo, revelado 

por EratÃ³stenes8, matemÃ¡tico grego do sÃ©culo III a.C.  

Lema 3. Seja ğ‘› âˆˆ â„•, se ğ‘› nÃ£o Ã© um nÃºmero primo, entÃ£o ğ‘› possui um fator primo 

ğ‘ â‰¤ âˆšğ‘›. 

DemonstraÃ§Ã£o. Seja ğ‘ um nÃºmero composto, entÃ£o ğ‘ = ğ‘1 âˆ™ ğ‘2, no qual 1 < ğ‘1 < ğ‘ 

e 1 < ğ‘2 < ğ‘. Sem perder a generalidade, suporemos que ğ‘1 â‰¤ ğ‘2. Como 

EntÃ£o 

ğ‘1 âˆ™ ğ‘2 = ğ‘ â‡’ âˆšğ‘1 âˆ™ âˆšğ‘2 = âˆšğ‘ 

ğ‘1 â‰¤ ğ‘2 â‡’ âˆšğ‘1 â‰¤ âˆšğ‘2 

Multiplicando ambos os membros das desigualdades por âˆšğ‘1, temos 

âˆšğ‘1 âˆ™ âˆšğ‘1 â‰¤ âˆšğ‘2 âˆ™ âˆšğ‘1 

E como âˆšğ‘2 âˆ™ âˆšğ‘1 = âˆšğ‘, entÃ£o 

âˆšğ‘1 âˆ™ âˆšğ‘1 â‰¤ âˆšğ‘2 âˆ™ âˆšğ‘1 â‡’ ğ‘1 â‰¤ âˆšğ‘ 

Agora, pelo Teorema Fundamental da AritmÃ©tica, ğ‘1 possui pelo menos 

um fator primo ğ‘ e como ğ‘1 â‰¤ âˆšğ‘, entÃ£o ğ‘ â‰¤ âˆšğ‘. Desse modo, como ğ‘ Ã© fator primo 

de ğ‘1, entÃ£o ğ‘ tambÃ©m Ã© fator primo de ğ‘, jÃ¡ que ğ‘1 Ã© fator de ğ‘, provando-se, assim, 

o lema.  

Ã€  vista  disso,  no  mÃ©todo  supracitado,  para  verificar  a  primalidade  de 

determinado nÃºmero, nÃ£o Ã© necessÃ¡rio realizar divisÃµes sucessivas atÃ© este, basta 

selecionar possÃ­veis fatores atÃ© a raiz quadrada do valor. 

Estes  conhecimentos  tornaram  possÃ­vel  a  idealizaÃ§Ã£o  de  um  dos 

mÃ©todos  clÃ¡ssicos  mais conhecidos  quanto  a  identificaÃ§Ã£o de  primos, o  Crivo  de 

8 EratÃ³stenes de Cirene foi um matemÃ¡tico grego que nasceu em Cirene, Norte da Ãfrica, atualmente 
Shahhat, na LÃ­bia. Viveu entre os anos de 276 a. C. e 194 a.C. Este estudioso ficou famoso por seu 
trabalho  sobre  nÃºmeros  primos  e  por  medir  o  diÃ¢metro  do  planeta  Terra  (O'CONNOR  e 
ROBERTSON, 1999).  

 
 
 
32 

EratÃ³stenes9, que atravÃ©s de um raciocÃ­nio simples, mas eficaz, Ã© capaz de gerar 

rapidamente tabelas destes nÃºmeros. 

Um dos resultados cruciais sobre os primos que serviu de base para um 

sÃ³lido  desenvolvimento  do  conhecimento  acerca  destes  nÃºmeros  foi  o  Pequeno 

Teorema  de  Fermat,  revelado  no  sÃ©culo  XVII  por  aquele  que  leva  o  seu  nome. 

Referido teorema diz o seguinte: 

Teorema 2. Seja ğ‘ âˆˆ â„¤ e ğ‘ um nÃºmero primo, tem-se que ğ‘ divide ğ‘ğ‘ âˆ’ ğ‘. 

DemonstraÃ§Ã£o. Para ğ‘ = 2, temos ğ‘2 âˆ’ ğ‘ = ğ‘(ğ‘ âˆ’ 1), cujo resultado Ã© par, logo Ã© 

divisÃ­vel por 2. Agora provaremos para ğ‘ Ã­mpar. Como para ğ‘ < 0 e ğ‘ Ã­mpar temos 

ğ‘ğ‘ âˆ’ ğ‘ < 0, entÃ£o basta provar para ğ‘ â‰¥ 0. Por induÃ§Ã£o sobre ğ‘, temos que ğ‘ = 0 

implica em ğ‘2 âˆ’ ğ‘ = 0, que Ã© divisÃ­vel por ğ‘. Supondo, agora, verdadeiro para ğ‘ =

ğ‘˜, temos ğ‘˜ğ‘ âˆ’ ğ‘˜ divisÃ­vel por ğ‘. Vamos provar que para ğ‘˜ + 1 tambÃ©m Ã© verdadeiro. 

Assim, atravÃ©s do desenvolvimento do binÃ´mio, temos 

(ğ‘˜ + 1)ğ‘ âˆ’ (ğ‘˜ + 1) = (

ğ‘
0

) ğ‘˜ğ‘ + (

ğ‘
1

) ğ‘˜ğ‘âˆ’1 + â‹¯ + (

ğ‘
ğ‘ âˆ’ 1

ğ‘
) ğ‘˜ğ‘âˆ’1 + (
ğ‘

) ğ‘˜0 âˆ’ (ğ‘˜ + 1) 

= ğ‘˜ğ‘ + (

ğ‘
1

) ğ‘˜ğ‘âˆ’1 + â‹¯ + (

ğ‘
ğ‘ âˆ’ 1

) ğ‘˜ğ‘âˆ’1 + 1 âˆ’ (ğ‘˜ + 1) 

  = ğ‘˜ğ‘ âˆ’ ğ‘˜ + (

ğ‘
1

) ğ‘˜ğ‘âˆ’1 + â‹¯ + (

ğ‘
ğ‘ âˆ’ 1

) ğ‘˜ğ‘âˆ’1 

(12) 

Como  (ğ‘

ğ‘âˆ’1) ğ‘˜ğ‘âˆ’1  Ã©  divisÃ­vel  por  ğ‘  (demonstraÃ§Ã£o  no 
apÃªndice) e, por hipÃ³tese de induÃ§Ã£o, ğ‘˜ğ‘ âˆ’ ğ‘˜ tambÃ©m Ã© divisÃ­vel por ğ‘, segue que 

1)ğ‘˜ğ‘âˆ’1 + â‹¯ + ( ğ‘

(12) Ã© divisÃ­vel por ğ‘, logo, para ğ‘˜ + 1, Ã© verdadeiro, provando-se o teorema.  

Uma importante aplicaÃ§Ã£o do Pequeno Teorema de Fermat Ã© o seu uso 

na  verificaÃ§Ã£o  de  primos,  cujos  estudos  serviram  de  base  para  a  formulaÃ§Ã£o  de 

diversos testes de primalidade como o Teste de Lucas, Teste de Brillhart e Selfridge, 

Teste de Pepin, entre outros (RIBENBOIM, 2014). 

9 MÃ©todo criado por EratÃ³stenes para localizar primos (serÃ¡ estudado detalhadamente no capÃ­tulo 
5). 

 
 
 
33 

Outros conceitos foram de suma importÃ¢ncia para o desenvolvimento de 

testes de primalidade por intermÃ©dio do avanÃ§o da aritmÃ©tica, especialmente a ideia 

de  congruÃªncia,  que  Ã©  definida por Hefez  (2014, p.  192)  como  â€œuma  das  noÃ§Ãµes 

mais  fecundas  da  aritmÃ©tica,  introduzida  por  Gauss  no  seu  livro  Disquisitiones 

Arithmeticae, de 1801. Trata-se da realizaÃ§Ã£o de uma aritmÃ©tica com os restos da 

divisÃ£o euclidiana por um nÃºmero fixado.â€ 

A partir dessa nova abordagem matemÃ¡tica, novas perspectivas foram 

projetadas  e  avanÃ§os  significativos  foram  alcanÃ§ados  no  campo  da  Teoria  dos 

NÃºmeros, notadamente no conjunto dos nÃºmeros primos. A grande importÃ¢ncia da 

aritmÃ©tica  modular  pode  ser  percebida  nas  palavras  de  Sautoy  (2007),  que 

comparou suas propriedades ao funcionamento de uma calculadora-relÃ³gio: 

O potencial e a velocidade da calculadora-relÃ³gio se tornam evidentes no 
momento em que Gauss deseja calcular o valor de 7  Ã—  7  Ã—  7. Em vez de 
multiplicar  novamente  49  por 7,  Gauss  pode  simplesmente  multiplicar  a 
Ãºltima resposta (que era 1) por 7, obtendo o resultado 7. Assim, sem ter 
que  calcular  o  valor  de  7  Ã—  7  Ã—  7  (que  vem  a  ser  343),  ele  sabia,  com 
pouco esforÃ§o, que o resultado deixaria resto 7 ao ser dividido por 12. A 
forÃ§a da calculadora foi revelada quando Gauss passou a explorar grandes 
nÃºmeros situados alÃ©m de seu alcance computacional. Embora nÃ£o tivesse 
a  menor  ideia  do  valor  de  799,  sua  calculadora-relÃ³gio  lhe  dizia  que  o 
nÃºmero deixava resto 7 ao ser dividido por 12 (SAUTOY, 2007, p. 29). 

Em geral, dizemos que os inteiros ğ‘ e ğ‘ sÃ£o congruentes mÃ³dulo ğ‘š, com 

ğ‘š natural, se os restos da divisÃ£o euclidiana de ğ‘ e ğ‘ por ğ‘š sÃ£o iguais. Em termos 

simbÃ³licos, temos:  

ğ‘ â‰¡ ğ‘ mod ğ‘š, ğ‘š âˆˆ â„•, ğ‘ âˆˆ â„¤, ğ‘ âˆˆ â„¤ 

As aplicaÃ§Ãµes dessa nova aritmÃ©tica sÃ£o inÃºmeras, dado que atravÃ©s de 

seus  conceitos  e  propriedades,  por  exemplo,  Ã©  possÃ­vel  provar  que  determinado 

nÃºmero de Mersenne nÃ£o Ã© primo, que alguns nÃºmeros de Fermat nÃ£o sÃ£o primos, 

alÃ©m de estabelecer critÃ©rios de divisibilidade por certos nÃºmeros. Isso mostra que 

o conceito de congruÃªncia revelou novas formas de testar a primalidade 

4.2 Era computacional 

A  humanidade,  nos  Ãºltimos  sÃ©culos,  evoluiu  tecnologicamente  com 

grande  celeridade,  como  jamais  cresceu  ao  longo  de  sua  histÃ³ria.  Grande  parte 

 
 
34 

desse  acentuado  desenvolvimento  se  deve  ao  advento  e  aperfeiÃ§oamento  dos 

computadores.  

As  mÃ¡quinas  tornaram-se  uma  realidade  inevitÃ¡vel,  dado  o  constante 

crescimento cientÃ­fico e sua consequente aplicaÃ§Ã£o em invenÃ§Ãµes e aprimoramento 

de  instrumentos.  Desde  o  perÃ­odo  renascentista,  uma  forte  tendÃªncia  voltada  ao 

desenvolvimento 

intelectual  se 

instalou  nas  sociedades  ocidentais,  em 

conformidade com o trecho a seguir: 

[...] O Renascimento deu um extraordinÃ¡rio salto para diante. Nunca uma 
civilizaÃ§Ã£o dera tÃ£o grande lugar Ã  pintura e Ã  mÃºsica, nem erguera ao cÃ©u 
tÃ£o  altas  cÃºpulas,  nem  elevara  ao  nÃ­vel  da  alta  literatura  tantas  lÃ­nguas 
nacionais  encerradas  em  tÃ£o  exÃ­guo  espaÃ§o.  Nunca  no  passado  da 
Humanidade tinham surgido tantas invenÃ§Ãµes em tÃ£o pouco tempo. Pois o 
renascimento  foi,  especialmente,  progresso  tÃ©cnico;  deu  ao  homem  do 
Ocidente maior domÃ­nio sobre um mundo mais bem conhecido. Ensinou-
lhe a atravessar os oceanos, a fabricar ferro fundido, a servir-se das armas 
de fogo, a contar as horas com um motor, a imprimir, a utilizar dia a dia a 
letra de cÃ¢mbio e o seguro marÃ­timo (DELUMEAU, 1984, p. 23). 

A  partir  desse  perÃ­odo,  uma  efervescente  busca  por  descobertas  no 

campo cientÃ­fico possibilitou o desenvolvimento tecnolÃ³gico que se estendeu pelos 

sÃ©culos vindouros e estabeleceu uma nova era da humanidade. Concomitante ao 

movimento  de  expansÃ£o  da  ciÃªncia,  nasceram  as  mÃ¡quinas  e,  dentre  estas, 

destacamos  as  capazes  de  realizar  operaÃ§Ãµes  matemÃ¡ticas  e  transpor  os 

obstÃ¡culos presentes na limitaÃ§Ã£o de cÃ¡lculos mentais.  

As  primeiras mÃ¡quinas  voltadas  Ã   realizaÃ§Ã£o  de operaÃ§Ãµes aritmÃ©ticas 

foram as calculadoras mecÃ¢nicas, cujo funcionamento permitiu ao homem executar 

cÃ¡lculos â€“ que na Ã©poca levavam vÃ¡rias horas â€“ em apenas poucos comandos. Este 

tipo  de  funcionamento  representou  os  primÃ³rdios  dos  conceitos  do  computador 

moderno. Vejamos o entendimento de Wazlawick (2016) sobre o tema: 

Os sÃ©culos XVII,  XVIII e XIX viram o surgimento e  aperfeiÃ§oamento das 
calculadoras  mecÃ¢nicas.  A  partir  de  trabalhos  inovadores  como  os  de 
Schickard,  Pascal  e  Leibniz,  mÃ¡quinas  capazes  de  realizar  as  quatro 
operaÃ§Ãµes aritmÃ©ticas com o simples girar de uma alavanca se tornaram 
realidade. Essas mÃ¡quinas, bem como o tear mecÃ¢nico, que usava cartÃµes 
perfurados  jÃ¡  no  inÃ­cio  do  sÃ©culo  XIX,  foram  fundamentais  para  a 
concepÃ§Ã£o  posterior  dos  computadores  de  propÃ³sito  geral  â€“  ou  seja, 
mÃ¡quinas programÃ¡veis para executar qualquer funÃ§Ã£o computÃ¡vel e nÃ£o 
apenas as quatro operaÃ§Ãµes. Esse mesmo perÃ­odo tambÃ©m testemunhou 
o  desenvolvimento  da  aritmÃ©tica  binÃ¡ria  e  o  surgimento  dos  primeiros 

 
 
35 

computadores  humanos,  ou  seja,  pessoas  cuja  profissÃ£o  era  executar 
cÃ¡lculos repetitivos Ã  mÃ£o (WAZLAWICK, 2016, p. 27). 

Nota-se, deste modo, a tendÃªncia em delegar Ã  mÃ¡quina certas tarefas 

habitualmente exercidas pelo ser humano. Num momento de grande expansÃ£o do 

conhecimento  cientÃ­fico,  a  matemÃ¡tica 

tambÃ©m  passou  por  um  elevado 

desenvolvimento entre os sÃ©culos XVII e XIX, razÃ£o pela qual as mÃ¡quinas tambÃ©m 

foram objetos de uso para cÃ¡lculos.  

A partir do desenvolvimento constante dos instrumentos de calcular, nÃ£o 

demorou  atÃ©  que  os  computadores  surgissem.  AtravÃ©s  da  junÃ§Ã£o  de  conceitos 

preconcebidos  de  matemÃ¡tica  e  engenharia,  nasceram  as  primeiras  mÃ¡quinas 

capazes de executar funÃ§Ãµes gerais, conforme apresentado a seguir: 

O  sÃ©culo  XIX  viu  surgir  o  primeiro  projeto  de  computador  de  propÃ³sito 
universal: a MÃ¡quina AnalÃ­tica de Charles Babbage. Neste sÃ©culo tambÃ©m 
se consolidaram as calculadoras mecÃ¢nicas baseadas em engrenagens, 
que  passaram  a  ser  bastante  utilizadas  em  empresas  e  organizaÃ§Ãµes. 
Pesquisas iniciais com dispositivos elÃ©tricos como os relÃªs, permitiram que 
ao  final  desse  sÃ©culo  as  primeiras  mÃ¡quinas  somadoras  ou  contadoras 
com base eletromecÃ¢nica fossem construÃ­das por Hermann Hollerith. NÃ£o 
menos importante, durante o sÃ©culo XIX ocorreram avanÃ§os nas ciÃªncias 
da  LÃ³gica  e  MatemÃ¡tica,  devido  principalmente  a  Boole,  Frege,  dentre 
outros  que  lanÃ§aram  os  fundamentos  teÃ³ricos  para  a  CiÃªncia  da 
ComputaÃ§Ã£o  a  nascer  no  inÃ­cio  do  sÃ©culo  XX  com  trabalhos  como  o  de 
Turing (WAZLAWICK, 2016, p. 53). 

Com  o  surgimento  do  computador  eletrÃ´nico,  a  matemÃ¡tica  alcanÃ§ou 

novos  patamares,  por  intermÃ©dio  da  resoluÃ§Ã£o  de  extensos  cÃ¡lculos,  antes 

inalcanÃ§Ã¡veis  pela  mente  humana.  Valores  de  complexas  funÃ§Ãµes  puderam  ser 

conhecidos graÃ§as a essa importante invenÃ§Ã£o.  

Alguns  clÃ¡ssicos  artifÃ­cios  utilizados  na 

facilitaÃ§Ã£o  de  cÃ¡lculos 

matemÃ¡ticos e resoluÃ§Ã£o de problemas, como a tÃ¡bua de logaritmos10, deram lugar 

ao  poder  de  processamento  dos  computadores  eletrÃ´nicos.  Assim,  temos  a 

descriÃ§Ã£o de Boyer (1974) sobre a vastidÃ£o da utilidade destas mÃ¡quinas: 

Os  computadores  hoje  tornaram-se  tÃ£o  vastos  e  intrincados  que 
ultrapassam  os  sonhos  de  Babbage,  que  viveu  um  sÃ©culo  antes  de  seu 

10  Tabela  com  correspondÃªncia  entre  os  valores  de  logğ‘ ğ‘¥  e  ğ‘ğ‘¥,  para  valores  de  ğ‘¥  definidos  em 
determinado  intervalo  e  com  base  ğ‘ = 10,  geralmente.  Devido  Ã s  propriedades  operatÃ³rias  dos 
logaritmos, estas tabelas eram utilizadas para transformar multiplicaÃ§Ãµes em somas, simplificando a 
realizaÃ§Ã£o de cÃ¡lculos complexos.  

 
 
 
36 

advento.  Problemas  que  estavam  desesperadoramente  alÃ©m  das 
capacidades  dos  matemÃ¡ticos  de  eras  anteriores  recentemente  foram 
resolvidos com a  ajuda dos computadores de alta velocidade.  Se, como 
Kepler disse, a invenÃ§Ã£o dos logaritmos duplicou a vida de um astrÃ´nomo, 
quanto mais o computador eletrÃ´nico expandiu as carreiras de cientistas e 
matemÃ¡ticos (BOYER, 1974, p. 456). 

Os  tradicionais  mÃ©todos  de  localizaÃ§Ã£o  de  primos  tinham,  em  sua 

maioria, funcionamento baseado em sucessivas divisÃµes que, com a elevaÃ§Ã£o dos 

nÃºmeros  testados,  tornavam  os  trabalhos  operacionais  excessivamente  difÃ­ceis. 

Com a cooperaÃ§Ã£o das mÃ¡quinas de calcular, essas tarefas foram demasiadamente 

facilitadas. 

Dentre as  inÃºmeras  possibilidades  trazidas pelo  computador eletrÃ´nico 

no  campo  matemÃ¡tico,  destacamos  a  utilizaÃ§Ã£o  de  algoritmos  especialmente 

elaborados para a localizaÃ§Ã£o de nÃºmeros primos. Uma das grandes vantagens do 

poder computacional destes novos equipamentos foi sua capacidade de processar 

numerosas  operaÃ§Ãµes  matemÃ¡ticas  de  elevada  complexidade  que  naturalmente 

seriam de difÃ­cil resoluÃ§Ã£o pelo ser humano. 

Os  primeiros  desafios  dos  computadores  modernos  consistiram  na 

identificaÃ§Ã£o de primos de Mersenne. O professor da Universidade da CalifÃ³rnia em 

Berkeley,  Raphael  Robinson,  marido  da  matemÃ¡tica  norte-americana  Julia 

Robinson11, conseguiu, por intermÃ©dio do Standards Western Automatic Computer 

(SWAC), mÃ¡quina criada por Derrick Lehmer12, utilizar um algoritmo, de sua autoria, 

que  identificava  primos  de  Mersenne.  Os  resultados  foram  alcanÃ§ados  em  1952, 

quando  este  computador  conseguiu  descobrir  os  primeiros  primos  alÃ©m  da 

capacidade de alcance do ser humano, ao apresentar os nÃºmeros 2521 âˆ’ 1, 2607 âˆ’

1  e  22281 âˆ’ 1,  batendo  o  recorde,  seguidas  vezes,  de  maiores  nÃºmeros  primos 

conhecidos naquela Ã©poca (SAUTOY, 2007). 

11 MatemÃ¡tica norte-americana que viveu entre 1919 e 1985. Tornou-se famosa por ter participado 
da  resoluÃ§Ã£o  do  dÃ©cimo  problema  de  Hilbert,  que  buscava  encontrar  um  algoritmo  capaz  de 
determinar a existÃªncia de raÃ­zes inteiras de uma equaÃ§Ã£o polinomial (SAUTOY, 2007).  
12 Derrick Henry Lehmer (1905-1991) foi um matemÃ¡tico estadunidense que trabalhou em Teoria dos 
NÃºmeros e generalizou os Teste Primalidade de Lucas para os primos de Mersenne (O'CONNOR e 
ROBERTSON, 2002). 

 
 
 
37 

De  fato,  o  computador  eletrÃ´nico  possibilitou  um  gigantesco  passo  na 

captura de primos cada vez maiores. DÃ©cadas antes do advento desta mÃ¡quina, em 

1876, Lucas13, atravÃ©s do Teste de Lucas e Lehmer â€“ que serÃ¡ estudado mais Ã  

frente  â€“  provou  que  o  nÃºmero  2127 âˆ’ 1,  com  39  dÃ­gitos,  Ã©  primo.  Este  recorde 

persistiu  durante  vÃ¡rios  anos,  atÃ©  que,  a  partir  de  1951,  primos  maiores  foram 

apresentados com o auxÃ­lio de computadores, como o nÃºmero 180(2127 âˆ’ 1)2 + 1, 

em 1951, e os nÃºmeros 2521 âˆ’ 1, 2607 âˆ’ 1, 21279 âˆ’ 1, 22203 âˆ’ 1 e 22281 âˆ’ 1, todos em 

1952, pelo SWAC, ultrapassando a casa dos 680 dÃ­gitos (CALDWELL, 2021). 

13 FranÃ§ois Ã‰douard Anatole Lucas (1842-1891) foi um matemÃ¡tico francÃªs que se notabilizou por 
seus estudos sobre Teoria dos NÃºmeros, SequÃªncia de Fibonacci e SequÃªncia de Lucas, esta Ãºltima, 
com nome em sua homenagem. Lucas desenvolveu importantes testes de primalidade, influentes 
atÃ© os dias atuais (O'CONNOR e ROBERTSON, 1996). 

 
 
 
 
 
38 

5 ASPECTOS BÃSICOS DOS TESTES DE PRIMALIDADE 

Em conformidade com o narrado ao longo deste trabalho, os testes de 

primalidade  representam  uma  notÃ¡vel  forma  de  se  identificar  nÃºmeros  primos, 

grandemente  utilizada  ao  longo  dos  anos.  Sua  evoluÃ§Ã£o  seguiu,  em  muitos 

aspectos,  uma  tendÃªncia  de  tornÃ¡-los  Ã¡geis  e  praticÃ¡veis.  Neste  sentido, 

apresentamos  alguns  conceitos  importantes  relacionados  Ã s  caracterÃ­sticas  dos 

testes aqui estudados. 

5.1 Capacidade mental versus capacidade computacional 

Os primeiros testes de primalidade adotavam o esforÃ§o mental mÃ­nimo 

como principal diferencial e, para tal fim, apoiavam-se em propriedades aritmÃ©ticas 

dos nÃºmeros inteiros para reduzir o trabalho e o tempo de soluÃ§Ã£o.  

Com  o  advento  dos  computadores,  o  tempo  de  cÃ¡lculo  foi  comprimido 

consideravelmente, reduzindo operaÃ§Ãµes, que levavam horas, para apenas poucos 

segundos.  Ã‰  inquestionÃ¡vel  o  poder  computacional  destes  instrumentos  e  seu 

alcance  transcende  excessivamente  a  capacidade  humana  de  realizar  cÃ¡lculos, 

percebida  atravÃ©s  da  performance  atingida  pelas  primeiras  geraÃ§Ãµes  de 

computadores e que se acentua cada vez mais com as mÃ¡quinas atuais.  

A  disparidade  entre  o  poder  de  cÃ¡lculo  da  mente  humana  e  o  das 

mÃ¡quinas  pode  ser  percebida  pela  anÃ¡lise  de  desempenho  do  precursor  dos 

computadores digitais e eletrÃ´nicos, o ENIAC (Electronic Numerical Integrator and 

Calculator), operado entre os anos de 1946 e 1955. Referido computador, alÃ©m do 

grande porte fÃ­sico â€“ possuÃ­a 17 mil vÃ¡lvulas, 10 mil capacitores, 70 mil resistores e 

pesava 30 toneladas â€“ era capaz de realizar 5 mil adiÃ§Ãµes por segundo e, em termos 

comparativos,  um  cÃ¡lculo  que  levava  vinte  e  quatro  horas  manualmente  era 

resolvido em menos de trinta segundos (MACHADO e MAIA, 2014). 

O  campo  de  desenvolvimento  dos  computadores  esteve  em  ampla 

ascensÃ£o  desde  sua  criaÃ§Ã£o,  de  tal  modo  que  a  potÃªncia  dessas  mÃ¡quinas  foi 

 
 
39 

elevada  a  nÃ­veis  colossais  nas  Ãºltimas  dÃ©cadas.  Segundo  a  TOP50014,  o 

computador mais rÃ¡pido registrado em novembro de 2020 foi o  supercomputador 

japonÃªs Fugaku, instalado no RIKEN Center for Computational Science (R-CCS), 

em Kobe, JapÃ£o. Ele possui uma velocidade de 442 petaflops15, ou seja, Ã© capaz 

de realizar 442 quatrilhÃµes de cÃ¡lculos por segundo (STROHMAIER, DONGARRA, 

et  al.,  2020).  Ao  comparÃ¡-lo  com  um  computador  pessoal  da  ordem  de  100 

gigaflops, o Fugaku Ã© 4 milhÃµes e 420 mil vezes mais rÃ¡pido.  

Nota-se,  portanto,  o  quanto  as  mÃ¡quinas  evoluÃ­ram  e  tornaram-se 

instrumentos  fundamentais  na  pesquisa  cientÃ­fica,  na  qual  inclui-se  o  estudo  dos 

nÃºmeros primos e consequentemente o desenvolvimento de testes de primalidade 

aptos a identificar primos cada vez maiores.  

5.2 Custo de um algoritmo  

Os  computadores  modernos,  apesar  da  grande  capacidade  de 

processamento  de  alguns  de  seus  modelos,  possuem  limitaÃ§Ãµes  prÃ¡ticas 

concernentes ao uso de algoritmos especÃ­ficos. A depender da operaÃ§Ã£o, o tempo 

de resposta pode demandar um tempo de espera inaceitÃ¡vel. Este campo de estudo 

refere-se  ao  custo  de  um  algoritmo,  ou  seja,  aos  recursos  que  este  precisa  para 

funcionar. 

Diversos atributos podem ser avaliados ao se determinar o custo de um 

algoritmo, porÃ©m Cormem (2002, p. 16) salienta que o fator primoridial Ã© o tempo 

de resposta, ao afirmar que â€œocasionalmente, recursos como memÃ³ria, largura de 

banda de comunicaÃ§Ã£o ou hardware de computador sÃ£o a principal preocupaÃ§Ã£o, 

mas com frequÃªncia Ã© o tempo de computaÃ§Ã£o que desejamos medir.â€ 

Tempo de resposta, conforme Machado e Maia (2014) Ã© definido como: 

â€œTempo de resposta Ã© o tempo decorrido entre uma requisiÃ§Ã£o ao sistema 
ou  Ã   aplicaÃ§Ã£o  e  o  instante  em  que  a  resposta  Ã©  exibida.  Em  sistemas 
interativos, podemos entender como o tempo decorrido entre a Ãºltima tecla 

14 Ranking dos 500 supercomputadores de alto desempenho (disponibilizados comercialmente) mais 
poderosos do mundo. Esta lista Ã© atualizada duas vezes ao ano.  
15  1  petaflop  equivale  Ã   1  quatrilhÃ£o  de  flops,  que  Ã©  a  abreviaÃ§Ã£o  para  o  termo  computacional 
â€œfloating-point operations per secondâ€, que, traduzido, representa a unidade para operaÃ§Ãµes de ponto 
flutuante por segundo. 

 
 
 
40 

digitada  pelo  usuÃ¡rio  e  o  inÃ­cio  da  exibiÃ§Ã£o  do  resultado  no  monitor.â€ 
(MACHADO e MAIA, 2014, p. 173). 

Este  tempo  depende  diretamente  do  nÃºmero  de  operaÃ§Ãµes  a  serem 

realizadas por um algoritmo, ou seja, quanto maior a quantidade de algarismos de 

determinado  nÃºmero  de  entrada  ğ‘‹,  maior  serÃ¡  a  quantidade  de  operaÃ§Ãµes 

aritmÃ©ticas a serem executadas.  

Isso  nos  leva  a  destacar  outro  importante  conceito,  o  tamanho  da 

entrada, naturalmente medido atravÃ©s do nÃºmero de itens da entrada. Relacionado 

a este, temos tambÃ©m o jÃ¡ delineado tempo de execuÃ§Ã£o, entendido como o nÃºmero 

de operaÃ§Ãµes primitivas ou â€œpassosâ€ executados por um algoritmo em determinada 

entrada (CORMEM, LEISERSON, et al., 2002).  

Em termos gerais, o tempo de execuÃ§Ã£o Ã© representado pela soma dos 

tempos  despendidos  em  cada  uma  das  etapas  executadas  pelo  algoritmo.  Com 

base no tempo necessÃ¡rio de resposta, um algoritmo pode ser classificado como de 

tempo polinomial ou de tempo exponencial. Vejamos como Ribemboim (2014) os 

define: 

O algoritmo Ã© chamado de tempo polinomial se existir um polinÃ´mio ğ‘“(ğ‘‹), 
tal  que,  para  todo  ğ‘,  o  tempo  necessÃ¡rio  para  levÃ¡-lo  ao  fim,  quando  o 
dado inicial Ã© o nÃºmero ğ‘, Ã© limitado por ğ‘“(log ğ‘). Se o algoritmo nÃ£o Ã© a 
tempo polinomial, mas se o tempo de execuÃ§Ã£o Ã© limitado por ğ‘“(ğ‘), para 
todo  ğ‘  (onde  ğ‘“(ğ‘‹)  Ã©  um  polinÃ´mio),  entÃ£o  Ã©  ele  chamado  de  tempo 
exponencial,  porque  ğ‘ = ğ‘’log ğ‘.  Um  algoritmo  sÃ³  Ã©  economicamente 
aceitÃ¡vel se for de tempo polinomial (RIBENBOIM, 2014, p. 108, grifo do 
autor). 

Conforme  o  supramencionado,  hÃ¡  um  limite  de  viabilidade  econÃ´mica 

para  determinados  algoritmos  e  tal  barreira  estÃ¡  diretamente  relacionada  ao  seu 

custo. Desta forma, define-se como aceitÃ¡veis aqueles classificados como de tempo 

polinomial.  

Tratar  de  tempo  polinomial  e  tempo  exponencial  nos  remete  Ã   anÃ¡lise 

dos  termos  da  funÃ§Ã£o  e  suas  taxas  de  crescimento.  Dada  uma  funÃ§Ã£o  ğ‘“ 

representada  por  ğ‘“(ğ‘¥) = ğ‘ğ‘¥2 + ğ‘ğ‘¥ + ğ‘,  para  o  nÃºmero  de  entrada  ğ‘¥  e  tempo  de 

execuÃ§Ã£o  ğ‘“(ğ‘¥),  quando  se  eleva  indefinidamente  o  valor  de  ğ‘¥,  os  termos  ğ‘ğ‘¥  e  ğ‘ 

tornam-se  praticamente  insignificantes,  logo,  podem  ser  ignorados  no  cÃ¡lculo  do 

tempo, assim como a constante ğ‘, uma vez que tambÃ©m se torna desprezÃ­vel em 

 
 
41 

relaÃ§Ã£o Ã  taxa de crescimento quando em grandes entradas. Estas anÃ¡lises apoiam-

se no fato de que a taxa de crescimento Ã© o fator decisivo no tempo de execuÃ§Ã£o 

de um algoritmo (CORMEM, LEISERSON, et al., 2002). Em linhas gerais, quanto 

menor a ordem de crescimento de um algoritmo, mais eficiente este serÃ¡.  

O custo de um algoritmo Ã© comumente avaliado com base no seu tempo 

de  execuÃ§Ã£o,  cujas  variÃ¡veis  englobam  a  quantidade  de  operaÃ§Ãµes  necessÃ¡rias 

para a conclusÃ£o das tarefas e o perÃ­odo tomado por cada uma destas. Como jÃ¡ 

citado, utiliza-se uma funÃ§Ã£o ğ‘“ (funÃ§Ã£o de complexidade) para se verificar o tempo 

de execuÃ§Ã£o de um algoritmo. Stanat e McAllister (1977, apud ZIVIANI 2011, p. 5) 

definem que â€œse ğ‘“(ğ‘›) Ã© a medida de tempo necessÃ¡rio para executar um algoritmo 

para um problema de tamanho ğ‘›, entÃ£o ğ‘“ Ã© chamada de funÃ§Ã£o de complexidade 

de tempo do algoritmo.â€  

O  principal  custo  de  um  algoritmo  avaliado  neste  trabalho  serÃ¡  o  que 

relaciona  o  tamanho  da  entrada  dos  dados  com  seu  custo  de  execuÃ§Ã£o,  assim, 

teremos  a  funÃ§Ã£o  de  complexidade  de  tempo  atrelada  Ã   dimensÃ£o  dessas 

informaÃ§Ãµes. Dentre os casos possÃ­veis â€“ melhor, mÃ©dio e pior â€“ consideraremos o 

pior  caso,  uma  vez  que  representarÃ¡  o  pior  tempo  de  execuÃ§Ã£o  dentre  todas  as 

entradas, dessa forma a funÃ§Ã£o ğ‘“ sempre representarÃ¡ o maior o custo de aplicaÃ§Ã£o 

do algoritmo. 

Sabendo-se  que  o  custo  de  um  algoritmo  estÃ¡  diretamente  ligado  ao 

tamanho da entrada ğ‘›, entÃ£o nota-se que esta entrada oferece um forte parÃ¢metro 

de  medida  de  complexidade  do  problema,  assim,  na  medida  que  ğ‘›  cresce,  a 

complexidade de tempo de algoritmo tambÃ©m sobe.  

Feofiloff (2019, p. 10) revela que â€œPara cada instÃ¢ncia16 do problema, o 

algoritmo consome uma quantidade de tempo diferente. Digamos que o algoritmo 

consome ğ‘‡(ğ¼) unidades de tempo para resolver a instÃ¢ncia ğ¼. A relaÃ§Ã£o entre ğ‘‡(ğ¼) 

e o tamanho de ğ¼ dÃ¡ uma medida da eficiÃªncia do algoritmo.â€ (grifo nosso). 

16 Compreendida aqui como caso particular. 

 
 
 
42 

A  anÃ¡lise  assintÃ³tica17  da 

funÃ§Ã£o  ğ‘“  nos  permite  observar  seu 

comportamento quando o custo de ğ‘› se eleva consideravelmente. Knuth (1968, p. 

104,  apud  Ziviani,  2011,  p  12)  sugeriu  a  seguinte  notaÃ§Ã£o  para  dominaÃ§Ã£o 

assintÃ³tica. 

Para  expressar  que  ğ‘“(ğ‘›)  domina  assintoticamente  ğ‘”(ğ‘›),  escrevemos 
ğ‘”(ğ‘›) = ğ‘‚(ğ‘“(ğ‘›)), onde se lÃª ğ‘”(ğ‘›) Ã© da ordem no mÃ¡ximo ğ‘“(ğ‘›). Por exemplo, 
quando dizemos que o tempo de execuÃ§Ã£o ğ‘‡(ğ‘›) de um programa Ã© ğ‘‚(ğ‘›Â²), 
isto  significa  que  existem  constantes  ğ‘  e  ğ‘š  tais  que,  para  valores  de  n 
maiores ou iguais a ğ‘š, ğ‘‡(ğ‘›) â‰¤ ğ‘ğ‘›Â² (KNUTH, 1968, p. 104, apud ZIVIANI, 
2011, p. 12). 

Simbolicamente, temos 

DefiniÃ§Ã£o 2. Dadas as funÃ§Ãµes ğ‘”: â„• â†’ â„ e ğ‘“: â„• â†’ â„. Dizemos que ğ‘”(ğ‘›) = ğ‘‚(ğ‘“(ğ‘›)), 

ou que ğ‘” estÃ¡ em ğ‘“, se existirem constantes inteiras nÃ£o negativas ğ‘ e ğ‘, tais que 

ğ‘”(ğ‘›) â‰¤ ğ‘ âˆ™ ğ‘“(ğ‘›), para todo ğ‘› â‰¥ ğ‘.  

Exemplo. Seja ğ‘”(ğ‘›) = 2ğ‘›Â² + ğ‘› + 1 

EntÃ£o ğ‘”(1) = 4. Assim podemos considerar que ğ‘”(ğ‘›) estÃ¡ em ğ‘‚(ğ‘›Â²), pois 

quando ğ‘ = 1 e ğ‘ = 4 temos 

2ğ‘›Â² + ğ‘› + 1 â‰¤ 4ğ‘›Â² 

Para ğ‘› â‰¥ 1. 

Ressalta-se  que  a  expressÃ£o  ğ‘”(ğ‘›) = ğ‘‚(ğ‘“(ğ‘›)),  apesar  do  sinal  de 

igualdade, denota que ğ‘”(ğ‘›) â€œestÃ¡ escondidoâ€ em ğ‘‚(ğ‘“(ğ‘›)), ou seja, que ğ‘”(ğ‘›) â‰¤ ğ‘ âˆ™

ğ‘“(ğ‘›), para ğ‘ e ğ‘› suficientemente grandes. 

Em resumo, com base na DefiniÃ§Ã£o 2, o exemplo supra mostra que, na 

anÃ¡lise assintÃ³tica de ğ‘”, a expressÃ£o 2ğ‘›Â² + ğ‘› + 1 se resume a ğ‘›Â², isto Ã©, no exame 

de  um  algoritmo  com  custo  representado  por  esta  funÃ§Ã£o,  o  termo  determinante 

serÃ¡ ğ‘›Â². 

17 Segundo Feofiloff (2021), a matemÃ¡tica que se interessa apenas pelos enormes  valores de ğ‘› Ã© 
chamada assintÃ³tica.  

 
 
 
43 

5.3 Testes de primalidade determinÃ­sticos e nÃ£o determinÃ­sticos   

Outro  aspecto  de  capital  importÃ¢ncia  na  classificaÃ§Ã£o  dos  testes  de 

primalidade Ã© a sua capacidade de garantir que determinado nÃºmero ğ‘ de entrada 

Ã© primo ou composto. Dada a natureza e complexidade de cada teste, determinados 

algoritmos podem nÃ£o assegurar a primalidade de um nÃºmero ğ‘ e retornam como 

resultado apenas a probabilidade de ser primo.  

Temos,  portanto,  os  Testes  DeterminÃ­sticos  de  Primalidade  e  os  NÃ£o 

DeterminÃ­sticos. No primeiro, a entrada de um inteiro positivo ğ‘› apresenta na saÃ­da 

uma mensagem indicando se ğ‘› Ã© ou nÃ£o primo. Desta forma, temos a garantia se ğ‘› 

Ã© primo ou composto. Por outro lado, os testes nÃ£o determinÃ­sticos de primalidade 

garantem apenas que o nÃºmero Ã© primo com uma certa probabilidade, controlada 

de acordo com necessidade do usuÃ¡rio (COUTINHO, 2004). 

Uma questÃ£o que pode ser levantada Ã© a respeito do uso de testes nÃ£o 

determinÃ­sticos  em  detrimento  da  utilizaÃ§Ã£o  dos  determinÃ­sticos,  jÃ¡  que  estes, 

diferentemente daqueles, trazem como resultado uma resposta garantida sobre a 

primalidade  de  um  nÃºmero.  A  resposta  reside  em  sua  eficiÃªncia,  detalhada  nos 

testes apresentados nesta obra.  

5.4 Formas de classificaÃ§Ã£o 

Em  razÃ£o  da  grande  diversidade  de  caracterÃ­sticas  dos  testes  de 

primalidade,  Ã©  possÃ­vel  encontrar  vÃ¡rias  formas  de  classificÃ¡-los.  Ribenboim,  em 

sua obra sobre nÃºmeros primos, classifica estes testes de acordo com os seguintes 

critÃ©rios: testes para nÃºmeros de forma particular ou testes para nÃºmeros genÃ©ricos; 

testes  completamente  justificados  por  teoremas  ou  testes  cuja  justificativa  Ã© 

baseada em  conjecturas  e  testes  determinÃ­sticos  ou  testes  probabilÃ­sticos  (ou  de 

Monte Carlo) (RIBENBOIM, 2014). 

Face  Ã   linha  temporal  adotada  neste  trabalho,  a  qual  discorre  sobre  a 

evoluÃ§Ã£o  dos  testes  de  primalidade,  opta-se  por  utilizar  como  critÃ©rio  de 

classificaÃ§Ã£o os perÃ­odos nos quais estÃ£o situados cada um, empregando-se como 

 
 
44 

divisor capital o inÃ­cio do uso computacional, dividindo-os em mÃ©todos clÃ¡ssicos e 

mÃ©todos computacionais.  

Esta  forma  de  classificaÃ§Ã£o  nos  permite  esclarecer  as  caracterÃ­sticas 

bÃ¡sicas dos algoritmos e as aplicaÃ§Ãµes dos testes de primalidade encontrados por 

pesquisadores, tÃ£o Ãºteis para a organizaÃ§Ã£o das sociedades modernas.  

 
 
 
 
45 

6 TESTES CLÃSSICOS 

6.1 DivisÃ£o por tentativa 

Nas  sÃ©ries  iniciais  do  estudo  bÃ¡sico,  apÃ³s  aprender  os  conceitos 

fundamentais sobre os nÃºmeros primos, um estudante pode idealizar, naturalmente, 

uma  simples  forma  de  identificÃ¡-los.  AtravÃ©s  de  sucessivas  divisÃµes,  Ã©  possÃ­vel 

testar  a  primalidade  de  determinado  nÃºmero.  O  mÃ©todo  consiste  nas  seguintes 

etapas: 

Passo 1. Seleciona-se um nÃºmero natural ğ‘› do qual deseja-se testar a primalidade;  

Passo 2. Realiza-se divisÃµes sucessivas de ğ‘› por ğ‘š, para 1 < ğ‘š < ğ‘› 

Passo 3. Dado o seguinte lema, jÃ¡ provado nesse trabalho18: 

Lema. Seja ğ‘› âˆˆ â„•, se ğ‘› nÃ£o Ã© um nÃºmero primo, entÃ£o ğ‘› possui um fator primo ğ‘ â‰¤

âˆšğ‘›. 

EntÃ£o a divisÃ£o precisa seguir, apenas, atÃ© âˆšğ‘›, ou seja, 1 < ğ‘š â‰¤ âˆšğ‘›. 

Passo 4. Por fim, se ğ‘› nÃ£o for divisÃ­vel por ğ‘š, tal que 1 < ğ‘š â‰¤ âˆšğ‘›, entÃ£o ğ‘› serÃ¡ um 

nÃºmero primo, caso contrÃ¡rio, serÃ¡ um composto.  

Este Ã© um tÃ­pico mÃ©todo baseado na exaustÃ£o, logo, apesar do simples 

raciocÃ­nio, a tarefa se tornarÃ¡ excessivamente trabalhosa para nÃºmeros grandes, 

entretanto,  para  nÃºmeros  relativamente  pequenos,  Ã©  um  teste  prÃ¡tico  e  de  fÃ¡cil 

aplicaÃ§Ã£o que ainda retorna todos os divisores do nÃºmero testado. 

O teste Ã© claramente determinÃ­stico, com tempo de execuÃ§Ã£o de ğ‘‚(âˆšğ‘›), 

contudo, levando-se em conta sua representaÃ§Ã£o binÃ¡ria para uso computacional19, 

sua  complexidade  Ã©  ğ‘‚(2âˆšğ‘›),  portanto,  de  tempo  exponencial,  logo  de  custo 

computacional impraticÃ¡vel.  

18 Vide CapÃ­tulo 3, Item 3.1. 
19  A  linguagem  binÃ¡ria,  atualmente  utilizada  pelos  computadores,  representa  uma  relaÃ§Ã£o  lÃ³gica 
entre a Ã¡lgebra de Boole (matemÃ¡tico britÃ¢nico do sÃ©culo XIX) e os circuitos eletrÃ´nicos, atravÃ©s dos 
estados lÃ³gicos SIM e NÃƒO para diferentes diferenÃ§as de potencial no circuito (COSTA, 2007). 

 
 
 
46 

6.2 Crivo de EratÃ³stenes 

Um  dos  testes  de  primalidade  mais  antigos  da  histÃ³ria  Ã©  o  Crivo  de 

EratÃ³stenes,  nome dado  em  homenagem  ao  matemÃ¡tico  grego  EratÃ³stenes, que 

viveu entre os anos de 276 e 194 a. C. Como estampado na designaÃ§Ã£o do teste, 

este mÃ©todo filtra os nÃºmeros colocados a teste â€“ como um crivo â€“ e entÃ£o obtÃ©m 

como resposta apenas aqueles classificados como primos. 

Uma  ideia  simples,  entretanto,  eficiente  para  localizar  primos  num 

intervalo  pequeno  de  nÃºmeros.  Vejamos  como  usar  este  mÃ©todo  para  obter  os 

nÃºmeros primos de 1 atÃ© um certo natural ğ‘›. 

Passo 1. No conjunto â„•, seleciona-se um subconjunto com todos os naturais atÃ© um 

dado nÃºmero ğ‘›; 

Passo 2. O nÃºmero 1, por definiÃ§Ã£o, nÃ£o Ã© primo, logo deve ser retirado do conjunto; 

Passo 3. Deve-se seguir a anÃ¡lise com o prÃ³ximo da lista, ou seja, o nÃºmero 2, que 

Ã© primo, logo deve ser mantido na lista. Em seguida sÃ£o cortados da lista todos os 

mÃºltiplos de 2, isto Ã©, os nÃºmeros pares; 

Passo 4.  A  seguir,  seleciona-se o  prÃ³ximo nÃºmero  nÃ£o  riscado  da  lista,  o 3,  que 

necessariamente Ã© primo, pois nÃ£o Ã© mÃºltiplo do nÃºmero anterior, nÃ£o cortado. ApÃ³s 

isso, corta-se todos os mÃºltiplos de 3 restantes no conjunto;  

Passo  5. Pelo mesmo  princÃ­pio  apresentado  na  DivisÃ£o  por Tentativa,  o  passo  4 

deve ser seguido atÃ© âˆšğ‘›. ApÃ³s isso, restarÃ£o na lista apenas os nÃºmeros primos. 

Para  ilustrar,  vamos  selecionar  os  primos  para  ğ‘› = 50.  Escreve-se 

inicialmente os nÃºmeros naturais atÃ© 50. 

  4 

  2 

  5 

  3 

  8 

  7 

  10 
  6 
1 
11    12    13    14    15    16    17    18    19    20 
21    22    23    24    25    26    27    28    29    30 
31    32    33    34    35    36    37    38    39    40 
41    42    43    44    45    46    47    48    49    50 

  9 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Agora, risca-se o 1. Em seguida mantÃ©m-se o 2, porÃ©m, risca-se todos 

os mÃºltiplos deste. 

47 

  4 

  3 

  5 

  2 

  8 

  7 

  9 

  10 
  6 
1 
11    12    13    14    15    16    17    18    19    20 
21    22    23    24    25    26    27    28    29    30 
31    32    33    34    35    36    37    38    39    40 
41    42    43    44    45    46    47    48    49    50 
Segue-se  o  mesmo  procedimento  para  o  prÃ³ximo  nÃºmero,  que 

necessariamente Ã© primo. Na nossa relaÃ§Ã£o Ã© o nÃºmero 3, logo cortam-se todos os 

seus mÃºltiplos. 

  3 

  2 

  4 

  5 

  8 

  7 

  10 
  6 
1 
11    12    13    14    15    16    17    18    19    20 
21    22    23    24    25    26    27    28    29    30 
31    32    33    34    35    36    37    38    39    40 
41    42    43    44    45    46    47    48    49    50 

  9 

O  prÃ³ximo  da  lista  Ã©  o  nÃºmero  7,  e  como  este  Ã©  o  nÃºmero  inteiro 

imediatamente anterior Ã   âˆš50,  entÃ£o,  serÃ¡  o  Ãºltimo nÃºmero  cujos mÃºltiplos  serÃ£o 

cortados de nossa relaÃ§Ã£o, assim. 

  3 

  5 

  4 

  2 

  8 

  9 

  7 

  10 
  6 
1 
11    12    13    14    15    16    17    18    19    20 
21    22    23    24    25    26    27    28    29    30 
31    32    33    34    35    36    37    38    39    40 
41    42    43    44    45    46    47    48    49    50 
Ao retirarmos os nÃºmeros nÃ£o riscados de nosso conjunto, teremos todos 

os nÃºmeros primos atÃ© o nÃºmero 50, a saber: 

2,3,5,11,13,17,19,23,29,31,37,41,43,47 

Algumas observaÃ§Ãµes importantes podem ser feitas perante o processo 

anteriormente  apresentado.  A  primeira  Ã©  o  fato  de  que  alguns  nÃºmeros  da  lista 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
48 

foram riscados mais de uma vez, como o nÃºmero 15, que foi cortado, primeiramente, 

por  ser  mÃºltiplo  de  3  e,  posteriormente,  por  ser  mÃºltiplo  de  5,  provocando  um 

trabalho desnecessÃ¡rio.  

Este  esforÃ§o  pode  ser  extinguido  da  seguinte  forma:  ao  selecionar  um 

nÃºmero ğ‘› cujos mÃºltiplos serÃ£o riscados da lista, serÃ¡ notado que os seus mÃºltiplos 

que  concomitantemente  sÃ£o  mÃºltiplos  de  um  primo  anterior  da  relaÃ§Ã£o  jÃ¡  se 

encontram riscados, portanto basta iniciar o corte a partir de ğ‘›Â², evitando-se utilizar 

fatores menores que ğ‘›, que seguramente jÃ¡ resultaram em eliminaÃ§Ãµes de nÃºmeros 

da  lista.  Em  suma,  a  partir  de  um  novo  primo  ğ‘›,  a  exclusÃ£o  de  novos  nÃºmeros 

deverÃ¡ ser realizada de ğ‘›2 em diante, resultando em economia de tempo. 

Uma  forma  generalizada  do  crivo  de  EratÃ³stenes,  na  qual  se  ignora  a 

ordem do nÃºmero a ser selecionado como referÃªncia na retirada dos mÃºltiplos, alÃ©m 

de  englobar  qualquer  subconjunto  de  naturais,  pode  ser  descrita  conforme 

detalhamento abaixo.  

Passo 1. Seja o conjunto ğ´ = {ğ‘›1, ğ‘›2, ğ‘›3, â€¦ , ğ‘›ğ‘š}, ğ´ âŠ‚ â„• para o qual deseja-se testar 

a primalidade dos elementos de ğ´; 

Passo  2.  Seja  ğ‘›1  o  menor  nÃºmero  do  conjunto  ğ´,  verifica-se  se  ğ‘›1  Ã©  primo  ou 

composto, adotando-se o seguinte procedimento conforme o respectivo caso; 

Caso 1. Se ğ‘›1 for composto, entÃ£o ele Ã© retirado do conjunto, assim como todos os 

seus mÃºltiplos pertencentes ao conjunto ğ´; 

Caso 2. Se ğ‘›1 for primo, entÃ£o ele Ã© mantido no conjunto, contudo todos os seus 

mÃºltiplos sÃ£o retirados do conjunto ğ´; 

Passo  3.  O  passo  2  Ã©  repetido  com  o  menor  elemento  de  ğ´,  a  exceÃ§Ã£o  do 

anteriormente analisado, atÃ© que se atinja o maior elemento deste conjunto.  

ApÃ³s  conclusÃ£o  dos  passos  acima,  restarÃ£o  no  conjunto  ğ´  apenas  os 

nÃºmeros primos.   

Uma  boa  observaÃ§Ã£o  do  passo  2,  nos  leva  a  concluir  que  o  nÃºmero 

selecionado como ponto de partida, ou qualquer outro que permaneÃ§a no conjunto 

 
 
49 

ğ´,  nÃ£o  necessita  ser  o  menor  nÃºmero  de  ğ´,  todavia,  na  escolha  de  um  nÃºmero 

aleatÃ³rio como referÃªncia para a retirada se seus mÃºltiplos, o processo demandarÃ¡ 

um maior tempo de execuÃ§Ã£o, visto que eventualmente poderÃ¡ ser o mÃºltiplo de um 

nÃºmero ainda nÃ£o selecionado, o que acarretarÃ¡ um passo a mais no processo.  

O crivo de EratÃ³stenes Ã© um teste determinÃ­stico e de custo exponencial. 

Oâ€™Neill (2008, apud Junior, Neto, 2009, p. 1) relata que â€œo algoritmo do crivo vai se 

tornando inapropriado Ã  medida que se aumenta o tamanho de ğ‘›. O tamanho de ğ‘› 

Ã©  exponencial  no  nÃºmero  de  dÃ­gitos.  A  complexidade  deste  algoritmo  Ã© 

ğ‘‚(ğ‘› log log ğ‘›).â€ 

Isto posto, temos um algoritmo de elevado custo, porÃ©m, apesar de sua 

impraticabilidade,  o  crivo  Ã©  uma  simples  forma  de  se  determinar  primos  em  um 

intervalo pequeno, alÃ©m  de  ser alvo de estudos  e  possuir  relevante  aplicaÃ§Ã£o  na 

computaÃ§Ã£o. 

Atualmente,  existem  inÃºmeros  dispositivos  digitais  (computadores, 

laptops, celulares, tablets etc.) que, por suas caracterÃ­sticas diversas, possuem uma 

grande variedade de desempenho. Uma forma de avaliar sua performance Ã© atravÃ©s 

de um ou mais programas.  

Um  dos  mais  reconhecidos  Ã©  o  mÃ©todo  denominado  benchmark,  que 

conforme Brookshear (2008, p. 93), â€œÃ© o processo de comparar o desempenho de 

mÃ¡quinas diferentes executando o mesmo programa, conhecido como amostra de 

teste (benchmark)â€. 

Devido Ã  simplicidade do mÃ©todo, o crivo de EratÃ³stenes Ã© utilizado como 

benchmark  padrÃ£o  na  avaliaÃ§Ã£o  de  desempenho  de  programas  de  computador, 

uma vez que dispensa operaÃ§Ãµes com divisÃ£o. Vejamos o que Gilbreath (1981, p. 

180) fala a respeito das caracterÃ­sticas de um benchmark hÃ¡bil. 

[...] o benchmark deve ser curto (nÃ£o mais do que uma pÃ¡gina de cÃ³digo-
fonte), capaz de acessar uma quantidade considerÃ¡vel de memÃ³ria, sem 
realizaÃ§Ã£o  de  multiplicaÃ§Ã£o  ou  divisÃ£o  e  facilmente  codificado  em  uma 
variedade  de  linguagens  de  alto  nÃ­vel.  Finalmente,  o  benchmark  deve 
realizar algo Ãºtil (ou pelo menos reconhecÃ­vel e verificÃ¡vel) (GILBREATH, 
1981, p. 180, traduÃ§Ã£o nossa). 

 
 
50 

O programa supra idealizado baseava-se no Crivo de EratÃ³stenes, pelas 

peculiaridades jÃ¡ descritas. Em 1980, Gilbreath relatou em seu artigo a criaÃ§Ã£o de 

um algoritmo do Crivo de EratÃ³stenes que calculava todos os nÃºmeros primos entre 

3 e 16.000 e que, ao contrÃ¡rio de outros mÃ©todos, o crivo evitava a divisÃ£o e era 

extremamente  rÃ¡pido,  pois  usava  conhecimento  sobre  nÃºmeros  que  podiam  ser 

primos (nÃºmeros pares e mÃºltiplos de primo) (GILBREATH, 1981). 

6.3 Teste de Fermat 

Como jÃ¡ descrito, Fermat foi um pensador do sÃ©culo XVII que realizou 

importantes  descobertas  no  campo  da  Teoria  dos  NÃºmeros,  dentre  elas, 

destacamos  o  Pequeno  Teorema  de  Fermat,  jÃ¡  apresentado  e  demonstrado20. 

Vejamos o que a literatura fala a respeito desse importante teorema. 

â€œO teorema tem sido uma grande influÃªncia em algoritmos da Teoria dos 

NÃºmeros, na medida em que representa a base para alguns dos mais conhecidos 

algoritmos de testes de primalidadeâ€ (AGRAWAL, 2006, traduÃ§Ã£o nossa). 

O Teorema de Fermat tambÃ©m pode ser exibido da seguinte forma. 

Teorema 3. Se p Ã© um nÃºmero primo, entÃ£o, para todo ğ‘ âˆˆ â„¤, ğ‘ğ‘ â‰¡ ğ‘ mod p. 

Quando ğ‘ âˆ¤ ğ‘, ou seja, se (ğ‘, ğ‘) = 121, pelo CorolÃ¡rio C.8.1, temos  

ğ‘ğ‘ â‰¡ ğ‘ mod p âŸº

ğ‘ğ‘
ğ‘

â‰¡

ğ‘
ğ‘

 mod p âŸº ğ‘ğ‘âˆ’1 â‰¡ 1 mod p 

Este resultado, apesar de ter sido proposto por Fermat no ano de 1640, 

sÃ³ foi provado em 1736, por Euler, e serviu de base para formulaÃ§Ãµes de diversos 

testes de primalidade posteriores.  

Vejamos, portanto, alguns exemplos de que ğ‘ primo e (ğ‘, ğ‘) = 1 implica 

em ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘, para todo ğ‘ inteiro. Para tanto, adotemos a seguinte forma: 

ğ‘ƒ primo  âŸ¹ ğ‘ âˆ£ ğ‘ğ‘âˆ’1 âˆ’ 1, âˆ€ ğ‘ âˆˆ â„¤   

20 Vide CapÃ­tulo 4, Item 4.1. 
21 Dados os inteiros ğ‘ e ğ‘, denota-se por (ğ‘, ğ‘) o mÃ¡ximo divisor comum de ğ‘ e ğ‘. 

 
 
 
Como ğ‘ divide ğ‘ğ‘âˆ’1 âˆ’ 1, entÃ£o existe ğ‘˜ âˆˆ â„¤, tal que ğ‘ğ‘âˆ’1 âˆ’ 1 = ğ‘˜ğ‘. Alguns 

resultados sÃ£o apresentados na tabela a seguir, para determinados valores de ğ‘ e 

ğ‘.  

51 

Tabela 2 â€“ Valores de (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘ para alguns primos ğ‘ 
ğ‘ 
2 
2 
2 
2 
2 
3 
3 
3 
3 
3 
4 
4 
4 
4 

ğ‘˜ = (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘ 
1 
3 
9 
93 
315 
1 
16 
104 
5368 
40880 
5 
51 
585 
95325 

ğ‘ğ‘âˆ’1 âˆ’ 1 
3 
15 
63 
1023 
4095 
2 
80 
728 
59048 
531440 
15 
255 
4095 
1048575 

ğ‘ 
3 
5 
7 
11 
13 
2 
5 
7 
11 
13 
3 
5 
7 
11 

Fonte: Elaborado pelo autor 

Ã‰  importante  observar  que  a  utilizaÃ§Ã£o  do  teste  para  confirmaÃ§Ã£o  de 

primos  consiste  na  utilizaÃ§Ã£o  da  recÃ­proca  do  Teorema  de  Fermat,  uma  vez  que 

desejamos descobrir se determinado nÃºmero ğ‘ Ã© primo, contudo, nem todo ğ‘ que 

divide ğ‘ğ‘âˆ’1 âˆ’ 1, para todo ğ‘ inteiro, Ã© primo.  

Vejamos a tabela seguinte com alguns valores de (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘: 

Tabela 3 â€“ Valores de (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘ para alguns valores de ğ‘ composto 

ğ‘ 
2 
2 
2 
2 
3 
3 
3 
3 
4 
5 
5 
5 

ğ‘ 
9 
15 
21 
25 
4 
8 
10 
14 
9 
8 
10 
14 

ğ‘ğ‘âˆ’1 âˆ’ 1 
255 
16383 
1048575 
16777215 
26 
2186 
19682 
1594322 
65535 
78124 
1953124 
1220703124 

ğ‘˜ = (ğ‘ğ‘âˆ’1 âˆ’ 1)/ğ‘ 
28,33333333 
1092,2 
49932,14286 
671088,6 
6,5 
273,25 
1968,2 
113880,1429 
7281,666667 
9765,5 
195312,4 
87193080,29 

Fonte: Elaborado pelo autor 

 
 
52 

Ã€ primeira vista, pode parecer que para todo ğ‘ inteiro e ğ‘ composto, tem-

se  que  ğ‘  nÃ£o  divide  ğ‘ğ‘âˆ’1 âˆ’ 1,  contudo  o  composto  ğ‘ = 561 = 3 âˆ™ 11 âˆ™ 17  Ã©  um 

contraexemplo de que a recÃ­proca do Pequeno Teorema de Fermat nem sempre Ã© 

verdadeira. 

Quando ğ‘ e ğ‘ sÃ£o coprimos, os nÃºmeros compostos ğ‘ tais que ğ‘ğ‘âˆ’1 â‰¡

1 mod ğ‘, para todo ğ‘, 1 < ğ‘ < ğ‘, sÃ£o denominados NÃºmeros de Carmichael22, cujo 

menor Ã© 561 = 3 âˆ™ 11 âˆ™ 17 (RIBENBOIM, 2014). 

O  teste  de  Fermat  consiste  na  utilizaÃ§Ã£o  do  Pequeno  Teorema  de 

Fermat, atravÃ©s do qual adota-se um valor inteiro de ğ‘ para um determinado nÃºmero 

ğ‘ a ser testado como primo, com (ğ‘, ğ‘) = 1. Estipula-se uma quantidade ğ‘˜ de vezes 

de  realizaÃ§Ã£o  do  teste.  Se  em  todas  estas,  resultar  ğ‘ âˆ£ ğ‘ğ‘âˆ’1 âˆ’ 1,  entÃ£o  p  serÃ¡ 

retornado  como  provavelmente  primo.  Caso  contrÃ¡rio,  serÃ¡  respondido  como 

seguramente composto. O teste Ã© probabilÃ­stico, uma vez que Ã© impossÃ­vel realizar 

infinitas tentativas.  

O  teste  Ã©  quase  perfeito,  jÃ¡  que  os  nÃºmeros  de  Carmichael  sÃ£o 

extremamente  raros.  HÃ¡  apenas  255  destes  menores  que  100.000.000,  ou  seja, 

somente  0,000255%  dos  primeiros  nÃºmeros  naturais  sÃ£o  de  Carmichael 

(CORMEM, LEISERSON, et al., 2002). 

Segue-se,  a  partir  desta  ideia,  o  conceito  de  pseudoprimo,  definidos 

como  provÃ¡veis  primos  que  sÃ£o,  na  verdade,  compostos.  Consoante  Cadwell 

(2021),  ao  se  aplicar  o  Teste  de  Fermat,  em  ğ‘ğ‘âˆ’1 â‰¡ 1 (mod ğ‘), se  o  nÃºmero  ğ‘ 

testado for primo, entÃ£o serÃ¡ denominado provÃ¡vel primo base ğ‘ ou apenas a-PRP 

â€“ do inglÃªs, probable prime base ğ‘) (CALDWELL, 2021). 

O teste de Fermat possui larga utilizaÃ§Ã£o em criptografia, na medida em 

que  se  busca  uma  rÃ¡pida  localizaÃ§Ã£o  de  chaves  criptogrÃ¡ficas.  Seu  tempo  de 

execuÃ§Ã£o Ã© ğ‘‚(ğ‘ log ğ‘›) operaÃ§Ãµes aritmÃ©ticas para ğ‘ diferentes bases em a-PRP.  

22    Robert  Daniel  Carmichael  (1879-1967),  matemÃ¡tico  estadunidense  com  Ã¡rea  de  atuaÃ§Ã£o  em 
Teoria dos NÃºmeros. Ficou mais conhecido pelo nÃºmero que leva seu nome, nÃºmero de Carmichael 
(O'CONNOR e ROBERTSON, 2010) 

 
 
 
53 

6.4 Teste de Proth 

Os  NÃºmeros  de  Proth,  assim  denominados  em  alusÃ£o  ao  matemÃ¡tico 

francÃªs FranÃ§ois Proth, que viveu no sÃ©culo XIV, sÃ£o aqueles da forma  

ğ‘ = ğ‘˜ âˆ™ 2ğ‘› + 1  

Onde ğ‘˜ Ã© um nÃºmero inteiro Ã­mpar e ğ‘› Ã© um inteiro positivo tal que 2ğ‘› >

ğ‘˜. Os primeiros sete nÃºmeros de Proth sÃ£o  

Para ğ‘˜ = 1 e ğ‘› = 1, ğ‘ = 1 âˆ™ 21 + 1 = 3 

Para ğ‘˜ = 1 e ğ‘› = 2, ğ‘ = 1 âˆ™ 22 + 1 = 5 

Para ğ‘˜ = 1 e ğ‘› = 3, ğ‘ = 1 âˆ™ 23 + 1 = 9 

Para ğ‘˜ = 3 e ğ‘› = 2, ğ‘ = 3 âˆ™ 22 + 1 = 13 

Para ğ‘˜ = 1 e ğ‘› = 4, ğ‘ = 1 âˆ™ 24 + 1 = 17 

Para ğ‘˜ = 3 e ğ‘› = 3, ğ‘ = 3 âˆ™ 23 + 1 = 25 

Para ğ‘˜ = 1 e ğ‘› = 5, ğ‘ = 1 âˆ™ 25 + 1 = 33 

Ã‰ importante notar que os NÃºmeros de Fermat ğ¹ğ‘› =   22ğ‘›

+ 1, jÃ¡ definidos 

no atual trabalho, sÃ£o um caso particular dos nÃºmeros de Proth. Quando primos, os 

nÃºmeros de Proth sÃ£o denominados Primos de Proth. 

O Teste de Primalidade de Proth Ã© uma consequÃªncia direta do Teorema 

de  Proth,  um  teste  probabilÃ­stico  publicado  em  1878,  cuja  descriÃ§Ã£o  pode  ser 

observada logo a seguir. 

Teorema 4. Seja ğ‘ = ğ‘˜ âˆ™ 2ğ‘› + 1  um nÃºmero de Proth. Se existe ğ‘ âˆˆ â„¤, ğ‘ > 1, tal que  

ğ‘âˆ’1
2 â‰¡ âˆ’1(mod ğ‘) 

ğ‘

EntÃ£o ğ‘ Ã© primo. 

DemonstraÃ§Ã£o. Adotemos o seguinte resultado, demonstrado na obra de Martinez, 

Moreira, et al., (2013).  

 
 
54 

Se ğ‘› âˆ’ 1 = ğ¹ğ‘…, com ğ¹ > ğ‘… e para todo fator primo ğ‘ de ğ¹ existe um ğ‘ >

1, tal que ğ‘ğ‘›âˆ’1 â‰¡ 1 (mod ğ‘›) e (ğ‘

ğ‘›âˆ’1
ğ‘ âˆ’ 1, ğ‘›) = 1, entÃ£o ğ‘› Ã© primo. 

Agora, fazendo ğ¹ = 2ğ‘˜, temos ğ‘› = â„2ğ‘˜ + 1 âŸº ğ‘› âˆ’ 1 = â„2ğ‘˜, como 2ğ‘˜ > â„ 

e como para todo fator primo ğ‘ de 2ğ‘˜ (ğ‘ = 2), existe ğ‘ > 1 tal que  

ğ‘›âˆ’1
2 â‰¡ âˆ’1(mod ğ‘›) âŸº (ğ‘

ğ‘

2
ğ‘›âˆ’1
2 )

â‰¡ (âˆ’1)2(mod ğ‘›) âŸº ğ‘ğ‘›âˆ’1 â‰¡ 1(mod ğ‘›) 

E como  

ğ‘›âˆ’1
2 â‰¡ âˆ’1(mod ğ‘›) âŸº ğ‘› âˆ£ ğ‘

ğ‘›âˆ’1
2 + 1 

ğ‘

Mas ğ‘› Ã© Ã­mpar maior que 1, logo  

ğ‘› âˆ¤   ğ‘

ğ‘›âˆ’1
2 + 1 âˆ’ 2 = ğ‘

ğ‘›âˆ’1
2 âˆ’ 1 

Dessa forma, (ğ‘

ğ‘›âˆ’1
2 âˆ’ 1, ğ‘›) = 1 

Portanto, ğ‘› Ã© primo.  

O maior primo conhecido antes da era computacional foi de Proth, com 

44  dÃ­gitos,  encontrado  em  1951,  com  a  ajuda  de  uma  calculadora  mecÃ¢nica  de 

mesa, conforme descrito por Caldwell (2021): â€œem 1951, Ferrier encontrou o primo 

(2148 + 1)/17 =  20988936657440586486151264256610222593863921â€. 

Os  primos  de  Proth  sÃ£o  frequentes  e  facilmente  verificados,  pelos 

resultados  anteriormente  apresentados, 

logo  muitos  dos  maiores  primos 

conhecidos sÃ£o desse tipo (MARTINEZ, MOREIRA , et al., 2013). 

6.5 Teste de PÃ©pin 

O Teste de PÃ©pin Ã© um teste de primalidade para nÃºmeros de Fermat. O 

teste  leva  o  nome  do  matemÃ¡tico  francÃªs  Jean  FranÃ§ois  ThÃ©ophile  PÃ©pin  (1826-

1905) e Ã© descrito da seguinte forma 

Teorema 5. Seja ğ¹ğ‘› = 22ğ‘›
ğ¹ğ‘› Ã© primo.  

+ 1 (nÃºmero de Fermat), se 3

2 â‰¡ âˆ’1 (mod ğ¹ğ‘›), entÃ£o 

ğ¹ğ‘›âˆ’1

 
 
55 

DemonstraÃ§Ã£o.  Seja  a  seguinte  proposiÃ§Ã£o,  demonstrada  na  obra  de  Martinez, 

Moreira, et al., (2013).  

Dado ğ‘› > 1, se para cada fator primo ğ‘ de ğ‘› âˆ’ 1 existe um inteiro ğ‘ğ‘ tal 

que ğ‘ğ‘

ğ‘›âˆ’1 â‰¡ 1 (mod ğ‘›) e ğ‘ğ‘

ğ‘ â‰¢ 1 (mod ğ‘›), entÃ£o ğ‘› Ã© primo. 

ğ‘›âˆ’1

Agora, pela proposiÃ§Ã£o destacada, dado ğ¹ğ‘› = 22ğ‘›

+ 1, que Ã© maior que 

1,  entÃ£o  ğ¹ğ‘› âˆ’ 1 = 22ğ‘›

,  cujo  fator  primo  Ã©  2.  Como,  pela  hipÃ³tese,  3

2 â‰¡

ğ¹ğ‘›âˆ’1

âˆ’1 (mod ğ¹ğ‘›) âŸº   (3

2

ğ¹ğ‘›âˆ’1

2 )

â‰¡ (âˆ’1)2 (mod ğ¹ğ‘›) âŸº 3ğ¹ğ‘›âˆ’1 â‰¡ 1 (mod ğ¹ğ‘›), entÃ£o existe um 

inteiro  ğ‘ğ‘  tal  que  ğ‘ğ‘

ğ‘›âˆ’1 â‰¡ 1 (mod ğ‘›)  e  nÃ£o  existe  3

ğ¹ğ‘›âˆ’1
2

  congruente  Ã   1  mÃ³dulo  ğ¹ğ‘›, 

logo, ğ¹ğ‘› Ã© primo.  

Para exemplificar, vamos aplicar o teste para o nÃºmero de Fermat com 

ğ‘› = 4. 

Devemos  provar  que  3

2 â‰¡ âˆ’1 (mod ğ¹4).  Como  ğ¹4 = 224

+ 1 = 216 +

ğ¹4âˆ’1

1 = 65536 + 1 = 65537, 

entÃ£o 

ğ¹4âˆ’1
2

= 32768. 

Mas 

332768 â‰¡ 65536 â‰¡

âˆ’1(mod 65537), entÃ£o 3

ğ¹4âˆ’1

2 â‰¡ âˆ’1 (mod ğ¹4), e ğ¹4 Ã© primo.  

6.6 Teste de Lucas-Lehmer 

O teste a seguir foi apresentado por Lucas em 1876 e aperfeiÃ§oado por 

Lehmer em 1932. O algoritmo Ã© definido por recorrÃªncia e Ã© utilizado para testar a 

primalidade de nÃºmeros de Mersenne. A chave do teste encontra-se na sequÃªncia 

de inteiros ğ‘†0, ğ‘†1, ğ‘†2, â€¦ definida recursivamente como 

{

ğ‘†0 = 4
ğ‘†ğ‘› = ğ‘†ğ‘›âˆ’1

2 âˆ’ 2

Teste de Lucas-Lehmer. Seja ğ‘ um nÃºmero primo positivo. Se ğ‘†ğ‘âˆ’2 â‰¡ 0 (mod ğ‘€ğ‘), 

entÃ£o o nÃºmero de Mersenne ğ‘€ğ‘ Ã© primo. 

Ou em outras palavras, se ğ‘€ğ‘ divide ğ‘†ğ‘âˆ’2, entÃ£o ğ‘€ğ‘Ã© primo.  

 
 
 
56 

Sua  demonstraÃ§Ã£o  transcende  o  conteÃºdo  abordado  nesse  trabalho, 

contudo pode ser verificada no trabalho de Coutinho (2004, p. 162), no entanto o 

teste Ã© de fÃ¡cil implementaÃ§Ã£o e utilizaÃ§Ã£o. Vejamos alguns exemplos. 

Para  ğ‘› = 3,  temos  ğ‘€3 = 23 âˆ’ 1 = 7.  Como  ğ‘†0 = 4,  entÃ£o  ğ‘†1 = 42 âˆ’ 2 =

14. Dessa forma, ğ‘€3 âˆ£ ğ‘†1, logo ğ‘€3 Ã© primo. 

Para ğ‘› = 7, temos ğ‘€7 = 27 âˆ’ 1 = 127. Devemos achar ğ‘†5, entÃ£o temos 

ğ‘†2 = 142 âˆ’ 2 = 194 

ğ‘†3 = 1942 âˆ’ 2 = 37.636 âˆ’ 2 = 37.634 

ğ‘†4 = 366342 âˆ’ 2 = 1.416.317.956 âˆ’ 2 = 1.416.317.954 

ğ‘†5 = 1.416.317.9542 âˆ’ 2 = 2.005.956.546.822.746.116 âˆ’ 2
= 2.005.956.546.822.746.114 

Como  127 âˆ™ 15.794.933.439.549.182 = 2.005.956.546.822.746.114,  entÃ£o 

ğ‘€7 âˆ£ ğ‘†5 e, portanto, ğ‘€7 Ã© primo.  

O Ãºltimo exemplo serviu para mostrar que, como a sequÃªncia ğ‘†ğ‘› cresce 

rapidamente, Ã© mais conveniente utilizar operaÃ§Ãµes com mÃ³dulo ğ‘€ğ‘. Assim, o Teste 

de Lucas-Lehmer poderia ser escrito da seguinte forma. 

ğ‘†0 = 4

{

ğ‘†ğ‘› â‰¡ (ğ‘†ğ‘›âˆ’1

2 âˆ’ 2) (mod ğ‘€ğ‘) 

ğ‘†ğ‘›âˆ’2 â‰¡ 0 (mod ğ‘€ğ‘) âŸ¹   ğ‘€ğ‘ Ã© primo

Logo, para ğ‘› = 7 terÃ­amos. 

ğ‘†0 = 4 

 ğ‘†1 â‰¡ 14 (mod 127) 

 ğ‘†2 â‰¡ (142 âˆ’ 2) â‰¡ 194 â‰¡ 67 (mod 127) 

 ğ‘†3 â‰¡ (672 âˆ’ 2) â‰¡ 4487 â‰¡ 42 (mod 127) 

 ğ‘†4 â‰¡ (422 âˆ’ 2) â‰¡ 1762 â‰¡ 111 (mod 127) 

 ğ‘†5 â‰¡ (1112 âˆ’ 2) â‰¡ 12319 â‰¡ 0 (mod 127) 

 
 
 
57 

Portanto, como  ğ‘†5 â‰¡ 0 (mod ğ‘€7), ğ‘€7 Ã© primo.  

O mÃ©todo acima Ã© determinÃ­stico de tempo polinomial e seu custo Ã© da 

ordem de O(ğ‘2 log ğ‘) (COLQUITT e WELSH JR, 1991). Comparado a outros testes, 

o algoritmo de Lucas-Lehmer Ã© de baixo custo, o que o tem colocado, desde a sua 

idealizaÃ§Ã£o, como um dos principais na descoberta de primos.  

Lucas, em 1876, ao aplicar seu prÃ³prio teste, descobriu que ğ‘€127 Ã© primo. 

Com 39 algarismos, este foi o maior primo conhecido atÃ© o ano de 1951, quando se 

iniciou a era dos computadores modernos (RIBENBOIM, 2014). 

Na medida que ğ‘ aumenta, ğ‘€ğ‘ torna-se consideravelmente grande, o que 

torna  os  cÃ¡lculos  excessivamente  trabalhosos  e  exaustivos,  contudo,  com  a 

evoluÃ§Ã£o das mÃ¡quinas, esta tarefa foi consideravelmente reduzida, conforme se vÃª 

na narrativa seguinte. 

A aplicaÃ§Ã£o do teste de LUCAS e LEHMER para investigar a primaridade 
de ğ‘€ğ‘ quando ğ‘ Ã© grande, exige cÃ¡lculos muito longos. Para afrontar esses 
problemas tÃ©cnicos, trabalha-se com computadores muito possantes, em 
equipes. Mas tambÃ©m  utilizam-se programas especialmente concebidos. 
[...]  WOLTMAN23  preparou  um  programa  com  janelas  e  criou  o  GIMPS 
(â€˜Great  Internet  Mersenne  Prime  Searchâ€).  Qualquer  um  que  queira 
participar  no  projeto,  com  seus  computadores  pessoais,  recebe  o 
â€œsoftwareâ€ gratuitamente, uma faixa de primos ğ‘ a serem investigados bem 
como acesso de informaÃ§Ãµes sobre o assunto (RIBENBOIM, 2014, p. 76). 

Desde 1996, os Ãºltimos 15 maiores primos descobertos foram provados 

pelo programa GIMPS. AtÃ© o fechamento deste trabalho (agosto de 2021), o maior 

primo conhecido Ã© o de Mersenne, ğ‘€82589933 = 282589933 âˆ’ 1, com 24.862.048 de dÃ­gitos 

(CALDWELL, 2021). 

6.7 Crivo de Sundaram 

Com um mÃ©todo parecido ao  Crivo de EratÃ³stenes, jÃ¡ detalhado nesta 

pesquisa, apresentaremos agora um sistema de nÃºmeros dispostos em tabela com 

exclusÃµes e destaque de certos algarismos.  

Muitos  leitores,  provavelmente,  estÃ£o  familiarizados  com  o  "Crivo  de 

EratÃ³stenes" para filtrar nÃºmeros primos, contudo, em 1934, um jovem estudante 

23 George Woltman, criador e um dos diretores do GIMPS. 

 
 
 
58 

indiano  chamado  Sundaram,  propÃ´s  uma  outra  alternativa,  chamada  Crivo  de 

Sundaram (HONSBERGER, 1970).  

O mÃ©todo explora o fato de que todo primo a partir do 2 Ã© um nÃºmero 

Ã­mpar nÃ£o composto. Consiste, portanto, na formaÃ§Ã£o de uma tabela de nÃºmeros 

naturais Ã­mpares compostos dispostos em progressÃ£o aritmÃ©tica, em cada coluna. 

Ao final, os Ã­mpares que nÃ£o estiverem na tabela, serÃ£o primos.  

Consideremos os nÃºmeros Ã­mpares representados por 2ğ‘š + 1 e 2ğ‘› + 1, 

com  ğ‘š  e  ğ‘›  naturais.  Assim  sendo,  poderÃ­amos  representar  o  nÃºmero  Ã­mpar  ğ‘ 

composto da seguinte maneira: ğ‘ = (2ğ‘š + 1)(2ğ‘› + 1) = 4ğ‘šğ‘› + 2ğ‘š + 2ğ‘› + 1 

A  montagem  da  tabela  consiste  em  organizar  seus  nÃºmeros  ğ‘ğ‘–Ã—ğ‘— 

conforme a disposiÃ§Ã£o das linhas ğ‘šğ‘– = ğ‘–, com ğ‘– âˆˆ â„•, e colunas ğ‘›ğ‘— = ğ‘—, com ğ‘— âˆˆ â„•. 

Assim, terÃ­amos ğ‘ğ‘–Ã—ğ‘— = 4ğ‘šğ‘–ğ‘›ğ‘— + 2ğ‘šğ‘– + 2ğ‘›ğ‘— + 1. Dessa forma, para a primeira linha e 

primeira coluna, temos ğ‘š1 = 1 e ğ‘›1 = 1 que resultam em ğ‘1Ã—1 = 4 âˆ™ 1 âˆ™ 1 + 2 âˆ™ 1 + 2 âˆ™

1 + 1 = 9; para a segunda linha e primeira coluna, possuÃ­mos ğ‘š2 = 2 e ğ‘›1 = 1 que 

resultam  em  ğ‘2Ã—1 = 4 âˆ™ 2 âˆ™ 1 + 2 âˆ™ 2 + 2 âˆ™ 1 + 1 = 15,  e  assim  sucessivamente,  atÃ© 

chegarmos na seguinte tabela, para valores de ğ‘š e ğ‘› de 1 a 16. 

Tabela 4 â€“ Crivo de Sundaram 

ğ‘›1  ğ‘›2  ğ‘›3  ğ‘›4  ğ‘›5  ğ‘›6  ğ‘›7  ğ‘›8  ğ‘›9  ğ‘›10  ğ‘›11  ğ‘›12  ğ‘›13  ğ‘›14  ğ‘›15  ğ‘›16 
57 
99 
95 

63 
93 
105  115  125  135  145  155 

51 
85 

75 

69 

81 

87 

45 
75 
105  119  133  147  161  175  189  203 

39 
65 
91 
117  135  153  171  189  207  225  243 

33 
55 
77 
99 
121  143  165  187  209  231  253  275 

27 
45 
63 
81 
99 
117  143  169  195  221  247  273  299 

21 
35 
49 
63 
77 
91 
105  135  165  195  225  255  285  315 
119  153  187  221  255  289  323 
133  171  209  247  285  323 

ğ‘š1  9 
15 
ğ‘š2  15  25 
ğ‘š3  21  35 
ğ‘š4  27  45 
ğ‘š5  33  55 
ğ‘š6  39  65 
ğ‘š7  45  75 
ğ‘š8  51  85 
ğ‘š9  57  95 
ğ‘š10  63  105  147  189  231  273  315 
ğ‘š11  69  115  161  207  253  299 
ğ‘š12  75  125  175  225  275 
ğ‘š13  81  135  189  243 
ğ‘š14  87  145  203 
ğ‘š15  93  155 
ğ‘š16  99 
Fonte: Elaborado pelo autor  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
59 

A tabela formada pelos nÃºmeros ğ‘šğ‘– e ğ‘›ğ‘—, com ğ‘– = ğ‘—, separa os elementos 

(2ğ‘šğ‘–â€² + 1)(2ğ‘›ğ‘—â€² + 1)  e 

(2ğ‘šğ‘–â€²â€² + 1)(2ğ‘›ğ‘—â€²â€² + 1),  com 

ğ‘–â€² = ğ‘—â€²â€²  e 

ğ‘–â€²â€² = ğ‘—â€²,  e 

consequentemente  ğ‘šğ‘–â€² = ğ‘›ğ‘—â€²â€²  e  ğ‘šğ‘–â€²â€² = ğ‘›ğ‘—â€²,  logo  (2ğ‘šğ‘–â€² + 1)(2ğ‘›ğ‘—â€² + 1) = (2ğ‘šğ‘–â€²â€² +

1)(2ğ‘›ğ‘—â€²â€² + 1). A tabela 4 reÃºne todos os elementos com ğ‘– variando de 1 a 16 e ğ‘— de 

1 a 16, dos quais, os nÃºmeros formados por ğ‘š1 e ğ‘›ğ‘—, ğ‘— âˆˆ (1,16), ğ‘š2 e ğ‘›ğ‘—, ğ‘— âˆˆ (1,9), 

ğ‘š3 e ğ‘›ğ‘—, ğ‘— âˆˆ (1,6), ğ‘š4 e ğ‘›ğ‘—, ğ‘— âˆˆ (1,5) formam todos os nÃºmeros Ã­mpares compostos 

atÃ© 99. Como, com exceÃ§Ã£o do 1, todo nÃºmero Ã­mpar nÃ£o contido na tabela nÃ£o Ã© 

composto, entÃ£o todos os Ã­mpares atÃ© 100, nÃ£o pertencentes Ã quela, sÃ£o primos, a 

saber: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 

83, 89, 97. 

 
 
 
 
60 

7 TESTES COMPUTACIONAIS 

7.1 Teste de Solovay-Strassen 

O  Teste  de  Slovay-Strassen  Ã© um mÃ©todo  desenvolvido  em  1977 pelo 

estadunidense Robert Martin Solovay e pelo alemÃ£o Volker Strassen. Ã‰ um teste 

probabilÃ­stico  em  tempo  polinomial  do  tipo  Monte-Carlo.  Sobre  esta  Ãºltima 

ferramenta,  Weisstein  (2021)  a  define  como  â€œqualquer  mÃ©todo  que  resolva  um 

problema por meio da geraÃ§Ã£o adequada de nÃºmeros aleatÃ³rios e analise se aquela 

fraÃ§Ã£o  de  nÃºmeros  obedece  determinadas  propriedades.  O  mÃ©todo  Ã©  Ãºtil  para 

obtenÃ§Ã£o  de  soluÃ§Ãµes  numÃ©ricas  para  problemas  que  sÃ£o  muito  complicados  de 

resolver analiticamente.â€ (WEISSTEIN, 2021, traduÃ§Ã£o nossa)  

O teste Ã© realizado, basicamente, atravÃ©s de uma seleÃ§Ã£o aleatÃ³ria dos 

dados  de  entrada  que  retorna  um  resultado  provavelmente  correto.  Dado  um 

nÃºmero  de  entrada  ğ‘›,  a  saÃ­da  serÃ¡  ğ‘›  composto  ou  ğ‘›  provavelmente  primo.  Seu 

funcionamento baseia-se no CritÃ©rio de Euler, que afirma: 

Se ğ‘ Ã© um nÃºmero Ã­mpar e ğ‘ âˆˆ â„¤, com ğ‘ e ğ‘ coprimos, entÃ£o 

ğ‘

ğ‘âˆ’1
2 â‰¡ (

ğ‘
ğ‘

) (mod ğ‘) 

Onde (

ğ‘

ğ‘

) Ã© o sÃ­mbolo de Legendre24, definido, para ğ‘ primo, como: 

0,

caso ğ‘ divida ğ‘

{

 1, caso ğ‘ seja um resÃ­duo quadrÃ¡tico25 mÃ³dulo ğ‘
âˆ’1, caso ğ‘ nÃ£o seja um resÃ­duo quadrÃ¡tico mÃ³dulo ğ‘

O critÃ©rio Ã© demonstrado em Hefez (2014, p. 287). 

Para ğ‘› âˆˆ â„¤, Ã­mpar, temos (

ğ‘

ğ‘›

) como resultado do produto dos sÃ­mbolos 

de  Legendre,  definido  como  sÃ­mbolo  de  Jacobi26,  portando  representa  uma 

generalizaÃ§Ã£o daquele. Sendo ğ‘ğ‘– cada um dos fatores primos de ğ‘›, temos 

24 Adrien-Marie Legendre, matemÃ¡tico francÃªs que viveu entre os sÃ©culos XVIII e XIX (1752-1833) 
25 Um nÃºmero ğ‘ âˆˆ â„¤ Ã© um resÃ­duo quadrÃ¡tico mÃ³dulo ğ‘ se existe algum ğ‘¥ que satisfaÃ§a a equaÃ§Ã£o 
ğ‘¥2 â‰¡ ğ‘ (mod ğ‘) 
26 Carl Gustav Jakob Jacobi, matemÃ¡tico alemÃ£o do sÃ©culo XIX (1804-1851). 

 
 
 
 
(

ğ‘
ğ‘›

) = (

ğ‘
ğ‘1

) (

ğ‘
ğ‘2

) (

ğ‘
ğ‘3

) âˆ™ â‹¯ âˆ™ (

ğ‘
ğ‘ğ‘›

) 

61 

Como, para todo ğ‘ âˆˆ â„¤, o critÃ©rio Ã© verdadeiro, entÃ£o se, apÃ³s testados 

todos os valores do intervalo (1, ğ‘› âˆ’ 1), o critÃ©rio for satisfeito, ğ‘› serÃ¡ primo. Sendo 

assim, para valores aleatÃ³rios de ğ‘›, a congruÃªncia a ser verificada serÃ¡. 

ğ‘›âˆ’1
2 â‰¡ (

ğ‘

ğ‘
ğ‘›

) (mod ğ‘›) 

Os passos adotados no algoritmo de Solovay-Strassen sÃ£o os seguintes. 

Passo 1. Selecionar aleatoriamente um nÃºmero ğ‘¥; 

Passo 2. Aplicado o teste, este trarÃ¡ como resposta que ğ‘¥ Ã© seguramente composto 

ou que ğ‘¥ Ã© provavelmente primo; 

Passo 3. Se ğ‘¥ for provavelmente primo, a chance de ser composto Ã© de no mÃ¡ximo 

1/2; 

Passo  4.  ApÃ³s  ğ‘›  operaÃ§Ãµes,  com  a  permanÃªncia  da  resposta  de  provavelmente 

primo, a probabilidade de retorno de um pseudoprimo Ã© de no mÃ¡ximo de (Â½)ğ‘›. Na 

medida que ğ‘› aumenta, o erro se torna desprezÃ­vel. 

Assim  como  os  demais  testes  probabilÃ­sticos,  o  algoritmo  de  Solovay-

Strassen possuirÃ¡ maior precisÃ£o quanto maior for o nÃºmero de iteraÃ§Ãµes, logo, pelo 

exposto, o teste Ã© determinÃ­stico para exames com todos os valores de ğ‘›, contudo, 

para enormes valores de ğ‘›, o mÃ©todo Ã© inviÃ¡vel.  

Com  uso  de  rÃ¡pidos  algoritmos  de  exponenciaÃ§Ã£o  modular,  o  custo 

computacional 

deste 

algoritmo 

Ã©  ğ‘‚(ğ‘˜ âˆ™ ğ‘™ğ‘œğ‘”3ğ‘›), 

para 

ğ‘˜ 

testagens 

(GEEKSFORGEEKS, 2021).  

7.2 Teste de Miller-Rabin 

Ã‰  um  teste  probabilÃ­stico  de  tempo  polinomial  tambÃ©m  do  tipo  Monte 

Carlo, elaborado por Gary Miller e Michael Rabin. Ã‰ um aprimoramento do teste de 

Solovay-Strassen,  com  margem  de  erro  consideravelmente  menor.  Sobre  esse 

algoritmo, Sautoy (2007, p. 263) relata que â€œnos anos de 1980, dois matemÃ¡ticos, 

 
 
62 

Gary Miller e Michael Rabin, desenvolveram finalmente uma variaÃ§Ã£o que garantiria, 

apÃ³s poucos testes, que um nÃºmero Ã© primoâ€. 

O teste Ã© fundamentado no seguinte teorema. 

Teorema  6.  Se  ğ‘  Ã©  um  nÃºmero  primo  e  ğ‘¥ > 1,  tal que  ğ‘¥2 â‰¡ 1(mod ğ‘),  entÃ£o ğ‘¥ â‰¡

1 (mod ğ‘) ou ğ‘¥ â‰¡ (ğ‘ âˆ’ 1) (mod ğ‘) 

DemonstraÃ§Ã£o..ğ‘¥2 â‰¡ 1 (mod ğ‘) âŸ¹ ğ‘¥2 âˆ’ 1 â‰¡ 0 (mod ğ‘) âŸ¹ (ğ‘¥ + 1)(ğ‘¥ âˆ’ 1) â‰¡

0 (mod ğ‘) âŸ¹  ğ‘¥ + 1 â‰¡ 0 (mod ğ‘) ou ğ‘¥ âˆ’ 1 â‰¡ 0 (mod ğ‘) âŸ¹ ğ‘¥ â‰¡ âˆ’1 (mod ğ‘) ou ğ‘¥ â‰¡

1 (mod ğ‘) âŸ¹ ğ‘¥ â‰¡ âˆ’1 â‰¡ ğ‘ âˆ’ 1 (mod ğ‘) ou ğ‘¥ â‰¡ 1 (mod ğ‘) âŸ¹ ğ‘¥ â‰¡ (ğ‘ âˆ’

1) (mod ğ‘) ou ğ‘¥ â‰¡ 1 (mod ğ‘) 

O funcionamento do teste Ã© baseado na seguinte anÃ¡lise:  

Dado  um  nÃºmero  ğ‘¥ âˆˆ â„¤,  par,  podemos  escrevÃª-lo  como  ğ‘¥ = 2ğ‘,  logo, 

temos dois casos: 

I.  ğ‘ Ã­mpar âŸ¹ ğ‘¥ = 2ğ‘1 
II.  ğ‘ par âŸ¹ ğ‘1 = 2ğ‘2, logo ğ‘¥ = 2 âˆ™ 2ğ‘2 = 22ğ‘2 

No segundo caso, podemos continuar o processo enquanto  ğ‘ğ‘› for par, 

com consequente aumento do Ã­ndice ğ‘›. Ã€ vista disso, ğ‘ğ‘› diminui atÃ© que em dado 
momento ğ‘ğ‘› serÃ¡ Ã­mpar, ou seja, ğ‘¥ = 2ğ‘›ğ‘ğ‘›. Fazendo ğ‘ğ‘› = ğ‘, temos ğ‘¥ = 2ğ‘›ğ‘.  

Sabendo que para todo primo ğ‘ > 2, ğ‘ âˆ’ 1 Ã© par, teremos ğ‘ âˆ’ 1 = 2ğ‘›ğ‘š.  

Dados  ğ‘  primo  e  ğ‘ âˆˆ â„¤ ,  se  ğ‘ âˆ¤ ğ‘,  entÃ£o  (ğ‘, ğ‘) = 1  e,  pelo  Pequeno 

Teorema  de  Fermat,  ğ‘ğ‘âˆ’1 â‰¡ 1 (mod ğ‘),  assim  ğ‘2ğ‘›ğ‘š â‰¡ 1 (mod ğ‘) âŸ¹ (ğ‘ğ‘š)2ğ‘›
1 (mod ğ‘). Dessa forma, pela ProposiÃ§Ã£o C.9, ğ‘ğ‘š â‰¡ 1 (mod ğ‘) ou ğ‘ğ‘š â‰¡ âˆ’1 (mod ğ‘). 

â‰¡

Pelo  Teorema  C.10,  se  ğ‘ âˆ¤ ğ‘,  ğ‘ â‰¢ 1 (mod ğ‘),  ğ‘ â‰¢ âˆ’1 (mod ğ‘)  e  ğ‘2 â‰¡

1 (mod ğ‘), entÃ£o ğ‘ Ã© composto.  

Agora, utilizando-se destes resultados, podemos testar a primalidade de 

um nÃºmero da seguinte forma.  

Passo 1. Seleciona-se um nÃºmero inteiro ğ‘› > 2 Ã­mpar e faz-se ğ‘› âˆ’ 1 = 2ğ‘›ğ‘š; 

 
 
63 

Passo 2. Seleciona-se  um  nÃºmero  inteiro ğ‘  qualquer, 1 < ğ‘ < ğ‘› âˆ’ 1,  e  calcula-se 

ğ‘ğ‘šmod ğ‘›. DaÃ­, haverÃ¡ dois casos possÃ­veis. 

 ğ‘ğ‘šmod ğ‘› = 1 âŸ¹ ğ‘ğ‘š â‰¡ 1 (mod ğ‘›)  ou  ğ‘ğ‘šmod ğ‘› = ğ‘› âˆ’ 1 âŸ¹ ğ‘ğ‘š â‰¡ (n âˆ’
Caso  1. 
1) (mod ğ‘›) âŸ¹ ğ‘ğ‘š â‰¡ âˆ’1 (mod ğ‘›).  Logo  ğ‘ğ‘š â‰¡ Â±1 (mod ğ‘›) âŸ¹ ğ‘2ğ‘›ğ‘š â‰¡ 1 (mod ğ‘›), 
entÃ£o ğ‘ğ‘›âˆ’1 â‰¡ 1(mod ğ‘›) e, portanto, ğ‘› serÃ¡ primo; 

Caso  2.  ğ‘ğ‘š mod ğ‘› â‰  1  e  ğ‘ğ‘š mod ğ‘› â‰  ğ‘› âˆ’ 1 âŸ¹ ğ‘ğ‘š â‰¢ 1 (mod ğ‘›)  e  ğ‘ğ‘š â‰¢ (ğ‘› âˆ’
1)(mod ğ‘›) âŸ¹ ğ‘ğ‘š â‰¢ âˆ’1 (mod ğ‘›) âŸ¹ ğ‘ğ‘š â‰¢ Â±1 (mod ğ‘›).  Fazemos,  entÃ£o,  ğ‘¥1 =
(ğ‘ğ‘šmod ğ‘›)2 mod ğ‘› e teremos as seguintes possibilidades. 

I.  Se ğ‘¥1 = ğ‘› âˆ’ 1, entÃ£o ğ‘› serÃ¡ primo 

II.  Se ğ‘¥1 = 1, entÃ£o ğ‘› serÃ¡ composto 

III.  Se nÃ£o I ou II nÃ£o for verdadeiro, faz-se ğ‘¥2 = ğ‘¥1

2mod ğ‘›, e verifica-se 

novamente se I ou II Ã© verdadeiro. 

Repete-se este processo atÃ© que ğ‘¥ğ‘– seja igual a ğ‘› âˆ’ 1 ou 1.  

O  teste  mostra-se  muito  eficiente  para  um  nÃºmero  determinado  de 

tentativas, conforme observa-se adiante. 

[...]  o  algoritmo  Miller-Rabin,  um  exemplo  de  teste  de  primalidade 
probabilÃ­stico. Dado ğ‘›, tomamos ğ‘¡ valores de ğ‘ ao acaso no intervalo 1 <
ğ‘ < ğ‘›  e  verificamos  para  cada  ğ‘  se  ğ‘›  passa  no  teste  de  primalidade  na 
base ğ‘. Se ğ‘› for Ã­mpar composto, a probabilidade de que um dado ğ‘ acuse 
a  nÃ£o-primalidade  de  ğ‘  Ã©  maior  do  que  3/4  (pelo  teorema);  assim,  a 
probabilidade de que ğ‘› escape a ğ‘¡ testes Ã© menor do que 4âˆ’ğ‘¡ (MOREIRA 
e SALDANHA, 2012, p. 3). 

Deste modo, para dado ğ‘›, apÃ³s testagem de 75% das bases menores 

que ğ‘›, haveria certeza sobre a primalidade de ğ‘›, contudo, para elevados valores de 

ğ‘›, o teste Ã© obviamente custoso. 

O teste apresentado neste tÃ³pico Ã© uma variaÃ§Ã£o probabilÃ­stica, devida a 

Rabin,  de  um 

teste  determinÃ­stico  proposto  por  Miller  que  dependia  da 

generalizaÃ§Ã£o da HipÃ³tese de Riemann. Uma forma de transformar o teste de Miller-

Rabin  em  determinÃ­stico  Ã©  testar  todos  os  valores  da  base  ğ‘  em  um  intervalo 

suficientemente grande. A referida generalizaÃ§Ã£o da HipÃ³tese citada implica que o 

 
 
64 

intervalo  de  1  atÃ©  2(ğ‘™ğ‘œğ‘” ğ‘›)2  Ã©  o  suficiente.  Apesar  deste  algoritmo  ser  rÃ¡pido, 

depende da comprovaÃ§Ã£o de uma conjectura (MARTINEZ, MOREIRA , et al., 2013).  

7.3 Teste AKS 

No ano de 2002, os pesquisadores indianos Manindra Agrawal, Neeraj 

Kayal e Nitin Saxena publicaram no trabalho intitulado PRIMES is in P um algoritmo 

determinÃ­stico que determina a primalidade de um nÃºmero em tempo polinomial, um 

relevante resultado da busca de um teste capaz de tal feito.  

O  teste  Ã©  de  fÃ¡cil  aplicaÃ§Ã£o  e  utiliza  como  base  a  generalizaÃ§Ã£o  do 

Pequeno Teorema de Fermat. O algoritmo fundamenta-se no seguinte lema: 

Lema 4. Dado ğ‘ inteiro, ğ‘› natural maior que 2 e ğ‘ e ğ‘› coprimos, entÃ£o 

(ğ‘¥ + ğ‘)ğ‘› â‰¡ ğ‘¥ğ‘› + ğ‘ (mod ğ‘›) âŸº ğ‘› Ã© primo   

Uma  vez  que  (ğ‘¥ + ğ‘)ğ‘›  e  ğ‘¥ğ‘› + ğ‘  deixarÃ£o  o  mesmo  resto  mÃ³dulo  ğ‘›  se 

divididos por qualquer polinÃ´mio, entÃ£o, em particular, se forem divididos por ğ‘¥ğ‘Ÿ âˆ’

1, teremos. 

(ğ‘¥ + ğ‘)ğ‘› â‰¡ ğ‘¥ğ‘› + ğ‘ (mod ğ‘¥ğ‘Ÿ âˆ’ 1, ğ‘›) âŸº ğ‘› Ã© primo   

Ambos  resultados  sÃ£o  demonstrados  no  artigo  PRIMES  is  in  P 

(AGRAWAL, 2006) e o Ãºltimo mostra que para verificar a primalidade de ğ‘›, basta 

testar a congruÃªncia para um determinado valor de ğ‘Ÿ, que no trabalho mencionado 

representa um nÃºmero primo no qual ğ‘Ÿ âˆ’ 1 possui um fator primo ğ‘ â‰¥ 4âˆšğ‘Ÿ log ğ‘›, que 

divide a ordem de ğ‘› mÃ³dulo ğ‘Ÿ.  

Com este Ãºltimo resultado, a aplicaÃ§Ã£o do teste consiste em selecionar 

um determinado nÃºmero ğ‘› a fim de testar sua primalidade e adotar um determinado 

valor primo para ğ‘ e ğ‘Ÿ. Em seguida, apÃ³s substituiÃ§Ã£o na congruÃªncia (ğ‘¥ + ğ‘)ğ‘› â‰¡

ğ‘¥ğ‘› + ğ‘ (mod ğ‘¥ğ‘Ÿ âˆ’ 1, ğ‘›),  analisar  se  os  restos  da  divisÃ£o  de  (ğ‘¥ + ğ‘)ğ‘›  e  ğ‘¥ğ‘› + ğ‘  por 

ğ‘¥ğ‘Ÿ âˆ’ 1 divididos por ğ‘› sÃ£o iguais.  

Os  autores  do  teste  puderam  avaliar  o  tempo  de  execuÃ§Ã£o  deste 

algoritmo em (log ğ‘›)12, o qual foi aprimorado e reduzido para (log ğ‘›)7,5. Por fim, no 

trabalho intitulado Primality testing with Gaussian periods, pode ser verificada uma 

 
 
65 

reduÃ§Ã£o  ainda  maior  da  complexidade  do  algoritmo  para  (log ğ‘›)6  (RIBENBOIM, 

2014). 

Face a imensa importÃ¢ncia da identificaÃ§Ã£o de primos cada vez maiores, 

este  teste  tornou-se  um  marco  na  busca  por  nÃºmeros  primÃ¡rios  gigantes, 

fortalecendo  ainda mais as  operaÃ§Ãµes  dependentes destes  algarismos,  conforme 

se vÃª nas palavras de Agrawal, Kayal e Saxena (2004). 

Os  nÃºmeros  primos  sÃ£o  de  fundamental  importÃ¢ncia  na  matemÃ¡tica  em 
geral,  e  na  Teoria  dos  NÃºmeros,  em  particular.  Por  isso,  Ã©  de  grande 
interesse  estudar  diferentes  propriedades  de  nÃºmeros  primos.  HÃ¡  um 
destaque  especial  para  aquelas  propriedades  que  permitem  determinar 
eficientemente se um nÃºmero Ã© primo. Tais testes eficientes tambÃ©m sÃ£o 
Ãºteis  na  prÃ¡tica:  uma  sÃ©rie  de  protocolos  criptogrÃ¡ficos  precisam  de 
grandes nÃºmeros primos (AGRAWAL, KAYAL e SAXENA, 2004, p.  781, 
traduÃ§Ã£o nossa). 

7.4 Outros mÃ©todos computacionais  

AlÃ©m da relevante descoberta do teste AKS, que rompeu com a barreira 

da  espera  de  um  algoritmo  determinÃ­stico  em  tempo  polinomial,  uma  sÃ©rie  de 

estudos avanÃ§ados foram desenvolvidos com o intuito de aprimorar os mÃ©todos de 

localizaÃ§Ã£o  de  grandes  primos.  Nesta  corrida,  muitos  outros  testes  foram 

apresentados, com resultados e alcances notÃ¡veis.  

O  Teste  de  Baillie  â€“  PSW,  desenvolvido  por  Robert  Baillie,  Carl 

Pomerance,  John  Selfridgee  e  Samuel  Wagstaff,  Ã©  um  mÃ©todo  que  consiste  na 

utilizaÃ§Ã£o de um conjunto de algoritmos probabilÃ­sticos. 

Conforme  Weisstein  (2021),  uma  das  formas  desse  algoritmo  Ã©  a 

aplicaÃ§Ã£o  de  um  teste  de  pseudoprimo  forte  de  base  2,  para  um  nÃºmero  ğ‘›.  Se 

 passar, aplica-se o teste de Lucas, com emprego do sÃ­mbolo de Jacobi. Se ğ‘› passar 

neste Ãºltimo, entÃ£o serÃ¡ considerado provavelmente primo.  

O teste possui algo grau de confiabilidade e atÃ© a data de fechamento 

deste  trabalho  ainda  nÃ£o  fora  apresentado  um  nÃºmero  composto  que  passe  no 

teste. Sobre esse fato, Weisstein (2021) afirma que nÃ£o hÃ¡ exemplos de nÃºmeros 

compostos que passem no teste e, em 13 de junho de 2009, Jeff Gilchrist confirmou 

que nÃ£o hÃ¡ pseudoprimos Baillie-PSW atÃ© 1017. 

 
 
66 

As linhas de pesquisas sobre testes de primalidade foram desviadas para 

campos  mais avanÃ§ados  da matemÃ¡tica,  com  uso de  conceitos mais complexos. 

Neste contexto, testes como APR, proposto por L. M. Adleman, C. Pomerance e R. 

S.  Rumely,  em  1983,  surgiram  como  novas  ferramentas  de  menor  custo  na 

identificaÃ§Ã£o de primos.  

O  teste  APR  utiliza  conceitos  avanÃ§ados  de  Teoria  dos  NÃºmeros, 

conforme se vÃª a seguir. 

O  teste  Ã©  rigorosamente  justificado  e,  para  isso,  foi  necessÃ¡rio,  pela 
primeira vez nesse domÃ­nio, apelar para resultados difÃ­ceis da teoria dos 
nÃºmeros  algÃ©bricos;  hÃ¡  necessidade  de  intervenÃ§Ã£o  de  cÃ¡lculos  com  as 
raÃ­zes da unidade e da lei de reciprocidade geral do sÃ­mbolo de restos de 
potÃªncias (RIBENBOIM, 2014, p. 111). 

Trata-se,  entÃ£o,  de  conteÃºdos  pouco  utilizados  em  cursos  bÃ¡sicos  de 

matemÃ¡tica,  Ãºteis,  no  entanto,  em  Ã¡reas  especÃ­ficas  de  estudo.  Ainda  conforme 

Ribenboim (2014), o teste possui larga vantagem em relaÃ§Ã£o a seus antecessores, 

como a possibilidade de aplicaÃ§Ã£o a nÃºmeros naturais quaisquer, sem necessidade 

de  determinar  fatores  primos  de  ğ‘› âˆ’ 1  ou  ğ‘› + 1,  para  um  dado  ğ‘›  testado.  Um 

exemplo de sua eficiÃªncia Ã© a testagem de um nÃºmero de 247 algarismos em 1987, 

por Cohen e A.K Lenstra, que levou apenas 15 minutos.  

Outro  tipo  de  abordagem  na  verificaÃ§Ã£o  de  primos,  Ã©  a  utilizaÃ§Ã£o  de 

curvas  elÃ­pticas27,  desenvolvido  em  1986  por  A.O.L.  Atkin  e  denominado  ECPP 

(Eliptic Curve Primality Proving). O teste Ã© realizado em tempo polinomial e  pode 

ser comprovado com rigor. Estima-se que seu custo computacional Ã© da ordem de 

ğ‘‚(log ğ‘›)5 (MORAIN, 2007).  

27 Curvas definidas por equaÃ§Ãµes cÃºbicas 

 
 
 
 
 
 
67 

8 APLICAÃ‡Ã•ES 

O que outrora aparentava ter um fim em si mesmo, atualmente o estudo 

dos nÃºmeros primos possui uma imensa importÃ¢ncia na forma de organizaÃ§Ã£o do 

mundo  moderno,  motivo  pelo  qual  os  testes  de  primalidade  ganharam  notÃ¡vel 

destaque ao longo dos Ãºltimos sÃ©culos.  

AlÃ©m  das  aplicaÃ§Ãµes  jÃ¡  elencadas  no  bojo  deste  trabalho,  salientamos 

uma  daquelas  que  podemos  considerar  de  maior  proveito  na  atualidade:  a 

criptografia.  Antes  de  adentramos  no  assunto,  vamos  discorrer  sobre  alguns 

conceitos relevantes no ramo desta ciÃªncia, a comeÃ§ar pelo conceito de criptografia 

que, conforme (COUTINHO, 2005), Ã© descrita como. 

Em  grego,  cryptos  significa  secreto,  oculto.  A  criptografia  estuda  os 
mÃ©todos  para  codificar  uma  mensagem  de  modo  que  sÃ³  o  destinatÃ¡rio 
legÃ­timo consiga interpretÃ¡-la. Ã‰ a arte dos â€˜cÃ³digos secretosâ€™, que todos jÃ¡ 
praticamos quando crianÃ§a. O mais simples destes cÃ³digos consiste em 
substituir  uma  letra  pela  seguinte;  isto  Ã©  transladar  o  alfabeto  uma  casa 
para adiante. Um cÃ³digo semelhante foi usado por CÃ©sar para comunicar-
se com as legiÃµes em combate pela Europa (COUTINHO, 2005, p. 1). 

A conceituaÃ§Ã£o e detalhamento supra nos serve de confirmaÃ§Ã£o para a 

mais  basilar  importÃ¢ncia  das  comunicaÃ§Ãµes  secretas:  a  confidencialidade.  Em 

diversos  tipos  de  eventos,  a  troca  de  mensagens  necessita  de  seguranÃ§a  na 

transmissÃ£o de seu conteÃºdo, logo, desde tempos remotos, o transmissor e receptor 

buscam meios de proteger a troca de informaÃ§Ãµes.  

Ao  se  debater  sobre  a  seguranÃ§a  das  informaÃ§Ãµes,  logo  se  suscita  o 

mÃ©todo  de  codificaÃ§Ã£o  de  mensagens,  atravÃ©s  do  qual  o  conteÃºdo  destas  Ã© 

cuidadosamente dissimulado por um conjunto de caracteres ou sÃ­mbolos e, assim, 

modificado em sua aparÃªncia, mas mantido em seu conteÃºdo.  

Um  dos  mÃ©todos  mais  antigos  de  codificaÃ§Ã£o  de  mensagens  Ã©  a 

substituiÃ§Ã£o de cada caractere por outro, o qual pode ser entendido pelo interlocutor 

que saiba quais critÃ©rios na escolha do conjunto de sÃ­mbolos foram utilizados pelo 

comunicante.  Para  exemplificar:  se  alguÃ©m  codifica  uma  mensagem  escolhendo 

como novo caractere de cada letra o correspondente da ordem inversa do alfabeto, 

entÃ£o,  se  a  mensagem  original  for  PRIMOS,  pela  tabela  seguinte,  a  palavra 

codificada serÃ¡ KIRNLH. 

 
 
68 

Tabela 5 â€“ CÃ³digos de ordem invertida do alfabeto 
ORDEM  CARACTERE ORIGINAL  CARACTERE SUBSTITUTO 

1Â° 
2Â° 
3Â° 
4Â° 
5Â° 
6Â° 
7Â° 
8Â° 
9Â° 
10Â° 
11Â° 
12Â° 
13Â° 
14Â° 
15Â° 
16Â° 
17Â° 
18Â° 
19Â° 
20Â° 
21Â° 
22Â° 
23Â° 
24Â° 
25Â° 
26Â° 

a 
b 
c 
d 
e 
f 
g 
h 
i 
j 
k 
l 
m 
n 
o 
p 
q 
r 
s 
t 
u 
v 
x 
y 
w 
z 

z 
w 
y 
x 
v 
u 
t 
s 
r 
q 
p 
o 
n 
m 
l 
k 
j 
i 
h 
g 
f 
e 
d 
c 
b 
a 

Fonte: Elaborado pelo autor 

Esse  mÃ©todo  de  substituiÃ§Ã£o  de  caracteres  por  sÃ­mbolos  previamente 

estabelecidos possui algumas fraquezas, como o fato de cada idioma possuir certa 

regularidade  na  formaÃ§Ã£o  de  suas  palavras.  Para  exemplificar, citamos o  fato  de 

que a probabilidade de uso de uma vogal em determinada palavra Ã© maior que o 

uso de uma consoante, jÃ¡ que estas sÃ£o em nÃºmero maior que aquelas. HÃ¡ tambÃ©m 

o fato de que letras como ğ‘š e ğ‘ sÃ£o bem mais frequentes em palavras da lÃ­ngua 

portuguesa do que letras como ğ‘§ e ğ‘¦. Estes e outros fatos correlacionados geram 

 
 
 
 
69 

critÃ©rios de formaÃ§Ã£o de palavras que revelam dicas de decodificaÃ§Ã£o, facilitando a 

descoberta do conteÃºdo da mensagem.  

Ã‰  importante,  tambÃ©m,  definir  o  significado  dos  termos  codificar  e 

decodificar,  que  significam,  respectivamente,  um  conjunto  de  aÃ§Ãµes  necessÃ¡rias 

para  encobrir  e  descobrir  uma  mensagem,  ambas  realizadas  por  usuÃ¡rios 

autorizados. Neste mesmo sentido, vem Ã  tona o termo decifrar, que significa a aÃ§Ã£o 

de desvendar o cÃ³digo a fim de interpretar a mensagem.  

InÃºmeros  cÃ³digos  foram  utilizados  ao  longo  dos  anos,  alguns  de  alta 

complexidade,  entretanto,  com  ferramentas  adequadas,  capazes  de  serem 

quebrados  e  terem  suas  mensagens  reveladas.  Um  famoso  exemplo  Ã©  o  cÃ³digo 

utilizado  pelas  forÃ§as  alemÃ£es  na  segunda  Guerra  Mundial,  com  o  auxÃ­lio  da 

mÃ¡quina denominada enigma, a mais avanÃ§ada da Ã©poca, conforme mencionado 

por Sautoy (2007, p. 241): â€œo mais avanÃ§ado mÃ©todo mecÃ¢nico de codificaÃ§Ã£o era 

a mÃ¡quina Enigmaâ€. 

Tal ferramenta era tÃ£o avanÃ§ada para a Ã©poca que a faÃ§anha de quebrar 

seu cÃ³digo foi realizada por instrumentos que executavam aÃ§Ãµes que transcendiam 

a capacidade mental. Era a Ã©poca da exploraÃ§Ã£o da computaÃ§Ã£o e nascia uma das 

mais importantes cooperaÃ§Ãµes da histÃ³ria: o conhecimento humano e a capacidade 

de processamento de computadores.  

A  partir  da  criaÃ§Ã£o  e  rÃ¡pido  desenvolvimento  dos  computadores 

eletrÃ´nicos,  cÃ³digos  antes  inacessÃ­veis  Ã   compreensÃ£o  humana,  tornaram-se 

obsoletos ao poder computacional destas mÃ¡quinas. Desta forma, era necessÃ¡rio a 

adoÃ§Ã£o  de  novos  mÃ©todos  de  codificaÃ§Ã£o  de  mensagens,  capazes  de  reduzir  ao 

mÃ¡ximo a possibilidade de sua quebra, atÃ© mesmo pelos computadores. 

Foi nesse cenÃ¡rio, aliado Ã  ampliaÃ§Ã£o do mercado financeiro realizado 

por intermÃ©dio da rede mundial de computadores, que surgiram ideias de proteÃ§Ã£o 

de  mensagens  e  de  seguranÃ§a  das  transaÃ§Ãµes  comerciais  por  meios  digitais. 

Destacamos, aqui, os modernos cÃ³digos de chave pÃºblica, detalhados da seguinte 

forma: 

 
 
70 

Esta  Ã©  uma  ideia  introduzida  em  1976  por  W  Diffie  e  M.E.  Hellman  da 
Universidade  da  CalifÃ³rnia.  No  cÃ³digo  usado  por  CÃ©sar,  se  vocÃª  sabe 
codificar, entÃ£o sabe  decodificar.  Em  um cÃ³digo de  chave pÃºblica saber 
codificar  nÃ£o  implica  saber  decodificar!  Isto  parece  impossÃ­vel:  se  sei 
codificar,  para  decodificar  basta  desfazer  o  que  fiz.  [...]  â€˜desfazerâ€™  o 
processo  de  codificaÃ§Ã£o  pode  nÃ£o  ser  tÃ£o  simples  quanto  parece 
(COUTINHO, 2005, p. 3). 

Criptografia de Chave PÃºblica pode ser definida, entÃ£o, como sendo um 

sistema criptogrÃ¡fico que usa uma chave pÃºblica e uma chave privada, das quais, 

a primeira Ã© de conhecimento amplo e a segunda de domÃ­nio apenas do usuÃ¡rio.  

Nasce, portanto, o RSA, assim denominado por conta de seus criadores, 

os pesquisadores R. L. Rivest, A. Shamir e L, Adleman, que em 1978 criaram este 

mÃ©todo de criptografia de chave pÃºblica que se tornaria um dos mais importantes 

das Ãºltimas dÃ©cadas. 

O mÃ©todo RSA baseia em conhecimentos sobre primos, pois para sua 

implementaÃ§Ã£o  sÃ£o  necessÃ¡rios  dois  destes  nÃºmeros.  Vejamos  o  processo  no 

diagrama a seguir, para ğ´ e ğµ primos. 

Quadro 1: Processo de codificaÃ§Ã£o e decodificaÃ§Ã£o de mensagem no mÃ©todo RSA 

Fonte: Elaborado pelo autor 

Podemos  verificar  que  uma  determinada  mensagem,  na  criptografia 

RSA,  Ã©  encriptada  pela  chave  pÃºblica  ğ‘,  logo  de  fÃ¡cil  acesso,  contudo,  para  ser 

decodificada,  sÃ£o  necessÃ¡rias  as  chaves  privadas,  representadas  pelos  fatores 

primos ğ´ e ğµ de ğ‘. Fatorar ğ‘, quando este Ã© grande, Ã© uma tarefa excessivamente 

difÃ­cil pelos mÃ©todos conhecidos atualmente, senÃ£o vejamos:  

          *                                                                                                 ğ´ ğµ ğ‘=ğ´Ã—ğµ ğ´ ğµ CHAVE PÃšBLICA ğ‘ CHAVES PRIVADAS ğ´ E ğµ  
 
 
71 

Decifrar o RSA Ã© teoricamente muito simples: o obstÃ¡culo Ã© de natureza 
tecnolÃ³gica. Usando como chaves de codificaÃ§Ã£o do RSA nÃºmeros muito 
grandes (de 150 algarismos ou mais), fatorar ğ‘›, para achar ğ‘ e ğ‘, com os 
mÃ©todos  atuais  levaria  alguns  milhares  de  anos.  Ã‰  disto  que  depende  a 
seguranÃ§a do RSA; da ineficiÃªncia dos mÃ©todos de fatoraÃ§Ã£o atualmente 
conhecidos (COUTINHO, 2005, p. 4).  

EntÃ£o,  para  a  seguranÃ§a  do  RSA,  ğ‘›  deve  ser  bem  grande  e 

consequentemente ğ‘ e ğ‘ tambÃ©m serÃ£o. Neste processo, os fatores primos de ğ‘› 

tambÃ©m serÃ£o de difÃ­cil verificaÃ§Ã£o, conforme estudado no decurso deste trabalho. 

Extrai-se daqui a elevada importÃ¢ncia dos testes de primalidade, fundamentais na 

localizaÃ§Ã£o de primos cada vez maiores e sua utilizaÃ§Ã£o em mÃ©todos como o RSA.  

 
 
 
 
 
72 

9 CONCLUSÃƒO 

ApÃ³s a anÃ¡lise dos testes de primalidade e consumadas as discussÃµes 

apresentadas no transcurso deste trabalho, pode-se inferir importantes resultados 

alcanÃ§ados  apÃ³s  aplicaÃ§Ã£o  dos  mÃ©todos  prÃ©-selecionados  e  abordagens  das 

referÃªncias empregadas. 

Um relevante aspecto acerca dos primos Ã© a possibilidade de encontrar 

alguns  destes  por  meio  de  fÃ³rmulas.  Neste  sentido,  apresentamos  a  fÃ³rmula 

proposta  por  Pierre  de  Fermat,  todavia  esta  se  mostrou  verdadeira  apenas  para 

alguns valores testados. Outra forma de gerar primos mostrada nesse trabalho foi 

a  proposta apresentada  pelo estudioso  Mersenne, na  forma  2ğ‘š âˆ’ 1,  em que ğ‘š  Ã© 

primo,  a  qual  Ã©  capaz  de  gerar  primos  para  diversos  valores  de  ğ‘š.  Os  maiores 

primos conhecidos sÃ£o do tipo idealizado por Mersenne.  

Com  o  mesmo  objetivo,  porÃ©m  com  uma  diferente  abordagem, 

apresentamos a funÃ§Ã£o ğœ‹ de Gauss, desenvolvida durante vÃ¡rios anos atÃ© que se 

demonstrasse o Teorema dos NÃºmeros Primos, que provou que ğœ‹(ğ‘¥) tende a se 

aproximar de ğ‘¥/ ğ‘™ğ‘› ğ‘¥ Ã  medida que o valor de ğ‘¥ aumenta. AlÃ©m desta, outra funÃ§Ã£o 

de importÃ¢ncia na atualidade, Ã© a FunÃ§Ã£o Zeta de Riemann, desenvolvida a partir 

da  FunÃ§Ã£o  Zeta  de  Euler,  que  mostramos  resultar  em  uma  notÃ¡vel  conjectura 

nomeada HipÃ³tese de Riemann. Apesar de ainda nÃ£o provada, os resultados desta 

estruturam relevantes testes de primalidade apresentados nos Ãºltimos anos.  

Os resultados que exibimos sobre os nÃºmeros primos serviram de base 

para  a  elaboraÃ§Ã£o  daquelas  que  podemos  considerar as  principais  de  formas  de 

localizÃ¡-los,  os  testes  de  primalidade.  Estes  algoritmos  utilizam  como  base  fatos 

resultantes de teoremas e propostas de estrutura de primos, para entÃ£o identificÃ¡-

los apÃ³s a realizaÃ§Ã£o de uma sÃ©rie de etapas prÃ©-definidas. 

Tratamos  do  estudo  dos  mÃ©todos  de  localizaÃ§Ã£o  dos  primos  de  forma 

cronolÃ³gica,  abordando  sua  forma  mais  elementar  atÃ©  as  mais  sofisticadas, 

dividindo-os  em  dois  grandes  grupos:  os  testes  prÃ©-computacionais  e  os 

computacionais. Nessa linha, saÃ­mos das formas mais simplÃ³rias de buscar primos, 

 
 
73 

como  as  divisÃµes  sucessivas,  atÃ©  os  testes  mais  complexos,  como  o  APR, 

demonstrando como se deu esse processo de evoluÃ§Ã£o. 

Observou-se  que  as  etapas  histÃ³ricas  de  evoluÃ§Ã£o  dos  testes  de 

primalidade foram alicerÃ§adas em diversos fatores, dos quais um mereceu grande 

destaque:  o  progresso  da  tecnologia.  Apresentamos  a  evoluÃ§Ã£o  das  mÃ¡quinas  e 

sua conexÃ£o com os testes de primalidade. A nÃ­vel de exemplificaÃ§Ã£o, destacamos 

a  calculadora  mecÃ¢nica  de  Leibniz  e  a  mÃ¡quina  analÃ­tica  de  Babbage,  que 

evoluÃ­ram  atÃ©  culminarem  nos  computadores  modernos,  cujas  ideias  iniciais  se 

fundamentaram nos trabalhos de Turing.  

No  campo  computacional,  os  importantes  aspectos  que  detalhamos 

sobre  os  testes  foram  o  custo  de  um  algoritmo,  com  destaque  para  o  tempo 

polinomial  e  o  tempo  exponencial,  alÃ©m  de  abordÃ¡-los  mediante  sua  divisÃ£o  em 

testes determinÃ­sticos e nÃ£o determinÃ­sticos 

Os  testes  discorridos  nesse  estudo  foram  iniciados  pelos  clÃ¡ssicos, 

incluÃ­dos  na  era  prÃ©-computacional.  O  primeiro  foi  o  de  DivisÃ£o  por  Tentativa, 

seguido  pelo  Crivo  de  EratÃ³stenes,  o  Teste  de  Fermat,  o  teste  probabilÃ­stico  de 

Proth, o Teste de Pepin, o Teste de Lucas-Lehmer (utilizado frequentemente para 

testar nÃºmeros de Mersenne Mp) e o crivo de Sundaram. 

Em  cumprimento  ao  acompanhamento  do  processo  de  evoluÃ§Ã£o  dos 

testes  de  primalidade,  analisamos  tambÃ©m  os  testes  da  era  computacional, 

iniciando  pelo  estudo  do  algoritmo  de  Solovay-Strassen  e  seguindo  pelo  teste 

probabilÃ­stico de Miller-Rabin, acompanhado pela apresentaÃ§Ã£o do inovador teste 

AKS, de Manindra Agrawal, Neeraj Kayal e Nitin Saxena, divulgado em 2006.  

Um pensamento diferente que relacionamos Ã  procura de primos Ã© o uso 

de  mais  de  um  teste  de  primalidade  para  um  mesmo  nÃºmero.  Ã‰  a  forma  de 

abordagem do Teste de Baillie-PSW. Outros testes que mostramos consistem em 

temas matemÃ¡ticos avanÃ§ados, como o APR. Por fim, tambÃ©m foi abordado o teste 

de algoritmo ECPP (Eliptic Curve Primality Proving), com uso de equaÃ§Ãµes cÃºbicas. 

 
 
74 

Apresentamos  um  mÃ©todo  criptogrÃ¡fico  que  revolucionou  as  relaÃ§Ãµes 

financeiras do mundo contemporÃ¢neo: a criptografia RSA. Esta ferramenta surgiu a 

partir de importantes fatos sobre os primos, como o da sua difÃ­cil localizaÃ§Ã£o para 

valores  elevados e  consequente  dificuldade de  fatoraÃ§Ã£o  de  grandes  nÃºmeros, o 

que torna os processos financeiros mais seguros. 

Os  testes  apresentados  e  discorridos  neste  estudo  mostraram  a  linha 

evolutiva dos conhecimentos acerca dos primos e os importantes passos dados ao 

longo dos anos para um conhecimento mais aprofundado destes nÃºmeros. Pode-

se verificar as diversas formas de abordagem para se localizar primos, dentre as 

quais destacamos: a forÃ§a bruta de divisÃµes sucessivas; o uso de crivos (tabelas de 

nÃºmeros com exclusÃ£o de algarismos compostos) para filtrar conjuntos de nÃºmeros 

naturais e localizar primos; a utilizaÃ§Ã£o de teoremas sobre propriedades dos primos 

e, por fim, a utilizaÃ§Ã£o de conceitos avanÃ§ados em matemÃ¡tica. 

Com  resultados  amplos  ou  restritos,  seguros  ou  provÃ¡veis,  rÃ¡pidos  ou 

demorados, os testes aqui apresentados tiveram como fundamentos descobertas 

sobre  os  primos  reveladas  ao  longo  dos  anos  e  processos  engenhosos  de 

localizaÃ§Ã£o destes nÃºmeros, o que nos leva a garantir que essa busca por formas 

cada vez mais rÃ¡pidas e confiÃ¡veis permanecerÃ¡ por anos a frente, tornando este 

trabalho  um  alicerce  para  pesquisa  futuras,  apoiadas  nas  descobertas  a  serem 

reveladas.  

 
 
 
 
 
 
 
 
 
 
REFERÃŠNCIAS 

75 

AGRAWAL, M. Primality tests based on Fermatâ€™s little theorem. In: CHAUDHURI , 
S., et al. Distributed computing and networking: 8th International Conference, 
ICDCN 2006, Guwahati, India, December 27-30, 2006, proceedings. [S.l.]: 
Springer Science & Business Media, v. 4308, 2006. ISBN 978-3-540-68139-7. 

AGRAWAL, M.; KAYAL, N.; SAXENA, N. PRIMES is in P. Annals of 
Mathematics, v. 160, p. 781-793, Setembro 2004. Disponivel em: 
<https://annals.math.princeton.edu/wp-content/uploads/annals-v160-n2-p12.pdf>. 
Acesso em: 05 Junho 2021. 

ÃVILA, G. A sÃ©rie harmÃ´nica e a fÃ³rmula de Euler-Maclaurin. MatemÃ¡tica 
UniversitÃ¡ria, Rio de Janeiro, n. 19, p. 55-63, Dezembro 1995. Disponivel em: 
<https://rmu.sbm.org.br/wp-content/uploads/sites/27/2018/03/n19_Artigo05.pdf>. 
Acesso em: 05 Janeiro 2021. 

BOYER, C.. HistÃ³ria da MatemÃ¡tica. TraduÃ§Ã£o de Elza F. Gomide. SÃ£o Paulo: 
Edgard Blucher, Ed. da Universidade de SÃ£o Paulo, 1974. 

BROOKSHEAR, J. G. CiÃªncia da ComputaÃ§Ã£o [recurso eletrÃ´nico]: uma visÃ£o 
abrangente. TraduÃ§Ã£o de Cheng Mei Lee. 7. ed. Porto Alegre: Bookman, 2008. 
ISBN 978-85-7780-314-9. Dados EletrÃ´nicos. 

CALDWELL, C. K. Probable Prime. The Prime Pages, 2021. Disponivel em: 
<https://primes.utm.edu/glossary/xpage/PRP.html>. Acesso em: 2 maio 2021. 

CALDWELL, C. K. The Largest Known prime by Year: A Brief History. The Prime 
Pages, 2021. Disponivel em: <https://primes.utm.edu/notes/by_year.html>. Acesso 
em: 19 Janeiro 2021. 

COLQUITT, W. N.; WELSH JR, L. A NEW MERSENNE PRIME. Mathematics of 
Computation, 56, n. 194, Abril 1991. 867-870. Disponivel em: 
<https://www.ams.org/journals/mcom/1991-56-194/S0025-5718-1991-1068823-
9/S0025-5718-1991-1068823-9.pdf>. Acesso em: 15 Maio 2021. 

CORMEM, T. H. et al. Algoritmos: teoria e prÃ¡tica. TraduÃ§Ã£o de Vanderberg D. 
de Souza. Rio de Janeiro: Elsevier, 2002. ISBN 85-352-0926-3. 

COSTA, R. George Boole. Brasil Escola, 2007. Disponivel em: 
<https://brasilescola.uol.com.br/biografia/george-boole.htm>. Acesso em: 06 abril 
2021. 

COUTINHO, S. C. Primalidade em Tempo Polinomial: uma introduÃ§Ã£o ao 
algoritmo AKS. Rio de Janeiro: [s.n.], 2004. Disponivel em: 
<https://dcc.ufrj.br/~collier/Books/AKS1.pdf>. Acesso em: 10 Fevereiro 2021. 

 
 
 
 
 
 
 
 
 
 
 
 
 
76 

COUTINHO, S. C. NÃ¹meros Inteiros e Criptografia RSA. 2Âª. ed. RIo de Janeiro: 
IMPA, 2005. ISBN 85-244-0124-9. 

Dâ€™AMBROSIO, U. EULER, UM MATEMÃTICO MULTIFACETADO. Revista 
Brasileira de HistÃ³ria da MatemÃ¡tica, [S. l.], Vol. 9, n. 17, p. 13-31, 2020. 
Disponivel em: <https://www.rbhm.org.br/index.php/RBHM/article/view/167. >. 
Acesso em: 09 Janeiro 2021. 

DELUMEAU, J. A CivilizaÃ§Ã£o do Renascimento. 4. ed. Lisboa: Editorial 
Estampa, v. I, 1994. ISBN 972-33-1000-7. 

FEOFILOFF,. Minicurso de AnÃ¡lise de Algoritmos. SÃ£o Paulo: [s.n.], 2019. 
Disponivel em: <https://www.ime.usp.br/~pf/livrinho-AA/>. Acesso em: 05 Abril 
2021. 

FEOFILOFF,. ComparaÃ§Ã£o assintÃ³tica de funÃ§Ãµes. IME, 2021. Disponivel em: 
<https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/Oh.html>. Acesso em: 
05 abril 2021. 

FONSECA, J. J. S. D. Metodologia da Pesquisa CientÃ­fica. Fortaleza: UEC, 
2002. Apostila. 

GEEKSFORGEEKS. Primality Test | Set 4 (Solovay-Strassen). GeeksforGeeks, 
19 Maio 2021. Disponivel em: <https://www.geeksforgeeks.org/primality-test-set-4-
solovay-strassen/>. Acesso em: 01 Junho 2021. 

GILBREATH, J. A High-Level Language Benchmark. BYTE Magazine Volume 06 
Number 09 - Artificial Intelligence, v. 6, Setembro 1981. Disponivel em: 
<https://archive.org/details/byte-magazine-1981-
09/page/n181/mode/2up?q=criteria+were>. Acesso em: 02 Abril 2021. 

HEFEZ, A. Elementos de AritmÃ©tica. Rio de Janeiro: SBM, 2005. ISBN 85-
85818-25-5. 

HEFEZ, A. AritmÃ©tica. 1. ed. Rio de Janeiro: SBM, 2014. ISBN 978-85-85818-92-
0. (ColeÃ§Ã£o PROFMAT;08). 

HONSBERGER , ROSS. Sundaram's Sieve. Ingenuity in Mathematics, New 
York, v. 23, 1970. ISSN 0394709233. Disponivel em: 
<https://archive.org/details/ingenuityinmathe0000hons/page/76/mode/2up>. 
Acesso em: 15 maio 2021. 

IMPA. Instituto de MatemÃ¡tica Pura e Aplicada, 15 Janeiro 2019. Disponivel em: 
<https://impa.br/noticias/descoberto-numero-primo-com-quase-25-milhoes-de-
digitos/>. Acesso em: 02 Janeiro 2021. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
77 

JÃšNIOR, J. G. D. S.; NETO, L. P. V. PrograÃ§Ã£o Concorrente e Paralela: 
algoritmo paralelo para o Crivo de EratÃ³stenes. [S.l.]: [s.n.], 2009. Disponivel em: 
<http://www.inf.puc-rio.br/~noemi/pcp-13/primos.pdf>. Acesso em: 09 abril 2021. 

LIMA, E. L. NÃºmeros e FunÃ§Ãµes Reais. 1Âª. ed. RIo de Janeiro: SBM, 2013. ISBN 
978-85-85818-81-4. 

MACHADO, F. B.; MAIA, L. P. Arquitetura de sistemas operacionais. 5. ed. Rio 
de Janeiro: LTC, 2014. ISBN 978-85-216-2287-1. 

MARTINEZ, F. E. B. et al. Teoria dos NÃºmeros: um passeio com primos e outros 
nÃºmeros familiares pelo mundo inteiro. [S.l.]: [s.n.], 2013. Disponivel em: 
<https://edisciplinas.usp.br/pluginfile.php/4576649/mod_resource/content/1/Um%2
0passeio%20pelos%20primos%20e%20outros%20n%C3%BAmeros%20familiares
.pdf>. Acesso em: 02 Maio 2021. 

MORAIN, F. Implementing the Asymptotically Fast Version of the Elliptic Curve 
Primality Proving Algorithm. Mathematics of Computation, Providence - Rhode 
Island - USA, v. v. 76, n. 257, p. 493-505, Janeiro 2007. Disponivel em: 
<https://www.ams.org/journals/mcom/2007-76-257/S0025-5718-06-01890-
4/S0025-5718-06-01890-4.pdf>. Acesso em: 15 Junho 2021. 

MOREIRA, C. G. T. D. A.; SALDANHA, N. C. CritÃ©rios de Primalidade, Rio de 
Janeiro, 19 Junho 2012. Disponivel em: <http://klein.sbm.org.br/wp-
content/uploads/sites/17/2016/02/criterios-de-primalidade.pdf>. Acesso em: 02 
Junho 2021. 

MOREIRA, C. G.; MARTINÃ‰Z, F. E. B. Primos gÃªmeos, primos de Sophie Germain 
e o Teorema de Brun. MatemÃ¡tica UniversitÃ¡ria, Rio de Janeiro, n. 48/49, p. 93-
101, Junho/Dezembro 2010. Disponivel em: <https://rmu.sbm.org.br/wp-
content/uploads/sites/27/2018/03/n48_n49_Artigo06.pdf>. Acesso em: 06 Janeiro 
2021. 

O'CONNOR, J.; ROBERTSON, E. FranÃ§ois Ã‰douard Anatole Lucas. MacTutor 
History of Mathematics Archive, Dezembro 1996. Disponivel em: 
<https://mathshistory.st-andrews.ac.uk/Biographies/Lucas/>. Acesso em: 18 
Janeiro 2021. 

O'CONNOR, J.; ROBERTSON, E. Georg Friedrich Bernhard Riemann. MacTutor 
History of Mathematics Archive, Setembro 1998. Disponivel em: 
<https://mathshistory.st-andrews.ac.uk/Biographies/Riemann/>. Acesso em: 15 
Janeiro 2021. 

O'CONNOR, J.; ROBERTSON, E. Eratosthenes of Cyrene. MacTutor History of 
Mathematics Archive, Janeiro 1999. Disponivel em: <https://mathshistory.st-
andrews.ac.uk/Biographies/Eratosthenes/>. Acesso em: 16 Janeiro 2021. 

 
 
 
 
 
 
 
 
 
 
 
78 

O'CONNOR, J.; ROBERTSON, E. Charles Jean Gustave Nicolas Baron de la 
VallÃ©e Poussin. MacTutor History of Mathematics Archive, MarÃ§o 2001. 
Disponivel em: <https://mathshistory.st-
andrews.ac.uk/Biographies/Vallee_Poussin/>. Acesso em: 16 Janeiro 2021. 

O'CONNOR, J.; ROBERTSON, E. Derrick Henry Lehmer. MacTutor History of 
Mathematics Archive, Novembro 2002. Disponivel em: <https://mathshistory.st-
andrews.ac.uk/Biographies/Lehmer_Derrick/>. Acesso em: 18 Janeiro 2021. 

O'CONNOR, J.; ROBERTSON, E. Jacques Salomon Hadamard. MacTutor 
History of Mathematics Archive, Outubro 2003. Disponivel em: 
<https://mathshistory.st-andrews.ac.uk/Biographies/Hadamard/>. Acesso em: 2015 
Janeiro 2021. 

O'CONNOR, J.; ROBERTSON, E. Robert Daniel Carmichael. MacTutor History 
of Mathematics Archive, Fevereiro 2010. Disponivel em: <https://mathshistory.st-
andrews.ac.uk/Biographies/Carmichael/>. Acesso em: 30 Abril 2021. 

RIBENBOIM, P. NÃºmeros Primos: velhos mistÃ©rios e novos recordes. 1. ed. Rio 
de Janeiro: IMPA, 2014. ISBN 978-85-244-0334-7. (ColeÃ§Ã£o MatemÃ¡tica 
UniversitÃ¡ria). 

SANTOS, J. P. D. O. IntroduÃ§Ã£o Ã  Teoria dos NÃºmeros. 3. ed. Rio de Janeiro: 
IMPA, 2015. ISBN 978-85-244-0142-8. 

SAUTOY, M. D. A MÃºsica dos NÃºmeros Primos: a histÃ³ria de um problema nÃ£o 
resolvido na matemÃ¡tica. TraduÃ§Ã£o de Diego Alfaro. Rio de Janeiro: Zahar, 2007. 
ISBN 978-85-378-007-9. 

SPENTHOF, R.; SOUZA, J. D. Primos: da aleatoriedade ao padrÃ£o. Revista 
eletrÃ´nica da Sociedade Brasileira de MatemÃ¡tica, v.1, n.1. Rio de Janeiro, 
2013. 12-31. Disponivel em: <http://pmo.sbm.org.br/wp-
content/uploads/sites/16/dlm_uploads/2019/03/art2_vol1_2013_SBM_PMO-1.pdf>. 
Acesso em: 27 Dezembro 2020. 

STEWART, I. Em Busca do Infinito: uma histÃ³ria da matemÃ¡tica dos primeiros 
nÃºmeros Ã  teoria do caos. TraduÃ§Ã£o de George Schlesinger. EdiÃ§Ã£o digital: 
fevereiro 2014. ed. Rio de Janeiro: Zahar, 2014. ISBN 978-85-378-1193-1. 
Disponivel em: <https://lelivros.love/book/baixar-livro-em-busca-do-infinito-ian-
stewart-em-pdf-epub-e-mobi-ou-ler-online/>. Acesso em: 22 Dezembro 2020. 

STROHMAIER, E. et al. TOP500, 2020. Disponivel em: 
<https://top500.org/lists/top500/2020/11/>. Acesso em: 30 marÃ§o 2021. 

 
 
 
 
 
 
 
 
 
 
 
 
 
79 

WAZLAWICK, R. S. HIstÃ³ria da ComputaÃ§Ã£o. 1. ed. Rio de Janeiro: Elsevier, 
2017. ISBN 978-85-352-8545-1. 

WEISSTEIN, E. W. Monte Carlo Method. MathWorld--A Wolfram Web Resource, 
18 Maio 2021. Disponivel em: 
<https://mathworld.wolfram.com/MonteCarloMethod.html>. Acesso em: 30 maio 
2021. 

WEISSTEIN, W. Baillie-PSW Primality Test. MathWorld, 23 Julho 2021. 
Disponivel em: <https://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html>. 
Acesso em: 25 Julho 2021. 

ZIVIANI, N. Projeto de algoritmos: com implementaÃ§Ãµes em Java e C++. 1. ed. 
SÃ£o Paulo: Cengage Learning, 2011. ISBN 978-85-221-0821-3. 

 
 
 
 
 
 
 
 
 
80 

APÃŠNDICE A â€“ MÃXIMO DIVISOR COMUM E DEMONSTRAÃ‡Ã•ES 

A.1 MÃ¡ximo Divisor Comum. Dados a e b inteiros, com ğ‘ â‰  0 ğ‘œğ‘¢ ğ‘ â‰  0, define-se 

como mÃ¡ximo divisor comum entre ğ‘ e ğ‘, representado por (ğ‘, ğ‘), o nÃºmero inteiro 

ğ‘‘, tal que ğ‘‘ Ã© o maior inteiro que divide ğ‘ e ğ‘.  

A.2 Teorema. Se ğ‘‘ = (ğ‘, ğ‘), entÃ£o existem ğ‘š, ğ‘› âˆˆ â„¤, tais que ğ‘‘ = ğ‘šğ‘ + ğ‘›ğ‘. 

DemonstraÃ§Ã£o. Dados ğ‘ e ğ‘ inteiros e a combinaÃ§Ã£o linear ğ‘šğ‘ + ğ‘›ğ‘, com ğ‘š, ğ‘› âˆˆ â„¤. 

Seja,  agora,  ğ‘¡ = ğ‘šâ€²ğ‘ + ğ‘›â€²ğ‘  tal  que  ğ‘¡  Ã©  o  menor  inteiro  positivo  resultante  dessa 

combinaÃ§Ã£o  linear.  Devemos  provar  que  ğ‘¡  divide  ğ‘  e  ğ‘¡  divide  ğ‘.  Supondo,  por 

absurdo,  que  ğ‘¡ âˆ¤ ğ‘,  entÃ£o,  pela  divisÃ£o  euclidiana,  podemos  escrever  ğ‘ = ğ‘ğ‘¡ + ğ‘Ÿ, 

como  0 < ğ‘Ÿ < ğ‘¡.  Dessa  maneira,  ğ‘Ÿ = ğ‘ âˆ’ ğ‘ğ‘¡ = ğ‘ âˆ’ ğ‘(ğ‘šâ€²ğ‘ + ğ‘›â€²ğ‘) = ğ‘ âˆ’ ğ‘ğ‘šâ€²ğ‘ âˆ’

ğ‘ğ‘›â€²ğ‘ = ğ‘(1 âˆ’ ğ‘ğ‘šâ€²) + ğ‘(âˆ’ğ‘ğ‘›â€²). DaÃ­, conclui-se que ğ‘Ÿ Ã© uma combinaÃ§Ã£o linear de ğ‘ 

e ğ‘, pois 1 âˆ’ ğ‘â€™ğ‘š e âˆ’ğ‘ğ‘›â€² sÃ£o inteiros, mas 0 < ğ‘Ÿ < ğ‘¡ e ğ‘¡ Ã© o menor inteiro positivo 

resultante  da  combinaÃ§Ã£o  linear  ğ‘šğ‘ + ğ‘›ğ‘,  portanto  Ã©  uma  contradiÃ§Ã£o,  provando 

que ğ‘¡ âˆ£ ğ‘. Prova-se que ğ‘¡ âˆ£ ğ‘ de forma anÃ¡loga.  

Agora, como ğ‘‘ = (ğ‘, ğ‘), entÃ£o existem ğ‘â€² e ğ‘" inteiros, tais que ğ‘ = ğ‘â€²ğ‘‘ e 

ğ‘ = ğ‘"ğ‘‘, logo ğ‘¡ = ğ‘šâ€²ğ‘ + ğ‘›â€²ğ‘ = ğ‘šâ€²ğ‘â€²ğ‘‘ + ğ‘›â€²ğ‘"ğ‘‘ = ğ‘‘(ğ‘šâ€²ğ‘â€² + ğ‘›â€²ğ‘"), portanto ğ‘‘ âˆ£ ğ‘¡. Como 

ğ‘‘ > 0 ğ‘’ ğ‘¡ > 0, entÃ£o ğ‘‘ â‰¤ ğ‘¡, mas ğ‘‘ nÃ£o pode ser menor do que ğ‘¡, pois ğ‘‘ Ã© o mÃ¡ximo 

divisor comum entre ğ‘ ğ‘’ ğ‘. Logo ğ‘¡ = ğ‘‘ e conclui-se que ğ‘‘ = ğ‘šâ€™ğ‘ + ğ‘›â€™ğ‘. 

A.2.1 CorolÃ¡rio. Para todo ğ‘¡ inteiro nÃ£o nulo, temos (ğ‘¡ğ‘, ğ‘¡ğ‘) = ğ‘¡(ğ‘, ğ‘) 

DemonstraÃ§Ã£o. Pelo teorema anterior, (ğ‘¡ğ‘, ğ‘¡ğ‘) = ğ‘šğ‘¡ğ‘ + ğ‘›ğ‘¡ğ‘, ğ‘š, ğ‘› âˆˆ ğ•«. Logo temos 

(ğ‘¡ğ‘, ğ‘¡ğ‘) = ğ‘šğ‘¡ğ‘ + ğ‘›ğ‘¡ğ‘ = ğ‘¡(ğ‘šğ‘ + ğ‘›ğ‘) = ğ‘¡(ğ‘, ğ‘) 

A.2.2 CorolÃ¡rio. Se ğ‘ > 0, ğ‘ âˆ£ ğ‘ e ğ‘ âˆ£ ğ‘, entÃ£o 

(

ğ‘
ğ‘

,

ğ‘
ğ‘

) =

1
ğ‘

(ğ‘, ğ‘) 

DemonstraÃ§Ã£o. Como ğ‘ âˆ£ ğ‘, entÃ£o   ğ‘
ğ‘

âˆˆ ğ•« e como ğ‘ âˆ£ ğ‘, entÃ£o  ğ‘
ğ‘

âˆˆ â„¤, logo ğ‘ = ğ‘ğ‘˜â€™ e 

ğ‘ = ğ‘ğ‘˜â€, para ğ‘˜â€², ğ‘˜" inteiros, assim, para ğ‘š, ğ‘› âˆˆ ğ•«, temos 

 
 
ğ‘
(
ğ‘

,

ğ‘
ğ‘

) = (

ğ‘ğ‘˜â€²
ğ‘

,

ğ‘ğ‘˜"
ğ‘

) = (ğ‘˜â€², ğ‘˜") = ğ‘šğ‘˜â€² + ğ‘›ğ‘˜" =

ğ‘šğ‘ğ‘˜â€²
ğ‘

+

ğ‘›ğ‘ğ‘˜"
ğ‘

=

ğ‘šğ‘
ğ‘

+

ğ‘›ğ‘
ğ‘

=

1
ğ‘

(ğ‘šğ‘ + ğ‘›ğ‘)

81 

=

1
ğ‘

(ğ‘, ğ‘) 

A.2.3 CorolÃ¡rio. Se ğ‘‘ = (ğ‘, ğ‘), para ğ‘ e ğ‘ inteiros, e ğ‘ â‰  0 ou ğ‘ â‰  0, temos 

DemonstraÃ§Ã£o. 

ğ‘
(
ğ‘‘

,

ğ‘
ğ‘‘

) = 1 

ğ‘
(
ğ‘‘

,

ğ‘
ğ‘‘

) = (

ğ‘
(ğ‘, ğ‘)

,

ğ‘
(ğ‘, ğ‘)

) 

Como (ğ‘, ğ‘) divide ğ‘ e divide ğ‘, entÃ£o, pelo corolÃ¡rio anterior,  

ğ‘
(
(ğ‘, ğ‘)

,

ğ‘
(ğ‘, ğ‘)

) =

1
(ğ‘, ğ‘)

(ğ‘, ğ‘) = 1 

A.3 ProposiÃ§Ã£o. Dados ğ‘, ğ‘ e ğ‘ inteiros positivos tais que ğ‘ âˆ£ ğ‘ğ‘ e (ğ‘, ğ‘) = 1, entÃ£o 

ğ‘ âˆ£ ğ‘. 

DemonstraÃ§Ã£o. Como (ğ‘, ğ‘) = 1, pelo Teorema A.2, existem ğ‘š e ğ‘› inteiros tais que 

ğ‘ğ‘¥ + ğ‘ğ‘¦ = 1. Multiplicando ambos os membros por ğ‘, temos ğ‘ğ‘¥ğ‘ + ğ‘ğ‘¦ğ‘ = ğ‘. Como 

ğ‘ âˆ£ ğ‘ğ‘¥ğ‘ e ğ‘ âˆ£ ğ‘ğ‘¦ğ‘, entÃ£o ğ‘ âˆ£ ğ‘. 

A.4 ProposiÃ§Ã£o. Se ğ‘ Ã© um nÃºmero primo e ğ‘ âˆ£ ğ‘ğ‘ entÃ£o ğ‘ âˆ£ ğ‘ ou ğ‘ âˆ£ ğ‘. 

DemonstraÃ§Ã£o.  Se  ğ‘ âˆ£ ğ‘,  estÃ¡  provada  a  proposiÃ§Ã£o.  Se  ğ‘ âˆ¤ ğ‘ ,  entÃ£o,  como  ğ‘  Ã© 

primo, entÃ£o (ğ‘, ğ‘) = 1, logo, pela ProposiÃ§Ã£o A.3, ğ‘ âˆ£ ğ‘. 

 
 
 
APÃŠNDICE B â€“ NÃšMEROS PRIMOS E DEMONSTRAÃ‡Ã•ES 

82 

B.1 Lema. Dados os nÃºmeros (ğ‘

ğ‘˜), com 0 < ğ‘˜ < ğ‘. Se ğ‘ Ã© primo, entÃ£o (ğ‘

ğ‘˜) Ã© divisÃ­vel 

por ğ‘. 

DemonstraÃ§Ã£o. Para ğ‘˜ = 1, temos  

(

ğ‘
1

) = ğ‘ 

Logo, divisÃ­vel por ğ‘. Vamos verificar, agora, para 1 < ğ‘˜ < ğ‘. Como ğ‘˜! =

ğ‘˜(ğ‘˜ âˆ’ 1)(ğ‘˜ âˆ’ 2) âˆ™ â€¦ âˆ™ 2 âˆ™ 1, entÃ£o ğ‘˜! divide ğ‘(ğ‘ âˆ’ 1) âˆ™ â€¦ âˆ™ (ğ‘ âˆ’ ğ‘˜ + 1). JÃ¡ que ğ‘˜! e ğ‘ sÃ£o 

primos entre si, entÃ£o (ğ‘˜!, ğ‘) = 1, logo ğ‘˜! divide (ğ‘ âˆ’ 1) âˆ™ â€¦ âˆ™ (ğ‘ âˆ’ ğ‘˜ + 1). Sabendo-

se que  

(

ğ‘
ğ‘˜

) = ğ‘

(ğ‘ âˆ’ 1) âˆ™ â€¦ âˆ™ (ğ‘ âˆ’ ğ‘˜ + 1)
ğ‘˜!

EntÃ£o ğ‘ divide (ğ‘

ğ‘˜), concluindo, assim, a demonstraÃ§Ã£o.  

 
 
 
 
 
83 

ANEXO C â€“ CONGRUÃŠNCIAS E DEMONSTRAÃ‡Ã•ES 

C.1 ProposiÃ§Ã£o. ğ‘ â‰¡ ğ‘ mod ğ‘š, para ğ‘ âˆˆ â„¤, ğ‘š âˆˆ â„• 

DemonstraÃ§Ã£o. Decorre imediatamente da definiÃ§Ã£o de congruÃªncia 

C.2 ProposiÃ§Ã£o. Se ğ‘ â‰¡ ğ‘ mod ğ‘š, entÃ£o ğ‘ â‰¡ ğ‘ mod ğ‘š 

DemonstraÃ§Ã£o. Decorre imediatamente da definiÃ§Ã£o de congruÃªncia 

C.3 ProposiÃ§Ã£o. Se ğ‘ â‰¡ ğ‘ mod ğ‘š e ğ‘ â‰¡ ğ‘ mod ğ‘š, entÃ£o ğ‘ â‰¡ ğ‘ mod ğ‘š 

DemonstraÃ§Ã£o. Decorre imediatamente da definiÃ§Ã£o de congruÃªncia 

C.4 ProposiÃ§Ã£o. Dados ğ‘, ğ‘ e ğ‘š inteiros, com ğ‘š > 1, entÃ£o  

ğ‘ â‰¡ ğ‘ mod ğ‘š âŸº ğ‘š âˆ£ ğ‘ âˆ’ ğ‘ 

DemonstraÃ§Ã£o. Se ğ‘ â‰¡ ğ‘ mod ğ‘š, entÃ£o o resto da divisÃ£o de ğ‘ por ğ‘š Ã© igual ao resto 

da divisÃ£o de ğ‘ por ğ‘š, assim, para ğ‘1, ğ‘Ÿ1, ğ‘2 e ğ‘Ÿ2 inteiros, temos 

ğ‘ = ğ‘1ğ‘š + ğ‘Ÿ1 âŸ¹ ğ‘Ÿ1 = ğ‘ âˆ’ ğ‘1ğ‘š 

ğ‘ = ğ‘2ğ‘š + ğ‘Ÿ2 âŸ¹ ğ‘Ÿ2 = ğ‘ âˆ’ ğ‘2ğ‘š  

Com 0 â‰¤ ğ‘Ÿ1 < ğ‘š e 0 â‰¤ ğ‘Ÿ2 < ğ‘š, logo  

ğ‘Ÿ1 = ğ‘Ÿ2 âŸ¹ ğ‘ âˆ’ ğ‘1ğ‘š = ğ‘ âˆ’ ğ‘2ğ‘š âŸ¹ ğ‘ âˆ’ ğ‘ = ğ‘1ğ‘š âˆ’ ğ‘2ğ‘š âŸ¹ ğ‘ âˆ’ ğ‘ = ğ‘š(ğ‘1 âˆ’ ğ‘2)

= ğ‘ âˆ’ ğ‘ = ğ‘š(ğ‘2 âˆ’ ğ‘1) 

Portanto,  

ğ‘š âˆ£ ğ‘ âˆ’ ğ‘ 

Reciprocamente,  se ğ‘š divide ğ‘ âˆ’ ğ‘, entÃ£o existe ğ‘ âˆˆ â„¤, tal que ğ‘ âˆ’ ğ‘ =

ğ‘ğ‘š. Fazendo ğ‘ = ğ‘2 âˆ’ ğ‘1, com ğ‘1 e ğ‘2 inteiros, temos ğ‘ âˆ’ ğ‘ = (ğ‘2 âˆ’ ğ‘1)ğ‘š, entÃ£o 

ğ‘ âˆ’ ğ‘ = (ğ‘2 âˆ’ ğ‘1)ğ‘š âŸ¹ ğ‘ âˆ’ ğ‘ = ğ‘šğ‘2 âˆ’ ğ‘šğ‘1 âŸ¹ ğ‘ âˆ’ ğ‘šğ‘2 = ğ‘ âˆ’ ğ‘šğ‘1 

Como ğ‘ âˆ’ ğ‘šğ‘2 Ã© o resto da divisÃ£o de ğ‘ por ğ‘š e ğ‘ âˆ’ ğ‘šğ‘1 Ã© o resto da 

divisÃ£o de ğ‘ por ğ‘š, e sÃ£o iguais, entÃ£o, pela definiÃ§Ã£o de congruÃªncia, temos 

ğ‘ â‰¡ ğ‘ mod ğ‘š 

Assim, conclui-se que  

 
 
84 

ğ‘ â‰¡ ğ‘ mod ğ‘š âŸº ğ‘š âˆ£ ğ‘ âˆ’ ğ‘ 

C.5 ProposiÃ§Ã£o. ğ‘ â‰¡ ğ‘ mod ğ‘š e ğ‘ â‰¡ ğ‘‘ mod ğ‘š âŸ¹ ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘‘ mod ğ‘š 

Para ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘š inteiros e ğ‘š > 1 

DemonstraÃ§Ã£o. Pela proposiÃ§Ã£o anterior, se ğ‘ â‰¡ ğ‘ mod ğ‘š, entÃ£o ğ‘š âˆ£ ğ‘ âˆ’ ğ‘ e se ğ‘ â‰¡

ğ‘‘ mod ğ‘š, entÃ£o ğ‘š âˆ£ ğ‘‘ âˆ’ ğ‘. Agora, se ğ‘š âˆ£ ğ‘ âˆ’ ğ‘, entÃ£o existe ğ‘¥ âˆˆ â„¤, tal que  

ğ‘ âˆ’ ğ‘ = ğ‘¥ğ‘š 

Anologamente, se ğ‘š âˆ£ ğ‘‘ âˆ’ ğ‘, entÃ£o existe ğ‘¦ âˆˆ â„¤, tal que  

ğ‘‘ âˆ’ ğ‘ = ğ‘¦ğ‘š 

Somando-se (I) e (II), temos 

(ğ‘ âˆ’ ğ‘) + (ğ‘‘ âˆ’ ğ‘) = ğ‘¥ğ‘š + ğ‘¦ğ‘š = ğ‘š(ğ‘¥ + ğ‘¦) âŸ¹ 

(ğ‘ + ğ‘‘) âˆ’ (ğ‘ + ğ‘) = ğ‘š(ğ‘¥ + ğ‘¦) 

(I) 

(II) 

Portanto, ğ‘š divide (ğ‘ + ğ‘‘) âˆ’ (ğ‘ + ğ‘) e, pela proposiÃ§Ã£o anterior, conclui-

se que 

ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘‘ mod ğ‘š 

C.6 ProposiÃ§Ã£o. ğ‘ â‰¡ ğ‘ mod ğ‘š âŸº ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘ mod ğ‘š, para ğ‘, ğ‘, ğ‘, ğ‘š inteiros e ğ‘š >

1 

DemonstraÃ§Ã£o.  Se  ğ‘ â‰¡ ğ‘ mod ğ‘š  e,  pela  ProposiÃ§Ã£o  1,  ğ‘ â‰¡ ğ‘ mod ğ‘š,  temos,  pela 

ProposiÃ§Ã£o 5, o seguinte 

ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘ mod ğ‘š 

Agora, se ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘ mod ğ‘š, temos 

ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘ mod ğ‘š âŸ¹ ğ‘š âˆ£ (ğ‘ + ğ‘) âˆ’ (ğ‘ + ğ‘) âŸ¹  ğ‘š âˆ£ ğ‘ âˆ’ ğ‘ âŸ¹  ğ‘ â‰¡ ğ‘ mod ğ‘š 

Portanto,  

ğ‘ â‰¡ ğ‘ mod ğ‘š âŸº ğ‘ + ğ‘ â‰¡ ğ‘ + ğ‘ mod ğ‘š 

C.7 ProposiÃ§Ã£o. ğ‘ â‰¡ ğ‘ mod ğ‘š e ğ‘ â‰¡ ğ‘‘ mod ğ‘š âŸ¹ ğ‘ğ‘ â‰¡ ğ‘ğ‘‘ mod ğ‘š 

 
 
 
 
Para ğ‘, ğ‘, ğ‘, ğ‘‘, ğ‘š inteiros e ğ‘š > 1 

DemonstraÃ§Ã£o.  Como  ğ‘ â‰¡ ğ‘ mod ğ‘š  e  ğ‘ â‰¡ ğ‘‘ mod ğ‘š,  entÃ£o  ğ‘š âˆ£ ğ‘ âˆ’ ğ‘  e  ğ‘š âˆ£ ğ‘‘ âˆ’ ğ‘, 

respectivamente. Dessa forma, para ğ‘¥ e ğ‘¦ inteiros, temos  

85 

ğ‘ âˆ’ ğ‘ = ğ‘¥ğ‘š 

ğ‘‘ âˆ’ ğ‘ = ğ‘¦ğ‘š 

(I) 

(II) 

Agora, multiplicando (I) e (II) por ğ‘‘ e ğ‘, respectivamente, temos 

ğ‘ğ‘‘ âˆ’ ğ‘ğ‘‘ = ğ‘‘ğ‘¥ğ‘š 

ğ‘ğ‘‘ âˆ’ ğ‘ğ‘ = ğ‘ğ‘¦ğ‘š 

(III) 

(IV) 

Somando-se (III) e (IV), obtemos 

ğ‘ğ‘‘ âˆ’ ğ‘ğ‘ = ğ‘‘ğ‘¥ğ‘š + ğ‘ğ‘¦ğ‘š = ğ‘š(ğ‘‘ğ‘¥ + ğ‘ğ‘¦) 

Logo, ğ‘š âˆ£ ğ‘ğ‘‘ âˆ’ ğ‘ğ‘, e, portanto, ğ‘ğ‘ â‰¡ ğ‘ğ‘‘ mod ğ‘š. 

Uma consequÃªncia direta da ProsiÃ§Ã£o 6 Ã© o seguinte corolÃ¡rio 

C.7.1 CorolÃ¡rio. Dados ğ‘› natural e ğ‘, ğ‘ inteiros, temos 

ğ‘ â‰¡ ğ‘ mod ğ‘š âŸ¹ ğ‘ğ‘› â‰¡ ğ‘ğ‘› mod ğ‘š 

C.8 ProposiÃ§Ã£o 

ğ‘ğ‘ â‰¡ ğ‘ğ‘ mod ğ‘š âŸº ğ‘ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ 

ğ‘š
(ğ‘, ğ‘š)

Para ğ‘, ğ‘, ğ‘ inteiros e ğ‘š inteiro maior do que 1. 

DemonstraÃ§Ã£o.  Seja  ğ‘ğ‘ â‰¡ ğ‘ğ‘ mod ğ‘š,  com  ğ‘, ğ‘, ğ‘ âˆˆ â„¤  e  ğ‘š âˆˆ â„¤, ğ‘š > 1,  entÃ£o,  pela 

ProposiÃ§Ã£o C.4,  

ğ‘ğ‘ â‰¡ ğ‘ğ‘ mod ğ‘š âŸº ğ‘š âˆ£ ğ‘ğ‘ âˆ’ ğ‘ğ‘ = ğ‘š âˆ£ ğ‘(ğ‘ âˆ’ ğ‘) âŸº

ğ‘š
(ğ‘, ğ‘š)

âˆ£

ğ‘
(ğ‘, ğ‘š)

(ğ‘ âˆ’ ğ‘) 

 
 
 
 
 
 
 
Como,  pelo  CorolÃ¡rio  A.2.3,  (

ğ‘š
(ğ‘,ğ‘š)

,

ğ‘
(ğ‘,ğ‘š)

) = 1,  entÃ£o  ğ‘š
(ğ‘,ğ‘š)

  e 

ğ‘
(ğ‘,ğ‘š)

  sÃ£o 

coprimos28, logo  

86 

ğ‘š
(ğ‘, ğ‘š)

âˆ£

ğ‘
(ğ‘, ğ‘š)

(ğ‘ âˆ’ ğ‘) âŸº

ğ‘š
(ğ‘, ğ‘š)

âˆ£ ğ‘ âˆ’ ğ‘ 

E novamente pela ProposiÃ§Ã£o C.4, 

ğ‘š
(ğ‘, ğ‘š)

âˆ£ ğ‘ âˆ’ ğ‘ âŸº ğ‘ â‰¡ ğ‘ mod 

ğ‘š
(ğ‘, ğ‘š)

C.8.1 CorolÃ¡rio. Da ProposiÃ§Ã£o C.8, se (ğ‘, ğ‘š) = 1, entÃ£o 

ğ‘ğ‘ â‰¡ ğ‘ğ‘ mod ğ‘š âŸº ğ‘ â‰¡ ğ‘ mod ğ‘š 

C.9 ProposiÃ§Ã£o. Se ğ‘ Ã© primo, (ğ‘, ğ‘) = 1 e ğ‘2 â‰¡ 1 (mod ğ‘), entÃ£o ğ‘ â‰¡ 1 (mod ğ‘) ou 

ğ‘ â‰¡ âˆ’1 (mod ğ‘). 

DemonstraÃ§Ã£o.  

ğ‘2 â‰¡ 1 (mod ğ‘) âŸº ğ‘ âˆ£ (ğ‘2 âˆ’ 1) âŸº ğ‘ âˆ£ (ğ‘ + 1)(ğ‘ âˆ’ 1) 

Como  ğ‘  Ã©  primo,  entÃ£o  ğ‘ âˆ£ (ğ‘ + 1)  ou  ğ‘ âˆ£ (ğ‘ âˆ’ 1),  portanto  ğ‘ â‰¡

âˆ’1 (mod ğ‘) ou ğ‘ â‰¡ 1 (mod ğ‘). 

C.10 Teorema.  Sejam  ğ‘  e  ğ‘  inteiros,  se ğ‘ âˆ¤ ğ‘,  ğ‘ â‰¢ 1 (mod ğ‘)  e  ğ‘ â‰¢ âˆ’1 (mod ğ‘)  e 

ğ‘2 â‰¡ 1 (mod ğ‘), entÃ£o ğ‘ Ã© composto.  

DemonstraÃ§Ã£o.  Como  ğ‘2 â‰¡ 1 (mod ğ‘),  entÃ£o  ğ‘ âˆ£ (ğ‘2 âˆ’ 1)  que  equivale  a  ğ‘ âˆ£ (ğ‘ +

1)(ğ‘ âˆ’ 1). Supondo que ğ‘ Ã© primo, entÃ£o, pela proposiÃ§Ã£o anterior, temos ğ‘ âˆ£ (ğ‘ +

1) ou ğ‘ âˆ£ (ğ‘ âˆ’ 1), um absurdo, pois, por hipÃ³tese, ğ‘ â‰¢ 1 (mod ğ‘) e ğ‘ â‰¢ âˆ’1 (mod ğ‘), 

isto Ã©, ğ‘ âˆ¤ (ğ‘ âˆ’ 1) e ğ‘ âˆ¤ (ğ‘ + 1), logo ğ‘ Ã© composto. 

28 Define-se como coprimos, dois nÃºmeros inteiros ğ‘ e ğ‘, cujo Ãºnico divisor positivo comum Ã© 1, isto 
Ã©, (ğ‘, ğ‘) = 1. Os nÃºmeros ğ‘ e ğ‘ tambÃ©m sÃ£o definidos como primos entre si.  

 
 
 
 
 
 
 
