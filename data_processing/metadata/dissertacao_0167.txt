UNIVERSIDADE FEDERAL RURAL DE PERNAMBUCO
DEPARTAMENTO DE MATEMÁTICA
Mestrado Proﬁssional em Matemática em Rede Nacional

Cristiano Isidoro da Silva

Códigos Cíclicos: uma proposta de sequência didática para o

ensino de polinômios

RECIFE
2020

UNIVERSIDADE FEDERAL RURAL DE PERNAMBUCO
DEPARTAMENTO DE MATEMÁTICA
Mestrado Proﬁssional em Matemática em Rede Nacional

Cristiano Isidoro da Silva

Códigos Cíclicos: uma proposta de sequência didática para o
ensino de polinômios

Dissertação de mestrado apresentada ao Departamento
de Matemática da Universidade Federal Rural de Per-
nambuco como requisito parcial para obtenção do título
de Mestre em Matemática.

Orientadora: Profa. Dra. Bárbara Costa Silva

RECIFE
2020

Dados Internacionais de Catalogação na Publicação Universidade Federal Rural de PernambucoSistema Integrado de BibliotecasGerada automaticamente, mediante os dados fornecidos pelo(a) autor(a)S586cSilva, Cristiano Isidoro        Códigos Cíclicos: uma proposta de sequência didática para o ensino de polinômios / Cristiano Isidoro Silva. - 2020.        83 f. : il.        Orientador: Barbara Costa da Silva.        Inclui referências.        Dissertação (Mestrado) - Universidade Federal Rural de Pernambuco, Programa de Mestrado Profissional emMatemática (PROFMAT), Recife, 2021.        1. Transmissão de mensagens. 2. Códigos Corretores de Erro. 3. Códigos Cíclicos. 4. Polinômios. I. Silva, Barbara Costada, orient. II. Título                                                                                                                                                   CDD 510CRISTIANO ISIDORO DA SILVA    Códigos Cíclicos: uma proposta de sequência Didática para o ensino de polinômios.    Trabalho apresentado ao Programa de Mestrado Profissional em Matemática – PROFMAT do Departamento de Matemática da UNIVERSIDADE FEDERAL RURAL DE PERNAMBUCO, como requisito parcial para obtenção do grau de Mestre em Matemática.      Aprovado em ___ /___ /_____       BANCA EXAMINADORA      _ Profª. Drª. Bárbara Costa da Silva (Orientadora)– UFRPE     _ Prof. Dr. Éden Santana Campos Amorim – CEFET-MG     _ Prof. Dr. Gabriel Araújo Guedes– PROFMAT/UFRPE DECLARAÇÃO 

Eu, CRISTIANO ISIDORO DA SILVA declaro, para devidos fins e efeitos, que a dissertação 
sob título “Códigos Cíclicos: uma proposta de sequência didática para o ensino de polinômios”, 
entregue como Trabalho de Conclusão de curso para obtenção do título de mestre, com exceção 
das citações diretas e indiretas claramente indicadas e referenciadas, é um trabalho original. Eu 
estou  consciente  que  a  utilização  de  material  de  terceiros  incluindo  uso  de  paráfrase  sem  a 
devida indicação das fontes será considerado plágio, e estará sujeito à processos administrativos 
da  Universidade  Federal  Rural  de  Pernambuco  e  sanções  legais.  Declaro  ainda  que  respeitei 
todos os requisitos dos direitos de autor e isento a Pós-graduação PROFMAT/UFRPE, bem como 
a  professora  orientadora  BÁRBARA  COSTA  DA  SILVA,  de  qualquer  ônus  ou  responsabilidade 
sobre a sua autoria.  

Recife, 7 de dezembro de 2020. 

_______________________________________________ 

Cristiano Isidoro da Silva 

 
 
 
 
 
  
 
À minha família

Agradecimentos

Agradeço em primeiro lugar a Deus, pois sem Ele nada eu seria. À minha amada
esposa Sâmela Isys que me apoiou e acreditou em mim durante todo período do mestrado.
À minha ﬁlha Clarice que foi motivo de minha inspiração e força desde que chegou ao
mundo. Aos meus pais Claudeny e Dulcilene pela educação que me deram e ao meu irmão
Adriano por acreditar sempre em mim. À minha orientadora, Dra. Barbara Costa, pelas
ricas contribuições durante toda orientação. Aos meus amigos Eliú Oliveira, Pedro Vitor,
Valter Junior, Gabriel Brito, Peterson, Cícero e Luiz Manoel por tornarem o período
do mestrado aprazível. Também quero agradecer a todos os professores do programa
PROFMAT que contribuíram de forma efetiva com a minha formação.

“Não vos amoldeis às estruturas deste mundo,
mas transformai-vos pela renovação da mente,
a ﬁm de distinguir qual é a vontade de Deus:
o que é bom, o que Lhe é agradável, o que é perfeito.
(Bíblia Sagrada, Romanos 12.2)

Resumo

A matemática está em toda parte. O problema é que muitas vezes não percebemos isso.
Por exemplo, ao assistirmos televisão, ao enviarmos um e-mail, ao realizarmos uma ligação
telefônica, ou ao utilizarmos qualquer meio de comunicação, a matemática está presente. De
uma forma geral, quando uma mensagem é transmitida por qualquer meio de comunicação,
existe um código numérico associado. Códigos corretores de erros são códigos utilizados no
sistema de transmissão de mensagens, com o objetivo de recuperar uma informação perdida
durante o processo de transmissão, na ocorrência de algum erro ou alteração na mensagem.
Nesta dissertação, apresentamos os códigos cíclicos, um tipo de código corretor de erros,
cuja relevância é possuir algoritmos de implementação de grande eﬁciência, baseados em
operações com polinômios. Propomos uma sequência didática, direcionada para turma do
3o ano do Ensino Médio, que permite ao professor realizar uma aplicação com operações
de polinômios em um tema relacionado ao cotidiano dos alunos.

Palavras-chave: Transmissão de mensagens, Códigos Corretores de Erros, Códigos Cícli-
cos, Polinômios.

Abstract

Mathematics is in everywhere. The problem is that we often don’t realize this. For example,
when watching television, sending an e-mail, making a phone call, or using any means of
communication, mathematics is present. In general, when a message is transmitted by
any means of communication there is an associated numeric code. Error correcting codes
are codes used in the message transmission system, in order to recover lost information
during the transmission process, in the event of an error or change in the message. In this
dissertation, we present the cyclic codes, a type of error-correcting code, whose relevance is
to have highly eﬃcient implementation algorithms, based on operations with polynomials.
We propose a didactic sequence, aimed at the 3rd year high school class, which allows the
teacher to carry out an application with polynomial operations on a theme related to the
students’ daily lives.

Keywords: Transmission of messages, Error Correcting Codes, Cyclic Codes, Polynomials.

Lista de ilustrações

Figura 1 – Esquema de Transmissão da Informação . . . . . . . . . . . . . . . . . 36

Sumário

Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

19

1
1.1
1.1.1
1.2

UM BREVE PASSEIO PELAS ESTRUTURAS ALGÉBRICAS 23
23
Noções de anéis . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
Anéis de polinômios . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 31
Noções de álgebra linear sobre corpos ﬁnitos

2
2.1
2.2

3
3.1
3.2
3.3
3.4

4
4.1
4.2
4.3
4.4
4.5
4.6
4.7

35
CÓDIGOS QUE CORRIGEM ERROS . . . . . . . . . . . . . .
A métrica de Hamming . . . . . . . . . . . . . . . . . . . . . . . .
36
O problema fundamental da teoria dos códigos . . . . . . . . . . 41

CÓDIGOS CÍCLICOS . . . . . . . . . . . . . . . . . . . . . . . .
Caracterização dos códigos cíclicos . . . . . . . . . . . . . . . . .
Matriz geradora . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Códigos duais - matriz teste de paridade . . . . . . . . . . . . .
Codiﬁcação e decodiﬁcação . . . . . . . . . . . . . . . . . . . . . .

43
43
48
50
54

UMA PROPOSTA PARA O ENSINO DE POLINÔMIOS . .
Aula 1: Corpos ﬁnitos . . . . . . . . . . . . . . . . . . . . . . . . .
Aula 2: Polinômios com coeﬁcientes em um corpo ﬁnito . . . .
. . . . . . . . . . . . . .
Aula 3: Divisão de polinômios em K[X]
. . . . . . . . . . . . . .
Aula 4: Fatorando polinômios em K[X]
Aula 5: Códigos corretores de erros
Aula 6: Codiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . . . .
Aula 7: Decodiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . .

59
60
64
66
69
. . . . . . . . . . . . . . . . . 71
73
75

Conclusão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

79

REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . .

81

Introdução

19

A Teoria dos Códigos Corretores de Erros, fundada pelo matemático C. E. Shannon,
num trabalho publicado em 1948, foi inicialmente de interesse dos matemáticos, que deram
grandes contribuições no período entre as décadas de 50 e 60. Com o passar dos anos, com
o avanço nas pesquisas espaciais e a popularização dos computadores, passou também a ser
do interesse dos engenheiros. Nos dias atuais, essa teoria se tornou um campo de pesquisa
muito ativo em diversas áreas do conhecimento: matemática, engenharia, computação,
estatística, biologia entre outras.

Recentemente, o avanço das tecnologias de comunicação vem sendo cada vez mais
impressionante. É muito difícil encontrar uma pessoa que não foi inﬂuenciada pelo uso
dessas novas tecnologias. Isto justiﬁca a importância desses meios na vida da sociedade.
Uma simples transmissão de mensagens escritas por correio eletrônico, de voz por telefone
ou de imagens e sons da televisão, que estão presentes no nosso cotidiano, envolve uma
teoria matemática, que permite ao usuário desses meios de comunicação uma transmissão
de qualidade.

No processo da transmissão de informações, podem ocorrer algum tipo de inter-
ferência ou erro, que é chamado de ruído, fazendo com que a mensagem recebida seja
diferente da enviada. Com o surgimento de um sistema de comunicação cada vez mais
moderno, é possível fazer com que essa mensagem chegue ao receptor da forma mais
conﬁável possível. O uso desses sistemas de comunicação torna possível o desenvolvimento
de teorias matemáticas basilares às novas tecnologias, dentre elas, a Teoria dos Códigos
Corretores de Erros.

Na experiência como professor, já ouvi de muitos alunos a seguinte pergunta: "Onde
os polinômios serão usados na minha vida?"ou "Pra que serve esse ou aquele conteúdo de
matemática e onde é aplicado?"Com base nesses tipos de pergunta, resolvemos elaborar essa
dissertação que tem por objetivo principal propor uma sequência didática que possibilite
ao professor do ensino básico apresentar aos seus alunos uma aplicação de polinômios em
um tema relacionado com o cotidiano deles.

Vejamos a seguir as competências 3 e 4 especíﬁcas de matemática para o ensino

médio, presentes no texto da BNCC 1 (11)(BRASIL, 2018, p. 531).

3. Utilizar estratégias, conceitos, deﬁnições e procedimentos matemáticos
para interpretar, construir modelos e resolver problemas em diversos
contextos, analisando a plausibilidade dos resultados e a adequação das
soluções propostas, de modo a construir argumentação consistente.

1 Base Nacional Comum Curricular

20

Introdução

4. Compreender e utilizar, com ﬂexibilidade e precisão, diferentes regis-
tros de representação matemáticos (algébrico, geométrico, estatístico,
computacional etc.), na busca de solução e comunicação de resultados de
problemas.

Nessas competências, consideramos relevante para os nossos propósitos a necessidade
do uso de procedimentos matemáticos na construção de modelos e resolução de problemas
em diversos contextos, e da utilização de registros algébricos e computacionais, na busca
de solução e comunicação de resultados de problemas. Essas competências apoiam a ideia
do estudo de aplicações matemáticas, que envolvem os diversos campos dessa ciência, entre
eles a álgebra.

No primeiro capítulo, trazemos os principais resultados que servirão de material
de apoio para o professor relembrar alguns conceitos das disciplinas de Anéis e Álgebra
Linear. Os resultados apresentados nesse capítulo ajudarão na compreensão dos resultados
posteriores encontrados principalmente no capítulo 3, no qual estudaremos os códigos
cíclicos.

No segundo capítulo, além de descrever alguns fatos históricos, apresentamos os
conceitos básicos da teoria, como deﬁnições de códigos corretores de erros, a métrica de
Hamming, os parâmetros de um código, e ﬁnalizamos com o problema fundamental da
teoria dos códigos.

No terceiro capítulo, estudamos os códigos cíclicos, numa abordagem voltada para o
professor do ensino médio. No estudo desse código, utilizamos algoritmos de implementação
muito eﬁcientes baseados em operações com polinômios e multiplicação de matrizes.

No capítulo 4, produto ﬁnal dessa dissertação, elaboramos uma proposta de sequên-
cia didática, voltada para alunos do Ensino Médio, turmas participantes de olimpíadas de
matemática e alunos interessados. A sequência é composta por 7 aulas de 50 minutos. A
primeira aula, aborda o conteúdo "Divisão euclidiana", que é ensinado no Ensino Funda-
mental - Anos Finais para compreensão da deﬁnição de corpos ﬁnitos. Vejamos o que diz
a BNCC, com relação ao estudo dos conteúdos do Ensino Fundamental no Ensino Médio.

A BNCC da área de Matemática e suas Tecnologias propõe a consoli-
dação, a ampliação e o aprofundamento das aprendizagens essenciais
desenvolvidas no Ensino Fundamental. Para tanto, propõe colocar em
jogo, de modo mais inter-relacionado, os conhecimentos já explorados
na etapa anterior, a ﬁm de possibilitar que os estudantes construam
uma visão mais integrada da Matemática, ainda na perspectiva de sua
aplicação à realidade. (BRASIL, 2018, p. 527)

A BNCC prima pela aplicação dos conteúdos do Ensino Fundamental no Ensino
Médio de forma mais aprofundada e integrada à realidade. As aulas 2, 3 e 4 tratam do
estudo dos polinômios com coeﬁcientes em corpos ﬁnitos. Nelas abordaremos raízes, divisão

e fatoração de polinômios com coeﬁcientes em corpos ﬁnitos. As aulas 5, 6 e 7 dedicam-se
à aplicação de códigos cíclicos no ensino médio, nos quais os alunos usarão operações de
polinômios em algoritmos para codiﬁcação e decodiﬁcação de mensagens.

21

1 Um breve passeio pelas estrutu-

ras algébricas

23

Para melhor entendimento do estudo dos códigos cíclicos, trataremos nesse capítulo
de alguns conceitos e resultados matemáticos fundamentais para o desenvolvimento da
teoria. Para um estudo mais objetivo, alguns resultados que utilizaremos não serão demons-
trados. Ao leitor interessado em um maior aprofundamento no conteúdo recomendamos
uma consulta às referências (1), (2), (3) e (4).

1.1 Noções de anéis

Deﬁnição 1.1. Seja A um conjunto não vazio munido de duas operações, às quais
chamaremos de soma e produto em A e denotaremos por + e ·

Assim,

+ : A × A −→ A

e

· : A × A −→ A

(a, b)

7−→ a + b

(a, b)

7−→ a · b

Chamaremos a tripla (A, +, ·) um anel comutativo com unidade, se as seguintes

propriedades são veriﬁcadas, quaisquer que sejam a, b, c ∈ A.

(A1) (a + b) + c = a + (b + c) (associatividade da soma);

(A2) Existe um elemento chamado zero e denotado por 0, de forma que a + 0 = 0 + a = a

(existência de elemento neutro para a soma);

(A3) Dado a ∈ A, existe um único elemento chamado simétrico de a e denotado por −a

tal que a + (−a) = −a + a = 0 (existência de inverso aditivo);

(A4) a + b = b + a (comutatividade da soma);

(M1) (a · b) · c = a · (b · c) (associatividade do produto);

(M2) Existe um elemento chamado unidade e denotado por 1 tal que a · 1 = 1 · a = a

(elemento neutro do produto);

(M3) a · b = b · a (comutatividade do produto);

(AM) a · (b + c) = a · b + a · c (distributividade do produto em relação à soma).

24

Capítulo 1. Um breve passeio pelas estruturas algébricas

Seja A um anel. Diremos que a 6= 0 um elemento de A é um divisor de zero se existir
b ∈ A, com b 6= 0 tal que a · b = 0. Diremos que o anel A é um domínio de integridade se
A não possui divisores de zero.

Se A é um domínio de integridade então vale a Lei do Cancelamento, isto é, dados

a, b, c ∈ A tais que c 6= 0 e a · c = b · c, então a = b.

Exemplo 1.2. Os conjuntos Z, Q, R e C, juntamente com suas operações usuais de soma
e produto são exemplos de domínios de integridade. Já o conjunto dos naturais N não é
um anel, por não haver simétrico, nem elemento neutro da soma.

Um elemento a de um anel A será dito invertível, se existir um elemento a−1 ∈ A
de modo que a · a−1 = 1. Assim diremos que a−1 é o inverso de a. Ao anel, onde todos os
elementos não nulos são invertíveis, chamaremos de corpo.

Dos exemplos acima, Q, R e C são exemplos de corpo, porém Z não é corpo, pois
os únicos elementos invertíveis neste anel são 1 e −1. Assim, nem todo domínio é corpo.

Todo corpo A é um domínio de integridade, pois se a ∈ A é um divisor de zero,
então existe b ∈ A com b 6= 0 tal que a · b = 0. Sendo A corpo e b 6= 0 existe b−1 inverso de
b. Daí,

a = a · 1 = a · (b · b−1) = (a · b) · b−1 = 0 · b−1 = 0.

Deﬁnição 1.3. Seja A um anel e I um subconjunto de A. Diremos que I é um ideal de
A se para todo x, y ∈ I e a ∈ A temos

i) x + y ∈ I.

ii) a · x ∈ I.

Observe que {0} e o próprio A são ideais de A. Se A é um anel e a ∈ A, então A · a é
um ideal de A, chamado de ideal principal gerado por a. De formal geral, se a1, · · · , an ∈ A,
então o conjunto

I = {x1a1 + · · · + xnan; x1, · · · , xn ∈ A}

é um ideal de A, e os elementos a1, · · · , an são chamados de geradores de I.

Deﬁnição 1.4. Seja A um anel. Um ideal M é chamado de ideal maximal se M 6= A e
se I é um ideal de A, de forma que

M ⊆ I ⊆ A, então I = M ou I = A.

Observação 1.5. Em relação ao anel dos inteiros, é possível mostrar que todo ideal de Z é
principal. E dado p · Z = I ⊂ Z, poderemos veriﬁcar também que p é um número primo
se, e somente se I é um ideal maximal em Z.

1.1. Noções de anéis

25

Seja A um anel e I um ideal de A, deﬁniremos a relação ≡ mod I em A por:

x, y ∈ A, x ≡ y mod I ⇔ x − y ∈ I.

A relação ≡ mod I deﬁne em A uma relação de equivalência.

A classe de equivalência do elemento x ∈ A em relação a ≡ mod m, denotada por x,
é o conjunto x = {y ∈ A | y ≡ x mod I} = x + I e o conjunto das classes de equivalências,
chamado de conjunto quociente, será denotado por A/I = {x = x + I | x ∈ A}.

O próximo resultado nos permitirá deﬁnir as operações de adição e multiplicação

no conjunto quociente A/I.

Proposição 1.6. Seja A um anel e I um ideal em A. Se a ≡ b mod I e c ≡ d mod I,
então

(i) a + c ≡ b + d mod I

(ii) a · c ≡ b · d mod I.

Observe que pela Proposição 1.6 a classe da soma não depende dos representantes
das classes das parcelas, como de modo análogo ocorre com a classe do produto que não
depende das classes dos fatores. Ou seja, as operações da adição e multiplicação em A/I,
que serão apresentadas no próximo Teorema, estão bem deﬁnidas.

Teorema 1.7. Seja A um anel e I um ideal de A. Se x = x + I e A/I = {x | x ∈ A},
então

i. As operações de adição e multiplicação em A/I são deﬁnidas por

+ : A/I × A/I −→ A/I

e

· : A/I × A/I −→ A/I

(x, y)

7−→ x + y = x + y

(x, y)

7−→ x · y = x · y

ii. O conjunto A/I munido das operações de adição de multiplicação deﬁnidas no item

acima é um anel, chamado de anel quociente de A por I;

iii. Se 1 é a unidade de A, então 1 é a unidade de A/I;

iv. Se A é um anel comutativo, então A/I é comutativo.

Teorema 1.8. Seja A um anel comutativo com unidade 1 ∈ A e seja I um ideal de A.
Então I é ideal maximal de A se, e somente se, A/I é um corpo.

Veremos agora como exemplo as operações de soma e produto em Zm = Z/I, em

que I = mZ, para alguns valores de m especíﬁcos.

26

Capítulo 1. Um breve passeio pelas estruturas algébricas

Exemplo 1.9. Seja m = 3. Assim Z3 = {0, 1, 2} e efetuando todas as operações de soma
e produto possíveis com elementos de Z3, obteremos

+ 0
0
0
1
1
2
2

1
1
2
0

2
2
0
1

e

·
0
1
2

0
0
0
0

1
0
1
2

2
0
2
1

.

Como 1 e 2 são invertíveis, Z3 é um corpo.

Exemplo 1.10. Seja m = 4. Logo Z4 = {0, 1, 2, 3} e fazendo todas as operações de soma
e produto possíveis com elementos de Z4, teremos

+ 0
0
0
1
1
2
2
3
3

1
1
2
3
0

2
2
3
0
1

3
3
0
1
2

e

·
0
1
2
3

0
0
0
0
0

1
0
1
2
3

2
0
2
0
2

3
0
3
2
1

.

Como 2 não é invertível, Z4 não é um corpo. Como 2 · 2 = 0, esse anel não é um

domínio de integridade.

Pela Observação 1.5 e Teorema 1.8 temos que Zm é um corpo se, e somente se, m

é um número primo.

1.1.1 Anéis de polinômios

Nesta seção, estudaremos o conceito de polinômios com coeﬁcientes em um anel.
Observaremos que as propriedades das operações de polinômios estão intimamente ligadas
às propriedades da soma e produto no conjunto de seus coeﬁcientes.

Seja A um anel. Chamaremos de um polinômio sobre A em uma indeterminada

X /∈ A a expressão do tipo

P (X) = a0 + a1X + · · · + anX n =

n
X

i=0

aiX i,

onde n é um inteiro não negativo, ai ∈ A, para 0 ≤ i ≤ n. É de costume não escrever o
termo aiX i sempre que ai = 0.

Dados dois polinômios P (X) = a0 +a1X +· · ·+anX n e Q(X) = b0 +b1 +· · ·+bmX m,
ambos com coeﬁcientes em A. Diremos que P (X) = Q(X) se, e somente se, m = n e
ai = bi para 0 ≤ i ≤ n.

Denotaremos por A[X] o conjunto de todos os polinômios na indeterminada X

com coeﬁcientes em A.

1.1. Noções de anéis

27

Deﬁniremos as operações de soma e produto de polinômios em A[X], tomando

como base as operações de soma e produto sobre A.

Deﬁnição 1.11. Sejam P (X) =

n
X

aiX i e Q(X) =

operações de soma e produto em A[X] como segue

i=0

m
X

i=0

biX i em A[X], deﬁniremos as

P (X) + Q(X) =

max{n,m}
X

ciX i,

P (X) · Q(X) =

i=0

n+m
X

i=0

ciX i,

onde ci = ai + bi, e

onde

c0 = a0 · b0
c1 = a0 · b1 + a1 · b0
...
ci = X
...
cn+m = an · bm.

λ+µ = i

aλ · bµ = a0 · bi + a1 · bi−1 + · · · + ai · b0

Teorema 1.12. Com as operações acima deﬁnidas, A[X] é um anel.

Deﬁnição 1.13. Para todo polinômio P (X) não identicamente nulo em A[X], algum
coeﬁciente deve ser distinto de zero. Então existe um maior índice n 6= 0, o qual chamaremos
de grau de P (X) e denotaremos por gr(P (X)). Neste caso, chamaremos an de coeﬁciente
líder de P (X).

Observação 1.14. Note que pela deﬁnição acima gr(P (X)) = 0 se, e somente se, P (X) =
a0 ∈ A \ {0}, e que o grau do polinômio nulo não é deﬁnido.

Proposição 1.15. Seja A um domínio de integridade. As seguintes condições são satis-
feitas.

(i) Se P (X), Q(X) ∈ A[X] \ {0}, então gr(P (X) · Q(X)) = gr(P (X)) + gr(Q(X));

(ii) A[X] é um domínio de integridade;

(iii) Os elementos invertíveis de A[X] são os elementos invertíveis de A.

De agora em diante admitiremos que A é um corpo K. Segue do resultado acima

que K[X] é um domínio de integridade.

Deﬁnição 1.16. Os polinômios de grau n com coeﬁciente líder an = 1 são chamados de
polinômios mônicos.

28

Capítulo 1. Um breve passeio pelas estruturas algébricas

Iremos enunciar alguns resultados de divisibilidade, iniciando com o algoritmo

euclidiano de divisão de polinômios com coeﬁcientes em um corpo arbitrário K.

Deﬁnição 1.17. Sejam dois polinômios F (X) e G(X) no anel de polinômios K[X]
com coeﬁcientes num corpo K. Diremos que F (X) é múltiplo de G(X) quando existe
H(X) ∈ K[X] tal que F (X) = G(X) · H(X). Para o caso em que G(X) 6= 0, diremos que
G(X) divide F (X).

Proposição 1.18. (Divisão Euclidiana)

Seja K um corpo e F (X), G(X) ∈ K[X], com G(X) 6= 0. Então, existem Q(X) e

R(X) em K[X], unicamente determinados, de modo que

F (X) = Q(X)G(X) + R(X),

em que R(X) = 0 ou gr(R(X)) < gr(G(X)).

Deﬁnição 1.19. Seja K um corpo e F (X) ∈ K[X]\K. Diremos que F (X) é um polinômio
irredutível em K[X] se possuir a seguinte propriedade:

• Se F (X) = G(X) · H(X), com G(X), H(X) ∈ K[X], então G(X) ou H(X) é um

polinômio constante não nulo.

Teorema 1.20. (Fatoração única) Todo polinômio mônico em K[X], não constante e não
irredutível, pode ser escrito como produto de polinômios de K[X] irredutíveis e mônicos.
Essa escrita é única a menos da ordem dos fatores.

Deﬁnição 1.21. Seja P (X) ∈ K[X] e seja α ∈ K, onde K é um anel. Diremos que α é
uma raiz de P (X), se P (α) = 0.

Proposição 1.22. Sejam K um corpo, P (X) ∈ K[X] e α ∈ K. Então α é uma raiz de
P (X) se, e somente se, (X − α) divide P (X).

Teorema 1.23. Um polinômio de grau n com coeﬁcientes num corpo K possui, no máximo,
n raízes distintas sobre K.

Estudaremos agora os ideais de K[X] que serão fundamentais para o desenvolvi-

mento e compreensão da teoria dos códigos cíclicos.

Proposição 1.24. Todo ideal de K[X] é da forma I(F (X)), onde F (X) ∈ K[X].

Dado um ideal I de K[X], se F (X) é um gerador de I, para toda constante não
nula c ∈ K, cF (X) também é um gerador de I. Como consequência dos resultados obtidos
acima, temos o seguinte corolário:

1.1. Noções de anéis

29

Corolário 1.25. Seja I 6= {0} um ideal de K[X]. Então, existe um único polinômio
mônico F (X) em I (de grau mínimo), tal que I = I(F (X)).

Estudaremos os anéis quocientes K[X]/P (X), onde P (X) é um polinômio não

constante e mônico de grau n. Observe inicialmente que

K[X]/P (X) = {R(X); R(X) ∈ K[X] com R(X) = 0, ou gr(R(X)) < n}

e que dado R1(X), R2(X) ∈ K[X] com gr(R1(X)) < n e gr(R2(X)) < n, sendo R1(X) 6=
R2(X), então R1(X) 6= R2(X).

Teorema 1.26. O anel K[X]/P (X) é um corpo se, e somente se, o polinômio P (X) é
irredutível.

O resultado acima nos fornece uma forma prática para construção de corpos ﬁnitos.
Dado K = Zp, em que p é um número primo positivo. Se P (X) ∈ K[X] é irredutível com
grau n, então K[X]/P (X) é formado pelas classes de polinômios a0 + a1X + · · · + an−1X n−1
em K[X], e dois polinômios distintos de graus menores do que n deﬁnem classes distintas.
O corpo K[X]/P (X) tem pn elementos. Veremos Zp como um subcorpo de K[X]/P (X) e
identiﬁcaremos o elemento λ ∈ K = Zp como λ ∈ K[X]/P (X).

Exemplo 1.27. Sejam K = Z2 e P (X) = X 2 + X + 1. Observe que P (X) é irredutível
em K[X]. Construiremos um corpo F4, cujos elementos listamos abaixo.

F4 = K[X]/P (X) = {0, 1, X, 1 + X}.

As tabelas de operações de soma e produto de F4 são, respectivamente:

+
0
1
X

0
0
1
X

1 + X 1 + X

1
1
0
1 + X
X

X
X
1 + X
0
1

1 + X
1 + X
X
1
0

,

·

0

1

X

0
1
X

0
0
0
1 + X 0

0
1
X
1 + X

0
X
1 + X
1

1 + X

0
1 + X
1
X

.

Exemplo 1.28. Dado P (X) = X 2 + 1 ∈ Z3[X], um polinômio irredutível. Poderemos
construir um corpo F9 com 9 elementos, os quais descreveremos abaixo:

F9 = {0, 1, 2, X, 2X, 1 + X, 1 + 2X, 2 + X, 2 + 2X}.

30

Capítulo 1. Um breve passeio pelas estruturas algébricas

Exemplo 1.29. Seja K = Z2 e P (X) = X 7 − 1. Observe que 1 é raiz de P (X). Logo
poderemos escrever

P (X) = (X + 1)(X 6 + X 5 + X 4 + X 3 + X 2 + X + 1).

Portanto, nesse caso, como P (X) é redutível, pelo teorema 1.26, o conjunto K[X]/P (X)
não é corpo. Poderemos continuar com a fatoração do polinômio Q(X) = X 6 + X 5 + X 4 +
X 3 + X 2 + X + 1. Como Q(X) não tem raízes em Z2 e gr(Q(X)) = 6, então poderemos
considerar que, ou Q(X) é irredutível, ou é produto de dois polinômios de grau 3, ou é
produto de três polinômios de grau 2. Veriﬁcando os possíveis casos, teremos que o único
polinômio de grau 2 irredutível sobre Z2[X] é X 2 + X + 1, e como (X 2 + X + 1)3 6= Q(X),
concluíremos que Q(X) só pode ser produto de dois polinômios irredutíveis de grau 3. Os
únicos casos de irredutíveis de grau 3 em Z2[X] são os polinômios X 3 + X + 1 e X 3 + X 2 + 1.
Logo poderemos veriﬁcar que

P (X) = X 7 − 1 = (X + 1)(X 3 + X + 1)(X 3 + X 2 + 1).

Proposição 1.30. Todo ideal de K[X]/P (X) é da forma I(F (X)), onde F (X) é um
divisor de P (X).

Demonstração. Seja I um ideal de K[X]/P (X). Considere o conjunto

J = {G(X) ∈ K[X]; G(X) ∈ I}.

Iremos mostrar que J é um ideal de K[X]. Para isso, considere G1(X) e G2(X) elementos
de J, o que signiﬁca que G1(X) e G2(X) estão em I. Desta maneira

G1(X) + G2(X) = G1(X) + G2(X) ∈ I

assim G1(X) + G2(X) ∈ J.

No entanto, se G(X) ∈ J e H(X) ∈ K[X], como efeito G(X) ∈ I, e sendo assim

G(X) · H(X) = G(X)H(X) ∈ I. Portanto, G(X)H(X) ∈ J.

Como P (X) ∈ J, logo J 6= {0}, segue da proposição 4.6. que existe F (X) ∈

K[X] \ {0} de forma que J = I(F (X)).

Como P (X) ∈ J = I(F (X)), segue que P (X) é um múltiplo de F (X), ou F (X) é

um divisor de P (X).

Agora observe que I = {G(X); G(X) ∈ J}, e como J = I(F (X)), poderemos

concluir que

I = {H(X) · F (X); H(X) ∈ K[X]/P (X)} = I(F (X)).

1.2. Noções de álgebra linear sobre corpos ﬁnitos

31

Para ﬁnalizar essa seção, veremos um exemplo de anel quociente que, apesar de
não ser um corpo, será de extrema importância para o estudo do capítulo sobre códigos
cíclicos.

Exemplo 1.31. O anel quociente Rn = K[X]/(X n − 1) onde seus elementos são da forma

F (X) = {F (X) + G(X)(X n − 1); G(X) ∈ K[X]}.

Observe que Rn não é um corpo, pois o polinômio X n − 1, para n ∈ Z, n (cid:62) 2 , não

é irredutível, pois sempre é divisível por X − 1.

Uma outra forma de veriﬁcar que Rn não é um corpo, é o fato de não ser um

domínio de integridade, pois como contraexemplo

X − 1 · X n−1 + · · · + X + 1 = X n − 1 = 0.

1.2 Noções de álgebra linear sobre corpos ﬁnitos

Estudaremos nesta seção, as noções básicas de álgebra linear necessárias para o

estudo de códigos cíclicos.

Deﬁnição 1.32. Seja K um corpo, cujos elementos são chamados de escalares. Um espaço
vetorial sobre K, ou um K-espaço vetorial, é um conjunto V , não vazio, munido de duas
operações, uma operação de adição

+ : V × V −→ V

(v, w)

7−→ v + w

e uma multiplicação dos elementos de V por escalares

· : K × V −→ V

(λ, v)

7−→ λ · v

possuindo as seguintes propriedades para quaisquer que sejam u, v, w ∈ V e λ, µ ∈ K:

(i) associatividade:

(u + v) + w = u + (v + w) e (λµ)v = λ(µv);

(ii) comutatividade da adição:

u + v = v + u;

(iii) vetor nulo: Existe 0 ∈ V de forma que u + 0 = u;

(iv) inverso aditivo: Existe − u ∈ V tal que u + (−u) = 0;

(v) distributividade:

(λ + µ)v = λv + µv e λ(u + v) = λu + λv;

(vi) multiplicação pela unidade de K:

1 · v = v.

32

Capítulo 1. Um breve passeio pelas estruturas algébricas

Um subespaço vetorial de um espaço vetorial V é um subconjunto W ⊂ V que com

as mesmas operações de adição e multiplicação de V , também é um K-espaço vetorial.

Deﬁnição 1.33. Seja V um espaço vetorial, um subconjunto W ⊂ V , não vazio, será um
subespaço de V , se satisfaz as seguintes condições:

1. 0 ∈ W ;

2. Para quaisquer u, v ∈ W , u + v ∈ W ;

3. Se v ∈ W , então para todo λ ∈ K, λv ∈ W.

Note que as condições 2 e 3 na deﬁnição 1.33 podem ser substituídas por:

4. W é um subespaço de V se for cumprida a condição:

∀ u, v ∈ W, ∀ λ ∈ K, u + λv ∈ W.

Os espaços vetoriais de dimensão ﬁnita possuem uma estrutura algébrica apresen-

tada pelas ideias de base e dimensão.

Um conjunto B = {v1, · · · , vn} de vetores linearmente independentes é um conjunto
cuja única combinação linear nula de seus vetores é aquela cujos coeﬁcientes são todos
iguais a zero. Em símbolos, temos

λ1v1 + · · · + λnvn = 0 =⇒ λ1 = · · · = λn = 0.

No caso em que os vetores de B não são linearmente independentes, eles serão chamados
linearmente dependentes. Isto signiﬁca que v1, · · · , vn são linearmente dependentes quando
existem escalares λ1, · · · , λn não todos nulos de modo que

λ1v1 + · · · + λnvn = 0.

Deﬁnição 1.34. Seja V um espaço vetorial. Uma base de V é um subconjunto B ⊂ V
linearmente independente que gera V . Ou seja, todo vetor v ∈ V pode ser representado de
forma única, como combinação linear dos elementos da base B.

Se um espaço vetorial V admite uma base com n elementos, então todas as bases
de V têm o mesmo número n de elementos. Este número é chamado de dimensão de V .

Deﬁnição 1.35. Sejam V e W dois K-espaços vetoriais. Uma transformação linear
T : V −→ W é uma aplicação que associa a cada vetor v ∈ V um vetor T (v) ∈ W de
forma que sejam veriﬁcadas para quaisquer u, v ∈ V e λ ∈ K as seguintes condições:

(i) T (u + v) = T (u) + T (v);

1.2. Noções de álgebra linear sobre corpos ﬁnitos

33

(ii) T (λ · v) = λ · T (v).

Dada a transformação linear T : V −→ W , existem dois subespaços essenciais para
o estudo do comportamento de T : o núcleo de T , que é subespaço de V , e a imagem de T ,
que é um subespaço de W .

Deﬁnição 1.36. A imagem de T é o subconjunto Im(T ) ⊂ W formado por todos os
vetores w = T (v) ∈ W que são imagens de elementos de V por T .

Diremos que a transformação T é sobrejetora se Im(T ) = W . Ou seja, para todo

w ∈ W , existe v ∈ V tal que T (v) = w.

Seja X = {v1, · · · , vn} um conjunto de vetores que geram V . A transformação
T : V −→ W é sobrejetora se, e somente se, transforma X num conjunto de geradores de
W . Isto signiﬁca que, se v1, · · · , vn geram V , os vetores T (v1), · · · , T (vn) geram W .

Deﬁnição 1.37. O núcleo da transformação linear T : V −→ W é o conjunto dos vetores
v ∈ V tais que T (v) = 0. Denotaremos o núcleo de T por N (T ).

Teorema 1.38. Uma transformação linear T : V −→ W é injetora se, e somente se,
N (T ) = {0}.

Teorema 1.39. Uma transformação linear é injetiva se, e somente se, leva vetores L.I.
em vetores L.I.

Deﬁnição 1.40. Diremos que uma transformação linear T : V −→ W é invertível quando
existe T −1 : W −→ V linear de forma que T −1T = IV e T T −1 = IW .

Uma transformação linear T é invertível se, e somente se, ela é injetiva e sobrejetiva.
Diremos então que T é uma bijeção linear entre V e W ou, mais precisamente, que
T : V −→ W é um isomorﬁsmo e que os espaços vetoriais V e W são isomorfos.

Teorema 1.41. (Teorema do Núcleo e da Imagem) Sejam V e W espaços vetoriais
de dimensão ﬁnita. Se T : V −→ W é uma transformação linear sobre um corpo K, então
dimKN (T ) + dimKIm(T ) = dimKV .

Como consequência do teorema do núcleo e da imagem, segue o resultado abaixo.

Corolário 1.42. Dados V e W espaços vetoriais de mesma dimensão ﬁnita n. Uma
transformação linear T : V −→ W é injetora se, e somente se, é sobrejetora e portanto é
um isomorﬁsmo.

Demonstração. De fato, sendo n = dimN (T ) + dimIm(T ). Logo N (T ) = 0 se, e somente
se, dimIm(T ) = n, isto signiﬁca que, Im(T ) = W .

34

Capítulo 1. Um breve passeio pelas estruturas algébricas

Exemplo 1.43. O anel quociente Rn = K[X]/(X n −1) do exemplo 1.31, com as operações
de soma deﬁnida por

e multiplicação por escalares λ ∈ K, deﬁnida por

f1(X) + f2(X) = f1(X) + f2(X)

λf (X) = λf (X),

é um k-espaço vetorial de dimensão n com base 1, X, · · · , X n−1.

De fato, a soma e a multiplicação por escalar é bem deﬁnida, satisfazendo as
propriedades da deﬁnição 1.32, e o conjunto {1, X, · · · , X n−1} é L.I. dado que λ0 + λ1X +
· · · + λn−1X n−1 se anula somente quando é multiplo de X n − 1. E nesse caso, isso ocorre
apenas quando λ0 = λ1 = . . . = λn−1 = 0.

Exemplo 1.44. Considere a aplicação

σ : K n
(a0, ..., an−1)

−→
7−→ a0 + a1X + ... + an−1X n−1.

Rn

Seja u, v ∈ K n e λ ∈ K com u = (u0, ..., un−1) e v = (v0, ..., vn−1). Assim,

σ(u + λv) = (u0 + λv0) + (u1 + λv1)X + ... + (un−1 + λvn−1)X n−1

= u0 + u1X + ... + un−1X n−1 + λ(v0 + v1X + ... + vn−1X n−1)

= u0 + u1X + ... + un−1X n−1 + λv0 + v1X + ... + vn−1X n−1

= σ(u) + λσ(v).

Logo σ é uma transformação linear e, pelo corolário 1.42 Rn é isomorfo a K n através de σ.

A ideia de isomorﬁsmo entre espaços vetoriais é imprescindível, pois nos permite
relacionar, sob a perspectiva algébrica, espaços que se apresentam de formas distintas
aparentemente, mas que são indistinguíveis algebricamente. Por exemplo, a correspondência
(a0, · · · , an−1) ←→ a0X + · · · + an−1X n−1, é um isomorﬁsmo natural entre K n e Pn−1,
onde Pn−1 é o espaço dos polinômios de grau menor ou igual a n − 1, que possui dimensão
n.

2 Códigos que corrigem erros

35

A Teoria dos códigos corretores de erros, hoje em dia, é muito aplicada nos campos
da engenharia, computação, matemática, entre outros. O objetivo principal dessa teoria é
de garantir com precisão e eﬁcácia, sempre que possível, a transferência, do remetente ao
receptor, da informação desejada. Para elaboração deste capítulo foram estudados (1), (6)
e (8).

Fundada pelo matemático Claude E. Shannon, num artigo publicado em 1948,
intitulado "A Mathematical Theory of Communications", a Teoria dos Códigos Corretores
de Erros foi inicialmente de interesse dos matemáticos, que foram responsáveis por grande
parte do desenvolvimento da Teoria nas décadas de 50 e 60. Nesse período se destacam a
construção dos códigos de Hamming, para simples correção de erros, e a construção dos
poderosos códigos de Reed-Solomon. Na década de 70, com as pesquisas avançadas nas
explorações espaciais e o advento da popularização dos computadores, houve também o
interesse dos engenheiros no estudo dos códigos corretores de erros.

Para um bom esclarecimento da ideia dessa teoria, usaremos um exemplo. Supo-
nhamos que uma máquina de impressão utiliza as cores Ciano, Magenta, Amarelo e Preto,
para desenvolver o seu trabalho. E que ao darmos o comando de impressão ela receba a
informação das cores que serão usadas para realizar a impressão.

Poderemos codiﬁcar as quatro cores acima como elementos de {0, 1} × {0, 1}, da

seguinte forma:

Ciano
Magenta

7−→ 00
7−→ 01

Amarelo
Preto

7−→ 10
7−→ 11

Admitiremos agora que essas mensagens sejam transmitidas de um computador
via cabo para nossa máquina de impressão e que durante a transmissão ocorra alguma
interferência. Imagine que no lugar da mensagem 10 transmitida, recebamos a mensagem
11. Isto nos traria um problema, pois onde seria usado a cor Amarelo, agora, com o erro de
transmissão, será usado a cor Preto. Dessa forma se faz necessário recodiﬁcar as mensagens
inserindo dígitos de redundância, que permitam detectar e corrigir erros.

Assim, por exemplo, poderemos modiﬁcar o nosso código de acordo com a tabela

abaixo:

36

Capítulo 2. Códigos que corrigem erros

Fonte Código da fonte Código de canal

Ciano

Magenta

Amarelo

Preto

00

01

10

11

00000

01011

10110

11101

Nessa nova recodiﬁcação, a primeira coluna da tabela, chamada de fonte, representa
a mensagem original. Na segunda coluna temos o código da fonte; e na terceira coluna o
código de canal, que nos permite detectar e corrigir possíveis erros na transmissão.

Imagine agora que durante uma transmissão da palavra 10110 ocorra um erro e a
palavra recebida seja 10010. Realizando uma comparação dessa mensagem recebida, com
as mensagens do código, perceberemos que ela não pertence ao código, assim saberemos
que existe um erro e, portanto veriﬁcaremos que a palavra do código que tem o menor
número de componentes distintos da palavra recebida é 10110, que é corretamente a
palavra transmitida.

A ﬁgura 1 abaixo representa bem o procedimento de transmissão da informação.

Figura 1 – Esquema de Transmissão da Informação

Fonte: Elaborada pelo autor

O canal é o meio pelo qual a mensagem é transmitida. Por exemplo, pode ser um
cabo, um canal de radiofrequência, canal de micro-ondas, disco de armazenamento, ou
qualquer outro meio que represente uma rede de comunicação.

Nesse trabalho, abordaremos bem todo processo do esquema da ﬁgura 1, enfatizando

a detecção e correção de erros, sempre que possível.

2.1 A métrica de Hamming

Para entender como construir um código corretor de erros, inicialmente deﬁniremos

alguns conceitos básicos e notações que utilizaremos a partir daqui.

Um alfabeto é um conjunto ﬁnito Aq = {a1, a2, · · · , aq}.

2.1. A métrica de Hamming

37

Usaremos |A| para denotar a quantidade de elementos do conjunto A, e o símbolo

q para representar essa quantidade.

Uma palavra é uma sequência ﬁnita de símbolos do alfabeto. Ao número de símbolos

de uma palavra chamamos de seu comprimento.

Um código corretor de erros é um subconjunto de An

q , para n natural, onde n é o

comprimento das palavras do código.

Deﬁnição 2.1. Seja u e v elementos de An
como

q , a distância de Hamming entre u e v é deﬁnida

d(u, v) = |{i; ui 6= vi, 1 (cid:54) i (cid:54) n}|.

Exemplo 2.2. Considere o exemplo da máquina de impressão apresentado no início deste
capítulo. Assim teremos

d(01011, 10110) = 4
d(00000, 01011) = 3

Proposição 2.3. Dados u, v, w ∈ An

q , valem as seguintes propriedades:

1. Positividade: d(u, v) (cid:62) 0, valendo a igualdade se, e somente se, u = v.

2. Simetria: d(u, v) = d(v, u).

3. Desigualdade Triangular: d(u, v) (cid:54) d(u, w) + d(w, v).

Demonstração. Para primeira propriedade, como d(u, v) é por deﬁnição a quantidade
de elementos de um conjunto, não pode ser negativa. Para segunda propriedade, basta
veriﬁcar que comparar as coordenadas entre duas palavras u e v independe da ordem das
palavras. Na terceira propriedade, temos dois casos:

i) Se ui = vi, para todo i, então por deﬁnição d(u, v) = 0. E por (1.) segue que

d(u, v) (cid:54) d(u, w) + d(w, v).

ii) Se ui 6= vi, não podemos ter ui = wi e wi = vi, logo segue que

d(u, v) (cid:54) d(u, w) + d(w, v).

Deﬁnição 2.4. Dado um conjunto X , uma métrica sobre X é uma função

d : X × X −→ R

que goza das propriedades da proposição 2.3. Por isso, a distância de Hamming entre
elementos de An

q é também chamada de métrica de Hamming.

38

Capítulo 2. Códigos que corrigem erros

Deﬁnição 2.5. Dados a ∈ An
e raio t, como sendo, respectivamente, os conjuntos ﬁnitos

q e t ∈ R, com t (cid:62) 0, deﬁnimos a bola e a esfera de centro a

B(a, t) = {u ∈ An

q ; d(u, a) (cid:54) t},

S(a, t) = {u ∈ An

q ; d(u, a) = t}.

O próximo lema nos fornecerá as cardinalidades desses conjuntos.

Lema 2.6. Quaisquer que sejam a ∈ An

q e r > 0, com r ∈ N, tem-se que

|B(a, r)| =

!

(q − 1)i.

r
X

i=0

 n
i

Demonstração. Primeiro vamos mostrar que

|S(a, i)| =

!

(q − 1)i.

 n
i

Como a ∈ An
q , logo precisaremos escolher i componentes dentre as n possibilidades.
maneiras. Agora basta trocar o símbolo de cada uma
Essa escolha pode ser feita de
das i componentes escolhidas, onde para cada uma teremos q − 1 possibilidades, daí segue
o resultado.

(cid:16)n
i

(cid:17)

Observe que S(a, i) ∩ S(a, j) = ∅ sempre que i 6= j. Assim segue que

Assim, obteremos que

r
[

i=0

S(a, i) = B(a, r).

|B(a, r)| =

r
X

i=0

!

 n
i

(q − 1)i.

Deﬁnição 2.7. Seja C um código. A distância mínima de C é o número

d = min{d(u, v); u, v ∈ C e u 6= v}.

Observe, na tabela a seguir, que no exemplo do código da máquina de impressão,

dado no início desse capítulo, a distância mínima é d = 3.

u

v

d(u, v)

00000

01011

00000

10110

00000

11101

01011

10110

01011

11101

10110

11101

3

3

4

4

3

3

2.1. A métrica de Hamming

39

Deﬁnição 2.8. Sejam a, b ∈ Z. Chamaremos de parte inteira de

ou igual a

a
b

. Denotaremos por b

a
b

c.

a
b

o maior inteiro menor

3
2
c = 1.

Por exemplo, considerando a = 3 e b = 2, a parte inteira de

é o maior inteiro na

reta real que aparece a esquerda do número

3
2

. E portanto, b

3
2

Observação 2.9. Escrevendo a divisão euclidiana de a por b, obteremos

temos

e, portanto

a = bq + r,

com 0 (cid:54) r < b,

bq (cid:54) bq + r < bq + b,

bq (cid:54) a < b(q + 1)

dividindo a desigualdade por b, segue que

q (cid:54) a
b

< q + 1.

Logo o quociente q da divisão euclidiana é o maior inteiro menor ou igual a

a
b

.

Deﬁnição 2.10. Dado um código C, com distância mínima d, deﬁne-se k = b

d − 1
2

c.

Lema 2.11. Dado C um código com distância mínima d. Se c e c0 são palavras distintas
de C, então

B(c, k) ∩ B(c0, k) = ∅.

Demonstração. Se x ∈ B(c, k) ∩ B(c0, k), então d(x, c) (cid:54) k e d(x, c0) (cid:54) k, e, pela simetria,
pela desigualdade triangular e pela Observação 2.9,

d(c, c0) (cid:54) d(c, x) + d(x, c0) (cid:54) 2k (cid:54) d − 1,

que é um absurdo, pois d(c, c0) (cid:62) d.

O resultado a seguir, mostrará a importância da distância mínima d de um código.

Teorema 2.12. Seja C um código de distância mínima d e k = b
detectar até d − 1 erros e corrigir até k erros.

d − 1
2

c. Então C pode

Demonstração. Se durante a transmissão de uma palavra c do código ocorre i erros, com
i (cid:54) k, e receberemos a palavra r, então d(r, c) = i (cid:54) k. Mas pelo Lema 2.11, como
B(c, k) ∩ B(c0, k) = ∅ e r ∈ B(c, k), então r /∈ B(c0, k), ou seja, a distância de r a qualquer

40

Capítulo 2. Códigos que corrigem erros

outra palavra do código diferente de c é maior de que k. Assim, temos que a palavra c
está univocamente determinada a partir de r.

Para detecção de erros, dada uma palavra do código, é possível inserir nela até
d − 1 erros, sem encontrar outra palavra do código, possibilitando assim a detecção do
erro.

Observe que pelo Teorema 2.12 acima, quanto maior for a distância mínima d
maior a capacidade de correção do código, porém aumentar a distância mínima siginiﬁca
aumentar o comprimento das palavras do código, então para obtermos bons códigos de
correção de erros, é fundamental encontrar um equilíbrio entre esses parâmetros. Isso torna
a distância mínima fundamental na Teoria dos Códigos. O teorema ainda nos diz que, se
uma palavra recebida r encontra-se numa bola de raio k cujo centro é uma palavra c do
código, essa palavra c é única, sendo c a palavra do código enviada.

Deﬁnição 2.13. Dado C ⊂ An

q um código com distância mínima d e seja k = b

d − 1
2

c. Se

B(c, k) = An
q ,

[

c∈C

então o código C será chamado de código perfeito.

Deﬁnição 2.14. Seja a ∈ An

q , o peso de a é deﬁnido como

ou seja, é o número de coordenadas não nulas de a.

ω(a) := |{i; ai 6= 0}|,

Em particular, o peso de um código C ⊂ An

q é o inteiro

ω(C) := min{ω(a); a ∈ C\{0}}.

Proposição 2.15. Seja C ⊂ An
a subtração, então vale a seguinte igualdade:

q um código com distância mínima d. Se C é fechado para

d = min{ω(a); a ∈ C, a 6= 0}.

Demonstração. Sejam a, a0 ∈ C. Como C é fechado para subtração, (a − a0) ∈ C. Assim
a contribuição das i-ésimas coordenadas de a e a0 para d(a, a0) é zero se ai − a0

i = 0.

No caso em que a contribuição das i-ésimas coordenadas de a e a0 para d(a, a0) é
i 6= 0. Portanto d(a, a0) = ω(a − a0). Concluíremos dessa

igual a um, teremos que ai − a0
forma que

d = min{d(a, a0); a, a0 ∈ C e a 6= a0} = min{ω(b); b ∈ C, b 6= 0}.

onde b = a − a0.

Assim a proposição acima nos fornece uma forma mais simples de encontrar a
distância mínima, em que basta veriﬁcar a palavra que mais se aproxima do vetor nulo.

2.2. O problema fundamental da teoria dos códigos

41

2.2 O problema fundamental da teoria dos códigos

Um código C sobre um alfabeto Aq é bem determinado por três parâmetros
fundamentais [n, M, d], onde n é o seu comprimento, M o número de palavras do código,
e d a sua distância mínima. Para um código ter uma boa eﬁciência, é desejável que M e
d sejam grandes em relação a n. Mas construir códigos que satisfazem essa relação é o
problema principal da teoria dos códigos.

No que se refere a essa interdependência entre os parâmetros de um código, exis-
tem alguns resultados desenvolvidos para análise do problema. O leitor interessado nas
demonstrações dos resultados abaixo deve consultar (1).

Teorema 2.16. (Cota de Singleton) Seja C um código com parâmetros [n, M, d], deﬁnido
sobre um alfabeto Aq. A seguinte relação é veriﬁcada.

M (cid:54) qn−d+1.

Teorema 2.17. (Cota de Hamming) Seja C um código com parâmetros [n, M, d]. Se

k = b

d − 1
2

c, então

M (cid:54)

Pr

i=0

qn
(cid:17)

(cid:16)n
i

(q − 1)i

,

valendo a igualdade se, e só se, C é um código perfeito.

Analisando o problema de um outro ponto de vista, considere a função:

Aq(n, d) = max{M ; existe um código com parâmetros [n, M, d]}.

Deﬁnição 2.18. Um código Aq com os parâmetros [n, M, d] se diz ótimo se M = Aq(n, d).

Pouco se sabe ainda sobre Aq(n, d). Porém, segue abaixo um dos resultados obtidos,

em relação à cota de Hamming, que limita esses valores.

Corolário 2.19. Para todos os números naturais n e d, segue que

Aq(n, d) (cid:54)

Pr

i=0

qn
(cid:17)

(cid:16)n
i

(q − 1)i

.

O próximo resultado nos dará uma cota inferior para Aq(n, d), descoberta indepen-

dentemente por Gilbert em 1952 e por Varshamov em 1957.

Teorema 2.20. (Cota de Gilbert-Varshamov) Para todos os números naturais n e d com
n (cid:62) d, segue que

Aq(n, d) =

Pd−1
i=0

qn
(cid:17)

(cid:16)n
i

.

(q − 1)i

3 Códigos cíclicos

43

Os códigos cíclicos se tornam atraentes por terem uma estrutura algébrica de fácil
implementação, que nos possibilita encontrar vários métodos práticos para codiﬁcação e
decodiﬁcação. Para o desenvolvimento deste capítulo foram estudados (1), (5), (7) e (9).

3.1 Caracterização dos códigos cíclicos

Seja K um corpo ﬁnito e seja v = (v0, v1, ..., vn−1) ∈ K n. Ao deslocarmos cada
coordenada de v uma vez para a direita, e a última coordenada para a posição da primeira,
obtemos um novo vetor v(1) = (vn−1, v0, ..., vn−2) ∈ K n. Esse procedimento é o que
chamamos de deslocamento cíclico de v à direita, cuja ordem é 1. Analogamente, podemos
realizar um deslocamento cíclico de v à esquerda.

Se as coordenadas de v forem deslocados ciclicamente i vezes para a direita, o
vetor resultante seria v(i) = (vn−i, vn−i+1, ..., vn−1, v0, ..., vn−i−1). Observe que deslocar
ciclicamente v i vezes para a direita é equivalente a deslocar ciclicamente v n − i vezes
para a esquerda.

Deﬁnição 3.1. Seja K um corpo ﬁnito e seja C ⊂ K n. Dizemos que C é um código cíclico
se:

i. C é um subespaço de K n;

ii. se para todo v ∈ C temos v(1) ∈ C.

Da deﬁnição de códigos cíclicos dada acima, concluímos que C ⊂ K n é um espaço
vetorial de dimensão ﬁnita. Seja k a dimensão de C e b1, · · · , bk uma base de C, todos os
elementos de C podem ser escritos da forma

λ1b1 + · · · + λkbk,

em que λi ∈ K com i = 1, · · · , k. Assim denotaremos por C(n, k) um código cíclico
C ⊂ K n de comprimento n e dimensão k.

Exemplo 3.2. São exemplos de códigos cíclicos "não interessantes", os códigos C = 0,
onde 0 é o vetor nulo, e C = K n.

Sabemos que uma forma de obter subespaços de K n é considerar os espaços gerados
por um conjunto ﬁnito de vetores de K n. Mostramos, no próximo exemplo, que dado
v ∈ K n o subespaço C = hv, v(1), . . . , v(n−1)i é um código cíclico. Além disso, no corolário

44

Capítulo 3. Códigos cíclicos

3.8, mostramos que dado um código cíclico C de comprimento n, existe um vetor v ∈ K n tal
que C = hv, v(1), . . . , v(n−1)i. Para simpliﬁcar a notação usamos C = hvi para representar
C = hv, v(1), . . . , v(n−1)i.

Exemplo 3.3. Seja K um corpo ﬁnito e seja v ∈ K n. Então C = hvi é um código cíclico.

Basta mostrar que, se dado um vetor arbitrário u ∈ C = hv, v(1), . . . , v(n−1)i, então

u(1) ∈ C.

Então dada a matriz

V =











v
v(1)
...
v(n−1)











=











v0
v1
vn−1 v0
...
...
v2
v1











.

. . . vn−1
. . . vn−2
...
. . .
v0
. . .

E seja

(cid:16)

Λ =

λ0 λ1

. . . λn−1

(cid:17)

em que λ0, λ1, . . . , λn−1 ∈ K. Considerando

u = λ0v + λ1v(1) + . . . + λn−1v(n−1) = ΛV.

Observe que ΛV = u e u(1) = Λ(1)V .











|

λ0v0 + λ1vn−1 + . . . + λn−1v1
λ0v1 + λ1v0 + . . . + λn−1v2
...
λ0vn−1 + λ1vn−2 + . . . + λn−1v0
{z
ut





















λ0vn−1 + λ1vn−2 + . . . + λn−1v0
λ0v0 + λ1vn−1 + . . . + λn−1v1
...
λ0vn−2 + λ1vn−3 + . . . + λn−1vn−1
{z
(u(1))t

.











}

}

|

Deslocar cíclicamente para direita as coordenadas do vetor u é o mesmo que deslocar

ciclicamente as constantes na combinação linear dos vetores v, v(1), . . . , v(n−1). Assim

u(1) = λn−1v + λ0v(1) + . . . + λn−2v(n−1) ∈ C = hvi.

Em particular, considere K = F2 e seja v = (10011001) ∈ K 8. Como v(4) = v segue

que

C = hvi = K(10011001) + K(11001100) + K(01100110) + K(00110011)

(3.1)

Como K = F2 é um corpo com dois elementos então C é um código em exatamente

8 palavras, mais especiﬁcamente,

C = {(10011001), (01010101), (00110011), (00000000),

3.1. Caracterização dos códigos cíclicos

45

(11001100), (10101010), (01100110), (11111111)}.

A partir de agora vamos mostrar alguns resultados que relacionam cada código
cíclico com um polinômio irredutível no anel Rn = K[X]/(X n − 1), deﬁnido no exemplo
1.31. Lembre-se que no exemplo 1.43 mostramos que Rn também é um espaço vetorial.

Considerando a aplicação

σ : K n
(a0, ..., an−1)

−→
7−→ a0 + a1X + ... + an−1X n−1

Rn

temos, pelo Corolário 1.42, Rn é isomorfo a K n através de σ.

Dessa forma, todo código C ⊂ K n pode ser transportado para Rn mediante o
isomorﬁsmo σ. A vantagem de estudar os códigos em Rn é que, além de uma estrutura de
espaço vetorial, Rn tem também uma estrutura de anel.

Dado v um vetor de K n, chamaremos de v(i)(X) o polinômio associado ao vetor

v(i) = (vn−i, vn−i+1, . . . , vn−1, v0, . . . , vn−i−1) dado por

vn−i + vn−i+1X + . . . + vn−i−1X n−1.

Existe uma relação algébrica interessante entre v(X) e v(i)(X).

Lema 3.4. Em Rn, X iv(X) = v(i)(X).

Demonstração. Multiplicando v(X) por X i, obtemos

X iv(X) = v0X i + v1X i+1 + ... + vn−i−1X n−1 + ... + vn−1X n+i−1.

A equação acima pode ser manipulada da seguinte forma:

X iv(X) = vn−i + vn−i+1X + ... + vn−1X i−1 + v0X i + ... + vn−i−1X n−1+

+vn−i(X n − 1) + vn−i+1X(X n − 1) + ... + vn−1X i−1(X n − 1)

= q(X)(X n − 1) + v(i)(X),

onde q(X) = vn−i + vn−1+1X + ... + vn−1X i−1. Vemos que o polinômio do código v(i)(X) é
simplesmente o resto da divisão do polinômio X iv(X) por X n − 1.

Lema 3.5. Seja V um subespaço vetorial de Rn. Então, V é um ideal de Rn se, e somente
se, V é fechado pela multiplicação por X.

Demonstração. Observe que se V é um ideal de Rn, então pela deﬁnição de ideal, segue
que X · f (X) ∈ V , qualquer que seja f (X) ∈ V .

46

Capítulo 3. Códigos cíclicos

Reciprocamente, V é um subespaço vetorial, logo é fechado pela soma e multiplica-
ção por escalar. Suponha que V seja fechado pela multiplicação por X. Vamos veriﬁcar
que qualquer que seja g(X) ∈ Rn, e para todo f (X) ∈ V , obtemos g(X) · f (X) ∈ V .

Seja f (X) ∈ V . Temos que para todo a ∈ K, a · f (X) ∈ V . Como

X · f (X) = Xf (X) ∈ V,

então

X · Xf (X) = X 2 · f (X) = X 2f (X) ∈ V.

De modo indutivo, obtemos, para todo m ∈ N, que

X m · f (X) = X mf (X) ∈ V.

Assim, escrevendo g(X) = a0 + a1X + ... + an−1X n−1 temos que

g(X) · f (X) = g(X)f (X) = (a0 + a1X + ... + an−1X n−1)f (X) =

a0f (X) + a1X · f (X) + ... + an−1X n−1 · f (X) ∈ V,

pois V é subespaço e cada termo da última expressão pertence a V .

A discussão acima, juntamente com o Lema 3.5, provam o seguinte teorema:

Teorema 3.6. Um subespaço C de K n é um código cíclico se, e somente se, σ(C) é um
ideal de Rn.

Assim, pela Proposição 1.30, podemos concluir que um código C em K n é cíclico se,
e somente se, σ(C) = I(g(X)), onde g(X) ∈ K[X] é um divisor de X n − 1. Isto signiﬁca
que, ao realizarmos a decomposição de X n − 1 em fatores irredutíveis, obtemos todos os
possíveis códigos cíclicos C ⊂ K n.

Teorema 3.7. Seja I = I(g(X)), onde g(X) é um divisor de X n − 1 de grau r. Temos
que g(X), Xg(X), X 2g(X), ..., X n−r−1g(X) é uma base de I como espaço vetorial sobre K.

Demonstração. Admitimos que

a0g(X) + a1Xg(X) + ... + an−k−1X n−r−1g(X) = 0.

Assim,

g(X) · a0 + a1X + ... + an−r−1X n−r−1 = 0.

Desse modo, existe d(X) ∈ K[X], tal que

g(X)(a0 + a1X + ... + an−r−1X n−r−1) = d(X) · (X n − 1).

3.1. Caracterização dos códigos cíclicos

47

Dividindo ambos os membros da última equação por g(X), obtemos

a0 + a1X + ... + an−r−1X n−r−1 = d(X) · h(X).

Como o grau de h(X) é n − r > n − r − 1, devemos ter a0 + a1X + ... + an−r−1X n−r−1 = 0,
e consequentemente, a0 = a1 = an−r−1 = 0.

Portanto os elementos acima são linearmente independentes.

Para ﬁnalizarmos, mostramos que g(X), Xg(X), X 2g(X), ..., X n−r−1g(X) geram I

sobre K. Se f (X) ∈ I, temos que

f (X) ≡ d(X) · g(X) mod (X n − 1).

Pelo algoritmo da divisão, temos que d(X) = c(X) · h(X) + r(X), com r(X) = a0 + a1X +
... + an−r−1X n−r−1. Assim

f (X) ≡ d(X) · g(X) ≡ c(X) · h(X) · g(X) + r(X) · g(X) mod (X n − 1),

Logo

Portanto

f (X) ≡ c(X) · (X n − 1) + r(X) · g(X) ≡ r(X) · g(X) mod (X n − 1).

f (X) = a0g(X) + a1Xg(X) + ... + an−r−1X n−r−1g(X).

Corolário 3.8. Dado um código cíclico C, existe v ∈ C tal que C = hvi.

Demonstração. Seja I = σ(C). Logo I é gerado como K-espaço vetorial por

g(X), Xg(X), ..., X n−r−1g(X),

onde g(X) é um divisor de X n − 1 de grau r. Assim colocando v = σ−1(g(X)), temos que
C é gerado por v, v(1), ..., v(n−r−1) e, portanto, C = hvi.

Observe que pela demonstração do corolário acima e pelo Teorema 3.7 a dimensão

de C é n − r onde r é o grau de g(X).

Exemplo 3.9. Considere o polinômio X 3 − 1 sobre F2 e sua fatoração dada por

X 3 − 1 = (X + 1)(X 2 + X + 1).

Note que o código cíclico C(3, 2) é determinado pelo polinômio X + 1, divisor de X 3 − 1,
de grau r = 1.

Dessa forma, sendo v = σ−1(X + 1) = 110, segue do Corolário 3.8 que C(3, 2) =

h110i.

Analogamente, o código cíclico C(3, 1) determinado por X 2 + X + 1, divisor de

X 3 − 1 é gerado por 111, ou seja C(3, 1) = h111i.

48

Capítulo 3. Códigos cíclicos

3.2 Matriz geradora

A matriz geradora de um código cíclico tem um papel fundamental na codiﬁcação
de uma palavra do código fonte para o código de canal, ou seja, com ela inserimos os
dígitos de redundância na mensagem.

Deﬁnição 3.10. Sejam K um corpo ﬁnito e C ⊂ K n um código cíclico. Dada B =
{v1, ..., vk} uma base ordenada de C, a matriz geradora de C associada à base B é a
matriz G, cujas linhas são os vetores vi = (vi1, ..., vin), i = 1, ..., k, isto é,

G =








v1
...
vk








=








v11 v12
...
...
vk1 vk2








.

· · · v1n
...
· · · vkn

Para entender melhor a função da matriz geradora, considere a transformação

linear deﬁnida por

T : K k −→ K n
7−→ xG

x

.

Note que para x = (x1, ..., xk), temos

T (x) = xG = x1v1 + · · · + xkvk,

logo T (K k) = C. Assim consideramos K k como sendo o código da fonte, C o código do
canal e a transformação T uma codiﬁcação.

Como para cada base β temos uma matriz geradora de C, podemos escolher β de
modo conveniente. Uma outra base de C pode ser obtida de β através de uma sequência
de operações do tipo:

(V1) Permutação de vetores.

(V2) Multiplicação de um vetor por um escalar não nulo.

(V3) Adição de um múltiplo escalar de um vetor a outro vetor.

Estas operações estão intrinsecamente ligadas a operações com as linhas da matriz
G. Assim uma matriz geradora de C pode ser obtida de G por uma sequência de operações
do tipo:

(L1) Permutação de duas linhas.

(L2) Multiplicação de uma linha por um escalar não nulo.

3.2. Matriz geradora

49

(L3) Adição de um múltiplo escalar de uma linha a outra.

Deﬁnição 3.11. Uma matriz geradora G de um código C está na forma padrão se tivermos

(cid:16)

G =

A | Idk

(cid:17)

,

onde Idk é a matriz identidade k × k e A uma matriz k × (n − k).

Da deﬁnição de matriz geradora e dos resultados anteriores em relação ao estudo

dos códigos cíclicos, segue corolário abaixo:

Corolário 3.12. Seja g(X) = g0 + g1X + · · · + grX r um divisor de X n − 1 de grau r. Se
I = I(g(X)), então

e o código C = σ−1(I) tem matriz geradora

dimKI = n − r,











G =

σ−1(g(X))
σ−1(Xg(X))
...
σ−1(X n−r−1g(X))











=











g0
0
...
0

g1
g0
...
· · ·

· · ·
g1
...
0

gr
· · ·

g0

0
gr
...
· · ·











· · ·
· · ·

0
0
...
· · · gr

Analisamos a seguir uma outra forma de determinar uma matriz geradora de C na

forma padrão

(cid:16)
R | Idk

(cid:17)

.

Para o que se segue, denotamos por K[X]r−1 o espaço vetorial dos polinômios de

grau menor ou igual a r − 1.

Considere o isomorﬁsmo θ abaixo que será de fundamental importância para o

resultado em seguida.

θ : K r
(a0, ..., ar−1)

−→
7−→ [a0 + a1X + ... + ar−1X r−1]

K[X]r−1 ⊂ K[X]

Teorema 3.13. Seja C ⊂ K n um código cíclico. Suponhamos que C = σ−1(I), em que
I = I(g(X)), com g(X) um divisor de X n − 1 de grau r. Seja R a matriz (n − r) × r
cuja i-ésima linha é

Ri = −θ−1(si(X)),

1 ≤ i ≤ n − r,

onde si(X) é o resto da divisão de X r−1+i por g(X). Então (R | Idn−r) é uma matriz
geradora de C.

Demonstração. Sejam qi(X) e si(X) o quociente e o resto da divisão de X r−1+i por g(X).
Assim teremos

X r−1+i = g(X)qi(X) + si(X),

com si(X) = 0 ou gr(si(X)) ≤ r − 1.

50

Capítulo 3. Códigos cíclicos

Logo X r−1+i − si(X) = g(X)qi(X). Portanto X r−1+i − si(X) pertence a I e evidente-
mente esses vetores para i = 1, ..., n − r são linearmente independentes sobre K. Como
σ−1(X r−1+i − si(X)) = er−1+i − θ−1(si(X)), temos que a matriz











−θ−1(s1(X))
−θ−1(s2(X))
...

1 0 · · · 0
0 1 · · · 0
...
...
−θ−1(sn−r(X)) 0 0 · · · 1

...











é uma matriz geradora de C.

Exemplo 3.14. Considere o exemplo C(7, 4), onde g(X) = 1 + X + X 3. Temos que n = 7,
k = 4 e r = 3. Vamos determinar a matriz geradora desse código na forma padrão, de
acordo com o Teorema 3.13. Assim

X 3 = (X 3 + X + 1) + (X + 1)

X 4 = (X 3 + X + 1)X + (X 2 + X)

X 5 = (X 3 + X + 1)(X 2 + 1) + (X 2 + X + 1)

X 6 = (X 3 + X + 1)(X 3 + X + 1) + (X 2 + 1)

Portanto basta observar os restos das divisões acima, que nos fornece a matriz

geradora (R | Id4) de C, dada por

G0 =











1 1 0 1 0 0 0
0 1 1 0 1 0 0
1 1 1 0 0 1 0
1 0 1 0 0 0 1











.

Para o estudo da codiﬁcação, essa segunda forma de construir a matriz geradora de
C é mais interessante. Vemos essa relação na Seção 3.4, na qual abordamos a codiﬁcação
de códigos cíclicos.

3.3 Códigos duais - matriz teste de paridade

Seja hu, vi o produto interno usual de vetores em K n. O complemento ortogonal

de um código cíclico C ⊂ K n é o conjunto

C ⊥ = {v ∈ K n; hv, ui = 0, ∀ u ∈ C}.

Lema 3.15. Se C ⊂ K n é um código cíclico, com matriz geradora G, então

i) C ⊥ é um subespaço de K n;

3.3. Códigos duais - matriz teste de paridade

51

ii) v ∈ C ⊥ ⇐⇒ Gvt = 0.

Demonstração. (i) Sejam u, v ∈ C ⊥ e λ ∈ K. Para todo w ∈ C, tem-se:

hu + λv, wi = hu, wi + λhv, wi = 0,

portanto hu + λv, wi ∈ C ⊥, mostrando que C ⊥ é um subespaço vetorial de K n.

(ii) v ∈ C ⊥ se, e somente se, v é ortogonal a todos os vetores de C e portanto ortogonal

à base de C. Como as linhas de G formam uma base de C, logo Gvt = 0.

Da deﬁnição acima e do Lema 3.15 segue que C ⊥ é um subespaço de K n, ortogonal

a C, e também um código cíclico ao qual chamamos de código dual de C.

Vamos agora estudar uma matriz fundamental no processo de decodiﬁcação de uma
palavra recebida. Ela nos permite identiﬁcar erro na palavra recebida e corrigir quando
possível, o que minimiza os erros no processo de transmissão.

Como consequência do Lema 3.15 , x = (x1, · · · , xn) pertence a C ⊥ se, e somente

se, Gxt = 0. Como G está na forma padrão, isso equivale a ter

Gxt =











s11
s21
...
s(n−r)1

que equivale a

s1r
a2r
...

· · ·
1 0 · · · 0
0 1 · · · 0
· · ·
...
...
...
. . .
· · · s(n−r)r 0 0 · · · 1

...





















x1
x2
...
xn











=





















xr+1
xr+2
...
xn

+ R ·

·











= 0











x1
x2
...
xr





















xr+1
xr+2
...
xn

= −R ·











.











x1
x2
...
xr

Portanto C ⊥ possui qn−k elementos, que são justamente as possíveis escolhas arbitrárias
de xk+1, · · · , xn. Logo C ⊥ tem dimensão n − k. Devido ao bloco Idn−k, podemos perceber
que as linhas da matriz H são linearmente independentes e, portanto geram um subespaço
vetorial de dimensão n − k.

Observação 3.16. Como as linhas de H são ortogonais às linhas de G, temos que o espaço
gerado pelas linhas de H está contido em C ⊥; e como esses dois espaços têm mesma
dimensão, eles coincidem, provando assim que H é uma matriz geradora de C ⊥.

A matriz geradora H de C ⊥ é chamada de matriz teste de paridade de C.

52

Capítulo 3. Códigos cíclicos

Teorema 3.17. A matriz teste de paridade de C é da forma H = (Idr | − Rt) =











.











L1
L2
...
Lr

Demonstração. Dado

R =











R1
R2
...
Rn−r











,

onde Ri = −θ−1(si(X)) e si(X) ≡ X n−1+i mod G(X), queremos provar que

(i) as linhas de H são ortogonais a todo vetor de C;

(ii) as linhas de H são linearmente independentes.

(i) Lembre que a matriz geradora de C é da forma (R | Idn−r) e as linhas dessa

matriz é base de C.

Seja aij os elementos da matriz H e bij os elementos de G, em que G é a matriz
geradora de C. Observe que ai(r+j) = −bji pela deﬁnição de H. Assim, sendo Li, L0
j
respectivamente as linhas das matrizes H e G, em que 1 (cid:54) i (cid:54) r e 1 (cid:54) j (cid:54) n − r,
temos que

H · Gt = hLi, L0

ji = bji + ai(r+j) = bji − bji = 0.

(ii) Sejam λ1, · · · , λr ∈ K tais que

λ1L1 + · · · + λrLr = 0,

e suponha que λi 6= 0 para algum i = 1, · · · , r. Daí

Li = −

λ1
λi

L1 − · · · −

λi−1
λi

Li−1 −

λi+1
λi

Li+1 − · · · −

λr
λi

Lr.

Como a i-ésima coordenada de Li é 1 e as coordenadas dos Lj (j 6= i) são 0, temos
um absurdo. Logo λi = 0 para todo i = 1, · · · , r.

Deﬁnição 3.18. Seja C um código cíclico com matriz teste de paridade H e um vetor
v ∈ K n, chamamos o vetor Hvt de síndrome de v.

O resultado a seguir nos permite utilizar a matriz H para caracterizar os elementos

de um código cíclico C por uma condição de anulamento.

3.3. Códigos duais - matriz teste de paridade

53

Proposição 3.19. Seja C um código cíclico e suponhamos que H seja uma matriz geradora
de C ⊥. Temos então que

v ∈ C ⇐⇒ Hvt = 0.

Demonstração. Seja G a matriz geradora de C. Logo G · H t = 0. Tomando as transpostas
nessa última igualdade, temos que H · Gt = 0, logo, G é matriz geradora de (C ⊥)⊥. Assim,
v ∈ (C ⊥)⊥ se, e somente se, Hvt = 0.

Para veriﬁcar se um determinado vetor v pertence ou não a um código C com
matriz geradora G, é necessário veriﬁcar se o sistema de n equações com k incógnitas
x = (x1, ..., xk), dado por

xG = v,

admite solução. Em geral, resolver esse sistema requer um custo computacional elevado,
especialmente quando se tem um código de comprimento n grande. Porém, utilizando a
matriz teste de paridade H, basta veriﬁcar se o vetor Hvt é nulo, que é bem mais simples.

Exemplo 3.20. Seja o código cíclico C sobre F2 com matriz geradora











G =

1 1 1 0 0 0
1 0 0 1 0 0
0 1 0 0 1 0
1 1 0 0 0 1











.

Como G está na forma padrão, a matriz teste de paridade H, como já vimos na observação
3.16, é expressa por





H =

1 0 1 1 0 1
0 1 1 0 1 1


 .

Dados v = (010101) e v0 = (100111), como

Hvt =



0


0

e

H(v0)t =



1


0

temos que v ∈ C e v0 6∈ C.

O resultado a seguir nos fornece uma forma de calcular algebricamente a síndrome
de um vetor v em relação a uma matriz teste de paridade num código cíclico, sem que
seja necessário efetuarmos o produto matricial Hvt.

Teorema 3.21. Seja C ⊂ K n um código cíclico gerado por um polinômio mônico de
grau r com matriz geradora na forma padrão (R | Idn−r) e matriz teste de paridade
H = (Idr | −RT ). Se v = (v0, ..., vn−1) ∈ K n, então a síndrome de v com relação à matriz
H é dada por

θ−1(s(X)),

onde s(X) é o resto da divisão de v0 + v1X + · · · + vn−1X n−1 por g(X).

54

Capítulo 3. Códigos cíclicos

Demonstração. A síndrome de v é o vetor

(Idr| − Rt)vt =

(θ−1(1), θ−1(X), · · · , θ−1(X r−1), θ−1(s1(X)), · · · , θ−1(sn−r(X)))vt =

θ−1(v0 + v1X + · · · + vr−1X r−1 + vrs1(X) + · · · + vn−1sn−r(X)),

de onde segue o resultado, pelo fato de

s(X) = v0 + v1X + · · · + vr−1X r−1 + vrs1(X) + · · · + vn−1sn−1(X)

ser o resto da divisão de v0 + v1X + · · · + vn−1X n−1 por g(X).

Considere o código C(7, 4). A matriz teste de paridade associada é a matriz

H =








1 0 0 1 0 1 1
0 1 0 1 1 1 0
0 0 1 0 1 1 1








Dado o vetor (1101001) ∈ F7
2, para calcular a síndrome, extraímos o resto da divisão do
polinômio 1 + X + X 3 + X 6 por g(X) = 1 + X + X 3 que é s(X) = X 2 + 1. De acordo
com o Teorema 3.21, a síndrome é dada por

θ−1(s(X)) = (101).

3.4 Codiﬁcação e decodiﬁcação

A ideia de codiﬁcação de códigos corretores de erros se baseia em codiﬁcar uma
informação (mensagem), adicionando informação redundante, de forma que, ao receber
a mensagem modiﬁcada (com algum erro), seja possível recuperar a informação na sua
forma original.

Ainda considerando o isomorﬁsmo 3.2 e sendo C ⊂ K n um código cíclico, de matriz
geradora na forma padrão G0, para codiﬁcar um vetor do código fonte como elemento de
C, basta multiplicar o vetor do código por G0. Assim

(a1, ..., an−r) · (R | Idn−r) = (b0, ..., br−1, a1, ..., an−r) ∈ C,

no qual são inseridos os dígitos (símbolos) de redundância

(b0, ..., br−1) = −a1θ−1(s1(X)) − ... − an−rθ−1(sn−r(X)) =

−θ−1(a1s1(X) + ... + an−rsn−r(X)).

A partir de agora, vamos estudar o procedimento de detecção e correção de erros

num determinado código. Tal procedimento é chamado de decodiﬁcação.

3.4. Codiﬁcação e decodiﬁcação

55

Deﬁnição 3.22. O peso de um código cíclico C é o inteiro

ω(C) := min{ω(x); x ∈ C \ {0}.

Observação 3.23. Encontrar uma forma para calcular o peso de um código cíclico é um
problema muito difícil de ser resolvido e é, em parte, uma questão em aberto.

Deﬁnição 3.24. Deﬁnimos o vetor erro e como sendo a diferença entre o vetor recebido
r e o vetor transmitido c, isto é,

e = r − c.

Para exempliﬁcar, suponhamos que num determinado código sobre F2 na trans-
missão da mensagem (010011) ocorreu um erro e a palavra recebida tenha sido (101011).
Então

e = (101011) − (010011) = (111000).

Observe que o peso do vetor erro corresponde ao número de erros cometidos durante

a transmissão.

Seja H a matriz teste de paridade do código. Como Hct = 0, temos que

Het = H(rt − ct) = Hrt − Hct = Hrt.

Portanto a palavra recebida e o vetor erro têm mesma síndrome.

Denotamos por hi a i-ésima coluna da matriz H. Se e = (α1, · · · , αn), então

n
X

i=1

αihi = Het = Hrt.

Lema 3.25. Seja C um código cíclico em K n com capacidade de correção κ. Se r ∈
K n e c ∈ C são tais que d(c, r) (cid:54) κ, então existe um único vetor e com ω(e) (cid:54) κ, cuja
síndrome é igual à síndrome de r e tal que c = r − e.

Demonstração. De fato, e = r − c satisfaz as condições do Lema, já que ω(e) = d(c, r) (cid:54) κ.
Para provar a unicidade, suponhamos que e = (α1 · · · αn) e e0 = (α0
n) sejam tais que
ω(e) (cid:54) κ e ω(e0) (cid:54) κ e tenham mesma síndrome que r. Então, se H é uma matriz teste
de paridade de C, temos

1 · · · α0

Het = He0t =⇒

n
X

i=1

αihi =

n
X

i=1

ihi,
α0

o que nos dá uma relação de dependência linear entre 2κ((cid:54) d − 1) colunas de H. Como
quaisquer d − 1 colunas de H são linearmente independentes, temos que αi = α0
i para todo
i, logo e = e0.

Como determinar o vetor e a partir de Hrt?

56

Capítulo 3. Códigos cíclicos

Exemplo 3.26. Determinação de e quando ω(e) (cid:54) 1.

Seja C um código de distância mínima d (cid:62) 3 e o vetor erro e inserido durante uma
transmissão da mensagem c seja tal que ω(e) (cid:54) 1. Isto signiﬁca que o canal introduziu no
máximo um erro.

Se Het = 0, então r (palavra recebida) pertence a C e temos c = r.

Considere Het 6= 0, então ω(e) = 1 e, portanto e tem apenas uma coordenada não
nula. Assim, consideramos que e = (0, · · · , α, · · · , 0) com α 6= 0 na i-ésima posição. Logo,

Het = αhi,

onde hi é a i-ésima coluna de H. Portanto, não conhecendo e, mas conhecendo

Het = Hrt = αhi,

podemos determinar e como sendo o vetor com todas as componentes nulas exceto a
i-ésima componente que é α.

Agora vamos ver com o exemplo abaixo como construir um código cíclico, suas

matrizes geradora e teste de paridade, e decodiﬁcar algumas mensagens.

Exemplo 3.27. Considere o polinômio X 8 − 1 sobre F3.

a) Vamos determinar a fatoração desse polinômio em polinômios irredutíveis e mônicos

em F3[X].

Como 1 e 2 são raízes, tem-se

X 8 − 1 = (X + 1)(X + 2)(X 6 + X 4 + X 2 + 1),

temos ainda que

(X 6 + X 4 + X 2 + 1) = X 4(X 2 + 1) + X 2 + 1 = (X 2 + 1)(X 4 + 1).

Note que X 2 + 1 é irredutível, pois esse polinômio não possui raízes em F3[X].

Observe também que 0, 1 e 2 não são raízes de X 4 + 1, e como seus possíveis fatores
ou têm graus 1 e 3 ou dois fatores de grau 2, então a segunda opção é a única possível.
Portanto

X 4 + 1 = (X 2 + b1X + c1)(X 2 + b2X + c2) =

= X 4 + (b1 + b2)X 3 + (b1b2 + c1 + c2)X 2 + (b1c2 + c1b2)X + c1c2.

Resolvendo o sistema






b1 + b2 = 0

b1b2 + c1 + c2 = 0

b1c2 + b2c1 = 0

c1c2 = 1

3.4. Codiﬁcação e decodiﬁcação

57

temos b1 = 1, b2 = c1 = c2 = 2. Assim

X 8 − 1 = (X + 1)(X + 2)(X 2 + 1)(X 2 + X + 2)(X 2 + 2X + 2).

b) Seja C ⊂ F8

3 o código cíclico gerado por g(X) = X 2 + 2X + 2. Vamos construir a
matriz geradora de C na forma padrão (R|Id) e sua correspondente matriz teste de
paridade (Id| − Rt).

Observe que com a escolha do polinômio g(X), temos a construção de um código
C(8, 6), isto signiﬁca que, pra esse código, são acrescentados 2 dígitos de redundância
na codiﬁcação. Assim, aplicando o teorema 3.13, e realizando as divisões

X 2 = (X 2 + 2X + 2) + (X + 1)

X 3 = (X 2 + 2X + 2)(X + 1) + (2X + 1)

X 4 = (X 2 + 2X + 2)(X 2 + X + 2) + 2

X 5 = (X 2 + 2X + 2)(X 3 + X 2 + 2X) + 2X

X 6 = (X 2 + 2X + 2)(X 4 + X 3 + 2X 2 + 2) + (2X + 2)

X 7 = (X 2 + 2X + 2)(X 5 + X 4 + 2X 3 + 2X + 2) + (X + 2)

obtemos a matriz geradora (R|Id6) e a matriz teste de paridade (Id2| − Rt) de C,
dadas por

G0 =

















2 2 1 0 0 0 0 0
2 1 0 1 0 0 0 0
1 0 0 0 1 0 0 0
0 1 0 0 0 1 0 0
1 1 0 0 0 0 1 0
1 2 0 0 0 0 0 1

















e

H 0 =





1 0 1 1 2 0 2 2
0 1 1 2 0 2 2 1


 .

c) Agora iremos decodiﬁcar as mensagens X 6 + X 4 + X 2 + 1, X 7 + X 5 + 2X + 1 e

X 7 + 2X 6 + X 5 + X 3 + X 2 + 2X + 1.

Para isto, encontramos a síndrome das mensagens recebidas dividindo o polinômio
que caracteriza cada mensagem por g(X), e se o resto for 0, então a mensagem
pertence ao código, caso contrário, corrigimos o erro aplicando o algoritmo da
decodiﬁcação.

Como,

logo

X 6 + X 4 + X 2 + 1 = (X 2 + 2X + 2)(X 4 + X 3 + X + 2),

σ−1(X 6 + X 4 + X 2 + 1) = 10101010 ∈ C.

58

Capítulo 3. Códigos cíclicos

Assim, como a decodiﬁcação é dada pela matriz geradora na forma padrão, a
mensagem transmitida é dada pelas seis componentes ﬁnais do vetor 10101010 que é
101010.

Analogamente, para a mensagem X 7 + X 5 + 2X + 1, tem-se

X 7 + X 5 + 2X + 1 = (X 2 + 2X + 2)(X 5 + X 4 + X 2 + X + 2) + 2X,

onde s(X) = 2X é o resto da divisão de X 7 + X 5 + 2X + 1 por g(X), e consequente-
mente, a síndrome é o vetor (02). Comparando com as colunas de H 0 temos que o
vetor da síndrome é igual à sexta coluna de H 0, pelo algoritmo da decodiﬁcação o
vetor e = (00000200). A relação c = r + e, nos permite corrigir a mensagem. Logo

c = σ−1(X 7+X 5+2X+1)+(00000200) = (12000101)+(00000200) = (12000001) ∈ C.

E a mensagem decodiﬁcada é 000001.

Para ﬁnalizar temos

X 7 + 2X 6 + X 5 + X 3 + X 2 + 2X + 1 = (X 2 + 2X + 2)(X 5 + 2X 3 + 2X 2 + 2X + 2)

isso signiﬁca que σ−1(1 + 2X + X 2 + X 3 + X 5 + 2X 6 + X 7) = 12110121 ∈ C. E a
mensagem transmitida é 110121.

4 Uma proposta para o ensino de

polinômios

59

Neste capítulo, desenvolvemos uma proposta de sequência didática para a construção
do conhecimento sobre polinômios, aplicada aos códigos cíclicos, no processo de codiﬁcação
e decodiﬁcação. Realizamos nosso estudo, inicialmente abordando conteúdos fundamentais
da matemática que estão diretamente relacionados com a aplicação dos códigos cíclicos.

Nosso intuito inicial era mostrar, nesta dissertação, os resultados da aplicação
dessa proposta porém, devido ao período pandêmico vivenciado durante a produção dessa
sequência didática, não foi possível realizar tal aplicação. Mesmo assim nos dedicamos
ao máximo na elaboração desse trabalho com o propósito de construir um matérial de
qualidade para uma aplicação futura.

Recomendamos que esta sequência didática seja aplicada, como projeto extracurri-
cular, para um grupo de alunos pré-selecionados do Ensino Médio. De preferência alunos
que têm mais aﬁnidade com a matemática. Como exemplo, a formação de uma sala de
alunos que estudam para participarem de olimpíadas de matemática (OBMEP, OBM,
OPEMAT, entre outras).

Sugerimos, com a ﬁnalidade de motivar os alunos pra essa sequência didática, que
o professor construa uma aula 0, com as atividades 1 e 2, de Lira (10) (2018, p. 95), que
foram atividades que nos inspiraram na construção das aulas 6 e 7 da sequência didática.

O objetivo dessa sequência didática é mostrar ao aluno que a matemática está
intimamente presente no dia a dia deles. Em uma simples mensagem de e-mail, em uma
ligação telefônica, na utilização de smartphones, computadores, entre outros meios de
comunicação, a matemática está diretamente relacionada.

Nas próximas seções vamos apresentar a estrutura e organização de cada aula dessa

sequência.

Da aula 1 até a aula 4, abordamos os conteúdos matemáticos necessários para
aplicação nos códigos cíclicos. Na aula 5, introduzimos a teoria dos códigos com um
texto de fácil compreensão. Nas aulas 6 e 7, apresentamos o algoritmo da codiﬁcação e
decodiﬁcação, que utiliza a operação de polinômios como principal conteúdo abordado.

As aulas apresentadas a seguir estão estruturadas com os seguintes tópicos:

• Objetivos - O que desejamos que os alunos compreendam;

• Recursos didáticos - Materiais sugeridos para utilização na aula;

60

Capítulo 4. Uma proposta para o ensino de polinômios

• Conteúdos abordados - O conhecimento matemático abordado na aula;

• Tempo de duração - tempo sugerido para duração da aula/atividade;

• Metodologia - A forma como o professor conduzirá a aula;

• Texto para o aluno - Texto para aprendizagem construtiva dos alunos;

• Atividades1 - Conjunto de exercícios relacionados à aula;

• Avaliação - Propostas ou instrumentos de avaliação para acompanhar o progresso dos

alunos com relação aos conteúdos das aulas;

• Orientação para o professor - Sugestões para uma boa condução e aproveitamento da

sequência didática.

4.1 Aula 1: Corpos ﬁnitos

Objetivos: Compreender os conjuntos da forma Zn como anel, com n inteiro; Realizar as
operações de adição e multiplicação nesses conjuntos; Identiﬁcar quando Zn é um
corpo ﬁnito.

Recursos didáticos: Data show, computador, quadro branco e pincel.

Conteúdos abordados: Divisão euclidiana.

Tempo de duração: Sugerimos um período de 50 minutos, que é o tempo deﬁnido para

uma aula nas escolas públicas no estado de Pernambuco.

Metodologia: O professor entregará aos alunos o texto abaixo onde será apresentado ou
relembrado os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Corpos Finitos

Dado um inteiro n > 1, o Teorema da Divisão Euclidiana garante que para todo
número inteiro a existem inteiros q e r tais que a = q · n + r, com 0 (cid:54) r < n, ou
seja, é sempre possível dividir o número inteiro a por n com quociente q e resto r.

1 As atividades precedidas de ∗ são atividades fundamentais, pois obedecem uma ordem na construção

do conhecimento, dando uma ideia de continuidade.

4.1. Aula 1: Corpos ﬁnitos

61

Como consequência deste Teorema temos o que chamamos de Lema dos restos,
enunciado a seguir:

Lema dos Restos A soma e o produto de quaisquer dois números inteiros deixa o
mesmo resto que a soma e o produto dos seus restos, respectivamente, na divisão
por um inteiro n, n 6= 0.

De fato, se a = q1 · n + r1 e b = q2 · n + r2 então

a + b = (q1 + q2) · n + (r1 + r2) e

a · b = (q1 · q2 · n + q1 · r2 + q2 · r1) · n + (r1 · r2).

Como a primeira parcela de a + b e a · b já é múltiplo de n resta dividir r1 + r2 e
r1 · r2 por n.

Dado n > 0 um número inteiro vamos considerar o conjunto

Zn = {0, 1, . . . , n − 1}

onde r, 0 ≤ r ≤ n − 1, representa todos os números inteiros que têm resto r
quando dividido por n. Por exemplo, no conjunto Z2 = {0, 1}, 0 representa todos
os números pares e 1 representa todos os números ímpares.

Utilizando o Lema dos restos podemos concluir que a + b = a + b e a · b = a · b.
Por exemplo, em Z5 somar 3 e 4 signiﬁca somar um número da forma a = 5 · q + 3
com outro da forma b = 5 · k + 4, portanto a + b = 5 · (q + k) + 7 = 5 · (q + k + 1) + 2.
A maneira simpliﬁcada de escrever isso é 3 + 4 = 3 + 4 = 2, pois dividindo 7 por
5 obtemos resto 2.

Segue abaixo a tabela de multiplicação e adição de Z3

+ 0
0
0
1
1
2
2

1
1
2
0

2
2
0
1

e

·
0
1
2

0
0
0
0

1
0
1
2

2
0
2
1

Quando Zn é corpo ﬁnito? Diremos que Zn é um corpo ﬁnito se todo elemento
a 6= 0 tem inverso multiplicativo, ou seja, existe b tal que a · b = 1.

Olhando a tabela de multiplicação do Z3 notamos que os elementos 1 e 2 têm
inverso multiplicativo pois 1 · 1 = 1 e 2 · 2 = 1, logo Z3 é um corpo ﬁnito.

62

Capítulo 4. Uma proposta para o ensino de polinômios

Atividades: (Identiﬁcando corpos ﬁnitos)

4.1.1. Preencha as tabelas de adição e multiplicação dos conjuntos abaixo.

Z2:

Z5:

Z6:

Z7:

Z8:

·
0
1

·
0
1
2
3
4

·
0
1
2
3
4
5

·
0
1
2
3
4
5
6

·
0
1
2
3
4
5
6
7

0

1

e

+ 0
0
1

0

1

2

3

4

1

e

0

1

2

3

4

5

1

2

3

4

+ 0
0
1
2
3
4

1

2

3

4

5

e

+ 0
0
1
2
3
4
5

0

1

2

3

4

5

6

1

2

3

4

5

6

e

+ 0
0
1
2
3
4
5
6

0

1

2

3

4

5

6

7

1

2

3

4

5

6

7

e

+ 0
0
1
2
3
4
5
6
7

4.1. Aula 1: Corpos ﬁnitos

63

Z9:

·
0
1
2
3
4
5
6
7
8

0

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

e

+ 0
0
1
2
3
4
5
6
7
8

4.1.2. Veriﬁque para quais valores de n dos conjuntos Zn, do item anterior, Zn é

um corpo ﬁnito.

4.1.3. Qual a condição que classiﬁca um conjunto Zn como um corpo ﬁnito?

4.1.4. Se num conjunto, existem elementos a e b diferentes de zero, de forma que
a × b = 0, dizemos que este conjunto possui divisores de zero. Identiﬁque quais
conjuntos do exercício 1 admitem divisores de zero. Esses conjuntos são corpos
ﬁnitos?

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

Orientações para o professor: Para essa atividade, o professor poderá dividir a turma
em equipes de quatro ou três alunos, em seguida entregar o texto Corpos Finitos
para que as equipes realizem a leitura. Sugerimos que seja deﬁnido o tempo de 10
minutos para leitura do texto.

Após a leitura, o professor poderá relembrar e esclarecer alguns conceitos descritos no
texto, utilizando exemplos numéricos. Também sugerimos que seja realizado algumas
mediações sobre o texto. Por exemplo:

• O que diz o lema dos restos?

• Quem são os elementos de Z5?
• Quando Zn é um corpo?
• Quem são os elementos invertíveis de Z4?

As perguntas devem orientar o aluno na construção do conhecimento proposto no
texto.

Para ﬁnalizar a aula, o professor entrega aos alunos as tabelas de adição e multi-
plicação dos conjuntos Z4 e Z5 para eles preencherem juntamente com a lista de
exercícios.

64

Capítulo 4. Uma proposta para o ensino de polinômios

4.2 Aula 2: Polinômios com coeﬁcientes em um corpo

ﬁnito

Objetivos: Identiﬁcar o grau de um polinômio; efetuar a adição e multiplicação de
polinômios; determinar as raízes de um polinômio com coeﬁcientes em um corpo
ﬁnito.

Recursos didáticos: Data Show, computador, quadro branco e pincel.

Conteúdos abordados: Grua de um polinômio; adição e multiplicação de polinômios;

raiz de um polinômio.

Tempo de duração: Para essa atividade sugerimos que seja aplicada no tempo de uma

aula 50 minutos.

Metodologia: O professor entregará aos alunos o texto abaixo, onde será apresentado
ou relembrado os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Polinômios com coeﬁcientes em um corpo ﬁnito

Sejam K = Zp (com p um número primo) um corpo ﬁnito, e X uma variável. Um
polinômio P (X) com coeﬁcientes em K é uma expressão da seguinte forma

P (X) = amX m + am−1X m−1 + · · · + a1X + a0,

em que m é um número inteiro não negativo, e a0, a1, · · · , am são elementos de K,
tal que am 6= 0. Chamamos m de grau do polinômio P (X).

Dados F (X) = amX m + · · · + a1X + a0 e G(X) = bnX n + · · · + b1X + b0 polinômios
com coeﬁcientes em K, podemos deﬁnir as operações de adição e multiplicação de
polinômios da seguinte forma:

(i) F (X) + G(X) = cnX n + · · · + c1X + c0 onde ci = ai + bi, com i = 0, 1, · · · , n;

(ii) F (X)·G(X) = cm+nX m+n+· · ·+c1X +c0, onde ci = a0·bi+a1·bi−1+· · ·+ai·b0,

com i = 0, 1, · · · m + n.

O resultado da adição entre dois polinômios é chamado de soma, já o resultado
da multiplicação chamamos de produto.

4.2. Aula 2: Polinômios com coeﬁcientes em um corpo ﬁnito

65

Por exemplo, sejam F (X) = X 3 + X + 1, G(X) = X 3 + X 2 + 1 em Z2. Então

F (X) + G(X) = (1 + 1)X 3 + (0 + 1)X 2 + (1 + 0)X + (1 + 1) = X 2 + X

e

F (X) · G(X) = (X 3 + X + 1) · (X 3 + X 2 + 1)

= X 3 · (X 3 + X 2 + 1) + X · (X 3 + X 2 + 1) + 1 · (X 3 + X 2 + 1)

= (X 6 + X 5 + X 3) + (X 4 + X 3 + X) + (X 3 + X 2 + 1)

= X 6 + X 5 + X 4 + X 3 + X 2 + X + 1.

Dizemos que α ∈ K é uma raiz de P (X) se P (α) = 0, ou seja,

amαm + am−1αm−1 + · · · + a1α + a0 = 0.

Como exemplo, considerando K = Z5 e P (X) = X 2 + 2X + 1 temos que 4 é uma
raiz do polinômio, pois

42 + 2 × 4 + 1 = 0.

Para encontrar as raízes de um polinômio P (X) em K = Zp, onde Zp é um corpo
ﬁnito, basta avaliar P (X) para os p elementos de Zp. Isto é um problema simples
quando p é um número relativamente pequeno.

Por exemplo, para encontrar todas as raízes do polinômio P (X) = X 3+X 2+2X +2
em Z5, vamos avaliar em todos os elementos de Z5 = {0, 1, 2, 3, 4}.

Assim temos

P (0) = 03 + 02 + 2 · 0 + 2 = 2

P (1) = 13 + 12 + 2 · 1 + 2 = 1

P (2) = 23 + 22 + 2 · 2 + 2 = 3

P (3) = 33 + 32 + 2 · 3 + 2 = 4

P (4) = 43 + 42 + 2 · 4 + 2 = 0,

e, portanto 4 é a única raiz do polinômio P (X) sobre Z5.

Atividades:

(Polinômios)

4.2.1 Complete a tabela abaixo, realizando as operações e veriﬁcando os graus dos

polinômios.

66

Capítulo 4. Uma proposta para o ensino de polinômios

P (X) + Q(X)

grau de P (X)

grau de P (X) + Q(X)

P (X) · Q(X)

e Q(X)

e P (X) · Q(X)

K

P (X)

Q(X)

Z2 P (X) = X 3 + X 2 + 1

Q(X) = X 3 + X

Z3 P (X) = X 3 + 2X + 1

Z5

Q(X) = X 2 + 2
P (X) = X 4 + 1
Q(X) = X 2 + X + 1

4.2.2. Encontre todas as raízes dos polinômios X 3 + 2X + 1, X 3 + 2X 2 + X + 2,

X 2 + 2 e X 5 + 2X em Z3.

4.2.3. Calcule todas as raízes do polinômio F (X) = X 5 + 3X 3 + X 2 + 2X com

coeﬁcientes em:
(a) Z5;
(b) Z7.

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

Orientações para o professor: Nos primeiros 15 minutos, o professor poderá entregar
aos alunos o texto Polinômios com coeﬁcientes em um corpo ﬁnito para uma
primeira leitura. Em seguida realizar algumas mediações com relação à leitura do
texto. Por exemplo:

• De acordo com os exemplos do texto (ou da atividade) qual a relação entre o grau

da soma P (X) + Q(X), e o grau dos polinômios P (X) e Q(X)?.

• E o que podemos concluir do grau do produto?

• O que é uma raiz de um polinômio?

Lembrando que as perguntas, aqui servem para direcionar o aluno, contribuindo
para construção do conhecimento proposto no texto.

Para ﬁnalizar, o professor poderá entregar as atividades propostas (Polinômios).

4.3 Aula 3: Divisão de polinômios em K[X]

Objetivos: Compreender e aplicar o Algoritmo da Divisão de Polinômios em um corpo

ﬁnito.

Recursos Didáticos: Data show, computador, quadro branco e pincel.

Conteúdos Abordados: Divisão de polinômios.

4.3. Aula 3: Divisão de polinômios em K[X]

67

Tempo de duração: Para essa atividade, sugerimos empregar o tempo de uma aula de

50 minutos.

Metodologia: O professor entregará aos alunos o texto abaixo, onde será apresentado
ou relembrado os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Algoritmo da Divisão de Polinômios em K[X]

Sejam K = Zp (com p um número primo) um corpo ﬁnito, e X uma variável.
Assim como nos inteiros, o Teorema da Divisão Euclidiana também se aplica aos
polinômios em K[X], assegurando que dados F (X) e G(X) ∈ K[X], com F (X) 6=
0 existem únicos polinômios Q(X) e R(X), tais que G(X) = Q(X) · F (X) + R(X),
com o grau de R(X) menor do que o grau de F (X) ou R(X) = 0.

Como efetuar na prática esta divisão?

Primeiro precisamos entender que, se o grau de G(X) for menor do que o grau de
F (X), então

G(X) = 0 · F (X) + G(X),

ou seja, Q(X) = 0 e R(X) = G(X).

Porém, se o grau de G(X) = amX m + . . . + a1X + a0 (am 6= 0) for maior do que
ou igual ao grau de F (X) = bnX n + . . . + b1X + b0 (bn 6= 0), ou seja, m ≥ n então
escreveremos Q1(X) = amb−1
n X m−n e R1(X) = G(X) − Q1(X) · F (X), sendo b−1
n
o inverso multiplicativo de bn. Se o grau de R1(X) for menor do que o grau de
F (X) ou R1(X) = 0 acabamos a divisão e G(X) = Q1(X) · F (X) + R1(X), caso
contrário repetimos o processo anterior agora com R1(X) e F (X).

Vejamos no exemplo abaixo a divisão do polinômio G(X) = X 4 + X 3 + X + 1
pelo polinômio F (X) = 2X 3 + X + 1 em Z3[X].

Passo 1 O inverso multiplicativo de 2 em Z3 é 2, logo Q1(X) = 2 · 1 · X 4−3 e

R1(X) = G(X) − Q1(X) · F (X) = X 4 + X 3 + X + 1 − 2 · X · (2X 3 + X + 1)

R1(X) = X 3 − 2X 2 − X + 1

X 4 + X 3 + X + 1
−X 4 − 2X 2 − 2X
X 3 − 2X 2 − X + 1

2X 3 + X + 1
2X

68

Capítulo 4. Uma proposta para o ensino de polinômios

Passo 2 Veja que o grau de R1(X) é igual ao grau de F (X), então devemos repetir
o processo anterior agora com R1(X) e F (X). Assim Q2(X) = 2 · 1 · X 3−3 e

R2(X) = R1(X) − Q2(X) · F (X) = X 3 − 2X 2 − X + 1 − 2 · (2X 3 + X + 1)

R2(X) = −2X 2 − 1

2X 3 + X + 1
2X + 2

X 4 + X 3 + X + 1
−X 4 − 2X 2 − 2X
X 3 − 2X 2 − X + 1
−X 3 − 2X − 2
−2X 2 − 1

Como o grau de R2(X) é menor que o grau de F (X), não continuamos com a
divisão. E Obtemos Q(X) = Q1(X) + Q2(X) = 2X + 2 e R(X) = R2(X) =
−2X 2 − 1.

Uma consequência direta do Teorema da Divisão Euclidiana para polinômios é o
Lema a seguir.

Lema α é uma raiz do polinômio P (X) se, e somente se, P (X) é divisível por
(X − α), ou seja, P (X) = (X − α) · Q(X).

Mais ainda, se α1, · · · , αi são as raízes distintas de P (X), então podemos escrever

P (X) = (X − α1)(X − α2) · · · (X − αi) · Q(X).

Atividades: (Divisão de polinômios)

4.3.1. Escreva cada polinômio da questão 4.2.2 da forma P (X) = (X − α1)(X −

α2) · · · (X − αi) · Q(X).

4.3.2. ∗Efetue a divisão em Z2 do polinômio X 3 + X + 1 por X 3, X 4, X 5, X 6.

Complete a tabela preenchendo com o quociente e o resto.

Quociente

Resto

Divisão
X 3 ÷ X 3 + X + 1
X 4 ÷ X 3 + X + 1
X 5 ÷ X 3 + X + 1
X 6 ÷ X 3 + X + 1

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

4.4. Aula 4: Fatorando polinômios em K[X]

69

Orientações para o professor: Sugerimos ao professor que disponibilize o texto para
os alunos, e desenvolva, junto com eles, o algoritmo da divisão de polinômios. Em
seguida poderá abordar o Lema da divisão por X − α, e concluir mostrando que α é
uma raíz de P (X) se, e somente se, P (X) é divisível por (X − α).

Para concluir, entregar a ﬁcha de atividades (Divisão de polinômios) sugerida.

4.4 Aula 4: Fatorando polinômios em K[X]

Objetivos: Desenvolver técnicas de fatoração de um polinômio em polinômios irredutíveis.

Recursos Didáticos: Data show, computador, quadro branco e pincel.

Conteúdos Abordados: Fatoração de polinômios.

Tempo de duração: Para essa atividade sugerimos que seja empregado o tempo de

uma aula de 50 minutos.

Metodologia: O professor entregará aos alunos o texto abaixo, onde será apresentado
ou relembrado os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Fatoração de Polinômios

Sejam K = Zp (com p um número primo) um corpo ﬁnito, e X uma variável.
Agora estudaremos como fatorar um polinômio em K[X] em fatores irredutíveis,
ou polinômios irredutíveis sobre K.

Mas o que são polinômios irredutíveis?
Um polinômio P (X) é chamado de irredutível, quando dada qualquer fatoração
da forma P (X) = F (X)G(X), pelo menos um dos fatores (F (X) ou G(X)) é um
polinômio constante não nulo.

Por exemplo, o polinômio P (X) = X 3 + X 2 + 2 é irredutível sobre Z3, pois para
ser redutível ele deveria ser escrito como produto de um polinômio de grau 1 com
um polinômio de grau 2, ou seria produto de três polinômios de grau 1. Mas não
existem raízes em Z3. Logo P (X) é irredutível sobre Z3.

Todo polinômio de grau 1 em K[X] é irredutível (Por quê?).

70

Capítulo 4. Uma proposta para o ensino de polinômios

Para fatorar um polinômio P (X) ∈ K[X] em polinômios irredutíveis, seguimos os
seguintes passos:

Passo 1: Encontramos todas as raízes do polinômio em K;

Passo 2: Escrevemos P (X) = (X − α1)(X − α2) · · · (X − αi) · Q(X);

Passo 3: Encontramos todos os polinômios irredutíveis de grau maior ou igual a

2 e veriﬁcar quais deles dividem Q(X).

Por exemplo, vamos fatorar o polinômio P (X) = X 3 + X + 2 em K = Z5, em
polinômios irredutíveis.

Seguindo os passos acima, primeiro vamos encontrar as raízes de P (X), então
temos

P (0) = 03 + 0 + 2 = 2,

P (1) = 13 + 1 + 2 = 4,

P (2) = 23 + 2 + 2 = 2,

P (3) = 33 + 3 + 2 = 2,

P (4) = 43 + 4 + 2 = 0,

logo 4 é a única raiz de P (X).

Agora, escrevemos P (X) = (X − 4)(X 2 + 4X + 2). Como 4 é a única raiz de P (X),
segue que (X 2 + 4X + 2) é irredutível.

Atividades: (Fatorando polinômios)

4.4.1. ∗Marque na tabela os polinômios irredutíveis em Z2 de grau menor do que

ou igual a 3.

P (X)

X
X 2 + 1
X 3
X 3 + X + 1
X 3 + X 2 + X

K = Z2 P (X)
X + 1
X 2 + X
X 3 + 1
X 3 + X 2
X 3 + X 2 + X + 1

K = Z2 P (X)

K = Z2

X 2
X 2 + X + 1
X 3 + X
X 3 + X 2 + 1

4.4.2. Fatore em polinômios irredutíveis os seguintes polinômios:

∗a) X 7 − 1 em Z2;
b) X 6 − 1 em Z5.

4.5. Aula 5: Códigos corretores de erros

71

c) X 4 + X 3 + X + 1 em Z3.

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

Orientações para o professor: O professor poderá iniciar discutindo a quantidade de
raízes de um polinômio P (X). Explicar o que é um polinômio irredutível. Abordar
cada passo da fatoração de polinômios descritos no exemplo do texto.

Para concluir, entregar a ﬁcha de atividades (Fatorando polinômios) sugerida.

4.5 Aula 5: Códigos corretores de erros

Objetivos: Compreender a importância da matemática na aplicação de códigos corre-
tores de erros. Estudar os códigos cíclicos, utilizando a divisão de polinômios com
coeﬁcientes em um corpo ﬁnito como ferramenta para codiﬁcação e decodiﬁcação.

Recursos didáticos: Data show, computador, quadro branco e pincel.

Conteúdos abordados: Códigos cíclicos; operações com polinômios.

Metodologia: O professor entregará aos alunos o texto abaixo, onde será apresentado
ou relembrado os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Códigos corretores de erros

A Teoria dos códigos corretores de erros, hoje em dia, é muito aplicada nos campos
da engenharia, computação, matemática, entre outros. O objetivo principal dessa
teoria é de garantir com precisão e eﬁcácia, sempre que possível, a transferência,
do remetente ao receptor, da informação desejada.

Todos os meios de comunicação (como comunicação entre computadores, telefo-
nes, smartphones, televisores, entre outros), são suscetíveis a erros durante uma
transmissão.

Como é feita a transmissão das mensagens? Para transmitir uma mensagem,
cada palavra é pré-codiﬁcada com um código chamado código da fonte. O código
da fonte é formado por elementos de um conjunto chamado de alfabeto.

72

Capítulo 4. Uma proposta para o ensino de polinômios

Uma palavra do código é uma sequência ﬁnita de símbolos do alfabeto. O número
de letras de uma palavra do código chama-se o seu comprimento.

Quando o alfabeto utilizado é o conjunto Z2 = {0, 1} o código diz-se binário.

Por exemplo, suponha que numa sorveteria uma máquina para pedidos de sorvete,
possa fazer até quatro pedidos de sabores distintos de sorvete. Sejam eles baunilha,
doce de leite, chocolate e morango. Ao escolher um sabor, essa máquina envia um
código, referente ao sabor do sorvete, de acordo com a tabela abaixo.

Baunilha
Chocolate

7−→ 00
7−→ 01

Doce de Leite
Morango

7−→ 10
7−→ 11

Suponha então, que ao enviar um pedido de um sorvete sabor Baunilha, por
alguma interferência, no lugar de enviar o código 00, a máquina envia o código 10,
trocando o valor do primeiro dígito do código. Nesse caso, ao receber o código 10
será feito o sorvete sabor Doce de Leite. Considere que a cada interferência de
transmissão a máquina comete no máximo um erro. Como evitar o problema
da máquina de pedir sorvete?

A ideia da construção de códigos corretores de erros é de inserir dígitos de
redundância para evitar esse tipo de problema.

Assim, por exemplo podemos modiﬁcar o nosso código da fonte acrescentando
alguns dígitos, de acordo com a tabela abaixo:

Fonte

Código da fonte Código de canal

Baunilha

Chocolate

Doce de Leite

Morango

00

01

10

11

00000

01011

10110

11101

Suponha agora que durante uma transmissão da mensagem 11101, ocorre um erro,
e a mensagem recebida seja 10101. Realizando uma comparação dessa mensagem
recebida, com as mensagens do código, percebemos que ela não pertence ao código,
assim sabemos que existe um erro, e portanto veriﬁcamos que a mensagem do
código que tem o menor número de componentes distintos da mensagem recebida
é 11101, que é corretamente a mensagem transmitida.

Atividades: Não sugerimos atividades para essa aula.

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

4.6. Aula 6: Codiﬁcação

73

Orientações para o professor: Sugerimos que essa atividade seja aplicada em uma

aula com duração de 50 minutos.

Nesta aula o professor irá mostrar a importância dos códigos corretores na transmissão
da informação. O texto explica a ideia desse processo, com um exemplo ilustrativo,
para que os alunos desenvolvam o conhecimento proposto pela atividade.

4.6 Aula 6: Codiﬁcação

Objetivos: Estudar os códigos cíclicos, utilizando a divisão de polinômios com coeﬁcientes

em um corpo ﬁnito como ferramenta para codiﬁcação.

Recursos didáticos: Data show, computador, quadro branco e pincel.

Conteúdos abordados: Multiplicação de matrizes; operações com polinômios.

Tempo de duração: Sugerimos que essa atividade seja aplicada em uma aula com

duração de 50 minutos.

Metodologia: O professor entregará aos alunos o texto abaixo, onde será apresentado
ou relembrado os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Codiﬁcação

Estudaremos agora um tipo especial de códigos, que são chamados códigos cíclicos.
Para deﬁnirmos esses códigos vamos considerar toda teoria que estudamos até aqui.
E o interessante é que ele se torna simples quando trabalhamos com polinômios.

Escolhendo um código

Para deﬁnir um código cíclico precisaremos de um corpo ﬁnito K = Zp (sendo
p um número primo) e de um número natural n. Depois precisaremos fatorar
X n − 1 em K em fatores irredutíveis e escolheremos um desses fatores para gerar
o código. Chamaremos o gerador do código de G(X) = arX r + . . . + a1X + a0.

Por exemplo, sejam K = Z2 e n = 9. A fatoração de X 9 − 1 é dada por

X 9 − 1 = (X + 1)(X 2 + X + 1)(X 6 + X 3 + 1).

Agora, vamos considerar o código C gerado pelo polinômio G(X) = X 6 + X 3 + 1.

Preparando-se para a codiﬁcação Divida X r, X r+1, . . . , X n−1 por G(X) e
guarde cada um de seus restos. Chamaremos esses restos de R1(X), . . . , Rn−r(X).

74

Capítulo 4. Uma proposta para o ensino de polinômios

Prosseguindo com o exemplo dado acima temos:

X 6 = (X 6 + X 3 + 1) + (X 3 + 1)

X 7 = (X 6 + X 3 + 1)X + (X 4 + X)

X 8 = (X 6 + X 3 + 1)X 2 + (X 5 + X 2).

Assim, R1(X) = X 3 + 1, R2(X) = X 4 + X e R3(X) = X 5 + X 2.
Antes de continuarmos, vamos estabelecer uma relação entre um polinômio em
K[X] de grau menor do que n e uma sequência de n números em K. Para
o polinômio P (X) = bmX m + . . . + b1X + b0, m < n, considere a sequência
(b0, b1, . . . , bm, 0, 0, . . . , 0
{z
}
|
n−m vezes

).

Codiﬁcando uma mensagem Para codiﬁcar a palavra (c1, . . . , cn−r), calculamos
o polinômio

C(X) = −c1R1(X) − . . . − cn−kRn−k(X)

que tem grau menor do que k (Por quê?). Digamos que C(X) = br−1X r−1 + . . . +
b1X + b0. Então a palavra codiﬁcada será (b0, b1, . . . , br−1, c1, . . . , cn−r).
Usando o exemplo dado no texto, codiﬁque a palavra (1, 1, 0). Temos

C(X) = 1 · (X 3 + 1) + 1 · (X 4 + X) + 0 · (X 5 + X 2)

C(X) = X 4 + X 3 + X + 1,

logo a palavra codiﬁcada será C = (1, 1, 0, 1, 1, 0, 1, 1, 0)

Atividade: (Codiﬁcando uma mensagem)

4.6.1. ∗Considere K = Z2, n = 7 e o código cíclico C gerado pelo polinômio

G(X) = X 3 + X + 1. Observe a tabela abaixo.

Palavra

Pré-codiﬁcação

Palavra

Pré-codiﬁcação

MATEMÁTICA

ROBÓTICA

FAMÍLIA

CONVERSAR

VÍDEO GAME

1100

0110

0011

1010

0101

COMER

BRINCAR

NAMORAR

COMPUTADOR

MÚSICA

1001

1110

0111

1011

1101

Dentre as palavras pré-codiﬁcadas acima escolha uma que seja importante para
você e a codiﬁque.

4.7. Aula 7: Decodiﬁcação

75

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

Orientações para o professor: Nesta atividade, a turma será dividida em três grupos,
e cada grupo irá simular uma função no sistema de comunicação (codiﬁcação, canal
de transmissão e decodiﬁcação). Os grupos deverão ser mantidos na próxima aula.

Para esta aula, o professor poderá desenvolver o algoritmo da codiﬁcação com a
participação dos alunos. Permitindo que eles realizem cada passo do algoritmo,
utilizando o conhecimento desenvolvido nas aulas anteriores.

Para uma maior familiaridade com o algoritmo, solicite aos alunos que respondam a
atividade (Codiﬁcando) proposta.

4.7 Aula 7: Decodiﬁcação

Objetivos: Estudar os códigos cíclicos, utilizando a divisão de polinômios com coeﬁcientes

em um corpo ﬁnito como ferramenta para decodiﬁcação.

Recursos didáticos: Data show, computador, quadro branco e pincel.

Conteúdos abordados: Códigos cíclicos; operações com polinômios.

Metodologia: O professor entregará aos alunos o texto abaixo onde serão apresentados
ou relembrados os conteúdos necessários para a execução da atividade. Este material
também poderá ser apresentado pelo professor utilizando o data show.

Decodiﬁcação

A decodiﬁcação é o método para detectar e corrigir erros num determinado código.
Nem sempre um código é capaz de corrigir erros nas mensagens, e quando temos um
determinado código corretor de erros, é possível corrigir apenas uma quantidade
limitada de erros. Isto signiﬁca que, ao utilizarmos um código corretor de erros,
estamos apenas minimizando os erros na transmissão das mensagens, o que traz
maior qualidade e eﬁciência na comunicação.

Vamos primeiramente discutir como detectar erros nas mensagens recebidas em
um código cíclico.
Detectando Erros Suponha que, depois de enviada a mensagem codiﬁcada, rece-
bemos a palavra M = (m0, m2, . . . , mn−1).

76

Capítulo 4. Uma proposta para o ensino de polinômios

Passo 1: Escrevemos o polinômio associado à palavra M , que é M (X) =

mn−1X n−1 + . . . + m1X + m0;

Passo 2: Dividimos M (X) por G(X) (o polinômio gerador do código);

Se o resto da divisão for zero então a mensagem recebida está correta, caso
contrário houve erro na transmissão e teremos que tentar corrigir o erro.

Corrigindo um erro O que iremos estudar agora permite corrigir no máximo um
erro de transmissão.
Antes da continuar vamos lembrar algumas notações da aula anterior.

• Chamamos o grau de G(X) de r;

• Chamamos o resto da divisão de X r+i−1 por G(X) de Ri(X), sendo o i

qualquer valor entre 1 e n − r.

Para descobrir em qual posição da palavra M está o erro, basta observar o resto
da divisão R(X) de M (X) por G(X) de acordo com os itens descritos abaixo:

1. se R(X) = a · X l, com 0 ≤ l ≤ r − 1 então o erro está na posição l;

2. se R(X) = a · Ri(X), com 1 ≤ i ≤ n − r então o erro está na posição r − 1 + i.

Supondo que o erro ocorreu na posição l, corrija M pondo C = (m0, . . . , ml −
a, . . . , mn−1).
Exemplo: Vamos considerar o exemplo da aula anterior, onde K = Z2, n = 9 e
G(X) = X 6 + X 3 + 1 é o polinômio gerador do código. Suponha que recebemos a
palavra M = (1, 1, 0, 1, 0, 0, 1, 1, 0).
O polinômio associado a M é M (X) = X 7 + X 6 + X 3 + X + 1. Ao dividirmos
M (X) por G(X) obtemos

M (X) = G(X)(X + 1) + X 4.

Como o resto não é zero temos um erro de transmissão. Além disso, sendo o resto
da divisão acima R(X) = X 4 e este tem grau menor do que o grau de G(X),
segue que o erro da mensagem está em m4. Logo

C = (1, 1, 0, 1, 0 − 1, 0, 1, 1, 0) = (1, 1, 0, 1, 1, 0, 1, 1, 0)

(lembre-se que em Z2 temos 1 = −1).
Volte à aula passada e observe quem é C.

4.7. Aula 7: Decodiﬁcação

77

Atividade 1: (Detectando e Corrigindo Erros)

4.7.1. ∗Nesta atividade, os grupos da aula anterior serão mantidos. As palavras
codiﬁcadas pelo primeiro grupo serão passadas para o segundo grupo e as do
segundo para o terceiro, e as do terceiro para o primeiro (Chamaremos este
processo de giro de palavras). Após passarem as palavras, cada grupo irá decidir
se insere ou não um erro na palavra. Então farão um novo giro de palavras, de
forma que o primeiro grupo ﬁque com as palavras do segundo, o segundo com
as do terceiro e o terceiro com as do primeiro. Depois cada grupo irá realizar o
processo de decodiﬁcação das palavras.

Avaliação: A avaliação do aprendizado dos alunos será feita a partir das observações do

professor durante a execução das atividades.

Orientações para o professor: Nesta aula o professor colocará em prática o processo

de transmissão e decodiﬁcação das mensagens.

Para isso, sugerimos que inicialmente, realize em grupos o estudo do texto do aluno.
E em seguida faça mediações abordando o conteúdo do texto. Por exemplo:

• Qual é o processo da decodiﬁcação?

• Como sabemos se uma palavra tem ou não erro?

Sugerimos para realização da atividade (Detectando e Corrigindo Erros) proposta.

Conclusão

79

Nesta dissertação, mostramos, de uma forma simpliﬁcada, a matemática presente
nos meios de comunicação, utilizando os códigos cíclicos, como ferramenta de codiﬁcação e
decodiﬁcação. Apesar da pouca utilização desses códigos na prática, consideramos uma boa
ferramenta didática, por ser um código de implementação simples envolvendo operações
com polinômios, e que não exige muito além do que é visto no ensino básico. Como
produto ﬁnal desta dissertação desenvolvemos uma proposta de sequência didática, voltada
para alunos do Ensino Médio, participantes de olimpíadas de matemática, entre outros
interessados. Por questões do isolamento, devido a pandemia, fomos impossibilitados de
aplicar essa sequência com os alunos, mas esperamos com este trabalho estimular os
professores em sua prática docente no ensino da matemática (especialmente no ensino de
polinômios) e seus alunos a desenvolverem um maior interesse pelo estudo de polinômios,
e incentivá-los na busca pelo conhecimento e relações da matemática presente no meio em
que vivemos.

Referências

81

1 HEFEZ, Abramo; VILLELA, Maria Lúcia T. Códigos corretores de erros. Instituto
de Matematica Pura e Aplicada, 2008.

2 HEFEZ, Abramo. Curso de Algebra, vol. 1. Coleção Matemática Universitária,
IMPA/CNPq, RJ, 1993.

3 HEFEZ, ABRAMO; ARITMÉTICA, Coleção PROFMAT. Sociedade Brasileira de
Matemática. 2009.

4 LIMA, Elon Lages. Álgebra linear. 2006.

5 BERLEKAMP, Elwyn. Algebraic coding theory. 1968.

6 SHANNON, Claude Elwood. The Mathematical Theory of Communication, by
CE Shannon (and Recent Contributions to the Mathematical Theory of Communication),
W. Weaver. University of illinois Press, 1949.

7 MACWILLIAMS, Florence Jessie; SLOANE, Neil James Alexander. The theory of
error-correcting codes. Elsevier, 1977.

8 ROUSSEAU, Christiane, et al. Mathematics and technology. New York: Springer,
2008.

9 LIN, Shu; COSTELLO, Daniel J.Error control coding. Prentice hall, 2001.

10 LIRA, Everton Henrique Cardoso de. Códigos Corretores de Erros no Ensino
Médio: um estudo sobre o Código de Hamming. Dissertação de Mestrado -
PROFMAT. Universidade Federal Rural de Pernambuco, 2018.

11 BRASIL. Ministério da Educação. Base Nacional Comum Curricular. Brasília,
2018.

