ANDR√â VIN√çCIUS SPINA

N√öMEROS PRIMOS E CRIPTOGRAFIA

CAMPINAS
2014

i

ii

Ficha catalogr√°ficaUniversidade Estadual de CampinasBiblioteca do Instituto de Matem√°tica, Estat√≠stica e Computa√ß√£o Cient√≠ficaMaria Fabiana Bezerra Muller - CRB 8/6162      Spina, Andr√© Vin√≠cius, 1986-  Sp46nSpiN√∫meros primos e criptografia / Andr√© Vin√≠cius Spina. ‚Äì Campinas, SP : [s.n.],2014.      SpiOrientador: Ricardo Miranda Martins.  SpiDisserta√ß√£o (mestrado profissional) ‚Äì Universidade Estadual de Campinas,Instituto de Matem√°tica, Estat√≠stica e Computa√ß√£o Cient√≠fica.       Spi1. N√∫meros primos. 2. Criptografia - Matem√°tica. I. Martins, RicardoMiranda,1983-. II. Universidade Estadual de Campinas. Instituto de Matem√°tica,Estat√≠stica e Computa√ß√£o Cient√≠fica. III. T√≠tulo. Informa√ß√µes para Biblioteca DigitalT√≠tulo em outro idioma: Prime numbers and encryptionPalavras-chave em ingl√™s:Primes numbersCryptography - Mathematics√Årea de concentra√ß√£o: Matem√°tica em Rede NacionalTitula√ß√£o: Mestre em Matem√°tica em Rede NacionalBanca examinadora:Ricardo Miranda Martins [Orientador]Ary Orozimbo ChiacchioAngelo Calil BianchiData de defesa: 31-03-2014Programa de P√≥s-Gradua√ß√£o: Matem√°tica em Rede NacionalPowered by TCPDF (www.tcpdf.org)ivAbstract

The paper presents a Number Theory introduction, trough a RSA and Diffie-Hellman crypto-
graphic methods approach, where one can observe situations where they are effective. The mathe-
matical theory introduced in this paper encompass prime numbers, Modular arithmetic,Primality
test, groups and other Number Theory related branches.

Keywords: Primes numbers, Cryptography-Mathematics.

Resumo

A pesquisa apresentar√° uma introdu√ß√£o a Teoria dos N√∫meros atrav√©s de uma abordagem
sobre os m√©todos criptogr√°ficos RSA e Diffie-Hellman, onde pode-se constatar situa√ß√µes onde eles
s√£o eficientes. A teoria matem√°tica presente nesse trabalho envolve conhecimentos em n√∫meros
primos, aritm√©tica modular, testes de primalidade, grupos e outras quest√µes envolvendo teoria dos
n√∫meros.

Palavras-chave: N√∫meros primos, Criptografia-Matem√°tica.

vi

Sum√°rio

Dedicat√≥ria

Agradecimentos

Introdu√ß√£o

1 PRELIMINARES

1.1 Teorema Fundamental da Aritm√©tica . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Pequeno Teorema de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Grupos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

viii

ix

1

3
4
6
9

2 TESTES DE PRIMALIDADE

2.1 Teste De Leibniz
2.2 Teste de Miller
2.3 Teste de Lucas

15
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

3 M√âTODOS CRIPTOGR√ÅFICOS

22
3.1 Criptografia RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.2 Criptografia Diffie-Hellman . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

4 SEQU√äNCIA DID√ÅTICA

35
Introdu√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.1
4.2 Objetivos
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.3 Metodologia e Apresenta√ß√£o de Materiais . . . . . . . . . . . . . . . . . . . . . . . . 36
4.4 Roteiro detalhado da proposta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.5 Considera√ß√µes finais sobre a aplica√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . 39

Refer√™ncias

43

vii

Dedico esta disserta√ß√£o a toda minha fam√≠lia, amigos e principalmente a meus alunos, que ao
estud√°-la consigam sentir um pouco do prazer que a matem√°tica √© capaz de proporcionar.

viii

Agradecimentos

A Deus por ter me dado for√ßas que me permitiram chegar at√© aqui, por ter me apontado a
dire√ß√£o a qual me levou a conquistar esse meu sonho. Obrigado Pai, o Senhor √© meu caminho,
minha verdade e minha vida. A minha fam√≠lia por toda a educa√ß√£o, carinho, confian√ßa e paci√™ncia
que me foram concedidas e que serviram de alicerce para o meu comprometimento e paix√£o com
os estudos. Muito obrigado por terem me permitido sonhar. Em especial a minha M√£e e meu
Pai, meus primeiros professores, meu porto seguro. A todos os amigos que Deus colocou no meu
caminho, os quais me levaram a ser quem sou. A todos os meus professores que me ajudaram a
chegar at√© aqui, desde minha m√£e que me ensinou minhas primeiras palavras at√© meu orientador,
Ricardo Miranda Martin, o qual acompanhou todos os passos da elabora√ß√£o dessa disserta√ß√£o.
Agrade√ßo tamb√©m a CAPES pelo apoio financeiro e ao IMECC UNICAMP por abrir as portas
para que eu pudesse realizar o sonho de cursar mestrado.

ix

Introdu√ß√£o

Todos os n√∫meros inteiros ùëõ ‚â• 2 s√£o formados como produtos de n√∫meros primos, ou seja,
os n√∫meros primos s√£o a mat√©ria prima para a constru√ß√£o dos n√∫meros. Mas, como encontrar
n√∫meros primos? Os n√∫meros primos aparecem ao acaso no nosso conjunto num√©rico e descobrir
uma maneira eficaz de encontr√°-los tem sido a tarefa de alguns matem√°ticos por mais de dois
mil anos, tarefa que, apesar de alguns avan√ßos, continua sem solu√ß√£o. Assim sendo, dar sentido
a ordem dos n√∫meros primos e descobrir uma maneira eficaz de encontr√°-los √© um problema e,
tamb√©m, um desafio.

Nos √∫ltimos anos essa quest√£o ganhou uma nova forma de incentivo, devido a um m√©todo
criptogr√°fico chamado RSA, no qual todo o sistema financeiro atual esta apoiado e o qual se
utiliza de n√∫meros primos para tornar essas opera√ß√µes seguras. Seguran√ßa essa, que se baseia na
dificuldade de encontrar os fatores primos de um dado n√∫mero. Se esse problema tivesse solu√ß√£o, se
fosse poss√≠vel fatorar um n√∫mero rapidamente, a seguran√ßa do sistema financeiro atual deixaria de
existir, pois tal m√©todo criptogr√°fico seria inutilizado, bem como todas as suas atuais aplica√ß√µes.
Sabemos que grande parte das transa√ß√µes que envolvem dinheiro, tais como compras com
cart√£o de cr√©dito e at√© mesmo saques em caixas eletr√¥nicos s√£o feitas via internet, podendo assim,
serem interceptadas sem que ningu√©m perceba. Para que essas transa√ß√µes tornem-se seguras,
mesmo sendo interceptadas por pessoas mal intencionadas, elas devem ser protegidas, de modo
que somente o destinat√°rio (banco ou empresa do cart√£o de cr√©dito) consiga ler e utilizar as
informa√ß√µes ali contidas e para isso usamos a criptografia. Criptografia √© o estudo de m√©todos
para codificar mensagens de maneira que s√≥ o destinat√°rio possa ler e entender o conte√∫do que
ela cont√©m, de modo que para qualquer outra pessoa que consiga ter acesso a tal mensagem essa
torne-se ileg√≠vel, sendo ent√£o incapaz de ter acesso √†s suas informa√ß√µes. Os c√≥digos utilizados na
criptografia para codificar uma mensagem e tamb√©m para decodific√°-la s√£o chamadas de chaves.
Embora o conceito utilizado seja bem simples, encontrar uma maneira de codificar tais mensa-
gens com a seguran√ßa necess√°ria, n√£o foi tarefa f√°cil. Isso √© devido √† maneira como estas transa√ß√µes
banc√°rias ocorrem, por exemplo, quando √© realizada uma compra com cart√£o de cr√©dito via in-
ternet, o comprador precisa informar a loja sobre os dados de seu cart√£o de cr√©dito, por√©m, se
esses dados forem revelados a outra pessoa, essa pessoa conseguir√° fazer compras com tal cart√£o
e, assim, para que isso n√£o ocorra, as informa√ß√µes do cart√£o de cr√©dito precisam ser codificadas
pelo computador antes de serem enviadas.

O problema √© que a codifica√ß√£o feita pelo computador do comprador n√£o pode acontecer de
maneira aleat√≥ria, pois a loja que receber√° os dados do cart√£o de cr√©dito precisa saber decodificar.
O que ocorre, √© que a loja informa como deve ser feito a codifica√ß√£o (a chave de codifica√ß√£o),
tornando poss√≠vel para o computador do comprador codificar os dados do cart√£o de cr√©dito de
maneira que a loja consiga decodifica-los e, assim, utilizar tais dados. Por√©m, como o processo de

1

codifica√ß√£o foi enviado via internet pela loja at√© o comprador, ele fica vulner√°vel √† intercepta√ß√µes
de terceiros, os quais uma vez sabendo o c√≥digo (chave) utilizado para codificar os dados do cart√£o
de cr√©dito, podem decodific√°-los desfazendo a codifica√ß√£o realizada. O que, assim sendo, qualquer
que seja o c√≥digo que seu computador utilize para criptografar, ele sempre estar√° sujeito a cair nas
m√£os de terceiros, tornando assim essa opera√ß√£o nada segura.

At√© pouco tempo atr√°s, isso poderia ser verdade, por√©m nos dias atuais existem m√©todos crip-
togr√°ficos que, mesmo tendo acesso a chave utilizada para codificar a mensagem, decodific√°-la n√£o
√© t√£o simples assim. Decodificar a mensagem simplesmente desfazendo o processo de codifica√ß√£o
(utilizando um processo inverso ao utilizado para codificar) torna-se t√£o trabalhoso e demorado de
maneira que √© imposs√≠vel coloc√°-lo em pr√°tica.

Os m√©todos criptograficos v√™m sendo aprimorados desde a √©poca do Imperador Julio C√©sar,
que utilizava mensagens codificadas para se comunicar com seus soldados durante √©poca de guerra.
Por volta do ano de 1960 foi inventada a criptografia que utiliza chaves p√∫blicas, uma criptografia
onde mesmo se a chave transmitida for interceptada n√£o ser√° suficiente para a decodifica√ß√£o da
mensagem. A principal diferen√ßa entre a utiliza√ß√£o da chave p√∫blica de uma chave convencional,
est√° na decodifica√ß√£o da mensagem, pois para se decodificar uma mensagem que se utiliza de uma
chave convencional bastava realizar um processo inverso ao realizado para codificar tal mensagem.
J√° na utiliza√ß√£o da chave p√∫blica, realizar o processo inverso se torna t√£o trabalhoso e demorado
que vem a ser imposs√≠vel decodificar a mensagem atrav√©s deste processo. O porque desse processo
se tornar t√£o trabalhoso tem a mesma ess√™ncia do problema em descobrir se um n√∫mero √© primo.
A chave p√∫blica utilizada na criptografia RSA √© constitu√≠da de um n√∫mero composto suficiente-
mente grande, enquanto que a chave que ficar√° privada (e ser√° utilizada para decodificar) consiste
dos fatores primos de tal n√∫mero composto. Como dito anteriormente, √© um processo que n√£o
conhecemos nenhum m√©todo eficaz o suficiente, tornando segura a Criptografia RSA. Desfazer o
processo, ou seja, fatorar tal n√∫mero ou encontrar os primos que o comp√µe, √© um processo que
ainda n√£o conhecemos nenhum m√©todo eficaz suficiente, e esse fato √© o que torna tal chave segura.
Assim sendo, esse trabalho se pautar√° no estudo de m√©todos para se detectar n√∫meros primos
e de uma aplica√ß√£o envolvendo n√∫meros primos, a Criptografia de Chave P√∫blica, a qual se utiliza
de propriedades especiais dos n√∫meros primos. No cap√≠tulo 1 ser√° abordado um estudo a partir da
defini√ß√£o dos n√∫meros primos, onde, com a ajuda de alguns resultados matem√°ticos importantes,
avan√ßaremos o conhecimento sobre os n√∫meros primos, a ponto de tra√ßar testes de primalidades
modernos que ser√£o analisados no Cap√≠tulo 2 no qual levantaremos as vantagens e desvantagens
de cada um. Ao final do Cap√≠tulo 2 poder√° se constatar o grande problema que todos os testes de
primalidade sofrem, e que ser√° a ess√™ncia dos m√©todos criptogr√°ficos, que ser√£o apresentados no
Cap√≠tulo 3. No Cap√≠tulo 4 ser√° apresentada uma sequ√™ncia did√°tica idealizada que pode servir de
molde para uma utiliza√ß√£o em sala de aula.

2

Cap√≠tulo 1

PRELIMINARES

Ser√° tratado nesse cap√≠tulo o estudo de alguns teoremas, ideias e conceitos sobre n√∫meros
inteiros os quais s√£o imprescind√≠veis para a an√°lise e compreens√£o dos n√∫meros primos, bem como
a dificuldade em se detectar a primalidade de um n√∫mero, sendo esse o grande trunfo do m√©todo
criptogr√°fico RSA.

O resultado mais relevante at√© o momento para se detectar a primalidade de um n√∫mero √© o
chamado teste de Miller, o qual utiliza a aritm√©tica modular para analisar e encontrar n√∫meros
primos. Esse teste de primalidade √© o que se tem de mais moderno para se detectar se um n√∫mero √©
primo ou n√£o, mas mesmo assim ainda s√≥ √© vi√°vel sua utiliza√ß√£o at√© certo ponto, pois dependendo
do tamanho do n√∫mero a ser examinado, tal teste pode demorar tanto tempo para encontrar uma
resposta, que utiliz√°-lo se torna invi√°vel.
Afinal, o que √© um n√∫mero primo?

Defini√ß√£o 1. Um n√∫mero inteiro positivo √© chamado de primo quando possui somente dois divi-
sores: 1 e ele pr√≥prio.

Defini√ß√£o 2. Um n√∫mero inteiro positivo √© chamado de composto quando possui 3 ou mais
divisores.

Exemplo 1. 8 n√£o √© primo, pois 4 divide 8
5 √© primo, pois 2 n√£o divide 5, 3 n√£o divide 5 e 4 n√£o divide 5.

Quando um n√∫mero ùëè divide um n√∫mero ùëõ, escrevemos: ùëè | ùëõ , exemplo: 4 | 8 (4 divide 8). O
que equivale a dizer que a divis√£o de ùëõ por ùëè deixa resto zero ou ainda que: ùëõ = ùëè ¬∑ ùëû, exemplo:
8 = 4 ¬∑ 2.

Se um n√∫mero ùëè n√£o divide um n√∫mero ùëõ, escrevemos: ùëè (cid:45) ùëõ. O que equivale a dizer que a
divis√£o de ùëõ por ùëè deixa resto diferente de zero, ou ainda: ùëõ = ùëè ¬∑ ùëû + ùëü, com 0 < ùëü < ùëè, exemplo:
11 = 4 ¬∑ 2 + 3.

Neste ponto √© importante utilizarmos, como recurso, o Algoritmo da Divis√£o, o qual ajudar√°
a identificarmos mais rapidamente os poss√≠veis resultados. Tal Algoritmo nos diz que todo ùëõ ‚àà Z
pode ser escrito como:

3

Figura 1.1: Algoritmo da divis√£o

ùëõ = ùëè ¬∑ ùëû + ùëü, onde 0 ‚â§ ùëü < ùëè, sendo ùëè ‚àà N.
Assim sendo, temos os poss√≠veis casos:

‚Ä¢ Se ùëü = 0, temos que ùëè divide ùëõ e podemos escrever: ùëè | ùëõ.

‚Ä¢ Se ùëü Ã∏= 0, temos que ùëè n√£o divide ùëõ e escrevemos ùëè (cid:45) ùëõ.

Como saber se um n√∫mero √© primo?
Quanto maior for o n√∫mero a ser verificado, maior a quantidade de candidatos a divisores este

n√∫mero ter√°.

Exemplo 2. 5021 √© primo?

Para verificar se ele √© primo olhando para a defini√ß√£o de n√∫meros primos, temos que 5021 √©
primo se for divis√≠vel somente por 1e por ele mesmo, logo teria que se verificar se 5021 n√£o √©
divis√≠vel por 2, por 3, por 4, por 5, por 6,..., por 5020, o que d√° um total de 5018 candidatos a
verificar.

1.1 Teorema Fundamental da Aritm√©tica

Todos os n√∫meros n√£o primos podem ser formados como produtos de primos e de maneira

√∫nica, √© o que diz o Teorema Fundamental da Aritm√©tica:

Teorema 1. (Teorema Fundamental da Aritm√©tica) Um n√∫mero natural maior que 1, ou √© primo,
ou se escreve de maneira √∫nica como um produto de primos, a menos de ordena√ß√£o.

Demonstra√ß√£o: Vamos primeiro demonstrar que um n√∫mero natural ùëõ se escreve como um

produto de primos:

Para isso iremos utilizar o pr√≠ncipio de indu√ß√£o finita. Observe que ùëõ = 2, o teorema √© valido,
pois 2 √© primo. Suponha agora que o teorema √© valido para todo n√∫mero natural maior que 2 e
menor que ùëõ e, ent√£o, provaremos que tamb√©m √© v√°lido para ùëõ. Observe que dessa forma ùëõ n√£o √©
primo e, portanto, existe 2 ‚â§ ùëõ1 < ùëõ que divide ùëõ, e ent√£o escrevemos ùëõ = ùëõ1 ¬∑ ùëò sendo 2 ‚â§ ùëò < ùëõ.
Dessa forma por hip√≥tese de indu√ß√£o, temos que ùëõ1 e ùëò podem ser escrito como produto de primos:
ùëõ1 = ùëù1 ¬∑ ¬∑ ¬∑ ùëùùëõ e ùëò = ùëû1 ¬∑ ¬∑ ¬∑ ùëûùëõ, e ent√£o podemos escrever ùëõ = ùëõ1 ¬∑ ùëò = ùëù1 ¬∑ ¬∑ ¬∑ ùëùùëõ ¬∑ ùëû1 ¬∑ ¬∑ ¬∑ ùëûùëõ.

Falta agora demonstrar a unicidade dessa escrita.

4

Suponha por absurdo que ùëõ possa ser escrito de duas maneiras diferentes ao menos da ordem

de seus fatores, ou seja:
ùëõ = ùëù1 ¬∑ ùëù2 ¬∑ ... ¬∑ ùëùùëõ e tamb√©m:
ùëõ = ùëû1 ¬∑ ùëû2 ¬∑ ... ¬∑ ùëûùë†, com ùëùùëñ e ùëûùëó n√∫meros primos sendo ùëñ ‚àà {1, 2, ..., ùëõ} e ùëó ‚àà {1, 2, ..., ùë†}.
Observe que ùëù1|ùëõ pois ùëõ = ùëù1 ¬∑ ùëù2 ¬∑ ... ¬∑ ùëùùëõ , e dessa forma temos tamb√©m que:

ùëù1|ùëû1 ¬∑ ùëû2 ¬∑ ... ¬∑ ùëûùë† que tamb√©m podemos escrever:
ùëû1 ¬∑ ùëû2.... ¬∑ ùëûùë† = ùëù1 ¬∑ ùëé

Podemos reordenar os ùëûùëó de forma que ùëù1 = ùëû1.

Como ùëù1 √© um n√∫mero primo e ùëûùëó tamb√©m s√£o primos, conclui-se que ùëù1 = ùëûùëó para algum ùëó.

Desta forma podemos simplificar a igualdade ùëû1 ¬∑ ùëû2 ¬∑ ... ¬∑ ùëûùë† = ùëù1 ¬∑ ùëé obtendo: ùëû2 ¬∑ ... ¬∑ ùëûùë† = ùëé
Lembrando que ùëõ = ùëù1 ¬∑ ùëù2 ¬∑ ... ¬∑ ùëùùëõ , temos ent√£o que ùëé = ùëù2 ¬∑ ... ¬∑ ùëùùëõ, e portanto:

ùëù2|ùëé , e portanto, como ùëû2 ¬∑ ... ¬∑ ùëûùë† = ùëé, temos que:
ùëù2|ùëû2 ¬∑ ... ¬∑ ùëûùë† que √© o mesmo de:
ùëû2 ¬∑ ... ¬∑ ùëûùë† = ùëù2 ¬∑ ùëè onde ùëè = ùëù3 ¬∑ ... ¬∑ ùëùùëõ

Como ùëù2 √© um n√∫mero primo e ùëûùëó tamb√©m s√£o primos, conclui-se que ùëù2 = ùëûùëó para algum ùëó.

Podemos reordenar os ùëûùëó de forma que ùëù2 = ùëû2.

Podendo assim simplificar a igualdade ùëû2 ¬∑ ... ¬∑ ùëûùë† = ùëè obtendo: ùëû3 ¬∑ ... ¬∑ ùëûùë† = ùëù3 ¬∑ ... ¬∑ ùëùùëõ
Prosseguindo desta forma, podemos concluir que ùëù1 = ùëû1, ùëù2 = ùëû2, ..., ùëùùëõ = ùëûùë†, provando assim,

que ùëõ se escreve como produtos de primos de maneira √∫nica.

O Teorema Fundamental da Aritm√©tica √© o resultado que nos permite escrever qualquer n√∫mero
como um produto de primos. No ensino Fundamental o utilizamos em muitas ocasi√µes, simplificar
fra√ß√µes, calcular o m.m.c., m.d.c. entre outras aplica√ß√µes.

Exemplo 3. Escrevendo 10 e 18 como um produto de primos, temos:

10 = 2 ¬∑ 5
18 = 32 ¬∑ 2

O Teorema Fundamental da Aritm√©tica garante que um n√∫mero composto ter√° sempre os
mesmos n√∫meros primos em sua composi√ß√£o. Desta maneira, utilizando o algoritmo da fatora√ß√£o
podemos encontrar os fatores primos de um n√∫mero e escrev√™-lo como um produto de primos.

Podemos melhorar um pouco esse m√©todo se notarmos o seguinte:
Voltando ao exemplo 2, ao verificar que o n√∫mero 5021 n√£o √© divis√≠vel por 2, podemos afirmar
que este n√∫mero (pelo Teorema Fundamental da Aritm√©tica) n√£o cont√©m o fator 2 em sua decompo-
si√ß√£o em fatores primos, e portanto, nenhum outro n√∫mero que contenha o 2 em sua decomposi√ß√£o
(os m√∫ltiplos de 2) pode dividir o n√∫mero 5021. Nenhum n√∫mero do conjunto ùëÄ (2) = {2, 4, 6, 8, ...}
divide o n√∫mero 5021.

Utilizando o mesmo pensamento para todos os outros primos menores que 5021, podemos
concluir que basta verificar ent√£o se o n√∫mero em quest√£o, no caso 5021, √© divis√≠vel pelos primos
que ser√£o menores que ele.

Se pensarmos um pouco adiante, conseguiremos deduzir que tamb√©m n√£o se faz necess√°rio

verificar todos os primos menores que o n√∫mero em quest√£o.

Exemplo 4. Para o n√∫mero 73, temos que: 2 n√£o divide 73, 3 n√£o divide 73, 5 n√£o divide 73 e 7
73 < 9, temos que 9 ¬∑ 9 > 73 , e dessa forma n√£o existe nenhum fator primo
n√£o divide 73 e como

‚àö

5

de 73 maior do que
‚àö

73 ( j√° que verificamos para todos os menores do que

73, porque se houvesse o outro fator primo tamb√©m teria que ser maior que
73,) o que gera um absurdo, uma vez

‚àö

‚àö

que a multiplica√ß√£o de dois n√∫meros maiores do que 9 √© sempre maior do que 73.

Dessa forma para saber se um n√∫mero √© primo, basta verificar se ele √© divis√≠vel por algum

n√∫mero primo menor ou igual a raiz quadrada deste n√∫mero.

‚àö

No caso do 5021, basta verificar se ele √© divis√≠vel por algum n√∫mero primo menor ou igual a

5021 ‚âÉ 71, se nenhuma destas verifica√ß√µes acontecer 5021 ser√° primo.

Embora torne o m√©todo mais eficaz ele ainda funciona at√© certo ponto, j√° que quando se trata
de n√∫meros grandes, os n√∫meros que precisam ser verificados acabam sendo muitos, sem contar
que, faz-se necess√°rio conhecer todos os n√∫meros primos que s√£o menores que a raiz quadrada
deste.

Para seguir em frente, √© fundamental utilizar uma aritm√©tica focada nos restos de divis√µes, a

chamada arim√©tica modular.

Utilizando a divis√£o euclidiana, temos que um n√∫mero ùëõ ‚àà Z pode ser escrito como: ùëõ = ùëö¬∑ùëû+ùëü

onde ùëö ‚àà N e 0 ‚â§ ùëü < ùëö.

Mas, e se o que se precisa analisar for somente o resto desta divis√£o sem se preocupar com o

valor do quociente?

Nesse caso, poderemos escrever: ùëõ ‚â° ùëü mod ùëö, ou seja, ùëõ deixa resto ùëü quando dividido por

ùëö, ou ainda de uma maneira mais geral:
ùëõ ‚â° ùëé mod ùëö, dizemos que ùëõ √© congruo a ùëé no m√≥dulo ùëö, o que significa que ùëõ e ùëé tem o mesmo
resto na divis√£o por ùëö.

Tra√ßando um paralelo com a divisibilidade, podemos escrever tamb√©m:

ùëö|ùëõ ‚àí ùëé ‚áî ùëõ ‚â° ùëé mod ùëö, pois, se ùëõ e ùëé deixam o mesmo resto na divis√£o por ùëö, temos que a
diferen√ßa entre ùëõ e ùëé √© divis√≠vel por ùëö.

Exemplo 5. 34 ‚â° 10 mod 3, pois ambos deixam resto 1 quando divididos por 3. Utilizando
divisibilidade temos ent√£o: 3|34 ‚àí 10.

A utiliza√ß√£o da aritm√©tica modular facilita-r√° c√°lculos com n√∫meros grandes, em que, estamos

preocupados somente com o resto que eles deixam quando divididos por algum outro n√∫mero.

Como ilustra√ß√£o, vejamos um exemplo:

Exemplo 6. Qual o resto da divis√£o de 475 por 17?

42 ‚â° ‚àí1 mod 17 pois 42 = 16, portanto:
4 ¬∑ 474 ‚â° 4 ¬∑ (42)37 mod 17
4 ¬∑ (42)37 ‚â° 4 ¬∑ (‚àí1)37 mod 17
475 ‚â° ‚àí4 ‚â° 13 mod 17 , ou seja, o resto da divis√£o de 475 por 17 √© 13.

1.2 Pequeno Teorema de Fermat

Um resultado muito importante e que nos auxilia no c√°lculo de congru√™ncias √© o Pequeno

Teorema de Fermat.

6

Teorema 2. (Pequeno Teorema de Fermat) Se ùëù for um n√∫mero primo, ent√£o ùëù divide ùëéùëù ‚àí ùëé para
todo n√∫mero inteiro ùëé :

ùëù|ùëéùëù ‚àí ùëé, ou ainda: ùëéùëù ‚â° ùëé mod ùëù.

Demonstra√ß√£o:
Uma maneira de se provar tal resultado, √© utilizar o Princ√≠pio de Indu√ß√£o Finita, j√° que ele nos

fornece um m√©todo eficaz de demonstra√ß√µes em situa√ß√µes envolvendo n√∫meros Naturais.

Com o Pequeno Teorema de Fermat faz uso dos N√∫meros Inteiros, provaremos primeiro que ele

√© v√°lido para os N√∫meros Naturais e em seguida estenderems a prova para os N√∫meros Inteiros.

Queremos provar ent√£o, em um primeiro momento, que a proposi√ß√£o ùëéùëù ‚â° ùëé mod ùëù √© v√°lida

para os N√∫meros Naturais.

1)Utilizando ùëé = 1 como base, temos:
ùëéùëù = 1ùëù = 1, ‚àÄ primo ùëù, logo: 1ùëù ‚â° 1 mod ùëù

2) Ap√≥s ter conclu√≠do que para ùëé = 1 √© verdade. Suponhamos que ùëéùëù ‚â° ùëé mod ùëù, ‚àÄùëé ‚àà N esta

√© nossa Hip√≥tese de Indu√ß√£o.

3) Em seguida utilizando nossa hip√≥tese provaremos que:

(ùëé + 1)ùëù ‚â° ùëé + 1 mod ùëù

Expandindo (ùëé + 1)ùëù segundo o Bin√¥mio de Newton: ‚àëÔ∏Äùëù
Se ùëñ = 0 , temos (Ô∏Åùëù
¬∑ ùëéùëù ¬∑ 10 = ùëéùëù.
Se ùëñ = ùëù , temos (Ô∏Åùëù
¬∑ ùëéùëù‚àíùëù ¬∑ 1ùëù = 1ùëù.
Logo tirando estes dois casos do somat√≥rio, temos:

)Ô∏Å

)Ô∏Å

ùëù

0

ùëñ=0

)Ô∏Å

(Ô∏Åùëù
ùëñ

¬∑ ùëéùëù‚àíùëñ ¬∑ 1ùëñ.

(ùëé + 1)ùëù = ùëéùëù + 1ùëù +

)Ô∏É

ùëù‚àí1
‚àëÔ∏Å

ùëñ=1

(Ô∏Éùëù
ùëñ

¬∑ ùëéùëù‚àíùëñ ¬∑ 1ùëñ

Como (Ô∏Åùëù
ùëñ

ùëñ!

)Ô∏Å = ùëù¬∑(ùëù‚àí1)¬∑...¬∑(ùëù‚àíùëñ+1)

, √© sempre inteiro e como ùëù n√£o divide ùëñ!, temos que(Ô∏Åùëù

)Ô∏Å possui ùëù

ùëñ

como um de seus fatores primos e, portanto, ùëù divide (Ô∏Åùëù

)Ô∏Å.

ùëñ

Em termos de congru√™ncia: (Ô∏Åùëù
ùëñ
Assim:

)Ô∏Å

‚â° 0 mod ùëù.

)Ô∏É

ùëù‚àí1
‚àëÔ∏Å

ùëñ=1

(Ô∏Éùëù
¬∑
ùëñ

¬∑ ùëéùëù‚àíùëñ ¬∑ 1ùëñ ‚â° 0 mod ùëù.

E como por Hip√≥tese de Indu√ß√£o temos que ùëéùëù ‚â° ùëé mod ùëù, ‚àÄùëé ‚àà N, podemos concluir que:

ùëéùëù + 1ùëù +

)Ô∏É

ùëù‚àí1
‚àëÔ∏Å

ùëñ=1

(Ô∏Éùëù
ùëñ

¬∑ ùëéùëù‚àíùëñ ¬∑ 1ùëñ ‚â° ùëé + 1 mod ùëù

Encontrando assim que:
(ùëé + 1)ùëù ‚â° ùëéùëù + 1ùëù + ‚àëÔ∏Äùëù‚àí1
¬∑ ùëéùëù‚àíùëñ ¬∑ 1ùëñ ‚â° ùëéùëù + 1ùëù ‚â° (ùëé + 1) mod ùëù.
ùëñ=1
Desta forma provamos que : ùëéùëù ‚â° ùëé mod ùëù √© valido para todo ùëé ‚àà N

(Ô∏Åùëù
ùëñ

)Ô∏Å

7

Precisamos agora, estender esse resultado para os N√∫meros Inteiros (Z), para isso falta que

provemos que ùëéùëù ‚â° ùëé mod ùëù tamb√©m √© valido para os n√∫meros negativos.

Em um primeiro momento suponha que ùëù = 2 e ùëé = ‚àíùõº, com ùõº positivo:
(‚àíùõº)2 ‚â° ‚àíùõº mod 2
ùõº2 ‚â° ‚àíùõº mod 2
ùõº2 + ùõº ‚â° 0 mod 2
Observe agora que, se ùõº for par , ou seja : ùõº = 2ùëò, temos: (2ùëò)2 + 2ùëò ‚â° 0 mod 2 , que √©

sempre verdade.

Se ùõº for √≠mpar, ou seja: ùõº = 2ùëò + 1, temos:
(2ùëò + 1)2 + 2ùëò + 1 ‚â° 2.2ùëò2 + 2 ¬∑ 2ùëò + 1 + 2ùëò + 1 ‚â° 0 mod 2, que tamb√©m √© sempre verdade.
Assim, conclu√≠mos que, se ùëù = 2, temos que ùëéùëù ‚â° ùëé mod ùëù √© sempre verdade ‚àÄùëé ‚àà Z. Por
√∫ltimo falta provarmos que, se ùëù for um n√∫mero √≠mpar (uma vez que o √∫nico primo par existente
√© o 2) e ùëé um n√∫mero negativo, continua sendo v√°lido: ùëéùëù ‚â° ùëé mod ùëù.

Suponhamos ent√£o ùëé = ‚àíùõº e ùëù um primo √≠mpar, sendo ùõº ‚àà N, temos:
(‚àíùõº)ùëù = ‚àíùõºùëù, pois ùëù √© √≠mpar.
Utilizemos ent√£o ùõºùëù ‚â° ùõº mod ùëù, resultado que j√° provamos para os N√∫meros Naturais utili-
zando o Princ√≠pio da Indu√ß√£o Finita, e em seguida podemos multiplicar por (‚àí1) ambos os lados
da congru√™ncia, obtendo:

‚àíùõºùëù ‚â° ‚àíùõº mod ùëù, como ùëù √© √≠mpar:
(‚àíùõº)ùëù ‚â° ‚àíùõº mod ùëù, resultado ent√£o que o Teorema tamb√©m √© valido para os n√∫meros nega-

tivos.

Como o caso ùëé = 0 √© trivial, concluimos assim, a demonstra√ß√£o de que ùëéùëù ‚â° ùëé mod ùëù √© valido

para todo ùëé ‚àà Z e ùëù primo.

Exemplo 7.

43 ‚â° 4 mod 3 ‚áí 43 ‚â° 1 mod 3

62 ‚â° 6 mod 2 ‚áí 62 ‚â° 0 mod 2

√â importante observar que o Pequeno Teorema de Fermat diz respeito a congru√™ncias cujo
m√≥dulo s√£o apenas n√∫meros primos, o que traz uma restri√ß√£o quanto a sua utiliza√ß√£o. Essa restri√ß√£o
j√° n√£o existe no Teorema apresentado por Euler o qual abrange todos os n√∫meros inteiros.

Teorema 3. (Teorema de Euler) Sejam ùëé ‚àà Z e ùëõ ‚àà N, se (ùëé, ùëõ) = 1 ent√£o:

ùëéùúë(ùëõ) ‚â° 1 mod ùëõ,

primo com ùëõ, onde √© poss√≠vel calcul√°-la escrevendo ùëõ como um produto de primos: ùëõ = ùëùùõº1

sendo ùúë(ùëõ) a quantidade de elementos do conjunto dos poss√≠veis restos na divis√£o por n que s√£o
1 ¬∑...¬∑ùëùùõºùëõ
ùëõ ,
com ùëù1, ùëù2, ..., ùëùùëõ n√∫meros primos distintos e ùõº1, ùõº2, ..., ùõºùëõ n√∫meros inteiros positivos.Desta

forma:

ùúë(ùëõ) = ùúë(ùëùùõº1
1

¬∑ ... ¬∑ ùëùùõºùëõ
ùëõ

) = ùëùùõº1‚àí1
1

¬∑ ... ¬∑ ùëùùõºùëõ‚àí1

ùëõ

¬∑ (ùëù1 ‚àí 1) ¬∑ ... ¬∑ (ùëùùëõ ‚àí 1)

8

Observe que se n for um n√∫mero primo, temos: ùúë(ùëõ) = ùúë(ùëù) = ùëù1‚àí1 ¬∑ (ùëù ‚àí 1) = ùëù ‚àí 1, e ent√£o:
ùëéùúë(ùëõ) ‚â° 1 mod ùëõ ‚áí ùëéùëù‚àí1 ‚â° 1 mod ùëù , que nada mais √© do que o Pequeno Teorema de Fermat

em uma outra vers√£o a qual estudaremos mais adiante.

Para compreender um pouco mais sobre o Pequeno Teorema de Fermat e sobre a ordem de um

n√∫mero ùëõ, se faz necess√°rio estudar um pouco sobre Grupos.

1.3 Grupos

Um Grupo √© um conjunto que possui uma opera√ß√£o bem definida al√©m de satisfazer algumas

propriedades.

Para tal opera√ß√£o estar bem definida ela deve associar a cada dois elementos desse grupo um

terceiro elemento tamb√©m desse grupo:

Por√©m para tal conjunto constituir um grupo, precisa tamb√©m satisfazer as seguintes proprie-

ùëé, ùëè ‚àà ùê∫ ‚áí ùëé * ùëè ‚àà ùê∫.

dades:

1. Associatividade: ùëé * (ùëè * ùëê) = (ùëé * ùëè) * ùëê

2. Elemento Neutro: ùëé * ùëí = ùëí * ùëé = ùëé

3. Elemento Inverso ùëé * ùëé‚Ä≤ = ùëé‚Ä≤ * ùëé = ùëí

Um grupo muito utilizado √© o dos N√∫meros Inteiros com a opera√ß√£o da adi√ß√£o:
Temos que ùëé, ùëè ‚àà Z ‚áí ùëé + ùëè ‚àà Z e tamb√©m que vale:

1. Associatividade ùëé + (ùëè + ùëê) = (ùëé + ùëè) + ùëê

2. Elemento Neutro ùëé + 0 = 0 + ùëé = ùëé

3. Elemento Inverso ùëé + (‚àíùëé) = (‚àíùëé) + ùëé = 0

Caracterizando, assim, o conjunto dos N√∫meros Inteiros como um grupo para com a adi√ß√£o.
Entretanto, o conjunto dos N√∫meros Inteiros n√£o forma um grupo com a opera√ß√£o de multipli-
ca√ß√£o,pois apesar da opera√ß√£o estar bem definida: ùëé, ùëè ‚àà ùëç ‚áí ùëé ¬∑ ùëè ‚àà Z, e possuir as propriedades
Associativa e Elemento Neutro, ela n√£o possui Elemento Inverso:

1. Associatividade ùëé ¬∑ (ùëè ¬∑ ùëê) = (ùëé ¬∑ ùëè) ¬∑ ùëê;

2. Elemento Neutro ùëé ¬∑ 1 = 1 ¬∑ ùëé = ùëé.

9

Por√©m, (cid:64)ùëé‚Ä≤ ‚àà Z, tal que: ùëé ¬∑ ùëé‚Ä≤ = ùëé‚Ä≤ ¬∑ ùëé = 1, e, portanto, podemos concluir que os N√∫meros
Inteiros n√£o formam um grupo para com a opera√ß√£o de multiplica√ß√£o, pois ela n√£o possui elemento
inverso.

Ao se utilizar congru√™ncias, os grupos utilizados s√£o os Zùëõ, ou seja, Inteiros m√≥dulo ùëõ, vejamos

alguns exemplos:

1) Ao se analisar Z4, temos como classes residuais: ¬Ø0, ¬Ø1, ¬Ø2, ¬Ø3 (os poss√≠veis restos na divis√£o por

4). Logo, temos uma congru√™ncia do tipo: ùëé ‚â° ùëè mod 4 onde ùëé, ùëèùëí ‚àà Z e ¬Øùëé ‚àà

{Ô∏Å¬Ø0, ¬Ø1, ¬Ø2, ¬Ø3}Ô∏Å.

Vejamos se Z4 √© um grupo com a opera√ß√£o de adi√ß√£o:
Temos que ùë•, ùë¶ ‚àà Z ‚áí ùë• + ùë¶ ‚àà Z e ùë• ‚â° ùëè1 mod ùëõ e ùë¶ ‚â° ùëè2 mod ùëõ ‚áí ùë• + ùë¶ ‚â° ùëè1 + ùëè2 mod ùëõ.
Como ùëè1 ùëí ùëè2 ‚àà

, vejamos todas as possibilidades de ùëè1 + ùëè2 mod 4 :

{Ô∏Å¬Ø0, ¬Ø1, ¬Ø2, ¬Ø3}Ô∏Å

+ 0
0
0
1
1
2
2
3
3

1
1
2
3
0

2
2
3
0
1

3
3
0
1
2

Tabela 1.1: Adi√ß√£o em Z4

Verifica-se que ùëè1 + ùëè2 ‚àà Z4 e que:

1. Associatividade: ùëé + (ùëè + ùëê) = (ùëé + ùëè) + ùëê

2. Elemento Neutro: ùëé + 0 = 0 + ùëé = ùëé

3. Elemento Inverso ùëé + (‚àíùëé) = (‚àíùëé) + ùëé = 0

Desta forma Z4 √© um grupo com a opera√ß√£o de Adi√ß√£o.
Vejamos agora se Z4 tamb√©m √© um grupo com a opera√ß√£o de Multiplica√ß√£o:
Seguindo os mesmos passos, temos que ùë•, ùë¶ ‚àà Z ‚áí ùë• ¬∑ ùë¶ ‚àà Z e ùë• ‚â° ùëè1 mod ùëõ e ùë¶ ‚â° ùëè2

mod ùëõ ‚áí ùë• ¬∑ ùë¶ ‚â° ùëè1 ¬∑ ùëè2 mod ùëõ.

Como ùëè1 e ùëè2 ‚àà

{Ô∏Å¬Ø0, ¬Ø1, ¬Ø2, ¬Ø3}Ô∏Å

, vejamos todas as possibilidades de ùëè1 ¬∑ ùëè2 mod 4.

.
0
1
2
3

0
0
0
0
0

1
0
1
2
3

2
0
2
0
2

3
0
3
2
1

Tabela 1.2: Multiplica√ß√£o em Z4

Verifica-se que ùëè1 ¬∑ ùëè2 ‚àà Z4 .
Em seguida precisamos analisar se √© v√°lido:

10

1. Associatividade: ùëé ¬∑ (ùëè ¬∑ ùëê) ‚â° (ùëé ¬∑ ùëè) ¬∑ ùëê mod 4

2. Elemento Neutro: ùëé ¬∑ 1 ‚â° 1 ¬∑ ùëé ‚â° ùëé mod 4

3. Elemento Inverso ùëé ¬∑ ùëè ‚â° ùëè ¬∑ ùëé ‚â° 1 mod 4

As propriedades 1 e 2 podem ser facilmente analisadas pelas propriedades da multiplica√ß√£o, j√°
a propriedade 3 precisa ser analisado com um pouco mais de cuidado. Analisando todas as classes
residuais de Z4 temos:

Estamos analisando se ùëé ¬∑ ùëè ‚â° ùëè ¬∑ ùëé ‚â° 1 mod 4 para todo ùëé ‚àà Z4‚àñ{0}
Repare que, quando ùëé = 2, n√£o existe nenhum ùëè ‚àà Z4 tal que:

ùëé ¬∑ ùëè ‚â° ùëè ¬∑ ùëé ‚â° 1 mod 4

Logo, Z4 n√£o √© um grupo com a opera√ß√£o de multiplica√ß√£o.
A aus√™ncia deste inverso multiplicativo muitas vezes √© um problema, inclusive no estudo de
n√∫meros primos e de fatora√ß√£o, onde √© utilizada a multiplica√ß√£o com frequ√™ncia. Por esse motivo,
precisamos utilizar um grupo para com a opera√ß√£o de multiplica√ß√£o, e como a falta do Elemento
Inverso √© sempre um problema, comecemos procurando condi√ß√µes para que ùëé‚Ä≤, ùëé ‚àà Zùëõ, tenham a
propriedade:

ùëé ¬∑ ùëé‚Ä≤ ‚â° ùëé‚Ä≤ ¬∑ ùëé ‚â° 1 mod ùëõ, o que s√≥ acontecer√° se: ùëé ¬∑ ùëé‚Ä≤ + ùëû ¬∑ ùëõ = 1, com ùëõ ‚àà Z, observe que
podemos encontrar tal resultado utilizando o algoritmo extendido de Euclides em (ùëé, ùëõ) = 1, e
dessa forma para que o conjunto possua Elemento Inverso precisamos encontrar um ùëõ que seja
primo com ùëé.

Observe que ao utilizar o conjunto Zùëù, sendo ùëù um n√∫mero primo, a condi√ß√£o (ùëé, ùëù) = 1 √©
respeitada sempre que ùëù (cid:45) ùëé, mas observe que quando ùëù | ùëé, temos que ùëé = ùëù.ùëû para algum ùëû ‚àà Z,
e assim sendo, ùëé = ¬Ø0, portanto tal conjunto possui Elemento Inverso para todos os seus elementos
com excess√£o √© claro do zero (vale lembrar que em um grupo com a opera√ß√£o de multiplica√ß√£o n√£o
teremos Elemento Neutro e nem Elemento Inverso para o zero).

Nas congru√™ncias podemos obter um grupo para com a opera√ß√£o de multiplica√ß√£o ao utilizar
o conjunto Zùëõ desde que ùëõ seja um n√∫mero primo, j√° que assim, desta maneira, temos tamb√©m
o inverso multiplicativo (uma demonstra√ß√£o para tal resultado pode ser encontrada em Coutinho
2.013 p.141, 142.)

Vamos analisar o conjunto Z5 e provar que ele constitui um grupo para com a opera√ß√£o de

adi√ß√£o e tamb√©m para com a opera√ß√£o de multiplica√ß√£o:

Temos que ùëé, ùëè, ùëê ‚àà Z5 ‚áí ùëé + ùëè ‚àà Z e tamb√©m que vale:

1. Associatividade: ùëé + (ùëè + ùëê) ‚â° (ùëé + ùëè) + ùëê mod 5;

2. Elemento Neutro: ùëé + 0 ‚â° 0 + ùëé ‚â° ùëé mod 5;

3. Elemento Inverso ùëé + (‚àíùëé) ‚â° (‚àíùëé) + ùëé ‚â° 0 mod 5.

Com rela√ß√£o a Multiplica√ß√£o :
ùëé, ùëè ‚àà Z ‚áí ùëé ¬∑ ùëè ‚àà Z

11

1. Associatividade ùëé ¬∑ (ùëè ¬∑ ùëê) ‚â° (ùëé ¬∑ ùëè) ¬∑ ùëê mod 5;
2. Elemento Neutro ùëé ¬∑ 1 ‚â° 1 ¬∑ ùëé ‚â° ùëé mod 5,sendo ùëé Ã∏= ¬Ø0;
3. Elemento Inverso ùëé ¬∑ ùëè ‚â° ùëè ¬∑ ùëé ‚â° 1 mod 5sendo ùëé Ã∏= ¬Ø0.

Falta atentarmos com a quest√£o do inverso multiplicativo, observe que verificasse que para todo

ùëé ‚àà Z5‚àñ{0} , existe seu inverso multiplicativo ùëè ‚àà Z5

ùëé ¬∑ ùëè ‚â° ùëè ¬∑ ùëé ‚â° 1 mod 5
1 ¬∑ 1 ‚â° 1 ¬∑ 1 ‚â° 1 mod 5
2 ¬∑ 3 ‚â° 3 ¬∑ 2 ‚â° 1 mod 5
4 ¬∑ 4 ‚â° 4 ¬∑ 4 ‚â° 1 mod 5
E, desta forma, Z5 √© um grupo tanto para a adi√ß√£o quanto para a multiplica√ß√£o.
Voltemos ao Pequeno Teorema de Fermat: ele nos diz que se ùëù √© primo, temos: ùëéùëù ‚â° ùëé mod ùëù,
tomemos aqui o inverso multiplicativo de ùëé, ou seja, ùëè ‚àà Z, tal que: ùëé ¬∑ ùëè ‚â° 1 mod ùëù. Podemos
multiplicar ambos os lados da congru√™ncia ùëéùëù ‚â° ùëé mod ùëù por ùëè, obtendo:

ùëè ¬∑ ùëéùëù ‚â° ùëè ¬∑ ùëé mod ùëù, e, como ùëè √© inverso de ùëé:
ùëè ¬∑ ùëé ¬∑ ùëéùëù‚àí1 ‚â° ùëè ¬∑ ùëé mod ùëù
1 ¬∑ ùëéùëù‚àí1 ‚â° 1 mod ùëù
ùëéùëù‚àí1 ‚â° 1 mod ùëù.
Dessa forma, podemos entender com mais alguns detalhes o Pequeno Teorema de Fermat. J√° o
Teorema de Euler que √© uma vers√£o mais geral do Pequeno Teorema de Fermat cont√©m o n√∫mero
ùúë(ùëõ), que chamamos de fu√ß√£o phi de Euler, esse n√∫mero √© a quantidade de elementos de um sistema
reduzido de res√≠duos m√≥dulo ùëõ, as vezes tamb√©m chamado de quantidade de classes reduzidas de
res√≠duos, observemos a congru√™ncia: ùë• ‚â° ùë¶ mod 14.

A congru√™ncia acima apresenta o sistema completo de res√≠duos: 0, 1, 2, 3, ..., 13, que s√£o os

poss√≠veis restos de uma divis√£o por 14.

Podemos encontrar tamb√©m o sistema reduzido de res√≠duos:1, 3, 5, 9, 11, 13. Esse sistema redu-
zido de res√≠duos foi formado apenas com os elementos do sistema completo de res√≠duos que s√£o
primos com 14.

Logo como dito acima, temos que ùúë(14) √© a quantidade dos elementos do sistema reduzido de

res√≠duos, ou seja: ùúë(14) = 6.

Generalizando, podemos escrever: ùë• ‚â° ùë¶ mod ùëõ, tem como sistema completo de res√≠duos:
0, 1, 2, 3, ..., ùëõ ‚àí 1 e como sistema reduzido de res√≠duos: Os elementos ùëñ tais que (ùëñ, ùëõ) = 1 e
ùëñ ‚àà {0, 1, 2, 3, 4, 5, ..., ùëõ ‚àí 1} , ou seja, os elementos do sistema completo de res√≠duos que s√£o primos
com ùëõ.

Como calcular ùúë(ùëõ), ou seja, como calcular a quantidade de elementos do sistema reduzido de

res√≠duos?

Come√ßamos com o caso mais simples, quando ùëõ = ùëù ou seja se ùëõ √© um n√∫mero primo, temos
que (ùëñ, ùëù) = 1 para todos ùëñ ‚àà {1, 2, 3, 4, 5, ..., ùëù ‚àí 1} , e, portanto, conclu√≠mos que o n√∫mero de
elementos desse sistema reduzido de res√≠duos √© ùëù ‚àí 1, isto √©, ùúë(ùëù) = ùëù ‚àí 1.

Agora que j√° sabemos como calcular a ordem de ùëù primo, podemos com esse resultado calcular

a ordem de ùëùùëò, com ùëù primo e ùëò ‚àà N.

12

Utilizando o mesmo pensamento, buscaremos encontrar todos os (ùëñ, ùëùùëò) = 1 , onde ùëñ ‚àà {1, 2, 3, ..., ùëù ‚àí 1},

ou seja, queremos encontrar os ùëñ ‚àà {1, 2, 3, ..., ùëù ‚àí 1} que n√£o s√£o divis√≠veis por ùëùùëò. Como estra-
t√©gia, em primeiro lugar, contaremos todos os que s√£o divis√≠veis por ùëùùëò e, em seguida, tiramos do
total, restando assim, os que n√£o s√£o divis√≠veis por ùëùùëò.

Suponhamos 0 ‚â§ ùëé < ùëùùëò, sendo ùëé divis√≠vel por ùëù, logo ùëé se escreve: ùëé = ùëù ¬∑ ùëè e, portanto,

0 ‚â§ ùëè < ùëùùëò‚àí1.

Conclu√≠mos, ent√£o, que existem ùëùùëò‚àí1 inteiros que s√£o divis√≠veis por ùëù. Como temos um total

de ùëùùëò n√∫meros, temos que existem ùëùùëò ‚àí ùëùùëò‚àí1 n√∫meros que n√£o s√£o divis√≠veis por ùëù.

Logo, ùúë(ùëù) = ùëùùëò ‚àí ùëùùëò‚àí1 = ùëùùëò‚àí1 ¬∑ (ùëù ‚àí 1).
Falta agora provar a seguinte proposi√ß√£o:

Proposi√ß√£o 1. Se ùëö e ùëõ ‚àà N com ùëö > 1 e ùëõ > 1 sendo (ùëö, ùëõ) = 1 ent√£o: ùúë(ùëö ¬∑ ùëõ) = ùúë(ùëö) ¬∑ ùúë(ùëõ)

Demonstra√ß√£o:
Para provar tal resultado ser√° utilizada a abordagem feita por [?, p. 133]:

Consideremos a seguinte tabela formada pelos n√∫meros naturais de 1 a ùëö ¬∑ ùëõ:

1
ùëõ + 1
...

2
ùëõ + 2
...

...
...

(ùëö ‚àí 1) ¬∑ ¬∑ ¬∑ (ùëõ + 1) ùëö ‚àí 1 ¬∑ ¬∑ ¬∑ (ùëõ + 2)

...

ùëò
ùëõ + ùëò
...
(ùëö ‚àí 1) ¬∑ ¬∑ ¬∑ (ùëõ + ùëò)

...
...

ùëõ
2 ¬∑ ùëõ
...

... ùëö ¬∑ ùëõ

Como se tem que (ùë°, ùëö ¬∑ ùëõ) = 1 se, e somente se, (ùë°, ùëõ) = (ùë°, ùëö) = 1, para calcular
ùúë(ùëö ¬∑ ùëõ), devemos determinar os inteiros na tabela acima que s√£o simultaneamente
primos com ùëõ e ùëö.

Se o primeiro elemento de uma coluna n√£o for primo com ùëõ, ent√£o todos os ele-
mentos da coluna n√£o s√£o primos com ùëõ. Portanto, os elementos primos com ùëõ est√£o
necessariamente nas colunas restantes que s√£o em n√∫mero ùúë(ùëõ), cujos elementos s√£o
primos com ùëõ, como √© f√°cil verificar. Vejamos agora quais s√£o os elementos primos com
ùëö em cada uma dessas colunas.

Como (ùëö, ùëõ) = 1 , a sequ√™ncia :

ùëò, ùëõ + ùëò, ..., (ùëö ‚àí 1)ùëõ + ùëò

forma um sistema completo de res√≠duo m√≥dulo ùëö e, portanto, ùúë(ùëö) desses elementos
s√£o primos com ùëö. Logo, o n√∫mero de elementos simultaneamente primos com ùëõ e ùëö
√© ùúë(ùëö) ¬∑ ùúë(ùëõ).

Ap√≥s provado que ùúë(ùëö ¬∑ ùëõ) = ùúë(ùëö) ¬∑ ùúë(ùëõ) tais que ùëöùëëùëê(ùëö, ùëõ) = 1 basta tomarmos a decomposi√ß√£o
em fatores primos de n:
¬∑ ... ¬∑ ùëùùõºùëõ
ùëõ

, temos: ùúë(ùëõ) = ùúë(ùëùùõº1
1

¬∑ (ùëù1 ‚àí 1) ¬∑ ... ¬∑ ùëùùõºùëõ‚àí1

¬∑ (ùëùùëõ ‚àí 1) =

Se ùëõ = ùëùùõº1
1

) = ùëùùõº1‚àí1
1

¬∑ ... ¬∑ ùëùùõºùëõ
ùëõ

ùëõ

ùëùùõº1‚àí1
1

¬∑ ... ¬∑ ùëùùõºùëõ‚àí1

ùëõ

¬∑ (ùëù1 ‚àí 1) ¬∑ ... ¬∑ (ùëùùëõ ‚àí 1).

13

Assim sendo, podemos calcular a ordem de um n√∫mero, bastando para isso conhecermos a
sua decomposi√ß√£o em fatores primos. Por√©m, como vimos at√© ent√£o, saber tal decomposi√ß√£o nem
sempre √© tarefa f√°cil, pois, dependendo do tamanho do n√∫mero em quest√£o, torna-se complicado at√©
mesmo saber se ele √© primo. No cap√≠tulo a seguir ser√° apresentado alguns testes de primalidade,
estes testes s√£o os utilizados nos dias atuais pelos computadores quando se precisa verificar a
primalidade de um n√∫mero.

14

Cap√≠tulo 2

TESTES DE PRIMALIDADE

Nesse cap√≠tulo procuraremos falar sobre testes de primalidade atuais, os quais s√£o utilizados
pelos computadores para se detectar se um n√∫mero √© primo, analisando as suas vantagens e des-
vantagens apresentadas. Para tanto, partiremos de uma ideia inicial utilizada pelo matem√°tico
Leibniz, a qual n√£o estava totalmente certa, mas representou um avan√ßo na maneira de se pensar
e analisar a primalidade de um n√∫mero. Ap√≥s o matem√°tico Fermat ter enunciado seu teorema
tratado no cap√≠tulo anterior, Leibniz pensou que, se um n√∫mero qualquer ùëù satisfaz tal teorema,
isso bastaria para tal n√∫mero ser primo.

2.1 Teste De Leibniz

Como dito anteriormente, para Leibniz verificar se um n√∫mero ùëù era primo, ele verificava a
congru√™ncia: ùëéùëù‚àí1 ‚â° 1 mod ùëù, ‚àÄùëé tal que (ùëé, ùëù) = 1, ent√£o, se isso acontecesse, seria suficiente
para que esse n√∫mero fosse primo. Sem ao menos provar tal argumento, Leibniz utilizou essa
rec√≠proca como seu crit√©rio de primalidade, como observaremos abaixo.

Pequeno Teorema de Fermat: Se ùëù for um n√∫mero primo, ent√£o tem-se que ùëù divide ùëéùëù‚àí1 ‚àí 1

com (ùëé, ùëù) = 1, ou seja, ùëù √© primo ‚áí ùëéùëù‚àí1 ‚â° 1 mod ùëù.

Rec√≠proca do Teorema de Fermat: Se ùëù divide ùëéùëù‚àí1 ‚àí 1 sendo (ùëé, ùëù) = 1, ent√£o tem-se que ùëù √©

um n√∫mero primo, ou seja, ùëéùëù‚àí1 ‚â° 1 mod ùëù, ‚àÄùëé ‚àà Z tal que (ùëé, ùëù) = 1 ‚áí ùëù √© primo.

Um outro detalhe importante em seu teste de primalidade, √© que Leibniz utilizava sempre ùëé = 2,

para tornar seus c√°lculos menores.

Teste de Primalidade 1. (Teste de Leibniz) Dado um n√∫mero √≠mpar ùëõ ‚àà N, se 2ùëõ‚àí1 ‚â° 1 mod ùëõ,
ent√£o, ùëõ √© primo.

Ent√£o, se Leibniz quizesse descobrir se um n√∫mero, por exemplo, 229 era primo, bastava para

ele verificar se a congru√™ncia abaixo era satisfeita:

2229‚àí1 ‚â° 2 mod 229
2228 ‚â° 1 mod 229

15

Com um pouco de cuidado e uma calculadora √© poss√≠vel verificar tal congru√™ncia e, portanto,

afirmar que 229 √© um n√∫mero primo.

Por√©m, esse m√©todo nem sempre √© verdadeiro, ou seja, a rec√≠proca do Pequeno Teorema de
Fermat n√£o √© v√°lida, pois existem n√∫meros compostos que tamb√©m a verificam, exemplo o n√∫mero
341:

2341 ‚â° 2 mod 341

Acontece que 341 n√£o √© um n√∫mero primo, pois 341 = 11 ¬∑ 31
Pode-se concluir ent√£o, que este m√©todo n√£o traz a certeza de que o n√∫mero verificado √© primo,
j√° que as vezes ele acerta e as vezes ele erra. Contudo, mesmo assim, ao se verificar uma grande
quantidade de n√∫meros utilizando tal m√©todo, foi constatado que ele acerta muito mais do que
erra, e portanto um n√∫mero que passa em tal teste tem grande possibilidade de ser primo. Quando
um n√∫mero passa por este m√©todo e n√£o √© primo, passa a se denominar pseudo-primo.

2.2 Teste de Miller

A incerteza causada pelo m√©todo de Leibniz n√£o √© boa quando o que precisamos √© saber se
um n√∫mero √© primo. Por√©m, uma mudan√ßa neste m√©todo realizada por G. L. Miller, em 1976, foi
capaz de melhor√°-lo aumentando sua precis√£o e retirando em parte esta incerteza.

O Teste de Miller √© realizado da seguinte maneira:

Teste de Primalidade 2. (Teste de Miller)

Seja n o n√∫mero a ser verificado, podemos admitir n √≠mpar uma vez que, o √∫nico primo par √©

2. Se n √© √≠mpar temos que ùëõ ‚àí 1 √© par e portanto pode ser escrito como:

ùëõ ‚àí 1 = 2ùëò ¬∑ ùëû , onde extra√≠mos a maior pot√™ncia de 2, sendo assim q um n√∫mero √≠mpar.
Ent√£o escolhe-se uma base ùëè inteira, tal que 1 < ùëè < ùëõ ‚àí 1, se algum n√∫mero entre ùëèùëû,
ùëè2¬∑ùëû, . . . , ùëè2ùëò‚àí1¬∑ùëû for congruente a (‚àí1) m√≥dulo ùëõ, ou ùëè2ùëò¬∑ùëû for congruente a 1 m√≥dulo ùëõ, dessa forma
temos que ùëõ √© primo.

O exemplo abaixo utiliza um n√∫mero pequeno para facilitar a compreens√£o:

Exemplo 8. Seja ùëõ = 5021, ent√£o ùëõ ‚àí 1 = 5020 = 22 ¬∑ 1255, ou seja:

ùëò = 2 e ùëû = 1255, escolhemos uma base ùëè tal que 1 < ùëè < 5020, fa√ßamos ent√£o ùëè = 2, se algum

n√∫mero entre:

21255 e 22510 for congruente a ‚àí1 m√≥dulo 5021, ou 25020 for congruente a 1 m√≥dulo 5021, ent√£o

consideremos 5021 um n√∫mero primo.

Calculando assim tais congru√™ncias, teremos:
21255 ‚â° 3658 mod 5021
22510 ‚â° 5020 mod 5021 ‚áí 22510 ‚â° ‚àí1 mod 5021 e temos para a base 2 que o teste √© conclusivo.

√â importante saber que o Teste de Miller tamb√©m n√£o d√° certo sempre. Se acaso utilizarmos
a base 2 e testarmos todos os n√∫meros entre 1 e 1000000000 ele errar√° 1282 vezes, o que √© um
n√∫mero muito pequeno de vezes. Quando um n√∫mero composto passa pelo Teste de Miller tendo
como resultado ser um n√∫mero primo, dizemos que tal n√∫mero √© um pseudoprimo forte para a
base utilizada. A seguir ser√£o apresentados dois exemplos onde √© utilizado o Teste de Miller

16

para verificar a primalidade de um n√∫mero, para que assim possamos compreender melhor a sua
utilidade.

Exemplo 9. Queremos saber se 7561 √© um n√∫mero primo:

‚Ä¢ Escolhemos como base o n√∫mero 17, lembrando que a base tem que estar sempre entre 1 e

ùëõ ‚àí 1.

‚Ä¢ Tiramos uma unidade de 7561, ficando assim com 7560 e em seguida fazemos divis√µes suces-

sivas por 2 at√© encontrar um quociente √≠mpar.

‚Ä¢ Calculamos os restos de ùëèùëû¬∑2ùëñ por ùëõ, sendo no caso ùëñ ‚àà {0, 1, 2, 3}.

7560 = 23 ¬∑ 945

ùëèùëû¬∑ùëñ ‚â° ùëü mod 7561
17945 ‚â° 1 mod 7561
17945¬∑2 ‚â° 1 mod 7561
17945¬∑4 ‚â° 1 mod 7561
17945¬∑8 ‚â° 1 mod 7561

‚Ä¢ Os resultados s√£o analisados da seguinte forma: se ùëñ = 0 e ùëü = 1 ou ùëñ ‚â• 0 e ùëü = ‚àí1, temos

que 7561 √© primo para essa base.
Como temos ùëñ = 0 com ùëü = 1, nosso resultado √© que 7561 √© primo para a base 17, ou seja, √©
um pseudoprimo forte para a base 17.

Exemplo 10. Queremos saber se 1256347 √© um n√∫mero primo:

‚Ä¢ Escolhemos como base o n√∫mero 5, lembrando que a base tem que estar sempre entre 1 e

ùëõ ‚àí 1;

‚Ä¢ Tiramos uma unidade de 1256347, ficando assim com 1256346 e em seguida, fazemos divis√µes

sucessivas por 2 at√© encontrar um quociente √≠mpar: 1256346 = 2 ¬∑ 628173;

‚Ä¢ Calculamos os restos de ùëèùëû¬∑2ùëñ por ùëõ , sendo no caso ùëñ ‚àà {0, 1}.

ùëèùëû¬∑ùëñ ‚â° ùëü mod ùëõ
5628173 ‚â° ‚àí1 mod 1256347
5628173¬∑2 ‚â° 1 mod 1256347

‚Ä¢ Os resultados s√£o analisados da seguinte forma: se ùëñ = 0 e ùëü = 1 ou ùëñ ‚â• 0 e ùëü = ‚àí1 temos

que 1256347 √© primo para esta base.
Como temos ùëñ = 0 com ùëü = ‚àí1 , nosso resultado √© que 1256347 √© primo para a base 5, ou
seja, √© um pseudo-primo forte para a base 5.

17

Como j√° dito neste trabalho, ainda n√£o existe um teste de primalidade que determine todos
os n√∫meros primos de modo eficiente. Nos casos dos n√∫meros 7561 e 1256347, por serem n√∫meros
pequenos, os computadores atuais conseguem atrav√©s do Teste de Miller trazer a certeza de que
se trata de um n√∫mero primo, basta para isso segundo Coutinho (2013) realizar tal teste para 1
4
das bases entre 1 e ùëõ ‚àí 1. Por√©m se um n√∫mero for suficientemente grande, o n√∫mero de bases
entre 1 e ùëõ ‚àí 1 tamb√©m ser√°, e assim ser√° imposs√≠vel, at√© mesmo para o computador, realizar este
das bases em tempo h√°bil. O pr√≥prio software xM√°xima, que utilizamos para realizar
teste para 1
4
as contas, possui um comando o qual realiza automaticamente um teste de primalidade e, ent√£o,
consegue detectar que se trata de n√∫meros primos.

O que se faz hoje em dia quando se precisa descobrir se um n√∫mero √© primo √© utilizar o Teste
de Miller para uma quantidade de bases que acredite ser suficiente, fazendo com que a chance de
erro diminua ainda mais. Alguns softwares utilizam 10 bases previamente escolhidas, e afirmam
que um n√∫mero √© primo quando ele consegue passar pelo Teste de Miller para todas as 10 bases.
A seguir analisaremos o Teste de Lucas, o qual √© tamb√©m um teste determin√≠stico de primalidade

com vantagens e desvantagens em rela√ß√£o ao Teste de Miller.

2.3 Teste de Lucas

Esse teste utiliza como estrat√©gia tentar mostrar que a ordem ùúë(ùëõ) (phi de ùëõ) no n√∫mero ùëõ a
ser testado √© ùëõ ‚àí 1. Desta maneira sabemos que existem ùëõ ‚àí 1 n√∫meros menores que ùëõ os quais
(ùëé, ùëõ) = 1, e sendo assim conclui-se que ùëõ √© primo.

Teste de Primalidade 3. (Teste de Lucas)

Seja ùëõ um inteiro positivo √≠mpar e ùëè um inteiro tal que 2 ‚â§ ùëè ‚â§ ùëõ ‚àí 1. Se: ùëèùëõ‚àí1 ‚â° 1 mod ùëõ e

ùëõ‚àí1
ùëù

ùëè

Ã∏‚â° 1 mod ùëõ para cada fator primo ùëù de ùëõ ‚àí 1 , ent√£o ùëõ √© primo.

O teste de Lucas possui a vantagem de afirmar com certeza que um determinado n√∫mero √©
primo, ou seja, se um n√∫mero passar em tal teste ele com certeza √© um n√∫mero primo, diferente-
mente dos testes anteriores, onde quando um n√∫mero passava no teste havia uma grande chance
de ser primo, por√©m em alguns poucos casos o teste falhava.

Exemplo 11. Vamos utilizar o teste de Lucas para saber se o n√∫mero 7561 √© um n√∫mero primo.

‚Ä¢ Escolhemos uma base para realizar o teste, vamos utilizar ùëè = 888

‚Ä¢ Verificamos se a primeira condi√ß√£o √© valida: ùëèùëõ‚àí1 ‚â° 1 mod ùëõ

8887560 ‚â° 1 mod 7561

‚Ä¢ Verificamos se a segunda condi√ß√£o √© v√°lida:

ùëõ‚àí1
ùëù

Ã∏‚â° 1 mod ùëõ

ùëè
para cada fator primo ùëù de ùëõ ‚àí 1 , ent√£o ùëõ √© primo.
Logo, para isso, fatoramos ùëõ ‚àí 1. Utilizando o algoritmo da fatora√ß√£o encontramos ùëõ ‚àí 1 =
23.33.5.7 e, portanto, temos que verificar para 4 fatores primos:

18

888 7560

2 = 8883780 ‚â° ‚àí1 mod 7561
3 = 8882520 ‚â° 6262 mod 7561
5 = 8881512 ‚â° 5935 mod 7561
7 = 8881080 ‚â° 5291 mod 7561

888 7560

888 7560

888 7560

Uma vez tendo as duas condi√ß√µes satisfeitas podemos concluir que 7561 √© um n√∫mero primo.

Vale lembrar que, se uma das condi√ß√µes n√£o √© satisfeita no teste de Lucas, n√£o significa que o

n√∫mero que temos n√£o √© primo, nesse caso a estrat√©gia √© trocar a base que estamos utilizando.

Exemplo 12. Queremos provar que 31 √© primo utilizando o teste de Lucas:

‚Ä¢ Escolhemos uma base para realizar o teste, vamos utilizar ùëè = 2

‚Ä¢ Verificamos se a primeira condi√ß√£o ùëèùëõ‚àí1 ‚â° 1 mod ùëõ √© valida:

230 ‚â° 1 mod 31;

‚Ä¢ Verificamos se a segunda condi√ß√£o ùëè

Ã∏‚â° 1 mod ùëõ √© v√°lida para cada fator primo ùëù de ùëõ‚àí1:
Logo, para isso, fatoramos ùëõ ‚àí 1 = 30. Utilizando o algoritmo da fatora√ß√£o encontramos
30 = 2 ¬∑ 3 ¬∑ 5 e, portanto, temos que verificar para 3 fatores primos.
2 30

2 ‚â° 1 mod 31

ùëõ‚àí1
ùëù

Observe que o teste falhou j√° no primeiro fator primo de ùëõ ‚àí 1, por√©m 31 √© um n√∫mero primo
muito conhecido. Logo o teste tinha que ter uma resposta positiva, para isso s√≥ o que temos a
fazer √© trocar a base e realizar os passos novamente.

‚Ä¢ Escolhemos uma nova base para realizar o teste, vamos utilizar ùëè = 12;

‚Ä¢ Verificamos se a primeira condi√ß√£o ùëèùëõ‚àí1 ‚â° 1 mod ùëõ √© valida:

1230 ‚â° 1 mod 31

‚Ä¢ Verificamos se a segunda condi√ß√£o ùëè

ùëõ‚àí1
ùëù

Ã∏‚â° 1 mod ùëõ √© v√°lida para cada fator primo ùëù de ùëõ‚àí1:

12 30

2 ‚â° ‚àí1 mod 31
3 ‚â° 25 mod 31
5 ‚â° 2 mod 31

12 30

12 30

Assim, ap√≥s termos comprovados as duas condi√ß√µes, podemos afirmar que 31 √© um n√∫mero

primo.

19

A escolha de uma base que satisfa√ßa ambas as condi√ß√µes pode ser um tanto trabalhosa. Feliz-
mente, segundo Coutinho (2013, p.171) ‚ÄúEm 1.975 Brilhart, Lehmer e Selfridge observaram que
n√£o √© necess√°rio usar uma base √∫nica no teste de Lucas. Podemos nos dar ao luxo de escolher uma
base distinta para cada primo. Com isto obtemos um teste um pouco mais eficiente‚Äù.

Seja ùëõ > 0 um inteiro tal que: ùëõ ‚àí 1 = ùëùùëí1

1 ¬∑ ¬∑ ¬∑ ùëùùëíùëü

ùëü , onde ùëù1 < ¬∑ ¬∑ ¬∑ < ùëùùëü s√£o primos. Se, para cada

ùëñ = 1, ¬∑ ¬∑ ¬∑ , ùëü, existirem inteiros positivos ùëèùëñ com 2 ‚â§ ùëèùëñ ‚â§ ùëõ ‚àí 1 que satisfa√ßam:

ùëñ ‚â° 1 mod ùëõ
ùëèùëõ‚àí1

ùëõ‚àí1
ùëùùëñ

Ã∏‚â° 1 mod ùëõ, ent√£o ùëõ √© primo. N√£o sendo necess√°rio que os ùëèùëñ‚Äôs sejam todos distintos.

ùëè
ùëñ
Vejamos como utilizar tal vers√£o aprimorada deste teste de primalidade:

Exemplo 13. Vamos utilizar o teste de Lucas para provar que o n√∫mero 7 √© um n√∫mero primo.

‚Ä¢ Escolhemos uma nova base para realizar o teste, valor utilizar ùëè = 2

‚Ä¢ Verificamos se a primeira condi√ß√£o ùëèùëõ‚àí1 ‚â° 1 mod ùëõ √© valida:

26 ‚â° 1 mod 7;

‚Ä¢ Verificamos se a segunda condi√ß√£o √© v√°lida:

ùëõ‚àí1
ùëù

Ã∏‚â° 1 mod ùëõ para cada fator primo ùëù de ùëõ ‚àí 1. Assim sendo, ùëõ √© primo.

ùëè
Logo, para isso fatoramos ùëõ‚àí1 = 6. Utilizando o algoritmo da fatora√ß√£o encontramos 6 = 2¬∑3
e, portanto, temos que verificar para 2 fatores primos.

ùëõ‚àí1
ùëù

Ã∏‚â° 1 mod ùëõ

ùëè
2 6
2 ‚â° 1 mod 7 , e o teste falha, desta forma mudamos a base para 3.
3 6
2 ‚â° ‚àí1 mod 7
3 6
3 ‚â° 2 mod 7,

tendo como saida assim que o n√∫mero 7 √© primo.

Apesar do teste de Lucas possuir a grande vantagem de ter como sa√≠da a certeza de que um
determinado n√∫mero √© primo, ele padece tamb√©m de um grande problema. J√° que ao se observar
com aten√ß√£o seu enunciado percebemos que ele tem que ser verificado para cada fator primo
de ùëõ ‚àí 1, ou seja, precisamos fatorar ùëõ ‚àí 1, e como j√° sabemos fatorar um n√∫mero suficientemente
grande pode levar tanto tempo que se torna invi√°vel.

No teste de Lucas a estrat√©gia utilizada √© provar que a ordem de ùëõ √© igual a ùúë(ùëõ), significando
assim que se ùëé < ùëõ √© um inteiro positivo, temos (ùëé, ùëõ) = 1 o que significaria que ùëõ √© primo. Para
encontrar a ordem de um n√∫mero ùëõ, ou seja, encontrar a quantidade de n√∫meros menores que ùëõ e
que tamb√©m s√£o primos com ùëõ, em um primeiro pensamento, pode se tentar contar os elementos
um a um, tarefa essa imposs√≠vel se o n√∫mero em quest√£o for grande o suficiente. Para contornar
esse problema, faz se uso do Teorema da Raiz Primitiva.

Quando ùúë(ùëõ) √© a ordem de ùëé com respeito a ùëõ, ent√£o dizemos que ùëé √© uma raiz primitiva m√≥dulo

ùëõ. ùëé √© raiz primitiva com respeito a ùëõ ‚áî ordem de ùëé com respeito a ùëõ √© igual ùúë(ùëõ) .

20

Teorema 4. (Teorema da Raiz Primitiva)

Se a √© raiz primitiva de p, ent√£o:
ùëé mod ùëù, ùëé2 mod ùëù, ùëé3 mod ùëù, ..., ùëéùëù‚àí1 mod ùëù, s√£o distintos e pertencem a {Ô∏Å¬Ø1... ¬Øùëù ‚àí 1}Ô∏Å

, ou

seja, a raiz primitiva gera todos os elementos do grupo multiplicativo Zùëù.

A seguir √© apresentado um exemplo para melhor ilustrar o Teorema:

Exemplo 14. Vamos calcular a ordem de 5 com respeito a 9, o que podemos denotar como:
ùëúùëüùëë9(5).

Como sabemos que ùúë(9) = ùúë(32) = 32‚àí1 ¬∑ (3 ‚àí 1) = 6 e que ùëúùëüùëë9(5)|ùúë(9) = 6, basta calcular as

pot√™ncias dos divisores de 6 para encontrarmos tal ordem:

51 ‚â° 5 mod 9
52 ‚â° 7 mod 9
53 ‚â° 8 mod 9
56 ‚â° 1 mod 9

Desta forma ùëúùëüùëë95 = 6. Como ùëúùëüùëë95 = 6 = ùúë(9), dizemos que 5 √© uma raiz primitiva m√≥dulo 9.

O Teorema da raiz primitiva nos garante que sempre existir√° um n√∫mero ùëè que cumpra as

condi√ß√µes descritas acima se ùëõ for realmente um n√∫mero primo.

No cap√≠tulo a seguir ser√° abordado m√©todos criptogr√°ficos os quais se utilizam dos teoremas
que foram apresentados at√© ent√£o, juntamente com as fragilidades dos testes de primalidade exis-
tente. Ser√° poss√≠vel analisar como a dificuldade em se fatorar um n√∫mero serve de apoio para a
Criptografia RSA e tamb√©m como o Teorema da raiz primitva √© √∫til para o m√©todo criptogr√°fico
Diffie-Hellman os quais estudaremos mais adiante.

21

Cap√≠tulo 3

M√âTODOS CRIPTOGR√ÅFICOS

Ser√° abordado neste cap√≠tulo, uma aplica√ß√£o matem√°tica que nos √∫ltimos anos passou a tirar
proveito da dificuldade em se fatorar um n√∫mero e, tamb√©m, da dificuldade em descobrir se um
n√∫mero (‚àà N) √© primo, a criptografia.

A criptografia √© muito utilizada nos dias atuais para proteger transa√ß√µes financeiras realizadas
atrav√©s do computador. Um exemplo muito comum s√£o as compras realizadas via Internet e pagas
com cart√£o de cr√©dito, nelas o comprador digita o n√∫mero e alguns dados de seu cart√£o de cr√©dito
no site da loja e somente com estas informa√ß√µes √© realizado o pagamento da compra. Se esses
dados ca√≠ssem nas m√£os de um terceiro, ele conseguiria utilizar este cart√£o para novas compras
em seu nome, sem nenhuma dificuldade. Por esse motivo, essas informa√ß√µes do cart√£o de cr√©dito
precisam ser codificadas de maneira que somente o destinat√°rio real (a loja) consiga compreender.
Essa codifica√ß√£o precisa atender alguns requisitos para que possa ser eficaz, o primeiro deles √©
que o destinat√°rio (em nosso exemplo, a loja) saiba como decodificar os dados. Portanto, a
codifica√ß√£o n√£o pode ocorrer de forma aleat√≥ria, significando assim que tanto a loja quanto o
comprador precisam saber como codificar tais dados. Mas, nesse ponto temos um problema, pois
a comunica√ß√£o entre a loja e o comprador est√° sendo realizada via internet e, da mesma maneira
que os dados do cart√£o de cr√©dito podem ser interceptados por um terceiro (e por este motivo
precisam ser codificados), a codifica√ß√£o utilizada tamb√©m corre este risco. Assim quando a loja
comunica ao comprador o c√≥digo que ele utilizar√° para codificar, esse c√≥digo n√£o √© mais seguro.

Tal fato era verdade at√© algum tempo atr√°s, pois antigamente as maneiras conhecidas de se
codificar tinham uma rela√ß√£o muito forte com as de decodificar, bastando para isso ‚Äúdesfazer"a
codifica√ß√£o ( voltar os passos realizados para codificar). O que acontece √© que quando vamos codi-
ficar alguma informa√ß√£o, existe uma ‚Äúreceita"contendo o passo a passo do processo de codifica√ß√£o,
chegando assim ao terminar esse processo no resultado final que √© a mensagem codificada. Se
essa maneira de codificar (‚Äúreceita") ca√≠sse nas m√£os de um terceiro, juntamente com a mensagem
codificada, bastava para ele voltar os passos realizados para codificar, conseguindo decodificar tal
mensagem.

Como dito anteriormente isto era verdade at√© algum tempo atr√°s, o que acontece √© que existe
uma maneira de se codificar a qual n√£o sofre deste mal, pois ao tentar realizar tal processo inverso

22

da codifica√ß√£o, esse processo se torna t√£o trabalhoso a ponto de ser imposs√≠vel ser realizado, ou
seja, um processo f√°cil de ser feito mais muito dif√≠cil de ser desfeito, garantindo assim que mesmo
se um terceiro soubesse como a codifica√ß√£o foi realizada, este terceiro n√£o conseguiria decodificar os
dados. Essa nova maneira de se codificar √© conhecida como Criptografia de Chave P√∫blica, levando
em conta que o processo de codifica√ß√£o pode se tornar p√∫blico sem comprometer a seguran√ßa do
m√©todo.

Na Criptografia de Chave P√∫blica a codifica√ß√£o √© realizada utilizando uma chave (m√©todo de
codifica√ß√£o) p√∫blica, por√©m para ser decodificada se faz necess√°rio o uso de uma outra chave
(m√©todo), chave esta que, fica privada somente ao destinat√°rio da mensagem, ou seja, aquele que
decodificar√° tal mensagem. O que resolve o problema descrito acima, haja visto que desta forma
a pessoa que ir√° codificar os dados n√£o precisa conhecer o m√©todo de decodifica√ß√£o e, dessa forma,
mesmo que exista um terceiro que encontre a mensagem criptografada junto com o m√©todo de
codifica√ß√£o, este terceiro n√£o conseguir√° decodificar tais dados.

A Criptografia de Chave P√∫blica utilizada no exemplo da compra via internet paga com cart√£o
de credito √© conhecida como Criptografia RSA, sigla essa que leva as iniciais de seus criadores
R.L.Rivest, A. Shamir e L. Adleman, como homenagem. Vejamos a seguir como tal m√©todo se
utiliza da matem√°tica para seu funcionamento.

3.1 Criptografia RSA

Aqui vamos entender um pouco como funciona o m√©todo RSA. A chave de codifica√ß√£o utilizada
neste m√©todo √© composta pelo n√∫mero ùëõ formado pelo produto de dois n√∫meros primos distintos
ùëé e ùëè, tal chave √© conhecida como chave p√∫blica. A chave de decodifica√ß√£o √© composta pelos dois
n√∫meros primos ùëé e ùëè, essa √© a chave privada. Embora exista aparentemente uma proximidade
entre ambas, n√£o √© poss√≠vel encontrar a chave privada (os dois n√∫meros primos ùëé e ùëè) a partir da
chave p√∫blica ùëõ, pois, para isso, precisar√≠amos decompor a chave ùëõ. Como vimos at√© agora, se um
n√∫mero for grande o suficiente, se torna imposs√≠vel at√© mesmo com a utiliza√ß√£o de um computador
decompor esse n√∫mero, em tempo h√°bil.

Dados necess√°rios para a utiliza√ß√£o da criptografia RSA:

‚Ä¢ escolhe-se dois n√∫meros primos distintos ùëù e ùëû grandes o suficiente e calcula-se o produto ùëù ¬∑ ùëû

, o resultado chamamos de ùëõ (ùëõ = ùëù ¬∑ ùëû):

‚Ä¢ ùëõ √© utilizado para codificar a mensagem (ùëõ √© a chave p√∫blica);

‚Ä¢ ùëù e ùëû s√£o utilizados para decodificar a mensagem (ùëù e ùëû s√£o as chaves privadas);

‚Ä¢ para quebrar o c√≥digo RSA √© necess√°rio fatorar ùëõ descobrindo assim os n√∫meros ùëù e ùëû, por√©m
ao se utilizar n√∫meros grandes o suficiente (de cerca de 100 digitos), fator√°-lo se torna um
processo invi√°vel, devido ao tempo que os m√©todos atuais levariam, sendo assim imposs√≠vel
de coloc√°-los em pr√°tica.

Assim sendo, as chaves de codifica√ß√£o e de decodifica√ß√£o s√£o n√∫meros, e a codifica√ß√£o √© realizada
por meio do c√°lculo de uma pot√™ncia m√≥dulo ùëõ (chave p√∫blica de codifica√ß√£o). Para que isso seja

23

poss√≠vel, a mensagem a ser codificada precisa ser um n√∫mero inteiro e, portanto, quando tal
mensagem for um texto devemos converter tal texto em uma sequ√™ncia de n√∫meros para assim
codific√°-la.

1. Na primeira etapa, converteremos as letras em n√∫meros de dois d√≠gitos para evitar ambigui-

dades, conforme a tabela a seguir:

11

J K L M
F G H
A B C D E
10
22
19
17
16
15
14
12
N O P Q R S T U V W X Y Z
35
29
23

I
18

32

34

33

31

30

13

26

20

24

28

21

25

27

Na convers√£o, o espa√ßo entre duas palavras √© substituido pelo n√∫mero 99 e, desta forma,
temos a mensagem convertida para uma sequ√™ncia de n√∫meros.

2. Feito toda a convers√£o da mensagem a ser codificada para n√∫meros, o pr√≥ximo passo √© a
escolha dos dois n√∫meros primos distintos ùëù e ùëû, os quais chamaremos de par√¢metros e o
c√°lculo de ùëõ, tal que ùëõ = ùëù ¬∑ ùëû.

3. O √∫ltimo passo antes de iniciarmos a codifica√ß√£o em si, √© quebrar a sequ√™ncia de n√∫meros em
blocos, de maneira que cada bloco produzido seja menor que o n√∫mero ùëõ. Existem diversas
maneiras em que pode-se quebrar os blocos, por√©m, eles n√£o podem ser iniciados com 0, a fim
de evitar problemas na hora de decodificar. Esses blocos n√£o correspondem a letras, s√≠mbolos
ou qualquer outra unidade lingu√≠stica e, portanto, elimina a possibilidade da utiliza√ß√£o da
decodifica√ß√£o por frequ√™ncia.

4. Ap√≥s esta etapa, j√° pode-se dar in√≠cio a codifica√ß√£o da mensagem que esta divida em blocos.
Para codificar a mensagem √© utilizada a chave p√∫blica a qual √© composta pelos n√∫meros ùëõ
e ùëí, sendo ùëí um inteiro positivo invers√≠vel m√≥dulo ùúë(ùëõ), ou seja, ùëöùëëùëê(ùëí, ùúë(ùëõ)) = 1. Observe
que o c√°lculo de ùúë(ùëõ) √© poss√≠vel se soubermos a chave de decodifica√ß√£o, pois ùëõ = ùëù.ùëû e assim
sendo ùúë(ùëõ) = ùúë(ùëù ¬∑ ùëû) = (ùëù ‚àí 1) ¬∑ (ùëû ‚àí 1). Dessa forma, juntamente com ùëõ temos como parte
da chave de codifica√ß√£o o n√∫mero ùëí.

5. Seja ùëè o bloco a ser codificado, logo ùëè √© um inteiro positivo menor que ùëõ. Denotando o bloco
codificado como ùê∂(ùëè), calculamos ùê∂(ùëè) atrav√©s do seguinte c√°lculo: ùëèùëí ‚â° ùê∂(ùëè) mod ùëõ, sendo
0 ‚â§ ùê∂(ùëè) < ùëõ , dessa forma podemos dizer que ùê∂(ùëè) √© o resto da divis√£o de ùëèùëí por ùëõ.
Feita a codifica√ß√£o de todos os blocos, blocos esses que, ap√≥s terem sido codificados, n√£o
podem mais serem reunidos de modo a formar novamente um grande n√∫mero, pois se isto
ocorrer ser√° imposs√≠vel sua decodifica√ß√£o.

6. Para realizar a decodifica√ß√£o se faz necess√°rio a posse de dois n√∫meros: ùëõ e ùëë , onde ùëë √© o

inverso de ùëí m√≥dulo ùúë(ùëõ). Os n√∫meros ùëë e ùëí formam a chave de decodifica√ß√£o.
De posse da chave de decodifica√ß√£o juntamente com os blocos j√° codificados, precisamos
compreender quais s√£o os passos que nos permitem reconstruir os blocos originais de antes
da codifica√ß√£o.

24

7. Seja ùëé o bloco codificado, o qual queremos decodificar, e ùê∑(ùëé) o resultado do processo desta
decodifica√ß√£o. Calculamos ùê∑(ùëé) da seguinte forma: ùëéùëë ‚â° ùê∑(ùëé) mod ùëõ, sendo 0 ‚â§ ùê∑(ùëé) < ùëõ
, dessa forma podemos dizer que ùê∑(ùëé) √© o resto da divis√£o de ùëéùëë por ùëõ.
Desta forma temos que encontrar ùëë. Observe que ele pode ser calculado com facilidade
atrav√©s do algoritmo euclidiano estendido, desde que ùúë(ùëõ) e ùëí sejam conhecidos.

8. Ap√≥s este passo precisamos provar que, sendo ùëè um bloco da mensagem original, temos
ùê∑(ùê∂(ùëè)) = ùëè , ou seja, decodificando um bloco da mensagem codificada, sempre encontramos
o bloco da mensagem original correspondente. Em seguida, basta colocar novamente os
blocos em uma sequ√™ncia longa de n√∫meros e convert√™-los na mensagem original.

A seguir um exemplo de como a Criptografia RSA pode ser utilizada:

Exemplo 15. Vamos codificar a mensagem ‚ÄúN√öMEROS INTEIROS‚Äù.

1. Num primeiro momento devemos converter as letras em n√∫meros com aux√≠lio da tabela:

11

F G H
A B C D E
J K L M
22
17
16
14
12
10
15
19
N O P Q R S T U V W X Y Z
35
29
23

I
18

28

25

13

24

21

26

32

20

31

30

34

33

27

Assim sendo, conseguimos a sequ√™ncia num√©rica a seguir:

23302214272428991823291418272428

2. O pr√≥ximo passo √© a escolha dos par√¢metros, ou seja, dos dois n√∫meros primos ùëù e ùëû. Para
simplificar um pouco, escolheremos n√∫meros primos pequenos a fim de facilitar as contas, as
quais podem ser realizadas at√© mesmo com a calculadora cient√≠fica do computador, tornando
mais evidente o m√©todo que est√° sendo utilizado.
Seja ent√£o, ùëù = 11 e ùëû = 13 , sendo assim temos ùëõ = 143

3. Temos que quebrar esta sequ√™ncia num√©rica em pequenos blocos, de maneira que cada bloco

seja menor que o n√∫mero ùëõ, em nosso caso menor que 143.
23302214272428991823291418272428

Assim procedendo, temos os blocos separados por um tra√ßo:
23 ‚àí 30 ‚àí 22 ‚àí 142 ‚àí 72 ‚àí 42 ‚àí 89 ‚àí 91 ‚àí 82 ‚àí 32 ‚àí 91 ‚àí 41 ‚àí 82 ‚àí 72 ‚àí 42 ‚àí 8

4. Em seguida calculamos ùúë(ùëõ) a fim de encontrar um n√∫mero ùëí tal que ùëöùëëùëê(ùëí, ùúë(ùëõ)) = 1, onde:

ùúë(ùëõ) = ùúë(ùëù.ùëû) = ùúë(13.11) = 12.10 = 120
Tamb√©m, a fim de facilitar os c√°lculos, visto que, o objetivo deste exemplo √© evidenciar o
m√©todo que est√° sendo utilizado, utilizaremos ùëí = 7, podemos fazer isto pois ùëöùëëùëê(7, 120) = 1.
Produzimos assim os itens necess√°rio da chave p√∫blica (de codifica√ß√£o), que s√£o os n√∫meros
‚Äúùëí‚Äù e ‚Äúùëõ‚Äù.

25

5. De posse da chave de codifica√ß√£o e dos blocos convertidos em n√∫meros, podemos dar in√≠cio

√† codifica√ß√£o:

23 ‚àí 30 ‚àí 22 ‚àí 142 ‚àí 72 ‚àí 42 ‚àí 89 ‚àí 91 ‚àí 82 ‚àí 32 ‚àí 91 ‚àí 41 ‚àí 82 ‚àí 72 ‚àí 42 ‚àí 8
ùëèùëí ‚â° ùê∂(ùëè) mod ùëõ , sendo ùê∂(ùëè) < ùëõ
237 ‚â° 23 mod 143
307 ‚â° 134 mod 143
227 ‚â° 22 mod 143
1427 ‚â° 142 mod 143
727 ‚â° 19 mod 143
427 ‚â° 81 mod 143
897 ‚â° 67 mod 143
917 ‚â° 130 mod 143
827 ‚â° 69 mod 143
327 ‚â° 98 mod 143
917 ‚â° 130 mod 143
417 ‚â° 24 mod 143
827 ‚â° 69 mod 143
727 ‚â° 19 mod 143
427 ‚â° 81 mod 143
87 ‚â° 57 mod 143
Feito os c√°lculos, temos os blocos agora codificados:

23 ‚àí 134 ‚àí 22 ‚àí 142 ‚àí 19 ‚àí 81 ‚àí 67 ‚àí 130 ‚àí 69 ‚àí 98 ‚àí 130 ‚àí 24 ‚àí 69 ‚àí 19 ‚àí 81 ‚àí 57

6. Para realizar a decodifica√ß√£o da mensagem, se faz necess√°rio os n√∫meros ùëõ e ùëë, ent√£o devemos

calcular o valor de ùëë para que possamos prosseguir com a decodifica√ß√£o:
ùëë.ùëí ‚â° 1 mod ùúë(ùëõ)
ùëë.7 ‚â° 1 mod 120
103.7 ‚â° 1 mod 120 , encontramos ùëë = 103, utilizando aqui o algoritmo de Euclides estendido
com os n√∫meros 7 e 120.
Temos assim a chave privada (de decodifica√ß√£o), composta por ùëë e ùëõ.

7. De posse da chave privada (ùëõ = 143, ùëë = 103) e dos blocos codificados, podemos iniciar a

decofica√ß√£o que acontecer√° da seguinte maneira:

23 ‚àí 134 ‚àí 22 ‚àí 142 ‚àí 19 ‚àí 81 ‚àí 67 ‚àí 130 ‚àí 69 ‚àí 98 ‚àí 130 ‚àí 24 ‚àí 69 ‚àí 19 ‚àí 81 ‚àí 57
ùëé ‚â° ùê∑(ùëé)ùëë mod ùëõ, sendo ùê∑(ùëé) < ùëõ , ùëé um bloco codificado e ùê∑(ùëé) o bloco j√° decodificado.

26

ùëé ‚â° ùê∑(ùëé)ùëë mod ùëõ
23103 ‚â° 23 mod 143
134103 ‚â° 30 mod 143
22103 ‚â° 22 mod 143
142103 ‚â° 142 mod 143
19103 ‚â° 72 mod 143
81103 ‚â° 42 mod 143
67103 ‚â° 89 mod 143
130103 ‚â° 91 mod 143
69103 ‚â° 82 mod 143
98103 ‚â° 32 mod 143
130103 ‚â° 91 mod 143
24103 ‚â° 41 mod 143
69103 ‚â° 82 mod 143
19103 ‚â° 72 mod 143
81103 ‚â° 42 mod 143
57103 ‚â° 8 mod 143
E assim, conseguimos realizar toda a decodifica√ß√£o, encontrando novamente os blocos num√©-
ricos de antes da codifica√ß√£o:

23 ‚àí 30 ‚àí 22 ‚àí 142 ‚àí 72 ‚àí 42 ‚àí 89 ‚àí 91 ‚àí 82 ‚àí 32 ‚àí 91 ‚àí 41 ‚àí 82 ‚àí 72 ‚àí 42 ‚àí 8

8. Como √∫ltimo passo, devemos ent√£o, juntar os blocos de maneira a formar uma grande lista
de n√∫meros e em seguida converter novamente os n√∫meros nas letras conforme tabela descrita
anteriormente.

23302214272428991823291418272428

23 ‚àí 30 ‚àí 22 ‚àí 14 ‚àí 27 ‚àí 24 ‚àí 28 ‚àí 99 ‚àí 18 ‚àí 23 ‚àí 29 ‚àí 14 ‚àí 18 ‚àí 27 ‚àí 24 ‚àí 28
N√öMEROS INTEIROS

Ao observar a codifica√ß√£o e a decodifica√ß√£o do m√©todo de Criptografia RSA observamos que,

para codificar, utilizamos:

ùëèùëí ‚â° ùê∂(ùëè) mod ùëõ, com ùê∂(ùëè) < ùëõ, e, para decodificar, utilizamos:
ùëéùëë ‚â° ùê∑(ùëé) mod ùëõ, com ùê∑(ùëé) < ùëõ.
Por√©m, observamos que na etapa de codifica√ß√£o utilizamos ùê∂(ùëè) para o bloco j√° codificado e na

etapa de decodifica√ß√£o este mesmo bloco codificado passou a se denominar ùëé, logo ùê∂(ùëè) = ùëé.

Logo, temos que provar que ùê∑(ùê∂(ùëè)) = ùëè para 1 ‚â§ ùëè ‚â§ ùëõ ‚àí 1.
Desta forma podemos utilizar congru√™ncias, pois tanto ùê∑(ùê∂(ùëè)) quanto ùëè s√£o menores que ùëõ :

ùê∑(ùê∂(ùëè)) ‚â° ùê∑(ùëèùëí) ‚â° (ùëèùëí)ùëë ‚â° ùëèùëí¬∑ùëë mod ùëõ.

27

Lembrando que: ùëí ¬∑ ùëë ‚â° 1 mod ùúë(ùëõ), ou ainda, ùëí ¬∑ ùëë = 1 + ùëò ¬∑ ùúë(ùëõ), com ùëò ‚àà Z, segue que:
ùëèùëí¬∑ùëë ‚â° ùëè1+ùëò¬∑ùúë(ùëõ) mod ùëõ.
ùëè1+ùëò¬∑ùúë(ùëõ) ‚â° ùëè1 ¬∑ (ùëèùúë(ùëõ))ùëò mod ùëõ
Como sabemos fatorar ùëõ, podemos calcular ùúë(ùëõ) (ùúë(ùëõ) = ùúë(ùëù¬∑ùëû) = (ùëù‚àí1)¬∑(ùëû ‚àí1)), substituindo

em nossa congru√™ncia:

ùëè1+ùëò¬∑ùúë(ùëõ) ‚â° ùëè1 ¬∑ (ùëè((ùëù‚àí1)¬∑(ùëû‚àí1)))ùëò mod ùëõ
ùëè1 ¬∑ ùëè(ùëù‚àí1)¬∑(ùëû‚àí1)¬∑ùëò ‚â° ùëè1 ¬∑ (ùëè(ùëù‚àí1))(ùëû‚àí1)¬∑ùëò mod ùëõ
Temos at√© o momento:
ùê∑(ùê∂(ùëè)) ‚â° ùê∑(ùëèùëí) ‚â° (ùëèùëí)ùëë ‚â° ùëèùëí¬∑ùëë ‚â° ùëè1 ¬∑ (ùëè(ùëù‚àí1))(ùëû‚àí1)¬∑ùëò mod ùëõ
Pelo Pequeno Teorema de Fermat sabemos que:
ùëè1 ¬∑ (ùëè(ùëù‚àí1))(ùëû‚àí1)¬∑ùëò ‚â° ùëè ¬∑ 1(ùëû‚àí1)¬∑ùëò mod ùëù
Analogamente encontramos que :
ùëè1 ¬∑ (ùëè(ùëû‚àí1))(ùëù‚àí1)¬∑ùëò ‚â° ùëè ¬∑ 1(ùëù‚àí1)¬∑ùëò mod ùëû
Como ùëù e ùëû s√£o primos distintos , temos (ùëù, ùëû) = 1, das congru√™ncias acima temos:
ùëù|ùëè(ùëí¬∑ùëë) ‚àí ùëè e ùëû|ùëè(ùëí¬∑ùëë) ‚àí ùëè, e assim podemos concluir que:
ùëù ¬∑ ùëû|ùëè(ùëí¬∑ùëë) ‚àí ùëè , como ùëõ = ùëù ¬∑ ùëû, podemos escrever em termos de congru√™ncia:
ùëè(ùëí¬∑ùëë) ‚â° ùëè mod ùëõ
Concluimos assim, que:
ùê∑(ùê∂(ùëè)) ‚â° ùëè mod ùëõ.
Mostramos, que esse m√©todo funciona, mas precisamos agora entender um pouco sobre o que
torna o RSA seguro. A seguran√ßa deste m√©todo reside no fato de que a pessoa que codifica os
dados tem acesso apenas a chave p√∫blica (os n√∫meros ùëõ e ùëí) enquanto que para decodificar os
dados faz-se necess√°rio conhecer a chave privada (os n√∫meros ùëõ e ùëë), ou seja o RSA se torna seguro
devido a grande dificuldade em calcular ùëë conhecendo apenas ùëõ e ùëí.

Sabemos que ùëë √© o inverso de ùëí m√≥dulo ùúë(ùëõ), desta forma bastaria aplicar o algoritmo de
Euclides estendido aos n√∫meros ùëí e ùúë(ùëõ), por√©m assim se faz necess√°rio conhecer ùúë(ùëõ) e, para isso,
devemos fatorar ùëõ, o que j√° vimos ser muito dif√≠cil se ùëõ for grande o suficiente. Logo, s√≥ √© poss√≠vel
calcular ùëë se soubermos os valores de ùëù e ùëû tal que ùëõ = ùëù ¬∑ ùëû e tais valores s√≥ est√£o dispon√≠veis a
quem decodificar√° a mensagem, tornando o m√©todo de Criptografia RSA seguro.

Assim sendo, podemos entender como e porqu√™ este m√©todo de Criptografia funciona. Em
seguida ser√° apresentada uma aplica√ß√£o mais pr√°tica que a anterior, utilizando n√∫meros maiores
para codificar e decodificar os dados de um cart√£o de cr√©dito, que foi utilizado em uma compra via
internet. As contas realizadas no exemplo a seguir foram feitas utilizando o software xMaxima.

Exemplo 16. Jo√£o est√° realizando uma compra via internet, a qual decidiu pagar com seu cart√£o
de cr√©dito. Ao efetivar sua compra, Jo√£o deve preencher os seus dados pessoais bem como seu
endere√ßo para o qual ser√° enviado seu produto e, em algum momento, ap√≥s esta etapa ele ser√° en-
caminhado a uma p√°gina na qual dever√° efetuar o pagamento pela compra realizada. Nessa p√°gina
Jo√£o dever√° informar os dados do seu cart√£o de cr√©dito e, ao digitar tais dados, seu computador
codificar√° esses dados com a chave p√∫blica que foi enviada pelo site da loja.

A loja √© a respons√°vel pela distribui√ß√£o da chave p√∫blica, dessa maneira v√°rios compradores
podem utilizar a mesma chave p√∫blica sem nenhum problema, pois somente ela tem a chave privada
a qual permite decodificar tais dados e, assim, conseguir compreender os dados enviados. Desse

28

modo, a loja envia ao computador de Jo√£o a chave p√∫blica composta dos n√∫meros ùëõ = 11.413 e
ùëí = 3.

Jo√£o digita o n√∫mero de seu cart√£o de cr√©dito: 1234567812345678, o seu computador os separa

em blocos e em seguida os codifica:
123 ‚àí 4567 ‚àí 8123 ‚àí 456 ‚àí 78
1233 ‚â° 548 mod 11413
45673 ‚â° 1558 mod 11413
81233 ‚â° 10.120 mod 11413
4563 ‚â° 11.025 mod 11413
783 ‚â° 6.619 mod 11413
O Computador ap√≥s codificar os blocos em que foram separados os dados, os envia para a loja:
548 ‚àí 1558 ‚àí 10120 ‚àí 11025 ‚àí 6619
A loja, de posse da chave privada composta pelos n√∫meros ùëë = 7467 e ùëõ = 11413, recebe os
blocos devidamente codificados e ent√£o realiza os c√°lculos para decodificar os dados contidos nos
blocos.

5487467 ‚â° 123 mod 11413
15587467 ‚â° 4567 mod 11413
101207467 ‚â° 8123 mod 11413
110257467 ‚â° 456 mod 11413
66197467 ‚â° 78 mod 11413
Encontrando assim os blocos j√° decodificados:
123 ‚àí 4567 ‚àí 8123 ‚àí 456 ‚àí 78
Bastando agora junt√°-los, voltando assim a forma original dos dados do cart√£o de cr√©dito.
Uma vez com os dados necess√°rios em m√£os, a loja efetua o pagamento e envia a mercadoria,
concretizando a compra.

Os n√∫meros primos utilizados no exemplo acima possuem apenas 3 casas decimais e, mesmo
assim, j√° se faz necess√°rio o uso de um software matem√°tico capaz de calcular com n√∫meros grandes,
em opera√ß√µes reais os n√∫meros primos utilizados possuem cerca de 100 d√≠gitos.

3.2 Criptografia Diffie-Hellman

Uma outra criptografia que tamb√©m utiliza chave p√∫blica √© a criptografia de Diffie-Hellman,
esse m√©todo tem sua seguran√ßa baseada na dificuldade em se encontrar logar√≠tmos discretos e foi
criado para solucionar o seguinte problema:

Imagine que duas pessoas Alice e Bob precisam se comunicar via internet de maneira segura,
ou seja, de forma que somente Alice leia as mensagens enviadas por Bob e de que somente Bob leia
as mensagens enviadas por Alice. Para ter seguran√ßa tais mensagens devem ser codificadas a fim
de evitar que um terceiro as interceptem obtendo acesso as informa√ß√µes descritas nas mensagens.
Pensando assim, quando Alice mandar uma mensagem para Bob, ela deve codific√°-la de ma-
neira que somente Bob consiga decodificar e ler a mensagem, e tamb√©m quando ele mandar uma
mensagem para Alice ele deve condific√°-la de maneira que somente ela consiga decodificar e ler a

29

mensagem. O Problema aqui √© que, quando um deles transmite a mensagem codificada deve tam-
b√©m enviar uma chave contendo as informa√ß√µes necess√°rias para que o receptor possa decodific√°-las
e, se essa informa√ß√£o for interceptada, um terceiro pode ter acesso as mensagens trocadas, deixando
assim de serem secretas.

Esse problema teria solu√ß√£o simples se Alice e Bob pudessem se encontrar e combinar com
anteced√™ncia a chave que utilizariam, por√©m o problema aqui apresentado trata de situa√ß√µes onde
o √∫nico meio de comunica√ß√£o poss√≠vel √© a internet e, portanto, eles devem encontrar uma maneira
segura de combinarem uma chave a ser usada, podendo assim se comunicarem de maneira segura.
Segundo Pires (2010), Whitfield Diffie e Martin Hellman propuseram uma solu√ß√£o para este
problema, a qual ficou conhecida como protocolo Diffie-Hellman para a troca de chaves. O Pro-
tocolo Diffie-Hellman √© uma maneira segura de compartilhar uma chave, atrav√©s de uma s√©rie de
procedimentos, duas pessoas conseguem compartilhar uma chave de codifica√ß√£o e decodifica√ß√£o
sem que mais ningu√©m tenha acesso, podendo utiliz√°-la para codificar as mensagens que ser√£o
enviadas ao parceiro e decodificar as mensagens que ser√£o recebidas pelo mesmo.

Vejamos como funciona tal procedimento para troca de chaves, talvez a melhor maneira de se
compreender o funcionamento deste m√©todo Criptografico seja utilizando um ‚Äúesquema de cores".
Vamos voltar ao nosso problema de in√≠cio, no qual duas pessoas precisavam se comunicar via
internet de maneira segura, a Alice e o Bob.

Antes de iniciar a conversa Alice e Bob devem utilizar a troca de chaves, para isto eles seguem

os passos a seguir:

1. Combinam uma cor que ser√° de conhecimento de ambos (c), al√©m dessa cor cada um tamb√©m

escolhe uma outra cor secreta a qual n√£o mostrar√£o a ningu√©m.

2. Alice mistura a cor comum (c) a sua cor secreta (a) produzindo uma nova cor (ca) e ent√£o

a envia para Bob.

3. Bob tamb√©m mistura a cor comum (c) a sua cor secreta (b) produzindo tamb√©m uma nova

cor (cb) e ent√£o a envia para Alice.

4. Alice recebe a cor obtida da mistura feita por Bob (cb) e ent√£o adiciona a esta mistura sua

cor secreta obtendo uma nova cor (cba).

5. O mesmo √© feito por Bob, ele pega a mistura feita por Alice e adiciona sua cor secreta,

obtendo assim a mesma nova cor (cab) obtida por Alice.

Mesmo que em ordem diferente, a cor encontrada por Bob e a cor encontrada por Alice s√£o
iguais, pois foram produzidas com os mesmos ingredientes, esta nova cor √© o segredo comum de
Alice e Bob.

Se algu√©m interceptar as cores enviadas entre Alice e Bob, essa pessoa n√£o conseguir√° descobrir
os ingredientes necess√°rios para obter a nova cor que √© o segredo a ser utilizado por Alice e Bob.
Isso devido ao fato de que antes de enviar a cor secreta, cada um a misturou a cor comum formando
assim uma nova cor, e ap√≥s ter misturado duas cores obtendo uma terceira √© imposs√≠vel desfazer
o processo para descobrir as cores secretas de Alice e de Bob as quais s√£o ingredientes para a cor
secreta.

30

Ao compararmos o procedimento das cores ao m√©todo Diffie-Hellman temos que a cor secreta
obtida ser√° a chave secreta que Alice e Bob utilizariam para conversarem em seguran√ßa, vejamos
como tal m√©todo funciona utilizando n√∫meros ao inv√©s de cores.

1. Alice e Bob combinam dois n√∫meros ùõº, ùëù ‚àà N , sendo ùëù primo e ùõº uma raiz primitiva de ùëù,

esses n√∫meros s√£o a chave p√∫blica do m√©todo.

2. Em seguida, Alice escolhe um n√∫mero que seja menor que ùëù e o mant√©m em segredo, ou seja,
ùë•ùëé < ùëù. Bob tamb√©m escolhe um n√∫mero menor que ùëù e o mant√©m em segredo, ou seja,
ùë•ùëè < ùëù.

3. O pr√≥ximo passo de Alice √© misturar seu n√∫mero secreto com a chave p√∫blica, para isso

calcula ùë¶ùëé da seguinte forma:
ùõºùë•ùëé ‚â° ùë¶ùëé mod ùëù, sendo ùë¶ùëé < ùëù.
Bob tamb√©m executa esse passo misturando seu n√∫mero secreto com a chave p√∫blica, pro-
duzindo assim ùë¶ùëè da seguinte forma:
ùõºùë•ùëè ‚â° ùë¶ùëè mod ùëù, sendo ùë¶ùëè < ùëù.

4. Nesta etapa Alice envia para Bob o n√∫mero obtido de seu c√°lculo: ùë¶ùëé e Bob tamb√©m envia

para Alice o n√∫mero obtido de seu c√°lculo: ùë¶ùëè.

5. Alice ent√£o recebe o n√∫mero ùë¶ùëè enviado por Bob e faz o seguinte c√°lculo para obter o n√∫mero

ùëò:
ùëè ‚â° ùëò mod ùëù.
ùë¶ùë•ùëé
Bob tamb√©m realiza seus c√°lculos para obter ùëò:
ùëé ‚â° ùëò mod ùëù.
ùë¶ùë•ùëè

Com isto Alice e Bob chegam ao mesmo n√∫mero ùëò, sem terem compartilhado tal n√∫mero com

mais ningu√©m, essa √© a chave privada do m√©todo Diffie-Hellman.

Vejamos um exemplo num√©rico para melhor entendermos o funcionamento deste m√©todo Crip-

togr√°fico:

Exemplo 17.

1. Alice e Bob combinam a chave p√∫blica que ser√° utilizada: 5 e 113, sendo que

5 √© raiz primitiva de 113.

2. Alice escolhe seu n√∫mero privado: 16.

Bob tamb√©m escolhe seu n√∫mero privado: 73.

3. Alice mistura seu n√∫mero privado com a chave p√∫blica:

516 ‚â° 30 mod 113, e encontra assim o n√∫mero 30, Bob tamb√©m executa esse passo mistu-
rando seu n√∫mero privado com a chave p√∫blica:

573 ‚â° 76 mod 113, encontrando assim o n√∫mero 76.

31

4. Alice envia para Bob o n√∫mero 30, e Bob envia para Alice o n√∫mero 76.

5. Alice ent√£o recebe o n√∫mero 76 enviado por Bob e faz o seguinte c√°lculo para obter o n√∫mero

ùëò :
7616 ‚â° ùëò mod 113, sendo 0 ‚â§ ùëò < 113
7616 ‚â° 106 mod 113
Encontrando ùëò = 106.

6. Bob recebe o n√∫mero 30 enviado por Alice e faz o seguinte c√°lculo para obter o n√∫mero ùëò :

3073 ‚â° ùëò mod 113, sendo 0 ‚â§ ùëò < 113
3073 ‚â° 106 mod 113
Encontrando ùëò = 106.

Alice e Bob agora possuem a chave privada 106, que ser√° utilizada por ambos para codificarem

e decoficarem suas mensagens e assim se comunicarem em seguran√ßa.

O pr√≥ximo passo √© entender o porque deste m√©todo ser considerado seguro, apesar de toda a
combina√ß√£o da chave a ser utilizada ter ocorrido via internet, sendo assim pass√≠vel de intercepta√ß√£o.
Vejamos:

‚Ä¢ Ao iniciar Alice e Bob combinaram dois n√∫meros ùëé = 5 e ùëù = 113 que formariam a chave
p√∫blica. Esses n√∫meros foram enviados de um para o outro e portanto poderiam cair nas
m√£os de um interceptador que no caso em quest√£o chamaremos de Eva.

‚Ä¢ Ap√≥s Alice ter ‚Äúmisturado"seu n√∫mero secreto com a chave p√∫blica ela envia o n√∫mero
encontrado ùë¶ùëé = 30 para Bob. Ao ser enviado esse n√∫mero tamb√©m pode cair nas m√£os de
Eva.

‚Ä¢ Bob tamb√©m envia o n√∫mero ùë¶ùëè = 76 encontrado da ‚Äúmistura"da chave p√∫blica com seu

n√∫mero secreto. Esse n√∫mero ao ser enviado tamb√©m pode ser interceptado por Eva.

Desta forma Eva ao investigar a conversa entre Alice e Bob consegue interceptar os n√∫meros
ùëé, ùëù, ùë¶ùëé e ùë¶ùëè(5, 113, 30, 76), por√©m nenhum deles corresponde a chave secreta ùëò que ser√° utilizada
por Alice e Bob.

O n√∫mero ùëò = 106 foi calculado das seguintes forma:
(516)73 ‚â° (30)73 ‚â° 106 mod 113
(573)16 ‚â° (76)16 ‚â° 106 mod 113
Para que Eva consiga descobrir o valor de ùëò ela precisa resolver:
5ùë•ùëé ‚â° 30 mod 113 ou
5ùë•ùëè ‚â° 76 mod 113
Neste caso temos que ùë•ùëé √© chamado de logaritmo discreto de 30 m√≥dulo 113 na base 5, temos

tamb√©m que ùë•ùëè √© o logaritmo discreto de 76 m√≥dulo 113 na base 5. Podemos denot√°-los por:

ùëëùëôùëúùëî5,113(30) = ùë•ùëé e ùëëùëôùëúùëî5,113(76) = ùë•ùëè.

32

Os logaritmos discretos s√£o os respons√°veis por garantir a seguran√ßa do m√©todo Diffie-Hellman,
isso devido a complexidade em resolver tais congru√™ncias como as descritas acima. Obviamente
existem softwares computacionais capazes de resolver tais congru√™ncias, mas isso √© devido a estar-
mos utilizando apenas n√∫meros pequenos. Por√©m, na pr√°tica, o Algoritmo Diffie-Hellman utiliza
um n√∫mero primo de centenas de d√≠gitos, aumentando de tal maneira as possibilidades para tal
logaritmo discreto que os softwares conhecidos para se calcular demorariam anos para conseguir
encontrar uma resposta, tornando assim tal busca por encontrar a chave utilizada um fracasso.

Os softwares computacionais inventados para calcular estes logaritmos discretos operam pelo
m√©todo da tentativa e erro. Portanto, quanto maiores forem os n√∫meros que est√£o sendo utilizados,
mais tempo este software demorar√° para encontrar uma resposta, at√© que em determinado ponto
os n√∫meros utilizados sejam grande o suficiente para que o tempo gasto torne estes softwares
ineficazes e garantindo a seguran√ßa deste m√©todo criptogr√°fico.

Ap√≥s ter comprovado a seguran√ßa da chave utilizada no m√©todo Diffie-Hellman, pode-se dar
in√≠cio a etapa de codifica√ß√£o. Nesta etapa o m√©todo Diffie-Hellman j√° foi utilizado, na verdade tal
m√©todo √© util apenas para o acordo da senha que sera utilizada durante a conversa para codifica√ß√£o
e decodifica√ß√£o das mensagens, e se faz necess√°rio utilizar um m√©todo de codifica√ß√£o e decodifica√ß√£o
das mensagens.

Para conclu√≠rmos o nosso exemplo da Alice e do Bob, utilizaremos um m√©todo simples, onde
mudamos a posi√ß√£o do alfabeto conforme a chave obtida, lembrando que a chave que Alice e Bob
tinham combinado era 106. tabela. Na verdade tem mais op√ß√µes, mas estas s√£o as mais simples.

f

c

e

a

b

/
h
d
1 B C D E F G H I
0 A B C D E F G H I
6 G H I

i
l m
k
J K L M N
J K L M
J K L M N O P Q R S

g

j

r

s

o

q

p

n

z
/
1 O P Q R S T U V W X Y Z A
0 N O P Q R S T U V W X Y Z
6 T U V W X Y Z A B C D E F

w x

u

y

v

t

Alice envia para Bob a seguinte mensagem:
‚ÄúQual mesmo o dia do anivers√°rio de sua m√£e?‚Äù
Codificando a mensagem utilizando alternadamente os alfabetos permutados de ordem (1, 0 e

6) obt√©m-se:

RUGNEYNOUEIGEOGOIBFRYBROPDKTUGNAK
Como Bob possui a chave de codifica√ß√£o e decodifica√ß√£o, ele decodifica, compreende a mensagem

e, ent√£o, responde √† Alice:

‚ÄúSer√° dia nove‚Äù
Que √© enviada at√© a Alice codificada:
TEXBDOBNUWE

33

Alice, por possuir o c√≥digo, compreende a resposta enviada por Bob. Qualquer outra pessoa

que intercepte a conversa obter√° a conversa criptografada:

Alice: RUGNEYNOUEIGEOGOIBFRYBROPDKTUGNAK
Bob: TEXBDOBNUWE,
n√£o sendo poss√≠vel descobrir qual o significado.
Na pr√°tica existem softwares capazes de aplicar o Algoritmo Diffie-Hellman, bem como realizar
toda a parte de codifica√ß√£o e decodifica√ß√£o, ficando por parte do usu√°rio somente escrever o texto
em tal software munido de sua senha privada. Toda a informa√ß√£o enviada de um computador para
o outro acontecer√° de maneira segura. Por√©m, esse m√©todo sofre de uma fraqueza se comparado a
criptografia RSA.

Se o computador da Alice ou o do Bob for invadido por um hacker e este por sua vez obtiver
as informa√ß√µes contidas no computador, o m√©todo Diffie-Hellman perde sua seguran√ßa assim, tal
hacker consegue acesso direto √† senha de codifica√ß√£o e decodifica√ß√£o, n√£o sendo necess√°rio ele
interceptar os dados que est√£o sendo enviandos pela internet e descobrir o logaritmo discreto, o
qual comentamos anteriormente. Como a senha de codifica√ß√£o e decodifica√ß√£o √© uma s√≥, se tal
hacker conseguir acesso a um dos computadores utilizados para a comunica√ß√£o, a seguran√ßa do
m√©todo Diffie-Hellman ficar√° comprometida.

Dizemos assim, que, para que o m√©todo Diffie-Hellman ser realmente eficaz, ele dever√° ocorrer
em um ambiente em que se possa garantir a seguran√ßa dos computadores contra v√≠rus e invas√µes
de hackers. Tal mal j√° n√£o ocorre na criptografia RSA, pois mesmo que o hacker obtenha todo o
acesso ao computador de quem est√° codificando, conseguindo acesso √† chave de codifica√ß√£o, essa
chave n√£o √© util para decodificar os dados.

A criptografia RSA possui a vantagem de somente o computador do destinat√°rio precisar se-
guran√ßa. Por esse motivo, o m√©todo criptogr√°fico utilizado nas opera√ß√µes financeiras √© o RSA, o
que o torna mais utilizado do que o m√©todo Diffie-Hellman, por√©m isso n√£o significa que o √∫ltimo
n√£o tenha suas aplica√ß√µes, ele pode ser usado em conversas entre duas pessoas, por exemplo, na
troca de e-mails confidenciais entre duas pessoas.

A seguir ser√° apresentado um modelo de sequ√™ncia did√°tica, no qual aplicaremos os conceitos

vistos aqui, no cotidiano escolar.

34

Cap√≠tulo 4

SEQU√äNCIA DID√ÅTICA

Ser√° apresentada a seguir uma sequ√™ncia did√°tica idealizada tendo como intuito o ensino dos
conte√∫dos matem√°ticos contidos neste trabalho. Ela ser√° apresentada atrav√©s de uma abordagem
investigativa em sala de aula, na qual ser√° abordada a dificuldade em se encontrar n√∫meros primos
e em se fatorar n√∫meros inteiros. Dificuldades essas que servir√£o de suporte para uma aplica√ß√£o:
a Criptografia de chave p√∫blica. Vale lembrar que esta √© uma sequ√™ncia did√°tica idealizada e,
desse modo, dever√° ser adaptada a cada realidade escolar visando suprir sempre √†s necessidades
da escola em quest√£o.

A sequ√™ncia did√°tica apresenta alguns conte√∫dos matem√°ticos referentes aos aprendidos pelos
alunos durante o Ensino Fundamental e M√©dio, sendo que os conte√∫dos restantes podem ser en-
sinados durante o caminhar da atividade, deste modo ela poder√° ter como p√∫blico-alvo os alunos
que est√£o cursando qualquer um dos tr√™s anos do Ensino M√©dio. Por√©m, visto que ela apresenta
conte√∫dos como: pot√™ncias, logar√≠tmos e an√°lise do resto de divis√µes com n√∫meros inteiros, que
s√£o assuntos tratados no durante o 1≈æ ano do Ensino M√©dio, seria de bom tom o desenvolvimento
dessa atividade ao final desta etapa de ensino.

Em um primeiro momento, ser√° abordada a dificuldade em se encontrar n√∫meros primos. Nessa
etapa os alunos apresentar√£o conhecimentos j√° adquiridos sobre n√∫meros primos e, juntamente
com o professor, ir√£o estudar os testes de primalidades existentes, se atentando as dificuldades que
esses m√©todos apresentam conforme aumenta-se o tamanho dos n√∫meros a serem analisados. √â
justamente nessa etapa que o professor ficar√° encarregado de aproximar os alunos do conhecimento
e, para tanto, dever√° apresentar o conhecimento matem√°tico que se faz necess√°rio na utiliza√ß√£o
desses testes de primalidades.

Feito isso, os alunos utilizar√£o tais testes de modo a analisarem at√© onde conseguem ser eficientes
e, em seguida, ser√° apresentado atrav√©s de v√≠deos uma aplica√ß√£o que se utiliza da fragilidade dos
testes de primalidade, a Criptografia de chave p√∫blica. Os alunos ap√≥s terem contato com tal
aplica√ß√£o, aprender√£o a utiliz√°-las. O professor formar√° pequenos grupos de alunos, os quais
trocar√£o mensagens codificadas. √â importante frisar que o professor deve ser sempre o mediador,
ou seja, deve ser aquele que instiga e aproxima o aluno da busca pelo conhecimento.

35

4.1

Introdu√ß√£o

Este plano de aula ter√° como intuito estimular a curiosidade e o interesse dos alunos por meio de
aplica√ß√µes pr√°ticas dos conte√∫dos abordados durante esse trabalho. As atividades aqui preparadas
permitir√£o ao aluno analisar e compreender melhor o funcionamento dos m√©todos criptogr√°ficos
estudados bem como a import√¢ncia que a matem√°tica tem para o funcionamento deles.

Os educandos realizar√£o uma investiga√ß√£o na busca de descobrir m√©todos eficazes para en-
contrar n√∫meros primos e fatorar n√∫meros inteiros, para que possam compreender a dificuldade
existente nesses dois itens quando estamos tratando de n√∫meros grandes, dificuldade essa, que √©
respons√°vel pela seguran√ßa do m√©todo Criptogr√°fico RSA. Em um segundo momento, eles ser√£o
convidados a utilizarem os m√©todos criptogr√°ficos RSA e Diffie-Hellman para que possam se co-
municar em segredo, contextualizando assim, o conte√∫do aprendido em sala de aula. A abordagem
apresentada neste trabalho tem como objetivo ser uma ponte para que o aluno se aproxime e iden-
tifique a import√¢ncia da matem√°tica aprendida na escola em aplica√ß√µes pr√°ticas, promovendo uma
participa√ß√£o mais ativa a com o ensejo de construir um conhecimento matem√°tico com significado.
Essa sequ√™ncia did√°tica poder√° proporcionar o aumento da capacidade de percep√ß√£o do aluno,
uma vez que motivados e convencidos da import√¢ncia da matem√°tica em seu dia a dia, poder√£o
estud√°-la com novos olhares, ampliando assim o raio de utiliza√ß√£o dos seus conhecimentos matem√°-
ticos, uma vez que est√° ligada √† resolu√ß√£o de problemas da realidade, ajudando-os a compreender
melhor a import√¢ncia da matem√°tica em sua vida cotidiana, conforme concep√ß√µes apresentadas
por Ara√∫jo (2009). O aluno poder√° adquirir uma compreens√£o mais ampla dos conceitos aqui
discutidos, j√° que buscaremos focar mais no despertar da criatividade do discente, para que ele
consiga utilizar o pensamento l√≥gico matem√°tico em um raio maior de situa√ß√µes.

4.2 Objetivos

A abordagem apresentada neste trabalho tem como objetivo ser uma ponte para que o aluno se
aproxime e identifique a import√¢ncia da matem√°tica aprendida na escola em aplica√ß√µes pr√°ticas,
promovendo assim uma participa√ß√£o mais ativa e visando construir um conhecimento matem√°tico
com significado.

A escolha de uma aplica√ß√£o presente nos dias atuais e ligada a tecnologia, tem por objetivo
evidenciar a import√¢ncia da matem√°tica na sociedade e, assim, ser um motivador para o estudo
dessa disciplina, promovendo uma maior dedica√ß√£o, comprometimento e interesse do aluno.

O maior objetivo deste trabalho √© dar ao aluno uma compreens√£o mais ampla dos conceitos
aqui discutidos, na busca de instig√°-los ao pensamento l√≥gico, bem como despertar sua criatividade
nas mais diversas situa√ß√µes nas quais se √© poss√≠vel aplicar seus conceitos.

4.3 Metodologia e Apresenta√ß√£o de Materiais

Por meio de uma atividade aplicada, ser√° poss√≠vel mostrar aos educandos aplica√ß√µes da mate-
m√°tica aprendida na escola. Tal atividade tem como inten√ß√£o mostrar como a matem√°tica aliada
com ideias criativas s√£o √∫teis na resolu√ß√£o de problemas que pareciam n√£o ter solu√ß√£o.

36

Atrav√©s de uma problem√°tica inicial o professor instigar√° o aluno a refletir sobre seu grau
de complexidade, promovendo assim uma maior aten√ß√£o e comprometimento na constru√ß√£o do
conhecimento necess√°rio para resolver tal problem√°tica.

A avalia√ß√£o acontecer√° durante todo o projeto, com o intuito de observar a autonomia e a
participa√ß√£o de cada educando, para que possam compreender e participar de maneira ativa das
aulas. Tamb√©m dever√£o ocorrer observa√ß√µes, media√ß√µes e se necess√°rio futuras interven√ß√µes e
mudan√ßas no caminhar do projeto, visando se adequar a realidade da sala. A avalia√ß√£o se dar√°
por meio da:

‚Ä¢ Observa√ß√£o do professor nas intera√ß√µes entre aluno-aluno e professor-aluno;

‚Ä¢ Relat√≥rio;

‚Ä¢ Aulas expositivas;

‚Ä¢ Irabalho em grupo.

4.4 Roteiro detalhado da proposta

Na atividade em quest√£o, o s√≥cio-interacionismo ter√° papel de destaque, pois √© interagindo com
seus colegas e professor que o adolescente construir√° suas conclus√µes necess√°rias a cada etapa do
projeto. O construtivismo tamb√©m ter√° sua relev√¢ncia no que diz respeito √† sequ√™ncia de ideias e
pensamentos que resultar√£o na solu√ß√£o do problema apresentado.

Percebe-se tamb√©m neste projeto, que a busca pelo conhecimento ser√° algo cont√≠nuo, constru√≠do

por etapas, e que cada passo dado ser√° de grande import√¢ncia para √†queles que vir√£o.

1. Levantamento da Problem√°tica

Numa primeira etapa o professor dever√° apresentar uma problem√°tica para os alunos, a qual
servir√° como quest√£o norteadora de seus estudos al√©m de ter a fun√ß√£o de motiv√°-los durante
os estudos.

Tal problem√°tica ser√° iniciada tendo em vista a dificuldade existente at√© hoje em se encon-
trar n√∫meros primos e tamb√©m de se fatorar n√∫meros inteiros e como matem√°ticos famosos
souberam utilizar tal dificuldade para seu benef√≠cio, utilizando-a em uma aplica√ß√£o que √©
utilizada cada vez com maior frequ√™ncia a criptografia RSA e de Diffie-Hellman, que s√£o
respons√°veis por proteger comunica√ß√µes via-internet tornando tal meio de comunica√ß√£o um
ambiente seguro.

Para isso, o professor far√° uma abordagem a fim de levantar o conhecimento dos alunos sobre
como encontrar n√∫meros inteiros e, a partir de tal, atrav√©s de uma investiga√ß√£o mediada pelo
professor, os alunos dever√£o aprimorar tal m√©todo de se encontrar n√∫meros primos, passando
desde o crivo de Erast√≥tenes at√© os mais atuais como o teste de Miller e o de Lucas, para
os quais os alunos precisar√£o ter conhecimento sobre alguns conte√∫dos matem√°ticos como
congru√™ncias e alguns teoremas, que precisar√£o ser trabalhados durante essa investiga√ß√£o.

37

Ap√≥s a familiariza√ß√£o com os testes de primalidades mais atuais, ser√° apresentada sua prin-
cipal aplica√ß√£o utilizada nos dias atuais, a Criptografia de chave p√∫blica. Para isso, pode ser
utilizado v√≠deos como os listados nas refer√™ncias, os quais exemplificam o funcionamentode
tais m√©todos criptogr√°ficos, evidenciando a matem√°tica utilizada. √â importante ressaltar
que o professor deve agir como mediador escolhendo momentos que julgar mais importan-
tes, fazendo coment√°rios que auxiliem os alunos a se aproximarem mais do tema e, assim,
ajudando a fixar a ideia que est√° sendo utilizada.

Ap√≥s a exibi√ß√£o dos v√≠deos e explica√ß√£o te√≥rica sobre o assunto, deve se abrir um espa√ßo
para um debate, no qual atrav√©s de perguntas o professor tenta aproximar os alunos cada
vez mais do conhecimento matem√°tico necess√°rio, deixando claro assim quais os conte√∫dos
que ser√£o aprendidos e os quais s√£o necess√°rio para utilizar tais t√©cnicas Criptogr√°ficas, o
que al√©m de incentiv√°-los, deixar√° claro o objetivo a ser alcan√ßado.

2. Pressupostos Te√≥ricos

Para a segunda etapa o professor dever√° recordar conte√∫dos j√° estudados em anos anteriores
pelos alunos sobre os n√∫meros inteiros como a defini√ß√£o de n√∫meros primos, o algoritmo da
divis√£o, o algoritmo fatora√ß√£o e o crivo de Erast√≥stenes. Nesta etapa, pode se lan√ßar como
desafio para os alunos alguns n√∫meros √≠mpares grandes de at√© 10 algarismos para que eles
tentem fatorar tais n√∫meros, e caso n√£o consigam, pe√ßa que j√° que n√£o se √© poss√≠vel fator√°-los
para que provem que tais n√∫meros s√£o primos.

Exemplos de n√∫meros a serem aplicados:

4051 ‚àí 6967 ‚àí 3739 ‚àí 12547 ‚àí 654369 ‚àí 1256347 ‚àí 25365351 ‚àí 231258657
Ap√≥s terem vivenciado a dificuldade em se determinar se um n√∫mero √© primo ou n√£o, o
professor pode argumentar sobre a exist√™ncia de testes de primalidade que surgiram ao longo
da hist√≥ria matem√°tica, bem como o avan√ßo de sua efici√™ncia em detectar se um n√∫mero
√© primo. Ap√≥s essa etapa, o professor pode introduzir o conceito de divisibilidade e de
congru√™ncias, assim como os Teoremas de Fermat e Euler que servir√£o de ferramentas para
os testes de primalidade que aprender√£o a seguir.

3. Testes de Primalidade

Nesta etapa ser√£o apresentados alguns testes de primalidade que surgiram ao longo da hist√≥ria
da matem√°tica:

‚Ä¢ Divis√£o por tentativa

‚Ä¢ Crivo de Erat√≥stenes

‚Ä¢ Teste de primalidade de Leibniz

‚Ä¢ Teste de primalidade de Miller

‚Ä¢ Teste de primalidade de Lucas

38

O professor poder√° abordar as vantagens e desvantagens da utiliza√ß√£o de cada um dos tes-
tes de primalidade, bem como compar√°-los, evidenciando assim a evolu√ß√£o do pensamento
humano durante a constru√ß√£o do conhecimento.

Al√©m do conhecimento sobre os testes de primalidade essa etapa tem por objetivo mostrar a
dificuldade em se fatorar um n√∫mero e, at√© mesmo, de detectar se tal n√∫mero √© primo.

√â de suma import√¢ncia que o aluno compreenda tal dificuldade, pois ela ser√° utilizada nos
m√©todos criptogr√°ficos da pr√≥xima etapa.

4. Criptografia

Nesta etapa os alunos se dividir√£o em grupos com quantidade pr√©-estabelecido pelo professor,
e ter√£o que se comunicar com um outro grupo em segredo, para isso utilizar√£o os m√©todos
criptogr√°ficos apresentados neste trabalho.

Em um primeiro momento ser√° utilizada a criptografia Diffie-Hellman. Para isso, cada grupo
de aluno dever√° se comunicar com um outro grupo, aos pares, o professor ser√° respons√°vel
por analisar e ver se o m√©todo esta sendo empregado corretamente. √â importante aqui, que
o professor auxilie os alunos na escolha da chave p√∫blica, definindo o tamanho dos n√∫meros
a serem utilizados, o que depende diretamente dos instrumentos que ser√£o utilizados para
realizar os c√°lculos (calculadora cient√≠fica, calculadora do computador, softwares matem√°ti-
cos).

Ap√≥s os alunos terem trocado mensagens utilizando a criptografia Diffie-Hellman, ser√° a vez
de utilizarem a criptografia RSA. Para isso, o professor ser√° o destinat√°rio das mensagens.
Portanto, o professor escolher√° a chave privada e criar√° a chave p√∫blica do m√©todo RSA,
repassando somente a chave p√∫blica para os outros grupos e ficando de posse da chave
privada, a qual utilizar√° para decodificar as mensagens enviadas a ele pelos grupos.

4.5 Considera√ß√µes finais sobre a aplica√ß√£o

Os alunos poder√£o realizar uma reda√ß√£o sobre as aulas apresentadas a fim de identificarem o
conhecimento adquirido e expressarem suas opini√µes sobre o modelo de atividade realizada. Ser√°
importante buscar destacar o quanto a criatividade acompanha o desenvolvimento da Matem√°tica.
Espera-se que o aluno aumente sua capacidade de interligar os conte√∫dos vistos em sala de aula a
outras aplica√ß√µes, conseguindo identificar situa√ß√µes onde possa utilizar tais conhecimentos.

Ara√∫jo(2009) nos diz que o aprendizado √© algo que precisa ser interiorizado, ou seja, precisa
estar numa zona proximal de conhecimento, para que assim seja poss√≠vel unir o conhecimento que
est√° descobrindo com os que j√° possui, fazendo sentido tal aprendizado. Desta forma, sempre que
descobrimos algo ele se tornar√° alicerce para novas descobertas, e que o aprender faz parte do ser
humano.

O uso do v√≠deo e das hist√≥rias dever√° ajudar o aluno a entrar no mundo imagin√°rio, a fim de
vivenciar a problem√°tica vivida ao longo do tempo, reviver etapas da constru√ß√£o do conhecimento
e perceber como o racioc√≠nio pode ser utilizado para resolver situa√ß√µes complicadas. Com isso,

39

construir um conhecimento mais amplo, no intuito de conseguir utiliz√°-lo n√£o s√≥ em situa√ß√µes
‚Äúprogramadas‚Äù, mas sim, em situa√ß√µes reais com naturalidade e dinamismo.

40

Conclus√£o

Durante este trabalho foi poss√≠vel estudar propriedades fundamentais sobre N√∫meros Inteiros,
atrav√©s de uma aplica√ß√£o muito utilizada no dia a dia a Criptografia de chave p√∫blica, a qual
s√≥ se tornou poss√≠vel atrav√©s de ideias criativas que utilizam tecnologia aliada a conhecimentos
matem√°ticos.Tivemos como norte o estudo dos n√∫meros primos e da Criptografia a medida que
avan√ßavamos por entre conte√∫dos matem√°ticos que tal aplica√ß√£o se utiliza.

Foi poss√≠vel observar ainda, de maneira l√≥gica, o avan√ßo da efici√™ncia dos m√©todos utilizados
para detectar n√∫meros primos, conseguindo distinguir com eficiencia um n√∫meros primos com
tamanho consider√°vel. O trabalho apresentou a evolu√ß√£o de alguns testes de primalidades, evi-
denciando as ideias e o processo de constru√ß√£o de cada um, at√© alcan√ßar os testes de primalidades
atuais: o teste de primalidade de Lucas Lehmer o qual consegue detectar com exatid√£o n√∫me-
ros primos at√© um certo tamanho, e o Teste de Miller cujo qual devida sua tamanha efici√™ncia √©
utilizado por softwares computacionais nos dias atuais.

Por√©m, constatou-se que apesar de tal melhora nos testes de primalidades, ainda n√£o existe
um m√©todo que consiga detectar se um n√∫mero qualquer √© primo, pois os testes de primalidade
apresentados funcionam at√© certo ponto, sendo que se o n√∫mero a ser testado for muito grande,
tal teste perde sua efici√™ncia devido a capacidade limitada do computador, o qual pode levar anos
para terminar tal teste, tornando assim o mesmo invi√°vel.

Com o passar dos tempos, vimos que o problema matem√°tico de se detectar a primalidade
de um n√∫mero, e at√© mesmo de se encontrar fatores primos de n√∫meros inteiros teve um grande
avan√ßo, por√©m, quando se trata de n√∫meros muito grande, esse problema ainda continua sem
solu√ß√£o. Vimos tamb√©m, que o fato desse problema continuar sem solu√ß√£o, passou a ser a chave
para resolver um outro problema: o problema da troca de chaves, pois tal dificuldade em se detectar
n√∫meros primos e fatorar n√∫meros Inteiros, se torna ent√£o solu√ß√£o para a troca de informa√ß√µes
de maneira segura via internet, atrav√©s da criptografia de chave publica (RSA e Diffie-Hellman),
aplica√ß√£o essa que se tornou essencial para o desenvolvimento de nossa sociedade. Desta maneira,
pode-se perceber que se usada de maneira criativa, a matem√°tica torna-se suporte para novas
aplica√ß√µes.

A Escrita em C√≥digos (Criptografia) desperta a curiosidade humana em explorar o desco-
nhecido, motivando assim a busca pelo saber . A Criptografia presente neste trabalho faz uso
de conhecimentos matem√°ticos importantes, assim sendo foi poss√≠vel durante a abordagem aqui
apresentada, estudar desde conceitos b√°sicos como n√∫meros primos, divisibilidade e fatora√ß√£o at√©
conceitos mais avan√ßados como o estudo de grupos, congru√™ncias e testes de primalidades para
n√∫meros grandes. A utiliza√ß√£o desta aplica√ß√£o a qual esta presente atualmente no meio digital
teve por objetivo apresentar a import√¢ncia da matem√°tica no meio em que vivemos, analisando
e compreendendo seu m√©todo de funcionamento, o que consequentemente promoveu um interesse

41

maior pela matem√°tica, incentivando e despertando para um aprendizado mais significativo.

No √∫ltimo capitulo foi apresentada uma sequ√™ncia did√°tica, visando a aplica√ß√£o em sala de aula
dos conte√∫dos, conceitos e aplica√ß√µes estudados ao longo dessa disserta√ß√£o para alunos do ensino
m√©dio, a fim de ilustrar uma proposta que busca despertar o racioc√≠nio l√≥gico dos alunos atrav√©s
de uma abordagem investigativa cuja qual instiga o aluno na busca pelo conhecimento.

Ao longo de todo este trabalho foi poss√≠vel notar tamb√©m, a evolu√ß√£o da matem√°tica atrav√©s dos
tempos, ao estudarmos os testes de primalidade pode-se notar como o conhecimento matem√°tico
existente se torna alicerce para que um novo passo possa surgir, atrav√©s da evolu√ß√£o de ideias
e da maneira de pensar. Essa evolu√ß√£o do pensamento humano permite o surgimento de novas
aplica√ß√µes como a criptografia de chave p√∫blica, a qual se tornou indispens√°vel no mundo financeiro
atual.

42

Refer√™ncias Bibliogr√°ficas

[1] Khan

Academy.

Document√°rio:

Criptografia

diffie-hellman.

http://www.youtube.com/watch?v=YEBfamv-_do (acesso em 24/02/2014).

[2] Khan Academy. Document√°rio: Criptografia rsa. https://www.youtube.com/watch?v=wXB-

V_Keiu8 (acesso em 24/02/2014).

[3] Site do software matem√°tico maxima.

http://MAXIMA.sourceforge.net

(acesso em

13/03/2014).

[4] SPM. Document√°rio: N√∫meros primos. http://www.youtube.com/watch?v=FCMyFgUK5jM

(acesso em 24/02/2014).

[5] SPM. Document√°rio: A chave das chaves. http://www.youtube.com/watch?v=Vm1Y6Kr9DCw

(acesso em 24/02/2014).

[6] HEFEZ A. Elementos de aritm√©tica. Cole√ß√£o Textos Universit√°rios, SBM, 2011.

[7] SANTOS B.

Introdu√ß√£o ao software maxima. Centro de Matem√°tica da Universidade do

Porto, CMUP, 2009.

[8] COUTINHO S. C. N√∫meros inteiros e criptografia rsa. Cole√ß√£o Matem√°tica e Aplica√ß√µes,

IMPA, 2013.

[9] ARA√öJO J. L. Uma abordagem s√≥cio-cr√≠tica da modelagem matem√°tica: a perspectiva da
educa√ß√£o matem√°tica cr√≠tica. ALEXANDRIA Revista de Educa√ß√£o em Ci√™ncia e Tecnologia,
2(2):55‚Äì68, Julho 2009.

[10] PIRES R. M. Aplica√ß√£o do algoritmo diffie-hellman no compartilhamento de volumes crip-
tografados do truecrypt. Departamento de Ci√™ncia da Computa√ß√£o, Universidade Federal de
Goi√°s, 2010.

43

