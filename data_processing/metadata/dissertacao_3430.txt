UNIVERSIDADE FEDERAL DO AMAPÁ

COLEGIADO DE MATEMÁTICA

MESTRADO PROFISSIONAL EM MATEMÁTICA

Linovaldo Coêlho dos Santos

Uma ferramenta computacional para o cálculo e treinamento do método de

escalonamento de Gauss

MACAPÁ

2016

Linovaldo Coêlho dos Santos

Uma ferramenta computacional para o cálculo e treinamento do método de

escalonamento de Gauss

Dissertação apresentada ao Programa de Mestrado
Proﬁssional em Matemática em Rede Nacional -
PROFMAT da Universidade Federal do Amapá,
como requisito parcial para obtenção do título de
Mestre em Matemática.

Orientador Prof. Dr. José Walter Cárdenas Sotil

MACAPÁ

2016

Dados Internacionais de Catalogação na Publicação (CIP)
Biblioteca Central da Universidade Federal do Amapá

515.35
S237f

Santos, Linovaldo Coêlho dos.

Uma ferramenta computacional para o cálculo e treinamento do
método de escalonamento de Gauss / Linovaldo Coêlho dos Santos;
orientador, José Walter Cárdenas Sotil. - Macapá, 2016.

103 f.

Dissertação (mestrado) - Fundação Universidade Federal do
Amapá, Programa de Pós-Graduação em Matemática (PROFMAT).

1. Método de Gauss. 2. Software. 3. Equações diferenciais
lineares. I. Sotil, José Walter Cárdenas, orientador. II. Fundação
Universidade Federal do Amapá. III. Título.

Linovaldo Coêlho dos Santos

Uma ferramenta computacional para o cálculo e treinamento do método de

escalonamento de Gauss

Aprovado em 05 de Agosto de 2016

Banca examinadora

Prof. Dr. José Walter Cárdenas Sotil
Departamento de Ciências Exata e Tecnológica,
UNIFAP

Prof. Me. Astrogecildo Ubaiara Brito
Instituto Federal do Amapá,
IFAP

Prof. Dr. Guzman Eulálio Isla Chamilco
Departamento de Ciências Exata e Tecnológica,
UNIFAP

Prof. Dr. Erasmo Senger
Departamento de Ciências Exata e Tecnológica,
UNIFAP

MACAPÁ

2016

Agradecimentos

Agradeço primeiramente a Deus, pela vida, "todo aquele que ouve minhas palavras, e as

põe em prática, será como um homem prudente que construiu sua casa sobre rocha"(Mt-7,24).

A minha família, que sempre esteve ao meu lado me apoiando, em especial minha esposa

Luciana, e aos meus ﬁlhos Ingrid e Lucas, que sempre entenderam minhas ausências necessárias

para estudo.

A Unifap que através do programa PROFMAT me deu a oportunidade de continuar ampli-

ando meus conhecimentos matemáticos.

Ao Prof. Dr. José Walter Cárdenas Sotil, por toda sua inestimável colaboração neste projeto,

sempre acreditando e incentivando.

Aos colegas da turma 2013 - PROFMAT, pela união e colaboração mútua.

A todos que direta ou indiretamente me incentivaram a continuar e ﬁnalizar o mestrado.

Por ﬁm, à CAPES, pelo apoio ﬁnanceiro.

"Verdadeiramente o que
mais prazer me proporciona,
não é o saber, mas o estudar,
não é a posse, mas a conquista,
não é o estar aqui, mas o chegar além."

(Carl Friedrich Gauss)

Resumo

Neste trabalho desenvolvemos o método de escalonamento de Gauss e mostramos a sua eﬁ-

ciência para calcular determinantes, matrizes inversas e sistemas de equações lineares quando

comparados com o método de Laplace. O método de escalonamento de Gauss tem complexi-

dade computacional da ordem polinomial, enquanto o método de Laplace segue uma complexi-

dade de ordem exponencial. Foi desenvolvido no ambiente DELPHI 7 um aplicativo chamado

MATRIZ, o qual calcula determinantes, matrizes inversas e sistemas de equações lineares algé-

bricas como ferramenta computacional a ser usado em sala de aula. O aplicativo MATRIZ tem

como diferencial possuir um ambiente de treinamento, onde o aluno pode decidir qual é o pivô e

os multiplicadores, tornando as aulas mais dinâmicas, permitindo ﬁxar os conceitos adquiridos,

tomar decisões e obter rapidamente os resultados esperados.

Palavras-chave: Método de Gauss, Escalonar, Software, Matrizes, Determinantes, Matriz

Inversa, Equações Lineares.

Abstract

In this work developed the scaling method of Gauss and show your efﬁciency to calculate de-

terminants, inverse matrices and systems of linear equations compared with Laplacian method.

The scaling method of Gauss has computational complexity of the polynomial order, while the

method of Laplace follows a complexity of exponential order. It was developed in DELPHI 7

environment application called MATRIZ, which calculates determinants, inverse matrices and

systems of algebraic linear equations as a computational tool to be used in the classroom. The

application MATRIZ has the differential to have an training environment , where the student

can decide which is the pivot and multipliers, making classes more dynamic, allowing ﬁx the

acquired concepts, take decisions and get expected results quickly.

Key words: Gauss method, Scale, Software, Matrices, Determinants, Inverse Matrice, Li-

near Equations.

Lista de Figuras

5.1 Tela Inicial

.

.

.

.

5.2 Tela Determinante .

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.3 Tela Equações Lineares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.4 Tela Matriz Inversa .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.5 Tela Treinamento Gauss

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.6 Primeiro passo - Determinante . . . . . . . . . . . . . . . . . . . . . . . . . .

5.7 Segundo passo - Determinante . . . . . . . . . . . . . . . . . . . . . . . . . .

5.8 Terceiro passo - Determinante . . . . . . . . . . . . . . . . . . . . . . . . . .

5.9 Quarto passo - Determinante . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.10 Primeiro passo - Equações Lineares

. . . . . . . . . . . . . . . . . . . . . . .

5.11 Segundo passo - Equações Lineares

. . . . . . . . . . . . . . . . . . . . . . .

5.12 Terceiro passo - Equações Lineares . . . . . . . . . . . . . . . . . . . . . . . .

5.13 Quarto passo - Equações Lineares

. . . . . . . . . . . . . . . . . . . . . . . .

5.14 Primeiro passo - Matriz Inversa . . . . . . . . . . . . . . . . . . . . . . . . . .

5.15 Segundo passo - Matriz Inversa . . . . . . . . . . . . . . . . . . . . . . . . . .

5.16 Terceiro passo - Matriz Inversa . . . . . . . . . . . . . . . . . . . . . . . . . .

5.17 Quarto passo - Matriz Inversa . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.18 Primeiro passo - Treinamento Gauss . . . . . . . . . . . . . . . . . . . . . . .

5.19 Segundo passo - Treinamento Gauss . . . . . . . . . . . . . . . . . . . . . . .

5.20 Terceiro passo - Treinamento Gauss

. . . . . . . . . . . . . . . . . . . . . . .

5.21 Terceiro passo - Treinamento Gauss - 2 . . . . . . . . . . . . . . . . . . . . .

5.22 Quarto passo - Treinamento Gauss . . . . . . . . . . . . . . . . . . . . . . . .

5.23 Quinto Passo - Treinamento Gauss . . . . . . . . . . . . . . . . . . . . . . . .

5.24 Quinto passo - Treinamento Gauss - 2 . . . . . . . . . . . . . . . . . . . . . .

50

51

52

53

54

55

55

56

57

58

58

59

60

61

61

62

63

64

64

65

65

66

67

67

ix

Sumário

1

Introdução

2 Um pouco de História

2.1 Gauss, Príncipe da Matemática e seu raciocínio brilhante . . . . . . . . . . . .

2.2 Gauss e a Transformação Linear

. . . . . . . . . . . . . . . . . . . . . . . . .

2.3 Gauss e o Método da Eliminação . . . . . . . . . . . . . . . . . . . . . . . . .

2.4 Sistemas de equações .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.5 Como surgiram as matrizes . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Sistemas de Equações Lineares

3.1 Matriz .

.

.

.

.

.

.

3.2 Tipos de matrizes .

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.3 Operações com matrizes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.4 Determinantes .

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.4.1 Determinante de matrizes de ordem n ≥ 2 . . . . . . . . . . . . . . . .

3.4.2

Propriedades dos determinantes

. . . . . . . . . . . . . . . . . . . . .

3.5 Equação Linear .

.

. .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.6 Sistema de equações lineares . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.6.1 Regra de Cramer

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.7 Sistema escalonado . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.7.1 Resolução de um sistema escalonado . . . . . . . . . . . . . . . . . .

3.8 Método de Gauss .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.9 Matriz inversa .

. .

. .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4 Aspectos numéricos

4.1 Complexidade Computacional

. . . . . . . . . . . . . . . . . . . . . . . . . .

4.1.1

Sistema diagonal

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.1.2

Sistema triangular superior . . . . . . . . . . . . . . . . . . . . . . . .

x

12

14

14

16

17

18

19

20

20

20

22

24

25

27

28

29

30

31

31

32

35

38

38

38

39

4.1.3 Eliminação Gaussiana . . . . . . . . . . . . . . . . . . . . . . . . . .

4.1.4 Determinantes por Cofatores . . . . . . . . . . . . . . . . . . . . . . .

4.1.5 Matriz Inversa

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.2 Transformação de decimais em frações . . . . . . . . . . . . . . . . . . . . . .

4.2.1 Número inteiro em fração . . . . . . . . . . . . . . . . . . . . . . . .

4.2.2 Número decimal exato em fração . . . . . . . . . . . . . . . . . . . .

4.2.3 Dízima periódica em fração . . . . . . . . . . . . . . . . . . . . . . .

4.3 Uma abordagem computacional para a representação de uma fração . . . . . .

5 Descrição do Aplicativo

5.1 Tela Inicial

.

.

.

.

5.2 Determinante .

. .

5.3 Equações Lineares

5.4 Matriz Inversa .

. .

.

.

.

.

5.5 Treinamento Gauss .

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.6 Exemplo de Cálculo de Determinante

. . . . . . . . . . . . . . . . . . . . . .

5.7 Exemplo de Cálculo de Equações Lineares . . . . . . . . . . . . . . . . . . . .

5.8 Exemplo de Cálculo de Matriz Inversa . . . . . . . . . . . . . . . . . . . . . .

5.9 Exemplo de Treinamento Gauss

. . . . . . . . . . . . . . . . . . . . . . . . .

Considerações Finais

Referências Bibliográﬁcas

A Programa em Delphi

40

42

45

45

46

46

46

48

50

50

51

52

53

54

55

57

60

63

69

70

72

Capítulo 1

Introdução

Os educadores sempre tiveram diﬁculdade em mostrar a aplicação dos conteúdos matemá-

ticos, as aulas dadas de forma tradicional, com muita teoria e pouca ou nenhuma prática, com

fórmulas prontas e sem signiﬁcado para os alunos, torna a disciplina desinteressante. Precisa-

mos tornar nossa aulas mais dinâmicas e interativas, para atrair o interesse dos nossos alunos.

A informática na educação pode ser esse diferencial, pois nossos jovens estão cada vez mais

integrados com a informática, tanto na sua disponibilidade quanto no que diz respeito à questão

do seu manuseio.

A utilização dos computadores é irreversível, dada a diversidade de suas aplicações e ca-

pacidade de armazenar, organizar e processar informações. Na escola, essa realidade não é

diferente: o computador renova as práticas docentes e institucionais.

Nos dias de hoje, o conhecimento por simulação está em alta, próprio da cultura informá-

tica, faz com que o computador seja também visto como um recurso didático cada dia mais

indispensável, pensando nisso, elaboramos este trabalho com o objetivo principal de desenvol-

ver um aplicativo para escalonar utilizando o método de Gauss e também fazer um treinamento

desse método de modo a ﬁxar a teoria. O software foi elaborado usando os conhecimentos

de programação em cima da plataforma Borland Delphi 7 e os conhecimentos matemáticos de

matrizes.

O primeiro capítulo contém a vida e algumas das obras de Carl Friedrich Gauss que, pelo seu

trabalho, aplicação e consequentemente divulgação dessa forma de escalonar, recebeu seu nome

no referido método, o qual mostrou-se muito eﬁciente em diversas aplicações e mostraremos

especiﬁcamente o cálculo de determinantes, variáveis de equações lineares e matrizes inversas.

No segundo capítulo temos a fundamentação teórica iniciando com matrizes, dando uma vi-

são geral do conteúdo, ou seja, pretende-se deﬁnir o que é uma matriz, alguns tipos de matrizes,

12

13

suas operações aritméticas, como também estabelecer algumas de suas propriedades algébri-

cas e seu determinante. Em seguida veriﬁcamos as propriedades dos determinantes, equações

lineares e sistema de equações lineares. Temos ainda, regra de Cramer, sistemas escalonados,

método de Gauss e matrizes inversas com teoria e exemplos.

No capítulo 3 trataremos dos aspectos numéricos com o cálculo do custo computacional de

um algoritmo com o objetivo de mostrarmos a eﬁciência do método de Gauss em relação ao

método de Laplace no cálculo de determinantes. Temos também um estudo das transforma-

ções numéricas, em especial dos números decimais em frações, onde faremos uma abordagem

diferente para essa transformação.

O último capítulo tem descrição do aplicativo com todas as telas, funcionalidades e exem-

plos com passo a passo da utilização dos recursos do sistema. Deve-se enfatizar a importância

do Treinamento Gauss, que no exemplo é feito com uma matriz de quarta ordem, porém pode-

se, teoricamente, utilizar matrizes bem maiores para a ﬁxação do método.

Capítulo 2

Um pouco de História

2.1 Gauss, Príncipe da Matemática e seu raciocínio brilhante

De acordo com (BEMFICA, 2015), uma das histórias mais fascinantes envolvendo pro-

gressões é a do matemático alemão Carl Friedrich Gauss (1777-1855), considerado o maior

matemático do século XIX e um dos maiores de todos os tempos, juntamente com Arquimedes

e Isaac Newton. Filho de família pobre, seu pai tentou evitar que recebesse instrução adequada.

Gauss, porém, contou com o apoio da mãe, para que pudesse estudar.

A precocidade de Gauss, tido como uma criança prodígio, pode ser exempliﬁcada por um

fato interessante ocorrido em sua infância. Aos 10 anos, Gauss frequentava uma escola local, na

qual o professor era tido como muito exigente. Certo dia, com a intenção de manter a turma em

silêncio, pediu aos alunos que somassem os números naturais de 1 a 100 (1 + 2 + 3 + · · · + 100)

e, assim que terminassem, colocassem a solução sobre sua mesa. Quase que imediatamente,

Gauss colocou sobre a mesa do professor a resposta encontrada. Ele olhou para o menino

com pouco-caso, enquanto os demais alunos trabalhavam arduamente. Quando conferiu os

resultados, o professor veriﬁcou que a única resposta correta era a de Gauss, 5.050, mas sem

fazê-la acompanhar de nenhum cálculo.

Gauss havia feito o cálculo mentalmente, observando que a soma do primeiro e do último

termo (1+100), do segundo e do penúltimo termo (2+99), do terceiro e do antepenúltimo (3+98),

e assim por diante era sempre 101.

A soma dos números naturais de 1 a 100 é dada por 50 · 101 = 5.050, cálculo que resultou

na fórmula da soma dos n primeiros termos de uma PA.

Sn =

n(a1 + an)
2

Veriﬁcamos em (USP, 2015), que o menino precoce Gauss, aos 12 anos, criticava os Funda-

14

15

mentos da Geometria; com 13 anos, projetava uma Geometria não-euclidiana; por volta dos 15

ou 16 anos de idade, descobriu o Teorema do Número Primo e concebeu a Lei Gaussiana - ou

da Distribuição Normal - da Teoria das Probabilidades. Com 18 anos, inventou o método dos

mínimos quadrados e, aos 22 anos, determinou as funções elípticas.

Gostava muito de estudar, mas estava indeciso entre tornar-se um ﬁlósofo ou um matemá-

tico. No dia 30 de março de 1796, ao que parece, essa decisão foi tomada, quando optou pela

Matemática. Conseguira construir, segundo as regras euclidianas, o polígono regular de dezes-

sete lados. Note-se que já eram conhecidas as construções, com régua e compasso, do triângulo

equilátero e do pentágono regular, além de outros polígonos regulares, cujo número de lados

fosse múltiplo de 2, 3 e 5, mas de nenhum outro com número primo de lados. A descoberta de

Gauss foi publicamente anunciada numa revista literária.

Nesse mesmo dia, Gauss começou a escrever um diário composto por 19 páginas que talvez

seja o documento mais importante de toda a História da Matemática. Nele encontram-se 146

breves enunciados de diversos resultados. O último enunciado tem data de 09 de julho de 1814.

O conteúdo do diário só foi publicado em 1901 pelo matemático Felix Klein.

Uma das obras mais importantes de Gauss é a Disquisitiones Arithmeticae publicada em

1801, considerada o marco inicial da moderna Teoria dos Números, além de ser importantíssimo

por trazer uma abordagem rigorosa e moderna da Matemática. Salvo alguns poucos resultados

matemáticos antigos, o trabalho é inteiramente original. Na parte inicial se encontra a primeira

demonstração do Teorema Fundamental da Aritmética, segundo o qual todo inteiro n>1 pode

ser escrito de forma única como um produto de primos. Na parte central fala-se da congruência

quadrática, formas e resíduos, e na última seção encontra-se a teoria do polinômio ciclotômico

com suas aplicações para a construtibilidade de polígonos regulares.

Em sua tese de doutorado, publicada em 1799 em Helmstädt, encontra-se uma demonstra-

ção do Teorema Fundamental da Álgebra. Esse teorema garante que toda equação polinomial de

grau n admite n raízes complexas e, em sua demonstração Gauss utilizou números complexos e

a geometria do plano complexo com total segurança, além de inaugurar a era das demonstrações

de existência, importantes para a Matemática pura. A demonstração apresentada em sua tese

baseia-se em parte em considerações geométricas. Em 1816, Gauss publicou duas demonstra-

ções e, em 1850, publicou uma terceira, esforçando-se para encontrar uma prova inteiramente

algébrica.

Outro grande trabalho foi um artigo publicado em 1830 sobre resíduos biquadráticos, cujas

16

idéias inauguraram a Teoria Algébrica dos Números. A partir de 1830, Gauss se ocupou com

a Física, realizando estudos em diversos ramos, como a Óptica, onde introduziu o conceito de

comprimento focal de um sistema de lentes e inventou as lentes grandes angulares de Gauss

para telescópios e objetivas.

Embora tenha publicado muito, vários de seus estudos não o foram, pois Gauss preferia

mergulhar em um novo estudo em lugar de escrever sobre as descobertas feitas.

Gauss passou os anos de 1845 a 1851 atualizando os fundos monetários da Universidade de

Göttingen. Esse trabalho lhe deu uma experiência em práticas ﬁnanceiras e, com isso, fez sua

fortuna através de investimentos astutos em companhias privadas.

Conforme (UFF, 2015), Gauss atuou em muitas áreas das ciências exatas. Trabalhou em

álgebra, teoria dos números, equações diferenciais, teoria de funções elípticas, cartograﬁa, pes-

quisou o campo magnético terrestre, participou do desenvolvimento do primeiro telégrafo elé-

trico, contribuiu para a física-matemática com trabalhos em eletromagnetismo e gravitação,

além de inúmeros outros tópicos aos quais dedicou suas pesquisas.

Gauss casou-se duas vezes. A primeira esposa, Johanna, deu-lhe três ﬁlhos, mas faleceu

cedo, em 1809. Seu segundo casamento foi com Minna Waldeck, ﬁlha de outro professor de

Göttingen, que lhe deu mais três descendentes.

Gauss morreu em Göttingen no dia 23 de Fevereiro de 1855, coincidindo com o incremento

da Revolução Industrial. A crença oﬁcial no progresso pacíﬁco começava a ser substituída pela

realidade de uma época de crises. Daí em diante, a ﬁgura do cientista integral, interessado em

todos os aspectos do conhecimento humano, se tornou praticamente uma raridade. Por isso, o

desaparecimento de Gauss marcou o ﬁm de uma era.

2.2 Gauss e a Transformação Linear

Segundo (DIEUDONNÉ, 1981), o conceito de transformação linear ou a representação de

uma variável como combinação de outras variáveis tornou-se familiar para os matemáticos ape-

nas a partir do século XVIII. Esta técnica teve em Gauss seu maior divulgador. Ele a publicou

em seu livro Disquisitiones generales cerca superfícies curvas (1827). Escrito em latim, este tra-

balho foi resultado dos estudos realizados por Gauss para diversos governos da região que hoje

forma a Alemanha. À época, Gauss tinha sido comissionado para supervisionar uma medição

precisa do meridiano entre as cidades de Göttingen e Alton, e confeccionar um mapa geodésico

do Ducado de Hannover. Tarefas deste tipo levaram este matemático a fundar os princípios de

17

um novo campo, a Geodésia avançada, e a conduzir medidas geodésicas de campo que consumi-

ram 15 anos de trabalho (KOLMOGOROV and YUSHKEVICH, 1981). Em seu Disquisitiones

generales, Gauss deﬁniu o que seriam as representações paramétricas de uma superfície e ex-

pressões para o cálculo de distâncias. Foi nesse contexto que ganharam utilidade as descrições

abreviadas de transformações lineares, baseadas em uma notação que se assemelha a que seria

usada futuramente para matrizes (BASHMAKOVA and SMIRNOVA, 2000).

2.3 Gauss e o Método da Eliminação

Origem bem diferente teve o Método da Eliminação de Gauss. Tal método, descrito com

a nomenclatura atual, consiste em uma sequência de operações aplicadas linha a linha de uma

matriz, com a intenção de mudar os coeﬁcientes da matriz e reduzi-la a uma matriz triangular

superior (em que os coeﬁcientes abaixo da diagonal são nulos). A solução do sistema linear

representado por esta matriz é então obtida por substituição reversa, começando pela última

equação do sistema reduzido. Encontramos em (ALTHOEN and MCLAUGHLIN, 1987), no

entanto, a informação de que o Método da Eliminação de Gauss foi concebido como uma fer-

ramenta para se chegar ao Método dos Mínimos Quadrados, que por sua vez foi concebido

para encontrar a melhor função linear que se aproximava de dados coletados em campo. Por

causa disso, o Método dos Mínimos Quadrados despertou interesse dos cientistas e engenheiros

ligados à Geodésia, e o próprio Método da Eliminação foi lembrado por muito tempo apenas

como um instrumento geodésico. O roteiro de uso do Método da Eliminação foi encontrado em

um livro de Gauss publicado em 1810, Disquisitio de Elementis Ellipticis Palladis. Nesta obra,

Gauss queria determinar detalhes sobre a órbita de Pallas, um dos maiores asteroides do Sistema

Solar. No caminho, ele se deparou com um sistema de equações lineares em seis incógnitas,

em que nem todas as equações poderiam ser satisfeitas ao mesmo tempo. Isso fez com que

fosse preciso determinar valores para as incógnitas que minimizassem o erro quadrático total.

Em vez de tentar solucionar o problema diretamente, Gauss introduziu um método para lidar

com sistemas de equações lineares em geral. Esse método seria aperfeiçoado mais tarde pelo

matemático Wilhelm Jordan (1842-1899). Em seu livro Handbuch der Vermessungskeunde, pu-

blicado em 1888, Jordan apresenta seu método, batizado de GaussJordan, que resulta em uma

matriz diagonal equivalente (com coeﬁcientes nulos acima e abaixo da diagonal) e fornece o

valor das incógnitas de forma imediata (ALTHOEN and MCLAUGHLIN, 1987).

18

2.4 Sistemas de equações

Os primeiros exemplos de resoluções de equações e de sistemas lineares de 1o grau são

encontrados nas civilizações egípcia e babilônica, por volta de 2000 a.C.

Já em 250 a.C, encontramos uma importante contribuição chinesa ao desenvolvimento da

Matemática: a obra Nove capítulos sobre a arte matemática. Nela são apresentados problemas

sobre assuntos diversos, entre os quais soluções de alguns sistemas de equações lineares.

Os gregos também desenvolveram métodos de resolução de alguns sistemas de equações de

1o grau, como aqueles encontrados na obra de Diofanto de Alexandria (200-284). Trabalhos

dessa natureza são igualmente encontrados nas obras de diversos matemáticos hindus, como

Aryabhata (476-550) e Bramagupta (598-670), e árabes, como Al-Khowarismi (século IX) e

Ornar Khayyam (1048-1131).

No entanto, somente na segunda metade do século XVII, tem início um tratamento sistemati-

zado da teoria de sistemas de equações lineares, com os estudos de G. W. Leibnitz (1646-1716),

na Alemanha, e Takakazu Seki Kowa (1642-1708), no Japão.

No século XVIII, diversos trabalhos sobre sistemas de equações lineares deram corpo a esse

estudo, destacando-se aqueles apresentados por Colin Maclaurin (1698-1746), Gabriel Cramer

(1704-1752) e Etienne Bézout (1730-1783), que formularam métodos de resolução de sistemas.

Já no século XIX, são signiﬁcativas para a consolidação da teoria dos sistemas lineares

as contribuições de Carl Gustav Jacob Jacobi (1804-1851), Leopold Kronecker (1832-1891),

Eugène Rouché (1832-1910) e Ferdinand Georg Frobenius (1847-1917), que tornaram possível

uma abordagem mais simpliﬁcada desse assunto.

Ao ﬁnal do século XVIII, Leibnitz, na Alemanha, e Seki Kowa, no Japão, desenvolveram

métodos de resolução de sistemas lineares baseados em tabelas numéricas formadas pelos coeﬁ-

cientes das equações que compunham esses sistemas. Essas tabelas numéricas deram origem ao

que hoje denominamos matrizes que, além de serem aplicadas ao estudo dos sistemas lineares,

possibilitaram o desenvolvimento de novos ramos da Matemática.

Durante o século XVIII, diversos matemáticos desenvolveram estudos sobre algumas pro-

priedades dessas tabelas. Entre os vários trabalhos desenvolvidos, destacam-se os de Pierre S.

Laplace (1749-1827) e Alexandre Théophile Vandermonde (1735-1796).

(MUIR, 1890) aponta que Gauss foi o primeiro a usar o termo determinante, em um texto

de 1801, só que em outro contexto. O termo determinante foi posteriormente resgatado por

Cauchy (1789-1857), desta vez com o signiﬁcado que conhecemos hoje.

19

No início do século XIX, Augustin Louis Cauchy (1789-1857) apresentou um importante

trabalho sobre essas tabelas, a partir do qual outros matemáticos, como Carl G. J. Jacobi (1804-

1851), Arthur Cayley (1821-1895), James J. Sylvester (1814-1897) e Francesco Brioschi (1824-

1897), desenvolveram e sistematizaram deﬁnições, propriedades, operações e aplicações até

hoje utilizadas.

2.5 Como surgiram as matrizes

Conforme (DANTE, 2014), a necessidade de escrever mensagens sigilosas é muito antiga.

Ao longo da história, reis, rainhas, generais, entre outros buscaram meios eﬁcientes de comuni-

cação entre seus aliados.

Segundo (IEZZI et al., 2010), as matrizes teriam surgido com a escola inglesa Trinity Col-

lege, em um artigo do matemático Arthur Caylay(1821-1895), datado de 1858. Vale lembrar,

no entanto, que, bem antes, no século III a.C., os chineses já desenvolviam um processo de

resolução de sistemas lineares em que apareciam implícita a ideia das matrizes.

Cayley criou as matrizes no contexto de estrutura algébrica, sem pensar em suas aplicações

práticas que apareceriam posteriormente.

As transformações geométricas no plano (ou transformações 2D - duas dimensões) são

muito usadas pela computação gráﬁca para a construção de ﬁguras e produção de imagens.

Tais imagens podem ser percebidas nos efeitos especiais utilizados no cinema, na TV e nos sis-

temas multimídia em geral, além de servir de ferramenta de auxílio em várias áreas da atividade

humana. As três transformações básicas são: translação, rotação e escala.

Capítulo 3

Sistemas de Equações Lineares

Neste capítulo apresentamos os conceitos teóricos e práticos associados ao cálculo de deter-

minantes, matrizes inversas e resolução de equações lineares algébricas pelo método de Gauss

e o método de Laplace.

3.1 Matriz

Denomina-se matriz toda tabela retangular de valores dispostos ordenadamente em linhas

e colunas. As matrizes são indicadas por letras maiúsculas do alfabeto latino e representadas

utilizando-se parênteses ou colchetes.

Um elemento genérico de uma matriz A é simbolizado por aij, em que i indica a linha e j a

coluna a que o elemento pertence. Se a matriz tem m linhas e n colunas, dizemos que ela é de

ordem m × n e é representada assim:

A =








a11
a12
a21
a22
...
...
am1 am2

· · ·
a1n
· · ·
a2n
...
...
· · · amn








Essa matriz m × n possui m · n elementos. Podemos também expressá-la de forma mais

reduzida, por meio de uma lei de formação para seus elementos:

A = (aij)m×n,

onde i ∈ {1, 2, 3, · · · , m}, e j ∈ {1, 2, 3, · · · , n}.

3.2 Tipos de matrizes

Algumas matrizes recebem nomes especiais em função de suas características:

20

21

a) Matriz linha

É toda matriz de ordem 1 × n (n ∈ Z+):

(cid:2) a11 a12 a13

. . . a1n

(cid:3)

Se A é uma matriz de ordem m × n, denotamos a i-ésima linha de A como Ai, isto é

Ai = (cid:2) ai1 ai2 ai3

. . . ain

(cid:3)

b) Matriz coluna

É toda matriz de ordem m × 1 (m ∈ Z+):










a11
a21
a31
...
am1










.

Se A é uma matriz de ordem m × n, denotamos a j-ésima coluna de A como Aj, isto é

Aj =










.










a1j
a2j
a3j
...
amj

c) Matriz quadrada

É toda matriz cujo número de linhas é igual ao número de colunas. Assim, chamamos

matriz quadrada de ordem n a toda matriz de ordem n × n.

A =








a11 a12
a21 a22
...
...
an1 an2

· · ·
a1n
· · ·
a2n
...
...
· · · ann








Toda matriz quadrada possui duas diagonais:

i) Diagonal principal: composta por elementos aij tais que i = j, isto é,

a11, a22, a33, a44, · · · , ann;

ii) Diagonal secundária: em que os elementos aij são tais que i + j = n + 1, isto é,

a1n, a2(n−1), a3(n−2), a4(n−3), · · · , an1.

22

d) Matriz nula

É toda matriz de ordem m × n cujos elementos são todos nulos. Para indicar uma matriz

nula utiliza-se a notação Om×n.

e) Matriz diagonal

É toda matriz quadrada em que os elementos não pertencentes à diagonal principal são

todos nulos.

f) Matriz identidade

A =








a11
0
...
0

0
a22
...
0

· · ·
0
· · ·
0
...
...
· · · ann








É toda matriz diagonal em que os elementos da diagonal principal são iguais a 1. Para

indicar uma matriz identidade de ordem n, utilizamos a notação In.

In =








1 0 · · ·
0 1 · · ·
...
...
...
0 0 · · ·








0
0
...
1

3.3 Operações com matrizes

Para que seja possível aplicar o conceito de matrizes em diversas situações de resolução de

problemas práticos, é necessário que sejam deﬁnidos os seguintes processos de operações com

matrizes:

a) Transposição de uma matriz

Dada uma matriz A do tipo m × n, chama-se transposta de A e indica-se por At a matriz

que se obtém trocando-se ordenadamente as linhas pelas colunas de A. A operação de

obtenção de uma matriz transposta de A é denominada transposição da matriz A. Assim,

se A é uma matriz de ordem 3 × 2, então At é uma matriz de ordem 2 × 3 como mostra o

seguinte exemplo,

A =





a d
e
b
c f





⇒

At =

(cid:21)

(cid:20) a b

c
d e f

onde, a primeira linha de At corresponde à primeira coluna de A e a segunda linha de At

corresponde à segunda coluna de A.

23

b) Igualdade de matrizes

Duas matrizes, A e B, serão iguais se forem da mesma ordem e se os elementos corres-

pondentes forem iguais. Assim, se A = (aij) e B = (bij) são matrizes de ordem m × n,

então:

A = B ⇔ (aij = bij,

∀ 1 ≤ i ≤ m, ∀ 1 ≤ j ≤ n) .

c) Adição de matrizes

Dadas duas matrizes de mesmo tipo, A = (aij)m×n e B = (bij)m×n, denomina-se matriz

soma (A + B) a matriz obtida adicionando-se os elementos correspondentes de A e B:

A + B = (aij + bij)m×n.

d) Matriz oposta

Seja a matriz A = (aij) de ordem m × n. Denomina-se a matriz oposta de A, à matriz

denotada por −A, da mesma ordem que A e cuja soma com A resulta na matriz nula. Isto

é,

e) Subtração de matrizes

A + (−A) = 0 ⇔ −A = (−aij).

Dadas duas matrizes A e B de ordem m × n, denomina-se matriz diferença A − B à

matriz de ordem m × n, obtida subtraindo-se os elementos correspondentes de A e B:

A − B = (aij − bij)m×n.

f) Multiplicação de número real por matriz

Dada uma matriz A = (aij)m×n e um número real k, denomina-se matriz produto do

número real k por A. à matriz denotada por k · A de ordem m × n, obtida multiplicando-

se cada um dos elementos de A por k,

k · A = (k · aij)m×n.

g) Multiplicação de matrizes

Dadas as matrizes A = (aij)m×n e B = (bij)n×p, deﬁnimos a matriz produto de A e B,

de ordem m × p e denotada C = A · B = (cij)m×p, onde

cij = Ai · Bj =

n
(cid:88)

k=1

aik · bk

= ai1b1j + ai2b2j + · · · + ainbnj,

i = 1, . . . , m,

j = 1, . . . p.

24

Da deﬁnição observe que o produto C = A · B seja possível, é necessário que o número

de colunas de A seja igual ao número de linhas de B

Cm×p = Am×n · Bn×p

onde, cij = Ai · Bj é o produto da i-esima linha de A e a j-ésima coluna de B a qual é

deﬁnido como a soma dos produtos de cada elemento da linha pelo seu correspondente

elemento da coluna.

3.4 Determinantes

Dada uma matriz A, quadrada de ordem n, podemos associar a ela um número real chamado

determinante da matriz A, obtido a partir de operações realizadas com seus elementos. Para se

indicar o determinante de uma matriz A utiliza-se a abreviatura det(A) ou |A|.

O cálculo do determinante de uma matriz A pode ser feito por uma lei geral que estabelece

as operações a serem realizadas com os elementos da matriz. Antes de estudarmos essa lei

geral, vamos estabelecer regras práticas para determinantes de matrizes quadradas de ordens 1,

2 e 3.

a) Matriz 1 × 1

Dada a matriz A = [a11], o seu determinante é o próprio número a11:

det(A) = |a11| = a11

b) Matriz 2 × 2

Dada a matriz A =

(cid:21)

(cid:20) a11 a12
a21 a22

, o seu determinante é igual ao produto dos elementos

da diagonal principal menos o produto dos elementos da diagonal secundária.

det(A) = a11a22 − a12a21

c) Matriz 3 × 3

Dada a matriz A =





a11 a12 a13
a21 a22 a23
a31 a32 a33



, o seu determinante é igual a:

det(A) = a11a22a33 + a12a23a31 + a13a21a32 − a13a22a31 − a11a23a32 − a12a21a33

Podemos obter esses seis produtos de uma forma prática, conhecida como regra de Sarrus,

fazendo o seguinte:

• Repetimos as duas primeiras colunas à direita da matriz e multiplicamos as seis multipli-

cações como indicado:

25

+
a11

a21

a31
−

+
a12

a22

a32
−

+
a13

a23

a33
−

a11

a21

a31

a12

a22

a32

• Os produtos obtidos na direção da diagonal principal permanecem com o mesmo sinal;

• Os produtos obtidos na direção da diagonal secundária mudam de sinal;

• O determinante é a soma dos valores assim obtido.

3.4.1 Determinante de matrizes de ordem n ≥ 2

O determinante de uma matriz A = (aij)n×n, com n ≥ 2, pode ser obtido a partir do

conceito de cofator de um elemento da matriz A.

• Menor Complementar

Dada a matriz quadrada A = (aij)n×n de ordem n(n ≥ 2), o menor complementar de um

elemento genérico aij da matriz é o determinante Dij que se obtém suprimindo a linha i

e a coluna j de A.

Exemplo: Dada a matriz

A =



4 −3 9
5
0
2

1
5
3



 ,

os menores complementares D11 , D22 e D33 são:

D11 =

D22 =

D33 =

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

0 5
5 1

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
4 −3
(cid:12)
(cid:12)
0
2
(cid:12)

4 9
3 1

= −25;

= −23;

= 6.

• Cofator

Dada uma matriz A = (aij)n×n, chama-se cofator do elemento aij o número

Aij = (−1)i+j · Dij,

26

em que Dij é o menor complementar de aij.

Exemplo: Dada a matriz:

os cofatores A11 , A21 e A31 são:

A =



4 −3 9
5
0
2

1
5
3



 ,

A11 = (−1)1+1 ·

A21 = (−1)2+1 ·

A31 = (−1)3+1 ·

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

0 5
5 1

(cid:12)
(cid:12)
(cid:12)
(cid:12)
−3 9
1
5

−3 9
5
0

= 1 · (0 − 25) = −25;

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

= (−1) · (−3 − 45) = 48;

= 1 · (−15 − 0) = −15

A partir do conceito de cofator, podemos enunciar a lei geral para o cálculo do determi-

nante de uma matriz quadrada de ordem n ≥ 2, conhecida como Teorema de Laplace

(Pierre-Simon Laplace, 1749-1827) oferece uma solução prática no cálculo dos determi-

nantes.

• Teorema de Laplace

Dada uma matriz A, quadrada de ordem n ≥ 2, o valor de det(A) é o número real obtido

pela soma dos produtos dos elementos de uma ﬁla qualquer (linha ou coluna) por seus

respectivos cofatores. Assim, se considerarmos os elementos de uma linha i, podemos

escrever:

det(A) = ai1Ai1 + ai2Ai2 + · · · + ainAin

Exemplo: Dada a matriz

A =



4 −3 9
5
0
2

1
5
3



 ,

calculamos seu determinante usando o Teorema de Laplace.

Escolhendo a 3a coluna como referência, temos,

det(A) = a13A13 + a23A23 + a33A33

= 9 · (−1)1+3 ·

+ 5 · (−1)2+3 ·

(cid:12)
(cid:12)
(cid:12)
(cid:12)

2 0
3 5

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
4 −3
(cid:12)
(cid:12)
5
3
(cid:12)

+ 1 · (−1)3+3 ·

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
4 −3
(cid:12)
(cid:12)
0
2
(cid:12)

= 9 · 1 · (10 − 0) + 5 · (−1) · (20 + 9) + 1 · 1 · (0 + 6)

= −49.

27

3.4.2 Propriedades dos determinantes

Para uma matriz quadrada A, de ordem n, podem ser demonstradas algumas propriedades

que simpliﬁcam o cálculo de seu determinante.

1. Se A tem uma linha (ou uma coluna) com todos os elementos nulos, seu determinante é

nulo.

2. Se uma matriz A tem duas linhas (ou duas colunas) proporcionais, seu determinante é

nulo.

3. Se trocarmos entre si a posição de duas linhas (ou duas colunas) de A, obtemos uma

matriz A(cid:48) tal que:

detA(cid:48) = −detA

4. Se multiplicarmos os elementos de uma ﬁla (ou de uma coluna) de A por um número real

k, obtemos uma matriz cujo determinante é k · det(A). Isto é,

det














A1
...
Ai−1
k · Ai
Ai+1
...
An














= k ·



























A1
...
Ai−1
Ai
Ai+1
...
An

5. De uma forma geral, podemos dizer que, para uma matriz A, quadrada de ordem n, temos:

det(k · A) = kn · det(A)

6. O determinante de uma matriz é igual ao determinante de sua transposta,

det(A) = det(At)

7. O determinante do produto de duas matrizes quadradas de mesma ordem é igual ao pro-

duto dos determinantes dessas matrizes,

det(A · B) = det(A) · det(B)

8. Se somarmos a uma ﬁla de A uma outra ﬁla previamente multiplicada por um número

real, obtemos uma matriz com determinante det(A),

28

det















A1
...
Ai + k · Aj
...
Aj
...
An















= det





























A1
...
Ai
...
Aj
...
An

Quando fazemos uma transformação dessa natureza numa matriz, dizemos que estamos

fazendo uma combinação linear. Esta propriedade nos garante, portanto, que, ao fazermos

combinações lineares entre ﬁlas de uma matriz, o valor de seu determinante não se altera.

3.5 Equação Linear

É toda equação do tipo

a1x1 + a2x2 + . . . + anxn = k

em que:

• x1, x2, · · · , xn são as incógnitas da equação;

• a1, a2, · · · , an são números reais denominados coeﬁcientes da equação;

• k é um número real chamado termo independente da equação.

Sempre que o termo independente de uma equação linear é zero (k = 0), ela é chamada equa-

ção linear homogênea. Uma sequência (0, 0, · · · , 0, 0) será sempre uma das soluções para uma

equação linear homogênea. Essa solução é denominada solução trivial.

Toda sequência ordenada de números reais que veriﬁca uma equação linear é chamada

solução da equação. Assim, uma sequência (α1, α2, · · · , αn) será solução da equação linear

a1x1 + a2x2 + · · · + anxn = k se ocorrer

a1α1 + a2α2 + · · · + anαn = k.

3.6 Sistema de equações lineares

Um sistema de equações lineares m × n é um conjunto de m equações lineares, cada uma

delas com n incógnitas:

29





a11x1 + a12x2 + · · · + a1nxn = b1
a21x1 + a22x2 + · · · + a2nxn = b2
...
...
am1x1 + am2x2 + · · · + amnxn = bm

...

...

...

em que:

• x1, x2, · · · , xn são incógnitas;

• aij,

i = 1, · · · m,

j = 1, · · · n são coeﬁcientes numéricos;

• b1, b2, · · · , bm são termos independentes.

Todo sistema linear do tipo:





a11x1 + a12x2 + · · · + a1nxn = 0
a21x1 + a22x2 + · · · + a2nxn = 0
...
am1x1 + am2x2 + · · · + amnxn = 0

...

...

...

...

é denominado sistema linear homogêneo do tipo m × n.

Denominamos solução do sistema linear toda sequência ordenada de números reais que

veriﬁca, simultaneamente, todas as equações do sistema. Dessa forma, resolver um sistema

signiﬁca encontrar todas as sequências ordenadas de números reais que satisfaçam as equações

do sistema.

Um sistema linear pode ser classiﬁcado de acordo com o número de soluções que admitir.

Considerando esse critério, existem três classes de sistemas lineares:

1. Os possíveis e determinados, para os quais existe uma única solução;

2. Os possíveis e indeterminados, que têm inﬁnitas soluções;

3. Os sistemas impossíveis, para os quais não existe solução.

A seguir resolvemos sistemas lineares pela Regra de Cramer e por escalonamento.

3.6.1 Regra de Cramer

A solução de um sistema linear com n equações e n incógnitas pode ser obtida utilizando-se

o cálculo com determinantes em uma regra prática denominada regra de Cramer. Considere o

30

sistema:





a11x1 + a12x2 + · · · + a1nxn = b1
a21x1 + a22x2 + · · · + a2nxn = b2
...
...
an1x1 + an2x2 + · · · + annxn = bn

...

...

...

Para obtermos sua solução por meio da regra de Cramer, procedemos da seguinte forma:

1. Calculamos o determinante da matriz A, formada pelos coeﬁcientes das variáveis do sis-

tema:

det(A) = det








a11
a12
a21
a22
...
...
am1 am2

· · ·
a1n
· · ·
a2n
...
...
· · · amn








2. Calculamos os determinantes das matrizes obtidas a partir de A, substituindo cada coluna

dos coeﬁcientes de xi, pela coluna dos termos independentes do sistema:

det(X1) = det

det(X2) = det

...

...

det(Xn) = det






















b1 a12
b2 a22
...
...
bn an2

a11
a21
...
an1

b1
b2
...
bn

a1n
· · ·
a2n
· · ·
...
...
· · · ann

a1n
· · ·
a2n
· · ·
...
...
· · · ann

a11 a12
a21 a22
...
...
an1 an2

· · ·
· · ·
...
· · ·

b1
b2
...
bn






















3. Se det(A) (cid:54)= 0, o sistema é possível e determinado e sua solução será:

x1 =

det(X1)
det(A)

,

x2 =

det(X2)
det(A)

,

· · · ,

xn =

det(Xn)
det(A)

4. Só é possível usar a Regra de Cramer em sistemas n × n em que det(A) (cid:54)= 0. Caso ocorra

que det(A) = 0, a discussão da solução do sistema deve ser feita por escalonamento.

31

3.7 Sistema escalonado

Um sistema linear de equações está na forma escalonada se em cada linha o número de zeros

antes do primeiro elemento não nulo é maior que a linha anterior. Logo, se tiver linhas nulas na

matriz escalonada elas ﬁcam nas linhas inferiores.

A partir da deﬁnição, pode-se concluir que, em todo sistema escalonado, o número de equa-

ções é sempre igual ou menor que o número de incógnitas.

3.7.1 Resolução de um sistema escalonado

Para se resolver um sistema escalonado com m equações e n incógnitas, devemos considerar

dois casos:

a) Número de equações (m) = número de incógnitas (n)






a11x1 + a12x2 + · · · + a1nxn = b1
+ a22x2 + · · · + a2nxn = b2
...
...
amnxn = bm

...
...

...

Para se chegar à solução desse sistema, parte-se da última equação, que fornece direta-

mente o valor de xn e, por retro-substituição nas equações anteriores, obtêm-se os valores

de xn−1, xn−2, · · · , x2 e x1.

b) Número de equações (m) < número de incógnitas (n)

a11x1 + a12x2
a22x2






+
+

· · · + a1nxn = b1
· · · + a2nxn = b2
...
...
...
...
...
amjxj + · · · + annxn = bn

Para se resolver esse tipo de sistema, procede-se da seguinte forma:

• Identiﬁcam-se as variáveis que não iniciam equações (variáveis livres);

• Transpõem-se as variáveis livres para o segundo membro de cada equação e atribuem-

se a elas valores reais arbitrários. Com esse procedimento, obtém-se um sistema em

que o número de equações é igual ao número de incógnitas, que pode ser resolvido

por substituições sucessivas.

32

3.8 Método de Gauss

A teoria das equações lineares desempenha papel importante e motivador no campo da

Álgebra Linear, onde muitos problemas são equivalentes ao estudo de um sistema de equações

lineares.

Considere o sistema linear Ax = b:

a11x1 + a12x2 + · · · + a1nxn = b1
a21x1 + a22x2 + · · · + a2nxn = b2




an1x1 + an2x2 + · · · + annxn = bn

...

O método de eliminação de Gauss consiste em transformar convenientemente o sistema

linear original para obter um sistema linear equivalente com a matriz dos coeﬁcientes sendo

triangular superior.

Para modiﬁcar convenientemente um sistema linear num equivalente, fazemos uso das se-

guintes operações elementares que não modiﬁcam a solução do sistema original:

• Trocar duas equações ou duas colunas;

• Multiplicar uma equação por uma constante não-nula;

• Adicionar um múltiplo de uma equação a outra equação.

Para triangularizar o sistema de equações lineares Ax = b pelo método de Gauss seguimos

o seguinte procedimento:

1. Eliminação da primeira coluna

Supondo a11 (cid:54)= 0 (pivô), eliminamos a incógnita x1 das últimas n − 1 equações fazendo:

Li ← Li −

ai1
a11

· L1,

i = 2, · · · , n

onde Li é a i-ésima linha do sistema de equações. Em termos dos coeﬁcientes para cada

i = 2, · · · , n temos,

a2
ij = aij −

· a1j,

j = 2, · · · , n

ai1
a11
ai1
a11

b2
i = bi −

· b1.

33

onde o super índice 2 indica o valor atualizado de aij e bi neste passo.

No ﬁnal deste estágio, obtém-se a seguinte conﬁguração para o sistema de equações:





a11x1 + a12x2 + · · · + a1nxn = b1
2nxn = b2
22x2 + · · · + a2
a2
2
...
...
...
nnxn = bn
n2x2 + · · · + an
an
n

2. Eliminação da segunda coluna

Supondo a2

22 (cid:54)= 0 (pivô) eliminamos a incógnita x2 das últimas n − 2 equações fazendo:

Li ← Li −

a2
i2
a2
22

· L1,

i = 3, · · · , n

Em termos dos coeﬁcientes para cada i = 3, · · · , n temos,

ij = a2
a3

ij −

b3
i = b2

i −

a2
i2
a2
22
a2
i2
a2
22

· a2

2j,

j = 3, · · · , n

· b2
2.

onde o super índice 3 indica o valor atualizado de aij e bi neste passo.

No ﬁnal deste estágio, obtém-se a seguinte conﬁguração para o sistema de equações:






a11x1 + a12x2 + a13x3 + · · · + a1nxn = b1
2nxn = b2
2
3nxn = b3
3
...
...
nnxn = bn
n

23x3 + · · · + a2
22x2 + a2
a2
33x3 + · · · + a3
a3
...
n3xn + · · · + an
an

3. Eliminação da k-ésima coluna

Supondo ak

kk (cid:54)= 0 (pivô) eliminamos a incógnita xk das últimas n − k equações fazendo:

Li ← Li −

ak
ik
ak
kk

· L1,

i = k + 1, · · · , n

Em termos dos coeﬁcientes para cada i = k + 1, · · · , n temos,

ij −

ak+1
ij

= ak

ak
ik
ak
kk
ak
ik
ak
kk
onde o super índice k + 1 indica o valor atualizado de aij e bi neste passo.

j = k + 1, · · · , n

= bk

bk+1
i

· bk
2.

i −

· ak

2j,

No ﬁnal deste estágio, obtém-se a seguinte conﬁguração para o sistema de equações:






23x3 + · · · + a2
22x2 + a2
a2
33x3 + · · · + a3
a3

a11x1 + a12x2 + a13x3 + · · · + a1nxn = b1
2nxn = b2
2
3nxn = b3
3
...
...
nnxn = bn
an
n

No caso de um pivô ser nulo, deve-se obter um pivô não nulo intercambiando a posição

com uma das linhas inferiores.

4. Resolvemos o sistema triangular superior por retro-substituição:

34

xn =

xn−1 =

bn
n
an
nn
n−1 − an−1
bn−1
n−1,n
an−1
n−1,n−1

... =

x1 =

...
b1 − a1nxn − · · · − a13x3 − a12x2
a11

.

Exemplo: Considere o sistema de equações






4x1 + 9x2 + 10x3 = 0
2x1 + 5x2 + 5x3 = 6
= 1
7x1 + 10x2

determinamos os valores de x1, x2 e x3 seguindo o método de Gauss:

1. Eliminação da primeira coluna

Considerando o pivô a11 = 4, fazemos as seguintes operações elementares,

L2 ←− L2 −

a21
a11

L1

←− (2x1 + 5x2 + 5x3 = 6) −

←− (0x1 +

1
2

x2 + 0x3 = 6)

2
4

L3 ←− L3 −

a31
a11

L1

(4x1 + 9x2 + 10x3 = 0)

←− (7x1 + 10x2 + 0x3 = 1) −

7
4

(4x1 + 9x2 + 10x3 = 0)

←− (0x1 −

23
4

x2 −

35
2

x3 = 1)

obtém-se o novo sistema equivalente:






4x1 + 9x2 + 10x3 = 0

1
2x2 + 0x3 = 6

− 23

4 x2 − 35

2 x3 = 1

35

2. Eliminação da segunda coluna

Considerando o pivô a22 = 1

2, fazemos as seguintes operações elementares:

L3 ←− L3 −

a32
a22

L2

←− (0x1 −

23
4

x2 −

35
2

x3 = 1) −

23
4
1
2

(0x1 +

1
2

x2 + 0x3 = 6)

←− (0x1 + 0x2 −

35
2

x3 = 70)

Obtemos agora um sistema linear triangular superior:






4x1 + 9x2 + 10x3 = 0

1
2x2

= 6

− 35

4 x3 = 70

3. Solução por retro-substituição

Agora ﬁca fácil a resolução. Vejam que a equação L3 já nos fornece diretamente o valor

da incógnita x3:

−

35
2

x3 = 70 =⇒ x3 = −4

Substituímos x3 na equação L2 obtendo:

1
2

x2 = 6 =⇒ x2 = 12

Substituímos x2 e x3 na equação L1, obtendo:

4x1 + 9x2 + 10x3 = 0 =⇒ x1 = −17

O sistema de equações lineares tem solução única e é dado por (-17,12,-4).

3.9 Matriz inversa

Para (OLIVEIRA, 2015), encontrar a matriz inversa de uma matriz conhecida é um pro-

cesso que envolve multiplicação e igualdade de matrizes. Vejamos como ocorre este processo

partindo da deﬁnição de uma matriz inversa.

Seja A uma matriz quadrada de ordem n, e X uma matriz tal que A · X = In e X · A = In

(onde In é a matriz identidade). Caso isso ocorra, denominamos a matriz X de matriz inversa

36

de A, tendo como notação A−1.

Portanto, para encontrar a inversa de uma matriz dada, deveremos resolver a igualdade de

matrizes (A · X = In). No caso em que sejam dadas duas matrizes e que seja pedido para

veriﬁcar se uma matriz é a inversa da outra, basta efetuar a multiplicação destas duas matrizes.

Se o resultado desta operação for a matriz identidade, aﬁrmaremos que se trata de uma matriz

inversa.

Para aqueles que já sabem calcular o determinante, existe um modo prático para descobrir

se uma matriz possui uma matriz inversa ou não. Basta calcular o determinante da matriz: caso

o determinante dê igual a zero, não existe matriz inversa para ela.

A parte principal para matriz inversa é a parte onde se deve encontrá-la tendo como base

uma matriz dada. Vejamos como proceder.

Exemplo: Seja a matriz A =

de mesma ordem,

(cid:21)

(cid:20) 2 3
2 5

. Sabemos que a matriz A−1 será uma matriz quadrada

A−1 =

(cid:20) a b
c d

(cid:21)

.

Logo,

A · A−1 = In ⇒

(cid:20) 2 3
2 5

(cid:21)

(cid:20) a b
c d

·

(cid:21)

=

(cid:20) 1 0
0 1

(cid:21)

Para tanto, deveremos compreender o processo de multiplicação de matrizes para realizarmos

estes cálculos.

(cid:20) 2a + 3c 2b + 3d
2a + 5c 2b + 5d

(cid:21)

=

(cid:20) 1 0
0 1

(cid:21)

Através da igualdade de matrizes, obteremos 4 igualdades muito importantes para os nossos

cálculos. Agrupá-las-emos de forma que as igualdades com mesmas incógnitas ﬁquem juntas.

I :

(cid:26) 2a + 3c = 1
2a + 5c = 0

II :

(cid:26) 2b + 3d = 0
2b + 5d = 1

Em situações como estas devemos resolver estes sistemas de equações com duas incógnitas.

Resolvemos o sistema I pelo método da adição,

2a + 3c = 1
2a + 5c = 0
= 1

−2c

⇒ c = −

1
2

.

Substituindo o valor de c, obteremos o valor de a,

2a + 3c = 1 ⇒ 2a + 3 · (−

1
2

) = 1 ⇒ a =

5
4

.

37

Resolvendo o sistema II de forma análoga, obteremos os seguintes valores para as incógnitas:

b = −

3
4

,

d =

1
2

.

Como encontramos os valores para os elementos da matriz inversa, vamos esboçá-la:

A−1 =








5
4

−

3
4

−

1
2

1
2








.

Neste primeiro momento veriﬁcaremos se de fato esta matriz corresponde à matriz inversa:

(cid:20) 2 3
2 5

(cid:21)



·



5

4 − 3

4

− 1
2

1
2





 =



2 · 5

4 + 3 · (− 1

2) 2 · (− 3

4) + 3 · ( 1
2)

2 · 5

4 + 5 · (− 1

2) 2 · (− 3

4) + 5 · ( 1
2)



 =

(cid:20) 1 0
0 1

(cid:21)

.

De fato, a matriz obtida corresponde à matriz inversa, pois o produto das duas matrizes re-

sultou na matriz identidade. Como vimos, o estudo da matriz inversa abarca diversos conceitos

da matemática, desde operações básicas até a resolução de sistemas com duas incógnitas.

Capítulo 4

Aspectos numéricos

Neste capítulo apresentamos aspectos numéricos associados à implementação dos algorit-

mos de resolução linear e determinantes, assim como a aproximação de um número real por

uma fração com o objetivo de fornecer uma melhor visualização dos resultados ao usuário.

4.1 Complexidade Computacional

A complexidade computacional ou custo computacional de um algoritmo é o número de

operações necessárias para concluir o algoritmo. Neste trabalho vamos contar quantas ope-

rações fundamentais são necessárias (adição, multiplicação, subtração e divisão). Sendo que

o tempo de execução do compilador para calcular uma multiplicação ou uma divisão é muito

maior que o de calcular uma adição ou subtração, consideramos portanto somente na contagem

o número de multiplicações e divisões.

Assim o custo computacional de um algoritmo será medido como

Custo Computacional = número de multiplicações + número de divisões

onde, uma multiplicação e uma divisão tem o mesmo custo computacional.

4.1.1 Sistema diagonal

Seja o sistema diagonal

a11x1

a22x2






. . .

. . .

= b1
= b2
...
...
annxn = bn

onde, aii (cid:54)= 0,

∀i = 1, · · · , n.

O algoritmo para resolver o sistema diagonal é:

38

39

Entrada: aii, bi, (i = 1, 2, · · · , n)
início

para i = 1 até i = n faça

Xi =

bi
aii

ﬁm

ﬁm

Como temos n divisões na execução do algoritmo, o custo computacional de resolver um sis-

tema diagonal é:

Custo Computacional = n

Isto é, o custo computacional do algoritmo do sistema diagonal cresce linearmente com n.

4.1.2 Sistema triangular superior

Seja o sistema diagonal






a11x1 + a12x2 + · · · + a1nxn = b1
a22x2 + · · · + a2nxn = b2
...
...
annxn = bn

. . .

...
...

onde, aii (cid:54)= 0,

∀i = 1, · · · , n.

O algoritmo para resolver o sistema triangular superior é:

Entrada: aij, bij, (i = 1, 2, · · · , n)
início

Xn =

bn
ann

para k = n − 1 até k = 1 faça

Soma ← bk
para j = k + 1 até j = n faça
Soma ← Soma − akjXj

ﬁm

Xk ←

Soma
akk

ﬁm

ﬁm

Como temos:

Divisões: 1 + (n − 1) = n

Multiplicações:

40

n−1
(cid:88)

n
(cid:88)

1 =

n−1
(cid:88)

(n − (k + 1) + 1)

k=1

j=k+1

k=1

=

=

n−1
(cid:88)

(n − k)

k=1
n−1
(cid:88)

n−1
(cid:88)

k

n −

k=1

k=1

n(n − 1)
2

= n(n − 1) −

=

n(n − 1)
2

Logo,

Custo Computacional = n +

n(n − 1)
2

= n +

n2
2

−

n
2

=

n2
2

+

n
2

Como n2 > n, consideramos:

Custo Computacional ≈

n2
2

Isto é, o custo computacional do algoritmo de retro-substituição cresce com a potência de n2.

4.1.3 Eliminação Gaussiana

Seja o sistema





a11x1 + a12x2 + · · · + a1nxn = b1
a21x1 + a22x2 + · · · + a2nxn = b2
...
. . .
an1x1 + an2x2 + · · · + annxn = bn

...

...

...

onde, det(A) (cid:54)= 0, sendo A = (aij)

O algoritmo para resolver a eliminação Gaussiana consta de dois passos:

1. Redução do sistema linear para sistema triangular superior por escalonamento.

2. Resolver o sistema triangular por retro-substituição.

O custo computacional do sistema triangular superior já foi analisado na seção 4.1.2, portanto

focamos nossa análise ao escalonamento do sistema linear.

O algoritmo para o escalonamento é:

41

Entrada: (aij), i = 1 : n, j = 1 : n
Entrada: (bi), i = 1 : n

início

para k = 1 até k = n − 1 faça
achar i ≥ k tal que aik (cid:54)= 0
troque linha k com linha i
se aii = 0, ∀i ≥ k então

STOP (cid:3) A não é inversível

ﬁm
para i = k + 1 até i = n faça

(cid:3) Multiplicador

aik
m ← mik =
akk
bi ← bi − m · bk
para j = k + 1 até j = n faça

aij ← aij − m · akj

ﬁm

ﬁm

ﬁm

ﬁm

Temos:

Divisões:

Multiplicações:

n−1
(cid:88)

n
(cid:88)

k=1

i=k+1

1 =

=

=

n−1
(cid:88)

k=1

n−1
(cid:88)

k=1
n−1
(cid:88)

(n − (k + 1) + 1)

(n − k)

n−1
(cid:88)

k

n −

k=1

k=1

= n(n − 1) −

=

n(n − 1)
2

n(n − 1)
2

n−1
(cid:88)

n
(cid:88)

1 +

n−1
(cid:88)

n
(cid:88)

n
(cid:88)

1 =

k=1

i=k+1

k=1

i=k+1

j=k+1

42

=

=

=

=

=

=

=

=

=

n(n − 1)
2

+

n−1
(cid:88)

n
(cid:88)

k=1

i=k+1

[n − (k + 1) + 1]

n(n − 1)
2

+

n(n − 1)
2

+

n(n − 1)
2

+

n(n − 1)
2

+

n−1
(cid:88)

n
(cid:88)

(n − k)

k=1

i=k+1

(n − k)

n
(cid:88)

1

i=k+1

(n − k) [n − (k + 1) + 1]

n2 − 2nk + k2

n−1
(cid:88)

k=1

n−1
(cid:88)

k=1
n−1
(cid:88)

k=1

n(n − 1)
2

n(n − 1)
2
n(n − 1)
2
n(n − 1)
2

+ n2

n−1
(cid:88)

k=1

1 − 2n

n−1
(cid:88)

n−1
(cid:88)

k2

k +

k=1

k=1

+ n2(n − 1 − 1 + 1) − 2n

n(n − 1)
2

+

(n − 1)n [2(n − 1) + 1]
6

+ n2(n − 1) − n2(n − 1) +

(n − 1)n(2n − 1)
6

+

(n − 1)n(2n − 1)
6

Logo, o custo computacional do escalonamento é:

Custo Computacional =

n(n − 1)
2

+

+

n(n − 1)(2n − 1)
6

n(n − 1)(2n − 1)
6

=

= n2 +

n(n − 1)
2
n
2

−

+

+

+

n2
2

n2
2

n
2
n(n − 1)(2n − 1)
6
3n3 − 3n2 + n
6

=

Como n3 > n2 e n3 > n temos que

Custo Computacional ≈ n3

Isto é, o custo computacional do algoritmo de eliminação de Gauss, cresce como uma potência

de n3.

4.1.4 Determinantes por Cofatores

Se A ∈ M (n) (matrizes quadradas de ordem n), então:

det(A) =

n
(cid:88)

j=1

aiAij

43

Para esclarecer o cálculo do custo computacional vamos exempliﬁcar com matrizes de ordem

1, 2, 3 e 4.

1. Se A ∈ M (1) e A = (a11), então det(A) = a11

2. Se A ∈ M (2) e A = (aij), então det(A) = a11a22 − a12a21, portanto

Custo Computacional ≈ 2

3. Se A ∈ M (3) e A = (aij), então det(A) = a11A11 + a12A22 + a13A33, onde Aii são

determinantes de ordem 2, logo temos:

Custo Computacional ≈ 3 · 2 = 6

4. Se A ∈ M (4) e A = (aij), então det(A) = a11A11 + a12A22 + a13A33 + a14A44, onde Aii

são determinantes de ordem 3, logo temos:

Custo Computacional ≈ 4 · 6 = 24

Em geral, denotemos Dj ≈ custo computacional de calcular o determinante de ordem j.

Se A ∈ M (n), temos

det(A) =

n
(cid:88)

j=1

aijAij

logo Dn ≈ n · Dn−1 a qual é a equação de recorrência.

Assim

D2 ≈ 2

D3 ≈ 3 · D2

D4 ≈ 4 · D3

D5 ≈ 5 · D4
...

...

Dn−1 ≈ (n − 1) · Dn−2

Dn ≈ n · Dn−1

Dn ≈ n!

multiplicando, temos

44

isto é, o custo de avaliar um determinante de uma matriz de ordem n é aproximadamente n!

multiplicações.

Usando a fórmula de Stirling temos:

Dn ≈ n! ≈

(cid:17)n √

2πn

(cid:16)n
e

signiﬁcando que o custo computacional de avaliar u determinante cresce exponencialmente com

a ordem do determinante. Por exemplo, se n = 20 temos:

D20 ≈ 20! ≈

(cid:19)20 √

2π20

(cid:18) 20
e

Se um computador tem um processador que executa um giga ﬂop por segundo (1G ﬂop/s = 109

ﬂop/s), o tempo para calcular um determinante de uma matriz de ordem 20 é:

t20 ≈

D20
109 ≈

(7, 38)20 × 11, 21
109

segundos

aplicando log, temos

log t20 ≈ 20 log 7, 38 + log 11, 21 − log(109)

≈ 17, 361 + 1, 041 − 9

≈ 9, 40

obtendo

t20 ≈ 109,40 segundos, ou

t20 ≈ 105,84 horas, ou

t20 ≈ 104,46 dias, ou

t20 ≈ 101,82 anos, ou

t20 ≈ 72 anos

ou seja, este processador com a capacidade de realizar 109 ﬂop/s demoraria 72 anos para calcu-

lar um determinante de ordem 20 usando o método dos cofatores.

Assim, o método dos cofatores não é um método eﬁciente para calcular determinantes de ma-

trizes de ordem maior que 3.

O cálculo ineﬁciente do determinante pelo método dos cofatores faz ineﬁciente também o mé-

todo de Cramer para resolver sistemas lineares, pois temos que calcular (n + 1) determinantes,

com um custo de :

Custo Computacional = (n + 1) · Dn ≈ (n + 1)

(cid:17)n √

2πn,

(cid:16)n
e

(n + 1) vezes o cálculo de um determinante pelo método dos cofatores.

o custo computacional de ordem polinomial n3 é muito mais eﬁciente e prático que o método

45

de Cramer resolvendo os determinantes por cofatores com custo computacional exponencial de

(n + 1)

(cid:16) n
e

(cid:17)n √

2πn

4.1.5 Matriz Inversa

Seja a matriz A ∈ M (n) e sua inversa A−1 ∈ M (n), onde A = (aij) é conhecida e

A−1 = (bij) é a matriz desconhecida. Veriﬁcando que:

A · A−1 = I

Para resolver a j-ésima coluna de A−1, formamos o sistema linear de n equações:

onde,

n
(cid:88)

k=1

aikbkj = δij,

i = 1, 2, · · · , n

δ =

(cid:26) 1
0

se
se

i = j
i (cid:54)= j

Como temos n colunas, então resolver a matriz inversa por este método requer resolver inde-

pendentemente n sistemas de equações de ordem n. Logo o custo computacional de calcular a

inversa de uma matriz de ordem n é:

Custo Computacional ≈ n · n3 = n4,

Assim, o cálculo da inversa de uma matriz de ordem n tem um custo computacional n4.

4.2 Transformação de decimais em frações

Nesta seção apresentamos como escrever um número como uma fração com o intuito de que

o resultado apresentado ao usuário seja uma fração. Mesmo que o resultado seja um número

irracional, este vai ser truncado com um número determinado de casas decimais representado

assim uma aproximação do número obtido.

De acordo com (MIRANDA, 2015), temos as seguintes transformações:

4.2.1 Número inteiro em fração

46

Se pegarmos o número 2 para representá-lo em forma de fração basta achar um número
200
100

que dividido por outro número o resultado seja 2. Por exemplo, as frações

20
10

10
5

ou

ou

representam o inteiro 2.

4.2.2 Número decimal exato em fração

Se pegarmos o número 0,5 (a leitura dele é cinco décimos), é preciso lembrar que décimo

vem de dez, assim como centésimos vem de cem e milésimo vem de mil, então para transformar

0,5 em fração basta eliminar a vírgula ﬁcando o número 5, assim o denominador será o número

que representa a casa decimal, então:

0, 5 =

5
10

=

1
2

Para transformar 2,25 (sua leitura é dois inteiros e vinte e cinco centésimos), retirando a

vírgula ﬁca 225 no numerador, o denominador ﬁca 100, pois as casas decimais estão em centé-

simos.

2, 25 =

225
100

=

45
20

=

9
4

Se dividirmos o numerador de cada fração acima pelo denominador correspondente, chega-

remos ao valor decimal correspondente a ele.

4.2.3 Dízima periódica em fração

Dízima periódica é a parte decimal inﬁnita, pois repete igualmente. Por exemplo: 0,6666...;

0,4545...; 5,6333... .

Esses números podem ser escritos em forma de fração, mas apesar de serem números deci-

mais na sua transformação utilizaremos um processo diferente.

Exemplo 1:

Vamos transformar 0, 6666... em fração, chamaremos a dízima de X:

X = 0, 6666...

(4.1)

Devemos eliminar as casas decimais. Para isso andaremos com a vírgula para a direita uma casa

decimal, pois apenas o 6 que repete. Isso é o mesmo que multiplicar o 0, 6666... por 10.

10.X = 6, 6666...

(4.2)

47

Iremos subtrair as duas equações: (4.2) − (4.1)

10X = 6, 6666...
X = 0, 6666...
9X =

6

X =

6
9

=

2
3

Exemplo 2:

Temos a dízima 0, 4545...

X = 0, 4545...

(4.3)

andando com a vírgula duas casas para a direita, pois o número que repete nas casas decimais é

o 45, andar duas casas para a direita é o mesmo que multiplicar por 100.

100 · X = 45, 4545...

(4.4)

Iremos subtrair as duas equações: (4.4) − (4.3)

100X = 45, 4545...
X = 0, 4545...

99X =

45

X

=

45
99

=

5
11

Exemplo 3:

Temos a dízima 5,6333... nessa percebemos que na parte decimal temos apenas o 3.

X = 5, 6333...

Como o 6 não faz parte da dízima devemos multiplicar a equação por 10 para que o número 6

passe pro outro lado deixando nas casas decimais apenas a dízima.

10 · X = 56, 3333...

(4.5)

Agora, multiplicamos a equação (4.5) por 10 novamente para que possamos cancelar a parte

decimal.

100 · X = 563, 3333...

(4.6)

Subtraindo as equações (4.6) − (4.5), teremos:

100X = 563, 3333...
10X = 56, 3333...
90X =

507

X

=

507
90

=

169
30

48

4.3 Uma abordagem computacional para a representação de

uma fração

Para uso no cotidiano os exemplos acima são bem práticos, porém para programação não é

tão simples assim, apesar de ser aplicável, não é viável, pois o computador utiliza muito mais

recursos para multiplicar e dividir, também teria uma grande diﬁculdade para simpliﬁcar fra-

ções, pensando nisso surgiu à ideia de utilizamos o que a máquina faz muito bem, que é somar

e contar, para fazer a transformação de números decimais em números fracionários.

Todo número decimal é uma fração de um número inteiro, portanto se somarmos várias ve-

zes essa fração chegaremos a um número inteiro que será o numerador da fração, o denominador

será determinado pela contagem das vezes que utilizamos o decimal na soma, baseado nisso,

desenvolvemos um algoritmo que transforma os decimais em frações para serem apresentados

nas matrizes.

Exemplo 1:

Vamos transformar 0, 75 em fração.

0, 75 ⇒ 1
0, 75 ⇒ 2

1, 50
0, 75 ⇒ 3

2, 25
0, 75 ⇒ 4

3, 00

Portanto 0, 75 =

3
4

.

Exemplo 2:

Vamos transformar 7, 625 em fração.

49

7, 625 ⇒ 1
7, 625 ⇒ 2

15, 250
7, 625 ⇒ 3

22, 875
7, 625 ⇒ 4

30, 500
7, 625 ⇒ 5

38, 125
7, 625 ⇒ 6

45, 750
7, 625 ⇒ 7

53, 375
7, 625 ⇒ 8

61, 000

Portanto 7, 625 =

61
8

.

Fazendo dessa forma teríamos um problema com números com a parte decimal muito longa,

pois a soma poderia demorar muito, para resolver esta situação utilizamos na programação, um

tipo de número decimal chamado currency, destinado a valores monetários e que tem precisão

até a quarta casa decimal, ou seja quando um número for 0,99995 ele considera 1. Apesar de

isso gerar um erro de arredondamento, não interfere no resultado das contas, pois as frações são

apenas para melhorar o visual das matrizes e os cálculos são feitos com os números decimais

originais.

Capítulo 5

Descrição do Aplicativo

O aplicativo Matriz tem como objetivo principal auxiliar o aluno a aprender o método de

Gauss para escalonar matrizes, esse método é muito útil nos mais diversos cálculos, como por

exemplo: determinante, equações lineares, matriz inversa, etc.

5.1 Tela Inicial

Figura 5.1: Tela Inicial

Na tela mostrada na Figura 5.1 temos os seguintes botões:

Determinante: Calcula o determinante de uma matriz pelo método de Laplace e pelo

método de Gauss (escalonamento).

Equações Lineares: Calcula a solução de equações lineares utilizando o método de

Gauss.

Matriz Inversa: Calcula matriz inversa utilizando o método de Gauss.

Treinamento Gauss: Treinamento do método de Gauss fazendo conferência pelo deter-

minante da matriz.

50

5.2 Determinante

51

Figura 5.2: Tela Determinante

Na tela mostrada na Figura 5.2 temos as seguintes opções:

Gera Matriz: Gera a matriz de acordo com a ordem deﬁnida.

Laplace: Calcula o valor do determinante da matriz pelo método de Laplace.

Gauss: Calcula o valor do determinante da matriz pelo método de Gauss.

Imprimir: Imprimi cálculos apresentados na área azul.

Ordem: Deﬁne a ordem da matriz.

Mostra Seq.: Mostra a sequência de cálculo na área azul.

... : Gera valores aleatórios para a matriz de acordo com a ordem.

5.3 Equações Lineares

52

Figura 5.3: Tela Equações Lineares

Na tela mostrada na Figura 5.3 temos as seguintes opções:

Gera Matriz: Gera a matriz de acordo com a ordem deﬁnida.

Gauss: Calcula o valor das variáveis da matriz pelo método de Gauss.

Imprimir: Imprimi cálculos apresentados na área azul.

Ordem: Deﬁne a ordem da matriz.

Mostra Seq.: Mostra a sequência de cálculo na área azul.

... : Gera valores aleatórios para a matriz de acordo com a ordem.

5.4 Matriz Inversa

53

Figura 5.4: Tela Matriz Inversa

Na tela mostrada na Figura 5.4 temos as seguintes opções:

Gera Matriz: Gera a matriz de acordo com a ordem deﬁnida.

Laplace: Calcula o valor do determinante da matriz pelo método de Laplace.

Gauss: Calcula a matriz inversa pelo método de Gauss.

Imprimir: Imprimi cálculos apresentados na área azul.

Ordem: Deﬁne a ordem da matriz.

Mostra Seq.: Mostra a sequência de cálculo na área azul.

... : Gera valores aleatórios para a matriz de acordo com a ordem.

5.5 Treinamento Gauss

54

Figura 5.5: Tela Treinamento Gauss

Na tela mostrada na Figura 5.5 temos as seguintes opções:

Gera Matriz: Gera a matriz de acordo com a ordem deﬁnida.

Iniciar: Calcula o determinante da matriz e inicia o treinamento de escalonamento pelo

método de Gauss.

Executar: Executa operações na última matriz apresentada na área azul.

Imprimir: Imprimi cálculos apresentados na área azul.

Ordem: Deﬁne a ordem da matriz.

Mostra Seq.: Mostra a sequência de cálculo na área azul.

... : Gera valores aleatórios para a matriz de acordo com a ordem.

Escalonamento: Operações de divisão de elementos, multiplicação de linha por número

e subtração de linhas com o objetivo de escalonar a matriz. (Gauss)

Modiﬁcar Matriz: Operações de adição ou subtração de linhas e multiplicação de linha

por número com o objetivo de evitar o pivô zero.

5.6 Exemplo de Cálculo de Determinante

55

Para calcular o determinante da matriz abaixo:
−2 −1
4 −1
−2
3

A =





1
4
5 −2
5 −1
3
0 −3 −2









1. Primeiro digite a ordem da matriz, nesse exemplo é da quarta ordem e em seguida clique

no botão "Gerar Matriz".

Figura 5.6: Primeiro passo - Determinante

2. Digite os elementos da matriz.

Figura 5.7: Segundo passo - Determinante

3. Marque "Mostra Seq."para que seja exibida a sequência de cálculo na área em azul, e

clique em "Gauss"ou "Laplace"para processar.

56

Figura 5.8: Terceiro passo - Determinante

4. Para imprimir o cálculo, clique em "Imprimir".

57

Figura 5.9: Quarto passo - Determinante

5.7 Exemplo de Cálculo de Equações Lineares

Para calcular as variáveis do sistema abaixo:






2x1 −3x2 +x3 −2x4 = 1
4x1 +2x2 −x3 −3x4 = −7
−x1 −2x2 +3x3 +x4 = 10
−2x1 +x2 −2x3 +2x4 = −1

1. Primeiro digite a ordem da matriz, nesse exemplo é da quarta ordem e em seguida clique

no botão "Gerar Matriz".

58

Figura 5.10: Primeiro passo - Equações Lineares

2. Digite os coeﬁcientes das equações, na ordem que aparecem, para montar a matriz.

Figura 5.11: Segundo passo - Equações Lineares

3. Marque "Mostra Seq."para que seja exibida a sequência de cálculo na área em azul, e

clique em "Gauss"para processar.

59

Figura 5.12: Terceiro passo - Equações Lineares

4. Para imprimir o cálculo, clique em "Imprimir".

60

Figura 5.13: Quarto passo - Equações Lineares

5.8 Exemplo de Cálculo de Matriz Inversa

Para calcular a matriz inversa da matriz abaixo:

A =

(cid:21)

(cid:20) 1 2
3 4

1. Primeiro digite a ordem da matriz, nesse exemplo é da segunda ordem e em seguida clique

no botão "Gerar Matriz".

61

Figura 5.14: Primeiro passo - Matriz Inversa

2. Digite os elementos da matriz.

Figura 5.15: Segundo passo - Matriz Inversa

3. Marque "Mostra Seq."para que seja exibida a sequência de cálculo na área em azul, e

clique em "Gauss"para processar.

62

Figura 5.16: Terceiro passo - Matriz Inversa

4. Para imprimir o cálculo, clique em "Imprimir".

63

Figura 5.17: Quarto passo - Matriz Inversa

5.9 Exemplo de Treinamento Gauss

Para treinamento vamos utilizar matriz abaixo:

A =





0 1
2
4 2 −1
3
2 5





 ⇒



a11 a12 a13
a21 a22 a23
a31 a32 a33





1. Primeiro digite a ordem da matriz, nesse exemplo a matriz é de terceira ordem, em seguida

clique no botão "Gerar Matriz"então digite os elementos da matriz.

64

Figura 5.18: Primeiro passo - Treinamento Gauss

2. Ao clicar em "Iniciar"o sistema calcula o determinante da matriz e mostra na parte inferior

esquerda da tela.

Figura 5.19: Segundo passo - Treinamento Gauss

3. Vale lembrar que cada coluna tem seu pivô e que os pivôs são os elementos da diagonal

principal (a11, a22, a33, · · · ) e o objetivo é zerar todos os elementos de cada coluna que

estiverem abaixo de seu respectivo pivô.

Como o pivô inicial a(1,1) é igual a zero, devemos modiﬁca-lo usando as propriedades

das matrizes, gerando outra matriz equivalente, para isso podemos somar a Linha1 com a

Linha3 e substituir a Linha1 pela soma, clique em "Modiﬁcar Matriz"e selecione Linha

1 / Somar / Linha 3 e clique "Executar".

65

Figura 5.20: Terceiro passo - Treinamento Gauss

Todas as operações irão aparecer dentro da área azul e o determinante da nova matriz será

calculado e exibido na parte inferior direita da tela.

Figura 5.21: Terceiro passo - Treinamento Gauss - 2

4. Agora que o nosso primeiro pivô passou a ser a(1,1) = 2 então iremos zerar o primeiro

elemento abaixo dele que é a(2,1) = 4.

Clique em "Escalonamento", lembrando que "Mult"é um multiplicador que tem como

numerador o elemento a ser zerado e como denominador o pivô

M ult =

a(2,1)
a(1,1)

=

4
2

= 2

A linha a ser modiﬁcada será igual a própria linha subtraída da multiplicação de Mult

pela linha do pivô.

Linha2 = Linha2 − M ult ∗ Linha1

Clique em "Executar".

66

Figura 5.22: Quarto passo - Treinamento Gauss

Caso tudo esteja correto, a nova matriz terá o elemento pretendido zerado e os dois núme-

ros abaixo da área azul, permaneceram iguais, pois são os determinantes da matriz inicial

e da matriz modiﬁcada.

5. Vamos zerar o próximo elemento abaixo do pivô que é a(3,1) = 2, então

M ult =

a(3,1)
a(1,1)

=

2
2

= 1

e a linha a ser modiﬁcada será:

Linha3 = Linha3 − M ult ∗ Linha1

67

Figura 5.23: Quinto Passo - Treinamento Gauss

Vamos zerar a(3,2)=−1, mudamos de coluna portanto mudamos de pivô que passa a ser

a(2,2) = −10 então

M ult =

a(3,2)
a(2,2)

=

−1
−10

=

1
10

e a linha a ser modiﬁcada será:

Linha3 = Linha3 − M ult ∗ Linha1

Figura 5.24: Quinto passo - Treinamento Gauss - 2

Após o escalonamento completo podemos calcular o determinante fazendo a multiplica-

ção dos pivôs resultantes.

det(A) = 2 · (−10) · (−

9
10

) ⇒ det(A) = 18

68

Considerações Finais

O material didático não deve ser esquecido, devemos lembrar que o uso do software é um

auxílio no ensino-aprendizagem da matemática. O conteúdo deve vir antes da utilização do

aplicativo, pois, não será suﬁciente somente uma abordagem computacional, devemos evitar o

uso dos softwares somente para resolução de problemas, temos que questionar os resultados e

comparar com os obtidos de forma manual.

É essencial conhecer a teoria por trás dos resultados, a ferramenta deve trazer consigo mo-

tivação e interesse para voos mais longos, partindo do ponto de vista que é possível resolver

questões extremamente grandes e complexas.

A utilização da informática no ensino-aprendizagem da matemática, sendo feita da forma

correta, pode contribuir para o melhor desempenho do aluno, despertando sua habilidade de

pensar matematicamente, de forma a ver os conceitos matemáticos ligados ao mundo real.

No apêndice "A"segue o código fonte do aplicativo, deixando disponível para outras pessoas

interessadas em programação para criar outros projetos usando parte ou o todo desse código.

O próximo passo será utilizar o software nas escolas e aferir sua eﬁciência no que diz res-

peito a ﬁxação do conteúdo e veriﬁcar se o mesmo desempenha um papel motivador nas aulas,

tanto para os alunos quanto para os professores.

69

Referências Bibliográﬁcas

ALTHOEN, S. and MCLAUGHLIN, R. (1987). GaussJordan Reduction: A Brief History. The

American Mathematical Monthly, 2 edition.

BASHMAKOVA, I. and SMIRNOVA, G. (2000). The beginnings and evolution of algebra.

New York: Cambridge University Press, 23 edition.

BEMFICA, A. (2015). Um pouco de história. http://professorandrios.blogspot.com.br/2012/03/

um-pouco-de-historia-gauss-e-o-seu.html.

DANTE, L. R. (2014). Contexto e Aplicações. Editora Ática, 2 edition.

DIEUDONNÉ, J. (1981). History of Functional Analysis. NorthHolland Mathematics Studies,

1 edition.

IEZZI, G., DOLCE, O., DEGENSZAJN, D., PÉRIGO, R., and ALMEIDA, N. D. (2010). Ma-

temática - Ciência e Aplicações. Editora Saraiva, 6 edition.

KOLMOGOROV, A. N. and YUSHKEVICH, A. P. (1981). Mathematics of the 19th Century.

Biekhäuser Verlag, 1 edition.

MIRANDA, D. D.

(2015).

Transformação

para

números

fracionários.

http://www.mundoeducacao.com/matematica/

transformacao-para-numeros-

fracionarios.htm.

MUIR, T. (1890). The theory of determinants in the historical order of development. London:

McMillan and Co. Ltd., 1 edition.

OLIVEIRA, G. A. D.

(2015).

Matriz inversa.

http://www.mundoeducacao.com/

matematica/matriz-inversa.htm.

UFF (2015). Gauss, o príncipe da matemática.

http://www.uff.br/sintoniamatematica/

curiosidadesmatematicas/curiosidadesmatematicas-html/audio-gauss-br.html.

70

USP (2015). Carl fridrich gauss (1777 - 1855). http://ecalculo.if.usp.br/historia/gauss.htm.

71

Apêndice A

Programa em Delphi

program Matriz;

uses

Forms,
Matriz_Principal in ’Matriz_Principal.pas’ {F_Principal},
U_Sobre in ’U_Sobre.pas’ {F_Sobre},
U_Trn_Determinante in ’U_Trn_Determinante.pas’ {F_Trn_Determinante},
U_Inversa in ’U_Inversa.pas’ {F_Inversa},
Funcoes in ’Funcoes.pas’,
U_ELineares in ’U_ELineares.pas’ {F_ELineares},
U_Determinante in ’U_Determinante.pas’ {F_Determinante},
CustomPreview in ’CustomPreview.pas’;

{$R *.res}
begin

F_Sobre:=TF_Sobre.Create(Application);
F_Sobre.BorderStyle:= bsNone;
F_Sobre.Show;
F_Sobre.Update;
Application.Title := ’Matriz’;
Application.CreateForm(TF_Principal, F_Principal);
Application.Initialize;
F_Sobre.Hide;
F_Sobre.Release;
Application.Run;

end.

====================================================================

unit Matriz_Principal;

interface

uses

Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms, Dialogs, Menus, ComCtrls, ToolWin, ImgList, ExtCtrls,
ShellAPI, funcoes;

type

TF_Principal = class(TForm)

MainMenu1: TMainMenu;
ToolBar1: TToolBar;
Arquivo1: TMenuItem;
Fecha1: TMenuItem;
Matrizes1: TMenuItem;
Determinante: TMenuItem;
ImageList_On: TImageList;
ToolButton1: TToolButton;
ToolButton2: TToolButton;
ToolButton3: TToolButton;
ELineares: TMenuItem;
ToolButton4: TToolButton;
Sobre1: TMenuItem;

72

73

Panel1: TPanel;
StatusBar1: TStatusBar;
Inversa: TToolButton;
Inversa1: TMenuItem;
ToolButton7: TToolButton;
ToolButton8: TToolButton;
TreinamentoGauss: TMenuItem;
AjudadoMatriz1: TMenuItem;
N1: TMenuItem;
SobredoMatriz1: TMenuItem;
procedure DeterminanteClick(Sender: TObject);
procedure ELinearesClick(Sender: TObject);
procedure Fecha1Click(Sender: TObject);
procedure FormCreate(Sender: TObject);
procedure InversaClick(Sender: TObject);
procedure TreinamentoGaussClick(Sender: TObject);
procedure ChamaHelp(var Msg: TMsg; var Handled: Boolean);
procedure SobredoMatriz1Click(Sender: TObject);
procedure AjudadoMatriz1Click(Sender: TObject);

private

{ Private declarations }

public

{ Public declarations }

end;

var

F_Principal: TF_Principal;

implementation

uses U_Sobre, U_Determinante, U_ELineares, U_Inversa,

U_Trn_Determinante;

{$R *.dfm}

procedure TF_Principal.DeterminanteClick(Sender: TObject);
begin

F_Determinante:= TF_Determinante.Create(Application);
F_Determinante.ShowModal;
F_Determinante.Release;
F_Determinante:=Nil;

end;

procedure TF_Principal.ELinearesClick(Sender: TObject);
begin

F_ELineares:= TF_ELineares.Create(Application);
F_ELineares.ShowModal;
F_ELineares.Release;
F_ELineares:=Nil;

end;

procedure TF_Principal.Fecha1Click(Sender: TObject);
begin

Close;

end;

procedure TF_Principal.FormCreate(Sender: TObject);
begin

Application.HintColor:= clAqua;
Application.HintHidePause:= 250;
Application.HintHidePause:= 10000;
Application.OnMessage := ChamaHelp;

end;

procedure TF_Principal.InversaClick(Sender: TObject);
begin

F_Inversa:= TF_Inversa.Create(Application);
F_Inversa.ShowModal;
F_Inversa.Release;
F_Inversa:=Nil;

end;

procedure TF_Principal.TreinamentoGaussClick(Sender: TObject);

74

begin

F_Trn_Determinante:= TF_Trn_Determinante.Create(Application);
F_Trn_Determinante.ShowModal;
F_Trn_Determinante.Release;
F_Trn_Determinante:=Nil;

end;

procedure TF_Principal.SobredoMatriz1Click(Sender: TObject);
begin

F_Sobre:= TF_Sobre.Create(Application);
F_Sobre.ShowModal;
F_Sobre.Release;
F_Sobre:=Nil;

end;

procedure TF_Principal.ChamaHelp(var Msg: TMsg; var Handled: Boolean);
begin

if (Screen.ActiveForm.ClassName = ’TMessageForm’) = false then

if Msg.message = WM_KEYDOWN then

if Msg.wParam = VK_F1 then

if ProcessoExiste(’hh.exe’) then

ShowMessage(’Ajuda está aberta.’)

else

ShellExecute(0,nil,’Ajuda.CHM’ ,nil, nil, SW_SHOWMAXIMIZED);

end;

procedure TF_Principal.AjudadoMatriz1Click(Sender: TObject);
begin

if ProcessoExiste(’hh.exe’) then

ShowMessage(’A Ajuda já está aberta.’)

else

ShellExecute(0,nil,’Ajuda.CHM’ ,nil, nil, SW_SHOWMAXIMIZED);

end;

end.

====================================================================

unit U_Determinante;

interface

uses

Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms, Dialogs, StdCtrls, Grids, ExtCtrls, Funcoes, Buttons,
RpDefine, RpBase, RpSystem, rpDevice, CustomPreview;

type

TF_Determinante = class(TForm)

Grid1: TStringGrid;
Edit1: TEdit;
Bt_Matriz: TButton;
Label1: TLabel;
Bt_Laplace: TButton;
Painel: TPanel;
SpeedButton1: TSpeedButton;
Bt_Gauss: TButton;
SB: TScrollBox;
CheckBox1: TCheckBox;
Button2: TButton;
RvSystem1: TRvSystem;
Bt_cancel: TButton;
procedure Bt_MatrizClick(Sender: TObject);
procedure Bt_LaplaceClick(Sender: TObject);
procedure Edit1KeyPress(Sender: TObject; var Key: Char);
procedure Limpa;
procedure FormCreate(Sender: TObject);
procedure SpeedButton1Click(Sender: TObject);
procedure Bt_GaussClick(Sender: TObject);
procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

75

procedure CheckBox1Click(Sender: TObject);
procedure Button2Click(Sender: TObject);
procedure RvSystem1Print(Sender: TObject);
procedure RvSystem1PrintHeader(Sender: TObject);
procedure Edit1Exit(Sender: TObject);
procedure RvSystem1OverridePreview(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideSetup(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideStatus(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure Edit2KeyPress(Sender: TObject; var Key: Char);
procedure Bt_cancelClick(Sender: TObject);

private

{ Private declarations }

public

{ Public declarations }

end;

var

F_Determinante: TF_Determinante;

implementation

{$R *.dfm}

procedure TF_Determinante.FormCreate(Sender: TObject);
begin

Grid1.OnDrawCell:= TMenuActions.SGDrawCell;
Grid1.OnKeyPress:= TMenuActions.GridKeyPress;
MSeq:= false;
EqLinear:= false;

end;

procedure TF_Determinante.Limpa;
var

i,j : integer;

begin

for i:= 0 to Grid1.ColCount -1 do

for j:= 0 to Grid1.ColCount -1 do

Grid1.Cells[i,j]:=’’;

SetLength(M,0,0);
Grid1.RowCount:= 1;
Grid1.ColCount:= 1;

end;

procedure TF_Determinante.Bt_MatrizClick(Sender: TObject);
var

x : integer;

begin

if Edit1.text = ’’ then Exit;
Limpa;
x:= StrToInt(Edit1.text);
Grid1.RowCount:= x;
Grid1.ColCount:= x;
Grid1.SetFocus;

end;

procedure TF_Determinante.Bt_LaplaceClick(Sender: TObject);
var

d,i,j : integer;

begin

if GridOk(Grid1) = false then exit;
Cancelar:= false;
Bt_cancel.Visible:= true;
SB.DestroyComponents;
d:= StrToInt(Edit1.text);
SetLength(M,d,d);
SetLength(SG,0);
Col_Tp:= d;
Tops:= 5;
CriaGridTex(SB,’Método de Laplace’);

76

{Matriz de dimensão 1}
if Grid1.ColCount = 1 then
begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Determinante = 0’);
Painel.Caption:= Grid1.Cells[0,0];
Exit;

end;
{Matriz recebe elementos do grid}
for i := 0 to d-1 do

for j := 0 to d-1 do

M[i,j]:= StrToFloat(Grid1.Cells[j,i]);

{Escreve matriz inicial}
CriaGridBox(SB,M);
{Verifica linha/coluna zerada}
if LCZerada(M) then
begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Determinante = 0’);
Painel.Caption:= ’0’;
exit;

end;
{Calcula determinante e escreve o resultado}
Painel.Caption:=FloatToStr(Determinante(SB,M));
CriaGridTex(SB,’Determinante = ’+ Painel.Caption);
{Posiciona na última linha do SB}
SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);
if Cancelar then
begin

SB.DestroyComponents;
Painel.Caption:=’’;

end;
Bt_cancel.Visible:= false;

end;

procedure TF_Determinante.Edit1KeyPress(Sender: TObject;

var Key: Char);

begin

if not (Ord(key) in [8,13,48..57]) then Key:= #0;

end;

procedure TF_Determinante.SpeedButton1Click(Sender: TObject);
var

i,x,iNum: Integer;
List_A: TStringList;

begin

List_A:= TStringList.Create;
x:= StrToInt(Edit1.text);
x:= x*x -1;
for i:=0 to x do
begin

Randomize;
iNum := Random(11);
List_A.Add(IntToStr(iNum));

end;
{Verifica a quantidade de elementos}
if List_A.Count <>
begin

Grid1.RowCount*Grid1.ColCount then

ShowMessage(’A Quantidade de elementos ’+IntToStr(List_A.Count)+
’ não preenche todas as células da Matriz!’);
Exit;

end;
{Mostra valores da lista no grid}
MostraListGrid(List_A,Grid1);

end;

procedure TF_Determinante.Bt_GaussClick(Sender: TObject);
Var

d,i,j: Integer;
Aux: real;
Mtemp: Mtz;

begin

if GridOk(Grid1) = false then exit;

77

Cancelar:= false;
Bt_cancel.Visible:= true;
SB.DestroyComponents;
d:= StrToInt(Edit1.text);
SetLength(M,d,d+1);
SetLength(SG,0);
Col_Tp:= d;
Tops:= 5;
CriaGridTex(SB,’Método de Gauss’);
{Matriz de dimensão 1}
if Grid1.ColCount = 1 then
begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Determinante = 0’);
Painel.Caption:= Grid1.Cells[0,0];
Exit;

end;
{Matriz recebe elementos do grid}
for i := 0 to d-1 do

for j := 0 to d-1 do

M[i,j]:= StrToFloat(Grid1.Cells[j,i]);

{Escreve matriz inicial}
CriaGridBox(SB,M);
{Verifica linha/coluna zerada}
if LCZerada(M) then
begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Determinante = 0’);
Painel.Caption:= ’0’;
exit;

end;
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,M);
{Verifica cancelamento}
if Cancelar then
begin

Bt_cancel.Visible:= false;
SB.DestroyComponents;
Painel.Caption:=’’;
Exit;

end;
{Calcula Variáveis}
SetLength(MTemp,1,d);
Aux:=1;
for i := 0 to d-1 do

for j := 0 to d-1 do

if i = j then
begin

Aux:= Aux*M[i,j];
Mtemp[0,j]:= M[i,j];

end;

CriaGridTex(SB,’Diagonal Final =’);
CriaGridBox(SB,MTemp);
CriaGridTex(SB,’Determinante = ’+ Fracao(Aux));
Painel.Caption:= Fracao(Aux);
{Posiciona na última linha do SB}
SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);
Bt_cancel.Visible:= false;

end;

procedure TF_Determinante.FormMouseWheelDown(Sender: TObject;

Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do

begin

Position := Position + Increment;

end;

end;

procedure TF_Determinante.FormMouseWheelUp(Sender: TObject;

Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do

78

begin

Position := Position - Increment;

end;

end;

procedure TF_Determinante.CheckBox1Click(Sender: TObject);
begin

if CheckBox1.Checked then Mseq:= true else Mseq:= false;

end;

procedure TF_Determinante.Button2Click(Sender: TObject);
begin

if SB.ComponentCount = 0 then Exit;
with RVSystem1.SystemPrinter do
begin

MarginRight:= 0.2;
MarginLeft:= 0.2;
MarginTop:= 1;
MarginBottom:= 1;
rpDev.Copies:= 1;
Copies:= rpDev.Copies;
rpDev.Orientation:= poPortrait;
Orientation:= rpDev.Orientation;
RVSystem1.SystemPreview.FormState:= wsMaximized;
RVSystem1.SystemSetups:= RVSystem1.SystemSetups - [ssAllowSetup];
rpDev.SelectPaper(’A4’,false);
RVSystem1.Execute;

end;

end;

procedure TF_Determinante.RvSystem1Print(Sender: TObject);
Var

x,i,j: integer;
TSG : TstringGrid;

begin

with RVSystem1.BaseReport do
begin

for x:= 0 to SB.ComponentCount-1
begin

do

TSG:= TStringGrid(SB.Components[x]);
for i:= 0 to TSG.rowCount - 1 do
begin

for j:= 0 to TSG.colCount - 1 do
begin

if TSG.colCount = 1 then

PrintLeft(TSG.Cells[j,i],MarginLeft)

else

PrintCenter(TSG.Cells[j,i],MarginLeft+0.2+(j/2));

end;
NewLine;
NewLine;
if LinesLeft<1 then NewPage;

end;

end;

end;

end;

procedure TF_Determinante.RvSystem1PrintHeader(Sender: TObject);
begin

with RVSystem1.BaseReport do
begin

SetFont(’Verdana’,12);
Bold := True;
PrintCenter(’Cálculo de Determinante’,PageWidth/2);
NewLine;
Canvas.Pen.Width := 2;
Canvas.Pen.Color := clBlack;
MoveTo(MarginLeft,YPos);
LineTo(PageWidth-MarginRight,YPos);
NewLine;
SetFont(’Verdana’,8);
Bold := False;

end;

79

end;

procedure TF_Determinante.Edit1Exit(Sender: TObject);
begin

Bt_MatrizClick(Bt_Matriz);

end;

procedure TF_Determinante.RvSystem1OverridePreview(ReportSystem:

TRvSystem; OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecutePreviewForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Determinante.RvSystem1OverrideSetup(ReportSystem:

TRvSystem; OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteSetupForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Determinante.RvSystem1OverrideStatus(ReportSystem:

TRvSystem; OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteStatusForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Determinante.Edit2KeyPress(Sender: TObject;

var Key: Char);

begin

if not (Ord(key) in [3,8,13,22,44,45,48..57,59]) then Key:= #0;

end;

procedure TF_Determinante.Bt_cancelClick(Sender: TObject);
begin

Cancelar:= true;
Bt_cancel.Visible:= false;

end;

end.

====================================================================

unit U_ELineares;

interface

uses

Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms, Dialogs, StdCtrls, Grids, ExtCtrls, Funcoes, Menus, Printers,
Buttons , ShellAPI, UPrintGrid, RpDefine, RpBase, RpSystem, rpDevice,
CustomPreview;

type

TF_ELineares = class(TForm)

Grid1: TStringGrid;
Edit1: TEdit;
Bt_Matriz: TButton;
Label1: TLabel;
Bt_Gauss: TButton;
SB: TScrollBox;
SpeedButton1: TSpeedButton;
CheckBox1: TCheckBox;
Button2: TButton;
RvSystem1: TRvSystem;
Bt_cancel: TButton;
procedure Bt_MatrizClick(Sender: TObject);
procedure Edit1KeyPress(Sender: TObject; var Key: Char);
procedure Grid1KeyPress(Sender: TObject; var Key: Char);
procedure LimpaGrid;
procedure Bt_GaussClick(Sender: TObject);
procedure Edit2KeyPress(Sender: TObject; var Key: Char);
procedure FormCreate(Sender: TObject);
procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

80

procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);
procedure SpeedButton1Click(Sender: TObject);
procedure CheckBox1Click(Sender: TObject);
procedure Button2Click(Sender: TObject);
procedure RvSystem1Print(Sender: TObject);
procedure RvSystem1PrintHeader(Sender: TObject);
procedure Edit1Exit(Sender: TObject);
procedure RvSystem1OverridePreview(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideSetup(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideStatus(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);

procedure Bt_cancelClick(Sender: TObject);

private

{ Private declarations }

public

{ Public declarations }

end;

var

F_ELineares: TF_ELineares;

implementation

{$R *.dfm}

procedure TF_ELineares.LimpaGrid;
var

i,j : integer;

begin

for i:= 0 to Grid1.RowCount -1 do
for j:= 0 to Grid1.ColCount -1 do

Grid1.Cells[i,j]:=’’;

SetLength(M,0,0);
Grid1.RowCount:= 1;
Grid1.ColCount:= 1;

end;

procedure TF_ELineares.Bt_MatrizClick(Sender: TObject);
var

x : integer;

begin

if Edit1.text = ’’ then Exit;
LimpaGrid;
x:= StrToInt(Edit1.text);
Grid1.RowCount:= x;
Grid1.ColCount:= x+1;
Grid1.SetFocus;
Col_Tp:= x+1;

{linhas do grid}

{colunas do grid}

end;

procedure TF_ELineares.Bt_GaussClick(Sender: TObject);
var

d,i,j,x :integer;
Resp: Mtz1;

begin

if GridOk(Grid1) = false then exit;
Cancelar:= false;
Bt_cancel.Visible:= true;
d:= StrToInt(Edit1.text);
SetLength(M,d,d+1);
//Col_Tp:= d+1;
{Preenche os valores do grid na Matriz}
for i:= 0 to d-1 do
for j:= 0 to d do

M[i,j]:= StrToFloat(Grid1.Cells[j,i]);

{Limpa escalonamento anterior}
SB.DestroyComponents;
SetLength(SG,0);
Tops:=5;

81

CriaGridBox(SB,M);

{Verifica linha coluna zerada}

if LCZerada(M) then
begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Sistema impossível - Não tem Solução!’);
ShowMessage(’Sistema impossível - Não tem Solução!’);
exit;

end;
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,M);
{Verifica cancelamento}
if Cancelar then
begin

SB.DestroyComponents;
Exit;

end;
{Verifica se existe solução}
for i := 0 to d-1 do

for j := 0 to d-1 do

if (i = j) and (M[i,j] = 0) then
begin

Bt_cancel.Visible:= false;
if M[j,d] = 0 then
begin

CriaGridTex(SB,

’Sistema possível e indeterminado - Infinitas Soluções!’);

ShowMessage(

’Sistema possível e indeterminado - Infinitas Soluções!’);

end
else
begin

CriaGridTex(SB,’Sistema impossível - Não tem Solução!’);
ShowMessage(’Sistema impossível - Não tem Solução!’);

end;
Exit;

end;

{Calcula as Variáveis}
Resp:= Variaveis(M,d);
{Mostra Respostas}
x:=1;
for i:= d-1 downto 0 do
begin

CriaGridTex(SB,’X[’+IntToStr(x)+’] = ’+Fracao(Resp[i]));
Inc(x);

end;
SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);
Bt_cancel.Visible:= false;

end;

procedure TF_ELineares.Edit1KeyPress(Sender: TObject; var Key: Char);
begin

if not (Ord(key) in [8,13,48..57]) then Key:= #0;

end;

procedure TF_ELineares.Grid1KeyPress(Sender: TObject; var Key: Char);
begin

if not (Ord(key) in [8,13,44,45,48..57]) then Key:= #0;

end;

procedure TF_ELineares.Edit2KeyPress(Sender: TObject; var Key: Char);
begin

if not (Ord(key) in [3,8,13,22,44,45,48..57,59]) then Key:= #0;

end;

procedure TF_ELineares.FormCreate(Sender: TObject);
begin

Grid1.OnDrawCell:= TMenuActions.SGDrawCell;
Grid1.OnKeyPress:= TMenuActions.GridKeyPress;
MSeq:= false;
EqLinear:= true;

end;

82

procedure TF_ELineares.FormMouseWheelDown(Sender: TObject;

Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do

begin

Position := Position + Increment;

end;

end;

procedure TF_ELineares.FormMouseWheelUp(Sender: TObject;

Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do
begin

Position := Position - Increment;

end;

end;

procedure TF_ELineares.SpeedButton1Click(Sender: TObject);
var

i,x,iNum: Integer;
List_A: TStringList;

begin

List_A:= TStringList.Create;
x:= StrToInt(Edit1.text);
x:= x*(x+1) -1;
for i:=0 to x do
begin

Randomize;
iNum := Random(11);
List_A.Add(IntToStr(iNum));

end;
{Verifica a quantidade de elementos}
if List_A.Count <>
begin

Grid1.RowCount*Grid1.ColCount then

ShowMessage(’A Quantidade de elementos ’+IntToStr(List_A.Count)

+’ não preenche todas as células da Matriz!’);

Exit;

end;
{Mostra valores da lista no grid}
MostraListGrid(List_A,Grid1);

end;

procedure TF_ELineares.CheckBox1Click(Sender: TObject);
begin

if CheckBox1.Checked then Mseq:= true else Mseq:= false;

end;

procedure TF_ELineares.Button2Click(Sender: TObject);
begin

if SB.ComponentCount = 0 then Exit;
with RVSystem1.SystemPrinter do
begin

MarginRight:= 0.2;
MarginLeft:= 0.2;
MarginTop:= 1;
MarginBottom:= 1;
rpDev.Copies:= 1;
Copies:= rpDev.Copies;
rpDev.Orientation:= poPortrait;
Orientation:= rpDev.Orientation;
RVSystem1.SystemPreview.FormState:= wsMaximized;
RVSystem1.SystemSetups:= RVSystem1.SystemSetups - [ssAllowSetup];
rpDev.SelectPaper(’A4’,false);
RVSystem1.Execute;

end;

end;

procedure TF_ELineares.RvSystem1Print(Sender: TObject);
Var

x,i,j: integer;
TSG : TstringGrid;

begin

83

with RVSystem1.BaseReport do
begin

for x:= 0 to SB.ComponentCount-1
begin

do

TSG:= TStringGrid(SB.Components[x]);
for i:= 0 to TSG.rowCount - 1 do
begin

for j:= 0 to TSG.colCount - 1 do
begin

if TSG.colCount = 1 then

PrintLeft(TSG.Cells[j,i],MarginLeft)

else

PrintCenter(TSG.Cells[j,i],MarginLeft+0.2+(j/2));

end;
NewLine;
NewLine;
if LinesLeft<1 then NewPage;

end;

end;

end;

end;

procedure TF_ELineares.RvSystem1PrintHeader(Sender: TObject);
begin

with RVSystem1.BaseReport do
begin

SetFont(’Verdana’,12);
Bold := True;
PrintCenter(’Cálculo de Equações Lineares’,PageWidth/2);
NewLine;
Canvas.Pen.Width := 2;
Canvas.Pen.Color := clBlack;
MoveTo(MarginLeft,YPos);
LineTo(PageWidth-MarginRight,YPos);
NewLine;
SetFont(’Verdana’,8);
Bold := False;

end;

end;

procedure TF_ELineares.Edit1Exit(Sender: TObject);
begin

Bt_MatrizClick(Bt_Matriz);

end;

procedure TF_ELineares.RvSystem1OverridePreview(ReportSystem:

TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecutePreviewForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_ELineares.RvSystem1OverrideSetup(ReportSystem:

TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteSetupForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_ELineares.RvSystem1OverrideStatus(ReportSystem:

TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteStatusForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_ELineares.Bt_cancelClick(Sender: TObject);
begin

Cancelar:= true;
Bt_cancel.Visible:= false;

end;

end.

====================================================================

84

unit U_Inversa;

interface

uses

Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms, Dialogs, StdCtrls, Grids, ExtCtrls, Funcoes, Buttons, RpDefine,
RpBase, RpSystem, rpDevice, CustomPreview;

type

TF_Inversa = class(TForm)

Edit1: TEdit;
Bt_Matriz: TButton;
Label1: TLabel;
Grid1: TStringGrid;
Bt_Gauss: TButton;
SB: TScrollBox;
SpeedButton1: TSpeedButton;
CheckBox1: TCheckBox;
Button2: TButton;
RvSystem1: TRvSystem;
Bt_cancel: TButton;
procedure Bt_MatrizClick(Sender: TObject);
procedure Edit1KeyPress(Sender: TObject; var Key: Char);
procedure Grid1KeyPress(Sender: TObject; var Key: Char);
procedure Grid1KeyDown(Sender: TObject; var Key: Word;

Shift: TShiftState);

procedure Edit1KeyDown(Sender: TObject; var Key: Word;

Shift: TShiftState);

procedure LimpaGrid;
procedure Edit2KeyPress(Sender: TObject; var Key: Char);
procedure Bt_GaussClick(Sender: TObject);
procedure FormCreate(Sender: TObject);
procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);
procedure SpeedButton1Click(Sender: TObject);
procedure SBMouseWheelDown(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

procedure SBMouseWheelUp(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);
procedure CheckBox1Click(Sender: TObject);
procedure Button2Click(Sender: TObject);
procedure RvSystem1Print(Sender: TObject);
procedure RvSystem1PrintHeader(Sender: TObject);
procedure Edit1Exit(Sender: TObject);
procedure RvSystem1OverridePreview(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideSetup(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideStatus(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);

procedure Bt_cancelClick(Sender: TObject);

private

{ Private declarations }

public

{ Public declarations }

end;

var

F_Inversa: TF_Inversa;

implementation

{$R *.dfm}

procedure TF_Inversa.LimpaGrid;
var

i,j : integer;

begin

for i:= 0 to Grid1.RowCount -1 do

85

for j:= 0 to Grid1.ColCount -1 do
begin

Grid1.Cells[i,j]:=’’;

end;
SetLength(M,0,0);
Grid1.RowCount:= 1;
Grid1.ColCount:= 1;

end;

procedure TF_Inversa.Bt_MatrizClick(Sender: TObject);
var

x : integer;

begin

if Edit1.text = ’’ then Exit;
LimpaGrid;
x:= StrToInt(Edit1.text);
Grid1.RowCount:= x;
Grid1.ColCount:= x;
Grid1.SetFocus;

{linhas do grid}
{colunas do grid}

end;

procedure TF_Inversa.Edit1KeyPress(Sender: TObject; var Key: Char);
begin

if not (Ord(key) in [8,13,48..57]) then Key:= #0;

end;

procedure TF_Inversa.Grid1KeyPress(Sender: TObject; var Key: Char);
begin

if not (Ord(key) in [8,13,44,45,48..57]) then Key:= #0;

end;

procedure TF_Inversa.Grid1KeyDown(Sender: TObject; var Key: Word;

Shift: TShiftState);

begin

if Key = 13 then Key:=9;

end;

procedure TF_Inversa.Edit1KeyDown(Sender: TObject; var Key: Word;

Shift: TShiftState);

begin

if Key = 13 then Perform(Wm_NextDlgCtl,0,0);

end;

procedure TF_Inversa.Edit2KeyPress(Sender: TObject; var Key: Char);
begin

if not (Ord(key) in [3,8,13,22,44,45,48..57,59]) then Key:= #0;
{3 CTR+C e 22 CTR+V}

end;

procedure TF_Inversa.Bt_GaussClick(Sender: TObject);
var

i,j,k,d : Integer;
Resp: Mtz1;
MtzInv, Mtemp: Mtz;
W: real;

begin

if GridOk(Grid1) = false then exit;
{Limpa escalonamento anterior}
Cancelar:= false;
Bt_cancel.Visible:= true;
d:= StrToInt(Edit1.text);
{Cria Matriz resposta e temporaria}
SetLength(MtzInv,d,d);
SetLength(Mtemp,d,d+1);
{Preenche os valores do grid nas Matrizes}
for i:= 0 to d-1 do

for j:= 0 to d-1 do
begin

MtzInv[i,j]:= StrToFloat(Grid1.Cells[j,i]);
Mtemp[i,j]:= StrToFloat(Grid1.Cells[j,i]);

end;

{Verifica o determinante da matriz temporaria linha/coluna zerada}
if LCZerada(Mtemp) then

begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Determinante = 0 - Matriz não Inversível.’);
ShowMessage(’Determinante = 0 - Matriz não Inversível.’);
exit;

86

end;
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,Mtemp);
{Verifica cancelamento}
if Cancelar then
begin

SB.DestroyComponents;
Exit;

end;
{Calcula determinante}
W:=1;
for i := 0 to d-1 do

for j := 0 to d-1 do

if i = j then

W:= W*Mtemp[i,j];

if W = 0 then
begin

Bt_cancel.Visible:= false;
CriaGridTex(SB,’Determinante = 0 - Matriz não Inversível.’);
ShowMessage(’Determinante = 0 - Matriz não Inversível.’);
exit;

end;
{Escreve matriz inicial}
SB.DestroyComponents;
SetLength(SG,0);
Tops:=5;
Col_Tp:= d;
CriaGridBox(SB,MtzInv);
{Calcula Matriz Inversa}
for k:= 1 to d do
begin

{Cria Matriz}
SetLength(M,d,d+1);
Col_Tp:= d+1;
for i := 0 to d-1 do
for j:= 0 to d do
begin

if j = d
begin

then

if i = k-1 then M[i,j]:= 1
else M[i,j]:= 0;

end
else M[i,j]:= StrToFloat(Grid1.Cells[i,j]);

end;
if Mseq then CriaGridTex(SB,IntToStr(k)+’a Matriz Transposta’);
if Mseq then CriaGridBox(SB,M);
{Escalona a Matriz}
EscalonaMatriz(SB,M);
{Verifica cancelamento}
if Cancelar then
begin

SB.DestroyComponents;
Exit;

end;
{Calcula as Variáveis}
Resp:= Variaveis(M,d);
{Inclui dados Matriz resposta}
j:=0;
for i := d-1 downto 0 do
begin

MtzInv[k-1,j]:=Resp[i];
if Mseq then CriaGridTex(SB,’X[’+IntToStr(j+1)+’] = ’

+Fracao(Resp[i]));

Inc(j);

end;

end;
{Mostra a Matriz resposta}
Col_Tp:= d;

87

CriaGridBox(SB,MtzInv);
SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);
Bt_cancel.Visible:= false;

end;

procedure TF_Inversa.FormCreate(Sender: TObject);
begin

Grid1.OnDrawCell:= TMenuActions.SGDrawCell;
Grid1.OnKeyPress:= TMenuActions.GridKeyPress;
MSeq:= false;
EqLinear:= false;

end;

procedure TF_Inversa.FormMouseWheelDown(Sender: TObject;

Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do
begin

Position := Position + Increment;

end;

end;

procedure TF_Inversa.FormMouseWheelUp(Sender: TObject;

Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do
begin

Position := Position - Increment;

end;

end;

procedure TF_Inversa.SpeedButton1Click(Sender: TObject);
var

i,x,iNum: Integer;
List_A: TStringList;

begin

List_A:= TStringList.Create;
x:= StrToInt(Edit1.text);
x:= x*x -1;
for i:=0 to x do
begin

Randomize;
iNum := Random(11);
List_A.Add(IntToStr(iNum));

end;
{Verifica a quantidade de elementos}
if List_A.Count <>
begin

Grid1.RowCount*Grid1.ColCount then

ShowMessage(’A Quantidade de elementos ’+IntToStr(List_A.Count)

+’ não preenche todas as células da Matriz!’);

Exit;

end;
{Mostra valores da lista no grid}
MostraListGrid(List_A,Grid1);

end;

procedure TF_Inversa.SBMouseWheelDown(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do

begin

Position := Position + Increment;

end;

end;

procedure TF_Inversa.SBMouseWheelUp(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do

begin

Position := Position - Increment;

end;

end;

88

procedure TF_Inversa.CheckBox1Click(Sender: TObject);
begin

if CheckBox1.Checked then Mseq:= true else Mseq:= false;

end;

procedure TF_Inversa.Button2Click(Sender: TObject);
begin

if SB.ComponentCount = 0 then Exit;
with RVSystem1.SystemPrinter do
begin

MarginRight:= 0.2;
MarginLeft:= 0.2;
MarginTop:= 1;
MarginBottom:= 1;
rpDev.Copies:= 1;
Copies:= rpDev.Copies;
rpDev.Orientation:= poPortrait;
Orientation:= rpDev.Orientation;
RVSystem1.SystemPreview.FormState:= wsMaximized;
RVSystem1.SystemSetups:= RVSystem1.SystemSetups - [ssAllowSetup];
rpDev.SelectPaper(’A4’,false);
RVSystem1.Execute;

end;

end;

procedure TF_Inversa.RvSystem1Print(Sender: TObject);
Var

x,i,j: integer;
TSG : TstringGrid;

begin

with RVSystem1.BaseReport do
begin

for x:= 0 to SB.ComponentCount-1
begin

do

TSG:= TStringGrid(SB.Components[x]);
for i:= 0 to TSG.rowCount - 1 do
begin

for j:= 0 to TSG.colCount - 1 do
begin

if TSG.colCount = 1 then

PrintLeft(TSG.Cells[j,i],MarginLeft)

else

PrintCenter(TSG.Cells[j,i],MarginLeft+0.2+(j/2));

end;
NewLine;
NewLine;
if LinesLeft<1 then NewPage;

end;

end;

end;

end;

procedure TF_Inversa.RvSystem1PrintHeader(Sender: TObject);
begin

with RVSystem1.BaseReport do
begin

SetFont(’Verdana’,12);
Bold := True;
PrintCenter(’Cálculo de Matriz Inversa’,PageWidth/2);
NewLine;
Canvas.Pen.Width := 2;
Canvas.Pen.Color := clBlack;
MoveTo(MarginLeft,YPos);
LineTo(PageWidth-MarginRight,YPos);
NewLine;
SetFont(’Verdana’,8);
Bold := False;

end;

end;

procedure TF_Inversa.Edit1Exit(Sender: TObject);
begin

89

Bt_MatrizClick(Bt_Matriz);

end;

procedure TF_Inversa.RvSystem1OverridePreview(ReportSystem: TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecutePreviewForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Inversa.RvSystem1OverrideSetup(ReportSystem: TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteSetupForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Inversa.RvSystem1OverrideStatus(ReportSystem: TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteStatusForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Inversa.Bt_cancelClick(Sender: TObject);
begin

Cancelar:= true;
Bt_cancel.Visible:= false;

end;

end.

====================================================================

unit U_Trn_Determinante;

interface

uses

Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms, Dialogs, StdCtrls, Grids, ExtCtrls, Funcoes, Buttons,
ComCtrls, RpDefine,

RpBase, RpSystem, rpDevice, CustomPreview;

type

TF_Trn_Determinante = class(TForm)

Grid1: TStringGrid;
Edit1: TEdit;
Bt_Matriz: TButton;
Label1: TLabel;
Painel: TPanel;
SpeedButton1: TSpeedButton;
Bt_Gauss: TButton;
SB: TScrollBox;
PageControl1: TPageControl;
TabSheet1: TTabSheet;
TabSheet2: TTabSheet;
GroupBox1: TGroupBox;
CBox1: TComboBox;
CBox2: TComboBox;
CBox3: TComboBox;
Bt_Soma: TButton;
GroupBox2: TGroupBox;
CBox4: TComboBox;
CBox5: TComboBox;
Bt_Mult: TButton;
Edit3: TEdit;
Panel1: TPanel;
GroupBox3: TGroupBox;
Label4: TLabel;
Pivot1: TComboBox;
Label5: TLabel;
Pivot2: TComboBox;
Li: TComboBox;
Label2: TLabel;
Li2: TComboBox;
Label3: TLabel;

90

Lf: TComboBox;
Button1: TButton;
Label6: TLabel;
Button2: TButton;
RvSystem1: TRvSystem;
Label7: TLabel;
Label8: TLabel;
Label9: TLabel;
Bt_cancel: TButton;
procedure Bt_MatrizClick(Sender: TObject);
procedure Edit1KeyPress(Sender: TObject; var Key: Char);
procedure Grid1KeyPress(Sender: TObject; var Key: Char);
procedure LimpaGrid;
procedure Edit2KeyPress(Sender: TObject; var Key: Char);
procedure FormCreate(Sender: TObject);
procedure SpeedButton1Click(Sender: TObject);
procedure Bt_GaussClick(Sender: TObject);
procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;

MousePos: TPoint; var Handled: Boolean);

procedure Bt_SomaClick(Sender: TObject);
procedure Bt_MultClick(Sender: TObject);
procedure Edit3KeyPress(Sender: TObject; var Key: Char);
procedure Button1Click(Sender: TObject);
procedure Button2Click(Sender: TObject);
procedure RvSystem1Print(Sender: TObject);
procedure RvSystem1PrintHeader(Sender: TObject);
procedure Edit1Exit(Sender: TObject);
procedure RvSystem1OverridePreview(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideSetup(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);
procedure RvSystem1OverrideStatus(ReportSystem: TRvSystem;
OverrideMode: TOverrideMode; var OverrideForm: TForm);

procedure Bt_cancelClick(Sender: TObject);

private

{ Private declarations }

public

{ Public declarations }

end;

var

F_Trn_Determinante: TF_Trn_Determinante;
Mt : Mtz;

implementation

{$R *.dfm}

procedure TF_Trn_Determinante.LimpaGrid;
var

i,j : integer;

begin

for i:= 0 to Grid1.ColCount -1 do

for j:= 0 to Grid1.ColCount -1 do

Grid1.Cells[i,j]:=’’;

SetLength(M,0,0);
Grid1.RowCount:= 1;
Grid1.ColCount:= 1;

//linhas do grid
//colunas do grid

end;

procedure TF_Trn_Determinante.Bt_MatrizClick(Sender: TObject);
var

x : integer;

begin

if Edit1.text = ’’ then Exit;
LimpaGrid;
x:= StrToInt(Edit1.text);
Grid1.RowCount:= x;
Grid1.ColCount:= x;
Grid1.SetFocus;

{linhas do grid}
{colunas do grid}

91

end;

procedure TF_Trn_Determinante.Edit1KeyPress(Sender: TObject;

var Key: Char);

begin

if not (Ord(key) in [8,13,48..57]) then Key:= #0;

end;

procedure TF_Trn_Determinante.Grid1KeyPress(Sender: TObject;

var Key: Char);

begin

if not (Ord(key) in [8,13,44,45,48..57]) then Key:= #0;

end;

procedure TF_Trn_Determinante.Edit2KeyPress(Sender: TObject;

var Key: Char);

begin

if not (Ord(key) in [3,8,13,22,44,45,48..57,59]) then Key:= #0;
{3 CTR+C e 22 CTR+V}

end;

procedure TF_Trn_Determinante.FormCreate(Sender: TObject);
begin

Grid1.OnDrawCell:= TMenuActions.SGDrawCell;
Grid1.OnKeyPress:= TMenuActions.GridKeyPress;
MSeq:= false;
EqLinear:= false;

end;

procedure TF_Trn_Determinante.SpeedButton1Click(Sender: TObject);
var

i,x,iNum: Integer;
List_A: TStringList;

begin

List_A:= TStringList.Create;
x:= StrToInt(Edit1.text);
x:= x*x -1;
for i:=0 to x do
begin

Randomize;
iNum := Random(11);
List_A.Add(IntToStr(iNum));

end;
{Verifica a quantidade de elementos}
if List_A.Count <>
begin

Grid1.RowCount*Grid1.ColCount then

ShowMessage(’A Quantidade de elementos ’+IntToStr(List_A.Count)

+’ não preenche todas as células da Matriz!’);

Exit;

end;
{Mostra valores da lista no grid}
MostraListGrid(List_A,Grid1);

end;

procedure TF_Trn_Determinante.Bt_GaussClick(Sender: TObject);
Var

d,i,j: Integer;
Aux: real;

begin

if GridOk(Grid1) = false then exit;
Cancelar:= false;
Bt_cancel.Visible:= true;
{Matriz de dimensão 1}
if Grid1.ColCount = 1 then
begin

Painel.Caption:= Grid1.Cells[0,0];
Exit;

end;
d:= StrToInt(Edit1.text);
{Adiciona linhas aos combos}
CBox1.Items.Clear;
CBox3.Items.Clear;
CBox4.Items.Clear;

92

Li.Items.Clear;
Li2.Items.Clear;
Lf.Items.Clear;
Pivot1.Items.Clear;
Pivot2.Items.Clear;
for i:= 1 to d do
begin

{Verifica cancelamento}
Application.ProcessMessages;
if Cancelar then
begin

SB.DestroyComponents;
Painel.Caption:=’’;
Exit;

end;
CBox1.Items.Add(’Linha ’+IntToStr(i));
CBox3.Items.Add(’Linha ’+IntToStr(i));
CBox4.Items.Add(’Linha ’+IntToStr(i));
Li.Items.Add(’Linha ’+IntToStr(i));
Li2.Items.Add(’Linha ’+IntToStr(i));
Lf.Items.Add(’Linha ’+IntToStr(i));

end;
{Preenche os valores do grid nas Matrizes}
Col_Tp:= d;
SetLength(M,d,d+1);
SetLength(Mt,d,d+1);
for i:= 0 to d-1 do

for j:= 0 to d-1 do
begin

{Verifica cancelamento}
Application.ProcessMessages;
if Cancelar then
begin

SB.DestroyComponents;
Painel.Caption:=’’;
Exit;

end;
M[i,j]:= StrToFloat(Grid1.Cells[j,i]);
Mt[i,j]:= StrToFloat(Grid1.Cells[j,i]);
Pivot1.Items.Add(IntToStr(j+1)+’,’+IntToStr(i+1));
Pivot2.Items.Add(IntToStr(j+1)+’,’+IntToStr(i+1));

end;

{Verifica linha coluna zerada}
if LCZerada(M) then
begin

Painel.Caption:= ’0’;
exit;

end;

SB.DestroyComponents;
SetLength(SG,0);
Tops:= 5;
CriaGridBox(SB,M);
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,M);
{Verifica cancelamento}
Application.ProcessMessages;
if Cancelar then
begin

SB.DestroyComponents;
Painel.Caption:=’’;
Exit;

end;
{Calcula Variáveis}
Aux:=1;
for i := 0 to length(M)-1 do

for j := 0 to length(M)-1 do

if i = j then

Aux:= Aux*M[i,j];
Painel.Caption:= Fracao(Aux);
Panel1.Caption:= ’’;
Bt_cancel.Visible:= false;

end;

93

procedure TF_Trn_Determinante.FormMouseWheelDown(Sender: TObject;
Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do

begin

Position := Position + Increment;

end;

end;

procedure TF_Trn_Determinante.FormMouseWheelUp(Sender: TObject;
Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);

begin

with SB.VertScrollBar do
begin

Position := Position - Increment;

end;

end;

procedure TF_Trn_Determinante.Bt_SomaClick(Sender: TObject);
Var

i,j,d,L1,L2 : integer;
S : String;
Aux: real;

begin

if (CBox1.ItemIndex = -1) or (CBox2.ItemIndex = -1) or
(CBox3.ItemIndex = -1) then

Exit;

SendMessage(SB.Handle, WM_VSCROLL, SB_TOP, 0);
d:= StrToInt(Edit1.text);
L1:= CBox1.ItemIndex;
L2:= CBox3.ItemIndex;
for i:= 0 to d-1 do

if CBox2.ItemIndex = 0 then
begin

Mt[L1,i]:= Mt[L1,i]+Mt[L2,i];
S:= ’ + ’;

end
else
begin

Mt[L1,i]:= Mt[L1,i]-Mt[L2,i];
S:= ’ - ’;

end;

CriaGridTex(SB,’L’+IntToStr(CBox1.ItemIndex+1)+’ = L’

+IntToStr(CBox1.ItemIndex+1)+
S+’L’+IntToStr(CBox3.ItemIndex+1));

CriaGridBox(SB,Mt);
{M recebe valores de Mt}
for i:= 0 to d-1 do

for j:= 0 to d-1 do
M[i,j]:= Mt[i,j];
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,M);
{Calcula Variáveis}
Aux:=1;
for i := 0 to length(M)-1 do

for j := 0 to length(M)-1 do

if i = j then

Aux:= Aux*M[i,j];
Panel1.Caption:= Fracao(Aux);
if Panel1.Caption = Painel.Caption then

Panel1.Font.Color:= clGreen

else

Panel1.Font.Color:= clRed;

SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);

end;
procedure TF_Trn_Determinante.Bt_MultClick(Sender: TObject);
Var

i,j,d,L1 : integer;
S : String;
Aux: real;

begin

if (CBox4.ItemIndex = -1) or (CBox5.ItemIndex = -1) or
(trim(Edit3.Text) = ’’) then

94

Exit;

SendMessage(SB.Handle, WM_VSCROLL, SB_TOP, 0);
d:= StrToInt(Edit1.text);
L1:= CBox4.ItemIndex;
for i:= 0 to d-1 do

if CBox5.ItemIndex = 0 then
begin

Mt[L1,i]:= Mt[L1,i]*StrToFloat(Edit3.Text);
S:= ’ * ’;

end
else
begin

Mt[L1,i]:= Mt[L1,i]/StrToFloat(Edit3.Text);
S:= ’ / ’;

end;

CriaGridTex(SB,’L’+IntToStr(CBox4.ItemIndex+1)+’ = L’

+IntToStr(CBox4.ItemIndex+1)+
S+Edit3.Text);
CriaGridBox(SB,Mt);
{M recebe valores de Mt}
for i:= 0 to d-1 do

for j:= 0 to d-1 do
M[i,j]:= Mt[i,j];
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,M);
{Calcula Variáveis}
Aux:=1;
for i := 0 to length(M)-1 do

for j := 0 to length(M)-1 do

if i = j then

Aux:= Aux*M[i,j];
Panel1.Caption:= Fracao(Aux);
if Panel1.Caption = Painel.Caption then

Panel1.Font.Color:= clGreen

else

Panel1.Font.Color:= clRed;

SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);

end;

procedure TF_Trn_Determinante.Edit3KeyPress(Sender: TObject;

var Key: Char);

begin

if (key = ’-’) and (length(TEdit(Sender).Text) > 1) then
begin

key:=#0;
exit;

end;
if (key = ’,’) and (pos(’,’,TEdit(Sender).Text) > 0) then
begin

key:=#0;
exit;

end;
if not (Ord(key) in [8,13,44,45,48..57]) then Key:= #0;

end;

procedure TF_Trn_Determinante.Button1Click(Sender: TObject);
Var

i,j,d,L1,L2,L3,i1,i2,j1,j2 : integer;
Pivot, Aux: real;
lista : TStringList;

begin

if (Pivot1.ItemIndex = -1) or (Pivot1.ItemIndex = -1)

or (Li.ItemIndex = -1) or (Li2.ItemIndex = -1)
or (Lf.ItemIndex = -1) then
Exit;

SendMessage(SB.Handle, WM_VSCROLL, SB_TOP, 0);
d:= StrToInt(Edit1.text);
L1:= Li.ItemIndex;
L2:= Li2.ItemIndex;
L3:= Lf.ItemIndex;
lista:= ArraydeString(Pivot1.Text,’,’);
i1:= StrToInt(lista[0])-1;
j1:= StrToInt(lista[1])-1;

95

lista:= ArraydeString(Pivot2.Text,’,’);
i2:= StrToInt(lista[0])-1;
j2:= StrToInt(lista[1])-1;
Pivot:= Mt[i1,j1]/Mt[i2,j2];
CriaGridTex(SB,’L’+IntToStr(L1+1)+’ = L’+IntToStr(L2+1)+

’ - (a[’+Pivot1.Text+’] / a[’+Pivot2.Text+’]) * L’+IntToStr(L3+1));

for j:= 0 to d-1 do

Mt[L1,j]:= Mt[L2,j]-(Pivot * Mt[L3,j]);

CriaGridBox(SB,Mt);
{M recebe valores de Mt}
for i:= 0 to d-1 do

for j:= 0 to d-1 do
M[i,j]:= Mt[i,j];
{Escalona a Matriz Gauss}
EscalonaMatriz(SB,M);
{Calcula Variáveis}
Aux:=1;
for i := 0 to length(M)-1 do

for j := 0 to length(M)-1 do

if i = j then

Aux:= Aux*M[i,j];
Panel1.Caption:= Fracao(Aux);
if Panel1.Caption = Painel.Caption then

Panel1.Font.Color:= clGreen

else

Panel1.Font.Color:= clRed;

SendMessage(SB.Handle, WM_VSCROLL, SB_BOTTOM, 0);

end;

procedure TF_Trn_Determinante.Button2Click(Sender: TObject);
begin

if SB.ComponentCount = 0 then Exit;
with RVSystem1.SystemPrinter do
begin

MarginRight:= 0.2;
MarginLeft:= 0.2;
MarginTop:= 1;
MarginBottom:= 1;
rpDev.Copies:= 1;
Copies:= rpDev.Copies;
rpDev.Orientation:= poPortrait;
Orientation:= rpDev.Orientation;
RVSystem1.SystemPreview.FormState:= wsMaximized;
RVSystem1.SystemSetups:= RVSystem1.SystemSetups - [ssAllowSetup];
rpDev.SelectPaper(’A4’,false);
RVSystem1.Execute;

end;

end;

procedure TF_Trn_Determinante.RvSystem1Print(Sender: TObject);
Var

x,i,j: integer;
TSG : TstringGrid;

begin

with RVSystem1.BaseReport do
begin

for x:= 0 to SB.ComponentCount-1
begin

do

TSG:= TStringGrid(SB.Components[x]);
for i:= 0 to TSG.rowCount - 1 do
begin

for j:= 0 to TSG.colCount - 1 do
begin

if TSG.colCount = 1 then

PrintLeft(TSG.Cells[j,i],MarginLeft)

else

PrintCenter(TSG.Cells[j,i],MarginLeft+0.2+(j/2));

end;
NewLine;
NewLine;
if LinesLeft<1 then NewPage;

end;

end;

96

end;

end;

procedure TF_Trn_Determinante.RvSystem1PrintHeader(Sender: TObject);
begin

with RVSystem1.BaseReport do
begin

SetFont(’Verdana’,12);
Bold := True;
PrintCenter(’Treinamento Escalonamento - Gauss’,PageWidth/2);
NewLine;
Canvas.Pen.Width := 2;
Canvas.Pen.Color := clBlack;
MoveTo(MarginLeft,YPos);
LineTo(PageWidth-MarginRight,YPos);
NewLine;
SetFont(’Verdana’,8);
Bold := False;

end;

end;

procedure TF_Trn_Determinante.Edit1Exit(Sender: TObject);
begin

Bt_MatrizClick(Bt_Matriz);

end;

procedure TF_Trn_Determinante.RvSystem1OverridePreview(ReportSystem:
OverrideMode: TOverrideMode; var OverrideForm: TForm);

TRvSystem;

begin

ExecutePreviewForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Trn_Determinante.RvSystem1OverrideSetup(ReportSystem:

TRvSystem;

OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteSetupForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Trn_Determinante.RvSystem1OverrideStatus(ReportSystem:
TRvSystem; OverrideMode: TOverrideMode; var OverrideForm: TForm);

begin

ExecuteStatusForm(Self,ReportSystem,OverrideMode,OverrideForm);

end;

procedure TF_Trn_Determinante.Bt_cancelClick(Sender: TObject);
begin

Cancelar:= true;
Bt_cancel.Visible:= false;

end;

end.

====================================================================

unit Funcoes;

interface

uses

Messages, Classes, SysUtils, Grids, Forms, StdCtrls, Graphics,
Windows, Math, Controls, Dialogs, Tlhelp32;

type

TMenuActions = class
public

{01a}class procedure SGDrawCell(Sender: TObject; ACol, ARow: Integer;

Rect: TRect; State: TGridDrawState);

{01b}class procedure GridKeyPress(Sender: TObject; var Key: Char);

end;

type Mtz = array of array of Real; {Matriz sem dimensão pré-definida}

Mtz1 = array of Real;

{Matriz de uma dimensão}

{02}function ArrayDeString(s:string; separador: char): TStringList;

97

{03}function MatrizMenor(M:Mtz; Linha,Coluna,Dim:integer):Mtz;
{04}function Determinante(SB: TScrollBox; M:Mtz):Real;
{05}function Variaveis(M:Mtz; Dim:integer):Mtz1;
{06}function Fracao(Valor: real):string;
{07}function GridOk(Grid: TStringGrid):Boolean;
{08}function LCZerada(M:Mtz): Boolean;
{09}procedure PivoZ(SB: TScrollBox; M:Mtz; Ni:integer);
{10}procedure EscalonaMatriz(SB: TScrollBox; M:Mtz);
{11}procedure MostraMatrizGrid(M:Mtz; Grid:TStringGrid);
{12}procedure MostraListGrid(List:TStringList; Grid:TStringGrid);
{13}procedure CriaGridBox(SB: TScrollBox; M:Mtz);
{14}procedure CriaGridTex(SB: TScrollBox; Tx: String);
{15}function ProcessoExiste(ExeFileName: string): boolean;

var

{matrizes temporarias}

M : Mtz;
SG : array of TStringGrid; {grids da area azul}
Tops : Integer;
Mseq : Boolean;
Col_Tp : Integer;
Cancelar : Boolean; {cancelar operações}
EqLinear : Boolean; {equações lineares}

{topo da area azul}
{escrever sequencia}
{colunas do grid}

implementation

{01a Altera largura das celulas e do grid e centraliza texto}
class procedure TMenuActions.SGDrawCell(Sender: TObject; ACol,

ARow: Integer; Rect: TRect; State: TGridDrawState);

begin

with Sender as TStringGrid do
begin

{Altera a cor do foco}
Canvas.Brush.Color := Color;
Canvas.Font.Color:= Font.Color;
{Modificar coluna nas eq lineares}
if EqLinear and (Col_Tp <> 0) and (ACOL = Col_Tp-1) then
begin

canvas.Brush.color := $00FFF1D5;// $00C08000;
canvas.Font.Color := clBLACK;
canvas.Font.Name := ’TAHOMA’;
canvas.FillRect(Rect);
canvas.TextOut(RECT.LEFT + 3,RECT.TOP,Cells[ACOL,AROW]);

end;
{Aumenta o tamanho da celula}
if Canvas.TextWidth(Cells[ACol,ARow]) > DefaultColWidth then

DefaultColWidth:= Canvas.TextWidth(Cells[ACol,ARow]);

{Centraliza o conteudo da celula}
Canvas.FillRect(Rect);
DrawText(Canvas.Handle,PChar(Cells[ACol,ARow]),-1,Rect,DT_CENTER);
{Aumenta a Largura do grid}
if (Name <> ’Grid1’) and (Name <> ’Grid2’) then

Width:= ColCount*DefaultColWidth+5;

end;

end;

{01b}
class procedure TMenuActions.GridKeyPress(Sender: TObject; var Key: Char);
begin

if Key = #13 then
begin

Key := #0;
TStringGrid(Sender).Perform(WM_KeyDown,VK_Tab,0);

end;
if not (Ord(key) in [3,8,13,22,44,45,48..57,59]) then Key:= #0;

end;

{02 Função para pegar os valores que estao entre separadores}
function ArrayDeString(s: string; separador: char): TStringList;
var

k: integer;
VS: TStringList; //vetor de string (resultado)
Aux: string;

//posição do separador

//substring (um valor extraido da string)

begin

VS:= TStringList.Create;
k:= pos(separador, s);
while (k <> 0) do

begin

//pega posição do separador enquanto a
//cadeia "s" for diferente de nulo

98

Aux := copy(s, 1, k-1); //sAux recebe os valores copiados de "s"
delete(s, 1, k);
VS.Add(Aux);
k:= pos(separador, s);

// adiciona os valores extraidos no vetor Vr
//pega posição do separador

//apaga o valor extraido da string "s"

end;
VS.Add(s);
result := VS;

end;

{03 Função para pegar a matriz com uma dimensão a menos}
function MatrizMenor(M:Mtz; Linha,Coluna,Dim:integer):Mtz;
var

i,j,k :integer;
M1
begin

:Mtz;

k:=1;
SetLength(M1,Dim-1,Dim-1);
Col_Tp:= dim-1;
for i:=0 to Dim-1 do

for j:=0 to Dim-1 do

//cria uma matriz com uma dimensão menor

if ((i<>Linha) and (j<>Coluna)) then
begin

if k mod Dim = 0 then

k:=k+1;

//se for diferente da linha/coluna

M1[(k div Dim),(k mod Dim)-1]:=M[i,j];
k:=k+1;

end;
result:=M1;

end;

{04 Função para calcular o determinante laplace}
function Determinante(SB: TScrollBox; M:Mtz):Real;
var

M1: Mtz;
i,d: integer;
temp: Real;

begin

d:= length(M);
{determinante de matriz 2x2}
if d=2 then

result:=((M[0,0]*M[1,1])-(M[0,1]*M[1,0]))

else
{dimensão maior que 2}
begin

temp:=0;
for i:=0 to d-1 do
begin

Application.ProcessMessages;
if Cancelar then Exit;
M1:=MatrizMenor(M,i,0,d);
if Mseq then CriaGridTex(SB,’(-1)^(’+IntToStr(i+1)+’+1)*a[’+

IntToStr(i+1)+’,1]*’);

if Mseq then CriaGridBox(SB,M1);
if (i mod 2 = 0) then

temp:= temp + M[i,0]*Determinante(SB,M1)

else

temp:= temp - M[i,0]*Determinante(SB,M1);

end;
result:= temp;

end;

end;

{05 Função para calcular variaveis de um sistema linear}
function Variaveis(M:Mtz; Dim:integer):Mtz1;
var

x,i,j,k :integer;
Soma: Real;
Resp: Mtz1;

99

begin

SetLength(Resp,Dim);
k:= 0;
x:= Dim;
Resp[k]:= M[x-1][x]/M[x-1][x-1];
for i := x-2 downto 0 do
begin

Soma:= 0;
for j:= k+1 downto 1 do

Soma:= Soma + M[i][x-j]*Resp[j-1];

Inc(k);
Resp[k] := (M[i][x] - Soma)/M[i][i];
Result:= Resp;

end;

end;

{06 Transforma decimal em fração com precisão de 4 casas decimais}
function Fracao(Valor: real):string;
var

i: integer;
x: real;
k: Currency;

begin

x:= Valor;
if frac(x) = 0 then
begin

result:= FloatToStr(x);
exit;

end;
i:= 1;
while 1 < 2 do
begin

k:= x;
if frac(k) = 0 then
begin

if i = 1 then

result:= FloatToStr(k)

else

result:= FloatToStr(k)+’/’+IntToStr(i);

exit;

end;
x:= x+Valor;
inc(i);

end;

end;

{07 Verifica o grid antes de continuar}
function GridOk(Grid: TStringGrid):boolean;
var

i,j,n : integer;
S : String;

begin

result:= true;
for i:= 0 to Grid.RowCount -1 do

for j:= 0 to Grid.ColCount -1 do
begin

{Celulas em branco}
if Grid.Cells[j,i] = ’’ then
begin

ShowMessage(’A Matriz não pode celulas em branco!’);
result:= false;
exit;

end;
{Celulas com mais de um sinal -}
n:=0;
S:= Grid.Cells[j,i];
while Pos(’-’, S) > 0 do
begin

S[Pos(’-’, S)]:= ’0’;
n:= n+1;

end;
if
begin

n > 1 then

100

ShowMessage(

’A Matriz não pode ter elementos com mais de um sinal negativo!’);

result:= false;
exit;

end;
S:= Grid.Cells[j,i];
if (n = 1) and (S[1] <> ’-’) then
begin

ShowMessage(

’A Matriz não pode ter elementos com um sinal negativo deslocado!’);

result:= false;
exit;

end;

end;

end;

{08 Verifica linha ou coluna zerada}
function LCZerada(M:Mtz): boolean;
var

i,j,d :integer;
LCz : Boolean;

begin

d:= Length(M);
{linha}
for i:= 0 to d-1 do
begin

LCz:=true;
for j:= 0 to d-1 do

if M[i,j] <> 0 then LCz:= false;

if LCz = true then
begin

result:= true;
exit;

end;

end;
{coluna}
for j:= 0 to d-1 do
begin

LCz:=true;
for i:= 0 to d-1 do

if M[i,j] <> 0 then LCz:= false;

if LCz = true then
begin

result:= true;
exit;

end;

end;
result:= false;

end;

{09 Verifica PIVô zerado}
procedure PivoZ(SB: TScrollBox; M:Mtz; Ni:integer);
var

i,d,k :integer;
cont : Boolean;

begin

d:= Length(M);
k:= Ni;
cont:= true;
while cont do
begin

if M[Ni,Ni]=0 then {se pivo for zero}
begin

Inc(k); {proxima linha}
if k = Ni then Inc(k); {caso mesma linha vai p/ proxima linha}
if k = d then k:=0;
for i:= 0 to d-1 do

{fim da matriz vai p/ primeira linha}

M[Ni,i]:= M[Ni,i]+M[k,i]; {soma linhas}

if Mseq then CriaGridTex(SB,’L’+IntToStr(Ni+1)+’ = L’+IntToStr(Ni+1)

+’ + L’+IntToStr(k+1));

end
else

cont:= false;

101

end;

end;

{10 Função para escalonar a matriz e mostra}
procedure EscalonaMatriz(SB: TScrollBox; M:Mtz);
var

i,j,k,d :integer;
Mult: Real;

begin

d:= length(M);
for k:= 0 to d-2 do
begin

for i:= 1 to d-1-k do
begin

{Verifica cancelamento}
Application.ProcessMessages;
if Cancelar then Exit;
{Pivo zerado}
if M[k,k] = 0 then
begin

PivoZ(SB,M,k);
if Mseq then CriaGridBox(SB,M);

end;
Mult:= M[i+k,k];
if Mseq then CriaGridTex(SB,’L’+IntToStr(i+k+1)+’ = L’+IntToStr(i+k+1)

+’ - (a[’+IntToStr(i+k+1)+’,’+IntToStr(k+1)
+’]/a[’+IntToStr(k+1)+’,’+IntToStr(k+1)+’])*L’+IntToStr(k+1));

for j := 0 to d-k do

M[i+k,j+k]:= ((M[i+k,j+k]*M[k,k])-(M[k,j+k]*Mult))/M[k,k];

end;
if Mseq then CriaGridBox(SB,M);

end;

end;

{11 Mostra matriz em grid}
procedure MostraMatrizGrid(M:Mtz; Grid:TStringGrid);
var

i,j :integer;

begin

for i := 0 to Grid.RowCount - 1 do

for j:= 0 to Grid.ColCount - 1 do

if Grid.Name = ’Grid1’ then

Grid.Cells[i,j]:= FloatToStr(M[j,i])

else

Grid.Cells[i,j]:= Fracao(M[j,i]);

end;

{12 Mostra lista em grid}
procedure MostraListGrid(List:TStringList; Grid:TStringGrid);
var

i,j,k :integer;

begin

k:= 0;
for i:= 0 to Grid.RowCount - 1 do

for j:= 0 to Grid.ColCount - 1 do
begin

if Grid.Name = ’Grid1’ then

Grid.Cells[j,i]:= List.Strings[k]

else

Grid.Cells[j,i]:= Fracao(StrToFloat(List.Strings[k]));

Inc(k);

end;

end;

{13 Cria varios grids com a sequencia da resolução}
procedure CriaGridBox(SB: TScrollBox; M:Mtz);
var

i,j,s :integer;

begin

s:= SB.ComponentCount;
SetLength(SG,Length(SG)+1);
if SG[s] = nil then SG[s]:= TStringGrid.Create(SB);
SG[s].Parent := SB;

102

SG[s].OnDrawCell:= TMenuActions.SGDrawCell;
if s = 0 then

SG[s].Font.Color:= clBlue

else

SG[s].Font.Color:= clRed;

SG[s].Font.Height:= -16;
SG[s].Font.Name:= ’MS Sans Serif’;
SG[s].Font.Style:= [fsBold];
SG[s].FixedCols:=0;
SG[s].FixedRows:=0;
SG[s].DefaultColWidth:= 24;
SG[s].DefaultRowHeight:=24;
SG[s].Ctl3D:= false;
SG[s].ScrollBars:= ssNone;
SG[s].Enabled:= false;
SG[s].Left:= 5;
SG[s].RowCount:= Length(M);
SG[s].ColCount:= Col_Tp; //Length(M[0]); //colunas
SG[s].Height:= SG[s].DefaultRowHeight*SG[s].RowCount+Length(M);
SG[s].Top:= Tops;
for i:= 0 to SG[s].colCount - 1 do

for j:= 0 to SG[s].rowCount - 1 do

SG[s].Cells[i,j]:= Fracao(M[j,i]);

Tops:= Tops+SG[s].Height+5;
SG[s].Show;

end;

{14 Cria varios grids com texto}
procedure CriaGridTex(SB: TScrollBox; Tx: String);
var

s :integer;

begin

s:= SB.ComponentCount;
SetLength(SG,Length(SG)+1);
if SG[s] = nil then SG[s]:= TStringGrid.Create(SB);
SG[s].Parent := SB;
SG[s].OnDrawCell:= TMenuActions.SGDrawCell;
SG[s].Font.Color:= clBlack;
SG[s].Font.Height:= -16;
SG[s].Font.Name:= ’MS Sans Serif’;
SG[s].Font.Style:= [fsBold];
SG[s].FixedCols:=0;
SG[s].FixedRows:=0;
SG[s].GridLineWidth:=0;
SG[s].Ctl3D:= false;
SG[s].ScrollBars:= ssNone;
SG[s].Enabled:= false;
SG[s].Left:= 5;
SG[s].RowCount:= 1;
SG[s].ColCount:= 1;
SG[s].Top:= Tops;
SG[s].Height:= SG[s].DefaultRowHeight*SG[s].RowCount;
SG[s].Cells[0,0]:= Tx;
Tops:= Tops+SG[s].Height+5;
SG[s].Show;

end;

{15 Verifica se o processo está ativo}
function ProcessoExiste(ExeFileName: string): boolean;
const

PROCESS_TERMINATE=$0001;

var

ContinueLoop: BOOL;
FSnapshotHandle: THandle;
FProcessEntry32: TProcessEntry32{declarar Uses Tlhelp32};

begin

result := false;
FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
FProcessEntry32.dwSize := Sizeof(FProcessEntry32);
ContinueLoop := Process32First(FSnapshotHandle,FProcessEntry32);
while integer(ContinueLoop) <> 0 do
begin

if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =

103

UpperCase(ExeFileName))

or (UpperCase(FProcessEntry32.szExeFile) = UpperCase(ExeFileName))) then
begin

Result := true;
exit;

end;
ContinueLoop := Process32Next(FSnapshotHandle,FProcessEntry32);

end;
CloseHandle(FSnapshotHandle);

end;

end.

Link’s para download do aplicativo

• http://www.mediafire.com/download/f6415rwm257p1lq/Matriz.rar

• https://drive.google.com/file/d/0B8d4RKfZIT3BaGpVNFAwWUwxSXM/

view?pref=2&pli=1

