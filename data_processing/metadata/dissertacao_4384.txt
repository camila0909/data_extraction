UFRRJ 

INSTITUTO DE CIÊNCIAS EXATAS 

MESTRADO PROFISSIONAL EM 

MATEMÁTICA EM REDE NACIONAL  

DISSERTAÇÃO 

Códigos Corretores de Erros: Exemplos da Matemática 

Aplicada em Situações do Cotidiano. 

Raphael Bruno Rodrigues da Silveira 

2015 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
UNIVERSIDADE FEDERAL RURAL DO RIO DE JANEIRO 
INSTITUTO DE CIÊNCIAS EXATAS 
MESTRADO PROFISSIONAL EM MATEMÁTICA EM REDE 
NACIONAL – PROFMAT 

CÓDIGOS CORRETORES DE ERROS: EXEMPLOS DA 
MATEMÁTICA APLICADA EM SITUAÇÕES DO COTIDIANO. 

RAPHAEL BRUNO RODRIGUES DA SILVEIRA 

Sob a Orientação do Professor 

Dr. André Luiz Martins Pereira 

Dissertação  de  Mestrado  apresentada  ao 
Mestrado  Profissional  em  Matemática  em 
Rede  Nacional  –  PROFMAT  –  da 
Universidade  Federal  Rural  do  Rio  de 
Janeiro, como requisito parcial à obtenção 
do título de Mestre em Matemática. 

Seropédica, RJ 

Maio de 2015 

i 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
UFRRJ / Biblioteca Central / Divisão de Processamentos Técnicos 

510.7 
S587c 
T 

Silveira, Raphael Bruno Rodrigues da, 1982- 
   Códigos  corretores de erros: exemplos da 
matemática 
do 
cotidiano 
/  Raphael  Bruno  Rodrigues  da 
Silveira. – 2015. 
   99 f.: il. 

situações 

aplicada 

em 

   Orientador: André Luiz Martins Pereira. 
   Dissertação  (mestrado)  –  Universidade 
Federal  Rural  do  Rio  de  Janeiro,  Curso  de 
Mestrado  Profissional  em  Matemática  em 
Rede Nacional, 2015. 
   Bibliografia: f. 92-95. 

   1.  Matemática  –  Estudo  e  ensino  – 
Teses.  2.  Códigos  corretores  de  erros 
(Teoria  da  informação)  –  Teses.  3. 
Sistemas  lineares  –  Teses.  4.  Matrizes 
(Matemática)  –  Teses.  5.  Ensino  auxiliado 
por  computador  –  Teses.  I.  Pereira,  André 
Luiz  Martins,  1980-  II.  Universidade 
Federal Rural do Rio de Janeiro.  Curso de 
Mestrado  Profissional  em  Matemática  em 
Rede Nacional. III. Título. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
ii 

 
 
 
 
 
 
 
 
DEDICATÓRIA 

Ao  meu  Deus, 

fonte  de  vida, 

conhecimento  e  inspiração;  à  minha 

esposa 

e 

à  minha 

filha,  meus 

verdadeiros  tesouros  nesse  mundo;  aos 

meus  amigos;  e  a  todos  que  acreditam 

na  educação  como  o  caminho  para 

desenvolvimento de nosso país. 

iii 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

A  Deus,  pois  sem  Ele  eu  não  teria  conseguido  alcançar  essa  bênção,  que  é  a 

conclusão do curso de Mestrado. 

Aos meus pais, Damil e Edionea, por terem me ensinado o caminho a seguir e 

pelas constantes orações. 

À minha amada esposa, pela compreensão, orações e palavras de fortalecimento 

em todos os momentos. 

Ao  meu  orientador,  André, que  além  de  ter  sido  professor  de  duas disciplinas 

durante  o  curso,  sempre  esteve  presente  nos  momentos  em  que  precisei, 

aconselhando-me durante a elaboração deste trabalho. 

Aos meus queridos amigos e professores da turma do PROFMAT/UFRRJ-2013 

pelos momentos que passamos juntos. 

À  SBM e  à  CAPES  que  idealizaram  este  maravilhoso  curso de  pós-graduação 

stricto sensu. 

iv 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
“Melhor é a sabedoria do que a força.” 

Eclesiastes capítulo 9, verso 16 – Bíblia Sagrada 

v 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

Este trabalho tem como objetivo oferecer uma sequência didática que permita a 
contextualização  do  ensino  de  sistemas  de  numeração,  vetores,  matrizes  e 
sistemas  lineares  por  meio dos códigos  corretores  de erros.  Na da mencionada 
sequência  de  atividades  é  realizada  a  contextualização histórica  do  surgimento 
dos  códigos  corretores,  com  o  uso  de  situações-problemas  para  motivar  os 
educandos.  Além  disso,  o  computador  é  utilizado  como  um  colaborador  no 
processo de ensino-aprendizagem. Os problemas são apresentados de forma que 
os  alunos  possam  perceber  o  que  motivou  Hamming  a  se  dedicar  à  pesquisa 
sobre  os  códigos  corretores,  pois  são  apresentadas  situações  em  que:  não  será 
possível a detecção de erros; será possível a detecção, mas não a correção; será 
possível  a  detecção,  mas  não  a  correção  com  confiança;  e  será  possível  a 
detecção  e  a  correção  com  certo  grau  de  certeza.  Assim,  por  meio  da 
mencionada  sequência  didática,  a  qual  possui  um  enfoque  construtivista  de 
construção  do  conhecimento,  espera-se  que  os  estudantes,  ao  final  das 
atividades,  compreendam  que  a  Matemática  é  útil  para  resolver  diversos 
problemas do dia-a-dia e sejam capazes de verificar que os conteúdos estudados 
no Ensino Médio possuem mais aplicações no cotidiano do que eles imaginam.   

Palavras-chave:  Códigos  Lineares  Corretores  de  Erros.  Ensino  de  Matemática. 
Contextualização. Matrizes e Sistemas Lineares.  

vi 

 
 
 
 
 
 
ABSTRACT 

This paper aims to offer a didactic sequence to enable the contextualization of  
teaching the numbering systems, vectors, matrices and linear systems using error 
correcting codes. Through the mentioned sequence of activities is carried out at 
historical background of the emergence of error correcting codes, with the use of 
application  problems  that  depict  real  situations  of  day-to-day  to  motivate 
students. In addition, the computer is used as a collaborator in the teaching and 
learning  process.  The  problems  are  presented  in  a  way  that  students  can 
understand  what  motivated    Hamming    to  research  on  error  correcting  codes, 
because  situations  are  presented  in  which:  no  error  detection  is  possible; 
detection  is  possible,  but  not  correction;  detection  is  possible,  but  not  the 
correction with confidence; and it is possible the detection and correction with 
some  degree  of  certainty.  Thus,  through  the    mentioned  didactic  sequence, 
which  has  a  constructivist  approach  to  knowledge  construction,  it  is  expected 
that students at the end of the activities, understand how mathematics is useful to 
solve  problems  and  be  able  to  verify  that  the  contents  studied  in  high  school 
have more applications in everyday life than they realize. 

Keywords:  Error  Correcting  Linear  Codes.  Mathematics  Teaching. 
Contextualization. Matrices and Linear Systems. 

vii 

 
 
 
 
 
 
 
SUMÁRIO 

INTRODUÇÃO .................................................................................................................... 1 

1 BREVE HISTÓRICO SOBRE O SURGIMENTO DOS CÓDIGOS CORRETORES 

DE ERROS ........................................................................................................................... 3 

2 CONCEITOS IMPORTANTES ....................................................................................... 5 

2.1 Definição de código corretor de erros ............................................................................... 5 

2.2 Principais conceitos relacionados aos códigos .................................................................. 9 

2.3 O problema principal da teoria dos códigos .................................................................... 14 

2.4 Uma estratégia para detectar e corrigir erros ................................................................... 16 

3 CÓDIGOS LINEARES ................................................................................................... 18 

3.1 Conceitos auxiliares ....................................................................................................... 18 

3.2 Entendendo o funcionamento de um código linear .......................................................... 23 

3.3 Formalizando o código ................................................................................................... 25 

3.3.1 Código obtido por meio da imagem de uma transformação linear ................................ 25 

3.3.2 Matriz geradora na forma padrão ................................................................................. 29 

3.3.3 Código dual ................................................................................................................. 31 

3.4 Um exemplo de código................................................................................................... 36 

3.5 Decodificação pela síndrome .......................................................................................... 37 

3.5.1 O algoritmo para códigos que corrigem um erro .......................................................... 39 

3.5.2 Classes laterais ............................................................................................................ 41 

3.5.3 Decodificação pela síndrome ....................................................................................... 42 

4 FUNDAMENTAÇÃO PEDAGÓGICA .......................................................................... 46 

4.1 A importância da contextualização histórica da Matemática ........................................... 47 

4.2 A resolução de problemas como estratégia de ensino-aprendizagem  .............................. 48 

4.3 O uso do computador em sala de aula ............................................................................. 50 

4.4 Paradigma construtivista ................................................................................................ 51 

viii 

 
 
 
 
 
 
 
5 PROPOSTAS DE ATIVIDADES ................................................................................... 54 

5.1 Conteúdo disciplinar ...................................................................................................... 54 

5.2 Proposta ......................................................................................................................... 54 

5.3 Atividades ...................................................................................................................... 54 

5.3.1 Atividade 1 .................................................................................................................. 54 

5.3.2 Atividade 2 .................................................................................................................. 58 

5.3.3 Atividade 3 .................................................................................................................. 67 

5.3.4 Atividade 4 .................................................................................................................. 76 

6 CONSIDERAÇÕES FINAIS .......................................................................................... 91 

7 REFERÊNCIAS .............................................................................................................. 92 

APÊNDICES ...................................................................................................................... 96 

A – Folha da atividade 1 .................................................................................................... 96 

B – Folha da atividade 2 .................................................................................................... 98 

ix 

 
 
 
 
 
INTRODUÇÃO 

Códigos capazes de detectar e corrigir erros estão presentes, sem que percebamos, em 

diversas  situações  no  cotidiano:  quando  ouvimos  um  CD,  assistimos  DVD  ou  televisão, 

utilizamos telefones celulares ou rádio, bem como quando há transferência e recebimento de 

informações via satélite ou por meio de computadores e internet.    

Os códigos corretores de erros tem a função de detectar e corrigir erros que surjam na 

transmissão ou armazenamento de dados. Como as informações, ao serem transmitidas, estão 

sujeitas  a  “ruídos”  –  erros  de  digitação,  interferências  eletromagnéticas,  dentre  outros  –, 

devem ser acrescentados dados adicionais ao codificar a informação que será transmitida ou 

armazenada  –  chamadas  de  redundâncias  –  e,  por  meio  dessa  informação  extra,  os  dados 

podem ser recuperados.  

Embora  estejam  tão  presentes  no  dia-a-dia,  a  grande  maioria  dos  alunos  termina  o 

Ensino Médio sem ao menos ter ouvido falar do assunto. Entretanto, os educandos estudam 

conteúdos  que  são  ferramentas  para  construção  de  códigos  como,  por  exemplo,  a 

representação  numérica  em  outras  bases  (mudanças  de  base),  os  vetores,  as  matrizes  e  os 

sistemas  lineares.  Conteúdos  esses  que,  muitas  vezes,  são  apresentados  na  forma  de 

procedimentos mecânicos para resolução problemas sem qualquer contexto prático. Portanto, 

considerando  a  possibilidade  de  contextualizar  os  assuntos  citados  por  meio  do  estudo  dos 

códigos  lineares  corretores  de  erros  e,  ainda,  de  despertar  nos  alunos  o  interesse  ao 

aprofundamento  dos  estudos  no  campo  científico  e  tecnológico,  é  que  será  apresentada  a 

sequência didática de atividades desta dissertação.  

A  referida  sequência  é  composta  de  situações  que  envolvem  a  codificação,  a 

transmissão, o recebimento e decodificação de mensagens, analisando-se em que situações é 

possível a correção delas, bem como o uso de planilhas eletrônicas como auxílio à resolução 

dos  problemas.  Ela  deve  ser  aplicada,  preferencialmente,  a  alunos  que  estejam  cursando  o 

segundo ou o  terceiro  ano  do  Ensino  Médio,  haja  vista  a  necessidade  de  conhecimento  dos 

conceitos relativos a matrizes e a sistemas lineares.   

Para que haja uma boa compreensão do que é e de como pode ser aplicado um código 

corretor de erros, a dissertação será estruturada em seis capítulos, da seguinte forma. 

No  primeiro  capítulo  é  apresentado  o  contexto  histórico  que  motivou  o  início  da 

pesquisa sobre os códigos corretores.  

 1

 
 
 
 
 
 
 
 
No  segundo  capítulo  é  exposta  a  fundamentação  teórica  sobre  a  teoria  dos  códigos, 

com  os  principais  conceitos  necessários  à  construção  de  um  código  corretor.  São 

apresentados,  ainda,  diversos  exemplos  que  possibilitam  uma  verificação  numérica  dos 

teoremas e dos mencionados conceitos. 

No  terceiro  capítulo  são  definidos  os  códigos  corretores  lineares,  bem  como  são 

apresentados teoremas importantes para a construção dos referidos códigos. Ressalta-se que, 

por meio dos mecanismos apresentados nesse capítulo, será possível a elaboração de códigos 

corretores mais eficazes.  

No  quarto  capítulo  é  apresentada  a  fundamentação  pedagógica,  por  meio  da  qual  é 

ressaltado que o uso da contextualização histórica, de situações-problema e de computadores 

em  sala  de  aula  são  métodos  eficazes  para  a  construção  do  conhecimento.  A  perspectiva 

adotada é a abordagem construtivista de ensino-aprendizagem. 

No  quinto  capítulo  são  apresentadas  as  propostas  de  atividades.  Inicialmente,  é 

construído um código no qual não há qualquer preocupação com a possibilidade de correção 

de erros, caso eles ocorram (atividade 1). Em seguida, são analisados alguns códigos que são 

capazes  de  indicar  –  não  em  todas  as  situações  –  que  ocorreram  erros,  mas  que  não  são 

capazes  de  corrigi-los  (atividade  2).  Após,  é  construído  um  código  capaz  de  corrigir  erros. 

Todavia,  não  se  sabe  a  quantidade de  erros que  ocorrem  na  transmissão ou  armazenamento 

das informações e, por isso, a correção fica prejudicada. Por último, é construído um código 

em que é considerado que quantidade de erros que ocorrem na transmissão ou armazenamento 

é  conhecida  e, portanto,  é possível  estabelecer  uma  situação ideal,  em que qualquer palavra 

pode ser corrigida, o que acontece quando o código linear é perfeito. 

No sexto e último capítulo são apresentadas as considerações finais. 

 2

 
 
 
 
 
 
1  BREVE  HISTÓRICO  SOBRE  O  SURGIMENTO  DOS  CÓDIGOS  CORRETORES 

DE ERROS 

Na  década  de  19401,  quando  os  computadores  não  eram  tão  populares  e  apenas 

grandes instituições tinham condições de possuí-los e mantê-los, Richard W. Hamming, que 

trabalhava para o laboratório Bell de Tecnologia, decidiu realizar pesquisas com o intuito de 

que as máquinas, que na época apenas detectavam erros, também fossem capazes de corrigi-

los.  A  motivação  para  o  estudo  foi  o  fato  de  ele  ter  perdido  várias  semanas  sem  que  seus 

arquivos  fossem  descarregados,  pois,  ao  detectar um  erro,  os  computadores  interrompiam  a 

leitura dos cartões perfurados e faziam a leitura dos dados do próximo usuário. Assim, como o 

acesso às máquinas era apenas nos fins de semana, quando chegava ao trabalho, no início da 

semana  seguinte,  Hamming  verificava  que os dados  não  haviam  sido descarregados. Então, 

após esse problema ter ocorrido alguma vezes, ele decidiu que deveria encontrar uma solução.  

Hamming começou sua pesquisa e a cada avanço publicava memorandos internos no 

Laboratório  Bell.  Em  1950  ele  publicou  seu  trabalho  no  “The  Bell  System  Thechnical 

Journal”, no qual ele expôs um código capaz de detectar até dois erros e corrigir apenas um 

erro, se ele fosse único. 

Mas  não  foi  apenas  Hamming  que  se  interessou  pelos  códigos  corretores  de  erros. 

Claude  E.  Shannon2  e  Marcel  J.  E.  Golay  também  se  debruçaram  sobre  a  pesquisa  dos 

códigos.  Este  último,  inclusive,  desenvolveu  um  código  que  foi  utilizado  para  transmitir 

fotografias coloridas de Jupiter e Saturno pela espaçonave Voyager3.  

As ideias desenvolvidas por Hamming, Shannon e Golay são utilizadas ainda hoje nos 

celulares,  gravadores  de  CD  e  DVD,  comunicações  via  satélite,  processamento  de  imagens 

digitais,  internet e rádio, entre outras. Por isso, os códigos corretores de erros são objeto de 

estudo de várias áreas como matemática, computação, engenharia elétrica, estatística etc. 

Atualmente  os  códigos  corretores  também  são  muito  utilizados  pela  National 

Aeronautics and Space Administration (NASA) e pelo Jet Propulsion  Laboratory (JPL). Por 

1  As  informações  descritas  neste  capítulo  referentes  ao  início  do  estudo  dos  códigos  corretores  de  erros  foram 
obtidas, principalmente, por meio da referência bibliográfica [16]. 
2 Shannon publicou um artigo intitulado “A Mathematical Theory of Communication” em outubro de 1948. Sua 
publicação é anterior ao artigo de Hamming, pois houve um pedido de patente dos códigos pelo laboratório Bell, 
o que ocasionou um atraso na publicação de Hamming. 
3  As  sondas  espaciais  Voyager  1  e  Voyager  2  enviam  dados  via  rádio  para  a  Terra  a  fim  de  que  os  cientistas 
possam  analisa-los.  Uma 
isso  está  disponível  em  http://ultimo 
segundo.ig.com.br/ciencia/2013-09-12/nasa-afirma-que-sonda-voyager-1-finalmente-saiu-do-sistema-solar.html 

interessante 

reportagem 

sobre 

 3

 
 
 
 
 
 
                                                 
exemplo,  nas  missões  Galileo4,  Cassini5  e  Marte  foram  utilizados  códigos  corretores  que 

combinam técnicas dos códigos de Reed-Solomon com códigos convolucionais. 

4  Sonda  enviada  à  Júpiter.  Para  mais  informações  sobre  o  assunto,  pode  ser  verificado  o  registro 
http://noticias.terra.com.br/ciencia/interna/0,,OI145598-EI301,00.html. 
5  Sonda  enviada  à  Saturno.  Mais  informações  podem  ser  encontradas  em  http://www.ccvalg.pt/astronomia/ 
noticias/2014/07/1_cassini_saturno.htm. 

 4

 
 
                                                 
2 CONCEITOS IMPORTANTES 

2.1 Definição de Código Corretor de Erros 

Um bom modelo de um código corretor de erros presente no cotidiano é um idioma. 

Procederemos  a  uma  caracterização  do  mencionado  código.  Inicialmente,  vamos  tomar  um 

“alfabeto” (cid:2418) formado pelas 26 letras do nosso alfabeto, pelo espaço em branco (considerado 

como  uma  letra),  pelo  c  cedilha  e  pelas  vogais  acentuadas.  A  seguir,  procedemos  à 

identificação  da  maior  palavra  do  “alfabeto”.  Na  língua  portuguesa  ela  é,  supostamente, 

inconstitucionalissimamente, que possui 27 letras. A partir daí, afirmaremos que cada palavra 

da língua portuguesa pode ser escrita como um elemento de (cid:2418)(cid:2779)(cid:2784), o espaço das 27-uplas com 

entradas em (cid:2418), bastando colocar espaços em branco à direita de cada palavra, até atingir 27 

“letras”, e omitindo esses caracteres em branco na escrita. A partir dessa construção, podemos 

tomar alguns exemplos de como ocorre a detecção e a correção de erros neste código.  

Tomemos  uma  exemplificação.  Ao  ser  visualizada  a  palavra  “cathorro”  é  possível 

perceber que houve um erro, pois a referida palavra não pertence ao conjunto das palavras da 

língua portuguesa. Além disso, é admissível a correção por “cachorro”, haja vista que esta é a 

palavra da língua portuguesa que mais se assemelha a “cathorro”. 

Podemos  imaginar,  em  vista  do  exemplo  analisado,  que  a  língua  portuguesa  é  um 

excelente  código  corretor  de  erros.  Entretanto,  vamos  verificar,  a  seguir,  que  isso  não  é 

verdade. Para tanto, imaginemos que uma palavra foi  grafada como “aato”. Neste caso, não 

seria  possível  identificar  a  palavra  correta,  pois  “bato”,  “tato”,  “gato”,  “mato”  e  “rato” 

também são palavras próximas àquela que foi erroneamente grafada. Devido a isso, podemos 

dizer que o código não é muito eficiente, pois existem diversas palavras muito próximas umas 

das outras. 

Apesar  de  a  língua  portuguesa  não  ser  um  bom  código  corretor  de  erros,  conforme 

ilustrado,  esse  modelo  de  codificação  é  muito  útil,  pois  mostra,  simplificadamente,  como 

funciona um código. A partir dele podemos refletir sobre que características um bom código 

deve possuir para ser capaz de detectar e corrigir erros.  

A  reflexão  elencada  é  justamente  o  objeto  de  estudo  da  chamada  de  Teoria  dos 

Códigos. Por meio dela são pesquisadas as formas de obtenção de bons códigos corretores de 

erros, que são aqueles capazes de detectar e corrigir erros com certa precisão. Segundo Villela 

 5

 
 
 
 
 
 
e  Hefez  (2008, p.  i),  “um  código  corretor de  erros  é,  em  essência,  um  modo organizado de 

acrescentar  algum dado  adicional  a  cada  informação que  se  queira transmitir  ou  armazenar, 

que permita, ao recuperar a informação, detectar e corrigir erros”.  

Um  exemplo  interessante  e  que  ilustra  como  funciona  um  código  que  consegue 

corrigir erros é o do código robô (Villela e Hefez, 2008, p. 2). Supõe-se que um robô esteja 

sobre um tabuleiro quadriculado e que seja capaz de se movimentar segundo quatro comandos 

apenas: Leste, Oeste, Norte, Sul. Assim, ao receber o comando, o robô se desloca do centro da 

casa que ocupa no tabuleiro para o centro da casa contígua indicada.  

Para  transmitir  a  informação  ao  robô,  utiliza-se  o  sistema  binário,  criando-se  um 

código de fonte segundo especificado a seguir: 

Tabela 1 

FONTE 

CÓDIGO DA FONTE 

Leste 

Oeste 

Norte 

Sul 

00 

01 

10 

11 

Fonte: Adaptação do exemplo apresentado por Villela e Hefez (2008, p.2). 

Porém,  ao  efetuar  a  transmissão  dos  dados  ao  robô,  pode  ocorrer  do  código  00  ser 

recebido como 10, por exemplo, o que acarretaria na impossibilidade de identificação do erro 

cometido. É nesse momento que se verifica a existência da necessidade de acrescentar mais 

informações  –  chamadas  de  redundâncias.  Assim,  ao  serem  adicionadas  as  mencionadas 

redundâncias,  é  criado  um  código  de  canal,  o  qual  permitirá  a  identificação  e  correção  de 

erros. 

CÓDIGO DA FONTE 

CÓDIGO DE CANAL 

Tabela 2 

00 

01 

10 

11 

00000 

01011 

10110 

11101 

Fonte: Adaptação do exemplo apresentado por Villela e Hefez (2008, p.2) 

 6

 
 
 
 
 
 
 
Dessa maneira, após a nova codificação, se houver um erro de transmissão de alguma 

palavra, por exemplo, se 10110 for recebido como 11110, além de ser possível a verificação 

de que houve um erro na transmissão, pois essa palavra não está nas relacionadas pelo código 

de  canal,  também  será  possível  a  busca  pela  palavra  correta.  Para  tanto,  será  procedida  a 

verificação  de  qual  palavra  está  mais  próxima  a  que  fora  transmitida,  ou  seja,  a  palavra 

recebida  é  comparada  com  todas  as  palavras  do  código  e  é  verificada  qual  delas  possui  a 

menor de quantidade de dígitos diferentes. No caso do exemplo anterior, obter-se-á a palavra 

10110  –  a  quantidade  de  caracteres  diferentes  entre  a  palavra  11110  e  as  palavras  00000, 

01011, 10110, 11101 é, respectivamente, quatro, três, um e dois. 

Um esquema do que é efetuado para transmissão da mensagem está na figura a seguir:  

Figura 1 
Fonte: Um Primeiro Curso sobre Códigos Corretores de Erros.  
Disponível em http://www.ufsj.edu.br/portal2-repositorio/File/i-ermac/anais/minicursos/mc8.pdf.  

Por meio do desenho, podemos observar que antes da transmissão da informação cada 

elemento do código de fonte é transformado em elemento do código de canal. A informação, 

então,  é  transmitida  –  podem  ocorrer  erros  –  e,  ao  ser  recebida,  o  decodificador  de  canal 

identifica e corrige erros – quando é possível a identificação e correção. Em seguida, a palavra 

é transformada na linguagem inicial para que o usuário possa entendê-la. 

É  importante  ressaltar  que  no  exemplo  apresentado  anteriormente  nada  foi  elencado 

sobre o aspecto probabilístico presente na teoria dos códigos. Da mesma forma procederemos 

em todos os demais exemplos que serão apresentados. Ou seja, estaremos considerando que, 

para ocorrer a transmissão e a recepção de mensagens com certo grau de certeza, devem ser 

 7

 
 
 
 
 
 
 
consideradas  conhecidas  a  quantidade  de  erros  e  também  não  deve  haver  diferença 

probabilística  de  erro  entre  os  símbolos  transmitidos.  Isto  significa  que  todos  os  caracteres 

têm  a  mesma  probabilidade  de  serem recebidos  errados  (por  exemplo,  a probabilidade  de o 

elemento “0” ser recebido com erro é a mesma de o elemento “1” ser recebido com erro) e 

que  a  probabilidade  de  um  símbolo  transmitido  com  erro  ser  qualquer  um  dos  demais 

caracteres do código é a mesma (por exemplo, se na palavra o caractere “0” foi transmitido 

com erro, a probabilidade de ele ser 1, 2, 3, ou qualquer outro é a mesma).  

Procedendo-se  em  conformidade  com  os  parâmetros  acima,  podemos  citar  outra 

situação em que é apresentado um bom código. Suponhamos que um indivíduo deseja enviar 

uma  mensagem  da  forma  (x,y,z),  em  que  x,  y,  z  ∈  {0,  1},  e  que  de  alguma  forma  foi 

identificado  que  o  canal  causa  um  erro  em  cada  seis  dígitos  consecutivos.  Dessa  maneira, 

haverá  erro  em  uma  mensagem  a  cada  duas  enviadas.  Sabendo  disso,  para  tentar  corrigir  o 

erro, o emissor  faz algumas  tentativas.  Na primeira  hipótese,  ele  envia  a  mesma  mensagem 

duas vezes. Por exemplo, ele envia (x, y, z) (x,  y, z) e recebe (x,  y, z) (y,  y, z). Nesse caso, 

não há como o receptor saber se a mensagem correta é (x, y, z) ou (y, y, z) e ele apenas tem 

certeza  de  que  dois  dos  dígitos  estão  corretos  –  o  segundo  e  o  terceiro,  pois  se  repetiram. 

Como  o  envio  de  duas  mensagens  não  permitiu  a  identificação  da  mensagem  correta,  o 

emissor decide, então, fazer outra tentativa. Desta vez ele faz o envio da mesma mensagem 

três  vezes.  Nessa  situação,  o  receptor  conseguirá  identificar  o  erro  e  obterá  a  mensagem 

correta. Porém, essa última tentativa gerou um custo computacional muito grande – envio de 

nove caracteres para receber uma mensagem de três. Uma alternativa para enviar a mensagem 

com custo computacional menor é acrescentar três redundâncias da seguinte maneira: (x, y, z, 

x + y, x + z, y + z). Como x, y, z ∈ {0, 1} devemos observar que a soma realizada é a soma 

módulo 2, ou seja, no sistema binário, onde 0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1 e 1 + 1 = 0. 

Vamos  entender  porque  essa  última  configuração  funciona.  Suponhamos  que  foi 

recebida a mensagem (a, b, c, d, e, f) na qual já se sabe que há apenas um erro – a, b, c, d, e, f 

pertencem ao sistema binário. Diante disso, o receptor calcula a + b. Se a + b = d, tem-se que 

a, b, d estão corretos e o erro está em c, e ou f. Como o c aparece três vezes (em c, em e, pois 

e = a + c, em f, pois f = b + c), comparando-se esses itens é possível  verificar que c será o 

valor que ocorrer duas vezes, sendo possível, portanto, obter a mensagem correta. Por outro 

lado,  se  a +  b  ≠  d, um  dos  três  (a,  b  ou  d)  está  errado.  Daí,  c  está correto,  e  = a  +  c  está 

correto, e f = b + c está correto. Portanto, como os caracteres c e e estão corretos, obtêm-se a. 

De  modo  semelhante,  como  f  e  c  estão  corretos,  obtêm-se  b.  Assim,  o  receptor  consegue 

corrigir o erro da mensagem. 

 8

 
 
Agora que já determinamos o que é e entendemos como funciona um código corretor 

de erro, vamos definir os elementos de um código. 

2.2 Principais Conceitos Relacionados aos Códigos 

Nesta  seção  serão  apresentados  os  conceitos  básicos  sobre  os  códigos  corretores  de 

erros. 

Começaremos pelo alfabeto.  Ele  é o primeiro  conjunto  necessário  para  construir um 

código  corretor  de  erros.  No  exemplo  do  código  robô,  o  alfabeto  escolhido  foi  o  conjunto      
(cid:2418)(cid:2870) = {0, 1}.6  

Vamos definir este importante conjunto. 

Definição 2.1. O alfabeto é um conjunto finito com q elementos ((cid:2418)(cid:3044)).  

Passemos, então, à próxima etapa. Escolhido o alfabeto, vamos formar sequências de 

caracteres com os símbolos do mencionado conjunto, a fim de codificarmos os elementos da 

fonte.  Em  seguida,  acrescentaremos  as  redundâncias.  Ao  final  desse  processo, obteremos  as 

denominadas  palavras.  O  número de  letras  das  palavras  é  chamado de  comprimento. Para 

facilitar na codificação e decodificação são convencionadas palavras de mesmo comprimento 

n.  Por  isso,  esses  códigos  também  são  chamados  de  códigos  em  blocos.  No  exemplo  do 

código robô, as palavras tinham comprimento n = 5.  

Por  meio do  exemplificado,  verificamos a  importância  da  existência  de um  conjunto 

(cid:2418)(cid:3044),  a  fim  de  que um  elemento  da  fonte  possa  ser  codificado  em  elemento  de  canal  e,  além 

disso,  a  necessidade  de  que  seja  estabelecido  um  comprimento  n  para  as  palavras  de  um 

código. Isso nos leva à próxima definição.  

Definição 2.2. (Código) Um código C é um subconjunto de (cid:2418)(cid:3044)

(cid:3041), em que  

(cid:3041) = {(a1, a2, ... , an) / ai 

(cid:2418)(cid:3044)

Î

 (cid:2418)(cid:3044) , 1  i 

£ £

 n }. 

O código criado é chamado de código q-ário de comprimento n.  

6 O conjunto {0, 1} é chamado de Z2. Ele é utilizado para representar os códigos criados no sistema binário de 
numeração. 

 9

 
 
 
 
 
 
 
 
 
 
 
 
 
                                                 
No caso do código robô, o código escolhido foi o conjunto C = {00000, 01011, 10110, 

11101} ⊂ (cid:2418)(cid:2870)
elementos 0 e 1 em cinco posições diferentes.  

(cid:2873) – o conjunto ℤ(cid:2870)

(cid:2873) = ℤ(cid:2870)

(cid:2873)  possui 32 elementos obtidos pela permutação simples dos 

Vamos prosseguir com mais definições. 

Definição  2.3.  (Distância  de  Hamming)  Dados  dois  elementos  x,  y  ∈  (cid:2418)(cid:3044)

(cid:3041),  a  distância  de 

Hamming entre x e y é definida como o cômputo da quantidade de vezes em que os caracteres 

de  mesma ordem diferem  nas  palavras.  Ou  seja, se  x = ((cid:1876)(cid:2869), (cid:1876)(cid:2870), … , (cid:1876)(cid:3041))  e  y = ((cid:1877)(cid:2869), (cid:1877)(cid:2870), … , (cid:1877)(cid:3041)), 

então 

d (x, y) = |{ i; (cid:1876)(cid:3036) ≠   (cid:1877)(cid:3036), 1 ≤ i ≤ n }| . 

Por exemplo, em {0, 1}4, verificamos que:  

d (0001, 1111) = 3; 

d (0000, 1111) = 4; 

d (1001, 1101) = 1. 

Definição 2.4. (Métrica) Uma função d: A x A →  ℝ é uma métrica se satisfaz as seguintes 

condições: 

i)  d (x, y) ≥ 0, 

"

 x, y ∈ A, sendo válida a igualdade se, e somente se, x = y; 

ii)  d (x, y) = d (y, x), 

"

 x, y ∈ A (propriedade simétrica); 

iii) d (x, y) ≤ d (x, p) + d (p, y),  " x, y, p ∈ A (desigualdade triangular). 

Teorema 2.1. A distância de Hamming é uma métrica. 

É imediata a constatação de que a distância de Hamming satisfaz as propriedades (i) e 

(ii). Vamos demonstrar que ela também satisfaz o item (iii). 

Demonstração: A contribuição das i-ésimas coordenadas de x e y para d (x, y) é igual a zero 

se (cid:1876)(cid:3036) = (cid:1877)(cid:3036), e igual a 1 se (cid:1876)(cid:3036) ≠ (cid:1877)(cid:3036). Assim, temos duas situações para verificar. 

A  primeira  é  aquela  em  que  a  contribuição  é  zero.  Nesse  caso,  é  certo  que  a 

contribuição das i-ésimas coordenadas a d (x, y) é menor ou igual a das i-ésimas coordenadas 

a d (x, p) + d (p, y), que podem ser 0, 1 ou 2 (0 ≤ 0, 0 ≤ 1 ou 0 ≤ 2). 

 10 

 
 
 
 
 
 
 
 
A segunda hipótese é aquela em que a contribuição é 1. Nessa situação, temos (cid:1876)(cid:3036) ≠ (cid:1877)(cid:3036) 

e,  então,  não  podemos  ter  (cid:1876)(cid:3036) = (cid:1868)(cid:3036)  e  (cid:1868)(cid:3036)(cid:2880)(cid:1877)(cid:3036).  Se  esse  último  resultado  acontecesse,  teríamos 

(cid:1876)(cid:3036) = (cid:1877)(cid:3036) e a contribuição seria zero, o que contraria nossa hipótese. A consequência do exposto 

é que a contribuição das i-ésimas coordenadas de d (x, p) + d (p, y) é maior ou igual a 1, que 

é o valor da contribuição das i-ésimas coordenadas de d (x, y). (cid:0) 

Definição 2.5. (Disco e esfera de centro em v e raio t) Seja v um elemento de (cid:2418)(cid:3044)

(cid:3041) e t ≥ 0 um 

número inteiro.  

Define-se  o  disco  de  centro  v  e 

raio 

t  como 

sendo  o  conjunto                                       

D (v, t) = {u ∈ (cid:2418)(cid:3044)

(cid:3041)/d (u, v) ≤ t}, ou seja, o conjunto dos elementos u de (cid:2418)(cid:3044)

(cid:3041) cuja distância até v 

seja menor do que ou igual ao número inteiro t.  

Define-se  a  esfera  de  centro  v  e 

raio 

t  como 

sendo  o  conjunto                                       

S (v, t) = {u ϵ (cid:2418)(cid:3044)

(cid:3041) /d (u, v) = t}, ou seja, o conjunto dos elementos u de (cid:2418)(cid:3044)

(cid:3041) cuja distância até v 

é exatamente igual ao número inteiro t. 

Lema 2.1. O número de elementos do conjunto D (v, t) = {u ϵ (cid:2418)(cid:3044)

(cid:3041) / d (u, v) ≤ t} é 

(cid:3047)

| (cid:1830) ((cid:1874), (cid:1872))| =   (cid:3533) (cid:4672) 

(cid:3036)(cid:2880)(cid:2868)

(cid:1866)
(cid:1861)

 (cid:4673)

 ((cid:1869) − 1)(cid:3036). 

O número de elementos do conjunto S (v, t) = {u ϵ (cid:2418)(cid:3044)

(cid:3041) / d (u, v) = t} é  

| (cid:1845) ((cid:1874), (cid:1872))| = (cid:4672) 

(cid:1866)
(cid:1872)

 (cid:4673) ((cid:1869) − 1)(cid:3047). 

Demonstração: Sabemos que ao escolhermos dois pontos x e y podemos afirmar que y está a 

distância  t  de  x  se,  e  somente  se,  x  for  diferente  de  y  em  exatamente  t  posições  (definição 

2.3). Então, ao analisarmos a quantidade de elementos do conjunto S (v, t), podemos dizer que 

para efetuar a contagem devemos selecionar t posições fixas para serem alteradas – entre as 

que compõem v –, a fim de que sejam obtidas as palavras cuja distância até v seja t. Como em 

cada uma das posições podemos ter q – 1 caracteres do alfabeto diferentes, existem ((cid:1869) − 1)(cid:3047) 

palavras  de  (cid:2418)(cid:3044)

(cid:3041)  que  são  diferentes  de  v  nas  t  posições  fixadas.  Além  disso,  temos  (cid:4672)

(cid:1866)
(cid:1872)

(cid:4673) 

maneiras  distintas  para  escolher  t  posições  dentre  n  posições  possíveis  no  elemento  v. 

Portanto,  existem  exatamente  (cid:4672)

(cid:1866)
(cid:1872)

(cid:4673) ((cid:1869) − 1)(cid:3047)  pontos  na  esfera  S  (v,  t)  (este  resultado  nos 

permite afirmar que todas as esferas de raio t possuem o mesmo número de pontos). 

 11 

 
 
 
Como  as  distâncias  são  sempre  números  naturais,  dentro  de  um  mesmo  disco7  de 

centro v e raio t estão contidas todas as esferas do mesmo centro e de raios que são naturais 

menores ou iguais a t.  

Logo: 

(cid:3047)

(cid:1830)((cid:1874), (cid:1872)) =   (cid:4651) (cid:1845)((cid:1874), (cid:1872))

(cid:3047)(cid:2880)(cid:2868)

Ante ao exposto, podemos dizer que o número de pontos no disco de centro v e raio t é 

dado pela seguinte expressão: 

(cid:3047)

| (cid:1830) ((cid:1874), (cid:1872))| =   (cid:3533)(
(cid:3036)(cid:2880)(cid:2868)

(cid:1866)
(cid:1861)

 ) ((cid:1869) − 1)(cid:3036)  

(cid:0) 

Tomemos um exemplo. Suponhamos que um conjunto (cid:2418)(cid:2870) = {0, 1} foi utilizado como 
(cid:2871) = {(0,0,0), (0,0,1), (1,0,0), (1,0,1), (1,1,0), (1,1,1), 

alfabeto para obtenção de um conjunto (cid:2418)(cid:2870)
(0,1,1), (0,1,0)}. Em seguida, escolhemos a palavra v = (0,0,0) e o número inteiro t = 1. Como 

q  =  2  (número  de  letras  do  alfabeto)  e  n  =  3  (comprimento  das  palavras),  o  número  de 

elementos de | D (v, t) | é: 

(cid:2869)

|(cid:1830) ((cid:1874), 1)| = (cid:3533)(
(cid:3036)(cid:2880)(cid:2868)

3
(cid:1861)

3
 ) (2 − 1)(cid:3036) = (cid:4672) 
0

 (cid:4673) (2 − 1)(cid:2868) + (cid:4672) 

3
1

 (cid:4673) (2 − 1)(cid:2869) = 1 + 3 = 4, 

resultado  que  pode  ser  verificado  por  meio  do  conjunto  D  ((0,0,0),  1)  =  {(0,0,0),  (0,0,1), 

(1,0,0), (0,1,0)}, que possui quatro elementos. 

Tomando-se a palavra v = (0,0,0), novamente, e modificando-se o número inteiro para 

t = 2, obtêm-se o conjunto D ((0, 0, 0), 2) = {(0,0,0), (1,0,0), (0,1,0), (0,0,1), (1,0,1), (1,1,0), 

(0,1,1)},  que  possui  sete  elementos.  O  referido  valor  também  é  confirmado  por  meio  do 

cálculo:  

(cid:2870)

|(cid:1830) ((cid:1874), 2)| = (cid:3533)(
(cid:3036)(cid:2880)(cid:2868)

3
(cid:1861)

3
 ) (2 − 1)(cid:3036) = (cid:4672) 
0

 (cid:4673) (2 − 1)(cid:2868) + (cid:4672) 

3
1

3
 (cid:4673) (2 − 1)(cid:2869) + (cid:4672) 
2

 (cid:4673) (2 − 1)(cid:2870)

= 1 + 3 + 3 = 7. 

7 Milies chama os discos de “bolas” em [15] e [16].  

 12 

 
 
 
 
 
 
 
 
 
                                                
Definição  2.6  (Distância  mínima)  A  distância  mínima  de  um  código  C  é  o  número                

d = min {d(x, y); x, y ∈ C e x ≠ y}.   

Por exemplo, no código robô temos que d = 3, pois: 

d(00000, 01011) = 3; 

d(00000, 10110) = 3; 

d(00000, 11101) = 4; 

d(01011, 10110) = 4; 

d(01011, 11101) = 3; 

d(11101, 10110) = 3. 

Para calcular d deve ser avaliada a distância entre as palavras uma quantidade de vezes 

igual a (cid:4672) 

(cid:1839)
2

 (cid:4673), onde M é o número de palavras do código (combinação entre todas as palavras, 

duas a duas). Todavia, existe uma forma mais prática, com custo computacional melhor, que 

será apresentada posteriormente8. 

Definição 2.7. (Parâmetro k) Em um código C com distância mínima d define-se κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675), 

onde [ x ] representa a parte inteira do número x. 

Teorema  2.2.  Utilizando-se  o  parâmetro  κ,  é  possível  constatar  que  se  x  e  y  são  palavras 

distintas de um código C, então D(x, κ) ∩ D(y, κ) = ∅. 

Demonstração: De fato, se uma palavra p pertencesse a D (x, κ) ∩ D (y, κ), então teríamos                 

d (p, x) ≤ κ e d (p, y) ≤ κ e, portanto, d (x, y) ≤ d (x, p) + d (p, y) ≤  2κ  ≤ d – 1, o que é um 

absurdo  já  que  d  (x,  y)  ≥  d,  haja  vista  que  x  e  y  são  palavras  do  código  e  d  é  a  distância 

mínima . (cid:0) 

Diante  do  que  foi  exposto  nas  definições  e  considerações  anteriores,  podemos 

apresentar, agora, o resultado principal da seção, que é o teorema que trata da quantidade de 

erros que podem ser detectados e corrigidos em um código. 

8 Voltaremos a esse assunto no capítulo 3, quando será definido o peso de um código. 

 13 

 
 
 
 
 
 
 
 
 
 
 
                                                 
Teorema 2.3 Seja C um código com distância mínima d. Então C pode corrigir até k = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:4675) 
(cid:2870)

erros e detectar até d – 1 erros.  

Demonstração:  Se  na  transmissão  de  uma  palavra  x  do  código  ocorrem  t  erros,  com  t ≤  κ, 

será recebida uma palavra y com d (x, y) = t ≤ κ. Daí, y ∈ D(x, κ) e, pelo exposto no teorema 

2.2, y ∉ D(x’, κ) para x ≠ x’, podendo-se concluir que d (x, y) é menor do que a distância de y 

a  qualquer  outra  palavra  do  código  e,  dessa  forma,  obtêm-se  x  a  partir  de  y.  Quanto  à 

quantidade de erros, como a distância mínima entre duas palavras do código C é d, tem-se que 

se a palavra x é recebida como y, com até d – 1 erros, pode-se verificar que y ∉ C, pois d (x, 

y) < d.  (cid:0) 

Por  exemplo,  no  código  robô  verificamos  que  d  =  3  (exemplo  apresentado  na 

definição  2.6).  Dessa  forma,  pelo  teorema  acima,  podemos  dizer que  o  mencionado  código 

corrige κ = (cid:4674)(cid:2871)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 1 erro e detecta até 3 – 1 = 2 erros.  

2.3 O Problema Principal da Teoria dos Códigos 

O principal problema da teoria dos códigos é estudar a relação entre os parâmetros n 

(comprimento das palavras do código), M (quantidade de palavras) e d (distância mínima). Os 

códigos que mais interessam são aqueles em que M e d sejam grandes relativamente a n, ou 

seja,  códigos  capazes  de  transmitir  bastante  informação  (M  é  relativamente  grande)  e  boa 

capacidade  de  correção  (d  é  relativamente  grande).  Infelizmente,  achar  uma  boa  correlação 

entre  n,  M  e  d  é  algo  complicado,  pois  quando  se  aumenta  o  número  de  palavras  de  um 

código,  naturalmente  a  distância  mínima  entre  elas  diminui.  Assim,  é  em  busca  da  melhor 

forma de correlacionar os três parâmetros que faremos as considerações a seguir. 

Inicialmente, fixemos n e analisemos a relação que deve existir entre M e d. Conforme 

demonstramos por meio do lema 2.1, se x ϵ (cid:2418)(cid:3044)

(cid:3041), então 

(cid:3047)

| (cid:1830) ((cid:1876), (cid:1872))| =   (cid:3533)(
(cid:3036)(cid:2880)(cid:2868)

(cid:1866)
(cid:1861)

 ) ((cid:1869) − 1)(cid:3036). 

Além  disso,  de  acordo  com  o  teorema  2.2,  todos  os  discos  com  centro  em  pontos 

diferentes do código C e raio κ tem interseção vazia. Assim, verificamos que  

 14 

 
 
 
 
 
 
 
 
 
 
e, então, 

(cid:4651) (cid:1830)((cid:1876), (cid:2018))
(cid:3051)∈(cid:3004)

(cid:3041) 
⊂ (cid:2418)(cid:3044)

(cid:3533) |(cid:1830)((cid:1876), (cid:2018))| ≤ (cid:1869)(cid:3041)
(cid:3051)∈(cid:3004)

. 

Portanto, se considerarmos que o código possui M palavras, podemos dizer que 

(cid:3089)

(cid:1839) [ (cid:3533)(
(cid:3047)(cid:2880)(cid:2868)

(cid:1866)
(cid:1872)

 ) ((cid:1869) − 1)(cid:3047)] ≤ (cid:1869)(cid:3041). 

Ante  ao  apresentado,  obtermos  uma  limitação  para  o  número  de  palavras  de  um 

código, considerando conhecidos o seu comprimento e a distância mínima. 

O resultado acima é conhecido como Cota de Hamming: 

(cid:1839)  ≤

(cid:1869)(cid:3041)

(cid:3089)
∑ (
(cid:3047)(cid:2880)(cid:2868)

(cid:1866)
(cid:1872)

 ) ((cid:1869) − 1)(cid:3047)

Definição  2.8.  (Código  Perfeito)  Um  código  C  ⊂  (cid:2418)(cid:3044)

(cid:3041)  com  distância  mínima  d  é  dito  um 

código perfeito se  

(cid:3041)
(cid:4651) (cid:1830)((cid:1855), (cid:1863)) = (cid:2418)(cid:3044)
(cid:3030)∈(cid:3004)

 , 

onde k = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675). Ou seja, se o código C tem M palavras, comprimento n, e distância mínima d, 

então ele é um código perfeito se, e somente se  

(cid:3038)

(cid:1839)[ (cid:3533)(

(cid:3047)(cid:2880)(cid:2868)

(cid:1866)
(cid:1872)

)((cid:1869) − 1)(cid:3047)] = (cid:1869)(cid:3041) 

A condição citada é chamada de condição de empacotamento9. 

A importância de o código ser perfeito é manifesta na seguinte situação. Suponhamos 

que uma mensagem seja recebida e que seja constatada a ocorrência de erro na transmissão. 

Procede-se, então, à verificação de qual disco contém a mensagem e, dessa forma, é possível 

efetuar  a  correção  do  erro,  assumindo  que  a  mensagem  correta  é  aquela  mais  próxima  da 

9 Vide referência bibliográfica [16]. 

 15 

 
 
 
 
 
 
 
 
 
 
                                                 
recebida, ou seja, o centro do disco. O problema é que algumas vezes ocorre de a mensagem 

não  pertencer  a  nenhum  dos  discos,  o  que  impossibilita  a  sua  correção.  Todavia,  em  se 

tratando de códigos perfeitos, isso não acontece. 

Por exemplo, o código robô não é um código perfeito. Vejamos porquê. O código robô 

foi definido como o conjunto C = {00000, 01011, 10110, 11101} ⊂ (cid:2418)(cid:2870)
os conjuntos D (00000, 1), D (01011, 1), D (10110, 1) e D (11101, 1). Temos que: 

(cid:2873) = ℤ(cid:2870)

(cid:2873). Vamos escrever 

D (00000, 1) = {00000, 10000, 01000, 00100, 00010, 00001} 

D (01011, 1) = {01011, 11011, 00011, 01111, 01001, 01010} 

D (10110, 1) = {10110, 00110, 11110, 10010, 10100, 10111} 

D (11101, 1) = {11101, 01101, 10101, 11001, 11111, 11100} 

Fazendo  a  união  dos  conjuntos  D  (00000,  1),  D  (01011,  1),  D  (10110,  1)  e                  

D  (11101, 1)  não obtemos o conjunto ℤ(cid:2870)
caracteriza os códigos perfeitos. 

(cid:2873).  Ou  seja,  esse  código não  satisfaz  a  condição que 

2.4 Uma Estratégia para Detectar e Corrigir Erros 

O teorema 2.3 permite traçar uma estratégia para detecção e correção de erros. Seja C 

um código com distância mínima d, que corrige até k = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) erros. Quando o receptor recebe 

uma palavra r, uma das seguintes situações é verificada: 

a)  a  palavra  r  está  em  algum  disco de raio  κ  em  torno de uma palavra  c  do  código 

(essa palavra é única, pela prova do teorema 2.2). Nesse caso, substitui-se r por c; 

b)  a palavra r não se encontra em nenhum disco de raio κ em torno de uma palavra c 

do código. Então, não é possível decodificar r com boa margem de segurança10. 

Observemos que em (a) não se pode ter certeza absoluta de que c tenha sido a palavra 

transmitida, pois poderíamos ter cometido mais do que κ erros, afastando assim r da palavra 

transmitida  e  aproximando-a  de  outra  palavra  do  código.  Observemos,  também,  que  a 

hipótese (b) não ocorre em códigos perfeitos. 

10 A estratégia de correção transcrita foi proposta por Hefez e Villela (2008, p. 7). Devemos ressaltar que o item 
(b) somente é verdadeiro quando o código for linear. 

 16 

 
 
 
 
 
 
 
                                                 
Exemplificando  a  estratégia  acima  por  meio  do  código  robô,  vamos  realizar  a 

verificação da possibilidade de decodificação das palavras 01011, 01101, 11011 e 10001.  

Inicialmente, calcula-se o disco de raio 1 em torno de cada palavra do código: 

D (00000, 1) = {(00000, 00001, 00010, 00100, 01000, 10000)} 

D (01011, 1) = {(01011, 11011, 00011, 01111, 01001, 01010)} 

D (10110, 1) = {(10110, 00110, 11110, 10010, 10100, 10111)} 

D (11101, 1) = {(11101, 01101, 10101, 11001, 11111, 11100)} 

Conforme  já  foi  afirmado,  o  código  robô  não  é  perfeito,  pois  a  união  dos  conjuntos 

anteriores não é o conjunto (cid:2418)(cid:2870)

(cid:2873). Agora, procede-se à análise de cada palavra. 

a)  a palavra 01011 ∈ D(01011, 1) e, portanto, a palavra foi enviada sem erros; 

b)  a palavra 01101 ∈ D(11101, 1) e, portanto, a palavra correta é 11101; 

c)  a palavra 11011 ∈ D(01011, 1) e, portanto, a palavra correta é 01011; 

d)  a palavra 10001 não pertence aos conjuntos dos discos de raio 1 em torno de cada 

palavra do código e, então, não é possível decodificar essa palavra com segurança. 

Além disso, d(00000, 10001) = 2 e d(11101, 10001) = 2, o que confirma não ser 

possível estimar qual a palavra código foi transmitida. 

É  importante  destacar  que  não  há  como  ter  certeza  absoluta  de  que  a  decodificação 

acima está correta, pois podem ter sido cometidos mais de κ erros – no caso da questão, foi 

utilizado κ =1 nas primeiras três mensagens.  

 17 

 
 
 
 
 
3 CÓDIGOS LINEARES 

A classe de códigos mais utilizada é a dos lineares. Para entendê-la será necessária a 

observação prévia de alguns conceitos da Álgebra Linear, o que será feito a seguir. 

3.1 Conceitos Auxiliares 

Definição  3.1.  (Corpo)  Um  conjunto  K  é  chamado  de  corpo  se  ele  for  munido  de  duas 

operações e satisfizer as seguintes condições: 

1) A adição é associativa: (a + b) + c = a + (b + c),  " a, b, c ∈ K; 

2) A adição é comutativa: a + b = b + a,  " a, b ∈ K; 

3) A adição possui elemento neutro: ∃ 0 ∈ K, tal que a + 0 = a,  " a ∈ K; 

4) A adição possui simétrico:  " a ∈ K, ∃  –a ∈ K tal que a + (–a) = 0; 

5) A multiplicação é associativa: (a x b) x c = a x (b x c),  " a, b, c ∈ K; 

6) A multiplicação é comutativa: a x b = b x a,  " a, b ∈ K; 

7) A multiplicação possui elemento neutro: ∃ 1 ∈ K\{0}, tal que a x 1 = a,  " a ∈ K; 

8) A multiplicação possui inversos:  " a ∈ K\{0},∃  a-1 ∈ K tal que a x a-1 = 1; 

9) A multiplicação é distributiva com relação à adição: a x (b + c) = a x b + a x c,  " a, 

b, c ∈ K. 

Os  conjuntos  numéricos  ℚ, ℝ (cid:1857) ℂ  satisfazem  as  condições  acima  e  por  isso  são 

classificados como corpos.  

Definição 3.2. (Espaço Vetorial) Um conjunto V é dito um espaço vetorial sobre um corpo 

K, se possui uma adição (+) com as seguintes propriedades: 

1) A adição é associativa: (u + v) + w = u + (v + w),  " u, v, w ∈ V ; 

2) A adição é comutativa: u + v = v + u,  " u, v ∈ V; 

3) A adição possui elemento neutro (elemento zero): ∃ 0 ∈ V , tal que v + 0 = v,  "v ∈ 

V; 

4) A adição possui simétricos:  " v ∈ V , ∃ – v ∈ V tal que v + (– v) = 0; 

 18 

 
 
 
 
 
 
 
 
e  existe,  ainda,  uma  operação  chamada  de  multiplicação  por  escalar,  que  associa  a  um 

elemento a ∈ K e a um elemento v ∈ V, um elemento av ∈ V, tal que 

5) a(u + v) = au + av,   " a ∈ K e u, v ∈ V; 

6) (a1 + a2) v = a1 v + a2 v,  " a1, a2 ∈ K e v ∈ V; 

7) (a1 a2) v = a1 (a2 v),  "a1, a2 ∈ K e v ∈ V; 

8) 1 v = v,  "v ∈ V. 

Os elementos do conjunto V são chamados de vetores e os elementos do corpo K de 

escalares. 

Definição 3.3. (Subespaço Vetorial) Sejam V um espaço vetorial e W um subconjunto não 

vazio de V. Dizemos que W é um subespaço vetorial de V, ou simplesmente um subespaço de 

V,  se  W,  com  as  operações  de  adição  em  V  e  de  multiplicação  por  escalares,  é  um  espaço 

vetorial. 

Simplificando  a verificação,  W  é  um  subespaço de  V se,  e  somente  se,  as  seguintes 

condições são satisfeitas: 

(i) 0 ∈ W 

(ii) se u, v ∈ W, então u + v ∈ W; 

(iii) se a ∈ K e u ∈ W, então a.u ∈ W. 

Por exemplo, o conjunto W = {(x, y); x + y = 0} é um subespaço vetorial de ℝ(cid:2870), pois: 

(i) (0, 0) ∈ W, se fizermos x = y = 0, temos 0 + 0 = 0; 

(ii)  se  (a,  b)  e  (c,  d)  ∈  W,  então  a  +  b  =  0  e  c  +  d  =  0.  Daí,  ao  efetuar  a  soma                

(a, b) + (c, d), obtemos o par (a + c, b + d) no qual a + c + b + d = a + b + c + d = 0 + 0 = 0 e, 

portanto, (a, b) + (c, d) ∈ W; 

(iii)  se  k  ∈  ℝ  e  (a,  b)  ∈  W,  então  k  (a,  b)  =  (ka,  kb)  ∈  W,  pois                                       

ka + kb = k (a + b) = k 0 = 0 (já que a + b = 0, pois (a, b) ∈ W). 

Já  o  conjunto  W  =  {(x,  y);  x  +  y  =  1}  não  é  um  subespaço  vetorial  de  ℝ(cid:2870),  pois              

0 = (0, 0) ∉ W. 

 19 

 
 
 
 
 
 
   
 
 
Verifiquemos,  agora,  uma  maneira  de  descobrir  o  subespaço  vetorial  gerado por um 

conjunto de vetores. 

Para isso, vamos apresentar, inicialmente, o que é uma combinação linear. Se V é um 

espaço  vetorial  e  (cid:1874)(cid:2869), (cid:1874)(cid:2870), … , (cid:1874)(cid:3045)  são  vetores  de  V,  então  dizemos  que  um  vetor  v  de  V  é  a 

combinação  linear  de (cid:1874)(cid:2869), (cid:1874)(cid:2870), … , (cid:1874)(cid:3045)   se  existirem  escalares  (cid:1853)(cid:2869), (cid:1853)(cid:2870), … , (cid:1853)(cid:3045) pertencentes  a  K  tais 

que  

(cid:1874) = (cid:1853)(cid:2869)(cid:1874)(cid:2869) + (cid:1853)(cid:2870)(cid:1874)(cid:2870) +  … + (cid:1853)(cid:3045)(cid:1874)(cid:3045) 

Por exemplo, o vetor (1, 6, 0) ∈ ℝ(cid:2871) é combinação linear dos vetores (1, 2, 0) ∈ ℝ(cid:2871) e    

(-1, 2, 0) ∈ ℝ(cid:2871), pois (1, 6, 0) = 2 (1, 2, 0) + 1 (-1, 2, 0). Por outro lado, o vetor (2, -2, 6) ∈

ℝ(cid:2871) não é combinação linear dos vetores (1, 2, 0) e (-1, 2, 0), pois não é possível encontrar a1 e 

a2  reais  tais  que  (2,  -2,  6)  =  a1  (1,  2,  0)  +  a2  (-1,  2,  0).  Isso  ocorre  porque  o  sistema  de 

equações lineares 

é impossível. 

(cid:3421)

(cid:1853)(cid:2869) − (cid:1853)(cid:2870) = 2
2. (cid:1853)(cid:2869) + 2. (cid:1853)(cid:2870) = −2
0. (cid:1853)(cid:2869) + 0. (cid:1853)(cid:2870) = 6

De  posse  dos  mesmos  vetores  do  ℝ(cid:2871)  do  parágrafo  anterior,  (1,  2,  0)  e  (−1,  2,  0), 

podemos  identificar  qual  o  conjunto  gerado  por  eles.  Para  isso,  basta  encontrarmos  um 

elemento genérico (x,  y, z)  ∈ ℝ(cid:2871) como combinação linear dos vetores (1, 2, 0) e (−1, 2, 0). 

Então, se tomarmos os números (cid:1853), (cid:1854) ∈  ℝ, podemos escrever a combinação dos vetores como 

(x, y, z) = a (1, 2, 0) + b (−1, 2, 0). 

O sistema de equações referente ao descrito acima é 

(cid:1853) − (cid:1854) = (cid:1876)
(cid:3421)
2. (cid:1853) + 2. (cid:1854) = (cid:1877)
0. (cid:1853) + 0. (cid:1854) = (cid:1878)

 , 

o  qual  só  possui  solução  se  z  = 0.  Ou  seja,  os  vetores  (1,  2,  0)  e  (−1,  2,  0)  geram  o  plano        

z = 0. 

Dessa  forma,  exemplificamos  que  ao  considerarmos  o  conjunto  de  todas  as 

combinações lineares dos vetores (cid:1874)(cid:2869), (cid:1874)(cid:2870), … , (cid:1874)(cid:3045) de V, obteremos um subespaço vetorial W de 

V, cujo conjunto gerador é {(cid:1874)(cid:2869), (cid:1874)(cid:2870), … , (cid:1874)(cid:3045)}.  

Todavia, em geral pode haver mais de uma forma de escrever um vetor de W como a 

combinação linear de vetores de um conjunto gerador. De fato, o ℝ(cid:2871), por exemplo, pode ser 

gerado pelos  vetores  (1,1,1),  (1,1,0),  (0,1,1)  e  (1,0,1)  ou  pelos  vetores  (1,  0,  0),  (0,  1,  0)  e      

 20 

 
 
 
 
 
 
 
 
 
(0, 0, 1). Então, ao observamos o vetor (4, 2, 1) do ℝ(cid:2871), verificamos que ele pode ser escrito 

como: 

(4,2,1) = 1 (1,1,1) + 2 (1,1,0) – 1 (0,1,1) + 1 (1,0,1) ou 

(4,2,1) = – 1 (1,1,1) + 2 (1,1,0) + 0 (0,1,1) + 2 (1,0,1). 

Ante o apresentado, a fim de que a maneira de obtenção de um vetor de um subespaço 

vetorial  seja  única,  é  necessário  utilizar  um  conjunto  gerador  que  tenha  uma  característica 

específica, ou seja, é preciso encontrar um conjunto linearmente independente. 

Podemos  dizer  que  um  conjunto  de  vetores  (cid:1874)(cid:2869), (cid:1874)(cid:2870), … , (cid:1874)(cid:3045)  de  um  espaço  Vetorial  V  é 

linearmente independente, se a equação  

(cid:1853)(cid:2869)(cid:1874)(cid:2869) + (cid:1853)(cid:2870)(cid:1874)(cid:2870) +  … + (cid:1853)(cid:3045)(cid:1874)(cid:3045) = 0 , 

é satisfeita se, e somente se,  (cid:1853)(cid:2869) =   (cid:1853)(cid:2870) =   … =   (cid:1853)(cid:3045) = 0. Caso exista algum ai ≠ 0, 1 ≤ i ≤ n, 

dizemos que os vetores são linearmente dependentes.  

Os resultados acima nos levam à próxima definição. 

Definição  3.4.  (Base  e  Dimensão)  Um  conjunto  {(cid:1874)(cid:2869), (cid:1874)(cid:2870), … , (cid:1874)(cid:3045)}  de  vetores  de  um  espaço 

vetorial V é uma base de V se esse conjunto é linearmente independente e se ele gera o espaço 

V. Quando isso acontece, cada vetor de V pode ser escrito de modo único como a combinação 

linear dos vetores da base. 

O número de elementos de uma base de um espaço vetorial V é chamado de dimensão 

de V. Se V for o espaço vetorial nulo, então sua dimensão é 0. 

Por exemplo, o conjunto {(1,0,0), (0,1,0), (0,0,1)} é linearmente independente e gera o 

ℝ(cid:2871). Portanto, ele é uma base do ℝ(cid:2871). A dimensão desse espaço vetorial é 3. 

Definição  3.5.  (Transformação  linear)  As  funções  de  interesse  da  Álgebra  Linear  são  as 

funções cujos domínios e contradomínios são espaços vetoriais e que, além disso, preservam 

as operações de adição de vetores e de multiplicação de um vetor por um escalar.  

Assim, tomando-se os espaços vetoriais V e W sobre um corpo K, dizemos que uma 

transformação  linear  de  V  em  W  é  uma  função  T  :  V  →  W  que  possui  as  seguintes 

propriedades: 

(i) T(v1 + v2) = T(v1) + T(v2), para quaisquer v1 e v2 em V; 

(ii) T(av) = aT (v), para quaisquer v em V e a em K. 

 21 

 
 
 
 
 
 
 
 
 
As propriedades (i) e (ii) são equivalentes à seguinte propriedade: 

T(v1 + av2) = T(v1) + aT(v2);  para quaisquer v1 e v2 em V e para qualquer a em K. 

Por  exemplo,  a  função  T:  ℝ(cid:2871)  →  ℝ(cid:2870)  dada  por  T  (x,  y,  z)  =  (x  –  y,  y  –  z)  é  uma 

transformação linear, pois se tomarmos v1 = (x1, y1, z1), v2 = (x2, y2, z2) ∈ ℝ(cid:2871) e a ∈ ℝ teremos: 

T(v1 + av2) = T(x1 + ax2, y1 + ay2, z1 + az2)  

= (x1 + ax2 – (y1 + ay2), y1 + ay2 – (z1 + az2)  

= ((x1 – y1) + a(x2 – y2), (y1 – z1) + a(y2 – z2))  

= (x1 – y1, y1 – z1) + a(x2 – y2, y2 – z2)  

= T(v1) + a T (v2) 

Definição  3.6.  (Núcleo  e  imagem  de  uma  transformação  linear)  Seja  T  :  V  →  W  uma 

transformação linear. O núcleo de T é o conjunto de vetores de V que são levados por T no 

vetor nulo de W, ou seja, {v ∈ V; T(v) = 0}. O núcleo é um subespaço de V.  

Se  o  núcleo de uma  transformação  linear  for apenas  o  vetor nulo,  a  transformação  é 

chamada de injetiva. 

A imagem de T é o conjunto Im T = T(V) e também é um subespaço vetorial. 

Por exemplo, se tomarmos T : ℝ(cid:2872) → ℝ(cid:2871) definida por T(x, y, s, t) = (x – y + s + t, x + 

2s – t, x + y + 3s – 3t), para calcular o núcleo devemos obter o conjunto de vetores (x, y, s, t) 

em ℝ(cid:2872) tais que T(x, y, s, t) = (x – y + s + t, x + 2s – t, x + y + 3s – 3t) = (0, 0, 0), ou seja, 

devemos obter a solução do sistema linear homogêneo  

(cid:1876) − (cid:1877) + (cid:1871) + (cid:1872) = 0
(cid:1876) + 2(cid:1871) − (cid:1872) = 0
(cid:3421)
(cid:1876) + (cid:1877) + 3(cid:1871) − 3(cid:1872) = 0

Resolvendo o sistema obtemos como núcleo o conjunto {(–2s + t, –s + 2t, s, t); s, t ∈ 

R}, que é um subespaço vetorial do ℝ(cid:2872) de dimensão 2. 

Para  determinar  o  espaço  gerado  pela  imagem,  devemos  tomar  um  conjunto  de 

geradores  do  ℝ(cid:2872)  (pode  ser  a  base  canônica)  e  obter  a  imagem  desses  geradores  para,  em 

seguida, após escalonar a matriz formada pelas imagens, tomar as linhas não nulas da matriz 

equivalente, as quais formam uma base para o espaço linha procurado. Portanto: 

T(1,0,0,0) = (1, 1, 1), T(0,1,0,0) = (–1, 0, 1), T(0,0,1,0) = (1, 2, 3) e T(0,0,0,1) = (1, –1, –3) 

1
1
1
0
1
−1
(cid:4686)
1
3
2
1 −1 −3

(cid:4687) 

 22 

 
 
 
 
 
 
 
 
 
Escalonando-se: 

1
1
1
0
1
−1
(cid:4686)
3
2
1
1 −1 −3

(cid:4687)

(cid:1838)(cid:2870) → (cid:1838)(cid:2870) + (cid:1838)(cid:2869)
(cid:1838)(cid:2871) → (cid:1838)(cid:2871) − (cid:1838)(cid:2869)
(cid:1838)(cid:2872) → (cid:1838)(cid:2872) − (cid:1838)(cid:2869)

→ (cid:4686)

1
1
1
0
2
1
2
1
0
0 −2 −4

(cid:4687)

(cid:1838)(cid:2871) → (cid:1838)(cid:2871) − (cid:1838)(cid:2870)
 (cid:1838)(cid:2872) → (cid:1838)(cid:2872) + 2(cid:1838)(cid:2870)

→ (cid:4686)

1
1
1
0
2
1
0 0 0
0 0 0

(cid:4687) 

Então, uma base da imagem é {(1, 1, 1), (0, 1, 2)}. 

3.2 Entendendo o Funcionamento de um Código Linear 

Tomemos o conjunto (cid:2418) = ℤ(cid:2870) = {0, 1} como alfabeto, no qual a operação de soma é a 

soma módulo 2 – sistema binário –, a fim de construir um código de comprimento n = 6, em 

que  as  três  primeiras  componentes  de  cada  uma  das  palavras  sejam  a  informação  que 

desejamos transmitir.  

Se  a  palavra  a  ser  transmitida  é  x,  y,  z,  podemos  definir  os  dígitos  de  redundância 

como t = x + y, w = x + z, v = y + z, por exemplo. 

Adotando-se a notação vetorial, uma palavra c do código pode ser escrita como c = (x, 

y, z, x + y, x + z, y + z), que na notação matricial é: 

((cid:1876), (cid:1877), (cid:1878)) (cid:3429) 

1 0 0
0 1 0
0 0 1

1 1 0
1 0 1
0 1 1

 (cid:3433) = ((cid:1876), (cid:1877), (cid:1878), (cid:1876) + (cid:1877), (cid:1876) + (cid:1878), (cid:1877) + (cid:1878)) 

Desse  modo,  quando  (x,  y,  z)  percorrer  todos  os  elementos  de  (cid:2418)(cid:2870)

(cid:2871) = ℤ(cid:2870)

(cid:2871),  serão 

produzidas todas as palavras do código. Por isso a matriz acima é chamada de matriz geradora 

do código. 

O exemplo ilustrou o que será apresentado a seguir. 

Definição 3.7. (Códigos Lineares) Tomemos um corpo finito (cid:2418)(cid:3044) de q elementos para ser um 

alfabeto e, a partir dele, construamos um código C ⊂ (cid:2418)(cid:3044)

(cid:3041). Esse código será chamado código 

linear se for um subespaço vetorial de (cid:2418)(cid:3044)

(cid:3041).  

Se a dimensão do referido subespaço for m, onde m < n, então o número de palavras 

do código será M = qm. 

 23 

 
 
 
 
 
 
 
    
 
 
 
 
Um  código  nas  condições  estabelecidas  acima  é  chamado  de  ((cid:2196), (cid:2195))(cid:3044)-código  linear 

sobre (cid:2418)  e,  caso  também  seja conhecida  a distância  mínima  d,  ele  é  chamado de ((cid:2196), (cid:2195), (cid:2186))(cid:3044)-

código linear. 

Note que os  códigos  lineares  são  subespaços  vetoriais.  Portanto, o  vetor 0,  elemento 

neutro da soma, sempre estará em um código linear. 

Definição 3.8. (Peso de um elemento) Define-se o peso de Hamming de um elemento c de 

um código linear como o número w (c) = d (c, 0), onde d é a métrica de Hamming.  

Definição 3.9. (Peso do código) O peso de um código C é o menor valor obtido dentre o peso 

de cada um dos elementos do código, ou seja,  

w(C) := min {w(c); c ∈ C \{0}} 

Notemos que se x = (a1, a2, ..., an) e y = (b1, b2, ..., bn) são elementos de um código 

linear C, então d (x, y) = |{i / ai ≠ bi, 1 ≤ i ≤ n}| = |{i / ai – bi ≠ 0, 1 ≤ i ≤ n}| = d (x – y, 0) =    

w (x – y). Portanto, toda distância entre  elementos do código C é também o peso de algum 

elemento, o que acarreta em  

d = w (C). 

Assim,  como  o  peso  do  código  é  a  distância  mínima,  não  é  mais  necessário  fazer  a 

análise de (cid:4672) 

(cid:1839)
2

 (cid:4673) = (cid:3014) ((cid:3014)(cid:2879)(cid:2869))

(cid:2870)

  distâncias (conforme descrito na definição 2.6), mas apenas de M 

– 1 (a distância de cada um dos M – 1 elementos não nulos ao elemento neutro). Apesar do 

avanço, se o número de elementos do código for muito grande, o cálculo de d por meio do 

peso das palavras  do  código  também  fica  inviável,  por  representar  um custo  computacional 

muito elevado, sendo necessário o desenvolvimento de outros métodos para determinação da 

distância mínima. 

Tomemos  um 

exemplo.  Seja  C  = 

{0000,  1011,  0110,  1101}  ⊂  

(cid:2872)  um  código  linear.  Podemos  observar  que  uma  base  para  o  código  pode  ser  o  conjunto 

ℤ(cid:2870)
{1011, 1101}, pois todos os elementos do código são combinação linear de 1011 e 1101: 

0000 = 0 (1011) + 0 (1101) 

1011 = 1 (1011) + 0 (1101) 

 24 

 
 
 
 
 
 
 
 
 
 
1101 = 0 (1011) + 1 (1101) 

0110 = 1 (1011) + 1 (1101). 

Ou seja, cada vetor foi escrito como a1 (1011) + a2 (1101), onde a1, a2 ∈ ℤ(cid:2870). Além disso, a1 

(1011)  +  a2  (1101)  =  (0000)  se,  e  somente  se,  a1  =  a2  =  0  (os  vetores  são  linearmente 

independentes). 

Para obter a distância mínima do código C basta calcular m – 1 = 4 – 1 = 3 pesos: w 

(1011) = 3, w (0110) = 2 e w (1101) = 3. Portanto, a distância mínima de C é 2 e o código 

pode ser classificado como um (4,2,2)(cid:2870)-código linear. 

3.3 Formalizando o Código 

Por meio da Álgebra Linear sabemos que é possível construir subespaços vetoriais C 

de  (cid:2418)(cid:3044)

(cid:3041)  de  duas  maneiras:  obtendo-se  o  núcleo  ou  a  imagem  de  uma  transformação  linear. 

Inicialmente vamos utilizar a imagem. 

3.3.1 Código obtido por meio da imagem de uma transformação linear 

Suponhamos  que  será  construído  um  código  para  enviar  m  dígitos  de  informação  e      

n – m dígitos de redundância. Desse modo, o vetor de informação é um elemento do espaço 

vetorial (cid:2418)(cid:3044)

(cid:3040), o vetor codificado é um elemento do (cid:2418)(cid:3044)

(cid:3041) e o código C é um subespaço C ⊂ (cid:2418)(cid:3044)

(cid:3041) de 

dimensão m e base v1, v2, ... , vm. 

Obteremos a representação do código C por meio da seguinte transformação linear: 

T:  

(cid:3040)  

(cid:2418)(cid:3044)

→  

(cid:3041) 
(cid:2418)(cid:3044)

x = (x1, x2, ... , xm) 

x1v1 + x2v2 + ... + xmvm 

Como a aplicação linear T é injetora (demonstração abaixo), então a imagem de T é o 

código C, ou seja, Im (T) = C. 

Demonstração: Tomemos x, y ∈ (cid:2418)(cid:3044)

(cid:3040) tais que T(x) = T(y). Portanto, 

x1v1 + x2v2 + ... + xmvm   =   y1v1 + y2v2 + ... + ymvm 

(x1 – y1)v1 + (x2 – y2)v2 + ... + (xm – ym) vm = 0 

 25 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
e, como {v1, v2, ... , vm} é um conjunto linearmente independente (pois é uma base do código 

C) temos que xi – yi = 0 para todo i ∈ {1, 2, ... , m}, o que acarreta em x = y e demonstra que a 

aplicação é injetora.(cid:0) 

Por  exemplo,  utilizemos  um  código  C  ⊂  (cid:2418)(cid:2870)

(cid:2875)  sobre  o  corpo  (cid:2418)(cid:2870)  =  {0,  1}  com  base 
{(1,0,0,0,1,1,0), (0,1,0,0,0,1,1), (0,0,1,0,1,0,1), (0,0,0,1,1,1,1)} e uma palavra x = (1,0,1,1) do 

espaço vetorial (cid:2418)(cid:2870)
T(x) = T(1,0,1,1) = 1. (1,0,0,0,1,1,0) + 0. (0,1,0,0,0,1,1) + 1.(0,0,1,0,1,0,1) + 1.(0,0,0,1,1,1,1) 

(cid:2872). Logo, para codificar x basta fazermos: 

Assim, a palavra foi codificada para o código e pode ser transmitida. 

T(x) = (1,0,1,1,1,0,0) = c. 

Façamos outro exemplo. Tomemos a transformação linear T: (cid:2418)(cid:2870)

(cid:2871) → (cid:2418)(cid:2870)

(cid:2873) tal que T(x1, x2, 

x3)  =  (x1,  x3,  x1  +  x2,  x2  +  x3,  x2).  No  caso,  T(x1,  x2,  x3)  =  (x1,  x3,  x1  +  x2,  x2  +  x3,  x2)  = 

(0,0,0,0,0) se, e só se, x1 = x2 = x3 = 0. Então, a aplicação é injetiva e sua imagem é o código 

C: Im (T) = C. 

Escrevendo a imagem dos elementos da base canônica de ℝ(cid:2871) em termos dos elementos 

da base canônica de ℝ(cid:2873), temos que: 

T(1,0,0) = (1,0,1,0,0) = 1(1,0,0,0,0) + 0(0,1,0,0,0) + 1(0,0,1,0,0) + 0(0,0,0,1,0) + 0(0,0,0,0,1) 

T(0,1,0) = (0,0,1,1,1) = 0(1,0,0,0,0) + 0(0,1,0,0,0) + 1(0,0,1,0,0) + 1(0,0,0,1,0) + 1(0,0,0,0,1) 

T(0,0,1) = (0,1,0,1,0) = 0(1,0,0,0,0) + 1(0,1,0,0,0) + 0(0,0,1,0,0) + 1(0,0,0,1,0) + 0(0,0,0,0,1) 

e, então, a matriz de codificação do código é 

(cid:3429)

1 0 1
0 0 1
0 1 0

0 0
1 1
1 0

(cid:3433) 

Ante ao apresentado, é possível observar que há duas formas de codificar uma palavra. 

Por exemplo, se x = (1,0,1), pode ser calculado T(1,0,1) = (1, 1, 1, 1, 0) ou 

[1 0 1] (cid:3429)

1 0 1
0 0 1
0 1 0

0 0
1 1
1 0

(cid:3433) = [1 1 1 1 0]. 

E, em vista do referido resultado, segue-se a definição abaixo. 

Definição 3.10.  (Matriz geradora  de  um  código)  Para descrever  a  matriz  geradora de  um 

código C ⊂ (cid:2418)(cid:3044)

(cid:3041)  (transmite elementos de um espaço (cid:2418)(cid:3044)

(cid:3040) com n – m dígitos de redundância), 

devemos tomar uma base B = {v1, v2, ..., vm} do código C, em que cada vetor é da forma vi = 

(vi1, vi2, ... , vin) e escrever a matriz na qual as linhas são os vetores da base de C. Essa matriz 

será chamada de matriz geradora do código C associada à base B.  

 26 

 
 
 
 
   
 
   
 
(cid:1833) = (cid:4686)

(cid:1874)(cid:2869)
(cid:1874)(cid:2870)
⋮
(cid:1874)(cid:3040)

(cid:4687) = (cid:3430)

(cid:1874)(cid:2869)(cid:2869)
(cid:1874)(cid:2870)(cid:2869)
⋮
(cid:1874)(cid:3040)(cid:2869)

(cid:1874)(cid:2869)(cid:2870) … (cid:1874)(cid:2869)(cid:3041)
(cid:1874)(cid:2870)(cid:2870) … (cid:1874)(cid:2870)(cid:3041)
⋮
⋱ ⋮
… (cid:1874)(cid:3040)(cid:3041)
(cid:1874)(cid:3040)(cid:2870)

(cid:3434) 

Como  em  cada  uma  das  linhas  da  matriz  há  um  vetor  do  código,  o  código  C  é  um 

subespaço de (cid:2418)(cid:3044)

(cid:3041) gerado pelas linhas da matriz G. Os elementos de C são vetores y ∈ (cid:2418)(cid:3044)

(cid:3041) da 

foma x.G = y, para todo x ∈   (cid:2418)(cid:3044)

(cid:3040). Isso é equivalente a escrever uma transformação linear 

T: 

(cid:3040)   →  

(cid:2418)(cid:3044)

(cid:3041) 
(cid:2418)(cid:3044)

          x         →       xG 

em que y = T (x) = x.G = x1v1 + x2v2 + ... + xmvm e x = (x1, x2, ... , xm). Logo, T ((cid:2418)(cid:3044)

(cid:3040)) = C. 

Daí,  podemos  afirmar  que  (cid:2418)(cid:3044)

(cid:3040)  é  o  código  da  fonte  e  C  o  código  de  canal,  sendo  a 

transformação T uma forma de codificação.  

Façamos  um  exemplo.  Tomemos  uma  transformação  linear  T:  (cid:2418)(cid:2870)

(cid:2870)  →  (cid:2418)(cid:2870)

(cid:2873)  tal  que           

T (x1, x2) = (x1, x2, x1, x1 + x2, x2), que transmite dois dígitos de informação e três dígitos de 

redundância, na qual o alfabeto é o corpo (cid:2418)(cid:2870) = {0, 1}. Inicialmente, é realizada a verificação 

de que a aplicação linear é injetiva.  

Note que T(x1, x2) = (x1, x2, x1, x1 + x2, x2) = (0,0,0,0,0) se, e só se, x1 = x2 = 0. Então, 

a aplicação é injetiva e a imagem dela é o código linear C.  

            Como os resultados de T(1,0) e T (0, 1) são, respectivamente, T(1,0) = (1, 0, 1, 1, 0) e 

T  (0,  1)  =  (0,  1,  0,  1,  1),  e  os  vetores  (1,  0,  1,  1,  0)  e  (0,  1,  0,  1,  1)  são  linearmente 

independentes,  podemos  concluir  que  {(1,  0,  1,  1,  0),  (0,  1,  0,  1,  1)}  é  uma  base  para  a 

imagem e, consequentemente, para o código.  Como a base possui dois vetores, então temos 

que sua dimensão m = 2. Além disso, verificamos que o código possui a seguinte quantidade 

de palavras: M = qm = 22 = 4.  

Obtida uma base para o código, podemos escrever a matriz geradora, que é 

(cid:1833) = (cid:4674)

1 0 1 1 0
0 1 0 1 1

(cid:4675) 

Vamos  efetuar  mais  algumas  verificações.  Podemos  escrever  todas  as  palavras  do 

código: T(0,0) = (0, 0, 0, 0, 0); T(1,0) = (1, 0, 1, 1, 0); T(0,1) = (0, 1, 0, 1, 1); T(1,1) = (1, 1, 1, 

0, 1). Em  seguida,  verifiquemos  o  valor  do peso de cada uma delas,  com  exceção  do  vetor 

nulo: w(1, 0, 1, 1, 0) = 3; w(0, 1, 0, 1, 1) = 3; w(1, 1, 1, 0, 1) = 4. Então, podemos concluir 

 27 

 
 
 
 
 
 
 
 
que o peso do código é 3. Portanto, a distância mínima é d = 3. Donde podemos afirmar que o 

código é capaz de corrigir κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 1 erro e detectar  d – 1 = 3 – 1 = 2 erros.  

Façamos outro exemplo. Tomemos o código que é a imagem da transformação linear  

T :  

(cid:2871)   →  

(cid:2418)(cid:2870)
x 

→ 

(cid:2873) 
(cid:2418)(cid:2870)
xG 

onde (cid:2418)(cid:2870) = ℤ(cid:2870) = {0, 1} e G é a seguinte matriz geradora: 
0 1
1 0
1 1

1 0 1
1 1 0
1 1 1

(cid:1833) = (cid:3429)

(cid:3433) 

A palavra 101 do código pode ser codificada como 01010, pois 

[1 0 1] (cid:3429)

1 0 1
1 1 0
1 1 1

0 1
1 0
1 1

(cid:3433) = [0 1 0 1 0]. 

Suponhamos  agora  que  desejamos  decodificar  a  palavra  10101.  Para  isso,  devemos 

resolver  o  sistema  [x1    x2    x3]G  =  [1    0    1    0    1],  ou  seja,  resolver  o  sistema  de  equações 

abaixo: 

(cid:1876)(cid:2869) + (cid:1876)(cid:2870) + (cid:1876)(cid:2871) = 1
(cid:1876)(cid:2870) + (cid:1876)(cid:2871) = 0
(cid:1876)(cid:2869) + (cid:1876)(cid:2871) = 1
(cid:1876)(cid:2870) + (cid:1876)(cid:2871) = 0
(cid:1876)(cid:2869) + (cid:1876)(cid:2871) = 1

⎧
⎪

⎨
⎪
⎩

cuja solução é x1 = 1, x2 = 0 e x3 = 0. 

Esse sistema foi de fácil resolução, mas se a matriz G for complexa, a resolução pode 

ficar muito difícil. Ou seja, o custo computacional da referida resolução pode ser elevado. 

Por outro lado, é possível efetuar operações11 com as linhas da matriz G, a fim de que 

ela assuma outra forma (G’): 

(cid:3429)

1 0 1
1 1 0
1 1 1

0 1
1 0
1 1

(cid:3433) 

→
(cid:1838)(cid:2870) → (cid:1838)(cid:2870) −  (cid:1838)(cid:2869)
(cid:1838)(cid:2871) → (cid:1838)(cid:2871) −  (cid:1838)(cid:2869)
1 0 1
0 1 0
0 0 1

(cid:3429)

1 0 1
(cid:3429)
0 1 1
0 1 0

0 1
1 1
1 0

(cid:3433)

→
(cid:1838)(cid:2870) ↔ (cid:1838)(cid:2871)

(cid:3429)

0 1
1 0
0 1

(cid:3433)

→
(cid:1838)(cid:2869) → (cid:1838)(cid:2869) − (cid:1838)(cid:2871)

(cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
0 1 0
0 1 1
0 0
1 0
0 1

(cid:3433) 

0 1
1 0
1 1

(cid:3433)

→
(cid:1838)(cid:2871) → (cid:1838)(cid:2871) − (cid:1838)(cid:2870)

11 São as mesmas operações utilizadas para obter sistemas de equações equivalentes. São elas: 
L1 – permutação de duas linhas 
L2 – multiplicação de uma linha por um escalar não nulo 
L3 – adição de um múltiplo escalar de uma linha a outra. 

 28 

 
    
 
    
 
 
 
 
 
    
    
    
 
    
    
 
 
                                                 
Dessa  forma,  ao  fazermos  xG’  obtemos  (x1    x2    x3    x2    x3)  o  que  torna  mais  fácil  a 

decodificação,  pois  o  vetor  é  imediatamente  identificado  por  meio  das  três  primeiras 

componentes. Logo, a palavra 10101 é facilmente decodificada como 101. 

O método utilizado nos leva aos resultado a seguir. 

3.3.2 Matriz geradora na forma padrão 

Dizemos  que uma  matriz  de  codificação  G  de um  código  C  está  na  forma padrão  se 

tivermos G = [Idm | A], onde Idm é a matriz identidade m x m e A uma matriz m x (n – m). 

Verificamos  que  a  matriz  geradora  do  tópico  anterior  pode  ser  colocada  na  forma 

padrão.  Todavia,  nem  sempre  isso  é  possível  com  o  uso  das  operações  entre  linhas.  Por 

exemplo, se tomarmos um código em (cid:2418)(cid:2870)

(cid:2873), (cid:2418)(cid:2870) = {0, 1}, de matriz geradora  
0 0 1 0 0
(cid:4674)
0 0 0 1 1
isso não será possível, pois as operações padrões entre linhas não permitem que tal aconteça. 

(cid:4675), 

Entretanto,  se  forem  efetuadas  operações  de  permutações  de  colunas,  é  possível  obter  uma 

matriz na forma padrão 

0 0 1 0 0
(cid:4674)
0 0 0 1 1

(cid:4675)

(cid:1855)(cid:2869) ↔ (cid:1855)(cid:2871)
(cid:1855)(cid:2870) ↔ (cid:1855)(cid:2872)

  (cid:4674)

1 0 0 0 0
0 1 0 0 1

(cid:4675). 

Portanto,  se  acrescentarmos  às  operações  padrões  entre  linhas  as  operações  entre 

colunas: 

C1 – permutação de duas colunas, e 

C2 – multiplicação de uma coluna por um escalar não nulo 

também poderemos encontrar matrizes G’ de um código C’ equivalente a C, o que nos leva ao 

teorema a seguir. 

Teorema  3.1.  (Código  equivalente)  Dado  um  código  C,  existe  um  código  equivalente  C’ 

com matriz geradora na forma padrão.  

Demonstração: Seja G uma matriz  geradora de um código C. Podemos colocar G na forma 

padrão com uma sequência das operações descritas no item 3.3.3 (L1, L2, L3, C1 e C2). 

Tomemos a matriz  

(cid:1833) = (cid:3430)

(cid:1874)(cid:2869)(cid:2869)
(cid:1874)(cid:2870)(cid:2869)
⋮
(cid:1874)(cid:3040)(cid:2869)

(cid:1874)(cid:2869)(cid:2870) … (cid:1874)(cid:2869)(cid:3041)
(cid:1874)(cid:2870)(cid:2870) … (cid:1874)(cid:2870)(cid:3041)
⋮
⋱ ⋮
… (cid:1874)(cid:3040)(cid:3041)
(cid:1874)(cid:3040)(cid:2870)

(cid:3434) 

 29 

 
 
 
 
 
 
 
 
 
Como  a  primeira  linha  de  G  não  é  nula  (os  vetores  linhas  de  G  são  linearmente 

independentes),  por  meio  de  C1  podemos  supor  de  (cid:1874)(cid:2869)(cid:2869)  ≠  0.  Em  seguida,  multiplicamos  a 
(cid:2879)(cid:2869) e, então, podemos colocar 1 no lugar de (cid:1874)(cid:2869)(cid:2869) (nesse caso foi utilizada a 

primeira linha por (cid:1874)(cid:2869)(cid:2869)
operação L2).  

Somando-se  à  i-ésima  linha  a primeira  linha  por (–1) (cid:1874)(cid:3036)(cid:2869), obteremos  a  matriz  abaixo 

(nesse caso foi utilizada uma sequência de operações do tipo L3): 

(cid:3430)

1
0
⋮
0

(cid:1853)(cid:2869)(cid:2870) … (cid:1853)(cid:2869)(cid:3041)
(cid:1853)(cid:2870)(cid:2870) … (cid:1853)(cid:2870)(cid:3041)
⋮
⋱ ⋮
… (cid:1853)(cid:3040)(cid:3041)
(cid:1853)(cid:3040)(cid:2870)

(cid:3434) 

Agora,  considerando  que  na  segunda  linha  da  matriz  há  algum  elemento  não  nulo  e 

que por meio da operação C1 podemos colocá-lo na segunda linha e segunda coluna, vamos 

proceder  de  forma  semelhante  ao  que  foi  realizado  no  parágrafo  anterior:  multiplicamos  a 

segunda  linha  pelo  inverso  do  elemento,  transformando  a  matriz,  conforme  apresentado 

abaixo. 

1
0
(cid:3430)
⋮
0

(cid:1854)(cid:2869)(cid:2870) … (cid:1854)(cid:2869)(cid:3041)
… (cid:1854)(cid:2870)(cid:3041)
1
⋮
⋱ ⋮
… (cid:1854)(cid:3040)(cid:3041)
(cid:1854)(cid:3040)(cid:2870)

(cid:3434) 

Assim, por  meio  de  operações  do  tipo  L3, de  forma  análoga  ao  que  já  foi realizado 

anteriormente, obtemos a matriz 

⎤
⎥
⎥
⋮   
⎥
(cid:1855)(cid:3040)(cid:2871) ⋯ (cid:1855)(cid:3040)(cid:3041)⎦
Fazendo-se  de  forma  sucessiva  o  procedimento  acima,  coluna  por  coluna,  em 

⎡
⎢
⎢
⎢
⎣

(cid:1855)(cid:2869)(cid:2871) ⋯ (cid:1855)(cid:2869)(cid:3041)
(cid:1855)(cid:2870)(cid:2871) ⋯ (cid:1855)(cid:2870)(cid:3041)
(cid:1855)(cid:2871)(cid:2871) ⋯ (cid:1855)(cid:2871)(cid:3041)
⋮
⋮     

1 0
0 1
0
0
⋮
⋮
0
0

determinado momento encontraremos uma matriz na forma padrão 

G’ = [Idm | A]. (cid:0) 

Façamos um exemplo. Tomemos um código C definido sobre (cid:2418)(cid:2870) = {0 ,1} pela matriz 

G  abaixo.  Podemos  obter  uma  matriz  G’  na  forma  padrão,  por  meio  dos  seguintes 

procedimentos: 

(cid:1833) = (cid:3430)

1 1 1 0 0 0 0
1 0 0 1 1 0 0
0 0 0 1 1
1
0 1 0 1 0
0

0
1

(cid:3434) 

 30 

 
 
 
 
 
 
 
 
1 1 1 0 0 0 0
1 0 0 1 1 0 0
(cid:3430)
0 0 0 1 1
1
0 1 0 1 0
0

0
1

(cid:3434)

(cid:1838)(cid:2870) → (cid:1838)(cid:2870) − (cid:1838)(cid:2869)
(cid:1838)(cid:2871) → (cid:1838)(cid:2871) − (cid:1838)(cid:2869)

(cid:3430)

1 1 1 0 0 0 0
0 1 1 1 1 0 0
1 0 0 1 1
0
0 1 0 1 0
0

1
1

(cid:3434)

(cid:1838)(cid:2871) → (cid:1838)(cid:2871) − (cid:1838)(cid:2870)
(cid:1838)(cid:2872) → (cid:1838)(cid:2872) − (cid:1838)(cid:2870)

1 1 1 0 0 0 0
0 1 1 1 1 0 0
(cid:3430)
0 1 1 1 1
0
1 0 1 1 0
0

0
0

1 1 0 1 0 0 0
0 1 1 1 1 0 0
(cid:3434)      (cid:1855)(cid:2871) ↔ (cid:1855)(cid:2872)      (cid:3430)
1 0 1 1 1
0
0 1 1 1 0
0

0
0

(cid:3434) (cid:1838)(cid:2869) → (cid:1838)(cid:2869) − (cid:1838)(cid:2870) 

1 0 1 0 1 0 0
0 1 1 1 1 0 0
(cid:3430)
1 0 1 1 1
0
0 1 1 1 0
0

0
0

(cid:3434)

(cid:1838)(cid:2869) → (cid:1838)(cid:2869) − (cid:1838)(cid:2871)
(cid:1838)(cid:2870) → (cid:1838)(cid:2870) − (cid:1838)(cid:2871)

(cid:3430)

1 0 0 0 0 1 1
0 1 0 1 0 1 1
1 0 1 1 1
0
0 1 1 1 0
0

0
0

(cid:3434) (cid:1838)(cid:2870) → (cid:1838)(cid:2870) − (cid:1838)(cid:2872) 

1 0 0 0 0 1 1
0 1 0 0 1 0 1
(cid:1833)(cid:4593) = (cid:3430)
1 0 1 1 1
0
0 1 1 1 0
0

0
0

(cid:3434)= [Id4 | A4x3]. 

3.3.3 Código dual 

Antes  de  iniciar  o  estudo  dos  códigos  duais,  é  importante  sabermos  a  definição  de 

produto interno de vetores.  

Definição 3.11. (Produto interno) Sejam u = (u1, u2, ... , un) e v = (v1, v2, ... , vn) elementos 

de (cid:2418)(cid:3041). Definimos o produto interno de u e v como  

< u, v > = u1v1 + u2v2 + ... + unvn. 

Observemos  que  a  operação  <  u,  v  >  possui  as  propriedades  usuais  de  um  produto 

interno, ou seja, é positiva e definida, simétrica e bilinear12.  

Dizemos que u é ortogonal a v se, e somente se, < u, v > = 0. 

Definição  3.12  (Código  dual)  Seja  C  ⊂  (cid:2418)(cid:3044)

(cid:3041)  um  código  linear  com  matriz  geradora  G. 

Definimos um conjunto (cid:1829)⟘ tal que 

 (cid:1829)⟘ = {v ∈ (cid:2418)(cid:3044)

(cid:3041): < v, u > = 0,  u ∈ C}. 

(cid:1866) 
12 i)   < u, u > ≥ 0, para todo u ∈ (cid:2418)(cid:1869)
    ii)  < u, u > = 0 se, e somente se, u = 0 
(cid:1866) 
    iii) < u, v > = < v, u >, para todo u, v ∈ (cid:2418)(cid:1869)
    iv) < u + αw, v > = < u, v > + α < w, v >, para todo u, v, w ∈ (cid:2418)(cid:1869)

(cid:1866)  e α ∈ (cid:2418). 

 31 

 
 
 
 
 
 
 
 
 
 
                                                 
O conjunto  (cid:1829)⟘ satisfaz as seguintes propriedades: 

(cid:3041) 
(cid:1861))  (cid:1829)⟘ é um subespaço vetorial de (cid:2418)(cid:3044)

Demonstração: De fato, se tomarmos u, v ∈  (cid:1829)⟘, x ∈ C e α ∈  (cid:2418), verificamos para todo x ∈ C 

que < u + αv, x > = < u, x > + α< v, x > = 0 e, portanto, u + αv ∈  (cid:1829)⟘. (cid:0) 

ii) x ∈  (cid:1829)⟘ se, e somente se, G xt = 0 

Demonstração: De fato, x ∈  (cid:1829)⟘se, e somente se, x é ortogonal a todos os elementos de C. E x 

é ortogonal a todos os elementos de C se, e somente se, x é ortogonal a todos os elementos de 

uma base de C, o que é o mesmo que dizer G xt = 0, pois as linhas de G são uma base de C. (cid:0) 

(cid:3041), 
Assim,  ante  ao  apresentado,  provamos  que   (cid:1829)⟘  é  um  subespaço  vetorial  de  (cid:2418)(cid:3044)

ortogonal a C, o qual chamaremos de código dual de C. 

A seguir serão apresentados alguns resultados importantes.  

Teorema 3.2. (Dimensão e matriz geradora de  (cid:2159)⟘) Seja C ⊂ (cid:2418)(cid:3044)

(cid:3041) um código de dimensão m 

e com matriz geradora G = [Idm | A], na forma padrão. Então 

i) 

ii) 

dim  (cid:1829)⟘= n – m;  

H = [ – At | Idn–m  ] é uma matriz geradora de  (cid:1829)⟘. 

Demonstração: 

(i) Um vetor v = (v1, v2, ... , vn) pertence a   (cid:1829)⟘ se, e somente se, G vt = 0. Como G 

está na forma padrão, isso equivale ao sistema:  

⎡ 1 0 0
0
0
0 1 0
0
0
⎢
⎢
0 0 ⋱
⋮
⋮
⎢
1 0
  ⋮
 ⋮
⋮
⎢
0 0 ⋯ 0 1
⎣

⋯
⋯
⋯

  | (cid:1853)(cid:2869)((cid:3040)(cid:2878)(cid:2869))
  | (cid:1853)(cid:2870)((cid:3040)(cid:2878)(cid:2869))
⋮     
|     
   ⋮    
|  

⎤
⎥
⎥
⎥
⎥
     | (cid:1853)(cid:3040)((cid:3040)(cid:2878)(cid:2869)) ⋯ (cid:1853)(cid:3040)((cid:3041))⎦

(cid:1853)(cid:2869)((cid:3041))
(cid:1853)(cid:2870)((cid:3041))
⋮
⋮

⋯

(cid:3040) (cid:3051) (cid:3041)

(cid:1874)(cid:2869)
⎤
⋮
⎥
⋮
⎥
⋮
⎥
(cid:1874)(cid:3041)⎦

(cid:3041) (cid:3051) (cid:2869)

⎡
⎢
⎢
⎢
⎣

=    

⎡
⎢
⎢
⎢
⎣

0
⎤
⋮
⎥
⋮
⎥
⋮
⎥
0⎦

(cid:3040) (cid:3051) (cid:2869)

Daí, 

 32 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
(cid:1874)(cid:2869)                                                           + (cid:1853)(cid:2869)((cid:3040)(cid:2878)(cid:2869)). (cid:1874)(cid:3040)(cid:2878)(cid:2869) + ⋯ + (cid:1853)(cid:2869)((cid:3041)). (cid:1874)(cid:3041) = 0
                    (cid:1874)(cid:2870)                                      + (cid:1853)(cid:2870)((cid:3040)(cid:2878)(cid:2869)). (cid:1874)(cid:3040)(cid:2878)(cid:2869) + ⋯ + (cid:1853)(cid:2870)((cid:3041)). (cid:1874)(cid:3041) = 0
⋱                                                              
⋱                                            
                                                        (cid:1874)(cid:3040) + (cid:1853)(cid:3040)((cid:3040)(cid:2878)(cid:2869)). (cid:1874)(cid:3040)(cid:2878)(cid:2869) + ⋯ + (cid:1853)(cid:3040)((cid:3041)). (cid:1874)(cid:3041) = 0

⎧
⎪

⎨
⎪
⎩

         ⇒ 

(cid:1874)(cid:2869) =   −((cid:1853)(cid:2869)((cid:3040)(cid:2878)(cid:2869)). (cid:1874)(cid:3040)(cid:2878)(cid:2869) + ⋯ + (cid:1853)(cid:2869)((cid:3041)). (cid:1874)(cid:3041))
(cid:1874)(cid:2870) = −((cid:1853)(cid:2870)((cid:3040)(cid:2878)(cid:2869)). (cid:1874)(cid:3040)(cid:2878)(cid:2869) + ⋯ + (cid:1853)(cid:2870)((cid:3041)). (cid:1874)(cid:3041))
⋮
⋮
(cid:1874)(cid:3040) = −((cid:1853)(cid:3040)((cid:3040)(cid:2878)(cid:2869)). (cid:1874)(cid:3040)(cid:2878)(cid:2869) + ⋯ + (cid:1853)(cid:3040)((cid:3041)). (cid:1874)(cid:3041))

⎧
⎪

⎨
⎪
⎩

(cid:1874)(cid:2869)
⎤
⎡
⋮
⎥
⎢
⋮
    ⇒   
⎥
⎢
⋮
⎥
⎢
(cid:1874)(cid:3040)⎦
⎣

= −(cid:1827).

(cid:1874)(cid:3040)(cid:2878)(cid:2869)
⎤
⎡
(cid:1874)(cid:3040)(cid:2878)(cid:2870)
⎥
⎢
⋮
⎥
⎢
⋮
⎥
⎢
(cid:1874)(cid:3041) ⎦
⎣

Portanto,  temos  que   (cid:1829)⟘  possui  n  –  m  elementos  (É  a  quantidade  de  elementos  da 

última coluna: n-(m+1)+1). Logo,  (cid:1829)⟘ tem dimensão n – m. (cid:0) 

(ii)  As  linhas  de  H  são  linearmente  independentes,  devido  ao  bloco  Idn–m.  Portanto, 

elas geram um subespaço vetorial de dimensão n – m. Como as linhas de H são ortogonais às 

linhas de G, temos que o espaço gerado pelas linhas de H está contido em  (cid:1829)⟘. E, como esses 

subespaços possuem a mesma dimensão, eles coincidem. Isso prova que H = [ – At | Idn–m  ] é 

uma matriz geradora de  (cid:1829)⟘. (cid:0) 

Proposição 3.1.  (Relação  entre as matrizes geradoras dos  códigos  C  e  (cid:2159)⟘)  Suponhamos 

que C ⊂ (cid:2418)(cid:3044)

(cid:3041) é um código de dimensão m e com matriz geradora G. Uma matriz H de ordem (n 

–  m)  x  n,  com  coeficientes  em  (cid:2418)(cid:2870)  e  com  linhas  linearmente  independentes,  é  uma  matriz 

geradora de  (cid:1829)⟘ se, e somente se, G . Ht = 0.  

Demonstração: As linhas de H geram um subespaço vetorial de (cid:2418)(cid:3044)

(cid:3041) que possui dimensão n – 

m,  idêntica  à  dimensão  de   (cid:1829)⟘.  Além  disso,  se  chamarmos  de  h1,  ...  hn–m  e  g1,  ...  gm, 

respectivamente, as linhas de H e de G, então 

((cid:1833). (cid:1834)(cid:3047))(cid:3036),(cid:3037) =< (cid:1859)(cid:3036), ℎ(cid:3037) > 

Portanto, dizer que (cid:1833). (cid:1834)(cid:3047) = 0 é equivalente a dizer que todos os vetores do subespaço 

gerado pelas  linhas  de  H  estão  em  (cid:1829)⟘.  E,  como  esse  subespaço tem  a mesma  dimensão  de 

 (cid:1829)⟘, então 

(cid:1833). (cid:1834)(cid:3047) = 0 ⇔  (cid:1829)⟘ é gerado pelas linhas de H. (cid:0) 

 33 

 
 
 
 
 
 
 
 
Proposição 3.2.  ((cid:2159)⟘)⟘ = (cid:2159) 

Demonstração: Sejam G e H, respectivamente, matrizes geradoras de C e  (cid:1829)⟘. Logo, (cid:1833). (cid:1834)(cid:3047) =

0. Tomando transpostas nessa última igualdade, temos que (cid:1834). (cid:1833) (cid:3047) = 0. Portanto, G é a matriz 

geradora de  ((cid:1829)⟘)⟘. Daí, segue-se o resultado. (cid:0) 

Proposição 3.3. Seja C um código linear e suponhamos que H seja uma matriz geradora de 

 (cid:1829)⟘. Então, temos que v ∈ C se, e somente se, H vt = 0.  

Demonstração: Conforme já demonstrado, temos que  ((cid:1829)⟘)⟘ = (cid:1829) e x ∈  (cid:1829)⟘ se, e somente se, 

G  xt  =  0.  Decorre  dessas  duas  afirmativas  que  v  ∈  C  se,  e  somente  se,  v  ∈    ((cid:1829)⟘)⟘  se,  e 

somente se, H vt = 0. (cid:0) 

A matriz H de  (cid:1829) ⟘ é chamada de matriz teste de paridade de C. 

Por exemplo, se for dado um código C sobre (cid:2418)(cid:2870) = {0, 1} com matriz geradora  

(cid:1833) = (cid:3429)

1 0 0
0 1 0
0 0 1

1 1 1
0 1 1
0 1 0

(cid:3433), 

como G está na forma padrão (G = [ Idm | A ]), é fácil encontrar a matriz teste de paridade H, 

pois ela é H = [– At | Idn–m  ]. Portanto, 

(cid:1834) = (cid:3429)

1 0 0
1 1 1
1 1 0

1 0 0
0 1 0
0 0 1

(cid:3433). 

Assim, se quisermos verificar se as palavras v1 = 100111 e v2 = 010101 pertencem ao 

código, basta calcular 

(cid:1834) (cid:1874)(cid:2869)

(cid:3047) = (cid:3429)

1 0 0
1 1 1
1 1 0

1 0 0
0 1 0
0 0 1

(cid:3433)

e 

(cid:1834) (cid:1874)(cid:2870)

(cid:3047) = (cid:3429)

1 0 0
1 1 1
1 1 0

1 0 0
0 1 0
0 0 1

(cid:3433)

1
⎤
⎡
0
⎥
⎢
0
⎥
⎢
1
⎥
⎢
⎥
1
⎢
1⎦
⎣

0
⎤
⎡
1
⎥
⎢
0
⎥
⎢
1
⎥
⎢
⎥
0
⎢
1⎦
⎣

= (cid:3429)

0
0
0

(cid:3433) 

= (cid:3429)

1
1
0

(cid:3433). 

 34 

 
 
 
 
 
 
    
    
 
    
    
Assim, podemos concluir que v1 ∈ C e v2 ∉ C, pois (cid:1834) (cid:1874)(cid:2869)

(cid:3047) é o vetor nulo e (cid:1834) (cid:1874)(cid:2870)

(cid:3047) não é o 

vetor nulo. 

A verificação de que uma palavra pertence ao código por meio da matriz de paridade 

requer um custo computacional muito menor do que o método apresentado anteriormente, por 

meio  do  qual  era  preciso  resolver  o  sistema  x1G  =  v1  e  x2G=v2,  onde  x1,  x2  ∈  (cid:2418)(cid:3044)

(cid:3040),  para 

verificar se os vetores pertenciam ao código.  

A  matriz  teste  de  paridade  também  contém  informações  sobre  o  peso  do  código, 

conforme veremos no próximo item. 

Proposição 3.4. Seja H a matriz teste de paridade de um código C. Temos que o peso de C é 

maior  ou  igual  a  s  se,  e  somente  se,  quaisquer  s  –  1  colunas  de  H  são  linearmente 

independentes. 

Demonstração:  Vamos  supor,  inicialmente,  que  cada  conjunto  de  s  –  1  colunas  de  H  seja 

linearmente independente. Tomemos uma palavra não nula c = (c1, c2, ..., cn) do código C e 

digamos que h1, h2, ..., hn sejam as colunas de H. Como Hct = 0, então 

0 = (cid:1834). (cid:1855)(cid:3047) = ∑ (cid:1855)(cid:3036)ℎ(cid:3036). 

Se w (c) ≤ s – 1, como w (c) é o número de componentes não nulas da palavra c e a 

equação 0 = (cid:1834). (cid:1855)(cid:3047) = ∑ (cid:1855)(cid:3036)ℎ(cid:3036), então haveria uma combinação nula de um número t de colunas 
de H, 1 ≤ t ≤ s – 1, o que é uma contradição. Portanto, w (c) ≥ s e w (C) ≥ s. 

Reciprocamente, suponhamos que w (C) ≥ s. Suponhamos ainda, por absurdo, que H 

tenha  s  –  1  colunas  linearmente  dependentes.  Suponhamos  que  sejam  as  colunas 
ℎ(cid:3036)(cid:3117), ℎ(cid:3036)(cid:3118), … , ℎ(cid:3036)(cid:3294)(cid:3127)(cid:3117). Dessa forma, haveria (cid:1855)(cid:3036)(cid:3117), (cid:1855)(cid:3036)(cid:3118), … , (cid:1855)(cid:3036)(cid:3294)(cid:3127)(cid:3117), nem todos nulos, tais que  

(cid:1855)(cid:3036)(cid:3117)ℎ(cid:3036)(cid:3117) + (cid:1855)(cid:3036)(cid:3118)ℎ(cid:3036)(cid:3118) +  … +   (cid:1855)(cid:3036)(cid:3294)(cid:3127)(cid:3117)ℎ(cid:3036)(cid:3294)(cid:3127)(cid:3117) = 0. 

Logo, c = (0, ... , (cid:1855)(cid:3036)(cid:3117), 0, ... , (cid:1855)(cid:3036)(cid:3294)(cid:3127)(cid:3117), 0, ..., 0) ∈ C e, consequentemente, w (c) ≤ s – 1 < s, 

o que seria um absurdo. (cid:0) 

Teorema 3.3. Seja H a matriz teste de paridade de um código C. Temos que o peso de C é 

igual  a  s  se,  e  somente  se,  quaisquer  s  –  1  colunas  de  H  são  linearmente  independentes  e 

existem s colunas de H linearmente dependentes. 

Demonstração:  Vamos  supor  que  w  (C)  =  s.  Logo,  todo  conjunto  de  s  –  1  colunas  de  H  é 

linearmente independente. Portanto, existem s colunas de H linearmente dependentes, pois se 

 35 

 
 
 
 
 
 
isso não acontecesse, teríamos w (C) ≥ s – 1, em observância ao apresentado na proposição 

anterior. 

Suponhamos,  agora,  que  todo  conjunto  de  s  –  1  colunas  de  H  é  linearmente 

independente  e  existem  s  colunas  linearmente  dependentes.  Daí,  pela  proposição  anterior, 

temos que w (C) ≥ s. Todavia, w (C) não pode ser maior que s, pois se isso ocorresse, pela 

proposição  anterior,  teríamos  que  todo  conjunto  com  s  colunas  de  H  é  linearmente 

independente, o que é uma contradição. (cid:0) 

Teorema 3.4. Cota de Singleton 

Os parâmetros (n, m, d) de um código linear satisfazem à desigualdade  

(cid:1856) ≤ (cid:1866) − (cid:1865) + 1. 

Demonstração:  A  matriz  teste  de paridade  H  tem  posto n –  m.  O  Teorema 3.3  nos permite 

afirmar que d – 1 é menor ou igual ao posto de H. Portanto, daí segue a desigualdade. (cid:0) 

3.4 Um Exemplo de Código 

Definição 3.13. (Código de Hamming) Um código de Hamming de ordem t sobre (cid:2418)(cid:2870) é um 

código com matriz teste de paridade Ht de ordem t x n, em que t = n – m, cujas colunas são 

(cid:3047) (exceto o vetor nulo de (cid:1832)(cid:2870)
os elementos de (cid:1832)(cid:2870)
determina o código C a menos de equivalência. 

(cid:3047)) em uma ordem qualquer. A definição de Ht 

Observa-se que o comprimento do  código  de  Hamming  de ordem t  é  (cid:1866)  =   2(cid:3047) − 1 =

2(cid:3041)(cid:2879)(cid:3040) − 1. A dimensão do código é m.  

Verifica-se que d = 3, pois em Ht é fácil achar três colunas linearmente dependentes. 

Como exemplo, consideremos a matriz 

(cid:1834)(cid:2871) = (cid:3429)

1 0 1 1 1 0 0
1 1 0 1 0 1 0
0 1 1 1 0 0 1

(cid:3433). 

Está é a matriz do código de Hamming correspondente a t = 3. 

Teorema 3.5. Todo código de Hamming é perfeito. 

Demonstração: No caso, como d =3, então κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675)= 1. Dado c em (cid:1832)(cid:2870)

(cid:3047), temos que | D (c, 1) | 

= 1 + n. 

 36 

 
 
 
 
 
 
 
 
 
 
 
 
Portanto,  

| ⋃

(cid:3030) ∈ (cid:3004)

(cid:1830) ((cid:1855), 1)| = 

[1 + (cid:1866)]. 2(cid:3040) = [1 + 2(cid:3041)(cid:2879)(cid:3040) − 1]. 2(cid:3040) = 2(cid:3041), 

e, consequentemente, 

⋃

(cid:3030) ∈ (cid:3004)

(cid:1830) ((cid:1855), 1) = 

(cid:3041). (cid:0) 

(cid:1832)(cid:2870)

3.5 Decodificação pela Síndrome 

A decodificação é o procedimento de detecção e correção de erros em um código. O 

método  que  será  apresentado  aqui  para  decodificação  é,  segundo  Hefez  e  Villela  (2008,  p. 

104)  um  aperfeiçoamento  do  método  inventado  por  D.  Slepian  que  era  utilizado  no 

laboratório Bell na década de 60. 

Inicialmente,  vamos  definir  o  vetor  erro  e  ∈  (cid:2418)(cid:3044)

(cid:3041)  como  a  diferença  entre  o  vetor 

recebido r ∈ (cid:2418)(cid:3044)

(cid:3041)  e o vetor transmitido c ∈ (cid:2418)(cid:3044)

(cid:3041):  

e = r – c. 

Por exemplo, se em um código sobre (cid:2418)(cid:2870) = {0, 1} foi transmitida a palavra 010011 e 

foi recebida a palavra 101011, então o vetor erro é e = 101011 – 010011 = 111000. 

O  peso  do  vetor  erro  indica  a  quantidade  de  erros  cometidos  na  transmissão.  No 

exemplo  anterior, o  valor do peso do  vetor  erro é  3, o que  indica  que ocorreram 3  erros  na 

transmissão. 

Tomemos, agora, a matriz H que faz o teste de paridade do código e calculemos Het. 

Como a palavra c pertence ao código, temos Hct = 0 e, então, verificamos que Het = H(rt – ct) 

= Hrt. Isso nos direciona ao próximo resultado. 

Definição  3.14.  (Síndrome  de  um  vetor)  Dados  um  código  C  ⊂  (cid:2418)(cid:3044)

(cid:3041), 
(cid:3041)  e  um  vetor  v  ∈  (cid:2418)(cid:3044)

chamamos de síndrome de v o vetor Hvt, onde H é a matriz teste de paridade do código C. 

Como  Het =  Hrt,  então podemos dizer  que o  vetor erro  e  e o  vetor  recebido  r  tem  a 

mesma síndrome. 

De fato, se chamarmos de hi a i-ésima coluna da matriz teste de paridade H e tivermos 

um vetor erro e = (x1, ... , xn), então 

(cid:3041)
(cid:3533) (cid:1876)(cid:3036)
(cid:3036)(cid:2880)(cid:2869)

ℎ(cid:3036) = (cid:1876)(cid:2869) (cid:4684)

ℎ(cid:2869)(cid:2869)
⋮
ℎ((cid:3041)(cid:2879)(cid:3040))(cid:2869)

(cid:4685) + ⋯ + (cid:1876)(cid:3041) (cid:4684)

ℎ(cid:2869)(cid:3041)
⋮
ℎ((cid:3041)(cid:2879)(cid:3040))(cid:3041)

(cid:4685) = 

 37 

 
 
 
 
 
 
 
 
 
 
= (cid:4684)

(cid:1876)(cid:2869)ℎ(cid:2869)(cid:2869) + ⋯ +   (cid:1876)(cid:3041)ℎ(cid:2869)(cid:3041)
⋮
(cid:1876)(cid:2869)ℎ((cid:3041)(cid:2879)(cid:3040))(cid:2869) + ⋯ +   (cid:1876)(cid:3041)ℎ((cid:3041)(cid:2879)(cid:3040))(cid:3041)

(cid:4685) = (cid:1834)(cid:1857)(cid:3047) =  (cid:1834)(cid:1870)(cid:3047). (cid:0) 

O  resultado  a  seguir  é  de  extrema  importância,  pois  é  por  meio  dele  que  é  possível 

efetuar a correção de uma palavra transmitida com erro. 

Teorema 3.6.  Seja C um código linear em (cid:2418)(cid:3044)

(cid:3041) com capacidade de correção κ. Se r ∈ (cid:2418)(cid:3044)

(cid:3041) e c ∈ 

C ⊂ (cid:2418)(cid:3044)

(cid:3041) são tais que d (c, r) ≤ κ, então existe um único vetor e com w(e) ≤ κ cuja síndrome é 

igual à síndrome de r e tal que c = r – e.  

Demonstração:  A demonstração deste teorema será dividida em três partes:  

Primeira Parte: Provando a existência do vetor e 

O problema que deveremos resolver é como determinar o vetor e a partir de Hrt. 

Suponhamos que um código C tenha distância mínima d ≥ 3 (pois caso contrário κ = 0 

e nada teríamos para demonstrar) e que o vetor erro e, introduzido entre a palavra transmitida 

c e a palavra recebida r, seja tal que w(e) ≤ 1, ou seja, o canal introduziu no máximo um erro. 

Se Het = 0, então r ∈ C e tomamos r = c. 

Se  Het  ≠  0,  então  w(e) =  1  e,  então, e  tem  apenas  uma  coordenada  não  nula.  Nesse 

caso, consideremos que e = (0, ... , x, ..., 0) com x ≠ 0 na i-ésima posição.  

Verificamos que  

Het = xhi, onde hi é a i-ésima coluna de H. 

Portanto, não conhecendo e, mas sabendo que:  

Het = Hrt = xhi, 

Podemos determinar e como sendo o vetor com todas as componentes nulas, exceto a 

i-ésima componentes que é x. 

Para  w(e) > 1, podemos  fazer  essa  mesma  construção,  anexando  mais coordenadas 

não nulas para o vetor e. 

Além disso w(e) = w (r – c) = d(c, r) e d(c, r) ≤ κ, então existe um vetor e tal que 

w(e) ≤  κ. 

Segunda Parte: Provando que a síndrome de e é igual a síndrome de r 

De fato, c = r – e e Het = H(rt – ct) = Hrt – Hct =  Hrt – 0 = Hrt . 

 38 

 
 
 
 
 
 
 
 
 
Terceira Parte: Provando a unicidade de e 

Para provar a unicidade, suponhamos que existam os vetores e = (x1, ... , xn) e e’ = 

(x’1,  ...  ,  x’n),  e  ≠  e’,  que  satisfaçam  w(e)  ≤  κ  e  w(e’)  ≤  κ  e  que  tenham  síndromes  iguais. 

Então, se H é uma matriz teste de paridade de C, temos 

(cid:3041)

(cid:1834)(cid:1857)(cid:3047) = (cid:1834)((cid:1857)′)(cid:3047)   ⇒  (cid:3533) (cid:1876)(cid:3036)ℎ(cid:3036)

(cid:3041)
= (cid:3533) (cid:1876)′(cid:3036)ℎ(cid:3036)
(cid:3036)(cid:2880)(cid:2869)
(cid:2869)) ℎ(cid:2869) + ⋯ + ((cid:1876)(cid:3041)−(cid:1876)(cid:4593)

(cid:3036)(cid:2880)(cid:2869)
⇒    ((cid:1876)(cid:2869) − (cid:1876)(cid:4593)

(cid:3041)) ℎ(cid:3041) = 0, ou seja, 

  ⇒    (cid:1876)(cid:2869)ℎ(cid:2869) + ⋯ +  (cid:1876)(cid:3041)ℎ(cid:3041) − (cid:1876)(cid:4593)

(cid:2869)ℎ(cid:2869) − ⋯ − (cid:1876)(cid:4593)

(cid:3041)ℎ(cid:3041) = 0 

(cid:3041)
(cid:3533)((cid:1876)(cid:3036) − (cid:1876)(cid:4593)
(cid:3036)(cid:2880)(cid:2869)

(cid:3036))ℎ(cid:3036) = 0

Como w(e) ≤ κ e w(e’) ≤ κ, ou seja, há no máximo κ entradas não nulas em cada vetor,  

consequentemente  no  máximo  2κ  coeficientes  ((cid:1876)(cid:3036) − (cid:1876) (cid:4593)
combinação linear . Mas  

(cid:3036))   ≠ 0,  com  i  ∈  {1,  2,  ...  ,  n},  na 

(cid:3041)
(cid:3533)((cid:1876)(cid:3036) − (cid:1876)(cid:4593)
(cid:3036)(cid:2880)(cid:2869)

(cid:3036))ℎ(cid:3036) = 0

, 

o que nos fornece uma relação de dependência linear entre m colunas de H com m ≤ 2κ ≤ d–1. 

Como  quaisquer  d  –  1  colunas  de  H  são  linearmente  independentes,  conforme  o 

teorema 3.3, temos que xi = x’i para todo i e, portanto, e = e’. (cid:0) 

3.5.1 O algoritmo para códigos que corrigem um erro 

Seja C ⊂ ℤ(cid:2870)

(cid:2873) o código gerado pela matriz  

(cid:1833) = (cid:4674)

1 0 1 1 0
0 1 0 1 1

(cid:4675). 

Suponhamos que o vetor erro e, introduzido entre a palavra transmitida c e a palavra 

recebida  r,  seja  tal  que  w(e) ≤ 1.  Suponhamos,  ainda, que  tenha  sido  enviada  a palavra c  = 

10110 e recebida a palavra r = 11110. Estudaremos a decodificação de r. 

Inicialmente, verificamos que a matriz G está na forma padrão G = [ Idm | A ]; que a 

dimensão  do  código  é  m  =  2, pois  a  imagem do  código  é  gerada  por dois  vetores;  e  que o 

tamanho  das  palavras  é  n  =  5.  Com  essa  informações,  podemos  construir  a  matriz  teste  de 

paridade H = [– At | Idn–m  ]: 

 39 

 
 
 
 
 
 
 
(cid:1834) = (cid:3429)

1 0 1
1 1 0
0 1 0

0 0
1 0
0 1

(cid:3433). 

Assim, após obter H, podemos calcular Hrt: 

(cid:3429)

1 0 1
1 1 0
0 1 0

0 0
1 0
0 1

(cid:3433)

1
⎤
⎡
1
⎥
⎢
1
⎥
⎢
1
⎥
⎢
0⎦
⎣

= (cid:3429)

0
1
1

(cid:3433) 

e podemos concluir que a palavra foi transmitida com erro, pois o resultado Hrt não foi o vetor 

nulo. Dessa forma, como w(e) ≤ 1, podemos concluir que há um erro na transmissão e que o 

vetor erro terá a forma e = (0, ... , x, ..., 0) com x ≠ 0 na i-ésima posição.  

Então, devemos determinar qual é a i-ésima posição. Para tanto, devemos calcular Het  

=  Hrt, mas    Het    =  xhi,  onde  hi  é  a  i-ésima  coluna  de  H.  Fazendo  a  conta,  verificamos  que         

i = 2, pois 

1 0 1
(cid:3429)
1 1 0
0 1 0

0 0
1 0
0 1

(cid:3433)

1
⎤
⎡
1
⎥
⎢
1
⎥
⎢
1
⎥
⎢
0⎦
⎣

= (cid:3429)

0
1
1

(cid:3433) = 1 (cid:3429)

0
1
1

(cid:3433) = 1. ℎ(cid:2870), 

e, então, escrevemos o vetor erro e = (0, 1, 0, 0, 0). Agora, falta apenas achar c. Como e = r – 

c,  ou  ainda  c  =  r  –  e,  obtemos  c  fazendo:  c  =  11110  –  01000  =  10110,  que  foi  a  palavra 

transmitida. 

Diante  do  exemplo  apresentado,  podemos  descrever  um  algoritmo  que  permite  a 

decodificação em códigos corretores de até um erro: 

Seja H a matriz teste de paridade de um código C e seja r um vetor recebido (suponhamos d 

≥ 3) 

i) 

ii) 

iii) 

iv) 

Calcule Hrt. 

Se Hrt = 0, aceite r como a palavra transmitida. 

 Se Hrt = st, compare st com as colunas de H. 

Se existirem i e x tais que st = xhi, para x ∈ (cid:2418), então e é a n-upla com x na posição 

i e zeros nas outras posições. Corrija r pondo c = r – e. 

v) 

Se o contrário de (iv) ocorrer, então mais de um erro foi cometido. 

 40 

    
 
 
    
    
 
 
 
 
 
3.5.2 Classes laterais 

Tomemos um vetor v ∈ (cid:2418)(cid:3044)

(cid:3041). Definimos o conjunto classe lateral de v segundo o código 

C ⊂ (cid:2418)(cid:3044)

(cid:3041) como sendo 

v + c = {v + c; c ∈ C}. 

Esse conjunto possui algumas propriedades, as quais serão elencadas a seguir e cuja 

demonstração pode ser verificada em Hefez e Villela (2008, p. 107-109). 

i) 

ii) 

iii) 

iv) 

v) 

Os vetores u e v de (cid:2418)(cid:3044)

(cid:3041) têm a mesma síndrome se, e somente se, u ∈ v + C; 

v + C = v’ + C ⇔ v – v’ ∈ C 

(v + C) ∩ (v’ + C) ≠ ∅  ⇒ v + C = v’ + C 

⋃

(cid:3289)
(cid:3049)∈(cid:2418)(cid:3292)

(cid:3041)
((cid:2204) + (cid:1829)) = (cid:2418)(cid:3044)

| (v + C) | = | C | = qm. 

O mais importante das classes laterais é que todos os elementos de uma classe têm a 

mesma  síndrome  e  que  os  elementos  de  classes  laterais  distintas  têm  síndromes  diferentes. 

(cid:3041). 
Estas características definem uma partição em (cid:2418)(cid:3044)

Por exemplo, seja C ⊂ (cid:2418)(cid:2870)

(cid:2872) o código gerado pela matriz  

(cid:1833) = (cid:4674)

1 0 1 1
0 1 0 1

(cid:4675). 

Nele, temos que: a dimensão do código é m = 2, pois a matriz G tem duas linhas; o 

tamanho das palavras é n = 4, pois a matriz G tem 4 colunas; o valor de q = 2, pois o alfabeto 

(cid:2418) tem 2 elementos.  

Com  essas  informações,  verificamos  que  n  –  m  =  2  e,  portanto,  o  número  de 

elementos de cada classe lateral será 4 = 22 = qm. O número de classes laterais é 

(cid:3044)(cid:3289)
(cid:3044)(cid:3288) = (cid:1869)(cid:3041)(cid:2879)(cid:3040) =

2(cid:2870) = 4.  

Por meio da matriz G também podemos obter as palavras do código. Basta fazer  

[0 0] (cid:4674)

[0 1] (cid:4674)

1 0 1 1
0 1 0 1
1 0 1 1
0 1 0 1

(cid:4675) = [0 0 0 0]; [1 0] (cid:4674)

(cid:4675) = [1 0 1 1]; 

(cid:4675) = [0 1 0 1]; [1 1] (cid:4674)

(cid:4675) = [1 1 1 0]. 

1 0 1 1
0 1 0 1
1 0 1 1
0 1 0 1

 41 

 
 
 
 
 
 
 
 
 
 
Ante o exposto, verificamos que as classes laterais são as seguintes: 

0000 + C = {0000, 1011, 0101, 1110} 

1000 + C = {1000, 0011, 1101, 0110} 

 0100 + C = {0100, 1111, 0001, 1010}  

  0010 + C = {0010, 1001, 0111, 1100}.  

Um  vetor de peso  mínimo  em uma  classe  lateral  é  chamado de  elemento líder dessa 

classe. Então, 0000 é o líder de C; 1000 é o líder de 1000 + C; 0100 e 0001 são líderes de 

0100 + C; e 0010 é líder de 0010 + C.  

O exemplo anterior mostrou que uma classe lateral pode ter mais de um líder. Todavia, 

o  que  se  busca  é  a  construção  de  um  código  em  que  cada  classe  tenha  um  único  líder. 

Verifiquemos, então, os resultados a seguir. 

Teorema 3.7. Tomando-se um código linear C ⊂ (cid:2418)(cid:3044)

(cid:3041) com distância mínima d, se u ∈ (cid:2418)(cid:3044)

(cid:3041)  é tal 

que w(u) ≤ (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675), então u é o único elemento líder de sua classe. 

Demonstração:  Suponhamos que  u,  v ∈ (cid:2418)(cid:3044)

(cid:3041)  com  w(u)  ≤ (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675)  e  w(v) ≤ (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675).  Se  u  e  v  são 

elementos da mesma classe, então u – v ∈ C, pois 

(cid:3421)

(cid:1873) ∈ (cid:1877) + (cid:1829) ⇒ (cid:1873) = (cid:1877) + (cid:1855)(cid:2869)
(cid:1874) ∈ (cid:1877) + (cid:1829) ⇒ (cid:1874) = (cid:1877) + (cid:1855)(cid:2870)
(cid:1873) − (cid:1874) = (cid:1855)(cid:2869) − (cid:1855)(cid:2870)   ∈  (cid:1829)

. 

Nesse  caso,  w(u –  v)  ≤  w(u) +  w(v) ≤ (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) + (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) ≤  d − 1.  Como w(c) ≥  d para 

todo c ∈ C ≠ 0, então u – v = 0 e, portanto, u = v. (cid:0) 

Observação importante: O código apresentado na seção anterior não possui um único 

elemento líder em suas classes laterais pois d = 2, logo  (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 0 . 

3.5.3 Decodificação pela síndrome 

Após a apresentação das informações anteriores, podemos apresentar um algoritmo de 

correção  de  mensagens  que  tenham  sofrido  uma  quantidade de  erros  menor  ou  igual  a  κ  = 

(cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675). 

 42 

 
 
 
 
 
 
 
 
Inicialmente,  devemos  determinar  os  elementos  u  ∈  (cid:2418)(cid:3044)

(cid:3041)  tais  que  w(u)  ≤  (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675).  Em 

seguida, devemos calcular as síndromes desses elementos e colocá-las em uma tabela. 

i) 

ii) 

Então, ao recebermos uma palavra r, devemos: 

Calcular a síndrome st = Hrt 

Se s está na tabela construída, tomamos o elemento l líder da classe tal que H.lt = 

st. Em seguida, trocamos r por r – l, pois r – l = c, onde c é a palavra do código 

transmitida. 

iii) 

Se s não está na tabela, então na mensagem recebida foram cometidos mais do que 

κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:4675)
(cid:2870)

erros. 

Por exemplo, consideremos um código linear C ⊂ (cid:2418)(cid:2870)

(cid:2874) com matriz teste de paridade 

(cid:1834) = (cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433). 

Como a matriz teste de paridade é uma matriz de ordem (n – m) x n, então temos que 

n – m = 3 e n = 6. Daí, temos que a dimensão do código é  m = 3. Além disso, verificamos 

que  as  colunas  da  matriz  H  são  linearmente  independentes  2  a  2  e  existem  três  colunas 

linearmente dependentes (primeira, segunda e quarta), podemos dizer que a distância mínima 

do código é d = 3 e, portanto, ele pode corrigir até κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 1 erro. 

Vamos escrever os vetores de (cid:2418)(cid:2870)

(cid:2874) com w(u) ≤ 1 e suas respetivas síndromes: 

(cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

(cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

(cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

⎡
⎢
⎢
⎢
⎢
⎣

⎡
⎢
⎢
⎢
⎢
⎣

⎡
⎢
⎢
⎢
⎢
⎣

0
⎤
0
⎥
0
⎥
0
⎥
⎥
0
0⎦
0
⎤
0
⎥
1
⎥
0
⎥
⎥
0
0⎦
0
⎤
0
⎥
0
⎥
0
⎥
⎥
1
0⎦

= (cid:3429)

0
0
0

(cid:3433);  (cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

⎡
⎢
⎢
⎢
⎢
⎣

= (cid:3429)

= (cid:3429)

0
0
1

0
1
1

(cid:3433) ; (cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

(cid:3433) ; (cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

 43 

0
⎤
1
⎥
0
⎥
0
⎥
⎥
0
0⎦
0
⎤
0
⎥
0
⎥
1
⎥
⎥
0
0⎦
0
⎤
0
⎥
0
⎥
0
⎥
⎥
0
1⎦

⎡
⎢
⎢
⎢
⎢
⎣

⎡
⎢
⎢
⎢
⎢
⎣

= (cid:3429)

0
1
0

(cid:3433) ; 

= (cid:3429)

= (cid:3429)

1
1
0

1
0
1

(cid:3433) ; 

(cid:3433) ; 

 
 
 
 
    
 
    
    
    
    
    
    
Então: 

(cid:3429)

1 0 0
0 1 0
0 0 1

1 0 1
1 1 0
0 1 1

(cid:3433)

1
⎤
⎡
0
⎥
⎢
0
⎥
⎢
0
⎥
⎢
⎥
0
⎢
0⎦
⎣

= (cid:3429)

1
0
0

(cid:3433). 

Tabela 3 
Líder  Síndrome 

000000 

000001 

000010 

000100 

001000 

010000 

100000 

000 

101 

011 

110 

001 

010 

100 

Fonte: FAMAT em Revista. 
Disponível em: http://www.portal.famat.ufu.br/sites/famat.ufu.br/files/Anexos/Bookpage/Famat_Revista_06.pdf 

Suponhamos que tenha sido recebida a palavra r = 100011. Logo, como Hrt = (010)t, 

temos que e = 010000. Consequentemente, c = r – e = 100011 – 010000 = 110011. 

Suponhamos, agora, que tenha sido recebida a palavra r = 111111. Logo, como Hrt = 

(111)t não se encontra na tabela, foi cometido mais que um erro na mensagem. 

Tomemos outro exemplo. Seja C ⊂ (cid:2418)(cid:2870)

(cid:2877) um código linear gerado pela matriz 

(cid:1833) = (cid:4674)

1 1 1 1 0 0 0 1 0
0 0 0 1 1 1 1 0 1

(cid:4675) 

e que possui distância mínima d = 5. Por  meio da  matriz  geradora, podemos identificar  que  a 

dimensão do código é m = 2 e o tamanho das palavras é n = 9.  

A matriz G não está na forma padrão. Então, por meio de operações elementares entre 

as colunas, podemos deixá-la no formato desejado. Portanto, 

(cid:1833) = (cid:4674)

1 1 1 1 0 0 0 1 0
0 0 0 1 1 1 1 0 1

(cid:4675) (cid:1855)(cid:2870) ↔ (cid:1855)(cid:2873) 

(cid:1833) (cid:4593) = (cid:4674)

1 0 1 1 1 0 0 1 0
0 1 0 1 0 1 1 0 1

(cid:4675) = [(cid:1835)(cid:1856)(cid:2870) | (cid:1827)]. 

Agora, podemos montar uma matriz H de teste de paridade, 

 44 

    
 
 
 
 
 
(cid:1834) =

1 0 1 0 0 0 0 0 0
⎤
1 1 0 1 0 0 0 0 0
⎥
1 0 0 0 0
1
⎥
0 1 0 0 0
0
⎥
0 0 1 0 0
0
⎥
⎥
0 0 0 1 0
1
0 0 0 0 1⎦
0

0 0 0
1 0 0
0
0
1
0
0
0
0
0
1

⎡
⎢
⎢
⎢
⎢
⎢
⎣

= [−(cid:1827)(cid:3047) | (cid:1835)(cid:1856)(cid:2875)]. 

No caso, temos que (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 2 e, portanto, a tabela deve ser montada com os vetores de 

peso ≤ 2 e suas respectivas síndromes: 

Tabela 4 - Vetores na forma transposta (vt) 

0  1  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 

0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 

0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  0  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 

0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0 

0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  1  1  1  1  0  0  0  0  0  0 

0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  0  1  1  1  0  0  0 

0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  1  0  0  1  1  0 

0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  1  0  1  0  1 

0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  1  0  1  1 

Tabela 5 - Síndrome na forma transposta  (Hvt) 

0  1  0  1  0  0  0  0  0  0  1  0  1  1  1  1  1  1  1  0  0  0  0  0  0  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 

0  1  1  0  1  0  0  0  0  0  0  1  0  1  1  1  1  1  1  0  1  1  1  1  1  1  0  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0 

0  1  0  0  0  1  0  0  0  0  1  1  1  0  1  1  1  1  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  1  1  1  1  0  0  0  0  0  0 

0  0  1  0  0  0  1  0  0  0  1  0  0  0  1  0  0  0  1  1  1  0  1  1  1  0  0  1  0  0  0  0  1  0  0  0  1  0  0  0  1  1  1  0  0  0 

0  0  1  0  0  0  0  1  0  0  1  0  0  0  0  1  0  0  1  1  1  1  0  1  1  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  1  0  0  1  1  0 

0  1  0  0  0  0  0  0  1  0  1  1  1  1  1  1  0  1  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  1  0  1  0  1 

0  0  1  0  0  0  0  0  0  1  1  0  0  0  0  0  0  1  1  1  1  1  1  1  0  0  0  0  0  0  1  0  0  0  0  1  0  0  0  1  0  0  1  0  1  1 

Suponhamos  que  a  palavra  recebida  seja  r  =  111011000.  Verificamos  que  Hrt  = 

(0000111)t,  valor que  não  consta  na  tabela, o que significa  que  na  palavra  foram  cometidos 

mais de dois erros.  

Agora  consideremos  a  palavra  recebida  r  =  111011100.  Verificamos  que    Hrt  = 

(0000011)t, palavra que existe na tabela. Tomamos então o líder da classe correspondente, que 

é o vetor 0000011 e obtermos a palavra transmitida c = 111011100 – 0000011 = 111011111, 

a qual pertence ao código, pois Hct = 0. 

 45 

 
 
 
 
 
 
 
4 FUNDAMENTAÇÃO PEDAGÓGICA 

Segundo  consta  nas  Orientações  Educacionais  Complementares  aos  Parâmetros 

Curriculares Nacionais para o Ensino Médio (PCN+, 2000, p. 8), o referido nível de ensino 

tem  por  objetivo  “preparar  para  a  vida,  qualificar  para  a  cidadania  e  capacitar  para  o 

aprendizado permanente, em eventual prosseguimento dos estudos ou diretamente no mundo 

do trabalho”. É em busca dessa finalidade que a área das Ciências da Natureza, Matemática e 

suas  Tecnologias  se  apresenta  como  capaz  de  desenvolver  competências  que  envolvem  a 

representação  e  a  comunicação;  a  investigação  e  compreensão;  e  a  contextualização  sócio-

cultural.  

Abordando-se mais especificamente o conhecimento matemático, é possível  verificar 

que ele desenvolve competências que auxiliam na tomada de decisões e também ampliam as 

habilidades do pensamento, ou seja, ele é capaz de ajudar na interpretação da realidade e no 

desenvolvimento de habilidades ao longo da vida social e profissional.  

Para que o Ensino Médio alcance os objetivos acima propostos e consiga efetivamente 

desenvolver as competências descritas, é preciso que o docente esteja preparado para utilizar 

novas  técnicas  de  ensino-aprendizagem.  Sobre  o  trabalho  do professor,  afirma  Parra  e  Saiz 

(apud Vilela, 2008, p. 8, 9): 

O trabalho do professor consiste [...] em propor ao aluno uma situação 
de aprendizagem para que elabore seus conhecimentos como resposta 
pessoal  a  uma  pergunta,  e  os  faça  funcionar  ou  os  modifique  como 
resposta às exigências do meio e não a um desejo do professor. (Parra 
e Saiz, 1996, p. 49) 

Portanto,  o  docente  deve  estar  pronto  para  propor  atividades  que  envolvam  a 

contextualização  dos  conteúdos,  a  resolução de  problemas,  a  aplicação  de  jogos  e  o uso  de 

computadores com a finalidade de construir o conhecimento. Dessa forma, o professor poderá 

contribuir para que os estudantes estejam preparados para os vários desafios que encontrarão 

quando finalizarem o Ensino Básico, uma vez que a sociedade está cada vez mais globalizada 

e informatizada.  

 46 

 
 
 
 
 
 
 
 
4.1 A Importância da Contextualização Histórica da Matemática 

A  análise  do  contexto  histórico  na  construção  dos  conceitos  matemáticos  é  muito 

importante. Segundo D’ Ambrosio: 

ideias  matemáticas  comparecem  em 

toda  a  evolução  da 
“As 
humanidade, definindo estratégias de ação para lidar com o ambiente, 
criando  e  desenhando  instrumentos  para  esse  fim,  e  buscando 
explicações  sobre os  fatos  e  fenômenos da natureza  e  para  a  própria 
existência.  Em  todos  os  momentos  da  história  e  em  todas  as 
civilizações, as ideias matemáticas estão presentes em todas as formas 
de fazer e de saber.” (D’ Ambrosio, 1999, p. 97) 

Assim,  podemos  afirmar  que  a  análise  histórica  contribui  para  a  construção  do 

conhecimento  pelos  alunos,  pois  permite  dar  significado  aos  conteúdos  escolares,  uma  vez 

que ajuda os educandos a entenderem os motivos que levam pessoas a fazerem Matemática e 

que  as  necessidades  (sejam  elas  práticas,  sociais,  econômicas  ou  físicas)  normalmente 

estimulam o desenvolvimento matemático.  

É claro que a formalização de uma teoria utilizada hoje não é idêntica à realizada no 

passado, quando foi obtido aquele resultado matemático. Entretanto, é importante que o aluno 

compreenda  em  que  circunstâncias  a  teoria  foi  formulada,  pois  isso  permitirá  uma  melhor 

compreensão  dos  conceitos  e  a  construção  do  conhecimento.  Nesse  sentido,  Viana  e  Silva 

afirmam que 

 “[...]  a  partir  do  momento  que  se  conhece  a  HM  [História  da 
Matemática], as aulas ficam mais interessantes e com aprendizado de 
qualidade” (Viana e Silva, 2007, p. 6).  

Ressalte-se  que  a  contextualização  histórica  de  um  conteúdo  matemático  não  serve 

apenas para se tornar uma aula mais interessante ou para dar significado a um conteúdo. Ela 

vai além, pois ajuda o aluno a perceber que a Matemática não está isolada dos demais saberes. 

Segundo Miguel e Miorim (apud Oliveira, Alves e Neves), as contribuições são da forma: 

(1) “A  matemática  como  uma  criação  humana;  (2)  as  razões  pelas 
quais  as  pessoas  fazem  Matemática;  (3)  as  necessidades  práticas, 
econômicas e físicas que servem de estímulo ao desenvolvimento 
das  ideias  matemáticas;  (4)  as  conexões  existentes  entre  a 
matemática e filosofia, matemática e religião, matemática e lógica, 

 47 

 
 
 
 
 
 
etc.;  (5)  a  curiosidade  estritamente  intelectual  que  pode  levar  a 
generalização e extensão de ideias e teorias; (6) as percepções que 
os  matemáticos  têm  do  próprio  objeto  da  matemática,  as  quais 
mudam  e  se  desenvolvem  ao  longo  do  tempo;  (7)  a  natureza  de 
uma  estrutura, de um  axiomatização  e  de  uma prova.”  (Miguel  e 
Miorim, 2004, p. 33) 

Portanto,  se  a  história  da  Matemática  for  utilizada  em  sala  de  aula,  será  criado  um 

ambiente  que  proporciona  ao  aluno  um  aprendizado  significativo,  por  meio  do  qual  será 

possível que o educando participe da descoberta dos conteúdos, observe os aspectos humanos 

envolvidos  no  desenvolvimento  de  uma teoria  e  analise  o  contexto  histórico  de  surgimento 

dela  (as  circunstâncias  em que  ela  foi  desenvolvida,  crenças,  emoções,  afetos  e outros  itens 

envolvidos no surgimento da teoria). 

4.2 A Resolução de Problemas como Estratégia de Ensino-aprendizagem 

O  ensino  da  Matemática  por  meio  da  resolução  de  problemas  auxilia  na 

contextualização dos conteúdos, uma vez que a Matemática é utilizada para resolver diversos 

problemas e situações no cotidiano.  

A recomendação de que o ensino seja contextualizado está nos PCN+: 

“Aprender  Matemática  de  uma  forma  contextualizada,  integrada  e 
relacionada a outros conhecimentos traz  em si o desenvolvimento de 
competências  e  habilidades  que  são  essencialmente  formadoras,  à 
medida  que  instrumentalizam  e  estruturam  o  pensamento  do  aluno, 
capacitando-o  para  compreender  e  interpretar  situações,  para  se 
apropriar  de  linguagens  específicas,  argumentar,  analisar  e  avaliar, 
tirar  conclusões  próprias,  tomar  decisões,  generalizar  e  para  muitas 
outras ações necessárias à sua formação.” (Brasil, 2010, p. 111) 

Para  que  a  metodologia  possa  ser  utilizada,  é  importante  que  alunos  e  professores 

saibam a diferença entre um problema matemático e um exercício matemático. O primeiro é 

definido como  

“uma  situação que demanda  a  realização  de uma  sequência  de  ações 
ou  operações  para  obter  um  resultado.  Ou  seja,  a  solução  não  está 
disponível de início, mas é possível construí-la” (PCN, 1998, p. 41)  

ou, segundo Silveira, como  

 48 

 
 
 
 
 
 
 
 
 
  
 
 
 
“toda  situação  requerendo  a  descoberta  de  informações  matemáticas 
desconhecidas  para  a  pessoa  que  tenta  resolvê-lo  e/ou  a  invenção  de 
uma  demonstração  de  um  resultado  matemático  dado.”    (Silveira, 
2001) 

O segundo, de acordo com Silveira é  

de 

atividade 

“uma 
alguma 
adestramento 
habilidade/conhecimento  matemático  já  conhecido  pelo  resolvedor, 
como  a  aplicação  de  um  algoritmo  conhecido,  de  uma  fórmula 
conhecida” (Silveira, 2001) 

uso 

no 

de 

Dessa  forma,  se  na  atividade  que  está  sendo  realizada  os  alunos  conseguem  interpretar  um 

enunciado,  estruturam  as  situações  apresentadas  (não  necessariamente 

todas  elas), 

desenvolvem uma ou mais estratégias de resolução e efetuam a verificação do resultado, então 

está sendo utilizado um problema matemático. Ressalta-se que o foco não é ensinar os alunos 

a resolverem problemas, mas sim ensinar Matemática por meio da resolução de problemas. 

Nesse sentido, para que um professor utilize o método de resolução de problemas para 

o  ensino  de  Matemática,  ele  deve  desenvolver  atividades  que  despertem  a  curiosidade  dos 

alunos – com problemas compatíveis com o desenvolvimento intelectual deles – e que sejam 

capazes de estimular os educandos a desenvolverem um trabalho investigativo – seja com o 

auxílio do professor ou com o auxílio de colegas –, a fim de encontrar a solução do problema. 

Essa maneira de interagir se assemelha ao que é sugerido por Vygotsky, pois permite que o 

discente  construa  o  conhecimento, passando da zona  de desenvolvimento  proximal (na  qual 

não consegue realizar todas as atividades sozinho, sendo dependente do auxílio recebido pelo 

professor  ou  por  outros  colegas)  para  a  zona  de  desenvolvimento  real  (quando,  então,  terá 

apreendido as novas teorias matemáticas e será capaz de resolver os problemas propostos de 

forma independente).  

Vygotsky  (1999)  ainda  destaca  a  importância  dos  problemas  para  a  formação  dos 

conceitos: 

“A  formação  de  conceitos  é  o  resultado  de  uma  complexa  atividade 
em que todas as funções intelectuais básicas tomam parte. No entanto, 
o processo não pode ser reduzido à associação, à atenção, à formação 
de  imagens,  à  inferência  ou  às  tendências  dominantes.  Todas  são 
indispensáveis, porém insuficientes sem o uso do signo, ou a palavra, 
como  meio  pelo  qual  conduzimos  as  nossas  operações  mentais, 
controlamos o seu curso e as canalizamos em direção à solução de um 
problema.” (Vygotsky, 1999, p. 72-73) 

 49 

 
 
 
 
 
o que corrobora a tese de que a solução de problemas pode ser utilizada para a construção dos 

conceitos matemáticos. 

4.3 O Uso do Computador em Sala de Aula 

Atualmente  vivemos  em  uma  sociedade  em  que  a  quantidade  de  informações 

transmitidas e a velocidade de transmissão estão cada vez maiores. A internet se tornou algo 

praticamente essencial no cotidiano das pessoas e é notória uma constante busca de inserção 

social  e  participação  na  nova  realidade digital  pelos  indivíduos.  A  escola  não  pode  ficar  de 

fora  dessa  nova  realidade.  Ela  precisa  criar  situações  em  que  seja  possível  a  utilização  do 

potencial  didático  dos  computadores,  softwares,  tablets,  smartphones,  internet,  etc.  na 

colaboração ao processo de ensino-aprendizagem.  

Isso é o que propõe Masseto (apud Quiles, 2009), 

“é  impossível  dialogarmos  sobre  tecnologia  e  educação,  inclusive 
educação  escolar,  sem  abordarmos  a  questão  do  processo  de 
aprendizagem.  Com  efeito,  a  tecnologia  apresenta-se  como  meio, 
como instrumento para colaborar no desenvolvimento do processo de 
aprendizagem” (Masseto, 2006, p. 139) 

Para  que  essa  colaboração  ao  processo  de  ensino-aprendizagem  ocorra,  é  necessário 

mais que o simples uso de um computador em sala de aula. O domínio do uso de um software 

por  parte  do  docente  também  não  garante  que  serão  criadas  situações  favoráveis  ao 

aprendizado. É preciso algo mais. O professor tem que reconstruir o conhecimento, modificar 

sua prática. Nesse sentido, afirma Oliveira (2007, p. 59): 

Os  recursos  computacionais  em  si  mesmos,  quando  amplamente 
dominados pelo professor, não são suficientes para garantir uma ação 
educacional  diferenciada,  se  não  estiverem  claras  e  fundamentas  as 
teorias. Assim, além da necessidade de saber lidar com o computador, 
o professor deve  entregar-se  ao  processo de  construir para  si  mesmo 
um novo conhecimento, incorporando não somente os princípios que 
estão  sendo  atualmente  desenvolvidos  sobre  informática  e  educação, 
mas  acima  de  tudo,  passando  pelas  considerações  teóricas  sobre  a 
aprendizagem que melhor explicam a aquisição do conhecimento e o 
desenvolvimento  cognitivo.  Trata-se  de  dominar  o  conhecimento 
científico  de  uma  maneira  ampla  e  necessária  para  o  seu  próprio 
aprimoramento intelectual. 

 50 

 
 
 
 
 
 
 
Valente (1999) também nos diz que 

Caberá  ao  professor  saber  desempenhar  um  papel  de  desafiador, 
mantendo  vivo  o  interesse  do  aluno  em  continuar  a  buscar  novos 
conceitos e estratégias de uso desses conceitos, incentivando relações 
sociais de modo que os alunos possam aprender uns com os outros a 
trabalhar  em  grupo.  Além  disso,  o  professor  deverá  servir  como 
modelo de aprendiz e ter um profundo conhecimento dos pressupostos 
teóricos que embasam os processos de construção de conhecimento e 
das tecnologias que podem facilitar esses processos. (1999, p. 40) 

Portanto,  o  computador  não  deve  ser  utilizado  para  tornar  informatizada  uma  aula 

tradicional. Isso não trará nenhum benefício. Ele deve ser empregado para criar um ambiente 

colaborativo,  investigativo,  no  qual  os  alunos  possam  formular  e  testar  conjecturas.  Um 

ambiente  no qual os educandos sejam ativos e busquem a construção do conhecimento, não 

sendo recipientes em que as informações são “depositadas”. Se o computador for empregado 

com esse fim, haverá o desenvolvimento nos alunos de habilidades voltadas à organização do 

pensamento e raciocínio, além da ampliação de uma postura autônoma e reflexiva, por meio 

do  desenvolvimento  de  habilidades  voltadas  à  tomada  de  decisões  e  construção  do  próprio 

conhecimento. 

Além do exposto, para que o computador cumpra seu papel de colaborar no processo 

de ensino-aprendizagem, é preciso que suas potencialidades sejam aproveitadas. Isso pode ser 

realizado por meio de softwares educacionais ou até mesmo por meio do uso de softwares não 

predominantemente educacionais – como planilhas eletrônicas. Esses programas permitem a 

representação dos objetos matemáticos de forma diferenciada e facilitam a compreensão dos 

conteúdos. Além disso, podem ser utilizados para que procedimentos rotineiros da matemática 

– contas grandes, por exemplo – sejam realizados de forma mais rápida e, então, os educandos 

ficam com mais tempo para a reflexão e a análise das situações-problema. 

Dessa  forma,  com  o  uso  do  potencial  dos  computadores  e  com  uma  mudança  na 

prática docente, as aulas serão mais prazerosas e dinâmicas e os alunos terão outra visão sobre 

o que é a Matemática. 

4.4  Paradigma Construtivista 

Os  Parâmetros  Curriculares  Nacionais  para  o  Ensino  Médio  recomendam  o 

desenvolvimento de uma proposta de ensino que busque o  

 51 

 
 
 
 
às  necessidades  da  vida  contemporânea, 

“desenvolvimento  de  conhecimentos  práticos,  contextualizados,  que 
respondam 
e  o 
desenvolvimento  de  conhecimentos  mais  amplos  e  abstratos,  que 
correspondam  a  uma  cultura  geral  e  a  uma  visão  de  mundo” 
(BRASIL, 2000, p. 6).  

Caminha  nesse  sentido o paradigma construtivista, no qual a Matemática  não é  vista 

como objeto de ensino e sim objeto de aprendizagem, por meio do qual é procurada a inserção 

do aluno em situações de investigação, exploração e descobrimento, ou seja, o discente passa 

a ser considerado ativo no processo de construção do conhecimento.  

São  vários  os  autores  que  oferecem  subsídios  teóricos  sobre  o  construtivismo, 

podendo-se citar Piaget, Vygotsky e Ausubel. As atividades a serem propostas, na concepção 

teórica  piagetiana,  devem  provocar  desequilíbrios  que,  após  equilibração  e  acomodação, 

levam os alunos ao aprendizado. Na concepção de Vygotsky, as atividades atuam na zona de 

desenvolvimento  proximal,  buscando  a  ligação  entre  o  nível  de  desenvolvimento  real  e  o 

potencial. E quanto à concepção teórica de Ausubel, afirma Moreira e Masini (2006) que para 

ocorrer uma aprendizagem significativa é preciso estabelecer, a priori, uma comparação entre 

as  concepções  que  o  aluno  já  possui  e  o  conceito  a  ser  apresentado,  devendo  o  professor 

promover  a  interação  da  informação  nova  com  estruturas  de  conhecimento  existentes  nos 

indivíduos. Essas estruturas já existentes são definidas como conceitos subsunçores Assim, 

Ausubel  define  o  processo  de  aprendizagem  significativa  como  aquele  em  que  o  conceito 

subsunçor  (que  é  o  conceito  de  referência  dos  indivíduos)  é  transformado  ou  adaptado  ao 

conceito  novo,  sendo  estabelecido  um  novo  elemento  significativo,  sem  que  os  conceitos 

percam seus significados.  

Estas  considerações  estão  em  consonância  com  os  PCN  do  Ensino  Médio,  uma  vez 

que ao estabelecer que os alunos devam ver a Matemática como ciência, é afirmado que é  

“importante  que o  aluno  perceba que as  definições,  demonstrações  e 
encadeamentos conceituais e lógicos têm a função de construir novos 
conceitos  e  estruturas  a  partir  de  outros  e  que  servem  para  validar 
intuições e dar sentido às técnicas aplicadas” (BRASIL, 2000, p. 40-
41).  

As propostas baseadas na abordagem construtivista abrangem, dentre outras, situações 

que envolvem a resolução de problemas como proposta metodológica, o uso de computadores 

e a história da Matemática como fator motivacional. A primeira tem por objetivo estimular os 

 52 

 
 
 
 
 
alunos, com o uso de situações problemas, a serem investigadores e exploradores na busca e 

construção dos novos conceitos. A segunda é de extrema importância, haja vista a influência 

da tecnologia no cotidiano dos discentes. Valente (1999, p. 24-25) afirma que  

“[...] o computador pode enriquecer ambientes de aprendizagem onde 
o aluno, interagindo com os objetos desse ambiente, tem a chance de 
construir  seu  conhecimento.  Nesse  caso,  o  conhecimento  não  é 
passado  ao  aluno.  O  aluno  não  é  mais  instruído,  ensinado,  mas  é  o 
construtor  do  seu  próprio  conhecimento.  Esse  é  o  paradigma 
construcionista onde a ênfase está na aprendizagem ao invés de estar 
no  ensino;  na  construção  do  conhecimento  e  não  na  instrução.” 
(Valente ,1999, p. 24-25) 

E a terceira é realizada pela contextualização histórica do objeto de estudo, inserindo-o num 

processo histórico e cultural, como resultado da construção humana, conforme sugerido nos 

PCN+ do Ensino Médio (BRASIL, 2002). 

Dessa  forma,  por  meio  do  paradigma  construtivista,  é  possível  atingir  os  objetivos 

propostos nos PCN do Ensino Médio, haja vista que se pode cultivar no aluno, segundo uma 

abordagem formativa da Matemática,  

“[...] a capacidade de resolver problemas genuínos, gerando hábitos de 
investigação,  proporcionando  confiança  e  desprendimento  para 
analisar  e  enfrentar  situações  novas,  propiciando a  formação de  uma 
visão  ampla  e  científica  da  realidade,  a  percepção  da  beleza  e  da 
harmonia, o desenvolvimento da criatividade e de outras capacidades 
pessoais.” (BRASIL, 2000, p.6) 

e,  numa  abordagem  instrumental,  prepara-se  o  discente  para  a  atividade  profissional, 

desenvolvendo a iniciativa e a segurança para adaptar os conceitos matemáticos em diferentes 

contextos.  Com  isso,  prepara-se  o  aluno  para  selecionar  informações,  analisá-las,  tomar 

decisões, bem como avaliar possibilidades e adequações tecnológicas em diferentes situações.  

 53 

 
  
 
 
 
 
 
 
 
 
 
 
5 PROPOSTAS DE ATIVIDADES 

5.1 Conteúdo Disciplinar 

Nos  códigos  lineares  corretores  de  erros  são  utilizados,  principalmente,  os  seguintes 

conteúdos: sistema de  numeração (na escolha do alfabeto), operações com vetores (soma de 

vetores,  produto  por  escalar,  dependência  e  independência  linear),  matrizes  (na  matriz 

geradora G e  na matriz teste de paridade H) e sistemas  lineares (na  verificação de que uma 

palavra pertence ao código sem o uso da matriz H). 

5.2 Proposta 

A proposta de atividades que será apresentada neste capítulo foi elaborada para atingir 

todos  os  objetivos  elencados  na  fundamentação  pedagógica.  Para  tanto,  serão  apresentados 

aos discentes exemplos de como a Matemática está presente no cotidiano. Além disso, serão 

analisadas situações-problema contextualizadas, as quais, para serem resolvidas, exigirão que 

os  alunos  adotem  uma  postura  crítica  e  reflexiva,  sendo  ativos  no  processo  de  ensino-

aprendizagem.  

As  referidas  atividades,  além  de  tornarem  o  estudo  da  Matemática  mais  prazeroso, 

ainda  auxiliarão  no  desenvolvimento  do  pensamento  algébrico  pelos  educandos  e,  também, 

podem  despertar  o  interesse  deles  pela  ciência,  fazendo  com  que  alguns  dos  alunos  se 

voluntariem a participar em projetos de iniciação científica para o Ensino Médio. 

5.3 Atividades 

5.3.1 Atividade 1 

Título: Um exemplo de transmissão de informações: “passando cola” 

Material/Recurso  necessário:  quadro  negro  (ou  branco),  giz  (ou  caneta  piloto),  uma 

avaliação interdisciplinar (impressa para cada um dos alunos), pequenos pedaços de papel. 

Divisão  da  Turma:  não  haverá  formação  de  grupos  nessa  atividade.  Os  alunos  deverão 

responder a todas as questões da prova e poderão consultar aos colegas que estejam próximos 

a eles. 

 54 

 
 
 
 
 
 
 
 
Tempo estimado: 60 minutos 

Descrição sucinta:  

Esta  atividade  tem  por  obtivo  mostrar  aos  educandos  como  é  possível  codificar  e 

decodificar informações.  

Aspectos operacionais: 

O  professor  apresentará  aos  alunos  uma  prova  objetiva,  ou  seja,  uma  “prova  de 

múltipla  escolha”,  a  qual  pode  conter  questões  sobre  atualidades  ou  algum  conteúdo  da 

Matemática ou de outras disciplinas. Um exemplo de avaliação está no apêndice A. 

O  docente  irá  pedir  aos  alunos,  antes  de  iniciar  a  prova,  que  pensem  nas  maneiras 

possíveis de passar cola a um colega com o uso de um pequeno pedaço de papel. Em seguida, 

o docente  deve  propor uma  forma de  transmissão  de  respostas,  sem  que  seja  notado que  se 

trata  de  algo  relativo  à  prova.  Para  isso,  a  ferramenta  a  ser  utilizada  será  um  algoritmo 

matricial.  Façamos  o  seguinte  exemplo.  Suponhamos  que  a  questão  e  sua  resposta  sejam 

codificadas por um vetor da forma (cid:4674)

(cid:1876)
(cid:1877)(cid:4675) em que x é o número da questão (1, 2, 3, ... , 8) e y é a 
alternativa  correta,  porém  as  respostas  referentes  às  letras  a,  b,  c,  d,  e  devem  ser  trocadas 

pelos números 1, 2, 3, 4, 5, respectivamente. Dessa forma, a codificação da fonte determina 

que se a resposta da questão 1 for a letra a, deve ser utilizado o vetor  (cid:4674)

1
1

(cid:4675); e se a resposta da 

questão 6 for a letra c, deve ser utilizado o vetor  (cid:4674)

6
3
Em seguida, o professor deve escolher uma matriz 2 x 2 invertível13. Vamos utilizar, 

(cid:4675). 

nesta exemplificação, a matriz (cid:1827) = (cid:4674)

2 3
1 2

(cid:4675) (esta será a matriz que, quando multiplicada pelo 

cada um dos vetores correspondentes à questão e sua respectiva resposta, irá gerar cada uma 

das palavras do código de canal). 

Portanto, podemos exemplificar que o código de canal de todas as possíveis respostas 

da questão 1 é obtido por meio dos produtos a seguir: 

(cid:1843)(cid:1873)(cid:1857)(cid:1871)(cid:1872)ã(cid:1867) 1 − (cid:1864)(cid:1857)(cid:1872)(cid:1870)(cid:1853) (cid:1853):  (cid:4674)

(cid:4675) . (cid:4674)

(cid:4675) =    (cid:4674)

(cid:1843)(cid:1873)(cid:1857)(cid:1871)(cid:1872)ã(cid:1867) 1 − (cid:1864)(cid:1857)(cid:1872)(cid:1870)(cid:1853) (cid:1854):  (cid:4674)

(cid:4675) . (cid:4674)

(cid:4675) =    (cid:4674)

2 3
1 2
2 3
1 2

1
1
1
2

5
3
8
5

(cid:4675) 

(cid:4675) 

13 O motivo de a matriz A ser necessariamente uma matriz invertível é que, se ela não o for, a equação matricial  
AX = B não terá solução. Isso será explicado com mais detalhes na próxima página. 

 55 

 
 
 
                                                 
  (cid:1843)(cid:1873)(cid:1857)(cid:1871)(cid:1872)ã(cid:1867) 1 − (cid:1864)(cid:1857)(cid:1872)(cid:1870)(cid:1853) (cid:1855):  (cid:4674)

(cid:4675) . (cid:4674)

(cid:4675) = (cid:4674)

(cid:4675) 

   (cid:1843)(cid:1873)(cid:1857)(cid:1871)(cid:1872)ã(cid:1867) 1 − (cid:1864)(cid:1857)(cid:1872)(cid:1870)(cid:1853) (cid:1856):  (cid:4674)

(cid:4675) . (cid:4674)

(cid:4675) = (cid:4674)

   (cid:1843)(cid:1873)(cid:1857)(cid:1871)(cid:1872)ã(cid:1867) 1 − (cid:1864)(cid:1857)(cid:1872)(cid:1870)(cid:1853) (cid:1857):  (cid:4674)

(cid:4675) . (cid:4674)

(cid:4675) = (cid:4674)

2 3
1 2
2 3
1 2
2 3
1 2

1
3
1
4
1
5

11
7
14
9
17
11

(cid:4675) 

(cid:4675) 

Dessa forma, caso um aluno queira avisar a um colega que a resposta da questão 1 é a 

letra d, ele deverá “passar cola” informando o vetor (cid:4674)

14
9

(cid:4675). 

O discente que está “recebendo a cola”, por sua vez, deverá proceder à decodificação 

da  mensagem,  a  fim  de  descobrir  a  que  questão  se  refere  a  resposta  e,  ainda,  qual  é  a 

alternativa  (a,  b,  c,  d  ou  e)  referente  à  resposta  transmitida.  Para  tanto,  uma  maneira  de 

decodificar a reposta recebida seria resolver a equação matricial A.X = B, haja vista que são 

conhecidas as matrizes A e B.  

Por  exemplo,  para  o  aluno  descobrir  a  que  questão  se  refere  e  qual  a  alternativa 

indicada por meio do vetor (cid:4674)

14
9

(cid:4675), ele deveria resolver  

(cid:4674)

2 3
1 2

(cid:4675) . (cid:4674)

(cid:1876)
(cid:1877)(cid:4675) = (cid:4674)

14
9

(cid:4675), 

que é equivalente a encontrar a solução do sistema  

2(cid:1876) + 3(cid:1877) = 14
(cid:3420)
(cid:1876) + 2(cid:1877) = 9

. 

Todavia,  existe  um  método  mais  rápido  para  decodificar  uma  resposta.  O  referido 

método consiste no cálculo da matriz coluna X por meio da solução da equação de matrizes a 

seguir: 

(cid:1827). (cid:1850) = (cid:1828)  ↔ (cid:1827)(cid:2879)(cid:2869). (cid:1827). (cid:1850) = (cid:1827)(cid:2879)(cid:2869). (cid:1828) ↔ (cid:1835). (cid:1850) = (cid:1827)(cid:2879)(cid:2869). (cid:1828) ↔ (cid:1850) = (cid:1827)(cid:2879)(cid:2869). (cid:1828). 

Dessa maneira, podemos concluir que por meio do produto das matrizes (cid:1827)(cid:2879)(cid:2869) (cid:1868)(cid:1867)(cid:1870) (cid:1828) é possível 

obtermos o  vetor  do  código  fonte  que permitirá  a  identificação  do  número  da  questão  e  da 

alternativa correspondente a ela.  

É  importante  ressaltar  que  a  equação  matricial  resolvida  no  parágrafo  anterior  só 

possui solução se a matriz A é invertível14. Podemos destacar uma maneira prática para obter 

a inversa de uma matriz 2 x 2, que é por meio da seguinte fórmula: 

(cid:1845)(cid:1857) (cid:1827) =   (cid:4674)

(cid:1853) (cid:1855)
(cid:1854) (cid:1856)

(cid:4675) , (cid:1857)(cid:1866)(cid:1872)ã(cid:1867) (cid:1827)(cid:2879)(cid:2869) =

1
(cid:1853)(cid:1856) − (cid:1854)(cid:1855)

(cid:4674) (cid:1856) −(cid:1855)
(cid:1853)
−(cid:1854)

(cid:4675). 

14  Se  (cid:1827) ∈ (cid:1839)(cid:3041)(ℝ)  é  inversível,  então  existe    (cid:1827)(cid:2879)(cid:2869)  tal  que  (cid:1827)(cid:2879)(cid:2869). (cid:1827) = (cid:1835).  Então,  det((cid:1827)(cid:2879)(cid:2869). (cid:1827)) = det((cid:1835)).  Como 
det((cid:1827)(cid:2879)(cid:2869). (cid:1827)) = det((cid:1827)(cid:2879)(cid:2869)) . det ((cid:1827))  e  det(I)  =  1,  então  det  ((cid:1827)(cid:2879)(cid:2869)) = (cid:2869)
.  Por  isso,  concluímos  que  para  existir  a 
inversão de uma matriz A, seu determinante não pode ser nulo. 

(cid:2914)(cid:2915)(cid:2930) ((cid:3002))

 56 

 
                                                 
Portanto,  utilizando  a  mencionada  fórmula,  determinamos  a  inversa  de  A,  que  é          

(cid:1827)(cid:2879)(cid:2869) = (cid:4674)

2 −3
2
−1

(cid:4675). Então, o aluno deve efetuar o produto (cid:4674)

2 −3
2
−1

(cid:4675) . (cid:4674)

(cid:4675) = (cid:4674)

(cid:4675) para obter a 

1
4

14
9
14
9

“cola” almejada. Ou seja, o educando irá decodificar o código de canal (cid:4674)

(cid:4675) para o código de 

fonte (cid:4674)

1
4

(cid:4675), o qual indica que a resposta se refere à primeira questão, alternativa d. 

Estabelecida  a  forma  de  codificação  e  decodificação,  o  professor  deve  autorizar  o 

início da prova. Cada um dos alunos, ao finalizar a prova, deverá escrever suas respostas no 

formato  codificado  pelo  código  de  canal  na  folha  de  respostas.  Após  todos  os  alunos 

realizarem  a  prova,  o  professor  deverá  colocar  as  respostas  no  quadro,  porém  na  forma 

codificada pelo canal, deixando que os alunos procedam à verificação delas. 

Respostas:  

5
(cid:4674)
3

(cid:4675) , (cid:4674)

13
8

(cid:4675) , (cid:4674)

18
11

(cid:4675) , (cid:4674)

17
10

(cid:4675) , (cid:4674)

16
9

(cid:4675) , (cid:4674)

24
14

(cid:4675) , (cid:4674)

29
17

(cid:4675) (cid:1857)  (cid:4674)

28
16

(cid:4675). 

1a, 2c, 3d, 4c, 5b, 6d, 7e, 8d. 

Procedimento pedagógico: 

Esta  atividade  propõe que  o  aluno  utilize  um  código  de  fonte  e  um  código  de  canal 

para codificar e decodificar informações. Por meio dela se espera que os educandos entendam 

para que serve um código e o que motivou o estudo sobre os códigos corretores de erros.  

Durante  a  realização  da  atividade,  é  possível  que  algum  aluno  reclame  que  recebeu 

uma resposta “inexistente”. Caso isso não aconteça, o professor deve criar essa situação por 

meio  de  um  exemplo  de  vetor  que  ao  ser  multiplicado  pela  matriz  inversa  não  retorna 

resultados  referentes  à  questão.  O docente  pode  supor, por  exemplo, que uma  cola  recebida 

tem a forma do vetor codificado pela matriz A = (cid:4674)

12
8

(cid:4675), e que ao proceder à decodificação foi 

encontrado  o  resultado  (cid:4674)

2 −3
2
−1

(cid:4675) . (cid:4674)

12
8

(cid:4675) = (cid:4674)

0
4

(cid:4675),  ou  seja,  ocorreu  algum  problema,  pois  não 

existe  a  questão  zero.  Nesse  instante,  o  professor  dirá  que  o  algoritmo  permite  apenas  a 

transmissão  de  informações,  sem  ser  possível  sua  correção,  e  que  esse  foi  o  problema  que 

motivou o estudo dos códigos corretores de erros. O professor pode aproveitar a oportunidade 

para fazer um resumo das condições históricas do surgimento dos códigos corretores de erros. 

Uma boa fonte de consulta é a Introdução do artigo intitulado “Breve introdução à Teoria dos 

Códigos Corretores de Erros”, de autoria de César Polcino Milies, apresentado no Colóquio 

 57 

 
 
 
de Matemática da Região Centro-Oeste, que foi realizado de 03 a 06 de novembro de 2009, e 

está  disponível  em  http://www.sbm.org.br/docs/coloquios/CO-1-09.pdf.  Além  disso,  a 

presente dissertação também é uma fonte de embasamento teórico sobre o assunto. 

5.3.2 Atividade 2 

Título: Os códigos corretores estão mais próximos de nós do que imaginamos 

Material/Recurso necessário: computador, projetor multimídia, quadro negro (ou branco) e 

giz (ou caneta piloto), embalagens de produtos onde o código de barras esteja visível 

Divisão  da  Turma:  em  alguns  momentos  haverá  a  formação  de  duplas  ou  grupos  nessa 

atividade. 

Tempo estimado: 100 minutos 

Descrição sucinta:  

Passo 1: Tem por objetivo despertar o interesse dos alunos para o estudo dos códigos 

corretores  de  erros.  Para  tanto,  será  apresentado o  exemplo da  língua  portuguesa,  que  é um 

código presente no cotidiano dos educandos. 

Passo  2:  Apresentar  um  exemplo  de  outros  códigos  presentes  no  cotidiano  dos 

educandos (UPC e EAN-13) e, também, mostrar que determinados algoritmos não são muito 

eficazes na detecção de erros. 

Passo  3:  Apresentar outro  exemplo de  códigos  presentes  no  cotidiano,  o qual  possui 

um mecanismo mais eficaz de detecção do que o que foi exibido no passo 2. 

Aspectos operacionais: 

O  professor deverá reservar  com  antecedência  o computador  e o projetor  multimídia 

de sua unidade escolar. 

Passo 1: 

O docente deverá iniciar a atividade com a projeção do seguinte parágrafo por meio do 

projetor multimídia: 

 58 

 
 
 
 
 
 
 
 
 
“De aorcdo com uma pqsieusa de uma uinrvesriddae ignlsea, não ipomtra em 

qaul  odrem  as  lrteas  de  uma  plravaa  etãso,  a  úncia  csioa  iprotmatne  é  que  a 

piremria  e  útmlia  lrteas  etejasm  no  lgaur  crteo.  O  rseto  pdoe  ser  uma  ttaol 

bçguana que vcoê pdoe anida ler sem pobrlmea. Itso é poqrue nós não lmeos 

cdaa lrtea isladoa, mas a plravaa cmoo um tdoo” 

Fonte: Troca-letras tem fundamento científico.  
Disponível em http://www.academus.pro.br/site/pg.asp? pagina=detalhe_variedade&titulo=Variedades 
&codigo=88&cod_categoria=&nome_categoria= 

Ele  pedirá,  então,  aos  alunos  que  façam  a  leitura  do  texto.  Espera-se  que  todos 

consigam ler o parágrafo. 

Após a referida leitura, o professor apresentará no quadro palavras soltas, com erros, e 

pedirá  que  os  alunos  digam  qual  a  palavra  correta.  A  primeira  sequência  de  palavras  deve 

possuir uma verificação de erro e correção bem  simples e direta. Por exemplo, “cathorro” e 

“telebisão”. A segunda sequência deve ser diferente. Por exemplo, “aato” e “aaca”. A palavra 

“aato” pode ser bato, mato, pato, gato, iato, etc. A palavra “aaca” pode ser vaca, maca, etc. 

Nesses  últimos  exemplos,  é  necessário  que  seja  acrescentado  um  contexto,  a  fim  de  que  a 

correção  seja  efetuada.  O  professor  pode  utilizar  frases  como  “a  aaca  leiteira  está  em  uma 

pastagem  verdinha”  ou  “o rato bebe  leite  todo dia”.  No primeiro caso, o  erro  está  claro  e  a 

palavra  correta é  vaca.  No  segundo,  aparentemente  não  há  erro, pois  rato  é  uma palavra  da 

língua portuguesa. Todavia, rato não bebe leite, e sim o gato. Dessa forma, encontra-se o erro 

e é efetuada a correção. 

Passo 2: 

Terminada  a  primeira  parte,  o  professor  deve  comentar  com  os  alunos  que  existem 

outros códigos muito utilizados no cotidiano, citando o código de barras. 

Inicialmente, o docente deverá explicar aos alunos como é formado o código de barras, 

dando-se ênfase à maneira como é obtido o dígito de verificação, pois é ele quem vai informar 

se houve ou não erro na digitação da sequência numérica referente ao código. Essa explicação 

pode ser apresentada com o uso do projetor multimídia ou com o quadro (negro ou branco). 

Após, o docente deverá aplicar a atividade descrita abaixo, na qual alguns exercícios 

são  adaptações  do  que  foi  apresentado  nas  dissertações  de  mestrado  que  tem  por  tema 

“Aritmética:  código de barras  e  outras  aplicações  de  congruências”  apresentada  por  Josiane 

Colombo  Pedrini  Esquinca  em  2013  (consulta  por  meio  do  site  http://bit.profmat-

 59 

 
  
 
 
sbm.org.br/xmlui/handle/123456789/371)  e  “Propostas  de  Utilização  de  Códigos  de  Barras 

como  Recurso  Didático  para  o  Ensino  de  Matemática”  apresentada  por  Valeska  Aparecida 

Rodrigues  da  Silva  em  2013 

(consulta  por  meio  do 

site  http://bit.profmat-

sbm.org.br/xmlui/handle/123456789/141/browse?value=VALESKA+APARECIDA+RODRI

GUES+DA+SILVA&type=author). 

O professor, então, após a explicação do funcionamento dos códigos UPC e EAN-13, 

deve  distribuir  aos  alunos  uma  folha  de  questões  (folha  de  atividades 2)  e pode  sugerir  que 

eles formem duplas a fim de resolver as questões. A folha de atividades 2 está no final deste 

capítulo.  

Espera-se, ao final da atividade, que os alunos consigam entender que a construção de 

um bom código corretor de erros não é uma tarefa simples, uma vez que é possível verificar, 

por meio dos exercícios, que em alguns casos ocorreu erro, mas ele sequer foi detectado. 

Informações complementares referentes ao passo 2: 

Na década de 1970 começou a ser utilizado um código para identificação de produtos. 

Esse  código  foi  elaborado  por  Geoge  J.  Laurer  e  ficou  conhecido  como  UPC  (Universal 

Product  Code),  sendo  adotado  nos  Estados  Unidos  e  no  Canadá.  Ele  consistia  de  listras 

verticais  alternadas,  nas  cores  preta  e  branca,  com  um  número  indicado  abaixo  delas.  A 

sequência dos números totalizava 12 dígitos. As larguras das barras verticais variam, podendo 

ser finas, médias, grossas ou muito grossas.  

A interpretação das barras deve ser realizada em conformidade com a tabela abaixo. 

Listras 

Branca 

Preta 

Fina 

0 

1 

Tabela 6 

Média 

00 

11 

Grossa 

Muito grossa 

000 

111 

0000 

1111 

Fonte: Códigos de Barras e outras Aplicações de Congruências. 
Disponível em http://bit.profmat-sbm.org.br/xmlui/handle/123456789/371. 

A  leitura  relativa  à  espessura  e  às  corres  das barras  é  realizada  de  forma que  a  cada 

quatro barras é obtida uma sequência de sete dígitos de zeros e uns. A referida sequência dá 

origem aos dígitos que aparecem abaixo das barras verticais, de acordo com a tabela a seguir. 

 60 

 
 
 
 
 
 
Dígito 

Tabela 7 
Lado esquerdo 

Lado direito 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0001101 

0011001 

0010011 

0111101 

0100011 

0110001 

0101111 

0111011 

0110111 

0001011 

1110010 

1100110 

1101100 

1000010 

1011100 

1001110 

1010000 

1000100 

1001000 

1110100 

Fonte: A Matemática dos Códigos de Barras. 
Disponível em http://mat.ufg.br/bienal/2006/mini/polcino.pdf 

Realizada  a  identificação  dos  algarismos  que  aparecem  abaixo  das  barras  verticais, 

podemos  enumerar  seus  significados.  O  primeiro  algarismo  indica  o  tipo  de  produto,  a 

sequência que se segue de outros cinco determina o fabricante, a sequência seguinte de mais 

cinco informa a classificação do produto e o último é um dígito verificador. 

Por exemplo: 

Figura 2 
Fonte: Figura adaptada de 
https://sistemas.ufms.br/sigpos/portal/trabalhos/download/1131/cursold:148 

 61 

 
 
 
 
O  número  036000  (lado  esquerdo)  e  291452  (lado  direito)  corresponde  à  sequência 

0001101  –  0111101  –  0101111  –  0001101  –  0001101  –  0001101  –  1101100  –  1110100  – 

1110010 – 1011100 – 1001110 – 1101100. 

A leitora do código consegue distinguir o lado direito do esquerdo, pois as sequências 

do lado esquerdo sempre têm um número ímpar de 1’s (“uns”) e as do direito um número par 

de  1’s  (“uns”).  Dessa  forma,  é  possível  à  máquina  efetuar  a  leitura  correta  do  código  de 

barras, seja passado o leitor da direita para esquerda, seja da esquerda para direita. 

Todavia,  apesar  de  a  máquina  possuir  essa  capacidade  de  leitura,  acontece,  algumas 

vezes,  de  ela  não  conseguir  realizar  a  identificação  do  produto.  Pode  haver  alguma 

imperfeição na embalagem ou ela pode estar molhada, por exemplo. Nesse caso, é preciso que 

a sequência numérica abaixo das barras seja digitada. É nessa situação que é possível notar a 

importância  do  dígito  verificador,  pois  ele  permite  a  identificação  de  erros  de  digitação  da 

referida sequência numérica.   

A  citada  verificação  se  dá  da  seguinte  forma.  É  calculado  o  produto  escalar  entre  o 

vetor de pesos (3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1), que é fixo, e o vetor construído por meio da 

sequência dos doze dígitos do código. O resultado dessa conta deve ser um múltiplo de dez. 

Caso isso não aconteça, é certo que ocorreu algum erro e a máquina informa isso na tela do 

computador. 

Vamos exemplificar essa situação por meio da figura de código de barras da figura 2. 

Para isso, devemos tomar o vetor (3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) e fazer o produto escalar com 

o vetor relativo à sequência numérica do código de barras (0, 3, 6, 0, 0, 0, 2, 9, 1, 4, 5, X). O 

resultado desta conta deve ser um múltiplo de 10. No caso do nosso exemplo, obtemos: 3.0 + 

1.3 + 3.6 + 1.0 + 3.0 + 1.0 + 3.2 + 1.9 + 3.1 + 1.4 + 3.5 + 1x = 58 + x. Para achar o valor de x, 

então, precisamos pensar que ele é o menor valor inteiro não negativo que quando somado a 

58  resulta  no  múltiplo  de  10  mais  próximo  de  58,  ou  seja,  devemos  fazer  x  =  2,  que  é 

exatamente o dígito de verificação que aparece na figura. 

O código descrito acima (UPC) foi alterado em 1976 por Laurer, a fim de ser realizado 

o acréscimo de um dígito. O código passou então a possuir treze dígitos e recebeu o nome de 

EAN-13  (European  Article  Numbering  system).  Todavia,  a  mudança  foi realizada de  forma 

que o leitor de barras pudesse  identificar tanto os códigos  UPC quanto os códigos EAN-13. 

Para isso, foi acrescido um zero antes do código UPC, sendo mantidas as demais informações. 

Dessa  maneira,  EUA  e  Canadá  são  identificados  por  um  zero  como  o  primeiro  número  do 

código.  Nos  demais  países,  a  identificação  é  realizada  por  meio  dos  três  primeiros  dígitos, 

conforme descrito na figura abaixo. 

 62 

Figura 3 
Fonte: Aritmética: Códigos de Barras e outras Aplicações de Congruências.  
Disponível em http://bit.profmat-sbm.org.br/xmlui/handle/123456789/371. Figura adaptada. 

As listras verticais alternadas, nas cores preta e branca, seguem a mesma codificação 

que o código UPC. 

Listras 

Branca 

Preta 

Fina 

0 

1 

Tabela 8 

Média 

00 

11 

Grossa 

Muito grossa 

000 

111 

0000 

1111 

Fonte: Aritmética: Códigos de Barras e outras Aplicações de Congruências. 
Disponível em http://bit.profmat-sbm.org.br/xmlui/handle/123456789/371. 

Também é mantida a leitura de forma semelhante, pois a cada quatro barras verticais é 

associada  uma  sequência  de  sete  dígitos  de  0’s  (“zeros”)  e  1’s  (“uns”),  e  um  número  é 

indicado  abaixo  das  barras  verticais.  Todavia,  a  tabela  em  que  são  mostrados  os  dígitos 

correspondentes a cada um dos blocos de 0’s (“zeros”) e 1’s (“uns”) é a seguinte: 

 63 

 
 
 
 
 
 
 
 
 
 
Dígito 

Lado esquerdo (ímpar)  Lado esquerdo (par) 

Lado direito 

Tabela 9 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0001101 

0011001 

0010011 

0111101 

0100011 

0110001 

0101111 

0111011 

0110111 

0001011 

0100111 

0110011 

0011011 

0100001 

0011101 

0111001 

0000101 

0010001 

0001001 

0010111 

1110010 

1100110 

1101100 

1000010 

1011100 

1001110 

1010000 

1000100 

1001000 

1110100 

Fonte: A Matemática dos Códigos de Barras. 
Disponível em http://mat.ufg.br/bienal/2006/mini/polcino.pdf 

Podemos  verificar  que  a  codificação  do  lado  direito  é  idêntica  ao  sistema  UPC 

(número  par  de  uns).  Todavia,  a  codificação  do  lado  esquerdo  foi  alterada.  Ela  agora  pode 

começar com um número par ou ímpar de dígitos iguais a 1, conforme a tabela apresentada 

acima. 

Falta apenas a indicação do dígito inicial. Ele é escolhido por meio de uma alternância 

entre a quantidade de dígitos pares ou ímpares, conforme abaixo. 

Dígito inicial 

1º 

Tabela 10 (continua) 
2º 

3º 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Ímpar 

Par 

Par 

Par 

Par 

Par 

Par 

4º 

Ímpar 

Ímpar 

Par 

Par 

Ímpar 

Ímpar 

Par 

Par 

Par 

Ímpar 

Par 

Par 

Par 

Ímpar 

Par 

Par 

Ímpar 

Ímpar 

5º 

6º 

Ímpar 

Ímpar 

Par 

Ímpar 

Par 

Par 

Ímpar 

Ímpar 

Ímpar 

Par 

Par 

Par 

Par 

Ímpar 

Par 

Par 

Ímpar 

Par 

Ímpar 

Ímpar 

Par 

Ímpar 

Fonte: A Matemática dos Códigos de Barras. 
Disponível em http://mat.ufg.br/bienal/2006/mini/polcino.pdf 

 64 

 
 
 
Assim,  a  partir  das  informações  acima  podemos  fazer  um  exemplo.  Tomemos  o 

código  de  barras  da  página  anterior  (4-891668-326689).  O  código  é  iniciado  pelo  número 

quatro. Então a sequência do lado esquerdo é ímpar – par – ímpar – ímpar – par – par.  Desse 

modo, a correspondência obtida da tabela é 8 → 0110111; 9 → 0010111, 1 → 0011001, 6 → 

0101111, 6  →  0000101,  8  →  0001001.  A  sequência  do  lado  direito  é  3  →  1000010,  2  → 

1101100, 6 → 1010000, 6 → 1010000, 8 → 1001000 e 9 → 1110100. 

É  importante  ressaltar  que  o  leitor  de  barras  consegue  identificar  corretamente  a 

sequência  numérica,  mesmo  que  a  leitura  aconteça  de  forma  invertida,  pois  a  sequência  da 

direita  sempre começa com o algarismo um e a sequência da esquerda sempre começa com 

zero. 

De  forma  semelhante  ao  realizado  no  código  UPC,  pode  acontecer  de  leitor  não 

conseguir  realizar  a  identificação  do  produto,  sendo  necessária  a  digitação  da  sequência 

numérica.  Nesse  caso,  o  dígito  verificador,  como  nos  códigos  UPC,  demonstrará  sua 

importância,  pois  ele  permitirá  a  identificação  de  erros  de  digitação  da  referida  sequência 

numérica.   

A citada verificação se dará da seguinte maneira. É calculado o produto escalar entre o 

vetor de pesos (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1), que é fixo, e o vetor construído por meio da 

sequência dos treze dígitos do código. O resultado dessa conta deve ser um múltiplo de dez. 

Se isto não acontecer, ocorreu algum erro e a máquina informa isso na tela do computador. 

Vamos exemplificar  a  situação descrita  no  parágrafo  anterior  utilizando o  código  de 

barras que tem por numeração a sequência 4-891668-326689. Para isso, vamos tomar o vetor 

(1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) e fazer o produto escalar com o vetor relativo à sequência 

numérica do código de barras (4, 8, 9, 1, 6, 6, 8, 3, 2, 6, 6, 8, X). O resultado desta conta deve 

ser um múltiplo de 10. No nosso exemplo, obtemos: 1.4 + 3.8 + 1.9 + 3.1 + 1.6 + 3.6 + 1.8 + 

3.3 + 1.2 + 3.6 + 1.6 + 3.8 + 1x = 131 + x. Para achar o valor de x, então, devemos somar o 

menor valor inteiro não negativo que transforme 131 no múltiplo de 10 mais próximo de 131, 

ou seja, devemos fazer x = 9, que é exatamente o dígito de verificação que aparece no código. 

Passo 3: 

O  professor  vai  citar  outro  código  presente  no  cotidiano:  o  código  do  cadastro  de 

pessoas física (CPF).  

Inicialmente, o docente irá explicar que o referido código é composto de onze dígitos, 

em que os nove primeiros são de identificação e os dois últimos são dígitos verificadores. Em 

 65 

 
 
 
seguida, o professor deve apresentar o algoritmo que permite a detecção de que ocorreu algum 

erro na digitação do número do CPF. 

Verifiquemos um exemplo. Vamos examinar a autenticidade do CPF 043.658.306-27. 

Para isso, primeiramente, devemos calcular o resultado: 1.0 + 2.4 + 3.3 + 4.6 + 5.5 + 6.8 + 7.3 

+ 8.0 +  9.6 =  189.  Em  seguida, dividimos  189 por 11. O  resto da  mencionada  divisão  é  2. 

Após, tomamos o resto encontrado, que agora passa a ser o dividendo, e dividimos por 10. O 

novo resto encontrado também é 2. Dessa forma, encontramos o primeiro dígito de controle, 

que  é  2,  idêntico  ao  informado  no  CPF  043.658.306-27.  Agora,  realizaremos  a  outra 

verificação,  correspondente  ao  segundo  dígito  de  controle.  Para  isso,  vamos  calcular, 

inicialmente,  o  resultado:  1.4  +  2.3  +  3.6  +  4.5  +  5.8  +  6.3  +  7.0  +  8.6  +  9.2  =  172.  Em 

seguida, dividimos  172 por 11.  O resto da  mencionada divisão  é  7.  Após,  tomamos o  resto 

encontrado, que agora passa a ser o dividendo, e dividimos por 10. O novo resto encontrado 

também é 7.  Ou seja, o segundo dígito de controle é 7, confirmando a autenticidade do CPF 

043.658.306-27. 

O professor proporá aos educandos que verifiquem a autenticidade de seus respectivos 

números de CPF. Caso algum aluno não tenha ou não lembre de seu CPF, ele pode realizar a 

tarefa junto a um colega. 

Informações complementares referentes ao passo 3: 

O número do CPF de um indivíduo tem a forma (cid:1853)(cid:2869)(cid:1853)(cid:2870)(cid:1853)(cid:2871)(cid:1853)(cid:2872)(cid:1853)(cid:2873)(cid:1853)(cid:2874)(cid:1853)(cid:2875)(cid:1853)(cid:2876)(cid:1853)(cid:2877)(cid:1853)(cid:2869)(cid:2868)(cid:1853)(cid:2869)(cid:2869), em que 

cada  um  dos  (cid:1853)(cid:3036)  para  1  ≤  i  ≤ 9 é  um  número  de  identificação,  (cid:1853)(cid:2869)(cid:2868)  e  (cid:1853)(cid:2869)(cid:2869)  são  dígitos  de 

controle, e os (cid:1853)(cid:3036)(cid:3046) são números não negativos de um algarismo. 

O seguinte algoritmo pode ser utilizado para calcular os dígitos de controle. 

(cid:2877)

(cid:1853)(cid:2869)(cid:2868) = (cid:4684)(cid:3533) (cid:1861) .  (cid:1876)(cid:3036)

 ((cid:1865)(cid:1867)(cid:1856) 11)(cid:4685) ((cid:1865)(cid:1867)(cid:1856) 10)   (cid:1857) 

(cid:3036)(cid:2880)(cid:2869)

(cid:2869)(cid:2868)

(cid:1853)(cid:2869)(cid:2869) = (cid:4684)(cid:3533)((cid:1861) − 1) .  (cid:1876)(cid:3036)

 ((cid:1865)(cid:1867)(cid:1856) 11)(cid:4685) ((cid:1865)(cid:1867)(cid:1856) 10). 

(cid:3036)(cid:2880)(cid:2870)

Mais  informações  sobre  esse  assunto  podem  ser  obtidas  por  meio  do  Trabalho  de 

Conclusão  de  Curso  do  Mestrado  Profissional  em  Matemática  de  autoria  de  Fernanda 

Rodrigues  Alves  Costa  e  Marcelo  Oliveira  Veloso,  disponível  em    http://bit.profmat-

sbm.org.br/xmlui/handle/123456789/1166. 

 66 

 
 
 
 
 
 
 
Procedimento pedagógico 

          O passo 2 é com certeza o mais complicado para o aluno entender. Então, é necessária a 

utilização  de  mais  tempo  na  explicação  e  realização  de  exemplos  nesse  passo.  Para  isso, 

sugerimos a utilização de mais exemplos para o melhor aprendizado deste conteúdo, podendo 

o professor trazer mais alguns códigos de barras de produtos de sua casa.  

          É  importante o professor salientar que o erro, se existir, em diversas hipóteses15 pode 

ser  identificado  (evita  que  uma  pessoa  compre  um  produto  e  pague  por  outro),  mas  em 

nenhuma delas pode ser corrigido, isto é, o código do produto terá que ser passado novamente 

pelo leitor ou digitado manualmente. 

          Abaixo  sugerimos  outras  possibilidades  de  passos  para  a  atividade  2,  que  deverá  ser 

utilizada caso os alunos tenham demonstrado boa compreensão do conteúdo e interesse pelo 

assunto. 

Possibilidade de outros passos na atividade 2: 

O  professor  pode  se  utilizar  de  mais  exemplos  semelhantes  aos  apresentados  nos 

passos 2 e 3. Para tanto, basta utilizar como referência de pesquisa a dissertação de mestrado 

“Uma  análise  dos  esquemas  de  dígitos  verificadores  usados  no  Brasil”  apresentada  por 

Natália  Pedroza  de  Souza  em  2013,  no  Centro  de  Tecnologia  e  Ciência  do  Instituto  de 

Matemática 

e 

Estatística 

da  UERJ.  O 

arquivo 

está 

disponível 

em 

http://www.bdtd.uerj.br/tde_busca/arquivo.php?codArquivo=6100.  Inclusive,  na  elencada 

dissertação, é apresentada a explicação do motivo pelo qual o CPF é um código melhor que os 

códigos de barra, pois a probabilidade de não detecção de erros neste último é muito menor. 

5.3.3 Atividade 3 

Título: “Desarmando uma bomba”  

Material/Recurso necessário: computador, projetor multimídia, quadro negro (ou branco) e 

giz (ou caneta piloto). 

15 Em  algumas hipóteses  o erro sequer é  identificado. Para  mais informações, deve ser consultada  a  referência 
bibliográfica [27]. 

 67 

 
 
 
 
 
 
 
                                                 
Divisão da Turma: Em alguns momentos da realização da atividade haverá divisão da turma 

em grupos de pelo menos 3 alunos.  

Tempo estimado: 100 minutos 

Descrição sucinta:  

Construção de um código capaz de detectar dois erros e corrigir até um. O algoritmo 

será construído supondo-se que não houve uma avaliação prévia da quantidade de erros que 

acontecem  quando  a  informação  é  transmitida  pelo  canal.  A  consequência  disso  é  que  em 

algumas situações não é possível a correção dos erros.  

A atividade é importante para demonstrar que o código deve ser construído após uma 

avaliação do canal, a  fim de que a quantidade de redundâncias acrescentadas seja suficiente 

para que ocorra a correção da informação com certo grau de certeza. 

Nesse exemplo não será utilizado um código linear. 

Aspectos operacionais: 

O  professor deverá explicar  aos  educandos quais  os primeiros  elementos  necessários 

para  a  criação  de  um  código:  alfabeto  e  comprimento  das  palavras.  Em  seguida,  definirá  o 
(cid:3041),  exemplificando  (pode  ser  utilizado  como  alfabeto  o  conjunto  (cid:2418)(cid:2870)  =  {0,  1}  e 

conjunto  (cid:2418)(cid:3044)

analisados os conjuntos  (cid:2418)(cid:2870)

(cid:2871), (cid:2418)(cid:2870)

(cid:2872) e  (cid:2418)(cid:2870)

(cid:2873)).  Após, o docente  explicará  aos  alunos  que um código 

pode ser um subconjunto qualquer de (cid:2418)(cid:3044)

(cid:3041).  

Esclarecidos os pontos acima, o docente proporá aos estudantes a construção de uma 

codificação  para  desarmar  a  bomba.  Para  tanto,  pode-se  supor  que  a  bomba  tenha  fios  das 

seguintes  cores:  branco,  preto,  amarelo,  vermelho,  azul  e  verde.  Uma  possível  codificação 

para a fonte está na tabela abaixo: 

Tabela 11 
Código de Fonte 

Branco 
Preto 
Amarelo 
Vermelho 
Azul 
Verde 

0  0  0 
0  1  0 
1  0  0 
0  1  1 
1  1  0 
1  1  1 

Em seguida, escolhe-se a quantidade de dígitos que serão acrescidos à informação – as 

chamadas  redundâncias  –,  a  fim  de  que  seja  possível  a  identificação  e  correção  de  erros. 

 68 

 
 
 
 
 
 
 
Suponhamos que sejam acrescentados 3 (três) dígitos, segundo a seguinte regra: (x, y, z, x + 

y, y + z, x + z). Utilizando-se de uma planilha eletrônica, podemos apenas preencher o valor 

do código da fonte e colocar as seguintes fórmulas para obter as palavras do código: 

Figura 4 

Figura 5 

 69 

 
 
 
Figura 6 

A função “MOD(a;b)”, nas planilhas eletrônicas, informa o resto da divisão do número 

a pelo número b. No caso, como o alfabeto é {0, 1}, está sendo utilizado o resto da divisão 

por 2. 

Assim, para preencher o código de canal, inicialmente repetiremos o código de fonte 

no intervalo F2:H7. Após, vamos colar as fórmulas indicadas nas figuras 4,5 e 6 em todas as 

células do intervalo I3:K7. Dessa forma, será construído o código de canal abaixo. 

Tabela 12 
Código de canal 
0  0  0  0  0  0 
0  1  0  1  1  0 
1  0  0  1  0  1 
0  1  1  1  0  1 
1  1  0  0  1  1 
1  1  1  0  0  0 

Elaborado  o  código,  o  professor  continuará  explicando  aos  educandos  mais  itens 

necessários  à  compreensão  do  funcionamento  de  um  algoritmo  de  detecção  e  correção  de 

erros. Para isso, ele apresentará o que é a distância entre as palavras de um código, bem como 

 70 

 
 
 
 
 
 
 
qual  o  procedimento  para  obter  a  distância  mínima  e  identificar  a  quantidade  de  erros  que 

podem ser corrigidos (definição 2.3, definição 2.6, definição 2.7 e teorema 2.3). 

Apresentados os conceitos acima, o docente procederá ao cálculo das distâncias entre 

todas  as  palavras  do  código  que  foi  criado.  Portanto,  serão  calculadas    (cid:3435)(cid:2874)

(cid:2870)(cid:3439) =

(cid:2874)!

(cid:2870)!.(cid:2872)!

= 15 

distâncias.  

Utilizando-se de uma planilha eletrônica16: 

Figura 7 

Figura 8 

16 Observemos que a função “SOMASE(intervalo; critérios; intervalo_soma)”, nas planilhas eletrônicas, faz a 
adição das células especificadas por um determinado critério ou condição. 

 71 

 
 
 
 
                                                 
podemos construir a tabela a seguir, 

Tabela 13 

Palavra x 

Palavra y 

0  0  0  0  0  0     0  1  0  1  1  0 
0  0  0  0  0  0     1  0  0  1  0  1 
0  0  0  0  0  0     0  1  1  1  0  1 
0  0  0  0  0  0     1  1  0  0  1  1 
0  0  0  0  0  0     1  1  1  0  0  0 
1  0  0  1  0  1 
0  1  0  1  1  0 
0  1  1  1  0  1 
0  1  0  1  1  0 
1  1  0  0  1  1 
0  1  0  1  1  0 
1  1  1  0  0  0 
0  1  0  1  1  0 
0  1  1  1  0  1 
1  0  0  1  0  1 
1  1  0  0  1  1 
1  0  0  1  0  1 
1  1  1  0  0  0 
1  0  0  1  0  1 
1  1  0  0  1  1 
0  1  1  1  0  1 
1  1  1  0  0  0 
0  1  1  1  0  1 
1  1  1  0  0  0 
1  1  0  0  1  1 

x-y 
0  1  0  1  1  0 
1  0  0  1  0  1 
0  1  1  1  0  1 
1  1  0  0  1  1 
1  1  1  0  0  0 
1  1  0  0  1  1 
0  0  1  0  1  1 
1  0  0  1  0  1 
1  0  1  1  1  0 
1  1  1  0  0  0 
0  1  0  1  1  0 
0  1  1  1  0  1 
1  0  1  1  1  0 
1  0  0  1  0  1 
0  0  1  0  1  1 

Quantidade de "1’s" 
3 
3 
4 
4 
3 
4 
3 
3 
4 
3 
3 
4 
4 
3 
3 

e, então, concluir que a distância mínima é d = 3 e que o código é capaz de identificar até dois 

erros. Além disso, como κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = (cid:4674)(cid:2871)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 1, o código pode corrigir 1 erro. 

Em seguida, o professor deve explicar aos alunos mais um conceito, o de disco com 

centro em uma palavra c do código e raio r. Após isso, será possível a construção dos discos 

de raio 1 para o código exemplificado, conforme abaixo: 

D (000000, 1) = {000000, 100000, 010000, 001000, 000100, 000010, 000001} 

D (010110, 1) = {010110, 110110, 000110, 011110, 010010, 010100, 010111} 

D (100101, 1) = {100101, 000101, 110101, 101101, 100001, 100111, 100100} 

D (011101, 1) = {011101, 111101, 001101, 010101, 011001, 011111, 011100} 

D (110011, 1) = {110011, 010011, 100011, 111011, 110111, 110001, 110010} 

D (111000, 1) = {111000, 011000, 101000, 110000, 111100, 111010, 111001} 

Finalizando  as  explicações  referentes  à  forma  de  correção  e  decodificação  de 

mensagens, o docente irá comentar com os alunos que a correção de um erro é realizada por 

meio  da  substituição  da  palavra  errada  por  aquela  que  lhe  é  mais  próxima,  ou  seja,  basta 

identificar em que disco está a palavra e trocá-la pela palavra do código que foi utilizada para 

construir o disco. 

 72 

 
 
 
 
 
É importante ressaltar que o código foi construído para efetuar a correção de até um 

erro.  Todavia,  não  sabemos  a  quantidade  de  erros  que  ocorre  na  transmissão.  A  atividade 

permitirá  a  verificação  da  importância  de  saber,  previamente,  a  quantidade  de  erros  que 

acontecem quando a informação é transmitida pelo canal. 

Cumpridos  os  itens  anteriores,  o  docente  pode  iniciar  a  atividade.  Ela  consiste  na 

seguinte  situação.  Considera-se  que  os  alunos  fazem  parte  da  equipe  de  ações  táticas  da 

polícia  de  um  país  e  que  uma  denúncia  foi  recebida  de  que  há  uma  bomba  na  escola.  Um 

membro da equipe, de posse de uma câmera, procede ao local da bomba e envia uma imagem 

do  objeto  ao  quartel.  Lá,  a  imagem  da  bomba  é  comparada  com  outros  padrões  e  é 

identificada a forma de desarmá-la. Todavia, antes de ser enviada pelo quartel a sequência de 

fios  que  deve  ser  cortada,  ocorre  uma  pane  nos  equipamentos  eletrônicos  e  o  policial  não 

consegue mais receber orientações da base. No entanto, ele sabe que a base continua a ouvi-

lo, pois a central eletrônica referente ao envio do sinal sonoro continua ativa. 

O policial, então, procura em sua mochila outro objeto para se comunicar com a base e 

apenas  encontra  um  aparelho  mais  antigo,  que  transmite  sequências  de  seis  dígitos  de  0’s 

(“zeros”)  e  1’s  (“uns”).  Ele  decide  utilizar  o  equipamento  e,  como  o  aparelho  havia  sido 

substituído por causa dos erros que ocorriam na transmissão, o policial cria um código capaz 

de  corrigir  até  um  erro  (já  foi  exemplificado  anteriormente17)  e  solicita  à  base  que  envie  as 

informações  para  ele  pelo  equipamento  antigo.  O  problema  é  que  o  policial  não  sabe  a 

quantidade  de  erros  que  ocorrem  quando  uma  informação  é  recebida  pelo  aparelho.  Ele 

deverá avaliar cada situação. 

Após  a  apresentação  acima,  em  que  a  situação-problema  é  proposta  aos  grupos,  o 

professor assume o papel da “base”, e começa a enviar sequências de dígitos a cada um dos 

grupos, a qual contém a sequência dos fios a serem cortados. 

Inicialmente, o docente deve enviar sequências que podem ser corrigidas pelo código. 

Por exemplo, se para desarmar a bomba devem ser cortados os fios verde, vermelho e branco, 

a  codificação  sem  erros  é  111000,  011101  e  000000,  respectivamente.  Todavia,  como  será 

considerado  que  ocorre  um  erro  na  transmissão,  o  professor  irá  informar  uma  sequência 

numérica  diferente.  Suponhamos  que  ela  seja  a  seguinte:  111001,  001101  e  000100, 

respectivamente. 

Os alunos, então, devem procurar as referidas palavras nos discos de raio 1 (um): 

D (111000, 1) = {111000, 011000, 101000, 110000, 111100, 111010, 111001} 

17 Uma palavra com código fonte (x,  y, z) é codificada para uma palavra de  código de canal por meio do  vetor   
(x, y, z, x + y, y + z, x + z). Os caracteres x, y, z são elementos do conjunto (cid:2418)(cid:2870) = {0, 1}. 

 73 

                                                 
D (011101, 1) = {011101, 111101, 001101, 010101, 011001, 011111, 011100} 

D (000000, 1) = {000000, 100000, 010000, 001000, 000100, 000010, 000001} 

Dessa  forma,  como  foi  possível  identificar  as  palavras  nos  discos  acima,  podemos 

fazer  a  substituição  delas  pelas  palavras  que  dão  origem  aos  discos,  ou  seja,  111001  por 

111000,  01101  por  011101  e  000100  por  00000.  Esse  é  caso  em  que,  aparentemente,  é 

possível a correção da mensagem. 

Após o envio pelo docente de algumas mensagens e a consequente decodificação por 

cada  um  dos  grupos,  o  professor  poderá  enviar  uma  mensagem  igual  a  todos  os  alunos. 

Todavia, essa mensagem deve conter dois erros. Suponhamos, utilizando a mesma sequência 

do  parágrafo  anterior  –  verde,  vermelho  e  branco  –  que  seja  recebida  a  sequência  101100, 

001100 e 001010. Os alunos deverão proceder da mesma maneira que estavam fazendo antes: 

procurando as palavras nos discos. Todavia, eles não encontrarão em disco algum as palavras 

fornecidas, e começarão a questionar o professor. Nesse momento, o docente, com o uso do 

projetor  multimídia  e  de  planilhas  eletrônicas,  explicará  aos  educandos  que  ocorreram dois 

erros  na  transmissão,  ou  seja,  eles  devem  procurar  outra  forma  para  descobrir  a  palavra 

correta. Ele sugere, então, que seja procurada a palavra do código mais próxima e, para isso, 

calcula as distâncias abaixo: 

Tabela 14 

Palavra x 

Palavra y 

0  0  0  0  0  0     1  0  1  1  0  0 
0  1  0  1  1  0     1  0  1  1  0  0 
1  0  0  1  0  1     1  0  1  1  0  0 
0  1  1  1  0  1     1  0  1  1  0  0 
1  1  0  0  1  1     1  0  1  1  0  0 
1  1  1  0  0  0     1  0  1  1  0  0 

0  0  0  0  0  0 
0  1  0  1  1  0 
1  0  0  1  0  1 
0  1  1  1  0  1 
1  1  0  0  1  1 
1  1  1  0  0  0 

0  0  0  0  0  0 
0  1  0  1  1  0 
1  0  0  1  0  1 
0  1  1  1  0  1 
1  1  0  0  1  1 
1  1  1  0  0  0 

0  0  1  1  0  0 
0  0  1  1  0  0 
0  0  1  1  0  0 
0  0  1  1  0  0 
0  0  1  1  0  0 
0  0  1  1  0  0 

0  0  1  0  1  0 
0  0  1  0  1  0 
0  0  1  0  1  0 
0  0  1  0  1  0 
0  0  1  0  1  0 
0  0  1  0  1  0 

x-y 
1  0  1  1  0  0 
1  1  1  0  1  0 
0  0  1  0  0  1 
1  1  0  0  0  1 
0  1  1  1  1  1 
0  1  0  1  0  0 

0  0  1  1  0  0 
0  1  1  0  1  0 
1  0  1  0  0  1 
0  1  0  0  0  1 
1  1  1  1  1  1 
1  1  0  1  0  0 

0  0  1  0  1  0 
0  1  1  1  0  0 
1  0  1  1  1  1 
0  1  0  1  1  1 
1  1  1  0  0  1 
1  1  0  0  1  0 

 74 

Quantidade de "uns" 
3 
4 
2 
3 
5 
2 

2 
3 
3 
2 
6 
3 

2 
3 
5 
4 
4 
3 

 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
Dessa  forma,  os  educandos  poderão  concluir  há  duas  palavras  mais  próximas  de 

101100,  que  são  100101  (amarelo)  e  111000  (verde);  há  duas  palavras  mais  próximas  de 

001100,  que  são  000000  (branco)  e  011101  (vermelho);  e  uma  palavra  mais  próxima  de 

001010 que é 000000 (branco).  

Como  a  sequência  que  o  professor  passou  é  verde,  vermelho  e  branco,  apenas  uma 

palavra foi identificada. As outras duas serão escolhidas ao acaso. Isso significa que a bomba 

pode  explodir.  Além  disso,  é  exemplificada  a  tese  de  que  o  código  consegue  identificar  a 

ocorrência de dois erros na transmissão e que a correção fica prejudicada quando ocorre mais 

de um erro. 

Após essa  explicação, o professor propõe outro exemplo. Ele  irá considerar que será 

recebida a sequência 101011, 110100 e 001101 para a mensagem verde, vermelho e branco (a 

mensagem  sem  erros  é  111000,  011101  e  000000,  respectivamente).  Ou  seja,  a  mensagem 

será recebida com 3 erros. Os educandos, então, devem procurar nos discos de raio 1 (um) as 

palavras informadas. Verificar-se-á que apenas uma será encontrada: 

D (011101, 1) = {011101, 111101, 001101, 010101, 011001, 011111, 011100} 

O fato de essa palavra ter sido encontrada em um disco traz como consequência a falsa 

ideia de que a sequência 001101 deve ser corrigida para 011101, o que não é verdade. Nesse 

caso, a bomba também explode. Assim, concluímos que quando ocorreram três erros o código 

além de não ser capaz de identificar o erro, também nos induz a uma falsa correção.  

Assim, para que não ocorram problemas semelhantes a esses, o canal deve ser avaliado 

previamente  a  fim  de  que  haja  a  identificação  da  quantidade  de  erros  que  ocorrem  na 

transmissão para, posteriormente, ser construído um código capaz de corrigir com  maior grau 

de certeza a informação recebida. 

Procedimento pedagógico 

Essa é a primeira atividade em que os alunos construirão um código que seja capaz de 

corrigir erros. Para isso, será  necessário que o docente explique vários conceitos – alfabeto, 

comprimento,  distância  entre  palavras,  distância  mínima,  parâmetro  κ,  disco  de  centro  em 

uma  palavra  c  do  código  e  raio  r,  além  do  critério  de  correção  por  meio  da  palavra  mais 

próxima. Ressalta-se que este código não será um código linear, pois ele não é um subespaço 

vetorial de (cid:2418)(cid:2870)

(cid:2874), haja vista que se efetuarmos a soma das palavras do código 010110 e 011101, 

 75 

 
 
 
 
 
obteremos 001011, que é uma palavra que não pertence ao código (definição 3.3, subespaços 

vetoriais). 

Esse código  reforça  a  ideia  de que  é  importante  que  saibamos  a quantidade de  erros 

que ocorrem na transmissão das informações, sendo que este dado é obtido estatisticamente. 

O aluno deverá concluir, ao fim da atividade, que não basta estabelecer um código de maneira 

aleatória,  mas  que  é  preciso  construir  um  algoritmo  que  tenha  realmente  a  capacidade  de 

codificar e decodificar as informações com um certo grau de certeza. E isso não acontece na 

questão. Portanto, a bomba pode explodir. 

5.3.4 Atividade 4 

Título: O “jogo da velha”  

Material/Recurso necessário: computador, projetor multimídia, quadro negro (ou branco) e 

giz (ou caneta piloto) 

Divisão da Turma: Inicialmente, para os procedimentos de elaboração do código, não haverá 

divisão  da  turma.  Posteriormente,  para  realização  do  jogo,  a  turma  será  dividida  em  dois 

grupos  e,  estes  grupos,  também  serão  divididos  em  duas  equipes,  em  que  uma  será 

responsável pela codificação das jogadas e outra pela decodificação. 

Tempo estimado: 120 minutos 

Descrição sucinta:  

Construção  de  um  código  linear  perfeito  capaz  de  detectar  dois  erros  e  corrigir  um 

erro.  Nesta  atividade  vamos  supor  que  houve  uma  verificação  estatística  e  que  o  canal 

ocasiona até um erro na transmissão da informação. A partir disso, construiremos um código 

perfeito que seja capaz de corrigir os erros. 

Aspectos operacionais: 

O  professor  deverá  recordar  com  os  alunos  os  conceitos  apresentados  na  última 

atividade. Em seguida, deverá explicar que existem códigos chamados de lineares (definição 

3.7).  Mas,  para  que  haja  um  bom  entendimento  dos  referidos  códigos,  o  docente  deverá 

esclarecer, de forma sucinta, o que é um subespaço vetorial. Inclusive, o professor pode citar 

 76 

 
 
 
 
 
 
 
que o  código  exemplificado  na  atividade  anterior  não  era  subespaço de (cid:2418)(cid:2870)

(cid:2874), pois  a  soma das 

palavras 010110 e 011101, pertencentes ao código, é 001011, que não pertence ao código. 

Após  essa  introdução,  o  professor  irá  explicar  aos  alunos  que  o  procedimento  a  ser 

adotado  nessa  atividade  será diferente  da  anterior.  Inicialmente,  saberemos  a  quantidade  de 

erros que ocorrem na transmissão. Então, a partir dessa informação, construiremos um código 

linear capaz de detectar e corrigir os erros. 

Antes de iniciar a construção de um código de canal linear perfeito, devemos construir 

um  código  de  fonte.  Para  isso,  o professor  deverá  explicar  à  turma  como  se  joga  o  jogo da 

velha  (caso  o  professor  não  conheça  o  jogo  da  velha,  ele  poderá  consultar  o  link 

http://pt.wikipedia.org/wiki/Jogo_da_velha  para  esclarecimentos)  e  compará-lo  com  uma 

matriz 3 x 3: 

Figura 9 

(cid:1853)(cid:2869)(cid:2869) (cid:1853)(cid:2869)(cid:2870) (cid:1853)(cid:2869)(cid:2871)
(cid:1853)(cid:2870)(cid:2869) (cid:1853)(cid:2870)(cid:2870) (cid:1853)(cid:2870)(cid:2871)
(cid:3429)
(cid:1853)(cid:2871)(cid:2869) (cid:1853)(cid:2871)(cid:2870) (cid:1853)(cid:2871)(cid:2871)

(cid:3433) 

Em seguida, o docente deve propor a criação de um código de fonte que seja capaz de 

indicar em que posição deve ser realizada uma jogada, ou seja, onde deve ser colocado X ou 

O. Para tanto, ele deve estar atento ao fato de que são necessárias pelo menos 9 palavras para 

elaboração de um código que atenda ao referido propósito, já que o tabuleiro tem 9 posições. 

Portanto, o professor pode sugerir que código a ser criado tenha exatamente M = 9 palavras. 

Em  seguida,  observando que  32  = 9,  o  professor  deve  recomendar  que  seja  utilizado  como 

alfabeto o conjunto (cid:2418)3 = {0, 1, 2}, a fim de que o código construído seja linear ((cid:1869)(cid:3040) = 3(cid:2870) = 9; 

vide definição 3.7).  

 77 

 
 
 
 
Suponhamos que o código de fonte esteja em conformidade com o seguinte algoritmo: 

(cid:1853)(cid:3036)(cid:3037) = ((cid:1861) − 1)((cid:1862) − 1).  Aplicando  a  fórmula,  cada  casa  do  tabuleiro  corresponderá  à 

codificação abaixo: 

Figura 10 

Apresentado o código da fonte, o professor exemplificará aos alunos que por meio do 

referido  código  não  são  possíveis  a  identificação  e  a  correção  de  erros  de  transmissão.  Por 

exemplo, se 00 for transmito e for recebido como 01, não há como descobrir que aconteceu 

um  erro  –  as  palavras  são  muito  próximas  umas  das  outras.  Diante  disso,  o  docente  deve 

explicar aos educandos que existe a necessidade de acrescentar dígitos à informação que está 

sendo transmitida (as chamadas redundâncias), o que caracteriza a criação de um código de 

canal. Ele, então, pode sugerir aos alunos o acréscimo de dois dígitos ao código de fonte, o 

que fará com o que código de canal18 tenha comprimento n = 4. 

O  professor,  após  o  estabelecimento  do  comprimento  do  código  de  canal,  deve 

recordar com os educandos o que é a distância mínima e citar o teorema 2.3. Só assim  será 

possível  a  continuidade  da  construção  do  código.  Em  seguida,  o  docente  pode  propor  a 

utilização  de  uma  distância  mínima  d  =  3  no  código  de  canal,  o  que  acarretará  em  uma 

capacidade  de  correção  de  κ  =  (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = (cid:4674)(cid:2871)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) =  1  erro.  No  caso,  estaremos  supondo  que  o 

canal é conhecido e que ele ocasiona até um erro na transmissão. 

A  partir  das  informações  acima,  o  docente  poderá  afirmar  que  o  código  a  ser 

construído  vai  possuir  comprimento  n = 4, dimensão  m  = 2, distância  mínima  d  = 3  e  será 

capaz de corrigir até κ = 1 erro. Todavia, apesar da definição dos parâmetros anteriores, ainda 

não  foi  estabelecido  um  critério  para  a  construção  do  código.  E  mais:  nem  sabemos  se  é 

possível construir um código com os parâmetros indicados para n, m e d. Diante disso, será 

18  Ao  fim  da  atividade,  o  docente  irá  explicar  aos  alunos  que  foi  tomado  o  valor  de  n  =  4  a  fim  de  fosse 
construído um código linear perfeito. 

 78 

 
 
                                                 
necessário  que o docente  faça  um  breve  esclarecimento  sobre  o que  são  as  matrizes  G  e  H 

(geradora e de teste de paridade – definição 3.10 e proposição 3.3). Também será necessário 

explicar  quando  um  conjunto  de  vetores  é 

linearmente  dependente  e 

linearmente 

independente.  

Procedidas às explicações anteriores, o professor irá criar, com o auxílio dos alunos, 

uma  matriz  de  verificação  do  código.  Para  tanto,  deverá  ser  construída  uma  matriz                  

H = [ – At | Idn–m  ] de ordem (n – m) x n. Como n = 4 e m = 2, a matriz terá ordem 2 x 4 e 

deve possuir o seguinte formato: 

(cid:1834) = (cid:4674)

(cid:1853) (cid:1855)
1 0
(cid:1854) (cid:1856) 0 1

(cid:4675) , (cid:1857)(cid:1865) (cid:1869)(cid:1873)(cid:1857) (cid:1853), (cid:1854), (cid:1855), (cid:1856)  ∈ {0, 1, 2}. 

Como sabemos que d = 3, então essa matriz deverá ter (de acordo com o apresentado 

no item 3.3.5.7) quaisquer duas (= d – 1 = 3 – 1) colunas linearmente independentes e devem 

existir  três  (d  =  3)  colunas  linearmente  dependentes. Um  exemplo  em  que ocorre  isso  é  na 

matriz 

(cid:1834) = (cid:4674)

1 2 1 0
1 1 0 1

(cid:4675) 

Notemos que as colunas, duas a duas, não são múltiplas uma das outras. Portanto, elas 

são linearmente independentes. Além disso, (1, 1) = 1.(1, 0) + 1.(0, 1), ou seja, existem três 

colunas linearmente dependentes. 

Construída H, procede-se à construção da matriz G. Conforme afirmado, H = [ – At | 

Idn–m    ].  Daí,  é  possível  obter  a  matriz  G,  pois  G  =  [Idm  |  A],  de  ordem  m  x  n.  No  nosso 

exemplo, basta observarmos que 

−(cid:1827)(cid:3047) = (cid:4674)

1 2
1 1

(cid:4675)      ↔     −(cid:1827) = (cid:4674)

1 1
2 1

(cid:4675)      ↔     (cid:1827) = (cid:4674)

2 2
1 2

(cid:4675) 

Não podemos esquecer que estamos realizando as operações acima na base 3: 

+ 
0 
1 
2 

Tabela 15 

1 
1 
2 
0 

0 
0 
1 
2 

2 
2 
0 
1 

 79 

 
 
 
 
 
 
 
 
Assim, podemos dizer que a matriz de codificação é 

(cid:1833) = (cid:4674)

1 0 2 2
0 1 1 2

(cid:4675) 

Obtida  a  matriz  G,  é  possível  escrever  todas  as  palavras  do  código  por  meio  do 

produto de matrizes x.G, onde x (matriz linha 1 x 2) é o código da fonte e G (matriz 2 x 4) é a 

matriz  geradora.    Cada  um  dos  produtos  terá  por  resultado  matrizes  coluna  (1  x  4)  com  as 

palavras do código. As tabelas a seguir foram construídas com o uso de planilhas eletrônicas. 

Nas  figuras  abaixo  podemos  ver  algumas  fórmulas,  as  quais  foram  copiadas  e  coladas  nas 

células da coluna correspondente. 

Figura 11 

Figura 12 

 80 

 
 
 
 
 
 
 
 
Figura 13 

Figura 14 

Tabela 16 

Código Fonte 

0 
0 
0 
1 
1 
1 
2 
2 
2 

0 
1 
2 
0 
1 
2 
0 
1 
2 

 81 

Matriz 
Geradora: G 
1 
0 

2 
1 

0 
1 

2 
2 

Código de Canal 
0 
0 
2 
0 
1 
0 
2 
1 
1 
1 
0 
1 
1 
2 
0 
2 
2 
2 

0 
1 
2 
2 
0 
1 
1 
2 
0 

0 
1 
2 
0 
1 
2 
0 
1 
2 

 
 
 
 
Após a construção das matrizes G e H é possível iniciar o jogo. Para isso, o professor 

pode propor a divisão da turma em dois grandes grupos. Cada um representará um “jogador”. 

Em cada grupo será realizada a seguinte subdivisão: um aluno será eleito para ser quem dirá 

ao grupo em qual “casa” será efetuada a jogada do X ou O; os demais alunos formarão dois 

subgrupos,  sendo  que  o  primeiro  será  responsável  pela  codificação  e  o  segundo  pela 

decodificação das mensagens.  

O jogo  funcionará da seguinte maneira. O  líder dirá à equipe de codificação em que 

local  pretende que  a  jogada  seja  realizada. Ela  codificará  a  informação  e o  avisará.  O  líder, 

então, receberá o vetor referente à jogada e poderá acrescentar um erro antes de encaminhá-la 

ao  líder  da  equipe  adversária.  Este  receberá  o  código  da  jogada  e  acionará  sua  equipe  de 

decodificação, a qual  irá  verificar se a mensagem possui erro e corrigi-la, a fim de que seja 

efetuada  a  marcação  no  jogo  da  velha  que  estará  no  quadro  (negro  ou  branco).  Se  o  grupo 

marcar uma casa errada, a equipe que enviou a mensagem poderá se manifestar. Para isso, o 

seu  líder  deverá  explicar  no  quadro  como  foi  realizada  a  codificação  e,  então, o  grupo  que 

marcou  erroneamente  a  localização  no  quadro  ficará  uma  rodada  sem  jogar.  Além  disso, 

ocorrerá a marcação no quadro da jogada correta. Caso seja enviada uma mensagem com mais 

de um erro ou tenha ocorrido algum equívoco na codificação realizada pelo grupo que efetuou 

a jogada, este é que ficará uma rodada sem jogar. O procedimento se repetirá até que haja um 

vencedor ou até que o jogo termine sem vencedores – ocorra empate. 

Tomemos um  exemplo.  Suponhamos  que  a  turma  foi  separada  nos  grupos  X  e  O.  O 

grupo X iniciará o jogo. O líder do grupo informa à equipe de codificação que deseja jogar o 

X na posição a22 da matriz. A equipe de codificação, então, verifica que o algoritmo da fonte19 

estabelece que (cid:1853)(cid:2870)(cid:2870) = [(2 − 1)

(2 − 1)] = [1 1] e efetua o seguinte produto: 

(cid:1876). (cid:1833) = [1 1]. (cid:4674)

1 0 2 2
0 1 1 2

(cid:4675) = [1 1 0 1] 

O líder do grupo, de posse da informação, encaminha ao líder do grupo adversário o 

vetor [1 0 0 1], em que há um erro. 

O  líder  do  grupo  O  recebe  a  informação  e  aciona  sua  equipe  de  decodificação.  A 

equipe, então, efetua o seguinte cálculo: 

(cid:1834). (cid:1870)(cid:3047) = (cid:4674)

1 2 1 0
1 1 0 1

(cid:4675) . (cid:4686)

1
0
0
1

(cid:4687) = (cid:4674)

1
2

(cid:4675) ≠ (cid:4674)

0
0

(cid:4675) 

19 O algoritmo da fonte, conforme consta no início da atividade, é (cid:1853)(cid:3036)(cid:3037) = ((cid:1861) − 1)((cid:1862) − 1) 

 82 

 
 
                                                 
Diante disso, ela conclui que a mensagem foi transmitida com erro. Como já foi estabelecido 

que no máximo acontece um erro, o vetor do erro tem a forma e = (0, ... , x, ..., 0), com x ≠ 0 

na i-ésima posição. Assim, a equipe procederá à busca de qual é a i-ésima posição. Como Het  

= Hrt e Het  = xhi (hi é a i-ésima coluna de H), ela verifica que  

1
(cid:4674)
2

(cid:4675) = 2. (cid:4674)

2
1

(cid:4675) = 2. ℎ(cid:2870). 

Portanto, o grupo conclui que o erro ocorreu na segunda coordenada e que o vetor erro é e = 

(0, 2, 0, 0). Assim, a palavra transmitida é c = (1001) – (0200) = (1101), a qual corresponde 

ao código de fonte 11 e, consequentemente, à posição a22.  

Agora o grupo O fará sua jogada. O líder escolhe uma posição e informa à equipe de 

codificação.  Suponhamos  que  seja  a33.  A  referida  equipe  verifica  que  o  algoritmo  da  fonte 

estabelece que (cid:1853)(cid:2871)(cid:2871) = [3 − 1 3 − 1] = [2 2] e efetua o seguinte produto: 

(cid:1876). (cid:1833) = [2 2]. (cid:4674)

1 0 2 2
0 1 1 2

(cid:4675) = [2 2 0 2] 

O líder do grupo, de posse da informação, encaminha ao líder do grupo adversário o 

vetor com um erro. Por exemplo, [2 2 0 0]. 

O  líder  do  grupo  X  recebe  a  informação  e  aciona  sua  equipe  de  decodificação.  A 

equipe, então, efetua o seguinte cálculo: 

(cid:1834). (cid:1870)(cid:3047) = (cid:4674)

1 2 1 0
1 1 0 1

(cid:4675) . (cid:4686)

2
2
0
0

(cid:4687) = (cid:4674)

0
1

(cid:4675) ≠ (cid:4674)

0
0

(cid:4675) 

Diante disso, ela conclui que a mensagem foi transmitida com erro. Como já foi estabelecido 

que no máximo acontece um erro, o vetor do erro tem a forma e = (0, ... , x, ..., 0), com x ≠ 0 

na i-ésima posição. Assim, a equipe procederá à busca de qual é a i-ésima posição. Como Het  

= Hct e Het  = xhi (hi é a i-ésima coluna de H), ela verifica que  

0
(cid:4674)
1

(cid:4675) = 1. (cid:4674)

0
1

(cid:4675) = 1. ℎ(cid:2872). 

Portanto, o grupo conclui que o erro ocorreu na quarta coordenada e que o vetor erro é e = (0, 

0, 0, 1). Assim, a palavra transmitida é c = (2200) – (0001) = (2202), a qual corresponde ao 

código de fonte 22 e, consequentemente, à posição a33.  

E o jogo continua até que haja um vencedor ou ocorra o empate.  

Após algumas rodadas do jogo, o professor pode propor que os cálculos de codificação 

e decodificação sejam realizados por meio de planilhas eletrônicas, o que tornará as jogadas 

mais rápidas e a atividade será mais dinâmica.  

 83 

 
 
Como pode acontecer de algum grupo transmitir uma mensagem com mais de um erro, 

vamos analisar a seguinte situação. Suponha-se que será efetuada uma jogada na posição a33. 

Conforme já calculado anteriormente, o vetor que codifica a jogada é [2 2 0 2]. Assim, 

se  for  recebido  o  vetor  [2 1 0 0],  isto  significa  que  ocorreram  dois  erros  durante  a 

transmissão da mensagem. No momento da decodificação, encontra-se,  

(cid:1834). (cid:1855) (cid:3047) = (cid:4674)

1 2 1 0
1 1 0 1

(cid:4675) . (cid:4686)

2
1
0
0

(cid:4687) = (cid:4674)

1
0

(cid:4675) ≠ (cid:4674)

0
0

(cid:4675)  (cid:1857)  (cid:4674)

1
0

(cid:4675) = 1. (cid:4674)

1
0

(cid:4675) = 1. ℎ(cid:2871) 

Nesse  caso,  é  identificado que  houve  um  erro. Todavia,  o procedimento  de  correção 

nos diz que o vetor erro é (0010) e que a palavra correta é c = (2100) – (0010) = (2120), que 

embora  seja  uma  palavra  que  pertence  ao  código,  não  é  a  palavra  que  foi  enviada.  Esse 

cálculo  exemplifica  a impossibilidade de correção da  mensagem quando ocorre  mais  de um 

erro na transmissão.  

Ao  final  da  atividade  o  professor  deverá  explicar  aos  alunos  o  motivo  pelo  qual 

escolheu o comprimento de palavras n = 4, que foi para obter um código linear perfeito. Para 

isso, o docente  deve  fazer  a  verificação de que os  parâmetros  M  = 9, k = 1,  q = 3  e  n = 4 

satisfazem as condições descritas  na definição 2.8. Além disso, o professor poderá construir 

todos os discos com centro nas palavras do código e distância 1, a fim de verificar que a união 

dos mencionados discos é o conjunto (cid:2418)(cid:2871)

(cid:2872).  

Segue abaixo a relação de discos com os respectivos elementos contidos em cada um 

deles. 

Tabela 17 
DISCOS 
D(0000, 1) = {0000, 1000, 0100, 0010, 0001, 2000, 0200, 0020, 0002} 
D(0112, 1) = {0112, 1112, 2112, 0012, 0212, 0102, 0122, 0110, 0111}  
D(0221, 1) = {0221, 1221, 2221, 0021, 0121, 0201, 0211, 0220, 0221} 
D(1022, 1) = {1022, 0022, 2022, 1122, 1222, 1002, 1012, 1020, 1021} 
D(1101, 1) = {1101, 0101, 2101, 1001, 1201, 1111, 1121, 1100, 1102} 
D(1210, 1) = {1210, 0210. 2210, 1010, 1110, 1200, 1220, 1211, 1212} 
D(2011, 1) = {2011, 0011, 1011, 2111, 2211, 2001, 2021, 2010, 2012} 
D(2120, 1) = {2120, 0120, 2120, 2020, 2220, 2100, 2110, 2121, 2122} 
D(2202, 1) = {2202, 0202, 1202, 2002, 2102, 2212, 2222, 2200, 2201} 

Procedimento pedagógico 

          A atividade é mais complexa que as demais sugeridas até o momento. Será necessária 

constante intervenção do docente no momento das jogadas, auxiliando os alunos. Além disso, 

 84 

 
 
o professor deve incentivar a participação ativa da turma na realização da atividade e assumir 

um papel de auxiliador na construção do conhecimento. 

         É  importante  o  professor  salientar  que,  em  virtude  de  o  código  ser  perfeito  e  o  canal 

causar no máximo um erro, nessa atividade será possível a detecção e a correção de quaisquer 

palavras.  

Informações complementares – determinação do valor de n: 

Conforme consta no capítulo referente aos códigos lineares, um código linear C é um 
(cid:3041)  de  dimensão  m  (m  <  n).  O  conjunto  (cid:2418)(cid:3044)  é  um  corpo  finito  de  q 

subespaço  vetorial  de  (cid:2418)(cid:3044)

elementos e n é o comprimento das palavras do código.  

A relação entre o número de palavras M de um código e os valores de q e m, em um 

código linear, se dá da seguinte forma: (cid:1839) = (cid:1869)(cid:3040). 

Com base nas informações acima é que foi iniciada a elaboração do código utilizado 

na atividade. De início, foi estabelecido que a quantidade de palavras deveria ser M = 9 (que é 

exatamente a quantidade de casas do tabuleiro do jogo da velha). Assim, como 9 = 32 e como 

q e m são números naturais, concluímos que q = 3 e m = 2. Dessa forma, podemos afirmar 

que o código tem dimensão m = 2 e o alfabeto possui q = 3 letras – (cid:2418)(cid:2871) = {0 ,1 2}. 

Com  relação  à  distância  mínima,  vamos  supor  que  ela  seja  d  =  3.  Então,  podemos 

dizer que o código permite a identificação de d – 1 = 2 erros e a correção de κ = (cid:4674)(cid:3031)(cid:2879)(cid:2869)
(cid:2870)

(cid:4675) = 1 

erro. 

Pois  bem,  ante  ao  exposto,  nos  resta  apenas  obter  a  seguinte  informação:  o 

comprimento  n das palavras.  Para obtermos possíveis  valores  de  n  vamos  utilizar  a  cota de 

Hamming e o limitante de Singleton. Lembremos, todavia, que o valor de n deve ser natural. 

A cota de Hamming nos informa que  

Daí,  

Donde se conclui que  

(cid:1839)  ≤

(cid:1869)(cid:3041)

(cid:3089)
∑ (
(cid:3047)(cid:2880)(cid:2868)

(cid:1866)
(cid:1872)

 ) ((cid:1869) − 1)(cid:3047)

9  ≤

(cid:4672)

(cid:1866)
0

3(cid:3041)

 (cid:4673) (3 − 1)(cid:2868) + (

(cid:1866)
1

 ) (3 − 1)(cid:2869)

1 + 2(cid:1866) ≤ 3(cid:3041)(cid:2879)(cid:2870) 

Fazendo o gráfico no Geogebra das funções y = 1 + 2x e (cid:1877) = 3(cid:3051)(cid:2879)(cid:2870), avaliamos que devemos 

ter  (cid:2196) ≥ 4, (cid:1866) ∈ (cid:1840).   

 85 

  
 
 
 
Por outro lado, utilizando a Cota de Singleton, temos que 

Figura 15 

Daí, 

Donde se conclui que  

(cid:1856) ≤ (cid:1866) − (cid:1865) + 1 

3 ≤ (cid:1866) − 2 + 1 

4 ≤ (cid:1866) 

Avaliamos, então, que também devemos ter  (cid:2196) ≥ 4, (cid:1866) ∈ (cid:1840).   

Ante o apresentado, concluímos que o comprimento do código deve ser maior ou igual 

a 4. Vamos procurar um valor que nos forneça um código perfeito. 

Verificação de que o código é um código perfeito: 

Podemos  notar  –  com  o  uso  dos  parâmetros  comprimento  n  =  4,  dimensão  m  =  2, 

distância  mínima  d  =  3,  capacidade  de  corrigir  até  κ  =  1  erro  –  que  a  seguinte  equação  é 

satisfeita: 

pois, 

(cid:3038)

(cid:1839)[ (cid:3533)(
(cid:3047)(cid:2880)(cid:2868)

(cid:1866)
(cid:1872)

)((cid:1869) − 1)(cid:3047)] = (cid:1869)(cid:3041) 

(cid:2869)

4
(cid:1872)

9[ (cid:3533)(
(cid:3047)(cid:2880)(cid:2868)

)(3 − 1)(cid:3047)] = 9. [(cid:3436)

4
0

4
(cid:3440) (2)(cid:2868) + (cid:3436)
1

(cid:3440) (2)(cid:2869) = 9. [1 + 8] = 81 = 3(cid:2872) 

 86 

 
 
 
 
 
 
 
 
 
 
Assim, de acordo com na definição 2.8, podemos dizer que se adotarmos n = 4, no presente 

exemplo,  teremos  um  código  perfeito.  A  vantagem  do  uso  desse  código  é  que  sempre  que 

ocorrer 1 (um erro) é possível a sua correção, pois a palavra irá pertencer a um dos discos D 

(c, 1), para c pertencente ao código. 

Vamos escrever os discos de raio 1 para cada uma das palavras do código. As palavras 

do código já foram identificadas na seção “aspectos operacionais”, da atividade 4. Portanto,  

(cid:4651) (cid:1830)((cid:1855), 1) = (cid:1869)(cid:3041) =
(cid:3030)∈(cid:3004)

3(cid:2872) 

Tabela 17 
D(0000, 1) = {0000, 1000, 0100, 0010, 0001, 2000, 0200, 0020, 0002} 
D(0112, 1) = {0112, 1112, 2112, 0012, 0212, 0102, 0122, 0110, 0111}  
D(0221, 1) = {0221, 1221, 2221, 0021, 0121, 0201, 0211, 0220, 0221} 
D(1022, 1) = {1022, 0022, 2022, 1122, 1222, 1002, 1012, 1020, 1021} 
D(1101, 1) = {1101, 0101, 2101, 1001, 1201, 1111, 1121, 1100, 1102} 
D(1210, 1) = {1210, 0210. 2210, 1010, 1110, 1200, 1220, 1211, 1212} 
D(2011, 1) = {2011, 0011, 1011, 2111, 2211, 2001, 2021, 2010, 2012} 
D(2120, 1) = {2120, 0120, 2120, 2020, 2220, 2100, 2110, 2121, 2122} 
D(2202, 1) = {2202, 0202, 1202, 2002, 2102, 2212, 2222, 2200, 2201} 

A tabela da página anterior apenas confirma que, de fato, o código é perfeito. 

Outra maneira de identificar quais são as palavras do código: 

Construída H, podemos verificar quais palavras pertencem ao código. Como m = 2 e   

n  =  4,  serão  acrescentados  dois  dígitos  de  redundância  à  codificação  da  fonte.  Assim, 

podemos ter palavras de comprimento quatro, segundo os parâmetros da tabela abaixo20. 

Tabela 18 

Fonte 

Redundâncias 

0 
0 
0 
1 
1 
1 
2 
2 
2 

0 
1 
2 
0 
1 
2 
0 
1 
2 

20 Os espaços vazios da tabela 18 serão preenchidos por elementos do conjunto (cid:2418)(cid:2871) = {0, 1, 2}. 

 87 

 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
                                                 
Portanto, existem três opções para cada dígito da redundância, uma vez que o alfabeto 

é  {0,  1,  2}.  Ou  seja,  para  cada  uma  das  linhas  da  tabela  acima  há  nove  possibilidades  de 

formação de palavra.  Todavia,  para que  a palavra  formada pertença  ao  código, devemos  ter 

H.ct = 0, onde ct é a transposta de cada linha. 

As contas de verificação são um pouco extensas. Então, uma excelente opção é o uso 

de  planilhas  eletrônicas.  Para  tanto,  vamos  escrever  a  matriz  H  e,  em  seguida,  as 

possibilidades de cada linha. Por meio de fórmulas, as planilhas eletrônicas realizam as contas 

e nos informam qual a palavra c em que ocorre H.ct = 0. 

Figura 16 

Figura 17 

 88 

 
 
 
 
Matriz H 
1 
2 
0 
1 

1 
1 

0 
1 

Tabela 19 

Verificação de a11 
0  0  0  0  0  0  0  0  0 
0  0  0  0  0  0  0  0  0 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

Verificação de a12 
0  0  0  0  0  0  0  0  0 
1  1  1  1  1  1  1  1  1 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

2  2  2  0  0  0  1  1  1 
1  2  0  1  2  0  1  2  0 

Verificação de a13 
0  0  0  0  0  0  0  0  0 
2  2  2  2  2  2  2  2  2 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

Verificação de a21 
1  1  1  1  1  1  1  1  1 
0  0  0  0  0  0  0  0  0 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

Verificação de a22 
1  1  1  1  1  1  1  1  1 
1  1  1  1  1  1  1  1  1 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

1  1  1  2  2  2  0  0  0 
2  0  1  2  0  1  2  0  1 

1  1  1  2  2  2  0  0  0 
1  2  0  1  2  0  1  2  0 

0  0  0  1  1  1  2  2  2 
2  0  1  2  0  1  2  0  1 

Verificação de a23 
1  1  1  1  1  1  1  1  1 
2  2  2  2  2  2  2  2  2 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

Verificação de a31 
2  2  2  2  2  2  2  2  2 
0  0  0  0  0  0  0  0  0 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

Verificação de a32 
2  2  2  2  2  2  2  2  2 
1  1  1  1  1  1  1  1  1 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

2  2  2  0  0  0  1  1  1 
0  1  2  0  1  2  0  1  2 

2  2  2  0  0  0  1  1  1 
2  0  1  2  0  1  2  0  1 

1  1  1  2  2  2  0  0  0 
0  1  2  0  1  2  0  1  2 

Verificação de a33 
2  2  2  2  2  2  2  2  2 
2  2  2  2  2  2  2  2  2 
0  0  0  1  1  1  2  2  2 
0  1  2  0  1  2  0  1  2 

0  0  0  1  1  1  2  2  2 
1  2  0  1  2  0  1  2  0 

Ante  ao  exposto,  podemos  montar  a  seguinte  tabela,  na  qual  estão  as  palavras  do 

código de canal: 

 89 

 
 
 
 
 
 
 
 
 
Tabela 20 

Código da 
fonte 
00 
01 
02 
10 
11 
12 
20 
21 
22 

Código de 
Canal 
0000 
0112 
0221 
1022 
1101 
1210 
2011 
2120 
2202 

Posição 
a11 
a12 
a13 
a21 
a22 
a23 
a31 
a32 
a33 

 90 

 
 
 
6 CONSIDERAÇÕES FINAIS 

Novos métodos de ensino de Matemática têm revolucionado a forma de construção do 

conhecimento  pelos  educandos.  Essas  novas  concepções  têm  trazido  o  foco  do  processo  de 

ensino-aprendizagem  para  o  aluno,  colocando-o  como  um  sujeito  ativo,  questionador, 

reflexivo, capaz de analisar problemas e buscar soluções. 

Essa nova maneira de ensinar Matemática faz com que o professor também tenha que 

modificar sua prática, pois será ele quem criará as condições para que o aprendizado ocorra e, 

para isso, serão necessárias a elaboração de situações-problema, a contextualização histórica, 

o  uso  de  computadores  em  sala  de  aula,  dentre  outras  situações  possíveis.  Além  disso,  o 

docente  também  deve  adotar  uma  postura  de  orientador,  e  não  de  “detentor  de  todo  o 

conhecimento”, indicando o caminho a ser seguido pelo educando para que este investigue e 

resolva as situações-problema. 

As  atividades propostas  seguem  esta  concepção de  ensino-aprendizagem.  Elas  foram 

desenvolvidas  com  o  objetivo  de  contextualizar  o  estudo  de  matrizes,  vetores,  sistemas  de 

numeração  e  sistemas  lineares.  Por  meio  delas  os  educandos  podem  analisar  problemas, 

propor soluções, verificar que em determinados momentos a solução não é a melhor possível. 

Isso acontece porque as atividades tentam recriar a forma como se deu o desenvolvimento do 

estudo dos códigos corretores de erros, uma vez que é apresentada a seguinte sequência: um 

modelo  de  código  que  não  detecta  e  nem  corrige  erros;  modelos  de  códigos  que  apenas 

detectam erros; um código que detecta e corrige (mas não muito preciso); e um código linear 

diferenciado, chamado de código perfeito.  

Portanto,  por  meio  da  sequência  proposta,  espera-se  que  os  alunos  adquiram 

competências  relacionadas  ao  desenvolvimento  do  pensamento  algébrico,  à  segurança  para 

adaptar  o  uso  de  conceitos  matemáticos  em  outros  contextos,  à  análise  de  informações  e 

tomada  de  decisões,  bem  como  comecem  a  avaliar  quando  o  uso  de  uma  ferramenta 

tecnológica pode ser útil para resolver um problema.  

Dessa  forma,  podemos  concluir  que  as  atividades  auxiliam  na  qualificação  dos 

educandos para, ao final do Ensino Médio, serem inseridos no mercado de trabalho ou para o 

prosseguimento dos estudos. 

 91 

 
 
 
 
 
  
 
 
 
7 REFERÊNCIAS 

[1]  ARMELLA,  Luiz  Moreno;  WALDEGG,  Guilhermina.  Educação Matemática.  México: 
1992, v.4, p. 7-15.  

[2] BITTENCOURT, Simone. Como nosso cérebro lê? Pré-Univesp, n. 4, 2010. Disponível 
em: 
<http://www.univesp.ensinosuperior.sp.gov.br/preunivesp/503/como-nosso-c-rebro-l-
.html>. Acesso em: 10 jun. 2014. 

[3]  BAHIA,  Flaviano.  Um  Primeiro  Curso  sobre  Códigos  Corretores  de  Erros.  In: 
ERMAC  2010:  I  Encontro  Regional  de  Matemática  Aplicada  e  Computacional,  2010,  São 
João Del Rei, MG. Anais... Disponível em <http://www.ufsj.edu.br/portal2-repositorio/File/i-
ermac/anais/mini cursos/mc8.pdf>. Acesso em: 15 janeiro 2015. 

[4]  BRASIL.  Ministério  da  Educação.  Secretaria  de  Educação  Média  e  Tecnológica. 
Parâmetros Curriculares Nacionais (Ensino Médio). Brasília: MEC, 2000. Disponível em: 
< http://portal .mec.gov.br/seb/arquivos/pdf/ciencian.pdf. Acesso em: 11 maio 2014. 

[5]  BRASIL.  Ministério  da  Educação.  Secretaria  da  Educação  Média  e  Tecnológica.  
Parâmetros  Curriculares  Nacionais  +  (PCN+)  -  Ciências  da  Natureza  e  suas 
Tecnologias. Brasília: MEC, 2002. Disponível em: 
 <http://portal.mec.gov.br/seb/arquivos/pdf/CienciasNatureza.pdf>.  Acesso  em:  11  maio 
2014. 

[6] COSTELLO, D. J.;  HAGENAUER J.; ILMAI H.; WICKER S. B. Applications of Erros-
Control  Coding.  IEEE  Transactions  on  Information  Theory,  out.  98.  Disponível  em: 
<http://arquivoescolar.org/bitstream/arquivo-e/132/4/cap2.pdf>. Acesso em: 16 abril 2014. 

[7]  D’AMBRÓSIO,  Ubiratan.  A  história  da  matemática:  questões  historiográficas  e 
políticas  e  reflexos  na  educação  matemática.  In:  BICUDO,  M.  A.  V.  (Ed.).  Pesquisa  em 
educação  matemática:  concepções  e  perspectivas.  São  Paulo:  UNESP,  1999.  p.  97–115. 
Disponível  em:  <http://cattai.mat.br/site/files/ensino/uneb/pfreire/docs/HistoriaDaMatematica 
/Ubiratan_DAmbrosio_doisTextos.pdf>. Acesso em 01 abril 2015.   

[8]  ESQUINCA,  Josiane  Colombo  Pedrini.  Aritmética:  Códigos  de  Barras  e  Outras 
Aplicações de Congruências. 2013. Dissertação  (Mestrado Profissional em Matemática em 
Rede  Nacional)  –  Centro  de  Ciências  Exatas  e  Tecnologia,  Universidade  Federal  de  Mato 
Grosso  do  Sul,  Campo  Grande  –  MS,  2013.  Disponível  em:  <  http://bit.profmat-
sbm.org.br/xmlui/bitstream/handle/123456789/371/2011_00238_JOSIANE_COLOMBO_PE
DRINI_ESQUINCA.pdf?sequence=1>. Acesso em: 07 janeiro 2015. 

 92 

 
 
 
 
 
 
 
 
 
 
 
 
[9] FEIO, Evandro dos Santos Paiva; SILVA, Francisco Hermes Santos da. Reflexões sobre 
linguagem  e  inclusão  à  luz  da  teoria  da  aprendizagem  significativa.  Aprendizagem 
Significativa em revista – v2 (3), pp. 58-68, 2012. Disponível em: <http://www.if.ufrgs.br/asr/ 
artigos/Artigo_ID37/v2_n3_a2012.pdf>. Acesso em: 11 maio 2014. 

[10] FIGUEIREDO, Luis Manoel; CUNHA, Marisa Ortega da. Álgebra Linear I. Volume 2. 
2. ed. Rio de Janeiro: Fundação CECIERJ, 2010. 

[11]  FONTES,  Marício de Moraes;  FONTES,  Dineusa  Jesus  dos  Santos;  FONTES, Miriam 
de Morais. O Computador como Recurso Facilitador da Aprendizagem Matemática. In: I 
Simpósio  Nacional  de  Ensino  de  Ciência  e  Tecnologia,  2009,  Universidade  Tecnológica 
Federal do Paraná - UTFPR. Anais... Disponível em: 
<http://www.sinect.com.br/anais2009/artigos/10%20Ensinodematematica/Ensinodematematic
a_artigo13.pdf>. Acesso em: 13 março 2015. 

[12]  HEFEZ,  Abramo;  FERNANDES,  Cecília  de  Souza.  Introdução  à  Álgebra  Linear. 
SBM. 1ª Edição. 2012. Coleção Profmat.  

[13] HEFEZ, Abramo; VILLELA, Maria Lucia T. Códigos Corretores de Erros. 2. ed. Rio 
de Janeiro: IMPA, 2008.  

[14] MENEGHESSO, Carla. Códigos Corretores de Erros. 2012. Trabalho de Conclusão de 
Curso  (Licenciatura  em  Matemática)  –  Centro  de  Ciências  Exatas  e  de  Tecnologia, 
Universidade  Federal 
em: 
<http://www.dm.ufscar.br/dm/attachments/article/5/monografia_carla%20TCC.pdf>.  Acesso 
em: 15 abril 2014. 

de  São  Carlos,  São  Carlos, 

2012.  Disponível 

[15]  MILIES,  César  Polcino.  A  Matemática  dos  Códigos  de  Barras.  Disponível  em: 
<http://mat.ufg.br/bienal/2006/mini/polcino.pdf>. Acesso em: 10 março 2015. 

[16] MILIES, César Polcino. Breve introdução à Teoria dos Códigos Corretores de Erros. 
In:  1º  Colóquio  de  Matemática  da  Região  Centro-Oeste,  2009,  UFMS,  Campo  Grande. 
Anais... São Paulo: Instituto de Matemática e Estatística da Universidade de São Paulo, 2009. 
Disponível  em:  <http://www.coloquiodematematica.ufms.br/conteudo/  material/mc09.pdf>. 
Acesso em: 15 abril 2014. 

[17] MILIES, César Polcino. Breve introdução à Teoria dos Códigos Corretores de Erros. 
In: 1º Colóquio de Matemática da Região Nordeste, 2011, UFS, Sergipe. Anais... São Paulo: 
Instituto de Matemática e Estatística da Universidade de São Paulo, 2011. Disponível em:  
< http://www.sbm.org.br/docs/coloquios/NE-1.04.pdf>. Acesso em: 15 abril 2014. 

[18]  MOREIRA,  Marco  Antonio.  Aprendizagem  Significativa: Um  Conceito  Subjacente. 
In:  Aprendizagem  Significativa  em  Revista  –  V1(3),  p.  25-46,  2011.  Disponível  em: 
<http://www.if.ufrgs.br/asr/artigos/Artigo_ID16/v1_n3_a2011.pdf>.  Acesso  em:  8  janeiro 
2015. 

 93 

 
 
 
 
 
 
 
 
 
 
[19]  OLIVEIRA,  Elizabeth  M.  Metodologia  para  o  uso  da  Informática  na  Educação. 
Revista da Sociedade Brasileira de Educação Matemática. SBEM. Ano 13. nº.23. dez. 2007. 

[20] OLIVEIRA, José Sávio Bicho de; ALVES, Angela Xavier; NEVES, Sandra Socorro de 
Miranda.  História  da  Matemática:  Contribuições  e  Descobertas  para  o  Ensino-
aprendizagem de Matemática. Disponível em: 
 <http://www.sbemrn.com.br/site/II%20erem/comunica/doc/comunica14.pdf>.  Acesso  em  16 
março 2015. 

[21]  QUILES,  Cláudia  Natália  Saes.  O  Uso  do  Computador  na  Escola:  Mapeando  os 
“Métodos  de  Ensinar”  na  Sala  de  Tecnologias  Educacionais  (STE).  In:  IX  Congresso 
Nacional de Educação – EDUCERE. PUCPR, 2009. Disponível em:  
<  http://www.pucpr.br/eventos/educere/educere2009/anais/pdf/2487_1780.pdf>.  Acesso  em: 
12 janeiro 2015. 

[22]  RIOS,  Isabel  Lugão;  FIGUEIREDO,  Luiz  Manoel;  CUNHA,  Marisa  Ortegoza  da. 
Álgebra Linear I. Volume 1. 3. ed. Rio de Janeiro: Fundação CECIERJ, 2010. 

[23]  SILVA,  Valeska  Aparecida  Rodrigues  da.  Propostas  de  Utilização  de  Códigos  de 
Barras  como  Recurso  Didático  para  o  Ensino  da  Matemática.  2013.  Dissertação 
(Mestrado  Profissional  em  Matemática  em  Rede  Nacional)  –  Instituto  de  Ciências  Exatas, 
Universidade  Federal  Rural  do  Rio  de  Janeiro,  Seropédica,  2013.  Disponível  em: 
<http://bit.profmat-sbm.org.br/xmlui/bitstream/handle/123456789/520/2011_00418_VALES 
KA_APARECIDA_RODRIGUES_DA_SILVA.pdf?sequence=1>. Acesso em: 21 abril 2014. 

[24]  SILVEIRA,  J.  F.  Porto.  O  que  é  um  problema  matemático?  2001.  Disponível  em: 
<http://www.mat.ufrgs.br/~portosil/resu1.html>. Acesso em: 20 fevereiro 2015. 

[25]  SOUZA,  Adenilce  Oliveira;  CÂMARA,  Marcos  Antonio  da.  Códigos  Corretores  de 
Erros Lineares. FAMAT em Revista, Uberlândia, nº 6, p. 75-110, maio 2006. Disponível em: 
<http://www.portal.famat.ufu.br/sites/famat.ufu.br/files/Anexos/Bookpage/Famat_Revista_06
.pdf>. Acesso em: 21 abril 2014. 

[26] SOUZA, Mário José de. Mini Curso Códigos Corretores de Erros. In: XXIII Semana 
do  IME  na  Universidade  Federal  de  Goiás,  UFG,  Goiânia.  Notas  disponíveis  em: 
<https://semanadoime.mat.ufg.br/up/34/o/min_mario.pdf>. Acesso em: 15 janeiro 2015. 

[27]  SOUZA,  Natália  Pedroza  de.  Uma  Análise  dos  Esquemas  de  Dígitos  Verificadores 
Usados  no  Brasil.  2013.  Dissertação  (Programa  de  Pós-Graduação  em  Ciências 
Computacionais  da  UFRJ)  –  Centro  de  Tecnologia  e  Ciênicas,  Instituto  de  Matemática  e 
Estatística,  Universidade Federal do Rio de Janeiro, Rio de Janeiro, 2013. Disponível em: < 
http://www.bdtd.uerj.br/tde_busca/arquivo.php?codArquivo=6100>.  Acesso  em:  10  março 
2015. 

 94 

 
 
 
 
 
 
 
 
 
 
[28]  VALENTE,  José  Armando.  O  Computador  na  Sociedade  do  Conhecimento. 
Ministério  da Educação.  Coleção  Informática  para  a  mudança  na  Educação.  Disponível  em: 
<http://www.dominiopublico.gov.br/download/texto/me003150.pdf>.  Acesso  em:  02  abril 
2015. 

[29]  VELOSO,  Marcelo  Oliveira;  COSTA,  Fernanda  Rodrigues  Alves.  Sistemas  de 
Identificação  Modular:  uma  Aplicação  no  Ensino  Fundamental.  2014.  Trabalho  de 
Conclusão  de  Curso  (Mestrado  Profissional  em  Matemática  -  PROFMAT),  Universidade 
Federal  de  São  João  Del  Rei,  Alto  Paraopeba,  2014.  Disponível  em:  <  http://bit.profmat-
sbm.org.br/xmlui/bitstream/handle/123456789/1166/2012_00948_FERNANDA_RODRIGU
ES_ALVES_COSTA.pdf?sequence=1>. Acesso em: 15 março 2015. 

[30]  VIANA,  Marger  da  Conceição  Ventuna;  SILVA,  Célia  Maria  da.  Concepção  de 
Professores de Matemática sobre a Utilização da História da Matemática no Processo de 
Ensino  Aprendizagem.  Disponível  em:  <http://www.limc.ufrj.br/htem4/papers/15.pdf>. 
Acesso em: 15 março 2015. 

[31] VILELA, Vera Lúcia Maria Luciano. O Lúdico como Instrumento de Aprendizagem 
no Ensino da Matemática. Dissertação (Mestrado em Educação) – Universidade Federal de 
Goiás,  Goiânia,  2008.  Disponível  em:  <https://ppge.fe.ufg.br/up/6/o/Dissert-%20Vera.pdf>. 
Acesso em: 15 janeiro 2015.  

[32]  VOLOCH,  José  Felipe.  Códigos  corretores  de  erros.  In:  16º  Colóquio  brasileiro  de 
Matemática, 1987, IMPA, Rio de Janeiro.  Anais... Rio de Janeiro:  IMPA, 1987. Disponível 
em: <http://www.impa.br/opencms/pt/biblioteca/cbm/16CBM/16_CBM_87 _06.pdf>. Acesso 
em: 05 abril 2014. 

[33]  VYGOTSKY,  Lev  Semenovich.  A  formação  social  da  mente.  4.  ed.  Brasileira.  São 
Paulo: Martins Fontes, 1984, p. 160. 

 95 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
APÊNDICE A 

Folha da atividade 1  

Questão 1: A primeira final de copa do mundo de futebol foi realizada entre quais países? 

a)  Uruguai e Argentina 

b)  Argentina e Brasil 

c)  Alemanha e Itália 

d)  Uruguai e Brail 

e)  Inglaterra e Paraguai 

Questão 2: Na frase: Antônio e Maria foram ao cinema. O sujeito da frase é classificado em: 

a)  Oculto 

b)  Simples 

c)  Composto 

d)  Oração sem sujeito 

e)  Indeterminado 

Questão 3: O Brasil vive uma crise hídrica. Qual o nome do rio que abastece os estados do 

Rio  de  Janeiro,  São  Paulo  e  Minas  Gerais  e  que  foi  objeto  de  um  recente  acordo  com  a 

Agência Nacional de Águas para sua utilização? 

a)  Rio Acre 

b)  Rio Amazonas 

c)  Rio São Francisco 

d)  Rio Paraíba do Sul 

e)  Rio Guandú 

Questão 4: Qual o nome do primeiro presidente eleito pelo voto direto da população após o 

período da ditadura militar? 

a)  Fernando Henrique Cardoso 

b)  Sarney 

c)  Fernando Collor 

d)  Dilma 

e)  Lula 

 96 

 
 
 
 
 
Questão 5: Quais os nomes das camadas eletrônicas de distribuição de elétrons? 

a)  A, B, C, D, E, F, G 

b)  K, L, M, N, O, P, Q 

c)  R, S, T, U, V, W, X 

d)  M, N, O, P, Q, R, S 

e)  A, E, I, O, U 

Questão 6: Qual o nome do primeiro brasileiro campeão de surf? 

a)  Guga 

b)  Pedro Alvarenga 

c)  José Dirceu 

d)  Gabriel Medina 

e)  Mick Fanning 

Questão 7: Suponha que sobre uma mesa haja um livro. Qual será a força que a mesa exerce 

sobre o livro (força normal), sabendo que a força com que a Terra o atrai é de 10N? 

a)  5N 

b)  8N 

c)  15N 

d)  3N 

e)  10N 

Questão 8: Os insetos possem: 

a)  Um par de asas e 3 pares de pernas 

b)  Dois pares de asas e 2 pares de pernas 

c)  Quatro pares de asas e 3 pares de pernas 

d)  Um ou dois pares de asas e 3 pares de pernas 

e)  Um par de asas e um par de pernas 

 97 

 
 
 
 
 
 
 
APÊNDICE B 

Folha da atividade 2  

Questão 1: Nos códigos de barras das figuras a seguir, faça o cálculo referente à identificação 

do dígito verificador. 

Fonte: Foto de uma embalagem de chocolate 

Fonte: Foto de uma embalagem de milho verde. 

Questão  2:  Determine  o  dígito  verificado  de  um  produto  que  tem  código  de  barras 

correspondente à sequência numérica 789603609511X. 

Questão 3: Considere que o número 4891668326689 é a sequência numérica de um código de 

barras. Verifique em cada caso se o erro será detectado. 

a) A sequência digitada é 4891668326698 (houve inversão dos dois últimos dígitos) 

b) A sequência digitada é 4896168326689 (houve inversão do quarto e quinto dígitos na 

digitação) 

 98 

 
 
 
 
 
 
 
 
 
Observações referentes à folha de atividades 2: 

Questão  1:  A  primeira  questão  pode  ser  substituída  por  uma  atividade  na  qual  sejam 

distribuídas aos alunos embalagens de produtos a fim de que eles analisem o código de barras 

correspondente.  

Questão 2:  

Resolução:  

Como o código contém 13 dígitos, trata-se de um EAN-13. Façamos o produto escalar entre 

os vetores (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) e (7, 8, 9, 6, 0, 3, 6, 0, 9, 5, 1, 1, X). Teremos, 

portanto, como resultado, a expressão 101 + x. O menor valor de x inteiro não negativo que 

pode nos levar ao menor múltiplo de dez mais próximo de 101 é x = 9. 

Questão 3:  

a)  

Resolução: 

O  código  possui  13  dígitos.  Trata-se,  portanto,  de  um  EAN-13.  Devemos  fazer  o  produto 

escalar entre os vetores (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) e (4, 8, 9, 1, 6, 6, 8, 3, 2, 6, 6, 9, 8). 

O resulta é 144, que não é um múltiplo de dez. Portanto, o erro será detectado. 

b)  

Resolução: 

Vamos fazer o produto escalar entre os vetores (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) e (4, 8, 9, 6, 

1, 6, 8, 3, 2, 6, 6, 9, 8). O resulta é 150, que é um múltiplo de dez. Portanto, o erro não será 

detectado. 

 99 

 
 
 
 
 
 
 
