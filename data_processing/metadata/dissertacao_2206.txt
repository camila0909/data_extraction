COLÃ‰GIO PEDRO II 

PrÃ³-Reitoria de PÃ³s-GraduaÃ§Ã£o, Pesquisa, ExtensÃ£o e Cultura 

Mestrado Profissional em MatemÃ¡tica em Rede Nacional 

Thiago Valladares da Silva 

CAMINHOS MÃNIMOS EM GRAFOS:  
Uma Proposta para AlÃ©m da Sala de Aula 

Rio de Janeiro 
2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Thiago Valladares da Silva 

CAMINHOS MÃNIMOS EM GRAFOS:  
Uma Proposta para AlÃ©m da Sala de Aula 

DissertaÃ§Ã£o  de  Mestrado  apresentada  ao 
Programa  de  Mestrado  Profissional  em 
MatemÃ¡tica  em  Rede  Nacional,  vinculado  Ã  
PrÃ³-Reitoria  de  PÃ³s-GraduaÃ§Ã£o,  Pesquisa, 
ExtensÃ£o e Cultura do ColÃ©gio Pedro II, como 
requisito  parcial  para  obtenÃ§Ã£o  do  tÃ­tulo  de 
Mestre em MatemÃ¡tica. 

                              Orientador(a): Prof(a). Dra. PatrÃ­cia Erthal de Moraes 

Rio de Janeiro 
2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                       
 
                                                                       
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
COLÃ‰GIO PEDRO II 

PRÃ“-REITORIA DE PÃ“S-GRADUAÃ‡ÃƒO, PESQUISA, EXTENSÃƒO E CULTURA 

BIBLIOTECA PROFESSORA SILVIA BECHER  

CATALOGAÃ‡ÃƒO NA FONTE 

S586     Silva, Thiago Valladares da  

    Caminhos mÃ­nimos em grafos: uma proposta para alÃ©m da sala de 
aula / Thiago Valladares da Silva. â€“ Rio de Janeiro, 2018. 

                    77 f. 

         DissertaÃ§Ã£o (Mestrado Profissional em MatemÃ¡tica em Rede 
Nacional) â€“ ColÃ©gio Pedro II. PrÃ³-Reitoria de PÃ³s-GraduaÃ§Ã£o, Pesquisa, 
ExtensÃ£o e Cultura. 
      Orientador: Patricia Erthal. 

                    1. MatemÃ¡tica â€“ Estudo e ensino. 2. Grafo. 3. AlgorÃ­tmo de Dijkstra. 
4. AlgorÃ­tmo de Floyd-Warshall. I. Erthal, Patricia. II. TÃ­tulo.  
                                                                                                                 CDD 510 

Ficha catalogrÃ¡fica elaborada pelo BibliotecÃ¡rio Andre Dantas â€“ CRB7 5026 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                     
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
Thiago Valladares da Silva 

CAMINHOS MÃNIMOS EM GRAFOS 
Uma Proposta para AlÃ©m da Sala de Aula 

DissertaÃ§Ã£o  de  Mestrado  apresentada  ao 
Programa  de  Mestrado  Profissional  em 
MatemÃ¡tica  em  Rede  Nacional,  vinculado  Ã  
PrÃ³-Reitoria  de  PÃ³s-GraduaÃ§Ã£o,  Pesquisa, 
ExtensÃ£o e Cultura do ColÃ©gio Pedro II, como 
requisito  parcial  para  obtenÃ§Ã£o  do  tÃ­tulo  de 
Mestre em MatemÃ¡tica. 

Aprovado em: _____/_____/_____. 

Banca Examinadora: 

_________________________________________ 
Prof. Dra. PatrÃ­cia Erthal de Moraes â€“ ColÃ©gio Pedro II 

_________________________________________ 
Prof. Dra. Christine SertÃ£ Costa 

_________________________________________ 
Prof. Dra.  EmÃ­lia Carolina Santana Teixeira Alves 

Rio de Janeiro 
2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

AgradeÃ§o aos meus pais por terem feito de mim o homem que hoje sou. Se cheguei atÃ© 

aqui, devo isso a eles. 

AgradeÃ§o aos meus colegas pelas diversas vezes que estudamos, mesmo que Ã  distÃ¢ncia 

por intermÃ©dio de um aplicativo de mensagens instantÃ¢neas. Em especial, agradeÃ§o aos amigos 

Ãlvaro  Domingos,  VinÃ­cius  Trevezzini  e  Denise  Tokuyama  pelos  diversos  momentos  de 

descontraÃ§Ã£o que tivemos. A caminhada foi mais fÃ¡cil por conta deles. 

AgradeÃ§o  a  todos  os  funcionÃ¡rios  da  PROPGEPEC  e  a  todo  corpo  docente  do 

PROFMAT/CPII, em especial ao Prof. Dr. Daniel Martins que tambÃ©m me incentivou a prestar 

o exame de acesso e a minha orientadora e amiga, a Prof. Dra. PatrÃ­cia Erthal, que me conduziu 

na Ã¡rdua tarefa de escrever este trabalho. Meu muito obrigado a vocÃªs. 

AgradeÃ§o Ã  Capes pelo fomento fornecido durante o curso, sem o qual seria impossÃ­vel 

conclui-lo. 

AgradeÃ§o a minha amada esposa que me incentivou a prestar a prova de acesso para o 

mestrado apesar de eu nÃ£o demonstrar interesse. AgradeÃ§o a ela por ter estudado comigo diversas 

vezes, por compreender a ausÃªncia em algumas atividades devido ao tempo destinado aos estudos 

e por me dar suporte ao longo dessa jornada. Sem ela ao meu lado eu nunca teria chegado aqui. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
â€œSe  enxerguei  mais  longe,  foi  porque  me 
apoiei sobre ombros de gigantes. â€ 

- Isaac Newton 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

SILVA, Thiago Valladares da. Caminhos MÃ­nimos em Grafos: Uma Proposta para AlÃ©m da 
Sala  de Aula.  2018.  77  f.  DissertaÃ§Ã£o  (Mestrado)  â€“  ColÃ©gio  Pedro  II,  PrÃ³-Reitoria  de  PÃ³s-
GraduaÃ§Ã£o, Pesquisa, ExtensÃ£o e Cultura, Programa de Mestrado Profissional em MatemÃ¡tica 
em Rede Nacional, Rio de Janeiro, 2018. 

O presente trabalho apresenta conceitos e resultados bÃ¡sicos acerca da Teoria dos Grafos e tem 
por objetivo fornecer a fundamentaÃ§Ã£o teÃ³rica necessÃ¡ria para que o tema possa ser explorado e 
discutido com alunos do Ensino MÃ©dio. A partir da apresentaÃ§Ã£o de um problema aparentemente 
simples e de fÃ¡cil entendimento, O Problema de Caminho MÃ­nimo em um Grafo, estuda-se dois 
algoritmos: o Algoritmo de Dijkstra e o Algoritmo de Floyd-Warshall. Com relaÃ§Ã£o a esse Ãºltimo, 
Ã© discutido um Problema de AlocaÃ§Ã£o. Ao final do trabalho Ã© apresentada uma proposta de oficina 
para alunos do Ensino MÃ©dio que tem por objetivo desenvolver os algoritmos citados ao longo 
do Trabalho, aplicando-os na resoluÃ§Ã£o de um problema previamente sugerido. A intenÃ§Ã£o Ã© que 
os  alunos,  a  partir  de  uma  situaÃ§Ã£o  concreta,  construam  um  modelo  matemÃ¡tico  aplicando  a 
Teoria de Grafos, utilizem um algoritmo, compreendam passo a passo o seu funcionamento, para 
assim obterem uma soluÃ§Ã£o desejada. 

Palavras-chave:  Grafo.  Problema de Caminho  MÃ­nimo. Algoritmo de  Dijkstra. Algoritmo de 
Floyd-Warshall. 

 
 
 
 
 
 
ABSTRACT 

SILVA, Thiago Valladares da. Caminhos MÃ­nimos em Grafos: Uma Proposta para AlÃ©m da 
Sala de Aula. 77 f. DissertaÃ§Ã£o (Mestrado) â€“ ColÃ©gio Pedro II, PrÃ³-Reitoria de PÃ³s-GraduaÃ§Ã£o, 
Pesquisa,  ExtensÃ£o  e  Cultura.  Programa  de  Mestrado  Profissional  em  MatemÃ¡tica  em  Rede 
Nacional, Rio de Janeiro, 2018. 

This  study  presents  concepts  and  basic  results  on  the  Graph Theory.  Its  main  objective  is  to 
provide the necessary theoretical basis so that the theme can be explored and discussed with High 
School students. Starting from the presentation of an apparently simple and easily understandable 
problem, the Shortest Path in a Graph problem, we study two algorithms: the Dijkstra Algorithm 
and the Floyd-Warshall Algorithm. Concerning the latter, it is discussed the Allocation Problem. 
By the end of the study, it is presented a proposition of a workshop for High School students, 
which aims to develop the algorithms cited throughout the study, applying them to the solution 
of a previoulsy suggested problem. The intention is that the students, starting from a concrete 
situation,  construct  a  mathematical  model  applying  the  Graph  Theory,  use  an  algorithm, 
understand each step of its operation, in order to obtain the desired solution. 

Keywords: Graph. Short Path Problem. Dijkstra Algorithm. Floyd-Warshall Algorithm. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÃRIO 

1 INTRODUÃ‡ÃƒO .................................................................................................................... 10 

2 TEORIA DOS GRAFOS ..................................................................................................... 12 

2.1 Resumo HistÃ³rico .............................................................................................................. 12 

2.2 DefiniÃ§Ãµes e Conceitos acerca da Teoria dos Grafos ........................................................ 15 

3 O PROBLEMA DE CAMINHO MÃNIMO EM UM GRAFO ........................................ 27 

3.1 O Algoritmo de Dijkstra ................................................................................................... 27 

3.1.1 Funcionamento do Algoritmo de Dijkstra ................................................................. 29 

3.2 O Algoritmo de Floyd-Warshall (ou Roy-Warshall) ........................................................ 34 

3.2.1 Funcionamento do Algoritmo de Floyd-Warshal ...................................................... 35 

3.2.2 AplicaÃ§Ãµes do Algoritmo de Floyd-Warshal.............................................................. 41 

4 UMA PROPOSTA PARA ALÃ‰M DA SALA DE AULA ................................................. 44 

4.1 TÃ³pico 1: O Problema Motivador ..................................................................................... 44 

4.2 TÃ³pico 2: Algoritmos ........................................................................................................ 46 

4.3 TÃ³pico 3: O Algoritmo de Dijkstra ................................................................................... 47 

4.4 TÃ³pico 4: AplicaÃ§Ã£o do Algoritmo de Dijkstra ................................................................. 49 

4.5 TÃ³pico 5: O Algoritmo de Floyd-Warshall ....................................................................... 55 

4.6 TÃ³pico 6: AplicaÃ§Ã£o do Algoritmo de Floyd-Warshall ..................................................... 57 

5 CONSIDERAÃ‡Ã•ES FINAIS .............................................................................................. 70 

REFERÃŠNCIAS ...................................................................................................................... 71 

APÃŠNDICE A â€“ FLUXOGRAMA DO ALGORITMO DE DIJKSTRA ........................... 72 

APÃŠNDICE B â€“ PSEUDOCÃ“DIGO DO ALGORITMO DE DIJKSTRA ........................ 73 

APÃŠNDICE C â€“ FLUXOGRAMA DO ALGORITMO DE FLOYD-WARSHAL ........... 74 

APÃŠNDICE D â€“ PSEUDOCÃ“DIGO DO ALGORITMO DE FLOYD-WARSHALL ..... 75 

APÃŠNDICE F â€“ SITUAÃ‡Ã•ES MOTIVADORAS PARA A INTRODUÃ‡ÃƒO DO CONCEITO DE 

ALGORITMOS ............................................................................................................ 76 

APÃŠNDICE G â€“ RESUMO HISTÃ“RICO DO SURGIMENTO DOS ALGORITMOS .. 77 

 
 
1 INTRODUÃ‡ÃƒO 

10 

Uma busca constante de professores de matemÃ¡tica Ã© a contextualizaÃ§Ã£o dos conteÃºdos 

de maneira a dar resposta a perguntas como â€œOnde Ã© que usarei isso professor?â€ ou â€œPra que 

serve  isso?â€.  Por  vezes  cria-se  uma  situaÃ§Ã£o  muito  artificial  para  justificar  o  ensino  de 

determinados conteÃºdos. De fato, hÃ¡ assuntos que tem pouquÃ­ssima ou nenhuma aplicaÃ§Ã£o fora 

da matemÃ¡tica em si. Contudo, hÃ¡ aqueles que podem ser adaptados com relativa facilidade, de 

maneira significativa para o aluno. Neste trabalho apresentaremos um tÃ³pico que julgamos se 

encaixar no segundo grupo: a Teoria de Grafos. 

A  Teoria  dos  Grafos  Ã©  um  assunto  que  remonta  ao  sÃ©culo  XVIII  e  possui  diversas 

aplicaÃ§Ãµes  em  situaÃ§Ãµes  reais.  Seu  conceito  foi  introduzido  pelo  matemÃ¡tico  suÃ­Ã§o  Leonhard 

Euler  em  1736  para  resolver  um  problema  que  hoje  Ã©  conhecido  como  â€œAs  sete  pontes  de 

KÃ¶ningsbergâ€.  Este  problema  constituiu  um  dos  primeiros  resultados  de  uma  nova  Ã¡rea  da 

matemÃ¡tica, a topologia. De maneira informal, um grafo pode ser interpretado como um conjunto 

de pontos no plano, denominado vÃ©rtices, e um conjunto de segmentos, chamados de arestas, que 

conectam dois destes pontos. Ã‰ possÃ­vel modelar diversas situaÃ§Ãµes concretas utilizando grafos, 

tais como: fluxo de dados em sistemas de computaÃ§Ã£o, malha de trÃ¡fego urbano, aplicaÃ§Ãµes em 

circuitos  elÃ©tricos,  modelos  de  quÃ­mica  orgÃ¢nica,  coloraÃ§Ã£o  de  mapas  entre  outras.  A 

simplicidade  desse  conceito,  a  quase  nÃ£o  existÃªncia  de  prÃ©-requisitos  necessÃ¡rios  para  o  seu 

entendimento e a sua vasta aplicabilidade tornam o assunto bastante atrativo para ser apresentado 

a alunos do ensino mÃ©dio. 

Atribuindo valores Ã s arestas podemos estabelecer a noÃ§Ã£o de custo de travessia entre os 

vÃ©rtices de um grafo. Dependendo do problema modelado esse custo pode representar um valor 

monetÃ¡rio,  tempo,  fluxo  de  objetos,  distÃ¢ncia,  entre outros.  Muitos  problemas  de  otimizaÃ§Ã£o, 

conhecidos  como  Problema  de  Caminhos  MÃ­nimos,  tÃªm  por  objetivo  minimizar  esse  custo. 

Existem diversos algoritmos utilizados para esse fim. Neste trabalho abordaremos dois deles, o 

Algoritmo de Dijkstra e o Algoritmo de Floyd-Warshall. 

A fim de introduzir o conceito de grafos para alunos do ensino mÃ©dio, propomos uma 

oficina ao final deste trabalho. Nela apresentamos um problema de ordem prÃ¡tica que pode ser 

modelado  utilizando-se  um  grafo.  A  partir  deste  problema  Ã©  possÃ­vel  apresentar  os  conceitos 

iniciais de grafos, os algoritmos supracitados e levÃ¡-los a resolver esse problema utilizando-os. 

Essa  oficina  foi  elaborada  em  uma  sequÃªncia  de  tÃ³picos  que  julgamos  necessÃ¡rios  para  tal 

 
 
 
 
 
11 

abordagem. O nosso objetivo Ã© que, ao final da oficina, o aluno tenha desenvolvido um pouco do 

pensamento algorÃ­tmico alÃ©m de ter se apropriado de um novo conceito matemÃ¡tico. 

Este trabalho estÃ¡ estruturado de modo que no capÃ­tulo 2 sÃ£o estudados alguns conceitos 

introdutÃ³rios em Teoria dos Grafos bem como alguns de seus aspectos histÃ³ricos. No capÃ­tulo 3 

apresentamos O Problema de Caminhos MÃ­nimos em um Grafo e estudamos os algoritmos de 

Dijkstra e Floyd-Warshall, descrevendo em detalhes o funcionamento de cada um deles. Afim 

de aplicarmos a teoria apresentada nos capÃ­tulos anteriores, propomos, no capÃ­tulo 4, a oficina 

descrita acima. No capÃ­tulo 5 sÃ£o feitas algumas consideraÃ§Ãµes a respeito do trabalho como um 

todo, bem como as dificuldades apresentadas em sua elaboraÃ§Ã£o. 

 
 
 
 
 
 
 
 
2 TEORIA DOS GRAFOS 

12 

Esse trabalho tem a intenÃ§Ã£o de ser o mais autocontido possÃ­vel. Por conta disso foram 

elencados  alguns  conceitos  e  resultados  bÃ¡sicos  sobre  a  Teoria  de  Grafos  que  consideramos 

necessÃ¡rios para a compreensÃ£o do tema. AlÃ©m disso, apresentaremos um apanhado histÃ³rico de 

sua origem. 

2.1 Resumo HistÃ³rico 

Nessa  seÃ§Ã£o  serÃ¡  feita  uma  abordagem  histÃ³rica  acerca  da  Teoria  de  Grafos  que  foi 

elaborada com base em Boaventura e Jurkiewicz (2009). 

O primeiro registro de um problema envolvendo grafos remonta ao sÃ©c. XVIII. No ano 

de  1736  o  matemÃ¡tico  suÃ­Ã§o  Leonhard  Euler  se  encontrava  na  cidade  de  KÃ¶nigsberg  (hoje 

Kaliningrd, na RÃºssia), onde um problema aparentemente simples, mas ainda sem soluÃ§Ã£o, estava 

sendo discutido pelos intelectuais do local. No rio Preguel, que cortava a cidade, havia duas ilhas 

que eram interligadas por uma ponte. Essas ilhas ainda se interligavam Ã s margens do rio por 

mais seis pontes (ver Figura 1). O problema consistia em encontrar um caminho com inÃ­cio em 

uma das margens que percorresse as sete pontes, sem repetiÃ§Ã£o, e terminasse no ponto de partida. 

Figura 1 â€“  Cidade de KÃ¶nigsberg 

 Fonte: http://matematicacomge.blogspot.com.br/2015/01/as-sete-pontes-de-konigsberg.html 

Utilizando uma representaÃ§Ã£o simplificada do problema, onde as massas de terra eram 

representadas  por  pontos  e  as  pontes  por  linhas,  Euler  demonstrou  que  tal  percurso  era 

 
 
  
 
 
 
 
impossÃ­vel. Ele notou que o nÃºmero de passagens de uma margem para uma ilha, ou entre as 

ilhas, era Ã­mpar (ver Figura 2). 

Figura 2 â€“ RepresentaÃ§Ã£o das pontes de KÃ¶nigsberg 

13 

Fonte: http://matematicacomge.blogspot.com.br/2015/01/as-sete-pontes-de-konigsberg.html 

Se  o  nÃºmero  de  pontes  com  extremidade  em  uma  massa  de  terra  Ã©  Ã­mpar,  em  algum 

momento se chegarÃ¡ a ela, mas nÃ£o serÃ¡ possÃ­vel sair, pois as demais pontes jÃ¡ foram utilizadas. 

Euler demonstrou que o percurso sÃ³ seria possÃ­vel se o nÃºmero de ligaÃ§Ãµes entre as massas de 

terra fosse um nÃºmero par.  

O esquema utilizado por Euler Ã© uma representaÃ§Ã£o grÃ¡fica do que hoje se chama de grafo 

nÃ£o orientado, ou simplesmente grafo. Ã‰ possÃ­vel compreender um grafo como uma estrutura 

composta  por elementos  de  dois  conjuntos:  um ao  qual  chamamos  de conjunto  de  vÃ©rtices,  e 

outro,  chamado  conjunto  de  arestas,  onde  descrevemos  as  relaÃ§Ãµes  entre  os  vÃ©rtices. 

Graficamente,  representamos  os  vÃ©rtices  por  pontos  e  as  arestas  por  segmentos  de  retas  que 

possuem os vÃ©rtices como extremidade. 

Euler resolveu o problema das pontes de KÃ¶nigsberg mas nÃ£o se preocupou em estudar a 

fundo  ou  achar  alguma  aplicaÃ§Ã£o  para  esse  novo  tipo  de  estrutura.  Foi  apenas  que  1847  que 

Gustav Robert Kirchhoff publicou um resultado envolvendo circuitos elÃ©tricos que utilizava um 

modelo  de  grafos.  Dez  anos  mais  tarde,  Arthur  Cayley  utilizou  um  modelo  de  grafo  para 

determinar o nÃºmero de isÃ´meros diferentes de um hidrocarboneto com cadeia aberta.  

Francis  Guthrie  tambÃ©m  se  deparou  com  grafos  ao  analisar  um  suposto  fato  sobre 

coloraÃ§Ã£o de mapas. Era de conhecimento de todos os cartÃ³grafos da Ã©poca que quatro  cores 

eram suficientes para colorir qualquer mapa. Guthrie enunciou esse â€œfatoâ€ como um teorema e 

tentou prova-lo utilizando grafos. Apesar de seus esforÃ§os, Guthrie nÃ£o logrou Ãªxito, e o teorema, 

que ficou conhecido como â€œproblema das quatro coresâ€, ficou em aberto por mais de um sÃ©culo. 

 
 
 
 
 
 
Somente  em  1976,  com  o  uso  de  computadores  que  Kenneth  Appel e Wolfgang  Haken, 

demonstraram o teorema. 

A Teoria de Grafos se desenvolveu com mais intensidade a partir de 1950 com o advento 

da computaÃ§Ã£o, como explica Boaventura e Jurkiewicz (2009, p. 5): 

14 

A  partir  da  dÃ©cada  de  1950  a  pesquisa  operacional  (...)  comeÃ§ou  a  utilizar 
intensamente  os  modelos  de  grafo  em  busca  de  melhores  soluÃ§Ãµes  para 
problemas de projeto, organizaÃ§Ã£o e distribuiÃ§Ã£o. Essas aplicaÃ§Ãµes, viabilizadas 
pela invenÃ§Ã£o do computador, promoveram uma grande divulgaÃ§Ã£o desse tipo 
de modelagem (...). 

A  modelagem  de  problemas  por  grafos  Ã©  empregada  hoje  em  diversos  campos  como 

gestÃ£o de recursos, planejamento de transportes, projetos de processadores eletrÃ´nicos, estudo de 

estrutura de DNA, otimizaÃ§Ã£o de recursos humanos, entre outros.  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
2.2 DefiniÃ§Ãµes e Conceitos acerca da Teoria dos Grafos 

15 

Nesta  seÃ§Ã£o  elencaremos  alguns  conceitos  e  definiÃ§Ãµes  acerca  da  Teoria  de  Grafos. 

Utilizamos  como  base  para  esse  texto:  BOAVENTURA  (2009),  SCHEINERMAN  (2011)  e 

DIESTEL (2000). 

DefiniÃ§Ã£o 2.1: Um grafo nÃ£o orientado, ou simplesmente um grafo, Ã© um par ğº = (ğ‘‰, ğ¸), onde 

ğ‘‰ Ã© um conjunto finito e ğ¸ Ã© um conjunto de subconjuntos de dois elementos de ğ‘‰. Os elementos 

de ğ‘‰ sÃ£o chamados de vÃ©rtices do grafo e os elementos de ğ¸ sÃ£o as arestas do grafo que possuem 

como extremidades os vÃ©rtices pertencentes a esse subconjunto de dois elementos. 

Para um grafo de ğ‘› vÃ©rtices adotaremos ğ‘‰ = {1,2, â€¦ , ğ‘›}, ğ‘› âˆˆ â„•. 

Exemplo 2.1: Seja ğº = (ğ‘‰, ğ¸), onde ğ‘‰ = {1,2,3,4,5,6} e ğ¸ = {{1,2}, {2,4}, {4,5}, {1,6}, {4,6}, {5,6}}. 

De acordo com a definiÃ§Ã£o 2.1, ğº Ã© um grafo pois ğ‘‰ Ã© finito e ğ¸ Ã© um conjunto de subconjuntos 

de  ğ‘‰.  Nesse  exemplo,  o  grafo  possui  seis  vÃ©rtices  e  seis  arestas.  Como  se  pode  imaginar,  Ã© 

possÃ­vel representar esse grafo por meio de uma figura. Para tanto assinalamos seis pontos no 

plano  e  os  rotulamos  de  1  a  6.  Para  cada  aresta  ğ‘’ = {ğ‘–, ğ‘—} âˆˆ ğ¸  assinalamos  uma  curva  com 

extremos em ğ‘– e ğ‘—. A figura a seguir representa trÃªs diagramas para o mesmo grafo do exemplo 

2.1. 

Figura 3 â€“ Grafos 

Fonte: O autor, 2018 

No terceiro diagrama, o fato das linhas se cruzarem nÃ£o constituem problema, pois a informaÃ§Ã£o 

transmitida pelo desenho (vÃ©rtices e ligaÃ§Ãµes entre eles) nÃ£o se altera. Contudo, os cruzamentos 

podem tornar a leitura do grafo um pouco mais difÃ­cil. 

DefiniÃ§Ã£o 2.2: Seja ğº = (ğ‘‰, ğ¸) um grafo e ğ‘–, ğ‘— âˆˆ ğ‘‰. Dizemos que ğ‘– Ã© adjacente a ğ‘— se, e somente 

se, existe {ğ‘–, ğ‘—} âˆˆ ğ¸. A notaÃ§Ã£o ğ‘–~ğ‘— significa que ğ‘– Ã© adjacente a ğ‘—. 

 
 
 
 
 
 
 
DefiniÃ§Ã£o 2.3 (Isomorfismo): Dois grafos  ğº = (ğ‘‰, ğ¸) e ğºâ€² = (ğ‘‰â€², ğ¸â€²) sÃ£o isomorfos se existe 

uma bijeÃ§Ã£o ğœ‘: ğ‘‰ â†’ ğ‘‰â€² que preserva a adjacÃªncia dos vÃ©rtices, isto Ã©, se a aresta (ğ‘–, ğ‘—) âˆˆ ğ¸ entÃ£o, 

a aresta (ğœ‘(ğ‘–), ğœ‘(ğ‘—)) âˆˆ ğ¸â€². Escrevemos ğº â‰… ğºâ€² para indicar que os grafos ğº e ğºâ€² sÃ£o isomorfos. 

16 

Exemplo 1: Considere os grafos da Figura 4. 

Figura 4 â€“ Grafos Isomorfos 

ğº e ğºâ€² sÃ£o isomorfos e a funÃ§Ã£o que garante esse isomorfismo Ã© 

Fonte: O autor, 2018 

ğœ‘: ğ‘‰ â†’ ğ‘‰(cid:4593) 

ğ‘˜ â†’ ğ‘˜ 

onde ğ‘˜ âˆˆ {1,2,3,4,5}. 

DefiniÃ§Ã£o 2.4 (Digrafo): Um grafo orientado, ou digrafo, Ã© um par ğº = (ğ‘‰, ğ¸), onde ğ‘‰ Ã© um 

conjunto finito e ğ¸ Ã© o conjunto de pares ordenados (ğ‘–, ğ‘—), com ğ‘–, ğ‘— âˆˆ ğ‘‰. 

Apesar  da  semelhanÃ§a  dessa  definiÃ§Ã£o  com  a  DefiniÃ§Ã£o  2.1,  a  situaÃ§Ã£o  Ã©  completamente 

diferente.  Num  grafo  nÃ£o  orientado,  se  existe  uma  aresta  unindo  dois  vÃ©rtices  ğ‘–  e  ğ‘—  dizemos 

indistintamente que ğ‘–~ğ‘— e que ğ‘—~ğ‘–. Em um grafo orientado, o par (ğ‘–, ğ‘—) indica apenas que ğ‘–~ğ‘—. 

Em outras palavras: a relaÃ§Ã£o de adjacÃªncia nÃ£o se dÃ¡ nos dois sentidos. Para representar o sentido 

da relaÃ§Ã£o graficamente orientamos as arestas por meio de setas. Veja o exemplo a seguir. 

Exemplo  2.2:  Sejam  ğ‘‰ = {1,2,3,4,5,6}  e  ğ¸ = {(1,2),(2,4),(4,5),(1,6),(4,6),(5,6)}  e  o  par  ğº =

(ğ‘‰, ğ¸). Uma representaÃ§Ã£o desse grafo pode ser vista na Figura 5. 

Figura 5 â€“ Digrafo 

Fonte: O autor, 2018 

 
 
 
 
 
 
DefiniÃ§Ã£o 2.5 (VizinhanÃ§a e Grau de um VÃ©rtice): Dado um grafo ğº = (ğ‘‰, ğ¸) e ğ‘– âˆˆ ğ‘‰ chama-

se vizinhanÃ§a de ğ‘–, e denotamos por ğ‘(ğ‘–), o conjunto de todos os vÃ©rtices que sÃ£o adjacentes a ğ‘–. 

17 

Isto Ã©, 

Para o grafo do Exemplo 2.1, temos 

ğ‘(ğ‘–) = {ğ‘— âˆˆ ğ‘‰|ğ‘–~ğ‘—} 

ğ‘(1) = {2,6}    ğ‘(2) = {1,4}    ğ‘(3) = âˆ…    

ğ‘(4) = {2,5,6}    ğ‘(5) = {4,6}     ğ‘(6) = {1,4,5} 

Para o Exemplo 2.2, temos 

ğ‘(1) = {2,6}    ğ‘(2) = {4}    ğ‘(3) = âˆ…    

ğ‘(4) = {5,6}    ğ‘(5) = {6}     ğ‘(6) = âˆ…  

O grau de um vÃ©rtice ğ‘£, denotado por ğ‘‘ğ‘’ğ‘”(ğ‘–), Ã© o nÃºmero de vÃ©rtices adjacentes a ğ‘£, ou seja, 

Para o grafo do Exemplo 2.1, temos 

ğ‘‘ğ‘’ğ‘”(ğ‘–) = |ğ‘(ğ‘–)| 

ğ‘‘ğ‘’ğ‘”(1) = 2     ğ‘‘ğ‘’ğ‘”(2) = 2     ğ‘‘ğ‘’ğ‘”(3) = 0     ğ‘‘ğ‘’ğ‘”(4) = 3     ğ‘‘ğ‘’ğ‘”(5) = 2     ğ‘‘ğ‘’ğ‘”(6) = 3. 

O resultado a seguir relaciona os graus dos vÃ©rtices ao nÃºmero de arestas do grafo. 

Teorema 2.1: A soma dos graus dos vÃ©rtices de um grafo Ã© igual ao dobro do nÃºmero de arestas 

desse grafo. Ou seja: 

(cid:3041)

(cid:3533) ğ‘‘ğ‘’ğ‘”(

ğ‘–) = 2. |ğ¸| 

(cid:3036)(cid:2880)(cid:2869)

DemonstraÃ§Ã£o. Como cada aresta de um grafo incide em dois vÃ©rtices distintos, ao somarmos os 

graus  dos  vÃ©rtices  estaremos  contando  a  mesma  aresta  em  dois  momentos,  de  onde  segue  a 

verificaÃ§Ã£o do teorema. 

CorolÃ¡rio 2.1: Todo grafo ğº possui um nÃºmero par de vÃ©rtices de grau Ã­mpar. 

DemonstraÃ§Ã£o: Seja G um grafo. Suponha por absurdo que o nÃºmero de vÃ©rtices de grau Ã­mpar 

seja Ã­mpar. Dessa forma, a soma dos graus desses vÃ©rtices serÃ¡ um nÃºmero Ã­mpar ğ¼. Por outro 

lado, a soma dos graus dos vÃ©rtices de grau par sempre serÃ¡ par. Seja ğ‘ƒ esse valor. Logo a soma 

 
 
 
 
 
 
 
 
 
dos graus de todos os vÃ©rtices serÃ¡ ğ¼ + ğ‘ƒ, que Ã© um nÃºmero Ã­mpar. Absurdo, pois o Teorema 2.1 

garante que a soma dos graus Ã© o dobro do nÃºmero de arestas, portanto, um nÃºmero par. 

18 

DefiniÃ§Ã£o  2.6  (Arestas  Paralelas  e  Multigrafo):  Duas  arestas  distintas  de  um  grafo  ğº  sÃ£o 

paralelas se possuÃ­rem os mesmos extremos. Um grafo que possui pelo menos um par de arestas 

paralelas Ã© chamado de multigrafo, conforme a Figura 6. 

Figura 6 â€“ Grafo com arestas paralelas ğ‘’(cid:2869) e ğ‘’(cid:2870) 

Fonte: O autor, 2018 

DefiniÃ§Ã£o 2.7 (LaÃ§o): Chama-se laÃ§o a aresta que liga um vÃ©rtice a ele mesmo, conforme Figura 

7. 

Figura 7 â€“  Grafo com um laÃ§o 

Fonte: O autor, 2018 

Grafos que nÃ£o possuem arestas paralelas nem laÃ§os sÃ£o chamados de grafos simples. 

DefiniÃ§Ã£o 2.8 (Grafo Ponderado ou Valorado): Um grafo Ã© dito ponderado, ou simplesmente 

valorado, quando a cada uma de suas arestas Ã© atribuÃ­do um valor chamado de peso. Geralmente 

esse valor estÃ¡ associado ao custo da ligaÃ§Ã£o entre os vÃ©rtices. 

 
 
 
 
 
 
 
Exemplo 2.3: Podemos atribuir pesos ao grafo do exemplo 2.2, conforme a Figura 8. 

Figura 8 â€“ Grafos Valorados 

19 

Fonte: O autor, 2018 

DefiniÃ§Ã£o 2.9 (Matriz de AdjacÃªncia de um Grafo): Dados um grafo ğº = (ğ‘‰, ğ¸), e ğ‘–, ğ‘— âˆˆ ğ‘‰, 

chama-se matriz de adjacÃªncia de ğº, denotado por ğ´(cid:3008), Ã  matriz 

ğ´(cid:3008) = ğ‘(cid:3036)(cid:3037) = (cid:3420)

1, ğ‘ ğ‘’ ğ‘–~ğ‘— 
0, ğ‘ ğ‘’ ğ‘– â‰ ğ‘—

Essa definiÃ§Ã£o nos diz que Ã© possÃ­vel organizar a informaÃ§Ã£o das adjacÃªncias dos vÃ©rtices de um 

grafo em uma matriz onde as entradas sÃ£o apenas 0 ou 1. Se o vÃ©rtice ğ‘– Ã© adjacente ao vÃ©rtice ğ‘— 

temos  que  ğ‘(cid:3036)(cid:3037) = 1,  caso  contrÃ¡rio  ğ‘(cid:3036)(cid:3037) = 0.  Para  grafos  nÃ£o  orientados,  ğ´(cid:3008) serÃ¡  uma  matriz 

simÃ©trica, uma vez que ğ‘–~ğ‘— implica que j~ğ‘–. 

Exemplo 2.4: Para os grafos dos exemplos 2.1 e 2.2 temos, respectivamente, as matrizes 

0 1 0 0 0 1
â¤
â¡
1 0 0 1 0 0
â¥
â¢
0 0 0 0 0 0
â¥
â¢
0 1 0 0 1 1
â¥
â¢
â¥
â¢
0 0 0 1 0 1
1 0 0 1 1 0â¦
â£

    ğ’†    

0 1 0 0 0 1
â¤
â¡
0 0 0 1 0 0
â¥
â¢
0 0 0 0 0 0
â¥
â¢
. 
0 0 0 0 1 1
â¥
â¢
â¥
â¢
0 0 0 0 0 1
0 0 0 0 0 0â¦
â£

Num grafo valorado hÃ¡ uma outra matriz bastante utilizada chamada matriz dos pesos 

ğ‘ƒ = [ğ‘(cid:3036)(cid:3037)], definida como 

ğ‘(cid:3036)(cid:3037) = (cid:3420)

0, se nÃ£o existe a aresta (ğ‘–, ğ‘—)
ğ‘˜, onde k Ã© o peso da aresta (ğ‘–, ğ‘—)

As matrizes de pesos dos grafos representados na Figura 8 sÃ£o 

8 0 0 0 13
0
â¤
â¡
0
0 0 7 0
8
â¥
â¢
0
0 0 0 0
0
â¥
â¢
5
7 0 0 1
0
â¥
â¢
â¥
â¢
4
0 0 1 0
0
0 â¦
â£
13 0 0 5 4

    ğ’†    

0
0
0

3
0 17 0 0
â¤
â¡
0
0 4
0
â¥
â¢
0
0 0
0
â¥
â¢
. 
0 0 15 2
0
â¥
â¢
â¥
â¢
1
0 0
0
0â¦
â£
0 0
0

0
0
0
0
0

0
0

 
 
 
 
 
 
 
 
20 

A  matriz  de  adjacÃªncia  armazena  a  informaÃ§Ã£o  de  adjacÃªncia  relacionando  vÃ©rtice  a 

vÃ©rtice. TambÃ©m podemos armazenar essa informaÃ§Ã£o relacionando arestas a vÃ©rtices por meio 

de uma matriz, chamada matriz de incidÃªncia. Vejamos a definiÃ§Ã£o. 

DefiniÃ§Ã£o 2.10 (Matriz de IncidÃªncia): Chama-se matriz de incidÃªncia do grafo ğº = (ğ‘‰, ğ¸), Ã  

matriz ğµ = [ğ‘(cid:3036)(cid:3037)](cid:3040)Ã—(cid:3041), onde ğ‘š Ã© o nÃºmero de vÃ©rtices e ğ‘› Ã© o nÃºmero de arestas ğº, e 

ğ‘(cid:3036)(cid:3037) = (cid:3420)

1, se a aresta j possui o vÃ©rtice i como extremidade        
. 
0, se a aresta j nÃ£o possui o vÃ©rtice i como extremidade

A Figura 9 ilustra um exemplo.  

Figura 9 â€“ Grafos ğº e sua matriz de incidÃªncia 

Fonte: O autor, 2018 

Cada coluna dessa matriz representa uma aresta e conterÃ¡ apenas dois elementos 1, uma 

vez que uma aresta contÃ©m apenas dois extremos. As linhas em que esses elementos se encontram 

indicam quais vÃ©rtices sÃ£o extremos dessa aresta. Caso o grafo seja orientado, o vÃ©rtice-origem 

do arco Ã© identificado com âˆ’1 e o vÃ©rtice-fim com +1, como mostra a Figura 10. 

Figura 10 â€“ Grafos orientado e sua matriz de incidÃªncia 

Fonte: O autor, 2018 

 
 
 
 
 
 
 
 
21 

DefiniÃ§Ã£o 2.11 (Percurso ou Passeio): Chama-se percurso ou passeio num grafo ğº = (ğ‘‰, ğ¸) a 

uma sequÃªncia formada por elementos de ğ‘‰ e de ğ¸, alternadamente 

(ğ‘–(cid:2869), ğ‘’(cid:2869), ğ‘–(cid:2870), ğ‘’(cid:2870), â€¦ , , ğ‘–(cid:3041)(cid:2879)(cid:2869), ğ‘’(cid:3041)(cid:2879)(cid:2869), ğ‘–(cid:3041)) 

de modo que ğ‘’(cid:3038) = {ğ‘–(cid:3038), ğ‘–(cid:3038)(cid:2878)(cid:2869)}, ğ‘˜ = 1, â€¦ , ğ‘› âˆ’ 1. Em outras palavras, um percurso Ã© determinado 

por uma coleÃ§Ã£o de vÃ©rtices sucessivamente adjacentes.  

Considere o grafo da Figura 3. Nomeamos as arestas para descrever um percurso. 

Figura 11 â€“ DescriÃ§Ã£o de percursos 

Fonte: O autor, 2018 

Podemos  destacar,  por  exemplo,  o  passeio  ğœƒ(cid:2869) = (4, ğ‘’(cid:2874), 6, ğ‘’(cid:2873), 1, ğ‘’(cid:2869), 2, ğ‘’(cid:2870), 4, ğ‘’(cid:2871), 5).  Note 

que Ã© possÃ­vel repetir vÃ©rtices. Quando o vÃ©rtice inicial coincide com o vÃ©rtice final temos um 

passeio fechado. O passeio ğœƒ(cid:2870) = (4, ğ‘’(cid:2874), 6, ğ‘’(cid:2872), 5, ğ‘’(cid:2871), 4) Ã© fechado. O comprimento de um passeio 

num grafo nÃ£o ponderado Ã© igual ao nÃºmero de arestas que ele possui. Em um grafo ponderado, 

o comprimento de um passeio Ã© igual a soma dos pesos das arestas que esse passeio possui. 

Vejamos  agora  mais  algumas  definiÃ§Ãµes  obtidas  quando  alguma  restriÃ§Ã£o  Ã©  feita  ao 

passeio. 

DefiniÃ§Ã£o  2.12  (Trilha  ou  Cadeia):  Chama-se  trilha  ou  cadeia  ao  passeio  em  que  nÃ£o  hÃ¡ 

repetiÃ§Ã£o de arestas. 

O percurso ğœƒ(cid:2869), por exemplo, Ã© uma trilha. Note que nÃ£o hÃ¡ repetiÃ§Ã£o de arestas (apesar 

do vÃ©rtice 4 se repetir). 

DefiniÃ§Ã£o 2.13 (Caminho): Um caminho Ã© uma trilha que em que nÃ£o hÃ¡ repetiÃ§Ã£o de vÃ©rtices. 

O percurso ğœƒ(cid:2871) = (4, ğ‘’(cid:2870), 2, ğ‘’(cid:2869), 1, ğ‘’(cid:2873), 6), por exemplo, Ã© um caminho. 

DefiniÃ§Ã£o 2.14 (Ciclo): Um ciclo Ã© um passeio fechado sem repetiÃ§Ã£o de arestas e sem repetiÃ§Ã£o 

de vÃ©rtices a menos do inicial e do final. Por exemplo, o percurso fechado ğœƒ(cid:2870) tambÃ©m Ã© um ciclo. 

Num grafo ponderado, um ciclo Ã© dito negativo se a soma das arestas que o compÃµe resultar num  

nÃºmero negativo. 

 
 
 
 
 
 
 
 
 
 
22 

Se existe um caminho ligando ğ‘– a ğ‘—, partindo de ğ‘–, dizemos que ğ‘— Ã© atingÃ­vel a partir de  ğ‘–.  

DefiniÃ§Ã£o 2.15 (Fecho Transitivo): Num grafo nÃ£o orientado ğº = (ğ‘‰, ğ¸), o fecho transitivo de 

um vÃ©rtice ğ‘– em ğº, denotado por ğ‘…(ğ‘–), Ã© o conjunto de todos os vÃ©rtices que sÃ£o atingÃ­veis a partir 

de ğ‘–. 

Caso o grafo seja orientado haverÃ¡ dois tipos desses fechos: 

Fecho Transitivo Direto: Seja ğ‘– um vÃ©rtice de ğº. O conjunto de todos os vÃ©rtices atingÃ­veis a 

partir de ğ‘–, denotado por ğ‘…(cid:2878)(ğ‘–), Ã© chamado fecho transitivo direto. Os elementos de ğ‘…(cid:2878)(ğ‘–) sÃ£o 

chamados de descendentes de ğ‘–. 

Fecho Transitivo Inverso: Seja ğ‘– um vÃ©rtice de ğº. O conjunto de todos os vÃ©rtices ğ‘— para os quais 

ğ‘– Ã© atingÃ­vel a partir de ğ‘—, denotado por ğ‘…(cid:2879)(ğ‘–), Ã© chamado fecho transitivo inverso. Os elementos 

de ğ‘…(cid:2879)(ğ‘–) sÃ£o chamados de ascendentes de ğ‘–. 

Definiremos  a  seguir  um  conceito  muito  importante  em  teria  dos  grafos  chamado 

conexidade.  Esse  conceito  classifica  os  grafos  de acordo  com  as  ligaÃ§Ãµes  entre  seus  vÃ©rtices. 

Vamos a ele. 

DefiniÃ§Ã£o 2.16 (Conexidade): Um grafo nÃ£o orientado Ã© dito conexo se existe um caminho que 

une dois vÃ©rtices quaisquer desse grafo. Um grafo que nÃ£o possui essa propriedade Ã© chamado 

de desconexo. A Figura 12 ilustra um exemplo. 

Figura 12 â€“ Grafo conexo ğº(cid:2869) e grafo desconexo ğº(cid:2870) 

Observe o grafo orientado apresentado na Figura 13. 

Fonte: O autor, 2018 

Figura 13 â€“ Grafo ğº 

Fonte: O autor, 2018 

 
 
 
 
 
 
 
23 

Se escolhermos dois vÃ©rtices quaisquer neste exemplo, sempre existe um caminho que os 

une. Contudo, esse caminho nÃ£o ocorre nos dois sentidos. Tome por exemplo os vÃ©rtices 6 e 4. 

Existem um caminho que une 6 a 4, mas nÃ£o existe nenhum que une 4 a 6 (pois 4 sÃ³ recebe 

arcos). Precisamos entÃ£o estender a definiÃ§Ã£o para grafos orientados. 

Para um grafo orientado, temos as seguintes classificaÃ§Ãµes com relaÃ§Ã£o a conexidade: nÃ£o 

conexo, simplesmente conexo, semi-fortemente conexo e fortemente conexo.  Vamos a elas. 

Seja G um grafo orientado. 

ï‚·  ğº Ã© nÃ£o conexo se, desconsiderando a orientaÃ§Ã£o, existe pelo menos um par de vÃ©rtices que 

nÃ£o Ã© ligado por nenhum tipo de caminho.  

ï‚·  ğº  Ã©  simplesmente  conexo  se,  desconsiderando  a  orientaÃ§Ã£o,  existem  caminhos  ligando 

quaisquer par de vÃ©rtices.  

ï‚·  ğº Ã© dito semi-fortemente conexo se, para quaisquer vÃ©rtices ğ‘¢ e ğ‘£ existir um caminho de ğ‘¢ 

atÃ© ğ‘£ ou de ğ‘£ atÃ© ğ‘¢. O grafo da figura 10 Ã© desse tipo. 

ï‚·  ğº Ã© fortemente conexo se, para todo par de vÃ©rtices ğ‘¢ e ğ‘£, existe um caminho de ğ‘¢ atÃ© ğ‘£ e 

existe um caminho de ğ‘£ atÃ© ğ‘¢. Na figura abaixo mostramos alguns exemplos. 

Figura 14 â€“ Grafo desconexo, simplesmente conexo e fortemente conexo 

Enunciaremos  agora  um  teorema  que  garante  a  conexidade  num  grafo  simples  nÃ£o 

Fonte: O autor, 2018 

orientado. 

Teorema  2.2:  Seja  ğº = (ğ‘‰, ğ¸)  um  grafo  com  ğ‘›  vÃ©rtices.  Se  ğ‘‘ğ‘’ğ‘”(ğ‘£) â‰¥

entÃ£o ğº Ã© conexo. 

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

  para  todo  ğ‘£ âˆˆ ğ‘‰, 

DemonstraÃ§Ã£o:  Suponha  por  absurdo  que  ğº  seja  desconexo.  EntÃ£o  existem  pelo  menos  dois 

vÃ©rtices ğ‘¢, ğ‘£ âˆˆ ğ‘‰ que nÃ£o estÃ£o conectados. De cada um destes vÃ©rtices partem pelo menos 

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

arestas, os conectando a pelo menos 

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

 vÃ©rtices distintos como mostra a Figura 15. 

 
 
 
 
 
 
 
 
 
 
Figura 15 â€“ VÃ©rtices adjacentes a ğ‘¢ e vÃ©rtices adjacentes a ğ‘£ 

24 

Como  ğ‘¢  e  ğ‘£  nÃ£o  estÃ£o  conectados  ğ‘(ğ‘¢) âˆ© ğ‘(ğ‘£) = âˆ….  Observando  a  figura  12,  temos  que  ğº 

Fonte: O autor, 2018 

possui, no mÃ­nimo, 2 + 2 âˆ™ (cid:4672)

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

(cid:4673) = ğ‘› + 1 vÃ©rtices, o que Ã© um absurdo. Logo, ğº Ã© conexo. 

DefiniÃ§Ã£o 2.17 (Subgrafo): Considere os grafos ğº = (ğ‘‰, ğ¸) e ğºâ€² = (ğ‘‰â€², ğ¸â€²). Se ğºâ€² Ã© tal que ğ‘‰â€² âŠ†

ğ‘‰ e ğ¸â€² âŠ† ğ¸ dizemos que que ğºâ€² Ã© um subgrafo de ğº e ğºâ€² âŠ† ğº.  

Naturalmente, um grafo Ã© subgrafo de si prÃ³prio. Informalmente dizemos que ğº contÃ©m 

ğºâ€². ğº Ã© chamado de supergrafo de ğºâ€². A figura 5 mostra um grafo e alguns exemplos de subgrafo. 

Figura 16 â€“ Grafo ğº e alguns subgrafos. 

Fonte: O autor, 2018 

O subgrafo ğºâ€² e ğºâ€²â€² sÃ£o conexos. O primeiro Ã© obtido pela eliminaÃ§Ã£o da aresta {2,5} enquanto 

o segundo Ã© obtido pela deleÃ§Ã£o dos vÃ©rtices 3 e 4 e todas as arestas que neles incidem. JÃ¡ ğºâ€²â€²â€² Ã© 

desconexo e foi obtido pela supressÃ£o do vÃ©rtice 2 e suas arestas. Um vÃ©rtice pode ter todas as 

suas  arestas  deletadas  e  ser  mantido.  O  subgrafo  resultante  terÃ¡  um  vÃ©rtice  isolado  e  serÃ¡ 

desconexo. 

Mostraremos agora que o problema inicial do passeio pela cidade de Koningsberg 

nÃ£o possui soluÃ§Ã£o. Mas primeiro definiremos Trilha Euleriana e Grafo Euleriano. 

DefiniÃ§Ã£o 2.18 (Trilha Euleriana e Grafo Euleriano): Uma trilha fechada Ã© dita Euleriana se 

atravessa todas as arestas do grafo. Um grafo Ã© dito Euleriano se possui uma Trilha Euleriana. 

 
 
 
 
 
 
25 

Teorema  2.3  (CaracterizaÃ§Ã£o  de  Grafos  Eulerianos):  Um  grafo  conexo  Ã©  Euleriano  se,  e 

somente se, cada um de seus vÃ©rtices possui grau par. 

DemonstraÃ§Ã£o: 

(â‡’) Se um grafo possui uma trilha euleriana, significa que, para percorrer todas as arestas, a 

trilha â€œentrouâ€ e â€œsaiuâ€ pelo menos uma vez de cada vÃ©rtice. Logo, todos os vÃ©rtices tÃªm grau 

par. 

(â‡) Seja ğº um grafo conexo onde os graus de todos os vÃ©rtices sejam pares e seja 

ğ‘‡ = (ğ‘–(cid:2869), ğ‘’(cid:2869), ğ‘–(cid:2870), ğ‘’(cid:2870), â€¦ , ğ‘–(cid:3041)(cid:2879)(cid:2869), ğ‘’(cid:3041)(cid:2879)(cid:2869), ğ‘–(cid:3041)) 

a trilha de maior comprimento em ğº. Como ğ‘‡ nÃ£o pode ser estendido, ele contÃ©m todas as arestas 

incidentes em ğ‘–(cid:2869) e ğ‘–(cid:3041). Por hipÃ³tese, o nÃºmero de arestas Ã© par. Logo, devemos ter forÃ§osamente 

ğ‘–(cid:2869) = ğ‘–(cid:3041) e ğ‘‡ Ã© uma trilha fechada. Suponha que ğ‘‡ nÃ£o seja uma trilha euleriana. EntÃ£o ğº possui 

uma aresta ğ‘’ fora de ğ‘‡ mas incidente em um vÃ©rtice de ğ‘‡, uma vez que ğº Ã© conexo. Sem perda 

de generalidade seja ğ‘’ = {ğ‘¢, ğ‘–(cid:2870)}. EntÃ£o o passeio 

possui comprimento maior do que ğ‘‡. Absurdo. 

ğ‘‡â€² = (ğ‘¢, ğ‘’, ğ‘–(cid:2870), ğ‘’(cid:2870), â€¦ , , ğ‘–(cid:3041)(cid:2879)(cid:2869), ğ‘’(cid:3041)(cid:2879)(cid:2869), ğ‘–(cid:3041), ğ‘’(cid:2869), ğ‘–(cid:2870)) 

Dessa forma fica evidente que o problema das pontes de KÃ¶ningsberg, introduzido na seÃ§Ã£o 2.1, 

nÃ£o possui soluÃ§Ã£o, uma vez que trÃªs de seus vÃ©rtices possuem graus Ã­mpar. 

DefiniÃ§Ã£o 2.19 (Ãrvores): Uma Ã¡rvore Ã© um grafo conexo e sem ciclos. Note que uma Ã¡rvore Ã© 

um grafo simples, uma vez que arestas paralelas e laÃ§os formam ciclos. A figura abaixo mostra 

alguns exemplos de Ã¡rvores. 

Figura 17 â€“ Exemplos de Ã¡rvores. 

Fonte: O autor, 2018 

A estrutura de uma Ã¡rvore estÃ¡ presente em diversas situaÃ§Ãµes do cotidiano. Ela pode ser 

usada  para  representar,  por  exemplo,  o  organograma  de  uma  empresa  ou  um  fluxograma  de 

tomada de decisÃ£o. O teorema a seguir nos darÃ¡ uma maneira de caracterizar uma Ã¡rvore. 

 
 
 
 
 
26 

Teorema 2.4: Um grafo ğº com ğ‘› vÃ©rtices Ã© uma Ã¡rvore se: 

i.  existe exatamente um caminho simples entre cada par de vÃ©rtices ou; 

ii.  Ã© conexo e possui ğ‘› âˆ’ 1 arestas ou; 

iii.  Ã© conexo e a deleÃ§Ã£o de qualquer aresta torna o grafo desconexo. 

 DemonstraÃ§Ã£o: 

i) Se existe exatamente um caminho entre cada par de vÃ©rtices entÃ£o ğº Ã© conexo. Suponha agora 

que ğº nÃ£o seja uma Ã¡rvore. EntÃ£o, ğº possui pelo menos um ciclo. Mas em todo par de vÃ©rtices 

de um ciclo existem pelo menos dois caminhos, absurdo. Logo, ğº Ã© uma Ã¡rvore. 

ii) A prova se dÃ¡ por induÃ§Ã£o. Para ğ‘› = 1 a verificaÃ§Ã£o Ã© imediata. Suponha agora que ğº seja 

uma Ã¡rvore com ğ‘› vÃ©rtices e ğ‘› âˆ’ 1 arestas. Seja ğºâ€² o grafo obtido a partir de ğº ao acrescentar 

mais um vÃ©rtice ğ‘£(cid:3041)(cid:2878)(cid:2869)  de grau 1 a ele. Devemos mostrar que ğºâ€² Ã© uma Ã¡rvore. De fato, o acrÃ©scimo 

de ğ‘£(cid:3041)(cid:2878)(cid:2869) a ğº nÃ£o gera um ciclo pois ğ‘£(cid:3041)(cid:2878)(cid:2869) possui grau 1 e ğºâ€² Ã© conexo pois ğ‘£(cid:3041)(cid:2878)(cid:2869) estÃ¡ conectado a 

ğº que Ã© conexo. Logo, ğºâ€² Ã© uma Ã¡rvore, o que encerra a prova. 

iii) Suponha por absurdo que ğº nÃ£o seja uma Ã¡rvore. Como ğº Ã© conexo e nÃ£o Ã© uma Ã¡rvore hÃ¡ 

um  ciclo  em  ğº.  Mas  se  hÃ¡  um  ciclo  em  ğº,  a  deleÃ§Ã£o  de  uma  aresta  neste  ciclo  nÃ£o  o  torna 

desconexo. Absurdo. Logo, ğº Ã© uma Ã¡rvore. 

No capÃ­tulo seguinte veremos como podemos determinar  a menor distÃ¢ncia entre dois 

vÃ©rtices  de  um  grafo  ponderado  por  meio  de  dois  algoritmos:  O  Algoritmo  de  Dijkstra  e  o 

Algoritmo de Floyd-Warshall 

 
 
 
 
 
 
 
3 O PROBLEMA DE CAMINHO MÃNIMO EM UM GRAFO 

27 

Em  Teoria  dos  Grafos,  o  Problema  de  Caminho  MÃ­nimo  consiste  em  determinar  a 

sequÃªncia de vÃ©rtices que minimiza o custo de travessia entre dois vÃ©rtices de um grafo valorado. 

Esse custo Ã© determinado pela soma dos pesos das arestas que o compÃµe. Se nÃ£o houver nenhum 

caminho que una os vÃ©rtices em questÃ£o o problema nÃ£o possui soluÃ§Ã£o. Se o vÃ©rtice de origem 

coincide com o vÃ©rtice de destino e as arestas tem pesos nÃ£o negativos1, a soluÃ§Ã£o Ã© Ãºnica e tem 

comprimento zero. Utilizaremos distÃ¢ncia para designar o custo de um caminho. 

Conforme Boaventura e Jurkiewicz (2009), podemos subdividir este problema em, pelo 

menos, trÃªs categorias de subproblemas de caminho mÃ­nimo: 

ï‚·  Origem Ãšnica: determinar a menor distÃ¢ncia entre um vÃ©rtice e os demais; 

ï‚·  Origem-Destino: determinar a menor distÃ¢ncia entre dois vÃ©rtices dados; 

ï‚·  Par a Par: determinar a menor distÃ¢ncia entre cada par de vÃ©rtices do grafo.  

Existem  diversos  algoritmos  especializados  em  determinar  o  caminho  mÃ­nimo  em  um 

grafo. Como exemplo temos o Algoritmo de Bellmand-Ford, Algoritmo de Johnson, Algoritmo 

de  Dijkstra  e  Algoritmo  de  Floyd-Warshall.  Neste  capÃ­tulo  abordaremos  o  funcionamento  e 

aplicaÃ§Ãµes  dos  dois  Ãºltimos,  que  tem  enfoque  nos  subproblemas  Origem-Destino  e  Par  a  Par 

respectivamente. 

3.1 O Algoritmo de Dijkstra2 

Edsger Wybe Dijkstra foi um matemÃ¡tico HolandÃªs pioneiro no setor de programaÃ§Ã£o 

computacional. Sua carreira como cientista de computaÃ§Ã£o teve inÃ­cio em 1951. ApÃ³s ter sido 

aprovado no exame de admissÃ£o para cursar fÃ­sica e matemÃ¡tica na University of Leiden, Dijkstra 

participou  de  um  curso  de  programaÃ§Ã£o  em  Cambrige,  Inglaterra.  Em  1952,  o  diretor  do 

Mathematisch  Centrum  de  AmsterdÃ£,  Aad  van  Wijngaarden,  tomou  conhecimento  de  sua 

participaÃ§Ã£o no curso e ofereceu a ele uma vaga de meio perÃ­odo como programador. 

Em 1955, apÃ³s trÃªs anos de trabalho como programador, Dijkstra decidiu abandonar a 

fÃ­sica para se tornar um programador em tempo integral, como ele mesmo relata: 

1 Alguns problemas em grafos, como aqueles que envolvem fluxos, utilizam arestas com pesos negativos 

em sua modelagem. 

2 Esta seÃ§Ã£o foi composta de que informaÃ§Ãµes foram compiladas de diversas fontes de pesquisa entre elas: 

jornais, obituÃ¡rio, entrevista etc. 

 
 
 
 
 
 
                                                           
 
28 

(â€¦) Eu conclui que o desafio intelectual de programar era muito maior que o 
desafio  intelectual de  fÃ­sica  teÃ³rica  e,  como  resultado,  eu  escolhi  programar. 
Programar era tÃ£o implacÃ¡vel. Se alguma coisa desse errado, quero dizer, um 
zero Ã© um zero e um um Ã© um um. Eu nunca usei o software de outra pessoa. Se 
alguma coisa desse errado, eu era o responsÃ¡vel. E foi isso que me desafiou. 
(DIJKSTRA, 2010, p. 42, traduÃ§Ã£o nossa)3 

ApÃ³s  tomar  essa  decisÃ£o  Dijkstra  terminou  seus  estudos  o  mais  rÃ¡pido  possÃ­vel,  se 

graduando em 1956, uma vez que nÃ£o se sentia mais bem-vindo na universidade: 

(â€¦)  os fÃ­sicos  me  consideraram um  desertor e os matemÃ¡ticos  se  mostraram 
desdenhosos com relaÃ§Ã£o a computaÃ§Ã£o. Na cultura matemÃ¡tica daquele tempo 
seu trabalho tinha que lidar com o infinito para ser cientificamente respeitÃ¡vel. 
(DIJKSTRA, 2010, p. 42, traduÃ§Ã£o nossa) 

No  mesmo  ano,  a  construÃ§Ã£o  do  segundo  computador  automÃ¡tico  do  Mathematisch 

Centrum, o ARMAC, estava prestes a ser concluÃ­da. Para celebrar sua inauguraÃ§Ã£o foi preparada 

uma apresentaÃ§Ã£o que deveria ser simples o suficiente para que pessoas leigas em matemÃ¡tica 

pudessem entender. Dijkstra entÃ£o projetou um programa que determina a menor distÃ¢ncia entre 

duas cidades da Holanda, considerando uma malha ferroviÃ¡ria simplificada contendo apenas 64 

cidades. Nesse programa ele utilizou um algoritmo que desenvolveu, segundo ele prÃ³prio, em 

vinte minutos durante um passeio com sua noiva, enquanto estavam sentados descansando apÃ³s 

uma caminhada. A demonstraÃ§Ã£o foi um grande sucesso e esse algoritmo, que hoje Ã© amplamente 

utilizado, leva seu nome. 

Dijkstra trabalhou como programador no Mathematisch Centrum atÃ© 1962, quando foi 

indicado para uma cadeira na Eindhoven University of Technology onde permaneceu atÃ© 1973. 

Na universidade, desenvolveu um sistema operacional para o sistema de computadores interno. 

A  elegÃ¢ncia  e  estrutura  hierÃ¡rquica  do  sistema  foi  reconhecida  e  tÃ³pico  de  interesse  no  1Âº 

SimpÃ³sio de PrincÃ­pios de Sistemas Operacionais. 

Em  1973,  Dijkstra  deixou  a  universidade  para  se  tornar  um  pesquisador  associado 

na Burroughs Corporation, onde obteve total liberdade para efetuar sua pesquisa da maneira que 

desejasse.  

Em 1984 decidiu voltar a lecionar  e aceitou a Schlumberger Centennial Chair da The 

University of Texas at Austin onde permaneceu atÃ© sua aposentadoria em 1999. 

Suas contribuiÃ§Ãµes cobrem diversas Ã¡reas da ciÃªncia da computaÃ§Ã£o, incluindo sistemas 

operacionais, pesquisa em linguagens de programaÃ§Ã£o, programaÃ§Ã£o sequencial e concorrente, 

algoritmos para grafos entre outras. Ele ajudou a modelar a ciÃªncia da computaÃ§Ã£o como ela Ã© 

conhecida  hoje.  Muitas  de  suas  publicaÃ§Ãµes  foram  fonte  de  pesquisa  para  novas  Ã¡reas  de 

3 Embora Dijkstra tenha falecido em 2002, a publicaÃ§Ã£o desta entrevista foi feita somente em 2010. 

 
 
 
                                                           
conhecimento. Diversos conceitos e problemas que hoje sÃ£o padrÃµes em ciÃªncia da computaÃ§Ã£o 

foram primeiramente identificados e/ou levam nomes cunhados por ele. 

Figura 18 â€“ Edsger W. Dijkstra 

29 

Fonte: Dijkstra, 2010 

3.1.1 Funcionamento do Algoritmo de Dijkstra 

Seja ğº = (ğ‘‰, ğ¹) um grafo ponderado com arestas de pesos nÃ£o negativos. O Algoritmo 

de  Dijkstra  oferece  uma  soluÃ§Ã£o  para  determinar  o  menor  caminho  entre  dois  vÃ©rtices  de  ğº. 

Fixado o vÃ©rtice de inÃ­cio ğ‘– e vÃ©rtice final ğ‘“ o algoritmo determina durante sua execuÃ§Ã£o quais 

sÃ£o os vÃ©rtices de G que devem ser inseridos entre ğ‘– e ğ‘“ para que se tenha o menor caminho. 

O funcionamento do algoritmo pode ser dividido em trÃªs etapas. Na primeira etapa ele 

cria as variÃ¡veis que serÃ£o atualizadas ao longo da execuÃ§Ã£o: 

ï‚·  ğ‘‘(ğ‘—): Ã© a menor distÃ¢ncia do vÃ©rtice de origem ğ‘– ao vÃ©rtice ğ‘—,  

ï‚·  ğ‘(ğ‘—): indica qual Ã© o vÃ©rtice que antecede o vÃ©rtice  ğ‘—, na sequÃªncia de vÃ©rtices que vai 

compor o caminho desejado. Quando nÃ£o houver vÃ©rtice antecedente, representaremos 

sua ausÃªncia com o algarismo zero. 

ï‚·  Conjunto dos vÃ©rtices fechados, ğ¹: Ã© o conjunto que contÃ©m os vÃ©rtices para os quais a 

menor distÃ¢ncia jÃ¡ foi determinada;  

ï‚·  Conjunto dos vÃ©rtices abertos,  ğ´: Ã© o conjunto que contÃ©m os vÃ©rtices para os quais a 

menor distÃ¢ncia ainda nÃ£o foi determinada durante a execuÃ§Ã£o do algoritmo. Note que 

ğ´ = ğ‘‰ âˆ’ ğ¹. 

Seja ğ‘ƒ = [ğ‘(cid:3044)(cid:3038)] a matriz dos pesos do grafo atribuÃ­dos. Considere ğ‘€ = [ğ‘š(cid:3044)(cid:3038)] obtida a 

partir da matriz ğ‘ƒ, onde  

ğ‘š(cid:3044)(cid:3038) = (cid:4688)

ğ‘(cid:3044)(cid:3038), se ğ‘ Ã© adjacente a ğ‘˜    
0, se ğ‘ = ğ‘˜                                
âˆ, se ğ‘ nÃ£o Ã© adjacente a ğ‘˜

 
 
 
 
 
 
30 

Utilizamos o sÃ­mbolo âˆ (infinito) para diferenciar uma aresta de peso zero entre ğ‘ e ğ‘˜ da 

nÃ£o existÃªncia de uma aresta entre esses vÃ©rtices. Chamaremos ğ‘€ de Matriz de Manejo. 

Inicialmente, ğ‘‘(ğ‘–) = ğ‘(ğ‘–) = 0, ğ¹ = {ğ‘–}, ğ´ = ğ‘‰ âˆ’ {ğ‘–} e, para todo ğ‘— âˆˆ ğ´, temos 

ğ‘‘(ğ‘—) = (cid:3420)

ğ‘š(cid:3036)(cid:3037), se ğ‘š(cid:3036)(cid:3037) â‰  âˆ
âˆ, se ğ‘š(cid:3036)(cid:3037) = âˆ , ğ‘(ğ‘—) = (cid:3420)

ğ‘–, se ğ‘š(cid:3036)(cid:3037) â‰  âˆ
. 
0, se ğ‘š(cid:3036)(cid:3037) = âˆ

Na segunda etapa o algoritmo utiliza a matriz ğ‘€ e procura iterativamente o vÃ©rtice ğ‘Ÿ âˆˆ ğ´ 

mais prÃ³ximo a ğ‘–. Esse vÃ©rtice, chamado â€œvÃ©rtice da vezâ€, Ã© entÃ£o movido do conjunto ğ´ para o 

conjunto ğ¹. Em seguida, para cada vÃ©rtice ğ‘  âˆˆ ğ´ âˆ© ğ‘…(cid:2878)(ğ‘Ÿ) adjacente ao vÃ©rtice da vez, o algoritmo 

verifica se ğ‘‘(ğ‘ ) Ã© maior que a ğ‘‘(ğ‘Ÿ) + ğ‘š(cid:3045)(cid:3046). Em caso afirmativo, o caminho do vÃ©rtice inicial atÃ© 

o vÃ©rtice ğ‘ , passando por ğ‘Ÿ Ã© menor que o caminho previamente existente. Nesse caso, a entrada 

ğ‘‘(ğ‘ ) do vÃ©rtice ğ‘  Ã© atualizada com o menor valor e a entrada ğ‘(ğ‘ ) Ã© atualizada com ğ‘Ÿ. O algoritmo 

executa essa rotina atÃ© que ğ‘“ o vÃ©rtice da vez.4 

Na  terceira  e  Ãºltima  etapa  o  algoritmo  criarÃ¡  (se  possÃ­vel)  um  vetor  que  contÃ©m  a 

sequÃªncia de vÃ©rtices que descreve o menor caminho de ğ‘– atÃ© ğ‘“. Quando o vÃ©rtice ğ‘“ for o vÃ©rtice 

da vez teremos uma das seguintes situaÃ§Ãµes: 

ï‚·  O  valor  da  entrada  ğ‘(ğ‘“)  Ã©  nulo.  Se  isso  ocorrer  significa  que  nenhuma  das  iteraÃ§Ãµes 

anteriores  encontrou  um  caminho  de  ğ‘–  atÃ©  ğ‘“.  Logo  o  valor  ğ‘‘(ğ‘“)  nÃ£o  foi  alterado  e 

permanece infinito, de onde segue que o vÃ©rtice ğ‘“ nÃ£o Ã© adjacente de nenhum outro vÃ©rtice 

do grafo. 

ï‚·  O valor da entrada ğ‘(ğ‘“) Ã© nÃ£o nulo. Nesse caso, ğ‘“ Ã© adjacente a algum vÃ©rtice para o qual 

Ã© possÃ­vel traÃ§ar um caminho atÃ© ele a partir de ğ‘–. O algoritmo entÃ£o executa uma rotina 

para  varrer  os  vÃ©rtices  anteriores  partindo  de  ğ‘“,  criando  um  vetor  ğ¶  que  determina 

caminho mÃ­nimo. 

Fixado um vÃ©rtice inicial ğ‘–, o algoritmo busca iterativamente o primeiro vÃ©rtice aberto 

mais prÃ³ximo, o segundo mais prÃ³ximo, o terceiro mais prÃ³ximo e assim sucessivamente, atÃ© 

encontrar o vÃ©rtice desejado ğ‘“. Como a busca Ã© feita pelo menor caminho e as arestas tem pesos 

nÃ£o negativos, uma vez que o vÃ©rtice esteja fechado, nÃ£o hÃ¡ um caminho com menor distÃ¢ncia 

atÃ© ele.  

Apresentamos  o  pseudocÃ³digo  e  o  fluxograma  que  descrevem  o  funcionamento  do 

algoritmo no ApÃªndice A e B respectivamente. Para ilustrar o funcionamento do Algoritmo de 

Dijskstra, como explicado acima, vamos determinar o menor caminho entre os vÃ©rtices 1 e 5 no 

grafo ğº apresentado na Figura 19. 

4 Ã‰ possÃ­vel escrever o algoritmo de Dijkstra de maneira que ele obtenha a menor distÃ¢ncia de um vÃ©rtice a 
todos os outros, o que o caracterizaria como Origem Ãšnica. Para os fins deste trabalho, escolhemos uma versÃ£o que 
se encerra ao encontrar a menor distÃ¢ncia atÃ© um vÃ©rtice especÃ­fico. 

 
                                                           
Figura 19 â€“ Grafo ğº. 

31 

Fonte: O autor, 2018 

Baseado no grafo ğº temos as seguistes matrizes de Peso e de Manejo: 

Figura 20: Matriz de Peso e de Manejo do Grafo ğº. 

Fonte: O autor, 2018 

A sequÃªncia de figuras 21 a 26 mostram o desenvolvimento do algoritmo. Inicialmente Ã© 

preciso criar as variÃ¡veis que serÃ£o atualizadas em cada iteraÃ§Ã£o. AtribuÃ­mos zero a ğ‘‘(1) e ğ‘(1). 

Se ğ‘š(cid:2869)(cid:3037) = 0, definimos ğ‘‘(ğ‘—) = âˆ e ğ‘(ğ‘—) = { }. Caso contrÃ¡rio fazemos ğ‘‘(ğ‘—) = ğ‘(cid:2869)(cid:3037) e ğ‘(ğ‘—) = {1}.  

Por Ãºltimo, definimos o Conjunto dos VÃ©rtices Abertos e o Conjunto dos VÃ©rtices Fechados (ver 

Figura 13). 

Figura 21 â€“ InicializaÃ§Ã£o do Algoritmo de Dijkstra 

Fonte: O autor, 2018 

 
 
 
 
32 

A partir do vÃ©rtice de origem 1 devemos procurar o vÃ©rtice mais prÃ³ximo. Nesse caso o 

vÃ©rtice  mais  prÃ³ximo  Ã©  2,  que  entÃ£o  Ã©  fechado.  Para  cada  vÃ©rtice  aberto  adjacente  a  ele 

verificamos se sua distÃ¢ncia atÃ© a origem Ã© maior que a distÃ¢ncia da origem atÃ© ele passando por 

2. Como nÃ£o hÃ¡ nenhum arco unindo 3 e 7 Ã  origem, a estimativa passando por 2 Ã© melhor e as 

variÃ¡veis desses vÃ©rtices devem ser atualizadas (Figura 22). 

Figura 22 â€“ Algoritmo de Dijkstra apÃ³s primeira iteraÃ§Ã£o. 

Fonte: O autor, 2018 

 O prÃ³ximo vÃ©rtice a ser fechado Ã© 3, pois possui a menor distÃ¢ncia ğ‘‘(ğ‘—), ğ‘— âˆˆ ğ´. Como 4 

e  8  nÃ£o  possuem  estimativa  de  menor  distÃ¢ncia,  o  caminho  passando  por  3  Ã©  menor.  Como 

ğ‘‘(7) > ğ‘‘(3) + ğ‘š(cid:2871)(cid:2875), melhoramos a estimativa para o menor caminho de 1 para 7 e fazemos as 

devidas alteraÃ§Ãµes. 

Figura 23 â€“ Algoritmo de Dijkstra apÃ³s terceira iteraÃ§Ã£o. 

Fonte: O autor, 2018 

Prosseguimos  procurando  o  vÃ©rtice  aberto  mais  prÃ³ximo  da  origem.  Nessa  iteraÃ§Ã£o 

fecharemos  o  vÃ©rtice  6.  O  Ãºnico  vÃ©rtice  adjacente  a  6  Ã©  5.  Como  ğ‘‘(5) > ğ‘‘(6) + ğ‘š(cid:2874)(cid:2873), 

atualizamos os valores de ğ‘‘(5) e ğ‘(5). 

 
 
 
 
 
 
Figura 24 â€“ Algoritmo de Dijkstra apÃ³s quarta iteraÃ§Ã£o. 

33 

Fonte: O autor, 2018 

De  acordo  com  a  variÃ¡vel  ğ‘‘(ğ‘—),  o  prÃ³ximo  vÃ©rtice  a  ser  fechado  Ã©  7.  O  Ãºnico  vÃ©rtice 

adjacente  aberto  que  ele  possui  Ã©  5.  Como  ğ‘‘(5) > ğ‘‘(7) + ğ‘š(cid:2875)(cid:2873),  melhoramos  a  estimativa  e 

fazemos as devidas alteraÃ§Ãµes em ğ‘‘(5) e ğ‘(5). 

Figura 25 â€“ Algoritmo de Dijkstra apÃ³s quarta iteraÃ§Ã£o. 

Finalmente,  fechamos o  vÃ©rtice 5. Como ğ‘(5) â‰  { }, existe uma sequÃªncia de vÃ©rtices 

adjacentes que liga 1 a 5 de custo total ğ‘‘(5). AlÃ©m disso essa sequÃªncia possui o menor custo 

Fonte: O autor, 2018 

possÃ­vel. 

Figura 26 â€“ Algoritmo de Dijkstra finalizado. 

Fonte: O autor, 2018 

 
 
 
 
 
 
34 

Nesse ponto o algoritmo varrerÃ¡ os valores de ğ‘(ğ‘—) a partir de ğ‘(5) e construirÃ¡ o vetor ğ¶ que 

contÃ©m os endereÃ§os dos vÃ©rtices que compÃµem esse caminho: 

ğ‘(5) = 7;       ğ‘(7) = 3;      ğ‘(3) = 2;     ğ‘(2) = 1. 

ğ¶ = (1,2,3,7,5) 

Portanto, o menor caminho que une o vÃ©rtice 1 ao 5 mede 12 unidades e ele segue a ordem 

1 â†’ 2 â†’ 3 â†’ 7 â†’ 5. 

Figura 27 â€“ Caminho de menor distÃ¢ncia do vÃ©rtice 1 atÃ© o vÃ©rtice 5. 

Fonte: O autor, 2018 

3.2 O Algoritmo de Floyd-Warshall (ou Roy-Warshall)5 

Ao contrÃ¡rio do algoritmo de Dijkstra, o algoritmo de Floyd-Warshall, ou ainda Roy -

Warshall, foi desenvolvido independentemente por trÃªs pessoas. O primeiro a se deparar com ele 

foi  o  professor  francÃªs  Bernard  Roy  (1934-2017),  em  1959  quando  era  entÃ£o  consultor  da 

SociÃ©tÃ© de MathÃ©matiques AppliquÃ©es (SMA). No campo de Grafos, sua principal contribuiÃ§Ã£o 

se  deu  teoria  de  fluxos  em  redes  e  agendamento  de  projetos,  com  a  invenÃ§Ã£o  do  mÃ©todo  de 

Atividade  no  VÃ©rtice.  Uma  outra  grande  contribuiÃ§Ã£o  foi  a  invenÃ§Ã£o  da  famÃ­lia  de  mÃ©todos 

ELECTRE (ELimination Et Choix Traduisant la RealitÃ©) utilizados amplamente no campo de 

anÃ¡lise decisÃµes envolvendo mÃºltiplos critÃ©rios.  

A segunda pessoa a elaborar o algoritmo foi Robert W. Floyd (1936-2001), no ano de 

1962. Ele foi um cientista computacional americano e vencedor do prÃªmio Turing, maior honraria 

em  ciÃªncia  da  computaÃ§Ã£o,  em  1978.  Floyd  foi  uma  crianÃ§a  prodÃ­gio  tendo  terminado  sua 

5 As informaÃ§Ãµes desta seÃ§Ã£o foram compiladas de sites de universidades, artigos online, biografias nÃ£o 

oficiais e obituÃ¡rios. 

 
 
 
 
 
 
                                                           
primeira graduaÃ§Ã£o, em artes liberais, aos dezessete anos. Thomas Haigh descreve como foi sua 

transiÃ§Ã£o para a ciÃªncia da computaÃ§Ã£o: 

35 

Como  toda  crianÃ§a  em  programas  avanÃ§ados  ele  logo  perdeu  o  gosto  pela 
escola. Enquanto isso, conseguiu um emprego na Armour Research Foundation 
of Illinois Institute of Technology, primeiro como um operador de computador 
autodidata e depois como um programador sÃªnior e analista. Ele recebeu seu 
bacharelado em fÃ­sica da University of Chicago em 1958 e publicou um artigo 
sobre interferÃªncia de rÃ¡dio no mesmo ano. NÃ£o demorou muito para que seu 
amor  pela computaÃ§Ã£o  ficasse claro. De fato, ele comeÃ§ou  a  publicar  artigos 
para revistas de computaÃ§Ã£o em 1959. (HAIGH, 2004, p. 75, traduÃ§Ã£o nossa) 

Suas  maiores  contribuiÃ§Ãµes  aconteceram  no  campo  de  anÃ¡lise  sintÃ¡tica  (theory  of  parsing), 

semÃ¢ntica  de  linguagens  de  programaÃ§Ã£o,  verificaÃ§Ã£o  automÃ¡tica  de  programas,  sÃ­ntese  de 

programa automÃ¡tica e anÃ¡lise de algoritmos. 

No mesmo ano de 1962, Stephen Warshall (1935-2006) publicou um artigo descrevendo 

o  algoritmo  enquanto  trabalhava  na  Massachusetts  Computer  Associates.  Ele  recebeu  seu 

bacharelado em matemÃ¡tica pela Harvard University em 1956, aos 21 anos. Ele nÃ£o fez questÃ£o 

de continuar os estudos para obter o grau de mestre pois os cursos oferecidos pela universidade 

nÃ£o o interessavam. 

Figura 24 â€“ Bernard Roy, Robert Floyd e Stephen Warshall 

Fonte: <http://www.lamsade.dauphine.fr/~roy/>; <https://cs.stanford.edu/memoriam/professor-

robert-w-floyd>; <https://en.wikipedia.org/wiki/Stephen_Warshall>   

3.2.1 Funcionamento do Algoritmo de Floyd-Warshal 

O algoritmo de Floyd-Warshal Ã© um algoritmo que determina o caminho de menor custo 

entre  todos  os  vÃ©rtices  de  um  grafo  ponderado  com  arestas  de  peso  positivo  ou  negativo.  O 

algoritmo  original  nÃ£o  determina  quais  vÃ©rtices  devem  ser  percorridos.  Contudo  Ã©  possÃ­vel 

 
 
 
 
 
36 

contornar  esse  problema  fazendo  algumas  alteraÃ§Ãµes  simples  no  cÃ³digo.  Nesse  trabalho 

utilizaremos a versÃ£o modificada do algoritmo. Vale ainda ressaltar que estamos supondo um 

grafo simples sem ciclos negativos. Adiante explicaremos o porquÃª dessa escolha. 

Considere  um  grafo  ğº = (ğ‘‰, ğ¸),  com  ğ‘›  vÃ©rtices  rotulados  utilizando-se  os  nÃºmeros 

naturais 1,2, â€¦ , ğ‘›. Com base na matriz de manejo ğ‘€(cid:2868) = [ğ‘š(cid:3036)(cid:3037)

(cid:2868) ], o algoritmo cria uma matriz ğ‘…(cid:2868) =

(cid:2868)] tal que 

[ğ‘Ÿ(cid:3036)(cid:3037)

(cid:2868) = (cid:4682)
ğ‘Ÿ(cid:3036)(cid:3037)

ğ‘—, se ğ‘š(cid:3036)(cid:3037)
0, se ğ‘š(cid:3036)(cid:3037)

(cid:2868) â‰  âˆ
(cid:2868) = âˆ.

Os Ã­ndices superiores das matrizes, bem como de seus elementos, se referem a iteraÃ§Ã£o na qual a 

matriz foi obtida. Inicialmente esses Ã­ndices sÃ£o zero, significando valores iniciais. Conforme as 

iteraÃ§Ãµes do algoritmo acontecem, esses Ã­ndices sÃ£o atualizados. 

A matriz ğ‘… recebe o nome de matriz de roteamento do grafo e ela servirÃ¡ para construir 

o vetor ğ¶ que contÃ©m em suas entradas os rÃ³tulos dos vetores que comprÃ£o o menor caminho. 

Para  cada  par  de  vÃ©rtices  (ğ‘–, ğ‘—)  ela  nos  informa  qual  Ã©  o  vÃ©rtice  seguinte  ğ‘Ÿ(cid:3036)(cid:3037)  na  sequÃªncia  de 

vÃ©rtices que irÃ¡ compor o menor caminho possÃ­vel de ğ‘– atÃ© ğ‘—. Se  ğ‘š(cid:3036)(cid:3037)

(cid:2868) = âˆ, ou seja, nÃ£o existe 

arco  (ğ‘–, ğ‘—),  assinalamos  ğ‘Ÿ(cid:3036)(cid:3037)

(cid:2868) = 0,  o  que  nos  diz  que  nÃ£o  existe  um  vÃ©rtice  seguinte  a  ğ‘–  na 

composiÃ§Ã£o do caminho. Se ğ‘š(cid:3036)(cid:3037)

(cid:2868) â‰  âˆ entÃ£o hÃ¡ duas possibilidades: 

ï‚· 

ï‚· 

 ğ‘š(cid:3036)(cid:3037)

(cid:2868) â‰  0. Dessa forma existe o arco (ğ‘–, ğ‘—).  

 ğ‘š(cid:3036)(cid:3037)

(cid:2868) = 0. EntÃ£o, nÃ£o existe o arco (ğ‘–, ğ‘—), ou seja, ğ‘š(cid:3036)(cid:3037)

(cid:2868)  Ã© um elemento da diagonal principal. 

Em ambos os casos, o vÃ©rtice seguinte na construÃ§Ã£o do caminho Ã© o prÃ³prio vÃ©rtice de destino 

ğ‘—.  

Por exemplo, seja ğº um grafo de 5 vÃ©rtices. Se no inÃ­cio da execuÃ§Ã£o do algoritmo temos 

(cid:2868) = 18, significa que existe a o arco (2,5) e ele possui peso 18. AlÃ©m disso o prÃ³ximo vÃ©rtice 

ğ‘š(cid:2870)(cid:2873)

no menor caminho 2 â†’ 5 (por enquanto) Ã© o prÃ³prio 5. Assim, ğ‘Ÿ(cid:2870)(cid:2873)

(cid:2868) = 5. Suponha ainda, nesse 

mesmo grafo, que ğ‘š(cid:2871)(cid:2872)

(cid:2868) = âˆ. EntÃ£o, nÃ£o existe o arco (3,4). Logo, devemos ter ğ‘Ÿ(cid:2871)(cid:2872)
A cada iteraÃ§Ã£o, o algoritmo fixa o vÃ©rtice de menor rÃ³tulo ğ‘˜ dessa lista, chamado vÃ©rtice 

(cid:2868) = 0. 

intermediÃ¡rio. EntÃ£o ele cria as matrizes ğ‘€(cid:3038) e ğ‘…(cid:3038) que serÃ£o atualizadas durante a execuÃ§Ã£o. 

Cada elemento ğ‘š(cid:3036)(cid:3037)

(cid:3038)  de ğ‘€(cid:3038) e ğ‘Ÿ(cid:3036)(cid:3037)

(cid:3038) de  ğ‘…(cid:3038) sÃ£o tais que 

ğ‘š(cid:3036)(cid:3037)

(cid:3038) = ğ‘š(cid:3036)(cid:3037)

(cid:3038)(cid:2879)(cid:2869) e ğ‘Ÿ(cid:3036)(cid:3037)

(cid:3038) = ğ‘Ÿ(cid:3036)(cid:3037)

(cid:3038)(cid:2879)(cid:2869). 

Em seguida, para cada par (ğ‘–, ğ‘—), com ğ‘– e ğ‘— distintos de ğ‘˜, o algoritmo verifica se a distÃ¢ncia 

entre esses vÃ©rtices, passando pelo intermediÃ¡rio ğ‘˜, Ã© menor que distÃ¢ncia sem passar por ele. 

Em outras palavras, o algoritmo verifica se  

ğ‘š(cid:3036)(cid:3038)

(cid:3038)(cid:2879)(cid:2869) + ğ‘š(cid:3038)(cid:3037)

(cid:3038)(cid:2879)(cid:2869) < ğ‘š(cid:3036)(cid:3037)

(cid:3038)(cid:2879)(cid:2869). 

 
 
Em caso afirmativo, ğ‘š(cid:3036)(cid:3037)

(cid:3038)  Ã© substituÃ­da pelo valor da soma.  

37 

Por Ãºltimo, a matriz de roteamento Ã© atualizada.  Sempre que ğ‘š(cid:3036)(cid:3037)

(cid:3038)  for substituÃ­da, ğ‘Ÿ(cid:3036)(cid:3037)

(cid:3038) Ã© 

substituÃ­da  por  ğ‘Ÿ(cid:3036)(cid:3038)

(cid:3038)(cid:2879)(cid:2869).  Essa  escolha  estÃ¡  de  acordo  com  a  definiÃ§Ã£o  da  matriz  ğ‘…,  pois  se  ao 

tomarmos ğ‘˜ como intermediÃ¡rio, a distÃ¢ncia ğ‘– â†’ ğ‘— Ã© melhorada, entÃ£o ğ‘Ÿ(cid:3036)(cid:3037)

(cid:3038) deve ser atualizada com 

o vÃ©rtice seguinte a ğ‘–, no caminho de ğ‘– atÃ© ğ‘˜, ou seja ğ‘Ÿ(cid:3036)(cid:3038)

(cid:3038)(cid:2879)(cid:2869). 

Retomando o exemplo acima, considere que o algoritmo esteja na segunda iteraÃ§Ã£o e que  
(cid:2869) . 
(cid:2869) < ğ‘š(cid:2871)(cid:2873)
ğ‘š(cid:2871)(cid:2870)
(cid:2869)  na matriz ğ‘€(cid:2870) e ğ‘Ÿ(cid:2871)(cid:2873)

(cid:2870)  Ã© substituÃ­da por ğ‘š(cid:2871)(cid:2870)

(cid:2870)  Ã© substituÃ­da por ğ‘Ÿ(cid:2871)(cid:2870)

(cid:2869) , uma vez que o 

(cid:2869) + ğ‘š(cid:2870)(cid:2873)

(cid:2869) + ğ‘š(cid:2870)(cid:2873)

EntÃ£o, ğ‘š(cid:2871)(cid:2873)

caminho Ã© mais curto tomando o vÃ©rtice 2 como intermediÃ¡rio no caminho de 3 atÃ© 5. 

O processo para quando ğ‘˜ varrer todos os vÃ©rtices do grafo e o algoritmo tem como saÃ­da 

as matrizes ğ‘€(cid:3041) e ğ‘…(cid:3041). Ã‰ possÃ­vel ainda criar uma rotina que obtÃ©m o caminho entre dois vÃ©rtices 

apÃ³s a execuÃ§Ã£o do algoritmo. O fluxograma e pseudocÃ³digo do  algoritmo se encontram nos 

apÃªndices C e D respectivamente. 

Utilizaremos  o  grafo  ğº  da  Figura  25  para  um  exemplo  de  execuÃ§Ã£o  do  algoritmo.  As 

matrizes ğ‘€(cid:2868) e ğ‘…(cid:2868) sÃ£o mostradas ao lado do grafo. 

Figura 25 â€“ Grafo ğº e suas matrizes de Pesos e de Roteamento 

Para  esse  grafo  o  algoritmo  farÃ¡  cinco  iteraÃ§Ãµes  tomando  o  vÃ©rtice  1  como  primeiro 

Fonte: O autor, 2018 

intermediÃ¡rio. 

1Âª IteraÃ§Ã£o (ğ’Œ = ğŸ): Para cada par de vÃ©rtices (ğ‘–, ğ‘—), com ğ‘–, ğ‘— â‰  1, o algoritmo verificarÃ¡ se a 

distÃ¢ncia entre esses vÃ©rtices, tendo 1 como intermediÃ¡rio, Ã© menor que a distÃ¢ncia entre eles, ou 

seja, se ğ‘š(cid:3036)(cid:2869)

âˆ  ou  ğ‘š(cid:2869)(cid:3037)

(cid:2868) < ğ‘š(cid:3036)(cid:3037)

(cid:2868) + ğ‘š(cid:2869)(cid:3037)
(cid:2868) = âˆ  a  estimativa  do  caminho  nÃ£o  serÃ¡  melhorada  pois  a  soma  ğ‘š(cid:3036)(cid:2869)

(cid:2868) . Em caso afirmativo, ğ‘š(cid:3036)(cid:3037)

(cid:2868) . Sempre que ğ‘š(cid:3036)(cid:2869)
(cid:2868) + ğ‘š(cid:2869)(cid:3037)

(cid:2869) â† ğ‘š(cid:3036)(cid:2869)

(cid:2868) + ğ‘š(cid:2869)(cid:3037)

(cid:2869) â† ğ‘Ÿ(cid:3036)(cid:2869)

(cid:2868) e ğ‘Ÿ(cid:3036)(cid:3037)

(cid:2868)   nunca 

(cid:2868) =

poderÃ¡ ser inferior a âˆ. Assim temos: 

 
 
 
 
38 

(cid:2868) = âˆ; 
(cid:2869) â† 10 e ğ‘Ÿ(cid:2871)(cid:2870)
(cid:2868) = ğ‘š(cid:2869)(cid:2872)
(cid:2868) = âˆ; 

(cid:2869) â† 1; 
(cid:2868) = ğ‘š(cid:2869)(cid:2873)

ğ‘– = 2 ğ‘’ ğ‘— = 2,3,4,5: NÃ£o hÃ¡ alteraÃ§Ãµes na segunda linha pois ğ‘š(cid:2870)(cid:2869)

ğ‘– = 3 ğ‘’ ğ‘— = 2: ğ‘š(cid:2871)(cid:2869)

(cid:2868) + ğ‘š(cid:2869)(cid:2870)

(cid:2868) = 7 + 3 < âˆ = ğ‘š(cid:2871)(cid:2870)

(cid:2868) , entÃ£o ğ‘š(cid:2871)(cid:2870)

ğ‘– = 3 ğ‘’ ğ‘— = 3,4,5: NÃ£o hÃ¡ alteraÃ§Ãµes na terceira linha pois ğ‘š(cid:2869)(cid:2871)

(cid:2868) = âˆ; 

ğ‘– = 4 ğ‘’ ğ‘— = 2,3,4,5: NÃ£o hÃ¡ alteraÃ§Ãµes na quarta linha pois ğ‘š(cid:2872)(cid:2869)

ğ‘– = 5 ğ‘’ ğ‘— = 2,3,4,5: NÃ£o hÃ¡ alteraÃ§Ãµes na quinta linha pois ğ‘š(cid:2873)(cid:2869)

(cid:2868) = âˆ; 

ApÃ³s a 1Âª iteraÃ§Ã£o temos as matrizes de manejo e de roteamento mostradas na Figura 26. 

Figura 26 â€“ Matrizes de Pesos e de Roteamento apÃ³s a 1Âª iteraÃ§Ã£o 

Fonte: O autor, 2018 

2Âª IteraÃ§Ã£o (ğ’Œ = ğŸ):  

ğ‘– = 1 ğ‘’ ğ‘— = 1: Inicialmente supomos que trabalharÃ­amos em grafos simples sem ciclos negativos. 

Fizemos essa suposiÃ§Ã£o pois o algoritmo nÃ£o consegue lidar com tais ciclos, pois de outra forma 

ele sempre conseguiria encontrar um caminho menor de um vÃ©rtice a ele mesmo e entraria em 

loop.  Portanto,  ğ‘š(cid:3036)(cid:3036)

(cid:3038)  nunca sofrerÃ¡ ajuste. Assim, ğ‘š(cid:2869)(cid:2869)

(cid:2870)  nÃ£o serÃ¡ atualizado. De agora em diante 

(cid:3038) . 
nÃ£o analisaremos mais o caso ğ‘š(cid:3036)(cid:3036)

ğ‘– = 1 ğ‘’ ğ‘— = 3: ğ‘š(cid:2869)(cid:2870)

(cid:2869) = 3 + 5 < âˆ = ğ‘š(cid:2869)(cid:2871)
(cid:2869) = âˆ; 
(cid:2869) = 3 + 3 < âˆ = ğ‘š(cid:2869)(cid:2873)

(cid:2869) + ğ‘š(cid:2870)(cid:2871)
ğ‘– = 1 ğ‘’ ğ‘— = 4: NÃ£o hÃ¡ alteraÃ§Ãµes pois ğ‘š(cid:2870)(cid:2872)
(cid:2869) + ğ‘š(cid:2870)(cid:2873)
ğ‘– = 3 ğ‘’ ğ‘— = 1,4: NÃ£o hÃ¡ alteraÃ§Ãµes pois ğ‘š(cid:2870)(cid:2869)
(cid:2869) + ğ‘š(cid:2870)(cid:2873)

(cid:2869) = ğ‘š(cid:2870)(cid:2872)
(cid:2869) = 10 + 3 > âˆ’4 = ğ‘š(cid:2871)(cid:2873)

ğ‘– = 1 ğ‘’ ğ‘— = 5: ğ‘š(cid:2869)(cid:2870)

ğ‘– = 3 ğ‘’ ğ‘— = 5: ğ‘š(cid:2871)(cid:2870)

(cid:2869) , entÃ£o ğ‘š(cid:2869)(cid:2871)

(cid:2870) â† 8 e ğ‘Ÿ(cid:2869)(cid:2871)

(cid:2870) â† 2; 

(cid:2870) â† 6 e ğ‘Ÿ(cid:2869)(cid:2871)

(cid:2870) â† 2; 

(cid:2869) , entÃ£o ğ‘š(cid:2869)(cid:2873)
(cid:2869) = âˆ; 

(cid:2869) , portanto nÃ£o hÃ¡ alteraÃ§Ã£o na distÃ¢ncia (3,5); 

ğ‘– = 4 ğ‘’ ğ‘— = 1,3,5: NÃ£o hÃ¡ alteraÃ§Ãµes na quarta linha pois ğ‘š(cid:2872)(cid:2870)

(cid:2869) = âˆ; 

ğ‘– = 5 ğ‘’ ğ‘— = 1,3,4: NÃ£o hÃ¡ alteraÃ§Ãµes na quinta linha pois ğ‘š(cid:2873)(cid:2870)

(cid:2869) = âˆ. 

 
 
 
 
 
 
 
 
 
Figura 27 â€“ Matrizes de Pesos e de Roteamento apÃ³s a 2Âª iteraÃ§Ã£o 

39 

Fonte: O autor, 2018 

3Âª IteraÃ§Ã£o (ğ’Œ = ğŸ‘):  

ğ‘– = 1 ğ‘’ ğ‘— = 2: ğ‘š(cid:2869)(cid:2871)

ğ‘– = 1 ğ‘’ ğ‘— = 4: ğ‘š(cid:2869)(cid:2871)

ğ‘– = 1 ğ‘’ ğ‘— = 5: ğ‘š(cid:2869)(cid:2871)

ğ‘– = 2 ğ‘’ ğ‘— = 1: ğ‘š(cid:2870)(cid:2871)

ğ‘– = 2 ğ‘’ ğ‘— = 4: ğ‘š(cid:2870)(cid:2871)

(cid:2871) . 
(cid:2870) , sem alteraÃ§Ã£o em ğ‘š(cid:2869)(cid:2871)
(cid:2870) , entÃ£o ğ‘š(cid:2869)(cid:2872)

(cid:2870) + ğ‘š(cid:2871)(cid:2870)
(cid:2870) + ğ‘š(cid:2871)(cid:2872)
(cid:2870) + ğ‘š(cid:2871)(cid:2873)
(cid:2870) + ğ‘š(cid:2871)(cid:2869)
(cid:2870) + ğ‘š(cid:2871)(cid:2872)
(cid:2870) + ğ‘š(cid:2871)(cid:2873)

(cid:2870) > ğ‘š(cid:2869)(cid:2871)
(cid:2870) = 8 + 4 < âˆ = ğ‘š(cid:2869)(cid:2872)
(cid:2870) = 8 + (âˆ’4) < 6 = ğ‘š(cid:2869)(cid:2873)
(cid:2870) = 5 + 7 < âˆ = ğ‘š(cid:2870)(cid:2869)
(cid:2870) = 5 + 4 < âˆ = ğ‘š(cid:2870)(cid:2872)
(cid:2870) = 5 + (âˆ’4) < 3 = ğ‘š(cid:2870)(cid:2873)

(cid:2870) , entÃ£o ğ‘š(cid:2870)(cid:2869)
(cid:2870) , entÃ£o ğ‘š(cid:2870)(cid:2872)

(cid:2870) , entÃ£o ğ‘š(cid:2869)(cid:2873)

ğ‘– = 2 ğ‘’ ğ‘— = 5: ğ‘š(cid:2870)(cid:2871)

(cid:2870) , entÃ£o ğ‘š(cid:2870)(cid:2873)
ğ‘– = 4 ğ‘’ ğ‘— = 1,2,5: NÃ£o hÃ¡ alteraÃ§Ãµes na quarta linha pois ğ‘š(cid:2872)(cid:2871)

(cid:2871) â† 1 e ğ‘Ÿ(cid:2870)(cid:2873)
(cid:2870) = âˆ; 

(cid:2871) â† 12 e ğ‘Ÿ(cid:2869)(cid:2872)

(cid:2871) â† ğ‘Ÿ(cid:2869)(cid:2871)

(cid:2870) = 2; 

(cid:2870) = 2; 

(cid:2871) â† 4 e ğ‘Ÿ(cid:2869)(cid:2873)
(cid:2871) â† 12 e ğ‘Ÿ(cid:2870)(cid:2869)
(cid:2871) â† 9 e ğ‘Ÿ(cid:2870)(cid:2872)

(cid:2871) â† ğ‘Ÿ(cid:2869)(cid:2871)
(cid:2871) â† ğ‘Ÿ(cid:2870)(cid:2871)
(cid:2871) â† ğ‘Ÿ(cid:2870)(cid:2871)

(cid:2870) = 3; 

(cid:2870) = 3; 

(cid:2871) â† ğ‘Ÿ(cid:2870)(cid:2871)

(cid:2870) = 3; 

ğ‘– = 5 ğ‘’ ğ‘— = 1,2,4: NÃ£o hÃ¡ alteraÃ§Ãµes na quarta linha pois ğ‘š(cid:2873)(cid:2871)

(cid:2870) = âˆ; 

ApÃ³s a 3Âª IteraÃ§Ã£o temos: 

Figura 28 â€“ Matrizes de Pesos e de Roteamento apÃ³s a 3Âª iteraÃ§Ã£o 

Fonte: O autor, 2018 

4Âª IteraÃ§Ã£o (ğ’Œ = ğŸ’):  

Como ğ‘š(cid:2872)(cid:3037)

(cid:2871) = âˆ para todo ğ‘— â‰  4, nÃ£o haverÃ¡ melhora nas estimativas tomando o vÃ©rtice 4 como 

intermediÃ¡rio. Isso fica evidente ao observarmos na representaÃ§Ã£o grÃ¡fica que o vÃ©rtice 4 nÃ£o Ã© 

adjacente a nenhum outro. Assim, 

 
 
 
 
 
 
 
Figura 29 â€“ Matrizes de Pesos e de Roteamento apÃ³s a 4Âª iteraÃ§Ã£o 

40 

 5Âª IteraÃ§Ã£o (ğ’Œ = ğŸ“):  

Fonte: O autor, 2018 

(cid:2872) = ğ‘š(cid:2873)(cid:2870)

(cid:2872) = ğ‘š(cid:2873)(cid:2871)
(cid:2872) , entÃ£o ğ‘š(cid:2869)(cid:2872)
(cid:2872) = ğ‘š(cid:2873)(cid:2871)

ğ‘– = 1 ğ‘’ ğ‘— = 4: ğ‘š(cid:2869)(cid:2873)

ğ‘– = 2 ğ‘’ ğ‘— = 4: ğ‘š(cid:2870)(cid:2873)

(cid:2872) = 4 + 3 < 12 = ğ‘š(cid:2869)(cid:2872)

ğ‘– = 1 ğ‘’ ğ‘— = 1,2,3: NÃ£o hÃ¡ alteraÃ§Ãµes pois ğ‘š(cid:2873)(cid:2869)
(cid:2872) + ğ‘š(cid:2873)(cid:2872)
ğ‘– = 2 ğ‘’ ğ‘— = 1,2,3: NÃ£o hÃ¡ alteraÃ§Ãµes pois ğ‘š(cid:2873)(cid:2869)
(cid:2872) = 1 + 3 < 9 = ğ‘š(cid:2870)(cid:2872)
(cid:2872) + ğ‘š(cid:2873)(cid:2872)
ğ‘– = 3 ğ‘’ ğ‘— = 1,2,3: NÃ£o hÃ¡ alteraÃ§Ãµes pois ğ‘š(cid:2873)(cid:2869)
(cid:2872) + ğ‘š(cid:2873)(cid:2872)
ğ‘– = 4 ğ‘’ ğ‘— = 1,2,3: NÃ£o hÃ¡ alteraÃ§Ãµes pois ğ‘š(cid:2873)(cid:2869)
Finalmente, apÃ³s as cinco iteraÃ§Ãµes temos as matrizes: 

(cid:2872) = (âˆ’4) + 3 < 4 = ğ‘š(cid:2871)(cid:2872)

ğ‘– = 3 ğ‘’ ğ‘— = 4: ğ‘š(cid:2871)(cid:2873)

(cid:2872) = ğ‘š(cid:2873)(cid:2870)
(cid:2872) , entÃ£o ğ‘š(cid:2870)(cid:2872)
(cid:2872) = ğ‘š(cid:2873)(cid:2870)

(cid:2872) = ğ‘š(cid:2873)(cid:2871)
(cid:2872) , entÃ£o ğ‘š(cid:2871)(cid:2872)
(cid:2872) = ğ‘š(cid:2873)(cid:2871)

(cid:2872) = ğ‘š(cid:2873)(cid:2870)

(cid:2872) = âˆ; 
(cid:2873) â† 7 e ğ‘Ÿ(cid:2869)(cid:2872)
(cid:2872) = âˆ; 
(cid:2873) â† 4 e ğ‘Ÿ(cid:2870)(cid:2872)
(cid:2872) = âˆ; 

(cid:2872) = âˆ; 

(cid:2873) â† ğ‘Ÿ(cid:2869)(cid:2873)

(cid:2872) = 2; 

(cid:2873) â† ğ‘Ÿ(cid:2870)(cid:2873)

(cid:2872) = 3; 

(cid:2873) â† âˆ’1 e ğ‘Ÿ(cid:2871)(cid:2872)

(cid:2873) â† ğ‘Ÿ(cid:2871)(cid:2873)

(cid:2872) = 5; 

Figura 30 â€“ Matrizes de Pesos e de Roteamento apÃ³s a 5Âª iteraÃ§Ã£o 

Fonte: O autor, 2018 

Na matriz ğ‘€(cid:2873) temos o valor do custo mÃ­nimo para ir do vÃ©rtice ğ‘– ao vÃ©rtice ğ‘—. Se algum 

(cid:2873) = âˆ  entÃ£o  o  vÃ©rtice  ğ‘—  nÃ£o  Ã© atingÃ­vel  a  partir  de  ğ‘–.  A matriz  de roteamento  fornecerÃ¡  os 

ğ‘š(cid:3036)(cid:3037)

vÃ©rtices que irÃ£o compor o caminho ğ‘– â†’ ğ‘—.  

Vamos determinar a sequÃªncia de vÃ©rtices que irÃ£o compor o caminho 1 â†’ 5. Observando 

a  matriz  de  manejo  temos  ğ‘š(cid:2869)(cid:2873)
unidades.   Consultando agora a matriz ğ‘…(cid:2873) temos ğ‘Ÿ(cid:2869)(cid:2873)
primeiro devemos passar por 2. Buscamos agora qual Ã© o vÃ©rtice seguinte a 2 no caminho 2 â†’ 5 

(cid:2873) = 4,  entÃ£o  existe  o  trajeto  1 â†’ 5  e  seu  custo  mÃ­nimo  Ã©  de  4 

(cid:2873) = 2. Isso quer dizer que para chegar a 5, 

5: ğ‘Ÿ(cid:2870)(cid:2873)

(cid:2873) = 3. Ou seja, para atingir 5 a partir de 2, devemos passar por 3. Devemos agora buscar 

 
 
 
 
qual Ã© o prÃ³ximo vÃ©rtice no caminho 3 â†’ 5. Consultando novamente a matriz encontramos ğ‘Ÿ(cid:2871)(cid:2873)
5, que Ã© o nosso vÃ©rtice final. EntÃ£o a sequÃªncia de vÃ©rtices procurada Ã© 1 â†’ 2 â†’ 3 â†’ 5. 

(cid:2873) =

Figura 31 â€“ Menor caminho que une o vÃ©rtice 1 ao vÃ©rtice 5. 

41 

Fonte: O autor, 2018 

3.2.2 AplicaÃ§Ãµes do Algoritmo de Floyd-Warshal 

Os algoritmos de caminho mÃ­nimo podem nos ajudar na tomada de decisÃ£o em 

diversas situaÃ§Ãµes. Considere a seguinte:  

O dono de uma marca de chocolates que deseja expandir seus negÃ³cios comprou dez imÃ³veis 

numa dada regiÃ£o. Em um desses imÃ³veis ele estabelecerÃ¡ a fÃ¡brica que irÃ¡ produzir e distribuir 

os  chocolates.  Nos  demais  imÃ³veis  serÃ£o  construÃ­das  as  lojas  que  efetuarÃ£o  as  vendas  para o 

pÃºblico. No grafo abaixo os vÃ©rtices representam os terrenos e os pesos das arestas a distÃ¢ncia 

entre eles em quilÃ´metros. 

Figura 32 â€“ Grafo que representa os imÃ³veis comprados. 

 Em qual dos imÃ³veis a fÃ¡brica deverÃ¡ ser instalada? Por que? 

Fonte: O autor, 2018 

Para responder Ã  pergunta acima devemos estabelecer algum tipo critÃ©rio. A escolha do 

imÃ³vel deve se dar de maneira que o custo de distribuiÃ§Ã£o seja mÃ­nimo, dessa forma o lucro serÃ¡ 

 
 
 
 
 
 
 
mÃ¡ximo. Esse Ã© um dos critÃ©rios mais recorrentes e Ã© comumente chamado de critÃ©rio de lucro 

(BOAVENTURA; JURKIEWICZ, 2009).  Em  geral, os custos  com distribuiÃ§Ã£o sÃ£o menores 

quando a distÃ¢ncia entre os pontos de entrega tambÃ©m o sÃ£o. Devemos entÃ£o determinar o vÃ©rtice 

cuja  soma  das  menores  distÃ¢ncias  atÃ©  os  outros  vÃ©rtices  Ã©  mÃ­nima.  Para  isso,  basta  aplicar  o 

algoritmo de Floyd-Warshall e calcular a soma dos elementos de cada linha da matriz de saÃ­da6.  

42 

4 

6 

8 
7 
2 
6 

Figura 33 â€“ Matrizes das menores distÃ¢ncias e da distÃ¢ncia acumulada. 
  D. A. 
184 
147 
131 
156 
212 
175 
152 
159 
133 
161 

9 
10 
3 
7 
5 
2 
1 
22  19 
13  26  36  29  23 
9 
0 
1 
13  24 
17  27  28  23 
4 
0 
9 
2 
20 
9 
13  23  24  19 
13 
0 
4 
3 
10  11  17  19  22  21 
26  17  13 
0 
4 
21  25  29  15  26 
0 
36  27  23  10 
5 
30  16  10 
0 
29  28  24  11  21 
6 
6 
25  10 
23  23  19  17  25 
4 
6 
0 
7 
15  26 
0 
6 
2 
7 
19  29  30  25 
8 
11 
0 
22  15  16  10  15 
9 
22  13 
9 
0 
26  11 
10  19  24  20  21  26  10 

4 

Fonte: O autor, 2018 

Ao  lado  da  matriz  de  distÃ¢ncias  encontra-se  a  coluna  distÃ¢ncia  acumulada  (D.A.). 

Podemos observar que o vÃ©rtice 3 possui a menor distÃ¢ncia acumulada dos outros vÃ©rtices. Isso 

quer dizer que um veÃ­culo que faÃ§a o transporte da fÃ¡brica para as lojas percorrerÃ¡ uma distÃ¢ncia 

menor,  gerando  um  custo  de  transporte  menor  e,  por  consequÃªncia  um  maior  lucro  para  a 

empresa. Em teoria dos grafos  o vÃ©rtice que tem essa propriedade Ã© chamado de mediana do 

grafo. Esse tipo de problema Ã© conhecido como problema de mediana ou minissoma. 

Um  outro  critÃ©rio  bastante  empregado  Ã©  o  critÃ©rio  de  emergÃªncia.  Ele  Ã©  aplicÃ¡vel  em 

situaÃ§Ãµes onde o vÃ©rtice onde se deseja alocar a instalaÃ§Ã£o ficar o mais prÃ³ximo possÃ­vel dos 

outros vÃ©rtices, como por exemplo a construÃ§Ã£o de um hospital, posto policial, quartel do corpo 

de bombeiros, etc. A ideia por trÃ¡s dessa escolha Ã© que o usuÃ¡rio (vÃ©rtice) mais distante nÃ£o tenha 

que esperar muito para ser atendido. Vamos apresentar um exemplo. 

Suponha que o grafo da Figura 31 representa a distribuiÃ§Ã£o de casas numa regiÃ£o rural 

fictÃ­cia e deseja-se instalar um posto policial para atender a essas famÃ­lias. O local escolhido deve 

ficar o mais prÃ³ximo possÃ­vel de todas as casas. Para que isso aconteÃ§a, a maior distÃ¢ncia do 

posto policial a uma dessas casas deve ser a menor possÃ­vel, ou seja, estamos procurando o vÃ©rtice 

6  

Para  obtenÃ§Ã£o  dos  valores  apresentados  na  Figura  32  utilizamos  uma  versÃ£o  do  algoritmo 
implementada  numa  planilha  excel.  DisponÃ­vel  em:  <https://www.excelforum.com/excel-programming-vba-
macros/>. Acesso em: 12 Jan. 2018. 

 
 
 
 
 
 
 
 
 
 
 
 
                                                           
 
cuja maior distÃ¢ncia em relaÃ§Ã£o aos outros Ã© a menor possÃ­vel. Consultando novamente a matriz 

da Figura 33 podemos construir a tabela a seguir. 

Figura 34 â€“ Maior distÃ¢ncia do posto policial. 

43 

VÃ©rtice  Afastamento 

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 

36 
28 
24 
26 
36 
29 
25 
29 
22 
26 
Fonte: O autor, 2018 

Nessa matriz a coluna Afastamento representa a maior das distÃ¢ncias de um vÃ©rtice aos outros. 

Podemos observar que o vÃ©rtice 9 apresenta a menor dessas distÃ¢ncias. Portanto ele Ã© o melhor 

candidato para a instalaÃ§Ã£o do nosso posto policial. Um vÃ©rtice com tal propriedade Ã© chamado 

de centro do grafo e seu afastamento Ã© o raio do grafo. 

 
 
 
 
4 UMA PROPOSTA PARA ALÃ‰M DA SALA DE AULA 

44 

Este capÃ­tulo tem por objetivo apresentar uma proposta de oficina para alunos do ensino 

mÃ©dio onde serÃ£o introduzidos alguns conceitos bÃ¡sicos da teoria de Grafos e uma aplicaÃ§Ã£o dos 

algoritmos de Dijkstra e Floyd-Warshall. A partir de um problema contextualizado de caminhos 

mÃ­nimos o aluno serÃ¡ encorajado a encontrar soluÃ§Ãµes utilizando tais algoritmos.  

Para isso, sugerimos uma sequÃªncia de tÃ³picos que podem ser trabalhados com alunos do 

2Âº ou 3Âº ano do ensino mÃ©dio. Ã‰ desejÃ¡vel, mas nÃ£o necessariamente obrigatÃ³rio, que esses alunos 

tenham conhecimento bÃ¡sico do conceito de Matrizes. A estrutura de desenvolvimento desses 

tÃ³picos se relaciona com os conteÃºdos dos capÃ­tulos 2 e 3 desse trabalho pois acreditamos que os 

modelos apresentados possam ser construÃ­dos por esses alunos, seja para demonstrar aplicaÃ§Ã£o, 

verificar resultados ou mesmo despertar interesse pelo tema. 

4.1 TÃ³pico 1: O Problema Motivador 

Objetivo: AtravÃ©s de um problema motivador apresentar alguns conceitos bÃ¡sicos da teoria de 

Grafos; 

Desenvolvimento:  

ï‚·  ApresentaÃ§Ã£o do Problema Motivador: 

â€œO dono de uma loja de departamentos deseja expandir seus negÃ³cios numa regiÃ£o do interior de 

SÃ£o Paulo. Ele pretende abrir sete lojas nas cidades de Piracicaba, Botucatu, TatuÃ­, Sorocaba, Itu, 

JundiaÃ­, Indaiatuba e um centro de distribuiÃ§Ã£o em Campinas.  Sempre que se deseja fazer uma 

entrega do Centro de distribuiÃ§Ã£o para uma das lojas aproveita-se a viagem para recolher notas 

fiscais nas demais lojas situadas ao longo do caminho por onde o entregador passarÃ¡. A escolha 

do caminho utilizado pelo entregador deve ser feita de modo que a distÃ¢ncia percorrida por ele 

seja a menor possÃ­vel. A Figura 35 apresenta o mapa da regiÃ£o onde serÃ£o instaladas as lojas. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figura 35 â€“ Mapa com as cidades onde as lojas serÃ£o abertas. 

45 

De posse dessas informaÃ§Ãµes e das distÃ¢ncias apresentadas na Figura 36 responda as perguntas 

Fonte: <https://www.google.com.br/maps> 

abaixo.  

a) Quantos quilÃ´metros serÃ£o percorridos para fazer uma entrega para a loja situada em TatuÃ­? 

Por quais cidades esse entregador passarÃ¡? 

b) Suponha agora que a central de distribuiÃ§Ã£o possa ser instalada em qualquer uma das cidades. 

Em qual delas vocÃª a instalaria? Por que?â€ 

Figura 36 â€“ Tabela com distÃ¢ncias conhecidas. 

Cidades 
ğ‘ƒğ‘–ğ‘Ÿğ‘ğ‘ğ‘–ğ‘ğ‘ğ‘ğ‘ â†” ğµğ‘œğ‘¡ğ‘¢ğ‘ğ‘ğ‘¡ğ‘¢ 
ğµğ‘œğ‘¡ğ‘¢ğ‘ğ‘ğ‘¡ğ‘¢ â†’ ğ¼ğ‘¡ğ‘¢ 
ğ¼ğ‘¡ğ‘¢ â†’ ğµğ‘œğ‘¡ğ‘¢ğ‘ğ‘ğ‘¡ğ‘¢ 
ğµğ‘œğ‘¡ğ‘¢ğ‘ğ‘ğ‘¡ğ‘¢ â†” ğ‘‡ğ‘ğ‘¡ğ‘¢Ã­ 
ğ‘‡ğ‘ğ‘¡ğ‘¢Ã­ â†’ ğ‘†ğ‘œğ‘Ÿğ‘œğ‘ğ‘ğ‘ğ‘ 
ğ‘†ğ‘œğ‘Ÿğ‘œğ‘ğ‘ğ‘ğ‘ â†’ ğ‘‡ğ‘ğ‘¡ğ‘¢Ã­ 
ğ¼ğ‘¡ğ‘¢ â†” ğ‘†ğ‘œğ‘Ÿğ‘œğ‘ğ‘ğ‘ğ‘ 
ğ¼ğ‘¡ğ‘¢ â†” ğ½ğ‘¢ğ‘›ğ‘‘ğ‘–ğ‘Ã­ 
ğ¼ğ‘¡ğ‘¢ â†” ğ¼ğ‘›ğ‘‘ğ‘ğ‘–ğ‘ğ‘¡ğ‘¢ğ‘ğ‘ 
ğ½ğ‘¢ğ‘›ğ‘‘ğ‘–ğ‘ğ‘–ğ‘ â†” ğ¼ğ‘›ğ‘‘ğ‘ğ‘–ğ‘ğ‘¡ğ‘¢ğ‘ğ‘ 
ğ¼ğ‘›ğ‘‘ğ‘ğ‘–ğ‘ğ‘¡ğ‘¢ğ‘ğ‘ â†” ğ¶ğ‘ğ‘šğ‘ğ‘–ğ‘›ğ‘ğ‘  
ğ¶ğ‘ğ‘šğ‘ğ‘–ğ‘›ğ‘ğ‘  â†” ğ½ğ‘¢ğ‘›ğ‘‘ğ‘–ğ‘Ã­ 
ğ¶ğ‘ğ‘šğ‘ğ‘–ğ‘›ğ‘ğ‘  â†” ğ‘ƒğ‘–ğ‘Ÿğ‘ğ‘ğ‘–ğ‘ğ‘ğ‘ğ‘ 

DistÃ¢ncia (Km) 
115 
148 
164 
107 
61 
52 
38 
48 
27 
47 
28 
39 
71 

Fonte: O autor, 2018 

ï‚· 

IntroduÃ§Ã£o aos conceitos bÃ¡sicos de Teoria de Grafos 

Com  o  objetivo  de  modelar  o  problema  motivador,  serÃ£o  apresentados  os  conceitos 

fundamentais acerca da teoria de grafos abordados no CapÃ­tulo II. Espera-se que a introduÃ§Ã£o 

desse  novo  objeto  de  estudo,  associado  a  um  problema  de  ordem  prÃ¡tica,  propicie  uma 

aprendizagem significativa para alunos. AlÃ©m disso, tais conceitos serÃ£o importantes tanto para 

 
 
 
a compreensÃ£o da modelagem como para o entendimento dos algoritmos que serÃ£o tratados nos 

46 

tÃ³picos posteriores.  

ï‚·  Modelagem do Problema 

A  partir  do  que  foi  visto  anteriormente,  o  problema  serÃ¡  modelado  por  um  digrafo 

ponderado como o da figura a seguir. 

Figura 37 â€“ SituaÃ§Ã£o problema modelada por um grafo. 

ï‚·  Relacionar o Problema Motivador com a determinaÃ§Ã£o de um caminho mÃ­nimo entre dois 

Fonte: O autor, 2018 

vÃ©rtices do grafo. 

4.2 TÃ³pico 2: Algoritmos 

Objetivo: Conceituar o que Ã© um algoritmo e descrever seus passos. 

Desenvolvimento:  

ï‚· 

Sugerir que os alunos proponham soluÃ§Ãµes para algumas situaÃ§Ãµes tais como atravessar 

uma rua, fazer uma pipoca, calcular uma mÃ©dia final escolar, procurar palavras no dicionÃ¡rio, 

etc, descrevendo de maneira eficiente um passo a passo de suas aÃ§Ãµes encadeadas logicamente. 

Duas sugestÃµes de situaÃ§Ãµes problema e seus respectivos algoritmos podem ser encontradas no 

ApÃªndices F.  

ï‚· 

Conceituar algoritmo segundo BACKES (2011): â€œUm algoritmo pode ser definido como 

uma sequÃªncia finita e ordenada de instruÃ§Ãµes para solucionar um determinado problema.â€ 

ï‚· 

Fazer um apanhado histÃ³rico da origem dos algoritmos. Uma sugestÃ£o de material para 

consulta encontra-se no apÃªndice G. 

 
 
 
 
 
 
  
47 

4.3 TÃ³pico 3: O Algoritmo de Dijkstra 

Objetivo: Apresentar o passo a passo do Algoritmo de Dijkstra.  

Desenvolvimento:  

ï‚·  Descrever a finalidade do algoritmo; 

ï‚·  Apresentar  o  passo  a  passo  do  Algoritmo  de  Dijkstra,  fazendo  uma  adequaÃ§Ã£o  de 

linguagem do conteÃºdo apresentado no capÃ­tulo 3 de maneira a torna-lo mais acessÃ­vel para a 

compreensÃ£o dos alunos, o que serÃ¡ feito a seguir. 

Sejam ğ‘– e ğ‘“ dois vÃ©rtices em um grafo ğº = (ğ‘‰, ğ¸). Deseja-se determinar o custo do menor 

caminho que tem origem em ğ‘– e tÃ©rmino em ğ‘“. Note que o caminho possui orientaÃ§Ã£o, uma vez 

que em um grafo orientado caminho ğ‘– â†’ ğ‘“ Ã© distinto do caminho  ğ‘“ â†’ ğ‘–. 

Para o funcionamento do algoritmo, precisamos definir dois parÃ¢metros relacionados com 

os vÃ©rtices do grafo. Seja ğ‘— âˆˆ ğ‘‰: 

ïƒ˜  ğ‘‘(ğ‘—): Ã© o comprimento do menor caminho que tem origem em ğ‘– e tÃ©rmino em ğ‘—; 

ïƒ˜  ğ‘(ğ‘—): indica qual Ã© o vÃ©rtice que antecede ğ‘£ na sequÃªncia de vÃ©rtices que vÃ£o compor o 

caminho desejado. 

Por exemplo, considere o grafo da Figura 38. 

Figura 38 â€“ Grafo. 

Fonte: O autor, 2018 

Suponha que desejamos buscar o menor caminho do vÃ©rtice 1 atÃ© o vÃ©rtice 4. Por inspeÃ§Ã£o 

verificamos que o caminho procurado Ã© (1,3,4) e ele mede 11 unidades de comprimento. Assim 

ğ‘‘(4) = 11, ğ‘(4) = 3, ğ‘(3) = 1 e ğ‘(1) = âˆ„. 

Durante a execuÃ§Ã£o do algoritmo obteremos sucessivamente o menor caminho do vÃ©rtice 

de origem a cada vÃ©rtice do grafo, atÃ© que o vÃ©rtice de nosso interesse seja atingido. Dessa forma, 

os  vÃ©rtices  podem  ser  classificados  de  duas  formas,  para  as  quais  definiremos  os  conjuntos 

abaixo: 

ï‚·  Conjunto ğ¹ dos vÃ©rtices fechados: formados pelos vÃ©rtices ğ‘— para os quais jÃ¡ se obteve o 

menor caminho de ğ‘– a ğ‘—. 

 
 
 
 
ï‚·  Conjunto ğ´ dos vÃ©rtices abertos: Ã© o complementar de ğ¹ em relaÃ§Ã£o a ğ‘‰, ou seja, ğ´ =

ğ‘‰ âˆ’ ğ¹ 

O passo a passo do algoritmo serÃ¡ apresentado a seguir. 

48 

Algoritmo de Dijkstra 

Seja ğ‘€ = [ğ‘š(cid:3036)(cid:3037)] a matriz de manejo associada ao grafo, ğ‘– o vÃ©rtice de origem, ğ‘“ o vÃ©rtice 

de destino e ğ‘— um vÃ©rtice qualquer. 

1Âº Passo: Fazemos ğ‘‘(ğ‘–) = 0, e ğ‘(ğ‘–) = âˆ„ 

2Âº Passo: Fazemos ğ‘‘(ğ‘—) = ğ‘š(cid:3036)(cid:3037) se existe a aresta (ğ‘–, ğ‘—). Caso contrÃ¡rio e ğ‘‘(ğ‘—) = âˆ. 

3Âº Passo: Fazemos ğ‘(ğ‘—) = âˆ„ se ğ‘‘(ğ‘—) = âˆ. Caso contrÃ¡rio ğ‘(ğ‘—) = ğ‘–; 

4Âº Passo: Fazemos ğ¹ = {ğ‘–} e ğ´ = ğ‘‰ âˆ’ ğ¹; 

5Âº Passo: Seja ğ‘Ÿ âˆˆ ğ´ tal que ğ‘‘(ğ‘Ÿ) seja mÃ­nimo; 

6Âº Passo: Fechamos o vÃ©rtice ğ‘Ÿ. O retiramos de ğ´ e o incluÃ­mos em ğ¹; 

7Âº Passo: Se ğ‘Ÿ = ğ‘“ o algoritmo cessa. Caso contrÃ¡rio faÃ§a: 

(1): Para todo vÃ©rtice ğ‘  âˆˆ ğ´  tal que ğ‘  sucessor de ğ‘Ÿ calcule a soma ğ‘‘(ğ‘Ÿ) + ğ‘š(cid:3045)(cid:3046); 

(2): Caso alguma soma da etapa (1) seja inferior a ğ‘‘(ğ‘ ), substitua ğ‘‘(ğ‘ ) por essa soma e 

faÃ§a ğ‘(ğ‘ ) = ğ‘Ÿ.  

(3): Retorne para o 5Âº passo. 

 
 
 
 
 
49 

4.4 TÃ³pico 4: AplicaÃ§Ã£o do Algoritmo de Dijkstra 

Objetivo: Responder ao item a) do problema motivador.  

Desenvolvimento:  

ï‚·  Retomar o item a) do problema motivador: â€œQuantos quilÃ´metros serÃ£o percorridos para 

fazer uma entrega para a loja situada em TatuÃ­? Por quais cidades esse entregador passarÃ¡?â€ 

ï‚·  Aplicar o passo a passo do algoritmo  

Podemos  responder  Ã   primeira  pergunta  aplicando-se  o  Algoritmo  de  Dijkstra.  Nesse 

caso, o custo serÃ¡ a distÃ¢ncia entre Campinas e TatuÃ­ e os vÃ©rtices que constituirÃ£o esse menor 

caminho serÃ£o as cidades percorridas pelo entregador. A Matriz de Manejo relacionada ao grafo 

Ã© 

ğ‘€ =

0

71 âˆ
0

âˆ âˆ âˆ 39 28
0
â¤
â¡
115 âˆ âˆ âˆ âˆ âˆ
71
â¥
â¢
107 âˆ 148 âˆ âˆ
âˆ 115
â¥
â¢
61 âˆ âˆ âˆ
âˆ âˆ 107
â¥
â¢
38 âˆ âˆ
âˆ âˆ
0
â¥
â¢
48 27
âˆ âˆ 164 âˆ 38
0
â¥
â¢
â¥
â¢
47
0
âˆ âˆ 48
âˆ
39 âˆ
0 â¦
â£
47
âˆ âˆ 27
âˆ
28 âˆ

0
âˆ 52

Seguindo a rotulaÃ§Ã£o proposta na Figura 37 temos ğ‘– = 1 e ğ‘“ = 4. Executando os 4 primeiros 

passos do algoritmo: 

1Âº Passo: ğ‘‘(1) = 0 e ğ‘(1) = âˆ„ 

2Âº Passo: ğ‘‘(2) = 71; ğ‘‘(7) = 39; ğ‘‘(8) = 28 ğ‘’ ğ‘‘(3) = ğ‘‘(4) = ğ‘‘(5) = ğ‘‘(6) = âˆ 

3Âº Passo: ğ‘(2) = ğ‘(7) = ğ‘(8) = 1 ğ‘’ ğ‘(3) = ğ‘(4) = ğ‘(5) = ğ‘(6) = âˆ„ 

4Âº Passo: ğ¹ = {1} ğ‘’ ğ´ = {2,3,4,5,6,7,8} 

A Figura 39 indica o estado atual do algoritmo. Os vÃ©rtices fechados serÃ£o assinalados 

em vermelho. 

Figura 39 â€“ InicializaÃ§Ã£o do Algoritmo de Dijkstra. 

 
 
 
 
 
 
A  partir  do  5Âº  passo  buscaremos  sucessivamente  o  vÃ©rtice  mais  prÃ³ximo  da  origem. 

Consultando a tabela da Figura 39 temos que o menor dos ğ‘‘(8) Ã© o mais prÃ³ximo da origem. 

Fonte: O autor, 2018 

50 

Executando o 5Âº e 6Âº passo temos: 

5Âº Passo: Fazemos ğ‘Ÿ = 8; 

6Âº Passo: ğ¹ = {1,8} ğ‘’ ğ´ = {2,3,4,5,6,7} 

7Âº Passo: Neste passo verificamos se o vÃ©rtice ğ‘Ÿ selecionado Ã© o nosso vÃ©rtice de destino. Como 

isso nÃ£o ocorre o algoritmo segue. As etapas (1) e (2) desse passo verificam se o comprimento 

do caminho ğ‘– â†’ ğ‘Ÿ â†’ ğ‘ , onde ğ‘  Ã© um vÃ©rtice aberto e adjacente a ğ‘Ÿ, Ã© menor que o comprimento 

ğ‘‘(ğ‘ ) que nÃ£o possui ğ‘Ÿ como intermediÃ¡rio. Em caso afirmativo atualizamos os valores ğ‘‘(ğ‘ ) e 

ğ‘(ğ‘ ). Nesse caso, avaliaremos os vÃ©rtices 6 e 7 que sÃ£o os Ãºnicos vÃ©rtices adjacentes e abertos a 

8.  

ğ‘Ÿ = 8 â‰  4,  

(1) ğ‘  = 6 â‡’ ğ‘‘(8) + ğ‘š(cid:2876)(cid:2874) = 55 
ğ‘  = 7 â‡’ ğ‘‘(8) + ğ‘š(cid:2876)(cid:2875) = 75 

(2) Como ğ‘‘(6) = âˆ > 55 atualizamos ğ‘‘(6) = 55 e ğ‘(6) = 8 

Como ğ‘‘(7) = 39 < 75 nÃ£o alteramos ğ‘‘(7) e ğ‘(7). 

(3) Retorne para o 5Âº Passo. 

O caminho 1 â†’ 8 â†’ 6 menor comprimento que o caminho 1 â†’ 8 que nÃ£o possui 6 como 

intermediÃ¡rio.  Logo,  melhoramos  a  estimativa da  menor  distÃ¢ncia  de  1  atÃ©  6  e  atualizamos  o 

vÃ©rtice anterior a 6 para 8, pois Ã© passando por 8 que temos esse caminho. Finalmente o algoritmo 

retorna para o 5Âº Passo, onde um novo vÃ©rtice mais prÃ³ximo a origem Ã© escolhido. A Figura 40 

mostra estado atual do algoritmo. Assinalamos a aresta (1,8) em vermelho para indicar que ela 

comporÃ¡ o menor caminho de algum vÃ©rtice (o vÃ©rtice 8 atÃ© o momento). 

Figura 40 â€“ 1Âª iteraÃ§Ã£o do Algoritmo de Dijkstra 

 
 
5Âº  Passo:  Consultando  a  tabela  da  Figura  40  observamos  que  ğ‘‘(7)  Ã©  o  mÃ­nimo  do  conjunto 

Fonte: O autor, 2018 

51 

{ğ‘‘(ğ‘—), ğ‘— âˆˆ ğ´}. Portanto ğ‘Ÿ = 7. 

6Âº Passo: ğ¹ = {1,7,8} ğ‘’ ğ´ = {2,3,4,5,6} 

7Âº  Passo:  Como  ğ‘Ÿ = 7 â‰  4  o  algoritmo  prossegue.  O  Ãºnico  vÃ©rtice aberto  adjacente  a  7  Ã©  6. 

EntÃ£o: 

(1) ğ‘  = 6 â‡’ ğ‘‘(7) + ğ‘š(cid:2875)(cid:2874) = 87 
(2) Como ğ‘‘(6) = 55 < 87 nÃ£o alteramos ğ‘‘(6) e ğ‘(6). 

(3) Retorne para o 5Âº Passo. 

Figura 41 â€“ 2Âª iteraÃ§Ã£o do Algoritmo de Dijkstra 

 5Âº  Passo:  Consultando  a  tabela  da  Figura  41  observamos  que  ğ‘‘(6)  Ã©  o  mÃ­nimo  do  conjunto 

Fonte: O autor, 2018 

{ğ‘‘(ğ‘—), ğ‘— âˆˆ ğ´}. Portanto ğ‘Ÿ = 6. 

6Âº Passo: ğ¹ = {1,6,7,8} ğ‘’ ğ´ = {2,3,4,5} 

7Âº Passo: Como ğ‘Ÿ = 6 â‰  4 o algoritmo prossegue. Os vÃ©rtices abertos adjacentes a 6 sÃ£o 3 e 5. 

EntÃ£o: 

(1) ğ‘  = 3 â‡’ ğ‘‘(6) + ğ‘š(cid:2874)(cid:2871) = 203 
ğ‘  = 5 â‡’ ğ‘‘(6) + ğ‘š(cid:2874)(cid:2873) = 93 

(2) Como ğ‘‘(3) = âˆ > 203 atualizamos ğ‘‘(3) = 203 e ğ‘(3) = 6 

      Como ğ‘‘(5) = âˆ > 93 atualizamos ğ‘‘(5) = 93 e ğ‘(5) = 6 

(3) Retorne para o 5Âº Passo. 

 
 
 
 
 
 
 
 
 
Figura 42 â€“ 3Âª iteraÃ§Ã£o do Algoritmo de Dijkstra 

52 

5Âº  Passo:  Consultando  a  tabela  da  Figura  42  observamos  que  ğ‘‘(2)  Ã©  o  mÃ­nimo  do  conjunto 

Fonte:  O autor, 2018 

{ğ‘‘(ğ‘—), ğ‘— âˆˆ ğ´}. Portanto ğ‘Ÿ = 2. 

6Âº Passo: ğ¹ = {1,2,6,7,8} ğ‘’ ğ´ = {3,4,5} 

7Âº  Passo:  Como  ğ‘Ÿ = 2 â‰  4  o  algoritmo  prossegue.  O  Ãºnico  vÃ©rtice  aberto  adjacente  a  2  Ã©  o 

vÃ©rtice 3. EntÃ£o: 

(1) ğ‘  = 3 â‡’ ğ‘‘(2) + ğ‘š(cid:2870)(cid:2871) = 186 
(2) Como ğ‘‘(3) = 203 > 203 atualizamos ğ‘‘(3) = 186 e ğ‘(3) = 2 

(3) Retorne para o 5Âº Passo. 

Figura 43 â€“ 4Âª iteraÃ§Ã£o do Algoritmo de Dijkstra 

5Âº  Passo:  Consultando  a  tabela  da  Figura  43  observamos  que  ğ‘‘(5)  Ã©  o  mÃ­nimo  do  conjunto 

Fonte: O autor, 2018 

{ğ‘‘(ğ‘—), ğ‘— âˆˆ ğ´}. Portanto ğ‘Ÿ = 5. 

6Âº Passo: ğ¹ = {1,2,5,6,7,8} ğ‘’ ğ´ = {3,4} 

 
 
 
 
7Âº  Passo:  Como  ğ‘Ÿ = 5 â‰  4  o  algoritmo  prossegue.  O  Ãºnico  vÃ©rtice  aberto  adjacente  a  5  Ã©  o 

vÃ©rtice 4. EntÃ£o: 

53 

(1) ğ‘  = 4 â‡’ ğ‘‘(5) + ğ‘š(cid:2873)(cid:2872) = 145 
(2) Como ğ‘‘(4) = âˆ > 145 atualizamos ğ‘‘(4) = 145 e ğ‘(4) = 5 

(3) Retorne para o 5Âº Passo. 

Figura 44 â€“ 5Âª iteraÃ§Ã£o do Algoritmo de Dijkstra 

5Âº  Passo:  Consultando  a  tabela  da  Figura  44  observamos  que  ğ‘‘(4)  Ã©  o  mÃ­nimo  do  conjunto 

Fonte: O autor, 2018 

{ğ‘‘(ğ‘—), ğ‘— âˆˆ ğ´}. Portanto ğ‘Ÿ = 4. 

6Âº Passo: ğ¹ = {1,2,4,5,6,7,8} ğ‘’ ğ´ = {3} 

7Âº Passo: Como ğ‘Ÿ = 4 o algoritmo o algoritmo cessa. 

Figura 45 â€“ Algoritmo de Dijkstra finalizado. 

Portanto, a distÃ¢ncia percorrida de Campinas atÃ© TatuÃ­ serÃ¡ de 145 km. Para respondermos 

Ã  segunda pergunta do item a) comporemos o caminho utilizando a informaÃ§Ã£o na lista ğ‘(ğ‘£). 

Fonte: O autor, 2018 

 
 
 
 
Iniciamos por ğ‘(4) = 5, pois 4 Ã© o nosso vÃ©rtice destino. Verificamos entÃ£o que ğ‘(5) = 6. O 

processo se repete atÃ© que ğ‘(ğ‘£) = 1, que Ã© o nosso vÃ©rtice de partida. Assim: 

54 

ğ‘(4) = 5 

ğ‘(5) = 6 

ğ‘(6) = 8 

ğ‘(8) = 1 

Portanto o caminho percorrerÃ¡ os vÃ©rtices 1, 8, 6, 5 e 4, sendo 1 e 4 os pontos de partida e de 

chegada respectivamente. Consultando a tabela da figura x verificamos que o caminhÃ£o passarÃ¡ 

nas cidades de Indaiatuba, Itu e Sorocaba, nesta ordem, antes de chegar em TatuÃ­. 

 
 
 
 
 
55 

4.5 TÃ³pico 5: O Algoritmo de Floyd-Warshall 

Objetivo: Apresentar o passo a passo do Algoritmo de Floyd-Warshall.  

Desenvolvimento:  

ï‚·  Apresentar historicamente Bernard Roy, Robert Floyd e Stephen Warshall. 

Explicar a finalidade do algoritmo bem como o seu passo a passo. Como no algoritmo de 

Dijkstra, foi feita uma adequaÃ§Ã£o da linguagem  do conteÃºdo apresentado no capÃ­tulo 3 como 

descreveremos a seguir. 

Seja ğº um grafo com ğ‘› vÃ©rtices. Baseado na Matriz de Manejo de ğº, devemos construir 

uma outra matriz ğ‘…(cid:3041)Ã—(cid:3041) = [ğ‘Ÿ(cid:3036)(cid:3037)] denominada Matriz de Roteamento. Essa matriz fornecerÃ¡ a â€œrotaâ€ 

que devemos estabelecer entre os vÃ©rtices na construÃ§Ã£o do menor caminho entre dois vÃ©rtices 

do grafo. Ela Ã© definida como se segue: 

ğ‘Ÿ(cid:3036)(cid:3037) = (cid:3420)

ğ‘—, ğ‘ ğ‘’ ğ‘’ğ‘¥ğ‘–ğ‘ ğ‘¡ğ‘’ ğ‘œ ğ‘ğ‘Ÿğ‘ğ‘œ (ğ‘–, ğ‘—)        
0, ğ‘ ğ‘’ ğ‘›Ã£ğ‘œ ğ‘’ğ‘¥ğ‘–ğ‘ ğ‘¡ğ‘’ ğ‘œ ğ‘ğ‘Ÿğ‘ğ‘œ (ğ‘–, ğ‘—)

O elemento  ğ‘Ÿ(cid:3036)(cid:3037) indica qual Ã© o vÃ©rtice seguinte a ğ‘– no menor caminho de ğ‘– atÃ© ğ‘— (caso 

exista). Inicialmente temos que o menor caminho entre dois vÃ©rtices Ã© igual ao peso do arco que 

os une. Dessa forma, ğ‘Ÿ(cid:3036)(cid:3037) = ğ‘— se existir o arco (ğ‘–, ğ‘—), ou seja, o vÃ©rtice seguinte a ğ‘– no caminho ğ‘– â†’

ğ‘— Ã© o prÃ³prio ğ‘—. Caso nÃ£o exista esse arco, nÃ£o hÃ¡ inicialmente um caminho possÃ­vel de ğ‘– atÃ© ğ‘— e 

indicamos a ausÃªncia desse caminho fazendo ğ‘Ÿ(cid:3036)(cid:3037) = ğ‘—. 

O algoritmo farÃ¡ uma iteraÃ§Ã£o para cada um de seus vÃ©rtices e atualizarÃ¡ as matrizes de 

manejo e de roteamento. Em cada iteraÃ§Ã£o ğ‘˜ serÃ¡ verificado, com base na matriz de manejo, se 

o comprimento do caminho do vÃ©rtice ğ‘– atÃ© o vÃ©rtice ğ‘—, tendo ğ‘˜ como intermediÃ¡rio, Ã© menor do 

que o comprimento jÃ¡ existente entre esses vÃ©rtices. Em sÃ­mbolos: 

ğ‘š(cid:3036)(cid:3038) + ğ‘š(cid:3038)(cid:3037) < ğ‘š(cid:3036)(cid:3037). 

Caso se verifique a Ãºltima desigualdade substituÃ­mos o valor de ğ‘š(cid:3036)(cid:3037) por ğ‘š(cid:3036)(cid:3038) + ğ‘š(cid:3038)(cid:3037) na 

matriz de manejo. Em seguida devemos atualizar a matriz de roteamento. Se para atingir ğ‘— a partir 

de ğ‘– devemos passar primeiro por ğ‘˜, entÃ£o ğ‘Ÿ(cid:3036)(cid:3037) deve ser atualizado com o vÃ©rtice seguinte a ğ‘– no 

caminho ğ‘– â†’ ğ‘˜, ou seja ğ‘Ÿ(cid:3036)(cid:3038). 

Esse processo se repete em cada iteraÃ§Ã£o para todo ğ‘–, ğ‘— â‰  ğ‘˜, jÃ¡ que ao tomarmos ğ‘˜ como 

intermediÃ¡rio, nÃ£o podemos tÃª-lo como vÃ©rtice de origem ou de destino. 

Cabe ressaltar que se ğ‘š(cid:3036)(cid:3038) = âˆ ou ğ‘š(cid:3038)(cid:3037) = âˆ, a distÃ¢ncia de ğ‘– atÃ© ğ‘— nÃ£o serÃ¡ melhorada 

(reduzida) pois o membro esquerdo da desigualdade serÃ¡ sempre maior. Isso pode ser Ãºtil quando 

executamos o algoritmo manualmente, poupando checagens desnecessÃ¡rias.  

Para obter a sequÃªncias de vÃ©rtices que determina o caminho mÃ­nimo de ğ‘– â†’ ğ‘—, devemos 

consultar o elemento ğ‘Ÿ(cid:3036)(cid:3037) da matriz de roteamento. Se ğ‘Ÿ(cid:3036)(cid:3037) = ğ‘, significa que o caminho passa por 

 
 
 
 
 
 
 
 
ğ‘ depois de ğ‘–. Devemos agora localizar o elemento ğ‘Ÿ(cid:3028)(cid:3037), que indicarÃ¡ o prÃ³ximo vÃ©rtice depois de 

ğ‘. Se ğ‘Ÿ(cid:3028)(cid:3037) = ğ‘ entÃ£o ğ‘ Ã© o vÃ©rtice seguinte a ğ‘ no caminho mÃ­nimo. Esse processo continua atÃ© 

56 

que ğ‘Ÿ(cid:3051)(cid:3037) = ğ‘—, gerando o caminho 

(ğ‘–, ğ‘, ğ‘, â€¦ , ğ‘—) 

Abaixo temos o passo a passo do algoritmo. 

Algoritmo de Floyd-Warshall 

Seja ğº = (ğ‘‰, ğ¸) um grafo com ğ‘› vÃ©rtices, onde ğ‘‰ = {1,2, â€¦ , ğ‘›}. 

1Âº Passo: ğ‘˜ = min (ğ‘‰). Remova ğ‘˜ de V. 

2Âº  Passo:  Para  todo  ğ‘š(cid:3036)(cid:3037),  com  ğ‘–, ğ‘— â‰  ğ‘˜,  verifique  se  ğ‘š(cid:3036)(cid:3038) + ğ‘š(cid:3038)(cid:3037) < ğ‘š(cid:3036)(cid:3037).  Em  caso  afirmativo 

substitua ğ‘š(cid:3036)(cid:3037) por ğ‘š(cid:3036)(cid:3038) + ğ‘š(cid:3038)(cid:3037) e ğ‘Ÿ(cid:3036)(cid:3037) por ğ‘Ÿ(cid:3036)(cid:3038). 

3Âº Passo: Se ğ‘˜ = ğ‘› o algoritmo cessa. Caso contrÃ¡rio retorne ao 1Âº Passo. 

 
 
 
 
 
 
 
57 

4.6 TÃ³pico 6: AplicaÃ§Ã£o do Algoritmo de Floyd-Warshall 

Objetivo: Responder ao item b) do problema motivador.  

Desenvolvimento:  

ï‚·  Retomar o item b) do problema motivador: â€œSuponha agora que a central de distribuiÃ§Ã£o 

possa ser instalada em qualquer uma das cidades. Em qual delas vocÃª a instalaria? Por 

que?â€ 

ï‚·  Aplicar o passo a passo do algoritmo. 

Ã‰ mais vantajoso instalar o centro de distribuiÃ§Ã£o na cidade que seja mais prÃ³xima de 

todas as outras, pois assim o custo com combustÃ­vel serÃ¡ o menor possÃ­vel. Em outras palavras, 

estamos procurando uma cidade cuja soma das distÃ¢ncias atÃ© as outras seja a menor possÃ­vel. 

Podemos aplicar o algoritmo de Floyd-Warshall para determinar qual Ã© a menor distÃ¢ncia entre 

todas as cidades e em seguida calcular a soma dessas distÃ¢ncias para cada cidade. Resgatando o 

grafo do problema motivador temos as seguintes matrizes de manejo e de roteamento. 

Figura 46 â€“ Matrizes de Manejo e de Roteamento do Problema Motivador. 

Para este grafo temos ğ‘‰ = {1,2,3,4,5,6,7,8}. Vamos aplicar o algoritmo. 

Fonte: O autor, 2018 

1Âº Passo: min(ğ‘‰) = 1. ExcluÃ­mos o vÃ©rtice 1 de ğ‘‰:  ğ‘‰ = {2,3,4,5,6,7,8} 

1Âª IteraÃ§Ã£o 

2Âº Passo:  

Para ğ‘– = 2 temos que  

ğ‘š(cid:2870)(cid:2869) + ğ‘š(cid:2869)(cid:2875) < ğ‘š(cid:2870)(cid:2875) ğ‘’ ğ‘š(cid:2870)(cid:2869) + ğ‘š(cid:2869)(cid:2876) < ğ‘š(cid:2870)(cid:2876). 

Nos  outros,  ğ‘š(cid:2870)(cid:2871) = ğ‘š(cid:2870)(cid:2872) = ğ‘š(cid:2870)(cid:2873) = ğ‘š(cid:2870)(cid:2874) = âˆ,  logo  as  distÃ¢ncias  nÃ£o  serÃ£o  melhoradas. 

SubstituÃ­mos os valores de ğ‘š(cid:2870)(cid:2875) e ğ‘š(cid:2870)(cid:2876) com os valores das respectivas somas: 

ğ‘š(cid:2870)(cid:2875) = ğ‘š(cid:2870)(cid:2869) + ğ‘š(cid:2869)(cid:2875) = 120 ğ‘’ ğ‘š(cid:2870)(cid:2876) =   ğ‘š(cid:2870)(cid:2869) + ğ‘š(cid:2869)(cid:2876) = 99. 

 
 
 
 
 
  Em seguida substituÃ­mos o valor de ğ‘Ÿ(cid:2870)(cid:2875) por ğ‘Ÿ(cid:2870)(cid:2869) = 1, que Ã© o vÃ©rtice pelo qual se deve 

passar a partir de 2 para chegar a 1. O mesmo Ã© feito com relaÃ§Ã£o a ğ‘š(cid:2870)(cid:2876). A Figura 46 ilustra essas 

mudanÃ§as  na  1Âª  iteraÃ§Ã£o.  A  cada  iteraÃ§Ã£o  sempre  fixaremos  a  linha  e  coluna  ğ‘˜  na  matriz  de 

manejo e a coluna ğ‘˜ na matriz de pesos de maneira a tornar o processo manual mais simples. 

Figura 47 â€“ Matrizes de Manejo e de Roteamento durante a 1Âª iteraÃ§Ã£o do algoritmo. 

58 

Fonte: O autor, 2018 

Para ğ‘– = 3,4,5,6 temos ğ‘š(cid:2871)(cid:2869) = ğ‘š(cid:2872)(cid:2869) = ğ‘š(cid:2873)(cid:2869) = ğ‘š(cid:2874)(cid:2869) = âˆ. Logo as distÃ¢ncias 2,3,4,5 e 6, tomando 

o vÃ©rtice 1 como intermediÃ¡rio, atÃ© os outros vÃ©rtices nÃ£o poderÃ¡ ser melhorada (nÃ£o hÃ¡ conexÃ£o 

desses vÃ©rtices com o vÃ©rtice 1). Assim, nÃ£o alteraremos as linhas 2,3,4,5 e 6 nesta iteraÃ§Ã£o. 

Para ğ‘– = 7 temos apenas  

ğ‘š(cid:2875)(cid:2869) + ğ‘š(cid:2869)(cid:2870) < ğ‘š(cid:2875)(cid:2870). 

Assim, ğ‘š(cid:2875)(cid:2870) = ğ‘š(cid:2875)(cid:2869) + ğ‘š(cid:2869)(cid:2870) = 120 e ğ‘Ÿ(cid:2875)(cid:2870) = ğ‘Ÿ(cid:2875)(cid:2869) = 1 

Para ğ‘– = 8 temos apenas 

ğ‘š(cid:2875)(cid:2869) + ğ‘š(cid:2869)(cid:2870) < ğ‘š(cid:2875)(cid:2870). 

Assim, ğ‘š(cid:2876)(cid:2870) = ğ‘š(cid:2876)(cid:2869) + ğ‘š(cid:2869)(cid:2870) = 99 e ğ‘Ÿ(cid:2876)(cid:2870) = ğ‘Ÿ(cid:2875)(cid:2869) = 1 

3Âº Passo: Como ğ‘˜ = 1 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo.  

Ao final da 1Âª iteraÃ§Ã£o temos as seguintes matrizes de manejo e de roteamento conforme 

mostrado na Figura 47. 

Figura 48 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 1Âª iteraÃ§Ã£o.  

Fonte: O autor, 2018 

 
 
 
 
1Âº Passo: min(ğ‘‰) = 2. ExcluÃ­mos o vÃ©rtice 2 de ğ‘‰:  ğ‘‰ = {3,4,5,6,7,8} 

2Âª IteraÃ§Ã£o 

2Âº Passo: 

Figura 49 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 2Âª iteraÃ§Ã£o. 

59 

ï‚·  Para ğ‘– = 1 e 

Fonte: O autor, 2018 

 ğ‘— = 3: ğ‘š(cid:2869)(cid:2870) + ğ‘š(cid:2870)(cid:2871) < ğ‘š(cid:2869)(cid:2871). Assim ğ‘š(cid:2869)(cid:2871) = ğ‘š(cid:2869)(cid:2870) + ğ‘š(cid:2870)(cid:2871) = 186 e  ğ‘Ÿ(cid:2869)(cid:2871) =   ğ‘Ÿ(cid:2869)(cid:2870) = 2; 

ğ‘— = 4,5,6,7,8: ğ‘š(cid:2869)(cid:2870) + ğ‘š(cid:2870)(cid:3037) > ğ‘š(cid:2869)(cid:3037). NÃ£o hÃ¡ alteraÃ§Ãµes a fazer. 

ï‚·  Para ğ‘– = 3 e 

ğ‘— = 1: ğ‘š(cid:2871)(cid:2870) + ğ‘š(cid:2870)(cid:2869) < ğ‘š(cid:2871)(cid:2869). Portanto ğ‘š(cid:2871)(cid:2869) = ğ‘š(cid:2871)(cid:2870) + ğ‘š(cid:2870) = 186 e  ğ‘Ÿ(cid:2871)(cid:2869) =   ğ‘Ÿ(cid:2871)(cid:2870) = 2; 

ğ‘— = 4,5,6: nÃ£o hÃ¡ nada a se fazer pois ğ‘š(cid:2871)(cid:3037) = âˆ; 

ğ‘— = 7,8: ğ‘š(cid:2871)(cid:2870) + ğ‘š(cid:2870)(cid:2875) < ğ‘š(cid:2871)(cid:2875) e ğ‘š(cid:2871)(cid:2870) + ğ‘š(cid:2870)(cid:2876) < ğ‘š(cid:2871)(cid:2876). EntÃ£o 

ğ‘š(cid:2871)(cid:2875) = ğ‘š(cid:2871)(cid:2870) + ğ‘š(cid:2870)(cid:2875) = 235 e  ğ‘Ÿ(cid:2871)(cid:2875) =   ğ‘Ÿ(cid:2871)(cid:2870) = 2; 

ğ‘š(cid:2871)(cid:2876) = ğ‘š(cid:2871)(cid:2870) + ğ‘š(cid:2870)(cid:2876) = 214 e  ğ‘Ÿ(cid:2871)(cid:2876) =   ğ‘Ÿ(cid:2871)(cid:2870) = 2. 

ï‚·  Para ğ‘– = 4,5,6 nÃ£o hÃ¡ nada a se fazer pois ğ‘š(cid:3036)(cid:2870) = âˆ. 

ï‚·  Para ğ‘– = 7 e 

ğ‘— = 1,4,5,6,8: ğ‘š(cid:2875)(cid:2870) + ğ‘š(cid:2870)(cid:3037) > ğ‘š(cid:2875)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 3: ğ‘š(cid:2875)(cid:2870) + ğ‘š(cid:2870)(cid:2871) < ğ‘š(cid:2875)(cid:2871). EntÃ£o ğ‘š(cid:2875)(cid:2871) = ğ‘š(cid:2875)(cid:2870) + ğ‘š(cid:2870)(cid:2871) = 235 e ğ‘Ÿ(cid:2875)(cid:2871) =   ğ‘Ÿ(cid:2875)(cid:2870) = 1. 

ï‚·  Para ğ‘– = 8 e 

ğ‘— = 1,4,5,6,7: ğ‘š(cid:2876)(cid:2870) + ğ‘š(cid:2870)(cid:3037) > ğ‘š(cid:2876)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 3: ğ‘š(cid:2876)(cid:2870) + ğ‘š(cid:2870)(cid:2871) < ğ‘š(cid:2876)(cid:2871). EntÃ£o ğ‘š(cid:2876)(cid:2871) = ğ‘š(cid:2876)(cid:2870) + ğ‘š(cid:2870)(cid:2871) = 214 e ğ‘Ÿ(cid:2876)(cid:2871) =   ğ‘Ÿ(cid:2876)(cid:2870) = 1. 

3Âº Passo: Como ğ‘˜ = 1 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo.  

 
 
 
 
 
 
 
 
Figura 50 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 2Âª iteraÃ§Ã£o. 

60 

Fonte: O autor, 2018 

3Âª IteraÃ§Ã£o 

1Âº Passo: min(ğ‘‰) = 3. ExcluÃ­mos o vÃ©rtice de ğ‘‰:  ğ‘‰ = {4,5,6,7,8} 

2Âº Passo: 

Figura 51 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 3Âª iteraÃ§Ã£o. 

ï‚·  Para ğ‘– = 1 e 

Fonte: O autor, 2018 

 ğ‘— = 2,5,7,8: ğ‘š(cid:2869)(cid:2871) + ğ‘š(cid:2871)(cid:3037) > ğ‘š(cid:2869)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 4,6: ğ‘š(cid:2869)(cid:2871) + ğ‘š(cid:2871)(cid:2872) < ğ‘š(cid:2869)(cid:2872) e ğ‘š(cid:2869)(cid:2871) + ğ‘š(cid:2871)(cid:2874) < ğ‘š(cid:2869)(cid:2874). EntÃ£o, 

ğ‘š(cid:2869)(cid:2872) = ğ‘š(cid:2869)(cid:2871) + ğ‘š(cid:2871)(cid:2872) = 393 e  ğ‘Ÿ(cid:2869)(cid:2872) =   ğ‘Ÿ(cid:2869)(cid:2871) = 2; 

ğ‘š(cid:2869)(cid:2874) = ğ‘š(cid:2869)(cid:2871) + ğ‘š(cid:2871)(cid:2874) = 434 e  ğ‘Ÿ(cid:2869)(cid:2874) =   ğ‘Ÿ(cid:2869)(cid:2871) = 2; 

ï‚·  Para ğ‘– = 2 e 

ğ‘— = 1,5,7,8: ğ‘š(cid:2870)(cid:2871) + ğ‘š(cid:2871)(cid:3037) > ğ‘š(cid:2869)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 4,6: ğ‘š(cid:2870)(cid:2871) + ğ‘š(cid:2871)(cid:2872) < ğ‘š(cid:2870)(cid:2872) e ğ‘š(cid:2870)(cid:2871) + ğ‘š(cid:2871)(cid:2874) < ğ‘š(cid:2870)(cid:2874). EntÃ£o, 

ğ‘š(cid:2870)(cid:2872) = ğ‘š(cid:2870)(cid:2871) + ğ‘š(cid:2871)(cid:2872) = 263 e  ğ‘Ÿ(cid:2870)(cid:2872) =   ğ‘Ÿ(cid:2870)(cid:2871) = 3; 

ğ‘š(cid:2870)(cid:2874) = ğ‘š(cid:2870)(cid:2871) + ğ‘š(cid:2871)(cid:2874) = 434 e  ğ‘Ÿ(cid:2870)(cid:2874) =   ğ‘Ÿ(cid:2870)(cid:2871) = 3; 

 
 
 
 
 
61 

ï‚·  Para ğ‘– = 4 e 

ğ‘— = 1: ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2869) < ğ‘š(cid:2872)(cid:2869). Portanto ğ‘š(cid:2872)(cid:2869) = ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2869) = 393 e  ğ‘Ÿ(cid:2872)(cid:2869) =   ğ‘Ÿ(cid:2872)(cid:2871) = 3; 

ğ‘— = 2: ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2870) < ğ‘š(cid:2872)(cid:2870). Portanto ğ‘š(cid:2872)(cid:2870) = ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2870) = 222 e  ğ‘Ÿ(cid:2872)(cid:2870) =   ğ‘Ÿ(cid:2872)(cid:2871) = 3; 

ğ‘— = 5: NÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2871)(cid:2873) = âˆ; 

ğ‘— = 6: ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2874) < ğ‘š(cid:2872)(cid:2874). Portanto ğ‘š(cid:2872)(cid:2874) = ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2874) = 255 e  ğ‘Ÿ(cid:2872)(cid:2874) =   ğ‘Ÿ(cid:2872)(cid:2871) = 3; 

ğ‘— = 7: ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2875) < ğ‘š(cid:2872)(cid:2875). Portanto ğ‘š(cid:2872)(cid:2875) = ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2875) = 342 e  ğ‘Ÿ(cid:2872)(cid:2875) =   ğ‘Ÿ(cid:2872)(cid:2871) = 3; 

ğ‘— = 8: ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2876) < ğ‘š(cid:2872)(cid:2876). Portanto ğ‘š(cid:2872)(cid:2876) = ğ‘š(cid:2872)(cid:2871) + ğ‘š(cid:2871)(cid:2876) = 321 e  ğ‘Ÿ(cid:2872)(cid:2876) =   ğ‘Ÿ(cid:2872)(cid:2871) = 3; 

ï‚·  Para ğ‘– = 5 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2873)(cid:2871) = âˆ; 

ï‚·  Para ğ‘– = 6 e 

ğ‘— = 1: ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:2869) < ğ‘š(cid:2874)(cid:2869). Portanto ğ‘š(cid:2874)(cid:2869) = ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:2869) = 450 e  ğ‘Ÿ(cid:2874)(cid:2869) =   ğ‘Ÿ(cid:2874)(cid:2871) = 1; 

ğ‘— = 2: ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:2870) < ğ‘š(cid:2874)(cid:2870). Portanto ğ‘š(cid:2874)(cid:2870) = ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:2870) = 279 e  ğ‘Ÿ(cid:2874)(cid:2870) =   ğ‘Ÿ(cid:2874)(cid:2871) = 1; 

ğ‘— = 4: ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:2872) < ğ‘š(cid:2874)(cid:2872). Portanto ğ‘š(cid:2874)(cid:2872) = ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:2872) = 271 e  ğ‘Ÿ(cid:2874)(cid:2872) =   ğ‘Ÿ(cid:2874)(cid:2871) = 1; 

ğ‘— = 5: NÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2871)(cid:2873) = âˆ; 

ğ‘— = 7,8:  ğ‘š(cid:2874)(cid:2871) + ğ‘š(cid:2871)(cid:3037) > ğ‘š(cid:2874)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ï‚·  Para ğ‘– = 7 e 

ğ‘— = 1,2,5,6,8:  ğ‘š(cid:2875)(cid:2871) + ğ‘š(cid:2871)(cid:3037) > ğ‘š(cid:2875)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 4: ğ‘š(cid:2875)(cid:2871) + ğ‘š(cid:2871)(cid:2872) < ğ‘š(cid:2875)(cid:2872). Portanto ğ‘š(cid:2875)(cid:2872) = ğ‘š(cid:2875)(cid:2871) + ğ‘š(cid:2871)(cid:2872) = 342 e  ğ‘Ÿ(cid:2875)(cid:2872) =   ğ‘Ÿ(cid:2875)(cid:2871) = 1; 

ï‚·  Para ğ‘– = 8 e 

ğ‘— = 1,2,5,6,7:  ğ‘š(cid:2876)(cid:2871) + ğ‘š(cid:2871)(cid:3037) > ğ‘š(cid:2876)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 4: ğ‘š(cid:2876)(cid:2871) + ğ‘š(cid:2871)(cid:2872) < ğ‘š(cid:2876)(cid:2872). Portanto ğ‘š(cid:2876)(cid:2872) = ğ‘š(cid:2876)(cid:2871) + ğ‘š(cid:2871)(cid:2872) = 321 e  ğ‘Ÿ(cid:2875)(cid:2872) =   ğ‘Ÿ(cid:2876)(cid:2871) = 1; 

3Âº Passo: Como ğ‘˜ = 3 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo. 

Figura 52 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 3Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

 
 
 
 
 
1Âº Passo: min(ğ‘‰) = 4. ExcluÃ­mos o vÃ©rtice de ğ‘‰:  ğ‘‰ = {5,6,7,8} 

4Âª IteraÃ§Ã£o 

2Âº Passo: 

Figura 53 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 4Âª iteraÃ§Ã£o. 

62 

ï‚·  Para ğ‘– = 1 e 

Fonte: O autor, 2018 

ğ‘— = 2,3,6,7,8:  ğ‘š(cid:2869)(cid:2872) + ğ‘š(cid:2872)(cid:3037) > ğ‘š(cid:2869)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 5: ğ‘š(cid:2869)(cid:2872) + ğ‘š(cid:2872)(cid:2873) < ğ‘š(cid:2869)(cid:2873). Portanto ğ‘š(cid:2869)(cid:2873) = ğ‘š(cid:2869)(cid:2872) + ğ‘š(cid:2872)(cid:2873) = 454 e  ğ‘Ÿ(cid:2869)(cid:2873) =   ğ‘Ÿ(cid:2869)(cid:2872) = 2; 

ï‚·  Para ğ‘– = 2 e 

ğ‘— = 1,3,6,7,8:  ğ‘š(cid:2870)(cid:2872) + ğ‘š(cid:2872)(cid:3037) > ğ‘š(cid:2870)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 5: ğ‘š(cid:2870)(cid:2872) + ğ‘š(cid:2872)(cid:2873) < ğ‘š(cid:2869)(cid:2873). Portanto ğ‘š(cid:2870)(cid:2873) = ğ‘š(cid:2870)(cid:2872) + ğ‘š(cid:2872)(cid:2873) = 283 e  ğ‘Ÿ(cid:2870)(cid:2873) =   ğ‘Ÿ(cid:2870)(cid:2872) = 3; 

ï‚·  Para ğ‘– = 3 e 

ğ‘— = 1,2,6,7,8:  ğ‘š(cid:2871)(cid:2872) + ğ‘š(cid:2872)(cid:3037) > ğ‘š(cid:2871)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 5: ğ‘š(cid:2871)(cid:2872) + ğ‘š(cid:2872)(cid:2873) < ğ‘š(cid:2869)(cid:2873). Portanto ğ‘š(cid:2871)(cid:2873) = ğ‘š(cid:2870)(cid:2872) + ğ‘š(cid:2872)(cid:2873) = 168 e  ğ‘Ÿ(cid:2871)(cid:2873) =   ğ‘Ÿ(cid:2871)(cid:2872) = 4; 

ï‚·  Para ğ‘– = 5 e 

ğ‘— = 1: ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2869) < ğ‘š(cid:2873)(cid:2869). Portanto ğ‘š(cid:2873)(cid:2869) = ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2869) = 445 e  ğ‘Ÿ(cid:2873)(cid:2869) =   ğ‘Ÿ(cid:2873)(cid:2872) = 4; 

ğ‘— = 2: ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2870) < ğ‘š(cid:2873)(cid:2870). Portanto ğ‘š(cid:2873)(cid:2870) = ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2870) = 274 e  ğ‘Ÿ(cid:2873)(cid:2870) =   ğ‘Ÿ(cid:2873)(cid:2872) = 4; 

ğ‘— = 3: ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2871) < ğ‘š(cid:2873)(cid:2871). Portanto ğ‘š(cid:2873)(cid:2871) = ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2871) = 159 e  ğ‘Ÿ(cid:2873)(cid:2871) =   ğ‘Ÿ(cid:2873)(cid:2872) = 4; 

ğ‘— = 6: ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2874) > ğ‘š(cid:2873)(cid:2874) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 7: ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2875) < ğ‘š(cid:2873)(cid:2875). Portanto ğ‘š(cid:2873)(cid:2875) = ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2875) = 394 e  ğ‘Ÿ(cid:2873)(cid:2875) =   ğ‘Ÿ(cid:2873)(cid:2872) = 4; 

ğ‘— = 8: ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2876) < ğ‘š(cid:2873)(cid:2876). Portanto ğ‘š(cid:2873)(cid:2876) = ğ‘š(cid:2873)(cid:2872) + ğ‘š(cid:2872)(cid:2876) = 373 e  ğ‘Ÿ(cid:2873)(cid:2869) =   ğ‘Ÿ(cid:2873)(cid:2872) = 4; 

ï‚·  Para ğ‘– = 6 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2874)(cid:2872) + ğ‘š(cid:2872)(cid:3037) > ğ‘š(cid:2874)(cid:3037), para todo ğ‘— = 1,2,3,5,7,8; 

ï‚·  Para ğ‘– = 7 e 

ğ‘— = 1,2,3,6,8:  ğ‘š(cid:2875)(cid:2872) + ğ‘š(cid:2872)(cid:3037) > ğ‘š(cid:2875)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 5: ğ‘š(cid:2875)(cid:2872) + ğ‘š(cid:2872)(cid:2873) < ğ‘š(cid:2875)(cid:2873). Portanto ğ‘š(cid:2875)(cid:2873) = ğ‘š(cid:2875)(cid:2872) + ğ‘š(cid:2872)(cid:2873) = 403 e  ğ‘Ÿ(cid:2875)(cid:2873) =   ğ‘Ÿ(cid:2875)(cid:2872) = 1; 

ï‚·  Para ğ‘– = 8 e 

 
 
ğ‘— = 1,2,3,6,7:  ğ‘š(cid:2876)(cid:2872) + ğ‘š(cid:2872)(cid:3037) > ğ‘š(cid:2876)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 5: ğ‘š(cid:2876)(cid:2872) + ğ‘š(cid:2872)(cid:2873) < ğ‘š(cid:2876)(cid:2873). Portanto ğ‘š(cid:2876)(cid:2873) = ğ‘š(cid:2876)(cid:2872) + ğ‘š(cid:2872)(cid:2873) = 382 e  ğ‘Ÿ(cid:2876)(cid:2873) =   ğ‘Ÿ(cid:2876)(cid:2872) = 1; 

63 

3Âº Passo: Como ğ‘˜ = 4 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo.  

Figura 54 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 4Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

5Âª IteraÃ§Ã£o 

1Âº Passo: min(ğ‘‰) = 5. ExcluÃ­mos o vÃ©rtice de ğ‘‰:  ğ‘‰ = {6,7,8} 

2Âº Passo: 

Figura 55 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 5Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

ï‚·  Para ğ‘– = 1 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2869)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2869)(cid:3037), para todo ğ‘— = 2,3,4,6,7,8; 

ï‚·  Para ğ‘– = 2 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2870)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2870)(cid:3037), para todo ğ‘— = 1,3,4,6,7,8; 

ï‚·  Para ğ‘– = 3 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2871)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2871)(cid:3037), para todo ğ‘— = 1,2,4,6,7,8; 

ï‚·  Para ğ‘– = 4 e 

ğ‘— = 1,2,3,7,8: ğ‘š(cid:2872)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2872)(cid:3037) e nÃ£o hÃ¡ o que fazer; 

ğ‘— = 6: ğ‘š(cid:2872)(cid:2873) + ğ‘š(cid:2873)(cid:2874) < ğ‘š(cid:2872)(cid:2874). Portanto ğ‘š(cid:2872)(cid:2874) = ğ‘š(cid:2872)(cid:2873) + ğ‘š(cid:2873)(cid:2874) = 99 e  ğ‘Ÿ(cid:2872)(cid:2874) =   ğ‘Ÿ(cid:2872)(cid:2873) = 5; 

 
 
 
 
 
 
64 

ï‚·  Para ğ‘– = 6 e 

ğ‘— = 1,2,3,7,8: ğ‘š(cid:2874)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2872)(cid:3037) e nÃ£o hÃ¡ o que fazer; 

ğ‘— = 4: ğ‘š(cid:2874)(cid:2873) + ğ‘š(cid:2873)(cid:2872) < ğ‘š(cid:2874)(cid:2872). Portanto ğ‘š(cid:2874)(cid:2872) = ğ‘š(cid:2874)(cid:2873) + ğ‘š(cid:2873)(cid:2872) = 90 e  ğ‘Ÿ(cid:2874)(cid:2872) =   ğ‘Ÿ(cid:2874)(cid:2873) = 5; 

ï‚·  Para ğ‘– = 7 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2875)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2875)(cid:3037), para todo ğ‘— = 1,2,3,4,6,8; 

ï‚·  Para ğ‘– = 8 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2876)(cid:2873) + ğ‘š(cid:2873)(cid:3037) > ğ‘š(cid:2876)(cid:3037), para todo ğ‘— = 1,2,3,4,7,8; 

3Âº Passo: Como ğ‘˜ = 5 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo.  

Figura 56 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 5Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

6Âª IteraÃ§Ã£o 

1Âº Passo: min(ğ‘‰) = 6. ExcluÃ­mos o vÃ©rtice de ğ‘‰:  ğ‘‰ = {7,8} 

2Âº Passo: 

Figura 57 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 6Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

ï‚·  Para ğ‘– = 1 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2869)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2869)(cid:3037), para todo ğ‘— = 2,3,4,5,7,8; 

ï‚·  Para ğ‘– = 2 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2870)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2870)(cid:3037), para todo ğ‘— = 1,3,4,5,7,8; 

ï‚·  Para ğ‘– = 3 e 

 
 
 
 
 
 
65 

ğ‘— = 1,2,4,5: ğ‘š(cid:2871)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2871)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 7: ğ‘š(cid:2871)(cid:2874) + ğ‘š(cid:2874)(cid:2875) < ğ‘š(cid:2871)(cid:2875). Portanto ğ‘š(cid:2871)(cid:2875) = ğ‘š(cid:2871)(cid:2874) + ğ‘š(cid:2874)(cid:2875) = 196 e  ğ‘Ÿ(cid:2871)(cid:2875) =   ğ‘Ÿ(cid:2871)(cid:2874) = 6; 

ğ‘— = 8: ğ‘š(cid:2871)(cid:2874) + ğ‘š(cid:2874)(cid:2876) < ğ‘š(cid:2871)(cid:2876). Portanto ğ‘š(cid:2871)(cid:2876) = ğ‘š(cid:2871)(cid:2874) + ğ‘š(cid:2874)(cid:2876) = 175 e  ğ‘Ÿ(cid:2871)(cid:2875) =   ğ‘Ÿ(cid:2871)(cid:2874) = 6; 

ï‚·  Para ğ‘– = 4 e 

ğ‘— = 1,2,3,5: ğ‘š(cid:2872)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2872)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 7: ğ‘š(cid:2872)(cid:2874) + ğ‘š(cid:2874)(cid:2875) < ğ‘š(cid:2872)(cid:2875). Portanto ğ‘š(cid:2872)(cid:2875) = ğ‘š(cid:2872)(cid:2874) + ğ‘š(cid:2874)(cid:2875) = 147 e  ğ‘Ÿ(cid:2872)(cid:2875) =   ğ‘Ÿ(cid:2872)(cid:2874) = 5; 

ğ‘— = 8: ğ‘š(cid:2872)(cid:2874) + ğ‘š(cid:2874)(cid:2876) < ğ‘š(cid:2872)(cid:2876). Portanto ğ‘š(cid:2872)(cid:2876) = ğ‘š(cid:2872)(cid:2874) + ğ‘š(cid:2874)(cid:2876) = 126 e  ğ‘Ÿ(cid:2872)(cid:2876) =   ğ‘Ÿ(cid:2872)(cid:2874) = 5; 

ï‚·  Para ğ‘– = 5 e 

ğ‘— = 1,2,3,4: ğ‘š(cid:2873)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2873)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 7: ğ‘š(cid:2873)(cid:2874) + ğ‘š(cid:2874)(cid:2875) < ğ‘š(cid:2873)(cid:2875). Portanto ğ‘š(cid:2873)(cid:2875) = ğ‘š(cid:2873)(cid:2874) + ğ‘š(cid:2874)(cid:2875) = 86 e  ğ‘Ÿ(cid:2873)(cid:2875) =   ğ‘Ÿ(cid:2873)(cid:2874) = 6; 

ğ‘— = 8: ğ‘š(cid:2872)(cid:2874) + ğ‘š(cid:2874)(cid:2876) < ğ‘š(cid:2872)(cid:2876). Portanto ğ‘š(cid:2873)(cid:2876) = ğ‘š(cid:2873)(cid:2874) + ğ‘š(cid:2874)(cid:2876) = 65 e  ğ‘Ÿ(cid:2873)(cid:2876) =   ğ‘Ÿ(cid:2873)(cid:2874) = 6; 

ï‚·  Para ğ‘– = 7 e 

ğ‘— = 1,2,8: ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2875)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 3: ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:2871) < ğ‘š(cid:2875)(cid:2871). Portanto ğ‘š(cid:2875)(cid:2871) = ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:2871) = 212 e  ğ‘Ÿ(cid:2875)(cid:2872) =   ğ‘Ÿ(cid:2875)(cid:2874) = 6; 

ğ‘— = 4: ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:2872) < ğ‘š(cid:2875)(cid:2872). Portanto ğ‘š(cid:2875)(cid:2872) = ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:2872) = 138 e  ğ‘Ÿ(cid:2875)(cid:2872) =   ğ‘Ÿ(cid:2875)(cid:2874) = 6; 

ğ‘— = 5: ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:2873) < ğ‘š(cid:2875)(cid:2873). Portanto ğ‘š(cid:2875)(cid:2873) = ğ‘š(cid:2875)(cid:2874) + ğ‘š(cid:2874)(cid:2873) = 86 e  ğ‘Ÿ(cid:2875)(cid:2873) =   ğ‘Ÿ(cid:2875)(cid:2874) = 6; 

ï‚·  Para ğ‘– = 8 e 

ğ‘— = 1,2,7: ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:3037) > ğ‘š(cid:2875)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 3: ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:2871) < ğ‘š(cid:2876)(cid:2871). Portanto ğ‘š(cid:2876)(cid:2871) = ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:2871) = 191 e  ğ‘Ÿ(cid:2876)(cid:2871) =   ğ‘Ÿ(cid:2876)(cid:2874) = 6; 

ğ‘— = 4: ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:2872) < ğ‘š(cid:2876)(cid:2872). Portanto ğ‘š(cid:2876)(cid:2872) = ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:2872) = 117 e  ğ‘Ÿ(cid:2876)(cid:2872) =   ğ‘Ÿ(cid:2876)(cid:2874) = 6; 

ğ‘— = 5: ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:2873) < ğ‘š(cid:2876)(cid:2873). Portanto ğ‘š(cid:2876)(cid:2873) = ğ‘š(cid:2876)(cid:2874) + ğ‘š(cid:2874)(cid:2873) = 65e  ğ‘Ÿ(cid:2876)(cid:2873) =   ğ‘Ÿ(cid:2876)(cid:2874) = 6; 

3Âº Passo: Como ğ‘˜ = 6 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo.  

Figura 58 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 6Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

 
 
 
1Âº Passo: min(ğ‘‰) = 7. ExcluÃ­mos o vÃ©rtice de ğ‘‰:  ğ‘‰ = {8} 

7Âª IteraÃ§Ã£o 

2Âº Passo: 

Figura 59 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 7Âª iteraÃ§Ã£o. 

66 

Fonte: O autor, 2018 

ï‚·  Para ğ‘– = 1 e 

ğ‘— = 2,8: ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2869)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 3: ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2871) < ğ‘š(cid:2869)(cid:2871). Portanto ğ‘š(cid:2869)(cid:2871) = ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2871) = 251 e  ğ‘Ÿ(cid:2869)(cid:2871) =   ğ‘Ÿ(cid:2869)(cid:2875) = 7; 

ğ‘— = 4: ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2872) < ğ‘š(cid:2869)(cid:2872). Portanto ğ‘š(cid:2869)(cid:2872) = ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2872) = 177 e  ğ‘Ÿ(cid:2869)(cid:2872) =   ğ‘Ÿ(cid:2869)(cid:2875) = 7; 

ğ‘— = 5: ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2873) < ğ‘š(cid:2869)(cid:2873). Portanto ğ‘š(cid:2869)(cid:2873) = ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2873) = 125 e  ğ‘Ÿ(cid:2869)(cid:2873) =   ğ‘Ÿ(cid:2869)(cid:2875) = 7; 

ğ‘— = 6: ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2874) < ğ‘š(cid:2869)(cid:2874). Portanto ğ‘š(cid:2869)(cid:2874) = ğ‘š(cid:2869)(cid:2875) + ğ‘š(cid:2875)(cid:2874) = 87 e  ğ‘Ÿ(cid:2869)(cid:2874) =   ğ‘Ÿ(cid:2869)(cid:2875) = 7; 

ï‚·  Para ğ‘– = 2 e 

ğ‘— = 1,3,4,5,8: ğ‘š(cid:2870)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2870)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 5: ğ‘š(cid:2870)(cid:2875) + ğ‘š(cid:2875)(cid:2873) < ğ‘š(cid:2870)(cid:2873). Portanto ğ‘š(cid:2870)(cid:2873) = ğ‘š(cid:2870)(cid:2875) + ğ‘š(cid:2875)(cid:2873) = 206 e  ğ‘Ÿ(cid:2870)(cid:2873) =   ğ‘Ÿ(cid:2870)(cid:2875) = 1; 

ğ‘— = 6: ğ‘š(cid:2870)(cid:2875) + ğ‘š(cid:2875)(cid:2874) < ğ‘š(cid:2870)(cid:2874). Portanto ğ‘š(cid:2870)(cid:2874) = ğ‘š(cid:2870)(cid:2875) + ğ‘š(cid:2875)(cid:2874) = 168 e  ğ‘Ÿ(cid:2870)(cid:2875) =   ğ‘Ÿ(cid:2870)(cid:2875) = 1; 

ï‚·  Para ğ‘– = 3 e 

ğ‘— = 1: ğ‘š(cid:2871)(cid:2875) + ğ‘š(cid:2875)(cid:2869) < ğ‘š(cid:2871)(cid:2869). Portanto ğ‘š(cid:2871)(cid:2869) = ğ‘š(cid:2871)(cid:2875) + ğ‘š(cid:2875)(cid:2869) = 186 e  ğ‘Ÿ(cid:2871)(cid:2869) =   ğ‘Ÿ(cid:2871)(cid:2875) = 6; 

ğ‘— = 2,4,5,6,8: ğ‘š(cid:2871)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2871)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ï‚·  Para ğ‘– = 4 e 

ğ‘— = 1: ğ‘š(cid:2872)(cid:2875) + ğ‘š(cid:2875)(cid:2869) < ğ‘š(cid:2872)(cid:2869). Portanto ğ‘š(cid:2872)(cid:2869) = ğ‘š(cid:2872)(cid:2875) + ğ‘š(cid:2875)(cid:2869) = 186 e  ğ‘Ÿ(cid:2872)(cid:2869) =   ğ‘Ÿ(cid:2872)(cid:2875) = 6; 

ğ‘— = 2,3,5,6,8: ğ‘š(cid:2872)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2871)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ï‚·  Para ğ‘– = 5 e 

ğ‘— = 1: ğ‘š(cid:2873)(cid:2875) + ğ‘š(cid:2875)(cid:2869) < ğ‘š(cid:2873)(cid:2869). Portanto ğ‘š(cid:2873)(cid:2869) = ğ‘š(cid:2873)(cid:2875) + ğ‘š(cid:2875)(cid:2869) = 186 e  ğ‘Ÿ(cid:2873)(cid:2869) =   ğ‘Ÿ(cid:2873)(cid:2875) = 5; 

ğ‘— = 2: ğ‘š(cid:2873)(cid:2875) + ğ‘š(cid:2875)(cid:2870) < ğ‘š(cid:2873)(cid:2870). Portanto ğ‘š(cid:2873)(cid:2870) = ğ‘š(cid:2873)(cid:2875) + ğ‘š(cid:2875)(cid:2869) = 206 e  ğ‘Ÿ(cid:2873)(cid:2870) =   ğ‘Ÿ(cid:2873)(cid:2875) = 5; 

ğ‘— = 3,4,6,8: ğ‘š(cid:2873)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2873)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

 
 
 
67 

ï‚·  Para ğ‘– = 6 e 

ğ‘— = 1: ğ‘š(cid:2874)(cid:2875) + ğ‘š(cid:2875)(cid:2869) < ğ‘š(cid:2874)(cid:2869). Portanto ğ‘š(cid:2874)(cid:2869) = ğ‘š(cid:2874)(cid:2875) + ğ‘š(cid:2875)(cid:2869) = 87 e  ğ‘Ÿ(cid:2874)(cid:2869) =   ğ‘Ÿ(cid:2874)(cid:2875) = 7; 

ğ‘— = 2: ğ‘š(cid:2874)(cid:2875) + ğ‘š(cid:2875)(cid:2870) < ğ‘š(cid:2873)(cid:2870). Portanto ğ‘š(cid:2874)(cid:2870) = ğ‘š(cid:2874)(cid:2875) + ğ‘š(cid:2875)(cid:2870) = 168 e  ğ‘Ÿ(cid:2874)(cid:2870) =   ğ‘Ÿ(cid:2874)(cid:2875) = 7; 

ğ‘— = 3,4,5,8: ğ‘š(cid:2873)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2873)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ï‚·  Para ğ‘– = 8 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2876)(cid:2875) + ğ‘š(cid:2875)(cid:3037) > ğ‘š(cid:2876)(cid:3037), para todo ğ‘— = 1,2,3,4,5,6,8; 

3Âº Passo: Como ğ‘˜ = 7 â‰  8 o algoritmo prossegue e retornamos ao 1Âº Passo.  

Figura 60 â€“ Matrizes de Manejo e de Roteamento apÃ³s a 7Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

1Âº Passo: min(ğ‘‰) = 8. ExcluÃ­mos o vÃ©rtice de ğ‘‰:  ğ‘‰ = {} 

8Âª IteraÃ§Ã£o 

2Âº Passo: 

Figura 61 â€“ Matrizes preparadas para o inÃ­cio das comparaÃ§Ãµes da 8Âª iteraÃ§Ã£o. 

Fonte: O autor, 2018 

ï‚·  Para ğ‘– = 1 e 

ğ‘— = 2,7: ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2875) > ğ‘š(cid:2869)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 3: ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2871) < ğ‘š(cid:2869)(cid:2871). Portanto ğ‘š(cid:2869)(cid:2871) = ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2871) = 219 e  ğ‘Ÿ(cid:2869)(cid:2871) =   ğ‘Ÿ(cid:2869)(cid:2876) = 8; 

 
 
 
 
 
 
68 

ğ‘— = 4: ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2872) < ğ‘š(cid:2869)(cid:2872). Portanto ğ‘š(cid:2869)(cid:2872) = ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2872) = 205 e  ğ‘Ÿ(cid:2869)(cid:2872) =   ğ‘Ÿ(cid:2869)(cid:2876) = 8; 

ğ‘— = 5: ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2873) < ğ‘š(cid:2869)(cid:2873). Portanto ğ‘š(cid:2869)(cid:2873) = ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2873) = 93 e  ğ‘Ÿ(cid:2869)(cid:2873) =   ğ‘Ÿ(cid:2869)(cid:2876) = 8; 

ğ‘— = 6 ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2873) < ğ‘š(cid:2869)(cid:2874). Portanto ğ‘š(cid:2869)(cid:2874) = ğ‘š(cid:2869)(cid:2876) + ğ‘š(cid:2876)(cid:2874) = 55 e  ğ‘Ÿ(cid:2869)(cid:2874) =   ğ‘Ÿ(cid:2869)(cid:2876) = 8; 

ï‚·  Para ğ‘– = 2 e 

ğ‘— = 1,3,7: ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:3037) > ğ‘š(cid:2870)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 4: ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:2872) < ğ‘š(cid:2870)(cid:2872). Portanto ğ‘š(cid:2870)(cid:2872) = ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:2872) = 216 e  ğ‘Ÿ(cid:2870)(cid:2872) =   ğ‘Ÿ(cid:2870)(cid:2876) = 1; 

ğ‘— = 5: ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:2873) < ğ‘š(cid:2870)(cid:2873). Portanto ğ‘š(cid:2870)(cid:2873) = ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:2873) = 164 e  ğ‘Ÿ(cid:2870)(cid:2873) =   ğ‘Ÿ(cid:2870)(cid:2876) = 1; 

ğ‘— = 6: ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:2874) < ğ‘š(cid:2870)(cid:2874). Portanto ğ‘š(cid:2870)(cid:2874) = ğ‘š(cid:2870)(cid:2876) + ğ‘š(cid:2876)(cid:2874) = 126 e  ğ‘Ÿ(cid:2870)(cid:2874) =   ğ‘Ÿ(cid:2870)(cid:2876) = 1; 

ï‚·  Para ğ‘– = 3 e 

ğ‘— = 2,4,5,6,7: ğ‘š(cid:2871)(cid:2876) + ğ‘š(cid:2876)(cid:3037) > ğ‘š(cid:2871)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 1: ğ‘š(cid:2871)(cid:2876) + ğ‘š(cid:2876)(cid:2869) < ğ‘š(cid:2871)(cid:2869). Portanto ğ‘š(cid:2871)(cid:2869) = ğ‘š(cid:2871)(cid:2876) + ğ‘š(cid:2876)(cid:2869) = 203 e  ğ‘Ÿ(cid:2871)(cid:2872) =   ğ‘Ÿ(cid:2871)(cid:2876) = 6; 

ï‚·  Para ğ‘– = 4 e 

ğ‘— = 2,3,5,6,7: ğ‘š(cid:2872)(cid:2876) + ğ‘š(cid:2876)(cid:3037) > ğ‘š(cid:2872)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 1: ğ‘š(cid:2872)(cid:2876) + ğ‘š(cid:2876)(cid:2869) < ğ‘š(cid:2872)(cid:2869). Portanto ğ‘š(cid:2872)(cid:2869) = ğ‘š(cid:2872)(cid:2876) + ğ‘š(cid:2876)(cid:2869) = 154 e  ğ‘Ÿ(cid:2872)(cid:2869) =   ğ‘Ÿ(cid:2872)(cid:2876) = 5; 

ï‚·  Para ğ‘– = 5 e 

ğ‘— = 3,4,6,7: ğ‘š(cid:2873)(cid:2876) + ğ‘š(cid:2876)(cid:3037) > ğ‘š(cid:2873)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 1: ğ‘š(cid:2873)(cid:2876) + ğ‘š(cid:2876)(cid:2869) < ğ‘š(cid:2873)(cid:2869). Portanto ğ‘š(cid:2873)(cid:2869) = ğ‘š(cid:2873)(cid:2876) + ğ‘š(cid:2876)(cid:2869) = 93 e  ğ‘Ÿ(cid:2873)(cid:2869) =   ğ‘Ÿ(cid:2873)(cid:2876) = 6; 

ğ‘— = 2: ğ‘š(cid:2873)(cid:2876) + ğ‘š(cid:2876)(cid:2870) < ğ‘š(cid:2873)(cid:2870). Portanto ğ‘š(cid:2873)(cid:2870) = ğ‘š(cid:2873)(cid:2876) + ğ‘š(cid:2876)(cid:2870) = 164 e  ğ‘Ÿ(cid:2873)(cid:2870) =   ğ‘Ÿ(cid:2873)(cid:2876) = 6; 

ï‚·  Para ğ‘– = 6 e 

ğ‘— = 3,4,5,7: ğ‘š(cid:2874)(cid:2876) + ğ‘š(cid:2876)(cid:3037) > ğ‘š(cid:2874)(cid:3037) e nÃ£o hÃ¡ nada a fazer; 

ğ‘— = 1: ğ‘š(cid:2874)(cid:2876) + ğ‘š(cid:2876)(cid:2869) < ğ‘š(cid:2874)(cid:2869). Portanto ğ‘š(cid:2874)(cid:2869) = ğ‘š(cid:2874)(cid:2876) + ğ‘š(cid:2876)(cid:2869) = 55 e  ğ‘Ÿ(cid:2874)(cid:2869) =   ğ‘Ÿ(cid:2874)(cid:2876) = 8; 

ğ‘— = 2: ğ‘š(cid:2874)(cid:2876) + ğ‘š(cid:2876)(cid:2870) < ğ‘š(cid:2873)(cid:2870). Portanto ğ‘š(cid:2874)(cid:2870) = ğ‘š(cid:2874)(cid:2876) + ğ‘š(cid:2876)(cid:2870) = 126 e  ğ‘Ÿ(cid:2874)(cid:2870) =   ğ‘Ÿ(cid:2874)(cid:2876) = 8; 

ï‚·  Para ğ‘– = 7 nÃ£o hÃ¡ nada a fazer pois ğ‘š(cid:2875)(cid:2876) + ğ‘š(cid:2876)(cid:3037) > ğ‘š(cid:2875)(cid:3037) para ğ‘— = 1,2,3,4,5,6; 

3Âº  Passo:  Como  ğ‘˜ = 8  o  algoritmo  cessa.  Na  Figura  62  ilustra  as  matrizes  Manejo  e  de 

Roteamento apÃ³s o tÃ©rmino do algoritmo. 

 
 
 
 
 
 
 
 
 
  
Figura 62 â€“ Matrizes de Manejo e de Roteamento ao fim do algoritmo. 

69 

Finalmente podemos  responder a pergunta do item b) do problema motivador. Vamos 

Fonte: O autor, 2018 

calcular, para cada cidade, a soma das distÃ¢ncias atÃ© todas as outras. 

Figura 63 â€“ Matriz de manejo e soma dos menores caminhos. 

Dessa forma, a cidade que Ã© menos distante de todas as outras Ã© a indicada pelo rÃ³tulo 6, ou seja, 

Fonte: O autor, 2018 

Itu. 

Figura 64 â€“ Melhor escolha para alocar o centro de distribuiÃ§Ã£o. 

Fonte: O autor, 2018 

Embora o desenvolvimento do algoritmo, indicando todas as comparaÃ§Ãµes, seja longo, 

sua execuÃ§Ã£o num quadro ou numa apresentaÃ§Ã£o em slides Ã© relativamente mais curta. 

 
 
 
 
 
 
5 CONSIDERAÃ‡Ã•ES FINAIS 

70 

Esse trabalho foi pensado de maneira a oferecer aos alunos um problema contextualizado 

em  que  eles  possam  aplicar  um  conceito  matemÃ¡tico  para  resolvÃª-lo.  Contudo,  qualquer 

problema que envolva determinar o caminho mÃ­nimo em um grafo pode ser utilizado em seu 

lugar.  

Os tÃ³picos apresentados na Ãºltima parte desse trabalho foram construÃ­dos de maneira a 

dar uma direÃ§Ã£o na conduÃ§Ã£o de uma oficina sobre o assunto. Infelizmente, devido a problemas 

com o tempo, nÃ£o foi possÃ­vel aplica-los numa sala de aula, o que limitou de maneira significativa 

sua construÃ§Ã£o. Esperamos uma futura oportunidade para aplicaÃ§Ã£o do mesmo e, de acordo com 

os resultados colhidos, remodela-los. 

Ã‰ possÃ­vel trabalhar em paralelo com a disciplina de informÃ¡tica educativa e implementar 

ambos  os  algoritmos  no  ambiente  Visualg,  utilizando  os  respectivos  fluxogramas  e  pseudo-

cÃ³digos descritos nos apÃªndices. Acreditamos que dessa forma o aluno consolidarÃ¡ o pensamento 

algorÃ­tmico e uma nova janela de opÃ§Ãµes acadÃªmicas serÃ¡ aberta para ele. 

 
 
 
 
 
  
71 

REFERÃŠNCIAS 

BACKES, AndrÃ©. Algoritmos e Fluxogramas. Notas de Aula. 

BOAVENTURA,  P.  Oswaldo;  JURKIEWICZ,  S.  Grafos:  IntroduÃ§Ã£o  e  PrÃ¡tica.  2  ed.  SÃ£o 
Paulo: Blucher, 2011. 

BOYER, Carl B. HistÃ³ria da MatemÃ¡tica. TraduÃ§Ã£o de Elza Gomide. 2Âª ed. SÃ£o Paulo: Edgard 
BlÃ¼cher, 1996. 

DIESTEL, R. Graph Theory. 2 ed. New York: Sping-Verlag, 2000. 

DIJKSTRA,  Edsger  W.;  MISA,  Thomas  J.  An  Interwiew  with  Edsger  W.  Dijkstra. 
Comunications of the ACM, v. 53, n. 8, p. 41-47, ago. 2010. 

BARROS,  Edson;  PAMBOUKIAN,  SÃ©rgio;  ZAMBONI,  Lincoln,  Algoritmo  de  Dijkstra: 
Apoio diÃ¡tico na implementaÃ§Ã£o, simulaÃ§Ã£o e utilizaÃ§Ã£o computacional, SÃ£o Paulo, 2007.   

FARIAS,  Gilberto;  MEDEIROS,  Eduardo  Santana.  IntroduÃ§Ã£o  Ã   ComputaÃ§Ã£o,  [S.l.]:  2013.  
VersÃ£o  1.0.  DisponÃ­vel  em  <  http://producao.virtual.ufpb.br/books/gilbertofarias/introducao-a-
computacao-livro/livro/livro.pdf>.  Acesso em: 12 de Janeiro de 2018. 

HAIGH, Thomas. Biographies. IEEE Annals of the History of Computing, p.75-83, Abr./Jun. 
2004. 

SCHIENERMAN, Edward R. MatemÃ¡tica Discreta: Uma introduÃ§Ã£o. TraduÃ§Ã£o de All Tasks. 
1 ed. SÃ£o Paulo: Cengage Learning, 2011. 

 
 
 
 
 
 
 
 
 
 
 
APÃŠNDICE A â€“ FLUXOGRAMA DO ALGORITMO DE DIJKSTRA 

72 

 
 
APÃŠNDICE B â€“ PSEUDOCÃ“DIGO DO ALGORITMO DE DIJKSTRA 

73 

ğ·ğ‘–ğ‘—ğ‘˜ğ‘ ğ‘¡ğ‘Ÿğ‘(ğ‘‰, ğ‘€, ğ‘–, ğ‘“) = (ğ‘‘(ğ‘“), ğ¶)  

O  algoritmo  Ã©  uma  funÃ§Ã£o  que  com  quatro  parÃ¢metros  de  entrada  (o  conjunto  de 

vÃ©rtices, a matriz de manejo do grafo, o vÃ©rtice inicial e o vÃ©rtice final) e dois de saÃ­da 

(a distÃ¢ncia mÃ­nima e o caminho percorrido). 

inÃ­cio 

ğ‘‘(ğ‘–) = 0, ğ‘(ğ‘–) = 0 ğ¹ = {ğ‘–}, ğ´ = ğ‘‰ âˆ’ ğ¹ 

ğ‘‘(ğ‘—) = (cid:3420)

ğ‘š(cid:3036)(cid:3037) ğ‘ ğ‘’ ğ‘š(cid:3036)(cid:3037) â‰  âˆ
âˆ ğ‘ ğ‘’ ğ‘š(cid:3036)(cid:3037) = âˆ , ğ‘(ğ‘—) = (cid:3420)

ğ‘– ğ‘ ğ‘’ ğ‘š(cid:3036)(cid:3037) â‰  âˆ
0 ğ‘ ğ‘’ ğ‘š(cid:3036)(cid:3037) = âˆ

; âˆ€ ğ‘— âˆˆ ğ´ 

ğ‘Ÿ â† ğ‘— | ğ‘šÃ­ğ‘›[ğ‘‘(ğ‘—)], ğ‘— âˆˆ ğ´ 

enquanto ğ‘Ÿ â‰  ğ‘“ fazer 

ğ‘Ÿ â† ğ‘£|ğ‘šÃ­ğ‘›[ğ‘‘(ğ‘—)], ğ‘— âˆˆ ğ´ Busca o vÃ©rtice aberto mais prÃ³ximo da origem. 

ğ¹ â† ğ¹ âˆª {ğ‘Ÿ}      â€Fechaâ€ o vÃ©rtice mais prÃ³ximo da origem. 

ğ´ â† ğ´ âˆ’ {ğ‘Ÿ}       Remove o vÃ©rtice fechado de A. 
ğ‘† â† ğ´ âˆ© ğ‘…(cid:2878)(ğ‘Ÿ)    Cria o conjunto ğ‘† dos vÃ©rtices adjacentes a ğ‘Ÿ que ainda estÃ£o abertos. 

para todo ğ‘  âˆˆ ğ‘† fazer 

ğ‘(cid:3046) = ğ‘šÃ­ğ‘›[ğ‘‘(ğ‘ ), ğ‘‘(ğ‘Ÿ) + ğ‘š(cid:3045)(cid:3046)] âˆ€ ğ‘  âˆˆ ğ‘† Compara as distÃ¢ncias. 
se ğ‘(cid:3046) < ğ‘‘(ğ‘ ) entÃ£o  

ğ‘‘(ğ‘ ) â† ğ‘(cid:3046)   Atualiza o valor da menor distÃ¢ncia. 
ğ‘(ğ‘ ) â† ğ‘Ÿ     Atualiza o parÃ¢metro anterior. 

fim-se 

fim-para todo 

fim-enquanto 

ğ¶ = ( ) 

ğ‘£ â† ğ‘Ÿ 

enquanto ğ‘£ â‰  ğ‘– e ğ‘(ğ‘£) â‰  0 fazer 

ğ¶ â† ğ¶ + (ğ‘£) e ğ‘£ â† ğ‘(ğ‘£)  Insere o vÃ©rtice ğ‘£ no vetor caminho e atualiza ğ‘£. 

fim-enquanto 

se ğ‘£ = ğ‘– entÃ£o 

O caminho mÃ­nimo de ğ‘– atÃ© ğ‘“ existe, mede ğ‘‘(ğ‘“) e Ã© ğ¶. 

NÃ£o existe caminho de ğ‘– atÃ© ğ‘“. 

senÃ£o 

fim-se 

fim 

 
 
 
 
 
 
 
 
 
 
APÃŠNDICE C â€“ FLUXOGRAMA DO ALGORITMO DE FLOYD-WARSHAL 

74 

 
 
 
75 

APÃŠNDICE D â€“ PSEUDOCÃ“DIGO DO ALGORITMO DE FLOYD-WARSHALL  

ğ‘“ğ‘™ğ‘œğ‘¦ğ‘‘ğ‘¤ğ‘ğ‘Ÿğ‘ â„ğ‘ğ‘™ğ‘™(ğ‘€, ğ‘…, ğ´) = (ğ‘€âˆ—, ğ‘…âˆ—, ğ¶) 

inÃ­cio  

ğ‘€(cid:2868) â† ğ‘€, ğ‘…(cid:2868) â† ğ‘… 

para ğ‘˜ = 1, . . . , ğ‘› fazer 

O  Algoritmo  tem  como  entradas  a  matriz  de 

manejo,  a  matriz  de  roteamento  e  um  conjunto  de  pares 

ordenados para os quais se deseja saber o menor caminho. 

ğ‘€(cid:3038) â† ğ‘€(cid:3038)(cid:2879)(cid:2869) e ğ‘…(cid:3038) â† ğ‘…(cid:3038)(cid:2879)(cid:2869)  Cria as matrizes de manejo e de roteamento que serÃ£o atualizadas. 

para todo ğ‘– â‰  ğ‘˜ fazer 

para todo ğ‘— â‰  ğ‘˜ fazer 

Se ğ‘š(cid:3036)(cid:3038)

(cid:3038) + ğ‘š(cid:3038)(cid:3037)

(cid:3038) < ğ‘š(cid:3036)(cid:3037)

(cid:3038)  entÃ£o     

(cid:3038)  
(cid:3038) + ğ‘š(cid:3038)(cid:3037)

(cid:3038) â† ğ‘š(cid:3036)(cid:3038)
ğ‘š(cid:3036)(cid:3037)
(cid:3038)  
(cid:3038) â† ğ‘Ÿ(cid:3036)(cid:3038)
ğ‘Ÿ(cid:3036)(cid:3037)

fim-se 

fim-para todo 

Compara  se  a  distÃ¢ncia  do  vÃ©rtice    ğ‘–  ao  vÃ©rtice  ğ‘— 

tomando ğ‘˜ como intermediÃ¡rio Ã© menor que a distÃ¢ncia 

existente  entre  esses  vÃ©rtices.  Em  caso  afirmativo 

atualiza as matrizes de manejo e de roteamento. 

fim-para todo 

fim-para 

ğ‘€âˆ— â† ğ‘€(cid:3041) , ğ‘…âˆ— â† ğ‘…(cid:3041) 

se ğ´ = {} fazer 

ğ¶ = {}    

senÃ£o 

para todo (ğ‘¥, ğ‘¦) âˆˆ ğ´ fazer 

âˆ—  
ğ‘ â† ğ‘Ÿ(cid:3051)(cid:3052)

ğ¶(cid:3051)(cid:3052) = (ğ‘¥, ğ‘) 

enquanto ğ‘ â‰  ğ‘› fazer 

âˆ—  
ğ‘ â† ğ‘Ÿ(cid:3051)(cid:3030)

ğ¶(cid:3051)(cid:3052) â† (ğ¶(cid:3051)(cid:3052), ğ‘) 

fim-enquanto 

fim-para-todo 

ğ¶ = {ğ¶(cid:3051)(cid:3052), âˆ€ (ğ‘¥, ğ‘¦) âˆˆ ğ´} 

fim-se 

fim 

Para todo par (ğ‘¥, ğ‘¦) em ğ´, descreve cria o vetor ğ¶(cid:3051)(cid:3052) que 

contÃ©m os rÃ³tulos dos vetores que compÃµe o caminho 

mÃ­nimo entre ğ‘¥ e ğ‘¦. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
76 

APÃŠNDICE  F  â€“  SITUAÃ‡Ã•ES  MOTIVADORAS  PARA  A  INTRODUÃ‡ÃƒO  DO 

CONCEITO DE ALGORITMOS 

 SituaÃ§Ã£o A: â€œComo preparar uma pipoca?â€ 

Num primeiro momento, com a ajuda dos alunos, descreve-se o passo a passo do preparo de uma 
pipoca. Os passos sugeridos pelos alunos devem ser escritos no quadro, em ordem e ser o mais 
claro  possÃ­vel.  Abaixo  temos  um  exemplo  de  uma  lista  de  passos  para  essa  tarefa. 
Preparo de uma Pipoca Salgada 

InÃ­cio 

1Âº Passo: Pegar milho de pipoca e uma pipoqueira no armÃ¡rio; 

2Âº Passo: Adicionar o milho de pipoca e Ã³leo Ã  pipoqueira. Levar pipoqueira ao fogo; 

3Âº Passo: Mexer a manivela da pipoqueira atÃ© que parem os estouros; 

4Âº Passo: Servir a pipoca com sal a gosto. 

Fim 

SituaÃ§Ã£o B: â€œNa escola de Pedro o ano letivo Ã© dividido em trÃªs trimestres. Para compor a MÃ©dia 
Anual (MA) calcula-se a mÃ©dia ponderada das trÃªs notas, atribuindo-se peso 3 Ã s duas primeiras 
e peso 4 Ã  Ãºltima. Se a MÃ©dia Anual for maior ou igual a 7, o aluno Ã© aprovado na disciplina, 
caso  contrÃ¡rio,  o  aluno  deverÃ¡  fazer  a  AvaliaÃ§Ã£o  Final  (AF).  Calcula-se  entÃ£o  a  MÃ©dia  Final 
(MF), obtida pela mÃ©dia ponderada entre a MÃ©dia Anual e a AvaliaÃ§Ã£o Final, com pesos 2 e 3 
respectivamente. Se a mÃ©dia final Ã© maior ou igual a 5, o aluno Ã© aprovado, caso contrÃ¡rio ele Ã© 
retido naquela disciplina. â€ 

Algoritmo Verificador de AprovaÃ§Ã£o/ReprovaÃ§Ã£o 

InÃ­cio 

1Âº Passo: Calcula-se a MÃ©dia Anual (MA) das notas dos trÃªs trimestres; 

ğ‘€ğ´ =

3 âˆ— ğ‘ğ‘œğ‘¡ğ‘ ğ¼ + 3 âˆ— ğ‘ğ‘œğ‘¡ğ‘ ğ¼ğ¼ + 4 âˆ— ğ‘ğ‘œğ‘¡ğ‘ ğ¼ğ¼ğ¼
10

2Âº Passo: Se ğ‘€ğ´ â‰¥ 7,0 o algoritmo cessa e o aluno estÃ¡ aprovado. Caso contrÃ¡rio o aluno deverÃ¡ 

fazer a AvaliaÃ§Ã£o Final (AF).  VÃ¡ para o 3Âº passo. 

3Âº Passo: Calcula-se a mÃ©dia final (MF) 

4Âº Passo: Se ğ‘€ğ¹ â‰¥ 5,0 o aluno Ã© aprovado. Caso contrÃ¡rio ele Ã© reprovado. 

ğ‘€ğ¹ =

3 âˆ— ğ‘€ğ´ + 2 âˆ— ğ‘€ğ¹
5

Fim 

 
 
 
 
  
 
APÃŠNDICE G â€“ RESUMO HISTÃ“RICO DO SURGIMENTO DOS ALGORITMOS 

77 

A origem da palavra remete ao sobrenome do matemÃ¡tico persa Mohammed Ibn Musa 

al-Khwarizmi e seu significado encerra a descriÃ§Ã£o sistemÃ¡tica da maneira de se realizar alguma 

tarefa (BOYER, 1964). Dessa forma, qualquer conjunto finito de instruÃ§Ãµes que resolvem um 

problema Ã© um algoritmo. A definiÃ§Ã£o inclui nÃ£o apenas algoritmos quem envolvam cÃ¡lculos 

(como  o  Algoritmo  de  Euclides  para  obter  o  mÃ¡ximo  divisor  comum  de  um  nÃºmero)  mas 

qualquer  conjunto  finito  de  regras  que  possa  ser  executado  por  uma  pessoa  contanto  que  ela 

possua  o  tempo  necessÃ¡rio  para  fazÃª-lo.  Essa  definiÃ§Ã£o  abarca  todos  os  programas  de 

computadores existentes. Contudo, a implementaÃ§Ã£o de algoritmos em mÃ¡quinas ocorreu bem 

antes do surgimento de computadores como os conhecemos hoje. 

O primeiro registro que se tem da implementaÃ§Ã£o de um algoritmo remonta Ã  revoluÃ§Ã£o 

industrial. Em 1801, o mecÃ¢nico e tecelÃ£o francÃªs Joseph Marie Jacquard (1752-1834) construiu 

um tear mecÃ¢nico controlado por grandes cartÃµes perfurados. 

Influenciado  por  Jacquard,  o  matemÃ¡tico  inglÃªs  Charles  Babagge  propÃ´s  em  1837  a 

construÃ§Ã£o  de  uma  mÃ¡quina  de  propÃ³sito  mais  genÃ©rico  chamada  MÃ¡quina  AnalÃ­tica.  Ele 

percebeu que poderia utilizar os cartÃµes perfurados para armazenar ideias abstratas ou nÃºmeros, 

que poderiam ser acessados posteriormente, o que chamamos hoje num computador de memÃ³ria. 

Infelizmente a MÃ¡quina AnalÃ­tica nunca foi construÃ­da. 

Durante o perÃ­odo em que Babagge tentava construir a MÃ¡quina AnalÃ­tica, Ada Byron, 

filha de Lord Byron, mostrou bastante interesse pelo projeto e propÃ´s diversas melhorias como 

relata Farias: 

A condessa de Lovelace, Ada Byron, se interessou pela mÃ¡quina analÃ­tica de 
Babbage e se comunicava com ele atravÃ©s de cartas e encontros. Ela passou a 
escrever programas que  a mÃ¡quina  poderia ser  capaz  de executar, caso fosse 
construÃ­da. Ela foi a primeira a reconhecer a necessidade de loops e sub-rotinas. 
Por  esta  contribuiÃ§Ã£o,  Ada  ficou  reconhecida  na  histÃ³ria  como  a  primeira 
programadora. (FARIAS; MEDEIROS, 2013, p. 9) 

Na primeira metade do sÃ©culo XX, Alan Turing formalizou o conceito de algoritmo como 

o  conhecemos  hoje  atravÃ©s  de  uma  invenÃ§Ã£o  sua,  a  MÃ¡quina  de  Turing.  Durante  a  Segunda 

Guerra  Mundial,  foi  chefe  do  setor  responsÃ¡vel  por  decifrar  a  mÃ¡quina  de criptografia  alemÃ£ 

Enigma.  Suas  contribuiÃ§Ãµes  delinearam  o  campo  da  ciÃªncia  da  computaÃ§Ã£o,  sendo  aclamado 

como o pai da ciÃªncia da computaÃ§Ã£o. 

 
 
 
 
