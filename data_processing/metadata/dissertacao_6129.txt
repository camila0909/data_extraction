Universidade Federal de Sergipe
PR ´O-REITORIA DE P ´OS-GRADUAC¸ ˜AO E PESQUISA
PROGRAMA DE P ´OS-GRADUAC¸ ˜AO EM MATEM ´ATICA
MESTRADO PROFISSIONAL EM MATEM ´ATICA
EM REDE NACIONAL - PROFMAT

Introdu¸c˜ao `a Matem´atica
do Criptossistema RSA

Por

Welington Batista Luz

Mestrado Proﬁssional em Matem´atica - S˜ao Crist´ov˜ao - SE

Abril de 2013

Universidade Federal de Sergipe
PR ´O-REITORIA DE P ´OS-GRADUAC¸ ˜AO E PESQUISA
PROGRAMA DE P ´OS-GRADUAC¸ ˜AO EM MATEM ´ATICA
MESTRADO PROFISSIONAL EM MATEM ´ATICA
EM REDE NACIONAL - PROFMAT

Welington Batista Luz

Introdu¸c˜ao `a Matem´atica do Criptossistema RSA

Trabalho apresentado ao Departamento de Matem´atica da

Universidade Federal de Sergipe como requisito ﬁnal para a

obten¸c˜ao do t´ıtulo de Mestre em Matem´atica pelo PROFMAT

Orientador: Profo. Dr. Kalasas Vasconcelos de Ara´ujo

S˜ao Crist´ov˜ao - Sergipe

Abril de 2013

Catalograﬁca.png

i

ii

Sum´ario

Dedicat´oria

Agradecimentos

Ep´ıgrafe

Resumo

Abstract

Introdu¸c˜ao

1 Criptograﬁa

1.1 O que ´e Criptograﬁa? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 Objetivos da Criptograﬁa

. . . . . . . . . . . . . . . . . . . . . . . . . . .

1.3 Criptograﬁa moderna . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.4 Sistema Criptogr´aﬁco Assim´etrico . . . . . . . . . . . . . . . . . . . . . . .

2 Teoria dos N´umeros para o RSA

2.1 Algoritmos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2 Divis˜ao com resto e divisibilidade . . . . . . . . . . . . . . . . . . . . . . .

v

vi

viii

ix

x

1

3

3

4

6

8

9

9

9

2.3 N´umeros primos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2.4 Expans˜ao bin´aria de um n´umero inteiro

. . . . . . . . . . . . . . . . . . . 12

2.5 Algoritmo Euclidiano Estendido . . . . . . . . . . . . . . . . . . . . . . . . 12

2.6 No¸c˜oes de Aritm´etica Modular . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.6.1 Congruˆencia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.6.2

2.6.3

Sistema Completo de Restos . . . . . . . . . . . . . . . . . . . . . . 16

Invers˜ao m´odulo n . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

2.6.4 Exponencia¸c˜ao r´apida . . . . . . . . . . . . . . . . . . . . . . . . . 17

2.7 Pequeno Teorema de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3 O Algoritmo RSA

20

3.1 Generaliza¸c˜ao de Euler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

iii

3.2 A magia do RSA – Como a mensagem codiﬁcada por Alice ´e recuperada

por Bob . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.3

Implementa¸c˜ao matem´atica do Algoritmo RSA . . . . . . . . . . . . . . . . 22

3.3.1 Pr´e-codiﬁca¸c˜ao do RSA . . . . . . . . . . . . . . . . . . . . . . . . 22

3.3.2 Codiﬁca¸c˜ao do RSA . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.4 Decodiﬁca¸c˜ao do RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

4 Implementa¸c˜ao RSA com MAXIMA

5 Seguran¸ca e Criptoan´alise do RSA

27

30

5.1 Algoritmo da fatora¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

5.2 Eﬁciˆencia do Algoritmo da fatora¸c˜ao . . . . . . . . . . . . . . . . . . . . . 32

6 Encontrando primos - Testes de primalidade

A Comandos do MAXIMA para o RSA

B Tabela ASCII imprim´ıveis mai´usculos

Referˆencias Bibliogr´aﬁcas

33

36

37

38

iv

Dedicat´oria

Dedico este trabalho a trˆes pessoas muito especiais:

Meu pai, Eugˆenio Batista Luz (in memorian).

Minha m˜ae, Judite Cˆandido Santos (in memorian).

Com a simplicidade de agricultores, eles me ensinaram que ´e poss´ıvel vencer o jogo da

vida e realizar os sonhos sem perder a alma! Eternas saudades!

Meu avˆo materno, Manoel Cˆandido Santos (in memorian).

Um agricultor, vaqueiro e canoeiro forte e obstinado, de quem eu muito me orgulho!

Welington Batista Luz

abril de 2013

v

Agradecimentos

Agrade¸co a Deus por tudo! Deus existe, porque a Matem´atica existe!

Agrade¸co `a CAPES - Coordena¸c˜ao de Aperfeicoamento de Pessoal de Nivel Superior,

pelo ﬁnanciamento do PROFMAT.

`A SBM - Sociedade Brasileira de Matem´atica, pela competente coordena¸c˜ao do pro-

grama, nas pessoas do Prof. Hil´ario Alencar e do Prof. Marcelo Viana.

Ao IMPA - Instituto de Matem´atica Pura e Aplicada, pelo apoio humano e instituci-

onal ao PROFMAT.

`A UFS - Universidade Federal de Sergipe, por ter apoiado e se integrado ao programa,
disponibilizando sua estrutura humana, material e log´ıstica. Em especial, aos competentes

e dedicados professores do Departamento de Matem´atica da UFS: Paulo Rabelo, Fabio

dos Santos, Naldisson dos Santos, Almir Rog´erio Silva Santos, Anderson dos Santos,
´Eder Mateus, Evilson da Silva Vieira, Arl´ucio Viana, Wagner Ferreira Santos, Natanael
Oliveira Dantas, Marco Aur´elio Guimar˜aes Monteiro, Danilo Felizardo Barbosa, e Kalasas

Vasconcelos de Ara´ujo, este especialmente por aceitar me orientar neste trabalho. E

aos professores Rodrigo Godim Neves da UFRPE e Zaqueu Alves Ramos da UFS, por

aceitarem participar da minha banca examinadora.

Ao Povo de Aracaju, ent˜ao representado pelo prefeito Edvaldo Nogueira e pelo Se-

cret´ario Municipal de Educa¸c˜ao e Desporto Antˆonio Bitencourt J´unior, pela licen¸ca para

cursar o PROFMAT.

Aos amigos Adailton Novais, Rodolfo Sampaio Cassaca, Geilson Le˜ao e Marcone Au-

gusto, cujas inteligˆencias e cultura cient´ıﬁca n˜ao comprometem a educa¸c˜ao e a simplici-

dade! Pela ajuda e pela torcida!

Ao amigo Leopoldo Ramos de Oliveira, companheiro de duras jornadas! Pelo exemplo,

e o apoio moral e afetivo.

Ao amigo Gerson Silva ´Avila, companheiro de dur´ıssimas jornadas e grandes alegrias.
Pela torcida e pelo incentivo sincero! Tamb´em `a sua esposa Eut´ımia Nascimento Santos
´Avila e sua ﬁlha e minha aﬁlhada Laura ´Avila (Laurinha). E tamb´em a sua m˜ae dona
Maria Silva `Avila pelo carinho e considera¸c˜ao de sempre!

Ao amigo e conterrˆaneo Francisco Ara´ujo Filho e `a sua noiva Marinalva dos Santos,

pelo companheirismo e pela torcida em todos os desaﬁos.

Ao amigo e conterrˆaneo Paulo Anderson Santana Rocha, pela conﬁan¸ca, companhei-

vi

rismo, torcida e incentivo!

Aos amigos e conterrˆaneos Isaias Santos Vilela e Ana Vilela,

Edivaldo Santos e

Marilene Santos Vilela, pela considera¸c˜ao e torcida sempre.

Aos amigos Ismael Ferreira e sua esposa Lucicleide Cavalcante Ferreira, pela torcida

e receptividade calorosa.

Ao amigo Edmundo Lisboa de Ara´ujo e sua esposa F´atima Ara´ujo Lisboa, por ter

acreditado em mim desde o primeiro encontro. Vocˆe ´e magnˆanimo!

`A fam´ılia Sim˜oes, na pessoa da minha sogra D. Pureza Sim˜oes, em especial `a minha
esposa Vˆania Alves Sim˜oes, que suportou com paciˆencia durante dois anos o efeito cola-

teral do PROFMAT. Sem o seu carinho e compreens˜ao as coisas teriam sido bem mais

dif´ıceis. Obrigado por tudo! Te amo! E a Thiago Sim˜oes, seu ﬁlho e meu enteado, pelo

respeito e torcida.

`A minha prima e madrinha por ado¸c˜ao Maria Jos´e Maia de Santana, uma pessoa
a quem eu sou muito grato pelo carinho nos tempos dif´ıceis! E tamb´em a seu marido

Joaquim Reis de Santana e seus ﬁlhos Marize Maia de Santana (in memorian), K´atia

Cilene Maia de Santana, Joaquim Maia de Santana Filho e M´ario Reis Maia de Santana.

Apesar da distˆancia, estamos juntos! Sei que vocˆes torcem por mim!

`A minha irm˜a Maria Jos´e Batista Luz de Lima e seu esposo Jo˜ao Jos´e de Lima. A
meu irm˜ao Antonio Batista Luz, o meu primeiro professor de Matem´atica! E a sua esposa

Isabel Cristina Correia Luz e ﬁlhos Robson Correira Luz e Rodrigo Correia Luz. Obrigado

pelo incentivo, pela ajuda e pelo carinho!

A todos colegas da EMEF Olga Ben´ario do Munic´ıpio de Aracaju-SE, pela torcida,

e aos colegas da DFDA-SE-MDA que tiveram que suportar minhas lamenta¸c˜oes diaria-

mente. Obrigado pela paciˆencia! E tamb´em pela parceria e torcida!

A todos os meus mestres de hoje e de ontem, porque eles s˜ao parte da minha vida,

dos meus sonhos e do meu sucesso! Inﬁnitamente grato!

Por ﬁm, agrade¸co aos meus valorosos colegas, companheiros e novos amigos desta dura

e gratiﬁcante jornada que foi o PROFMAT nesses ´ultimos dois anos: Elisabete Santana
de ´Avila e Silva, L´ucia Pereira dos Santos Gomes, Marcele Rodrigues Moreno Santos,
Evani Machado de Mello, Jimmy Cavalcanti Alves, Isaac Pinheiro Mota, Edvaldo Ara´ujo

dos Reis, Elton Jones da Silva Magalh˜aes, Elson Nascimento Lima, C´esar Augusto Vieira
Lima, ´Avido Sadote de Barros Neto, Luis Anselmo dos S. Vasconcelos, Gilvan Andrade
Santos, Carlos Alberto Barreto, Andr´e Bispo Calderaro, M´arcio Monte Alegre de Souza,

Davi Dantas Lima, S´ergio Ricardo dos Santos e Jos´e H´elio Barbosa. Com vocˆes eu aprendi

um estranho axioma da matem´atica do cora¸c˜ao: 1 + 1 >>> 2. Foi uma honra, sorte e

felicidade tˆe-los como meus colegas de mestrado! Sou grato por tudo!!!

Welington Batista Luz - abril de 2013

vii

“Nada ´e mais importante do que ver as fontes

da inven¸c˜ao que s˜ao, em minha opini˜ao, mais

interessantes do que as pr´oprias inven¸c˜oes”.

Gottfried Wilhelm Leibniz

Welington Batista Luz

abril de 2013

viii

Resumo

Este trabalho tem por objetivo apresentar uma introdu¸c˜ao `a matem´atica subjacente ao

Criptossistema RSA em um n´ıvel elementar, como motiva¸c˜ao a uma abordagem mais

concreta `a Teoria dos n´umeros. Pretende tamb´em servir de introdu¸c˜ao `a criptograﬁa

moderna, uma vez que esta vem se constituindo em uma ´area altamente estrat´egica e

fecunda tanto na Ciˆencia da Computa¸c˜ao quanto na Matem´atica. Ser˜ao abordadas as

principais deﬁni¸c˜oes, conceitos e resultados referentes `a Teoria Cl´assica dos N´umeros

que garantem o entendimento, o funcionamento e a seguran¸ca do Criptossistema RSA,

e apresentada sua implementa¸c˜ao matem´atica simpliﬁcada. Tamb´em ser´a apresentada

uma implementa¸c˜ao pr´atica do RSA utilizando o programa de computa¸c˜ao

alg´ebrica

MAXIMA. O conte´udo deste trabalho servir´a de base `a confec¸c˜ao de uma cartilha did´atica

de atividades destinada aos alunos do ensino b´asico, onde ser˜ao trabalhados os temas

acima citados.

Palavras chaves: Criptograﬁa, RSA, Pequeno Teorema de Fermat, N´umeros Primos,

Testes de primalidade, Euler, Euclides, Gauss, Congruˆencia, MAXIMA.

ix

Abstract

This work purpose one introdution for the mathematics behind RSA Cryptossistem on an

elementary level, as motivation to a more concrete approach to the theory of numbers. It

also seeks to serve as an introduction to modern cryptography, since this is becoming an

area of great strategic and fruitful both in Computer Science and in Mathematics. It will

address key deﬁnitions, concepts and results related to the Classical Theory of Numbers

that ensure understanding, operation and security of RSA Cryptographic Algorithm and

submitted its implementation simpliﬁed mathematics. Also presented will be a practical

implementation of RSA using the computer algebra program MAXIMA. The content

of this work will serve as a basis for making a booklet of activities aimed at teaching

elementary school students, where will be worked the thems mentioned above.

Key words: Cryptography, RSA, Fermat’s Little Theorem, Primes, Primality Tests,

Euler, Euclid, Gauss, Congruences, MAXIMA.

x

Introdu¸c˜ao

A partir da d´ecada de 70 a Criptograﬁa assumiu um papel essencial na garantia da

seguran¸ca da “sociedade da informa¸c˜ao”, ao ser massivamente aplicada aos protocolos de

comunica¸c˜ao da Internet. Como veremos ao longo deste trabalho, isto n˜ao seria poss´ıvel

sem a utiliza¸c˜ao da Teoria dos N´umeros, uma ´area da Matem´atica at´e ent˜ao tida como

meramente abstrata e sem nenhuma aplicabilidade ao mundo real.

Considerando que a proposta ´e abordar a Matem´atica envolvida no RSA sob um

ponto-de-vista elementar, destinada especialmente aos alunos do ensino

b´asico, ser´a

utilizada uma linguagem mais natural poss´ıvel, com o cuidado de se manter a exatid˜ao

e objetividade que o tema exige. Deve ser alertado que em muitas passagens a concis˜ao

foi propositalmente prejudicada em benef´ıcio da clareza. Isto pode a princ´ıpio parecer

contradit´orio para algu´em j´a familiarizado com o formalismo acadˆemico matem´atico, mas

n˜ao o ´e quando se quer assumir a ´otica e as limita¸c˜oes te´oricas do aluno do ensino b´asico.

Os resultados mais elementares da Aritm´etica ser˜ao considerados como j´a conhecidos e

ser˜ao apenas apresentados, a exemplo da Divisibilidade no conjunto dos n´umeros inteiros

e suas propriedades, o Algoritmo de Euclides Estendido, e a Aritm´etica Modular, uma vez

que se encontram bastante difundidos em excelentes trabalhos introdut´orios, a exemplo de

Pl´ınio[11], Hefez[9] e Silva[10]. Tamb´em o conceito de fun¸c˜ao ser´a dado como conhecido.

J´a os resultados que embasam mais diretamente o Algoritmo RSA ser˜ao justiﬁcados, a

exemplo do Pequeno Teorema de Fermat e a Generaliza¸c˜ao de Euler.

H´a aqui o entendimento de que ´e necess´ario apresentar logo cˆedo e de forma acess´ıvel

os temas mais avan¸cados da Matem´atica para o aluno do ensino b´asico como estrat´egia

de motiva¸c˜ao. Tamb´em entende-se necess´ario promover a interdisciplinaridade, tendo em

vista a dinˆamica cada vez mais intensa no Brasil da pesquisa cient´ıﬁca integrada e o

conseq¨uente aumento da demanda por matem´aticos de alto n´ıvel capazes de interagirem

com os demais campos do conhecimento.

No Cap´ıtulo 1 ser´a feito um resumido panorama hist´orico da Criptograﬁa Sim´etrica,

necess´ario `a justiﬁcativa da necessidade dos

Sistemas Criptogr´aﬁcos Assim´etricos, a

exemplo do RSA. Em seguida, no Cap´ıtulo 2, ser˜ao apresentadas as principais deﬁni¸c˜oes,

conceitos e teoremas referentes `a Teoria Cl´assica dos N´umeros que garantem o entendi-

mento, o funcionamento e a seguran¸ca do Algoritmo RSA. No Cap´ıtulo 3, com base no

que foi fundamentado nos cap´ıtulos ateriores, ser´a explicada a implementa¸c˜ao matem´atica

1

do RSA em linhas gerais, culminando com uma implementa¸c˜ao pr´atica e simpliﬁcada do

Algoritmo RSA. No Cap´ıtulo 4 ser´a trabalhada uma aplica¸c˜ao mais realista do RSA com

a utiliza¸c˜ao do MAXIMA.

No Cap´ıtulo 5, ser´a abordado o Algoritmo da Fatora¸c˜ao e feita uma an´alise de sua

eﬁciˆencia, bem como sua importˆancia e limita¸c˜oes na criptoan´alise do RSA. E por ﬁm,

no Cap´ıtulo 6, ser´a feita uma introdu¸c˜ao aos testes de primalidade utilizados pelos pro-

gramas de computa¸c˜ao alg´ebrica mais conhecidos. Tamb´em ser´a estimada a quantidade

de n´umeros primos de uma determinada grandeza utilizando-se o Teorema dos N´umeros

Primos.

2

Cap´ıtulo 1

Criptograﬁa

1.1 O que ´e Criptograﬁa?

Criptograﬁa ´e a ciˆencia da escrita secreta, cuja ﬁnalidade ´e o estudo das t´ecnicas que

permitem escrever uma mensagem leg´ıvel em um modo intelig´ıvel apenas para o seu autor

ou algu´em autorizado por ele.

A mensagem que se pretende esconder com criptograﬁa pode ser um texto, uma frase,

uma palavra ou at´e mesmo um n´umero.

Inicialmente, a Criptograﬁa foi praticada pelas civiliza¸c˜oes cl´assicas, a exemplo da

eg´ıpcia, grega, romana, chinesa, etc... e depois pelos povos modernos, geralmente ligada

aos assuntos do Estado, tais como espionagem, guerras e diplomacia. Atualmente ela se

encontra bastante disseminada em diversos campos da atividade humana, especialmente

para garantir o sigilo dos nossos dados e conte´udos.

A palavra cripto vem do grego “criptos”, que signiﬁca escondido, e a palavra graﬁa vem

do grego “graphein”, que signiﬁca escrever. Portanto, “Criptograﬁa” quer dizer “escrita

escondida”. Escondida no sentido de que algum “algoritmo criptogr´aﬁco” ´e usado para

“embaralhar” a mensagem, de modo que ou a posi¸c˜ao das suas letras s˜ao alteradas, ou

as letras s˜ao substitu´ıdas por outros s´ımbolos. Por exemplo, se na palavra “PROFMAT”

trocarmos cada letra pela terceira seguinte na ordem alfab´etica, obteremos “SURIPDW”.

J´a na “Esteganograﬁa”, a escrita ´e “escondida” no sentido de que ela ´e ocultada por

algum processo f´ısico-qu´ımico, a exemplo da conhecida “tinta invis´ıvel”, onde se escreve

com suco de lim˜ao sobre uma folha de papel branca. Ap´os esta secar, ´e s´o aquecer a folha

em contato com uma chama que a escrita aparece magicamente.

Quando substitu´ımos uma ´unica letra de um texto por outra do mesmo alfabeto ou

por um s´ımbolo qualquer, temos uma cifra. J´a quando substitu´ımos uma palavra inteira

por um s´ımbolo, temos um c´odigo. No entanto, neste texto, ser´a usado indistintamente os

termos cifra e c´odigo como sinˆonimos. Consequentemente, neste trabalho, codiﬁcar ser´a

sinˆonimo de cifrar.

3

Para podermos codiﬁcar uma mensagem precisamos de, no m´ınimo, trˆes coisas: um

“alfabeto simb´olico” usado para codiﬁcar o texto leg´ıvel; um “algoritmo criptogr´aﬁco”,

um conjunto de instru¸c˜oes que nos diz como a mensagem ser´a codiﬁcada; e uma “chave”,

que ´e uma informa¸c˜ao necess´aria tanto para codiﬁcar quanto para “inverter” o algoritmo

criptogr´aﬁco e obter o texto leg´ıvel original.

No exemplo visto acima, conhecido como Cifra de C´esar, o alfabeto simb´olico ´e o

pr´oprio alfabeto da mensagem leg´ıvel (A, B, C, . . . , X, Y, Z). O algoritmo criptogr´aﬁco

´e a instru¸c˜ao que manda trocar cada letra da mensagem por uma ´unica letra do mesmo

alfabeto, deslocando algumas posi¸c˜oes para a direita na ordem alfab´etica, e a “chave” ´e

o n´umero 3, pois devemos substituir cada letra da mensagem pela terceira seguinte na

ordem alfab´etica, permitindo-nos assim obter a tabela de substitui¸c˜ao abaixo e inverter o

processo de codiﬁca¸c˜ao.

a

b

c

d

e

f

g

h

i

j

k

l m

D E F G H I

J K L M N O P

n

o

p

q

r

s

t

u

v w x

y

z

Q R S T U V W X Y Z A B C

Geralmente a chave criptogr´aﬁca ´e dada em termos num´ericos, e quanto maior o

seu tamanho e sua quantidade, mais forte ´e o algoritmo criptogr´aﬁco. Por exemplo, na

Cifra de C´esar a chave tem no m´aximo dois d´ıgitos e s´o h´a 25 chaves poss´ıveis, o que ´e

obviamente um sistema criptogr´aﬁco fraco. Mas se admit´ıssemos substituir qualquer letra

do nosso alfabeto (26 letras) por qualquer outra do mesmo alfabeto, ter´ıamos uma cifra

permutacional que admitiria 26! = 403291461126605635584000000 chaves diferentes. No

entanto, a aparente for¸ca da cifra permutacional ´e vulner´avel `a “an´alise de frequˆencias”,

uma t´ecnica criada pelos matem´aticos ´arabes. Esta t´ecnica consiste em se contar as

frequˆencias dos s´ımbolos em um texto cifrado, com base na constata¸c˜ao de que a frequˆencia

de uma letra em um idioma ´e aproximadamente a mesma em textos diferentes, caso esses

textos sejam suﬁcientemente longos e aleat´orios. Por exemplo, na l´ıngua portuguesa, a

letra “a” ´e a mais frequente. Ent˜ao ´e muito prov´avel que em um texto longo cifrado do

portuguˆes, de uma cifra permutacional qualquer, o s´ımbolo mais frequente represente a

letra “a” do texto leg´ıvel.

1.2 Objetivos da Criptograﬁa

O objetivo da Criptograﬁa ´e proteger o conte´udo de uma mensagem da curiosidade e do

interesse de pessoas n˜ao autorizadas. Como sabemos, a informa¸c˜ao ´e uma mat´eria prima e

ao mesmo tempo um produto muito caro e estrat´egico. Informa¸c˜ao produz conhecimento,

e conhecimento ´e poder!

4

Portanto, a Criptograﬁa garante principalmente o sigilo de uma mensagem ou de da-

dos armazenados, isto ´e, s´o o autor ou algu´em autorizado por ele ter´a acesso ao conte´udo

do texto criptografado. A Criptograﬁa tamb´em pode garantir a autenticidade de um do-

cumento, quando ´e usada para criptografar a assinatura digital do seu titular, certiﬁcando

assim que a assinatura do documento perten¸ce de fato ao seu remetente.

Imaginemos que algu´em est´a realizando uma compra em um site da internet e precisa

enviar `a empresa vendedora o seu n´umero de cart˜ao de cr´edito. Se um “hacker” estiver

“fu¸cando” esta transa¸c˜ao e descobrir os dados trafegados, esta pessoa estar´a em apuros,

a menos que os dados enviados estejam criptografados.

Outra situa¸c˜ao terr´ıvel ´e algu´em ter seu “notebook”, “tablet” ou “pendrive” roubados,

o que deixaria seus documentos pessoais, agenda telefˆonica, fotograﬁas, v´ıdeos, etc...,

totalmente `a disposi¸c˜ao de quem estiver na posse do seu equipamento, caso n˜ao estejam

criptografados.

Pior, imaginemos agora que as informa¸c˜oes conﬁdenciais pertencem `a empresa ou

`a institui¸c˜ao em que uma pessoa trabalhe, por exemplo, uma pesquisa de um produto

inovador, informa¸c˜oes judiciais, policiais, ﬁnanceiras, etc...? Ou que as informa¸c˜oes s˜ao

um segredo de Estado, como os c´odigos que acionam uma arma nuclear? Como vemos,

s˜ao muitos e diversos os usu´arios da Criptograﬁa e diversas suas aplica¸c˜oes, sejam elas de

interesse privado ou p´ublico.

Mas a exemplo de quase tudo nesta vida, existem tamb´em usu´arios mal´eﬁcos da

Criptograﬁa: o crime organizado, o terrorismo e os ped´oﬁlos. Eles tamb´em tˆem interesse

em esconder seus planos do Estado. Em raz˜ao disto h´a um grande debate sobre o acesso

dos cidad˜aos civis aos m´etodos criptogr´aﬁcos mais seguros e eﬁcientes.

O Estado

argumenta que a criptograﬁa forte proteger´a o crime. Por outro lado, os cidad˜aos precisam

usar a Criptograﬁa para proteger sua privacidade de diversos intrusos, `as vezes at´e do

pr´oprio Estado, quando este age de modo arbitr´ario e invasivo atrav´es de agentes p´ublicos

corruptos.

Nunca a Criptograﬁa foi t˜ao necess´aria como nos dias atuais, em que a humanidade est´a

se conectando cada vez mais atrav´es da internet, constituindo a t˜ao propalada “sociedade

da informa¸c˜ao”, turbinada cada vez mais pela “convergˆencia digital”. Fala-se que em breve

at´e a moeda f´ısica, como a conhecemos hoje, vai desaparecer, dando lugar ao “dinheiro

eletrˆonico” viabilizado pelo uso de tecnologias cada vez mais “inteligentes”. Fatalmente,

todas as nossas transa¸c˜oes ﬁnanceiras ser˜ao eletrˆonicas, o que exigir´a um n´ıvel elevado

e ao mesmo tempo eﬁciente de criptograﬁa para proteger nossas informa¸c˜oes ﬁnanceiras

que ﬂuir˜ao livres pela internet, atrav´es de ondas el´etricas e eletromagn´eticas.

Mais do que uma necessidade tecnol´ogica a servi¸co do Estado, a Criptograﬁa vem se

constituindo tambem no principal assegurador da maior consquista pol´ıtica da moderni-

dade: a privacidade do cidad˜ao!

5

1.3 Criptograﬁa moderna

A era moderna da Criptograﬁa teve in´ıcio em 1948, com o nascimento da computa¸c˜ao

eletrˆonica e a publica¸c˜ao da Teoria dos C´odigos de Claude Shannon, onde ele delineou os

fundamentos matem´aticos e f´ısicos para a implementa¸c˜ao eletrˆonica de c´odigos, atrav´es da

sua tese de doutoramento intitulada “A mathematical theory of communication” (Teoria

matem´atica da comunica¸c˜ao). A partir deste trabalho, a Matem´atica assumiu deﬁnitiva-

mente as bases da Criptograﬁa com a cria¸c˜ao de sistemas criptogr´aﬁcos que se utilizam

de fun¸c˜oes matem´aticas e da aplica¸c˜ao maci¸ca dos resultados cl´assicos e modernos da

Teoria dos N´umeros, uma vez que os caracteres de um texto qualquer nada mais s˜ao do

que n´umeros bin´arios manipulados logicamente por um computador, podendo ser sub-

metidos `as opera¸c˜oes aritm´eticas cl´assicas, tais como adi¸c˜ao, multiplica¸c˜ao, potencia¸c˜ao,

aritm´etica modular, etc....

O primeiro algoritmo criptogr´aﬁco para uso geral, padronizado pelo NBS (National

Bureau of Standards) do governo dos EUA, foi produzido e publicado pela IBM em 1976,

denominado DES (Data Encryption Standard). At´e ent˜ao, os m´etodos criptogr´aﬁcos eram

secretos e de uso apenas estatal ou empresarial. A partir de 2001, o DES foi substitu´ıdo

pelo AES (Advanced Encryption Standard),

que ´e aplicado atualmente nas conex˜oes

Wi-Fi que n´os usamos em nossos lares.

No entanto, o AES e todos os m´etodos de cifragem cl´assicos s˜ao “Sistemas Crip-

togr´aﬁcos Sim´etricos”, ou de “Chave Privada”, onde uma mesma chave K ´e utilizada

tanto para codiﬁcar quanto para decodiﬁcar o texto enviado.

Sejam:

X: texto leg´ıvel a ser codiﬁcado;

C: texto codiﬁcado a ser transmitido;

K: chave privada;

f : fun¸c˜ao de codiﬁca¸c˜ao (ou algoritmo de codiﬁca¸c˜ao);
f −1: fun¸c˜ao de decodiﬁca¸c˜ao (ou algoritmo de decodﬁca¸c˜ao).

Em geral, um Sistema Criptogr´aﬁco Sim´etrico, deve atender `as seguintes condi¸c˜oes

m´ınimas:

1. Todos usu´arios utilizam a mesma chave K para codiﬁcar e decodiﬁcar a mensagem.

2. Se fK(X) = C, ent˜ao f −1

K (C) = X. Ou seja, ao aplicarmos o
algoritmo de decodiﬁca¸c˜ao com a chave K `a mensagem codiﬁcada C, recuperamos

K (fK(X)) = f −1

a mensagem leg´ıvel X.

3. O c´alculo de fK(X) e de f −1

K (C) ´e computacionalmente f´acil quando se conhece as

chaves K.

4. ´E “computacionalmente dif´ıcil” calcular f −1

K (C) sem o conhecimento de K.

6

Esquematicamente, temos:

Texto leg´ıvel(X)

Alice
fK (X)

(cid:47) Texto codiﬁcado(C)

Canal
seguro

(cid:47) Texto codiﬁcado(C)

Bob

f −1
K (C)

Texto leg´ıvel(X)

O problema com os Sistemas Criptogr´aﬁcos Sim´etricos reside na distribui¸c˜ao da chave,

que nos m´etodos implementados eletronicamente s˜ao feitos atrav´es dos canais eletrˆonicos

(linha telefˆonica e ondas de r´adio), vulner´aveis `a “escuta” de algum intruso. Se este

souber o algoritmo de codiﬁca¸c˜ao e descobrir a chave utilizada, tudo estar´a perdido.

Imaginemos milh˜oes de chaves ﬂuindo desprotegidas pela internet sujeitas `a inter-

cepta¸c˜ao de milhares de pessoas mal-intencionadas. Uma maneira de contornar este

problema seria enviar a chave atrav´es de um “canal seguro”, por exemplo, os correios

ou mesmo um mensageiro particular, o que tornaria todo o processo muito lento e caro.

Fica claro portanto que a troca de chaves ´e o aspecto mais cr´ıtico de qualquer sistema

criptogr´aﬁco sim´etrico.

´E neste contexto que aparecem os sistemas criptogr´aﬁcos assim´etricos, ou de chave
p´ublica, sugeridos pelos norte-americanos Whitﬁeld Diﬃe e Martin Hellman em um tra-

balho revolucion´ario intitulado “New Directions in Cryptography” (Novas dire¸c˜oes em

Criptograﬁa), publicado de 1976. Na criptograﬁa assim´etrica s˜ao usadas duas chaves,

uma p´ublica e outra privada, sendo que esta n˜ao transita pelos canais eletrˆonicos, ﬁcando

armazenada no computador do destinat´ario da mensagem, desde o momento em que ´e

criada por ele, conforme veremos adiante.

Mas a caracter´ıstica principal da criptograﬁa assim´etrica ´e a implementa¸c˜ao de uma

“fun¸c˜ao bijetiva de m˜ao ´unica”, ou seja uma fun¸c˜ao f´acil de se computar em um sentido

mas dif´ıcil de ser computada no sentido inverso, caso n˜ao se conhe¸ca a chave secreta.

Existem v´arios processos assim´etricos, a exemplo do famoso brinquedo Cubo M´agico.

Sabemos que ´e muito f´acil misturar as cores do Cubo girando suas faces, mas tamb´em

sabemos que ´e “muito dif´ıcil” retornar as faces `as suas cores originais, a menos que j´a se

conhe¸ca os movimentos certos para tal. Mas ser´a que um processo an´alogo poderia ser

implementado aritmeticamente a ponto de se poder construir uma criptograﬁa assim´etrica

forte? Felizmente a resposta ´e sim!

Inspirados por esta ideia, os pesquisadores do MIT Ronald Rivest,

Adi Shamir

e Leonard Adleman inventaram em 1978 o Criptosistema RSA, sendo este o primeiro

sistema criptogr´aﬁco de chave p´ublica utilizado e ainda o mais seguro e o mais difundido

atualmente. Por exemplo, o RSA ´e usado em SSL (Secure Socket Leyer), como uma

7

(cid:47)
(cid:47)
(cid:15)
(cid:15)
“camada” de seguran¸ca do http (Hypertext Transfer Protocol), tamb´em denominado de

“https” (Hypertext Transfer Protocol Secure), e que aparece no in´ıcio do endere¸co da

URL (endere¸co eletrˆonico do site) quando estamos fazendo uma compra com cart˜ao de

cr´edito em uma loja eletrˆonica na internet, combinado com o DES.

1.4 Sistema Criptogr´aﬁco Assim´etrico

Sejam:

X: texto leg´ıvel a ser codiﬁcado;

C: texto codiﬁcado a ser transmitido;

P : chave p´ublica;

S: chave privada;

f : fun¸c˜ao de codiﬁca¸c˜ao (ou algoritmo de codiﬁca¸c˜ao);
f −1: fun¸c˜ao de decodiﬁca¸c˜ao (ou algoritmo de decodﬁca¸c˜ao);

De forma geral, os sistemas criptogr´aﬁcos assim´etricos, ou de chave p´ublica, devem

atender `as seguintes condi¸c˜oes m´ınimas:

1. Cada usu´ario de um Sistema Criptogr´aﬁco Assim´etrico deve possuir um par de

chaves (P, S).

2. Se fP (X) = C, ent˜ao f −1

S (C) = X. Ou seja, ao aplicarmos o
algoritmo de decodiﬁca¸c˜ao com a chave privada S `a mensagem codiﬁcada C, recu-

S (fP (X)) = f −1

peramos a mensagem leg´ıvel X.

3. ´E computacionalmente f´acil calcular o par de chaves (P, S).

4. ´E computacionalmente dif´ıcil calcular a chave privada S a partir do conhecimento

da chave p´ublica P .

5. O c´alculo de fP (X) e de f −1

S (C) ´e computacionalmente f´acil quando se conhece as

chaves S e P .

6. ´E computacionalmente dif´ıcil calcular f −1

S (C) sem o conhecimento de S.

Esquematicamente, temos:

Texto leg´ıvel(X)

Alice
fP (X)

(cid:47) Texto codiﬁcado(C)

Canal

(cid:47) Texto codiﬁcado(C)

Bob

f −1
S (C)

Texto leg´ıvel(X)

O Criptosistema RSA foi o primeiro a atender os crit´erios acima para uma sistema

criptogr´aﬁco de chave p´ublica, conforme veremos adiante.

8

(cid:47)
(cid:47)
(cid:15)
(cid:15)
Cap´ıtulo 2

Teoria dos N´umeros para o RSA

2.1 Algoritmos

Como falaremos bastante sobre algoritmos nas p´aginas seguintes, conv´em sabermos

logo o que eles realmente s˜ao. A palavra “algoritmo” originou-se do nome do grande

matem´atico ´arabe Al Khowarismi (780 - 850), e signiﬁca, segundo a deﬁni¸c˜ao de Donald

Knuth em [8], p.4, “(...) um conjunto ﬁnito de instru¸c˜oes em uma dada sequˆencia de

opera¸c˜oes a ﬁm de se resolver um problema espec´ıﬁco, devendo apresentar cinco carac-

ter´ısticas essenciais: ﬁnitude, clareza, entrada, sa´ıda e efetividade”. Al´em de ser ﬁnito

em um tempo razo´avel, o algoritmo deve ser claro e cumprir realmente o que se quer com

sua implementa¸c˜ao.

Grande parte da Matem´atica consiste na implementa¸c˜ao de algoritmos, a exemplo do

Algoritmo de Euclides para o c´alculo do m´aximo divisor comum. E qualquer programa de

computador nada mais ´e do que sequˆencias enormes concatenadas de algoritmos escritos

em alguma linguagem que o computador pode “compreender” e implementar.

2.2 Divis˜ao com resto e divisibilidade

O resultado que segue nos acompanha desde o quinto ano do ensino fundamental e ´e

uma das ferramentas matem´aticas mais importantes que existem. Euclides de Alexandria

(360 — 295 a.C.) foi a primeira pessoa a dar uma demonstra¸c˜ao formal para ele na sua

monumental obra “Os elementos”. Este teorema fundamenta o que ´e conhecido como

Algoritmo da Divis˜ao Euclidiana, ou ainda Algoritmo da Divis˜ao com Resto. Euclides s´o

conhecia e trabalhava com n´umeros positivos (medidas de segmentos de reta), mas aqui

consideraremos tamb´em n´umeros inteiros negativos como dividendos.

i) “Sejam n e d > 0 inteiros. Ent˜ao existem ´unicos q e r inteiros tal que

n = q · d + r, com 0 ≤ r < d.” (Euclides)

9

Exemplos:

a) Sejam n = 20 e d = 3, temos 20 = 6 · 3 + 2.

b) Se n = −10 e d = 7, temos –10 = (−2) · 7 + 4.

Vamos lembrar que, quando estamos “dividindo” atrav´es deste algoritmo, estimamos

valores m´aximos para os quocientes, subtra´ımos o resultado do dividendo e obtemos restos,

at´e que o ´ultimo resto seja menor do que o divisor. A´ı a divis˜ao p´ara e temos portanto

o nosso quociente e resto “´unicos”. Isto ir´a sempre acontecer, pois a sequˆencia dos restos

obtida ´e formada por n´umeros inteiros positivos e decrescentes.

Quando r = 0, temos que n = q · d. Neste caso dizemos que d ´e divisor de n, ou

que d divide n, ou que n ´e m´ultiplo de d, ou que n ´e divis´ıvel por d. Tamb´em dizemos

neste caso que n pode ser fatorado nos fatores q e d. Exemplo: 5 ´e divisor de –20, pois

−20 = (−4) · 5 + 0. Da mesma forma, −4 ´e divisor de −20. Tamb´em poder´ıamos dizer

que –20 ´e m´ultiplo (ou divis´ıvel) de 5 e de –4.

ii) “Sejam a, b, c, m e n inteiros, onde c divide a e c divide b.

Ent˜ao c divide m · a + n · b.”

Exemplos:

a) Como 2 divide 8 e 2 divide 30, ent˜ao 2 divide 5 · 8 + 7 · 30.

b) Como 5 divide 15 e 5 divide 35, ent˜ao 5 divide 12 · 15 – 9 · 35.

2.3 N´umeros primos

A palavra “primo” vem do latim “primus”, e signiﬁca “os que vˆem primeiro”. O

sentido de “primo” em Aritm´etica ´e de que todos os demais n´umeros inteiros, que n˜ao s˜ao

primos, s˜ao formados pela multiplica¸c˜ao de n´umeros primos, como nos garante o Teorema

Fundamental da Aritm´etica (Euclides/Gauss).

Por desempenhar um papel importante no algoritmo RSA, os n´umeros primos e algu-

mas de suas propriedades fundamentais ser˜ao revisadas e justiﬁcadas a partir de agora.

Chamamos de primo ao n´umero inteiro p > 1 que s´o possui os divisores 1 e p. Um

n´umero inteiro p > 1 que n˜ao ´e primo ´e dito composto.

Exemplos:

a) 3, 7 e 23 s˜ao primos.

b) 9, 84 e 11235 s˜ao compostos.

10

Os n´umeros primos menores do que 100 s˜ao:

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97.

iii) “Existem inﬁnitos n´umeros primos.” (Euclides)

Vamos supor que exista uma quantidade ﬁnita p1, p2, . . . , pk de n´umeros primos. For-
memos com eles o n´umero n = p1 · p2 · p3 · . . . · pk + 1. ´E obvio que um dos primos
p1, p2, . . . , pk deve dividir n. Este fator primo que divide n tamb´em divide o produto
p1 · p2 · p3 · . . . · pk . Mas isto ´e um absurdo, pois, pelo resultado ii), este primo deve
dividir a diferen¸ca n − p1 · p2 · p3 · pk = 1, ou seja, deve dividir 1. Portanto, devem existir
mais primos do que os p1, p2, . . . , pk. Isto equivale a aﬁrmar que existem inﬁnitos n´umeros
primos! Lembremos que os gregos da ´epoca de Euclides n˜ao concebiam o “inﬁnito”.

Em outras palavras, este resultado nos diz que n˜ao pode haver uma “tabela peri´odica”

dos n´umeros naturais, ou seja, ﬁnitos n´umeros que “gerem” (pela multiplica¸c˜ao) todos os

outros n´umeros naturais. Isto ´e, os “elementos qu´ımicos” da Aritm´etica s˜ao inﬁnitos!

iv) “Para todo inteiro positivo k, existem k n´umeros inteiros consecutivos

todos compostos”

Consideremos a sequˆencia de k n´umeros consecutivos:

(k + 1)! + 2, (k + 1)! + 3, (k + 1)! + 4, (k + 1)! + 5, . . . , (k + 1)! + k, (k + 1)! + (k + 1).

Cada termo dela ´e claramente um n´umero composto, pois sao divis´ıveis por cada

n´umero inteiro de 2 a k + 1.

Exemplos:

a) 2 divide 2! + 2.

b) 2 divide 3! + 2 e 3 divide 3! + 3.

c) 2 divide 4! + 2, 3 divide 4! + 3 e 4 divide 4! + 4.

Este resultado nos informa que h´a intervalos muito longos (t˜ao longo quanto queira-

mos) entre dois n´umeros primos. Ou seja, intervalos arbitrariamente grandes formados

apenas por n´umeros compostos. Isso nos d´a uma ideia da ordem de grandeza com que

os n´umeros primos podem estar afastados quando avan¸camos na sequˆencia dos n´umeros

naturais. O que n˜ao quer dizer que n˜ao possa haver tamb´em intervalos contendo muitos

n´umeros primos mesmo ap´os intervalos longos de n´umeros compostos como estes.

11

2.4 Expans˜ao bin´aria de um n´umero inteiro

v) Consideremos dois n´umeros positivos n e b, com b > 1.

Ent˜ao n pode ser escrito na forma:

n = ak · bk + ak − 1 · bk−1 + . . . + a2 · b2 + a1 · b + a0,

onde 0 ≤ ak < b, 0 ≤ ak − 1 < b, . . . , 0 ≤ a2 < b, 0 ≤ a1 < b, 0 ≤ a0 < b

s˜ao ´unicos e ak (cid:54)= 0.

Aplicando o Algoritmo Euclidiano da Divis˜ao, temos: (I) n = q1 · b + a0, onde 0 ≤
a0 < b. Se q1 ≥ b, podemos dividi-lo por b, obtendo: (II) q1 = q2 · b + a1, onde 0 ≤ a1 < b.
Substituindo (II) em (I), temos: n = (q2 · b + a1) · d + a0 = q2 · b2 + a1 · b + a0, onde
0 ≤ a0, a1 < b. Continuando assim at´e que qk < b, para um k inteiro positivo, quando
paramos de dividir e obtemos n = qk · bk + ak−1 · bk−1 + . . . + a2 · b2 + a1 · b + a0. Como qk
´e o ´ultimo resto, fazemos qk = ak e, portanto:

n = ak · bk + ak − 1 · bk − 1 + . . . + a2 · b2 + a1 · b + a0

onde 0 ≤ ak, ak − 1, . . . , a2, a1, a0 < b s˜ao “´unicos”.

Neste caso dizemos que ak, ak−1, . . . , a2, a1, a0 s˜ao os algarismos de n na base b.
O n´umero n tamb´em pode ser representado como n = (akak – 1a2a1a0)b
Para obtermos a expans˜ao de um n´umero n em uma base qualquer b, aplicamos o

algoritmo da divis˜ao euclidiana sucessivamente entre os quocientes obtidos e a base b. Os

algarismos de n ser˜ao os restos obtidos na ordem contr´aria.

Quando a base b = 2, dizemos que a expans˜ao de n ´e bin´aria. Quando b = 10 dizemos
que ´e decimal. Neste caso, n˜ao ´e preciso indicar a base subscrita. Por exemplo (32)10 = 32.

Exemplo: Determinar a expans˜ao bin´aria do n´umero 37.

Inicialmente dividimos 37 por 2, obtendo 37 = 18 · 2 + 1. Em seguida dividimos 18

por 2, obtendo 18 = 9 · 2 + 0. E prosseguimos dividindo os quocientes obtidos por 2 at´e

obter um quociente menor do que 2, quando n˜ao poderemos mais continuar a divis˜ao com

resto. O numeral na base 2 ´e formado pelo ´ultimo quociente e pelos restos tomados na

ordem inversa do processo de divis˜ao. Continuando, ter´ıamos as igualdades: 9 = 4 · 2 + 1,
4 = 2 · 2 + 0, 2 = 1 · 2 + 0. Logo 37 = (100101)2.

2.5 Algoritmo Euclidiano Estendido

vi)“Se a e b s˜ao inteiros e a = b · q + r, onde q e r s˜ao inteiros,

ent˜ao mdc(a, b) = mdc(b, r)”

Onde mdc(a, b) ´e o maior divisor comum de a e b.

12

Isto ´e f´acil ver porque, de acordo com o resultado ii), como a = b · q + r, os divisores

de b e r dividem a, e os divisores de a e b tamb´em dividem r em raz˜ao de a − b · q = r.

Logo, o maior divisor de a e b tamb´em ´e o maior divisor de b e r.

Este fato nos d´a uma maneira bastante eﬁciente para calcular o mdc entre dois n´umeros

inteiros, realizando divis˜oes sucessivas, o que ´e conhecido como Algoritmo de Euclides.

Primeiro vamos aplicar o Algoritmo da Divis˜ao com Resto de Euclides, onde o dividendo

´e 876 e o divisor ´e 597. Em seguida vamos dividir 597 pelo resto da divis˜ao anterior, e

assim sucessivamente at´e obtermos um resto zero. Isto ser´a sempre poss´ıvel, pois os restos

obtidos neste processo formam uma sequˆencias decrescente de n´umeros inteiros positivos.

Fazendo assim, obteremos a sequencia de igualdades:

876 = 1 · (597) + 279 → Pelo teorema acima: mdc(876, 597) = mdc(597, 279)

597 = 2 · (279) + 39 → Idem: mdc(597, 279) = mdc(279, 39)

279 = 7 · (39) + 6 → Idem: mdc(279, 39) = mdc(39, 6)

39 = 6 · (6) + 3 → Idem: mdc(39, 6) = mdc(6, 3)

6 = 2 · (3) + 0 → Idem: mdc(6, 3) = mdc(3, 0) = 3.

Logo, temos:

mdc(876, 597) = mdc(597, 279) = mdc(279, 39) = mdc(39, 6) = mdc(6, 3) = mdc(3, 0) =

3.

Ou seja, o mdc ´e o ´ultimo resto n˜ao-nulo obtido na sequˆencia de divis˜oes euclideanas

acima. No entanto, ´e mais comum expressarmos essas divis˜oes no diagrama abaixo:

1

2

7

876

279

597

279

39

39

6

3

2

3

6

6

0

Onde na linha superior temos os quocientes. Na do meio, os dividendos, e na de

baixo, os restos. Apesar de ter sido inventado a mais de 2.000 anos, o Algoritmo de

Euclides ainda ´e o mais eﬁciente quando se trata de calcular o mdc entre dois n´umeros.

Segundo Silva em [10], p.65, uma avalia¸c˜ao importante da sua eﬁciˆencia computacional

foi feita pelo matem´atico Gabriel Lam´e (1795 – 1870). O Teorema de Lam´e garante que a

quantidade de divis˜oes necess´arias para se determinar o mdc entre dois n´umeros positivos

´e, no m´aximo, cinco vezes a quantidade de algarismos do menor deles. Por exemplo, para

se calcular o mdc entre 8579324 e 521 deveremos fazer, no m´aximo, 5 · 3 = 15 divis˜oes,

uma vez que o n´umero 521 tem trˆes algarismos.

Outro resultado importante para o RSA ´e o Teorema de Bachet-B´ezout:

vii) “Se mdc(a, b) = d, ent˜ao existem n´umeros inteiros x e y

tais que a · x + b · y = d ”

13

Para encontrarmos os n´umeros x e y, aplicamos o Algoritmo de Euclides Estendido,

que consiste em reescrever as igualdades das divis˜oes acima, isolando-se os restos obtidos

e substituindo-se, a partir da pen´ultima igualdade, as rela¸c˜oes resultantes anteriores nas

seguintes at´e se obter a rela¸c˜ao a · x + b · y = d. Tomando-se como base o exemplo anterior,

onde mdc(876, 597) = 3 = 876 · x + 597 · y, teremos:

876 = 1 · (597) + 279 =⇒ 876 – 597 = 279 (I)

597 = 2 · (279) + 39 =⇒ 597 – 2 · (279) = 39 (II)

279 = 7 · (39) + 6 =⇒ 279 – 7 · (39) = 6 (III)

39 = 6 · (6) + 3 =⇒ 39 – 6 · (6) = 3 (IV)

6 = 2 · (3) + 0

Substituindo (III) em (IV): 39 – 6 · [279 – 7 · (39)] = 3 =⇒ 39 · (43) – 6 · (279) = 3 (V)

Substituindo (II) em (V): [597 – 2·(279)]·(43) – 6·(279) = 3 =⇒ 43·(597) − 92·(279) = 3

(VI)

Substituindo (I) em (VI): 43·(597) – 92·(876 – 597) = 3 =⇒ (−92)·(876)+135·(597) = 3.

Logo x = −92 e y = 135.

Tamb´em importante para o Algoritmo RSA ´e o seguinte resultado:

viii) “Se a e b s˜ao relativamente primos e dividem c,

ent˜ao o produto a · b divide c”.

Pois como a divide c, podemos escrever c = a · k, para um k inteiro. E como b tamb´em

divide c mas ´e relativamente primo com a, temos que b tem que dividir k, ou seja, k = b·t,

para um t inteiro. Da´ı, c = a · (b · t) = (a · b) · t. Logo a · b divide c.

Dizer que a e b s˜ao relativamente primos (ou primos entre si) ´e o mesmo que aﬁrmar

mdc(a, b) = 1, ou seja eles n˜ao possuem divisores em comum al´em do n´umero 1.

Exemplo: Como 3 divide 120 e 5 divide 120, e mdc(3, 5) = 1, ent˜ao 3 · 5 = 15 divide

120.

2.6 No¸c˜oes de Aritm´etica Modular

2.6.1 Congruˆencia

A aritm´etica modular ´e popularmente conhecida como a “aritm´etica do rel´ogio”, onde

o n´umero total de horas ´e o “m´odulo”, um n´umero natural positivo que chamaremos de

n. Por exemplo, consideremos um rel´ogio de 12 horas. Se agora s˜ao 8 horas da manh˜a e

queremos saber que horas ser˜ao daqui a 10 horas, fazemos 8 + 10 = 18 e a soma dividimos

por 12, que nos d´a um resto 6.

Isto ´e, ser˜ao 6 horas da tarde. Portanto a adi¸c˜ao na

aritm´etica modular consiste em somar, depois dividir pelo m´odulo e obter o resto.

14

Em sua obra monumental sobre Teoria dos N´umeros “Disquisitiones Arithmeticae”

(Investiga¸c˜oes aritm´eticas) publicada em 1801, o grande Gauss (1777 - 1875) introduziu

a nota¸c˜ao de congruˆencia, conforme a deﬁni¸c˜ao abaixo:

Sejam a, b e n n´umeoros inteiros, com n > 0. Dizemos que a ´e congruente a b m´odulo

n se ocorrer que a – b = k · n, para k inteiro, ou seja, se n dividir a diferen¸ca a – b. Neste

caso, escrevemos:

a ≡ b (mod n)

´E f´acil ver que isto ocorrer´a se a e b deixarem o mesmo resto quando divididos por n,
ou seja: a = s · n + r e b = t · n + r, com s e t inteiros, o que n´os dar´a a − s · n = r e

b − t · n = r. Logo a − s · n = b − t · n. Da´ı, teremos a – b = (s – t) · n, ou ainda

a – b = k · n, onde s – t = k.

No exemplo acima, temos que 18 ≡ 6 (mod 12), pois 12 divide 18 – 6 = 12.

Da mesma forma 39 ≡ 3 (mod 12), pois 39 – 3 = 36 = 3 · 12, e 72 ≡ 0 (mod 12), pois

12 divide 72 – 0 = 72 = 6 · 12.

Se a n˜ao ´e congruente a b m´odulo n, escrevemos a (cid:54)≡ b (mod n).
´E f´acil ver que todo m´ultiplo de 12 ´e congruente a 0 m´odulo 12.
Se o nosso rel´ogio for de “5 horas”, ou seja, o m´odulo n = 5 e quisermos saber a que
horas equivale a potˆencia 34, ´e s´o calcularmos essa potˆencia e depois dividirmos o resultado
por 5. O resto obtido nesta conta ser´a a hora procurada. Ou seja, 34 = 81 = 16 · 5 + 1, o
que nos d´a 1 hora. Na forma de congruˆencia, ﬁca 34 ≡ 1 (mod 5).

ix) Valem as Propriedades:

Sejam a, b, c e d inteiros.

1) a ≡ a (mod n) (reﬂexiva);

2) Se a ≡ b (mod n) ent˜ao b ≡ a (mod n) (sim´etrica);

3) Se a ≡ b (mod n) e b ≡ c (mod n), ent˜ao a ≡ c (mod n) (transitiva);

4) Se a ≡ b (mod n) e c ≡ d (mod n), ent˜ao a + c ≡ b + d (mod n);

a – c ≡ b – d (mod n) e a · c ≡ b · d (mod n);

5) Se a ≡ b (mod n), ent˜ao ak ≡ bk (mod n), para k inteiro e k ≥ 0;

6) Se a ≡ b (mod n), ent˜ao a ± c ≡ b ± c (mod n);

7) Se a ≡ b (mod n), ent˜ao a · c ≡ b · c (mod n);

8) Se a·x ≡ b·x (mod n) e mdc(x, n) = 1 com x inteiro, ent˜ao a ≡ b (mod n).

Ou seja, podemos “cortar” o x dos dois lados da congruˆencia.

15

2.6.2 Sistema Completo de Restos

Considerando um rel´ogio de 12 horas, qualquer n´umero de horas, por maior que seja

dever´a ser congruente a uma das horas 0, 1, 2, 3, . . . , 10, 11. Ou seja, cada uma dessas

horas vai representar um conjunto de horas que deixam o mesmo resto quando dividida

por 12. Obviamente haver´a apenas 12 desses conjuntos. Por exemplo, 247 = 20 · 12 + 7.

Ou ainda 247 ≡ 7 (mod 12). Vamos ver isto com mais generalidade.

Sejam a e n inteiros, onde n > 0. Pelo Algoritmo de Euclides para a divis˜ao, temos

que a = q · n + r, onde q e r s˜ao inteiros ´unicos e 0 ≤ r < n. Ou seja, todo n´umero inteiro

quando dividido por n deixa um ´unico resto 0 ≤ r < n. Este resto tamb´em ´e chamado de

res´ıduo de a m´odulo n.

O Algoritmo de Euclides da divis˜ao nos garante que, quando dividimos um n´umero

inteiro a qualquer por n, os ´unicos res´ıduos (restos) poss´ıveis s˜ao 0, 1, 2, . . . , n – 1. Dize-
mos que r1, r2, r3, . . . , rn formam um sistema completo de restos (res´ıduos) m´odulo n, se
qualquer ri acima ´e congruente a um dos n n´umeros 0, 1, 2, . . . , n – 1, e s˜ao incongruentes
dois a dois.

Sejam r1, r2, r3, . . . , rn um sistema completo de restos m´odulo n e a um inteiro re-
lativamente primo com n. Temos que a · r1, a · r2, a · r3, . . . , a · rn tamb´em forma uma
sistema completo de restos m´odulo n, pois supondo que a · ri ≡ a · rj (mod n), e como
mdc(a, n) = 1, temos que ri ≡ rj (mod n), pela propriedade ix), item 8). Ou seja,
i = j, pois 0 ≤ r1, r2, r3, . . . , rn < n ´e um sistema completo de restos m´odulo n. Portanto,
podemos escrever:

a · r1 ≡ ri (mod n); a · r2 ≡ rj (mod n); . . . ≡ . . . ; a · rn ≡ rk (mod n).

onde ri, rj, . . . , rk s˜ao distintos dois a dois e est˜ao em correspondˆencia biun´ıvoca com os
n´umeros 0, 1, 2, . . . , n – 1.

Por exemplo, temos que 0, 1, 2, 3, 4, formam um sistema completo de res´ıduos m´odulo

5. Se multiplicarmos todos eles por 2, obteremos 0, 2, 4, 6, 8. Calculando m´odulo

5, temos 0, 2, 4, 1, 3. E tem que ser assim, pois, conforme ﬁcou comprovado acima,

ao multiplicarmos todos os elementos do sistema completo de restos por um n´umero

relativamente primo com o m´odulo, os produtos s˜ao incongruentes, e portanto iguais a

um dos elementos 0, 1, 2, 3, 4, m´odulo cinco. Podemos ver isto como uma permuta¸c˜ao

dos elementos do sistema completo de restos.

2.6.3 Invers˜ao m´odulo n

x) Se mdc(a, n) = 1, ent˜ao a ´e invers´ıvel m´odulo n, ou seja, existe o inverso
b = a−1 tal que a · a−1 ≡ 1 (mod n), onde 0 < a < n e 0 < b < n.

Seja mdc(a, n) = 1, temos pelo resultado vii) que existem x e y inteiros tal que

16

a · x + n · y = 1, o que nos permite escrever a · x = 1 – n · y = 1 + (−y) · n, isto ´e
a·x ≡ 1 (mod n). E x ´e o inverso de a m´odulo n, que indicamos x = a−1. E mais, o inverso
de a m´odulo n ´e ´unico. Pois se existisse outro inverso b−1, ter´ıamos a · b−1 ≡ 1 (mod n), e
portanto a · a−1 ≡ a · b−1 (mod n). Como mdc(a,n)=1, podemos cancelar a nos dois lados
da congruˆencia, o que nos d´a a−1 ≡ b−1 (mod n). E como b−1 < n, temos que a−1 = b−1.
Por exemplo, como mdc(3, 10) = 1, j´a sabemos que 3 ´e invers´ıvel m´odulo 10, isto ´e

3 · x ≡ 1 (mod 10). E que esta congruˆencia possui uma ´unica solu¸c˜ao m´odulo 10, onde

0 < x < 10. E esta ´e precisamente 7, pois 3 · (7) = 21 ≡ 1 (mod 10). Ou seja, 7 ´e o

inverso de 3 m´odulo 10.

Uma consequˆencia direta do que acabamos de ver ´e que se n for primo, todos os

elementos n˜ao nulos do sistema completo de restos m´odulo n s˜ao invers´ıveis, isto ´e, 1,2,3,

. . . , n – 1 s˜ao invers´ıveis, pois todos s˜ao relativamente primos com n.

2.6.4 Exponencia¸c˜ao r´apida

Vamos calcular 673 m´odulo 100. Pelo que j´a vimos at´e aqui, dever´ıamos calcular a
potˆencia 673 e depois dividirmos o resultado por 100, obtendo um determinado resto, que
seria o resultado. Mas pela nossa experiˆencia com potˆencias, calcular 673 ´e um trabalho
estupendo. Ent˜ao faremos esse c´alculo de uma forma surpreendentemente “r´apida”. Es-
crevemos primeiro a expans˜ao bin´aria do expoente: 73 = 1 + 23 + 26. Portanto, temos
673 = 61+23+26 = 61 · 623 · 626. Calculando os quadrados sucessivos de 6 e dividindo pelo
m´odulo 100, temos 62 = 36, 622 = (62)2 = (36)2 ≡ 1296 ≡ 96 (mod 100), 623 = (622)2 ≡
(96)2 ≡ 9216 ≡ 16 (mo 100), 624 = (623)2 ≡ (16)2 (mod 100) ≡ 256 ≡ 56 (mod 100),
625 = (624)2 ≡ (56)2 ≡ 3116 ≡ 36 (mod 100), 626 = (625)2 ≡ (36)2 ≡ 1296 ≡ 96 (mod 100).
Logo 673 = 61 · 623 · 626 = 6 · 16 · 96 ≡ 9216 ≡ 16 (mod 100).

Desta forma calculamos apenas seis quadrados e dois produtos para obter o resultado.
Se tiv´essemos feito 673 = 6·6·6·. . .·6 (73 fatores), ter´ıamos que computar 72 multiplica¸c˜oes!
Podemos calcular qualquer potˆencia pela exponencia¸c˜ao r´apida usando a recorrˆencia:

a2i+1 = (a2i)2, onde i ´e um n´umero natural maior que zero.

2.7 Pequeno Teorema de Fermat

Estudando os “n´umeros perfeitos”, aqueles n´umeros inteiros que s˜ao iguais `a soma

dos seus divisores pr´oprios, Fermat descobriu e conjecturou este resultado de grande

importˆancia na teoria dos n´umeros, e que n˜ao era conhecido dos gregos. Euclides j´a havia
provado n’Os Elementos, que os n´umeros pares da forma 2n − 1 · (2n − 1) s˜ao n´umeros
perfeitos sempre que 2n − 1 for primo.

17

Quando Fermat calculou as diversas potˆencias de 2 m´odulo 5, ele percebeu o seguinte

padr˜ao:

n
2n
2n (mod 5)

1

2

2

2

4

4

3

8

3

4

5

6

7

8

9

10

11

12

13

16

32

64

128

256

512

1024

2048

4096

8192

1

2

4

3

1

2

4

3

1

2

Podemos observar que 25 ≡ 2 (mod 5) e 24 ≡ 1 (mod 5).
Da mesma forma, quando ele calculou as potˆencias de 2 m´odulo 7 obteve 27 ≡
2 (mod 7) e 26 ≡ 1 (mod 7). E de forma geral, podemos veriﬁcar que ap ≡ a (mod p) com
p primo e ap − 1 ≡ 1 (mod p) onde mdc(a, p) = 1.

Observemos o comportamento aleat´orio das potˆencias de 2 m´odulo 5, bem diferente

das potˆencias de 2 normais, onde se pode deduzir facilmente o valor do expoente pelo

valor da potˆencia dada. Nas potˆencias m´odulo n qualquer isto n˜ao ´e poss´ıvel, pois as

mesmas n˜ao obedecem um padr˜ao de crescimento est´avel, principalmente se o m´odulo n

for um n´umero “grande”. Bennet em [3], p.162, aﬁrma que as potˆencias modulares s˜ao

inclusive utilizadas em “geradores congruenciais”na obten¸c˜ao de n´umeros aleat´orios para

utiliza¸c˜ao no m´etodo Monte Carlo.

Vamos portanto justiﬁcar o Pequeno Teorema de Fermat.

J´a sabemos que quando dividimos um n´umero qualquer por 5, os ´unicos restos poss´ıveis

s˜ao 0, 1, 2, 3, e 4. Vamos multiplicar um n´umero relativamente primo com 5, por exemplo

2, apenas pelos restos n˜ao nulos, isto ´e 2·(1), 2·(2), 2·(3), 2·(4), obtendo 2, 4, 6, 8. Tomando

o m´odulo 5, obtemos a sequˆencia 2, 4, 1 e 3. Ou seja, obtivemos os mesmos restos n˜ao

nulos em uma ordem diferente, o que j´a era esperado, de acordo com a Subse¸c˜ao 2.6.2.

Portanto temos que o produto 1.2.3.4 ´e congruente ao produto 2·4·1·3, o que nos autoriza

a escrever 2·4·1·3 ≡ 1·2·3·4 (mod 5), ou ainda 2·(1)·2·(2)·2·(3)·2·(4) ≡ 1·2·3·4 (mod 5).
Da´ı temos 24 · (1 · 2 · 3 · 4) ≡ 1 · 2 · 3 · 4 (mod 5). E como os n´umeros 1, 2, 3, e 4 s˜ao
relativamente primos com 5, podemos “cort´a-los” dos dois lados da congruˆencia, obtendo
24 ≡ 1 (mod 5).

Consideremos agora um primo p e um inteiro a qualquer onde mdc(a, p) = 1. Multi-

plicando a pelos restos n˜ao nulos m´odulo p, temos:

a · (1) · a · (2) · a · (3) · . . . · a · (p − 1) ≡ 1 · 2 · 3 · . . . · (p – 1)(mod p). O que nos d´a
ap − 1 · [1 · 2 · 3 · . . . · (p − 1)] ≡ 1 · 2 · 3 · . . . · (p – 1)(mod p). E como 1, 2, 3, . . . , (p – 1)
s˜ao relativamente primos com p, temos o Pequeno Teorema de Fermat na forma provada

por Euler:

ap − 1 ≡ 1 (mod p)

18

O que equivale a dizer que p divide ap − 1 – 1.

Exemplos:

a) 34 ≡ 1 (mod 5)

b) 256 ≡ 1 (mod 7)

c) Sabemos que 697259388 − 1 ´e divis´ıvel por 89, mesmo sem realizarmos o astronˆomico

c´alculo, pois 6972593 e 89 s˜ao primos, e portanto primos entre si.

A forma deste teorema originalmente conjecturada por Fermat ´e:

“Se p ´e primo e a ´e um inteiro positivo, ent˜ao ap ≡ a (mod p)”

Mas isto ´e uma consequˆencia direta da forma anterior, pois, se p dividir ap − 1, ent˜ao
p divide o pruduto a · (ap − 1), ou seja, p divide ap − a e da´ı ap ≡ a (mod p). E caso p
n˜ao divida a, pelo Pequeno Teorema de Fermat/Euler, p divide ap − 1. Da´ı p divide o
produto a · (ap − 1), isto ´e, p divide ap − a, e portanto ap ≡ a (mod p).

Exemplos:

a) 67 ≡ 6 (mod 7)

b) 1593 ≡ 15 (mod 93)

19

Cap´ıtulo 3

O Algoritmo RSA

3.1 Generaliza¸c˜ao de Euler

Para justiﬁcarmos porque o RSA realmente funciona, vamos conhecer antes um resul-

tado preliminar que ´e a generaliza¸c˜ao de Euler ao Pequeno Teorema de Fermat quando

n = p · q.

“Sejam p e q dois n´umeros primos distintos e seja X um n´umero inteiro,

tal que p e q n˜ao dividem X, ent˜ao X (p – 1)·(q − 1) ≡ 1 (mod p · q).”

De acordo com o resultado viii), ´e suﬁciente mostrarmos que:

X (p – 1)·(q − 1) ≡ 1 (mod p) e X (p – 1)·(q − 1) ≡ 1 (mod q)

Pois se p divide X (p – 1)·(q − 1) − 1 e q divide X (p – 1)·(q − 1) − 1, teremos que p.q

divide X (p – 1)·(q−1) − 1, pois mdc(p, q) = 1.

Pelo Pequeno Teorema de Fermat/Euler, temos que X p – 1 ≡ 1 (mod p), pois mdc(X, p) =

1. Elevando esta congruˆencia `a potˆencia q – 1, temos X (p – 1)·(q − 1) ≡ (1)(q – 1) (mod p),
ou seja, X (p – 1)·(q − 1) ≡ 1 (mod p). Da mesma forma se prova que X (p – 1)·(q − 1) ≡
1 (mod q). E portanto, segue o resultado X (p – 1)·(q − 1) ≡ 1 (mod p · q).

Observa¸c˜ao: De fato, a Generaliza¸c˜ao de Euler para o Pequeno Teorema de Fermat
´e o resultado que nos garante que se mdc(X, n) = 1, ent˜ao X ϕ(n) ≡ 1 (mod n), onde
ϕ(n) ´e a fun¸c˜ao totiente de Euler. Para a implementa¸c˜ao do RSA nos basta que ϕ(n) =

ϕ(p · q) = (p − 1) · (q − 1), onde p e q s˜ao primos. Maiores detalhes ver [11].

20

3.2 A magia do RSA – Como a mensagem codiﬁcada

por Alice ´e recuperada por Bob

Veremos a seguir a “f´ormula m´agica” que Rivest, Shamir e Adleman criaram usando

como “ingredientes” apenas Aritm´etica Modular, n´umeros primos, o Teorema de Euler

e complexidade computacional, atendendo perfeitamente `as exigˆencias de um Sistema

Criptogr´aﬁco Assim´etrico, segundo os postulados de Diﬃe e Hellman.

A base do RSA ´e o fato matem´atico descoberto por Euler visto anteriormente, origi-

nado do Pequeno Teorema de Fermat. O que Rivest, Shamir e Adleman ﬁzeram foi com-

binar esses fatos matem´aticos de forma coerente e eﬁciente de modo a criar um algoritmo

de grande complexidade reversa, ou seja muito dif´ıcil de ser desmontado conhecendo-se a

chave p´ublica apenas. A prova de que o RSA realmente funciona ´e dada a seguir.

Vamos supor que Alice queira enviar uma mensagem M criptografada com o RSA

para seu namorado Bob. Usando uma tabela de convers˜ao conveniente, transformaremos

a mensagem M em um n´umero inteiro positivo X, fazendo cada letra da mensagem cor-

responder a um n´umero inteiro, uma vez que na mem´oria do computador, um texto ou

qualquer informa¸c˜ao nada mais ´e do que um n´umeros bin´arios. Ou seja, no computador,

a m´axima de Pit´agoras (572 - 479 a.C.) ´e totalmente verdadeira: “Tudo s˜ao n´umeros”.

Segue enﬁm a “f´ormula m´agica” do Criptosistema RSA:

1o) Bob precisa gerar sua chave p´ublica para que Alice ou qualquer pessoa a use para
codiﬁcar sua mensagem X. Bob faz isso escolhendo um par de n´umeros inteiros

(n, e), onde n ´e o produto de dois primos ´ımpares “grandes” distintos p e q escolhidos

aleatoriamente, ou seja, n = p.q, e 1 < e < (p – 1) · (q – 1) com mdc[e, (p – 1) ·

(q – 1)] = 1. O n´umero n ´e chamado de m´odulo RSA, e e ´e chamado de expoente

de codiﬁca¸c˜ao.

2o) J´a a chave privada (n, d) para que Bob decodiﬁque a mensagem enviada por Alice,
ele a gera a partir de n e e, onde 1 < d < (p – 1)·(q – 1) e d·e ≡ 1 mod[(p – 1)·(q – 1)].

E como mdc[e, (p – 1) · (q – 1)] = 1, conforme vimos no resultado x), o n´umero d

existe, sendo o inverso multiplicativo de e m´odulo (p – 1) · (q – 1). O n´umero d ´e

chamado de expoente de decodiﬁca¸c˜ao.

3o) Para codiﬁcar sua mensagem X, tal que 0 < X < n, Alice toma a chave p´ublica
(n, e) de Bob, que est´a dispon´ıvel para qualquer pessoa, calcula a potˆencia X e e
determina o seu resto m´odulo n, obtendo assim a mensagem cifrada C, ou seja
C ≡ X e (mod n), em seguida envia C a Bob, atrav´es de um canal de comunica¸c˜ao.

4o) Quando Bob receber a mensagem cifrada C de Alice, e usando sua chave secreta
(n, d), ele calcula a potˆencia C d e determina o seu resto m´odulo n, isto ´e X ≡
C d (mod n), recuperando assim a mensagem X original que Alice lhe enviou.

21

Este ´ultimo passo ´e o mais importante, pois ele nos garante que a mensagem original

X enviada por Alice ser´a recuperada por Bob. Vamos justiﬁc´a-lo ent˜ao.

Elevando os dois membros da congruˆencia C ≡ X e (mod n) `a potˆencia d, teremos:
C d ≡ (X e)d (mod n), ou ainda C d ≡ X e·d (mod p · q). E como e · d ≡ 1 [mod (p – 1) ·
(q – 1)], teremos que e · d = k · (p – 1) · (q – 1) + 1, para um k inteiro. Logo, C d ≡
X [k·(p – 1)·(q – 1)+1] (mod n) ≡ [(X (p − 1)·(q − 1)]k · X (mod p · q). E pelo resultado da
Se¸c˜ao 3.1, X (p − 1)·(q − 1) ≡ 1 (mod p · q), temos que C d ≡ (1)k · X (mod p · q). Logo,
C d ≡ X (mod p · q) ou X ≡ C d (mod n), onde mdc(X, n) = 1.

S´o nos resta mostrar agora se quando 0 < X < n e mdc(X, n) (cid:54)= 1, ou seja, quando p ou
q dividir X, se X ≡ C d (mod n). Caso p divida X, tamb´em dividir´a X ·(X k·(p−1)·(q−1) −1),
para um k inteiro. Ou seja, p dividir´a X k·(p−1)·(q−1)+1 − X. De modo an´alogo, se q dividir
X, tamb´em dividir´a X k·(p−1)·(q−1)+1 − X. E como mdc(p, q) = 1, temos, pela propriedade
viii), que p · q divide X k·(p−1)·(q−1)+1 − X, o que equivale a X k·(p−1)·(q−1)+1 ≡ X (mod p · q),
ou seja, C d ≡ X (mod n).

E como C d (mod n) ´e um inteiro positivo menor que n, temos que realmente o X
encontrado nesse proceso ´e mesmo o n´umero inteiro X anterior `a codiﬁca¸c˜ao, uma vez
que s´o haver´a igualdade neste caso se C d for congruente a X m´odulo n, pois os inteiros
0, 1, 2, · · · , n − 1, formam um sistema completo de restos.

Portanto, a condi¸c˜ao 0 < X < n nos garante que a mensagem X ser´a recuperada

quando aplicarmos a fun¸c˜ao de decodiﬁca¸c˜ao Xi ≡ C d (mod n).

3.3

Implementa¸c˜ao matem´atica do Algoritmo RSA

A abordagem a seguir ´e uma expans˜ao e adapta¸c˜ao da excelente implementa¸c˜ao do

RSA feita por Coutinho [16], Cap´ıtulo 6, com as modiﬁca¸c˜oes necess´arias `a sua integra¸c˜ao

a este trabalho e `a sua clareza did´atica.

3.3.1 Pr´e-codiﬁca¸c˜ao do RSA

1o) Alice pode usar a tabela abaixo para converter letras em n´umeros, de modo que
ela poder´a codiﬁcar qualquer texto utilizando as ferramentas matem´aticas vistas anteri-

ormente.

A B C D E F G H I

J K L M

10

11

12

13

14

15

16

17

18

19

20

21

22

N O P Q R S T U V W X Y Z

23

24

25

26

27

28

29

30

31

32

33

34

35

´E interessante que Alice utilize n´umeros de dois d´ıgitos para cada letra a ﬁm de
evitar ambiguidades, tipo: n˜ao saber´ıamos se 15 seria AE ou O, caso Alice come¸casse

22

enumerando o alfabeto com 1, 2, 3, ... at´e 26.

Ela dever´a substituir o espa¸co entre duas palavras por 99. Por exemplo, vamos supor

que Alice vai enviar a mensagem “AMO O PROFMAT” para Bob. De acordo com a

tabela acima a mensagem ﬁcaria assim pr´e-codiﬁcada:

X = 10222499249925272415221029

2o) Bob deve deﬁnir os “parˆametros” do RSA, que s˜ao os n´umeros primos p e q que
formam o m´odulo RSA, n = p · q. Se ele escolher p = 11 e q = 23, teremos n = p · q =

11 · 23 = 253.

3o) Alice dever´a “quebrar” o texto X em blocos. O tamanho de cada bloco apenas

precisa ser menor que n. Ent˜ao Alice pode quebrar a mensagem num´erica acima como:

102–22–49–92–49–92–52–72–41–52–210 − 29

Que pode ser organizada na seguinte tabela de blocos:

X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12
29
102

210

92

72

22

52

41

49

92

52

49

Alice tamb´em precisa ter o cuidado para que nenhum bloco come¸ce com zero, pois na

hora de decodiﬁcar poderia haver confus˜ao. Por exemplo, n˜ao d´a pra distinguir 029 de 29

quando se est´a operando com esses n´umeros.

Observemos tamb´em que ao quebrar a mensagem X em blocos aleat´orios, Alice evita

que a frequˆencia de cada letra se mantenha ao longo do processo de cifragem.

4o) Bob deve escolher o expoente de codiﬁca¸c˜ao e, onde 1 ≤ e ≤ (p – 1) · (q – 1)
e mdc[e, (p – 1) · (q – 1)] = 1. Como (p – 1) · (q – 1) = 10 · 22 = 220, temos que

mdc(e, 220) = 1. Ele pode escolher e = 3, que ´e o menor poss´ıvel, o que torna o processo

de codiﬁca¸c˜ao mais “r´apido”, pois mdc(3,220)= 1, aplicando o Algoritmo de Euclides.

A chave p´ublica de Bob ´e portanto o par (n, e) = (253, 3) e que ﬁca `a disposi¸c˜ao de

qualquer pessoa que queira enviar uma mensagem para Bob.

Feito isto, podemos passar `a fase de Codiﬁca¸c˜ao.

3.3.2 Codiﬁca¸c˜ao do RSA

Seja um “texto-bloco” Xi, onde i = 1, 2, 3, ..., 12.

De acordo com a se¸c˜ao 3.1., Alice deve codiﬁcar o texto Xi como:

23

i (mod n), onde Ci ´e o texto cifrado.

Ci ≡ X e
Alice pode usar aqui a exponencia¸c˜ao r´apida vista no subse¸c˜ao 2.6.4 para facilitar seus
c´alculos. Tomando o primeiro bloco X1 da mensagem pr´e-codiﬁcada no item anterior,
temos:

1 (mod n). Como X1 = 102:

C1 ≡ X e
C1 ≡ 1023 ≡ (102)2+1 ≡ 1022·102 ≡ (10404)·102 ≡ (31)·102 ≡ 3162 ≡ 126 (mod 253).

Ou seja, o bloco X1 = 102 foi codiﬁcado como 126.

Fazendo o mesmo com os demais blocos da mensagem criptografada, Alice obter´a:
C2 ≡ X e
C2 ≡ 223 ≡ 222+1 ≡ (222) · 22 ≡ (484) · 22 ≡ (231) · 22 ≡ 5082 ≡ 22 (mod 253).

2 (mod n)

Ou seja, o bloco X2 = 22 foi codiﬁcado como 22.

3 (mod n)

C3 ≡ X e
C3 ≡ 493 ≡ 492+1 ≡ (492) · 49 ≡ (2401) · 49 ≡ (124) · 49 ≡ 6076 ≡ 4 (mod 253)

Ou seja, os blocos X3 = X5 = 49 foram codiﬁcados como 49.

4 (mod n)

C4 ≡ X e
C4 ≡ 923 ≡ 922+1 ≡ (922) · 92 ≡ (8464) · 92 ≡ (115) · 92 ≡ 10580 ≡ 207.

Ou seja, os blocos X4 = X6 = 92 foram codiﬁcados como 207.

7 (mod n)

C7 ≡ X e
C7 ≡ 523 ≡ 522+1 ≡ (522) · 52 ≡ (2704) · 52 ≡ (174) · 52 ≡ 9048 ≡ 193 (mod 253).

Ou seja, os blocos X7 = X10 = 52 foram codiﬁcados como 193.

8 (mod n)

C8 ≡ X e
C8 ≡ 723 ≡ 722+1 ≡ (722) · 72 ≡ (5184) · 72 ≡ (124) · 72 ≡ 8928 ≡ 73 (mod 253).

Ou seja, o bloco X8 = 72 foi codiﬁcado como 73.

9 (mod n)

C9 ≡ X e
C9 ≡ 413 ≡ 412+1 ≡ (412) · 41 ≡ (1681) · 41 ≡ (163) · 41 ≡ 6683 ≡ 105 (mod 253).

Ou seja, o bloco X9 = 41 foi codiﬁcado como 105.

C11 ≡ X e

11 (mod n)

24

C11 ≡ 2103 ≡ 2102+1 ≡ (2102) · 210 ≡ (44100) · 210 ≡ (78) · 210 ≡ 16380 ≡

188 (mod 253).

Ou seja, o bloco X11 = 210 foi codiﬁcado como 188.

12 (mod n)

C12 ≡ X e
C12 ≡ 293 ≡ 292+1 ≡ (292) · 29 ≡ (841) · 29 ≡ (82) · 29 ≡ 2378 ≡ 101 (mod 253).

Ou seja, o bloco X12 = 29 foi codiﬁcado como 101.

Ent˜ao, a mensagem ﬁcar´a cifrada da seguinte forma:

C1 C2 C3 C4 C5 C6
207
126

207

22

4

4

C7 C8 C9 C10 C11 C12
101
193

105

193

188

73

Observamos aqui que Bob tem de manter os blocos cifrados separados! Caso contr´ario,

ele n˜ao poder´a mais recuperar a mensagem original enviada por Alice, pois n˜ao saberia a
quais n´umeros aplicar corretamente a fun¸c˜ao de decodiﬁca¸c˜ao X ≡ C d (mod n).

3.4 Decodiﬁca¸c˜ao do RSA

Para decodiﬁcar a mensagem enviada por Alice, Bob precisar´a do n´umero n e do

expoente de decodiﬁca¸c˜ao d, onde e · d ≡ 1 mod[(p – 1) · (q – 1)] e 1 ≤ d ≤ (p – 1) · (q – 1),

de acordo com o item 3.1. Ou seja, a chave privada ´e o par (n, d), que deve ﬁcar em

posse apenas de Bob. Na verdade, apenas d deve ser sigiloso, pois n j´a foi divulgado

publicamente.

Como e = 3, p = 11 e q = 23, teremos:

e·d ≡ 1 [mod (p – 1)·(q – 1)] =⇒ 3·d ≡ 1 [mod(11 – 1)·(23 − 1)] =⇒ 3·d ≡ 1 (mod 220).

Logo d existe pois mdc (3, 220)= 1.

Fazendo 3 · d = 220 · k + 1, temos 3 · d – 220 · k = 1. Aplicando agora o Algoritmo

Euclideano Estendido, temos:

3

1

73

3

0

220

1

220 = 3 · (73) + 1 =⇒ (−73) · 3 + (1) · 220 = 1 =⇒ (−73) · 3 ≡ 1 (mod 220). E como

−73 ≡ 147 (mod 220), temos que (147) · 3 ≡ 1 (mod 220). Logo d = 147.

Observamos que, ao contr´ario do processo de codiﬁca¸c˜ao, onde ´e conveniente traba-

lhar com um expoente de codiﬁca¸c˜ao e pequeno, no nosso caso e = 3, o expoente de

25

decodiﬁca¸c˜ao d = 147 torna o processo de tentativa de ataque ao RSA dif´ıcil, pois o

atacante ter´a que testar v´arios candidatos a expoentes de decodiﬁca¸c˜ao grandes at´e obter
um texto-bloco Xi.

Consideremos o primeiro bloco codiﬁcado C1 = 126. Escrevendo d = 147 na base 2,
ou seja, 147 = 27 + 24 + 2 + 1 e aplicando a fun¸c˜ao de decodiﬁca¸c˜ao X ≡ C d (mod n),
teremos:

X1 ≡ C d

1 (mod n)

X1 ≡ 126147 ≡ 12627+24+2+1 ≡ (12627) · (12624) · (1262) · (126) (mod 253).

Antes de prosseguirmos vamos calcular as potˆencias obtidas acima por exponencia¸c˜ao

r´apida, separadamente.

1262 ≡ 15876 ≡ 190 (mod 253)

12622 ≡ (1262)2 ≡ 1902 ≡ 36100 ≡ 174 (mod 253).

12623 ≡ (12622)2 ≡ 1742 ≡ 30276 ≡ 169 (mod 253).

12624 ≡ (12623)2 ≡ 1692 ≡ 28561 ≡ 225 (mod 253).

12625 ≡ (12624)2 ≡ 2252 ≡ 50625 ≡ 25 (mod 253).

12626 ≡ (12625)2 ≡ 1252 ≡ 625 ≡ 119 (mod 253).

12627 ≡ (12626)2 ≡ 1192 ≡ 14161 ≡ 246 (mod 253).

Portanto, temos:

X1 ≡ 126147 ≡ (12627) · (12624) · (1262) · (126) ≡ (246) · (225) · (190) · (126) ≡ (55350) ·

(23940) ≡ (196) · (158) ≡ 30968 ≡ 102 (mod 253). (Viva Rivest, Shamir e Adleman !!!)

Se Bob aplicar Xi ≡ C d

i (mod n) aos demais blocos da mensagem cifrada, obter´a os
blocos num´ericos respectivos da mensagem original X enviada por Alice. Depois ´e s´o Bob
usar a tabela do item 1o), subse¸c˜ao 3.3.1, no sentido inverso e trocar os n´umeros pelas
letras, obtendo assim a mensagem em forma de texto leg´ıvel enviada por Alice.

26

Cap´ıtulo 4

Implementa¸c˜ao RSA com MAXIMA

Trabalharemos a seguir dois exemplos mais realistas de implementa¸c˜ao do RSA uti-

lizado como ferramenta de apoio did´atico o

programa de

computa¸c˜ao

alg´ebrica

wxMAXIMA, vers˜ao 12.04.0. Maiores detalhes e comandos ver Apˆendice A.

Exemplo 1: Achar primos de 10 d´ıgitos para usar no m´odulo RSA, codiﬁcar e deco-

diﬁcar a palavra ARACAJU usando a tabela ASCII contida no Apˆendice B.

Seja o m´odulo RSA n = p · q. Fa¸camos inicialmente p = 2351174217.

No MAXIMA:

primep(2351174217) retorna “false”. Ent˜ao fazemos em seguida next−prime(2351174217),

que reorna 2351174351.

Em seguida, no MAXIMA, fazemos:

primep(2351174351), que retorna “true”. Logo 2351174351 ´e primo com uma grande

probabilidade.

Portanto, fazemos p = 2351174351.

Do mesmo modo, fazemos inicialmente q = 1201429113.

No MAXIMA:

primep(1201429113), que retorna “false”.
Ent˜ao fazemos em seguida next−prime(1201429113), que retorna 1201429123.

Depois fazemos primep(1201429123), que retorna “true”. Logo 1201429123 ´e primo

com grande probabilidade.

27

E ent˜ao fazemos q = 1201429123.

Portanto, o m´odulo RSA n = p·q = 2351174351·1201429123 = 2824769338542024173.

Uma observa¸c˜ao importante! Para testar se o m´odulo RSA encontrado ´e“bom”, ou

seja, dif´ıcil de ser fatorado em um tempo“baixo”, podemos utilizar o comando factor(n).

Se esta a¸c˜ao retornar os fatores de n em um tempo “curto”, signiﬁca que devemos descartar

os parˆametros p e q e procurar outros at´e que a fatora¸c˜ao de n seja “dif´ıcil”.

Vamos calcular agora o expoente de codiﬁca¸c˜ao e.

Fazendo (p − 1) · (q − 1) = 2351174350 · 1201429122 = 2824769334989420700.

Procuramos agora um n´umero inteiro e que satisfa¸ca 1 < e < (p − 1) · (q − 1) e

mdc[e, (p − 1) · (q − 1)] = 1.

No MAXIMA:

gcd(3, 2824769334989420700) reorna 3;

gcd(5, 2824769334989420700) retorna 5;

gcd(7, 2824769334989420700) retorna 7;

gcd(11, 2824769334989420700) retorna 1.

Logo, podemos usar 11 como expoente de exponencia¸c˜ao. Da´ı, e = 11.

Portando a chave p´ublica ´e (n, e) = (2824769338542024173, 11), que iremos usar para

codiﬁcar as mensagens a serem enviadas a um destinat´ario.

Convertendo a palavra ARACAJU em um n´umero decimal de acordo com a tabela

ASCII constante no Apˆendice B, temos: X = 65826567657485.

Vamos agora codiﬁcar a mensagem X.

Para isso fazemos no MAXIMA:

power−mod (65826567657485, 11, 2824769338542024173), que retorna 1093258905866990787.

Ent˜ao a nossa mensagem codiﬁcada ´e C = 1093258905866990787.

Para decodiﬁcar a mensagem C recebida, o destinat´ario ter´a que calcular primeiro sua

chave privada, que ´e o expoente de decodiﬁca¸c˜ao d, onde e · d = 1 [mod (p − 1) · (q − 1)]
e 1 (cid:54) d (cid:54) (p − 1) · (q − 1).

28

No MAXIMA, fazemos:

inv−mod(11, 2824769338542024173), que retorna 1283986061358827591.
Ou seja d = 1283986061358827591.

Agora, para decodiﬁcar a mensagem C, basta calcularmos X ≡ C d (mod n).

No MAXIMA, fazemos:

power−mod(1093258905866990787, 1283986061358827591, 2824769338542024173), que
retorna 65826567657485. Aplicando inversamente a tabela ASCII obtemos a palavra

ARACAJU.

Exemplo 2: Uma mensagem foi codiﬁcada com a chave p´ublica e a tabela ASCII

do exemplo anterior, e corresponde a C = 392551868987068804 - 2113855424116769378 -

948229051171291444 - 726877796189145130. Decodiﬁcar a mensagem.

Como a mensagem foi codiﬁcada em blocos, basta decodiﬁcarmos cada bloco separa-

damente utilizando a chave privada d calculada no exemplo anterior, aplicando

X ≡ C d (mod n).

No MAXIMA, fazemos:

power−mod(392551868987068804, 1283986061358827591, 2824769338542024173), que re-

torna 793285787386698283 = X1

power−mod(2113855424116769378, 1283986061358827591, 2824769338542024173), que

retorna 793265678269687384 = X2

power−mod(948229051171291444, 1283986061358827591, 2824769338542024173), que re-

torna 653278653267827380 = X3

power−mod(726877796189145130, 1283986061358827591, 2824769338542024173), que re-

torna 8479718265707365 = X4

Concatenando os blocos decodiﬁcados, obtemos a mensagem X procurada. Assim,

temos:

X = 7932857873866982837932656782696873846532786532678273808479718265707365.

Que ap´os aplicarmos a tabela ASCII inversamente, obtemos:

X = O UNIVERSO ACREDITA NA CRIPTOGRAFIA. (Julian Assange)

29

Cap´ıtulo 5

Seguran¸ca e Criptoan´alise do RSA

5.1 Algoritmo da fatora¸c˜ao

Segundo Terada [7], p.21, “Criptoan´alise” ´e o conjunto de t´ecnicas matem´aticas que

tˆem por objetivo atacar um c´odigo a ﬁm de desvendar o signiﬁcado do texto criptografado,

atrav´es da descoberta do algoritmo criptogr´aﬁco, da sua chave de decodiﬁca¸c˜ao ou de um

ataque ao texto cifrado. O criptoanalista portanto nada mais ´e do que um “quebrador”

de c´odigos, e a Ciˆencia da Escrita Secreta tem sido a s´ıtese do confronto entre cript´ografos

e criptoanalistas. A estrat´egia mais importante usada pelos criptoanalistas para atacar o

RSA ´e a tentativa de fatorar n = p·q, pois o expoente de decodiﬁca¸c˜ao d pode ser deduzido

se conhecermos os n´umeros primos p e q, uma vez que e j´a ´e de conhecimento p´ublico,

onde e·d ≡ 1 [mod (p – 1)·(q – 1)] e 1 ≤ d ≤ (p – 1)·(q – 1). Ent˜ao, se algu´em conseguisse

fatorar n = p · q e consequentemente obtivesse d, qualquer mensagem enviada de Alice
para Bob poderia ser facilmente decodiﬁcada, bastando aplicar Xi ≡ C d
i (mod n) ao bloco
criptografado Ci, conforme visto anteriormente. Mas fatorar n ´e praticamente uma tarefa
imposs´ıvel de ser realizada em um tempo humanamente vi´avel e de uma maneira eﬁciente,

a menos que o m´odulo n RSA tenha fatores primos pequenos. Para nos convencermos

disto, vejamos o seguinte resultado:

“Se n n˜ao ´e primo, ent˜ao n possui, necessariamente, um divisor primo p,

tal que p ≤

n”

√

Como estamos supondo n ´e composto, ent˜ao o seu menor divisor ´e um primo p, se n˜ao
fosse existiria outro primo p1 < p, onde p = k · p1, e neste caso p1 tamb´em dividiria n.
Mas isto n˜ao pode ser pois estamos supondo que p ´e o menor divisor de n. Logo p ´e o

menor divisor de n. Ent˜ao podemos escrever n = p · c, onde c ´e um n´umero composto e
1 < p, c < n. Temos que p ≤ c. Multiplicando esta desigualdade por p, temos p2 ≤ p · c,
ou seja, p2 ≤ n, ou ainda p ≤

n.

√

30

Outra maneira equivalente de enunciar este resultado ´e:

“Se um n´umero inteiro positivo n n˜ao possui nenhum divisor primo p,

tal que p ≤

n, ent˜ao n ´e primo”.

√

Com base nos resultados acima, podemos esbo¸car um algoritmo simples que nos diz

se um determinado n´umero inteiro positivo n ´e ou n˜ao primo.

Algoritmo da fatora¸c˜ao

1. Entrada: Um n´umero inteiro positivo n

2. Sa´ıda: n ´e composto ou n ´e primo

3. Instru¸c˜oes: Tente dividir n por 2. Se for divis´ıvel p´are, e dois ´e um fator de n.

Sen˜ao tente dividir n por 3. Se for divis´ıvel, p´are, e trˆes ´e um fator de n. Se n˜ao

for, tente dividir n por 5... Fa¸ca isso at´e encontrar um divisor de n. Neste caso n

ser´a composto. Ou at´e que o candidato a divisor de n seja maior do que

acontece este ´ultimo caso, n ser´a primo!

√

n. Se

Para saber se um n´umero inteiro n ´e ou n˜ao divis´ıvel por outro n´umero a, podemos usar

as regrinhas de divisibilidade ou simplesmente aplicar o algoritmo da divis˜ao euclidiana.

Se o resto for zero, neste caso, n ser´a divis´ıvel por a, e a ser´a um fator de n.

Por exemplo, vamos veriﬁcar se o n´umero 173 ´e ou n˜ao primo usando o algoritmo

“Divis˜oes Sucessivas”. Teremos ent˜ao que tentar dividir 173 por 2, 3, 5, . . . at´e no m´aximo

13, pois

173 = 13, 152 . . . Assim temos que 173 n˜ao ´e divis´ıvel por 2, pois ´e ´ımpar. N˜ao

√

´e divis´ıvel por 3, pois a soma dos seus algarismos d´a 11. N˜ao ´e divis´ıvel por 5, pois o

seu algarismo das unidades n˜ao ´e zero. N˜ao ´e divis´ıvel por 7, pois deixa resto 5. N˜ao ´e

divis´ıvel por 11, pois deixa resto 8, e tamb´em n˜ao ´e divis´ıvel por 13, pois deixa resto 4.

Logo podemos concluir que 173 ´e primo!

Os resultados acima fundamentam o nosso t˜ao conhecido Algoritmo da Fatora¸c˜ao que

n´os aprendemos no sexto ano do ensino fundamental. Se o n´umero dado n for composto,

obteremos necessariamente um menor fator primo menor do que

n . Se continuarmos

√

aplicando o algoritmo da fatora¸c˜ao aos demais fatores de n, teremos no ﬁnal a decom-

posi¸c˜ao prima do n´umero dado. O Teorema Fundamental da Aritm´etica garante que

“todo n´umero inteiro positivo ou ´e primo ou pode ser decomposto em um produto ´unico

de fatores primos, a menos da ordem desses fatores.”

Por exemplo, 120 ´e divis´ıvel por 2, ent˜ao 120 = 2 · 60. Como 60 tamb´em ´e divis´ıvel

por 2, temos 120 = 2 · 2 · 30. Trinta tamb´em ´e divis´ıvel por 2, da´ı 120 = 2 · 2 · 2 · 15. Como

15 ´e divis´ıvel por 3, temos 120 = 2 · 2 · 2 · 3 · 5 = 3 · 2 · 5 · 2 · 2 = 5 · 2 · 3 · 2 · 2 = 2 · 3 · 3 · 5.

31

5.2 Eﬁciˆencia do Algoritmo da fatora¸c˜ao

Vamos analisar agora se o algoritmo das divis˜oes sucessivas ´e eﬁciente quando se trata

de fatorar n´umeros inteiros grandes . Digamos que o m´odulo n que queremos fatorar tem
100 algarismos, onde seus dois fatores primos s˜ao da ordem de 1050, ou seja, considerando-
10100 = 1050. Ou
se sua maior parcela 10100 e dispensando-se as demais, teremos
seja, ter´ıamos que realizar 1050 divis˜oes. Se cada divis˜ao gastasse um tempo de 10−10
segundos, que ´e um tempo muito menor do que o mais r´apido computador que existe
atualmente, levar´ıamos 1050 · 10−10 = 1040 segundos. Como um ano tem, em m´edia,
12 · 30 · 24 · 60 · 60 = 31.104.000 segundos, n´os gastar´ıamos 1040 ÷ 31.104.000 ∼= 1032 anos
= 100.000.000.000.000.000.000.000.000.000.000 anos! Que ´e cem sextilh˜oes de vezes mais

√

tempo do que a idade do universo, segundo os astrof´ısicos estimada em 13 bilh˜oes de anos.

Isto nos mostra que o algoritmo da fatora¸c˜ao ´e extremamente ineﬁciente quando se

trata de fatorar n´umeros inteiros grandes, pois a quantidade de opera¸c˜oes de divis˜ao

cresce exponencialmente com rela¸c˜ao `a quantidade de d´ıgitos do n´umero que se quer

fatorar. Ainda assim, o algoritmo das divis˜oes sucessivas n˜ao ´e totalmente in´util, pois

podemos esperar que o n´umero inteiro dado, mesmo muito grande, tenha um fator primo
“pequeno”, da ordem de 1010 algarismos. Isto pode ocorrer por descuido do programador
do algoritmo RSA sob ataque.

Segundo Paulo Ribenboim em [17], p.107, at´e hoje n˜ao se descobriu nenhum algoritmo

eﬁciente para se fatorar um n´umero inteiro grande, digamos com 200 algarismos. N˜ao se

sabe ainda se este algoritmo pode existir ou n˜ao. Mesmo com toda a Matem´atica e toda

a tecnologia computacional avan¸cada, ´e um problema em aberto fatorar com eﬁciˆencia

um n´umero inteiro muito grande. Esta ´e uma quest˜ao muito s´eria, uma vez que ´e poss´ıvel

algu´em conseguir a proeza em segredo, comprometendo totalmente a seguran¸ca do RSA

e consequentemente de suas aplica¸c˜oes.

Apesar desta cl´assica diﬁculdade em se fatorar um n´umero inteiro grande, algums

sucessos tˆem ocorrido com a utiliza¸c˜ao do Crivo Quadr´atico e do Crivo de Corpos, usando-

se computa¸c˜ao paralela e distribuida entre centenas de computadores de usu´arios da

internet. Aplicando esses m´etodos, j´a foi poss´ıvel fatorar n´umeros de at´e 200 d´ıgitos

decimais, embora em meses de processamento. Ver [7], p.129.

32

Cap´ıtulo 6

Encontrando primos - Testes de

primalidade

Nos exemplos anteriores foram utilizados n´umeros primos “pequenos” na composi¸c˜ao

do m´odulo n = p · q do Algoritmo RSA. Mas para garantir uma seguran¸ca satisfat´oria

para o m´odulo RSA, o ideal ´e que usemos n´umeros primos da ordem de 100 d´ıgitos ou

mais cada um. Conforme visto no item anterior, isso diﬁcultar´a uma tentativa de fatorar

n e obter o expoente de decodiﬁca¸c˜ao d. Na pr´atica, para obter n´umeros primos muito

grandes utilizamos programas de computa¸c˜ao alg´ebrica, a exemplo do MAXIMA.

Mas como ´e poss´ıvel o MAXIMA, ou outro programa de computa¸c˜ao alg´ebrica qual-

quer, encontrar n´umeros primos gigantes, da ordem de 100 d´ıgitos para serem usados no

algoritmo RSA, se j´a sabemos que ´e imposs´ıvel determinar se um n´umero desta ordem ´e

ou n˜ao primo, mesmo com o mais r´apido dos computadores? Ser´a que os programas de

computa¸c˜ao alg´ebrica implementam alguma f´ormula especial que nos forne¸ce o en´esimo

n´umero primo? Bom, essa f´ormula realmente existe, conforme podemos veriﬁcar em [17],

p.118, mas ´e uma f´ormula de grande complexidade computacional, totalmente in´util para

ﬁns pr´aticos. Na verdade, os programas de computa¸c˜ao alg´ebrica implementam crit´erios

de primalidade que consistem em se testar alguma propriedade dos n´umeros primos que

os caracterize com uma grande probabilidade, ou de forma determin´ıstica com base em

alguma propriedade espec´ıﬁca que determinados n´umeros primos apresentam, a exemplo

dos n´umeros de Fermat e Mersenne.

Os testes de primalidade mais eﬁcientes que s˜ao usados em programas de computa¸c˜ao

alg´ebrica s˜ao probabil´ısticos, e se baseiam no famoso Pequeno Teorema de Fermat/Euler:

“Seja p um n´umero primo. Se a ´e um n´umero inteiro tal que mdc(a, p) = 1,

ent˜ao ap – 1 ≡ 1 (mod p)”

Grandes matem´aticos, a exemplo de Leibniz (1646 - 1716), acreditavam que se um
n´umero natural n qualquer satisﬁzesse a congruˆencia an − 1 ≡ 1 (mod n), com mdc(a, n) =

33

1, ent˜ao n seria primo. Ou seja, pensava-se que a rec´ıproca do Pequeno Teorema de Fermat
tamb´em fosse verdadeira, o que n˜ao ´e verdade. Por exemplo 724 ≡ 1 (mod 25) e 25 ´e
composto. Os n´umeros compostos ´ımpares n que satisfazem o Pequeno Teorema de Fermat

s˜ao chamados de “pseudoprimos” na base a. E h´a ainda os n´umeros de Carmichael, que s˜ao

pseudoprimos para todas as bases a relativamente primas com n, o que faz os n´umeros

de Carmichael se “camuﬂarem” totalmente como se fossem n´umeros primos para esta
propriedade. O menor n´umero de Carmichael ´e 561 = 3 · 11 · 17, onde a560 ≡ 1 (mod 561),
para todo a relativamente primo com 561. Segundo S.Shokranian em [6], p.66, foi provado

por Alford, Granville e Pomerance em 1994 que existem inﬁnitos n´umeros de Carmichael.

Conforme Coutinho em [14], p.106, os pseudoprimos e os n´umeros de Carmichael s˜ao

bastante raros quando se testa n´umeros at´e a ordem de um bilh˜ao. Por exemplo, h´a

50.847.534 primos de 1 at´e um bilh˜ao, mas apenas 5587 pseudoprimos para a base 2. Ou

seja, aproximadamente 0,01% dentre primos destes s˜ao pseudoprimos. Se forem usadas

duas bases, por exemplo 2 e 3, conclui-se que h´a somente 1272 pseudoprimos para essas

bases, ou seja 0,0025%. Aumentando-se o n´umero de bases a serem testadas, pode-se

chegar a uma precis˜ao ainda maior neste tipo de teste de primalidade. Claro que esse

cuidado vai depender da importˆancia da aplica¸c˜ao RSA que est´a sendo implementada.

Quanto maior a seguran¸ca das informa¸c˜oes que se quer proteger, maior deve ser o cuidado

com a precis˜ao de um teste de primalidade probabil´ıstico.

Um teste de primalidade probabil´ıstico utilizado na maioria dos programas de com-

puta¸c˜ao alg´ebrica e que se baseia no Pequeno Teorema de Fermat ´e o Teste de Miller-
Rabin. Rabin provou que h´a uma probabilidade menor que 1
4 de este teste acusar
um pseudoprimo quando se testa uma base a aleat´oria. Ver Buchmann [13], p.153.
Ent˜ao, para k bases distintas testadas, h´a uma probabilidade menor que ( 1
4)k de n
ser composto. Por exemplo, testando-se 10 bases, h´a uma probabilidade menor que
4)10 = 1
( 1
220 (cid:39) 0, 000000954 de o n´umero testado n˜ao ser primo. No entanto, o teste
de de Miller-Rabin fundamenta-se na Hip´otese de Riemman Generalizada, que asegura

ser suﬁciene testar um n´umero “pequeno” de bases para se garantir a primalidade de um

n´umero. Ver Ribenboim [17], p.101.

H´a tamb´em os testes determin´ısticos que ﬁnalizam aﬁrmando com toda certeza se um

n´umero natural ´e ou n˜ao primo, embora eles sejam bem mais lentos na sua implementa¸c˜ao

computacional. Um exemplo ´e o teste de Lucas-Lehmer que testa a primalidade de um

n´umero de Mersenne. Ver [14], Cap.09.

Interessante observar que a contrapositiva do Pequeno Teorema de Fermat constitui-se

em um teste de composi¸c˜ao bastante eﬁcaz e determin´ıstico. Isto ´e:

“Se an − 1 (cid:54)≡ 1 (mod n), onde mdc(a, p) = 1, ent˜ao n n˜ao ´e primo”.

34

Ou ainda:

“Se an − 1 (cid:54)≡ 1 (mod n), onde mdc(a, p) = 1, ent˜ao n ´e composto”

Isto ´e, se an − 1 n˜ao ´e congruente a 1 m´odulo n, ent˜ao n ´e composto. Desta forma,
podemos saber se um determinado n´umero inteiro muito grande ´e composto sem no en-
tanto conhecermos seus fatores. Por exemplo, 3340 ≡ 56 (mod 341). Logo podemos ter
certeza de que 341 ´e composto.

Com a onipresen¸ca da internet em nossas vidas e a grande utiliza¸c˜ao do Criptosistema

RSA em seus protocolos de comunica¸c˜ao, podemos nos perguntar se h´a n´umeros primos

grandes o suﬁciente para que sejam gerados m´odulos RSA seguros para atender a todos

os habitantes da terra, de modo que possamos estar certos de que duas pessoas quisquer

n˜ao escolher˜ao o mesmo par de n´umeros primos, ou de que esta possibilidade ´e remota.

E uma vez que os n´umeros primos v˜ao ﬁcando mais raros e mais afastados `a medida que

avan¸camos na sequˆencia dos n´umeros naturais, podemos nos perguntar tamb´em se h´a

n´umeros primos suﬁcientemente grandes, digamos com 100 algarismos, para que possa-

mos obter um m´udulo RSA de 200 d´ıgitos, o que ´e considerado atualmente um n´ıvel de

seguran¸ca bastante satisfat´orio para a maioria das aplica¸c˜oes do RSA.

O Teorema dos N´umeros Primos de Gauss-Hadamard-Poussin nos garante que a quan-

tidade de primos de 1 at´e um dado natural n, denotada por π(n), ´e pr´oxima e sempre

menor do que o quociente de n por ln n quando n tende ao inﬁnito, ou seja:

π(n) ∼=

n
ln n

, para n → ∞.

Dessa forma temos que a quatidade de primos de 100 algarismos ´e igual `a quantidade
de primos at´e 10100 menos a quantidade de primos at´e 1099. Aplicando o Teorema dos
N´umeros Primos, temos:

10100
ln 10100

-

1099
ln 1099

∼= 3, 9 · 1097

Supondo que o Planeta Terra tivesse 10 bilh˜oes de habitantes, o que ´e claramente

uma estimativa exagerada, a quantidade de n´umeros primos de 100 algarismos para cada

habitante, seria:

3, 9 · 1097
1010

= 3, 9 · 1087

Que ´e aproximadamente 2 · 1087 pares distintos de primos para cada um dos 10 bilh˜oes

de habitantes da suposta popula¸c˜ao terr´aquea!

35

Apˆendice A

Comandos do MAXIMA para o RSA

O MAXIMA ´e um poderoso programa de computa¸c˜ao alg´ebrica que, dentre muitas

coisas, possui valiosas ferramentas para se explorar os principais elementos da Teoria dos

N´umeros ligados `as aplica¸c˜oes ao Criptosistema RSA. Sua vers˜ao gr´aﬁca wxMAXIMA

12.04.0 pode ser obtida gratuitamente no saite:

http://wxmaxima.sourceforge.net/wiki/index.php/Main_Page

Seguem abaixo os comandos b´asicos usados neste trabalho.

• primep(n): Se retornar "false", n ´e composto. Se retornar
"true", n ´e primo com grande probabilidade.(Miller-Rabin)

• factor(n): Retorna a fatora¸c~ao de n.

• next_prime(n): Retorna o menor primo maior que n.

• prev_prime(n): Retorna o maior primo menor que n.

• inv_mod(n,m): Retorna o inverso de n m´odulo m. Retorna

"false" se n m´odulo m for zero.

• remainder(D,q): Retorna o resto da divis~ao de D por q.

• power_mod(a,n,m): Retorna o resto da divis~ao de a^n por m.

• gcd(n,m): Retorna o mdc de n e m.

• float(n): Retorna o valor decimal aproximado de n.

36

Apˆendice B

Tabela ASCII imprim´ıveis

mai´usculos

Letra Rep. decimal Rep. bin´aria Letra Rep. decimal Rep. bin´aria

Espa¸co

A

B

C

D

E

F

G

H

I

J

K

L

M

32

65

66

67

68

69

70

71

72

73

74

75

76

77

0101 1010

0100 0001

0100 0010

0100 0011

0100 0100

0100 0101

0100 0110

0100 0111

0100 1000

0100 1001

0100 1010

0100 1011

0100 1100

0100 1101

N

O

P

Q

R

S

T

U

V

W

X

Y

Z

78

79

80

81

82

83

84

85

86

87

88

89

90

0100 1110

0100 1111

0101 0000

0101 0001

0101 0010

0101 0011

0101 0100

0101 0101

0101 0110

0101 0111

0101 1000

0101 1001

0101 1010

37

Referˆencias Bibliogr´aﬁcas

[1] CRATO, Nuno. A Matem´atica das Coisas, Editora Gradiva, Lisboa-Portugal, 10.ed,

2010.

[2] RANGEL, Ricardo. Passado e futuro da Era da Informa¸c˜ao, Editora Nova Fronteira,

Rio de Janeiro-RJ,1.ed.,1999.

[3] BENNET, Deborah J., Aleatoriedade, Editora Martins Fontes, S˜ao Paulo,1.ed.,2003.

[4] SINGH, Simon. O Livro dos C´odigos, Editora Record, Rio de Janeiro-RJ,3.ed,2003.

[5] KHAN, David. The Codebreakers - The story of secret writing, Editora New American

Library-NY-USA, 1.ed.,1973.

[6] SHOKRANIAN,

Salahodin. Criptograﬁa

para

iniciantes, Editora Ciˆencia

Moderna,Brasilia-DF, 2.ed., 2012.

[7] TERADA, Routo. Seguran¸ca de Dados: Criptograﬁa em redes de computadores, Edi-

tora Edgard Blucher,S˜ao Paulo-SP, 2.ed., 2008.

[8] KNUTH, Donald E., The art of computer programming, Editora Addison-Wesly Pu-

blishing Company, INC,Menlo Park-Califonia-USA, Volume1, 2.ed., 1973.

[9] HEFEZ, Abramo. Elementos de aritm´etica - Cole¸c˜ao Textos Universit´aros, Editora

da SBM, Rio de Janeiro-RJ, 2.ed.,2006.

[10] SILVA, Valdir Vilmar da. N´umeros - Constru¸c˜ao e propriedades, Editora da UFG,

Goiˆania-GO, 1.ed.,2003.

[11] SANTOS, Jos´e Pl´ınio de Oliveira. Introdu¸c˜ao `a Teoria dos N´umeros, Editora do

IMPA, Rio de Janeiro-RJ,3.ed.,2010.

[12] SAUTOY, Marcus du. A m´usica dos n´umeros primos, Editora Jorge Zahar, Rio de

Janeiro-RJ,1.ed.,2007.

[13] BUCHMANN, Johannes. Introdu¸c˜ao `a Criptograﬁa, Editora Berkeley, S˜ao Paulo-

SP,1.ed,2002.

38

[14] COUTINHO, S.C. N´umeros inteiros e Criptograﬁa RSA, Editora do IMPA, Rio de

Janeiro-RJ,1.ed,2007.

[15] COUTINHO, S.C. Primalidade em tempo polinomial, Editora da SBM, Janeiro-

RJ,1.ed,2004.

[16] COUTINHO, S.C. Criptograﬁa - Programa de Inicia¸c˜ao cient´ıﬁca OBMEP, Editora

da SBM, Janeiro-RJ,1.ed.,2008.

[17] RINBEMBOIM, Paulo. N´umeros primos: mist´erios e recordes, Editora do IMPA,

Janeiro-RJ,1.ed.,2001.

[18] LOV ´AZ, L., PELIK ´AN J. e VESZTERGOMBI K. Matem´atica Discreta, Editora da

SBM, Janeiro-RJ,1.ed.,2003.

[19] LAURITZEN, Niels. Concrete abstract algebra, Editora Cambridge University Press,

Cambridge-UK,5.ed.,2009.

[20] STEWART, Ian. Concepts of modern mathematics, Editora Dover Publications, INC,

New York-NY-USA,1.ed.,1995.

39

