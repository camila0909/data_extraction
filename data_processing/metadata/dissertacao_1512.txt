UNIVERSIDADE FEDERAL DA GRANDE DOURADOS - UFGD

Anderson Lopes de Barros

A Álgebra dos Códigos Corretores de Erros

Dourados - MS

2019

Anderson Lopes de Barros

A Álgebra dos Códigos Corretores de Erros

Dissertação apresentada ao ﬁnal do Programa
de Mestrado Proﬁssional em Matemática em
Rede Nacional - PROFMAT da Universidade
Federal da Grande Dourados - UFGD como
requisito parcial para obtenção do grau de
Mestre em Matemática.

Universidade Federal da Grande Dourados - UFGD

Faculdade de Ciências Exatas e Tecnologia

Orientador: Profa. Dra. Ana Cláudia Machado Mendonça

Dourados - MS

2019

(cid:39)(cid:68)(cid:71)(cid:82)(cid:86)(cid:3)(cid:44)(cid:81)(cid:87)(cid:72)(cid:85)(cid:81)(cid:68)(cid:70)(cid:76)(cid:82)(cid:81)(cid:68)(cid:76)(cid:86)(cid:3)(cid:71)(cid:72)(cid:3)(cid:38)(cid:68)(cid:87)(cid:68)(cid:79)(cid:82)(cid:74)(cid:68)(cid:111)(cid:109)(cid:82)(cid:3)(cid:81)(cid:68)(cid:3)(cid:51)(cid:88)(cid:69)(cid:79)(cid:76)(cid:70)(cid:68)(cid:111)(cid:109)(cid:82)(cid:3)(cid:11)(cid:38)(cid:44)(cid:51)(cid:12)(cid:17)

(cid:37)(cid:21)(cid:26)(cid:26)(cid:105)(cid:3) (cid:37)(cid:68)(cid:85)(cid:85)(cid:82)(cid:86)(cid:15)(cid:3)(cid:36)(cid:81)(cid:71)(cid:72)(cid:85)(cid:86)(cid:82)(cid:81)(cid:3)(cid:47)(cid:82)(cid:83)(cid:72)(cid:86)(cid:3)(cid:39)(cid:72)

(cid:36)(cid:3)(cid:200)(cid:79)(cid:74)(cid:72)(cid:69)(cid:85)(cid:68)(cid:3)(cid:71)(cid:82)(cid:86)(cid:3)(cid:38)(cid:121)(cid:71)(cid:76)(cid:74)(cid:82)(cid:86)(cid:3)(cid:38)(cid:82)(cid:85)(cid:85)(cid:72)(cid:87)(cid:82)(cid:85)(cid:72)(cid:86)(cid:3)(cid:71)(cid:72)(cid:3)(cid:40)(cid:85)(cid:85)(cid:82)(cid:86)(cid:3)(cid:62)(cid:85)(cid:72)(cid:70)(cid:88)(cid:85)(cid:86)(cid:82)(cid:3)(cid:72)(cid:79)(cid:72)(cid:87)(cid:85)(cid:123)(cid:81)(cid:76)(cid:70)(cid:82)(cid:64)(cid:3)(cid:18)(cid:3)(cid:36)(cid:81)(cid:71)(cid:72)(cid:85)(cid:86)(cid:82)(cid:81)(cid:3)(cid:47)(cid:82)(cid:83)(cid:72)(cid:86)(cid:3)(cid:39)(cid:72)(cid:3)(cid:37)(cid:68)(cid:85)(cid:85)(cid:82)(cid:86)(cid:17)(cid:3)(cid:16)(cid:16)

(cid:21)(cid:19)(cid:20)(cid:28)(cid:17)

(cid:36)(cid:85)(cid:84)(cid:88)(cid:76)(cid:89)(cid:82)(cid:3)(cid:72)(cid:80)(cid:3)(cid:73)(cid:82)(cid:85)(cid:80)(cid:68)(cid:87)(cid:82)(cid:3)(cid:83)(cid:71)(cid:73)(cid:17)

(cid:50)(cid:85)(cid:76)(cid:72)(cid:81)(cid:87)(cid:68)(cid:71)(cid:82)(cid:85)(cid:68)(cid:29)(cid:3)(cid:36)(cid:81)(cid:68)(cid:3)(cid:38)(cid:79)(cid:68)(cid:88)(cid:71)(cid:76)(cid:68)(cid:3)(cid:48)(cid:68)(cid:70)(cid:75)(cid:68)(cid:71)(cid:82)(cid:3)(cid:48)(cid:72)(cid:81)(cid:71)(cid:82)(cid:81)(cid:111)(cid:68)(cid:3)(cid:38)(cid:75)(cid:68)(cid:74)(cid:68)(cid:86)(cid:17)
(cid:39)(cid:76)(cid:86)(cid:86)(cid:72)(cid:85)(cid:87)(cid:68)(cid:111)(cid:109)(cid:82)(cid:3)(cid:11)(cid:48)(cid:72)(cid:86)(cid:87)(cid:85)(cid:68)(cid:71)(cid:82)(cid:3)(cid:72)(cid:80)(cid:3)(cid:48)(cid:68)(cid:87)(cid:72)(cid:80)(cid:105)(cid:87)(cid:76)(cid:70)(cid:68)(cid:12)(cid:16)(cid:56)(cid:81)(cid:76)(cid:89)(cid:72)(cid:85)(cid:86)(cid:76)(cid:71)(cid:68)(cid:71)(cid:72)(cid:3)(cid:41)(cid:72)(cid:71)(cid:72)(cid:85)(cid:68)(cid:79)(cid:3)(cid:71)(cid:68)(cid:3)(cid:42)(cid:85)(cid:68)(cid:81)(cid:71)(cid:72)(cid:3)(cid:39)(cid:82)(cid:88)(cid:85)(cid:68)(cid:71)(cid:82)(cid:86)(cid:15)(cid:3)(cid:21)(cid:19)(cid:20)(cid:28)(cid:17)
(cid:39)(cid:76)(cid:86)(cid:83)(cid:82)(cid:81)(cid:116)(cid:89)(cid:72)(cid:79)(cid:3)(cid:81)(cid:82)(cid:3)(cid:53)(cid:72)(cid:83)(cid:82)(cid:86)(cid:76)(cid:87)(cid:121)(cid:85)(cid:76)(cid:82)(cid:3)(cid:44)(cid:81)(cid:86)(cid:87)(cid:76)(cid:87)(cid:88)(cid:70)(cid:76)(cid:82)(cid:81)(cid:68)(cid:79)(cid:3)(cid:71)(cid:68)(cid:3)(cid:56)(cid:41)(cid:42)(cid:39)(cid:3)(cid:72)(cid:80)(cid:29)

(cid:75)(cid:87)(cid:87)(cid:83)(cid:86)(cid:29)(cid:18)(cid:18)(cid:83)(cid:82)(cid:85)(cid:87)(cid:68)(cid:79)(cid:17)(cid:88)(cid:73)(cid:74)(cid:71)(cid:17)(cid:72)(cid:71)(cid:88)(cid:17)(cid:69)(cid:85)(cid:18)(cid:86)(cid:72)(cid:87)(cid:82)(cid:85)(cid:18)(cid:69)(cid:76)(cid:69)(cid:79)(cid:76)(cid:82)(cid:87)(cid:72)(cid:70)(cid:68)(cid:18)(cid:85)(cid:72)(cid:83)(cid:82)(cid:86)(cid:76)(cid:87)(cid:82)(cid:85)(cid:76)(cid:82)

(cid:20)(cid:17)(cid:3)(cid:38)(cid:121)(cid:71)(cid:76)(cid:74)(cid:82)(cid:86)(cid:17)(cid:3)(cid:21)(cid:17)(cid:3)(cid:51)(cid:68)(cid:85)(cid:76)(cid:71)(cid:68)(cid:71)(cid:72)(cid:17)(cid:3)(cid:22)(cid:17)(cid:3)(cid:57)(cid:72)(cid:87)(cid:82)(cid:85)(cid:17)(cid:3)(cid:23)(cid:17)(cid:3)(cid:48)(cid:68)(cid:87)(cid:85)(cid:76)(cid:93)(cid:3)(cid:42)(cid:72)(cid:85)(cid:68)(cid:71)(cid:82)(cid:85)(cid:68)(cid:17)(cid:3)(cid:24)(cid:17)(cid:3)(cid:38)(cid:121)(cid:71)(cid:76)(cid:74)(cid:82)(cid:3)(cid:71)(cid:72)(cid:3)(cid:43)(cid:68)(cid:80)(cid:80)(cid:76)(cid:81)(cid:74)(cid:17)(cid:3)(cid:44)(cid:17)(cid:3)(cid:38)(cid:75)(cid:68)(cid:74)(cid:68)(cid:86)(cid:15)(cid:3)(cid:36)(cid:81)(cid:68)

(cid:38)(cid:79)(cid:68)(cid:88)(cid:71)(cid:76)(cid:68)(cid:3)(cid:48)(cid:68)(cid:70)(cid:75)(cid:68)(cid:71)(cid:82)(cid:3)(cid:48)(cid:72)(cid:81)(cid:71)(cid:82)(cid:81)(cid:111)(cid:68)(cid:17)(cid:3)(cid:44)(cid:44)(cid:17)(cid:3)(cid:55)(cid:116)(cid:87)(cid:88)(cid:79)(cid:82)(cid:17)

(cid:41)(cid:76)(cid:70)(cid:75)(cid:68)(cid:3)(cid:70)(cid:68)(cid:87)(cid:68)(cid:79)(cid:82)(cid:74)(cid:85)(cid:105)(cid:73)(cid:76)(cid:70)(cid:68)(cid:3)(cid:72)(cid:79)(cid:68)(cid:69)(cid:82)(cid:85)(cid:68)(cid:71)(cid:68)(cid:3)(cid:68)(cid:88)(cid:87)(cid:82)(cid:80)(cid:68)(cid:87)(cid:76)(cid:70)(cid:68)(cid:80)(cid:72)(cid:81)(cid:87)(cid:72)(cid:3)(cid:71)(cid:72)(cid:3)(cid:68)(cid:70)(cid:82)(cid:85)(cid:71)(cid:82)(cid:3)(cid:70)(cid:82)(cid:80)(cid:3)(cid:82)(cid:86)(cid:3)(cid:71)(cid:68)(cid:71)(cid:82)(cid:86)(cid:3)(cid:73)(cid:82)(cid:85)(cid:81)(cid:72)(cid:70)(cid:76)(cid:71)(cid:82)(cid:86)(cid:3)(cid:83)(cid:72)(cid:79)(cid:82)(cid:11)(cid:68)(cid:12)(cid:3)(cid:68)(cid:88)(cid:87)(cid:82)(cid:85)(cid:11)(cid:68)(cid:12)(cid:17)

(cid:139)(cid:39)(cid:76)(cid:85)(cid:72)(cid:76)(cid:87)(cid:82)(cid:86)(cid:3)(cid:85)(cid:72)(cid:86)(cid:72)(cid:85)(cid:89)(cid:68)(cid:71)(cid:82)(cid:86)(cid:17)(cid:3)(cid:51)(cid:72)(cid:85)(cid:80)(cid:76)(cid:87)(cid:76)(cid:71)(cid:82)(cid:3)(cid:68)(cid:3)(cid:85)(cid:72)(cid:83)(cid:85)(cid:82)(cid:71)(cid:88)(cid:111)(cid:109)(cid:82)(cid:3)(cid:83)(cid:68)(cid:85)(cid:70)(cid:76)(cid:68)(cid:79)(cid:3)(cid:71)(cid:72)(cid:86)(cid:71)(cid:72)(cid:3)(cid:84)(cid:88)(cid:72)(cid:3)(cid:70)(cid:76)(cid:87)(cid:68)(cid:71)(cid:68)(cid:3)(cid:68)(cid:3)(cid:73)(cid:82)(cid:81)(cid:87)(cid:72)(cid:17)

Dedicado a:
Meus Pais, João e Elizabethe, os quais sempre me disseram que estudo é ferramenta de
mudança de realidade e apoiaram desde os primeiros passos, além do meu irmão,
Alexsandro, que torcem e comemoram por cada passo dado;
Meus Primeiros professores, com os quais me ﬁzeram ter o gosto pela matemática;
As pessoas que aparecem em nosso caminho da escola pública ao mestrado, e que estão lá
ajudando e incentivando a não desistir dos objetivos.

Agradecimentos

Agradecer é um hábito que aprendemos desde pequenos, mas que a vida com seus
percalços e dinâmicas nos forçam a fazer com menos frequência. Revisitar todos aqueles
que fazem e ﬁzeram parte da nossa vida e demonstrar gratidão, é uma qualidade que
precisamos exercitar e por que não, incentivar.

Nessa caminhada, do tempo que tomei gosto pela matemática até este momento,
muitas diﬁculdades, amarguras, decepções e desapontamentos já atormentaram os pen-
samentos, mas é graças a ajuda de pessoas que podemos nos reerguer, lutar e superar
desaﬁos.

Dessas diversas pessoas que entram na nossa vida e caminham conosco, o meu
agradecimento a algumas delas e outras tantas que participaram da minha caminhada.
Primeiramente, a Deus, pelas oportunidades oferecidas e pela vontade e ânimo que
disponibiliza a mim, mesmo passando pelas mais diversas e tristes situações desde os
tempos de Ensino Médio (as quais, alias, alguns de meus orientadores e colegas conheceram
bem).

A meus pais, João(que me observa lá de cima), Elizabethe, minha mãe, parceira
e conﬁdente de todos os momentos, que garante que eu seja teimoso e batalhador pelas
coisas que acreditamos e a meu irmão Alexsandro, que ainda tem muito a caminhar, mas
que torce junto com meus familiares.

A minha família, em especial, aos tios Ademir e Valéria, de Presidente Prudente,
que observam a distância parte dessa grande viagem que é de deslocar a dourados e
ouviram bastante histórias sobre as coisas ocorridas nesse caminho.

Aos Amigos, professores dos tempos de escola e aqueles que acreditam e torcem
por mim, lá de Euclides da Cunha, dentre eles em especial Carmelita Matias e Eulides
Nicácio, Bete Calegari, Yolanda Sales e Suerley Negrão, que de certa forma atuaram na
minha história no Ensino Básico e a entrada na Graduação. Também, aos amigos com os
quais trabalho, colegas de auxílio nos desaﬁos diários, Tchuska, Lurdinha,Vera, Luciana,
Cleide, Karla, Tereza, entre tantos outros.

Das graduações até o acesso ao PROFMAT, agradeço àqueles que caminharam
comigo nestes cursos e aos professores que se tornaram colegas nesse período, nomes que
são tantos, mas citando nominalmente podem fazer deixar alguem de fora. Também, aos
professores que acabaram por se tornarem colegas durante este período. Faço aqui também
um agradecimento a Alessandra Dan, que junto comigo se aventurou nessa caminhada que
foi realizar o mestrado, participando e inscrevendo-se no processo seletivo.

Um agradecimento aos meus colegas que me acompanharam e se ﬁzeram presentes
nesses tempos de PROFMAT(turma 2016), dos quais Anderson, Beatriz, Eduarda, Miquéias,
Naiguiel, Rodrigo e Viviane. Estendo um especial agradecimento aos colegas Edvair, Éder
e Katiuce (pelas viagens, e diversas histórias vividas durante todo esse tempo, além do
auxílio no latex) além da Márcia(que além de dedicação extrema e fornecedora dos cafés
que tanto tomei, é de uma tranquilidade e paciência que é um exemplo a ser seguido, sem
contar o fato de que ainda me aconselhou bastante durante o preparo desta obra).

Finalizando os agradecimentos, expressando gratidão e parabenizando aos profes-
sores do PROFMAT, que entre conselhos, broncas e listas de exercícios, mostram que o
mestrado exige dedicação, estudo e muitos cafés nas madrugadas, sempre incentivando-nos
e não deixando desanimar-nos.

Por último, mas com o alto grau de importância que se dedicam a tarefa de ensinar,
agradeço as minhas orientadoras (sim, são duas), Ana Cláudia, pelo suporte e auxílio que
me dá desde o momento da deﬁnição do tema deste trabalho, incluindo os seminários mais
intensivos nessa fase ﬁnal, e a professora Irene Craveiro, nossa coordenadora, que desde
o início da turma esteve acompanhando o passo a passo de todos os alunos, orientando,
nos fazendo tomar ideia da realidade, puxando nossa orelha quando necessário, sempre
vislumbrando a conclusão de nossos esforços. São dois "Anjos"pelos quais sou muito grato
por todas as oportunidades vividas, pelo tempo que cederam e se dedicaram aos meus
estudos. São pessoas como todos vocês que marcam as nossas vidas e fazem com que eu
reveja o passado e possa dizer com satisfação: "A MATEMÁTICA MUDA VIDAS, e vale
a pena lutar por essas oportunidades"

Muitíssimo Obrigado!

Dessa aventura, levo amigos pra vida toda!! É muito bom poder contar com todos

vocês!!

"O presente trabalho foi realizado com apoio da Coordenação de Aperfeiçoamento de
Pessoal de Nível Superior Brasil (CAPES) - Código de Financiamento 001"

“Tudo o que um sonho precisa para ser realizado é alguém que acredite que ele possa ser
realizado.”

Roberto Shinyashiki.

Resumo

O trabalho com códigos corretores de erros é de grande utilidade em nossos dias, não
somente para a avaliação de esquemas de identiﬁcação, como também nas transmissões e
envio de diversos tipos de mídia utilizando os meios digitais. O que muitos não sabem é
que a implementação desses códigos e os algoritmos que permitem a segurança ou ainda
a recuperação destas informações utilizam esquemas de álgebra abstrata, conteúdo não
trabalhado em sala de aula. O escopo desse trabalho é falar sobre a álgebra escondida no
uso dos códigos e mostrar suas aplicações no dia a dia, apresentando um pouco sobre a
teoria do códigos corretores de erros e mostrar sua aplicabilidade em situações do cotidiano,
sugerindo um plano de trabalho que pode ser apresentado nas séries ﬁnais do Ensino
Fundamental, realizando um paralelo com os conteúdos trabalhados no meio acadêmico,
tais como relacionados a matrizes, vetores, paridade e algoritmos digitais.

Palavras-chaves: Códigos, paridade, matriz geradora, código de Hamming.

Abstract

The work related to error-correction codes is of great use today, not only for the validation
of identiﬁcation schemes, but also for the transmission and sending of various kinds of
media using digital media. What many people do not know is that the implementation
of these codes and the algorithmus that allow the security or even the retrieval of this
information use abstract algebra schemes, unworked content in our graduation.The scope of
this work is to present the hidden algebra in the use of codes and to show their applications
on a day by day, presenting a bit about the theory of error-correcting codes and showing
their applicability in everyday situations, suggesting a work plan that can to be presented
in the ﬁnal series of Elementary School, making a parallel with the contents worked in
the academic environment such as the related to matrices, vectors, parity and digital
algorithms.

Key-words: Codes, parity, generating matrix, Hamming code.

Lista de ilustrações

Figura 2.1 – Gauss e sua obra de referência para a teoria dos números . . . . . . . . 15
Figura 2.2 – O Cadastro de Pessoa Física - CPF . . . . . . . . . . . . . . . . . . . . 23
Figura 2.3 – Regiões Fiscais- CPF . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
Figura 2.4 – Mecanismo de Segurança da Nota do Euro . . . . . . . . . . . . . . . . 27
. . . . . . . . . . . . . . . . . . . . . . . . . 42
Figura 3.1 – Exemplo de colunas pivô.
Figura 4.1 – Acrescentando Bits de Paridade ao pacote de informação . . . . . . . . 49
Figura 4.2 – Procedimento para a transmissão de Mensagem . . . . . . . . . . . . . 50
Figura 4.3 – Hipercubo Binário de 3 bits . . . . . . . . . . . . . . . . . . . . . . . . 55
Figura 5.1 – Aula 12(OBMEP)- Sistemas de Numeração
. . . . . . . . . . . . . . . 78
Figura 5.2 – Conversão Decimal - Binário . . . . . . . . . . . . . . . . . . . . . . . . 79
. . . . . . . . . . . . 80
Figura 5.3 – Trecho da Tabela ASCII - Código Binário, 1963.

Lista de tabelas

Tabela 2.1 – Tabelas de adição e multiplicação em Z4 . . . . . . . . . . . . . . . . .

21

Sumário

Lista de tabelas

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

Sumário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

O ANEL DAS CLASSES RESIDUAIS . . . . . . . . . . . . . . . . . 15
O conjunto das classes residuais . . . . . . . . . . . . . . . . . . . . . 16
O Corpo Finito com um Número Primo de Elementos. . . . . . . . . 20
Alguns exemplos práticos de aplicação de Classes Residuais . . . . . 22
Os Dígitos de Veriﬁcação do CPF . . . . . . . . . . . . . . . . . . . . 23
As potências nas Congruências . . . . . . . . . . . . . . . . . . . . . . 25
Os ponteiros do relógio. . . . . . . . . . . . . . . . . . . . . . . . . . . 26
. . . . . . . . . . . . . . 27
Os números de segurança na nota do Euro.

O ESPAÇO VETORIAL FINITO Zn
p . . . . . . . . . . . . . . . . . . . 29
O Espaço Vetorial Zn
. . . . . . . . . . . . . . . . . . . . . . . . . . . 29
p
Os Subespaços de Zn
. . . . . . . . . . . . . . . . . . . . . . . . . . . 31
p
Combinação Linear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Subespaço Gerado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Dependência e Independência Linear em Zn
. . . . . . . . . . . . . . 34
p
Base e Dimensão de Subespaços de Zn
p . . . . . . . . . . . . . . . . . 37
Processo Prático Para Determinar Bases de Subespaços de Zn
p . . . 42
A Função Produto Interno em Zn
. . . . . . . . . . . . . . . . . . . . . . 46
p

CÓDIGOS LINEARES: CONCEITOS E A MÉTRICA DE HAMMING 48
Código Linear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
Métrica de Hamming . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
Matriz Geradora do Código . . . . . . . . . . . . . . . . . . . . . . . . 56
Código Dual e Matriz Teste de Paridade. . . . . . . . . . . . . . . . . 59
O Processo de Decodiﬁcação dos Códigos Lineares . . . . . . . . . . 66

O CÓDIGO LINEAR DE HAMMING E A ABORDAGEM DE CÓ-
DIGOS NO ENSINO BÁSICO. . . . . . . . . . . . . . . . . . . . . . 73
O Código de Hamming Binário . . . . . . . . . . . . . . . . . . . . . . 74
Sugestões da abordagem de Códigos de Erros no Ensino Básico . . 76
PLANO DE AULA PARA O ENSINO FUNDAMENTAL . . . . . . . . . . . 77

1

2
2.1
2.2
2.3
2.3.1
2.3.2
2.3.3
2.3.4

3
3.1
3.2
3.3
3.4
3.5
3.6
3.7
3.7.1

4
4.1
4.2
4.3
4.4
4.5

5

5.1
5.2
5.2.1

6

PALAVRAS FINAIS. . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

1 Introdução

13

Em nossas escolas, o desaﬁo no ensino de matemática é provar, por meio de
generalizações as estruturas e relações que conjuntos numéricos possuem. Algebrizar
operações envolvendo esses números e as propriedades que apresentam é algo que pode ser
elevado a um nível alto e tão importante que diversas ciências (além da matemática) se
utilizam dela.

A álgebra que denominamos “Abstrata” é utilizada para complementar a álgebra
elementar estudada no colégio, na qual são abordadas regras para manipular (somar,
multiplicar, etc) expressões algébricas em que aparecem variáveis e números reais ou
complexos. As ideias que este ramo da matemática trazem permitem estudar propriedades
e padrões que distintos conceitos de matemática tem em comum e com a ajuda desses
conceitos entender as operações e aplicações em áreas como a informática, por exemplo.

Parte-se da ideia de que, ao agrupar as coleções em conjuntos, existem operações
que são comuns a elas e obedecem a estruturas. Assim, a algébra abstrata levou em conta
que temos um conjunto númerico com elementos, que obedecendo uma operação binária
resulta num novo elemento.

Como citado em (DIAS, 1994)

“No novo cálculo se faz necessário instituir a relação de identidade; sem
a qual não se poderia comparar as classes originárias com outras delas
derivadas pelas operações basilares de . e +. Portanto, tome-se o símbolo
= para identiﬁcá-la. Ou seja, considerando-se o símbolo = entre os
símbolos que designam duas classes quaisquer (x e y, por exemplo) está
a indicar-se que as classes têm os mesmos membros e denota-se: x = y...
apresente-se a deﬁnição de sistema algébrico ou de álgebra abstrata; isto
é, denominam-se Álgebra Abstrata ou Sistema Algébrico a um conjunto
não vazio munido de um ou mais operadores binários sobre ele deﬁnidos.
Logo, designado por A o conjunto em questão, tem-se (A,∗,#) indica
uma álgebra com dois operadores”

A partir dessa deﬁnição, como ponto de partida, é possível entender que ela se
estrutura em propriedades e demonstrações as quais discorremos no capítulo seguinte.
Para se ter uma ideia da importância destes conceitos, uma aplicação prática de álgebra
abstrata se faz presente quando abordamos códigos corretores e erros, uma vez que, por
meio de teorias, temos um conjunto de “ palavras”, fundada em conjuntos numéricos,
que obedecem as estruturas que se realizam por meio de operação entre elementos desse
conjunto.

Nas comunicações, tal importância se faz ainda mas presente, seja pela questão da
segurança/conﬁabilidade, seja pela integridade da informação enviada/lida. O envio de

Capítulo 1.

Introdução

14

uma mensagem implica que ela seja clara, coesa e organizada segundo o código padrão
(alfabeto/idioma). Quando comunicamos nos meios digitais, onde máquinas se utilizam
de códigos numéricos, é comum que esta mensagem seja enviada de forma redundante,
e que máquinas no emissor e no destinátario se utilizam de algoritmos para desvelar a
mensagem enviada e tentar corrigi-la em caso de erros.

Os trabalhos ce Hamming, Galoy e Shannon permitiram que a partir da década
de 40, a comunicação por meios digitais desse um salto em eﬁciência e qualidade na
transmissão, e seus estudos são utilizados até hoje.

O que chamamos de Teoria da informação, na area de comunicações, é na verdade,
uma aplicação matemática e algébrica dos códigos Corretores de erros, que abordaremos
neste trabalho.

No capítulo 2, compreenderemos o processo de determinação das classes residuais,
para a construção de um código sobre um corpo ﬁnito. O conjunto escolhido foi o conjunto
Zp, com p primo, o qual provaremos que é um corpo ﬁnito. Finalizando o estudo do
capítulo, apresentamos algumas aplicações práticas da congruência módulo m na validação
dos códigos como o CPF e da nota de Euro, por meio do chamado dígito de veriﬁcação
(DV).

No capítulo 3, estudaremos o espaço vetorial ﬁnito Zn

p . Sua importância é pelo fato
que as “palavras” desse código podem ser entendidas como um vetores de coordenadas em
Zp.

No capítulo 4, são apresentadas as ideias de criação e interpretação dos códigos

lineares, assim como as matrizes responsáveis pela codiﬁcação e decodiﬁcação.

Por ﬁm, no último capítulo, entendido o processo de criação e as palavras do código,
já será possível entender com mais clareza o código de Hamming. Concluindo, daremos
sugestões para um plano de aula no Ensino Fundamental, contemplando alguns conceitos
associados aos códigos e às impressões sobre a álgebra presente neles, assim como o porquê
de se abordar, em cada nível de ensino o uso dessa álgebra.

Como se vê, a álgebra dos códigos de erros é um campo vasto que parte das
operações vistas em estruturas algébricas nos campos acadêmicos, mas não se restringem
somente a teorias. A álgebra dos códigos pode ser trabalhada em outras modalidades do
ensino básico até mesmo para mostrar sua importância e aplicabilidade.

2 O Anel das Classes Residuais

15

Na teoria nos números, independente para qual quantidade ou contagem que se
faça, temos na beleza da matemática a ideia de que todo o número tem característica que
os tornam próprios e especiais. Sejam primos, quadrados, ímpares, perfeitos, compostos,
inteiros ou racionais, o que temos na verdade é que eles possuem características que
permitem agrupá-los em conjuntos ou observar suas propriedades.

A teoria dos números é a área da matemática cujo objetivo é descobrir e estabelecer
as relações profundas e sutis que números de tipos diferentes guardam entre si e ao longo
da história, diversos pensadores, ﬁlósofos ou essencialmente matemáticos ﬁzeram com que
essa evoluísse, criando e provando teoremas dos mais diversos. Desde Pitágoras, Euclides,
Fermat, Gauss, entre outros, foi possível entender as relações que alguns números possuem
e até mesmo facilitar cálculos.

Gauss, em 1801, com 24 anos de idade, estabeleceu um novo conceito: o de con-

gruência

Figura 2.1 – Gauss e sua obra de referência para a teoria dos números

Fonte: autor/banco de imagens-internet

No capítulo destinado ao tema em seu livro, ele anuncia, de modo prático que:

Deﬁnição 2.1. Se um número m divide a diferença a − b ou (b − a) de dois números
inteiros a e b, então dizemos que a é congruente a b módulo m e denota-se

a ≡ b mod m

Capítulo 2. O Anel das Classes Residuais

16

O símbolo ≡ é de importante contribuição, pois realiza uma analogia entre con-

gruência e igualdades.

A congruência satisfaz as propriedades reﬂexiva, simétrica e transitiva. Ao enunciar
essas teorias, e suas decorrentes propriedades para o conjunto dos números inteiros é
deﬁnido o anel do conjunto Zm, formado pelas classes residuais módulo m, objeto de nosso
capítulo. O desenvolvimento dos resultados, conceitos e exemplos desse capítulo foram
baseados no livro (HEFEZ, 2008) .

2.1 O conjunto das classes residuais

O conjunto do números inteiros Z pode ser particionado em subconjuntos da
seguinte maneira: Dado x ∈ Z, m > 1, para todo a ∈ Z, x deixa restos 0, 1, 2, . . . ou, m − 1
quando dividido por m. Dessa forma deﬁnimos as classes:

[0] = {x ∈ Z; x ≡ 0 mod m}
[1] = {x ∈ Z; x ≡ 1 mod m}
[2] = {x ∈ Z; x ≡ 2 mod m}
...
[m − 1] = {x ∈ Z; x ≡ m − 1 mod m}

Quando a ∈ Z, [a] = {x ∈ Z; x ≡ a mod m}, chamamos de [a] de classe residual

módulo m. Denotamos Zm o conjunto das classes residuais em Z módulo m. Então,

Proposição 2.1. Sejam a, b ∈ Z:

Zm = {[a]; a ∈ Z}.

i) Duas classes residuais são iguais se, e somente se, quando a é congruente a b módulo

m, isto é,

[a] = [b] ⇔ a ≡ b mod m.

ii) Se a interseção de duas classes residuais é diferente de vazio, é por que de fato elas

são iguais, isto é,

[a] ∩ [b] Ó= ∅ ⇒ [a] = [b].

Capítulo 2. O Anel das Classes Residuais

17

iii) A união das classes residuais módulo m resulta no próprio conjunto dos inteiros,

isto é,

[a] = Z.

Ûa∈Z

Demonstração.

i) Como b ≡ b mod m (propriedade reﬂexiva), então

b ∈ [b] = {x ∈ Z; b ≡ b mod m}.

Por hipótese, [a] = [b], então b se encontra na classe residual de a, ou seja:

b ∈ [a] = {x ∈ Z; x ≡ a mod m}

Logo b ≡ a mod m. Por ﬁm, da propriedade de simetria, concluímos que a ≡ b mod m.

Para provar a recíproca, suponha a ≡ b mod m. Queremos provar que [a] = [b].

Como as classes residuais na verdade são conjuntos, provemos que [a] ⊂ [b] . Para
isso, com x ∈ [a], então x ≡ a mod m.

Por hipótese, a ≡ b mod m e x ≡ a mod m. Por simetria, obtemos b ≡ a mod m e
a ≡ x mod m. Valendo-nos da propriedade transitiva, b ≡ x mod m. Por simetria,
mais uma vez, obtemos x ≡ b mod m e, portanto, podemos dizer que esse x é um
elemento de [b].

Analogamente se veriﬁca que [b] ⊂ [a], e ﬁnalmente concluímos:

[a] ⊂ [b] e [a] ⊃ [b] ⇒ [a] = [b] .

ii) Por hipótese [a] ∩ [b] Ó= ∅, ou seja, existe c ∈ Z tal que c ∈ [a] e c ∈ [b]. Logo

c ≡ a mod m e c ≡ b mod m.

Segue do item i) que:

c ≡ a mod m ⇔ [c] = [a]

c ≡ b mod m ⇔ [c] = [b]

.






Logo, [a] = [b].

iii) É claro que ∪a∈Z[a] ⊂ Z. Provemos que Z ⊂ ∪a∈Z[a]. Para isso, tomemos a ∈ Z. Na
divisão euclidiana da a por m, temos que a ≡ a mod m. Logo a ∈ [a] e a ∈ ∪a∈Z[a].
Portanto, da reunião das classes residuais, obtêm-se que:

∪a∈Z[a] = Z.

Capítulo 2. O Anel das Classes Residuais

18

Proposição 2.2. Para cada a ∈ Z, existe um e somente um elemento r ∈ Z, com
0 6 r 6 m − 1 tal que [a] = [r].

Demonstração. Seja a ∈ Z, segue do algoritmo da divisão de Euclides que existem únicos
q, r ∈ Z, tais que:

a = mq + r

0 6 r 6 m − 1.

Logo, a ≡ r mod m. Assim, [a] = [r].

Agora, vamos deﬁnir em Zm uma adição e uma multiplicação como segue:

• Adição: [a] + [b] = [a + b],

∀a, b ∈ Z;

• Multiplicação: [a].[b] = [a.b] ,

∀a, b ∈ Z;

Deﬁnidas as operações acima para as classes residuais, vale dizer que as operações
são fechadas(que o resultado da operação entre dois elementos de um mesmo conjunto
tem como resultado um elemento deste próprio conjunto) e que o resultado de [a] + [b] e
[a].[b] independe do representante da classe que escolhemos. De fato:

[a] = [a′] ⇔ a ≡ a′ mod m; [b] = [b′] ⇔ b ≡ b′ mod m;

E, portanto, a soma dos elementos resultará a aﬁrmação

[a + b] = [a′ + b′] ⇔ a + b ≡ a′ + b′ mod m.

Atenção para o fato que sejam a e a′ elementos da classe [a] e b e b′ elementos da

classe [b], decorre simultaneamente que :

[a] = [a′] ⇔ a ≡ a′ mod m ⇔ ∃p ∈ Z; (a − a′) = mp
[b] = [b′] ⇔ b ≡ b′ mod m ⇔ ∃q ∈ Z; (b − b′) = mq




Da soma das equações acima, obtém-se



(a − a′) + (b − b′) = (a + b) − (a′ + b′) = mp + mq = m(p + q) ⇔

(a + b) − (a′ + b′) = m(p + q).

Daí, temos que a + b ≡ a′ + b′ mod m e [a + b] = [a′ + b′].

Situação análoga se veriﬁca para a operação [a.b] = [a′.b′], pois conhecidos os

representantes da classe como deﬁnida acima, temos que:

Capítulo 2. O Anel das Classes Residuais

19

[a] = [a′] ⇔ a ≡ a′ mod m ⇔ m | (a − a′)




[b] = [b′] ⇔ b ≡ b′ mod m ⇔ m | (b − b′)

Como a.b−a′b′ = a.b−a′b′−ab′+ab′ = a(b−b′)+b′(a−a′), temos que m | (a.b−a′b′),



que equivale a dizer

[a′.b′] = [a.b]

Temos, portanto, que as operações soma e multiplicação independem do represen-

tante da classe.

Proposição 2.3. Para quaisquer [a], [b], [c] ∈ Zm, temos que (Zm, +, .) é um anel cujas
seguintes propriedades são válidas:

A1 Associativa: ([a] + [b]) + [c] = [a] + ([b] + [c]);

P1 Associativa: ([a].[b]).[c] = [a].([b].[c]);

A2 Comutativa: [a] + [b] = [b] + [a];

P2 Comutativa: [a].[b] = [b].[a]; (Anel Comutativo).

A3 Elemento Neutro: ∃[0] ∈ Zm; [a] + [0] = [a], ∀a ∈Zm;

P3 Elemento Neutro: ∃[1] ∈Zm; [a].[1] = [a], ∀a ∈ Zm; (Anel com Unidade).

A4 Inverso Aditivo: Dado [a] ∈Zm; existe [−a] ∈Zm talque [a] + [−a] = [0];

A5 Distributiva: [a].([b] + [c]) = [a].[b] + [a].[c].

Demonstração. De fato, sejam [a], [b], [c] ∈ Zm.

A1 ([a]+[b])+[c] = ([a+b])+c = [(a+b)+c] = [a+(b+c)] = [a]+[b+c] = [a]+([b]+[c]).

P1 ([a].[b]).[c] = ([a.b].[c]) = [(a.b).c] = [a.(b.c)] = [a].[b.c] = [a].([b].[c]).

A2 [a] + [b] = [a + b] = [b + a] = [b] + [a].

P2 [a].[b] = [a.b] = [b.a] = [b].[a].

A3 Sejam [0] = {x ∈ Z; x ≡ 0 mod m} e [a] = {x ∈ Z; x ≡ a mod m}, classes residuais

que pertencem ao conjunto Zm podemos obter:

[a] + [0] = [a + 0] = [a], qualquer que seja a ∈ Zm.

Capítulo 2. O Anel das Classes Residuais

20

P3 Sejam [1] = {x ∈ Z; x ≡ 1 mod m} e [a] = {x ∈ Z; x ≡ a mod m}, classes residuais que
pertencem ao conjunto Zm podemos obter:

[a].[1] = [a.1] = [1.a] = [a], qualquer que seja a ∈ Zm.

A4 Seja [0] = {x ∈ Z; x ≡ 0 mod m} e [a] = {x ∈ Z; x ≡ a mod m} as classes residuais que
pertencem ao conjunto Zm, existe [−a] = {x ∈ Z; x ≡ m − a mod m} ⇔ x ≡ −a mod m e
de sua soma podemos obter:

[a] + [−a] = [a − a] = [0].

A5 ([b] + [c]).[a] = ([b + c]).[a] = [(b + c).a] = [(b.a) + (c.a)] = [b.a] + [c.a] = [b][a] + [c][a].

Como (Zm, +, .) satisfaz as propriedades para a soma e produto como descrito na

proposição 2.3, Zm também se denomina anel das classes residuais módulo m.

2.2 O Corpo Finito com um Número Primo de Elementos.

Agora iremos nos concentrar nas classes residuais módulo m de um número primo.
Quando estamos trabalhando no caso em que m = p, com p primo, o conjunto das classes
residuais ganha novas propriedades, ou seja, com relação a operação de multiplicação toda
classe residual não nula tem elementos opostos, que nesse caso chamaremos o elemento
inverso. Para isso, vamos deﬁnir alguns conceitos e validar resultados para caracterizar o
conjunto das classes residuais que já sabemos que é um anel.

Deﬁnição 2.2. Seja [a] ∈ Z, [a] Ó= [0], dizemos que [a] é invertível se existe [b] ∈ Z, tal
que [a].[b] = 1. Nesse caso, dizemos que [b] é o inverso de [a].

Exemplo 2.1. Observe que Z3 = {[0], [1], [2]} . Calculemos os elementos inversíveis de
Z3.

Solução: Temos que [1].[1] = [1], então [1] é o inverso do [1].

Da mesma forma, [2].[2] = [4] = [1] então [2] é o inverso de [2].

Logo em Z3, ∀ [a] Ó= [0], [a] é invertível.

Exemplo 2.2. Observe que Z4 = {[0], [1], [2], [3]} . Calculemos os elementos inversíveis
Z4.

Solução: Em Z4, [1] e [3] são invertiveis, entretanto [2] não é invertível, pois não existe
x ∈ Z4 tal que [2].[x] = 1.

Capítulo 2. O Anel das Classes Residuais

21

+ [0]
[0]
[0]
[1]
[1]
[2]
[2]
[3]
[3]

[1]
[1]
[2]
[3]
[0]

[2]
[2]
[3]
[0]
[1]

[3]
[3]
[0]
[1]
[2]

.
[0]
[1]
[2]
[3]

[0]
[0]
[0]
[0]
[0]

[1]
[0]
[1]
[2]
[3]

[2]
[0]
[2]
[0]
[2]

[3]
[0]
[3]
[2]
[1]

Tabela 2.1 – Tabelas de adição e multiplicação em Z4

Fonte: autor

Deﬁnição 2.3. Seja m ∈ Z, m > 1, um elemento [a] Ó= [0] em Zm é chamado divisor de
zero se existe [b] Ó= [0] tal que [a].[b] = [0].

Exemplo 2.3. Os divisores de zero em Z6 são [2] e [3], pois [2].[3] = [0].

Proposição 2.4. Um divisor de zero nunca é invertível.

Demonstração. Suponha (por absurdo) que [a] é um divisor de zero invertível, logo existe
[b] ∈ Zm tal que [a].[b] = 1. Como [a] é divisor de zero, então existe [c] Ó= 0, tal que
[a].[c] = 0. Multiplicando por [b] em ambos os lados de [a].[c] = [0], temos

[b].[a].[c] = [b].[0]

([b].[a]).[c] = [0]

Como sabemos que [1].[c] = [c]. Logo [c] = [0] e teremos uma contradição. Portanto,

[a] não é invertível.

Deﬁnição 2.4. Dado m ∈ Z, com m > 1. O anel Zm é chamado corpo se todo elemento
não nulo de Zm possuir inverso multiplicativo, ou seja,

∀[a] Ó= [0] ∈ Zm, ∃ [b] Ó= [0] ∈ Zm, tal que [a].[b] = 1.

Exemplo 2.4. Z5 = {[0], [1], [2], [3], [4]} é um corpo.

Demonstração. Construindo a tabela de multiplicação para Z5 e determinando os inversos
de cada classe residual, obtêm-se:

[1].[1] = [1]

[2].[3] = [6] = [1]

[3].[2] = [6] = [1]

[4].[4] = [16] = [1]

Capítulo 2. O Anel das Classes Residuais

22

Logo, Z5 é um corpo.

Proposição 2.5. Um elemento [a] ∈ Zm é invertível se, e somente se, mdc(a, m) = 1.

Demonstração. Temos que [a] é invertível se, e somente se, existe [b] ∈ Zm tal que [a].[b] = 1.
Assim, [a.b] = [1], ou seja, a.b ≡ 1 mod m se e somente se, existe y ∈ Z, tal que a.b−1 = my,
ou ainda ab − my = 1.

Observe que encontrar o inverso de um elemento [a] ∈ Zm equivale a resolver a

equação diofantina ax + my = 1.

Portanto, [a] ∈ Zm é invertível se e somente se mdc(a, m) = 1.

Proposição 2.6. (Zm, +, .) é um corpo se, e somente se, m é primo.

Demonstração. Suponha que Zm é um corpo e provemos que m é primo. Suponha por
absurdo que m é composto, ou seja, m = a.b com 1 < a, b < m. Como 1 < a, b < m então
[a] Ó= [0] e [b] Ó= [0]. Observe ainda que [0] = [m] = [a.b] = [a].[b].

Logo [a].[b] = [0], com [a] Ó= [0] e [b] Ó= [0] e temos uma contradição, pois sendo Zm

um corpo, [b] é inversivel e pela Proposição 2.4 não pode ser divisor de zero.

Para provar a recíproca, suponha m primo, logo mdc(m, i) = 1, 1 ≤ i ≤ m − 1.
Temos, pela Proposição 2.5, (m, i) = 1 se, e somente se, [i] é invertível em Zm, com
i = 1, 2, . . . , m − 1. Logo, Zm é um corpo.

Para compreender melhor as considerações sobre o conjunto Zm, nas demonstrações
ou deﬁnições nos capítulos seguintes, a referência a esta demonstração denotaremos corpo
“Zp, com p primo”, ou simplesmente Zp.

2.3 Alguns exemplos práticos de aplicação de Classes Residuais

A ideia do anel das classes residuais está presente em alguns exemplos práticos
do nosso cotidiano. Sem dúvida, a maior aplicabilidade deles é na criação de dígitos
veriﬁcadores, servindo para indicar e evitar erros de digitação. Na prática, eles evitam que
ambientes seguros aceitem fraudes, como forma de comprovar a autenticidade daquele
documento.

A chance de uma pessoa digitar errado um dígito de seu CPF(em um site, numa
compra online, por exemplo) é muito maior do que a probalidade de errar dois dígitos,
que é maior que de errar 3 e assim por diante.

De acordo com (EDC. . . , ), se veriﬁca que:

Mesmo sustituindo os números decimais por binários, os mecanismos
não mudam. [· · · ] O que muda é o “ poder de fogo ” da detecção de

Capítulo 2. O Anel das Classes Residuais

23

erros acima da capacidade de códigos. Por exemplo, o dígito vericador
decimal pode detectar até 90% dos erros de dois dígitos ou mais. Já o
seu equivalente binário, o bit de paridade, detecta apens 50% dos erros
de dois bits ou mais.

Isto acontece simplesmente porque um dígito decimal tem muito mais
valores distintos que um dígito binário (bit). No caso de um DV duplo
como o do CPF, 99% dos erros são pegos, enquanto um código de 2 bits
pega apenas 75% dos erros. A taxa de detecção é dada por:

p = bn−1
bn

, onde:

n = número de dígitos veriﬁcadores ou bits do código;

p = probabilidade de pegar erros de mais de “n” dígitos;

b = base numérica (binário = 2, decimal = 10)

De fato:

Para 1 dígito decimal

p = 101−1

101 = 10−1

10 = 9

10 = 90%

Para 2 dígitos decimais

p = 102−1

102 = 100−1

100 = 99

100 = 0, 99 = 99%

2.3.1 Os Dígitos de Veriﬁcação do CPF

O CPF, ou simplesmente Cadastro de Pessoa Física, é um documento de identi-
ﬁcação, tal como o registro de nascimento, que a receita federal emite para armazenar
informações dos contribuintes da receita federal, com informações fornecidas pelos mesmos
ou seus responsáveis (no momento em que foi exigido à época de registro de nascimento).
Serve para comprovar que a pessoa contribui com a Receita Federal ou é dependente de
alguém que contribui e é necessário em algumas situações, como a abertura de conta em
banco, crediário em lojas, cadastro em sites, inscrição em concursos, etc.

Capítulo 2. O Anel das Classes Residuais

24

Figura 2.2 – O Cadastro de Pessoa Física - CPF

Fonte: Governo Federal.

Para evitar duplicidade, o CPF tem estrutura de 11 dígitos, dos quais os oito
primeiros são aleatórios (possuindo algarismos de 0 a 9), o nono designa a região ﬁscal (de
acordo com o local de origem), e os últimos dois dígitos (DV, Dígito Veriﬁcador) provém
de um algarismo que usa a aritmética modular módulo 11.

Figura 2.3 – Regiões Fiscais- CPF

Fonte: Governo Federal. Adaptada pelo autor.

Basicamente, a obtenção dos dígitos veriﬁcadores são obtidos pelo algoritmo expli-

cado abaixo:

Capítulo 2. O Anel das Classes Residuais

25

Se a1a2a3a4a5a6a7a8a9 é a sequência formada pelos nove primeiros dígitos, devemos
multiplicar eles nesta mesma ordem, pelos números: 1, 2, 3, 4, 5, 6, 7, 8, 9, e seguida somar
os produtos obtidos.

Se este primeiro resultado obtido denominarmos S1, o décimo dígito que denota-
remos por a10, deverá ser tal que S1 − a10 seja múltiplo de 11 ou S1 − a10 ≡ 0 (mod 11).
Assim, obtemos que S1 será o próprio resto da divisão por 11 da soma obtida.

Para obtermos o segundo dígito de controle, utilizamos o mesmo procedimento
acrescentando o décimo dígito que acabamos de calcular e usando uma base de multiplicação
de 0 a 9, nesta mesma ordem, pelos números: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, assim obtendo uma
soma S2.

O décimo primeiro dígito que denotamos por a1, será tal que S2 − a11 seja múltiplo
de 11 ou S2 − a11 ≡ 0 (mod 11). Assim, obtemos que S2 será o próprio resto da divisão por
11 da soma obtida.

Para ﬁns didáticos, um provável CPF do Mato Grosso do Sul, poderia ser exempli-
ﬁcado com o número 850.098.821-99. Todavia, ele é falso, pois o primeiro digito veriﬁcador
válido é 5 e não 9. Para provar tal aﬁrmação, vamos seguir os passos do procedimento
acima relatado.

Multiplicando os dígitos 8, 5, 0, 0, 9, 8, 8, 2, 1 pelos números 1, 2, 3, 4, 5, 6, 7, 8, 9 e

calculando sua soma, S1, encontramos:

S1 = 8.1+5.2+0.3+0.4+9.5+8.6+8.7+2.8+1.9 = 8+10+0+0+45+48+56+16+9 = 192

Como S1 ≡ 5 (mod 11), o primeiro dígito de veriﬁcação é 5.

Como se pode ver, o CPF 850.098.821-99, por sí só atésta-se que é inválido pelo seu
primeiro dígito veriﬁcador. Mesmo assim, continuaremos o procedimento para descobrir
S2 e o segundo dígito de veriﬁcação. Daí:

Multiplicando os dígitos 8, 5, 0, 0, 9, 8, 8, 2, 1, 5 pelos números 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

e calculando sua soma, S2, encontramos:

S1 = 8.0 + 5.1 + 0.2 + 0.3 + 9.4 + 8.5 + 8.6 + 2.7 + 1.8 + 5.9 =
0 + 5 + 0 + 0 + 36 + 40 + 48 + 14 + 8 + 45 = 196

Como S2 ≡ 9 (mod 11), o segundo dígito de veriﬁcação é 9.

Na verdade, o CPF correto para MS com os dígitos de veriﬁcação corretos do nosso

exemplo será 850.098.821-59.

Capítulo 2. O Anel das Classes Residuais

26

2.3.2 As potências nas Congruências

Outro exemplo que podemos aplicar classes residuais é para determinar o resto
da divisão de uma potência de um número inteiro positivo, por exemplo, queremos
determinar o resto da divisão de 2100 por 11, para isso basta encontrar a classe de
[a] ∈ {[0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]} tal que [2100] = [a].

Inicialmente, denominando os representantes da classe residual modulo 11, teríamos:

[0] = {x ∈ Z; x ≡ 0 mod m}

[1] = {x ∈ Z; x ≡ 1 mod m}
...
[10] = {x ∈ Z; x ≡ m − 1 mod m}

E valendo da Proposição 2.1 e da propriedade abaixo, adaptada para uma melhor
compreensão, segue que a relação de congruência módulo m divide Z em classes de
equivalência as quais são chamadas de classe residuais ou classe dos restos das divisões
por m. Daí, se a ≡ b (mod 11), então ar ≡ br (mod 11), com a, b, r ∈ Z. Vamos construir as
potências de 2, e determinar a classe residual a qual respctivamente pertence. Temos

20 ≡ 20 (mod 11) ⇒ 20 ≡ 1 (mod 11) e 1 ≡ 1 (mod 11) ⇒ [20] = [1],

21 ≡ 21 (mod 11) ⇒ 21 ≡ 2 (mod 11) e 2 ≡ 2 (mod 11) ⇒ [21] = [2],

22 ≡ 22 (mod 11) ⇒ 22 ≡ 4 (mod 11) e 4 ≡ 4 (mod 11) ⇒ [22] = [4],

23 ≡ 23 (mod 11) ⇒ 23 ≡ 8 (mod 11) e 8 ≡ 8 (mod 11) ⇒ [23] = [8],

24 ≡ 24 (mod 11) ⇒ 24 ≡ 16 (mod 11) e 16 ≡ 5 (mod 11) ⇒ [24] = [5],

25 ≡ 25 (mod 11) ⇒ 25 ≡ 32 (mod 11) e 32 ≡ 10 (mod 11) ⇒ [25] = [10],

26 ≡ 26 (mod 11) ⇒ 26 ≡ 64 (mod 11) e 64 ≡ 9 (mod 11) ⇒ [26] = [9],

27 ≡ 27 (mod 11) ⇒ 27 ≡ 128 (mod 11) e 128 ≡ 7 (mod 11) ⇒ [27] = [7],

28 ≡ 28 (mod 11) ⇒ 28 ≡ 256 (mod 11) e 256 ≡ 3 (mod 11) ⇒ [28] = [3],

29 ≡ 29 (mod 11) ⇒ 29 ≡ 512 (mod 11) e 512 ≡ 6 (mod 11) ⇒ [29] = [6],

210 ≡ 210 (mod 11) ⇒ 210 ≡ 1024 (mod 11) e 1024 ≡ 1 (mod 11) ⇒ [210] = [1],

211 ≡ 211 (mod 11) ⇒ 211 ≡ 2048 (mod 11) e 2048 ≡ 2 (mod 11) ⇒ [211] = [2] e

212 ≡ 212 (mod 11) ⇒ 212 ≡ 4096 (mod 11) e 4096 ≡ 4 (mod 11) ⇒ [212] = [4].

Observa-se em destaque que a partir da potência 210, temos uma repetição dos
restos, e, portanto,encontram-se representantes de classes residuais iguais, como num ciclo.
Então podemos dizer que:

Capítulo 2. O Anel das Classes Residuais

27

[210] = [20], [211] = [21], [212] = [22], [213] = [23], e assim por diante.

Assim uma resolução “esperta” para o problema é escrever o número 100 como
uma congruência modulo 10, e uma vez conhecidos os seus restos, veriﬁcar o esquema
acima e identiﬁcar qual o representante da classe aritmética módulo 11. Calculando:

210 ≡ 1 mod 11 ⇒ (210)10 ≡ (1)10 mod 11 ⇒ 2100 ≡ 1 mod 11 ⇒ [2100] = [1]

Portanto, a classe [a] para o qual [2100] = [a] é o representante da classe [1]. Ou

ainda, o resto da divisão de [2100] por 11 é 1.

2.3.3 Os ponteiros do relógio.

Outra aplicação prática das congruências é no relógio de ponteiro analógico, onde
o dia é dividido em dois períodos de 12 horas cada. Acontece que neste exemplo, ignora-se
os múltiplos de um dado número quando fazemos cálculos. Neste exemplo, é a aritmética
módulo 12.

Se nesse momento são 5 horas, então daqui a 8 horas será 1 hora. A adição usual
sugere que o tempo futuro deveria ser 5 + 8 = 13, mas na verdade, tomando o mostrador
do ponteiro analógico, esta é a resposta errada por que o relógio “volta para trás” a cada
12 horas; não existe “13 horas” no relógio do ponteiro. Dessa forma, o ponteiro das horas
desloca-se para o 1.

Numa outra situação, se o relógio começa em 12 : 00(meio dia) e 21 horas passam,
então a hora será 9 : 00 do dia seguinte, em vez de 33 : 00. 12 é congruente não só a 12
mesmo, mas também a 0, assim a hora chamada “12 : 00” pode também ser chamada
“0 : 00”, pois 0 ≡ 12 mod 12. Por isso, o ponteiro das horas obedece uma aritmética modular
12.

O mesmo vale para o ponteiro dos minutos, que em ciclos de 60 retoma sua posição

inicial, ou seja, deslocando-se entre as posições 00 a 59.

2.3.4 Os números de segurança na nota do Euro.

Outro exemplo de aplicação, citado em (PINTO, 2006) descreve um dos mecanismos
de segurança estabecido pelo Banco Central Europeu para notas de Euro que entraram
em circulação em 1 de janeiro de 2002, baseado num sistema de congruência módulo 9.

Capítulo 2. O Anel das Classes Residuais

28

Figura 2.4 – Mecanismo de Segurança da Nota do Euro

Fonte: Helder Pinto (2006)

Basicamente, o número de série que podemos encontrar numa qualquer nota
(verdadeira) de Euro é composto por uma letra seguida de onze algarismos. A letra
representa o país do qual é fabricada a nota (por exemplo, na imagem, T indica essa nota
como pertencente a Irlanda) e os onze algarismos representam o número de identiﬁcação
da nota. O último de seus algarismos chamados dígito de controle ou veriﬁcador, é obtido
da operação.

L + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + C ≡ 0 (mod 9)

Onde L é o valor atribuído ao pais respectivo e C é o dígito de controle.

Tomando como referência a nota representada acima, T 23186909697, veriﬁquemos

se 7 é o dígito veriﬁcador (DV) correto.

3 + 2 + 3 + 1 + 8 + 6 + 9 + 0 + 9 + 6 + 9 + C ≡ 0 (mod 9)

Perceba que a soma parcial resulta em 56, que sobre uma congruência módulo 9

resulta em:

56 + C ≡ 0 (mod 9) ⇒

2 + C ≡ 0 (mod 9)

Daí o único número que C pode assumir para a soma ser congruente é 7. Portanto,

7 é verdadeiramente o dígito veriﬁcador.

Neste mesmo artigo, ele realiza uma crítica quanto à eﬁcácia, quando, na pág 86

diz que:

Que tipos de erros são detectados por este sistema? Em primeiro lugar,
nenhuma transposição de dois (ou mais) algarismos é detectada devido à
propriedade comutativa da adição (modular) e mesmo os erros singulares

Capítulo 2. O Anel das Classes Residuais

29

não são todos detectados. Se trocarmos um zero por um nove (ou vice-
versa) o número de controle mantém-se inalterado.

[. . . ] De fato, se escrevemos um nove em vez de um zero (ou vice-versa)
o número de controle mantém-se inalterado. Note-se que este é um
problema prático grave, pois, se reparar no seu teclado, existe uma tecla
nove junto de uma tecla zero, o que pode levar a que este engano seja
frequente. Esta última insuﬁciência surge do fato de 9 ser igual a 0 na
aritmética módulo 9, ou seja, tanto o nove como o zero têm o mesmo
resto quando divididos por nove. O fato de este mecanismo não detectar
com segurança estes dois tipos de erros (que são os tipos de erro mais
frequentes), torna-o num sistema bastante fraco.

Como se observa nos exemplos acima, tais situações são inclusive motivadores para
elaboração de planos de aulas para o ensino fundamental. Para tal, é possível introduzir a
ideia do efeito causado na mudança de apenas um dígito e como ela inﬂui na determinação
do DV.1

Um outro exemplo da aplicabilidade da congruência e classe residual, este mais
sintonizado com a aprendizagem em sala de aula, é explicar superﬁcialmente a criação
de um código através de uma lista de palavras, explicando a relação que a mesma tem
com o conteúdo de matrizes e operações, para a segunda série do ensino médio. Neste
caso, a codiﬁcação das palavras de um código pode ser feita com o auxílio de um matriz
chave para “embaralhar” as letras, e o uso da sua inversa para desembaralhar, é a melhor
estratégia. As operações de multiplicação e soma são ótimas opções para exploração e
abordagem dos códigos corretores.

Mas para mostrar a álgebra dos códigos corretores, é preciso, antes de tudo, entender
sob qual conjunto está estruturado e as operações e propriedades deste. Daí, utilizamos a
abordagem de um espaço vetorial especial, o Zn
p , que abordaremos no capítulo seguinte.

1 Digito veriﬁcador ou algarismo de controle é um mecanismo de autenticação utilizado para veriﬁcar
a validade e a autenticidade de um campo numérico digitado, evitando dessa forma fraudes. São
algarismos adicionais colocados e validados por um algoritmo para garantir a segurança. Documentos
de identiﬁcação normalmente utilizam dígitos veriﬁcadores.

3 O Espaço Vetorial Finito Zn
p.

30

Como visto no Capítulo 2, vemos que o uso das classes residuais e a ideia de
congruências é de grande valia para algumas aplicações no cotidiano e são facilitadores na
deﬁnição de dígitos de veriﬁcação (como no caso do CPF). Isso é possível devido a escolha
de quais algarismos e operações serão válidas para tal função.

Este capítulo é destinado a apresentar o espaço vetorial Zn

p , cujo o número de
elementos é ﬁnito, essencial para o entendimento dos códigos lineares e suas propriedades,
com suas respectivas propriedades. Ao operar com os diferentes tipos de números, estamos
intuitivamente manipulando valores, sem que estes alterem suas estruturas.

A escolha do corpo Zp, não é aleatória, devido ao fato das operações e propriedades
que o caracterizam estarem bem deﬁnidas e provadas no capítulo anterior. A partir dele,
as n-uplas permitem a deﬁnição de um espaço vetorial, fundamental para o nosso trabalho.

Se pensamos a informação a ser transmitida como um pacote com n-uplas de valores
ordenados, temos as palavras de um código fundamentado numa estrutura que segue a de
um espaço vetorial. Neste capítulo, vamos entender o espaço vetorial e algumas dessas
propriedades.

3.1 O Espaço Vetorial Zn
p

A ideia é considerar Zn
cartesiano de n cópias de Zp, ou seja,

p , onde p é primo e n ∈ Z, n ≥ 1, que consiste do produto

p = Zp × Zp × . . . × Zp
Zn

n vezes

ü

ûú

ý

e explorar a estrutura de espaço vetorial em Zn

p , juntamente com suas propriedades
e conceitos inerentes das características que possuem os espaços vetoriais ﬁnitamente
gerados. Apresentamos os resultados de espaços vetoriais, e verﬁcando a aplicabilidade
para subespaços de Zn
p , pois os subespaços são exemplos de espaços vetoriais. Percebemos
que essas demonstrações análogas as demonstrações do caso geral que constam em livros de
álgebra linear. A bibliograﬁa de consulta para este capítulo se baseia nos autores (HEFEZ,
2016), (WINTERLE; STEINBRUCH, 1987), (ANTON; RORRES, 2001),(PULINO, 2012)
e (BOLDRINI et al., 1978).

Em todo texto usaremos a notação Zn
p .

Capítulo 3. O Espaço Vetorial Finito Zn
p .

31

Segue, do Capítulo 2, que Zp={[0], [1], [2], . . . , [p − 1]} é um corpo. Nas próximas
seções e capítulos iremos abandonar a notação [a] ∈ Zp e apenas escreveremos a, mas
trata-se de uma classe residual módulo p. Faremos isso para a notação de vetor não ﬁcar
muito carregada.

Temos que

u ∈ Zn

p ⇔ u = (a1, a2, . . . , an) com a1, a2, an ∈ Zp.

Os elementos u ∈ Zn

p são chamados vetores.

Segue da deﬁnição do corpo Zp e do princípio multiplicativo (uma vez que o anel Zn
p
p |= pn, que torna o referido conjunto
p e uma multiplicação de
p explorando a estrutura de espaço vetorial em Zn
p .

é formado por n-uplas de Zp) que a cardinalidade | Zn
ﬁnito. Vamos então deﬁnir uma soma de dois vetores u, v ∈ Zn
um escalar α ∈ Zp por um vetor u ∈ Zn

Para isso, sejam u, v, w ∈ Zn
p .

u ∈ Zn

p ⇔ u = (a1, a2, . . . , an);

v ∈ Zn

p ⇔ u = (b1, b2, . . . , bn);

w ∈ Zn

p ⇔ u = (c1, c2, . . . , cn);

Deﬁnimos:

+ : u + v = (a1 + b1, a2 + b2, . . . , an + bn) e

. : α.u = (αa1, αa2, . . . , αan), com α ∈ Zp.

O conjunto Zn

p , com as operações + e . forma um Espaço Vetorial sobre Zp, ou

seja, satisfazem as seguintes operações:

A1) u + v = v + u (Comutativa);

A2) (u + v) + w = u + (v + w)(Associativa);

A3) ∃ e ∈ V , denominado elemento neutro, tal que u + e = e + u = u;

A4) Para cada u ∈ V , tem-se (−u) ∈ V , chamado elemento oposto de u, tal que

u + (−u) = e.

M1) (αβ)u = α(βu);

M2) (α + β)u = αu + βu;

M3) α(u + v) = αu + αv ;

Capítulo 3. O Espaço Vetorial Finito Zn
p .

32

M4) 1u = u.

A demonstração que

(WINTERLE; STEINBRUCH, 1987) , p. 20-21.

Zn

p , +, .
2

1

é um espaço vetorial pode ser encontrada em

3.2 Os Subespaços de Zn
p

Deﬁnição 3.1. Seja W ⊂ Zn
se as operações de Zn

p , W não vazio. Dizemos que W é subespaço vetorial de Zn

p

p em W torna esse conjunto ainda um espaço vetorial sobre Zp.

Proposição 3.1. Seja W ⊂ Zn
propriedades:

p , W não vazio. Então W é subespaço de Zn

p , se satisfaz as

i) (0, 0, . . . , 0) ∈ W ;

ii) W é fechado para a adição de vetores, isto é, u + v ∈ W, ∀u, v ∈ W ;

iii) W é fechado na multiplicação por escalar, ou seja, αu ∈ W, ∀u ∈ W e ∀α ∈ Zp.

Demonstração. Suponhamos W subespaço vetorial de Zn
p . Basta considerar que nos espaços
vetoriais a adição de vetores e a multiplicação por escalar é fechada, e válida para α = 0,
ou seja, 0v ∈ W, ∀v ∈ W. Logo, 0v = (0, 0, . . . , 0) ∈ W , e, portanto, o elemento neutro
= (0, 0, . . . , 0) de V está em W .

Se W é espaço vetorial, então satisfaz todas as condições de espaço vetorial, em

particular, satisfaz (ii), (iii).

Para a recíproca deste teorema, tomemos os vetores u, v ∈ W e um escalar α ∈ Zp.

temos que:

As propriedades (A1), (A2), (M1), (M2), (M3), (M4) são herdadas de Zn

p , pois W ⊂Zn
p .
Vimos de i) que (0, · · · , 0) ∈ W e (0, · · · , 0) + u = u, para todo u ∈ W . Logo é válido
(A3).

Como α.u ∈ W , para todo u ∈ W e α ∈Zp, então −u = (−1).u ∈ W e u+(−u) = 0,

logo vale (A4).

Portanto W é espaço vetorial.

Exemplo 3.1. O subconjunto de um espaço vetorial formado apenas pelo vetor nulo
(0, 0, . . . , 0) é um subespaço vetorial de Zn
p .

Exemplo 3.2. O próprio Zn
vetorial. Estes dois subespaços são chamados triviais.

p como subconjunto dele mesmo também é um subespaço

Capítulo 3. O Espaço Vetorial Finito Zn
p .

33

3.3 Combinação Linear

Deﬁnição 3.2. Um vetor v que é um elemento do espaço vetorial Zn
nação linear dos elementos v1, v2, . . . , vn ∈ Zn
Zp, de tal forma que ele esse vetor pode ser determinado pela seguinte operação:

p é denominado combi-
p quando existem escalares α1, α2, . . . , αn ∈

v = α1v1 + α2v2 + · · · + αnvn.

Exemplo 3.3. O elemento v = (0, 1) ∈ Z2
e v2 = (0, 1).

2 é combinação linear dos elementos v1 = (1, 0)

De fato, v pode ser escrito como:

v = (0, 1) = 0.(1, 0) + 1.(0, 1) = 0.v1 + 1.v2

Assim, existem os escalares α1 = 0 e α2 = 1 tais que v pode ser escrito como

v = α1v1 + α2v2. Logo, v é combinação linear de v1 e v2.

Exemplo 3.4. O elemento v = (2, 0, 1) ∈ Z3
(1, 0, 0) e v2 = (0, 0, 1).

3 é combinação linear dos elementos v1 =

De fato, v pode ser escrito como:

v = (2, 0, 1) = 2.(1, 0, 0) + 1.(0, 0, 1) = 2.v1 + 1.v2

Assim, existem os escalares α1 = 2 e α2 = 1 tais que v pode ser escrito como
v = α1v1 + α2v2. Logo, v é combinação linear de v1 e v2. Partindo da premissa que um
vetor pertencente ao espaço vetorial Zn
p é escrito por meio de outros vetores operados, e
estes, que sempre aparecerão, permitem estabelecer uma deﬁnição importante descrita na
seção seguinte.

3.4 Subespaço Gerado

Deﬁnição 3.3. Seja S = {v1, v2, . . . , vm} ⊂ Zn
todos os elementos u ∈ Zn
de S é chamado subespaço gerado por S e denotamos:

p formado por
p que podem ser escritos como combinação linear dos elementos

p . O subconjunto W ⊂ Zn

W = [S] = [v1, . . . , vm]

=

u ∈ Zn

I

p | u = α1v1 + α2v2 + · · · + αmvm =

m

i=1
Ø

αivi; α1, . . . , αm ∈ Zp

J

Capítulo 3. O Espaço Vetorial Finito Zn
p .

34

Proposição 3.2. Seja S = {v1, v2, . . . , vm} ⊂ Zn
W = [S] = [v1, . . . , vm] é um subespaço de Zn
p .

p , com p primo e n ≥ 1 natural. Então

Demonstração. Seja S = {v1, v2, . . . , vm} um conjunto de m elementos de Zn
este resultado basta veriﬁcar que valem as condições de subespaço vetorial para [S]:

p . Para provar

i) O elemento neutro de Zn
0v1 + 0v2 + · · · + 0vm;

p está em [S], pois basta observar que (0, 0, . . . , 0) =

ii) Considere u, w ∈ [S]. Se u ∈ [S], então u = α1v1 + α2v2 + · · · + αmvm, com
α1, α2, · · · , αm ∈ Zp. E se w ∈ [S], então w = β1v1 + β2v2 + · · · + βmvm, com
β1, β2, · · · , βm ∈ Zp.

Temos que, u + w = (α1v1 + α2v2 + · · · + αmvm) + (β1v1 + β2v2 + · · · + βmvm) =
(α1 + β1)v1 + (α2 + β2)v2 + · · · + (αm + βn)vm. Como αi + βi ∈ Zp, temos que u + w
é também combinação linear dos elementos de S, logo u + w ∈ [S];

iii) Considere u ∈ [S] e um escalar β ∈ Zp. Se u ∈ [S], então u = α1v1+α2v2+· · ·+αmvm,
com α1, α2, · · · , αm ∈ Zp. Temos que βu = β(α1v1 + α2v2 + · · · + αmvm) = βα1v1 +
βα2v2 + · · · + βαmvm. Como βαi ∈ Zp, temos que βu é também combinação linear
dos elementos de S, logo βu ∈ [S]. Assim, provamos que [S] é um subespaço vetorial
de Zn
p .

O conjunto gerado por S = {v1, v2, . . . , vm} ⊂ Zn

p , W = [v1, . . . , vm] é chamado

também de subespaço gerado por S, ou subespaço gerado por v1, v2, . . . , vm.

Exemplo 3.5. O conjunto W = {(x1, x2, x3) ∈ Z3
Z3

3 gerado pelo vetor v1 = (0, 1, 1).

3 : x1 = 0, x2 ∈ Z3} é um subespaço de

Deﬁnição 3.4. Um espaço vetorial V é ﬁnitamente gerado se existem v1, v2, · · · , vm ∈
V , tal que V = [v1, v2, · · · , vm]

Exemplo 3.6. O conjunto S = {(1, 0), (0, 1)} gera o espaço vetorial Z2
2.

Exemplo 3.7. O conjunto S = {(1, 1)} ⊂ Z2

2 gera o subespaço U = {(x, y) ∈ Z2

2 | y = x}.

De fato, tomando um elemento u = (x, y) ∈ U , temos que y = x, logo podemos

escrever: u = [(x, y) = (x, x) = x(1, 1), com x ∈ Z2].

Capítulo 3. O Espaço Vetorial Finito Zn
p .

35

3.5 Dependência e Independência Linear em Zn
p

Deﬁnição 3.5. Seja S = {v1, v2, . . . , vm} ⊂ Zn
p . Dizemos que o
conjunto S é Linearmente Independente (L . I), quando para α1, α2, . . . , αm ∈ Zp
tais que

p , com m 6 n de Zn

α1.v1 + α2.v2 + · · · + αm.vm = (0, 0, . . . , 0)

tivermos αi = 0, para todo i = 1, ..., m, ou seja α1 = α2 = . . . = αm = 0.

Para o conjunto S ser Linearmente Dependente (L . D), basta existir pelo

menos um αi Ó= 0, tal que

α1.v1 + α2.v2 + · · · + αm.vm = (0, 0, . . . , 0).

Dos conceitos de dependência e independência linear decorrem as seguintes propri-

edades dadas nas seguintes proposições.

Proposição 3.3.

(1) Se um conjunto ﬁnito S de elementos de Zn

p contém o elemento

vetor nulo (0, 0, . . . , 0), então S é L . D.

(2) Se S = {v} ⊂ V , com v Ó= (0, 0, . . . , 0), então S é L . I.

(3) Se S = {v1, v2, . . . , vm} ⊂ Zn

p , é L . D, então um dos seus elementos é combinação

linear dos demais.

Demonstração. Para (1) considere um conjunto contendo o vetor nulo,

S = {(0, 0, . . . , 0), v2, . . . , vm} ⊂ Zn
p . Então temos, α.(0, 0, . . . , 0) + 0.v2, . . . , o.vm =
(0, 0, . . . , 0), para todo α ∈ Zp. Assim, existe pelo menos um α Ó= 0 que satisfaz a
equação, o que mostra que o sistema S é L.D. .

Para (2), considere a equação

α.v = (0, 0, . . . , 0)

Como v Ó= (0, 0, . . . , 0), então temos α = 0, pois Zp é um corpo. Assim, S é L.I.

Para (3), se admitirmos que S é L . D., por deﬁnição temos que existem escalares
α1, α2, . . . , αm não todos nulos, tais que: α1.v1 + · · · + αi.vi + · · · + αm.vm = (0, 0, . . . , 0)

Supondo que αi Ó= 0, temos o inverso multiplicativo de αi. Multiplicando todos os

elementos por α−1

i

obtemos:

α−1
i

.α1.v1 + · · · + α−1

i

.αi.vi + · · · + α−1

i

.αm.vm = (0, 0, . . . , 0).

Então

Capítulo 3. O Espaço Vetorial Finito Zn
p .

36

α−1
i

.α1.v1 + · · · + vi + · · · + α−1

i

.αm.vm = (0, 0, . . . , 0).

Logo,

vi = −α−1

i

.α1.v1 − · · · − α−1

i

.αm.vm

Ou seja, o elemento vi é combinação linear dos outros elementos de S.

Proposição 3.4.

(1) Sejam S1 e S2 subconjuntos ﬁnitos e não vazios de Zn

p . Se S1 é

L.D. e S1 ⊂ S2, então S2 também e L.D.

(2) Sejam S1 e S2 subconjuntos ﬁnitos e não vazios de Zn

p . Se S2 é L . I. e S1 ⊂ S2,

então S1 também e L . I.

(3) Se S = {v1, v2, . . . , vn} ⊂ Zn

p é L . I. e para algum v ∈ Zn
p tivermos que S ∪ {v} =
{v1, v2, . . . , vn, v} é L . D. então o elemento v é combinação linear dos elementos de
S.

Demonstração. Para (1) escrevemos os subconjuntos S1 = {v1, v2, . . . , vj} e

S2 = {v1, . . . , vj, . . . , vn}, não vazios de Zn

p . Ora, se S1 é L . D, então existem

escalares α1, α2, . . . , αj nem todos nulos, de forma que:

α1.v1 + α2.v2 + · · · + αj.vj = (0, 0, . . . , 0)

E completando essa equação com zeros até utilizarmos todos os vn elementos para

descrever S2 temos:

α1.v1 + · · · + αi.vj + 0.vj+1 + · · · + 0.vn = (0, 0, . . . , 0)

Podemos notar que nem todos os escalares desta igualdade serão nulos, portanto

temos que S2 é L . D.

Para (2), note que, das observações em (1), caso S1 fosse L . D., então teríamos que
S2 também é L . D. Entretanto, S2 é L . I, assim S1, subconjunto com menos elementos,
só pode ser L . I.

Para (3) se temos S∪{v} um conjunto L . D . Então, existem escalares α1, α2, · · · , αm, α,

não todos nulos tais que:

α1.v1 + α2.v2 + · · · + αmvm + αv = (0, 0, . . . , 0)

(3.1)

Podemos veriﬁcar que um dos escalares não nulos é α, uma vez que se α = 0

teríamos:

α1.v1 + · · · + αmvm = (0, 0, . . . , 0)

Capítulo 3. O Espaço Vetorial Finito Zn
p .

37

Mas, como S é L . I. esta última igualdade só vale se α1 = · · · = αm = 0. Porém,
neste caso teríamos α1 = · · · = αm = α = 0 e daí o conjunto v1, . . . , vm, v seria L . I., oque
contradiz a hipótese dele de ser L . D. Assim, temos que α Ó= 0.

Podemos então multiplicar por α−1 a equação 3.1:

α−1.α1.v1 + α−1.α2.v2 + · · · + α−1.αm.vm + v = (0, 0, . . . , 0).

Logo

v = −α−1.α1.v1 − α−1.α2.v2 − · · · − α−1.αm.vm.

O que mostra que v é combinação linear dos elementos de S, ou seja, v ∈ [S]

Proposição 3.5. Se um elemento é combinação linear dos demais, ele pode ser extraído
do conjunto de geradores, sem mudar do subespaço gerado, ou seja:

Se S = {v1, . . . , vj, . . . , vm} ⊂ [S − {vj}], então [S] = [S − {vj}].

Demonstração. Suponhamos que v1 é combinação linear dos demais elementos de S, então
ele pode ser escrito como:

v1 = β2.v2 + · · · + βm.vm.

Considere um elemento x ∈ [S], isto é, x pode ser escrito como combinação linear

dos elementos de S:

x = α1.v1 + α2.v2 + · · · + αm.vm

= α1 (β2.v2 + · · · + βm.vm) + α2.v2 + · · · + αm.vm

= (α1.β2 + α2) .v2 + · · · + (α1.βm + αm) .vm

O que mostra que x é combinação linear dos elementos de [S − {v1}], ou seja,

x ∈ [S − {v1}].

Daí, supondo que x ∈ [S − {v1}] temos que x = 0.v1 + γ2.v2 + · · · + γm.vm, ou seja

x ∈ [S].

Portanto, qualquer elemento de [S] pertence a [S − {v1}] e vice versa, permitindo

que o elemento v1 possa ser extraído do conjunto de geradores.

Exemplo 3.8. Os elementos v1 = (1, 2) e v2 = (3, 6) do espaço vetorial Z2
dependente.

7 são linearmente

Basta veriﬁcar que: (3, 6) = 3.(1, 2), ou seja, v2 = 3v1. Assim, v2 é combinação

linear de v1.

Capítulo 3. O Espaço Vetorial Finito Zn
p .

38

Exemplo 3.9. O subconjunto S = {(1, 1, 0, 0), (0, 1, 0, 2), (0, 0, 1, 0), (0, 2, 4, 4)} ⊂ Z4
linearmente dependente.

5 é

De fato, temos que:

0.(1, 1, 0, 0) + 2.(0, 1, 0, 2) + 4.(0, 0, 1, 0) = (0, 2, 4, 4)

ou seja, um dos vetores é combinação linear dos demais, assim o subconjunto é L .

D.

Pela Proposição 3.5 podemos extrair (0, 2, 4, 4) do conjunto de geradores e temos:

[S] = [(1, 1, 0, 0), (0, 1, 0, 2), (0, 0, 1, 0)]

, ou seja, S é gerado por esses três vetores.

Exemplo 3.10. O conjunto {(1, 0), (0, 1)} em Z2

2 é linearmente independente.

De fato, a equação: α1(1, 0) + α2(0, 1) = (0, 0) só vale para α1 = α2 = 0. Assim, os

vetores (1, 0), (0, 1) são L . I.

3.6 Base e Dimensão de Subespaços de Zn
p

Deﬁnição 3.6. Seja V um subespaço de um espaço vetorial Zn
p . Uma base de V é um
conjunto ﬁnito B = {v1, . . . , vn} ⊂ Zn
p de elementos de V , tal que B é linearmente
independente(L.I.) e gerador do espaço vetorial V , ou seja, qualquer elemento de V pode
ser escrito como combinação linear dos elementos de B.

Exemplo 3.11. Tem-se que {(1, 0), (0, 1)} é uma base para o espaço vetorial Z2
tambem é conhecida como base canônica do Z2
2.

2, que

Teorema 3.1. Dado V um subespaço de Zn
geram V , então é possível, a partir desses elementos, extrair uma base para V .

p e um subconjunto contendo m elementos que

Demonstração. Considere B = {v1, . . . , vm} ⊂ V o conjunto de elementos que geram V .

Se B = {v1, . . . , vm} é composto de vetores L.I. , por deﬁnição eles geram uma

base, e não é necessário realizar demonstração .

Por outro lado, se o mesmo conjunto de vetores for L.D., então existem escalares

α1, . . . , αm tal que seja válida a igualdade:

α1.v1 + α2.v2 + · · · + αm.vm = (0, 0, . . . , 0)

Capítulo 3. O Espaço Vetorial Finito Zn
p .

39

Suponhamos, sem perda de generalidade, αm Ó= 0. Podemos multiplicar todos os

αi’s por α−1

m , obtendo

m .α1.v1 + α−1
α−1

m .α2.v2 + · · · + α−1

m .αm.vm = (0, 0, . . . , 0)

vm = −α−1

m .α1.v1 − α−1

m .α2.v2 − · · · + α−1

m .αm−1.vm−1

Na prática signiﬁca dizer que vm é combinação linear dos demais elementos. Pela
Proposição 3.5, mesmo extraindo o vetor vm, V continua sendo gerado por {v1, · · · , vm−1}.
E repetindo o processo uma quantidade ﬁnita de vezes, temos um subconjunto {v1, . . . , vr}
com r elementos (r ≤ m) que ainda geram V e são L.I., ou seja, formam uma base de V .
Portanto, é possivel extrair um conjunto de vetores que geram uma base para V .

Teorema 3.2. Se B = {v1, . . . , vm} é uma base para o subespaço vetorial V , com m vetores,
qualquer outro subconjunto de vetores L.I. que gera V tem no máximo m elementos.

Demonstração. Considere w = {w1, w2, · · · , wm, · · · , wk} ⊂ V , com k > m. Mostraremos
que W é linearmente dependente (L.D.).

Como {v1, v2, · · · , vm} é base de V e cada wi ∈ V , segue que

wi = α1i.v1 + α2i.v1 + · · · + αmi.vm, i = 1, 2, · · · , k

(3.2)

Considere também a combinação linear nula

β1.w1 + · · · + βk.wk = (0, 0, . . . , 0), com escalares β1, · · · , βk ∈ Zp

(3.3)

Podemos reescrever a equação de 3.2 em 3.3, substituindo cada wi = α1i.v1 +

α2i.v1 + · · · + αki.vk, obtendo

β1.w1 + · · · + βk.wk = (0, 0, . . . , 0)
β1.(α11.v1 + α21.v1 + · · · + αm1.vm) + · · · + βk.(α1k.v1 + α2k.v1 + · · · + αmk.vm) = (0, 0, . . . , 0),
ou seja
v1.(β1.α11 + · · · + βk.α1k) + · · · + vm.(β1.αm1 + · · · + βk.αmk) = (0, 0, . . . , 0)

Como {v1, . . . , vn} é uma base para V , então este conjunto é L . I. Assim temos:

β1.α11 + β2.α12 + · · · + βk.α1k = 0




β1.αm1 + β2.αr2 + · · · + βk.αmk = 0



Capítulo 3. O Espaço Vetorial Finito Zn
p .

40

Obtemos um sistema linear homogêneo com m equações e k incógnitas β1, . . . , βk.
E como o número de equações é menor que o número de incógnitas, o sistema admite
solução não trivial. Assim, existem escalares não todos nulos β1, . . . , βk, tais que:

β1.w1 + · · · + βk.wk = (0, 0, . . . , 0)

Portanto, W = {w1, w2, . . . , wk} é L . D. Assim, qualquer conjunto com mais de k

elementos é L .D., ou seja, qualquer conjunto L . I. possui no máximo m elementos.

Teorema 3.3. Se V um subespaço de Zn
o mesmo número de elementos.

p , então duas bases quaisquer, A e B tem sempre

Demonstração. Sejam as bases A = {v1, . . . , vm} e B = {w1, . . . , wk} geradores de V ⊂Zn
p .
Se considerarmos que A gera V , então podemos dizer que é formado por vetores L.I..

Se m < k e k é o número de elementos da base B, o conjunto B não será L.I.
Contradizendo o Teorema 3.2. De modo análogo, não podemos ter m > k, pois o conjunto
A também é L.I. Portanto, m = k. e assim, qualquer base de V tem o mesmo número de
elementos.

Segue do Teorema 3.3 a deﬁnição que daremos a seguir, que é o conceito de

dimensão.

p , V Ó= ∅ é o número de
Deﬁnição 3.7. A dimensão de um espaço vetorial V ⊂ Zn
elementos de uma base, cuja notação é dim(V ). Caso V seja formado apenas pelo vetor
nulo, ou seja, V = {(0, 0, . . . , 0)} então sua dimensão dim(V ) = 0.

Exemplo 3.12. Temos que {(1, 0), (0, 1)} é uma base para o espaço vetorial Z2
dimensão será dim(Z2

2) = 2.

2 . Sua

Teorema 3.4 (Teorema do Completamento). Seja um subespaço vetorial V ⊂ Zn
p . Qual-
quer conjunto ﬁnito de elementos linearmente independentes (L.I) de V pode ser completado
até formar uma base para V .

Demonstração. Seja dim(V ) = m e v1, . . . , vr elementos L . I. em V pelo Teorema 3.3
r ≤ m. Se os elementos v1, . . . , vr geram V , então {v1, . . . , vr} já é uma base. Agora, se
isso não ocorre, então existe um vr+1 ∈ V que não é combinação linear de v1, . . . , vr então
{v1, . . . , vr, vr+1} ainda é L . I., pois caso contrário a equação: α1.v1+. . .+αr.vr+αr+1.vr+1 =
(0, 0, . . . , 0) seria verdadeira para αr+1 Ó= 0 e, então poderíamos multiplicar a equação por
α−1
r+1 e determinar vr+1, como combinação linear de v1, . . . , vr, o que é uma contradição.

Se {v1, . . . , vr, vr+1} gera V , então é uma base. Caso contrário, repetimos o processo
até completar a base. Esse processo termina em um número ﬁnito de passos, uma vez que

Capítulo 3. O Espaço Vetorial Finito Zn
p .

41

pelo Teorema 3.3, não podemos ter um conjunto L . I. com mais de m elementos, já que
dim(V ) = m.

Teorema 3.5. Sejam U, W ⊂ Zn
U + W é obtida pela relação

p subespaços vetoriais. Então, a dimensão do vetor soma

dim(U + W ) = dim(U ) + dim(W ) − dim(U ∩ W ).

onde U ∩ W reúne os elementos comuns aos dois subespaços.

Demonstração. Tomemos {v1, . . . , vr} os elementos de uma base para U ∩ W . Logo
(dim(U ∩ W ) = r) pelo Teorema 3.4, podemos completar esse conjunto até obter uma
base para U .

Seja {v1, . . . , vr, u1, . . . , um} esta base para U , (dim(U ) = r + m).

De maneira análoga, podemos completar {v1, . . . , vr} para obter uma base para W .
Seja {v1, . . . , vr, w1, . . . , wk} base para W , sua dimensão será (dim(W ) = r + k). Como
U = év1, . . . , vr, u1, . . . , umê e W = év1, . . . , vr, w1, . . . , wkê então temos que:

U + W = év1, . . . , vr, u1, . . . , um, w1, . . . , wkê

E provemos que esse conjunto é linearmente independente.

Considere a equação:

r

i=1
Ø

m

k

aivi +

bjuj +

clwl = (0, 0, . . . , 0)

(3.4)

j=1
Ø

Øl=1

Logo,

k

r

m

−

clwl =

aivi +

bjuj

Øl=1

i=1
Ø

j=1
Ø

(3.5)

O primeiro termo da última igualdade é uma combinação linear de elementos de
W , logo pertence a W , o segundo termo é uma combinação linear de elementos de U , logo
pertence a U .

Como vale a igualdade, então temos que o primeiro termo também pertence a U ,

assim:

clwl ∈ U ∩ W .

k

Øl=1

Capítulo 3. O Espaço Vetorial Finito Zn
p .

42

Podemos escrevê-lo como combinação linear dos elementos da base de U ∩ W .

k

Øl=1

r

k

r

clwl =

αivi ⇔

clwl −

αivi = (0, 0, . . . , 0)

(3.6)

Øl=1

Øl=1

i=1
Ø

Como {v1, . . . , vr, w1, . . . , wk} é L . I., pois é uma base para W , temos c1 = . . . =

ck = α1 = . . . = αr = 0

Na equação 3.4, obtemos:

r

m

k

aivi +

bjuj +

clwl = (0, 0, . . . , 0)

i=1
Ø
Como {v1, . . . , vr, u1, . . . , um} é L.I., pois é uma base de U , temos que a1 = . . . =

j=1
Ø

Øl=1

ar = b1 = . . . = bm = 0.

Portanto {v1, . . . , vr, u1, . . . , um, w1, . . . , wk} é uma base de U + W . Logo:

dim(U + W ) = r + m + r + k − r = (r + m) + (r + k) − r, ou seja,

dim(U + W ) = dim(U ) + dim(W ) − dim(U ∩ W ).

Teorema 3.6. Seja B = {v1, . . . , vm} uma base ordenada de V , com V ⊂Zn
p e os
elementos de B seguindo uma ordem ﬁxa. Então, todo elemento de V pode ser escrito de
modo único como combinação linear dos vetores da base.

Demonstração. Considere v ∈ V e que v =

m

m

m

j=1
Ø

m

ajvj e v =

bjvj. Fazendo v − v temos:

j=1
Ø

v − v = (0, 0, . . . , 0) =

ajvj −

bjvj,

j=1
Ø

j=1
Ø

ou seja,

(aj − bj)vj = (0, 0, . . . , 0)

m

j=1
Ø

O que implica que aj − bj = 0 se, e só se aj = bj∀j, uma vez que {v1, . . . , vm} é L .
I. Logo, o elemento v ∈ V é escrito de modo único como combinação linear dos elementos
da base ordenada de V .

Como se vê, com a ideia de que subespaços de Zn

p podem ser gerados a partir
de alguns vetores, é possível, a partir de alguns vetores, determinar outros, gerando um
conjunto. Vejamos na seção seguinte o procedimento para determinação destes geradores.

Capítulo 3. O Espaço Vetorial Finito Zn
p .

43

3.7 Processo Prático Para Determinar Bases de Subespaços de Zn
p

Primeiro Processo

Seja W ⊂ Zn

p o subespaço vetorial gerado pelo conjunto de vetores {a1, a2, . . . , am},

ou seja,

W = [a1, a2, . . . , am].

É possível obter uma base de W , contida em {a1, a2, . . . , am}, seguindo o seguinte

procedimento:

Início do procedimento:

i Construir uma matriz M cujos vetores a1, a2, . . . , am são as colunas dessa matriz, ou

seja, ela tem n linhas por m colunas;

M = [a1, a2, . . . , am]

ii Realizar, nessa matriz, operações de escalonamento nas linhas, obtendo M ′.

iii Observar na matriz M ′ quais colunas são colunas pivô, ou seja, contém um elemento
não nulo e suas posições a esquerda, na mesma linha, mas como índice de coluna
menor, contém zeros, como (LAY, 2007) ilustra representativamente abaixo:

iv Os vetores que geram a base a partir do subespaço W são os vetores ai nos quais o

respectivo índice na matriz escalonada apresenta pivô.

Figura 3.1 – Exemplo de colunas pivô.

Fonte: David C. Lay/Algebra Linear e Aplicações.

Fim do procedimento.

Para melhor compreensão, vejamos o exemplo abaixo:

Capítulo 3. O Espaço Vetorial Finito Zn
p .

44

Exemplo 3.13. Seja S subespaço de Z5

2 gerado pelo conjunto A = {a1, a2, a3, a4} onde:

a1 = (1, 0, 1, 1, 0) ; a2 = (1, 1, 0, 0, 0) ; a3 = (0, 1, 1, 1, 0) ; a4 = (1, 0, 0, 1, 0)

Vamos executar os passos do procedimento para encontrar uma base S contida em

A. Fazemos isso considerando a matriz M cujas colunas são os vetores de A:

M =

1 1 0 1
0 1 1 0
1 0 1 0
1 0 1 1
0 0 0 0



























Escalonamos a matriz M usando operações de linha

1 1 0 1
0 1 1 0
1 0 1 0
1 0 1 1
0 0 0 0














M =














−−−−−−→
L3=L3+L1
L4=L4+L1














1 1 0 1
0 1 1 0
0 1 1 1
0 1 1 0
0 0 0 0

−−−−−−→
L3=L3+L2
L4=L4+L2














1 1 0 1
0 1 1 0
0 0 0 1
0 0 0 0
0 0 0 0



























Note que as colunas pivô, em destaque, são respectivamente as colunas 1, 2 e 4. Daí
concluímos que a base S contida em A é formada pelos vetores.

a1 = (1, 0, 1, 1, 0) ; a2 = (1, 1, 0, 0, 0) ; a4 = (1, 0, 0, 1, 0) ;

Apenas pra comprovarmos que os vetores a1, a2, a4 geram uma base, do Teorema

3.1 vamos veriﬁcar se eles são L . I. De fato:

α1.a1 + α2.a2 + α4.a4 = (0, 0, 0, 0)

α1.(1, 0, 1, 1, 0) + α2.(1, 1, 0, 0, 0) + α4.(1, 0, 0, 1, 0) = (0, 0, 0, 0)

(α1 + α2 + α4, α2, α1, α1 + α4, 0) = (0, 0, 0, 0)

E organizando os sistemas de equações para a obtenção dos αis temos

α1 + α2 + α4 = 0

⇒

α2 = 0

α1 = 0






α1 + α4 = 0 ⇒ 0 + α4 = 0 ⇒ α4 = 0

De fato, os vetores são L.I. e podem gerar uma base.

Como abordado em (TAUSK, 2008), o método é eﬁcaz porque se baseia em três

fatos:

Capítulo 3. O Espaço Vetorial Finito Zn
p .

45

Aﬁrmação 1. Se uma matriz M ′ é obtida de uma matriz M através de operações
de escalonamento (operações de linha ) então as relações lineares satisfeitas pelas colunas
de M são as mesmas que as relações lineares satisfeitas pelas colunas de M ′. Perceba que
o conjunto solução de um sistema linear homogêneo não se altera quando escalonamos
(com operações de linha) a sua matriz de coeﬁcientes e que as colunas a1, a2, · · · , am da
matriz M formam uma relação linear do tipo

α1.a1 + α2.a2 + · · · + αm.am = 0

com α1, α2, · · · , αm soluções do sistema com matriz de coeﬁcientes M .

Aﬁrmação 2. Se M ′ é uma matriz escalonada n × m então as colunas pivô de M ′

formam um subconjunto linearmente independente de Zn
p .

Se olharmos as colunas pivô na matriz escalonada, vamos descobrir que os vetores

formados por elas são L.I.

Aﬁrmação 3. Se M ′ é uma matriz escalonada n × m então uma coluna de M ′
que não contém pivô pertence ao subconjunto de Zn
p gerado pelas colunas-pivô de M ′ que
a antecedem. Olhando com atenção o exemplo realizado acima, note que na matriz M ′, a
terceira coluna não contém pivô, mas que pode ser resultado da operação:

′

a

′

3 = a

1 + a
2

′

Portanto, o processo descrito é uma forma de determinar bases de subespaços de

Zn
p .

Segundo Processo

No livro "Álgebra Linear e aplicações" de (CALLIOLI et al., 2000), em sua página
p , dado

80, é descrito um outro procedimento para se obter uma base de um subespaço Zn
por seus geradores ou onde seja possível encontrar esses geradores.

Para tanto, ele se baseia em três aﬁrmações.

Sendo W = [a1, a2, . . . , ar] ⊂ Zn

p , ou seja, subespaço de Zn

p valem:

• Se permutarmos dois vetores que lá estão presentes, não alteramos o subespaço

gerado, ou seja,

W = [a1, a2, . . . , ai, · · · , aj, . . . , ar] = [a1, a2, . . . , aj, · · · , ai, . . . , ar]

• Para todo número α ∈ Zp têm-se que

W = [a1, a2, . . . , ai, · · · , aj + αai, . . . , ar]

Capítulo 3. O Espaço Vetorial Finito Zn
p .

46

• Se a1, a2, · · · , ar se apresentam na forma escalonada, com o número de zeros iniciais
de a2 , maior que o de a1, então os vetores a1, · · · , ar formarão um conjunto L.I e
dimW = r.

Vamos seguir os seguintes passos:

Início do Procedimento

i Construir uma matriz M onde os vetores {a1, a2, · · · , ar} são as Linhas de M .

M =

a1
a2
...
ar





















ii Realizar nessa matriz M operações de escalonamento em linhas, obtendo M ′.

iii As linhas não nulas de M ′ são os vetores da base de W .

Fim do procedimento.

Uma ressalva importante é que os vetores da base encontrada não necessariamente

estão contidos em {a1, a2, · · · , ar}.

Baseado neste procedimento descrito acima,vamos realizar um exemplo para a

determinação de uma base.

Exemplo 3.14. Seja W subespaço de Z5

2 gerado pelo conjunto A = {a1, a2, a3, a4}

onde:

a1 = (1, 0, 1, 1, 0) ; a2 = (1, 1, 0, 0, 0) ; a3 = (0, 1, 1, 1, 0) ; a4 = (1, 0, 0, 1, 0)

Realizando as operações do procedimento acima relatado e executando o escalona-

mento temos:

1 0 1 1 0
1 1 0 0 0
0 1 1 1 0
1 0 0 1 0











M =











−−−−−−→
L2=L2+L1
L4=L4+L1











1 0 1 1 0
0 1 1 1 0
0 1 1 1 0
0 0 1 0 0











−−−−−−−−−→
L3 = L3 + L2

1 0 1 1 0
0 1 1 1 0
0 0 0 0 0
0 0 1 0 0





















−−−−−→
L3 ↔ L4











1 0 1 1 0
0 1 1 1 0
0 0 1 0 0
0 0 0 0 0











Capítulo 3. O Espaço Vetorial Finito Zn
p .

47

1 0 1 1 0
0 1 1 1 0
0 0 1 0 0
0 0 0 0 0





















As linhas não nulas da matriz M ′ =

serão os vetores da base

de W . E para mostrar que b1 = (1, 0, 1, 1, 0), b2 = (0, 1, 1, 1, 0) e b3 = (0, 0, 1, 0, 0) são
geradores de uma base sobre Z5
2, vejamos se tais vetores são Linearmente Independentes.

Sejam β1, β2, · · · , βr ∈ Z2 e b1, b2, · · · , br vetores sobre Z5

2, eles serão L.I. quando:

β1.b1 + β2.b2 + · · · + βr.ar = 0.

De fato:

β1.b1 + β2.b2 + β3.b3 = (0, 0, 0, 0, 0)

β1.(1, 0, 1, 1, 0) + β2.(0, 1, 1, 1, 0) + β3.(0, 0, 1, 0, 0) = (0, 0, 0, 0, 0)

(β1, β2, β1 + β2 + β3, β1 + β2, 0) = (0, 0, 0, 0, 0)

E organizando os sistemas de equações para a obtenção dos βis temos

β1 = 0






β2 = 0

⇒

β1 + β2 + β3 = 0

β1 + β2 = 0

ou seja β1 = β2 = β3 = 0

Portanto, os vetores são L.I. e podem gerar uma base.

Como C é um espaço vetorial, se tivermos todos os elementos de C, observe que
em ambos os processos obtemos os mesmos resultados, porém o processo citado em Callioli
é o mais conhecido.

3.7.1 A Função Produto Interno em Zn
p

Considere a função:

é., .ê : Zn

p × Zn

p → Zn

p

éu, vê = a1.b1 + a2.b2 + · · · + an.bn, onde u = (a1, a2, . . . , an) e v = (b1, b2, . . . , bn).

Essa função é um quase produto interno no espaço vetorial Zn
p .

Proposição 3.6. A função quase produto interno satisfaz as seguintes propriedades:

i) éu, vê = év, uê, para todo u, v ∈ Zn
p

ii) éu, v + wê = éu, vê + éu, wê para todo u, v, w ∈ Zn
p ;

Capítulo 3. O Espaço Vetorial Finito Zn
p .

48

iii) αéu, vê = éαu, vê = éu, αvê para todo α ∈ Zp e u, v ∈ Zn
p .

Demonstração.

i) Observe que é verdade, pois:

éu, vê = a1.b1 + a2.b2 + · · · + an.bn = b1.a1 + b2.a2 + · · · + bn.an = év, uê .

ii) De fato, pois

consideremos v + w = (b1 + c1, b2 + c2, . . . , bn + cn) e obtemos.

éu, v + wê = a1.(b1 + c1) + a2.(b2 + c2) + · · · + an.(bn + cn) =

= (a1.b1 + a1.c1) + (a2.b2 + a2.c2) + · · · + (an.bn + an.cn)

= (a1.b1 + a2.b2 + · · · + an.bn) + (a1.c1 + a2.c2 + · · · + an.cn)

= éu, vê + éu, wê

iii) De fato, pois

éαu, vê = (αa1).b1 + (αa2).b2 + · · · + (αan).bn

α(a1.b1 + a2.b2 + · · · + an.bn) = αéu, vê.

Observação: A operação deﬁnida na proposição 3.6 possui propriedades que são
usuais no conceito de produto interno. Todavia a propriedade éu, uê = 0 se, e somente se
u = 0 não é satisfeito em Zn

p . Por exemplo, considere u = (1, 1) ∈ Z2

2 e observe que

éu, uê = 1.1 + 1.1 = 2 e u Ó= 0.

Apresentadas as propriedades do Espaço Vetorial Zn

p , é possivel deﬁnir os conceitos
de códigos, em especial os lineares, assim compreender melhor os algoritmos envolvidos na
codiﬁcação e os bits de vericação/paridade na criação do mesmo.

4 Códigos Lineares: Conceitos e a Métrica de

49

Hamming

Desde a criação dos primeiros algoritmos computacionais e a programação de
máquinas locais e remotas, ou ainda a necessidade de transmissão para grandes distâncias,
havia a preocupação sobre a garantia de que a informação transmitida fosse facilmente
entendida dos dois lados da transmissão.

Fazendo uma analogia rasa, de fácil compreensão, imaginemos a atividade lúdica
“ telefone sem ﬁo ”. Escolhido o meio por onde a mensagem foi repassada, se em algum
momento a mensagem se perdeu, parcial ou totalmente, desde a sua emissão, teremos um
destinatário que não entenderá a mensagem e pedirá novamente, ou pior ainda, decifrará
de modo errado a mensagem.

A aplicabilidade dos algoritmos nas comunicações e a integridade de que a infor-
mação chegará inteira, conﬁável e com menor possibilidade de perda, fez com que estudos
nesse sentido avançassem, principalmente nos sistemas de comunicações.

(ALENCAR, 2007) aﬁrma:

Todos os sistemas de comunicações em pequenas ou altas proporções,
estão sujeitos a pertubações causadas pela ação do ruído presente no
canal. Este efeito pode acasionar a ocorrência de erros nas mensagens
que são recebidas por um sistema receptor. Genericamente são chamados
de erros aleatórios, quando este tipo de incidência ocorre de maneira
esporádica e independente; já quando ocorrem em surtos, ou seja, em
sequência de vários erros consecutivos, são denominados erros em rajadas
(ALENCAR,2007)

Como precursores na teoria de códigos, podemos enunciar que eles acompanham o
salto computacional no ínicio dos anos 40, onde a tecnologia era utilizada para tarefas
complexas e posteriormente, os sistemas de controle digitais(SCD).

Segundo (MILIES, 2009) :

A teoria teve início na decada de quarenta quando os computadores
eram máquinas muito caras e apenas instituições de grande porte como o
governo ou as universidades tinham condições de mantê-la. Eles usando-
os para executar tarefas numéricas complexas, com calcular o órbita
precisa de Marte ou fazer a avaliação estatística de um censo.

Quem primeiro se preocupou de forma sistemática com esse assunto foi Richard
Wesley Hamming (1915 − 1998). Em 1950, ele publicou, no Bell System Technical Journal
de abril, um trabalho com o título de: Error Detecting and Error Correcting Codes, que

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

50

pode ser considerado a primeira sistematização teórica sobre detecção e correção de erros
((ROCHOL, 2012), p, 249).

Além de Hamming, Shannon (com a sua teoria de códigos e a Teoria da Informação),
Golay (cujo código foi usado pela espaçonave Voyager(em 1980 e 1981) para transmitir
fotograﬁas coloridas de Júpter e Saturno), e outros cientistas foram os grandes pioneiros
que iniciaram o trabalho com este assunto e desenvolveram estudos e ideias que são usadas
em nosso dia a dia, como por exemplo, a comunicação móvel (telefones celular), aparelhos
de armazenamento de imagens digitais, internet e rádio entre outras utilidades.

As técnicas de paridade foram as primeiras técnicas a serem desenvolvidas e
utilizadas. Devido sua simplicidade, ainda são largamente utilizadas em protocolos de
comunicação baseados em caracteres.

Basicamente, na transmissão de uma informação, nos preocupamos com o meio por
onde ela passará, o tamanho da quantidade (ou pacote) de informação a ser transmitida, e
o algoritmo a ser utilizado.

Figura 4.1 – Acrescentando Bits de Paridade ao pacote de informação

Fonte: Silvio Abrantes, pg 39

Nos meios digitais, por exemplo, que reconhecem apenas bits, dependendo do que
se quer transmitir, temos um algoritmo para transformação do texto em código, geralmente
do tipo Z2 (aceitando apenas bits 0 e 1), e a adição de bits de veriﬁcação ou simplesmente
bits para veriﬁcação do erro no destinatário.

Vale destacar ainda que existem, na teoria de códigos os algoritmos corretores
de erros e os veriﬁcadores de erros. Eles podem funcionar em conjunto ou isoladamente,
dependendo da função a que se aplica, para garantir a seguridade da informação transmitida.

Ao transmitir uma informação ou dado com conﬁabilidade, independente do meio,
é preciso planejar e escolher qual algoritmo é o mais adequado. Pensemos na diﬁculdade
que seria enviar uma mensagem e ela chegar sem compreensão do outro lado, partida
ou exigir que o emissor precise repeti-la até que fosse compreendida. Além de demandar

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

51

tempo e energia, dependendo de como isso é feito, ainda se torna inseguro ou inviável,
cumprindo fracamente a função ou a ideia de comunicar.

Quando nos referimos a informação por meios digitais, velocidade, segurança e
compreensão são fundamentais, o que demanda implementação de estratégias eﬁcientes e
que gastem o menor esforço possível.

Ao realizarmos uma transmissão em pacotes de dados, a informação a ser encami-
nhada nada mais é do que pacotes de dados, de estruturas que aceitam valores (ou bits)
quaisquer, mas que ainda mantém sua estrutura, por possuir um tamanho ﬁxo.

Costurando essa ideia com a álgebra abstrata, a mensagem a ser transmitida entre
o meio nada mais é do que o bloco de informação cuja escrita se baseia da utilização de bits
ou algorismos que pertencem a um conjunto. Independente de quantos e quais elementos
possuam tais blocos de informação, o que temos é a certeza de que, utilizando-se da
álgebra, são palavras de um “alfabeto”, que são obtidos através de vetores ou combinação
de elementos de um conjunto ﬁnito. (HEFEZ ABRAMO. M.L.T, 2008)

Figura 4.2 – Procedimento para a transmissão de Mensagem

Fonte: autor/banco de imagens-internet

Partindo dessa ideia, pensemos num conjunto não vazio (como o caracterizado
anteriormente no capítulo anterior, Zn
p ) na qual podemos deﬁnir operações de soma e de
multiplicação por escalar. Com o auxílio da álgebra linear sobre corpos ﬁnitos, podemos
dizer ainda que esses blocos de informação são na verdade sequências de bits organizados

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

52

como vetores, ou simplesmente n-uplas de elementos de Zp, como abordado em (HEFEZ
ABRAMO. M.L.T, 2008) .

Ao realizar as diferentes operações deﬁnidas com estes elementos, de quantidade
ﬁnita, cria-se o que deﬁnimos como espaço vetorial. Ao admitir, por exemplo, que uma
coordenada do Z2
p, de coordenada genérica V = (a, b), com a e b elementos do conjunto
Zp, estamos construindo um espaço vetorial.

Neste capítulo, deﬁniremos alguns conceitos relacionados a ideia de códigos, as-
sim como representarmos e deﬁnirmos o que é um código, sua construção e codiﬁca-
ção/decodiﬁcação por meio de matrizes. A metodologia segue os conceitos de (HEFEZ
ABRAMO. M.L.T, 2008), deﬁnindo primeiramente o que é o código linear e a constituição
de suas palavras, para posteriormente, apoiados na consideração que estas palavras podem
ser codiﬁcadas por meio de matrizes, explicar o processo de criação da “ novas palavras ”
e o processo de decodiﬁcação e comparação dos pacotes, através das distâncias e métricas.

4.1 Código Linear

Imaginemos uma grande quantidade de informação a ser transmitida de um meio
para outro, como por exemplo este trabalho através de um e-mail. A máquina na qual
este arquivo está armazenado não considera a estrutura e o valor do nosso “ idioma ”,
entendendo na verdade que cada caracter assume valores 0 e 1 ou simplesmente bits de
informação. Ao armazenar este arquivo na forma de um “ idioma de máquina”, temos
o equivalente a um código. Entenda-se que para a transmissão, esse código precisa ser
robusto e conﬁável o suﬁciente para não se perder na transmissão. Para tal, essa sequência
é segmentada em blocos de mensagens, mensagens estas que fazem parte do código.

Cada palavra/mensagem deste código é vista como uma n-upla 1, cuja forma de
saída da fonte é da forma binária. Daí, das operações de vetores vistas no capítulo anterior,
podemos adicionar os bits para o aumento do comprimento da mensagem e podemos tanto
codiﬁcá-la quanto decodiﬁcá-la.

Por ser uma sequência ordenada de n elementos, de forma binária, e poder ser vista
como vetores, é possível mapeá-los dentro de um outro subespaço vetorial de tamanho
maior, graças a propriedade de fechamento de subespaços.

Trazendo luz a analogia citada, perceba que as palavras escritas nesta obra são
apenas fáceis de entender porque todas as palavras colocadas aqui fazem parte do nosso
“ idioma ”. No momento em que escrevo qualquer coisa diferente das palavras “ comuns
” (lista de palavras que são compreendidas no nosso idioma-código), perde-se o valor da

1 Uma n-upla é uma sequência ordenada de n elementos. Também é conhecida com n-upla, u-tuplo
ou simplesmente tupla. Por exemplo, (1, 0) é uma 2-upla binaria. Já a sequência (1, 0) é outra 2-upla
binária.

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

53

informação e portanto, é necessário reescrevê-la.

Para as transmissões digitais, a mensagem enviada faz parte da lista de palavras
do código e graças a isso ela pode ser entendida no destinatário (depois de decodiﬁcada).
O que temos, abordando de forma simples é que a mensagem transmitida guarda consigo
a informação e que esta faz parte de uma lista de palavras presentes no código. O fato de
ele ser linear permite que não apenas esses bits sejam ordenados, como as operações de
codiﬁcações realizadas sobre ele modiﬁquem a mensagem, mas preservem a informação ao
descodiﬁcar.

Para melhor entender os principais conceitos que fazem parte desse processo,

vejamos as deﬁnições e proposições seguintes.

Deﬁnição 4.1. Se C ⊂ Zn
vetorial de Zn

p . Se p = 2, C é chamado de código linear binário.

p . Dizemos que C é um código linear se C é um subespaço

A deﬁnição acima é valida para qualquer corpo ﬁnito, como abordado em ((HEFEZ

ABRAMO. M.L.T, 2008), pg. 85-86).

Como C ⊂ Zn

p e C é um subespaço vetorial de Zn

p , então existem v1, v2, . . . , vk ∈

Zn

p vetores linearmente independentes, tais que

C = év1, v2, . . . , vkê = {a1v1 + a2v2 + · · · + akvk, a′

is ∈ Zp}

Daí, dimZpC = k, onde dimZpC denomina-se a dimensão de código C.

Proposição 4.1. Se C ⊂ Zn

p é um código linear de dimensão k, então m = |C| = pk.

Demonstração. Para w ∈ C,existem a1, a2, . . . , an ∈ Zp tais que w = a1v1+a2v2+· · ·+akvk.
Segue do princípio multiplicativo que temos pk possibilidades para cada a1, a2, . . . , ak ∈
Zp formando vetores w ∈ C. Portanto |C| = pK.

Observe que: m = pk ⇔ logp pk = k = dimZpC.

Para exempliﬁcar a notação, escrevemos

Dado C ⊂ Zn

p um código linear cuja base é {v1, v2, . . . , vk} então k é a dimensão

do código e n é o comprimento do código.

Para não tornar a notação carregada para a estrutura do vetor, ao citar as "palavras"
do código, vamos omitir as vírgulas, representando o vetor v = (v1v2...vn) ao invés de
v = (v1, v2, ..., vn).

Exemplo 4.1. Seja C = {(0000), (0110), (1101), (1011)} um código linear binário de
comprimento 4 e dimensão 2, uma vez que: C = [(0110), (1101)] e {(0110), (1101)} são
linearmente independente.

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

54

De fato: a.(0110) + b.(1101) = (0000). Logo

b = 0



a + b = 0 → a = b = 0

a = 0


Portanto, só admite a solução trivial.

A partir deles, obtendo as outras palavras do código, já que:

(0000) = 0.(0110) + 0.(1101)

(0110) = 1.(0110) + 0.(1101)

(1101) = 0.(0110) + 1.(1101)

(1011) = 1.(0110) + 1.(1101)

4.2 Métrica de Hamming

Deﬁnição 4.2. Sejam u = (x1x2 . . . xn) e v = (y1y2 . . . yn) ∈ Zn
p . A distância de Hamming
entre u e v é o número de coordenadas onde os dois vetores diferem e denotamos por
d(u, v), ou seja,

d(u, v) =| {i ∈ {1, 2, . . . , n} ; xi Ó= yi} |

Exemplo 4.2. Sendo u = (10111) e v = (00101) ∈ Z5

2, têm-se que

d(u, v) = | {i ∈ {1, 2, 3, 4, 5} , xi Ó= yi} | = | {1, 4} | = 2.

Segue direto da deﬁnição 4.2:

Proposição 4.2. Sejam u = (x1x2 . . . xn) e v = (y1y2 . . . yn) ∈ Zn
entre u e v pode-se dizer que:

p . Sobre a distância

1) d(u, v) ≥ 0, ∀u, v ∈ Zn
p ;

2) d(u, v) = 0 se, e somente se, u = v;

3) d(u, v) = d(v, u), ∀u, v ∈ Zn
p .

Observe que dados u = (x1x2 . . . xn) e v = (y1y2 . . . yn) ∈ Zn

p , ˙temos que

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

55

d(u, v) = | {i ∈ {1, 2, . . . , n} ; x1 Ó= yi} | =| ∪n

i=1 {i, xi Ó= yi} |=

d(xi, yi).

n

i=1
Ø

Proposição 4.3. Sejam u = (x1x2 . . . xn) e v = (y1y2 . . . yn) e w = (z1z2 . . . zn) em Zn
p .
Então

d(u, v) + d(v, w) ≥ d(u, w).

Demonstração adaptada se encontra em (HEFEZ ABRAMO. M.L.T, 2008), página

5.

Como d(u, v) satisfaz as propriedades dos itens da Proposição 4.2 e a Proposição

4.3 , dessa forma d(u, v) é uma métrica chamada Métrica de Hamming.

Deﬁnição 4.3. Seja a ∈ Zn
seguinte subconjunto de Zn
p :

p e r ∈ Z com r ≥ 0 deﬁnimos o disco de raio r e centro a o

D(a, r) =

u ∈ Zn
î

p ; d(u, a) ≤ r

.

ï

Também, deﬁnimos a esfera de centro a e raio r como

Proposição 4.4. Para todo c ∈ Zn

p e todo número natural r > 0 temos que

S(a, r) =

u ∈ Zn
î

p ; d(u, a) = r

.

ï

| S(a, r) | =

(p − 1)r.

n
r

1

2

A demonstração desta proposição é abordada em (MACHADO, ), p. 31.

Observação: S(a, r1) ∩ S(a, r2) = ∅ se r1 Ó= r2. De fato, se u ∈ S(a, r1) ∩ S(a, r2)

então d(u, a) = r1 e d(u, a) = r2. Logo, r1 = r2. Além disso,

r

D(a, r) =

S(a, i).

i=0
Û

Proposição 4.5. Para todo a ∈ Zn

p e todo número natural r > 0, então:

| D(a, r) |=

i ) (p − 1)i
(n

r

i=0
Ø

Demonstração. Como | D(a, r) |=| ∪r

i=0S(a, i) | e S(a, r1) ∩ S(a, r2) = ∅ se r1 Ó= r2 então

r

r

| D(a, r) |=|

S(a, i) |=

|S(a, i)| =

i=0
Û

i=1
Ø

i ) (p − 1)i.
(n

r

i=1
Ø

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

56

Deﬁnição 4.4. O peso de Hamming de um vetor v = (x1x2 . . . xn) ∈ Zn
de dígitos não nulos do vetor v, o que denotamos w(v), ou seja:

p é o número

w(v) =| {i ∈ {1, 2, . . . , n} ; xi Ó= 0} |

Exemplo 4.3. u = (10110) ∈ Z5

2 ⇒ w(u) = 3

Exemplo 4.4. u = (01212110) ∈ Z8

3 ⇒ w(u) = 6

Deﬁnição 4.5. Seja C ⊂ Zn

p um código linear, a distância mínima de C é dada por:

d = dmin = min {d(u, v); u, v ∈ C e u Ó= v} .

Observação: A distância mínima do código C equivalente ao peso mínimo do código.

Exemplo 4.5. Para o código linear C = {(0000), (0110), (1101), (1011)} teríamos as
respectivas distâncias entre as palavras

d(0000, 0110) = 2;

d(0000, 1101) = 3;

d(0000, 1011) = 3;

d(0110, 1101) = 3;

d(0110, 1011) = 3;

d(1101, 1011) = 2;

Logo a distância mínima de C é a menor de todas as distâncias entre palavras do

código, ou seja, dmin = 2.

Exemplo 4.6. Considere o cubo binário de vertices representando todas as palavras
de 3 bits, onde os vertices vizinhos representam as palavras de distância 1. Temos a
representação abaixo:

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

57

Figura 4.3 – Hipercubo Binário de 3 bits

Fonte: autor/banco de imagens-wikipedia

Geometricamente, as distâncias entre duas palavras são os menores caminhos entre

os vertices. Assim, d(000,101)=2 e d(010,101)=3.

Para calcular a distância mínima, como visto acima, foi necessário encontrar as
distâncias de todas as palavras, duas a duas, ou simplesmente
. A partir do momento
que o comprimento e o número de palavras do código aumenta, esse esforço não se torna
mais viável mecanicamente. Daí, é interessante o conhecimento algébrico de técnicas para
torná-lo mais eﬁciente, que demandarão menos energia para estimar a distância mínima.

|C|
2

1

2

Proposição 4.6. Seja C ⊂ Zn

p um código linear. Se c, c′ ∈ C, c Ó= c′, então

D(c, t) ∩ D(c′, t) = ∅, onde t =

d−1
2

.

è

é

Demonstração. Suponha por absurdo que existe v ∈ D(c, t) ∩ D(c′, t). Logo, d(v, c) ≤ t e
d(v, c′) ≤ t. Segue da desigualdade triangular, a Proposição 4.3 que:

d(c, c′) ≤ d(c, v) + d(v, c′) ≤ t + t = 2t ≤ 2. d−1

2 = d − 1.

Logo d(c, c′) ≤ d − 1 < d e isso é um absurdo, pois d é a distância mínima, logo

D(c, t) ∩ D(c′, t) = ∅

Teorema 4.1. Dado um código C ⊂ Zn
detecta até d − 1 erros e corrige k =

p com distância mínima d, dizemos que esse código
d−1
2

erros.

Demonstração. Ver em (HEFEZ ABRAMO. M.L.T, 2008), p.6.

è

é

Deﬁnição 4.6. Um codigo linear C ⊂ Zn
detecção k diz-se perfeito se :

p , com distãncia mínima d e capacidade de

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

58

D(c, k) = Zn
p

Ûc ∈ C

Uma outra forma de se trabalhar com os códigos é utilizando a abordagem com

matrizes, que discorremos nas seções a seguir.

4.3 Matriz Geradora do Código

Deﬁnição 4.7. Sejam Zp, com p primo, um corpo ﬁnito de p elementos e C ⊂ Zn
p ,
n ∈ Z, n ≥ 2 um código linear. Considere β = {v1, v2, . . . , vk} uma base ordenada de C.
Denomina-se matriz geradora do código C a matriz G representada como

G =

v1
v2
...
vk





















Observação: A matriz geradora (G) de um código não é única, pois depende da

base de C que estamos considerando.

Efetuando operações elementares de escalonamento sobre as linhas de G, é possível
obter uma outra matriz geradora para o código C, em relação a uma outra base ordenada.

Exemplo 4.7. Sejam v1, v2, v3, v4 ∈ Z7

2 tais que:

v1 = (1101000), v2 = (0110100), v3 = (1110010), v4 = (1010001)

a) Prove que {v1, v2, v3, v4} é linearmente independente (L. I).

b) Descrever as palavras do código C ⊂ Z7

2, gerado pelos vetores v1, v2, v3, v4.

c) Representar a matriz geradora de C.

Resposta:a) Pela deﬁnição os vetores v1, v2, v3, v4 são linearmente independentes se

os coeﬁcientes a1, a2, a3, a4 da combinação linear:

a1v1 + a2v2 + a3v3 + a4v4 = (0000000)

forem a1 = a2 = a3 = a4 = 0.

Realizando a combinação linear para os vetores mencionados acima temos

a1v1 + a2v2 + a3v3 + a4v4 = (0000000)

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

59

a1(1101000) + a2(0110100) + a3(1110010) + a4(1010001) = (0000000)

E desenvolvendo, analisando cada uma das coordenadas desse vetor, encontramos

o sistema:

a1 + a3 + a4 = 0

a1 + a2 + a3 = 0

a2 + a3 + a4 = 0






a1 = 0

a2 = 0

a3 = 0

a4 = 0

Como se pode perceber naturalmente a1 = a2 = a3 = a4 = 0, temos a solução

trivial e portanto {v1, v2, v3, v4} é L . I.

b) As palavras que farão parte do código são resultado da combinação linear de

a1v1 + a2v2 + a3v3 + a4v4

Daí, a1, a2, a3, a4 assumirá 1 ou 0, e as combinações lineares possiveis são:

COMBINAÇÃO LINEAR
0.(1101000) + 0.(0110100) + 0.(1110010) + 0.(1010001)
1
1.(1101000) + 0.(0110100) + 0.(1110010) + 0.(1010001)
2
0.(1101000) + 1.(0110100) + 0.(1110010) + 0.(1010001)
3
0.(1101000) + 0.(0110100) + 1.(1110010) + 0.(1010001)
4
0.(1101000) + 0.(0110100) + 0.(1110010) + 1.(1010001)
5
1.(1101000) + 1.(0110100) + 0.(1110010) + 0.(1010001)
6
1.(1101000) + 0.(0110100) + 1.(1110010) + 0.(1010001)
7
1.(1101000) + 0.(0110100) + 1.(1110010) + 1.(1010001)
8
0.(1101000) + 1.(0110100) + 1.(1110010) + 0.(1010001)
9
10 0.(1101000) + 1.(0110100) + 0.(1110010) + 1.(1010001)
11 1.(1101000) + 1.(0110100) + 1.(1110010) + 0.(1010001)
12 1.(1101000) + 1.(0110100) + 0.(1110010) + 1.(1010001)
13 0.(1101000) + 1.(0110100) + 1.(1110010) + 1.(1010001)
14 1.(1101000) + 0.(0110100) + 1.(1110010) + 1.(1010001)
15 0.(1101000) + 0.(0110100) + 1.(1110010) + 1.(1010001)
16 1.(1101000) + 1.(0110100) + 1.(1110010) + 1.(1010001)

PALAVRA
(0000000)
(1101000)
(0110100)
(1110010)
(1010001)
(1011100)
(0011010)
(0111001)
(1000110)
(1100101)
(0101110)
(0001101)
(0010111)
(1001011)
(0100011)
(1111111)

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

60

c) A matriz geradora do Código é:

G =

=

v1
v2
...
vk





















1101000
0110100
1110010
1010001





















Deﬁnição 4.8. Diremos que uma matriz geradora de código C ⊂ Zn
na forma padrão se G =
e A é a matriz de ordem k × (n − k).

p , de dimensão k está
, onde Ik×k é a matriz identidade de ordem k

Ik×k | Ak×(n−k)

é

è

Exemplo 4.8. Considere o código C ⊂ Z7

2 de matriz geradora G =

do exemplo 4.7.

1101000
0110100
1110010
1010001





















Temos que a dimensão de C é igual ao número de linhas de G, ou seja, 4. Vamos
encontrar uma matriz equivalente a G com operações elementares de escalonamento de
forma que a matriz esteja na forma padrão. Assim,

−−−−−−→
L3=L3−L1
L4=L4−L1

1101000
0110100
1110010
1010001































1101000
0110100
0011010
0111001

−−−−−−−−−→
L4 = L4 − L2











1101000
0110100
0011010
0001101











−−−−−−−−−→
L3 = L3 − L4





















1101000
0110100
0010111
0001101











−−−−−−−−−→
L2 = L2 − L3

−−−−−−−−−→
L1 = L2 − L1











1001011
0100011
0010111
0001101











−−−−−−−−−→
L1 = L1 − L4





















1000110
0100011
0010111
0001101













1101000
0100011
0010111
0001101








1000110
0100011
0010111
0001101













Logo G′ =







padrão.(Ver seção 3.7)


é uma matriz geradora do código C e está na forma

4.4 Código Dual e Matriz Teste de Paridade.

Deﬁnição 4.9. Dado C ⊂ Zn

p um código linear, deﬁnimos o conjunto

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

61

C ⊥ =

v ∈ Zn
î

p ; < v, c >= 0, ∀c ∈ C

ï

Observe que C ⊥ é um subespaço de Zn

p . De fato: C ⊥ Ó= ∅, pois < (0000000), c >= 0,

para todo c ∈ C. Sejam u, v ∈ C ⊥, ou seja,

< u, c >= 0, ∀c ∈ C.

< v, c >= 0, ∀c ∈ C.

Logo, < u + v, c >=< u, c > + < v, c >= 0 + 0 = 0 para todo c ∈ C ⊥, assim
u + v ∈ C ⊥. Também temos < α.u, c >= α. < u, c >= α.0 = 0, ∀c ∈ C. Logo, α.u ∈ C ⊥.
Com essas observações concluímos que C ⊥ é subespaço de Zn
p . Denominamos o conjunto
C ⊥ de código dual de C.

Teorema 4.2. Seja C ⊂ Zn

p um código linear de dimensão k e matriz geradora G, então:

x ∈ C ⊥ se, e somente se, G.xt =

0


0
, onde x ∈ Zn
...








0







p e xt denota a transposta da

a matriz geradora de C. Escrevemos vi = (vi1vi2 . . . vin) , i =

matriz x = (x1x2 . . . , xn) .

Demonstração. Seja G =

1, 2, . . . , k. Então:

v1
v2
...
vk





















G =

v11 v12
v21 v22
...
...
vk1 vk2











· · · v1n
· · · v2n
...
. . .
· · · vkn











k×n

Suponha que x = (x1x2 . . . xn) ∈ C ⊥. Então:

< x, vi >= x1vi1 + x2vi2 . . . xnvin = 0, i = 1, 2, . . . , k.

Observe que:

G.xt =

v11 v12
v21 v22
...
...
vk1 vk2











· · · v1n
· · · v2n
...
. . .
· · · vkn

x1
x2
...
xn











.





















=

x1v11 + x1v12 + · · · + xnv1n
x1v21 + x2v22 + · · · + xnv2n
... +
x1vk1 + x2vk2 + · · · + xnvkn

. . . +

... +

...











=











éx, v1ê
éx, v2ê
...
éx, vnê











.











Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

62

Portanto, G.xt =

.

0

0
...




0














Para veriﬁcar a recíproca, suponha que G.xt =

. Assim,

0

0
...




0














= G.xt =

0


0
...








0







v11 v12
v21 v22
...
...
vk1 vk2











· · · v1n
· · · v2n
...
. . .
· · · vkn











x1
x2
...
xn

x1v11 + x1v12 + · · · + xnv1n
x1v21 + x2v22 + · · · + xnv2n
...
x1vk1 + x2vk2 + · · · + xnvkn

=





















=











k×n



.








éx, v1ê
éx, v2ê
...
éx, vnê











.











Queremos provar que x ∈ C ⊥, ou seja éx, cê = 0, ∀c ∈ C. Sabemos que

éx, viê = 0, i = 1, 2, . . . , k.

Seja c ∈ C. Como C = [v1, v2, . . . , vk] , então c = a1v1+a2v2+· · ·+akvk, a1, a2, . . . , ak ∈

Zp. Assim,

éx, cê = éx, a1v1 + a2v2 + · · · + akvkê =

éx, a1v1ê + éx, a2v2ê + · · · + éx, akvkê

a1éx, v1ê + a2éx, v2ê + · · · + akéx, vkê = 0 + 0 + · · · + 0 = 0

Logo, x ∈ C ⊥.

Teorema 4.3. Seja C ⊂ Zn
forma padrão G = (Ik|Ak,n−k), então:

p um código linear de dimensão k e matriz geradora G, na

a) dimC ⊥ = n − k.

b) Se a matriz geradora de C estiver na forma padrão G = (Ik | A) , então H =

(−At | In−k) é a matriz geradora de C ⊥.

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

63

A demonstração deste Teorema encontra-se em (HEFEZ ABRAMO. M.L.T, 2008)

p. 94 e 95.

Teorema 4.4. Seja C ⊂ Zn
p um código de dimensão k com matriz geradora G. Uma
matriz H de ordem (n − k) × n com coeﬁcientes em Zp e linhas linearmente independente

é uma matriz geradora de C ⊥ se, e somente se, G.H t = 





0 · · · 0
...
...
. . .
0 · · · 0








.

k×n−k

Demonstração. As linhas de H geram um subespaço vetorial de dimensão igual a n − k.

Sejam h1, h2, . . . , hn−k linhas de H, logo dim[h1, h2, . . . , hn−k] = n − k, e assim,

serão deﬁnidas:

h1 = (h11, h12, . . . , h1n)

h2 = (h21, h22, . . . , h2n)
...

hn−k =

h(n−k)1, h(n−k)2, . . . , h(n−k)n

1

2

Sejam g1, g2, . . . , gk linhas de G, logo dim[g1, g2, . . . , gk] = k, e assim, serão deﬁnidas:

g1 = (g11, g12, . . . , g1n)

g2 = (g21, g22, . . . , g2n)
...

gk = (gk1, gk2, . . . , gkn)

Multiplicando G e H t, encontramos:

g11 g12
...
g21
gk1 gk2

G.H t = 





· · · g1n
...
. . .
· · · gkn

ég1, h1ê
...
égk, h1ê

= 












k×n

. 




ég1, h2ê
...
égk, h2ê

h11 h21
...
h12
h1n h2n

· · · h(n−k)1
. . .
· · · h(n−k)n

...








n×n−k

· · ·
. . .
· · ·

ég1, hn−kê
...
égk, hn−kê








k×n−k

(4.1)

Temos nas posições da matriz os produtos internos

égi, hjê; ∀ i = 1, 2, . . . , jk, j = 1, 2, . . . , jn−k. Como C = [g1, g2, . . . , gk], segue que

para cada c ∈ C temos c = a1.g1 + a2.g2 + . . . , ak.gk.

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

64

Logo

Pois

égi, hjê = 0 ⇔< c, hi >= 0; i = 1, 2, . . . , k, j = 1, 2, . . . , n − k.

(4.2)

éc, hiê = éa1.g1 + a2.g2 + . . . + ak.gk, hiê =

= a1.ég1, hiê + a2.ég2, hiê + · · · + ak.égk, hiê = 0.

Segue das Equações 4.1 e 4.2 que

égi, hjê = 0; i = 1, . . . , k, j = 1, . . . , n − k ⇔ hi ∈ C ⊥; i = 1, . . . , n − k.

Ou seja, hi ∈ C ⊥. Como dimC ⊥ = n − k e dim [h1, . . . , hn−k] = n − k, então

C ⊥ = [h1, . . . , hn−k]

Portanto G.H t = 





0 · · · 0
...
...
. . .
0 · · · 0








⇔ C ⊥ é gerado pela linhas de H.

Proposição 4.7. Seja C ⊂ Zn

p um código linear, então

⊥

C ⊥

= C.

1

2

Demonstração. Sejam H e G matrizes geradoras de C ⊥ e C respectivamente

Suponha dimC = k, segue do Teorema 4.4

Hn−k,n = H é matriz geradora de C ⊥ se, e somente se, G.H t = 





t

0 · · · 0
...
...
. . .
0 · · · 0








.

k×n−k

0 · · · 0
...
...
. . .
0 · · · 0








G.H t = 





k×n−k

⇔ (G.H t)t = 











0 · · · 0
...
...
. . .
0 · · · 0








k×n−k

(H t)t .Gt = 





⇔ H.Gt = 





0 · · · 0
...
...
. . .
0 · · · 0

0 · · · 0
...
...
. . .
0 · · · 0















n−k×k

n−k×k

⇔









(4.3)

Segue da Proposição 4.7 que G é matriz geradora de

⊥

C ⊥

= C.

1

2

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

65

Proposição 4.8. Seja C ⊂ Zn
Então:

p um código linear e seja H a matriz geradora de C ⊥.

v ∈ C ⇔ H.vt =

.

0


0
...








0







Demonstração. Temos do Teorema 4.2 que: x ∈ C ⊥ ⇔ G.xt =

, daí

0


0
...








0







v ∈

C ⊥

⊥

⇔ H.vt =

1

2

. Como

C ⊥

⊥

= C, então v ∈ C =

1

2

C ⊥

⊥

⇔

1

2

0


0
...








0







.

H.vt =

0


0
...








0






Deﬁnição 4.10. Seja C ⊂ Zn
matriz de teste de paridade.

p um código linear, a matriz geradora de C ⊥ é chamada

A Proposição 4.8 permite caracterizar os elementos de um código C por uma
condição de anulamento. Essa condição é obtida por meio da matriz teste de paridade, ou
seja,

v ∈ C ⇔ H.vt =

.

0


0
...








0







A matriz teste de paridade de um código linear C ⊂ Zn

p contém informações sobre
o peso do código C, w(C) = d. Esses resultados são característicos por meio dos Teoremas
a seguir.

Teorema 4.5. Se H é a matriz teste de paridade de um código C ⊂ Zn
p , o peso de
C, w(C) > s se, e somente se, quaisquer s − 1 colunas de H são linearmente independentes.

A demonstração é abordada em (HEFEZ ABRAMO. M.L.T, 2008), p. 98.

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

66

Teorema 4.6. Seja H a matriz de paridade de um código C ⊂ Zn
p . O peso de C, w(C) = s
se, e somente se, quaisquer s − 1 colunas de H são linearmente independentes e existem s
colunas de H linearmente dependentes.

Demonstração. Suponha que w(C) = s. Segue do Teorema 4.5 w(C) = s > s ⇔ ∀s − 1
colunas de H são linearmente independentes. Resta provar que existem s colunas de H
que são linearmente dependentes. De fato, se quaisquer k colunas de H são linearmente
independentes com k > s, então segue do Teorema 4.5 que k = k + 1 − 1 colunas de H
são linearmente independentes se, e somente se, w(C) > k + 1. Entretanto,

w(C) > k + 1 > s + 1 > s e isto é uma contradição, pois w(C) = s. Portanto segue

o resultado.

Reciprocamente, suponha que quaisquer s − 1 colunas de H são linearmente
independentes e existem s colunas de H que são linearmente dependentes. Queremos
provar que w(C) = s. Segue do Teorema 4.5 que w(C) = s, pois por hipótese quaisquer
s − 1 colunas de H são L . I.

w(C) > s ⇔ w(C) = s ou w(C) > s

Se w(C) > s então w(C) > s + 1.

Segue do Teorema 4.5 que w(C) > s + 1, se e somente se, quaisquer (s + 1) − 1 = s
colunas de H são L . I. o que é um absurdo, pois existem s colunas de H que são L . D,
por hipótese. Portanto w(C) = s.

Corolário 4.1. Considere os parâmetros (n, k, d) de um código C ⊂ Zn
e d = w(C) é o peso do código C. Então d 6 n − k − 1.

p , onde k = dimC

Demonstração. Seja H = [h1, h2, . . . , hn] a matriz teste de paridade de C, onde [h1, h2, . . . , hn]
são as colunas de H.

Dessa forma, posto de H é igual a n − k. Segue de (HEFEZ, 2016) em sua página
42, que posto coluna de H é igual ao posto linha de H, que no caso é n − k, ou seja, o
espaço gerado pelas colunas de H tem dimensão igual a n − k.

Segue do Teorema 4.6 que w(C) = d se, e somente se, quaisquer d − 1 colunas de
H é lineamente independentes e existem d colunas de H que são linearmente dependentes.

Dessa forma, quaisquer d−1 colunas de {h1, h2, . . . , hn} gera um espaço de dimensão
d − 1 que está contido no espaço gerado por h1, h2, . . . , hn. Logo d − 1 6 n − k, ou seja,
d 6 n − k − k + 1

Para concluir o processo de codiﬁcação que foi desenvolvido nas seções 4.1, 4.2
p , que

e 4.3 temos que uma mensagem u é codiﬁcada com uma palavra código x ∈ Zn

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

67

em geral é um vetor de Zn
p , cujas as k primeiras coordenadas correspondem a própria
mensagem, seguida de n − k componentes, chamados símbolos de veriﬁcação e paridade,
ou seja, x = (x1x2 . . . xn) com x1 = u1; x2 = u2; . . . xk = uk onde (u1u2 . . . uk) ∈ C. Os
dígitos xk+1, . . . , xn são escolhidos de forma a satisfazer



x1
...
xn

0
...

= 


0






Exemplo 4.9. Considere o código C ⊂ Z6

H. 










, onde H é a matriz de paridade do código C. Por exemplo,

2, com dimC = 3 e matriz de paridade abaixo:

0 1 1 | 1 0 0
1 0 1 | 0 1 0
0 1 0 | 0 0 1








H=





Temos que H = [−At | In−k], logo

0 1 1
1 0 1
1 1 0



−At = 





e I6−3 = I3 = 





1 0 0
0 1 0
0 0 1







Uma mensagem u = (u1u2u3) é codiﬁcada na palavra x = (x1x2x3x4x5x6) cujos






dígitos tem a seguintes características.

x1 = u1; x2 = u2; x3 = u3;

E os dígitos x4x5x6 são tomada de maneira a satisfazer:

0 1 1 | 1 0 0
1 0 1 | 0 1 0
0 1 0 | 0 0 1

x1
x2
x3
x4
x5
x6

















⇔

0
...

= 


0

























.






H.

x1
x2
x3
x4
x5
x6





0
...
= 



0




















x2 + x3 + x4 = 0















⇔ 







.

x1 + x3 + x5 = 0

x2 + x6 = 0

Dessa forma concluímos

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

68

Mensagem: (u1u2u3) Palavra código: (x1x2x3x4x5x6)

(000)
(001)
(010)
(011)
(100)
(101)
(110)
(111)

(000000)
(001110)
(010101)
(011011)
(100010)
(101100)
(110111)
(111001)

4.5 O Processo de Decodiﬁcação dos Códigos Lineares

O processo de decodiﬁcação no qual o decodiﬁcador tenta encontrar a palavra código
mais próxima da mensagem recebida é denominada decodiﬁcação. Uma possibilidade é
calcular a distância de y ∈ Zn
p (mensagem recebida) a cada palavra de código em C ⊂ Zn
p
e corrigir pela palavra código mais próxima. Entretanto, essa ideia é inviável para corrigir
mensagens com dimC = k para k muito grande, pois requer pk cálculos de distâncias e
em seguida considerar a menor delas.

Dessa forma, iremos introduzir os conceitos de síndrome de um vetor v ∈ Zn

p e
p para descrever um método mais eﬁcaz para

de classes laterais de um código C ⊂ Zn
decodiﬁcar palavras recebidas.

Deﬁnição 4.11. Dados um código C ⊂ Zn
vetor S(v) = H.vt é chamado de síndrome de v.

p com matriz teste de paridade H e v ∈ Zn

p . O

A matriz de veriﬁcação de paridade H de um código C ⊂ Zn

p vai assumir um papel
principal de detecção e correção de erros. Se a sindrome é 0, o vetor está no código e a
mensagem recebida, após decodiﬁcada, é a mesma que a transmitida. Caso contrário,temos
um vetor erro ε ∈ Zn
p , deﬁnido como ε = r − c, onde r é a mensagem recebida e c ∈ C é a
mensagem transmitida. Segue da Proposição 4.8 que H.ct = 0 ⇔ c ∈ C. Assim, para todo
c ∈ C temos:

H.εt = H. (r − c)t = H.

rt − ct

= H.rt − H.ct = H.rt − 0 = H.rt

(4.4)

1

2

Agora apresentaremos o conceito de classes laterais relacionando esse conceito com

o vetor síndrome para dar seguimento ao estudo da decodiﬁcação de códigos lineares.

Deﬁnição 4.12. Sejam C ⊂ Zn

p um código linear e a ∈ Zn

p . O conjunto

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

69

a + C = {a + x; x ∈ C}

é chamado classe lateral de C.

Proposição 4.9. Seja C ⊂ Zn

p um código linear com matriz de paridade H e u, v ∈ Zn
p .

S(u) = S(v) ⇔ u ∈ v + C.

0
...
Demonstração. S(u) = S(v) ⇔ H.ut = H.rt ⇔ H. (ut − vt) = 



0







⇔

0
...
H. (u − v)t = 



0







⇔ u − v ∈ C ⇔ u ∈ v + C.

Proposição 4.10. Seja C ⊂ Zn

p um código linear com dimC = k, então:

I. v + C = v′ + C ⇔ v − v′ ∈ C;

II. (v + C) ∩ (v′ + C) Ó= ∅ ⇔ v + C = v′ + C

Demonstração. Abordada em (MACHADO, ), p.39 e (HEFEZ ABRAMO. M.L.T, 2008),
p. 107.

Proposição 4.11. Seja C ⊂ Zn

p um código linear com dimC = k. então:

I. | v + C |= pk

II. Zn

p = C ∪ (a1 + C) ∪ (a2 + C) + . . . + ∪ (at + C)

Demonstração. Abordada em (MACHADO, ), p.39 e (HEFEZ ABRAMO. M.L.T, 2008),
p. 107.

Exemplo 4.10. Seja C ⊂ Z6

2 um código linear dado por:

C = {(000000), (001110), (010101), (011011)(100011), (101101), (110110), (111000)}

Seguem algumas classes laterais de C :

(000000) + C = (000000), (001110), (010101), (011011)(100011), (101101), (110110), (111000)

(001110) + C = (000000), (001110), (010101), (011011)(100011), (101101), (110110), (111000)

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

70

Percebe-se que se uma palavra não faz parte de C ⊂ Z6
2, suas respectivas classes laterais
tambem não resultarão em palavras do código. Tomemos como exemplo as palavras
c1 = (000001) e c2 = (100000) temos abaixo suas respectivas classes laterais:

(000001) + C = (000001), (001111), (010100), (011010)(100010), (101100), (110111), (111001)

(100000) + C = (100000), (101110), (110101), (111011)(000011), (001101), (010110), (011000)

Teorema 4.7. Seja C um código linear em Zn
e c ∈ C, tais que d(c, r) 6 β então existe um único vetor ε ∈ Zn
síndrome é igual a síndrome de r tal que c = r − ε.

p com capacidade de correção β. Se r ∈ Zn
p
p com w(ε) 6 β, cuja

Demonstração. Seja H a matriz teste de paridade de C tal que H = [h1, h2, . . . , hn] . Tome
ε = r − c. Temos que: w(ε) = d(ε, 0) = d(r − c, 0) = d(r, c). Logo w(ε) = d(c, r) 6 β.

Além disso,

H.εt = H(r − c)t = H.(rt − ct) = H.rt − H.ct = H.rt pois c ∈ C, ou seja, ε e r tem

a mesma síndrome.

Agora vamos provar a unicidade de ε tal que w(ε) 6 β e H.εt = H.rt. Para isso
n) tais que w(ε) 6 β, w(ε′) 6 β, H.εt = H.rt e

sejam ε = (α1α2 . . . αn) e ε′ = (α′
H.ε′t = H.rt. Temos que H.εt = H.ε′t, então

2 . . . α′

1α′

αi.hi =

n

i=1
Ø

i.hi
α′

n

i=1
Ø

(4.5)

Daí:

(α1 − α′

1) .h1 + (α2 − α′

2) .h2 + · · · + (αn − α′

0
...
n) .hn = 



0







.

(4.6)

Com a capacidade de correção do código é β =

do código. Temos que

, onde d = distância mínima

d−1
2

è

é

β =

d−1
2

6 d − 1.

è

é

Ou seja, 2β 6 d − 1. Além disso w(ε) 6 β signiﬁca que há no máximo β entradas
não nulas do vetor ε. De forma análoga, temos no máximo β entradas não nulas do vetor
ε′.

Suponha ε − ε′
1, . . . , αm − α′

Ó= 0 como w (ε − ε′) 6 w (ε) + w (ε′) 6 2β então ε − ε′ =
Ó= 0. Logo

m) tem no máximo 2β componentes tal que αi − α′
i

(α1 − α′

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

71

segue da equação 4.6 que há uma relação linear entre 2β 6 d − 1 colunas de H. Como
quaisquer d − 1 colunas de H são linearmente independentes (veja Teorema 4.5) temos
que αi = α′

i; i = 1, 2, . . . , n. Portanto, ε = ε′.

Deﬁnição 4.13. Sejam C ⊂ Zn
p um código linear com dimC = k e a1 + C, . . . , at + C, t =
qn−k as classes laterais de C. Um vetor v ∈ ai + C, para algum 1 6 i 6 t, é chamado
elemento líder da classe ai + C se o peso de v, w(v) é mínimo nessa classe.

Proposição 4.12. Seja C ⊂ Zn
d−1
tal que w(u) 6
2

, então u é o único elemento líder de sua classe.

p um código linear com distância mínima d. Se u ∈ Zn

p

è

é

Demonstração. Suponhamos que u, v ∈ Zn
u − v ∈ C. Temos que

p , com w(u) 6

d−1
2

è

é

e u ∈ v + C, ou seja,

w(u − v) 6 w(u) + w(v) 6

d−1
2

+

d−1
2

6 d−1

2 + d−1

2 = d − 1.

è

é

è

é

0
...
Como u − v ∈ C e w(u − v) 6 d − 1 < d, então u − v = 



0







, ou seja, u = v.

Para encontrar elementos lideres de classes laterais, basta tomarmos elementos de
. Segue da Proposição 4.12 que cada um desses elementos é líder

u tais que w(u) 6
de uma e somente uma classe.

d−1
2

è

é

Suponha que o código C possa corrigir até β erros, assim β =

, com d a
é
p tal que o peso de
, então u é o único vetor líder de sua classe. Então vamos nos concentrar

distância mínima do código C. Segue da Proposição 4.11 que se u ∈ Zn
d−1
u, w(u) 6
2
em listar os valores u ∈ Zn
é
vetor u, líder da classe.

. Em seguida calcule a síndrome cada

p tal que w(u) 6

d−1
2

é

è

è

è

d−1
2

Exemplo 4.11. Seja o Código C de dimensão 3 em Z6

2 cuja matriz geradora é

1 0 0 0 1 1
0 1 0 1 0 1
0 0 1 1 1 0








G = 





Vamos decodiﬁcar a palavra recebida r = (110100) usando os líderes de classes

laterais.

Note que a matriz geradora G já está na forma padrão. O código C gerado pela

matriz G tem as seguintes palavras:

C = {(000000), (001110), (010101), (011011)(100011), (101101), (110110), (111000)}

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

72

Se deﬁnirmos as classes laterais desse código, seus líderes serão as palavras com o
dígito 1 aparecendo alternadamente na posição ai, com peso igual a 1. Assim os líderes de
classe lateral serão: (100000), (010000), (001000), (000100), (000010), (000001).

A sua matriz teste de paridade H na forma padrão, necessária para a decodiﬁcação

da palavra recebida pode ser escrita como:

H = [−At | I6−3] = [−At | I3] , onde A = 





Logo,

0 1 1
1 0 1
1 1 0








e assim −A = 





0 1 1
1 0 1
1 1 0



.






0 1 1 | 1 0 0
1 0 1 | 0 1 0
1 1 0 | 0 0 1








H = 





=

h1 h2 h3 h4 h5 h6

è

é

Observe que h3 = h1+h2, ou seja, existem h1, h2 e h3 colunas lineamente dependente.

Então segue do Teorema 4.6 que d = w(C) = 3.

Assim o código C pelo Teorema 4.1 pode corrigir até β =

vamos listar u ∈ Z6

2, tais que w(u) 6 1.

3−1
2

=

2
2

è

é

è

é

= 1. Agora,

Mensagem: Líder da classe Lateral Síndrome

000000
100000
010000
001000
000100
000010
000001

000
011
101
110
100
010
001

Seja r = 110100, a síndrome da palavra, S(r), determina-se:

0 1 1 | 1 0 0
1 0 1 | 0 1 0
1 1 0 | 0 0 1

S(r) = H.rt= 





.

1


1


0






1






0






0







.

0

= 
1


0














De acordo com a tabela acima ε = (000010)

Capítulo 4. Códigos Lineares: Conceitos e a Métrica de Hamming

73

Logo, ε = r − c, onde c é a palavra enviada, ou seja, (000010) = (110100) − c. Isto

é c = (000010) + (110100) = (110110).

Agora é possível generalizar o procedimento para corrigir erros de uma palavra
p que pode corrigir até

recebida. Para isso os dados de entrada são: um código C ⊂ Zn
d−1
2

erros, onde d é a distância mínima e r ∈ Zn

p é a palavra recebida.

è

é

Procedimento:

Passo 1 - Calcule u ∈ Zn

p tal que w(u) 6

d−1
2

.

è

é

Passo 2 - Calcule a síndrome do vetor u obtido no passo 1.

Passo 3 - Faça a tabela, cuja a primeira coluna é o vetor u do passo 1 e a segunda coluna é a

síndrome S(u) do passo 2;

Passo 4 - Calcule H.rt = S(r). Se a síndrome de r estiver na tabela do passo 3, cujo u é o
elemento líder então faça c = r − u, senão S(r) não está na tabela e mensagem tem
mais do que

erros e, portanto, não pode ser corrigida.

d−1
2

è

é

Fim do Procedimento:

O procedimento de decodiﬁcação é eﬁcaz pelo fato de que se baseia num produto
de matrizes, e no caso de um código linear, o procedimento é ainda mais simples, seguindo
passos semelhantes:

Procedimento:

Passo 1 - Recebida a palavra r ∈ Zn

p , realize o produto das matrizes u = H.rt;

Passo 2 - Se no passo 1, o vetor u é igual ao vetor nulo, as palavras transmitida e recebida são
as mesmas, o que indica que não houve interferências. Caso contrário, assumimos
que o código apresentou o erro em um dígito e o vetor coincide com o índice de uma
das colunas da matriz teste de paridade, H, onde tal coluna é a posição em que
ocorreu o erro;

Passo 3 - Como explicado no passo 2, para obter a palavra transmitida basta modiﬁcar a

palavra recebida r, trocando o dígito incorreto na posição indicada.

Fim do Procedimento:

Como se pode ver, o processo de codiﬁcação/decodiﬁcação em Zn

p de um código
linear é facilitado pelas ideias de paridade, mas principalmente, pela descoberta da matriz
de paridade de um código. Para tal, é necessario entender as ideias de álgebra relacionadas
a teoria da informação, num algoritmo que, embora intuitivo, tem em suas estruturas
muito das álgebras abstrata e linear.

5 O Código Linear de Hamming e a aborda-

gem de códigos no ensino básico.

74

Admitir que a evolução das tecnologias é algo de suma importância na velocidade
das descobertas nos mais diferentes segmentos é, sem dúvida alguma, permitiu um grande
salto no século XX. Dividir com as máquinas a tarefa de realizar cálculos complexos, “
aprender ” com base no erro e sugerir correções foram motivos que encerraram guerras,
permitiram o homem conquistar “ outros espaços ”, e simular e prever eventos.

Levando em conta só o fato da transmissão de dados, temos dinamismo e agilidade.
Com os devidos protocolos e compactação de pacotes, temos segurança e redundância. Se
pensarmos que o rádio era a única fonte de transmissão de dados há menos de um século,
observamos um grande salto de transmissão de dados para os dias atuais.

Entretanto, encaremos os fatos. Nos anos quarenta, o que chamávamos de com-
putador era na verdade grande salas ocupadas por máquinas que faziam estes mesmos
cálculos realizando rotinas sequenciais e lineares. Rotinas de programação que precisavam
ser exatas e meticulosas, sob o risco de perderem informações ou simplesmente a não
execução delas. A “ inteligência ” do computador se media na sequência de algoritmos e a
velocidade com a qual ele os executa. Nem precisamos dizer o quão caro é dispor dessa
tecnologia e o quão restrita ela era.

Voltamos ao ano de 1947, especiﬁcamente aos laboratórios Bell e o problema do
matemático Richard Wesley Hamming. Ao perceber que parte dos algoritmos colocados
em cartões perfurados não era executado pelos computadores, ele se pergunta com a
capacidade de processamento que esses computadores possuem, não fosse possível detectar
e corrigir erros através de um algoritmo.

Nos anos seguintes, suas descobertas e as de C . E . Shannon, em 1948 e suas
publicações em 1950 no “ The Bell Journal ” permitiram o desenvolvimento do campo da
teoria da informação e códigos corretores.

A teoria da informação e dos códigos está ﬁrmada na álgebra linear e abstrata,
tão importante que entende a informação como bloco de conteúdo fundamentada num
alfabeto, da qual temos palavras formadas de acordo com o que se quer transmitir. Como
estão fundamentadas num código, é possível a construção de matrizes chaves e adicionar
bits que garantam a integridade dos dados, como os bits de paridade, e podendo com as
técnicas sugeridas por Hamming codiﬁcar e decodiﬁcar a mensagem mesmo que o meio de
transmissão seja ruidoso.

Vale lembrar aqui que as descobertas de Hamming e Golay permitiram que outros

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

75

códigos computacionais desevolvessem, tais como a leitura dos dados de hd, mesmo com
uns poucos cluster com erros, a criação de algoritmos para validar a autenticidade de um
documento, entre outros.

Neste capítulo, rapidamente falamos sobre o código de Hamming e a exempliﬁcação
do algoritmo, baseado nos conceitos citados em (HEFEZ ABRAMO. M.L.T, 2008) e
exempliﬁcado em trabalhos como o de (MEC, 1998),(DUTRA, 2018),(MALAGUTTI et
al., 2010),(OBMEP, ) e (GONZAGA, ). Em seguida, abordamos um pouco sobre uma
alternativa para se ensinar códigos corretores de erros, trazendo um pouco sobre o que
se fala sobre o assunto no documento referencial do ensino. Como falamos de códigos
computacionais, apresentar ao ﬁnal um exemplo de aula onde tais conceitos podem ser
aplicados.

5.1 O Código de Hamming Binário

Buscando atender o problema inicial da busca na correção do erros, Richard

Hamming tentou implementar uma estratégia para a identiﬁcação e a correção do erro.

Considerando que o código binário aceita apenas “ zeros ” e “ uns ”, e tratando
essa sequências como palavras de um código, no qual os bits se repetem um número
determinado de vezes, podemos deﬁnir o código e entender a estratégia de codiﬁcação e
decodiﬁcação.

Introduzido por Hamming, em 1950, o mais famoso desses códigos, o Hamming
(7, 4, 3) é o exemplo pelo qual a teoria da informação teve seu grande salto, e a partir
destes outros códigos puderam ser melhor compreendidos. Basicamente, ele considerava
os 4 bits de dados de uma palavra original, e acrescentava a ele três bits de veriﬁcação
(ou paridade). O algoritmo é funcional ao ponto de que o erro de um bit pode ser tanto
localizado como corrigido, mesmo com o meio de transmissão apresentando ruído.

Considerando que as palavras de um código são bits de dados que aguardam ser
transmitidos, que elas são fundamentadas num alfabeto (ou corpo ﬁnito ) da forma Zn
2 ,
podemos construir duas matrizes G e H, respectivamente as matrizes geradora e teste de
paridade, e assim codiﬁcar ou decodiﬁcar cada palavra transmitida.

Deﬁnição 5.1. Um (n, M, d) código é um código que tem M palavras de dimensão n e
distância mínima d.

Deﬁnição 5.2. Um código de Hamming de parâmetros (n, k, d) de ordem m sobre Zn
2
é um código com matriz teste de paridade Hm de ordem m × n, cujas colunas são os
elementos de Zm

2 − {(0, 0, · · · , 0)} numa ordem qualquer .

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

76

Ou seja, um código de Hamming de ordem m possui comprimento n = 2m − 1 e

dimensão k = 2m − m − 1.

Exemplo 5.1. A matriz H

1 0 1 1 1 0 0
1 1 0 1 0 1 0
0 1 1 1 0 0 1








H = 





É uma matriz de um código de Hamming(3, 2) e parâmetros (7, 4, 3). De fato:

m = 3; n = 23 − 1 = 7; k = 23 − 3 − 1 = 4; n − k = 7 − 4 = 3

Teorema 5.1. Seja m > 2. Então

i) Ham(m, 2) tem parâmetros [2m − 1, 2m − m − 1, 3] ;

ii) Ham(m, 2) é um código perfeito.

Demonstração.

i) Da Deﬁnição 5.2, Ham(m, 2) tem comprimento | Zm
2 − {(0 · · · 0)} |=
2m − 1 e dimensão k = 2m − m − 1. Provaremos que a distância mínima é d =
3. Observando a matriz de paridade de um código, considere as colunas ci, com
i = 1, . . . , 2m − 1,. Sabemos que nenhuma dessas colunas é nula, e que comparadas
entre-si, duas a duas, elas não são iguais. Assim, podemos admitir que duas delas
no mínimo são L.I. Pelo Teorema 4.6 uma terceira coluna sendo resultado soma de
outras duas, na matriz H , podemos dizer que para cada duas colunas L.I., temos 3
colunas L.D. . Logo d(Ham(m, 2)) = 3.

ii) Como d = 3, então β =

d−1
2

è

é

= 1 é a capacidade de correção de C. Logo

|D(c, 1)| =

n
1

= 1 + n , e assim

D(c, β)| = (1 + n).2k = [1 + 2m − 1].2n−m = 2n = |Zn
2 |

1

2

|

Ûc∈C

OBSERVAÇÕES: Para códigos de Hamming binários existe uma técnica para

decodiﬁcação que é resumida a seguir.

Segue do Teorema 4.1 e da Proposição 4.12 que o código de Hamming (n, k, d)

corrige até

= 1 erro e w(C) 6 1, onde c ∈ Zm

2 e o único líder de sua classe.

3 − 1
2

Considere que as colunas c1, c2, . . . , cn , constituintes da matriz de paridade. Siga

os seguintes passos:

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

77

1. Recebido y ∈ Zn

2 , calcular o sindrome S(y) = H.yt.

2. Se S(y) = 0, assumir que não ocorreram erros de transmissão e a palavra transmitida

é y.

3. Se S(y) Ó= 0, então S(y) é uma coluna de H e, se estas estão por ordem crescente,
assumir que ocorreu um erro na coordenada i correspondente ao número S(y) na
base 2, e alterar o bit naquela posição.

Exemplo 5.2. Considere a matriz de paridade do código hamming (7, 4, 3)

0 0 0 1 1 1 1
0 1 1 0 0 1 1
1 0 1 0 1 0 1



.






H = 





Se a palavra recebida y = 1101011, ao determinarmos S(y) encontramos o valor
S(y) = 110. Pelo fato de S(y) Ó= 0, podemos imediatamente identiﬁcar que o erro está no
sexto dígito, pois S(y) é igual a sexta coluna na matriz de paridade. Assim, decodiﬁcamos
como a palavra 1101001.

5.2 Sugestões da abordagem de Códigos de Erros no Ensino Básico

A teoria dos códigos tem aplicabilidade não apenas na informática como no desen-

volvimento de sistemas práticos de segurança implementados nos diversos setores.

Sem dúvida, se focarmos nossa atenção apenas no procedimento de codiﬁcação/-
decodiﬁcação de uma mensagem, temos envolvidas as operações aritméticas e o uso das
matrizes. Se a vertente a ser trabalhada fosse a dos mecanismos de criptograﬁa e validação,
poderíamos citar a maior parte das operações envolvendo a aritmética.

Os documentos que tratam da edução brasileira sugerem o trabalho com os códigos
e sua importância na matemática. Segundo os PCN (MEC, 1998) recursos da informática
auxiliam na aprendizagem de matemática e de outras áreas de ensino. Assim neste cenário
cabe à escola o desaﬁo de incorporar ao seu trabalho novas formas de se comunicar e
conhecer. Deve-se oferecer um educação tecnológica voltada a alguns conteúdos dentro de
sua estrutura e linguagem de diferentes aplicações da informática, sendo também ressaltada
no PCN (MEC, 2000).

A recém aprovada Base Nacional Curricular Comum (BNCC) dá ênfase ao uso
no campo dos códigos corretores de erros quando exalta o uso da matemática como
contextualizadora de situações práticas, como citado em (DUTRA, 2018), de um trecho
reproduzido abaixo:

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

78

A BNCC reconhece os benefícios que a cultura digital tem promovido
nas esferas sociais. O avanço tecnológico e a multiplicação de celulares,
smartphones e computadores estão diretamente ligados ao hábito de
consumo dos jovens. Diante dessas interações multimidiáticas e multi-
modais, a proposta da Base é trabalhar com uma intervenção social que
contextualiza o uso da tecnologia ao currículo aplicado, desenvolvendo
essa que é uma das dez competências gerais citadas pelo documento.

Ainda, são elencadas competências que relacionam a matemática e a tecnologia,
como na competência “ Utilizar processo e ferramentas matemáticas, inclusive tecnologias
digitais disponíveis, para modelar e resolver problemas cotidianos, sociais, de outras áreas
do conhecimento, validando estratégias e resultados.”

5.2.1 PLANO DE AULA PARA O ENSINO FUNDAMENTAL

O plano sugerido abaixo é um exemplo de como o ensino fundamental pode trabalhar

alguns desses conceitos na criação de um código.

OBJETIVOS:

• Perceber como funciona o sistema binário de numeração e realizar um paralelo com

o sistema decimal.

• Resolver problemas do sistema binário com o auxílio da calculadora, entendendo o

processo de conversão binário decimal.

• Compreender, praticando,simulando a estratégia do processo de decodiﬁcação de

uma mensagem.

• Utilizar do grupo de operações básicas para descobrir algebricamente um caractere

oculto.

DURAÇÃO DAS ATIVIDADES 5 a 6 aulas (50 minutos)

RECURSOS DIDÁTICOS Computador, projetor, quadro, folha de atividades,

calculadora e papel.

CONTEÚDOS:

• Apresentação do sistema binário de numeração e sua estrutura.

• Sistemas computacionais e paridade.

ORIENTAÇÕES METODOLÓGICAS:

As orientações dispostas aqui são apenas sugestões, uma vez que o professor pode

moldar a aula a seu interesse.

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

79

Para turmas de alunos cujo conhecimento é ainda superﬁcial, é interessante apre-
sentar um breve histórico, exibindo o vídeo “História dos Números“, de (TVESCOLA,
2018). O vídeo apresenta aos alunos a utilização dos números e de alguns sistemas de
numeração.

Nosso sistema de base 10, o sistema decimal, é formado por por dígitos de zero a
nove. Porém existem outros sistemas numéricos, os quais são usados para os mais variados
propósitos:

• A duração de um dia: 0 hora, 1 hora, 2 horas, 3 horas, ..., 23 horas, 1 dia e assim
por diante. Ou seja, a base utilizada é 24, pois a cada 24 horas nós temos um dia.

• A contagem das horas, cuja base é 60, pois a cada hora temos 60 minutos e cada

minuto 60 segundos...

• Sistemas Octa e Hexadecimal: Alternativas mais compactas ao sistema binário,

utilizados por muitas máquinas e transmissões.

É possível ao professor explorar outros sistemas de numeração presentes na história
da matemática, como introdução, embora o objetivo seja mostrar a utilidade do sistema
computacional binário e suas possibilidades.

Em seguida, apresentar a esquematização do sistema binário de base 2, como

explicado na aula de Aritmética da OBMEP, aula 12 – Bases de numeração.

Figura 5.1 – Aula 12(OBMEP)- Sistemas de Numeração

Fonte: youtube: disponivel em https://www.youtube.com/watch?v=4Bu9zJJEIpY

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

80

Como atividade, o professor pode sugerir, por exemplo, representar os números 13

e 129 no sistema binário.

Observe a a ﬁgura abaixo:

Figura 5.2 – Conversão Decimal - Binário

Fonte: do autor.

Como se pode observar, seguindo o sentido de leitura das setas, temos que os

números 13 e 129 ﬁcam assim representados:

13 = (1101)2, ou seja, 13 = 1.23 + 1.22 + 0.1 + 1.

129 = (10000001)2, ou seja, 129 = 1.27 + 0.26 + 0.25 + 0.24 + 0.23 + 0.22 + 0.21 + 1.

O professor deve sugerir outros números para que o aluno faça a conversão de uma
base para outra, primeiramente de decimal para binário, explorando a divisão e os restos,
como também de binário para decimal, revisitando as ideias relativas a importância do
valor posicional dos dígitos.

Para apresentar paridade, vemos basicamente quando um número é par ou não.

Pergunte ao seu aluno e peça que ele responda, argumentando com exemplos
questionamentos como "Aﬁnal por que o número é par? e por que ele é impar? O que será
que acontece quando somamos, subtraimos e multiplicamos números pares ou impares?"

Passadas as explicações, é possivel mostrar que a ideia de paridade pode ser aplicada

em outras situações (SIM/NÃO, LIGADO/DESLIGADO, 0/1).

Na computação, por exemplo prático, entenda-se que toda a informação é represen-

tada através dos simbolos 0 ou 1.

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

81

No contexto das telecomunicações e envio de mensagens, paridade refere-se ao
número de bits ’1’ de um determinado número binário. Para assinalar a paridade, é
adicionado, no ﬁnal ou no início de uma sequência binária, um dígito binário de
paridade.

A paridade de um bit (ou mais) é utilizada para detectar erros nas transmissões, já
que o seu cálculo é extremamente simples. Por exemplo, se for anexado um bit de paridade
extra a cada byte transmitido, um erro pode ser detectado se a paridade do byte não
coincidir com o bit de paridade.

Assim, imagine que vamos transmitir por exemplo a informação 1100101. Acrescen-
tar um dígito de paridade é colocar (normalmente no ﬁnal ou no início da mensagem)o
dígito correspondente.

Para compreender isso melhor, imagine que queira colocar um dígito de paridade
par(ou seja, o total de 1’s dá um resultado par)no ﬁnal da mensagem, e o nossa mensagem
ﬁcará

1100101 → 11001010

Pois 1100101 = 1+1+0+0+1+0+1= 4, que é um número par, e daí o digito do

ﬁnal será 0.

SUGESTÃO DE ATIVIDADE: A TABELA ASCII.

A tabela ASCII do inglês American Standard Code for Information Interchange, é
um código alfanumérico que estabelece uma correspondência entre a linguagem binária que
é entendida pelo computador e os símbolos que utilizamos para comunicar. Nos anos 60,
proposto por Robert W. Bemer, o código ASCII (American Standard Code for Information
Interchange) foi adotado como código padrão para a comunicação de informações.Assim,
seria possível que computadores de diversos fabricantes conseguissem entender melhor os
códigos.

Considere as vogais do nosso alfabeto convertidas na notação binária através da

tabela ASCII representada abaixo

Capítulo 5. O Código Linear de Hamming e a abordagem de códigos no ensino básico.

82

Figura 5.3 – Trecho da Tabela ASCII - Código Binário, 1963.

Fonte: computerhistory.org(Editado pelo autor).

Com a tabela ASCII em mãos, converta os caracteres usados em seu nome e escreva

da forma binária.

Imagine que este pacote de bits receberá a adição de um bit de paridade par no ﬁnal,
para que tenha uma maior conﬁabilidade sem perda de informação durante a transmissão.
Como seu nome estará formatado?

Se tomássemos como exemplo as letras do nome LUIZA, que na tabela ASCII
correspondem respectivamente a L = 1001100, U = 1010101, I = 1001001, Z = 1011010,
A = 1000001, após a adição do bit de paridade par ao ﬁnal teriamos:

10011001 10101010 10010011 10110100 10000010

AVALIAÇÃO

A aula proposta aqui é uma maneira de apresentar a aplicação prática e o raciocínio
algebrico na construção de um código, sua codiﬁcação e a checagem de erros bit a bit. Dessa
forma, a avaliação que se espera é aquela que seja diagnóstica, processual e contínua, ou
seja, realizada ao longo de todas as aulas, se possível em grupos produtivos nas atividades
que demandam um tempo maior.

Critérios a serem observados:

• Participação no desenvolvimento das atividades. Respondeu? Produziu?

• O Raciocínio é adequado? Interagiu e argumentou durante as atividades?

• Entendeu corretamente o uso o bit de paridade, produzindo na atividade em que se

deveria determinar o último bit?

6 Palavras Finais.

83

Os códigos, de uma maneira geral hoje são de grande valia nas telecomunicações,
assim como na criação de estratégias de segurança para os dados computacionais. Em
sala de aula, esses conteúdos normalmente são apresentados como textos base para que
professores e alunos sejam apresentados de uma forma rasa aos algoritmos de validação.

Certamente, o trabalho com códigos corretores permite não apenas a exploração
do raciocínio matemático como a veriﬁcação de algumas propriedades que permeiam a
álgebra e aritmética. Dessa forma é possível explorar muito mais opções de conteúdo na
hora da apresentação do sistema binário e mostrar que assim como outros sistemas de
base ele é fechado para as operações e de signiﬁcativa importância quando focamos nossa
atenção nos sistemas computacionais.

As possibilidades de exploração deste conteúdo são muitas, atacando não apenas
habilidades do Ensino Fundamental como habilidade do ensino médio e ainda explorando
desde conteúdos simples como paridade até conteúdos mais complexos como o entendimento
de maneira algébrica dos algoritmos de validação ou como citado no capítulo 2 o uso das
classe residuais.

Uma das reclamações frequentemente ouvidas no ensino básico é que o nosso aluno
se torna dependente de ferramentas eletrônicas. A pura e simples aplicação de um algoritmo
durante as aulas de matemática e o exercício realizado pelo aluno em papel, mesmo que
para um código muito grande, de certa maneira auxilia na apreensão da técnica, e no
caso deste algoritmo ser de fácil entendimento, o aluno pode inclusive investigar outras
alternativas mais rápidas tornando-se não só investigador, mas também um aprendiz capaz
de mobilizar seus saberes.

Ao ingressar no ensino superior, mesmo que ele não tenha sido formalmente
apresentado aos conteúdos de álgebra abstrata, um conhecimento na criação de um
algoritmo de codiﬁcação e de decodiﬁcação certamente o tornará preparado para não
somente compreender as técnicas utilizadas como um melhor aprofundamento do conteúdo.

Percebe-se portanto que os códigos corretores de erros poderiam ser melhor explo-
rados e a álgebra é uma ferramenta que pode ser trabalhada em algumas séries do ensino
básico em diferentes níveis de acordo com o interesse e disposição de proﬁssionais e alunos.

Embora a álgebra da qual os códigos de erros se fundamentam na abstrata, as
operações e procedimentos permeiam a aritmética e a construção do algoritmo para a
criação da estratégia de embaralhamento da mensagem. Nos bancos do ensino regular,
a contribuição que os proﬁssionais da educação podem dar é mostrar aos alunos que a

Capítulo 6. Palavras Finais.

84

algebra pode ser divertida e funcional, apresentando, mesmo que de forma básica e leve, as
estruturas envolvidas na criação de sistemas de identiﬁcação e validação. Tais algoritmos
por sí só já são códigos, e a estratégia utilizada para sua deﬁnição pode se tornar corretora
de erros. Por ﬁm, a relação entre a álgebra e os códigos corretores é interessante, de grande
aplicabilidade na computação moderna, e toda contribuição do proﬁssional na escola básica
é bem vinda, pois é possivel estabelecer um paralelo com os outros ramos da matemática
e mostrar que as propriedades que essas manipulações possuem podem ser aplicáveis nas
diversas áreas, garantindo segurança, eﬁciência e robustez.

Referências

85

ALENCAR, M. S. D. A. Televisão digital. [S.l.]: Érica, 2007. Citado na página 48.

ANTON, H.; RORRES, C. Álgebra linear com aplicações. [S.l.]: Bookman Porto Alegre,
2001. v. 8. Citado na página 29.

BOLDRINI, J. L. et al. Algebra Linear. Sao paulo: Editora harper & row do brasil ltda,
1978. Citado na página 29.

BRANCO, E. S. Como funciona o sistema binário?. Plano de Aula. 2010. Disponível em:
<http://portaldoprofessor.mec.gov.br/ﬁchaTecnicaAula.html?aula=22116>. Accessed:
2019-01-02. Nenhuma citação no texto.

CALLIOLI, C. A.; DOMINGUES, H. H.; COSTA, R. C. F. Álgebra linear e aplicações.
[S.l.]: Atual, 2000. Citado na página 44.

DIAS, C. M. C. Álgebra booleana e lógica digital uma aplicação da lógica matemática.
Revista Acadêmica: ciências agrárias e ambientais, Curitiba, 1994. Citado na página 13.

DUTRA, K. Como a BNCC prevê o uso das tecnologias na sua disciplina? 2018.
Disponível em: <http://redes.moderna.com.br/2018/08/07/bncc-tecnologias-disciplina>.
Accessed: 2018-10-08. Citado 2 vezes nas páginas 74 e 76.

EDC, Detecção e Código de erros. Disponível em: <https://epxx.co/artigos/edc.html>.
Accessed: 2018-08-30. Citado na página 22.

GONZAGA, Y. Unidade 1 - O sistema Binário. Disponível em: <https://youtu.be/
_Cw3STPum5w?t=113>. Accessed: 2018-11-08. Citado na página 74.

HEFEZ, A. Elementos de Aritmética. Rio de janeiro: Instituto de Matematica Pura e
Aplicada, IMPA, 2008. Citado na página 16.

HEFEZ, A. C. d. S. F. Introduçao a Álgebra Linear. Rio de janeiro: Instituto de
Matematica Pura e Aplicada, IMPA, 2016. Citado 2 vezes nas páginas 29 e 65.

HEFEZ ABRAMO. M.L.T, V. Código Corretores de erros. Rio de Janeiro: Instituto de
Matemática Pura e Aplicada, IMPA, 2008. Citado 9 vezes nas páginas 50, 52, 53, 56, 61,
64, 67, 68 e 74.

LAY, D. C. Algebra lineal y sus aplicaciones. [S.l.]: Pearson educación, 2007. Citado na
página 42.

LIRA, E. H. C. d. Códigos corretores de erros no ensino médio: Um estudo sobre o código
de hamming. Universidade Federal Rural de Pernambuco,Recife, BR-PE, 2018. Nenhuma
citação no texto.

MACHADO, D. A. Uma abordagem de dígitos veriﬁcadores e códigos corretores no ensino
fundamental. Tese (Doutorado) — Universidade de São Paulo. Citado 3 vezes nas páginas
54, 67 e 68.

Referências

86

MALAGUTTI, P. L.; BEZERRA, D. d. J.; RODRIGUES, V. C. d. S. Aprendendo
criptologia de forma divertida. [S.l.]: Paraıba, 2010. Citado na página 74.

MEC, M. d. E. e. C. Pcn - parametros curriculares nacionais do ensino fundamental.
Secretaria de Educação Fundamental. Brasília: MEC/SEF, 1998. Citado 2 vezes nas
páginas 74 e 76.

MEC, M. d. E. e. C. Pcn - parametros curriculares nacionais do ensino médio. Disponivel
em: http://portal.mec.gov.br/seb/arquivos/pdf/CienciasNatureza.pdf.Secretaria de
Educação Fundamental. Brasília: MEC/SEF, p. 43, 2000. Citado na página 76.

MILIES, C. P. Breve introduçao a teoria dos códigos corretores de erros. Departamento de
Matemática, UFMS, 2009. Citado na página 48.

NICOLETTI, E. R. Aplicações de ágebra linear aos códigos corretos de erros e ao ensino
médio. Universidade Estadual Paulista (UNESP),Mestrado Proﬁssional em Matemática,
2015. Nenhuma citação no texto.

OBMEP, P. d. I. C.-P. Aula 12- Bases de Numeração. Disponível em: <https:
//www.youtube.com/watch?v=4Bu9zJJEIpY>. Accessed: 2018-10-10. Citado na página
74.

PINTO, H. Sistemas de identiﬁcação com algarismos de controlo1. 2006. Citado na
página 27.

PULINO, P. Álgebra Linear e Suas Aplicações: Notas de Aula. 2012. 2012. Disponível em:
<http://www.ime.unicamp.br/~pulino/ALESA/Texto/>, note = Accessed: 2018-11-10.
Citado na página 29.

ROCHOL, J. Comunicação de dados. Bookman, 2012. Citado na página 49.

TAUSK, D. V. Método prático para extrair uma base de um conjunto. 2008. Disponível
em: <https://www.ime.usp.br/~tausk/texts/MetodoBase.pdf>. Accessed: 2018-11-08.
Citado na página 43.

TVESCOLA, M. História dos Números. 2018. Cópia do Video Disponível em:
<http://www.youtube.com/watch?v=Qh6wS2MWXLU>. Accessed: 2018-11-09. Citado
na página 78.

VENTURA, J. Notas de Combinatória e Teoria de Códigos. Disponível em:
<https://www.math.tecnico.ulisboa.pt/~jventura/CTC/NotasCTC.pdf>. Accessed:
2019-1-10. Nenhuma citação no texto.

WINTERLE, P.; STEINBRUCH, A. Álgebra linear. São Paulo: 2a ed. McGraw-Hill, 1987.
Citado 2 vezes nas páginas 29 e 31.

