UNIVERSIDADE FEDERAL DE SERGIPE

PRÓ-REITORIA DE PÓS- GRADUAÇÃO E PESQUISA

PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA

MESTRADO PROFISSIONAL EM MATEMÁTICA

REDE NACIONAL - PROFMAT

Vinícius Matos de Oliveira

Criptograﬁa e a Matemática

São Cristóvão - SE
2021

Vinícius Matos de Oliveira

Criptograﬁa e a Matemática

Dissertação apresentada ao Programa de Pós -

Graduação em Matemática da Universidade Fe-

deral de Sergipe, como parte dos requisitos para
obtenção do título de Mestre em Matemática.

Orientador: Prof. Dr. Naldisson dos Santos

São Cristóvão - SE
2021

                                   FICHA CATALOGRÁFICA ELABORADA PELA BIBLIOTECA CENTRAL UNIVERSIDADE FEDERAL DE SERGIPE     O48c  Oliveira, Vinícius Matos de    Criptografia e Matemática / Vinícius Matos de Oliveira ; orientador Naldisson dos Santos. – São Cristóvão, 2020.       54 f.        Dissertação (mestrado em Matemática) – Universidade Federal de Sergipe, 2020.     1. Matemática. 2. Números primos. 3. Congruências e restos.  4. Criptografia.  I. Santos, Naldisson dos orient. II. Título.  CDU 51   ___________________________________________________________________________________ Cidade Universitária “Prof. José Aloísio de Campos” – Av. Marechal Rondon, s/no - Jardim Rosa Elze – Campus de São Cristóvão. Tel. (00 55 79)  3194-6887  CEP: 49100-000 - São Cristóvão – Sergipe - Brasil – E-mail: promat.ufs@gmail.com   UNIVERSIDADE FEDERAL DE SERGIPE PRÓ-REITORIA DE PÓS-GRADUAÇÃO E PESQUISA PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA    Dissertação submetida à aprovação pelo Programa de Pós-Graduação em Matemática da Universidade Federal de Sergipe, como parte dos requisitos para obtenção do grau de Mestre em Matemática.    Criptografia e a Matemática   por  Vinicius Matos de Oliveira  Aprovada pela banca examinadora:    _________________________________________________ Prof. Naldisson dos Santos - UFS Orientador   __________________________________________________ Prof. Fabio dos Santos - UFS Primeiro Examinador    __________________________________________________ Prof. Gleidson Gomes da Silva - UFPE Segundo Examinador     São Cristóvão, 22 de Fevereiro de 2021  Agradecimentos

Agradeço primeiramente à minha família por todo apoio dado neste período de luta e,

sem dúvida, esta conquista eu divido com minha mãe, Gorete, minhas irmãs, Valéria e Vanessa

e meus sobrinhos, Luís Fernando e Isabela. Grato por toda palavra de incentivo nos momentos

de desânimo e por toda força a cada viagem de 440 quilômetros semanais para poder realizar

este sonho.

Aos professores do departamento de matemática da UFS, agradeço a todos que foram

meus professores durante o curso: Prof. Dr. Almir, Prof. Dr. Anderson, Prof. Dr. Alysson,

Prof. Dr. Evilson, Prof. Dr. Fábio e, especialmente, ao meu orientador Prof. Dr. Naldisson, por

toda dedicação, ensinamento e compreensão durante esta jornada. Muito obrigado a todos.

Aos meus colegas de Profmat: Carlos Educardo, Tony e Lucas. Obrigado pelo auxílio,

companheirismo e troca de experiências.

Não posso deixar de agradecer a todos meus amigos e familiares que contribuíram direta

ou indiretamente por esta conquista.

À CAPES, pois o presente trabalho foi realizado com apoio da Coordenação de Aper-

feiçoamento de Pessoal de Nível Superior - Brasil (CAPES) - Código de Financiamento 001.

Resumo

A presente dissertação visa alinhar o conhecimento matemático ao sistema de criptogra-

ﬁa RSA. Inicialmente, é feita uma linha histórica sobre a evolução da criptograﬁa, mostrando

a necessidade de governantes, reis, comandantes passarem informações conﬁdenciais ao longo

da história. A seguir, é estudado o conhecimento matemático essencial para entender o sistema

criptográﬁco mais utilizado atualmente: o sistema RSA. Entre este conhecimento matemático,

os números primos se destacam na aritmética básica, e o sistema de congruência na aritmé-

tica modular. Em seguida, é demonstrado como funciona o sistema RSA de criptograﬁa, assim

como é garantida enorme diﬁculdade em quebrar a mensagem criptografada a partir dos núme-

ros primos escolhidos para sua composição.

Palavras-chave: Números primos; Congruências; Criptograﬁa; Sistema RSA.

Abstract

The present dissertation aims to align the mathematical knowledge to the RSA encryp-

tion system theme. Initially, a historical line is made on the evolution of cryptography, showing

the need for rulers, kings, commanders to pass conﬁdential information throughout history.

Next, the essential mathematical knowledge is studied to understand the most used crypto-

graphic system today: the RSA system. Among this mathematical knowledge, prime numbers

stand out in basic arithmetic, and the congruence system in the modular arithmetic. Soon after,

it is demonstrated how works the system Encryption RSA, as well as is guaranteed enormous

difﬁculty in breaking the message encrypted from the prime numbers chosen for its composition

Keywords: Prime numbers; Congruences; Cryptography; RSA system.

Sumário

Introdução

1 A História da Criptograﬁa

1.1 Evolução da Criptograﬁa . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 Modelos de Criptograﬁa

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.3 Criptograﬁa simétrica e assimétrica . . . . . . . . . . . . . . . . . . . . . . . .

2 Números Primos e a Aritmética Modular

2.1 Divisão nos Inteiros e Algoritmo de Euclides

. . . . . . . . . . . . . . . . . .

2.2 Números Primos

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.1 Teorema Fundamental da Aritmética . . . . . . . . . . . . . . . . . . .

2.2.2

Inﬁnidade dos Primos

. . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.3 Métodos para Encontrar Números Primos . . . . . . . . . . . . . . . .

2.2.4 Números de Fermat e de Mersenne

. . . . . . . . . . . . . . . . . . .

2.3 Aritmética modular .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.3.1 Congruência e Propriedade . . . . . . . . . . . . . . . . . . . . . . . .

2.4 Teorema de Euller . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Criptograﬁa RSA

3.1 Tipos de Chaves .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.2 Processo de Codiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8

12

15

18

19

23

23

25

26

27

27

29

30

30

32

36

38

38

3.3 Processo de Decodiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.4 Segurança .

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.5 Assinaturas Digitais . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.6 Considerações Finais .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Referências

.

. .

. .

. .

. .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

40

45

48

49

52

Introdução

A necessidade de se comunicar é inerente ao ser humano. Hoje se vive em um mundo

onde o volume de troca de mensagens é imensurável e a quantidade de dados criados cresce

exponencialmente. Guardadas as devidas proporções, em toda a história da humanidade, houve

essa necessidade de troca de informações e, quanto mais sigilosa essa troca de informações,

mais privilegiado seria aquele que a conhecia.

O que diferencia as trocas de informações atuais daquelas de outrora é claramente o

avanço da tecnologia para codiﬁcar. Paralelamente, evoluíram as pessoas e as tecnologias que

decodiﬁcavam essas informações sigilosas. O método de codiﬁcar sempre precisava de novos

detalhes ou uma mudança radical diante do surgimento de métodos eﬁcazes para quebrar o

código apresentado.

A matemática entra nesse contexto porque é o centro do sistema de codiﬁcação mais

utilizado atualmente: o sistema RSA. Este sistema garante o sigilo do imenso ﬂuxo de informa-

ções, desde as transações bancárias, passando pelas mensagens nos aplicativos e por todas as

formas de se garantir, ou ao menos se tentar, que não vazem informações pessoais da população.

O sistema RSA utiliza conceitos matemáticos difundidos nos bancos escolares, como

o uso de números primos e as congruências, baseando sua logística na diﬁculdade de se de-

compor números cujos fatores são números primos grandes. Durante o trabalho será estudado

detalhadamente todos os conteúdos matemáticos essenciais para entender como funciona tal

sistema.

É importante frisar que o sistema RSA é recente e surge junto ao uso dos computa-

dores nas transações comerciais, políticas e pessoais. Antes disso, a humanidade passou por

8

diversos modelos de criptograﬁa, sempre com visão de que tal modelo nunca seria superado e

suas mensagens não seriam decodiﬁcadas. Puro engano. Diversos governantes perderam ba-

talhas ou a própria vida por ter informações interceptadas e decodiﬁcadas pelo oponente. Os

decodiﬁcadores passaram a ter fundamental importância nos rumos de uma guerra.

Diante desse cenário de necessidade de ter um ﬂuxo de informações que fosse ao mesmo

tempo secreto e rápido, a evolução nas últimas décadas é notória. Com o advento dos computa-

dores e sua rápida possibilidade de se trocar dados, foi necessário também se pensar como fazer

com que todo esse ﬂuxo fosse seguro para quem utilizava.

Na última década, com a popularização das redes sociais, puderam-se constatar diversas

situações em que os usuários tiveram seus dados expostos devido a alguma fragilidade no sis-

tema de codiﬁcação das informações. Toda essa situação coloca em xeque a real proteção que

tais redes sociais disponibilizam para seus usuários.

Uma situação de exposição de dados não pode ocorrer com o sistema bancário, pois

basta imaginar o caos que seria se as contas bancárias da população fossem expostas com suas

respectivas senhas, ou então os dados do cartão de crédito levados ao público, Hodiernamente,

grande parte das transações bancárias são realizadas por meio de aplicativos no próprio celu-

lar. O usuário precisa ter a conﬁança de que tais informações serão realmente sigilosas ou o

aplicativo não será utilizado pelos consumidores.

Diante de tanta necessidade e comodidade do uso da internet para as transações bancá-

rios, para a troca de mensagens pessoais, para os projetos realizados no trabalho, o que sustenta

toda conﬁabilidade neste uso é o sistema de criptograﬁa. Sem este, seria possível interceptar e

decodiﬁcar facilmente mensagens e dados trocados entre usuários.

Quando se fala em troca de mensagens eﬁcientes e sigilosas, recai-se sobre o sistema

RSA, criado por Ronald Rivest, Adi Shamir e Leonard Adleman - daí o nome RSA, inicias dos

sobrenomes de seus criadores. O ponto central da eﬁciência desta sistema é a facilidade em se

encontrar números primos grandes e a diﬁculdade em fatorar números formados pelo produto

destes números primos.

Rivest, Shamir e Adleman resolveram um problema do sistema criptográﬁco anterior ao

sistema RSA, idealizado pelos americanos Whitﬁeld Drifﬁe, Martin Hellman e Ralph Merkle.

Esse sistema denominado DHM já introduziu deﬁnitivamente a Matemática, com a Teoria dos

Números, utilizando as congruências. O sistema serviu de base para o RSA, com a diferença

que no sistema DHM havia a necessidade de troca de chaves secretas entre os indivíduos. Este

9

sistema era simétrico, pois precisava trocar essa informação inicial para poder ser utilizado,

diferentemente do sistema RSA que é assimétrico, ou seja, há uma chave pública para cifragem

e uma chave privada para decifrar mensagens.

Drifﬁe já havia percebido esse problema e a diﬁculdade em se compartilhar chaves se-

cretas com o grande ﬂuxo de informações mundiais que já ocorria. Não era nada prático. Mas o

sistema proposta com o uso de congruência era de uma simplicidade e conﬁabilidade incrível.

Faltava apenas resolver o problema das chaves simétricas. Drifﬁe não conseguiu, porém deixou

o legado para que outros pudessem fazer.

É este contexto que se encontra a presente dissertação, com foco no sistema RSA e toda

a utilização matemática envolvida. Dessa forma, além desta introdução e das considerações

ﬁnais, esta dissertação tratou das seguintes temáticas em seus capítulos:

No primeiro capítulo, houve um passeio histórico a respeito da criptograﬁa, percebendo-

se a importância histórica deste sistema para os governantes de todo o mundo. Ainda, são apre-

sentados os principais modelos de criptograﬁa já criadas pelos homens, apontando a evolução

deste modo de propagar uma informação sigilosa. Na sequência, é dado espaço para diferencias

as criptograﬁas simétricas e assimétricas, informações essenciais para entender mais à frente

porque o sistema RSA funciona.

O segundo capítulo foi dedicado ao estudo dos conteúdos matemáticos essências para

compreender o sistema RSA. Inicialmente, viu-se como funciona a divisão nos inteiros e o

algoritmo de Euclides. A seguir, o foco serão os números primos, base central para o sistema

RSA, com a apresentação do Teorema Fundamental da Aritmética, a inﬁnidade dos números

primos e a apresentação de alguns métodos para encontrar primos, além de uma passagem

rápida nos números de Fermat e de Mersenne. Foi estudada também a Aritmética Modular,

com a congruência e suas propriedades para, a seguir, se chegar ao Pequeno Teorema de Fermat.

Finalmente, neste capítulo será explanado a respeito do Teorema de Euller.

No terceiro capítulo, foi trabalhado especiﬁcamente o sistema RSA de criptograﬁa. Para

compreendê-lo, foram discutidas as chaves públicas e privadas presentes no sistema, bem como

o processo de codiﬁcação e decodiﬁcação. Um exemplo prático do sistema RSA é apresentado

na sequência e foi mostrado porque o sistema é seguro.

Dessa forma, a dissertação buscou mostrar a necessidade da humanidade em transferir

informações sigilosas, culminando com o sistema de criptograﬁa atual, baseado basicamente na

Matemática. Ou seja, o segredo das informações bancárias, das mensagens nas redes sociais,

10

a produção nas empresas, necessitam de informações matemáticas. Situação não imaginada ou

não difundida a somente um século. A Matemática veio garantir o ﬂuxo sigiloso de informações

e mostra que se faz essencial na maioria dos aspectos cotidiano do homem.

11

CAPÍTULO 1

A História da Criptograﬁa

Durante a história da humanidade, reis, rainhas, presidentes e generais valeram-se da

comunicação eﬁciente para governar e fazer com que toda a região governada recebesse as

orientações adequadas. Em momento de guerras, essa comunicação poderia custar a vida da

população e de seus governantes. Por isso, diversos líderes tentavam passar essas mensagens de

forma secreta, uma vez que a interceptação da mensagem e sua leitura pelo inimigo poderiam

mudar o rumo da guerra.

Esta busca pelo segredo levou as nações a criarem departamentos para a ela-

boração de códigos, responsáveis por garantirem a segurança das comunicações

inventando e utilizando os melhores códigos possíveis. Ao mesmo tempo, os deci-

fradores de códigos inimigos tentam quebrar esses códigos, para roubar seus segre-

dos. Os decifradores de códigos são os alquimistas linguísticos, uma tribo mística

que tenta invocar palavras que tenham signiﬁcado a partir de uma mistura de símbo-

los sem sentido. A história dos códigos e de suas chaves é a história de uma batalha

secular entre os criadores de códigos e os decifradores, uma corrida armamentista

intelectual que teve um forte impacto no curso da história humana. (SINGH, 2007,

p. 11)

Dessa forma, a comunicação eﬁciente e sigilosa torna-se essencial para um governo

próspero, cujo receio de invasão inimiga ou vazamento de informações privilegiadas são pro-

12

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

13

blemas constantes na história de quase todas as civilizações. Assim, a comunicação sigilosa é

ponto crucial para o desenvolvimento daquela sociedade, tornando a informação uma valiosa

arma: valiosa para aqueles que a mantém em segredo e, mais ainda, para os grupos inimigos

que conseguem interceptá-las e entender a mensagem a ser passada.

Os códigos utilizados, então, tornam-se ferramentas para o progresso ou derrota de uma

civilização. No momento em que a informação das estratégias de guerra, das rotas do comércio,

dos detalhes do exército torna-se decisivo no andamento da sociedade, a necessidade de passar

essa informação a seus aliados de forma codiﬁcada representa a vida ou morte de parte da

população e até(que palavra é essa) da própria comunidade.

À medida que a informação se torna uma mercadoria cada vez mais valiosa

e a revolução nas comunicações muda a sociedade, o processo de codiﬁcação de

mensagens vai desempenhar um processo cada vez maior na vida diária. Hoje em

dia nossas chamadas telefônicas saltam entre satélites e nossos e-mails passam por

vários computadores. Ambas as formas de comunicação podem ser interceptadas

facilmente, ameaçando nossa privacidade. De modo semelhante, à medida que

mais negócios são realizados através da Internet, devem ser instalados mecanismos

de proteção para a segurança das empresas e de seus clientes. (SINGH, 2007, p.

12)

Atualmente, o sistema de criptograﬁa possibilita uma garantia que os dados pessoais,

bancários, sigilosos, de modo que se possam fazer desde operações bancárias com altos valores

até conversas íntimas, sem que se sinta insegurança, na maioria das vezes, quando se realizam

tais ações. Claro que, da mesma forma que o sistema de criptograﬁa se torna mais eﬁciente,

também evolui o sistema de quebra dessa criptograﬁa, de modo que se podem veriﬁcar casos

de vazamento de informações por parte de algumas empresas, a exemplo dos recentes casos

do Facebook, onde parte dos usuários teve 50 milhões de contas expostas com dados pessoais

compartilhados, com informações dadas pelo próprio criador da rede, Mark Zuckberg.

A codiﬁcação, de acordo com Singh (2007, p. 13), é o único meio de proteger a privaci-

dade e garantir o sucesso do mercado digital, de forma que a criptograﬁa fornecerá os fechos e

as chaves da Era da Informação. Hodiernamente, as informações circulam com impressionante

velocidade e a espera pode se tornar um prejuízo ou desvantagem em relação a concorrentes

comerciais.

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

14

É importante destacar que a necessidade de vantagem na antecipação de informações

percorre toda a história. Sempre foi necessário saber algo antes de seus inimigos, seus concor-

rentes, para poder se preparar diante na nova situação apresentada. Então, quando se fala que

os tempos atuais exigem uma maior velocidade no recebimento de informações, na verdade,

deve-se relativizar esse entendimento, uma vez que a velocidade de informações à possibilitada

de acordo com as tecnologias de cada época. Dessa forma, sobressai-se aquele que encontra

formas de acelerar essa troca de informações e, obviamente, aquele que consegue interceptar e

decodiﬁcar as informações das mensagens secretas.

Na verdade, as formas de cifrar as mensagens atualmente são bastante semelhantes às

formas tradicionais de cifragem. Para exempliﬁcar, tivemos a Enigma, máquina de codiﬁcação

usada nas primeiras décadas do século 20, principalmente na Segunda Guerra Mundial. Singh

aponta que há apenas três diferenças signiﬁcativas entre a cifragem mecânica que foi a base de

cifras como a Enigma e a cifragem atual:

A primeira diferença é que uma máquina de cifras é mecânica, é limitada pelo

que se pode construir na prática, enquanto o computador pode simular uma máquina

de cifragem hipotética de imensa complexidade. A segunda diferença é simples-

mente uma questão de velocidade. A eletrônica pode operar muito mais rapida-

mente do que os misturadores mecânicos: um computador programado para imitar

a cifra Enigma pode cifrar em um instante uma longa mensagem. Além disso, um

computador programado para efetuar uma forma de cifragem muito mais complexa

pode realizar a tarefa dentro de um tempo razoável. A terceira diferença, e talvez

a mais signiﬁcativa, é que um computador mistura números no lugar de letras do

alfabeto. Os computadores lidam apenas com números binários - sequências de

um e zero conhecidas como dígitos binários, ou, abreviadamente, bits (de binary

digits, em inglês). Esta conversão pode ser realizada de acordo com vários proto-

colos, tais como o American Standard Code for Information Interechange (Código

Padrão Amercicano para Troca de Informações), conhecido pela sigla ASCII, que

se pronuncia ’ass-key’. (SINGH, 2007, p. 269)

O que não mudou no decorrer de toda a história foi a necessidade de codiﬁcar e decodi-

ﬁcar mensagens. A humanidade foi construída por disputas, sejam de grupos, de comunidades

ou de países, e a necessidade de sigilo das táticas utilizadas sempre foi importante para a ma-

nutenção do poder. No momento atual, a situação não é diferente: tanto há a necessidade de

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

15

proteção das informações no âmbito de uma nação, cuja exposição desencadearia intrigas e

guerras, como a necessidade de proteger dados e conversas pessoais do simples cidadão.

1.1 Evolução da Criptograﬁa

Inicialmente, os modelos de criptograﬁa eram mais simples, não por falta de necessi-

dade, mas por serem suﬁcientes para o momento histórico. A evolução do sistema criptográﬁco

é impulsionado pelas tentativas de se decodiﬁcar estes códigos para que se possam conhecer os

segredos ali criptografados. Assim, a história dos códigos secretos é marcada pela criação de

um novo método seguido pela sua tentativa de resolução pelos oponentes - situação que poderia

ocorrer rapidamente ou demorar séculos.

Alvarenga (2017, p. 48) considera o modelo de criptograﬁa presente na Antiguidade

"marcada por métodos extremamente simples, mas que eram suﬁcientes para a necessidade

da época". Neste rol de civilizações da Antiguidade, estão incluídos a Grécia, Egito e Roma,

civilizações com desenvolvimento tecnológico e intelectual considerável, corroborando a ideia

de que a criação de um sistema de criptograﬁa mais complexo não seria problema, o que não foi

feito porque as civilizações oponentes não dispunham de preparação adequada para decodiﬁcar

a criptograﬁa ingênua utilizada.

Esses métodos mais simples de criptograﬁa presentes na Antiguidade foram esquecidos

e/ou aperfeiçoados aos pouco e novos métodos mais complexos foram criados. Na Idade Média,

principalmente na civilização árabe-islâmica, devido à necessidade de gerir um grande territó-

rio, houve um avanço tanto nos métodos de criptograﬁa quanto nos estudos para decodiﬁcar os

sistemas criptografados. Surgem, então, estudos mais aprofundados sobre criptoanálise, cuja

tentativa era entender os textos criptografadas, geralmente analisando a frequência com que as

letras apareciam nas mensagens. Cada alfabeto possui letras que são usadas com mais frequên-

cia e, ao codiﬁcar, essas letras necessariamente transformam-se em um mesmo código. Assim,

os criptoanalistas analisavam a frequência dos códigos utilizados, fazendo a desencriptação até

o texto formar um texto coerente.

Quando as potências europeias começaram a se lançar ao mar em busca de especiarias

e, consequentemente, conquistando novos mundo, começou também a disputa mais acirrada

por estes elementos. As nações europeias passam, então, por períodos de aliança e, sequencial-

mente, por rompimento dessas alianças. A necessidade de comunicação, ligado à desconﬁança

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

16

a outras nações, levam ao estudo mais sério da criptograﬁa, fazendo evoluir os sistemas mono-

alfabéticos para os polialfabéticos, como argumenta Alvarenga (2017, p. 51). Este autor ainda

acrescenta:

A partir do século, XVI, com o início do Renascimento, a contínua animosidade

entre os países europeus e as contínuas alianças e rompimento de alianças levara

a que os governantes procurassem meios de ler a correspondência diplomática dos

inimigos, atuais ou futuros. Com este objetivo, criaram-se vários gabinetes, cha-

mados Câmaras Negras, cujo objetivo era tanto decifrar os códigos secretos, quanto

criar códigos invioláveis. (ALVARENGA, 2017, p. 50)

Nos séculos seguintes, a criptograﬁa foi tendo um enorme avanço, justamente pela dis-

puta entre as nações. Essa necessidade de proteger suas conquistas, territórios e, ao mesmo

tempo, descobrir as ideias e intenções dos oponentes, possibilitou esse progresso na criptogra-

ﬁa: cada vez mais se construíam códigos mais complexos e, do outro lado, a arte de decifrar

tais códigos ia se aperfeiçoando.

Com a criação do telégrafo, em 1838, pelo norte-americano Samuel F.B. Morse, as in-

formações começaram a chegar ao destino com rapidez. O código Morse utiliza justamente um

processo de substituição de letras por pontos e traços. Logo depois disso, surgiu a necessidade

de codiﬁcar a mensagem telegrafada. Deve-se perceber que para codiﬁcar uma mensagem há

a necessidade de o receptor ter a informação sobre como decodiﬁcar, e esta informação tam-

bém poderia ser interceptada pelo oponente. Mais a frente será discutida essa problemática que

percorreu toda a história da criptograﬁa.

Com o aumento no ﬂuxo de mensagem com a criação do telégrafo, tornou-se mais ur-

gente encontrar novas formas de codiﬁcação para tornar essa ação mais rápida. Neste ponto da

história, surgem as máquinas de codiﬁcação assistida, como aponta Alvarenga (2017, p. 52).

Ele aduz que a demanda por rapidez tanto na codiﬁcação quanto na decodiﬁcação das mensa-

gens, levou a o emprego de processos automáticos, através destas máquinas de codiﬁcação.

No século, há de se destacar o aperfeiçoamento das máquinas de codiﬁcação, principal-

mente na Alemanha, na Inglaterra e nos Estados Unidos. Até meados do século XIX, não havia

quase nenhuma informação a respeito da criptograﬁa estadunidense, que ganha destaque após

a primeira guerra mundial. A seguir, os principais sistemas de criptograﬁa destas potências

econômicas e bélicas, com as máquinas criadas tal ﬁnalidade.

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

17

Talvez a máquina mais famosa criada para codiﬁcar informações seja a "Máquina Enigma",

de origem na Alemanha nazista, surgida em 1918, conﬁgurada pelo alemão Arthur Scherbius.

Depois da primeira guerra mundial. O exército alemão sentiu necessidade de cifrar suas infor-

mações para tornar seguras as ordens estabelecidas. Alvarenga (2017, p. 61) fala que, a partir

de 1925 o exército alemão concluiu que esta máquina servia aos propósitos bélicos alemãs, e em

1928 começou a usar uma versão dela, a Enigma G97 que tinha como garantidor de segurança

a troca periódica mensal de suas chaves.. A máquina contava com três rotores, cuja função era

misturar o sistema para modiﬁcar o código a depender do interesse.

Quanto à criptograﬁa inglesa, destaca-se a criação da máquina "Typex", que tinha como

vantagem sobre a "Enigma"maior quantidade de rotores. A cronologia da invenção inglesa

acontece da seguinte forma:

Em agosto de 1934 surgiu o primeiro protótipo de uma máquina codiﬁcadora,

a Typex Mark I. Por volta de 1937 já havia cerca de 30 máquinas em operação. A

Typex era baseada na máquina comercial Enigma que incorporava um número de

características a mais, para aumentar a segurança. Por exemplo, tinha cinco rotores

(contra três ou quatro na Enigma), sendo que os dois primeiros ﬁcavam estacio-

nários, embora pudessem ser acionados a mão. Os rotores continham múltiplos

entalhes que poderiam eventualmente acionar os rotores vizinhos. (ALVARENGA,

2017, p. 62)

Quando se fala sobre a criptograﬁa estadunidense, pouco se tem informação sobre o

sistema apresentado antes do século XX, como mencionado anteriormente. Após a primeira

guerra mundial, os Estados Unidos aprimoraram a segurança de seus códigos, culminando com

a criação da máquina de cifras Sigaba, mais utilizada pela Marinha e pelo Exército. Ela possui

o mesmo processo da Enigma, com um sistema de rotores para a codiﬁcação das mensagens.

Porém, a máquina estadunidense possui quinze rotores, com clara vantagem sobre os três rotores

da máquina alemã. Ainda, a Sigaba possuía um dispositivo que fazia movimentar os rotores de

forma aleatória, diﬁcultando sua decodiﬁcação pelos oponentes.

Diante da história da evolução da criptograﬁa, percebe-se que os sistemas foram se tor-

nando mais complexos a partir da necessidade das civilizações e das situações em que o sistema

era decodiﬁcado pelos oponentes. A informação secreta sempre foi essencial para manter uma

civilização em vantagem em relação às demais. Esta vantagem tornou-se determinante no mo-

mento em que as informações circulam mais rapidamente. As nações aperfeiçoaram os sistemas

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

18

para ter seu domínio predominante e, posteriormente, as empresas passaram a necessitar destes

sistemas de codiﬁcação. Atualmente, diversas empresas, como bancos e redes sociais, investem

para tornar seus negócios cada vez mais seguros e poder alavancar um maior número de clien-

tes. A forma como essas empresas realizam a codiﬁcação e decodiﬁcação das informações é

estudado em capítulo posterior.

1.2 Modelos de Criptograﬁa

Como falado anteriormente, os sistema de codiﬁcação foram se aperfeiçoando ao longo

dos tempos de forma que a complexidade foi aumentando na proporção em que os oponen-

tes instituíam formas eﬁcazes para decodiﬁcar seus códigos. É importante conhecer alguns

principais modelos de criptograﬁa utilizados pelas civilizações, que vão desde a utilização de

substituição de letras - mono ou polialfabético -, por transposição e por esteganograﬁa.

A encriptação por substituição de letras serviu por muitos séculos aos interesses das

civilizações, apesar de seu sistema ser bastante simples, principalmente o monoalfabético que,

como o próprio nome indica, utiliza unicamente um alfabeto para fazer a substituição de letras.

Na Roma Antiga, Júlio César usava um simples sistema onde cada letra do alfabeto era trocada

por outra letra do mesmo alfabeto. Esse procedimento era bastante utilizado em Roma, quando

César precisava se comunicar com os generais.

Esse mesmo modelo foi utilizado pelos hebreus, com um detalhe que possibilitava uma

pequena vantagem na forma utilizada por César: "as 22 letras do alfabeto eram escritas onze

a onze, e cada letra seria substituída pela correspondente superior ou inferior"(ALVARENGA,

2017, p. 8). Esse modelo era chamado de "atbash", sendo relativamente fácil e ser decodiﬁcado

devido à simetria na troca das letras e na utilização do alfabeto de cima para baixo para codiﬁcar

e o inverso para decodiﬁcar.

O Código Mecânico, também criado utilizando o sistema monoalfabético de substitui-

ção de letras, valia-se de um posicionar as letras sequencialmente em quatro grades, de forma

que a letra seria substituída pelos traços da grade ao redor da letra, adicionado a pontos que ser-

viam para diferenciar grupos de letras. Outro modelo monoalfabético, criado por italiano Leon

Battista Alberti, utilizou um disco de cifras, com diâmetros diferentes e em que estão inseri-

dos os alfabetos. Com o movimento dos discos em torno de um eixo, criava-se com facilidade

nossas cifras a partir do giro desses discos.

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

19

O aperfeiçoamento dos métodos de codiﬁcação ocorre, como se discutiu anteriormente,

com a evolução dos métodos de decodiﬁcação, de forma que o surgimento do sistema polialfa-

bético foi introduzido justamente porque o sistema monoalfabético deixou de exercerem com

eﬁciente seu objetivo. Como se deve imaginar, o sistema polialfabético utiliza vários alfabetos

embaralhados, diﬁcultando o deciframento da mensagem.

Além dos métodos de substituição de letras, as civilizações utilizaram situações em que

as letras do alfabeto eram deslocadas de sua posição original ou ainda sistemas em que cada

letra tinha a função de uma palavra ou frase. Este último era a chamada "encriptação por

esteganofragia", que, de acordo com ALVARENGA o método consistia em:

Uma forma bastante astuciosa de esteganograﬁa foi utilizada pelo abade bene-

ditino Johannes Trithemius. Seu sistema era conhecido como as Ave Marias. Ele

era composto por 14 alfabetos, nos quais, a cada letra, corresponde uma palavra ou

grupo de palavras. O texto cifrado ﬁnal, quando lido normalmente, apresenta ser

um texto coerente, como se fosse uma oração ou gloriﬁcação religiosa, em latim.

(2017, p. 34)

O deslocamento das letras de sua posição original também foi bastante utilizado, sendo

chamado de método de "transposição". Esse sistema tinha uma vantagem em relação ao sistema

de substituição de letras, uma vez que as palavras de um idioma possuem agrupamentos mais

comuns de letras, ou até mesmo, obrigatórios, facilitando a descoberta por quais letras foram

substituídas as originais. Veja o exemplo da letra "Q"no idioma português: obrigatoriamente

deve haver a letra "U"na sequência. Esse fato poderia facilitar a decodiﬁcação da mensagem.

Com transposição das letras, essa junção não vai acontecer, tornando mais difícil de decodiﬁcar

a mensagem.

1.3 Criptograﬁa simétrica e assimétrica

Todas as possibilidades de codiﬁcar uma mensagem apresentadas até então se baseiam

em algum método onde o emissor deve compartilhar com o receptor a mensagem e também

o algoritmo para decodiﬁcar a mensagem. Ou seja, antes de alguém compartilhar um segredo

com outro, precisaria ter compartilhado outro segredo.

Imaginando que um professor X da

Universidade Federal de Sergipe - UFS -, no polo de São Cristóvão, deseja transmitir uma

mensagem secreta para um professor Y da UFS, no polo de Itabaiana, antes ele irá precisar

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

20

estabelecer os critérios para que a mensagem possa ser decifrada, ou seja, precisa indicar qual

o algoritmo para decodiﬁcação da mensagem. Esse algoritmo é a chave da cifragem. Neste

contexto, a forma de decodiﬁcar é apenas o algoritmo inverso da codiﬁcação. Deve-se perceber

que este tipo de cifragem corre risco se a chave privada se tornar pública.

Este tipo de sistema onde se usa a mesma chave para cifrar e decifrar a mensagem

é chamada de simétrica. Há também o sistema assimétrico, mais utilizado atualmente, que

se baseia numa chave pública e em uma privada. Neste caso, todos conhecem a forma para

codiﬁcar uma mensagem para alguém, a chave pública, mas somente a pessoa tem a chave

privada para decodiﬁcar.

[No sistema simétrico], ambos, o emissor e o receptor, possuem, efetivamente,

um conhecimento equivalente e ambos usam a mesma chave para cifrar e decifrar -

seu relacionamento é simétrico. Por outro lado, num sistema de chave assimétrico,

como o próprio nome sugere, a chave de cifragem e a chave de decifragem não são

idênticas. Em uma cifra assimétrica, se Alice sabe a chave de cifragem, ela pode

cifrar mas não pode decifrar a mensagem. Para decifrá-la, ela deve ter acesso à

chave de decifragem. Esta distinção entre cifragem e decifragem é o que torna a

cifra assimétrica tão especial. (SINGH, 2007, p. 294)

Na criptograﬁa assimétrica, existem duas chaves, a chave pública e a chave privada.

Para cifrar uma mensagem para alguém, precisa-se ter a chave pública, de conhecimento geral,

e utilizar esta chave para cifrar a mensagem; o receptor decifra a mensagem secretamente.

Voltando ao caso dos professores da UFS, para o professor X enviar uma mensagem cifrada ao

professor Y, ele utiliza a chave de ciframento pública PY e envia a mensagem para o professor

Y. Este tem a chave de deciframento secreta SY e decodiﬁca a mensagem. A chave não está

presente em nenhum nível na mensagem, sendo os algoritmos de ciframento e deciframento

iguais. Assim, garante-se o sigilo da mensagem entre o emissor e o receptor, porque somente

ambos têm conhecimento da chave secreta.

Alvarenga (2017, p. 118) compara o sistema a partir de três características: velocidade,

segurança e limitações. O autor foca que cada sistema - simétrico ou assimétrico - possui

vantagens e desvantagens, podendo o emissor e o receptor valer-se de um ou outro ou até de

ambos os sistemas. Deve-se lembrar de que a problemática do sistema sistemático é o fato de

o emissor também precisar compartilhar a chave privada para que o destinatário possa decifrar

a mensagem. Para aumentar a segurança, o receptor poderia compartilhar a chave privada por

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

21

uma mensagem cifrada pelo sistema assimétrico, garantido, assim, o sigilo. E por que não

enviar toda a mensagem pelo sistema assimétrico? Claro que é uma das possibilidades, porém

os algoritmos da chave simétrica possuem menor complexidade, inﬂuenciando diretamente em

sua velocidade e custo computacional.

Hodiernamente, o sistema RSA, anagrama formado pelos criadores - Rivest, Shamir e

Adleman -, é o sistema mais utilizado. Baseia-se no uso do produto de grandes números primos

para a construção da chave, sendo que a decodiﬁcação somente seria possível conhecendo tais

fatores primos. A diﬁculdade de decifrar tal código sem a chave privada reside no fator de

diﬁcilmente fatorar um número produto de fatores primos grandes unicamente na "força bruta".

Em teoria, quando o RSA foi inventado em 1977, ela ofereceu um antídoto

para o cenário do Grande Irmão, porque os indivíduos seriam capazes de criar suas

próprias chaves públicas e particulares, enviando e recebendo mensagens perfeita-

mente seguras. Contudo, na prática, havia um grande problema porque o processo

real da cifragem pela RSA exigia uma boa dose de poder de computação em compa-

ração com as formas simétricas de cifragem, tais como o DES. Consequentemente,

na década de 1980, apenas o governo, os militares e as grandes empresas pos-

suíam computadores suﬁcientemente poderosos para rodar a RSA. Não é surpresa

que a RSA Data Security Inc., a empresa fundada para comercializar a RSA, tenha

desenvolvido seus produtos de cifragem tendo em mente apenas esses mercados.

(SINGH, 1999, p. 324)

Foram Ronald Rivest, Adi Shamir e Leonard Adleman do Laboratório de Ciência de

Informação do Massachusetts Institute of Technolgy (MIT), que deram em 1978 o passo deci-

sivo para a implementação do sistema criptográﬁco com sistemas assimétricos, idealizado por

Drifﬁe. (HEFEZ, 2016, p. 274)

A esta altura, faz-se importante mencionar o código ASCII, American Standford Code

for Information Interchange, de tradução Código Padrão Americano para o Intercâmbio de In-

formação. Este código transformou as informações para o sistema adotado pelos computadores

- o sistema binário. Não conﬁgura um sistema de cifragem, mas uma tradução para o código

binário os símbolos mais utilizados. O RSA é um sistema que cifra a mensagem anteriormente

codiﬁcada em ASCII e somente o seu devido destinatário pode decifrá-la.

Em traços gerais, são gerados dois pares de números - as chaves - de tal forma

CAPÍTULO 1. A HISTÓRIA DA CRIPTOGRAFIA

22

que uma mensagem encriptada com o primeiro par possa ser apenas desencrip-

tada com o segundo par; entretanto, o segundo número não pode ser derivado do

primeiro. Esta propriedade assegura que o primeiro número possa ser divulgado

a alguém que pretenda enviar uma mensagem encriptada ao detentor do segundo

número, já que apenas essa pessoa pode desencriptar. (ALVARENGA, 2017, p.

174)

O sistema RSA é um dos mais seguros atualmente, sendo utilizado nas principais trocas

de mensagens de teor privado e/ou sigiloso. Diante de uma sociedade onde a quantidade de

conteúdo é aumentada exponencialmente e grande parte deste conteúdo é sigiloso, como men-

sagens pessoais, senha de contas bancárias e cartões de crédito, torna-se essencial proteger esse

sistema de troca. O sistema RSA parece ser o auge entre os sistemas que buscam codiﬁcar infor-

mações, originado na criação dos primeiros sistemas simples de substituição de letras, surgidos

na Antiguidade.

Para entender como funciona mais detalhadamente o sistema de criptograﬁa RSA, te-

mática abordada no quarto capítulo, faz-se necessário conhecer alguns conceitos matemáticos,

especialmente da Aritmética, para poder visualizar de forma mais clara como ocorrem a troca

de mensagens. Este sistema tem por concepção principal a relativa facilidade que se encontram

números primos grandes e da enorme diﬁculdade de fatorar um número que seja produto de

dois destes números primos. Assim, o próximo capítulo se debruça sobre tais conhecimentos

matemáticos necessários para entender mais a fundo o sistema RSA.

CAPÍTULO 2

Números Primos e a Aritmética Modular

2.1 Divisão nos Inteiros e Algoritmo de Euclides

A divisão nem sempre é possível entre números inteiros, podendo expressar tal pos-

sibilidade através da relação de divisibilidade. E mesmo quando não existir essa relação de

divisibilidade entre dois números inteiros, ainda tem-se a possibilidade de uma divisão com

resto, chamado de divisão euclidiana.

Dados dois números inteiros a e b, diz-se que a divide b, na forma a | b, quando existir
um c ∈ Z tal que b = ca. Assim, diz-se que a é um divisor de b, b é um múltiplo de a, ou ainda,

b é divisível por a. Caso não exista nenhum número inteiro c tal que b = ca, diz-se que b não é

divisível por a. Diz-se que 4 | 12, pois 12 = 4 × 3, temos também que 12 é múltiplo de 4 e 4 é
divisor de 12. E 4 não divide 14, pois não existe c ∈ N tal que 14 = c × 4 é satisfeita.

Sejam a, b, c ∈ Z. Tem-se que:

(i) 1 | a, a | a e a | 0. Isso decorre das igualdades a = a × 1, a = 1 × a e 0 = 0 × a. Como

consequência dessas proposições, todo número inteiro a é divisível por ±1 e por ±a.

(ii) 0 | a ⇔ a = 0. Suponha que 0 | a; logo existe c ∈ Z tal que a = c × 0.

(iii) se a | b e b | c, então a | c. Para a | b e b | c, implica que existem f, g ∈ Z, tais que

23

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

24

b = f a e c = gb. Substituindo o valor de b da primeira equação na outra, obtém-se:

c = gb = g(f a) = (gf )a,

o que mostra que a | c.

Dados dois números inteiros a e b, ambos diferentes de zero e pertencentes aos números

inteiros, pode-se associar cada um desses números ao conjunto de divisores de a e b, ou D(a) e

D(b). Fazendo a interseção desses conjuntos nunca resultará em conjunto vazio, uma vez que

sempre estará presente, ao menos, o número 1. Considerando o maior número na interseção

entre os divisores de dois números, tem-se o Máximo Divisor Comum.

Assim, dado d ≥ 0, d é máximo divisor comum de a e b se atende a essas duas propri-

edades: i) d é um divisor comum de a e b; e ii) d é divisível por todo divisor de a e b. Para a

notação de máximo divisor comum, será utilizado mdc(a, b) = d, de forma que não importa a

ordem de a e b, então mdc(a, b) = mdc(b, a).

É importante destacar que é sempre possível efetuar a divisão de a por b com resto,

mesmo quando um número inteiro b não divide o número inteiro a. Em seu livro Elementos,

Euclides já expressava tal possibilidade, sendo tal algoritmo nomeado como uma divisão eucli-

diana. Essa divisão serve de base para o Algoritmo de Euclides, que pode ser usado de forma

eﬁciente para o cálculo do máximo divisor comum entre dois números.

Teorema 2.1.1. Divisão Euclidiana. Sejam a e b dois números inteiros com b (cid:54)= 0. Existem

dois únicos números q e r tais que

a = bq + r, com 0 ≤ r <| b | .

A unicidade de q e r é comprovada da seguinte forma. Suponha que

a = bq + r = bq(cid:48) + r(cid:48), onde q, q(cid:48), r, r(cid:48) ∈ Z, com 0 ≤ r <| b | e 0 ≤ r(cid:48) < b.

Assim, tem-se que

− | b |< −r ≤ r(cid:48) − r ≤ r(cid:48) <| b | .

Por outro lado, b(q − q(cid:48)) = (r(cid:48) − r), o que implica que | b || q − q(cid:48) |=| r(cid:48) − r |<| b |, sendo

possível somente se q = q(cid:48) e, consequentemente, r = r(cid:48).

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

25

No teorema acima, os números q e r são chamados, respectivamente, de quociente e

resto da divisão de a por b. Esse quociente e resto sempre existem e são únicos.

Nos livros escolares de matemática, o método utilizado para o cálculo do mdc entre os

números a e b consiste em listar todos os divisores de a e todos os divisores de b. A seguir,

destaca-se o maior número na interseção entre os dois conjuntos. Não há nada de errado com

esse método, porém, torna-se impraticável com números grandes.

O objetivo do algoritmo euclidiano é calcular o máximo divisor comum entre dois nú-

meros inteiros. Este algoritmo é descrito por Euclides nas proposições 1 e 2 do Livro 7 dos

Elementos. Dados a e b inteiros positivos e que a ≥ b, deseja-se calcular o máximo divisor

comum entre a e b. O algoritmo euclidiano consiste em dividir a por b, achando o resto r1. Se

r1 (cid:54)= 0, divide-se b por r1, obtendo r2. Se r2 (cid:54)= 0, divide-se r1 por r2, obtendo o resto r3. E

assim sucessivamente até que o resto seja 0. O último resto diferente de zero é o máximo divisor

comum entre a e b. Veja o exemplo no quadro abaixo com o cálculo do máximo divisor comum

entre 240 e 162.

-

1

2

13

240

162

78

78

6

0

6

-

De acordo com a regra exposta anteriormente, o máximo divisor comum entre 240 e

162 é 6, ou seja, mdc(240, 162) = 6, que é o último resto não nulo da sequência de divisões.

Essa sequência sempre chega a um resto zero, pois, caso contrário, ter-se-ia uma sequência de

números naturais b > r1 > r2 > r3 . . . que não possui menor elemento, o que não é possível

pelo Princípio da Boa Ordenação.

2.2 Números Primos

Os números que somente possuem como divisores o número 1 e ele próprio são consi-

derados números primos. Dessa forma, os números 2, 3, 5, 7, 11, 13, 17 . . . são números primos.

Aqueles números que possuem mais de dois divisores são chamados de números compostos,

como os números 4, 6, 9, 15 . . .. Os números primos sempre despertaram grande interesse aos

estudiosos e diversos questionamentos a respeito ainda são um mistério.

Muitos problemas ainda estão em aberto quando o assunto é número primo. Não se tem

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

26

resposta sobre a possibilidade de existirem inﬁnitos números primos gêmeos, ou seja, pares de

números ímpares primos, cuja diferença é dois entre eles. Também não se sabe se a sequência de

Fibonacci (sequência iniciada em 0 e 1 em que cada termo equivale à soma dos dois números

subsequentes) contém inﬁnitos números primos. Ou ainda, sobre a possibilidade de sempre
existir um número primo entre n2 e (n + 1)2 para qualquer n ∈ N. Há ainda o seguinte

questionamento: para n = 0, 1, 2, 3, 4, . . . , 40, tem-se que n2 − n + 41 é primo. Para n = 41,

esta aﬁrmação não procede; porém o questionamento é sobre a existência de inﬁnitos números

primos dessa forma.

O que se percebe é que os números primos ainda são cercados de problemas em aberto

e outros tantos recentemente esclarecidos. Esse mistério sempre despertou a curiosidade dos

estudiosos e, atualmente, é a base para o Sistema de Criptograﬁa RSA, temática estudada no

próximo capítulo. Antes disso, serão estudados mais alguns pontos sobre os números primos e

outros conteúdos matemáticos essenciais para entender como funciona o Sistema RSA.

2.2.1 Teorema Fundamental da Aritmética

Como visto, um número natural maior do que 1 que só possui como divisores 1 e ele

próprio é um número primo. Esses números são suﬁcientes para gerar todos os outros. Isso

consiste no Teorema Fundamental da Aritmética, demonstrado abaixo por Hefez (2016, p. 123)

Teorema 2.2.1 (Teorema Fundamental da Aritmética). Todo número natural maior do que 1 ou

é primo ou se escreve de modo único como um produto de números primos.

Demonstração. Usaremos a segunda forma do Princípio de Indução. Se n = 2, o resultado é

obviamente veriﬁcado. Suponha-se o resultado válido para todo número natural menor do que n

e vamos provar que vale para n. Se o número n é primo, nada temos a demonstrar. Suponhamos,

então, que n seja composto. Logo, existem números naturais n1 e n2 tais que n = n1n2, com

1 < n1 < n e 1 < n2 < n. Pela hipótese de indução, temos que existem números primos

p1, . . . , pr e q1, . . . , qs tais que n1 = p1 . . . pr e n2 = q1 . . . qs. Portanto, n = p1 . . . prq1 . . . qs.

Vamos, agora, provar a unicidade da escrita. Suponha que tenhamos n = p1 . . . pr =

q1 . . . qs, onde os pi e os qj são números primos. Como p1|q1 . . . qs, temos que p1 = qj

para algum j, que, após reordenamento de q1, . . . , qs, podemos supor que seja q1. Portanto,

p2 . . . pr = q2 . . . qs. Como p2 . . . pr < n, a hopótese de indução acarreta que r = s e os pi e qj

são iguais aos pares.

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

27

2.2.2 Inﬁnidade dos Primos

Euclides, no Livro IX dos Elementos, já demonstrava que os números primos são in-

ﬁnitos. Ele faz a demonstração através da redução ao absurdo. Segue abaixo o teorema e a

demonstração:

Teorema 2.2.2. Existem inﬁnitos números primos.

Demonstração. Suponha que exista um número ﬁnito de números primos p1, p2, . . . , pr. Con-

sidere o número natural n = p1p2...pr + 1. Pelo Teorema Fundamental da Aritmética, o número

n possui um fator primo p que, portanto, deve ser um dos p1, p2, . . . , pr e, consequentemente,

divide o produto p1p2...pr. Mas isto implica que p divide 1, o que é absurdo.

Sabe-se, então, que existem inﬁnitos números primos. Com essa informação, outros

problemas importantes (sem resposta até o momento) surgem:

(i) há um padrão na distribuição dos números primos?

(ii) quando são considerados números cada vez maiores, a presença dos números primos

aumenta ou diminui?

(iii) há alguma regularidade nessa "densidade"?

(iv) há alguma forma de medir essa "densidade"?

Muitas foram as tentativas de se responder a estas e outras perguntas, além da tenta-

tiva de se contabilizar os números primos até certa numeração, porém, não se obteve método

eﬁciente para tal ﬁnalidade. A seguir, será visto algumas tentativas.

2.2.3 Métodos para Encontrar Números Primos

Um dos métodos mais antigos para se encontrar números primos é o método chamado

Crivo de Eratóstenes, criado pelo matemático grego Eratóstenes, antes de Cristo. Nicômaco

descreve o crivo de Eratóstenes em seu livro Aritmética da seguinte forma:

O método para obtê-los [os números primos] é chamado por Eratóstenes uma peneira,

porque tomamos os números ímpares misturados de maneira indiscriminada e, por este método,

como se fosse pelo uso de um instrumento ou peneira, separamos os primos ou indecomponíveis

dos secundários ou compostos. (NICÔMACO, apud COUTINHO, 2014, p. 62).

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

28

O crivo determina todos os números primos até um certo número natural n. O crivo

funciona da seguinte forma: Listam-se os números ímpares de 3 a n, isso porque 2 é o único

número par primo. O primeiro número da lista é 3, destaca-se este e riscam-se os demais

números da lista, de 3 em 3. Assim, riscam-se todos os múltiplos de 3. Na sequência, passa-se

para o menor elemento dessa lista, com exceção de 3, que não tenha sido riscado, ou seja, o

número 5. Destaca-se o número 5 e riscam-se os demais números da lista, de 5 em 5. Dessa

forma, eliminam-se todos os múltiplos de 5. Segue-se nesse ritmo até chegar ao número n.

Por exemplo, se n = 48, a lista de números é

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47.

Ao ﬁnal da primeira passagem, riscando de 3 em 3, tem-se

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47.

Ao ﬁnal da segunda passagem, riscando de 5 em 5, tem-se

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47.

Ao ﬁnal da terceira passagem, riscando de 7 em 7, nada é modiﬁcado na lista, assim

como pela quarta passagem, riscando de 11 em 11. Na verdade, mais nenhum número será

eliminado e a lista de números primos menores que 48 é

3 5 7 11 13 17 19 23 29 31 37 41 43 47.

Há de se destacar que a partir da terceira passagem não se eliminou mais nenhum nú-

mero, ou seja, todas as passagens seguintes foram desnecessárias. O que leva a imaginar que

não há necessidade de riscar os números até chegar ao número n, ou seja, há algum momento

em que se podem parar de riscar os números.

Coutinho (2014, p. 63-64) aponta que é possível parar de riscar bem antes de se chegar

a n. Ele aduz que, se m é um inteiro da lista, então m ≤ n. se m for composto, então terá um

fator menor ou igual a

√

m. Porém,

√

m ≤

√

n. Dessa forma, qualquer número composto da

lista tem um fator menor ou igual a

√

n. Conclui-se que não há necessidade de riscar números

de q em q, quando q >

√

n. No exemplo anterior poderia parar em de riscar de 5 em 5, uma vez

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

29

√

que

48 < 7.

Claro que o crivo de Eratóstenes não é viável quando se deseja encontrar números pri-

mos muito grandes. Essa nem é a intenção do crivo; este encontra os números primos até n.

Dessa forma, não se pode dizer que o crivo não seja eﬁciente; na verdade ele é, pois vale-se de

algoritmos simples para se chegar ao objetivo.

2.2.4 Números de Fermat e de Mersenne

Os números de Fermat são da forma Fn = 22n + 1, n = 0, 1, 2, . . .. Fermat conjecturou

que os números dessa forma seriam todos primos. Para os valores de n entre 0 e 6, os números

de Fermat são 3, 5, 17, 257, 65537, 4294967297 e 18446744073709551617. De fato, para n =

0, 1, 2, 3, 4, os números de Fermat são primos e, por isso, são chamados primos de Fermat.
Porém, quando n = 5, tem-se que Fn = 225 + 1 = 4294967297 = 641 × 6700417, sendo

composto, desacreditando a aﬁrmação de Fermat. Ainda não se sabe se existem outros primos

de Fermat além desses cinco primeiros.

Outros números especiais são os números de Mersenne, escritos da seguinte forma Mp =

2p − 1, onde p é um número primo. Hefez (2016, p. 145) explica o seguinte sobre os números

de Mersenne:

No intervalo 2 ≤ p ≤ 5000 os números de Mersenne que são primos, chamados de

primos de Mersenne, correspondem aos seguintes valores de p:

2, 3, 5, 7, 13, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253 e 4423.

Até o ano de 2016, o maior número primo conhecido era o número de Mersenne M57885161,

descoberto em janeiro de 2013, e que possui no sistema decimal 17425170 de dígitos.

Para se encontrar números primos grandes, as fórmulas exponenciais são as mais propí-

cias. Através dos números de Fermat e, principalmente, dos números de Mersenne os matemá-

ticos vêm encontrando números primos cada vez maiores; inclusive o maior número primo até

2016, como falado anteriormente, é um número de Mersenne. No número de Mersenne, se n é

composto, então M (n) também será composto.

Demonstração. Se n = rq, então

2n − 1 = (2r)q − 1 = (2r − 1)(2r(q−1)) + 2r(q−2) + · · · + 2r + 1).

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

30

Portanto, M (r) é fator de M (n) = M (rq). Claro que M (q) também é um fator de M (n).

Então, somente se encontram números primos através dos números de Mersenne com M (n),

com n primo. O que não garante que todos os números de Mersenne com M (n), com n primo

sejam também primos. O que garante é um caminho possível para se encontrar cada vez maiores

números primos.

2.3 Aritmética modular

2.3.1 Congruência e Propriedade

Diz-se que dois números a e b são congruentes módulo m quando o resto da divisão de

a e b por m resulta no mesmo número, sendo representado por a ≡ b mod m. Como exemplo,

tem-se que 31 ≡ 43 mod 4, pois o resto da divisão de 31 por 4 é o mesmo resto da divisão

de 43 por 4. Quando essa aﬁrmação não for verdadeira, diz que não são congruentes, ou seja,

a (cid:54)≡ b mod m.

Hefez (2016, p. 166) aduz que não há necessidade de efetuar a divisão euclidiana para

saber se dois números são congruentes módulo m. Basta aplicar a seguinte proposição:

Proposição 2.3.1. Suponha que a, b, m ∈ Z, com m > 1. Tem-se que a ≡ b mod m se, e

somente se, m|b − a.

Demonstração. Sejam a = mq + r, com 0 ≤ r < m e b = mq(cid:48) + r(cid:48), com 0 ≤ r(cid:48) < m, as

divisões euclidianas de a e b por m, respectivamente. Logo, b−a = m(q(cid:48)−q)+(r(cid:48)−r). Portanto,

a ≡ b mod m se, e somente se, r = r(cid:48) o que, em vista da igualdade acima, é equivalente a

dizer que m|b − a, já que |r − r(cid:48)| < m.

A congruência módulo um número inteiro m é uma relação de equivalência. Decorre

então as seguintes situações:

(i) a ≡ a mod m;

(ii) se a ≡ b mod m, então b ≡ a mod m;

(iii) se a ≡ b mod m e b ≡ c mod m, então a ≡ c mod m;

(iv) se a ≡ b mod m e c ≡ d mod m, então ac ≡ bd mod m;

(v) se a ≡ b mod m, então an ≡ bn mod m.

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

31

Para demonstrar esta última proposição, basta fazer por indução em n. Para a proposição

iv, Hefez (2016, pág. 168) indica que basta notar que bd − ac = d(b − a) + a(d − c), de onde

se conclui que m|bd − ac.

A congruência é uma relação importante de equivalência na adição e na multiplicação

dos números inteiros, como serão mostradas nas proposições a seguir:

Proposição 2.3.2. Sejam a, b, c, d, m ∈ Z, com m > 1.

(i) Se a ≡ b mod m e c ≡ d mod m, então a + c ≡ b + d mod m.

(ii) Se a ≡ b mod m e c ≡ d mod m, então ac ≡ bd mod m.

Demonstração. Suponhamos que a ≡ b mod m e c ≡ d mod m. Logo, tem-se que m|b − a e

m|d − c. i) Observa-se que m|(b − a) + (d − c) e, portanto, m|(b + d) − (a + c), o que prova

este resultado; ii) Deve-se notar que bd − ac = d(b − a) + a(d − c) e concluir que m|bd − ac.

A proposição seguinte mostra que o cancelamento sempre é válido com relação à adição

na congruência modular.

Proposição 2.3.3. Sejam a, b, c, m ∈ Z, com m > 1. Tem-se que a + c ≡ b + c mod m ⇔ a ≡

b mod m.

Demonstração. Se a ≡ b mod m, segue-se, das proposições anteriores que a+c ≡ b+c mod m,

pois c ≡ c mod m. Reciprocamente, se a + c ≡ b + c mod m, então, m|b + c − (a + c) ≡

b + c mod m, o que implica que m|b − a e, assim, a ≡ b mod m.

Como visto anteriormente, todo número inteiro é congruente módulo m ao seu resto.

Assim, á congruente a um dos números 0, 1, 2, 3, . . . , m − 1, sendo que dois desses números

diferentes não são congruentes módulo m. Com essa informação, é possível aﬁrmar que, para

encontrar o resto de uma divisão de um inteiro por m, somente é preciso encontrar um número

natural de 0 a m − 1 que seja congruente a a módulo m.

Hefez (2016, p. 167) aponta que um sistema completo de resíduos módulo m refere-se a

todo conjunto de números inteiros cujos restos pela divisão por m são os números 0, 1, 2, 3, . . . , m−

1, sem repetições e numa ordem qualquer. Assim, um sistema completo de resíduos módulo m

possui m elementos.

As proposições apresentadas até então servirão de apoio para a apresentação de um

teorema importante: Pequeno Teorema de Fermat.

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

32

Teorema 2.3.1 (Pequeno Teorema de Fermat). Dado um número primo p e a um natural não

divisível por p, tem-se que p divide o número ap−1 − 1.

Demonstração. Considerando os p − 1 múltiplos de a, tem-se: a, 2a, 3a, . . . , (p − 1)a. Sabe-se

que nenhum desses números é congruente módulo p com outros deles e nem congruentes a zero

módulo p. Tomando ra ≡ as mod p, com 1 ≤ r ≤ s ≤ (p−1), como p−a, temos r ≡ s mod p,

o que é uma contradição. Assim, tais números formam um sistema completo de resíduos. Logo,

eles são congruentes a 1, 2, 3, . . . , (p − 1) em alguma ordem. Dessa forma,

a × 1 × (2a) × (3a) . . . (p − 1)a ≡ 1 × 2 × 3 × . . . × (p − 1) mod p,

onde

ap−1(1 × 2 × 3 × . . . × (p − 1)) ≡ 1 × 2 × 3 × . . . × (p − 1) mod p.

Observa-se que o mdc(p, 1 × 2 × 3 × . . . × (p − 1)) = 1, segue-se que ap−1 ≡ 1 mod p.

De acordo com Hefez (2016, p. 137), o Pequeno Teorema de Fermat, "fornece-nos um
teste de não primalidade. De fato, dado m ∈ N, com m > 1, se existir algum a ∈ N, com

mdc(a, m) = 1, tal que m não divide am−1 − 1, então m não é primo".

2.4 Teorema de Euller

Será apresentado neste momento o Teorema de Euller. Este teorema e suas implicações

são de fundamental importância para o estudo dos sistema de criptograﬁa apresentados no pró-

ximo capítulo. Para chegar ao Teorema de Euller, deve-se apresentar primeiramente que um

sistema reduzido de resíduos módulo m é um conjunto de números inteiros r1, r2, . . . , rs tais

que:

(i) mdc(ri, m) = 1, para todo i = 1, 2, 3, . . . , s;

(ii) ri (cid:54)≡ rj mod m, se i (cid:54)= j;

(iii) Para cada n ∈ Z tal que mdc(n, m) = 1, existe i tal que n ≡ ri mod m.

Para obter um sistema reduzido de resíduos r1, r2, . . . , rs módulo m, pode-se utilizar um sistema

completo de resíduos a1, a2, . . . , as módulo m, eliminando-se os elementos ai que não são

primos com m. Será designado por ϕ(m) o "número de elementos de um sistema reduzido de

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

33

resíduos módulo m > 1, que corresponde à quantidade de números naturais entre 0 e m − 1 que

são primos com m."(HEFEZ, 2016, p. 195). Colocando ϕ(1) = 1, isso deﬁnira um importante

função dada por:

ϕ : N → N (denominada função ﬁ de Euler).

Pela deﬁnição, tem-se que:

ϕ(m) ≤ m − 1, para todo m ≥ 2.

Deve-se chamar atenção para o seguinte fato: se m ≥ 2, então ϕ(m) = m − 1 se e

somente se, m é um número primo. Realmente, m é primo se, e somente se, 1, 2, . . . , m − 1

formam um sistema reduzido de resíduos módulo m, ou seja, ϕ(m) = m − 1.

Para calcular ϕ(m), segue-se a seguinte proposição:

Proposição 2.4.1. Sejam r, s ∈ N tais que mdc(r, s) = 1. Então,

ϕ(r.s) = ϕ(r)ϕ(s).

Demonstração. Para r = 1 e s = 1 o resultado é trivial. Supondo então que r > 1 e s > 1,

observa-se a construção de uma tabela formada pelos números naturais de 1 e (r × s):

1

2

s + 1
...
(r − 1)s + 1

s + 2
...
(r − 1)s + 2

. . .

. . .
...
. . .

k

s + k
...
(r − 1)r + k

. . .

. . .
...
. . .

s

2s
...
r × s

Como se tem mdc(t, r × s) = 1 se, e somente se, mdc(t, r) = mdc(t, s) = 1, para calcular

ϕ(r.s), deve-se destacar aqueles números da tabela que são primos com r e com s. Hefez (2016,

p. 199) aponta que, se o primeiro número de uma coluna não for primo com s, então os demais

elementos destas colunas também não serão. Conclui-se que os números primos com s estão

nas colunas restantes em número de ϕ(s), com elementos que são primos com s. Deve-se,

agora, saber quais elementos das colunas restantes são primos com r. Como mdc(r, s) = 1,

então, a sequência k, s + k, . . . , (r − 1)s + k forma um sistema completo de resíduos módulo m

e, assim, ϕ(r) desses números são primos com r. Dessa forma, o número de elementos primos

ao mesmo tempo com 4r e s é ϕ(r).ϕ(s).

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

34

Por exemplo, se se deseja descobrir quais os números menores ou iguais a 65 que são

primos com este, ou seja, quanto é ϕ(65), deve-se fazer o seguinte:

ϕ(5).ϕ(13) = 4.12 = 48.

Com as informações acima, chega-se ao Teorema de Euler, descrito abaixo com a de-

monstração trazida por Hefez (2016, p. 197)

Teorema 2.4.1 (Teorema de Euler). Sejam m, a ∈ Z com m > 1 e mdc(a, m) = 1. Então,

aϕ(m) ≡ 1 mod m.

Demonstração. Seja r1, r2, . . . , rϕ(m) um sistema reduzido de resíduos módulo m. Logo,

ar1, ar2, . . . , arϕ(m) formam um sistema reduzido de resíduos módulo m e, portanto,

ar1, ar2, . . . , arϕ(m) ≡ r1, r2, . . . , rϕ(m) mod m.

Com isso,

aϕ(m)r1 × r2 × . . . × rϕ(m) = ar1 × ar2 × . . . × arϕ(m) ≡ r1 × r2 × . . . × rϕ(m) mod m.

Como (r1 × r2 × . . . × rϕ(m), m) = 1, segue-se que

aϕ(m) ≡ 1 mod m.

O Pequeno Teorema de Fermat é um caso particular do Teorema de Euler, uma vez

que enquanto o Teorema de Fermat trabalha com congruências envolvendo módulo primo, o

Teorema de Euler lida com módulos em números compostos. Basta notar que, se p é primo,

então, ϕ(p) = p − 1.

Teorema 2.4.2 (Pequeno Teorema de Fermat). Sejam a ∈ Z e p um número primo tais que

mdc(a, p) = 1. Tem-se que

ap−1 ≡ 1 mod p.

Utilizando os teoremas e suas consequências, qual o resto da divisão de 5103 por 33?

Note que

ϕ(33) = ϕ(3 × 11) = ϕ(3) × ϕ(11) = 2 × 10 = 20.

CAPÍTULO 2. NÚMEROS PRIMOS E A ARITMÉTICA MODULAR

35

Pelo Teorema de Euler, tem-se que 520 ≡ 1 mod 33, logo,

5103 = 520×5+3 ≡ 26 mod 33.

Portanto, 26 é o resto da divisão de 5103 por 33.

CAPÍTULO 3

Criptograﬁa RSA

O método mais conhecido de criptograﬁa de chave pública é o RSA. Ao contrário da

Difﬁe-Hellman, ela teve bastante sucesso porque era simples e muito segura. Apesar dos pro-

blemas informáticos associados à codiﬁcação e decodiﬁcação de mensagens, a RSA "foi criada

em um momento conveniente quando os computadores estavam recebendo um investimento

tecnológico"(KAHN, 1996, p. 251).

Este código foi inventado em 1978 por R. L. Rivest, A. Shamir e L. Adleman,

que na época trabalhavam no Massachussets Institute of Technology (M.I.T.). As

letras RSA correspondem às iniciais dos inventores do código. Há vários outros

códigos de chave pública, mas a RSA é, atualmente, o mais usado em aplicações

comerciais. Este é o método utilizado, por exemplo, no Netscape, o mais popular

dos softwares de navegação da Internet (COUTINHO, 2014, p. 3).

De fato, desde seu início, a criptograﬁa RSA é encontrada em várias implementações

de computadores, tais como segurança de bancos de dados bancários, tráfego de informações

conﬁdenciais em redes abertas e protocolos de comunicação na Internet, principalmente no

comércio eletrônico.

O sucesso da Era da Informação depende da capacidade de proteger essas in-

formações enquanto elas ﬂuem ao redor do mundo e isto depende do poder da

36

CAPÍTULO 3. CRIPTOGRAFIA RSA

37

criptograﬁa. A cifragem pode ser vista como a fonte das chaves e trancas da Era

da Informação. Durante dois mil anos ela foi importante apenas para o governo e

os militares, mas hoje ela também tem um papel a desempenhar na facilidade dos

negócios e, no futuro, pessoas comuns dependerão da criptograﬁa para proteger sua

privacidade. (SINGH, 1999 p. 318)

O princípio baseia-se na relativa facilidade em encontrar números primos grandes e ao

mesmo tempo na enorme diﬁculdade prática em fatorar o produto de dois desses números, além

do uso de propriedade relativamente elementares da Teoria dos Números, como a variante do

Teorema de Euler. (HEFEZ, 2016, p. 274)

De uma maneira muito introdutória e conversadora, a codiﬁcação RSA funciona da se-

guinte maneira: dois números primos p1 e p2, de preferência grandes, são selecionados, e, a

seguir, é feito o cálculo n = p1 × p2. Então um número menor que n e que seja primo é

escolhido, chamado aqui de e. Deve-se divulgar estes números n e e, uma vez que eles são

necessários para a cifragem da mensagem, sendo consideradas chaves públicas. A mensagem a

ser enviada é convertida em um número M e cifrada para produzir o texto C, de acordo com a

fórmula C = M mod N . Para decifrar, basta encontrar o número f , que é o módulo inverso a

ϕ(n).

Para poder implementar o RSA precisamos de dois parâmetros básicos: dois

números primos que vamos chamar de p e q. Para codiﬁcar uma mensagem usando

RSA é suﬁciente conhecer o produto dos dois primos, que vamos chamar de n.

Para decodiﬁcar uma mensagem precisamos conhecer os primos p e q. A chave

de codiﬁcação do RSA é portanto constituída essencialmente pelo número n = pq.

Cada usuário do método tem sua própria chave de codiﬁcação. Esta chave é tornada

pública: todos ﬁcam sabendo que, para mandar uma mensagem para o banco Acme,

deve ser usada a chave n. Por isso, n também é conhecida como "chave pública".

Já a chave de decodiﬁcação é constituída pelos primos p e q. Cada usuário tem

que manter sua chave de decodiﬁcação secreta ou a segurança do método estará

comprometida. (SINGH, 2007, p. 4)

Naturalmente, para o leitor ilegítimo, a explicação acima é bastante complicada, e os

objetos exibidos nela, bem como os resíduos de ﬁssão, podem parecer matemáticas avançadas e

tediosas. Os matemáticos tinham que realizar este cálculo de uma maneira simples e demonstrar

a segurança desta criptograﬁa.

CAPÍTULO 3. CRIPTOGRAFIA RSA

38

3.1 Tipos de Chaves

A RSA consiste em uma criptograﬁa de chave pública, portanto, ela deve ter duas cha-

ves: pública e privada. Esta chave pública pode ser revelada a qualquer pessoa sem compro-

meter a segurança do código. Com ele, os remetentes podem criptografar suas mensagens para

serem lidas pelo destinatário com sua chave privada.

Para tornar as chaves públicas e privadas, você deve selecionar o número primo. Nor-

malmente apenas dois números primos (u = 2) são escolhidos para as chaves, e quando se faz

esta escolha chamamos isso de criptograﬁa RSA dupla. "Quando mais de dois primos (u > 2)

são selecionados, chamamos de codiﬁcação multiprime RSA"(KAHN, 1996). Ao importar o

número de primos utilizados, deve-se ter em mente que a escolha dos primos é feita pelo desti-

natário da mensagem, e de preferência em segredo.

Uma vez selecionados os primos, a primeira chave que pode ser feita é a chave pú-

blica. Para ﬁns de criptograﬁa RSA, a chave pública consiste em dois números: n, chamado

de módulo RSA; e, chamado de display público. Por deﬁnição, n é o produto de todos os

primos selecionados, ou seja, n = p1 × p2 × . . . × pu. Para o número e, com e < n e

mdc(e, ϕ(n)p1 × p2 × . . . × pu) = 1. Em forma simpliﬁcada, deve-se:

n = p1 × p2 × . . . × pu,

(n, e) = {e; mdc(e, ϕ(n)) = 1}.

O par (n, e) é a chave pública da codiﬁcação RSA em questão.

A decodiﬁcação requer uma chave privada. Para os primos que compõem a chave pú-

blica, a chave privada RSA consiste em dois números: n, novamente o módulo RSA, e f ,

chamado de display privado RSA. O valor de n é igual à chave pública, onde n = p1 × p2. Para

o cálculo de f deve-se encontrar o inteiro positivo inverso do número e em ϕ(n). O par (n, d)

é a chave privada de criptograﬁa RSA em questão.

3.2 Processo de Codiﬁcação

Uma vez recebidas as chaves públicas e privadas, você pode criptografar suas mensa-

gens. O remetente recebe do destinatário a chave pública, que não deve ser enviada em segredo,

sem comprometer a segurança do código. O processo de codiﬁcação ou codiﬁcação é feito em

CAPÍTULO 3. CRIPTOGRAFIA RSA

39

duas etapas: Criptograﬁa e criptograﬁa preditiva.

Para acelerar a cifragem e a decifragem, Zimmermann empregou um truque há-

bil que usa a cifragem assimétrica RSA associada com a velha cifragem simétrica.

A cifragem simétrica tradicional pode ser tão segura quanto a cifragem assimétrica

e é muito mais rápida de ser feita, mas sofre com a necessidade de exigir a distri-

buição de uma chave, que terá que ser transportada em segurança do remetente ao

destinatário. é aí que a RSA vem em nossa ajuda, porque ela pode ser usada para

cifrar a chave simétrica. (SINGH, 1999, 324).

Na pré-codiﬁcação, a mensagem a ser enviada deve ser processada de tal forma que

possa ser modiﬁcada utilizando aplicações em fórmulas matemáticas, o que signiﬁca converter

a mensagem em uma sequência de números que formam um número completo (COUTINHO,

2014, p. 181). Há várias maneiras de fazer isso, que variam de acordo com as necessidades.

Por exemplo, o próprio documento de padronização da RSA menciona o OS21P (Octec-

String-to-lnteger-Primitive), que converte dados de uma forma octal para um número inteiro

positivo. Isto porque este documento se refere à criptograﬁa usada em computadores que tra-

balham com seus dados em forma de bits e bytes e, portanto, em agrupamento de 8 bits (forma

octal). No campo dos compactadores, há outra forma de converter caracteres não numéricos em

inteiros positivos, então, tem-se uma tabela ASCII (American Standard Code for lnformation

lnterchange), que corresponde a cada caractere legível por computador, um inteiro de O a 255.

(CAHN, 1996)

Mas não há obrigação de utilizar uma certa conversão de dados. é importante manter

o método entre o remetente e o receptor. Neste trabalho, será utilizada uma conversão muito

simples, pedagógica, de contagem de cartas sugerida por Cutião (2007), de acordo com a tabela

abaixo:

A B C D E

F G H

I

J

K L M

10 11

12 13 14

15 16 17

18 19 20

21 22

N O P Q R

S

T U V W X Y Z

23 24

25 26 27

28 29 30

31 32 33

34 35

CAPÍTULO 3. CRIPTOGRAFIA RSA

40

Nesta transformação, os espaços entre as palavras são representados pelo número 99.

Após converter os dados em inteiros correspondentes, o número longo resultante deve ser divi-

dido em blocos de outros inteiros, com números sempre abaixo de n (módulo RSA) e o maior

número possível.

Com uma mensagem pré-codiﬁcada, pode-se realizar a codiﬁcação. Uma vez codiﬁcada

a mensagem, é exibida uma sequência de blocos de números que devem ser processados um

após o outro. E a mensagem codiﬁcada com a chave pública (n, e) representada por (Cn,e) é

uma concatenação de blocos Cn, ou seja:

Cn,e = Cn,e1Cn,e2 . . . Cn,ez .

3.3 Processo de Decodiﬁcação

O processo de decodiﬁcação é semelhante à codiﬁcação reversa e é feito em uma única

etapa. Com a chave privada (n, f ), o destinatário pode decodiﬁcar as mensagens usando exposi-

ção e álgebra modular. A primeira etapa de decodiﬁcação é reorganizar a mensagem criptogra-

fada recebida em blocos inteiros. Da mesma forma, uma mensagem numérica deve ser dividida

em blocos de números inteiros menores do que n e em blocos maiores. Isto é possível, ou seja,

a sequência de blocos deve ser obtida novamente. Alterou a ordem dos blocos de números e a

propriedade da chave privada (n, d). Você obtém os blocos originais com o resto da divisão af

por n, onde a, refere-se a cada bloco codiﬁcado.

A seguir, será mostrado como a operação anterior nos devolve aos blocos de origem das

mensagens. É interessante notar que os processos de codiﬁcação e decodiﬁcação são matemati-

camente opostos, mas é impossível derivar um do outro sem conhecer o primo do qual as chaves

são feitas. Após decodiﬁcar os blocos, eles devem ser concatenados para obter uma codiﬁcação

preliminar ao longo de todo o comprimento. Ou até mesmo: P (cid:48) = P (cid:48)

1P (cid:48)

2 . . . P (cid:48)
z.

Após a concatenação, deve-se realizar um processo de pré-codiﬁcação reversa usando a

conversão reversa e receber a mensagem original novamente.

Para facilitar a compreensão e mostrar que os processos de codiﬁcação e decodiﬁcação

são matematicamente opostos, serão dados dois exemplos. Um primeiro mais simples, para

efeito de exercício da teoria, deve-se codiﬁcar/decodiﬁcar a mensagem PRIMO.

Escolhida a mensagem PRIMO, deve-se pré-codiﬁcar de acordo com uma tabela. Nessa

pré-codiﬁcação, será utilizada a seguinte tabela de conversão, com cada letra correspondendo a

CAPÍTULO 3. CRIPTOGRAFIA RSA

41

um número de dois algarismos e o espaço entre as palavras pelo número 99.

A B C D E

F

G

H

I

J

K L M

10 11

12 13 14

15 ; 16

17 18 19

20 21 22

N O P Q R

S

23 24

25 26 27

28

T

29

U V W X Y Z

30 31 32

33 34 35

Na tabela, foram consideradas apenas letras maiúsculas, e mais o espaço cujo código foi

convencionado como 99. Então, a mensagem pré-codiﬁcada ﬁca assim:

2527182224.

Utilizando os parâmetros do sistema RSA, escolhem-se dois números primos distintos, denota-

dos aqui por p e q. Seja n = pq. Para este exemplo, tem-se que p = 7 e q = 17, então n = 119.

Agora, deve-se quebrar em blocos o número produzido anteriormente, de forma que os blocos

sejam menores que n. Não existe uma única forma de quebrar esses números em blocos, mas se

devem evitar algumas situações, como iniciar um bloco por 0 (zero). A mensagem codiﬁcada,

então, ﬁcará com os seguintes blocos de números:

25 − 27 − 18 − 22 − 24.

Após a etapa de pré-codiﬁcação, passa-se a codiﬁcação em si. Para codiﬁcar a mensa-

gem, necessita-se de n, que é o produto dos primos q e r, e de um inteiro positivo e que seja

inversível módulo ϕ(n). Ou seja, mdc(e, ϕ(n)) = 1. Como visto no capítulo anterior, deve-se

calcular ϕ(n), sabendo que

ϕ(n) = ϕ(p) × ϕ(q) = (p − 1)(q − 1).

Cada bloco b é codiﬁcado assim: C(b) = be mod n, onde e representa o elemento que compõe a

chave pública (e, n). Neste caso, foi considerado e = 3 como expoente de cada código de letra,

uma vez que 3 é um dos coprimos com ϕ(n) = ϕ(119). Agora devem ser calculados os termos

b do bloco numérico.

CAPÍTULO 3. CRIPTOGRAFIA RSA

42

B1 25: 255 mod 119 = 9.765.625 mod 119 = 9

B2 27: 275 mod 119 = 14.348.907 mod 119 = 6

B3 18: 185 mod 119 = 1.889.568 mod 119 = 86

B4 22: 225 mod 119 = 5.153.632 mod 119 = 99

B5 24: 245 mod 119 = 47.962.624 mod 119 = 96.

Obtém-se, assim, a seguinte sequência de blocos:

9 − 6 − 86 − 99 − 96.

Na etapa de decodiﬁcação, é calculado o parâmetro da chave privada (d, n). Neste caso

só cálculos matemáticos envolvem aritmética modular, conceitos de inversibilidade de módulos

de números. Para esses valores de p e q, basta aplicar o algoritmo estendido de Euclides a e e

ϕ(n). Para o exemplo acima, obtém-se

96 = 5 × 19 + 1, de onde 1 = 96 + (−19) × 7.

Logo o inverso de 5 módulo 96 é −19. Porém, se se deseja f positivo para ser usado na potência,

de forma que f = 96 − 19 = 77, que é o menor inteiro positivo congruente a 96. Dessa forma,

para decodiﬁcar o primeiro bloco da mensagem codiﬁcada −9−, calcula-se a forma reduzida

de 977 mod 119, como segue abaixo:

C1 9: 977 mod 119 = 2, 99690673E + 73 = 25

C2 6: 677 mod 119 = 8, 27268102E + 59 = 27

C3 86: 8677 mod 119 = 9, 04442050E + 148 = 18

CAPÍTULO 3. CRIPTOGRAFIA RSA

43

C4 99: 9977 mod 119 = 4, 61221967E + 153 = 22

C5 96: 9677 mod 119 = 4, 31404771E + 52 = 24

A decodiﬁcação, assim, aponta para a mensagem original, de acordo coma tabela apre-

sentada: PRIMO.

Para complementar o estudo sobre o sistema RSA, mais um exemplo será dado. Isto

exige que dois professores da UFS, indicados aqui por PRO-I (Itabaiana) e por PRO-SC (São

Cristóvão) estejam distantes e que precisam compartilhar informações sensíveis de forma se-

gura. Eles irão usar criptograﬁa e esta será a RSA dos dois primos. PRO-I é o remetente do

sistema, e PRO-SC é o receptor. O receptor é responsável pela criação das chaves públicas e

privadas.

Para usar o método RSA, é preciso inicialmente converter a mensagem em uma sequên-

cia de números. Para exempliﬁcar, será feita codiﬁcada uma mensagem sem a presença de

números, apenas palavras. Dessa forma, a mensagem é constituída pelas palavras e pelos espa-

ços entre elas. Nessa pré-codiﬁcação, será utilizada a seguinte tabela de conversão, com cada

letra correspondendo a um número de dois algarismos e o espaço entre as palavras pelo número

99.

A B C D E

F G H

I

J

K L M

10 11

12 13 14

15 16 17

18 19 20

21 22

N O P Q R

S

T U V W X Y Z

23 24

25 26 27

28 29 30

31 32 33

34 35

A mensagem a ser codiﬁcada por PRO-I é UNIVERSIDADE FEDERAL DE SERGIPE.

Utilizando os códigos acima, a frase ﬁcará da seguinte forma:

30231831142728181310131499151413142710219913149928142716182514.

Utilizando os parâmetros do sistema RSA, PRO-SC escolhe dois números primos distintos,

CAPÍTULO 3. CRIPTOGRAFIA RSA

44

denotados aqui por p e q. Seja n = pq. Agora, deve-se quebrar em blocos o número produzido

anteriormente, de forma que os blocos sejam menores que n. Para este exemplo, tem-se que

p = 7 e q = 17, então n = 119. Não existe uma única forma de quebrar esses números

em blocos, mas se devem evitar algumas situações, como iniciar um bloco por 0 (zero). A

mensagem codiﬁcada, então, ﬁcará com os seguintes blocos de números:

30 − 23 − 18 − 31 − 14 − 27 − 28 − 18 − 13 − 101 − 31 − 49 − 91 − 51 − 41 −

31 − 42 − 7 − 102 − 19 − 91 − 31 − 49 − 92 − 81 − 42 − 71 − 61 − 82 − 51 − 4.

Os blocos em que a mensagem foi quebrada não tem nenhuma unidade linguística e,

portanto, não pode ser decodiﬁcada por contagem de frequência. Diferentemente de outros

sistemas criptográﬁcos primitivos que utilizavam a troca de letras e/ou palavras e que fazia a

mensagem ter certa lógica devido as frequências de letras no alfabeto e ao agrupamento de

determinadas letras, como o Q e o U na língua portuguesa.

Após a etapa de pré-codiﬁcação, passa-se a codiﬁcação em si. Para codiﬁcar a mensa-

gem, necessita-se de n, que é o produto dos primos q e r, e de um inteiro positivo e que seja

inversível módulo ϕ(n). Ou seja, mdc(e, ϕ(n)) = 1. Como visto no capítulo anterior, deve-se

calcular ϕ(n), sabendo que

ϕ(n) = ϕ(p) × ϕ(q) = (p − 1)(q − 1).

O par (n, e) será a chave de codiﬁcação do sistema RSA. Essa é a chamada chave pública

e PRO-SC poderá divulgar tal chave. Cada bloco será codiﬁcado separadamente, e a mensagem

codiﬁcada será a sequência de blocos codiﬁcados. Seja b cada um dos blocos, este número é

um inteiro menor do que n. Para calcular a codiﬁcação de cada bloco deve-se conseguir o resto

da divisão de be por n. Ou seja, a codiﬁcação é a forma reduzida de be módulo n.

Voltando a mensagem considerada, tem-se que p = 7 e q = 17, logo n = 119 e ϕ(n) =

96. Para escolher o número e, neste exemplo vai se escolher 5 que é o menor número primo

que não divide 96. Assim, o primeiro bloco - 30 - da mensagem é codiﬁcado como o resto da

divisão de 305 por 119, ou seja, deve-se calcular 305 mod 119:

305 = 302 × 302 × 30 ≡ 67 × 67 × 30 ≡ 86 × 30 ≡ −33 × 30 ≡ −38 ≡ 81 mod 119.

Codiﬁcando toda a mensagem, obtém-se a seguinte sequência de blocos:

81 − 109 − 86 − 12 − 63 − 6 − 112 − 86 − 13 − 33 − 12 − 70 − 7 − 102 − 62 −

CAPÍTULO 3. CRIPTOGRAFIA RSA

45

12 − 77 − 28 − 51 − 66 − 7 − 12 − 70 − 113 − 30 − 77 − 22 − 108 − 80 − 102 − 72.

Para decodiﬁcar um bloco de mensagem codiﬁcada, PRO-SC deve ter duas informações:

os números n e o inverso de e em ϕ(n), chamado aqui de f . Ou seja, o para (n, f ) será a chave

de decodiﬁcação. Essa é a chamada chave privada.

Assim, a chave privada é construída. Uma vez que as chaves públicas e privadas tenham

sido construídas, PRO-SC não precisará manter seus primos encontrados e eles poderão ser des-

cartados. Na verdade, ele não deveria sequer ter que mantê-los comprometidos pela segurança

da criptograﬁa se esses primos forem encontrados por um hacker que possa facilmente encon-

trar os valores n, e, f . Rejeitar os primos é necessário para manter a segurança e não prejudica

o uso do código.

Ao fazer as chaves, o receptor PRO-SC revela a chave pública a PRO-I por meios não

seguros. Quem intercepta a chave pública é incapaz, de forma prática e rápida, de decifrar a

informação, podendo, no melhor dos casos, enviar a informação também para PRO-SC. PRO-I,

que recebe a chave pública, é capaz de enviar mensagens.

Para calcular a decodiﬁcação, precisa-se veriﬁcar o resto da divisão de af por n, sendo

a cada um dos blocos a serem decodiﬁcados. Assim, estar-se calculando a forma reduzida de

af módulo n.

Sendo n e e conhecidos, ﬁca fácil o cálculo de f . Basta aplicar o algoritmo estendido de

Euclides a e e ϕ(n). Para o exemplo acima, obtém-se

96 = 5 × 19 + 1, de onde 1 = 96 + (−19) × 7.

Logo o inverso de 5 módulo 96 é −19, porém se deseja f positivo para ser usado na potência,

de forma que f = 96 − 19 = 77, que é o menor inteiro positivo congruente a 96. Dessa forma,

para decodiﬁcar o primeiro bloco da mensagem codiﬁcada - 81 -, calcula-se a forma reduzida

de 8177 mod119. Neste caso, o cálculo deverá ser feito através de programas de computadores

adequados, uma vez que os valores diﬁcilmente são encontrados sem recursos tecnológicos.

3.4 Segurança

Em teoria é possível decifrar o código na criptograﬁa RSA, e qualquer pessoa com um

conhecimento mínimo de matemática pode fazer isso. A chave pública da RSA consiste nos

números n e e enquanto a chave privada, além de n, também tem um display privado f . Deve-

CAPÍTULO 3. CRIPTOGRAFIA RSA

46

se lembrar de que estes três números são compostos de primos escolhidos no início, enquanto

o número f depende do número e selecionado. Tanto n como d podem ser identiﬁcados pelos

primos escolhidos e pela exibição pública.

O único problema para a segurança da criptograﬁa de chave pública RSA é que,

em alguma época no futuro, alguém possa encontrar um modo rápido de fatorar. É

concebível que daqui a uma década, ou mesmo amanhã, alguém possa descobrir

um método para a fatoração rápida e aí a RSA se tornará inútil. Contudo, por

dois mil anos os matemáticos têm tentado e fracassado em encontrar um atalho, e

por enquanto, a fatoração continua sendo um cálculo muito trabalhoso. A maioria

dos matemáticos acredita que a fatoração é uma tarefa inerentemente difícil e que

existe alguma lei matemática que proíbe a existência de qualquer atalho. Vamos

presumir que eles estejam certos: deste modo, a RSA estará segura durante o futuro

previsível. (SINGH, 2005, p. 303)

Acontece que o número n é o produto de todos os primos utilizados para criar as chaves

públicas e privadas, e este número é revelado na chave pública (n, e). Usando o processo de

fatorar em números primos, n pode ser identiﬁcado e todos os primos encontrados.

Observe que a segurança do sistema de criptograﬁa na RSA depende dos primos gera-

dores selecionados (COUTINHO, 2014, p. 182). Se selecionados corretamente, eles podem

tornar o trabalho do criptanalista mais difícil. Por exemplo, para evitar que o número n seja

levado em conta de uma maneira possível, podemos escolher geradores de números primos. Há

implementações comerciais baseadas na RSA, com chaves públicas, cujo n módulo da RSA tem

2467 números (COUTINHO, 2007). Para considerar um número com tal tamanho, devem-se

esperar 101233 operações computacionais. Se o computador atual (3,0 GHz Quad Core) realiza

algo como 1012 operações por segundo, levaria até 101221 segundos para o fator n. Este tempo

corresponde a, pelo menos, 3, 2 × 10 anos.

Desde a implementação do sistema RSA, tem-se procurado informações mais

precisas a respeito dos métodos de fatoração, ainda sem sucesso, uma vez que o

sistema ainda não foi quebrado. Porém, ainda se sabe se quebrar o código RSA

signiﬁca necessariamente descobri a fatoração do número n ou se haveria outra

forma mais simples de se fazer. De toda forma, até então, não se teve sucesso em

quebrar o código utilizando outra técnica que não seja a fatoração de n. (SINGH,

1999, p. 317)

CAPÍTULO 3. CRIPTOGRAFIA RSA

47

Coutinho (2014, p. 187) aponta que não basta ter números primos grandes, há outro

ponto fundamental:

Um ponto importante refere-se à escolha dos primos p e q. É claro que se forem peque-

nos, o sistema será fácil de quebrar. Mas não basta escolhê-los grandes. De fato, se p e q são

grandes, mas |p − q| é pequeno, então é fácil fatorar n = pq usando o algoritmo de Fermat.

(COUTINHO, 2014, p. 187)

O módulo RSA n não deve ter mais de 2467 dígitos para garantir a segurança. Para tes-

tar a segurança do próprio código, o Laboratório RSA executa constantemente uma tarefa cha-

mada RSA Factoring Challenge, recompensando aqueles que alcançam o fator chave público

RSA disponível em seu website com uma pequena quantia em dólares. Um dos problemas em

1999 foi a inclusão de uma chave pública RSA de 512 bits (155 dígitos). A chave foi a seguinte

(RSA, 2000):

10941738641570527421809707322040357612003732945449205990913842131476349984288

934784717997257891267332497625752899781833797076537244027146743531593354333897.

Esta edição foi revista em agosto de 1999 por um grupo de usuários liderado por A.

Lenstra e H. te Riehl usando 300 computadores em série, o que levou sete meses de trabalho

(RSA, 2000). Mais tarde, em 2005, outro desaﬁo ofereceu um prêmio de fatorar de 641 bits

(193 dígitos), que exigiu cinco meses de trabalho utilizando 80 computadores (COUTINHO,

2007).

Há algoritmos que podem fatorar um módulo RSA não utilizado, bem como a neces-

sidade de levar em consideração os primos. Quando os primos p1 e p2 são tais que é difícil

considerar o módulo, RSA (2000) os chama de primos fortes.

Dependendo da ﬁnalidade da codiﬁcação, a RSA (2000) oferece um tamanho mínimo

para um módulo RSA. Para ﬁns comerciais, recomenda-se usar pelo menos 1024 bits (aproxi-

madamente 308 dígitos) e 2048 bits (mais de 615 dígitos) de chaves para dados sensíveis, tais

como transações ﬁnanceiras. Para uso pessoal, uma chave de 768 bits (cerca de 231 dígitos) é

suﬁciente.

Além do tamanho da chave, é importante usá-la por menos de dois (02) anos, e sugere-se

duplicar o número de dígitos de uma nova chave. Ao dobrar o número de dígitos, o trabalho de

codiﬁcação e decodiﬁcação das mensagens pode aumentar quatro vezes, mas o fator de trabalho

para a inclusão desta nova chave é oito vezes maior (RSA, 2000).

Em épocas diferentes, durante os últimos dois mil anos, os criptógrafos já acre-

CAPÍTULO 3. CRIPTOGRAFIA RSA

48

ditaram que a cifra monoalfabética, a cifra polialfabética e as máquinas de cifragem

com a Enigma eram inquebráveis. E, em cada um desses casos, mostrou-se que os

criptógrafos estavam errados porque suas aﬁrmações eram baseadas meramente no

fato de que a complexidade das cifras tinha superado a engenhosidade e a tec-

nologia dos criptoanalistas naquele ponto da história. Hoje, podemos ver que os

criptoanalistas iriam, inevitavelmente, descobrir um meio de quebrar cada cifra, ou

desenvolveriam uma tecnologia para fazer isso para eles. (SINGH, 1999, p. 378)

3.5 Assinaturas Digitais

Assim como na assinatura escrita, a assinatura digital visa certiﬁcar a autenticidade e

autoria da mensagem enviada. Caso a informação não seja sigilosa, mas sua autoria tem de

ser certiﬁcada, ﬁca mais simples codiﬁcar a assinatura de forma única do que codiﬁcar toda a

mensagem. Atualmente, há alguns sistemas de assinaturas disponíveis, porém o mais utilizado

é o sistema RSA. A assinatura digital já foi imaginada pelo trio que criou o sistema RSA, logo

após sua criação.

A assinatura digital garante que a mensagem não foi modiﬁcada, uma vez que se não

estivesse íntegra a conferência entre os itens calculados pelo destinatário e o obtido na deco-

diﬁcação seria diferente. Além disso, a assinatura digital também garante que o remetente é

realmente quem diz ser, porque somente ele possui a chave privada e, assim, somente ele po-

deria produzir tal assinatura digital. Ainda, o sistema permite que o remetente não possa negar

que enviou tal mensagem, já que somente ele é detentor da chave privada.

Resumidamente, uma assinatura digital X de uma mensagem Y é criado a partir da

chave privada de algum usuário e pode ser conﬁrmada pela chave pública. Somente determi-

nado usuário poderia produzir sua assinatura digital válida, sendo inviável de alguém o fazer

baseando-se em mensagens anteriores.

A função Message Digest, ou simplesmente MD - resumo da mensagem, é a função

utilizada para assinar a mensagem a ser enviada, onde o processamento do documento produz

um punhado de dados, chamado de hash. Nitidamente, criptografar o hash leva bem menos

tempo que codiﬁcar toda a mensagem, uma vez que o MD constituem blocos pequenos e com

tamanho ﬁxo. Assim, o processo se torna mais eﬁciente.

A assinatura digital pode ser veriﬁcada matematicamente, de forma que o documento

CAPÍTULO 3. CRIPTOGRAFIA RSA

49

e sua assinatura digital podem ser facilmente conﬁrmados em sua integridade e originalidade.

O sistema funciona da seguinte forma: executa-se a função MD, produzindo, assim, um hash

para aquele documento e, a seguir, pode-se decifrar a assinatura digital com a chave pública

do remetente. Ao decifrar a assinatura, deve-se produzir o mesmo hash, caso isto não ocorra o

documento e/ou a assinatura foram alterados.

3.6 Considerações Finais

Hodiernamente, as comunicações entre as pessoas vêm sendo exercidas de modo pro-

gressivo através de redes sociais, bem como as transações bancárias estão migrando predomi-

nantemente para o meio virtual. Diante dessa demanda também há uma grande necessidade de

garantir sigilo na troca de informações, bem como segurança nas transações bancárias. Caso

não haja total segurança, as pessoas e as instituições teriam todos seus dados pessoais e patri-

moniais correndo riscos.

Esse problema não surgiu junto à internet. O segredo na troca de mensagens foi decisivo

para a disputa entre nações ou mesmo dentro de uma nação, sendo responsável por diversos

ataques e contra-ataques que mudaram o rumo de disputas e de guerras. A troca de informações

sigilosas foi indispensável para que os líderes pudessem espalhar suas estratégias de combate

somente para subordinados e aliados.

Esse sigilo era garantido através de uma codiﬁcação própria estabelecida anteriormente,

o que garantia que, mesmo interceptada, não seria conhecido o teor da mensagem por pessoas

alheias ao processo de codiﬁcação. Obviamente, à medida que mais mensagens eram inter-

ceptadas, maiores eram as chances de se descobrirem os segredos do processos de codiﬁcação.

Surgiam, dessa forma, pessoas especíﬁcas para trabalhar na tentativa de decodiﬁcar as mensa-

gens codiﬁcadas.

Esses decodiﬁcadores buscavam padrões no processo de decomposição. Os primeiros

códigos basicamente trocavam a posição das letras no alfabeto antes de codiﬁcar a mensagem.

Com o passar o tempo, e com as tentativas certeiras de decodiﬁcar as mensagens, os siste-

mas foram se aperfeiçoando, porém ainda poderiam se perceber alguns padrões presentes em

determinadas línguas.

Tomando como exemplo a língua portuguesa, a presença da letra Q é seguida obrigato-

riamente da letra U, o que torna sua decodiﬁcação mais facilitada. Esse sistema monoalfabético

CAPÍTULO 3. CRIPTOGRAFIA RSA

50

foi perdendo a eﬁciência ao longo da história, sendo substituído pelo sistema polialfabético,

que, como o próprio nome indica, utiliza mais de um alfabeto no processo de codiﬁcação de

mensagens.

Além dos métodos de substituição de letras, foram utilizados sistemas em que haviam

deslocamento das letras do alfabeto de sua posição original ou ainda sistemas em que cada letra

tinha a função de uma palavra ou frase. O deslocamento das letras de sua posição original era

chamado de método de transposição. Esse sistema tinha uma vantagem em relação ao sistema

de substituição de letras, uma vez que as palavras de um idioma possuem agrupamentos mais

comuns de letras, facilitando a descoberta por quais letras foram substituídas as originais.

Todos esses métodos têm em comum o fato de haver uma mesma chave para codiﬁcar e

para decodiﬁcar as mensagens, considerado um sistema simétrico. Ou seja, a pessoa que recebe

a mensagem codiﬁcada precisa conhecer o processo em que foi cifrada a mensagem para poder

entendê-la posteriormente, o que exige uma troca de informação prévia entre o emissor e o

receptor. Então, antes de enviar um segredo, os envolvidos já teriam de compartilhar um outro

segredo anteriormente: o sistema de codiﬁcação.

Essa forma, única até algumas décadas atrás, diﬁcultava a troca de mensagens importan-

tes e também era maior o risco de fracasso, caso o primeiro segredo - o sistema de codiﬁcação

- fosse logo interceptado. Surgiam, então, ideias de um código onde a chave para decodiﬁcar

fosse diferente da chave para codiﬁcação. A ideia surgia, mas seu desenvolvimento não era algo

simples.

Foi a matemática quem impulsionou e revolucionou a forma de trocar mensagens de

forma sigilosa. Aliada ao surgimento dos computadores, a forma de manter informações e dados

de pessoas e empresas passou a ser algo real, aderindo à forma onde a chave para decodiﬁcação

não seria a mesma para codiﬁcação, chamado de sistema assimétrico.

Foram Ronald Rivest, Adi Shamir e Leonard Adleman do Laboratório de Ciência de

Informação do Massachusetts Institute of Technolgy (MIT), que possibilitaram, em 1978, a

implementação do sistema criptográﬁco com sistemas assimétricos. O sistema ﬁcou conhe-

cido como RSA, pelo uso das iniciais dos criadores. Importante destacar que os computadores

utilizam a linguagem binária e é através do código padrão americano para intercâmbio de infor-

mações, conhecido pela sigla ASCII, que a mensagem é transformada para o sistema adotado

nos computadores. Então, o código ASCII não á necessariamente um sistema de cifragem, mas

somente uma forma de traduzir a mensagem para a linguagem dos computadores.

CAPÍTULO 3. CRIPTOGRAFIA RSA

51

O RSA consiste em uma criptograﬁa de chave pública, portanto, ela deve ter duas cha-

ves: pública e privada. Esta chave pública pode ser revelada a qualquer pessoa sem compro-

meter a segurança do código. Com ele, os remetentes podem criptografar suas mensagens para

serem lidas pelo destinatário com sua chave privada. Para as chaves públicas e privadas, devem

selecionar números primos. Os números primos sempre despertaram grande interesse aos estu-

diosos e diversos questionamentos a respeito ainda são um mistério. O Teorema Fundamental

da Aritmética aponta que todo número natural maior do que 1 ou é primo ou se escreve de

modo único como um produto de números primos. Euclides, no Livro IX dos Elementos, já

demonstrava que os números primos são inﬁnitos, fazendo a demonstração através da redução

ao absurdo. Essa inﬁnidade dos números primos garante ao sistema RSA de criptograﬁa um

campo amplo de possibilidades, uma vez que se vale da diﬁculdade de fatorar um número que

é produto de dois números primos bem grandes.

Além dos números primos, o sistema RSA vale-se da congruência entre números. Dois

números a e b são congruentes módulo m quando o resto da divisão de a e b por m resultam

no mesmo número, sendo representado por a ≡ b mod m. Além disso, o Teorema de Euler é

necessário no processo de codiﬁcação e decodiﬁcação das mensagens criptografadas por RSA.
Neste teorema, sejam m, a ∈ Z com m > 1 e mdc(a, m) = 1. Então,

aϕ(m) ≡ 1 mod m.

Feitas estas considerações matemáticas, e uma vez selecionados os primos para uso no

sistema RSA, a primeira chave que pode ser feita é a chave pública. Para ﬁns de criptograﬁa

RSA, a chave pública consiste em dois números: n, chamado de módulo RSA; e, chamado de

display público. Por deﬁnição, n é o produto dos primos selecionados, ou seja, n = p1 × p2.

Para o número e, com e < n e mdc(e, varphi(n) = p1 × p2) = 1.

Mais precisamente, o método de criptograﬁa RSA funciona do seguinte modo: I) escolhem-

se dois primos p e q, distintos entre si; II) deﬁne-se N = p × q; III) deve-se escolher um número

e, que faz parte da chave pública, de forma que o máximo divisor comum (mdc) entre ele e

ϕ(N ) seja 1; IV) de acordo com uma tabela pré-formulada e de domínio público é feita a trans-

formação de todos os caracteres da mensagem em números, obtendo-se a mensagem numérica

M , após conversão em dígitos binários ASCII, em um único bloco que será dividido em blocos

b, de forma que: b < N . Isso garante que, ao utilizar congruência, obtenha-se um único re-

sultado na decodiﬁcação; V) de posse da chave pública (e; N ), criptografam-se os blocos b de

CAPÍTULO 3. CRIPTOGRAFIA RSA

52

acordo com a congruência: C = M e mod N , onde M é a mensagem numérica ao qual a men-

sagem original foi convertida ao ASCII, e C(b) é a mensagem criptografada; VI) de posse da

chave privada (d; N ), descriptografa-se, e D é a mensagem descriptografada; VII) cada bloco D

deve ser colocado em sequência e de acordo com a mesma tabela usada no item IV os números

devem ser convertidos em caracteres.

O sistema RSA é assimétrico porque garante uma função de via única, que somente

poderia ser revertida com as informações privilegiadas dos números primos p e q utilizados.

Como um dos números da chave pública é N = p × q, a segurança do sistema é baseada

na diﬁculdade de se fatorar o número N . Assim, é essencial que os primos escolhidos sejam

muito grandes. Claro que isso não é feito de forma braçal, uma vez que os computadores se

encarregam de encontrar cada vez maiores números primos para essa função.

Parece ser o sistema RSA extremamente seguro devido a diﬁculdade de reversão apre-

sentada anteriormente. Porém, viu-se que em todos os sistemas utilizados durante a história,

sempre se tinham a impressão de inviolabilidade destes. Fica a dúvida se em algum momento

o sistema RSA poderá ser quebrado. Imagina-se que, se isso um dia vir a acontecer, poderá ser

de duas formas: encontrar alguma forma de fatorar os números utilizados que até então não se

conheça; ou perceber outro caminho para decodiﬁcar sem a necessidade de fatorar o número

utilizado. Por enquanto, o sistema RSA é seguro e viável para estabelecer a segurança das

transações bancárias, o segredo das grandes instituições e inclusive das mensagens particulares

trocadas nos aplicativos das redes sociais.

Referências

[1] COUTINHO S. C., Severino Collier. Números Inteiros e Criptograﬁa RSA. Rio de Ja-

neiro: IMPA, 2014.

[2] COUTINHO S. C. Programa de Iniciação Cientíﬁca da OBMEP - Criptograﬁa. Rio de

Janeiro. OBMEP, 2008.

[3] HEFEZ, A.. Aritmética. Rio de Janeiro: SBM, 2016. (Coleção PROFMAT).

[4] HEFEZ, A..Exercícios Resolvidos de Aritmética. Rio de Janeiro SBM, 2016. (Coleção

PROFMAT).

[5] KAHN, D. The codebreakers: The story of Secret Writing. New York: Scribner, 1996.

[6] RSA Laboraroties. Frequently Asked Questions About Today’s Cryptography. RSA

Labs, 2000. Disponível em http://www.rsa.com/rsalabs/faq/ﬁles/rsalabsfaq41.pdf.

Acesso em 21 de agosto de 2020.

[7] RSA Laboraroties. RSA Cryptography Standard. New York. Disponível em

ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf. Acesso em 21 de agosto de

2020.

[8] SINGH, Simon. O Livro dos Códigos: a ciência do sigilo - do antigo Egito à criptograﬁa

quântica. Trad. Jorge Calife. 6a ed. Rio de Janeiro: Record, 2007.

53

