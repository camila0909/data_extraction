UNIVERSIDADE FEDERAL RURAL DO SEMI-ÁRIDO 

PRÓ-REITORIA DE PESQUISA E PÓS-GRADUAÇÃO 

PROGRAMA DE PÓS-GRADUAÇÃO 

MESTRADO EM MATEMÁTICA 

WILLA DA SILVA MEDEIROS 

A ARTE DOS CÓDIGOS SECRETOS EM SALA DE AULA: EXPLORANDO 

CONCEITOS DE MATEMÁTICA BÁSICA EM CRIPTOGRAFIA 

MOSSORÓ 

2020 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
WILLA DA SILVA MEDEIROS 

A ARTE DOS CÓDIGOS SECRETOS EM SALA DE AULA: EXPLORANDO 

CONCEITOS DE MATEMÁTICA BÁSICA EM CRIPTOGRAFIA 

Dissertação  apresentada  ao  Programa  de  Pós-
Graduação  em  Matemática  da  Universidade 
Federal  Rural  do  Semi-Árido  como  requisito 
para  obtenção  do 
título  de  Mestre  em 
Matemática do programa PROFMAT. 

Orientadora:  Prof.  Dra.  Maria  Joseane  Felipe 
Guedes Macêdo 

MOSSORÓ 

2020 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
© Todos os direitos estão reservados a Universidade Federal Rural do Semi-Árido. O conteúdo desta obra é de inteira 
responsabilidade do (a) autor (a), sendo o mesmo, passível de sanções administrativas ou penais, caso sejam infringidas as 
leis que regulamentam a Propriedade Intelectual, respectivamente, Patentes: Lei n° 9.279/1996 e Direitos Autorais: Lei n° 
9.610/1998. O conteúdo desta obra tomar-se-á de domínio público após a data de defesa e homologação da sua respectiva 
ata. A mesma poderá servir de base literária para novas pesquisas, desde que a obra e seu (a) respectivo (a) autor (a) sejam 
devidamente citados e mencionados os seus créditos bibliográficos. 

O serviço de Geração Automática de Ficha Catalográfica para Trabalhos de Conclusão de Curso (TCC´s) foi desenvolvido pelo 
Instituto de Ciências Matemáticas e de Computação da Universidade de São Paulo (USP) e gentilmente cedido para o 
Sistema de Bibliotecas da Universidade Federal Rural do Semi-Árido (SISBI-UFERSA), sendo customizado pela 
Superintendência de Tecnologia da Informação e Comunicação (SUTIC) sob orientação dos bibliotecários da instituição para 
ser adaptado às necessidades dos alunos dos Cursos de Graduação e Programas de Pós-Graduação da Universidade. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
WILLA DA SILVA MEDEIROS 

A ARTE DOS CÓDIGOS SECRETOS EM SALA DE AULA: EXPLORANDO 

CONCEITOS DE MATEMÁTICA BÁSICA EM CRIPTOGRAFIA 

Dissertação  apresentada  ao  Programa  de  Pós-
Graduação  em  Matemática  da  Universidade 
Federal  Rural  do  Semi-Árido  como  requisito 
título  de  Mestre  em 
para  obtenção  do 
Matemática do programa PROFMAT. 

Defendida em: _25_ / _09_ / 2020 

BANCA EXAMINADORA 

_________________________________________ 
Prof. Dra. Maria Joseane Felipe Guedes Macêdo (UFERSA) 
Presidente 

_________________________________________ 
Prof. Dra. Antônia Jocivania Pinheiro (UFERSA) 
Membro Examinador 

________________________________________ 
_ 
Prof. Dr. Antonio Ronaldo Gomes Garcia (UFERSA) 
Membro Examinador 

_________________________________________ 
Prof. Dr. Leomaques Francisco Silva Bernardo (UFCG) 
Membro Examinador (Externo) 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
À minha mãe Damiana da Silva e demais familiares 
À minha esposa Ana Santana Clementino 
À minha amada vovó Maria de Lurdes dos Santos 
À minha sogra Maria das Graças Clementino 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Agradeço  a  Deus,  em  primeiro  lugar,  pelo  dom  da  vida,  por  me  conceder  forças, 

saúde,  discernimento  e  coragem  para  continuar  minha  caminhada  de  estudos,  mesmo  com 

todas as dificuldades que a  vida  nos  impõe. A  ele sou grato e devo tudo de bom que  já  me 

aconteceu, principalmente a oportunidade de realizar mais um sonho. 

Sou grato a minha família, nosso bem maior, por todo apoio a me concedido, por todo 

crédito  em  mim  depositado  e  por  ser  a  minha  principal  fonte  de  inspiração  e  motivação  na 

vida. Em  especial, quero agradecer a  minha  amada  mãe Damiana da Silva, a quem eu devo 

minha  vida,  por  sempre  acreditar  no  meu  potencial  e  me  incentivar  nos  estudos.  Foi  muito 

emocionante realizar o sonho dela de me ver formado e empregado. Quero agora lhe dedicar 

mais essa conquista e dizer que tudo que fiz, as batalhas que venci, foi tudo por ela. 

Sou  grato  a  minha  amada  esposa  Ana  Santana,  por  todo  carinho,  compreensão  e 

companheirismo de sempre.  Agradeço-lhe por todo o incentivo, motivação e por entender o 

motivo da minha ausência em determinadas ocasiões. Sou imensamente grato a Deus por tê-la 

ao meu  lado durante todos esses anos e por me permitir ser  feliz ao lado dela. Este trabalho 

também é dedicado a ela. 

Agradeço  de  coração  a  todos  os  meus  amigos  colegas  e  professores  do  PROFMAT, 

por toda ajuda concedida durante esses dois anos de mestrado. Em especial, quero destacar os 

colegas  de  curso  Levi  Rodrigo  e  Auricélio  Carneiro.  Sem  o  apoio  desses  dois  amigos, teria 

sido  impossível  terminar  este  curso.  Tenho  uma  dívida  eterna  com  eles  e  um  imenso 

sentimento de gratidão. Entre os professores, destaco Ronaldo Garcia, Antônio Gomes Nunes, 

Maria  Joseane  e  Fabrício  Figueiredo.  Em  um  momento  difícil  durante  o  curso,  esses 

professores, entre outros, foram muito importantes para mim.  

Por fim, quero agradecer mais uma vez a minha amiga e orientadora professora Maria 

Joseane Felipe Guedes Macêdo. A ela sou grato por ter aceitado meu pedido para ser minha 

orientadora,  por  toda  confiança  e  credibilidade  depositada  em  mim,  por  todo  tempo, 

disposição  e  motivação  investidos  na  orientação  deste  trabalho  e  por  seu  profissionalismo 

brilhante.  Tudo  isso  foi  responsável  pelo  excelente  desenvolvimento  e  conclusão  desta 

dissertação.  Sem dúvidas, o término deste trabalho ocorreu graças à enriquecedora orientação 

que tive.  

Ao final de um trabalho como este, é difícil lembrar-se de todas as pessoas que deram 

sua parcela de contribuição. Não podendo citar todos, encerro agradecendo todos àqueles que 

diretamente ou indiretamente contribuíram para a construção deste trabalho.  

Muito obrigado! 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Por  que  nos  torna  tão  pouco  felizes  esta 

maravilhosa  ciência  aplicada,  que  economiza 

trabalho e torna a vida mais fácil? A resposta é 

simples:  porque  ainda  não  aprendemos  a  nos 

servir dela com bom senso. 

Albert Einstein (1879 - 1955) 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

fatos  históricos 

Ensinar matemática não é uma tarefa fácil, pois já é tradição entre os alunos a ideia de 
que ela é uma disciplina difícil e, em ampla maioria, um amontoado de regras e fórmulas que 
parecem não possuir nenhuma aplicação prática importante. Neste sentido, é de fundamental 
importância explorar constantemente as aplicações dos conteúdos de matemática no cotidiano 
do  aluno.  Com  este  intuito,  o  presente  trabalho  busca,  a  partir  da  criptografia,  explorar  a 
relação  entre  alguns  temas  de  matemática  do  ensino  básico  e  os  métodos  criptográficos.  Os 
objetivos  principais  são:  abordar  alguns 
importantes  acerca  do 
desenvolvimento  dos  códigos  secretos  e  da  criptografia  em  geral;  relacionar  a  aritmética 
básica com um tipo de criptografia muito importante para a segurança na internet hoje em dia, 
a  criptografia  RSA;  enfatizar  como  determinados  conceitos  de  matemática  podem  fazer-se 
presentes  no  estudo  da  criptografia  aqui  desenvolvido  e  como  isso  pode  ser  útil  para  o 
aprendizado do aluno. Este trabalho revela a importância de tratarmos assuntos dessa natureza 
nas  aulas  de  matemática.  Numa  época  onde  a  internet  torna-se  indispensável  para  o  ser 
humano,  é  necessário  que  as  pessoas  desde  cedo  conheçam  pelo  menos  as  noções  mais 
básicas  da  inteligência  responsável  por  toda  segurança  desse  veículo  de  comunicação,  a 
criptografia.  Além  disso,  é  de  extrema  relevância  mostrar  para  os  estudantes  o  papel  da 
matemática na eficiência e no desenvolvimento dessa ciência. Deste modo, foram produzidos 
alguns  algoritmos  e  guias  que  servem  de  apoio  ao  professor  para  introduzir  e  explorar  a 
criptografia como aplicação da matemática em sala de aula. 

Palavras chave: Matemática do Ensino Básico. Matemática aplicada. Criptografia. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ABSTTRACT 

Teaching mathematics is not an easy task, since it has long been considered, among the vast 
majority of students, to be a subject full of rules and formulas that seem to have no important practical 
application. In this sense, it is crucial to constantly explore the applications of mathematical content in 
students’  daily  life.  For  this  purpose,  the  present  work  seeks,  from  cryptography,  to  explore  the 
relationship between some basic mathematics themes and cryptographic methods. The main goals are: 
to  broach  some  important  historical  facts  concerning  the  development  of  secret  codes  and 
cryptography in general; to relate basic arithmetic to a type of cryptography that is very important for 
Internet security today, RSA cryptography; to emphasize how certain concepts of mathematics can be 
present in the study of cryptography developed here and how it can be useful for student learning. This 
work reveals the importance of dealing with subjects of this nature in mathematics classes. At a time 
when the Internet has become indispensable for human beings, it is necessary for people from an early 
age to know at least the most basic notions of the intelligence responsible for all the security of this 
communication vehicle, cryptography. Besides, it is extremely important to show students the role of 
mathematics in the efficiency and development of this science. Thus, some algorithms (guides) were 
produced that serve to support the teacher to introduce and explore cryptography as an application  of 
mathematics in the classroom. 

Keywords: Basic education mathematics. Applied mathematics. Cryptography. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1  

–  Heródoto ......…...................................………….…………….......…… 22 

Figura 2  

–  Um exemplo de Grade de Cardano ...................................……...….....  26 

Figura 3  

–  Mensagem de Cobertura ……...............................……...…….…..…... 26 

Figura 4  

–  Decifrando a mensagem ……….........................………………....…… 27 

Figura 5 

Figura 6 

Figura 7 

Figura 8  

Figura 9 

Figura 10 

Figura 11 

Figura 12 

Figura 13 

Figura 14 

Figura 15 

Figura 16 

Figura 17 

Figura 18 

Figura 19 

Figura 20 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

Citale ou Bastão de Licurgo ………...............................……………… 31 

Algumas ramificações da Escrita Secreta .............................................. 37 

O Telégrafo ............................................................................................ 39 

Quadrado de Vigenère ........................................................................... 50 

Divisão exata de 𝑎 por 𝑏 ........................................................................ 62 

União de dois Conjuntos ...................................................................... 101 

Intersecção de dois Conjuntos ............................................................. 102 

Diferença de dois Conjuntos ................................................................ 103 

Complementar de 𝐵 com relação à 𝐴 ................................................... 103 

Complementar de 𝐴 com relação ao Universo ..................................... 104 

Uma Função 𝑓 de 𝐴 em 𝐵 .................................................................... 106 

Imagem de um Conjunto por meio de uma Função 𝑓 .......................... 108 

Imagem inversa de um Conjunto por meio de uma Função 𝑓 .............. 108 

Composição de funções ........................................................................ 109 

Um exemplo de Permutação ................................................................. 116 

Diagrama de árvore para o problema do Exemplo 4.52 ....................... 151 

 
 
   
 
 
 
 
 
 
 
 
 
 
LISTA DE TABELAS 

Tabela 1  

–  Cifra do tipo citado no Kama-Sutra …....................................………… 33 

Tabela 2  

–  Alfabeto Braille e outros símbolos ...................……….....………......... 38 

Tabela 3  

–  Alfabeto em Morse e outros caracteres.......................…..…….………. 41 

Tabela 4  

–  Cifra de Alberti ..............................................……….................…....... 48 

Tabela 5 

Tabela 6 

Tabela 7  

Tabela 8 

Tabela 9 

Tabela 10 

Tabela 11 

Tabela 12 

Tabela 13 

Tabela 14 

Tabela 15 

Tabela 16 

Tabela 17 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

– 

Utilizando a Palavra-chave ..................................................................... 51 

Codificando a Mensagem ....................................................................... 51 

Tabela de Conversão .............................................................................. 88 

Tabela de Pré-codificação .................................................................... 112 

Codificando a Mensagem ..................................................................... 121 

Decodificando a Mensagem ..................................................................123 

Codificação da Mensagem do Exemplo 4.28 ....................................... 125 

Codificando a Mensagem ......................................................................128 

Decodificando a Mensagem ..................................................................130 

Codificação da Mensagem do Exemplo 4.30 ........................................131 

Decodificação da Mensagem do Exemplo 4.30 ....................................132 

Operação com Números Binários ..........................................................152 

O Código ASCII ................................................................................... 154 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÁRIO 

INTRODUÇÃO ............................................................................................ 16 

CONCEITOS FUNDAMENTAIS EM CRIPTOGRAFIA ...................... 20 

Sobre a origem dos códigos secreto ............................................................ 21 

Um relato devido a Heródoto ......................................................................... 21 

Esteganografia e Criptografia ......................................................................... 24 

Cifras de Transposição e Substituição ........................................................... 29 

Cifras e Códigos: qual a diferença? ................................................................ 35 

Análise de frequência e o nascimento da Criptoanálise ................................. 42 

Chaves ............................................................................................................ 45 

Cifras de substituição Monoalfabéticas e Polialfabéticas .............................. 47 

O Conceito de Algoritmo `.............................................................................. 52 

Criptografia de Chave Privada e Criptografia de Chave Pública ........... 54 

Criptografia de Chave Privada ....................................................................... 54 

Criptografia de chave Pública ........................................................................ 55 

APLICAÇÕES I: ARITMÉTICA BÁSICA EM CRIPTOGRAFIA RSA 

......................................................................................................................... 57 

Conceitos básicos em teoria dos números .................................................. 58 

Números inteiros e o princípio da boa ordenação .......................................... 58 

Divisibilidade em ℤ: definições e algumas propriedades básicas .................. 61 

Divisão euclidiana .......................................................................................... 64 

Máximo divisor comum entre números inteiros ............................................ 66 

O algoritmo de Euclides ................................................................................. 69 

Números primos ............................................................................................. 70 

Aritmética modular ......................................................................................... 75 

O método criptográfico RSA ....................................................................... 86 

O processo de pré-codificação no RSA .......................................................... 88 

O processo de codificação no RSA ................................................................ 89 

O processo de decodificação no RSA ............................................................ 93 

APLICAÇÕES II: ALGUNS CONCEITOS DE MATEMÁTICA 

BÁSICA EM CRIPTOGRAFIA ................................................................. 98 

1 

2 

2.1 

2.1.1 

2.1.2 

2.1.3 

2.1.4 

2.1.5 

2.1.6 

2.1.7 

2.1.8 

2.2 

2.2.1 

2.2.2 

3 

3.1 

3.1.1 

3.1.2 

3.1.3 

3.1.4 

3.1.5 

3.1.6 

3.1.7 

3.2 

3.2.1 

3.2.2 

3.2.3 

4 

4.1 

Conjuntos, Funções e Criptografia.............................................................. 98     

 
 
 
 
 
 
 
 
4.1.1                         

Noções básicas sobre Conjuntos .................................................................... 98                                                          

4.1.2          

Noções básicas sobre Funções ..................................................................... 106                                                

4.1.3 

4.1.4 

4.1.5 

4.1.6 

4.2 

4.2.1 

4.3 

Criptossistemas ............................................................................................ 110                                                                                 

Alfabetos e Palavras ..................................................................................... 114                                                                     

Permutações ................................................................................................. 116                                                                                           

Cifras em Blocos .......................................................................................... 117                                                                                        

Funções Afins e Criptografia .................................................................... 119                                                                   

Um método criptográfico intuitivo baseado em Funções Afins .................. 120                   

Funções Quadráticas e Criptografia ........................................................ 126                                                      

4.3.1 

Um método criptográfico intuitivo baseado em Funções Quadráticas ........ 127 

4.4 

4.4.1 

4.4.2  

4.5 

4.5.1 

4.5.2 

5 

Matrizes e Criptografia ............................................................................. 133                                                                   

Algumas noções sobre Matrizes ................................................................... 133                                                                    

A Cifra de Hill .............................................................................................. 137                                                                               

Probabilidade e Criptografia .................................................................... 144                                                              

Noções básicas sobre probabilidade ............................................................. 144                                                        

Sigilo Perfeito e Probabilidade ..................................................................... 148                                                                                                                                 

CONSIDERAÇÕES FINAIS .................................................................... 155                                                                                          

REFERÊNCIAS BIBLIOGRÁFICAS 

 
 
 
 
 
 
 
 
 
 
 
 
 
                        
 
     
 
 
 
 
 
 
 
 
 
 
 
16 

I INTRODUÇÃO 

Recentemente  o  Brasil  passou  a  integrar  o  grupo  de  elite  em  pesquisa  matemática 

mundial.  Somos  uma  potência  em  matemática,  ao  lado  de  outras  grandes  potências  como 
Estados  Unidos,  China,  França  e  Alemanha1.  Chega  a  ser  espantoso  o  fato  de  que  essa 

potencialidade  ainda  não  se  refletiu  na  educação  básica.  Ainda  não  conseguimos  alcançar 

patamares  mais  elevados  e  o  estado  atual  em  que  se  encontra  o  ensino  e  aprendizagem  em 

matemática básica é crítico. Ironicamente, o Brasil é um dos países com pior desempenho em 

matemática  na  educação  básica  como  mostra  as  avaliações  educacionais  já  realizadas.  O 

último PISA (PROGRAMA INTERNACIONAL DE AVALIAÇÃO DE ALUNOS) realizado 

em  2018  mostrou  que  apesar  de  um  pequeno  aumento  na  média,  o  Brasil  não  conseguiu 

atingir uma melhoria significativa no desempenho dos estudantes em relação às disciplinas de 

matemática, português e ciências, ficando entre os 10 países com pior desempenho no ranking 
mundial2. 

Se tratando de matemática, e de frente a essa real situação, é de extrema importância e 

urgência  a  criação  e  desenvolvimento  de  práticas  inovadoras  de  ensino  e  metodologias  que 

possam  proporcionar  avanços  expressivos  no  ensino  e  aprendizagem  em  matemática  na 

educação  básica.  Nesse  conjunto  de  metodologias,  a  prática  de  desenvolver  o  ensino  de 

matemática  por  meio  da  contextualização  e  interdisciplinaridade  dos  conteúdos  vem  se 

tornando  cada  vez  mais  frequente  entre  os  docentes.  O  ensino  de  matemática  ao  ser 

relacionado  com  o  cotidiano  do  aluno  e  com  outras  ciências  torna-se  mais  prazeroso, 

produtivo  e  significativo,  pois  o  aluno  pode  ver  a  importância  de  um  determinado 

conhecimento não apenas dentro da própria disciplina, mas em outras áreas do saber, e isso dá 

mais  sentido  ao  estudo  realizado.  Assim,  a  contextualização  e  a  interdisciplinaridade  como 

forma  de  apresentar  as  aplicações  da  matemática  em  outros  campos  são  ferramentas 

poderosas  que 

já  vêm  sendo  bastante  usadas  no  ensino,  não  só  de  matemática.           

Brousseau (1996) citado por Pinheiro (2012) entende que a contextualização ocorre quando o 

aluno  é  levado  a  estudar  um  conteúdo  por  meio  de  uma  situação-problema,  sendo  essa 

situação  próxima  à  realidade  do  aluno  e,  mais  ainda,  que  essa  situação  esteja  inserida  num 

1 Ver matéria publicada no site do IMPA (INSTITUTO DE MATEMÁTICA PURA E APLICADA) no dia 27 de 
fevereiro de 2018. Fonte: <https://impa.br/noticias/tv-escola-destaca-entrada-do-brasil-na-elite-da-matematica/>. 
Acesso em: 02 jul. 2020. 
2  Ver  matéria  do  G1  em  <https://g1.globo.com/educacao/noticia/2019/12/03/brasil-cai-em-ranking-mundial-de-
educacao-em-matematica-e-ciencias-e-fica-estagnado-em-leitura.ghtml>    e  o  Relatório  Brasil  no  Pisa  2018  no 
site  do  INEP  em  <http://portal.inep.gov.br/web/guest/acoes-internacionais/pisa/resultados>.  Acesso  em:  02  jul. 
2020. 

 
                                                             
 
17 

cenário  que  seja  capaz  de  atribuir  significado  e  sentido  ao  objeto  de  estudo.  Desse  modo, 

Brousseau  (1996)  citado  por  Pinheiro  (2012)  deixa  claro  que  dar  sentido  ao  conteúdo 

ensinado por meio de situações é de extrema importância. Isso se reflete em matemática como 

resposta  àquelas  perguntas  que  todo  professor  de  matemática  já  ouviu:  isso  serve  para  quê? 

Onde vou usar isso na minha vida? 

É nessa perspectiva de contextualização e de inter-relacionar a matemática com outras 

ciências  que  o  presente  trabalho  está  inserido.  A  ciência  a  qual  iremos  relacionar  com  a 

matemática é a criptografia. Uma área da computação muito antiga e que tem sua origem bem 

parecida  com  a  da  matemática.  Hoje  em  dia  a  matemática  é  essencial  para  a  criptografia, 

constituindo  sua  base  conceitual  de  segurança,  assim  como  também  a  criptografia  é 

importante para a matemática. A palavra criptografia provém do grego  kriptos, que significa 

secreto,  oculto,  e  graphein,  que  significa  escrever.  Assim,  entendemos  criptografia  como  a 

ciência  que  estuda  os  meios,  os  métodos,  para  tornar  o  conteúdo  de  uma  mensagem 

incompreensível para todos aqueles que não têm permissão de lê-la, de modo que somente o 

destinatário legítimo possa obter a mensagem verdadeira.  

A  criptografia  está  relacionada  com  muitos  conceitos  básicos  de  matemática.  Entre 

eles estão a aritmética  básica (fatoração, máximo divisor comum, congruências), as  funções 

(cifras  de  substituição  e  criptossistemas  em  geral),  matrizes  (cifra  de  Hill),  probabilidades 

(sigilo  perfeito),  etc.,  (BUCHMANN,  2002).  Isso  faz  com  que  possamos  facilmente 

estabelecer relações entre essas duas áreas nas aulas de matemática. É justamente essa relação 

que  propomos  investigar,  frisando  alguns  tópicos  de  matemática  do  ensino  básico.  Sendo  a 

criptografia  um  tema  de  enorme  relevância,  pois  representa  uma  das  aplicações  mais 

importantes  da  matemática  para  a  sociedade,  relacioná-la  com  esses  conteúdos  tornará  as 

aulas  mais  interessantes,  dinâmicas  e  consequentemente  a  aprendizagem  mais  significativa 

(PEREIRA, 2015). 

Portanto,  a  relação  que  pretendemos  abordar  neste  trabalho  com  a  temática 

envolvendo  matemática  básica  e  criptografia  é  de  extremo  interesse  para  o  ensino  e 

aprendizagem dessa disciplina. Para Pereira (2015), aspectos da criptografia clássica, como as 

cifras  que  iremos  tratar  no  Capítulo  2  já  podem  ser  trabalhados  com  alunos  do  ensino 

fundamental.  Essa  é  uma  boa  maneira  de  exercitar  operações  básicas,  noções  de  análise 

combinatória,  fórmulas  matemáticas,  raciocínio  lógico,  resolução  de  problemas,  linguagens, 

história, etc.  

 
18 

Tópicos  de  criptografia  que  envolva  a  criação  de  algum  algoritmo  por  meio  de 

computador  ou  que  necessite  de  um  conhecimento  de  matemática  mais  aprofundado  são 

aplicações  que  serão  mais  bem  aproveitadas  no  ensino  médio  (PEREIRA,  2015).  Ainda  em 

relação ao ensino médio, para Pereira (2015) a abordagem do tema criptografia nessa etapa de 

ensino  será  de  grande  proveito  para  os  alunos,  pois  possibilitará  que  os  mesmos  tomem 

conhecimento  dos  conceitos  básicos  de  computação,  como  desenvolvimento  de  algoritmos 

simples, por exemplo, e assim possam compreender melhor o papel da matemática envolvida 

nesse  meio.  Isso  está  de  acordo  com  a  BNCC  (BASE  NACIONAL  COMUM 
CURRICULAR)  do  ensino  médio  na  habilidade  (EM13MAT06)3.  É  claro  que  muitos  dos 

conceitos  e  exemplos  que  veremos  serão  aplicáveis  tanto  no  ensino  fundamental  quanto  no 

médio.  Entretanto,  a  relação  descrita  neste  trabalho  entre  criptografia  e  matemática  destaca 

com mais evidência conteúdos do ensino médio. 

Assim, este trabalho tem por objetivo descrever, por meio de  um estudo introdutório, 

como  determinados  assuntos  de  matemática  básica  (conjuntos, 

funções,  matrizes, 

probabilidade,  análise  combinatória,  aritmética  básica,  etc.)  estão  inseridos  em  conceitos 

elementares de criptografia e como isso pode ser útil no aprendizado do aluno. Isso fará com 

que  possamos  compreender  como  esses  assuntos  podem  ser  trabalhados,  contextualizados, 

com base no tema criptografia. Os exemplos e as descrições dos métodos (cifras) funcionarão 

como  fonte  para  desenvolvermos  atividades  em  sala  de  aula,  apesar  dessas  atividades  não 

serem  descritas  passo  a  passo  neste  trabalho,  fornecendo,  assim,  subsídios  para  que  o 

professor possa dar maior aplicabilidade aos conteúdos estudados e, com maior ênfase, tornar 

o estudo mais significativo, sólido e mais próximo da realidade do aluno. Para complementar, 

abordaremos  fatos  importantes  acerca  do  desenvolvimento  dos  códigos  secretos  e  da 

criptografia,  e  introduziremos  a  Criptografia  RSA  como  uma  importante  aplicação  da 

aritmética básica. 

Para  o  embasamento  teórico  deste  trabalho  foram  realizadas  pesquisas  em  trabalhos 

acadêmicos já publicados, tais como monografias, dissertações, artigos e livros que tratam dos 

tópicos abordados em cada capítulo. Destacamos  as obras: Singh (2004), Buchmann (2002), 

Fiarresga  (2010),  Brandão  (2017),  Coutinho  (2005),  França  (2014),  Jesus  (2013),  Santos 

(2014) e meu TCC da graduação Medeiros (2017). Cada um deles (entre outros) tiveram sua 

parcela de contribuição no desenvolvimento desta dissertação.  

3 “Utilizar os conceitos básicos de uma linguagem de programação na implementação de algoritmos escritos em 
linguagem corrente e/ou matemática” (BRASIL, 2017). 

 
                                                             
19 

Quanto a sua estrutura, este trabalho está dividido em 3 capítulos, excetuando-se essa 

introdução e a conclusão. No Capítulo 2 tratamos dos conceitos fundamentais em criptografia. 

Abordaremos um pouco da sua história, destacando como os primeiros métodos para proteger 

mensagens enviadas foram criados. Definiremos e exemplificaremos alguns tipos especiais de 

cifras e finalizaremos o capítulo com uma rápida exposição sobre algoritmos e criptografia de 

chave pública. O Capítulo 3 trata da aritmética e sua aplicação na criptografia. Nele revisamos 

alguns  conceitos  básicos  da  chamada  Teoria  Elementar  dos  Números  com  a  intenção  de 

preparar  o  terreno  para  a  exposição  do  método  de  criptografia  de  chave  pública  mais 

importante atualmente, o RSA. Faremos uma rápida introdução histórica sobre esse método e 

seus  criadores,  partindo  então  para  a  definição  do  método  e  desenvolvimento  dos  seus 

processos de codificação e decodificação. Também apresentamos dois algoritmos que servem 

de guia para  introduzir em sala de aula o  método RSA. No Capítulo 4 o objetivo é explorar 

alguns  temas  de  matemática  básica  em  criptografia.  Os  conteúdos  escolhidos,  tais  como 

conjuntos, funções, matrizes e probabilidade, são brevemente revisados antes de explicarmos 

como os mesmos estão inseridos na criptografia. Em suma, estas explicações se resumem em 

considerar um conceito ou método de criptografia e tratar de discutir como as ideias daquele 

conteúdo  em  particular  ajudam  a  entender  o  funcionamento  daquele  algoritmo  criptográfico 

simples.  Reciprocamente,  ao  desenvolver  as  ideias  dos  métodos  criptográficos  com  base  na 

matemática  tratada,  teremos  mais  auxílio  para  trabalhar  melhor  a  contextualização  dos 

conteúdos com o tema criptografia. Além disso, apresentaremos alguns guias para aplicar tais 

exemplos em sala de aula.  

 
 
 
 
 
 
 
 
 
 
 
 
 
20 

2 CONCEITOS FUNDAMENTAIS EM CRIPTOGRAFIA 

É natural do ser humano a preocupação em  impor sigilo a determinadas  informações 

que ele considera importante e que, por algum motivo de privacidade e segurança pessoal não 

podem  ser  conhecidas  por  pessoas  não  autorizadas.  Essa  preocupação  acompanha  o  homem 

desde os tempos mais remotos, sendo ela a responsável pelo desenvolvimento de habilidades 

extraordinárias para manter a segurança das informações trocadas via mensagens. 

A  troca  de  mensagens  representou  um  grande  avanço  no  desenvolvimento  da 

comunicação, possibilitando o tráfego dessas informações por vias de diferentes naturezas. No 

entanto, durante um intercambio de mensagens, onde o conteúdo das mesmas não poderia ser 

compartilhado  por  pessoas  não  autorizadas,  o  emissor  e  o  receptor  (quem  envia  e  recebe  a 

mensagem,  respectivamente)  tinham  ciência  do  perigo  caso  tal  mensagem  chegasse  a  mãos 

erradas. Assim, entra em cena a questão da segurança e privacidade dessas mensagens: como 

enviar uma informação sigilosa com segurança de modo que, se por ventura ela caia em mãos 

inimigas, seu conteúdo não possa ser compreendido?  

Tal  pergunta,  e  o  problema  central  que  a  acompanha,  foram  responsáveis  por  fazer 

com que o homem desenvolvesse técnicas de proteção e ocultação do significado real de uma 

mensagem  antes  da  mesma  ser  enviada  para  outra  pessoa.  Dessa  maneira,  o  envio  e, 

principalmente, o trajeto dessa mensagem se tornam mais seguros e com maior probabilidade 

de  não  ser  violados.  Surgem  então  os  códigos  secretos,  os  procedimentos,  e  os  algoritmos 

para proteger as comunicações. 

Com  a  evolução  das  comunicações  e  o  desenvolvimento  da  linguagem,  os  códigos 

tiveram  que  ser  aperfeiçoados,  se  não  substituídos,  para  poder  atender  a  crescente  demanda 

por  segurança  no  envio  de  mensagens.  A  evolução  dos  códigos  primitivos  se  dar  com  o 

surgimento das cifras (explicaremos adiante o que isso significa) que, segundo Singh (2004), 

dominaram  a  arte  dos  códigos  secretos  no  primeiro  milênio.  Porém,  estas  cifras  não 

conseguiram seguir no topo da segurança das comunicações. Isso porque havia outro ramo de 

estudo,  chamado  criptoanálise,  que  se  destinava  a  desenvolver  alternativas  para  vencer  as 

cifras. Isso fez com que fossem idealizados vários tipos de cifras com o intuito de aperfeiçoar 

as alterações feitas nas mensagens. Mesmo assim, estas cifras eram baseadas em métodos que 

possuíam muitas deficiências quanto ao seu modo de mudar o significado de uma mensagem 

e a maneira de recuperá-la. Essa deficiência foi responsável por fazer com que um novo ramo 

de  escrita  secreta  surgisse.  Daí  em  diante  a  escrita  secreta  toma  um  novo  rumo,  mais 

 
21 

moderno,  onde  a  matemática  desempenha  o  papel  principal,  garantindo  a  segurança  dos 

códigos.  

Hoje,  conhecemos  o  estudo  da  arte  dos  códigos  através  da  criptografia,  uma  ciência 

que  se  encarrega  de  desenvolver  métodos  que  possibilitem  o  máximo  de  privacidade  e 

segurança no envio de mensagens.  

O objetivo principal deste capítulo é deixar o  leitor a par dos conceitos básicos  mais 

importantes  sobre  criptografia,  e  fazer  uma  contextualização  histórica  de  como  se  deu  o 

surgimento  dos  métodos  criptográficos  clássicos,  as  cifras  clássicas.  Para  isso,  iniciaremos 

falando um pouco sobre a origem dos códigos. Abordaremos um pouco de história das cifras 

como  parte  importante  no  desenvolvimento  da  criptografia,  destacando  alguns  exemplos  de 

cifras  muito  utilizadas  no  passado.  Abordaremos  conceitos  de  extrema  importância  em 

criptografia, tais como codificação, decodificação, criptografia de chave pública, criptografia 

de  chave  privada,  etc.  Por  fim,  trataremos  da  “inimiga”  da  criptografia:  a  criptoanálise.  A 

criptoanálise  estuda  os  métodos  pelos  quais  se  podem  vencer  os  algoritmos  criptográficos, 

isto é, ela busca desenvolver técnicas que sejam capazes de descobrir o texto original de uma 

mensagem  codificada.  Precisamente,  ela  tentar  “quebrar”  os  códigos  propostos  pela 

criptografia.  Os  conceitos  básicos  aqui  apresentados  são  de  fundamental  importância  para  o 

bom entendimento deste texto. Sem tal conhecimento é difícil apreciar esta belíssima ciência 

e, principalmente, será difícil apreciar o trabalho aqui realizado.   

2.1 Sobre a Origem dos Códigos Secretos 

2.1.1 Um relato devido a Heródoto4 

Precisar  quando  os  códigos  secretos  surgiram  é  algo  muito  complicado,  pois  há 

inúmeros relatos da utilização de códigos em envios de mensagens em épocas remotas e em 

períodos diferentes da história da humanidade.  Acredita-se, e seria o natural a supor com base 

nos  relatos  históricos,  que  os  primeiros  procedimentos  para  ocultar  a  existência  de  uma 

mensagem  ao  ser  enviada  surgiram  com  maior  evidência  no  período  das  grandes  guerras 

ocorridas  há  milhares  de  anos.  De  fato,  “durante  milhares  de  anos,  reis,  rainhas  e  generais 

dependeram  de  comunicações  eficientes  de  modo  a  governar  seus  países  e  comandar  seus 

4 Historiador e geógrafo grego. Viveu entre 485 a.C e 425 a.C.  
 Fonte: <https://pt.wikipedia.org/wiki/Her%C3%B3doto>. Acesso em: 28 set. 2019 

 
                                                                                                                            
                                                             
22 

exércitos”  (SINGH,  2004,  p.11).  Essa  dependência  de  uma  comunicação  mais  segura 

provocou o início da era dos códigos secretos. “Foi a ameaça da  interceptação pelo  inimigo 

que  motivou o desenvolvimento de códigos e cifras, técnicas para  mascarar uma  mensagem 

de modo que só o destinatário possa ler seu conteúdo” (SINGH, 2004, p. 11). 

No  primeiro  capítulo  de  Singh  (2004)  consta  que  um  dos  primeiros  relatos 

relacionados  à  utilização  de  escritas  secretas  se  deve  ao  grande  historiador  Heródoto, 

conhecido como o pai da história. 

Figura 1 – Heródoto 

Fonte: <https://images.app.goo.gl/6Dcu5Aq4d4enZZij9> 

Acesso em: 25 set. 2019 

Nesse contexto, Besselaar (1962) ainda nos situa no ambiente no qual se desenvolveu 

todo o trabalho de Heródoto. O autor comenta: 

Heródoto viveu, globalmente falando, entre os dois grandes conflitos do povo grego 
no século V, entre as guerras persas e as guerras do Peloponeso, isto é, numa Grécia 
vitoriosa  sobre  os  bárbaros  e  cheia  de  si, numa  Grécia  dolorosamente  dividida  por 
correntes  de  separatismo  e  por tentativas  de  imperialismo, mas numa  Grécia ainda 
não dilacerada, massacrada e humilhada. Neste ambiente viveu e respirou Heródoto, 
deste ambiente sua obra é a eloquente expressão [...]. (BESSELAAR 1962, p. 7) 

Nesse  ambiente,  Heródoto  narra  um  episódio  sobre  os  conflitos  entre  a  Grécia  e  a 

Pércia ainda no século V a.C. onde se observa a utilização de uma manobra para enviar uma 

 
 
 
 
 
23 

mensagem  secretamente. Para entender como tudo se originou devemos nos ater as palavras 

de Singh (2004), que nos diz:  

A antiga inimizade entre a Grécia e a Pércia evoluiu para uma crise logo depois que 
Xerxes  começou  a  construir  a  cidade  de  Persépolis,  a  nova  capital  do  seu  reino. 
Presentes e tributos chegaram de todas as regiões do império e dos estados vizinhos, 
com  a notável  exceção  de  Atenas  e  Esparta.  Determinado  a  vingar  esta insolência, 
Xerxes  começou  a  mobilizar  um  exército  [...].  Ele  passou  os  cinco  anos  seguintes 
montando  secretamente  a  maior  força  de  combate  da  história.  Então,  no  ano  480 
a.C., ele estava pronto para lançar um ataque-surpresa. (SINGH, 2004, p. 20)  

Xerxes é o rei, líder dos persas. No entanto, ao elaborar seu ataque ao povo grego, ele 

não  imaginava que  seus planos estavam sendo observados por outra pessoa que  não era seu 
aliado. Esta outra pessoa se chamava Demarato5, um grego que mesmo depois de ser expulso 

da  Grécia  ainda  era  fiel  ao  seu  país  de  origem  e  estava  disposto  a tudo  para  salva  sua  terra 

natal do terrível ataque do exército persa.  Havia, entretanto, um problema: como fazer para 

avisar os gregos sobre o ataque de Xerxes? Segundo Heródoto, citado por Singh (2004): 

O  perigo  de  ser  descoberto  era  grande;  havia  apenas  um  modo  pelo  qual  a 
mensagem poderia passar: isso  foi  feito raspando a cera de um par de tabuletas de 
madeira,  e  escrevendo  embaixo  o  que  Xerxes  pretendia  fazer,  depois  a  mesma  foi 
coberta novamente com cera. Deste modo, as tabuletas pareciam estar em branco e 
não causariam problemas com os guardas ao longo da estrada. Quando a mensagem 
chegou ao seu destino, ninguém foi capaz de perceber o segredo, até que, pelo que 
entendi,  a  filha  de  Cleômenes,  Gorgo,  que  era  casada  com  Leônidas,  adivinhou  e 
contou aos outros que se eles raspassem a cera encontrariam alguma coisa escrita na 
madeira. Isso foi feito, revelando a mensagem, então transmitida para os gregos.  

Com  isso,  graças  à  engenhosidade  de  Demarato,  os  Gregos tiveram  condições  de  se 

preparar para o ataque de Xerxes, se armando fortemente para tal fim. Assim, ainda segundo 

Singh  (2004),  com  a  perda  do  elemento  surpresa,  o  rei  Xerxes  e  todo o  seu  exército  foram 

surpreendidos  e  encurralados  na  baía  de  Salamina,  aos  arredores  de  Atenas,  perdendo  o 

confronto  humilhantemente  para  o  exército  grego.  Graças  a  uma  escrita  secreta,  os  gregos 

foram capazes de se livrar dos Persas e vencer a guerra. 

O  relato  feito  acima  por  Heródoto  citado  por  Singh  (2004)  representa  um  dos 

primeiros que trata da utilização de um método primitivo para mascarar a existência de uma 

mensagem. Veja que Demarato se preocupou em esconder a mensagem, e não seu conteúdo. 

Este tipo de estratégia era muito comum e foi a primeira a ser utilizada pelo ser humano para 

5  Grego,  rei  euripôntida  de  Esparta  (Cidade  –  Estado  da  Grécia  antiga)  que  viveu  entre  515  a.C  e  491  a.C.                         
Fonte: <https://pt.wikipedia.org/wiki/Demarato>. Acesso em: 28 set. 2019 

 
 
 
                                                             
esconder  os  vestígios  de  suas  comunicações  secretas.  Na  seção  seguinte,  este  tipo  de 

estratégia receberá um nome especial, e passaremos a discuti-la com mais alguns exemplos. 

24 

2.1.2 Esteganografia e Criptografia 

Como falamos anteriormente, sobre a estratégia de Demarato, a sua ideia foi esconder 

a  mensagem  nas  tabuletas  de  madeira  raspando  sua  cera.  Quando  usamos  algum  meio  para 

esconder  a  mensagem  em  nossas  comunicações,  estamos  praticando  a  esteganografia.  Mais 

precisamente,  temos  que  “a  comunicação  secreta,  quando  é  obtida  através  da  ocultação  da 

mensagem,  é  conhecida  como  esteganografia,  nome  derivado  das  palavras  gregas  steganos, 

que  significa  coberto,  e  graphein,  que  significa  escrever”  (SINGH,  2004,  p.  21).  Portanto, 

podemos  entender  esteganografia  como  a  ciência  que  busca  criar  meios,  métodos,  que 

possibilitam  manter  a  existência  de  uma  mensagem  em  total  segredo  quando  a  mesma  é 

enviada ao seu destinatário. 

Ainda se tratando de Heródoto, o mesmo detalhou mais um episódio onde se utilizou a 

comunicação  por  meio  da  ocultação  da  mensagem,  ou  seja,  a  esteganografia,  para  repassar 
uma informação secreta. Ele narra a história de Histaeu (515 a.C – 493 a.C)6, que queria fazer 
com que Aristágora de Mileto7 se revoltasse contra o rei persa Dário I. A estratégia de Histaeu 

é ainda mais inusitada do que a de Demarato. Singh (2004) nos conta qual foi essa estratégia:  

Para  transmitir  suas  informações  em  segurança,  Histaeu  raspou  a  cabeça  do 
mensageiro,  escreveu  a  mensagem  no  couro  cabeludo  e  esperou  que  o  cabelo 
voltasse  a  crescer.  O  mensageiro,  que  aparentemente  não  levava  nada  que  fosse 
perigoso, pôde viajar sem ser incomodado. Quando chegou ao seu destino, raspou a 
cabeça e a virou para o destinatário da mensagem. (SINGH, 2004, p. 21) 

Logicamente, tal método é bem utilizado quando a mensagem não é urgente, em vista 

de ter que esperar o cabelo crescer. No entanto, ele é um belo exemplo de como o ser humano 

foi  capaz  de  pensar  em  variados  tipos  de  métodos  de  esteganografia  para  poder  enviar  suas 

mensagens em segurança. Outro episódio devido a Heródoto é, segundo Julio et al. (2007, p. 

57),  o  caso  de  um  mensageiro  que  pretendia  entregar,  secretamente,  uma  determinada 

mensagem  ao  rei.  O  mensageiro,  então,  tem  a  ideia  de  se  passar  por  um  caçador,  onde, 

6 Tirano de Mileto sob o governo do rei persa Dário I.  
Fonte: <http://www.historyofwar.org/articles/people_histiaeus.html>. Acesso em: 24 out. 2019. 
7   Líder de Mileto no período que abrange o fim do século VI a.C e o início do século V a.C. Era genro e primo 
de Histaeu. Fonte: <https://pt.wikipedia.org/wiki/Arist%C3%A1goras>. Acesso em: 24 out. 2019. 

 
 
 
                                                             
25 

colocando  a  mensagem  dentro  de  uma  lebre,  pôde  passar  livremente  pelos  guardas  sem  ser 

incomodado. 

Além  dos  exemplos  de  esteganografia  dados  por  Heródoto,  muitos  outros  foram 

surgindo ao longo dos anos que sucederam a  morte deste historiador. Um deles é devido ao 

povo  chinês.  Segundo  Singh  (2004),  para  esconder  uma  mensagem  os  chineses  a  escrevia 

numa seda fina que era então amassada em formato de bolinha e envolvida numa cera. Para o 

transporte dessa mensagem, o mensageiro a engolia, escondendo assim sua existência. 

Outro  exemplo  de  esteganografia  vem  do  povo  grego.  Na  Grécia  antiga  se 

desenvolveu  um  meio  para  enviar  mensagens  escondidas  em  livros.  O  método  consistia  em 

furar  buracos  acima  das  letras  que  formavam  a  mensagem.  Assim,  quando  o  livro  estivesse 

nas mãos do destinatário, o mesmo buscaria pelos furos no texto e reescreveria novamente a 

mensagem  enviada.  É  claro  que  tal  método  é  muito  frágil  e  fácil  de  ser  violado.  Se  uma 

pessoa  muito  esperta  suspeitasse  do  código,  poderia  fuçar  o  livro  à  procura  dos  furos  e, 

consequentemente, tomaria conhecimento da mensagem.  

Ainda  se  tratando  de  exemplos  de  esteganografia,  o  próximo  método  é  devido  ao 

matemático italiano Girolamo Cardano (1501 - 1576). Tal método é conhecido como grade de 

Cardano  (ou  grelha  de  Cardano).  Este  método  se  utiliza  de  uma  folha  rígida,  chamada 

lâmina, na qual  constam  vários  furos retangulares aleatórios, isto é, tais  furos têm tamanhos 

aleatórios  e  são  espaçados  de  modos  distintos,  com  alturas  mais  ou  menos  igual  à  de  uma 

linha  de  texto.  Para  utilizar  este  método,  coloca-se  a  grade  sobre  uma  folha  de  papel  de 

mesmas dimensões e escrevem-se as palavras da mensagem nos retângulos formados. Depois 

disso,  os  espaços  que  sobram  em  branco  são  preenchidos  com  outras  palavras  ou  letras 

quaisquer  de  modo  a  formar  a  mensagem  total  que  seria  enviada,  isto  é,  a  “mensagem  de 

cobertura” (JULIO et al., 2007, p.58). Para recuperar a mensagem, o destinatário utiliza uma 

grade  idêntica  àquela  utilizada  pelo  remetente  para  escrever  a  mensagem.  Ele  coloca  sua 

grade sobre o texto, a qual revela a mensagem enviada. 

 
 
 
 
 
Figura 2 – Um exemplo de Grade de Cardano 

26 

Fonte: autoria própria 

                                      Figura 3 – Mensagem de Cobertura 

ANDREJSKDXBHCBACRIPTOGRAFIAOKFSHGHYUSYUFERSAMÉTODOSMATEEJ 

WIJAAHDGSBDTEEIÉHIEUMATEMÁTICAHFHDJHJJDSIUMAGHDUASDHSDASLO 

JJHDHJAAUDDHGCIFRASJWHJWWMELHORESLIVROCÓDIGOSTRYKJAJJDHSQP 

VBSIALKFGTSEJSUDHHAGDNSLUEDQPOALAJDHUNIVERSIDADESEVATSDDOK 

DISGFAJHAJSERTAHFJDFHCAOHSWUUIURMATHERHMUNDOCONCLUSAOWYE 

AGORADLSKKJRIRJKDVAMOSJIREIURSNFJHJKFHESTUDARKFKJGKLWOIRUUS 

Fonte: autoria própria 

Na Figura 2 temos um exemplo de uma grade de Cardano e na Figura 3 um exemplo 

de mensagem de cobertura. Para conseguirmos  identificar a mensagem secreta é preciso que 

coloquemos sobre a mensagem de cobertura uma grade idêntica à apresentada na Figura 2. A 

Figura 4 a seguir ilustra este procedimento. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
27 

Figura 4 – Decifrando a mensagem 

A 

É 

  UFERSA 

  UMA 

  DAS 

  MELHORES 

  UNIVERSIDADES 

DO 

MUNDO 

Fonte: autoria própria 

Ao fazemos isso, surgirá a mensagem:  

A UFERSA É UMA DAS MELHORES UNIVERSIDADES DO MUNDO 

Outro  método  muito  conhecido  de  esteganografia,  bastante  usado  na  primeira  e 

segunda guerra mundial, é o microponto. A  ideia do microponto era, segundo Singh (2004), 

reduzir  uma  mensagem,  ou  uma  página  de  texto  como  o  autor  sugere,  fotograficamente  até 

que a  mesma tomasse a  forma de um  minúsculo  ponto. Feito isso, tal  mensagem poderia se 

passar  por  um  ponto  final  em  uma  frase  qualquer  do  texto  ou  por  um  pingo  em  um  “i”  de 

alguma  palavra.  Ainda  segundo  o  autor,  foi  na  segunda  guerra  mundial  que  este  método  se 

tornou  realmente  popular,  sendo  um  dos  métodos  preferidos  dos  alemães  para  enviar  suas 

mensagens secretas.  

Finalmente, a esteganografia também aborda os métodos de ocultação de  mensagens 

através  da  utilização  das  chamadas  tintas  invisíveis.  Tal  método  é  muito  antigo  e  consiste 

basicamente na utilização de substâncias extraídas de plantas, fluidos orgânicos, entre outros, 

que  se  comportam  de  maneira  a  ficar  transparentes  depois  de  secas,  mas  voltam  a  aparecer 

depois  de  um  aquecimento  do  material  na  qual  elas  foram  aplicadas.  A  este  respeito, Singh 

(2004, p.22) ressalta que  “no primeiro século depois de Cristo, Plínio, o velho,  já explicava 

como  o  ‘leite’  da  planta  titímalo  podia  ser  usado  como  tinta  invisível.  Embora  fique 

transparente  depois  de  seca,  um  aquecimento  suave  queima  a  tinta,  tornando-a  marrom”. 

Neste caso, para mandar uma mensagem secreta, bastaria escrevê-la em uma folha com o leite 

da titímalo e esperar que o mesmo secasse. Depois de seco, o texto desaparecia e a mensagem 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
28 

poderia  ser  enviada  em  segurança.  Ao  chegar  ao  destinatário,  um  simples  aquecimento  na 

folha poderia revelar o conteúdo da mensagem.  

Os  métodos de esteganografia  foram por muito tempo a melhor opção para se enviar 

uma  mensagem  em  segurança.  No  entanto,  os  exemplos  anteriores  nos  mostram  que  esta 

segurança carece de potencial. Isto é, essa segurança é relativa, uma vez que se o meio pelo o 

qual  a  mensagem  está  sendo  transportado,  digamos,  um  mensageiro,  seja  interceptado,  a 

mensagem pode ser facilmente achada (já que ela está escondida!). Com respeito a este fato, 

Singh (2004) reitera o que acabamos de falar:  

A  interceptação  da  mensagem  compromete  toda  a  sua  segurança.  Uma  vigilância 
rígida  pode  revistar  qualquer  pessoa  que  cruze  a  fronteira,  raspando  a  cera  de 
qualquer tabuleta, aquecendo folhas de papel em branco, [...] raspando a cabeça das 
pessoas.  E  assim,  inevitavelmente,  haverá  ocasiões  em  que  a  mensagem  será 
descoberta. (SINGH, 2004, p. 22) 

Assim, embora a mensagem estivesse oculta e isso representasse certa segurança, era 

necessário  algo  mais.  Para  impor  um  alto  nível  de  segurança  nos  envios  de  informações 

privadas, não bastaria apenas fazer com que essa informação desaparecesse. Era preciso que 

além  da  anulação  visível,  fosse  desenvolvido  algum  meio  para  tornar  o  conhecimento  da 

informação, por parte de terceiros não autorizados, mais difícil.  

Métodos e alternativas para modificar o texto original de uma mensagem, tornando-o 

ilegível para aqueles que não fossem seu real destinatário, impulsionaram o desenvolvimento 

de uma das mais importantes ciências do século XX, e do século XXI com maior evidência, 

chamada  criptografia.  A  palavra  criptografia  vem  do  grego  kriptos,  que  significa  secreto, 

oculto,  e  graphein,  que  significa  escrever.  Assim,  podemos  entender  criptografia  como  a 

ciência  que  estuda  os  meios,  os  métodos,  para tornar  ilegível  o  significado  original  de  uma 

mensagem,  de  modo  que  somente  o  receptor  verdadeiro  tenha  possibilidade  de  lê-la.  De 

acordo com Singh (2004), a criptografia não se interessa  em esconder a mensagem. Ela está 

preocupada,  como  a  definição  acima  mostra,  em  dificultar  a  compreensão  do  texto  original 
para intrusos8. Para isso, tanto o emissor quanto o receptor utilizam um processo lógico para 

8  Usaremos  frequentemente  os  termos  intruso,  inimigo,  para  se  referir  a  um  indivíduo  que  tenta  quebrar  um 
código,  ou  seja,  que não  tem a  chave  de  decodificação.  Tal  indivíduo  não  possui  permissão  para  participar  da 
comunicação  via  mensagens,  mas  tenta  interferir  de  algum  modo.  Esses  termos,  intruso,  inimigo,  ou  ainda 
criptoanalista, são clássicos em textos de criptografia. Por isso iremos permanecer com sua utilização, apesar de 
que  o  significado  preciso  dessas  palavras  nem  sempre  vão  condizer  com  a  intenção  do  indivíduo  que  tentar 
quebrar um código. Por exemplo, se um grupo de inteligência tenta grampear a comunicação de terroristas para o 
bem da população, esse grupo só é inimigo com relação aos terroristas.  

 
 
                                                             
29 

poder se comunicar. O transmissor utiliza um método chamado  codificação, ou encriptação, 

para modificar o conteúdo original da mensagem. O receptor recupera a mensagem através da 

decodificação, ou descriptação. Tanto a codificação quanto a decodificação são processos que 

constituem  um  “protocolo  específico,  que  já  foi  estabelecido  previamente  por  ambos, 

transmissor  e  receptor”  (SINGH,  2004,  p.  22).  De  modo  intuitivo,  significa  combinar  como 

será feito a mudança no texto original da mensagem e quais passos seguir para reverter esse 

processo e recuperar a  forma original  dessa  mensagem. Posteriormente, vamos  nos referir  a 

este  protocolo  como  um  método  criptográfico  ou  criptossistema.  Definiremos  estas  noções 

quando oportuno.  

2.1.3 Cifras de Transposição e Substituição 

Quanto a sua estrutura, a criptografia pode ser dividida  em dois ramos que,  segundo 

Singh  (2004),  são  denominados  transposição  e  substituição.  O  que  é  um  método  de 

transposição  em  criptografia?  Transpor  é  sinônimo  de  permutar.  Portanto,  os  métodos  de 

transposição  consistem  simplesmente  em  permutar,  rearranjar  as  letras  que  constituem  a 

mensagem.  Se  considerarmos  uma  mensagem  muito  curta,  digamos  com  uma  palavra 

somente,  então  fica  muito  fácil  decodificar  a  mensagem,  pois  haverá  um  número 

relativamente  pequeno  de  rearranjos  para  checarmos.  Por  exemplo,  observe  que  a  palavra 

PROFMAT tem 7 letras, então da análise combinatória, ela admite 7! (7 fatorial) permutações 

de suas letras (anagramas) (Ver Capítulo 4, Seção 4.1.5). Isso quer dizer que há 7! maneiras, 

distintas,  já  que  as  7  letras  são  diferentes,  de  codificar  a  palavra  PROFMAT  por  meio  da 

transposição.  O  número  7!  =  5040  é  pequeno  e  se  tivermos  a  disposição  um  computador, 

ficará  fácil  descobrir  todos  os  anagramas.  É  claro  que  quando  estes  métodos  surgiram  não 

havia nem a ideia de uma máquina parecida com o computador, de modo que os métodos de 

transposição foram bastante usados e considerados bem eficientes para a tecnologia da época. 

Entretanto, palavras curtas não estavam totalmente isentas de serem descobertas pelo método 

de checagem de todos os anagramas, mesmo que demorasse muito tempo. 

Se com palavras pequenas este método é frágil, seria ele totalmente seguro para frases 

longas? Não necessariamente. Singh (2004, p. 23) esclarece que: 

[...]  à  medida  que  o  número  de  letras  aumenta,  o  número  de  arranjos  possíveis 
rapidamente  explode,  tornando  impossível  obter-se  a  mensagem  original  [...].  Mas 
há uma desvantagem. A transposição efetivamente gera um anagrama incrivelmente 
difícil  e,  se  as  letras  forem  misturadas  ao  acaso,  sem  rima  ou  fundamento,  a 

 
 
decodificação  do  anagrama  se  tornará  impossível,  tanto  para  o  destinatário  quanto 
para o interceptador inimigo. (SINGH, 2004, p. 23) 

30 

Quer  dizer  que,  se  não  há  um  protocolo  bem  estabelecido  entre  o  transmissor  e  o 

receptor,  então  este  tipo  de  método  criptográfico  é  inviável  nas  trocas  de  mensagens.  A 

permutação  não  pode  ser  aleatória,  como  deixa  claro  o  autor.  Pense,  por  exemplo,  em  uma 

frase  como  “Criptografia  é  a  arte  dos  códigos  secretos”.  Ela  possui  36  letras  e  mais  de      

500 000 000 000 000 000 000 000 (quinhentos sextilhões) de rearranjos distintos possíveis. 

Logo, inviável para qualquer pessoa testar cada um desses rearranjos. Portanto, para resolver 

este problema, basta o transmissor e o receptor combinarem qual o processo lógico que será 

utilizado para codificar a mensagem. Tal processo, claro, não pode ser conhecido por pessoas 

não autorizadas.  

O exemplo abaixo trata de uma maneira bem simples de transposição e foi extraído de 

Singh (2004). O método consiste em escrever uma mensagem qualquer distribuindo as letras 

que  a  formam  em  duas  linhas  paralelas  de  modo  que  tais  letras  fiquem  alternadas  nestas 

linhas. Assim, a primeira letra fica, digamos, na linha de cima, a segunda letra fica na linha de 

baixo, a terceira letra fica na linha de cima, e assim por diante. Considere a frase a seguir: 

TEU SEGREDO É TEU PRISIONEIRO; SE DEIXÁ-LO PARTIR SERÁ PRISIONEIRO DELE. 

Agora  desconsiderando  os  espaços  entre  palavras,  as  pontuações  e  os  acentos,  podemos 

reescrever esta mensagem assim: 

TEUSEGREDOETEUPRISIONEIROSEDEIXALOPARTIRSERAPRISIONEIRODELE 

Pelo método de transposição que descrevemos acima, esta mensagem fica assim: 

T   U   E   R   D   E   E   P   I   I   N   I   O   E   E   X   L   P   R   I    S    R   S   R   S   O   E   R   D   L 

           E   S   G   E   O   T   U  R  S  O   E   R   S   D    I   A   O   A   T   R   E   A  P    I    I   N    I    O   E   E 

A  mensagem  codificada  é,  então,  representada  pela  sequência  de  letras  da  linha  superior 

seguida da sequência de letras da linha inferior, como segue: 

TUERDEEPIINIOEEXLPRISRSRSOERDLESGEOTURSOERSDIAOATREAPIINIOEE 

Para  recuperar  a  mensagem,  o  receptor  deverá  refazer  os  passos  em  ordem  contrária.  Tal 

método é denominado “cerca de ferrovia” (SINGH, 2004, p. 24). 

 
 
 
 
 
31 

Ainda  no  século  V  a.C.,  o  exército  espartano  foi  o  responsável  por  idealizar  uma 

forma  bem  inteligente  de  enviar  mensagens  codificadas  por  transposição  através  de  um 

aparelho chamado de Citale. O Citale tem formato cilíndrico, assemelhando-se a um pequeno 

bastão, que pode ser de madeira ou de outro material qualquer (naquela época estes aparelhos 

eram feitos de madeira), no qual era enrolada uma fina tira de pano, ou couro, de modo que as 

faixas  de  tiras  não  ficassem  sobrepostas.  Para  codificar  uma  mensagem  através  deste 

aparelho, o emissor a escrevia ao longo da linha do comprimento do Citale. Quando a tira era 

desenrolada,  o  que  se  via  era  apenas  um  monte  de  letrinhas  espalhadas,  sem  sentido  e  sem 

ordem. Ao chegar ao seu destino, a mensagem só era revelada se a tira fosse colocada sobre 

outro Citale com as mesmas dimensões daquele que foi usado para codificá-la.  

Para  qualquer  intruso  que  por  ventura  interceptasse  o  mensageiro,  mesmo  que  a 

mensagem  fosse  capturada,  era  preciso  ter  em  posse  um  Citale  idêntico  ao  utilizado  pelo 

emissor. Caso contrário, a mensagem permaneceria em segredo. Dependendo da esperteza do 

mensageiro, ele poderia se utilizar da esteganografia e tentar esconder a tira com as letras em 

algum lugar em seu corpo para aumentar a segurança no envio (por exemplo, poderia usar a 

tira como um cinto ou amarrá-la na perna por debaixo das roupas). O Citale espartano, como é 

conhecido  hoje,  foi,  segundo  Singh  (2004),  o  primeiro  aparelho  de  criptografia  militar 

utilizado. O Citale também é conhecido por Scytale ou Bastão de Licurgo. “A sua referência 

encontra-se  descrita  no  tomo  III  de  As  Vidas  Paralelas  de  Plutarco”  (FIARRESGA,  2010, 

p.7), que é um conjunto de obras bibliográficas dos ilustres homens da Roma e Grécia antigas 
escritas por Plutarco9. Na figura abaixo, ilustramos um exemplo de Citale.  

Figura 5 – Citale ou Bastão de Licurgo 

< https://pt.wikipedia.org/wiki/C%C3%ADtala#/media/Ficheiro:Skytale.png >  

Acesso: 18 set. 2019 

9 Lucius Mestrius Plutarchus (46 d.C. – 120 d.C, aproximadamente). Foi historiador, filósofo e biógrafo grego. 
Fonte: <https://pt.wikipedia.org/wiki/Plutarco>. Acesso em: 18 set. 2019. 

 
 
 
 
                                                             
32 

Alternativamente,  também  temos  os  métodos  de  Substituição  em  criptografia.  Ao 

contrário  do  que  ocorre  com  a  transposição, onde  mudamos  a  posição  das  letras,  mas  estas 

conservam  suas  identidades, nos  métodos de substituição cada  letra na  frase será substituída 

por outra letra, mas a posição dessa letra não é alterada. Por exemplo, poderíamos utilizar um 

processo de codificação que consiste em substituir cada letra do nosso alfabeto original A, B, 

C, D, E, ..., pela letra seguinte. Assim, o A seria substituído pelo B, o B passaria a ser o C e 

assim  sucessivamente.  Logo,  se  quiséssemos  mandar  a  mensagem  volto  ao  amanhecer  por 

meio desse  método, então depois de codificada, esta mensagem passaria  a ser  WPMUP BP 

BNBOIFDFS. Veja que nenhuma letra da mensagem mudou de posição, isto é, o V continua 

sendo  a  primeira  letra  na  frase,  o  O  a  segunda,  o  L  a  terceira  e  assim  por  diante.  Mas  a 

identidade destas  letras  mudou. Na mensagem codificada, o V passa a ser o W, o O passa a 

ser o P, etc.  

Na  criptologia10,  qualquer  método  que  consiste  em  substituir  uma  letra  do  alfabeto 

original,  a qual  consta  na  mensagem, por outra  letra ou símbolo  é chamado de  Cifra. Deste 

modo,  podemos  nos  referir  aos  métodos  de  codificação  por  substituição  como  cifras  de 

substituição.  Assim,  os  métodos  de  transposição  serão  chamados  de  cifras  de  transposição. 

Esta linguagem é  mais adequada e  mais usada  na  literatura. Passaremos a usar esses termos 

com mais frequência a partir de agora. 

Segundo Singh (2004), um dos primeiros exemplos de  Cifras de  substituição que  foi 

descrito na  literatura apareceu num  livro  muito antigo, escrito ainda  no século IV, chamado 

Kama-Sutra. Segundo o autor:  

O  Kama-Sutra  recomenda  que  as  mulheres  devem  estudar  64  artes,  incluindo 
culinária,  vestuário,  massagem  e  preparação  de  perfumes.  A  lista  também  inclui 
algumas  artes  menos  óbvias,  incluindo  magia,  xadrez,  encadernação  de  livros  e 
carpintaria.  O  número  45  da  lista  é  a  mlecchita-vikalpa,  a  arte  da  escrita  secreta, 
justificada  de  modo  a  ajudar  as  mulheres  a  esconderem  os  detalhes  de  seus 
relacionamentos. (SINGH, 2004, p. 25) 

Uma  das  Cifras  apresentada  no  Kama-Sutra,  de  acordo  com  Singh  (2004),  consistia 

numa técnica simples que era a seguinte: considerando nosso alfabeto original, no qual há 26 

letras,  separe  de  modo  aleatório  essas  26  letras  em  dois  grupos  de 13  letras.  Agora  coloque 

10 “É a ciência da escrita secreta em todas as suas formas, cobrindo ambas, a criptografia e a criptoanálise” 
(SINGH, 2004, p. 424). 

 
 
 
 
                                                             
33 

esses dois grupos em duas linhas paralelas de modo que as letras fiquem em correspondência 

uma a uma, como na Tabela 1 a seguir. 

Tabela 1 – Cifra do tipo citado no Kama-Sutra 

A 

C 

F 

H 

K 

O 

Y 

L 

E 

N 

G 

P 

U 

V 

I 

J 

D 

X 

R 

Q 

B 

T 

M 

W 

S 

Z 

Fonte: Autoria própria 

Assim  sendo,  cada  letra  na  mensagem  será  substituída  por  àquela  que  lhe  é 

correspondente  na  tabela  acima.  Assim,  por  exemplo,  a  palavra  Matemática  codificada 

passaria a ser WCBNWCBJAC. Note que na tabela que apresentamos anteriormente, temos 

apenas uma das inúmeras maneiras de montá-la, usando o raciocínio de montar dois grupos de 

13  letras,  de  modo  que  fica  muito  difícil  para  um  invasor  descobrir  como  a  mensagem  foi 

codificada,  pois  existe  um  número  imenso  de  modos  distintos  de  se  fazer  isso.  Só  por 

curiosidade,  há  (26

13)  maneiras  distintas  de  montar  a  tabela  acima,  isto  é,  há  (26

13)  maneiras 

distintas  de  codificar  uma  mensagem  qualquer  por  meio  dessa  Cifra.  O  número  (26

13)  é  o 

binomial de 26 tomados 13 à 13, e o mesmo é igual a 

26!

.  

13!(26−13)!

Neste caso, dizemos que a cifra destacada acima transforma o nosso alfabeto usual (ou 

alfabeto original) A, B, C, D, E, F, G, H, ... Y, Z no alfabeto cifrado C, T, A, X, N, H, P, F,..., 

L, S. O alfabeto original é aquele que utilizamos para escrever a mensagem de modo correto, 

legível. Já o alfabeto cifrado  é aquele composto pelas  letras, ou símbolos, que serão usados 

para codificar uma mensagem.  

Alfabeto original: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z. 

Alfabeto cifrado: C, T, A, X, N, H, P, F, J, I, O, Y, W, E, K, G, R, Q, Z, B, V, U, M, D, L, S 

Na linguagem da criptografia é comum escrevermos o alfabeto original em minúsculo 

e  o  alfabeto  cifrado  em  maiúsculo.  Assim,  as  mensagens  que  apresentaremos  cifradas  serão 

escritas  em  maiúsculas,  enquanto  que  as  mensagens  originais  a  elas  correspondentes  serão 

dadas em minúsculas (SINGH, 2004). 

Voltando  ao  exemplo  dado  acima  sobre  a  cifra  apresentada  no  Kama-Sutra  segundo 

Singh  (2004),  veja  que  dentre  tantas  possibilidades  para  montarmos  o  alfabeto  cifrado, 

 
 
 
 
 
34 

poderíamos  pensar  naquelas  que  consistem  em  substituir  cada  letra  do  alfabeto original  por 

outra letra que está a uma distância de uma, duas,..., ou 25 letras desta.  Este tipo de cifra de 

substituição é muito antigo e é considerado um dos primeiros a ser usado para fins militares 

em guerras. Neste ambiente de conflitos militares, o imperador romano Julio César (100 a.C – 
44 a.C)11 foi o primeiro a usufruir deste tipo de cifra para se comunicar com seu exército em 

combate.  De  acordo  com  Singh  (2004),  a  ideia  inicial  de  César  foi  substituir  cada  letra  do 

alfabeto original  por  aquela  que  estivesse  a  três  casas  desta  letra.  Assim,  por  exemplo,  o  A 

seria  substituído  pelo  D,  o  B  seria  substituído  pelo  E,  o  C  passaria  a  ser  o  F,  e  assim  por 

diante.  Então,  a  palavra  código,  cifrada,  passaria  a  ser  FRGLJR.  O  alfabeto  cifrado  seria, 

então, o seguinte: 

D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, A, B, C 

Veja que ele nada mais é do que o alfabeto original, transladado três casas à frente. É 

claro que não há  nada de  especial  em escolher três casas para transladar o alfabeto.  Poderia 

ser  uma  escolha  qualquer  entre  1  e  25  (26  casas  não  dar,  pois  voltaria  para  a  mesma  letra). 

Logo, o  alfabeto original  pode  ser  transladado  de  25  maneiras  e  cada  uma  dessas  maneiras 

dará origem a uma cifra do tipo acima. Em homenagem ao imperador Julio César, estas cifras 

são conhecidas como cifras de César.  

Um  caso  particular  muito  interessante  da  cifra  de  César  é  a  chamada  cifra  ROT-13. 

Ela consiste em transladar o alfabeto 13 casas à frente. Neste caso, o A será substituído pelo 

N, o B pelo O e assim por diante. É claro que a letra N será substituída pela letra A, a letra O 

passará  a  ser  o  B,  etc.,  numa  rotação  característica  das  cifras  de  César,  daí  a  sigla  ROT-13 

(que  deriva  de  rotate  by  13  places,  que  significa  girar  13  lugares,  isto  é,  rotacionar  13 

posições). Quanto à segurança dessa  cifra, trata-se da  mesma segurança das cifras de César, 

isto  é,  baixa  e  de  fácil  violação,  pois  para  reverter  o  processo  de  codificação  basta  saber 

quantas letras o alfabeto foi deslocado. Mesmo assim, ela se destaca no meio computacional, 

como afirma Freitas et al. (2018): 

[...]  a  cifra  de  ROT-13,  aplicada  aproximadamente  em  1980  na  USENET,  era 
utilizada para ocultar piadas politicamente incorretas, ou spoilers. Números, espaços 
e  pontuação não  são  alterados.  É  usada  principalmente  para  proteger  endereços  de 

11 Conheça um pouco da história de César em: < https://www.ebiografia.com/julio_cesar/>. Acesso em: 27 out. 
2019. 

 
 
 
 
                                                             
correio  eletrônico,  e  também  mensagens  postadas  em  grupos  e  listas  de  discussão 
online. (FREITAS et al., 2018, p. 3) 

35 

Há  outras  cifras  semelhantes  à  ROT-13.  Cada  uma  delas  se  encarrega  de  realizar 

algum  tipo  de  codificação  especifica  com  relação  aos  caracteres  usados  para  elaborar  uma 

mensagem. Por exemplo, a cifra ROT-5 se ocupa em codificar os algarismos da base decimal 

0, 1, 2, 3, 4, 5, 6, 7, 8, 9. A cifra ROT-13 que mencionamos anteriormente codifica somente 

nosso alfabeto usual. Para codificarmos, tanto letras quanto números, utilizamos uma junção 

das  cifras  ROT-13  e  ROT-5  para  obtermos  a  chamada  cifra  ROT-18.  Todas  elas  foram 

desenvolvidas  para  fins  elementares  de  criptografia  básica  (cuja  ação  não  vai  além  de 

codificações  de 
governamentais). Não representando, portanto, um método criptográfico seguro12. 

informações  com 

importância 

inferior  as 

informações  militares  ou 

Nas  subseções  que  seguem,  voltaremos  a  falar  sobre  a  cifra  de  César  e  suas 

ramificações,  destacando  como  tal  cifra  poderia  ser  melhorada  e  qual  a  sua  fraqueza  em 

termos  de  segurança.  Na  oportunidade  destacaremos  outras  cifras  igualmente  importantes, 

porém,  com  características  diferentes  das  cifras  que  vimos  até  o  momento.  Nossa  intenção 

será tratar o nascimento da criptoanálise e quais foram as primeiras cifras desenvolvidas como 

alternativa para vencer uma nova técnica de decodificação de mensagem que foi desenvolvida 

no  oriente  e  causou  enormes  transtornos  para  os  criptógrafos  que  utilizavam  cifras  de 

substituição  semelhantes  as  que  apresentamos  anteriormente.  Abordaremos  novamente  o 

conceito de cifra, porém agora relacionando com o conceito de código.  

2.1.4 Cifras e Códigos: qual a diferença? 

Primeiramente, é preciso deixar claro que, estritamente falando, cifra e código não é a 

mesma coisa, embora em alguns momentos estas ideias se confundam. O conceito de cifra já 

foi mencionado na Página 32 e se refere a qualquer mecanismo de criptografia que se resuma 

a converter cada  letra do alfabeto original em outra  letra ou um símbolo qualquer. Já  vimos 

alguns exemplos de cifras nas seções precedentes. Quando usamos uma cifra para modificar o 

significado  real  de  uma  mensagem,  dizemos  que  a  mensagem  foi  cifrada.  Porém, 

utilizaremos,  como  já  vínhamos  fazendo,  a  palavra  codificar  para  denotar  o  processo  de 

mudar o significado original de uma mensagem por meio de um método de criptografia, seja 

12 Veja mais: <http://www.webutils.pl/ROTencode>. Acesso em: 27 out. 2019.  

 
 
 
 
 
                                                             
36 

ele cifra ou não. Então, decodificar será usado para descrever o processo inverso. Já a palavra 

decifrar é, precisamente falando, o processo de desfazer uma codificação que foi feita através 

de  uma  cifra  (SINGH,  2004).  Entretanto,  há  autores  como  Sautoy  (2007)  que  entende  este 

conceito como sendo o ato de um indivíduo descobrir o texto original de uma mensagem por 

meio  do  texto  codificado,  sendo  que  para  isso  ele  não  utiliza  o  processo  específico  de 

decodificação. Ou seja, decifrar para Sautoy (2007) é quebrar o procedimento de codificação, 

descobrir  a  mensagem  verdadeira,  sem,  no  entanto,  ser  o  legítimo  destinatário  daquela 

mensagem.  É  com  este  entendimento  que  optamos  em  usar  a  palavra  decifrar  com  este 

significado. 

Por outro lado, “a palavra código se refere a um tipo especial de comunicação secreta, 

cujo  uso  vem  declinando  ao  longo  dos  séculos”  (SINGH,  2004,  p.  14).  Um  código  é  um 

método  de  criptografia  mais  geral  do  que  as  cifras  no  sentido  de  que  agora  palavras  ou  até 

mesmo  frases  inteiras  podem  ser  substituídas  por  outras  palavras,  números  ou  símbolos 

quaisquer. É como se os códigos fossem uma generalização das cifras. Por exemplo,             

[...]  os  agentes  secretos  usam  nomes  em  códigos  no  lugar  de  seus  nomes 
verdadeiros,  de  modo  a  esconder  suas  identidades.  De  modo  semelhante,  a  frase 
“ataque  ao  amanhecer”  pode  ser  substituída  pela  palavra  código  “júpiter”  e  esta 
palavra  será  transmitida  ao  comandante,  no  campo  de  batalha,  com  o  fim  de 
confundir o inimigo. (SINGH, 2004, p. 14) 

Ou seja, o envio de mensagens por meio de códigos se caracteriza pela definição dos 

símbolos ou palavras-códigos que substituirão o conteúdo da mensagem original. Neste caso, 

o código age como um simplificador da mensagem em questão, pois um trecho ou até mesmo 

a  própria  mensagem  inteira,  podem  ser  substituídos  por  um  único  símbolo  ou  uma  palavra. 

Este tipo de característica não é comum às cifras. Cabe, então, uma pergunta: qual a diferença 

entre código e cifra? “tecnicamente um código é definido como uma substituição de palavras 

ou frases, enquanto a cifra é definida como uma substituição de letras" (SINGH, 2004, p.47). 

Porém,  haverá  ocasiões  em  que  vamos  nos  referir  a  um  tipo  de  método  criptográfico  como 

sendo  código,  mesmo  ele  não  sendo,  necessariamente,  um,  segundo  a  definição  anterior. 

Ficará  claro  no  contexto  se  estamos  tratando  de  uma  cifra  ou  código.  No  esquema  abaixo 

apresentamos  uma  divisão  das  ramificações  da  escrita  secreta  até  agora  apresentadas  neste 

trabalho.  

 
 
 
 
Figura 6 – Algumas Ramificações da Escrita Secreta 

37 

Fonte: Singh (2004). Acesso em: 24 out. 2019 

Dentre  inúmeros  códigos  desenvolvidos  ao  longo  da  história  da  criptografia, 

destacaremos  dois  por  se  tratarem  de  sistemas  revolucionários  que  contribuíram  fortemente 

para  o  desenvolvimento  das  comunicações  e  são,  até  hoje,  mundialmente  usados:  o  Código 

Braille e o Código Morse. O código Braille (ou sistema  Braille)  foi desenvolvido por Louis 

Braille  (1809  -  1852),  um  francês  que  ficou  completamente  cego  ainda  criança  em 

decorrência de um acidente sofrido quando manipulava as  ferramentas da oficina de seu pai 

(COSTA, 2009). Uma  ligeira  versão do sistema criado por Braille  foi proposto inicialmente 

por Charles Barbier de la Serre, um capitão de artilharia que desenvolveu um tipo de código 

para  se  comunicar  com  seus  soldados.  Daí,  poderíamos  dizer  que  o  código  Braille  teve  sua 
essência em um método de esteganografia militar13. A ideia do código de Barbier era que os 

soldados pudessem ler mensagens no escuro (por isso o código ficou conhecido como escrita 

no  escuro)  e,  para  isso,  as  mensagens  eram  transmitidas  por  meio  de  pontos  em  alto  relevo 

que  poderiam  ser  “lidas”  com  as  pontas  dos  dedos.  Já  a  versão  de  Braille  ainda  conserva  a 

disposição  de  pontos  em  alto  relevo,  porém  é  mais  completa  e  menos  complexa,  “é 

constituído por 63 sinais formados por pontos a partir do conjunto matricial ⋮⋮ (123456). Este 

conjunto  de  6  pontos  chama-se,  por  isso,  sinal  fundamental”  (BRASIL,  2006,  p.17). 

Denominamos Célula Braille a qualquer disposição dos pontos do conjunto fundamental, isto 

é, a qualquer configuração que gere um sinal produzido nesse sistema. A célula vazia é aquela 

13  Não  seria  correto  afirmar  que  o  código  desenvolvido  por  Barbier  era  um  método  criptográfico,  pois  sua 
intenção  não  era  modificar  o  conteúdo  da  mensagem  de  modo  que  só  o  receptor  pudesse  entender,  e  sim 
desenvolver  algum  procedimento  para  esconder  a  mensagem  através  de  símbolos  de  modo  que  os  soldados 
pudessem  ler no  escuro.  Isto  está mais  próximo  de  um método  de  esteganografia.  Da mesma  forma, não  seria 
aconselhável  dizer  que  os  códigos  Braille  e  Morse  são  métodos  criptográficos.  Eles  não  desempenham  tal 
função, mas são meios de transmitir uma mensagem por meio de símbolos. Em suma, vamos chamá-los apenas 
de códigos. 

 
 
 
                                                             
que nenhum ponto se destaca em relação aos demais. Ela também é considerada um símbolo. 

Logo, o código Braille passa a ser formado por 64 símbolos. A Tabela 2 ilustra a codificação 

feita via Braille para o alfabeto comum e mais alguns símbolos. 

38 

Tabela 2 – Alfabeto Braille e Outros Símbolos 

Fonte: <https://images.app.goo.gl/e413h53xenzkDhBX8>. Acesso em: 19 Out. 2019 

O  sistema  Braille  foi  introduzido  no  Brasil  em  1854  na  inauguração  do  Instituto 

Benjamin  Constant  (conhecido  como  Imperial  Instituto  dos  Meninos  Cegos),  no  Rio  de 

Janeiro (COSTA, 2009). Hoje, universalmente usado, o código Braille é uma das ferramentas 

 
 
 
39 

mais  importantes  para  que  pessoas  com  deficiências  visuais  possam  ter  acesso  ao 

conhecimento por meio da leitura e escrita.  

Com  relação  ao  código  Morse,  o  mesmo  teve  como  inventor  Samuel  Finley  Breese 
Morse (1791 - 1872)14 em 1835, com o auxílio de Joseph Henry (1797 - 1878)15 e Alfred Vail 
(1807 - 1859)16. Em 1835, Morse criou um aparelho que servia para enviar mensagens à longa 

distância por meio da rede elétrica. Este aparelho ficou conhecido como telégrafo elétrico. O 

telégrafo  foi  planejado  para  mandar  e  receber  mensagens  por  meio  de  pulsos  elétricos 

produzidos através de um eletroímã que era controlado pela corrente elétrica.  

Figura 7 – O telégrafo 

Fonte: <https://images.app.goo.gl/2uRBPGftafCZU3448>. Acesso em: 28 out. 2019 

O  código  desenvolvido  por  Morse  para  mandar  mensagens  através  do  telégrafo  se 

baseava exatamente nessa característica de envio por meio de pulsos elétricos. 

14 Foi inventor, físico e pintor estadunidense. Fonte: < https://pt.wikipedia.org/wiki/Samuel_Morse>.  
Acesso em: 28 out. 2019 
15 Cientista estadunidense. Fonte: < https://pt.wikipedia.org/wiki/Joseph_Henry>. Acesso em: 28 out. 2019 
16 Maquinista e inventor estadunidense. Fonte: < https://pt.wikipedia.org/wiki/Alfred_Vail>. Acesso em: 28 out. 
2019 

 
 
 
 
 
                                                             
40 

[...]  o  sistema  telegráfico  dos  três  americanos,  inaugurado  em  1844,  foi  projetado 
para  fazer  registros  em  uma  fita  de  papel  quando  correntes  elétricas  fossem 
recebidas. O receptor original do telégrafo Morse utilizava um mecanismo de rodas 
mecânicas  para  mover  a  fita.  Quando  uma corrente  elétrica era  recebida,  um 
eletroímã acionava uma caneta na fita de papel, que estaria em movimento, fazendo 
um recorte (risco) na fita. Quando a corrente era interrompida, a caneta era retraída, 
para  que  a  porção  da  fita  que  não  tivesse  sido  utilizada  continuasse  sem  marcas. 
(PORTO, [entre 2006 e 2019], p.1, grifo nosso) 

Este risco e a parte não tocada pela caneta passaram a ser caracterizados como “traço” 

(-)  e  “ponto”  (.).  Assim,  através  do  código  criado  por  Morse  as  mensagens  poderiam  ser 

codificadas  através  desse  sistema  de  ponto  e  traço  como  sinais  a  serem  decodificados  pelo 

receptor.  “Originalmente,  Morse  imaginou  numerar  todas  as  palavras  e  em  transmitir  seus 

números  através  do  telegráfo.  O  receptor,  usando  um  enorme  ‘dicionário’  decifraria  a 

mensagem  onde  as  letras  do  alfabeto  foram  definidas  pelo  padrão  ‘ponto  e  traço’  citado 

anteriormente” (FRANÇA, 2014, p.31, grifo nosso). Coube a Alfred Vail aprimorar o código 

de  Morse,  atribuindo  um  sistema  de  letras  e  caracteres  especiais  de  modo  a  simplificar  o 

código e torná-lo mais completo. Segundo França (2014, p. 31), “este novo código reconhecia 

quatro  estados:  voltagem-ligada  longa  (traço),  voltagem-ligada  curta  (ponto),  voltagem-

desligada  longa  (espaços  entre  caracteres  e  palavras)  e  voltagem-desligada  curta  (espaços 

entre  pontos  e  traços)”.  Vail  procurou representar  cada  letra  do  alfabeto  e outros  caracteres 

por  meio  de  sequências  de  pontos  e  traços.  Cada  letra,  número,  sinais  de  pontuação,  entre 

outros  símbolos,  possuíam  sua  sequência  bem  definida  de  pontos  e  traços.  As  letras  mais 

frequentes do alfabeto inglês (alfabeto em questão na época) ficaram com as sequências mais 

curtas  e  as  letras  menos  frequentes  com  as  sequências  mais  longas  de  pontos  e  traços, 

respectivamente, como uma alternativa para deixar o código mais leve, simples e de mais fácil 

memorização. A Tabela 3 apresenta o alfabeto usual codificado por código Morse, além dos 

algarismos de 0 à 10 e alguns sinais de pontuação. 

 
 
 
 
 
 
 
 
Tabela 3 – Alfabeto em Morse e outros caracteres 

41 

Fonte: <https://images.app.goo.gl/s4nvZb2UoVUzTBJL7>. Acesso em: 29 out. 2019 

O código Morse foi rapidamente aceito pela comunidade científica da época, tornando 

o  principal  meio  de  comunicação  à  distância  através  de  mensagens  enviadas  pelo  telégrafo. 

As companhias telegráficas eram as responsáveis por coordenar os envios de mensagens (e a 

cobrar  por  isso).  O  código  Morse  foi  muito  usado  na  aviação,  nas  navegações  e  no  meio 

militar em guerras. Seu ápice de uso ocorreu no século XIX, sendo utilizados por quase todos 

os países da Europa, obtendo uma nova versão mais desenvolvida (que ficou conhecida como 

código  Morse  internacional)  em  1865,  regulamentada  pelo  Congresso  Internacional 

Telegráfico  (FRANCISCO,  2019).  Certamente  um  dos  códigos  mais  importantes  já 

 
 
 
inventados.  Foi  essencial  para  o  desenvolvimento  das  comunicações  à  longa  distância  e 

proporcionou o início da era da comunicação telefônica. 

42 

2.1.5 Análise de frequências e o nascimento da Criptoanálise 

Se há a necessidade de proteger informações preciosas enviadas via mensagens, então 

é porque se pressupõe que essa  informação também pode ser do  interesse de outras pessoas 

que não têm autorização para conhecê-la, os intrusos. Neste caso, esses intrusos tentam a todo 

custo se apossar dessas mensagens procurando entendê-la de alguma forma. Ora, para manter 

a segurança e sigilo no envio, essas mensagens foram codificadas por métodos de criptografia.  

Logo,  só  o  emissor  e  o  receptor  têm  condições  de  decodificar  a  mensagem  e  conhecer  seu 

conteúdo original. Portanto, para o intruso, caso ele consiga interceptar o envio e pôr as mãos 

na  mensagem,  o  único  modo  de  conseguir  conhecer  seu  conteúdo  é  “quebrar”  o  método ou 

código  usado  para  codificá-la.  Esse  problema  no  envio  de  mensagens  fez  com  que, 

paralelamente  ao  desenvolvimento  da  criptografia,  outra  ciência  igualmente  importante  se 

desenvolvesse.  Esta  ciência  é  conhecida  como  Criptoanálise.  A  criptoanálise  “permite 

decifrar  uma  mensagem  sem  conhecer  a  chave.  Enquanto  o  criptográfo  desenvolve  novos 

métodos  de  escrita  secreta,  é  o  criptoanalista  que  luta  para  encontrar  fraquezas  nesses 

métodos, de modo a quebrar a mensagem secreta” (SINGH, 2004, p. 32).  

O  intruso  que  citamos  anteriormente  passará  a  ser  chamado  de  criptoanalista.  Seu 

principal  objetivo  é  decifrar  a  mensagem.  E  decifrar,  segundo  nossa  concepção  já 

mencionada, significa procurar reverter o processo de codificação sem ser o real destinatário 

da  mensagem.  As  ferramentas  que  o  criptoanalista  usa  para  achar  fraquezas  nos  métodos 

criptográficos e decifrar as mensagens fazem parte dos ataques a estes códigos. Esses ataques 

são diversos. Uma breve descrição de alguns deles pode ser encontrada em Terada (2000). 

A  invenção  da  criptoanálise  é  devida  aos  árabes  que,  além  de  um  grande  domínio 

sobre as cifras de substituição monoalfabéticas, foram os responsáveis por descobrir um meio 

de  decifrar  uma  mensagem  codificada  por  tais  cifras.  Porém,  antes  disso,  foi  preciso  um 

grande  desenvolvimento  no  conhecimento  de  algumas  ciências,  tais  como  matemática  (com 

ênfase  em  estatística)  e  linguística.  Além  dessa  evolução,  houve  um  avanço  significativo 

relacionado aos estudos religiosos (SINGH, 2004). 

 
 
43 

Além  de  uma  compreensão  maior  de  assuntos  leigos,  a  invenção  da  criptoanálise 
também  dependia  do  crescimento  dos  estudos  religiosos.  Grandes  escolas  de 
teologia  foram  fundadas  em  Basra,  Kufa  e  Bagdá,  onde  os  teólogos  examinavam 
cuidadosamente as revelações de Maomé contidas no Corão17. Os teólogos estavam 
interessados  em  estabelecer  a  cronologia  das  revelações,  e  o  faziam  contando  a 
frequência  das  palavras  contidas  em  cada  revelação.  (SINGH,  2004,  p.  33,  grifo 
nosso)  

Essa é a essência da criptoanálise: contar a frequência das palavras que aparecem em 

um  texto.  Esta  atividade  evoluiu  para  a  contagem  da  frequência  das  letras  que  compõe  um 

texto.  Os  estudiosos  árabes  descobriram  que  determinadas  letras  aparecem  com  mais 

regularidades, mais frequência, do que outras. Por exemplo, “as letras a e l são mais comuns 

no idioma árabe, parcialmente devido ao artigo indefinido al-, enquanto a letra j aparece com 

frequência dez vezes menor”  (SINGH, 2004, p. 33).  

O fato de que certas letras aparecem com mais frequência do que outras em textos de 

uma  determinada  língua  foi  o  grande  responsável  pelo  primeiro  avanço  significativo  da 

criptoanálise  desenvolvida  pelos  árabes.  Apesar  de  não  se  saber  exatamente  quem  foi  a 

primeira  pessoa  a  utilizar  a  frequência  das  letras  como  uma  técnica  de  criptoanálise  e  nem 

quando  isso  ocorreu,  Singh  (2004)  assegura  que  uma  das  descrições  mais  antigas  dessa 

técnica  aparece  em  uma  obra  de  um  cientista  árabe  do  século  IX  chamado  Abu  Yusef.  A 

seguir,  apresentamos  a  descrição  feita  por  Abu  Yusef  sobre  o  método  de  análise  de 

frequências. Esta descrição pode ser encontrada em Singh (2004, p. 33).  

“Um  meio  de  se  decifrar  uma  mensagem  codificada,  quando 

conhecemos  seu  idioma,  é  encontrar  um  texto  diferente,  na  mesma 

língua,  suficientemente  longo  para  preencher  uma  página.  Então 

contamos  a  frequência  com  que  cada  letra  aparece.  A  letra  que 

aparecer com maior frequência chamamos de “primeira”, enquanto a 

segunda  mais  frequente  recebe  o  nome  de  “segunda”,  a  terceira  em 

ordem  de  frequência  vira  “terceira”  e  assim  por  diante,  até 

contarmos todas as letras diferentes no texto”. 

“Em  seguida  examinamos  o  criptograma  que  desejamos  decifrar  e 

também classificamos os seus símbolos.  Descobrimos qual o símbolo 

que aparece com maior frequência e o transformamos na “primeira” 

17 Ver: <https://www.trt.net.tr/portuguese/programas/2016/03/30/o-corao-o-livro-sagrado-dos-muculmanos-
461197>.  

 
 
                                                             
44 

letra  do  texto  que  usamos  como  amostra.  O  segundo  símbolo  mais 

comum  é  transformado  na  “segunda”  letra,  enquanto  o  terceiro 

símbolo mais frequente vira a “terceira” letra e assim por diante, até 

convertermos  todos  os  símbolos  do  criptograma  que  desejamos 

decifrar”. 

O método acima descrito é o que hoje conhecemos como análise de frequências. O que 

o  torna  eficaz  como  método  de  criptoanálise  é  o  fato  de  que  além  de  existir  letras  de  uma 

determinada  língua,  mais  frequentes  do  que  outras,  estas  frequências  são  quase  que 

constantes.  Isto  é,  ao  estudarmos  vários  textos  em  português,  por  exemplo,  veremos  que  as 

letras  aparecem  numa  regularidade  que,  em  média,  é  fixa.  Este  fato,  somado  ao  método  de 

análise de frequências, possibilita que possamos estudar um texto cifrado, contar a frequência 

de  cada  caractere  deste  texto,  e  então  fazer  algumas  estimativas  estatísticas  a  fim  de 

determinar  quais  são os  símbolos  que  estão  substituindo  cada  letra  do  alfabeto original.  Por 

exemplo, segundo Terada (2000), após análise de vários textos em português, conclui-se que a 

vogal  mais  frequente  é  o  a,  que  aparece  com  uma  frequência  de  13,5%  em  média.  Ainda 

segundo  Terada,  as  vogais  e,  i,  o  e  u  apresentam  as  seguintes  frequências,  respectivamente: 

12,5%,  6,0%,  5,5%  e  4,5%.  Portanto,  se  num  texto  cifrado  observarmos  que  uma  letra, 

digamos  y,  aparece  com  uma  frequência  mais  ou  menos  igual  a  13,5%,  então  é  muito 

provável  que  ela  esteja  substituindo  o  a  no  texto  original.  Da  mesma  forma  pensamos  os 

demais símbolos. É lógico que não há como garantir que o y está substituindo o a com 100% 

de certeza, pois trata-se de uma  média, que será  melhorada se os textos cifrados  forem cada 
vez maiores18. Dependendo da quantidade de texto analisado, estes percentuais podem variar 

bastante. Usando este pensamento para todas as letras do texto cifrado, podemos desenvolver 
uma análise que poderá nos dar pistas de como foi realizada a codificação do texto original19.  

A  análise  de  frequência  é  a  principal  técnica  usada  contra  as  cifras  de  substituição 

monoalfabéticas, pois tais cifras possibilitam que as frequências das letras sejam preservadas 

ao  passar  para  o  texto  cifrado.  Por  isso,  a  análise  de  frequências  é  classificada  como  um 

ataque estatístico somente ao texto cifrado (TERADA, 2000). A invenção da criptoanálise, em 

especial da análise de frequências, tornou as cifras de substituição monoalfabéticas frágeis e 

18 O leitor pode consultar a obra Singh (2004) para obter mais informações a respeito do método de análise de 
frequência aplicado na decifragem de mensagens, inclusive um exemplo prático de como isso pode ser feito. 
19  Este  método  não  é  eficiente  para  textos  curtos.    Textos  longos  são  mais  receptíveis  a  uma  análise  bem 
sucedida.  

 
                                                             
45 

inseguras. Mas isso teve sua parcela de importância no desenvolvimento da criptografia, pois 

motivou o desenvolvimento de novas técnicas, mais eficientes, de codificação. 

2.1.6 Chaves 

Um dos conceitos mais importantes da criptografia é o de chave. Para entender o que 

significa uma chave e qual o seu papel nos métodos criptográficos devemos ter bem claro em 

mente  a  diferença  entre  o  método  geral  de  criptografia  em  uso  (que  mais  adiante  vamos 

chamá-lo  de  algoritmo)  e  o  procedimento  específico  de  codificação  de  uma  mensagem  por 

meio  desse  método.  Vamos  esclarecer  isso  através  de  exemplos:  Digamos  que  queremos 

estabelecer uma comunicação por mensagens e escolhemos uma cifra de César como método 

de  codificação.  Ora,  de  acordo  com  a  definição  da  cifra  de  César,  qualquer  translação  do 

alfabeto  entre  1  e  25  letras  nos  fornece  uma  maneira  de  definirmos  o  alfabeto  cifrado.  Por 

exemplo, se deslocarmos o alfabeto uma, duas, três ou quatro letras à frente, obtemos cifras de 

César cujos alfabetos cifrados são, respectivamente, os seguintes: 

B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,A 

C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, A, B 

D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, A, B, C 

E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, A, B, C, D 

Assim  sendo,  cada  um  desses  alfabetos  cifrados  distintos  nos  dá  uma  maneira 

específica  de  codificar  uma  mensagem.  Portanto,  dizemos  que  cada  um  desses  alfabetos 

cifrados  constitui  uma  chave  para  a  cifra  de  César,  sendo  esta  cifra  o  método  geral  de 

codificação. Como há 25 maneiras de transladarmos o alfabeto, então a cifra de César possui 

25 chaves.  

Mais geralmente, poderíamos pensar em outra cifra de substituição com base na cifra 

de César, impondo que o alfabeto cifrado seja qualquer permutação do alfabeto original, e não 

apenas  uma  translação  como  mostrado  anteriormente.  “Neste  caso, o  algoritmo  consiste  em 

substituir cada letra do alfabeto original por uma letra do alfabeto cifrado, e o alfabeto cifrado 

pode consistir em qualquer rearranjo do alfabeto original.  A  chave define o alfabeto cifrado 

exato que será usado em uma codificação em particular” (SINGH, 2004, p. 27).  

 
46 

A importância das chaves está ligada a segurança dos métodos criptográficos. São elas 

que bem caracterizam a segurança das cifras de substituição, com maior ênfase nos métodos 

que  funcionam com  chave única.  A quantidade de chaves é que define o grau de segurança 

dessas cifras no sentido de que se a cifra possui um número muito grande de chaves, então é 

muito difícil para um intruso quebrá-la por meio de uma tentativa de descobrir a chave certa 

de codificação. Por exemplo, a cifra de César só  possui 25 chaves, então fica  fácil  para um 

inimigo  tentar  descobrir  a  chave  certa  por  tentativas.  Por  outro  lado,  usando  a  cifra  que 

mencionamos  anteriormente,  onde  o  alfabeto  cifrado  pode  ser  qualquer  permutação  das  26 

letras do alfabeto original, o número de chaves cresce para 26! (26 fatorial), que é um número 

gigantesco.  Logo,  fica  praticamente  impossível  para  uma  pessoa  não  autorizada  descobrir  a 

chave  exata  com  tantas  possibilidades  a  testar,  mesmo  que  ela  saiba  qual  foi  o  método 

utilizado.  

O conhecimento do método geral usado para codificar a mensagem pode (ou não) ser 

do conhecimento do intruso. No entanto, mesmo  de posse da cifra em uso,  se o mesmo  não 

conhece a chave ou não tem  nenhuma condição  de obtê-la por qualquer de seus  métodos, a 

mensagem continua em segurança.  

De  um  modo  geral,  se  um  inimigo  intercepta uma mensagem  em  código,  ele  pode 
suspeitar  qual  seja  o  algoritmo,  mas  espera-se  que  ele  não  conheça  a  chave  exata. 
Por  exemplo,  ele  pode  suspeitar  de  que  cada  letra no  texto  original  foi  substituída 
por  uma  letra  diferente,  de  um  alfabeto  cifrado,  mas  é  improvável  que  o  inimigo 
saiba qual alfabeto cifrado foi usado. (SINGH, 2004, p. 27) 

Mais importante do que se ter um número imenso de chaves, é saber guardar bem elas, 

isto  é,  deve-se  manter  sempre  em  segredo  a  chave,  sendo  de  posse  restrita  do  emissor  e 

receptor.  A  justificativa  para  isso  é  óbvia,  uma  vez  que  se  a  chave  exata  cair  nas  mãos  do 

inimigo,  ele  poderá  decodificar  todas  as  mensagens  que  foram  codificadas  usando  aquela 

chave. Daí a relevância do sigilo da chave, que supera o sigilo do algoritmo utilizado. Ou seja, 

o conhecimento do algoritmo de criptografia utilizado não é mais  importante do que manter 

em segredo a chave. Segundo Singh (2004, p. 28),  

A  importância  da  chave,  em  oposição  ao  algoritmo,  é  um  princípio  constante  da 
criptografia, como foi definido de modo definitivo em 1883 pelo linguista holandês 
Auguste Kerckhoff von Nieuwenhof, em seu livro La Cryptographie Militaire. Este 
é o princípio de Kerckhoff: ‘a segurança de um criptossistema não deve depender da 
manutenção de um criptoalgoritmo em segredo. A segurança depende apenas de se 
manter em segredo a chave’. (SINGH, 2004, p. 28) 

 
 
 
47 

Criptossistemas estão intimamente relacionados ao conceito de função, generalizam e 

conceituam precisamente a ideia de métodos criptográficos, e serão abordados no Capítulo 4. 

Já  criptoalgoritmo  é  um  novo  nome  usado  para  se  referir  a  algoritmos  de  criptografia.    É 

preciso ressaltar que essa preocupação em manter em sigilo a chave de codificação só se faz 

presente  na  criptografia  de  chave  privada  (que  abordaremos  mais  adiante).  Como  até  agora 

nosso  métodos  estão  nessa  classe  de  criptografia,  a  discussão  acima  é  relevante  e  mostra  a 

importância do sigilo da chave nesse ambiente. No entanto, existe outro tipo de criptografia, 

que atua com duas chaves, onde a chave de codificação pode ser conhecida por qualquer um, 

mas a chave de decodificação é mantida em segredo. Faremos uma breve apresentação desses 

tipos de criptografia na Seção 2.2.  

2.1.7 Cifras de substituição Monoalfabéticas e Polialfabéticas 

A cifra de César e as demais cifras de substituição que já conhecemos até o momento 

possuem uma característica comum no que tange seu modo de agir: cada  uma delas faz com 

que  cada  letra  do  alfabeto  original  seja  substituída  por  uma  única  letra  do  alfabeto  cifrado. 

Quando  isso  acontece,  dizemos  que  a  cifra  usada  é  monoalfabética.  Mais  geralmente,  “uma 

cifra  monoalfabética  é  construída  ao  fazer  corresponder  cada  letra  distinta  do  alfabeto  a 

exatamente um  símbolo distinto” (FRANÇA, 2014, p.19). Ainda segundo França (2014), ao 

se considerar um conjunto de símbolos que serão usados para substituir os  caracteres de um 

texto legível e se esta substituição ainda preserva a característica de trocar cada caractere do 

texto  original  por  um  único  símbolo  substituto,  então  a  cifra  ainda  é  considerada 

monoalfabética.  

Da  mesma  forma,  se  em  uma  cifra  de  substituição  pode-se  trocar  cada  caractere  do 

texto  original  por  dois  ou  mais  símbolos  do  alfabeto  cifrado,  diremos  que  a  mesma  é  uma 

cifra  de  substituição  polialfabética.  Se  denominarmos  por  alfabeto  cifrante  o  conjunto  de 

símbolos (letras e outros caracteres) que serão usados para substituir as  letras da  mensagem 

original,  então  denominaremos  de  cifra  polialfabética  toda  aquela  que  admitir  mais  de  um 

alfabeto  cifrante  (FRANÇA,  2014).  É  possível,  em  uma  cifra  de  substituição  polialfabética, 

utilizar vários alfabetos cifrantes para codificar as letras de uma mesma mensagem. 

Em razão da fragilidade das cifras de substituição monoalfabéticas frente à análise de 

frequências,  as  cifras  de  substituição  polialfabéticas  surgiram  como  uma  brilhante  solução 

 
 
48 

para vencer este tipo de criptoanálise. Este tipo de cifra é imune à análise de frequência por se 

utilizar  vários  alfabetos  cifrados  para  codificar  o  texto  de  uma  mesma  mensagem.  Isso 

dificulta a contagem das frequências das letras que aparecem na mensagem cifrada.  

Um  dos  primeiros  exemplos  de  cifras  de  substituição  polialfabética  foi  proposto  por 

Leon Battista Alberti (1404 - 1472) no século XV.  

Naquela  época  todas  as  cifras  de  substituição  exigiam  um  único  alfabeto  cifrado 
para  codificar  cada  mensagem.  Alberti  propôs  o  uso  de  dois  ou  mais  alfabetos 
cifrados,  usados  alternadamente,  de  modo  a  confundir  os  criptoanalistas  em 
potencial. (SINGH, 2004, p.64) 

Isso significa que cada letra que aparece na mensagem original poderá ser substituída 

de duas maneiras diferentes na mensagem codificada. Ou seja, podemos alternar os alfabetos 

cifrados para codificar uma mensagem. Na Tabela 4, ilustramos um exemplo da cifra proposta 

por Alberti. Esta tabela pode ser encontrada em Singh (2004). 

Tabela 4 – Cifra de Alberti 

Alfabeto original: 

a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z 

Alfabeto cifrado 1: 

F  Z  B V  K I  X A Y M E P  L  S  D  H  J O R G N  Q  C  U  T  W 

Alfabeto cifrado 2: 

G  O X B  F W T H Q  I  L A  P  Z  J  D  E S V Y C  R  K  U  H  N 

Fonte: Singh (2004) 

De acordo com a tabela anterior, a letra a pode ser substituída pela letra F ou pela letra 

G. Da mesma forma, a letra d pode ser trocada por V ou por B e assim por diante. Então, se 

quisermos codificar a palavra tese, por exemplo, poderemos substituir o t por G, por meio do 

alfabeto cifrado 1. O e pode ser substituído por K ou F. Escolhamos K. A letra s passará a ser 

V,  utilizando  o  alfabeto  cifrado  2.  A  última  letra  e  será  substituída  por  F.  A  palavra  tese, 

codificada,  fica  assim:  GKVF.  Veja  que  a  mesma  letra  e  foi  codificada  de  duas  maneiras 

distintas. “A vantagem crucial do sistema de Alberti é que a mesma letra do texto original não 

aparece necessariamente como uma única letra no texto cifrado [...]” (SINGH, 2004, p.64). 

 
 
 
 
49 

No entanto, “embora houvesse descoberto o avanço mais significativo das cifras num 

período  de  mil  anos,  Alberti  não  conseguiu  desenvolver  sua  ideia,  transformando-a  num 

sistema completo de cifragem” (SINGH, 2004, p.64). Coube, então, a um trio de intelectuais a 

tarefa  de  dar  continuidade  ao  trabalho  de  Alberti  e  desenvolver  seu  trabalho  por  completo. 
Johannes Trithemius20 (1462 - 1516), Giovanni Porta21 (1535 - 1615) e Blaise de Vigenère22 

(1523 - 1596) deram suas contribuições para que a cifra de Alberti pudesse ser aperfeiçoada. 

Entretanto, coube a este último, Blaise de Vigenère, dar a versão final da cifra de Alberti. A 

novidade  colocada  por  Vigenère  é  que,  no  lugar  de  dois,  ele  utiliza  26  alfabetos  cifrados. 

Cada um desses alfabetos cifrados é do tipo dos da cifra de César, transladado 1, 2, 3,..., 26 

letras,  respectivamente.  Então,  cada  letra  da  mensagem  original  poderá  ser  codificada  de 

acordo  com  um  desses  26  alfabetos  cifrados.  Para  codificar  uma  mensagem,  usa-se  o 

quadrado de Vigenère, (ver Figura 8) que consiste na disposição do alfabeto original (na parte 

superior) juntamente com os 26 alfabetos transladados. É com ele que podemos nos orientar 

para seguir os passos corretos de codificação de cada letra do texto a ser codificado.  

20    Pseudônimo  de  Johann  Heidenberg,  polímata  e  monge  beneditino  alemão.  Foi  lexicógrafo,  cronista, 
criptógrafo  e  ocultista.  Dentre  suas  obras  há  uma  que  trata  da  esteganografia,  denominada  steganographia, 
escrita  por  volta  de  1499.  Saiba  mais  em:  <https://www.renaissanceastrology.com/trithemius.html>  e     
<https://pt.wikipedia.org/wiki/Johannes_Trithemius>. Acesso em: 23 out. 2019. 
21      Giovanni  Battista  Della  Porta.  Filósofo,  Cosmológico  e  Dramaturgo  italiano. Escreveu  inúmeros  trabalhos 
sobre os mais variados temas. Dentre eles, destaca-se um sobre criptografia, onde é descrito um dos primeiros  
exemplos 
em:  
<https://pt.wikipedia.org/wiki/Giovanni_Battista_della_Porta>. Acesso em: 24 out. 2019. 
22    Diplomata e criptógrafo francês.  Fonte: <https://en.wikipedia.org/wiki/Blaise_de_Vigen%C3%A8re>. 
Acesso em: 24 out. 2019.  

polialfabética. 

substituição 

mais 

Veja 

cifra 

de 

de 

 
         
 
 
 
 
 
 
          
 
                                                             
 
        Figura 8 – Quadrado de Vigenère 

50 

Fonte: <https://images.app.goo.gl/M3AHJ44PtX7KeZie9>. Acesso em: 24 out. 2019. 

É  claro  que  existem  inúmeras  maneiras  de  se  codificar  uma  mensagem  por  esse 

método.  Recaímos  então  naquele  problema  sobre  essa  codificação  não  ser  aleatória.  Isso 

causaria sérios problemas para o emissor e o destinatário. Então, para resolver este problema, 

usa-se uma palavra-chave (ou frase-chave) como meio de segurança para  lembrar os passos 

da codificação e, por outro lado, efetuar a decodificação. Cada letra da palavra-chave indicará 

qual  foi  a  linha  utilizada  no  quadrado  de  Vigenère.  Desse  modo,  suponhamos  que  a 

mensagem  “abortar  a  missão  imediatamente”  deva  ser  codificada  por  meio  da  cifra  de 

Vigenère. O emissor e o receptor combinam que a palavra-chave a ser utilizada será “lutar”. 

Então,  para  codificar  a  mensagem,  o  emissor  começa  escrevendo  repetidas  vezes  a  palavra-

chave  acima  ou  abaixo  da  mensagem  de  modo  que  cada  letra  da  mensagem  esteja  em 

correspondência com uma letra da palavra-chave, como mostra a Tabela 5 a seguir. 

 
 
 
51 

Tabela 5 – Utilizando a palavra-chave 

Palavra-chave 

l   u  t  a  r  l  u  t  a  r  l  u  t  a  r  l   u  t  a  r  l  u  t   a  r  l  u   

Mensagem  

a  b  o  r  t  a  r  a  m  i  s  s  a  o  i  m  e  d  i  a  t  a  m  e  n  t  e 

   Fonte: Autoria própria 

Feita esta associação, o emissor passa a codificar cada uma das letras da mensagem. O 

proceder do emissor será o seguinte: para codificar a primeira  letra da  mensagem, a  letra  a, 

ele  nota  de  inicio  que  a  letra  que  está  associada  ao  a  é  o  l.  Então,  como  dissemos 

anteriormente,  esta  letra  l  indica  uma  linha  do  quadrado  de  Vigenère,  que  no  caso  é  a  12ª 

linha.  Sendo  assim,  para  achar  a  letra  substituta  do  a,  o  emissor  considera  a  coluna  do 

quadrado de Vigenère correspondente  à  letra a, que no caso é a 1ª coluna, e observa  a  letra 

que está na intersecção dessa coluna com a 12ª linha, que no caso será o próprio l. Portanto, a 

primeira  letra  da  mensagem  será  substituída  pela  letra  l.  Da  mesma  forma,  para  codificar  a 

segunda  letra  da  mensagem,  a  letra  b,  o  emissor  nota  que  ela  está  associada  à  letra  u  na 

Tabela 3 e que ela determina a 21ª linha do quadrado de Vigenère. Como a letra b define a 2ª 

coluna,  a  letra  que  se  encontra  na  intersecção  da  2ª  coluna  com  a  21ª  linha  é  o  v.  Logo,  a 

segunda letra da mensagem será substituída pela letra  v. O emissor repete este procedimento 

para todas as letras da mensagem, codificando a mensagem por completa por meio da cifra de 

Vigenère. A Tabela 6 a seguir mostra o resultado final da codificação. 

Tabela 6 – Codificando a mensagem 

Palavra-chave 

l   u  t  a  r  l  u  t  a  r  l  u  t  a  r  l   u  t  a  r  l  u  t   a  r  l  u   

Mensagem  

a  b  o  r  t  a  r  a  m  i  s  s  a  o  i  m  e  d  i  a  t  a  m  e  n  t  e 

Mensagem codificada  L V H R K L L T M Z D M T O Z X Y W I R E U F E E E Y 

        Fonte: Autoria própria 

 
 
 
 
52 

A  palavra-chave  é  importante  na  utilização  da  cifra  de  Vigenère  porque  permite  ao 

emissor e receptor memorizar  facilmente a  maneira de codificar e decodificar as  mensagens 

trocadas. Sem contar que, uma vez definida essa palavra-chave ou frase-chave, o emissor e o 

receptor tem  total  sigilo  sobre  a  mesma,  pois  podem  simplesmente  guardar  essa  palavra  ou 

frase  na  mente,  tornando  pouco  provável  o  conhecimento  dela  por  parte  de  intrusos.  Assim 

sendo,  essas  palavras  ou  frases  que  são  usadas  como  auxiliares  para  a  codificação  de 

mensagens pela cifra de Vigenère constituem, literalmente, chaves dessa cifra, no sentido que 

abordamos  na  Seção  2.1.5.  Todavia,  é  fácil  notar  que  há  uma  quantidade  muito  grande  de 

chaves para esta cifra, pois qualquer palavra ou frase podem ser usadas como chaves para esse 

método.  Sem  contar  que  existem  as  maneiras  aleatórias  de  codificação,  as  quais  podem  ser 

descritas por meios de regras estabelecidas ou passos realizados para efetuar a codificação de 

uma determinada mensagem. 

2.1.8 O conceito de Algoritmo 

Os  métodos  gerais  de  codificação  são  chamados  de  Algoritmos.  O  termo  algoritmo 

aparece com  muita  frequência  em  criptografia. Não é por menos, já que  se constitui de uma 

noção  fundamental  nessa  ciência  (e  em  geral  para  a  ciência  da  computação),  veja    

Brookshear  (2013).  Portanto,  precisamos  entender  a  ideia  intuitiva  de  algoritmo.  Assim, 

“informalmente,  um  algoritmo  é  um  conjunto  de  passos  que  define  como  uma  tarefa  é 

realizada” (BROOKSHEAR, 2013, p. 2). Esse conjunto de passos, poderíamos encarar como 

uma receita para resolver determinada classe de problemas (a tarefa) (COUTINHO, 2005). 

Existem  muitos  algoritmos  e  lidamos  com  eles  o  tempo  todo.  Por  exemplo,  uma 

receita culinária é um exemplo simples de algoritmo. Considere a tarefa de fazer um bolo. 

Um  bom  livro  de  receita  tem  logo  depois  do  nome  do  bolo,  uma  lista  de 
ingredientes  necessários  à  sua  confecção.  Seguem-se  as  instruções  do  que  fazer 
com os ingredientes para chegar ao objetivo; coisas como: peneire, misture, bata, 
asse. Finalmente, temos o resultado: o bolo pronto. (COUTINHO, 2005, p.17 ) 

O  funcionamento  dos  algoritmos  imita  o  processo  de  fabricação  de  um  bolo.  O  que 

chamamos de Entrada e Saída do algoritmo corresponde, respectivamente, aos ingredientes e 

ao  bolo  pronto.  O  algoritmo  é  então  o  conjunto  das  instruções  para  fazer  o  bolo  dados  os 

ingredientes.  De  modo  geral,  o  algoritmo  é  caracterizado  pelo  conjunto  formado  por  sua 

entrada, saída e a receita para a realização do processo. 

 
 
 
53 

A  matemática  é  recheada  de  importantes  e  fundamentais  algoritmos.  Vamos  tratar 

alguns  desses  algoritmos,  tais  como  Algoritmo  de  Euclides  e  Algoritmo  da  divisão,  no 

Capítulo 3. Existem algoritmos de fatoração (Crivo de Eratóstenes, Algoritmo de fatoração de 

Fermat,  algoritmos  modernos  de  fatoração,  como  Crivo  Quadrático,  entre  outros).  Existem 

algoritmos  para  testar  primaridade  (testar  se  um  número  inteiro  é  primo,  ou  não),  para 

resolver  Equações  Diofantinas,  Congruências  Lineares,  etc.  O  leitor  interessado  no  assunto 

pode consultar Coutinho (2005) e Martinez et al. (2013).  

Na  criptografia  o  algoritmo  é  o  próprio  método  criptográfico.  Sua  entrada  é  a 

mensagem  original,  e  sua  saída  a  mensagem  codificada.  O  algoritmo  propriamente  dito  é  o 

passo a passo de como a codificação é realizada.  

Se  tratando  de  algoritmos  de  modo  geral,  é  claro  que  se  desejamos  realizar  alguma 

tarefa por meio de um, duas importantes perguntas devem ser feitas: Primeira, dada a entrada 

do algoritmo, realmente chegaremos a um resultado conveniente? E segunda, este resultado é 

alcançado  em  tempo  finito  (e  curto,  de  preferência)?  É  sabido  que  existem  processos  que 

podem ser realizados infinitamente, e algoritmos que se baseiam em processos desse tipo não 

são  descartados,  veja  Brookshear  (2013),  Capítulos  0  e  5.  Entretanto,  para os  interesses  em 

criptografia, os algoritmos devem se basear em procedimentos que podem ser realizados em 

tempo  finito,  caso  contrário  nunca  teríamos  a  mensagem  codificada.  Assim,  segundo 

Coutinho (2005), um conjunto de instruções pode ser considerado um algoritmo para resolver 

determinado problema se for satisfeitas as seguintes condições: (a) essas instruções, ao serem 

realizadas,  devem  conduzir  a  um  resultado.  (b)  o  resultado  deve  ser  o  esperado.  Ou  seja, 

usando  uma  terminologia  mais  rigorosa,  o  algoritmo  deve  convergir  para  uma  solução  do 

problema.  

Estas considerações devem bastar para que o conceito de algoritmo seja entendido. No 

próximo  capítulo  iremos  estudar  um  importante  algoritmo  de  criptografia,  o  RSA.  Este  é, 

portanto, o principal exemplo de algoritmo criptográfico que  iremos abordar. No Capítulo 4 

iremos  considerar  mais  alguns  algoritmos  simples  de  codificação,  mas  a  importância  deles 

reside  no  caráter  didático,  pois  os  mesmos  serão  usados  como  fonte  para  tratar  assuntos  de 

matemática básica. 

 
 
 
54 

2.2 Criptografia de Chave Privada e Criptografia de Chave Pública 

Nesta seção nosso objetivo é dar uma breve introdução às subdivisões da criptografia, 

que são as seguintes: Criptografia Simétrica, conhecida como Criptografia de Chave Privada e 

Criptografia Assimétrica, conhecida também como Criptografia de Chave Pública. Como um 

tratamento mais detalhado sobre esses ramos da criptografia fogem inteiramente dos objetivos 

deste trabalho, trataremos apenas de apresentar o significado e as características de cada um 

deles. 

2.2.1  Criptografia de Chave Privada 

Ao  tratamos  de  algumas  das  cifras  clássicas  em  seções  anteriores,  vimos  que  as 

mesmas  são  métodos  criptográficos  que  utilizam  apenas  uma  chave  para  desenvolver  os 

processos de codificação e decodificação. Por exemplo, as codificações feitas por métodos de 

substituição simples podem ser facilmente desfeitas, isto é, a mensagem pode ser decodificada 

(ou  decifrada)  se  soubermos  como  ocorreu  a  substituição,  ou  seja,  qual  o  alfabeto  cifrado. 

Assim,  o  conhecimento  da  chave  usada  para  codificação  (o  processo  específico  de 

codificação)  acarreta  o  conhecimento  do  processo  de  decodificação.  Afinal,  é  só  reverter  o 

processo. Dizemos nesse caso que a cifra de substituição simples é um método de criptografia 

de chave privada porque usa apenas uma chave e esta chave, obviamente, deve ser  mantida 

em segredo, sendo de posse restrita do emissor e destinatário legítimos. A área da criptografia 

que abrange os  métodos (algoritmos) criptográficos de chave privada chama-se Criptografia 

de Chave Privada (ou simétrica). 

Existem  muitos  exemplos  de  métodos  criptográficos  de  chave  privada.  Os  métodos 

que vimos até agora são todos de chave privada. Existem outros mais modernos e sofisticados 

que  desempenham  papel  importante  na  segurança  computacional.  Entre  eles  podemos 

destacar os seguintes: O Data Encryption Standard (DES), criado pela International Business 

Machines  (IBM)  no  ano  de  1977,  considerados  um  dos  melhores  algoritmos  do  mundo, 

tomado  como  padrão  de  criptografia  nos  Estados  Unidos,  até  perder  esse  posto  para  seu 

sucessor  Advanced  Encryption  Standard  (AES).  “Em  outubro  de  2000,  o  secretário  de 

comércio  dos  Estados  Unidos  anunciou  o  novo  Padrão  Avançado  de  Codificação 

Criptográfica  (Advanced  Encryption  Standard)  proposto  à  nação”  (BUCHMANN,  2002).  O 

 
 
55 

International  Data  Encryption  Algorithm  (IDEA)  é  outro  algoritmo  de  chave  privada  criado 

no ano de 1991 por James Massey e Xuejia Lai (FRANÇA, 2014). 

É  fácil  perceber  qual  a  fragilidade  dos  métodos  de  criptografia  de  chave  privada. 

Como a  mesma só trabalha com uma chave, para se desenvolver uma troca de mensagens o 

emissor  e  o  destinatário  deveriam  intercambiar  a  chave  usada  antes  de  realizar  a  troca  de 

mensagens.  Esse  intercâmbio,  claro,  poderia  ser  feito  pessoalmente,  caso  os  envolvidos  se 

encontrassem  para  trocar  as  chaves.  Ou  então  eles  poderiam  enviar  a  chave  por  mensagem 

através  de  um  veículo  de  comunicação  qualquer.  Acontece  que  em  ambos  os  casos  a  chave 

não estaria segura e poderia facilmente cair em mãos inimigas. Esta situação se agrava quando 

a troca de mensagens acontece entre muitos envolvidos. A segurança e gerenciamento dessas 

chaves torna-se um caos.  

Imagine  esse  tipo  de  criptografia  como  segurança  hoje  na  internet.  Se  desejássemos 

efetuar  uma  compra  em  uma  loja  virtual  qualquer, teríamos  que  esperar  a  loja  mandar  uma 

mensagem  informando  como  deveríamos  codificar  os  nossos  dados  pessoais  para  efetuar  o 

pagamento  da  nossa  compra,  isto  é,  a  loja  mandava  a  chave  de  codificação  para  que 

pudéssemos  codificar,  por  exemplo,  os  dados  do  cartão  de  crédito,  para  pagar  a  compra. 

Porém,  como  a  comunicação  entre  loja  e  comprador  estava  sendo  realizada  por  meio  da 

internet,  a  segurança  da  chave  enviada  pela  loja  poderia  ser  violada  por  terceiros  e, 

consequentemente, os nossos dados pessoais não estariam seguros (SAUTOY, 2007). 

2.2.2 Criptografia de Chave Pública 

Felizmente  um  novo  tipo  de  criptografia  foi  proposto  em  1976  para  acabar  com  o 

problema no gerenciamento da chave privada (veja Seção 3.2, Capítulo 3). Esse novo tipo de 

criptografia  traz  como  novidade  o  fato  de  que  ele  funciona  com  duas  chaves  distintas,  uma 

para  codificação  e  outra  para  decodificação,  e o conhecimento  da  chave  de  codificação  não 

possibilita  decodificar  a  mensagem.  Ou  seja,  a  chave  de  codificação  pode  ser  pública  e  só 

quem  poderá  decodificar  a  mensagem  é  o  real  destinatário.  A  chave  de  codificação  é  então 

chamada de chave pública e a chave de decodificação é a chave privada e deve ser  mantida 

em  segredo.  Sobre  o  funcionamento  deste  novo  tipo  de  criptografia,  Sautoy  (2007,  p.  243) 

acrescenta: 

 
 
56 

O  sistema  de  criptografia  de  chave  pública  é  como  uma  porta  com  duas  chaves 
diferentes: a chave A tranca a porta, mas uma chave diferente, B, a destranca. Então, 
não  é  mais  necessário  manter  qualquer  confidencialidade  em  relação  à  chave  A. 
Distribuir cópias dela não compromete a segurança. (SAUTOY, 2007, p. 243) 

O  primeiro  método  de  criptografia  de  chave  pública  desenvolvido  foi  o  RSA.  Este 

método  é  abordado  brevemente  neste  trabalho  no  Capítulo  3  como  aplicação  de  noções 

básicas  de  aritmética.  A  criptografia  de  chave  pública  propõe  o  desenvolvimento  de  um 

método criptográfico que atue com duas chaves distintas. Neste caso, costuma-se dizer que os 

métodos  de  criptografia  de  chave  pública  atuam  baseados  numa  função  (bijetiva)  de  mão 

única (FRANÇA, 2014). Isso quer dizer que esses  métodos são baseados em processos que, 

em essência, são fáceis de ser realizados, mas impossíveis de serem revertidos sem o uso da 

chave privada. Pense, por exemplo, na porta com duas chaves distintas. É fácil fechar a porta 

com a chave  A,  mas  impossível abri-la com a  mesma chave. O  método RSA se  baseia  num 

problema dessa natureza, que é o problema da fatoração de números inteiros. Daremos mais 

esclarecimentos sobre isso no Capítulo 3, mas para o leitor interessado em saber mais sobre a 

história e desenvolvimento da criptografia de chave pública e o método RSA sugerimos uma 

consulta às obras Sautoy (2007) e Singh (2004). 

 
 
 
 
 
 
 
 
 
 
 
 
 
57 

3  APLICAÇÕES I: ARITMÉTICA BÁSICA EM CRIPTOGRAFIA RSA 

“Os  números 

inteiros  desempenham  um  papel  fundamental  na  criptografia” 

(BUCHMANN, 2002, p.11). Entretanto, o estudo sobre os métodos clássicos de criptografia 

que  fizemos  até  agora,  baseado  nas  cifras,  ainda  não  nos  ajuda  a  entender  o  porquê  dos 

números  inteiros  serem  tão  importantes  para  a  segurança  da  criptografia  moderna.  Isto  se 

justifica  pelo  fato  de  que  as  cifras  clássicas  eram  métodos  de  criptografia  que  tinham  sua 

segurança  baseadas  em  procedimentos  que  alteravam  o  alfabeto  original,  mudando  a 

característica  das  letras  para  que  pudesse  ser  realizada  a  codificação.  Quanto  mais  bem 

elaborado fosse esse procedimento e maior fosse o número de chaves possíveis, melhor seria a 

cifra, uma vez que ela seria mais difícil de ser quebrada. 

A  matemática,  nesse  estágio  da  criptografia,  ainda  não  era  utilizada  no 

desenvolvimento de técnicas para impor maior segurança aos métodos criptográficos. Daí os 

números inteiros (positivos) só apareciam em suas funções naturais, expressando quantidades 

relacionadas com esses métodos. Por exemplo, utilizamos números inteiros positivos e noções 

a eles relacionadas para contar o número de chaves das cifras de transposição. Foi a partir da 

criação  da  criptografia  de  chave  pública,  ou  assimétrica,  que  a  matemática,  em  particular  a 

teoria dos números, passou a ocupar um lugar de destaque no mundo dos códigos secretos. A 

criptografia moderna tem hoje suas bases fixadas em problemas da teoria dos números e é isso 

que a torna tão segura.  

Portanto,  com  o  intuito  de  apresentar  um  exemplo  de  método  criptográfico  de  chave 

pública  e  estudar  os  conceitos  de  aritmética  básica  contidos  no  seu  desenvolvimento,  o 

presente capítulo tem por finalidade explorar o método RSA, destacando como o mesmo está 

definido,  seu  funcionamento  e  sua  segurança.  Para  isto,  como  o  método  RSA  se  baseia  em 

muitos conceitos elementares de teoria dos números, faremos inicialmente uma revisão sobre 

esses  conceitos,  procurando  mencionar  os  resultados  e  propriedades  mais  importantes  para 

que  possamos  desenvolver  com  mais  clareza  nossa  análise  sobre  como  essas  noções  estão 

relacionadas com a criptografia do RSA. É preciso frisar que nosso interesse aqui é investigar 

a matemática básica presente na criptografia. Sendo assim,  uma análise mais profunda sobre 

criptografia  RSA,  e  mais  geralmente  sobre  criptografia  de  chave  pública,  foge  inteiramente 

dos nossos objetivos e, portanto, não será realizada. 

Quanto  à  apresentação  de  conceitos  envolvendo  teoria  dos  números,  faremos  o 

possível para simplificar as notações, deixar mais claras as definições e as demonstrações que 

 
58 

aparecerão. Exemplos serão dados para tornar ainda mais fácil a compreensão dos conceitos 

expostos. É bem verdade que muitos dos conceitos que estudaremos aqui não são tão comuns 

no currículo de matemática no ensino básico. Mas, nossa abordagem se caracteriza, como na 

maioria dos livros de teoria elementar dos números (relacionados com criptografia), pelo fato 

de partirmos de noções simples sobre números inteiros, como divisibilidade e máximo divisor 

comum,  e  estendê-las  ao  ponto  que  acharmos  necessário  para  o  entendimento  básico  da 

matemática  presente  no  RSA.  Da  mesma  forma,  a  abordagem  sobre  o  método  RSA  será 

bastante  didática,  com  exemplos  que  ilustrarão  como  os  processos  de  codificação  e 

decodificação são realizados, bem  como se estrutura a eficiência e segurança desse  método. 

Para  o  desenvolvimento  deste  capítulo  nos  apoiaremos  em  obras  que  tratam  de  teoria  dos 

números ou criptografia. Entre elas, se destacam: Santos (2014), Alencar Filho (1989), Hefez 

(2014),  Shokranian  (2005),  Terada  (2000),  Buchmann  (2002),  Medeiros  (2017),  Carneiro 

(2017), Coutinho (2005), entre outros. 

3.1 Conceitos básicos de teoria dos números 

Como  já  mencionado,  é  de  fundamental  importância  o  conhecimento  dos  conceitos 

básicos  de  aritmética  para  melhor  compreender  a  descrição  e  o  funcionamento  do  método 

RSA. Mais importante ainda é poder analisar como a matemática básica se faz presente nesse 

meio.  Por  isso,  nesta  seção  discutiremos  sobre  diversos  conceitos  clássicos  da  teoria 

elementar dos números com a intenção de extrair as noções mais importantes e presentes na 

criptografia  RSA,  evidenciando  como  essas  noções  se  fazem  presentes  na  matemática  do 

ensino  básico,  ou  como  elas  derivam  de  temas  estudados  nessa  fase  de  ensino.  Números 

inteiros  e  suas  propriedades, 

tais  como  Divisibilidade,  Máximo  Divisor  Comum, 

Congruências,  etc,  serão os  principais  assuntos tratados  nesta  seção.  A  seguir,  faremos  uma 

breve  revisão  do  conjunto  dos  números  inteiros  e  do  Princípio  da  Boa  Ordenação,  com  o 

intuito de fornecer uma breve introdução para os leitores não familiarizados com o tema. Caso 

contrário, o leitor pode seguir para a Seção 3.2. 

3.1.1 Números inteiros e o princípio da boa ordenação 

Denomina-se  conjunto  dos  números  inteiros,  denotado  por  ℤ,  o  conjunto  cujos 

elementos são:  

 
 
 
59 

… − 4, −3, −2, −1, 0, 1, 2, 3, 4, … 

Ou  seja,  ℤ = {… − 4, −3, −2, −1, 0, 1, 2, 3, 4, … }.  Assim,  podemos  escrever  ℤ = ℕ ∪ {0} ∪

ℤ−, onde ℕ = {1, 2, 3, 4, … } é o conjunto dos números naturais e ℤ− = {−1, −2, −3, −4, … } é 
o conjunto dos números inteiros negativos.  

Em  ℤ  estão  definidas  duas  operações23:  uma  adição  (+),  que  a  cada  par  𝑎, 𝑏  de 

números inteiros faz corresponder sua soma 𝑎 + 𝑏 ∈ ℤ, e uma multiplicação (.), que associa a 

esses inteiros seu produto 𝑎. 𝑏 ∈ ℤ. Estas operações possuem as seguintes propriedades: 

(i)  A  adição  e  a  multiplicação  são  comutativas.  Ou  seja,  para  todos  𝑎, 𝑏 ∈ ℤ,  vale  que 

𝑎 + 𝑏 = 𝑏 + 𝑎 e 𝑎 ⋅ 𝑏 = 𝑏 ⋅ 𝑎.  

(ii) A adição e a multiplicação são associativas. Isto quer dizer que para todos 𝑎, 𝑏, 𝑐 ∈ ℤ, vale 

𝑎 + (𝑏 + 𝑐) = (𝑎 + 𝑏) + 𝑐 e 𝑎 ⋅ (𝑏 ⋅ 𝑐) = (𝑎 ⋅ 𝑏) ⋅ 𝑐. 

(iii) Existe o elemento neutro da adição, denotado por 0 e chamado de zero. Ou seja, para todo 

inteiro  𝑎, tem-se 𝑎 + 0 = 0 + 𝑎 = 𝑎. 

(iv)  Existe  o  elemento  neutro  da  multiplicação,  denotado  por  1  e  chamado  de  um.  Ou  seja, 

para todo inteiro  𝑎, vale que 𝑎 ⋅ 1 = 1 ⋅ 𝑎 = 𝑎. 

(v)  Para  todo  𝑎 ∈ ℤ  existe  −𝑎 ∈ ℤ,  tal  que,  𝑎 + (−𝑎) = (−𝑎) + 𝑎 = 0.  O  elemento  – 𝑎  é 

chamado de simétrico aditivo de 𝑎.  

(vi)  A  multiplicação  é  distributiva  com  relação  à soma.  Ou  seja,  para todos  𝑎, 𝑏, 𝑐 ∈ ℤ,  vale  

𝑎 ⋅ (𝑏 + 𝑐) = 𝑎 ⋅ 𝑏 + 𝑎 ⋅ 𝑐. 

(vii) O produto de dois  inteiros só é zero se, e somente se, ao menos um dos fatores é zero. 

Dito de outra forma, isso quer dizer que 𝑎 ⋅ 𝑏 = 0 ⇔ 𝑎 = 0 ou 𝑏 = 0. 

Além das propriedades de (i) a (vii), podemos definir uma relação de ordem (<) em ℤ 

segundo a qual podemos comparar dois números inteiros, como segue. 

Definição 3.1 Dados os inteiros  𝑎 e 𝑏, dizemos que 𝑎 é  menor do que 𝑏, e indicaremos por 

𝑎 < 𝑏, quando 𝑏 − 𝑎 ∈ ℕ, isto é, quando 𝑏 − 𝑎 for positivo. Analogamente, dizemos que 𝑎 é 

23 Uma operação num conjunto 𝑋 nada mais é que uma função (aplicação) 𝑓: 𝑋x𝑋 → 𝑋, que associa a cada par 
de elementos 𝑥, 𝑦 ∈ 𝑋x𝑋 um elemento 𝑧 = 𝑓(𝑥, 𝑦). Veja mais em: Monteiro (1969). 

 
                                                             
60 

maior do que 𝑏, e indicaremos por 𝑎 > 𝑏, quando 𝑎 − 𝑏 ∈ ℕ. Quando for verdade que 𝑎 < 𝑏 

ou  𝑎 = 𝑏,  diremos  que  𝑎  é  menor  do  que  ou  igual  𝑏  e  denotaremos  por    𝑎 ≤ 𝑏. 

Analogamente, 𝑎 ≥ 𝑏 significa que 𝑎 é maior do que ou igual 𝑏. 

Algumas propriedades importantes da relação de ordem (<) em ℤ são as seguintes:  

a) Como ℤ = ℕ ∪ {0} ∪ ℤ−, e esses conjuntos são disjuntos, segue que se 𝑎 é um inteiro não 

nulo, então ou 𝑎 é positivo ou 𝑎 é negativo. Ou seja, se 𝑎 ∈ ℤ e 𝑎 ≠ 0, então 𝑎 > 0 ou 𝑎 < 0. 

b) Dados 𝑎, 𝑏, 𝑐 ∈ ℤ, se for 𝑎 < 𝑏 e 𝑏 < 𝑐, então 𝑎 < 𝑐. (Propriedade transitiva) 

c) 𝑎 < 𝑏 se, e somente se, 𝑎 + 𝑐 < 𝑏 + 𝑐, para todos 𝑎, 𝑏, 𝑐 ∈ ℤ. 

d) Sejam 𝑎, 𝑏, 𝑐 ∈ ℤ, com 𝑐 > 0. Se 𝑎 < 𝑏, então 𝑎. 𝑐 < 𝑏. 𝑐. Esta propriedade diz que o sinal 

da  desigualdade  não  se  altera  se  multiplicarmos  o  mesmo  número  positivo  em  ambos  os 

lados.  

e)  Sejam  𝑎, 𝑏, 𝑐 ∈ ℤ,  com  𝑐 < 0.  Se  𝑎 < 𝑏,  então  𝑎 ⋅ 𝑐 > 𝑏 ⋅ 𝑐.  Esta  propriedade  diz  que  o 

sinal  da  desigualdade  é  alterado  se  multiplicarmos  o  mesmo  número  negativo  em  ambos  os 

lados.  

Propriedades análogas as anteriores também são válidas se substituirmos  < por ≤. O 

leitor interessado pode consultar Monteiro (1969), Hefez (2014) ou Alencar Filho (1989) para 

obter  mais  informações  a  respeito  das  propriedades  da  relação  de  ordem  em  ℤ  e  suas 

consequências,  bem  como  outras  propriedades  derivadas  daquelas  mencionadas  sobre  a 

adição e multiplicação que não citaremos aqui.  

A  noção  de  relação  de  ordem  definida  em  ℤ  nos  possibilita  estudar  o  importante 

conceito  de  conjuntos  limitados  e  elemento  mínimo  de  um  conjunto  de  números  inteiros, 

como segue. 

Definição  3.2  Um  conjunto  𝐴 ⊂ ℤ  é  limitado  inferiormente  quando  existe  um  inteiro  𝑎,  tal 

que, 𝑎 ≤ 𝑥 para todo elemento 𝑥 de 𝐴. Quando esse 𝑎 pertencer ao conjunto 𝐴, diremos que 𝑎 

é  o  menor  elemento  (ou  elemento  mínimo)  do  conjunto  𝐴.  Analogamente,  𝐴 ⊂ ℤ será  dito 

limitado  superiormente  se  existir  um  inteiro  𝑏, tal  que, 𝑏 ≥ 𝑥  para todo 𝑥 ∈ 𝐴.  No  caso  em 

que  esse  𝑏  pertencer  a  𝐴,  diremos  que  ele  é  o  maior  elemento  (ou  elemento  máximo)  do 

conjunto 𝐴. Se 𝐴 for limitado superior e inferiormente, diremos que 𝐴 é limitado. 

 
61 

É fácil ver que se o elemento mínimo (resp. máximo) existir, então ele é único.  

Um resultado importante que usaremos como técnica de demonstração mais adiante é 

o chamado Princípio da Boa Ordenação (PBO), que assegura que todo subconjunto de ℤ, não 

vazio  e  limitado  inferiormente,  admite  o  elemento  mínimo.  De  modo  semelhante,  pode-se 

verificar que todo subconjunto de ℤ, não vazio e limitado superiormente, admite um elemento 

máximo.  O  princípio  da  boa  ordenação  é  inicialmente  tratado  no  conjunto  ℕ  dos  naturais, 

onde  é  assegurado  que  todo  subconjunto  não  vazio  admite  um  menor  elemento.  Ele  é 

apresentado como teorema, cuja demonstração é consequência do princípio de indução finita 

(ver,  por  exemplo,  Santos  (2014)).  Para  a  demonstração  do  PBO  em  ℤ  podemos  usar  essa 

versão em ℕ para garantir o resultado mencionado anteriormente.  

Teorema 3.1 (Princípio da Boa Ordem em ℤ) Seja 𝐴 ⊂ ℤ, não vazio e limitado inferiormente. 

Existe 𝑎 ∈ 𝐴, tal que, 𝑎 ≤ 𝑥 para todo 𝑥 ∈ 𝐴.  

Demonstração: A prova deste teorema é bem simples. Primeiro, note que como 𝐴 ⊂ ℤ é não 

vazio e limitado inferiormente, então existe 𝑛0 ∈ ℤ, tal que, 𝑛0 ≤ 𝑥 para todo 𝑥 ∈ 𝐴. Assim, 

se  for  𝑛0 ∈ 𝐴,  não  há  nada  o  que  demonstrar.  Por  outro  lado,  se  𝑛0 < 𝑥,  para  todo  𝑥 ∈ 𝐴, 

então 𝑥 − 𝑛0 > 0. Considerando o conjunto 𝑆 de todos os elementos da forma 𝑥 − 𝑛0, isto é,  

𝑆 = {𝑥 − 𝑛0;  𝑥 ∈ 𝐴}. 

Vemos que  𝑆 é um  subconjunto não vazio de  ℕ, pois 𝐴 ≠ ∅. Logo, pelo PBO em  ℕ, temos 

que  existe  o  elemento  mínimo  de  𝑆.  Denotemos  por  𝑝  esse  elemento  mínimo.  Daí  existe 

𝑎 ∈ 𝐴 tal que 𝑝 = 𝑎 − 𝑛0. Como 𝑝 é o mínimo de 𝑆, então qualquer que seja o 𝑥 ∈ 𝐴, tem-se 

𝑝 ≤  𝑥 − 𝑛0 ⟹ 𝑎 − 𝑛0 ≤  𝑥 − 𝑛0 ⟹ 𝑎 ≤  𝑥.  Donde  concluímos  que  𝑎  é  o  menor  elemento 

de 𝐴. ∎ 

Faremos uso desse princípio na Seção 3.1.3, onde estudaremos o algoritmo da divisão, outra 

propriedade muito importante do conjunto dos números inteiros.  

3.1.2 Divisibilidade em ℤ: definição e algumas propriedades básicas 

O  conceito  de  divisibilidade  já  se  faz  presente  no  currículo  de  matemática  do  ensino 

fundamental  logo  no  6º  ano  (antiga  5ª  série).  Lá  este  conceito  é  estudado  com  relação  a 

 
 
62 

números  naturais.  Aprendemos  desde  então  que  dados  dois  números  naturais  𝑚  e  𝑛  (com 

𝑚 > 𝑛, por exemplo), se ao dividirmos 𝑚 por 𝑛 e o resto dessa divisão for zero, então 𝑚 será 

dito  divisível  por  𝑛,  ou  que  𝑛  divide  𝑚.  Caso  o  resto  seja  diferente  de  zero,  𝑚  não  será 

divisível  por  𝑛.  Esta  definição  nos  possibilita  estudar  múltiplos,  divisores,  números  primos, 

decomposição  em  fatores  primos,  máximo  divisor  comum,  mínimo  múltiplo  comum,  entre 

outros assuntos. Tudo isso tendo como campo de atuação o conjunto ℕ dos números naturais.  

Estendendo a definição dada anteriormente sobre divisibilidade em ℕ para o conjunto ℤ 

dos números inteiros, obtemos a seguinte versão: dados os números inteiros 𝑎 e 𝑏, com 𝑏 ≠ 0, 

ao dividirmos  𝑎 por 𝑏 e o resto for zero, o número 𝑎 será divisível por 𝑏. Caso contrário,  𝑎 

não  será  divisível  por  𝑏.  No  caso  em  que  o resto  é  zero,  podemos  escrever  𝑎 = 𝑏 ⋅ 𝑞 + 0, o 

que implica 𝑎 = 𝑏 ⋅ 𝑞, onde 𝑞 é chamado de quociente da divisão de 𝑎 por 𝑏 (o problema de 

obter  quociente  e resto  numa  divisão  será  formalizado  na  próxima  seção).  Isso  é  facilmente 

observado  se  pensarmos  na  maneira  usual  de  realizarmos  uma  divisão.  Por  exemplo,  60 

dividido por 15 dá resto 0 e quociente 4, isto é, 60 = 4 ⋅ 15 + 0 = 4 ⋅ 15. Se pensarmos em 

dois números inteiros genéricos 𝑎 e 𝑏, sendo 𝑏 ≠ 0, o esquema a seguir ilustra o caso em que 

a divisão de 𝑎 por 𝑏 dá resto 0.  

Figura 9 – Divisão exata de 𝑎 por 𝑏 

Fonte: Autoria própria 

Da mesma forma, se 𝑎 e 𝑏 são inteiros tais que 𝑎 = 𝑏 ⋅ 𝑞, com 𝑞 ∈ ℤ, então o resto da divisão 

de 𝑎 por 𝑏 é 0. Com base nessas observações, somos levados à seguinte definição. 

Definição  3.3  Sejam  dados  dois  números  inteiros  𝑎  e  𝑏,  com  𝑏 ≠ 0.  Dizemos  que  𝑎  é 

divisível por 𝑏, ou que 𝑏 divide 𝑎, quando existe um número inteiro 𝑞 tal que 𝑎 = 𝑏 ⋅ 𝑞.  

 
 
 
 
 
 
 
63 

Observe que  𝑎 = 𝑏 ⋅ 𝑞 é o mesmo que  𝑎
 𝑏

= 𝑞  inteiro. Ou seja, a  divisão de  𝑎 por 𝑏 é exata. 

Usamos o símbolo 𝑏|𝑎 para indicar que 𝑏 divide 𝑎. Quando 𝑏|𝑎 dizemos também que 𝑎 é um 

múltiplo de 𝑏, ou que 𝑏 é um divisor de 𝑎. Quando 𝑏 não divide 𝑎 usamos a simbologia 𝑏 ∤ 𝑎 

e isso significa que não existe inteiro 𝑞 tal que 𝑎 = 𝑏 ⋅ 𝑞.  

Exemplo 3.1 2|16, pois 16 = 2.8. Já 5 ∤ 12, pois não existe 𝑞 ∈ ℤ que verifique a igualdade 

12 = 5 ⋅ 𝑞.  
Observação  3.1  A  relação24  𝑏  divide  𝑎,  denotada  por  𝑏|𝑎, recebe  o  nome  de  relação  de 

divisibilidade em ℤ (ALENCAR FILHO, 1989). 

A  relação  de  divisibilidade  em  ℤ  admite  várias  propriedades  importantes.  Além  de 

caracterizar  o  conjunto  dos  números  inteiros,  estas  propriedades  são  usadas  constantemente 

nas demonstrações de resultados que envolvem a noção de divisibilidade. No teorema a seguir 

iremos  destacar  algumas  dessas  propriedades  e  suas  referidas  demonstrações.  Outras 

propriedades de importância superior serão desenvolvidas mais adiante.  

Teorema  3.2:  Sejam  𝑎,  𝑏  e  𝑐  números  inteiros.  A  relação  de  divisibilidade  admite  as 

seguintes propriedades: 

(i) 𝑎|0, 1|𝑎 e 𝑎|𝑎. Esta última é chamada de propriedade reflexiva. 

(ii) se 𝑎|𝑏 e 𝑏|𝑐, então 𝑎|𝑐. (propriedade transitiva) 

(iii) se 𝑎|𝑏, então 𝑎. 𝑐|𝑏. 𝑐. 

(iv) Se 𝑎|𝑏 e 𝑏 ≠ 0, então |𝑎| ≤ |𝑏|. Esta propriedade nos ensina que se 𝑎|𝑏, então, em valor 

absoluto,  𝑎  não  pode  ser  maior  do  que  𝑏.  Mais  ainda,  no  caso  em  que  temos  𝑎|𝑏  e  for 

|𝑎| > |𝑏|, então se deve ter, necessariamente, 𝑏 = 0.   

(v) se 𝑎|𝑏 e 𝑏|𝑎, então |𝑎| = |𝑏|. Em particular, quando 𝑎 e 𝑏 são números naturais, esta 

propriedade nos garante que se 𝑎|𝑏 e 𝑏|𝑎, então 𝑎 = 𝑏.  

(vi) se 𝑎|𝑏 e 𝑎|𝑐, então para todos os números inteiros 𝑥 e 𝑦 é válido que 𝑎|(𝑏. 𝑥 + 𝑐. 𝑦). Ou 

seja,  se  𝑎  divide  𝑏  e  𝑐  ao  mesmo  tempo,  então  𝑎  divide  qualquer  combinação  linear  com 

coeficientes inteiros de 𝑏 e 𝑐. 

24 Segundo Monteiro (1969), chama-se relação todo subconjunto ℛ do produto cartesiano 𝐸X𝐹, onde 𝐸 e 𝐹 são 
conjuntos. Diz-se nesse caso que ℜ é uma relação de 𝐸 em 𝐹. Quando ℜ é uma relação de 𝐸 em 𝐸, isto é, num 
conjunto nele mesmo, dizemos simplesmente que ℜ é uma relação sobre 𝐸. Assim sendo, podemos dizer que a 
relação de divisibilidade é uma relação sobre ℤ. Ou seja, um subconjunto de ℤ𝑥ℤ.  

 
 
 
 
 
                                                             
64 

Demonstração: 

(i) Segue imediatamente das igualdades: 0 = 𝑎 ⋅ 0, 𝑎 = 𝑎 ⋅ 1.  

(ii)  Com  efeito,  do  fato  de  𝑎|𝑏  e  𝑏|𝑐  segue  que  existem  números  inteiros  𝑞  e  𝑟,  tais  que 

𝑏 = 𝑎 ⋅ 𝑞  e  𝑐 = 𝑏 ⋅ 𝑟.  Logo,  𝑐 = 𝑏 ⋅ 𝑟 = (𝑎 ⋅ 𝑞) ⋅ 𝑟 = (𝑞 ⋅ 𝑟) ⋅ 𝑎.  Como  𝑞 ⋅ 𝑟  é  inteiro,  segue 

que 𝑎|𝑐. 

(iii)  Basta  notar  que  se  𝑎|𝑏,  então  podemos  escrever  𝑏 = 𝑎 ⋅ 𝑞, 𝑞 

inteiro.  Logo,                      

𝑏 ⋅ 𝑐 = (𝑎 ⋅ 𝑞) ⋅ 𝑐 = 𝑞 ⋅ (𝑎 ⋅ 𝑐). Portanto, 𝑎 ⋅ 𝑐|𝑏 ⋅ 𝑐. 

(iv) De fato, existe 𝑞 inteiro, tal que, 𝑏 = 𝑎 ⋅ 𝑞. Como 𝑏 ≠ 0, segue que 𝑞 ≠ 0 e 𝑎 ≠ 0. Logo, 

|𝑞| > 0, o que acarreta que |𝑞| é um número natural. Assim, temos |𝑞| ≥ 1. Segue então que: 

|𝑏| = |𝑎 ⋅ 𝑞| = |𝑎| ⋅ |𝑞| ≥ |𝑎| ⋅ 1 = |𝑎|. Portanto, |𝑏| ≥ |𝑎|.  

(v) Basta notar que se 𝑎|𝑏 e 𝑏|𝑎, então existem 𝑡, 𝑔 ∈ ℤ, tais que 𝑏 = 𝑎 ⋅ 𝑡 e 𝑎 = 𝑏 ⋅ 𝑔. Logo, 

𝑎 = 𝑏 ⋅ 𝑔 = (𝑎 ⋅ 𝑡) ⋅ 𝑔 = 𝑎 ⋅ (𝑡 ⋅ 𝑔). Assim, como 𝑎 ≠ 0, segue que 𝑡 ⋅ 𝑔 = 1. Isto implica 

que |𝑡| = |𝑔| = 1. Logo, |𝑎| = |𝑏 ⋅ 𝑔| = |𝑏||𝑔| = |𝑏|. Onde nesta última igualdade usamos o 

fato de que |𝑥 ⋅ 𝑦| = |𝑥| ⋅ |𝑦| para todos 𝑥, 𝑦 inteiros. 

(vi)  De  fato,  basta  ver  que  sendo  𝑎|𝑏  e  𝑎|𝑐,  então  𝑏 = 𝑎 ⋅ 𝑞  e  𝑐 = 𝑎 ⋅ 𝑟,  onde  𝑞  e  𝑟  são 

números  inteiros.  Logo,  𝑏 ⋅ 𝑥 + 𝑐 ⋅ 𝑦 = (𝑎 ⋅ 𝑞) ⋅ 𝑥 + (𝑎 ⋅ 𝑟) ⋅ 𝑦 = 𝑎 ⋅ (𝑞 ⋅ 𝑥 + 𝑟 ⋅ 𝑦).  Como 

(𝑞 ⋅ 𝑥 + 𝑟 ⋅ 𝑦) ∈ ℤ, segue que  𝑎| (𝑏 ⋅ 𝑥 + 𝑐 ⋅ 𝑦). ∎ 

3.1.3 Divisão Euclidiana  

A divisão euclidiana possibilita ampliar a noção de divisão em ℤ para os casos em que 

𝑏 ∤ 𝑎. Ao dividirmos 𝑎 por 𝑏, nem sempre essa divisão será exata, isto é, haverá ocasiões em 

que  o  resto  será  diferente  de  zero.  “No  entanto,  o  conjunto  dos  números  inteiros  tem  uma 

característica muito importante que é responsável por várias propriedades nesse conjunto. Em 

ℤ  sempre  é  possível  efetuarmos  a  divisão  de  dois  elementos,  obtendo  resto  pequeno”             

(MEDEIROS, 2017, p. 31). Este resultado fundamental em teoria dos números é apresentado 

a seguir como teorema, cuja demonstração se baseia em Alencar Filho (1989) e Hefez (2014). 

 
 
 
 
 
 
 
 
 
65 

Teorema 3.3: Sejam 𝑎 e 𝑏 dois inteiros dados, com 𝑏 ≠ 0. Existem, e são únicos, os inteiros 

𝑞 e 𝑟, tais que,  

𝑎 = 𝑏 ⋅ 𝑞 + 𝑟, com 0 ≤ 𝑟 < |𝑏| 

Os inteiros 𝑞 e 𝑟 com estas propriedades são chamados, respectivamente, de quociente e resto 

da divisão de 𝑎 por 𝑏. 

Demonstração: Como devemos provar a existência e unicidade, faremos a demonstração em 

duas  etapas.  Na  primeira  provaremos  a  existência  de  𝑞 e 𝑟,  e  na  segunda  a  unicidade  dos 

mesmos.  Suporemos  também  𝑏 > 0.  O  caso  em  que  𝑏 < 0  segue  como  consequência  desse 

primeiro e será provado por último. 

1ª etapa: Consideremos o conjunto 𝑆 de todos os inteiros  não negativos da  forma  𝑎 − 𝑏 ⋅ 𝑥, 

com 𝑥 inteiro. Ou seja,  

𝑆 = {(𝑎 − 𝑏 ⋅ 𝑥) ∈ ℤ; 𝑎 − 𝑏 ⋅ 𝑥 ≥ 0 e 𝑥 ∈ ℤ} 

Claramente  𝑆  é  limitado  inferiormente  (por  0)  e  não  vazio.  Com  efeito, tomando  𝑥 = −|𝑎|, 

segue  que  𝑎 − 𝑏 ⋅ 𝑥 = 𝑎 − 𝑏 ⋅ (−|𝑎|) = 𝑎 + 𝑏 ⋅ |𝑎|.  Como  𝑏 > 0,  temos  que  𝑏 ≥ 1  (já  que 

𝑏 ∈ ℤ). Segue então que  

𝑎 + 𝑏 ⋅ |𝑎| ≥ 𝑎 + 1 ⋅ |𝑎| = 𝑎 + |𝑎| ≥ 0 ⟹  𝑎 − 𝑏 ⋅ 𝑥 = 𝑎 − 𝑏 ⋅ (−|𝑎|) ∈ 𝑆. 

Portanto,  segue  pelo  princípio  da  boa ordenação em  ℤ  (Teorema  3.1)  que  existe o  elemento 

mínimo de  𝑆. Seja  𝑟 esse elemento mínimo. Assim, existirá  𝑞 ∈ ℤ, tal que, 𝑟 = 𝑎 − 𝑏 ⋅ 𝑞. É 

claro que 𝑟 ≥ 0, visto que 𝑟 é elemento de 𝑆. 

Note que até agora já temos justificada a existência de inteiros 𝑞 e 𝑟 com 𝑟 = 𝑎 − 𝑏 ⋅ 𝑞 ≥ 0. 

Para concluir nossa prova de existência será preciso provar que 𝑟 < 𝑏. Isto de fato é verdade. 

Com  efeito,  se  fosse  𝑟 ≥ 𝑏,  então  𝑟 − 𝑏 = 𝑎 − 𝑏 ⋅ 𝑞 − 𝑏 = 𝑎 − (𝑞 + 1) ⋅ 𝑏 ≥ 0 ⟹ 𝑟 − 𝑏 ∈

𝑆.  Mas  isso  é  um  absurdo,  pois  sendo  𝑏 > 0,  o  número  𝑟 − 𝑏  é  menor  do  que  𝑟,  que  é  o 

elemento  mínimo  de  𝑆. Portanto,  deve-se  ter 𝑟 < 𝑏.  Garantimos  então  a  existência  de  𝑞  e  𝑟 

com 𝑎 = 𝑏 ⋅ 𝑞 + 𝑟 e 0 ≤ 𝑟 < 𝑏. 

2ª etapa: Para provar que 𝑞 e 𝑟, com as propriedades mencionadas anteriormente, são únicos, 

suporemos a existência de outro par de inteiros 𝑞1, 𝑟1 possuindo as mesmas propriedades de 𝑞 

e 𝑟. Ou seja, tais que 𝑎 = 𝑏 ⋅ 𝑞1 + 𝑟1 , com 0 ≤ 𝑟1 < 𝑏. Assim sendo, teremos: 

𝑏 ⋅   𝑞1 + 𝑟1 = 𝑏 ⋅ 𝑞 + 𝑟 ⟹ 𝑏 ⋅ (𝑞1 − 𝑞) = 𝑟 − 𝑟1  (1) 

 
 
 
 
 
66 

Dessa  igualdade  segue  que  𝑏| 𝑟 − 𝑟1.  Porém,  como  0 ≤ 𝑟 < 𝑏  e  0 ≤ 𝑟1 < 𝑏,  temos  que 

0 ≤ 𝑟 < 𝑏 e – 𝑏 < −𝑟1 ≤ 0. Donde segue que: 

𝑟– 𝑏 < 𝑟 − 𝑟1 ≤ 𝑟 ⟹ −𝑏 ≤ 𝑟 − 𝑏 < 𝑟 − 𝑟1 ≤ 𝑟 < 𝑏 ⟹ −𝑏 < 𝑟 − 𝑟1 < 𝑏 ⟹ |𝑟 − 𝑟1| < 𝑏. 
Desta forma, temos que  𝑏| 𝑟 − 𝑟1 e |𝑟 − 𝑟1| < 𝑏. Segue da propriedade (iv) do Teorema 3.2 

que 𝑟 − 𝑟1 = 0 ⟹ 𝑟 = 𝑟1. O que acarreta, de (1), que 𝑞1 = 𝑞, pois 𝑏 ≠ 0.  

Provamos assim que, se existem outros inteiros 𝑞1 e 𝑟1 possuindo as mesmas propriedades de 

𝑞 e 𝑟, então 𝑞1 = 𝑞 e 𝑟1 = 𝑟. Isso garante que 𝑞 e 𝑟 são únicos.  

Para finalizar a prova, vamos supor o caso em que 𝑏 < 0. Neste caso, 𝑡 = |𝑏| > 0. Pelo que já 

provamos,  existem  únicos  𝑠, 𝑟 ∈ ℤ  com  𝑎 = |𝑏| ⋅ 𝑠 + 𝑟  e  0 ≤ 𝑟 < |𝑏|.  Isso  nos  dar              

𝑎 = 𝑏 ⋅ (−𝑠) + 𝑟 e 0 ≤ 𝑟 < |𝑏|. Tomando 𝑞 = −𝑠, temos garantida a existência e unicidade 

de 𝑞 e 𝑟, tais que 𝑎 = 𝑏 ⋅ 𝑞 + 𝑟 e 0 ≤ 𝑟 < |𝑏| quando 𝑏 < 0. Isto conclui a prova do teorema. 

∎ 

3.1.4 Máximo divisor comum entre números inteiros 

Nesta seção abordaremos o conceito de  máximo  divisor comum  entre dois  inteiros  e 

suas propriedades mais importantes.  

Definição 3.4 Sejam dados dois inteiros 𝑎 e 𝑏. Um divisor comum de 𝑎 e 𝑏 é um inteiro 

𝑑 ≠ 0 que divide 𝑎 e 𝑏 ao mesmo tempo. 

Exemplo 3.2 O 5 é um divisor comum de 25 e 60, pois 5|25 e 5|60. 

Observação  3.2  Ao  mencionar  divisor  de  um  número  inteiro,  estamos  nos  referindo  aos 

divisores  positivos.  Uma  vez  que  estamos  interessados  no  máximo  divisor  comum,  será 

suficiente se ater apenas aos positivos. 

Antes  de  definirmos  o  máximo  divisor  comum  de  dois  inteiros,  apresentaremos  um 

exemplo que ilustra este conceito. Consideremos os números 60 e 24. Sejam  𝐷(60) e 𝐷(24) 

os conjuntos dos divisores positivos de 60 e 24, respectivamente. Logo,  

𝐷(60) = {1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60} e 

𝐷(24) = {1, 2, 3, 4, 6, 8, 12, 24} 

 
 
 
 
 
 
 
 
67 

Observando os dois conjuntos, vemos que os divisores comuns de 60 e 24 são 1, 2,  3, 4, 6 e 

12. Como 12 é o maior número dessa lista, dizemos que 12 é o máximo divisor comum de 60 

e  24.  Indicamos  isso  com  a  notação  𝑚𝑑𝑐(60, 24) = 12.  Com  esse  exemplo  em  mente  fica 

fácil interpretar a definição a seguir: 

Definição 3.5 Sejam 𝑎 e 𝑏 números inteiros, com 𝑎 ≠ 0 ou 𝑏 ≠ 0. Um número inteiro 𝑑 > 0 

será dito o máximo divisor comum (𝑚𝑑𝑐) de 𝑎 e 𝑏 se possuir as seguintes propriedades: 

(i) 𝑑 é divisor comum de 𝑎 e 𝑏. Ou seja, 𝑑|𝑎 e 𝑑|𝑏. 

(ii) 𝑑 é o maior divisor comum de 𝑎 e 𝑏. Ou seja, dado qualquer divisor 𝑐 de 𝑎 e 𝑏, tem-se que 

𝑐 ≤ 𝑑. 

Usaremos a notação 𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏) para indicar que 𝑑 é o máximo divisor comum de 𝑎 e 𝑏.  

Vejamos algumas propriedades básicas do máximo divisor comum: 

Proposição  3.1  Valem  as  seguintes  propriedades  para  o  máximo  divisor  comum  de  dois 

inteiros: 

(1) (Outra caracterização do máximo divisor comum) O máximo divisor comum 𝑑 ≠ 0 de 𝑎 e 

𝑏  é  tal  que:  𝑑|𝑎  e  𝑑|𝑏  e  para  todo  divisor  comum  𝑐  de  𝑎  e  𝑏,  vale  que  𝑐|𝑑.  Ou  seja,  𝑑  é 

divisor  comum  de  𝑎  e  𝑏  e  é  divisível  por  todo  divisor  comum  de  𝑎  e  𝑏.  Esta  propriedade 

também poderia ser usada para definir o mdc de dois inteiros, sendo equivalente a Definição 

3.5. Uma demonstração deste fato pode ser encontrada em Santos (2014); 

(2)  (Existência  e  unicidade  do  mdc)  Sejam  𝑎  e  𝑏  números  inteiros,  com  𝑎 ≠ 0  ou  𝑏 ≠ 0. 

Existe e é único o máximo divisor comum de 𝑎 e 𝑏. De fato, o conjunto dos divisores comuns 

de 𝑎 e 𝑏 é não vazio (pelo  menos o 1 pertence a ele) e limitado superiormente (em vista da 

Propriedade  (iv),  Teorema  3.2).  Logo,  o  princípio  da  boa  ordenação  (versão  para 

subconjuntos limitados superiormente) assegura que existe e é único o maior elemento desse 

conjunto. Esse elemento é o 𝑚𝑑𝑐(𝑎, 𝑏); 

(3)  (Teorema  de  Bachet-Bézout25)  Seja  𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏).  Existem  inteiros  𝑥  e  𝑦,  tais  que, 

𝑑 = 𝑎𝑥 + 𝑏𝑦.  Ou  seja,  esta  propriedade  diz  que  podemos  escrever  o  𝑚𝑑𝑐(𝑎, 𝑏)  como 

combinação linear (com coeficientes inteiros) dos inteiros 𝑎 e 𝑏. Além disso, “o 𝑚𝑑𝑐(𝑎, 𝑏) é 

25 Ver página 20 de Martinez et al. (2013) 

 
 
 
 
 
 
                                                             
68 

o  menor  inteiro  positivo  da  forma  𝑎𝑥 + 𝑏𝑦”  (ALENCAR  FILHO,  1989,  p.  87).  Veja      

Santos  (2014)  ou  Alencar  Filho  (1989)  para  uma  demonstração  pelo  princípio  da  boa 

ordenação (Teorema 3.1). 

(4) (Inteiros primos entre si) Dois inteiros 𝑎 e 𝑏 (𝑎 ≠ 0 ou 𝑏 ≠ 0) são ditos primos entre si se 

𝑚𝑑𝑐(𝑎, 𝑏) = 1.  Um  resultado  importante  relacionado  com  essa  definição  é  o  seguinte:  os 

inteiros 𝑎 e 𝑏 (𝑎 ≠ 0 ou 𝑏 ≠ 0) são primos entre si se, e somente se, existem inteiros  𝑥 e 𝑦, 

tais que, 𝑎𝑥 + 𝑏𝑦 = 1. 

Demonstração: De fato, se 𝑚𝑑𝑐(𝑎, 𝑏) = 1, então a propriedade anterior garante que existem 

inteiros 𝑥 e 𝑦, tais que, 1 = 𝑚𝑑𝑐(𝑎, 𝑏) = 𝑎𝑥 + 𝑏𝑦. Por outro lado, suponhamos que existem 

inteiros  𝑥  e  𝑦,  tais  que,  𝑎𝑥 + 𝑏𝑦 = 1  e  seja  𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏).  Logo,  pelo  item  (vi)  do     

Teorema 3.2, 𝑑| (𝑎𝑥 + 𝑏𝑦) para quaisquer 𝑥, 𝑦 ∈ ℤ, assim segue que 𝑑|1 ⟹ 𝑑 = ±1. Sendo 

𝑑 positivo, temos 𝑑 = 1, o que acarreta  𝑚𝑑𝑐(𝑎, 𝑏) = 1. 

(5)  (Euclides)  Outra  propriedade  importante,  devida  a  Euclides,  assegura  que  se  𝑎|𝑏𝑐  e 

𝑚𝑑𝑐(𝑎, 𝑏) = 1, então 𝑎|𝑐.  

Demonstração: De  fato, se 𝑎|𝑏 ⋅ 𝑐, então 𝑏 ⋅ 𝑐 = 𝑎 ⋅ 𝑞, com 𝑞 ∈ ℤ. Como 𝑚𝑑𝑐(𝑎, 𝑏) = 1, a 

Propriedade  (3)  assegura  que  existem  inteiros  𝑥  e  𝑦,  tais  que,  𝑎𝑥 + 𝑏𝑦 = 1.  Multiplicando 

esta última equação por 𝑐, vem:  

𝑎 ⋅ 𝑐 ⋅ 𝑥 + 𝑏 ⋅ 𝑐 ⋅ 𝑦 = 𝑐 ⟹ 𝑎 ⋅ 𝑐 ⋅ 𝑥 + 𝑎 ⋅ 𝑞 ⋅ 𝑦 = 𝑐 ⟹ 𝑎 ⋅ (𝑐 ⋅ 𝑥 + 𝑞 ⋅ 𝑦) = 𝑐 

Desta última igualdade segue que 𝑎|𝑐, pois 𝑐 ⋅ 𝑥 + 𝑞 ⋅ 𝑦 é um número inteiro.  

(6) Dados os inteiros 𝑎, 𝑏 e 𝑦, é válido que 𝑚𝑑𝑐(𝑎, 𝑏) = 𝑚𝑑𝑐(𝑎, 𝑏 + 𝑦 ⋅ 𝑎). Esta propriedade 

auxilia muito no cálculo do 𝑚𝑑𝑐, pois é uma maneira de simplificar as contas. 

Demonstração:  De  fato,  se 𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏),  então 𝑑|𝑎  e 𝑑|𝑏.  Isso  implica  que  𝑑|𝑏  e  𝑑|𝑦. 𝑎 

⟹ 𝑑|(𝑏 + 𝑦 ⋅ 𝑎).  Assim,    𝑑|𝑎 e  𝑑|(𝑏 + 𝑦 ⋅ 𝑎).  Isso  nos  diz  que  𝑑  é  divisor  comum  de  𝑎  e 

𝑏 + 𝑦 ⋅ 𝑎. Para provar que 𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏 + 𝑦 ⋅ 𝑎), seja 𝑐 um divisor comum de 𝑎 e 𝑏 + 𝑦 ⋅ 𝑎. 

Logo,  𝑐|𝑦 ⋅ 𝑎 e 𝑐|(𝑏 + 𝑦 ⋅ 𝑎 − 𝑦 ⋅ 𝑎) ⟹ 𝑐|𝑎 e 𝑐|𝑏. Assim, 𝑐 é um divisor comum de  𝑎 e 𝑏. 

Como  𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏),  devemos  ter  𝑐 ≤ 𝑑.  Portanto,  𝑑  é  o  maior  divisor  comum  de  𝑎  e  de 

𝑏 + 𝑦 ⋅ 𝑎. Ou seja, 𝑑 = 𝑚𝑑𝑐(𝑎, 𝑏 + 𝑦 ⋅ 𝑎).                                                                              ∎                                                             

 
 
 
 
 
 
 
69 

3.1.5 O algoritmo de Euclides 

O  algoritmo  de  Euclides  consiste  de  um  método  sistemático  para  calcular  com 

eficiência  o  máximo  divisor  comum  de  dois  inteiros  𝑎  e  𝑏.  Este  algoritmo  também  é 

conhecido  como  método  das  divisões  sucessivas.  Antes  de  apresentá-lo,  provaremos  um 

resultado que será fundamental para o seu desenvolvimento. 

Teorema  3.4  Sejam  𝑎  e  𝑏  números  inteiros  com  𝑎 = 𝑏 ⋅ 𝑞 + 𝑟,  onde  𝑞  e  𝑟  também  são 

números inteiros. Temos que 𝑚𝑑𝑐(𝑎, 𝑏) = 𝑚𝑑𝑐(𝑏, 𝑟). 

Demonstração:  Com  efeito,  𝑚𝑑𝑐(𝑎, 𝑏) = 𝑚𝑑𝑐(𝑏 ⋅ 𝑞 + 𝑟, 𝑏) = 𝑚𝑑𝑐(𝑏, 𝑟)  pela  Propriedade 

6, dada anteriormente. ∎ 

Agora, sejam 𝑎 e 𝑏 números inteiros, com 𝑎 ≠ 0 ou 𝑏 ≠ 0. Nosso objetivo é calcular o 

valor  de  𝑚𝑑𝑐(𝑎, 𝑏).  Ora,  se  um  desses  dois  números  é  0,  então  é  fácil  calcular  o  máximo 

divisor comum entre eles, pois  𝑚𝑑𝑐(𝑎, 0) = |𝑎| e 𝑚𝑑𝑐(0, 𝑏) = |𝑏|. Da mesma forma, se for 

𝑎 = 𝑏,  então  𝑚𝑑𝑐(𝑎, 𝑏) = |𝑎| = |𝑏|.  Por  fim,  também  é  fácil  concluir  que  se  𝑎|𝑏,  então 

𝑚𝑑𝑐(𝑎, 𝑏) = |𝑎|. Enfim, em todas essas possibilidades o cálculo do máximo divisor comum é 

direto e não apresenta nenhuma dificuldade. Assim sendo, vamos supor que 𝑎 e 𝑏 são ambos 

inteiros  positivos,  com  𝑎 > 𝑏,  e  que  𝑏  não  divida  𝑎.  Utilizando  o  algoritmo  da  divisão 

(Teorema 3.3) para dividir 𝑎 por 𝑏, obtemos: 

𝑎 = 𝑏 ⋅ 𝑞1 + 𝑟1 , 0 < 𝑟1 < 𝑏. 

Em seguida, dividimos 𝑏 por 𝑟1, obtendo:  

𝑏 = 𝑟1 ⋅ 𝑞2 + 𝑟2 , 0 ≤ 𝑟2 < 𝑏. 

Se for 𝑟2 = 0, o algoritmo pára, pois o Teorema 3.4 garantirá que  

𝑚𝑑𝑐(𝑎, 𝑏) = 𝑚𝑑𝑐(𝑏, 𝑟1) = 𝑚𝑑𝑐(𝑟1, 𝑟2) = 𝑚𝑑𝑐(𝑟1, 0) = 𝑟1. 

Se for 𝑟2 > 0, repetimos o processo e dividimos 𝑟1 por 𝑟2, obtendo:  

𝑟1 = 𝑟2 ⋅ 𝑞3 + 𝑟3 , 0 ≤ 𝑟3 < 𝑏. 

 
 
 
 
 
 
 
 
 
 
70 

Pensando como anteriormente, temos que se 𝑟3 = 0, então  

𝑚𝑑𝑐(𝑎, 𝑏) = 𝑚𝑑𝑐(𝑏, 𝑟1) = 𝑚𝑑𝑐(𝑟1, 𝑟2) = 𝑚𝑑𝑐(𝑟2, 𝑟3) = 𝑚𝑑𝑐(𝑟2, 0) = 𝑟2. 

Por outro lado, se for 𝑟3 > 0, repetimos os cálculos feitos anteriormente, chegando a: 

𝑟2 = 𝑟3 ⋅ 𝑞4 + 𝑟4 , 0 ≤ 𝑟4 < 𝑏. 

Repetimos todo o processo feito nos passos anteriores e assim por diante. Nesse processo de 

divisões  sucessivas,  chegamos  a  duas  conclusões  muito  importantes:  a  primeira  é  que  esse 

processo não ocorre infinitamente. Ele pára em algum  momento, pois a cada passo obtemos 

um resto 𝑟𝑗 que é cada vez menor, mas não pode decrescer infinitamente porque é um número 

inteiro não negativo (o último resto obtido é 0). A segunda conclusão é que o 𝑚𝑑𝑐(𝑎, 𝑏) será 

igual  ao  último  resto  não  nulo  nessa  sequência  de  divisões  sucessivas.  Para  ver  isso  basta 

proceder  como  fizemos  anteriormente,  aplicando  o  Teorema  3.4  em  cada  uma  das  divisões 

que  aparecem  no  processo.  Este  método  para  calcular  o  máximo  divisor  comum  de  dois 

inteiros é devido a Euclides e  constitui-se de um  dos algoritmos  mais antigos  em teoria dos 

números.  Uma  exposição  detalhada  desse  algoritmo  pode  ser  encontrada  em  qualquer  bom 

livro  de  teoria  dos  números.  Destacamos  o  livro  do  Coutinho  (2005)  que  trás  uma 

apresentação  bem  rica,  com  demonstrações  e  uma  explicação  nos  mínimos  detalhes  desse 

algoritmo, apresentando ainda uma versão mais geral do mesmo, conhecido como  algoritmo 
euclidiano estendido26.  

3.1.6 Números Primos 

Os  números  primos  são  extremamente  importantes  para  a  criptografia  de  chave 

pública. Eles estão presentes na segurança de vários algoritmos de criptografia desse tipo. Um 
desses  algoritmos  é  o  RSA  que  apresentaremos  ao  final  deste  capitulo27.    Conceitos 

relacionados  com  números  primos,  tais  como  fatoração,  geração  e  critérios  de  primaridade, 

26 Este algoritmo é usado para determinarmos inteiros 𝑥 e 𝑦, tais que 𝑚𝑑𝑐(𝑎, 𝑏) = 𝑎𝑥 + 𝑏𝑦. Lembre-se que de 
acordo  com  a  Propriedade  3 da  Seção  3.1.4  esses  inteiros  sempre  existem.  O  algoritmo  de  Euclides  estendido 
encontra  grande  aplicação  na  resolução  de  equações  diofantinas  e  congruências  lineares.  Faremos  uma  rápida 
apresentação  das  congruências  lineares  na  seção  sobre  aritmética  modular,  mas  não  estudaremos  as  equações 
diofantinas detalhadamente. Sugerimos ao leitor pesquisar sobre o tema em qualquer uma das referencias citadas 
sobre teoria dos números. 
27  Outro  algoritmo  de  criptografia  de  chave  pública  relacionado  com  números  primos  é  o  ElGamal.  Este 
algoritmo se baseia no problema do logaritmo discreto para programar sua segurança. Ver: Buchmann (2002) e 
Terada (2000). 

 
 
 
 
 
 
                                                             
71 

estão no centro da segurança do algoritmo RSA. No entanto, explorar e analisar mais ao fundo 

essa relação levaria muito tempo e nos obrigaria a tratar de coisas que não convêm aos nossos 

objetivos. Portanto,  exploraremos apenas o que  for necessário para  a compreensão da  nossa 

apresentação sobre o método RSA. Para  isso,  faremos uma exposição básica  sobre  números 

primos,  destacando  sua  definição  e  alguns  resultados  elementares  importantes.  Para  o  leitor 

interessado em aprofundar seus estudos sobre números primos e criptografia RSA, sugerimos 

a consulta das seguintes obras que abarcam o tema de modo amplo e bem acessível ao público 

leigo: Daineze (2013), Okumura (2014), Spina (2014), Sousa (2015)  e outras já citadas, tais 

como  Medeiros  (2017),  Coutinho  (2005)  e  Carneiro  (2017).  Os  livros  de  Terada  (2000)  e 

Buchmann  (2002)  tratam  de  um  estudo  mais  aprofundado  e  teórico  sobre  criptografia,  em 

particular  da  criptografia  de  chave  pública  que  destaca  os  números  primos  como  agente 

principal  de  sua  segurança.  Para  conhecer  a  história  dos  números  primos  e  do  seu 

desenvolvimento ao longo do tempo, o leitor pode consultar Sautoy (2007). A obra de Sautoy 

também  dedica  um  capítulo  ao  estudo  de  criptografia  de  chave  pública  e  números  primos, 

bem como elementos de teoria dos números.  

Definição  3.6:  Um  inteiro  positivo  𝑝  (𝑝 > 1)  é  chamado  de  número  primo  quando  seus 

únicos divisores positivos são 1 e 𝑝. Se 𝑝 não for primo, ele será chamado de composto.  

Exemplo 3.3 Os números 2, 3, 5, 7, 11, 13, 17 e 19 são todos primos. Já os números 8, 10, 15, 

18, 28, 30 e 40 são compostos.  

Observação  3.3  O  número  natural  1  nem  é  primo  e  nem  composto.  O  número  2  é  o  único 

número primo par. Logo, se 𝑝 é primo e maior do que 2, então 𝑝 é impar. 

Teorema  3.5  Seja  𝑝  um  número  primo  e  𝑎  um  inteiro  qualquer.  Se  𝑝 ∤ 𝑎,  então    

𝑚𝑑𝑐(𝑎, 𝑝) = 1. Ou seja,  𝑎 e 𝑝 são primos entre si. Consequentemente, se 𝑎 e 𝑏 são inteiros 

quaisquer e 𝑝|𝑎 ⋅ 𝑏, então 𝑝|𝑎 ou 𝑝|𝑏. 

Demonstração:  Com  efeito,  seja  𝑑 = 𝑚𝑑𝑐(𝑎, 𝑝).  Logo,  𝑑|𝑎  e  𝑑|𝑝.  Ora,  como  𝑑|𝑝  e  𝑝  é 

primo, concluímos que só há dois valores possíveis para 𝑑: 1 ou 𝑝. Se 𝑑 = 𝑝, então teríamos 

𝑝|𝑎, pois 𝑑|𝑎, o que contradiz a hipótese de que 𝑝 ∤ 𝑎. Portanto, devemos ter 𝑑 = 1. Assim, 

temos 𝑚𝑑𝑐(𝑎, 𝑝) = 1. 

 
 
 
 
 
 
72 

Suponhamos agora que 𝑝|𝑎 ⋅ 𝑏. Se 𝑝 ∤ 𝑎, então 𝑚𝑑𝑐(𝑎, 𝑝) = 1 pelo que já provamos. Logo, 

pela  propriedade  de  Euclides  (Propriedade  5  sobre  máximo  divisor  comum)  segue  que  𝑝|𝑏. 

Ou seja, se 𝑝 divide o produto 𝑎 ⋅ 𝑏, então ele deve dividir ao menos um dos fatores. ∎ 

Exemplo  3.4  O  5  é  um  número  primo  e  5 ∤ 27.  Logo,  𝑚𝑑𝑐(5, 27) = 1.  Da  mesma  forma, 

veja que 5|4 ⋅ 10 ⟹ 5|4 ou 5|10 (o que é verdade pois 5|10). 

A  segunda  afirmação  contida  no  Teorema  3.5  pode  ser  generalizada  para  uma 

quantidade finita 𝑛 de inteiros. Ou seja, se 𝑝 é um número primo, onde 𝑝|𝑎1 ⋅ 𝑎2 ⋅ 𝑎3 ⋅ … ⋅ 𝑎𝑛 

(𝑎𝑖 ∈ ℤ), então existe um inteiro 𝑎𝑘 (1 ≤ 𝑘 ≤ 𝑛), tal que, 𝑝|𝑎𝑘. Um resultado mais particular 

assegura  que  se  𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑛  forem  também  primos,  então  existirá  um  índice  𝑗             

(1 ≤ 𝑗 ≤ 𝑛)  tal  que  𝑝 = 𝑎𝑗.  Ou  seja,  se  um  número  primo  divide  um  produto  de  números 

primos, então ele deve ser igual a um dos fatores. Veja o Capítulo 7 de Alencar Filho (1989).  

Baseando-se  em  Alencar  Filho  (1989),  apresentaremos  e  demonstraremos  a  seguir  o 

Teorema Fundamental da Aritmética (TFA). Um dos teoremas mais simples e importantes da 

teoria dos números. Sua simplicidade faz com que o mesmo seja um dos poucos teoremas da 

aritmética  básica que  ainda é estudado no ensino básico.  Para demonstrarmos esse teorema, 

faremos uso do seguinte resultado. 

Lema 3.1 Todo número composto possui ao menos um divisor primo.   

Demonstração: Mais precisamente, provaremos que o menor divisor de um inteiro composto 

𝑛 é primo. De  fato, seja  𝑝 o menor divisor de  𝑛. Se 𝑝 fosse composto, poderíamos escrever 

𝑝 = 𝑟 ⋅ 𝑠,  com  1 < 𝑟, 𝑠 < 𝑝.  Logo,  como  𝑟  e  𝑠  são  divisores  de  𝑝,  segue  que  𝑟  e  𝑠  são 

divisores de 𝑛. Mais isso é absurdo, porque 𝑟 e 𝑠 são menores do que 𝑝, e 𝑝 é o menor divisor 

de 𝑛.∎ 

Teorema 3.6 (Teorema Fundamental da Aritmética) Todo inteiro positivo 𝑛 (𝑛 > 1) pode ser 

escrito como um produto de números (fatores) primos. Esse produto é único, a não ser pela 

ordem dos fatores. Assim sendo, todo inteiro positivo maior do que 1 ou é primo ou pode se 

escrever como produto de números primos. 

 
 
 
 
 
 
 
 
73 

Demonstração:  

(Existência) Suponhamos 𝑛 composto (se ele for primo, nada há para demonstrar). Pelo lema 

anterior, 𝑛  possui  um  divisor  primo  𝑝1.  Logo, 𝑛 = 𝑝1 ⋅ 𝑘1,  com  1 < 𝑘1 < 𝑛.  Ora,  se  𝑘1  for 

primo,  a  demonstração  acaba  e  temos  que  𝑛 = 𝑝1 ⋅ 𝑘1.  Por  outro  lado,  se  𝑘1  for  composto, 

novamente  pelo  lema  anterior  temos  que  𝑘1 = 𝑝2𝑘2,  com  𝑝2  primo  e  1 < 𝑘2 < 𝑘1.  Logo, 

𝑛 = 𝑝1 ⋅ 𝑝2 ⋅ 𝑘2.  Podemos  fazer  uma  análise  semelhante  sobre  𝑘2  e  repetir  os  passos 

anteriores. Seguido assim, obtemos uma sequência de inteiros:  

𝑛 > 𝑘1 > 𝑘2 > 𝑘3 > 𝑘4 > ⋯ > 1. 

Como essa é uma sequência decrescente de inteiros maiores do que 1, segue que a mesma é 

finita. Existe, então, um último 𝑘𝑗 que será menor do que todos os outros. Portanto, 𝑘𝑗 é primo 

e podemos escrever  𝑛 = 𝑝1 ⋅ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅ 𝑝𝑟 (𝑝𝑟 = 𝑘𝑗), onde todos os 𝑝𝑖´𝑠 são primos. Assim, 

provamos que 𝑛 pode ser escrito como um produto de fatores primos. 

(Unicidade) Para provar que essa maneira de escrever  𝑛 é única, vamos supor que 𝑛 admite 

outra  representação  como  produto  de  números  primos.  Seja  𝑛 = 𝑞1 ⋅ 𝑞2 ⋅ 𝑞3 ⋅ … ⋅ 𝑞𝑠,  onde 

𝑞𝑖 ≤ 𝑞𝑗 𝑠𝑒 𝑖 < 𝑗.  Provaremos  que  𝑟 = 𝑠  e  𝑝𝑖 = 𝑞𝑖(1 ≤ 𝑖 ≤ 𝑟).  Para  isso,  suponhamos  por 

absurdo  que  𝑟 ≠ 𝑠.  Sem  perda  de  generalidade,  podemos  supor  que  𝑟 < 𝑠.  Temos  então  o 

seguinte: 

Como  𝑝1 ⋅ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅ 𝑝𝑟 = 𝑞1 ⋅ 𝑞2 ⋅ 𝑞3 ⋅ … ⋅ 𝑞𝑠,  segue  que  𝑞1|𝑝1 ⋅ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅ 𝑝𝑟.  Pela 

observação  após  o  Teorema  3.5,  concluímos  que  𝑞1 = 𝑝𝑗 ≥ 𝑝1,  para  algum  1 ≤ 𝑗 ≤ 𝑟.  Da 

mesma forma, 𝑝1|𝑞1 ⋅ 𝑞2 ⋅ 𝑞3 ⋅ … ⋅ 𝑞𝑠. Logo, 𝑝1 = 𝑞𝑖 ≥ 𝑞1, para algum 1 ≤ 𝑖 ≤ 𝑠. Portanto,  

𝑝1 = 𝑞1 ⟹ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅ 𝑝𝑟 = 𝑞2 ⋅ 𝑞3 ⋅ … ⋅ 𝑞𝑠. 

Repetindo este processo, obtemos 𝑝2 = 𝑞2, 𝑝3 = 𝑞3 e assim por diante. Supondo que 𝑟 < 𝑠, 

temos  que  na  igualdade  𝑝1 ⋅ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅ 𝑝𝑟 = 𝑞1 ⋅ 𝑞2 ⋅ 𝑞3 ⋅ … ⋅ 𝑞𝑠  o  lado  direito  tem  mais 

fatores  do  que  o  esquerdo.  Logo,  se  formos  eliminando  os  pares  𝑝𝑙 = 𝑞𝑘  de  primos  iguais, 

chegaremos à igualdade 1 = 𝑞𝑟+1 ⋅ 𝑞𝑟+2 ⋅ 𝑞𝑟+3 ⋅ … ⋅ 𝑞𝑠. Como no lado direito dessa igualdade 

temos um produto de números primos, esse produto não pode ser 1. Logo, a igualdade dada 

por 1 = 𝑞𝑟+1 ⋅ 𝑞𝑟+2 ⋅ 𝑞𝑟+3 ⋅ … ⋅ 𝑞𝑠 é absurda. Concluímos assim que devemos ter 𝑟 = 𝑠. Isso 

nos  diz  que  𝑝1 = 𝑞1, 𝑝2 = 𝑞2, 𝑝3 = 𝑞3, … , 𝑝𝑟 = 𝑞𝑟.  Ou  seja,  é  única  a  forma  para                        

 𝑛 = 𝑝1. 𝑝2. 𝑝3 … 𝑝𝑟.  Provamos  assim  a  existência  e  unicidade  da  representação  de  𝑛  como 

produto de fatores primos. Isto conclui a demonstração. ∎ 

Observação  3.4  É  claro  que  quando  escrevemos  𝑛 = 𝑝1 ⋅ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅ 𝑝𝑟,  os  fatores  primos 

𝑝1, 𝑝2, 𝑝3, … , 𝑝𝑟  não  são  necessariamente  distintos.  Assim,  organizando  esses  fatores  primos 

 
 
em  ordem  crescente  e  agrupando  os  fatores  iguais,  se  existirem,  pode-se  escrever                 

74 

𝑛1 ⋅ 𝑝2

𝑛2 ⋅ … ⋅ 𝑝𝑟

𝑛 = 𝑝1
chamada fatoração (ou decomposição) canônica de 𝑛. 

𝑛𝑟,  com  𝑝1 < 𝑝2 < 𝑝3 < ⋯ < 𝑝𝑟  e  𝑛𝑖 > 0  para  todo  1≤ 𝑖 ≤ 𝑟. Esta  é  a 

Exemplo 3.5 Seja 𝑛 = 340. Temos que  

𝑛 = 340 = 34 ∙ 10 = 2 ∙ 17 ∙ 2 ∙ 5 = 22 ∙ 5 ∙ 17. 

Portanto, 22 ∙ 5 ∙ 17 é a decomposição canônica de 340. 

O teorema a seguir foi provado pela primeira vez por Euclides. O mesmo assegura que 

os números primos  jamais se esgotarão. A demonstração apresentada segue a prova clássica 

dada por Euclides há mais de 2000 mil anos.  

Teorema 3.7 Existem infinitos números primos. 

Demonstração: Com efeito, suponhamos por absurdo que o conjunto dos números primos é 

finito.  Assim  sendo,  sejam  𝑝1, 𝑝2, 𝑝3, … , 𝑝𝑘 a  lista  de  todos  os  números  primos.  Se 

considerarmos  o  número 

 𝑃 = 𝑝1 ⋅ 𝑝2 ⋅ 𝑝3 ⋅ … ⋅  𝑝𝑘 + 1,  que  é  o  número  obtido  pela 

multiplicação de todos os primos da lista apresentada acrescido de uma unidade, então 𝑃 será 

maior  do  que  1  e  não  será  divisível  por  nenhum  dos  primos  𝑝1, 𝑝2, 𝑝3, … , 𝑝𝑘.  O  Teorema 

Fundamental  da  Aritmética  garante  que  ou  𝑃  é  primo  ou  pode  ser  escrito  como  produto  de 

números primos. Ora, se 𝑃 for primo, ele não pode pertencer a nossa lista, pois  𝑃 é maior do 

que  todos os 𝑝í´𝑠.  Por outro  lado,  se  𝑃  puder  ser  escrito  como  produto  de  números  primos, 

então ele será divisível por todos os primos que compõe esse produto. Logo, nenhum primo 

desse  produto  será  igual  a  algum  primo  da  lista  𝑝1, 𝑝2, 𝑝3, … , 𝑝𝑘.  Ou  seja,  existem  outros 

primos  que  geram  𝑃.  Portanto,  em  qualquer  das  possibilidades  para  𝑃,  temos  garantida  a 

existência  de  outros  primos  que  não  pertencem  a  lista  𝑝1, 𝑝2, 𝑝3, … , 𝑝𝑘.  Esta  contradição 

mostra que a lista dos números primos não pode ser finita. ∎ 

O fato de existir infinitos primos é o que fornece mais  subsídios para a segurança do 

método criptográfico RSA. De fato, como veremos mais adiante, este método se alimenta de 

números primos para construir  suas chaves de segurança. Utilizar  números primos cada  vez 

maiores,  com  um  número  muito  grande  de  algarismos  é  o  que  pode  dar  maior  segurança  e 

menores probabilidades do sistema ser violado.  

 
 
 
 
 
 
75 

Antes  de  analisarmos  onde  os  números  primos  estão  inseridos  no  método  RSA, 

precisamos  estudar  alguns  conceitos  relacionados  à  aritmética  modular.  Os  processos  de 

codificação, decodificação, geração de chaves, funcionamento geral, segurança, entre outros, 

referentes ao método RSA se utilizam de alguma noção dessa área, mais precisamente a noção 

de  inteiros  congruentes.  É  essencial,  portanto,  conhecer  um  pouco  sobre  aritmética  modular 

para entender o conteúdo que será desenvolvido posteriormente.  

3.1.7 Aritmética Modular 

Discutiremos agora sobre algumas noções de aritmética modular. Também conhecida 

como aritmética do relógio, a aritmética modular insere no conjunto dos números inteiros uma 

espécie  de  fenômeno  cíclico,  o  qual  estabelece  uma  relação  entre  dois  inteiros  e  possibilita 

classificá-los como congruentes em relação a outro número inteiro. A aritmética modular foi 

inicialmente  desenvolvida  pelo  eminente  matemático  alemão  Carl  Friedrich  Gauss  (1777-

1855), tomando como ponto de partida a idealização de uma calculadora-relógio. 

Uma  das  grandes  contribuições  precoces  de  Gauss  foi  a  invenção  da  calculadora-
relógio. Esse instrumento era uma ideia, e não uma máquina física, que possibilitava 
a  realização  de  cálculos  com  números  considerados  demasiadamente  extensos.  O 
princípio da calculadora-relógio é idêntico ao de um relógio comum. Se um relógio 
marca nove horas, e adicionamos quatro horas, o ponteiro das horas avança até uma 
hora.  Assim,  a  calculadora-relógio  de  Gauss  nos  daria  a  resposta  1,  e  não  13. 
(SAUTOY, 2007, p. 29) 

Para  a  multiplicação  7 ⋅ 7  digamos,  o  valor  fornecido  pela  calculadora  –  relógio  de 

Gauss seria 1, pois este é o resto na divisão de 7 ⋅ 7 = 49 por 12. Diante disso, ficava ainda 

mais  fácil para Gauss obter, por exemplo, o valor de 7 ⋅ 7 ⋅ 7. Como 7 ⋅ 7 é igual  a 1 na sua 

calculadora, para obter o valor de 7 ⋅ 7 ⋅ 7, Gauss só precisava multiplicar 1 por 7. Logo, sua 

calculadora lhe fornecia o valor 7, isto é, o número 7 ⋅ 7 ⋅ 7 deixa resto 7 na divisão por 12. A 

eficiência  e  a  velocidade  de  cálculo  da  calculadora-relógio  de  Gauss  tornaram-se  claros  ao 

serem  realizadas  multiplicações  com  um  número  maior  de  fatores:  “embora  não  tivesse  a 

menor ideia do valor de 799, sua calculadora-relógio lhe dizia que o número deixava resto 7 

ao ser dividido por 12” (SAUTOY, 2007, p. 29). 

Evidentemente,  os  relógios  com  12  horas  não  tinham  nada  de  especial  e  a  ideia  da 

calculadora – relógio de Gauss poderia ser aplicada a um relógio com uma quantidade  m de 

 
 
 
 
 
 
76 

horas. Ao generalizar essa ideia para relógios com uma quantidade qualquer de horas, Gauss 

deu vida a uma nova aritmética. Uma aritmética sobre os restos obtidos na divisão de inteiros, 

que  está  fixada  na  noção  fundamental  de  congruência.  O  potencial  dessa  nova  aritmética 

reside justamente nessa noção de congruência que torna possível a realização de divisões com 

números gigantescos em uma velocidade muito grande. Sem contar que as congruências são 

dotadas de uma aritmética muito simples, cujas propriedades se assemelham muito com as da 

relação de igualdade. Certamente a aritmética modular foi uma das grandes contribuições de 

Gauss,  que  proporcionou  o  desenvolvimento  não  só  da  teoria  dos  números,  mas  de  toda  a 

matemática.  Segundo  Sautoy  (2007,  p.  29),  “a  descoberta  desse  novo  tipo  de  aritmética 

revolucionou  a  matemática  na  virada  do  século  XIX.  [...]  a  invenção  da  calculadora-relógio 

ajudou  os  matemáticos  a  descobrir  padrões  no  universo  dos  números,  que  haviam  estados 

escondidos durante gerações”.  

Em  pleno  século  XXI,  a  aritmética  modular  de  Gauss  representa  a  ferramenta  mais 

poderosa  para  o  desenvolvimento  da  criptografia  moderna  na  internet.  Essa  aritmética  é  o 

alicerce para  muitos sistemas de criptografia, especificamente criptografia de chave pública. 

O  mais  famoso  desses  sistemas  é,  como  já  falamos,  o  RSA.  Muitos  resultados  e  conceitos 

relacionados  com  congruências  estão  inseridos  no  funcionamento  desse  método.  Portanto, 

iremos estudar algumas noções sobre aritmética modular com o intuito de preparar o terreno 

para  a  apresentação  do  método  RSA.  Faremos  a  apresentação  de  algumas  definições  e 

resultados  importantes  que  estão  relacionados  diretamente,  ou  indiretamente,  com  o  RSA. 

Iniciaremos com a importante noção de inteiros congruentes. 

Definição 3.7 (Inteiros congruentes) Sejam 𝑎, 𝑏 e 𝑚 números inteiros, com 𝑚 > 0. Diremos 

que 𝑎 é congruente a 𝑏 módulo 𝑚 quando 𝑎 − 𝑏 for múltiplo de 𝑚, isto é, quando 𝑚|𝑎 − 𝑏. 

Pode-se  provar  que  a  definição  anterior  é  equivalente  a  seguinte:  𝑎  é  congruente  a 𝑏 

módulo 𝑚 se, e somente se 𝑎 e 𝑏 deixam o mesmo resto quando divididos por 𝑚. Usaremos a 

notação  𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚)  para  indicar  que  𝑎  é  congruente  a  𝑏  módulo  𝑚.  Assim,  temos:                  

𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) ⇔  𝑚|𝑎 − 𝑏 ⇔  𝑎 e 𝑏 deixam o mesmo resto quando divididos por 𝑚. 

Exemplo 3.6 Temos 7 ≡ 1 (𝑚𝑜𝑑. 3), pois 3|(7 − 1); −15 ≡ 9 (𝑚𝑜𝑑. 8), pois 8|(−15 − 9); 

11 ≡ −1(𝑚𝑜𝑑. 4),  pois  4|(11 − (−1));  𝑛 ≡ 0 (𝑚𝑜𝑑. 2)  para  qualquer  𝑛  par;                     

𝑛 ≡ 1 (𝑚𝑜𝑑. 2),  para  todo  𝑛  ímpar;  como  17  =  4.4  +  1  e  29  =  4.7  +  1,  segue  que  17  e  29 

deixam o mesmo resto quando divididos por 4. Portanto, 17 ≡ 29 (𝑚𝑜𝑑. 4). 

 
 
 
77 

Quando  𝑚 ∤ 𝑎 − 𝑏,  dizemos  que  𝑎  é  incongruente  a  𝑏  módulo  𝑚.  Indicamos  isso  com  a 

notação  𝑎 ≢ 𝑏 (𝑚𝑜𝑑. 𝑚).  Isso  quer  dizer  que  𝑎  e  𝑏  não  deixam  o  mesmo  resto  quando 

divididos por 𝑚. 

Exemplo 3.7 Temos 7 ≢ 2 (𝑚𝑜𝑑. 3), pois 3 ∤ (7 − 2); −4 ≢ 1 (𝑚𝑜𝑑. 7), pois 7 ∤ (−4 − 1) 

e 19 ≢ 11 (𝑚𝑜𝑑. 5), pois 5 ∤ (19 − 11) 

Observação 3.5 

  Como  1|(𝑎 − 𝑏)  para  todos  𝑎  e  𝑏  inteiros,  segue  então  que  𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 1).  Por  esse 

motivo podemos descartar a congruência módulo 1 e supor sempre 𝑚 > 1; 

  A relação “𝑎 congruente a 𝑏 módulo 𝑚” é de equivalência em  ℤ. Isto significa que para 

todos 𝑎, 𝑏, 𝑐 e 𝑚 inteiros, com 𝑚 > 1, valem as seguintes propriedades:  

 (1)  𝑎 ≡ 𝑎 (𝑚𝑜𝑑. 𝑚) (propriedade reflexiva); 

 (2)  Se 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), então 𝑏 ≡ 𝑎 (𝑚𝑜𝑑. 𝑚) (propriedade simétrica); 

 (3)  Se  𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚)  e  𝑏 ≡ 𝑐 (𝑚𝑜𝑑. 𝑚),  então  𝑎 ≡ 𝑐 (𝑚𝑜𝑑. 𝑚)  (propriedade 

transitiva). 

 

(Caracterização  do  resto)  O  problema  de  obter  o  resto  na  divisão  de  um  inteiro  𝑎  por 

𝑚 > 0 é equivalente ao de obter um inteiro 𝑟, com 0 ≤ 𝑟 < 𝑚, tal que 𝑎 ≡ 𝑟 (𝑚𝑜𝑑. 𝑚). 

Assim,  por  exemplo,  se  quisermos  calcular  o  resto  de  9100  por  17,  basta  encontrar  um 

número 0 ≤ 𝑟 < 17 que verifique 9100 ≡ 𝑟 (𝑚𝑜𝑑. 17). 

As  duas  últimas  observações  citadas  anteriormente  são  consequências  imediatas  da 

definição de inteiros congruentes. Suas demonstrações não apresentam nenhuma dificuldade e 

serão deixadas como exercício. Os teoremas a seguir destacam algumas propriedades úteis das 

congruências.  

Teorema 3.8 Sejam dados os números inteiros 𝑎, 𝑏, 𝑐, 𝑑 e 𝑚, com 𝑚 > 1. Então:  

(1) Se 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), então 𝑎 ⋅ 𝑐 ≡ 𝑏 ⋅ 𝑐 (𝑚𝑜𝑑. 𝑚). Ou seja, nas congruências é permitido 

multiplicar ambos os membros por um mesmo número inteiro; 

(2) Se 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) e 𝑛 é um inteiro divisor de 𝑚, então 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑛); 

 
 
 
 
 
 
 
 
78 

(3) Se 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) e 𝑐 ≡ 𝑑 (𝑚𝑜𝑑. 𝑚), então  

𝑎 + 𝑐 ≡ 𝑏 + 𝑑 (𝑚𝑜𝑑. 𝑚) e 𝑎 − 𝑐 ≡ 𝑏 − 𝑑 (𝑚𝑜𝑑. 𝑚) . 

Consequentemente,  temos  que  𝑎 + 𝑐 ≡ 𝑏 + 𝑐 (𝑚𝑜𝑑. 𝑚)  e  𝑎 − 𝑐 ≡ 𝑏 − 𝑐 (𝑚𝑜𝑑. 𝑚).  Esta 

propriedade  diz  que  as  congruências  módulo  𝑚  podem  ser  somadas  e  subtraídas  membro  a 

membro,  bem  como  podemos  somar  e  subtrair  um  mesmo  número  inteiro  em  ambos  os 

membros de uma congruência; 

(4) Se 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), então para todo 𝑛 ∈ ℕ, vale que 𝑎𝑛 ≡ 𝑏𝑛(𝑚𝑜𝑑. 𝑚).  

As demonstrações dessas propriedades não apresentam nenhuma dificuldade e serão omitidas. 

Tais demonstrações podem ser consultadas em Santos (2014). 

O teorema a seguir destaca uma propriedade muito importante das congruências. Nas 

igualdades entre números reais, por exemplo, do tipo  𝑎𝑥 = 𝑎𝑦, só podemos cancelar o fator 

comum  𝑎  desde  que  ele  seja  diferente  de  zero.  Nas  congruências  há  também  uma  condição 

para que possamos cancelar um fator comum de ambos os membros.  Essa condição assegura 

que só podemos cancelar o fator comum desde que ele seja primo com o módulo.  

Teorema 3.9 Seja 𝑎 ⋅ 𝑐 ≡ 𝑏 ⋅ 𝑐 (𝑚𝑜𝑑. 𝑚) e 𝑐 primo com 𝑚. Então 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), isto é, o 

fator 𝑐 pode ser cancelado.  

Demonstração:  Com  efeito,  desde  que  𝑎 ⋅ 𝑐 ≡ 𝑏 ⋅ 𝑐 (𝑚𝑜𝑑. 𝑚),  podemos  garantir  que                

𝑚|(𝑎 ⋅ 𝑐 − 𝑏 ⋅ 𝑐).  Daí,  pondo  o  fator  𝑐  em  evidência,  obtemos:  𝑚|𝑐 ⋅ (𝑎 − 𝑏).  Como  𝑐  é 

primo  com  𝑚,  isto  significa  que  𝑚𝑑𝑐(𝑐, 𝑚) = 1.  Portanto,  o  Teorema  de  Euclides  (dado 

como Propriedade 5 na Seção 3.1.4 ) garante que 𝑚|𝑎 − 𝑏, donde 𝑎 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚). ∎ 

Exemplo  3.8  Considere  a  congruência  36 ≡ 12 (𝑚𝑜𝑑. 3).  Como  36 = 2 ⋅ 18  e  12 = 2 ⋅ 6, 

temos 2 ⋅ 18 ≡ 2 ⋅ 6 (𝑚𝑜𝑑. 3). Como 𝑚𝑑𝑐(2, 3) = 1, segue que 18 ≡ 6 (𝑚𝑜𝑑. 3). 

A definição a seguir estabelece uma noção muito presente em criptografia RSA. Trata-

se  da  noção  de  inverso  multiplicativo  de  um  inteiro  módulo  𝑚.  Sabemos  que  inverso 

multiplicativo  é  um  conceito  relacionado  à  multiplicação,  em  ℝ,  por  exemplo,  o  qual 

estabelece que um  número 𝑏 é o inverso multiplicativo de 𝑎 se, e somente se 𝑎 ⋅ 𝑏 = 1. Em 

termos de congruências, temos o seguinte. 

 
 
 
 
 
 
 
79 

Definição 3.8 Sejam 𝑎 e 𝑚 números inteiros, com 𝑚 > 1. Um número inteiro 𝑏 é dito inverso 

multiplicativo de 𝑎 módulo 𝑚 se 𝑎 ⋅ 𝑏 ≡ 1 (𝑚𝑜𝑑. 𝑚). Esse inverso multiplicativo módulo 𝑚, 

quando existe, é único, módulo 𝑚. 

Denota-se  por  𝑎−1  o  inverso  multiplicativo  de  𝑎.  Daí,  multiplicando  os  dois  lados  da 

congruência  𝑎 ⋅ 𝑏 ≡ 1 (𝑚𝑜𝑑. 𝑚)  por  𝑎−1,  teremos:  𝑎 ⋅ 𝑏 ⋅ 𝑎−1 ≡ 1 ⋅ 𝑎−1 (𝑚𝑜𝑑. 𝑚).  Logo. 

𝑏 ⋅ (𝑎 ⋅ 𝑎−1) ≡ 𝑎−1(𝑚𝑜𝑑. 𝑚) ⟹ 𝑏 ≡ 𝑎−1(𝑚𝑜𝑑. 𝑚).  Isto  justifica  o  fato  do  inverso  módulo 

𝑚 ser único. 

Exemplo 3.9 Temos que o inverso multiplicativo de 4 módulo 7 é 2, pois 4 ⋅ 2 ≡ 1 (𝑚𝑜𝑑. 7). 

Veja que qualquer inteiro 𝑐, com 𝑐 ≡ 2 (𝑚𝑜𝑑. 7) é um inverso multiplicativo de 4 módulo 7. 

Veja  também  que  4  é  primo  com  7.  Isso  não  é  por  acaso.  A  fim  de  que  𝑎  possua  inverso 

multiplicativo módulo 𝑚 é necessário e suficiente que 𝑎 seja primo com 𝑚. Este é o conteúdo 

do Teorema 3.10 a seguir. 

Teorema  3.10  Sejam  𝑎  e  𝑚,  𝑚 > 1,  inteiros  quaisquer.  Existe  um  inteiro  𝑏,  tal  que              

𝑎 ⋅ 𝑏 ≡ 1 (𝑚𝑜𝑑. 𝑚) se, e somente se, 𝑚𝑑𝑐 (𝑎, 𝑚) = 1. 

Demonstração:  De  fato,  suponhamos  que  exista  𝑏 ∈ ℤ,  tal  que  𝑎 ⋅ 𝑏 ≡ 1 (𝑚𝑜𝑑. 𝑚).  Logo, 

𝑚|(𝑎 ⋅ 𝑏 − 1).  Daí,  existe  um  número 𝑘 ∈ ℤ, tal  que 𝑎 ⋅ 𝑏 − 1 = 𝑚. 𝑘 ⟹ 𝑎 ⋅ 𝑏 − 𝑚 ⋅ 𝑘 = 1. 

Seja  𝑑 = 𝑚𝑑𝑐(𝑎, 𝑚),  então  𝑑|𝑎  e  𝑑|𝑚 ⟹ 𝑑|𝑎 ⋅ 𝑏  e  𝑑|𝑚 ⋅ 𝑘 ⟹ 𝑑|𝑎 ⋅ 𝑏 − 𝑚 ⋅ 𝑘 ⟹ 𝑑|1, 

donde 𝑑 = 1, pois 𝑑 > 0. Portanto, 𝑚𝑑𝑐(𝑎, 𝑚) = 1. 

A  recíproca  é  óbvia,  uma  vez  que  se  𝑚𝑑𝑐(𝑎, 𝑚) = 1,  então  existem  𝑥, 𝑦 ∈ ℤ,  com            

𝑎𝑥 + 𝑚𝑦 = 1 ⟹ 𝑎𝑥 − 1 = 𝑚 ⋅ (−𝑦) ⟹ 𝑚|(𝑎𝑥 − 1) ⟹ 𝑎𝑥 ≡ 1 (𝑚𝑜𝑑. 𝑚).  Portanto,  𝑥  é  o 

inverso multiplicativo de 𝑎 módulo 𝑚. ∎ 

Definição 3.9 Seja 𝑥 um número inteiro. Chama-se resíduo de 𝑥 módulo 𝑚 um inteiro 𝑎, tal 

que, 𝑥 ≡ 𝑎 (𝑚𝑜𝑑. 𝑚).  

Exemplo 3.10 5 é um resíduo de 12 módulo 7, pois 12 ≡ 5 (𝑚𝑜𝑑. 7). 

Dado um inteiro 𝑚 > 1, há uma quantidade finita de resíduos, incongruentes entre si, 

módulo m. Podemos considerar o conjunto de todos  esses resíduos. Isso nos leva a definir o 

conceito de Sistema Completo de Resíduos Módulo 𝑚. Intuitivamente, um sistema completo 

 
 
 
 
 
 
 
80 

de resíduos é um conjunto cujos elementos são todos os resíduos, incongruentes dois a dois, 

possíveis  a  módulo  𝑚.  Dois  resíduos  congruentes  módulo  𝑚  são  considerados  iguais  com 

relação a esse módulo. Portanto, ser incongruentes dois a dois significa que esses resíduos são 
distintos28.  Precisamente,  um  sistema  completo  de  resíduos  módulo  𝑚  é  um  conjunto 

{𝑟1, 𝑟2, … , 𝑟𝑠}  de  𝑠  inteiros,  onde  𝑟𝑖 ≢ 𝑟𝑗(𝑚𝑜𝑑. 𝑚)  para  todo  𝑖 ≠ 𝑗  e  dado  qualquer  número 

inteiro  𝑛,  existe  um  𝑟𝑖 tal  que  𝑛 ≡ 𝑟𝑖 (𝑚𝑜𝑑. 𝑚).  Pode-se  provar  (ver  Santos  (2014))  que  se 

{𝑟1, 𝑟2, … , 𝑟𝑠} é um sistema completo de resíduos módulo 𝑚, então 𝑠 = 𝑚.  

Exemplo 3.11 O conjunto {0, 1, 2, 3, 4, … , 𝑚 − 1} é um sistema completo de resíduos módulo 

𝑚. Com efeito, é claro que esses inteiros são dois a dois incongruentes módulo 𝑚, pois se dois 

elementos  distintos  desse  conjunto,  digamos  𝑟  e  𝑠  fossem  congruentes  módulo  𝑚,  teríamos 

que  𝑚|𝑟 − 𝑠.  Como  |𝑟 − 𝑠| < 𝑚,  segue  que  𝑟 − 𝑠 = 0,  donde  𝑟 = 𝑠.  O  que  é  um  absurdo. 

Por  outro  lado,  dado  um  inteiro  𝑛  qualquer,  temos  que  𝑛 ≡ 𝑟 (𝑚𝑜𝑑. 𝑚),  onde  0 ≤ 𝑟 < 𝑚. 

Portanto, {0, 1, 2, 3, 4, … , 𝑚 − 1} é um sistema completo de resíduos módulo 𝑚. 

Usaremos o exposto anteriormente para provar o  teorema  a seguir,  muito  importante 

em termos de aplicação em criptografia RSA.  

Teorema  3.11  (Pequeno  Teorema  de  Fermat)  Seja  𝑝  um  número  primo  e  𝑎  um  inteiro 

qualquer não divisível por 𝑝. Então, 𝑎𝑝−1 ≡ 1 (𝑚𝑜𝑑. 𝑝). Ou seja, se 𝑝 é primo e 𝑝 não divide 

𝑎, então 𝑝 divide 𝑎𝑝−1 − 1. 

Demonstração: Consideremos os conjuntos {0, 1, 2, 3, … 𝑝 − 1} e {𝑎, 2𝑎, 3𝑎, … , (𝑝 − 1)𝑎}. O 

primeiro  conjunto  é  um  sistema  completo  de  resíduos  módulo  𝑝  de  acordo  com  o  exemplo 

anterior. Agora, o segundo conjunto tem 𝑝 − 1 elementos, nenhum dos quais é múltiplo de 𝑝. 

Esses  elementos  são  incongruentes,  dois  a  dois,  módulo  𝑝.  De  fato,  sejam  𝑖𝑎  e  𝑗𝑎  dois 

elementos  distintos  do  conjunto  {𝑎, 2𝑎, 3𝑎, … , (𝑝 − 1)𝑎},  1 ≤ 𝑖, 𝑗 ≤ 𝑝 − 1.  Se  fosse          

𝑖𝑎 ≡ 𝑗𝑎 (𝑚𝑜𝑑. 𝑝),  teríamos  𝑖 ≡ 𝑗 (𝑚𝑜𝑑. 𝑝).  Como  𝑖  e  𝑗  são  menores  do  que  𝑝,  segue  então 

que 𝑖 = 𝑗. O que é absurdo. Assim  sendo, podemos concluir que cada elemento do conjunto 

{𝑎, 2𝑎, 3𝑎, … , (𝑝 − 1)𝑎}  é  congruente  a  um  único  elemento  do  conjunto  {1, 2, 3, … 𝑝 − 1}. 

28 Essa é uma característica geral das congruências. A noção de igualdade (ou equivalência), com relação a 𝑚, se 
reflete  na  de  congruência.  Defini-se,  portanto,  dois  inteiros  como  distintos  módulo  𝑚  se  eles  forem 
incongruentes com relação a esse módulo. Isso tem uso muito frequente não só no estudo dos sistemas completos 
de resíduos, mas também nas equações que envolvem congruência, popularmente conhecida como congruências 
lineares, para estabelecer a distinção entre suas raízes.  

 
 
 
 
                                                             
81 

Como 

esses 

conjuntos 

têm 

a  mesma  quantidade  de 

elementos,  o  produto                                

𝑎 ⋅ 2𝑎 ⋅  3𝑎 ⋅   … ⋅ (𝑝 − 1)𝑎 será congruente ao produto 1 ⋅ 2 ⋅ 3 ⋅  … ⋅ 𝑝 − 1. Assim, teremos: 

𝑎 ⋅ 2𝑎 ⋅  3𝑎 ⋅ … ⋅ (𝑝 − 1)𝑎 ≡  1 ⋅ 2 ⋅ 3 ⋅ … ⋅ 𝑝 − 1 (𝑚𝑜𝑑. 𝑝) 

⟹ 𝑎𝑝−1 ⋅ (1.2.3 … (𝑝 − 1)) ≡ 1 ⋅ 2 ⋅ 3 ⋅ … ⋅ (𝑝 − 1)(𝑚𝑜𝑑. 𝑝).    (i) 

Como  todos  os  elementos  do  conjunto  {1, 2, 3, … , 𝑝 − 1}  são  menores  que  𝑝, e  𝑝  é  primo, 

segue  que  todos  eles  são  primos  com  𝑝.  Portanto,  𝑚𝑑𝑐(1 ⋅ 2 ⋅ 3 ⋅ … ⋅ (𝑝 − 1), 𝑝) = 1  e 

podemos 

cancelar  o 

fator  1 ⋅ 2 ⋅ 3 ⋅ … ⋅ (𝑝 − 1)  na 

congruência 

(i),  obtendo                    

𝑎𝑝−1 ≡ 1 (𝑚𝑜𝑑. 𝑝), como queríamos demonstrar.  ∎    

Como  consequência  do  Pequeno  Teorema  de  Fermat,  temos  outro  importante 

resultado, que também é denominado de Pequeno Teorema de Fermat por alguns autores. Este 

resultado afirma que se 𝑝 é primo e 𝑎 é um inteiro qualquer, então 𝑎𝑝 ≡ 𝑎 (𝑚𝑜𝑑. 𝑝). De fato, 

se  𝑝|𝑎  não  há  o  que  demonstrar,  pois  nesse  𝑝| 𝑎𝑝 − 𝑎.  Por outro  lado,  se   𝑝 ∤ 𝑎,  então  pelo 

Teorema  3.11,  segue  que  𝑎𝑝−1 ≡ 1 (𝑚𝑜𝑑. 𝑝).  Multiplicando  ambos  os  lados  dessa 

congruência por 𝑎, chegamos ao resultado desejado.  

Exemplo  3.12  Como  5  é  primo  e  5  não  divide  37,  segue  que  375−1 ≡ 1 (𝑚𝑜𝑑. 5).  Daí, 

teremos 374 ≡ 1 (𝑚𝑜𝑑. 5). Da mesma forma, é sempre verdade que 375 ≡ 37 (𝑚𝑜𝑑. 5). 

O  leitor  interessado  pode  consultar  Sautoy  (2007),  Capítulo  10,  para  obter  uma 

interpretação  bem  interessante  do  Pequeno  Teorema  de  Fermat  em  termos  da  calculadora-

relógio de Gauss, bem como uma explicação bem rica e ilustrada da ação desse teorema sobre 

a criptografia RSA.  Esse capítulo da obra de Sautoy é dedicado à criptografia.  

Iremos  finalizar  essa  explanação  sobre  alguns  conceitos  elementares  da  aritmética 

básica  abordando  a  importante  função  𝜑(letra  grega  fi)  e  o  conceito  de  Congruências 

Lineares. 

Definição  3.10  (Função  𝜑  de  Euler)  Seja  𝑛 ∈ ℕ.  A  função  𝜑  de  Euler  é  uma  função 
aritmética29 definida por: 𝜑(𝑛) = número de inteiros positivos menores do que ou iguais a 𝑛 

que  são  relativamente  primos  com  𝑛.  Ou  seja,  𝜑(𝑛)  é  o  número  de  elementos  do  conjunto 

{𝑥 ∈ ℕ; 𝑥 ≤ 𝑛 𝑒 𝑚𝑑𝑐(𝑥, 𝑛) = 1}.  

29 Uma função cujo domínio e contradomínio é o conjunto ℕ dos números naturais. 

 
 
 
 
 
                                                             
82 

Exemplo 3.13 De acordo com a Definição 3.10, temos: 

𝜑(1) = 1, pois 1 é o único inteiro positivo menor do que ou igual a 1 e primo com 1; 

𝜑(2) = 1, pois 1 ≤ 2 e 𝑚𝑑𝑐(1, 2) = 1; 

𝜑(3) = 2, pois há dois inteiros positivos menores do que ou iguais a 3 que são primos com 3: 

1 e 2. 

𝜑(10) = 4, pois 1, 3, 7 e 9 são os únicos inteiros positivos menores do que ou iguais a 10 e 

primos com 10. 

O teorema a seguir mostra como calcular 𝜑(𝑛) quando 𝑛 é primo e quando 𝑛 for uma 

potência de um número primo.  

Teorema 3.12 Seja 𝑝 um número primo e 𝑎 um número inteiro positivo. Vale que  

𝜑(𝑝) = 𝑝 − 1 e 𝜑(𝑝𝑎) = 𝑝𝑎 − 𝑝𝑎−1.                                      (1) 

Demonstração:  Seja  𝑝  um  número  primo.  Os  números  1, 2, 3, 4, 5, … , 𝑝 − 1  são  todos 

menores do que 𝑝 e relativamente primos com  𝑝, pois sendo 𝑝 primo, 𝑝 não divide  nenhum 

número  dessa  lista.  Logo,  𝑚𝑑𝑐(𝑝, 𝑖) = 1  para  1 ≤ 𝑖 ≤ 𝑝 − 1.  Portanto,  há  𝑝 − 1  inteiros 

positivos menores do que 𝑝 e primos com 𝑝, isto é, 𝜑(𝑝) = 𝑝 − 1. 

Para  ver  que   𝜑(𝑝𝑎) = 𝑝𝑎 − 𝑝𝑎−1,  consideremos  a  sequência  dos  inteiros  positivos  desde  1 

até  𝑝𝑎:  1, 2, 3, … , 𝑝𝑎.  Queremos  saber  quantos  desses  inteiros  são  primos  com  𝑝.  Ora,  para 

saber  isso,  devemos  nos  perguntar  quantos  desses  inteiros  não  são  primos  com  𝑝.  Na 

sequência 1, 2, 3, … , 𝑝𝑎, os únicos números que não são primos com  𝑝 são aqueles múltiplos 

de  𝑝,  isto  é,  os  inteiros  1 ⋅ 𝑝, 2 ⋅ 𝑝, 3 ⋅ 𝑝, … , 𝑝𝑎−1 ⋅ 𝑝 = 𝑝𝑎.  Daí,  se  subtrairmos  a  quantidade 

desses inteiros (𝑝𝑎−1) da quantidade total de inteiros da sequência 1, 2, 3, … , 𝑝𝑎 (𝑝𝑎), temos a 

quantidade de  inteiros positivos  menores do que ou iguais a  𝑝𝑎 que são primos com  𝑝𝑎. Ou 

seja, 𝜑(𝑝𝑎) = 𝑝𝑎 − 𝑝𝑎−1. ∎ 

Exemplo  3.14  Tem-se  𝜑(13) = 13 − 1 = 12,  pois  13  é  primo.  Da  mesma  forma,  temos 

 𝜑(73) = 73 − 73−1 = 343 − 49 = 294. 

Antes  de  aprendermos  a  calcular  𝜑(𝑛)  para  todo  natural  𝑛,  necessitamos  de  uma 

definição  sobre  uma  classe  particular  muito  importante  de  funções  aritméticas.  Trata-se  das 

funções  aritméticas  multiplicativas.  Chamam-se  assim  as  funções  aritméticas  𝑓: ℕ → ℤ,  tais 

que  𝑓(𝑚 ⋅ 𝑛) = 𝑓(𝑚) ⋅ 𝑓(𝑛)  para  todo  par  de  inteiros  positivos  𝑚, 𝑛,  primos  entre  si.  A 

 
 
 
 
 
função 𝜑 de Euler se enquadra nessa classe de funções, isto é, 𝜑(𝑚 ⋅ 𝑛) = 𝜑(𝑚) ⋅ 𝜑(𝑛) para 

todos  𝑚, 𝑛 ∈ ℕ  com  𝑚𝑑𝑐(𝑚, 𝑛) = 1.  Uma  prova  deste  fato  pode  ser  encontrada  em        

Santos (2014, p.72) ou em qualquer livro sobre Teoria dos Números.  

83 

pode ser escrito, de modo único, na forma  𝑛 = 𝑝1

Sabemos  pelo  Teorema  Fundamental  da  Aritmética  que  todo  inteiro  positivo  𝑛 > 1 
𝑛𝑟, com 𝑝1 < 𝑝2 < ⋯ < 𝑝𝑟 e 
𝑛𝑖´𝑠  são 

𝑛𝑖 > 0  para  todo  1≤ 𝑖 ≤ 𝑟.  Como  os  primos  𝑝𝑖´𝑠  são  distintos,  as  potências  𝑝𝑖
números  primos  entre  si.  Assim,  para  𝑛 = 1,  já  sabemos  que  𝜑(1) = 1.  Por  outro  lado,  se 

𝑛2 ⋅ … ⋅ 𝑝𝑟

𝑛1 ⋅ 𝑝2

𝑛 > 1, escrevemos 𝑛 = 𝑝1

𝑛1 ⋅ 𝑝2

𝑛2 ⋅ … ⋅ 𝑝𝑟

𝑛𝑟 e aplicamos a função 𝜑. Obtemos: 

𝜑(𝑛) = 𝜑(𝑝1

𝑛1 ⋅ 𝑝2

𝑛2 ⋅ … ⋅ 𝑝𝑟

𝑛𝑟) = 𝜑(𝑝1

𝑛1) ⋅ 𝜑(𝑝2

𝑛2) ⋅ … ⋅ 𝜑(𝑝𝑟

𝑛𝑟). 

Já  sabemos  calcular  𝜑  para  potências  de  números  primos  pelo  Teorema  3.12.  Portanto, 

teremos:  

𝜑(𝑛) = 𝜑(𝑝1

𝑛1) ⋅ 𝜑(𝑝2

𝑛2) ⋅ … ⋅ 𝜑(𝑝𝑟

⟹ 𝜑(𝑛) = 𝑝1

𝑛1 (1 −

𝑛1 − 𝑝1

𝑛𝑟) = (𝑝1
1
𝑝1

) ⋅  𝑝2

𝑛1−1) ⋅ (𝑝2
1
𝑝2

𝑛2 (1 −

) ⋅ … ⋅ 𝑝𝑟

𝑛𝑟 (1 −

𝑛2−1) ⋅ … ⋅ (𝑝𝑟
1
𝑝𝑟

) 

𝑛2 − 𝑝2

𝑛𝑟 − 𝑝𝑟

𝑛𝑟−1) 

⟹ 𝜑(𝑛) = 𝑝1

𝑛1 ⋅ 𝑝2

𝑛2 ⋅ … ⋅ 𝑝𝑟

𝑛𝑟 ⋅   (1 −

1
𝑝1

) ⋅ (1 −

1
𝑝2

) ⋅ … ⋅ (1 −

1
𝑝𝑟

) 

                       ⟹ 𝜑(𝑛) = 𝑛 ⋅ (1 −

1
𝑝1

) ⋅ (1 −

1
𝑝2

) ⋅ … ⋅ (1 −

1
𝑝𝑟

).                         (2) 

A Fórmula 2 nos possibilita calcular  𝜑(𝑛) para todo 𝑛 > 1. Ela requer apenas que saibamos 

fatorar  𝑛  em  seus  constituintes  primos.  Quando  estudarmos  o  método  RSA,  veremos  que 

fatorar 𝑛 está diretamente relacionado com a quebra do código. Especificamente, fatorar  𝑛 e 

obter 𝜑(𝑛), para os 𝑛´𝑠 que são utilizados no RSA, significará quebrar o código. 

Exemplo 3.15 Vamos calcular 𝜑(2020). Como 2020 = 22 ⋅ 5 ⋅ 101 é a fatoração canônica 

de 2020, segue da Fórmula 2 que 

𝜑(2020) = 2020 ⋅ (1 − 1
2

) ⋅ (1 − 1
5

) ⋅ (1 − 1
101

) = 2020 ⋅ 1
2

⋅ 4
5

⋅ 100
101

= 2020 ⋅ 40
101

= 800. 

Ou  seja,  existem  800  inteiros  positivos  menores  do  que  ou  iguais  a  2020  que  são 

relativamente primos com 2020.  

 
 
 
 
 
84 

A seguir, enunciaremos o famoso Teorema de Euler (ou Teorema de Euler-Fermat), o 

qual  é  bastante  usado  para  calcular  resíduos  de  potências  módulo  𝑚  quando  a  base  da 

potência  é  um  número  primo  com  𝑚  e  a  potência  é  relativamente  grande.  A  demonstração 

desse teorema pode ser encontrada em Santos (2014, p. 43).  

Teorema 3.13 Sejam 𝑎 e 𝑚 números inteiros, com 𝑚 > 0 e 𝑚𝑑𝑐(𝑎, 𝑚) = 1. Então,  

𝑎𝜑(𝑚) ≡ 1 (𝑚𝑜𝑑. 𝑚) 

Exemplo  3.16  Sejam  dados  os  inteiros  𝑎 = 7  e  𝑚 = 15.  Como  𝑚𝑑𝑐(7, 15) = 1  e       

𝜑(15) = 𝜑(3.5) = 𝜑(3). 𝜑(5) = 2.4 = 8, segue que 7𝜑(15) = 78 ≡ 1 (𝑚𝑜𝑑. 15). 

Para  encerrarmos  esta  seção,  faremos  algumas  considerações  sobre  congruências 

lineares.  Chamam-se  assim  as  congruências  do tipo  𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), onde 𝑎, 𝑏, 𝑥  e 𝑚  são 

inteiros, com  𝑚 > 0. Veja que  há uma  forte semelhança entre esse tipo de congruência e as 

equações  de  primeiro  grau  𝑎𝑥 + 𝑏 = 0.  Nas  equações,  seja  de  primeiro  grau  ou  não,  nosso 

objetivo é determinar o(s) valor(es) de 𝑥 que satisfaz(em) a equação dada. Isso não é diferente 

com  as  congruências  𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), onde  procuramos  determinar  𝑥0 ∈ ℤ,  de  modo  que, 

𝑎𝑥0 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚). Tal 𝑥0 que verifique a congruência  𝑎𝑥0 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) será chamado de 

solução  dessa  congruência.  Assim,  considerando  a  congruência  dada  por    3𝑥 ≡ 1 (𝑚𝑜𝑑. 2), 

temos que 𝑥0 = 3 é solução, pois 3 ⋅ 3 = 9 ≡ 1 (𝑚𝑜𝑑. 2). 

É 

fácil  ver  que,  se  𝑥0  é  solução  da  congruência  𝑎𝑥0 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚)  e                       

𝑥1 ≡ 𝑥0 (𝑚𝑜𝑑. 𝑚), então 𝑥1 também é  solução de 𝑎𝑥0 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚). Com efeito, se temos 
𝑥1 ≡ 𝑥0 (𝑚𝑜𝑑. 𝑚), então 𝑎𝑥1 ≡ 𝑎𝑥0 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚). Daí 𝑎𝑥1 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚).  

Assim,  se  conhecemos  uma  solução  𝑥0  da  congruência  𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚),  então 

conhecemos uma família de soluções da mesma, onde tal família é o conjunto: 

{𝑦 ∈ ℤ; 𝑦 ≡ 𝑥0 (𝑚𝑜𝑑. 𝑚)} = 𝑐𝑜𝑛𝑗𝑢𝑛𝑡𝑜 𝑑𝑒 𝑟𝑒𝑠í𝑑𝑢𝑜𝑠 𝑑𝑒 𝑥0 𝑚ó𝑑𝑢𝑙𝑜 𝑚.  

Portanto,  soluções  diferentes  para  a  congruência  𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚)  serão  aquelas 

incongruentes  módulo  𝑚.  Os  teoremas  a  seguir  respondem,  respectivamente,  as  seguintes 

perguntas:  

(1) sob que condições a congruência linear 𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) admite soluções? 

(2) no caso de existirem soluções, quantas soluções incongruentes existem? 

 
 
 
  
 
 
85 

Teorema 3.14  Sejam 𝑎, 𝑏, 𝑥 e 𝑚 > 0 inteiros. A congruência linear 𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) admite 

solução se, e somente se, o 𝑚𝑑𝑐(𝑎, 𝑚) divide 𝑏.  

Teorema  3.15  Seja  𝑑 = 𝑚𝑑𝑐(𝑎, 𝑚).  No  caso  em  que  𝑑|𝑏,  a  congruência 

linear                

𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) admite exatamente 𝑑 soluções mutuamente incongruentes módulo 𝑚. Além 

disso, se 𝑥0 é uma solução particular de 𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚), então as 𝑑 soluções incongruentes 
módulo  𝑚  são  obtidas  pela  fórmula  𝑥0 + 𝑘 ⋅ 𝑚

,  𝑘 ∈ ℤ,  0 ≤ 𝑘 ≤ 𝑑 − 1.  Em  particular,  se  

𝑑

𝑑 = 1, então a congruência 𝑎𝑥 ≡ 𝑏 (𝑚𝑜𝑑. 𝑚) admite uma única solução módulo 𝑚. 

Tais  teoremas  não  serão  demonstrados  aqui,  mas  o  leitor  pode  facilmente  encontrar 

essas demonstrações em Santos (2014) ou Alencar Filho (1989).  

Exemplo  3.17  Vamos  resolver  as  congruências  18𝑥 ≡ 30 (𝑚𝑜𝑑. 42)  e  4𝑥 ≡ 8 (𝑚𝑜𝑑. 15). 

Note  inicialmente  que  𝑚𝑑𝑐(18, 42) = 6.  Logo,  como  6|30,  segue  do  Teorema  3.15  que  a 

congruência  18𝑥 ≡ 30 (𝑚𝑜𝑑. 42)  admite  exatamente  6  soluções  mutuamente  incongruentes 

módulo 42.  

Por  tentativas,  encontramos  𝑥0 = 4  como  solução  particular  de  18𝑥 ≡ 30 (𝑚𝑜𝑑. 42),  uma 

vez  que  18 ⋅ 4 = 72 = 42 ⋅ 1 + 30.  Portanto,  como  assegurado  no  Teorema  3.15,  as  6 

soluções  incongruentes  da  congruência  18𝑥 ≡ 30 (𝑚𝑜𝑑. 42)  serão  dadas  pela  fórmula                      
4 + 𝑘 ⋅ 42
6

= 4 + 7𝑘, com 0 ≤ 𝑘 ≤ 5. São elas: 

4 + 7 ⋅ 0;
⏟      
=4

4 + 7 ⋅ 1;
⏟      
=11

4 + 7 ⋅ 2;
⏟      
=18

4 + 7 ⋅ 3;
⏟      
=25

⏟    
4 + 7 ⋅ 4
=32

. 

Portanto, as soluções da congruência 18𝑥 ≡ 30 (𝑚𝑜𝑑. 42) são os inteiros: 4, 11, 18, 25, 32 e 

39. 

Com  relação  à  congruência  4𝑥 ≡ 8 (𝑚𝑜𝑑. 15),  como  𝑚𝑑𝑐(4, 15) = 1,  segue  que  a  mesma 

admite  uma  única  solução  módulo  15.  Como  já  é  nítido,  𝑥0 = 2  é  uma  solução  particular. 

Portanto, essa é a única solução incongruente módulo 15 da congruência dada. Isso significa 

que  qualquer  outra  solução  𝑥  da  congruência  4𝑥 ≡ 8 (𝑚𝑜𝑑. 15)  é tal  que 𝑥 ≡ 2 (𝑚𝑜𝑑. 15). 

Dizemos então que 𝑥 ≡ 2 (𝑚𝑜𝑑. 15) é a solução geral da congruência 4𝑥 ≡ 8 (𝑚𝑜𝑑. 15). 

Na  próxima  seção  passaremos  a  estudar  um  pouco  do  método  RSA,  sua 

funcionalidade e como o mesmo está relacionado com alguns métodos de teoria dos números 

que estudamos nesta seção.  

 
 
 
 
 
86 

3.2 O método criptográfico RSA 

De  acordo  com  Sautoy  (2007),  um  artigo  de  uma  dupla  de  matemáticos  da 

universidade  de  Stanford  –  Whit  Diffie  e  Martin  Hellman  –  chamado  novos  caminhos  da 

criptografia, teria sido o primeiro a propor a criptografia de chave pública no meio científico. 

Até então, todos os métodos criptográficos existentes eram de chave privada. Todavia, mesmo 

com a ideia desse novo tipo de criptografia, o artigo de Diffie e Hellman não dava nenhuma 

garantia que tal criptografia pudesse realmente existir, isto é, se seria possível desenvolver um 

método  criptográfico  que  possuísse  as  propriedades  de  um  sistema  de  criptografia  de  chave 

pública. 

Felizmente, não só foi possível desenvolver um método desse tipo, como também fixá-

lo fortemente em conceitos e resultados da teoria dos números. O primeiro método proposto 

de  criptografia  de  chave  pública  foi  desenvolvido  por  um  trio  de  cientistas  do  Instituto  de 

Tecnologia  de  Massachusetts  (MIT)  –  Ron  Rivest,  Adi  Shamir  e  Leonard  Adleman  –  em 

1978.  Este  método  foi  nomeado  de  RSA  em  alusão  as  iniciais  dos  sobrenomes  de  seus 

inventores.  O  RSA  é  um  dos  métodos  de  criptografia  de  chave  pública  mais  importante  e 

seguro  do  mundo,  usado  principalmente  em  aplicações  comerciais  via  internet.  “Este  é  o 

método utilizado, por exemplo, no Netscape, o mais popular dos Softwares de navegação da 

internet” (COUTINHO, 2005, p. 3).  

Como sabemos, os métodos de criptografia de chave pública atuam com duas chaves, 

uma pública e outra privada. No RSA, a chave pública constitui-se de um número natural 𝑁, o 

qual  é  originado  a  partir  da  multiplicação  de  dois  números  primos  𝑝  e 𝑞 (í𝑚𝑝𝑎𝑟𝑒𝑠),  isto  é, 

𝑁 = 𝑝. 𝑞. Para codificar uma mensagem 𝑀 usamos 𝑁, e para decodificá-la usamos os fatores 

primos  𝑝 e 𝑞 que geraram  𝑁. Portanto, 𝑁 é a chave pública e o par 𝑝, 𝑞 a chave privada. A 

rigor, tais chaves ainda vão requerer outros inteiros positivos, que destacaremos mais adiante.  

Como  a  chave  privada  é 𝑝  e 𝑞,  logo  entendemos  que  é  muito  fácil  quebrar  o  código 

RSA, pois é só fatorar 𝑁, certo? Certo! Porém, fatorar 𝑁 e descobrir seus fatores primos 𝑝 e 𝑞 

pode se tornar uma tarefa muito difícil, mesmo para os melhores computadores. A fatoração 

de 𝑁 é dificultada por dois motivos: primeiro porque os números primos utilizados nas chaves 

do  RSA  são  gigantescos.  Logo,  o  número  𝑁  será  enorme,  com  centenas  de  dígitos, 

dificultando muito sua fatoração. E segundo porque fatorar 𝑁 em tempo útil ainda  é um dos 

problemas  mais complicados da  matemática.  A  esse respeito, Coutinho (2005) reitera o que 

acabamos de mencionar: 

 
 
87 

Usando  como  chaves  de  codificação  do  RSA  números  muito  grandes  (de  150 
algarísmos  ou  mais),  fatorar  𝑵  para  achar  𝑝  e  𝑞,  com  os  métodos  atuais  levaria 
alguns milhares de anos. É disto que depende a segurança do RSA; da ineficiência 
dos  métodos  de  fatoração  atualmente  conhecidos.  (COUTINHO,  2005,  p.  4,  grifo 
nosso) 

Portanto, o problema da  fatoração é o que garante ao RSA a segurança da  sua chave 

privada. No entanto, é preciso frisar que não é impossível, para um intruso, descobrir a chave 

privada,  pois  apesar  do  problema  da  fatoração  ser  muito  complicado  para  números  muito 

grandes, isso não descarta a possibilidade de 𝑁 ser fatorado num determinado tempo, mesmo 

que esse tempo seja consideravelmente longo. 

Dessas considerações iniciais já temos uma boa ideia da segurança do RSA e no que 

ela  se  baseia  apesar  dessa  segurança  ser  muito  mais  complexa  do  que  parece.  Todavia, 

podemos  nos  convencer  da  eficiência  e  privacidade  do  RSA  e  passar  a  explorar  seus 

processos de codificação e decodificação. Portanto, passaremos a discutir agora sobre alguns 

aspectos  desses  processos,  buscando  entender  como  aquelas  ideias  de  aritmética  básica  que 

abordamos estão relacionadas com o RSA. 

3.2.1 O processo de pré-codificação no RSA 

Antes  de  abordarmos  a  codificação  e  decodificação  no  RSA,  é  preciso  destacar  um 

processo  preliminar,  chamado  de  pré-codificação.  Para  realizar  essa  pré-codificação, 

estabelecemos  algumas  restrições,  que  só  aparecem  aqui  com  o  intuito  de  simplificar  nossa 

apresentação  do  RSA.  Em  trabalhos  voltados  para  a  criptografia,  essas  restrições  não  são 

feitas, com exceção da restrição (1) abaixo, pois se trabalha com o RSA de modo geral e num 

nível muito mais avançado. As restrições são as seguintes:  

(1) Em geral, a mensagem será tratada como um texto, cujas palavras são formadas por letras 

de um alfabeto fixado. No nosso caso, o alfabeto a ser utilizado é o usual: A, B, C, ..., Z; 

(2) A mensagem não pode conter números em seu conteúdo. Isso não quer dizer que o RSA 

não codifica  números. Pelo contrário, há também um processo específico para a codificação 

de números. Veja, por exemplo, Buchmann (2002, p. 162); 

(3)  A  mensagem  original  e  a  codificada  serão  dadas  em 

letras  maiúsculas  e 

desconsideraremos os acentos das palavras. Apenas levamos em conta as letras que compõem 

as  palavras  e  os  espaços  entre  essas  palavras.  Os  sinais  de  pontuação  não  serão  levados  em 

conta aqui. 

 
 
 
 
 
88 

Depois disso, estabelecemos uma tabela de conversão, onde associamos a cada letra do 

nosso alfabeto um número, que no nosso caso será de dois dígitos, como segue. 

Tabela 7 – Tabela de conversão 

A 

11 

K 

21 

U 

31 

B 

12 

L 

22 

V 

32 

C 

13 

M 

23 

W 

33 

D 

14 

N 

24 

X 

34 

E 

15 

O 

25 

Y 

35 

F 

16 

P 

26 

Z 

36 

G 

17 

Q 

27 

H 

18 

R 

28 

I 

19 

S 

29 

J 

20 

T 

30 

Fonte: autoria própria 

Não  utilizamos  números  de  um  dígito  porque  isso  pode  causar  certas  ambiguidades. 

Por exemplo, se o A fosse representado por 3, quem seria 33? Poderia ser AA ou W. Assim, é 

melhor utilizarmos números com dois dígitos. Do mesmo modo, essa associação é aleatória e 

não sequencial, porém tomando o cuidado evidenciado anteriormente.  Para os espaços entre 

as  palavras  utilizamos  o  número  99.  Assim,  cada  mensagem  será  transformada  em  uma 

sequência de dígitos. Por exemplo, a mensagem A ARTE DOS CÓDIGOS SECRETOS  será 

convertida, de acordo com a Tabela 7, na seguinte sequência de dígitos:  

119911283015991425299913251419172529992915132815302529 

3.2.2 O processo de codificação no RSA 

Depois  que  já  convertemos  a  mensagem  em  uma  sequência  de  dígitos,  o  próximo 

passo é escolher os parâmetros de codificação e decodificação, que são dois números primos 
𝑝  e  𝑞  (de  preferência  da  mesma  ordem  de  grandeza30),  cujo  produto  resulta  em  𝑁.  A 

sequência  é então subdividida em  blocos, onde cada um desses  blocos são  números  inteiros 

positivos menores do que 𝑁. Segundo Coutinho (2009, p. 148) apud Medeiros (2017, p. 47): 

30 A ordem de grandeza de um número 𝑛 é a potência de 10 mais próxima desse número.  

 
 
 
 
 
 
 
 
 
                                                             
89 

A maneira de escolher os blocos não é única e os blocos não precisam sequer ter o 
mesmo tamanho. Contudo, certos cuidados devem ser tomados. Por exemplo, não é 
permitido escolher um bloco que comece por 0 porque isto traria problemas na hora 
de decodificar, já que, por exemplo, não temos como distinguir o bloco 071 do bloco 
71.  

Sendo  assim,  depois  de  convertermos  a  sequência  de  dígitos  em  blocos,  tomando  os 

devidos cuidados, podemos seguir na codificação da mensagem. Considere, então, que 𝑏 seja 

um  bloco  qualquer  da  mensagem  pré  codificada.  Para  codificarmos  a  mensagem,  devemos 

codificar todos os blocos obtidos. A questão é: como devemos realizar a codificação de cada 

um  desses  blocos?  Para  realizar  essa  codificação,  primeiro  devemos  considerar  o  inteiro 

positivo 𝑁 = 𝑝. 𝑞, onde já sabemos que 𝑝 e 𝑞 são números primos. Segundo, introduziremos 

uma  nova  variável  𝑒, tal  que,  𝑒  é  relativamente  primo  com  𝜑(𝑁) = (𝑝 − 1)(𝑞 − 1),  isto  é, 

𝑚𝑑𝑐(𝑒, 𝜑(𝑁)) = 1. 

Especificamente, o que chamamos de chave pública do RSA é o par (𝑁, 𝑒), o qual será 

utilizado para codificar cada  bloco 𝑏. Denotemos por 𝐶(𝑏) o bloco 𝑏 codificado. Para obter 

𝐶(𝑏), consideremos a seguinte congruência: 

𝑐(𝑏) ≡ 𝑏𝑒(𝑚𝑜𝑑. 𝑁) 

Ou seja, 𝑐(𝑏) e 𝑏𝑒 deixam o mesmo resto na divisão por 𝑁. Por convenção, 𝑐(𝑏) deve ser um 

inteiro  positivo  menor  do  que  𝑁.  Daí,  se  𝑏𝑒  deixa  resto  𝑟  na  divisão  por  𝑁,  segue  que 

𝐶(𝑏) ≡   𝑏𝑒 ≡ 𝑟(𝑚𝑜𝑑. 𝑁), 0 ≤ 𝑟 < 𝑁 ⟹ 𝐶(𝑏) = 𝑟.  Conclusão:  

𝐶(𝑏) = 𝑟𝑒𝑠𝑡𝑜 𝑑𝑎 𝑑𝑖𝑣𝑖𝑠ã𝑜 𝑑𝑒 𝑏𝑒 𝑝𝑜𝑟 𝑁. 

A seguir, temos o resumo dos processos de codificação e decodificação no algoritmo 

RSA. 

Algoritmo 3.1 – Processo de codificação utilizando o RSA 

Codificação 

ENTRADA: mensagem M  

Etapa 1: M é pré codificada com base em uma tabela (como a Tabela 7), onde cada letra e 

espaço entre palavras é substituído por um número. 

Etapa 2: Escolhem-se dois números primos grandes 𝒑 e 𝒒 (da mesma ordem de grandeza, de 

preferência) e efetua-se a multiplicação entre eles dando origem a um número 𝑵 = 𝒑 ⋅ 𝒒.  

Etapa 3: A mensagem M pré codificada é dividida em blocos (números) menores do que 𝑵. 

 
 
 
 
 
 
90 

Etapa 4: Escolhe-se um inteiro positivo 𝒆, com 𝒆 < (𝑝 − 1)(𝑞 − 1) = 𝜑(𝑁) e tal que 𝒆 seja 

relativamente  primo  com  𝜑(𝑁),  isto  é,  𝑚𝑑𝑐(𝑒, 𝜑(𝑁)) = 1.  O  par  (𝒆, 𝑵)  é  a  chave  de 

codificação. 

Etapa  5:  Cada  bloco 𝒃  que  compõe  a  mensagem  pré  codificada  será  codificado  segundo  a 

regra: 

𝑪(𝒃) = 𝒓𝒆𝒔𝒕𝒐 𝒅𝒂 𝒅𝒊𝒗𝒊𝒔ã𝒐 𝒅𝒆 𝒃𝒆 𝒑𝒐𝒓 𝑵. 

Onde 𝑪(𝒃) representará o bloco 𝑏 codificado. A mensagem codificada será então a sequência 

formada por todos os blocos codificados, respeitando a ordem em que os mesmos aparecem 

na mensagem original M. 

SAÍDA: a mensagem codificada 𝑴′ 

Fonte: Autoria própria 

Exemplo 3.18 Vamos codificar a palavra UFERSA seguindo o Algoritmo 3.1. 

Entrada: UFERSA 

Etapa  1:  De  acordo  com  a  Tabela  7,  a  palavra  UFERSA  será  convertida  na  seguinte 

sequência de dígitos:  

311615282911 

Etapa  2:  Nossos  parâmetros  serão  os  primos  𝑝 = 17  e  𝑞 = 31.  É  claro  que  poderia  ser 

quaisquer  dois  primos  distintos 𝑝 e 𝑞  ímpares,  mas  para  simplificar  os  cálculos,  escolhemos 

primos pequenos. Assim, 𝑁 = 17 ⋅ 31 = 527.  

Etapa 3: Devemos quebrar a sequência de dígitos 311615282911 em blocos 𝑐, onde 𝑐 é um 

número inteiro  positivo menor que 527. Uma possibilidade para essa divisão em blocos é: 

31-161-52-82-9-11. 

Etapa  4:  Por  fim,  precisamos  determinar  um  natural  𝑒, tal  que,  𝑚𝑑𝑐(𝑒, 𝜑(527)) = 1.  Ora, 

como a função 𝜑 é multiplicativa e 527 = 17 ⋅ 31, com 17 e 31 números primos, segue que 

𝜑(527) = 𝜑(17 ⋅ 31) = 𝜑(17) ⋅ 𝜑(31) = 16 ⋅ 30 = 480.  Tomando  𝑒 = 7,  temos  que  o 

𝑚𝑑𝑐(7, 𝜑(527)) = 𝑚𝑑𝑐(7, 480) = 1. Portanto, a chave de codificação (chave pública) será 

o par (7, 527). 

 
 
 
 
 
 
91 

Etapa  5:  Agora,  codificaremos  cada  um  dos  blocos  31,161,52,82,9,11  usando  a  regra 

𝐶(𝑏) = 𝑟𝑒𝑠𝑡𝑜 𝑑𝑎 𝑑𝑖𝑣𝑖𝑠ã𝑜 𝑑𝑒 𝑏𝑒 𝑝𝑜𝑟 𝑁.  A  mensagem  codificada  será  a  sequência  de  blocos 

codificados, também separados, obtidos nesse processo. Sendo assim, teremos:  

Codificação do bloco 31 

Neste caso, 𝑏 = 31, logo 𝐶(31) = resto da divisão de 317 por 527.  

Como 313 ≡ 279 (𝑚𝑜𝑑. 527), através das propriedades vistas no Teorema 3.8 temos que 

316 ≡ 2792 ≡ 372 (𝑚𝑜𝑑. 527) ⟹ 317 ≡ 31.372 ≡ 465 (𝑚𝑜𝑑. 527). 

Portanto,  consideraremos  𝐶(31) = 465,  que  é  o  resto  da  divisão  de  317  por  527.  Assim, 

dizemos que o bloco 31 depois de codificado passará a ser o bloco 465.  

De  modo  inteiramente  análogo,  podemos  codificar  os  demais  blocos.  Não  realizaremos  os 

cálculos detalhadamente, mas isso não apresenta grandes dificuldades porque os números são 

pequenos.  

Codificação do bloco 161 

 𝐶(161) =  resto  da  divisão  de  1617  por  527.  Como  1612 ≡ 98 (𝑚𝑜𝑑. 527),  temos  que 

1616 ≡ 983 (𝑚𝑜𝑑. 527) ⟹ 1616 ≡ 497(𝑚𝑜𝑑. 527) ⟹ 1617 ≡ 161.497(𝑚𝑜𝑑. 527) ⟹

1617 ≡ 440(𝑚𝑜𝑑. 527). Logo, teremos 𝐶(161) = 440 e o bloco 161 passará a ser 440. 

Codificação do bloco 52 

Analogamente, 𝐶(52) ≡ 527 (𝑚𝑜𝑑. 527). Precisamos determinar o resto da divisão de  527 

por 527. Calculando 523 = 140608 e dividindo por 527, obtemos como resto dessa divisão 

o  número  426.  Logo,  teremos  523 ≡ 426 (𝑚𝑜𝑑. 527) ⟹ 526 ≡ 4262 (𝑚𝑜𝑑. 527)   ⟹

526 ≡ 188 (𝑚𝑜𝑑. 527).  Portanto,  527 ≡ 52.188 (𝑚𝑜𝑑. 527) ⟹ 527 ≡ 290 (𝑚𝑜𝑑. 527). 

Logo, 𝐶(52) = 290. 

 
 
 
 
 
 
 
 
 
 
 
 
92 

Codificação do bloco 82 

Temos: 𝐶(82) ≡ 827 (𝑚𝑜𝑑. 527). Fazendo as contas, temos  823 ≡ 126(𝑚𝑜𝑑. 527). Logo, 

826 ≡ 1262 ≡ 66(𝑚𝑜𝑑. 527) ⟹ 827 ≡ 82.66 ≡ 142(𝑚𝑜𝑑. 527). Portanto, 𝐶(82) = 142. 

Codificação do bloco 9 

Como  uma  calculadora,  calculamos  o  valor  de  97, obtendo 97 = 4782969.  Dividindo  esse 

número  por  527,  obtemos  resto  igual  a  444.  Portanto,  97 ≡ 444(𝑚𝑜𝑑. 527),  donde      

𝐶(9) = 444. 

Codificação do bloco 11 

Neste  caso,  temos  114 = 14641 = 527 ⋅ 27 + 412  e  113 = 1331 = 527 ⋅ 2 + 277.  Logo,                

114 ≡ 412(𝑚𝑜𝑑. 527)  e  113 ≡ 277(𝑚𝑜𝑑. 527).  Multiplicando  essas  duas  últimas 

congruências, obtemos 117 ≡ 412 ⋅ 277 ≡ 292(𝑚𝑜𝑑. 527). Portanto, 𝐶(11) = 292. 

Saída: 465-440-290-142-444-292.  

Relembrando que os blocos codificados devem permanecer separados. Por outro lado, 

se quisermos reverter o processo e decodificar a palavra UFERSA, deveremos seguir um novo 

processo, que descreveremos a seguir.  

3.2.3 O processo de decodificação no RSA 

Nesta  seção  iremos  analisar  o  processo  de  decodificação  no  RSA.  Para  realizarmos 

esse  processo,  ainda  é  necessário  o  conhecimento  do  inteiro  𝑁 = 𝑝 ⋅ 𝑞.  No  entanto,  outro 

número inteiro será incluído. Esse número será denotado por  𝑑 e escolhido de tal  modo que 

ele  seja  o  inverso  multiplicativo  de  𝑒  módulo  𝜑(𝑁)  (aqui  já  percebemos  a  dificuldade  de 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
93 

quebrar o RSA, pois para calcular  𝑑 precisamos de 𝜑(𝑁), mas o valor de 𝜑(𝑁) é difícil de 

calcular porque os fatores primos 𝑝 𝑒 𝑞 não são de conhecimento do público). Lembre-se que 

𝑒 juntamente com 𝑁 formam a chave pública do sistema RSA. Como vimos, o fato de 𝑑 ser o 

inverso  multiplicativo  de  𝑒  módulo  𝜑(𝑁)  significa  que  𝑑 ⋅ 𝑒 ≡ 1(𝑚𝑜𝑑. 𝜑(𝑁)).  Como  𝑒  foi 

escolhido de modo a ser relativamente primo com 𝜑(𝑁), segue que sempre existirá o inverso 

multiplicativo de 𝑒 módulo 𝜑(𝑁), donde a existência de 𝑑 está garantida.  

Portanto, se 𝐶(𝑏) denota o bloco 𝑏 codificado, então 𝐷(𝐶(𝑏)) indicará o bloco 𝐶(𝑏) 

decodificado.  Isto  significa  que  recuperamos  o  bloco  𝑏.  Ou  seja,  que  𝐷(𝐶(𝑏)) = 𝑏.  Para 

calcular 𝐷(𝐶(𝑏)) usaremos uma receita parecida com a de calcular 𝐶(𝑏). Temos que, 

𝐷(𝐶(𝑏)) = 𝑟𝑒𝑠𝑡𝑜 𝑑𝑎 𝑑𝑖𝑣𝑖𝑠ã𝑜 𝑑𝑒 𝐶(𝑏)𝑑 𝑝𝑜𝑟 𝑁. 

Em termos de congruências, temos que:  

𝐷(𝐶(𝑏)) ≡ 𝐶(𝑏)𝑑 (𝑚𝑜𝑑. 𝑁) 

O par (𝑁, 𝑑) será chamado de chave secreta (privada) do sistema RSA e sua posse é de 

uso restrito. É com essa chave que podemos decodificar todas as mensagens codificadas com 

a chave  (𝑁, 𝑒). Naturalmente, para decodificar a  mensagem por inteira devemos decodificar 

cada um dos blocos codificados.  

O Algoritmo 3.2 a seguir resume as etapas do processo de decodificação no RSA.  

Algoritmo 3.2 – Processo de decodificação usando o RSA 

Decodificação 

Entrada: uma mensagem codificada 𝑀′ 

Etapa 1: Calcula-se o inverso multiplicativo de 𝑒 módulo 𝜑(𝑁), isto é, calcula-se um inteiro 

positivo 𝒅, 1 < 𝒅 < 𝜑(𝑁), tal que 𝒅 ⋅ 𝒆 ≡ 𝟏(𝒎𝒐𝒅. 𝝋(𝑵)). 

Etapa 2: Cada bloco 𝐶(𝑏) será decodificado segundo a regra:  

𝑫(𝑪(𝒃)) = 𝒓𝒆𝒔𝒕𝒐 𝒅𝒂 𝒅𝒊𝒗𝒊𝒔ã𝒐 𝒅𝒆 (𝑪(𝒃))

𝒅

 𝒑𝒐𝒓 𝑵 

𝑑
Isto equivale a dizer que  𝐷(𝐶(𝑏)) ≡ (𝐶(𝑏))

𝑑
(𝑚𝑜𝑑. 𝑁). Ou seja, 𝑏 ≡ (𝐶(𝑏))

(𝑚𝑜𝑑. 𝑁). O 

𝑑
bloco 𝑏 será então igual ao resto da divisão de (𝐶(𝑏))

 por 𝑁. 

Saída: A mensagem original 𝑀 

Fonte: Autoria própria 

 
 
 
94 

Exemplo 3.19 Por meio do Algoritmo 3.2 já sabemos como decodificar mensagens no RSA. 

Nos  preocuparemos,  agora,  em  recuperar  a  mensagem  465-440-290-142-444-292  codificada 

no  Exemplo  3.18.  Devemos  decodificar  cada  um  dos  blocos  e,  portanto,  decodificar  a 

mensagem por inteira seguindo as etapas dadas no Algoritmo 3.2. 

Etapa  1:  A  chave  pública  que  utilizamos  foi  (7, 527).  Para  calcular o  valor  de  𝑑,  devemos 

resolver a congruência 7𝑑 ≡ 1(𝑚𝑜𝑑. 𝜑(527)). Como já temos os fatores primos que geraram 

527, fica fácil calcular 𝜑(527) (como sabemos, na prática isso não acontece, pois os fatores 𝑝 

e  𝑞  não  são  publicados).  Temos  𝜑(527) =  𝜑(17 ⋅ 31) = 480.  Logo,  7𝑑 ≡ 1(𝑚𝑜𝑑. 480). 

Como  o  módulo  dessa  última  congruência  é  um  número  grande,  tentar  encontrar  𝑑  por 

tentativas  fica  muito  difícil.    Sendo  assim,  o  que  geralmente  é  feito  é  transformar  a 

congruência  7𝑑 ≡ 1(𝑚𝑜𝑑. 480)  numa  equação  do  tipo  𝑎𝑥 + 𝑏𝑦 = 𝑐,  com  𝑎, 𝑏, 𝑐, 𝑥  e  𝑦 
inteiros31.  Ora,  se  7𝑑 ≡ 1(𝑚𝑜𝑑. 480),  então  existe  𝑘 ∈ ℤ,  tal  que  7𝑑 = 480𝑘 + 1,  o  que 

implica  7𝑑 − 480𝑘 = 1,  que  é  uma  equação  diofantina.  Resolvendo  essa  equação,  obtemos 

uma solução (343, 5). Logo, uma solução para 7𝑑 ≡ 1(𝑚𝑜𝑑. 480) é 𝑑 = 343. Assim sendo, 

a chave secreta será (527, 343).  

Etapa  2:  Passemos  às  decodificações.  Como  os  cálculos  agora  serão  mais  trabalhosos  e 

extensos, pois os números serão muito grandes, optaremos por descrever aqui apenas alguns 

passos  do  cálculo  do  bloco  𝐷(465).  Para  os  demais  daremos  apenas  o  resultado  final, 

deixando a tarefa de verificar as contas por parte do leitor.  

Decodificação do bloco 465 

Devemos  calcular  o  resto  da  divisão  de  465343  por  𝑁 = 527  para  obter  𝐷(465). 

Começamos  calculando  4653 = 100544625.  O  resto  da  divisão  desse  número  por  527  é 

403,  donde  4653 ≡ 403(𝑚𝑜𝑑. 527).  A  partir  daí,  temos  as  implicações  seguintes,  que  o 

leitor pode verificar sem problema algum: 

4653 ≡ 403(𝑚𝑜𝑑. 527) ⟹ 4656 ≡ 93(𝑚𝑜𝑑. 527) ⟹ 46512 ≡ 217(𝑚𝑜𝑑. 527). 

Agora, 

como 

343 = 28.12 + 7, 

elevamos 

os 

dois 

lados 

da 

congruência                      

46512 ≡ 217(𝑚𝑜𝑑. 527) a 28, obtendo 465336 ≡ 21728(𝑚𝑜𝑑. 527). Precisamos determinar 

o  resto  da  divisão  do  número  21728  por  527.  Com  mais  alguns  cálculos,  que  podem  ser 

31  Essas  equações  são  chamadas  de  equações  diofantinas  (em  homenagem  ao  matemático  Diofanto  de 
Alexandria).  Para  estudar  os  métodos  de  resolução  dessas  equações,  o  leitor  pode  consultar  Santos  (2014)  ou 
Alencar Filho (1989). 

 
 
 
 
                                                             
95 

rápidos  se  tivermos  um  computador  por  perto,  podemos  calcular  este  resto  facilmente. 

Teremos:  

2173 ≡ 310(𝑚𝑜𝑑. 527) ⟹ 2176 ≡ 186(𝑚𝑜𝑑. 527) ⟹ 21712 ≡ 341(𝑚𝑜𝑑. 527) 

⟹ 21724 ≡ 341(𝑚𝑜𝑑. 527) 

⟹ 21728 = 21724. 2174 = 21724. 2173217 ≡ 341.310.217(𝑚𝑜𝑑. 527) 

Como 341.310.217 = 22939070 = 43527.527 + 341, segue que  

21728 ≡ 341.310.217 ≡ 341(𝑚𝑜𝑑. 527). 

Portanto,  465336 ≡ 21728 ≡ 341(𝑚𝑜𝑑. 527).  Para  finalizar,  multiplicamos  os  dois  lados 

desta  última  congruência  por  4657,  considerando  que  4657 ≡ 31(𝑚𝑜𝑑. 527).  Teremos, 

então 

4657. 465336 ≡ 4657. 341(𝑚𝑜𝑑. 527) ⟹ 465343 ≡ 31.341 ≡ 31(𝑚𝑜𝑑. 527). 

Portanto,  o  resto  da  divisão  de  465343  por  527  é  31,  isto  é,  𝐷(465) = 𝐷(𝐶(31)) = 31  e 

recuperamos o bloco 31. 

Utilizando um raciocínio análogo ao anterior, podemos recuperar os demais blocos. A tabela a 

seguir apresenta os demais resultados da decodificação. 

Decodificação dos demais blocos: 

𝐷(440) = 𝐷(𝐶(161)) = 161 

𝐷(290) = 𝐷(𝐶(52)) = 52 

𝐷(142) = 𝐷(𝐶(82)) = 82 

𝐷(444) = 𝐷(𝐶(9)) = 9 

𝐷(292) = 𝐷(𝐶(11)) = 11 

Saída: 31-161-52-82-9-11 

Terminado esse processo de decodificação, obteremos a seguinte sequência de blocos:        

31-161-52-82-9-11, que corresponde a palavra UFERSA de acordo com a Tabela 7.  

É claro que os cálculos anteriores são muito complicados para serem feitos com lápis e 

papel.  Na  prática  pode-se  utilizar  uma  calculadora  profissional,  um  aplicativo  de  celular  ou 

um  programa  de  computador  para  efetuar  essas  divisões  com  números  muito  grandes. 

Evidentemente,  nas  aplicações  do  RSA  no  mundo  real,  todos  os  cálculos  são  feitos  por 

 
 
 
 
 
96 

computador. O leitor pode desenvolver novos exemplos com números menores para facilitar o 

entendimento  dos  processos  de  codificação  e  decodificação.  O  importante,  com  base  no 

propósito  deste  trabalho,  é  entender  como  os  conceitos  de  aritmética  se  manifestam  nesse 

sistema criptográfico. Isto trará um entendimento mais sólido sobre o funcionamento do RSA 

e facilitará uma possível exposição desse método como uma aplicação da teoria dos números, 

em particular da aritmética básica, em sala de aula.  

Assim  sendo,  para  auxiliar  o  professor,  caso o  mesmo  deseje  trabalhar  o  RSA  como 

aplicação  da  aritmética  básica  em  suas  aulas,  os  Exemplos  3.18  e  3.19,  com  o  auxílio  dos 

Algoritmos  3.1  e  3.2,  foram  desenvolvidos  de  modo  a  explicitar  uma  possível  sequência 

didática que facilite a aplicação desse método criptográfico em sala de aula. De modo simples 

e  fácil,  o  professor  pode  utilizar  o  passo  a  passo  dado  nos  algoritmos  para  explicar  como 

funcionam  os  processos  de  codificação  e  decodificação  no  RSA.  Consequentemente,  esse 

passo  a  passo  pode  ser  utilizado  na  resolução  de  problemas  envolvendo  codificação  e 

decodificação de mensagens por meio do RSA como foi feito nos Exemplos 3.18 e 3.19. Isto 

torna  muito  mais  fácil  a  aplicação  e  entendimento  do  RSA,  bem  como  a  compreensão  da 

matemática  envolvida.  Além  de  apresentar  ao  aluno  situações  práticas  e  reais  em  que  a 

matemática está diretamente envolvida. 

Para  finalizarmos  este  capítulo,  explicaremos  brevemente  porque  o  RSA  funciona  e 

em que se baseia sua segurança com base no que vimos sobre aritmética básica. Inicialmente, 

como  estamos  tratando  de  um  método  de  criptografia,  os  processos  de  codificação  e 

decodificação  associados  a  ele  devem  ser  bem  específicos  e  relacionados  de  tal  modo  que 

sempre  deverá  ser  possível  recuperar  um  bloco  codificado,  isto  é,  reverter  o  processo  de 

codificação. No caso do RSA, é possível provar que 𝐷(𝐶(𝑏)) = 𝑏 qualquer que seja o bloco 

𝑏. Uma demonstração desse resultado pode ser encontrada em Coutinho (2005, p. 184). Isso 

garante que sempre que decodificarmos um bloco codificado voltaremos ao bloco 𝑏. De modo 

geral, sempre que decodificarmos um texto codificado, voltaremos ao texto original.  

Quanto à segurança do RSA, a mesma está apoiada na dificuldade de fatorar o inteiro 

𝑁,  como  já  citado.  Sendo  (𝑁, 𝑒)  a  chave  pública  do  sistema,  para  quebrá-lo  seria  preciso 

fatorar 𝑁 e descobrir os fatores primos 𝑝 e 𝑞. Conhecido os fatores primos, conhecemos 𝜑(𝑁) 

e,  consequentemente,  descobrimos  𝑑  que  é  a  chave  privada  propriamente  dita,  uma  vez  que 

𝑑 ⋅ 𝑒 ≡ 1(𝑚𝑜𝑑. 𝜑(𝑁)) e 𝑒 é público. No entanto, é muito difícil fatorar 𝑁 em tempo útil, pois 

como  já citamos, os primos utilizados no RSA podem ter  mais de 300 algarismos, de  modo 

 
97 

que poderia levar centenas de anos para que certas fatorações pudessem ser realizadas com os 

métodos que hoje existem. No entanto, se é muito complicado fatorar 𝑁, então o método RSA 

está livre de ataques? Ou melhor, existem outros modos para tentar vencer este sistema? Bom, 

há vários fatores que poderiam influenciar na quebra desse sistema, mas isso só é tratado em 

livros especializados em criptografia. Uma dessas maneiras está ligada a escolha dos primos 

que  darão  origem  ao  inteiro  𝑁.  Se  eles  forem  mal  escolhidos,  isso  pode  acarretar  em 

facilidade para fatorar 𝑁. Outra maneira que poderia tornar o RSA obsoleto seria a invenção 

de um  algoritmo de  fatoração de tempo polinomial,  isto é, que conseguisse  fatorar qualquer 

número inteiro muito rapidamente. Até agora tal algoritmo  não existe, mas não se descarta a 

possibilidade de um dia um vir a ser inventado.  

O que também poderia dar certo para vencer o RSA seria conseguir determinar 𝑑 sem 

ter que fatorar 𝑁. Ou então obter 𝜑(𝑁) sem conhecer 𝑝 e 𝑞. No entanto, esses são problemas 

para  os  quais  uma  solução  ainda  não  existe,  o  que  é  muito  bom  para  a  segurança  do  RSA. 

Enfim,  enquanto  não  existir  uma  maneira  rápida  para  fatorar  inteiros  ou  um  método  para 

calcular 𝑑 sem recorrer à fatoração, o RSA permanecerá intacto e nossas senhas de cartões de 

créditos  e  transações  comerciais  via  internet  estarão  seguros.  Logicamente,  a  segurança  do 

RSA é muito mais delicada do que possa parecer, e muitos outros fatores podem influenciar 

nessa  segurança.  Para  o  leitor  interessado  em  aprofundar  seus  estudos  em  criptografia,  em 

especial  a  criptografia  RSA,  as  obras  já  citadas  constituem  uma  rica  fonte  de  informações 

sobre o assunto.  

 
  
 
 
 
 
 
 
 
 
 
 
98 

4  APLICAÇÕES  II:  ALGUNS  CONCEITOS  DE  MATEMÁTICA  BÁSICA  EM 

CRIPTOGRAFIA 

Destacamos mais uma vez o objetivo central deste trabalho que é investigar a relação 

entre matemática básica e criptografia e como essa relação pode nos render ferramentas para a 

melhoria  do  ensino  e  aprendizagem  de  matemática.  No  Capítulo  2  já  citamos  elementos 

simples  de  matemática  que  tem  relação  com  criptografia,  como  análise  combinatória,  por 

exemplo.  No  Capítulo  3  nosso  objetivo  foi  ressaltar  que  a  aritmética  básica  também  está 

inserida na ciência dos códigos. Para finalizar nossa investigação, trataremos neste capítulo de 

revisar  alguns  temas  de  matemática  do  ensino  médio  e  relacioná-los  com  algum  método  de 

criptografia. Essa relação, na maioria das vezes dada por meio de exemplos, funcionará como 

uma aplicação daquele assunto na criptografia e como ferramenta principal de motivação para 

o desenvolvimento de atividades em sala de aula. Este capítulo fundamenta-se em obras, tais 

como:  Buchmann  (2002),  Lima  et  al.  (2006a),  Lima  (2013),  Lima  et  al.  (2006b),            

França (2014), Tavares et al. (2017), entre outros.  

4.1 Conjuntos, Funções e Criptografia 

Conjuntos e funções são tópicos já consagrados de matemática no ensino básico. Seu 

estudo é indispensável para a compreensão e o desenvolvimento de toda a matemática. Como 

consequência  disso,  o  conhecimento  nessa  área  nos  dá  condições  de  compreender  mais 

detalhadamente como funciona e se estrutura a matemática da criptografia. Sendo assim, nesta 

seção  desenvolveremos  um  pouco  da  teoria  relacionada  com  conjuntos  e  funções.  Como 

nosso estudo frisa a matemática básica, não nos estenderemos nessas teorias. Apresentaremos 

alguns conceitos básicos, porém necessários, para melhor proveito e compreensão de como os 

mesmos  se  fazem  presentes  na  criptografia.  Começaremos  revisando  alguns  fatos  básicos 

sobre a Linguagem de Conjuntos. 

4.1.1 Noções básicas sobre Conjuntos 

“Toda a  matemática  atual é  formulada  na  linguagem de conjuntos. Portanto, a noção 

de  conjunto  é  a  mais  fundamental:  a  partir  dela,  todos os  conceitos  matemáticos  podem  ser 

expressos”  (LIMA  et  al.,  2006a,  p.  1).  A  importância  do  conceito  de  conjunto,  destacado 

 
 
 
 
99 

anteriormente, também é notória em criptografia. Como veremos ao longo deste capítulo, os 

conjuntos  aparecerão  como  simplificadores  de  notações,  bem  como  simplificadores  da 

linguagem  utilizada  para  descrever  o  funcionamento  dos  métodos  criptográficos  em  geral. 

Portanto, é de suma  importância o conhecimento de noções  básicas de  conjuntos, tais como 

notação, quantidade de elementos e operações.  

Para isso, precisamos entender inicialmente o que é um conjunto. Na realidade, não há 

uma definição precisa para conjuntos com  base em outros conceitos já definidos. Ou seja, a 

noção de conjunto é primitiva. Isso significa que ela será adotada sem definição, aceita como 

algo conhecido por todos. Assim como na geometria, onde adotamos os conceitos de ponto, 

reta e plano como primitivos, e a partir daí desenvolvemos toda a teoria, nas exposições sobre 

linguagem  de  conjuntos  também  seguimos  esse  mesmo  raciocínio:  aceitamos  o  conceito  de 

conjunto  sem  definição,  e  a  partir  daí  nos  preocupamos  em  saber  como  são  constituídos  os 

conjuntos,  como  se  relacionam  e  quais  as  suas  propriedades.  Assim,  segundo  Lima  et  al. 

(2006a, p.1): 

Um conjunto é formado por elementos. Dados um conjunto 𝐴 e um objeto qualquer 
𝑎  (que  pode  até  mesmo  ser  outro  conjunto),  a  única pergunta  cabível  em relação  a 
eles  é:  𝑎  é  ou  não  um  elemento  do  conjunto  𝐴?  No  caso  afirmativo,  diz-se  que  𝑎 
pertence  ao  conjunto  𝐴  e  escreve-se  𝑎 ∈ 𝐴.  Caso  contrário,  põe-se  𝑎 ∉ 𝐴  e  diz-se 
que 𝑎 não pertence ao conjunto A. (LIMA et al., 2006a, p. 1) 

A relação a pertence ao conjunto A é dita relação de pertinência. Como de costume, 

utilizamos letras latinas maiúsculas para indicar os conjuntos, e letras latinas minúsculas para 

indicar os seus elementos.  A representação formal de um conjunto será, portanto, a seguinte:  

𝐴 = {𝑎, 𝑏, 𝑐, 𝑑, 𝑒, … }. 

Podemos  destacar  muitos  conjuntos  importantes:  os  conjuntos  numéricos  ℕ, ℤ, ℚ, ℝ 

(além do conjunto ℂ dos números complexos), conjuntos de pontos e de retas na geometria, 

conjunto  de  figuras  geométricas  (triângulos,  quadriláteros,  etc),  conjuntos  de  funções, 

matrizes,  entre  muitos  outros.  Além  desses,  podemos  destacar  o  conjunto  que  não  contém 

nenhum  elemento,  chamado  conjunto  vazio  e  indicado  pelo  símbolo  ∅,  e  os  conjuntos 

unitários  que  são  aqueles  que  possuem  um  único  elemento.  Na  criptografia,  na  área  de 

computação, o conjunto (que mais tarde iremos chamar de alfabeto) {0, 1} é essencial para a 

linguagem binária, base do sistema computacional moderno.  

 
 
100 

Definição  4.1  Sejam  𝐴  e 𝐵  conjuntos.  Se  para  cada elemento  𝑥 ∈ 𝐴  for  verdade  que  𝑥 ∈ 𝐵 

(ou seja, se todo elemento de 𝐴 for também elemento de 𝐵), então diremos que o conjunto 𝐴 

está  contido  no  conjunto  𝐵.  Indicamos  isto  com  a  notação  𝐴 ⊂ 𝐵.  Neste  caso,  dizemos 

também que 𝐴 é um subconjunto de 𝐵, ou que 𝐴 é uma parte de 𝐵. Por outro lado, se existir 

ao menos um elemento 𝑥 ∈ 𝐴 tal que 𝑥 ∉ 𝐵, dizemos que 𝐴 não está contido em 𝐵, ou que 𝐴 

não é um subconjunto de 𝐵, ou que 𝐴 não é uma parte de 𝐵 e denotamos por 𝐴 ⊄ 𝐵.  

Exemplo  4.1  O  conjunto  ℕ  dos  números  naturais  está  contido  no  conjunto  ℤ  dos  números 

inteiros, pois todo número natural também é inteiro. No geral, temos  ℕ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ.  

+ 1  (𝑛  inteiro  não  negativo),  chamados  números  de  Fermat32.  Fermat  chegou  a 

Exemplo 4.2 Seja  𝒫 o conjunto dos números primos e 𝐵 o conjunto dos números da  forma 
𝐹𝑛 = 22𝑛
conjecturar que todo número da forma 22𝑛
+ 1 é primo, o que ele verificou ser verdade para 
os  números  𝐹0, 𝐹1, 𝐹2,𝐹3  e  𝐹4.    Euler33  provou,  anos  depois,  que  a  conjectura  de  Fermat  era 

falsa. Euler conseguiu mostrar que o número 𝐹5 é composto. Portanto, 𝐵 ⊄ 𝒫. Hoje sabemos 

que todos os números de Fermat conhecidos são compostos, exceto aqueles encontrados pelo 

próprio Fermat. Não se sabe se existem outros números primos de Fermat, veja Martinez et al. 

(2013). 

A relação 𝐴 contido em 𝐵 é conhecida como relação de inclusão. Ela possui, qualquer 

que sejam os conjuntos 𝐴, 𝐵 e 𝐶, as seguintes propriedades:  

(i) 𝐴 ⊂ 𝐴 para todo conjunto 𝐴. (Propriedade reflexiva); 

(ii) se 𝐴 ⊂ 𝐵 e 𝐵 ⊂ 𝐴, então 𝐴 = 𝐵. (Propriedade anti - simétrica); 

(iii) se 𝐴 ⊂ 𝐵 e 𝐵 ⊂ 𝐶, então 𝐴 ⊂ 𝐶. (Propriedade transitiva); 

(iv) ∅ ⊂ 𝐴 

A  Propriedade  (ii)  estabelece  a  Igualdade  de  Conjuntos.  Ela  assegura  que  dois 

conjuntos 𝐴 e 𝐵 são iguais se, e somente se, 𝐴 ⊂ 𝐵 e 𝐵 ⊂ 𝐴, isto é, se, e somente se, 𝐴 e 𝐵 

possuem  os  mesmos  elementos  (LIMA  et  al.,  2006a).  Para  indicar  que  𝐴  não  é  igual  a  𝐵 

usamos a simbologia  𝐴 ≠ 𝐵. Neste caso, temos que 𝐴 ⊄ 𝐵 ou 𝐵 ⊄ 𝐴. Quando 𝐴 ⊂ 𝐵, sendo 

32 Pierre de Fermat (1601 - 1665), matemático francês.  
33 Leonard Euler (1707 - 1783), matemático e físico suíço. 

 
                                                             
101 

que  𝐴 ≠ 𝐵  e  𝐴 ≠ ∅,  dizemos  que  𝐴  é  uma  parte  própria  de  𝐵, ou  que  𝐴  é  um  subconjunto 

próprio de 𝐵. Os subconjuntos 𝐴 e ∅ de 𝐴 são chamados de subconjuntos triviais.  

Dado um conjunto 𝐴, o conjunto de todas as partes de 𝐴 será indicado por 𝑃(𝐴). Ou 

seja,  𝑃(𝐴) = {𝑋; 𝑋 ⊂ 𝐴}.  Neste  caso,  dizer  que  𝑋 ∈ 𝑃(𝐴)  é o  mesmo  que  dizer  𝑋 ⊂ 𝐴.  Por 

exemplo,  se  𝐴 = {𝑎, 𝑏, 𝑐},  então  𝑃(𝐴) = {∅, {𝑎}, {𝑏}, {𝑐}, {𝑎, 𝑏}, {𝑎, 𝑐}, {𝑏, 𝑐}, {𝑎, 𝑏, 𝑐}}.  É 

possível  provar,  e  já  é  bem  conhecido  que  se  𝐴  tem  𝑛  elementos,  então  𝐴  possui  2𝑛 

subconjuntos, isto é, 𝑃(𝐴) tem 2𝑛 elementos. 

Definição 4.2 (União de conjuntos) Sejam dados dois conjuntos quaisquer  𝐴 e 𝐵. Chama-se 

reunião, ou união, de 𝐴 e 𝐵 o conjunto formado por todos os elementos que pertencem a 𝐴 ou 

a 𝐵. Denotaremos por 𝐴 ∪ 𝐵 = {𝑥; 𝑥 ∈ 𝐴 𝑜𝑢 𝑥 ∈ 𝐵}. 

Ou  seja,  para  um  elemento  𝑥  pertencer  a    𝐴 ∪ 𝐵  é  necessário  e  suficiente  que  ele 

pertença a pelo menos um dos conjuntos 𝐴 ou 𝐵. 

Figura 10 – União de dois conjuntos 

                                               Fonte: Autoria própria 

Na Figura 10 temos que os conjuntos 𝐴 e 𝐵 estão representados por círculos. A união 

de 𝐴 com 𝐵 é representada pela região cinza.  

Exemplo  4.3  Se  𝐴 = {1, 2, 3}  e  𝐵 = {0, 4, 8, 10},  então  𝐴 ∪ 𝐵 = {0, 1, 2, 3, 4, 8, 10}.  Temos 

sempre que 𝐴 ⊂ 𝐴 ∪ 𝐵 e 𝐵 ⊂ 𝐴 ∪ 𝐵. Se 𝐴 ⊂ 𝐵, então 𝐴 ∪ 𝐵 = 𝐵. Para todo conjunto 𝐴, tem-

se que 𝐴 ∪ ∅ = 𝐴. Outras propriedades sobre a união de conjuntos podem ser encontradas em 

Alencar Filho (1972).  

 
 
     
 
 
102 

Definição  4.3  (Intersecção  de  Conjuntos)  Sejam  dados  dois  conjuntos  quaisquer  𝐴  e  𝐵. 

Chama-se intersecção de 𝐴 e 𝐵 o conjunto formado por todos os elementos que pertencem a 𝐴 

e 𝐵 simultaneamente. Denotaremos por 𝐴 ∩ 𝐵 = {𝑥; 𝑥 ∈ 𝐴 e 𝑥 ∈ 𝐵}. 

Ou  seja,  para  um  elemento  𝑥  pertencer  a    𝐴 ∩ 𝐵  é  necessário  e  suficiente  que  ele 

pertença 𝐴 e também a 𝐵. A Figura 11 a seguir ilustra a intersecção 𝐴 ∩ 𝐵 indicada pela parte 

cinza. 

Figura 11 – Intersecção de dois Conjuntos 

Fonte: Autoria própria 

Exemplo 4.4 Se 𝐴 = {1, 2, 3, 4, 5, 8, 10} e 𝐵 = {0, 4, 8, 10}, então 𝐴 ∩ 𝐵 = {4, 8, 10}. Temos 

sempre que 𝐴 ∩ 𝐵 ⊂ 𝐴 e 𝐴 ∩ 𝐵 ⊂ 𝐵. Se 𝐴 ⊂ 𝐵, então 𝐴 ∩ 𝐵 = 𝐴. Para todo conjunto 𝐴, tem-

se que 𝐴 ∩ ∅ = ∅. 

Definição 4.4 (Diferença de conjuntos) Dados os conjuntos 𝐴 e 𝐵, chama-se diferença entre 𝐴 

e 𝐵 o conjunto formado por todos os elementos que pertencem à 𝐴, mas não pertencem à 𝐵. 

Denotaremos por 𝐴 − 𝐵 = {𝑥; 𝑥 ∈ 𝐴 e 𝑥 ∉ 𝐵}.  

 
 
 
 
 
 
 
 
 
 
Figura 12 – Diferença de dois Conjuntos 

103 

Fonte: Autoria própria 

Exemplo 4.5 Se 𝐴 = {1, 2, 3, 4, 5, 8, 10} e 𝐵 = {0, 4, 8, 10}, então 𝐴 − 𝐵 = {1, 2, 3, 5, }. 

Quando  𝐴 ∩ 𝐵 = ∅, nenhum  elemento  de  𝐴  pertence  à  𝐵,  de  modo  que  𝐴 − 𝐵 = 𝐴 

(LIMA, 2013). Na Figura 12 a diferença 𝐴 − 𝐵 é indicada pela parte em cinza.  

Definição  4.5  (Complementar  de  um  conjunto)  Sejam  𝐴  e  𝐵  conjuntos  quaisquer,  tais  que 

𝐵 ⊂ 𝐴. A diferença 𝐴 − 𝐵 será dita o complementar de 𝐵 com relação à 𝐴, e será indicada por 

𝐶𝐴

𝐵. Portanto, 𝐶𝐴

𝐵 =  𝐴 − 𝐵. 

Figura 13 – Complementar de 𝐵 com relação à 𝐴 

Fonte: Autoria própria 

Exemplo 4.6 Seja ℝ o conjunto dos números reais. A diferença  ℝ − ℚ é o complementar de 

ℚ (conjunto dos números racionais) com relação à ℝ. O conjunto ℝ − ℚ é igual ao conjunto 

dos números irracionais.      

 
 
 
 
 
 
104 

Definição  4.6  (Conjunto  Universo)  Chama-se  conjunto  universo  𝑈  o  conjunto  formado  por 

todos os conjuntos tratados numa certa discussão (LIMA, 2013). 

Isto  quer  dizer  que  quando  considerarmos  conjuntos  𝐴,  𝐵,  𝐶,  ...,  etc.,  existirá  um 

conjunto maior que conterá todos esses conjuntos. Assim, por exemplo, quando abordamos a 

aritmética  no  Capítulo  3,  nosso  universo  era  o  conjunto  ℤ  dos  números  inteiros  (todos  os 

conjuntos que tratamos eram subconjuntos de ℤ). 

Com  a  noção  de  conjunto  universo  definida  podemos  completar  a  definição  de 

complementar de um conjunto. Assim, dado um conjunto 𝐴, contido num universo 𝑈, chama-

se complementar de 𝐴 com relação à 𝑈 a diferença 𝑈 − 𝐴, formada por todos os elementos de 

𝑈  que  não  pertencem  a  𝐴.  Em  símbolos,  temos  𝑈 − 𝐴 = 𝐶𝑈
simplificar, usa-se apenas a notação 𝐴𝐶 para indicar o complementar de 𝐴, sem fazer menção 

𝐴 = {𝑥 ∈ 𝑈; 𝑥 ∉ 𝐴}.  Para 

ao conjunto universo 𝑈: 𝐴𝐶 = 𝐶𝑈

𝐴. 

Figura 14 – Complementar de 𝐴 com relação ao Universo 

Fonte: Autoria própria 

Para  finalizar  essas  considerações  sobre  conjuntos,  abordaremos  brevemente  o 

importante conceito de conjunto finito.  

Definição 4.7 Seja 𝑛 um número natural. Com a notação Ι𝑛 indicaremos o conjunto de todos 

os números naturais da sequência 1, 2, 3, ..., 𝑛. Isto é, Ι𝑛 = {1, 2, 3, … , 𝑛}.  

Exemplo 4.7 Para 𝑛 = 10, tem-se Ι10 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. 

 
 
 
 
105 

Intuitivamente,  um  conjunto  é  finito  quando  podemos  dizer  quantos  são  os  seus 

elementos, isto é, quando ele possui uma quantidade  𝑥 de elementos. Para tornar essa noção 

mais rigorosa do ponto de vista matemático, precisamos tornar mais preciso o que se entende 

por uma contagem dos elementos de um conjunto, como veremos a seguir.   

Definição  4.8  (Conjuntos  Finitos)  Um  conjunto  𝐴  é  dito  finito  se  for  vazio  (neste  caso  ele 

possui  0  elementos),  ou  então  se  existir  um  função  bijetiva  𝑓: Ι𝑛 ⟶ 𝐴,  do  conjunto  Ι𝑛  no 

conjunto 𝐴. Neste último caso, dizemos que 𝐴 tem 𝑛 elementos. 

A  função  bijetiva  mencionada  na  definição  anterior  é  a  noção  mais  rigorosa  de  uma 

contagem  dos  elementos  de  𝐴.  Quando  estabelecemos  uma  bijeção  𝑓  de  Ι𝑛  em  𝐴,  estamos 

contando os elementos de 𝐴. Para ficar mais clara essa contagem, consideremos que  

𝑓(1) = 𝑥1, 𝑓(2) = 𝑥2,..., 𝑓(𝑛) = 𝑥𝑛 

Como 𝑓 é uma função bijetiva, podemos garantir que todos os elementos de 𝐴 foram contados 

(pois 𝑓 é sobrejetiva), e somente uma única vez (pois 𝑓 é injetiva). Logo, 𝐴 = {𝑥1, 𝑥2, … , 𝑥𝑛}. 

Donde podemos contar os elementos de 𝐴.  

Exemplo  4.8  O  conjunto  das  letras  do  nosso  alfabeto  é  finito  e  possui  26  elementos.  O 

conjunto dos divisores de um número inteiro é finito.  Se considerarmos o conjunto de todas 

as  permutações  da  palavra  criptografia,  veremos  que  esse  conjunto  é  finito  e  possui               

59 875 200 elementos.  

Quando  um  conjunto  não  é  finito,  ele  será  dito  infinito.  Portanto,  um  conjunto  𝐴  é  infinito 

quando não existe uma função bijetiva 𝑓: Ι𝑛 ⟶ 𝐴 qualquer que seja o 𝑛 natural. 

Exemplo 4.9 Os conjuntos ℕ, ℤ, ℚ e ℝ são todos infinitos. O conjunto dos números primos é 

infinito. O conjunto dos pontos do plano é infinito. 

Na próxima seção estudaremos alguns tópicos relacionados ao conceito de função.  

 
 
 
 
 
106 

4.1.2 Noções básicas sobre Funções 

De acordo com Lima (2013, p. 13),  

Uma função 𝑓: 𝐴 → 𝐵 consta de três partes: um conjunto 𝐴, chamado o domínio da 
função  (ou  o  conjunto  onde  a  função  é  definida),  um  conjunto  𝐵,  chamado  de 
contradomínio  da  função,  ou  o  conjunto  onde  a  função  toma  valores,  e  uma regra 
que permite associar, de modo bem determinado, a cada elemento 𝑥 ∈ 𝐴, um único 
elemento 𝑓(𝑥) ∈ 𝐵, chamado o valor que a função assume em 𝑥 (ou no ponto 𝑥). 

Assim, uma função nada mais é que uma receita (um algoritmo) que nos ensina como 

associar cada elemento de 𝐴 a um único elemento de 𝐵. Quanto as notações, uma função 𝑓, de 

𝐴 em  𝐵, é comumente  indicada por 𝑓: 𝐴 → 𝐵 (como já vimos anteriormente), ou 𝐴

𝑓
→ 𝐵, ou 

então 𝑥 → 𝑓(𝑥) para indicar que 𝑓(𝑥) é o valor associado à 𝑥 por 𝑓. Dizemos que 𝑦 = 𝑓(𝑥) é 

a imagem de 𝑥 por 𝑓. 

Figura 15 – Uma função 𝑓 de 𝐴 em 𝐵 

Fonte: Autoria própria 

Lima (2013) nos ensina ainda duas coisas importantes sobre funções:  

1ª)  Para  todo 𝑥 ∈ 𝐴,  deve  existir  ao  menos  um  𝑦 ∈ 𝐵, tal  que,  𝑦 = 𝑓(𝑥).  Ou  seja,  a 

regra  que  ensina  como  obter  𝑓(𝑥)  a  partir  de  𝑥  deve  valer  para  todos  os  elementos  𝑥  do 

domínio de 𝑓; 

2ª) Um elemento 𝑥 ∈ 𝐴 só pode ter uma  imagem  𝑦 = 𝑓(𝑥) ∈ 𝐵. Isto significa que se 

existir 𝑥 ∈ 𝐴, tal que, 𝑓(𝑥) = 𝑦 e 𝑓(𝑥) = 𝑦′, então 𝑦 = 𝑦′. 

 
 
 
 
107 

Exemplo 4.10 Fazendo 𝐴 = ℝ e 𝐵 = ℤ, podemos definir uma função  𝑓: ℝ → ℤ pondo, para 

cada 𝑥 ∈ ℝ,  𝑓(𝑥) = ⌊𝑥⌋ = 𝑝𝑎𝑟𝑡𝑒 𝑖𝑛𝑡𝑒𝑖𝑟𝑎 𝑑𝑒 𝑥. Onde ⌊𝑥⌋ é o maior inteiro que não excede 𝑥. 

Definição  4.9  Dizemos  que  duas  funções  𝑓  e  𝑔  são  iguais  se  elas  possuírem  o  mesmo 

domínio,  o  mesmo  contradomínio  e  a  mesma  lei  de  associação.  Ou  seja,  dadas  𝑓: 𝐴 → 𝐵  e 

𝑔: 𝐶 → 𝐷, 𝑓 = 𝑔 ⇔ 𝐴 = 𝐶, 𝐵 = 𝐷 e 𝑓(𝑥) = 𝑔(𝑥) para todo 𝑥 ∈ 𝐴. 

Definição 4.10 Seja dada uma função 𝑓: 𝐴 → 𝐵. 𝑓 é chamada de injetiva se dados 𝑥 e 𝑥′ em 

𝐴,  com  𝑥 ≠ 𝑥′,  tivermos  𝑓(𝑥) ≠ 𝑓(𝑥′)  em  𝐵.  Ou  seja,  uma  função  é  injetiva  quando 

elementos distintos no domínio possuem imagens distintas no contradomínio.  

Exemplo  4.11  Toda  função  afim  𝑓: ℝ → ℝ;  𝑓(𝑥) = 𝑎𝑥 + 𝑏,  com  𝑎 ≠ 0,  é  injetiva.  Com 

efeito, dados 𝑥 e 𝑥′ em ℝ, com 𝑥 ≠ 𝑥′, temos:  

𝑎𝑥 ≠ 𝑎𝑥′ ⟹ 𝑎𝑥 + 𝑏 ≠ 𝑎𝑥′ + 𝑏 ⟹ 𝑓(𝑥) ≠ 𝑓(𝑥′). 

Definição  4.11  Seja  𝑓: 𝐴 → 𝐵  uma  função.  Dizemos  que  𝑓  é  sobrejetiva  se  para  todo 

elemento 𝑦 ∈ 𝐵 existe ao menos um 𝑥 ∈ 𝐴 tal que 𝑦 = 𝑓(𝑥). Ou seja, todo elemento de 𝐵 é 

imagem  de  algum  elemento  em  𝐴.  Dizemos  que  𝐵  é  a  imagem  de  𝑓  e  denotamos  por          

𝐵 = 𝑖𝑚(𝑓). 

Uma  função  também  será  dita  sobrejetiva  se  𝑓(𝐴) = 𝐵.  Para  obter  algumas  propriedades 

importantes com relação  a imagens de subconjuntos de 𝐴 por 𝑓 consulte Lima (2013, p. 17-

18). 

Exemplo  4.12  A  função 𝑓: ℝ → ℝ  dada  por 𝑓(𝑥) = 2𝑥 + 1  é  sobrejetiva.  Com  efeito,  dado 

um 𝑦 ∈  ℝ, existe 𝑥 ∈ ℝ, 𝑥 = 𝑦−1
2

, tal que, 𝑓(𝑥) = 𝑓 (𝑦−1
2

) = 2 ∙ 𝑦−1
2

+ 1 = (𝑦 − 1) + 1 = 𝑦. 

Definição  4.12  Uma  função  𝑓: 𝐴 → 𝐵  é  dita  bijetiva  se  for  injetiva  e  sobrejetiva 

simultaneamente.  

Exemplo  4.13  A  função 𝑓: ℝ → ℝ  dada  por 𝑓(𝑥) = 2𝑥 + 1  é  bijetiva.  É  também  bijetiva  a 

função 𝑓: ℝ+ → ℝ+ dada por 𝑓(𝑥) = 𝑥2. A sobrejetividade dela é provada em Lima (2013). 

Exemplo 4.14 A função 𝑓: ℝ → ℝ dada por 𝑓(𝑥) = |𝑥|, onde |𝑥| denota o valor absoluto de 

𝑥, não é injetiva, pois, por exemplo, 𝑓(−1) = |−1| = |1| = 𝑓(1). Portanto, 𝑓 não é bijetiva. 

 
Seja dada uma função 𝑓: 𝐴 → 𝐵 e um subconjunto 𝑋 ⊂ 𝐴. Chama-se imagem de 𝑋 por 

𝑓 o conjunto de todos os elementos 𝑓(𝑥), onde 𝑥 ∈ 𝑋. Isto é, 𝑓(𝑋) = {𝑓(𝑥) ∈ 𝐵; 𝑥 ∈ 𝑋}. 

108 

Figura 16 – Imagem de um Conjunto por meio de uma Função 𝑓  

Fonte: Autoria própria 

A imagem inversa de um subconjunto 𝑌 ⊂ 𝐵 será definida como sendo o conjunto de 

todos os 𝑥 ∈ 𝐴 tais que 𝑓(𝑥) ∈ 𝑌. Esse conjunto é indicado na  literatura por 𝑓−1(𝑌). Isto é, 

𝑓 −1(𝑌) = {𝑥 ∈ 𝐴; 𝑓(𝑥) ∈ 𝑌}. 

Figura 17 – Imagem inversa de um Conjunto por meio de uma Função 𝑓 

Fonte: Autoria própria 

 
 
 
 
 
 
 
109 

Para  obter  algumas  propriedades  importantes  com  relação  a  imagens  inversas  de 

subconjuntos  𝑌 ⊂ 𝐵 por 𝑓 consulte Lima (2013, p. 19-20). 

Outra  operação  importante  entre  funções  é  a  operação  de  composição.  Em             

Dante (2011), Capítulo 2, o leitor encontrará uma rica fonte de informações sobre funções em 

nível  de  ensino  básico,  onde  a  função  composta  é  definida  da  seguinte  forma:  “dadas  as 

funções  𝑓: 𝐴 → 𝐵  e  𝑔: 𝐵 → 𝐶,  denominamos  função  composta  de  𝑔  e  𝑓  a  função                  

𝑔 ∘ 𝑓: 𝐴 → 𝐶, que é definida por (𝑔 ∘ 𝑓)(𝑥) = 𝑔(𝑓(𝑥)), 𝑥 ∈ 𝐴” (DANTE, 2011, p. 50). 

Figura 18 – Composição de Funções 

Fonte: Autoria própria 

Exemplo  4.15  Dadas  as  funções  𝑓: ℝ → ℝ,  tal  que,  𝑓(𝑥) = 𝑥 2  e  𝑔: ℝ+ → ℝ,  tal  que   

𝑔 (𝑥) = √𝑥, teremos 𝑔 ∘ 𝑓: ℝ → ℝ dada por (𝑔 ∘ 𝑓)(𝑥) = 𝑔(𝑓(𝑥)) = √𝑥2 = |𝑥|. 

Finalizaremos  estas  considerações  sobre  funções  apresentando  o  importante  conceito 

de função inversa. Para isso, vamos entender o que é função inversa à direita e função inversa 

à esquerda para uma função 𝑓: 𝐴 → 𝐵. 

Definição  4.13  Uma  função  𝑔: 𝐵 → 𝐴  será  dita  uma  inversa  à  esquerda  para  𝑓  se               

(𝑔 ∘ 𝑓)(𝑥) = 𝑔(𝑓(𝑥)) = 𝑥  para  todo  𝑥 ∈ 𝐴.  De  modo  análogo,  𝑔: 𝐵 → 𝐴  será  dita  uma 

inversa à direita para 𝑓 se (𝑓 ∘ 𝑔)(𝑥) = 𝑓(𝑔(𝑥)) = 𝑦 para todo 𝑦 ∈ 𝐵. Por fim, se 𝑔: 𝐵 → 𝐴 

for  uma  inversa  à  direita  e  à  esquerda  para  𝑓: 𝐴 → 𝐵,  diremos  simplesmente  que  𝑔  é  uma 

𝑖𝑛𝑣𝑒𝑟𝑠𝑎 para 𝑓. 

 
 
 
 
110 

Exemplo  4.16  Dadas  as  funções  𝑓: ℝ+ →   ℝ+,  tal  que,  𝑓(𝑥) = 𝑥2  e  𝑔: ℝ+ →   ℝ+,  definida 

por  𝑔(𝑥) = √𝑥, 

teremos:  (𝑔 ∘ 𝑓)(𝑥) = 𝑔(𝑓(𝑥)) = √𝑥2 = |𝑥| = 𝑥.  E,  por  sua  vez,           

(𝑓 ∘ 𝑔)(𝑥) = 𝑓(𝑔(𝑥)) = (√𝑥)2 = 𝑥. Logo, 𝑔 é uma inversa para 𝑓. 

Teorema 4.1 Uma função 𝑓: 𝐴 → 𝐵 admite inversa à esquerda se, e somente se, for injetiva, e 

inversa à direita se, e somente se, for sobrejetiva. 

Teorema 4.2 Se a função 𝑓 tem por inversa à direita a  função 𝑔 e por inversa à esquerda  a 

função ℎ, então 𝑔 = ℎ é a função inversa de 𝑓, e 𝑓 será dita invertível. 

Os Teoremas 4.1 e 4.2 nos ensina que uma função 𝑓 admite inversa se, e somente se, é 

bijetiva, e essa inversa, caso exista, é única. Para indicar a função inversa de 𝑓: 𝐴 → 𝐵 usamos 

a notação 𝑓−1: 𝐵 → 𝐴. Para uma demonstração destes teoremas, consulte Lima (2013). 

4.1.3 Criptossistemas 

Ao desenvolvermos nosso breve estudo sobre criptografia nos capítulos anteriores, já 

nos  deparamos  com  Criptossistemas,  só  que  com  outra  denominação.  O  que  chamamos  de 

criptossistema em criptografia nada mais é do que um método geral de criptografia (descrito 

formalmente  e  bem  caracterizado),  ou  algoritmo  criptográfico  como  havíamos  chamado. 

Também chamados de “esquema de codificação criptográfica” (BUCHMANN, 2002, p. 85), 

os criptossistemas são definidos da seguinte forma. 

Definição 4.14 (Criptossistemas) Dá-se o nome de criptossistema a toda lista (𝒫, 𝒞, 𝒦, ℰ, 𝒟), 

onde 𝒫, 𝒞, 𝒦, ℰ e 𝒟 são conjuntos não vazios, com as seguintes características: 

a)  O conjunto 𝒫 tem por elementos todos os textos originais que desejamos codificar. Esses 

textos originais também são chamados de textos comuns. Segundo Buchmann (2002), o 

conjunto 𝒫 denomina-se espaço de texto comum (ou plaintext); 

b)  Quando codificamos um texto comum 𝑥 ∈ 𝒫 obtemos outro texto, cifrado, 𝑦. O conjunto 

de todos os 𝑦´𝑠 obtidos através dos 𝑥´𝑠 em 𝒫 é o conjunto 𝒞. “Ele é chamado de espaço 

de  texto  cifrado.  Seus  elementos  são  chamados  de  textos  cifrados  (Ciphertext)” 

(BUCHMANN, 2002, p. 85); 

c)  O conjunto 𝒦 é formado por todas as chaves possíveis do criptossistema; 

 
 
111 

d)  Para cada chave 𝛼 ∈ 𝒦 utilizada, isto é, para cada maneira específica de codificarmos 

um texto comum, podemos associar uma função 𝐸𝛼: 𝒫 →  𝒞 que associa a cada texto 
comum  𝑥 ∈ 𝒫  um  texto  cifrado  𝑦 ∈  𝒞, tal  que  𝐸𝛼(𝑥) = 𝑦.  A  igualdade  𝐸𝛼(𝑥) = 𝑦 

significa que quando codificarmos o texto 𝑥 utilizando a chave  𝛼, obteremos o texto 

cifrado 𝑦. O conjunto ℰ será o conjunto de todas essas funções 𝐸𝛼 (ℰ = {𝐸𝛼; 𝛼 ∈ 𝒦}). 

Os elementos de ℰ serão chamados de funções de codificação criptográficas; 

e)  Para cada chave 𝛼 ∈ 𝒦, existe uma chave 𝛽 ∈ 𝒦 associada e uma função 𝐷𝛽: 𝒞 → 𝒫 

que  faz  corresponder  a  cada  texto  cifrado  𝑦  o  texto  comum  𝑥  a  ele  correspondente. 

Temos  𝐷𝛽(𝑦) = 𝑥.  O  texto  𝑥  é  recuperado  através  de  𝑦  e  da  chave  𝛽.  𝒟  será  o 

conjunto  de  todas  essas  funções  𝐷𝛽  (𝒟 = {𝐷𝛽; 𝛽 ∈ 𝒦).  Os  elementos  de  𝒟  serão 

chamados de funções de decodificação criptográfica; 

f)  A  chave  𝛼  é  a  chave  de  codificação  criptográfica,  e  a  chave  𝛽  é  a  chave  de 

decodificação  criptográfica  associada  à  𝛼.  Para  cada  𝛼 ∈ 𝒦  deve  existir  uma  chave 

𝛽 ∈ 𝒦, tal que 𝐷𝛽(𝐸𝛼(𝑥)) = 𝑥. Ou seja, sempre que codificarmos um texto comum 𝑥 

utilizando  𝛼,  devemos  ser  capazes  de  recuperar  𝑥  decodificando  𝐸𝛼(𝑥)  por  meio  da 

chave  𝛽.  Isto  mostra  que  a  função  𝐷𝛽  é  uma  inversa  à  esquerda  para  a  função  𝐸𝛼. 

Como a igualdade 𝐸𝛼 (𝐷𝛽(𝑦)) = 𝑦 é óbvia, segue que 𝐷𝛽 é uma inversa à direita para 

a função 𝐸𝛼. Portanto, 𝐷𝛽 é a função inversa de 𝐸𝛼. 

Observação 4.1 Como nosso propósito neste trabalho não é desenvolver os aspectos teóricos 

da  criptografia,  a  definição  acima  serve  apenas  para  destacar  os  conceitos  matemáticos 

envolvidos.  O  leitor  deve  perceber  o  quanto  de  clareza,  rigor  e  objetividade  a  definição 

ganhou  com  o  uso  de  ideias  básicas  de  conjuntos  e  funções.  Sem  problema  algum  a 

linguagem utilizada para caracterizar os criptossistemas é compreendida por qualquer pessoa 

que  tenha  o  domínio  básico  de  linguagem  de  conjuntos  e  funções.  Essa  simplicidade  da 

criptografia  proporcionada  pela  matemática  básica  pode  ser  apreciada  por  meio  de  outros 

temas,  tais  como  matrizes  e  probabilidades.  Teremos  a  oportunidade  de  apreciar  isso,  mais 

adiante, neste capítulo. 

 
 
 
 
112 

Exemplo  4.17  Como  exemplo,  vamos  explorar  mais  uma  vez  a  cifra  de  César             

(Capítulo  2,  Secção  2.1.3).  Ela  é  um  criptossistema.  Para  provarmos  isso,  devemos  nos 

certificar  que  essa  cifra  possui  todas  as  características  apresentadas  na  Definição  4.14.  De 

fato: 

a)  A cifra de César codifica letra por letra. Logo, o conjunto 𝒫 (espaço de texto comum) é o 

conjunto {A, B, C, ..., Z} de todas as letras do nosso alfabeto usual; 

b)  A cifra de César é de substituição, que associa a cada letra de 𝒫 outra letra também de 𝒫. 

Portanto, o conjunto 𝒞(espaço de texto cifrado) também é o conjunto {A, B, C, ..., Z}. 

c)  Sabemos  que  há  26  possíveis  chaves  para  a  cifra  de  César.  Uma  vez  que  cada  chave 

corresponde ao número de letras transladadas da  esquerda para a direita (e esse  número 

varia  de  1  á  26),  podemos  dizer  que  as  chaves  possíveis  para  a  cifra  de  César  são  os 

números 1, 2, 3, 4, ..., 25, 26. Por exemplo, se usarmos a chave  𝛼 = 7, então o alfabeto 

será transladado 7 casas à direita. Assim sendo,  𝒦 = {1,2,3,4,5, … ,26}. 

d)  Para  verificarmos  a  característica  (d)  da  Definição  4.14  iremos  associar  a  cada  letra  do 

alfabeto usual os números de 1 à 26 segundo a Tabela 8. 

Tabela 8 - Tabela de Pré-codificação 

A 

1 

N 

B 

2 

O 

C 

3 

P 

D 

4 

Q 

E 

5 

R 

F 

6 

S 

G 

H 

7 

T 

8 

U 

I 

9 

J 

K 

L 

M 

10 

11 

12 

13 

V  W 

X 

Y 

Z 

14 

15 

16 

17 

18 

19 

20 

21 

22 

23 

24 

25 

26 

Fonte: Autoria própria 

Com  a  ajuda  da  Tabela  8  e  do  que  aprendemos  sobre  congruências  no  Capítulo  3, 

podemos descrever as funções de codificação e decodificação criptográfica para a cifra de 

César. 

Iniciemos 

com 

a 

função 

de 

codificação.  Dada 

uma 

chave 

𝛼 ∈ 𝒦 = {1,2,3,4,5, … ,26},  a  função  de  codificação  criptográfica  vai  associar  a  cada 

letra de 𝒫 uma outra letra de 𝒫, obtida transladando o alfabeto 𝛼 casas à frente. Logo, se 

 
 
 
 
 
113 

𝑥 ∈ 𝒫 é um texto comum (uma letra, que neste caso passará a ser um número de 1 à 26 

pela Tabela 8), o texto cifrado 𝑦 ∈  𝒞 (mesma observação do caso de 𝑥) será dado por: 

𝑦 ≡ 𝑥 + 𝛼 (𝑚𝑜𝑑. 26) 

Ou seja, a função 𝐸𝛼: 𝒫 →  𝒞 é tal que 𝐸𝛼(𝑥) = 𝑦 ≡ 𝑥 + 𝛼 (𝑚𝑜𝑑. 26). Portanto, 

ℰ = {𝐸𝛼; 𝛼 ∈ 𝒦 e 𝐸𝛼(𝑥) ≡ 𝑥 + 𝛼 (𝑚𝑜𝑑. 26)}. 

Observação  4.2  Lembre-se  que  𝑥,  𝑦 𝑒 𝛼  são  inteiros  positivos  pertencentes  ao  conjunto      

{1, 2, 3, ..., 26}. Assim, a congruência 𝑦 ≡ 𝑥 + 𝛼 (𝑚𝑜𝑑. 26) nos diz que 𝑦 será igual ao resto 

da divisão de 𝑥 + 𝛼 por 26, que é uma maneira mais formal de apresentarmos as translações 

da cifra de César. Para entendermos melhor o porquê da função de codificação ser escolhida 

desta forma, suponhamos que a chave 𝛼 = 12. Isto quer dizer que o alfabeto será transladado 

12 casas à frente. Qual letra representará a codificação da letra W? Pela Tabela 8, temos que 

W  =  23.  Logo,  23  +  12  =  35.  Assim,  a  letra  W  será  substituída  pela  letra  de  número  35. 

Entretanto,  as  letras  estão  representadas  até  o  número  26.  Mas  como  35  =  26  +  9,  isto 

significa  que  contamos  até  a  letra  de  número  26  (letra  Z),  depois  voltamos  ao  inicio  do 

alfabeto e contamos mais nove casas (letras). Ou seja, a letra correspondente ao W será a letra 

de número 9, letra I. Note que 9 ≡ 23 + 12 (𝑚𝑜𝑑. 26) por isso, consideramos a congruência 

módulo 26 (contamos de 26 em 26).  

e)  Como para decodificar a cifra de César  basta apenas reverter  a translação, segue que se 

𝛽 ∈  𝒦, então a função de decodificação associada à 𝛽 será dada por: 

𝑥 ≡ 𝑦 − 𝛽 (𝑚𝑜𝑑. 26) 

Ou  seja,  a  função 𝐷𝛽:  𝒞 → 𝒫  é tal  que 𝐷𝛽(𝑦) = 𝑥 ≡ 𝑦 − 𝛽 (𝑚𝑜𝑑. 26).  Portanto, temos 

que 𝒟 = {𝐷𝛽;  𝛽 ∈ 𝒦 e 𝐷𝛽(𝑦) ≡ 𝑦 − 𝛽 (𝑚𝑜𝑑. 26)}. Como na cifra de César as chaves de 

codificação  e  decodificação  são  iguais,  segue  que    𝛼 =  𝛽  e  a  função  de  decodificação 

passar  a  ser  apenas  𝐷𝛽(𝑦) = 𝑥 ≡ 𝑦 −  𝛼(𝑚𝑜𝑑. 26).  Assim,  por  exemplo,  no  caso  da 

Observação  4.2,  com  𝛼 = 12,  vemos  que  𝛽 = 12  é  a  chave  de  decodificação  e     

𝐷12(9) ≡ 9 − 12 = −3 ≡ 23(𝑚𝑜𝑑. 26). Logo, decodificando a letra de número 9 (letra 

I), obtemos a letra de número 23 (letra W), isto é, recuperamos a letra W que tinha sido 

codificada. 

f)  Por fim, é óbvio que para toda chave  𝛼 ∈ 𝒦, existe uma chave 𝛽 ∈  𝒦, com 𝛼 =  𝛽, tal 

que 𝐷𝛽(𝐸𝛼(𝑥)) = 𝑥, qualquer que seja o texto comum 𝑥 ∈ 𝒫.  

 
 
114 

O exposto nos itens anteriores prova que a cifra de César é um criptossistema. Outro 

exemplo  muito  importante  de  criptossistema  é  o  RSA.  Para  mais  detalhes,  veja  Buchmann 

(2002). A seguir, trataremos das noções de alfabetos e palavras em criptografia. 

4.1.4 Alfabetos e Palavras 

Já  temos  uma  boa  noção  do  que  sejam  alfabetos  e  palavras  em  criptografia.  Porém, 

rigorosamente  falando,  esses  conceitos  assumem  um  significado  mais  geral  que  difere  do 

usual  utilizado  por  nós  no  dia  a  dia.  Como  já  sabemos,  para  que  possamos  escrever  uma 

mensagem  ou  um  texto  comum  precisamos  utilizar  um  alfabeto.  No  nosso  caso,  o  alfabeto 

usual  utilizado  é  {A,  B,  C,  ...,  Z}.  No  entanto,  esse  não  é  o  único  alfabeto  possível,  e  as 

palavras  e  os  textos  assumirão  características  que  dependem,  logicamente,    do  alfabeto 

utilizado. Por exemplo,  já  vimos dois exemplos clássicos de alfabetos: o alfabeto Morse e o 

alfabeto Braille. A definição a seguir baseia-se na dada por Buchmann (2002). 

Definição  4.15  Chama-se  Alfabeto  todo  conjunto  𝒜  finito  e  não  vazio.  Se  𝒜  tem  𝑛 

elementos, dizemos que o Comprimento de 𝒜 é igual a 𝑛. Os elementos de 𝒜 são chamados 

de Letras ou Símbolos. 

Exemplo 4.18 

a)  𝒜 = {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍} = Alfabeto usual. Comprimento de 𝒜 é igual a 26; 

b)  𝒜 = {0, 1} = Alfabeto binário. Comprimento de 𝒜 é igual a 2; 

c)  𝒜 = {𝑠í𝑚𝑏𝑜𝑙𝑜𝑠 𝐴𝑆𝐶𝐼𝐼} (ver Tabela 17). Comprimento de 𝒜 é igual a 128.  

Observação  4.3  Se  considerarmos,  como  fizemos  antes,  a  associação  apresentada  na      

Tabela  8,  podemos  interpretar  o  alfabeto  {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍}  como  sendo  o  conjunto               

{1, 2, 3, ..., 26}. Isto é muito usado em criptografia, pois permite  “calcular com  letras”. Em 

geral,  podemos  fazer  essa  associação  com  qualquer  alfabeto  𝒜.  Ou  seja,  se  𝒜  tem 

comprimento 𝑚, então podemos associar aos símbolos de 𝒜 os números 1, 2, 3,..., 𝑚, ou de 

maneira análoga aos números 0, 1, 2, ..., 𝑚 − 1, o que dá no mesmo (BUCHMANN, 2002). 

As definições a seguir, baseadas em Buchmann (2002), nos fornecem a noção formal 

de Palavra em criptografia e alguns conceitos relacionados. 

 
 
115 

Definição  4.16  Seja  𝒜  um  alfabeto  qualquer.  Chamamos  de  palavra  (em  𝒜)  qualquer 

sequência finita formada por símbolos de  𝒜. O espaço entre palavras também está incluso e 

passará a ser chamado de sequência vazia. 

Exemplo 4.19 Se 𝒜 = {0, 1}, então 𝑚 = 1001101011 é uma palavra em 𝒜. 

Definição  4.17  Cada  símbolo  que  compõe  uma  palavra  num  alfabeto  𝒜  será  chamado  de 

componente  da  palavra.  Se  uma  palavra  tem  𝑛  componentes,  diremos  que  o  comprimento 

dessa palavra é 𝑛. 

Exemplo  4.20  Seja  𝒜 = {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍}.  A  palavra  UFERSA  tem  comprimento  6  em  𝒜. 

Analogamente, a palavra  𝑚 = 1001101011 do alfabeto 𝒜 = {0, 1}, dada no Exemplo 4.19, 

tem comprimento igual a 10. 

Definição 4.18 Seja 𝒜 um alfabeto qualquer. O conjunto de todas as palavras que podem ser 

formadas  com  os  símbolos  de  𝒜,  incluindo  a  sequência  vazia,  será  denotado  por  𝒜∗.  Da 

mesma  forma,  o  conjunto  de todas  as  palavras  de  comprimento  fixo  𝑛  em  𝒜  será  denotado 

por 𝒜(𝑛). 

Exemplo 4.21 Seja 𝒜 = {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍}. Apenas com os símbolos de 𝒜, quantas palavras 

podemos  formar?  Quantas  dessas  palavras  tem  comprimento  4?  Ora,  podemos  ter  palavras 

com 1  símbolo, 2 símbolos, 3 símbolos, e assim  por diante, até as  palavras de 26  símbolos.  

Existem 26 palavras com 1 símbolo, 26 x 26 palavras com 2 símbolos, 26 x 26 x 26 palavras 

com 3 símbolos, ..., 26 x 26 x ... x 26 (26 fatores) palavras com 26 símbolos em  𝒜. Logo, a 

quantidade de palavras que podemos formar com os símbolos de 𝒜 é: 

26 + 262 + 263 + ⋯ + 2626. 

Se incluirmos a sequência vazia, temos uma quantidade de  

1 + 26 + 262 + 263 + ⋯ + 2626 =

2627 − 1
26 − 1

=

2627 − 1
25

palavras  formadas  com  os  símbolos  de  𝒜  = {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍}.  Assim,  𝒜∗  tem  2627−1

25

elementos.  A  quantidade  de  palavras  com  comprimento  4  é  264.  Logo,  𝒜(4)  tem  264 

elementos.  

 
 
 
 
116 

4.1.5 Permutações 

A  análise  combinatória,  tão  explorada  no  Ensino  Médio,  ganha  importância  em 

criptografia por meio da noção de Permutação. Esta noção é a base para o desenvolvimento 

das  Cifras  em  Blocos,  que  definiremos  mais  adiante.  Ao  leitor  interessado  em  relacionar 

análise combinatória com criptografia, sugerimos uma consulta a Malagutti (2015). 

O problema das permutações é um dos problemas centrais de que se ocupa a análise 

combinatória.  Ele  é  basicamente  o  seguinte:  De  quantas  formas  podemos  dispor  em  fila  𝑛 

objetos  distintos?  Ou  seja,  considerando  𝑋 = {𝑥1, 𝑥2, … , 𝑥𝑛}  um  conjunto  com  𝑛  elementos 

distintos,  de  quantos  modos  podemos  dispor  em  fila  todos os  elementos  de  𝑋?  A  cada  uma 

dessas disposições damos o nome de permutação dos elementos 𝑥1, 𝑥2, … , 𝑥𝑛. 

Exemplo  4.22  Seja  𝑋 = {𝑎, 𝑏, 𝑐}.  As  permutações  dos  elementos  de  𝑋 

são: 

(𝑎, 𝑏, 𝑐), (𝑎, 𝑐, 𝑏), (𝑏, 𝑎, 𝑐), (𝑏, 𝑐, 𝑎), (𝑐, 𝑎, 𝑏), (𝑐, 𝑏, 𝑎). 

Podemos formalizar a ideia de permutação da seguinte forma: 

Definição 4.19 Seja 𝑋 um conjunto não vazio. Chamamos de permutação dos elementos de 𝑋 

a qualquer função bijetiva 𝑓: 𝑋 → 𝑋. 

Exemplo  4.23  Seja  𝑋 = {𝑎, 𝑏, 𝑐}.  Uma  permutação  dos  elementos  de  𝑋  pode  ser  obtida 

considerando  a  função  bijetiva  𝑓: 𝑋 → 𝑋  definida  por  𝑓(𝑎) = 𝑏, 𝑓(𝑏) = 𝑐  e  𝑓(𝑐) = 𝑎.  No 

Exemplo  4.22  esta  permutação  se  refere  a  (𝑏, 𝑐, 𝑎).  Assim,  há  6  bijeções  𝑓: 𝑋 → 𝑋.  A     

Figura  19  a  seguir  ilustra  a  associação  entre  os  elementos  de  𝑋  de  modo  a  ter  uma 

bijeção 𝑓: 𝑋 → 𝑋. 

Figura 19 – Um exemplo de Permutação 

Fonte: Autoria própria 

 
                                                    
 
117 

É também comum indicarmos essa permutação assim: (

𝑎     𝑏     𝑐
𝑏     𝑐     𝑎

). 

As  permutações  que  aparecem  com  mais  frequência  em  criptografia  são  as  dos 

elementos  do  conjunto  𝐼𝑛 =   {1, 2, 3, 4, … , 𝑛}.  Denotaremos  por  𝑆𝑛  o  conjunto  de  todas  as 

permutações possíveis dos elementos de 𝐼𝑛. Sabemos da análise combinatória que o número 

de permutações de 𝑛 elementos distintos é igual a 𝑛! = 1 ⋅  2  ⋅  3  ⋅ … ⋅  𝑛. Portanto, o número 

de permutações dos elementos de 𝐼𝑛 é igual a 𝑛!. Ou seja, 𝑆𝑛 tem 𝑛! elementos. 

Exemplo  4.24  𝑆3  é  o  conjunto  de  todas  as  permutações  de  𝐼3 = {1, 2, 3}  e  possui  3! = 6 
elementos, que são: (1, 2, 3), (1, 3, 2), (3, 1, 2), (2, 1, 3), (2, 3, 1), (3, 2, 1). 

A  seguir,  iremos  estudar  as  cifras  em  blocos  e  analisar  como  o  conceito  básico  de 

permutação está inserido na definição dessas cifras. 

4.1.6 Cifras em Blocos 

As cifras em blocos, como o nome sugere, são aquelas que codificam em blocos, isto 

é,  codificam  palavras  de  comprimento  fixo  𝑛  (𝑛 ∈ ℕ).  No  Capítulo  1,  estudamos  cifras  em 

que  a  codificação  era  realizada  letra  por  letra  (cifras  de  substituição)  individualmente.  Nas 

cifras de blocos podemos codificar qualquer sequência finita de letras de mesmo comprimento 

e do mesmo alfabeto considerado. Passemos à definição formal:  

Definição 4.20 Um  método criptográfico (criptossistema) é chamado de  cifra de blocos (ou 

cifras em blocos) se seu espaço de texto comum e o seu espaço de texto cifrado correspondem 

ao conjunto 𝒜(𝑛) das palavras formadas por 𝑛 símbolos do alfabeto 𝒜 (BUCHMANN, 2002). 

Se  uma  cifra  em  blocos  codifica  palavras  de  comprimento  𝑛,  dizemos  que  essa  cifra  tem 

comprimento de bloco igual a 𝑛.  

Exemplo 4.25 A cifra de César é uma cifra em blocos. Seu comprimento de bloco é igual a 1 

porque ela codifica palavras de comprimento 1 em palavras de comprimento também igual a 

1. Outro exemplo, mais geral, de cifras em blocos são as cifras de substituição.  

O  teorema  a  seguir,  cuja  demonstração  pode  ser  encontrada  em  Buchmann           

(2002, p. 94) explicita a importância das permutações para as cifras em blocos.  

 
 
 
118 

Teorema 4.3 Nas cifras em blocos, as funções de codificação criptográfica são permutações. 

Um  dos  casos  mais  simples  de  cifras  em  blocos  consiste  naquele  onde  a  função  de 

codificação  criptográfica  associa  a  cada  palavra  (𝑙1, 𝑙2, … , 𝑙𝑛)34 ∈ 𝒜(𝑛)  a  palavra 
(𝑙𝜋(1),𝑙𝜋(2), … , 𝑙𝜋(𝑛)) ∈ 𝒜(𝑛),  onde  (𝜋(1), 𝜋(2), … , 𝜋(𝑛))  é  uma  permutação  dos  elementos 

do  conjunto  𝐼𝑛 =   {1, 2, 3, 4, … , 𝑛},  isto  é,    (𝜋(1), 𝜋(2), … , 𝜋(𝑛)) ∈ 𝑆𝑛.  Ou  seja,  o  que  esta 

cifra  faz  é  apenas  permutar  os  componentes  da  palavra  (𝑙1, 𝑙2, … , 𝑙𝑛).  Daí,  temos  que  essas 

cifras também são chamadas de cifras de permutação.  

Exemplo 4.26 Vamos considerar o alfabeto 𝒜 = {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍}. Uma cifra em blocos, de 

comprimento  𝑛,  pode  ser  definida  da  seguinte  forma:  A  cada  palavra  (𝑙1, 𝑙2, … , 𝑙𝑛) ∈ 𝒜(𝑛) 
associamos  a  palavra  (𝑙𝜋(1),𝑙𝜋(2), … , 𝑙𝜋(𝑛)) ∈ 𝒜(𝑛),  onde  (𝜋(1), 𝜋(2), … , 𝜋(𝑛))  é  uma 

permutação dos elementos 1, 2, ..., 𝑛. Neste caso, o espaço das chaves é o conjunto de todas 

as  permutações  de  𝐼𝑛,  isto  é,  o  conjunto  𝑆𝑛.  Ou  seja,  as  chaves  para  essa  cifra  são  as 
permutações  𝜋: {1, 2, … , 𝑛} → {1, 2, … , 𝑛}.  Portanto,  dada  uma  chave  𝜋 ∈ 𝑆𝑛,  temos  que  a 
função de codificação criptográfica será 

𝐸𝜋: 𝒜(𝑛) → 𝒜(𝑛); (𝑙1, 𝑙2, … , 𝑙𝑛) ↦   (𝑙𝜋(1) , 𝑙𝜋(2), … , 𝑙𝜋(𝑛)). 

Por outro lado, a função de decodificação criptográfica será: 

𝐷𝜋: 𝒜(𝑛) → 𝒜(𝑛); (𝑥1, 𝑥2, … , 𝑥𝑛) ↦ (𝑥𝜋−1(1), 𝑥𝜋−1(2), . . . , 𝑥𝜋−1(𝑛)), 

onde 𝜋−1: {1, 2, … , 𝑛} → {1, 2, … , 𝑛} é a função inversa da função 𝜋. 

Exemplo  4.27.  No  Exemplo  4.26,  façamos  𝑛 = 4.  Ou  seja,  vamos  definir  uma  cifra  em 

blocos  de  comprimento  4  sobre  𝒜  = {𝐴, 𝐵, 𝐶, 𝐷, … , 𝑍}.  Então, tomemos  uma  chave  𝜋 ∈ 𝑆4. 

Seja  𝜋 = (

1     2     3    4
2     1     4    3

)  (𝜋 é 𝑎 𝑝𝑒𝑟𝑚𝑢𝑡𝑎çã𝑜 (2, 1, 4, 3)).  Vamos  codificar  a  palavra 

(𝐴, 𝑀, 𝑂, 𝑅)  por  meio  da  cifra  descrita  no  Exemplo  4.26.  Ora,  neste  caso,  𝑙1 = 𝐴,  𝑙2 = 𝑀, 

𝑙3 = 𝑂  e 

𝑙4 = 𝑅.  Por  sua  vez, 

𝑙𝜋(1) = 𝑙2 = 𝑀, 

𝑙𝜋(2) = 𝑙1 = 𝐴, 

𝑙𝜋(3) = 𝑙4 = 𝑅  e              

𝑙𝜋(4) = 𝑙3 = 𝑂.  Ou  seja,  a  função  de  codificação  criptográfica  𝐸𝜋  vai  associar  à  palavra 

(𝐴, 𝑀, 𝑂, 𝑅)  a  palavra  (𝑀, 𝐴, 𝑅, 𝑂).  Portanto,  𝐸𝜋(𝐴, 𝑀, 𝑂, 𝑅) = (𝑀, 𝐴, 𝑅, 𝑂)  e  a  palavra 

AMOR será transformada em MARO. Por outro lado, para decodificar a palavra (𝑀, 𝐴, 𝑅, 𝑂) 

basta fazer: 𝑥1 = 𝑀, 𝑥2 = 𝐴, 𝑥3 = 𝑅 e 𝑥4 = 𝑂. Logo, 𝑥𝜋−1(1) = 𝑥2 = 𝐴, 𝑥𝜋−1(2) = 𝑥1 = 𝑀, 

34 Notação que usaremos para indicar uma palavra de comprimento fixo num alfabeto 𝒜. 

 
                                                             
119 

𝑥𝜋−1(3) = 𝑥4 = 𝑂 e 𝑥𝜋−1(4) = 𝑥3 = 𝑅. Assim, a função de decodificação criptográfica 𝐷𝜋 vai 

associar à palavra (𝑀, 𝐴, 𝑅, 𝑂) a palavra (𝐴, 𝑀, 𝑂, 𝑅). Portanto, 𝐷𝜋(𝑀, 𝐴, 𝑅, 𝑂) = (𝐴, 𝑀, 𝑂, 𝑅) 
e a decodificação está encerrada.  

Na  seção  a  seguir  estaremos  interessados  em  ampliar  nossa  investigação  acerca  das 

aplicações  de  funções  ao  campo  da  criptografia.  Para  isto,  revisaremos  um  tipo  muito 

importante de função, conhecido como Função Afim, e buscaremos desenvolver uma relação 

simples entre essas funções e um método bem elementar de criptografia. Na Seção 4.3, onde 

revisaremos outro tipo especial de função, as Funções Quadráticas, esta aplicação também se 

dará. 

4.2 Funções Afins e Criptografia 

Uma Função Afim é toda função 𝑓: ℝ → ℝ, tal que, existem números reais 𝑎 e 𝑏 com 

𝑓(𝑥) = 𝑎𝑥 + 𝑏. Quando 𝑎 = 0, temos a função constante 𝑓(𝑥) = 𝑏 que é um caso particular 

de Função Afim. Outros exemplos de Funções Afins são: 𝑓(𝑥) = 𝑎𝑥, (no caso em que temos 

𝑏 = 0 e  𝑎 ≠ 0)  𝑓(𝑥) = 2𝑥 + 1,  𝑓(𝑥) = 𝑥 + 𝑏 (𝐹𝑢𝑛çã𝑜 𝑇𝑟𝑎𝑛𝑠𝑙𝑎çã𝑜),  etc.  Outros  conceitos 

relacionados  à  teoria  das  Funções  Afins,  como  gráfico,  taxa  de  variação  e  teorema  de 

caracterização,  por  exemplo,  não  serão tratados  aqui.  Para o  que  segue, o  exposto  na  Seção 

4.1  sobre  funções  é  suficiente.  Para  o  leitor  interessado  em  revisar  as  noções  básicas  sobre 

Função  Afim,  e  outras  funções  elementares  vistas  no  ensino  básico,  indicamos  as  obras: 

Giovanni Júnior  et al. (2018), Bianchini (2018), Balestri (2016), Iezzi  et al. (2002), Lima et 

al. (2006a) e Dante (2006). Logicamente, no caso do professor, a primeira referência é o livro 

didático.  Para  melhor  desenvolver  essa  relação  entre  criptografia  e  matemática,  o  professor 

deve preparar sua abordagem de  acordo com a sequência do  livro utilizado pela turma e  no 

tempo  certo  para  não  ocorrer  de  precisar  de  ferramentas  que  só  serão  vistas  muito 

posteriormente. 

Portanto,  nesta  seção,  nosso  objetivo  é  apresentar  um  exemplo  bem  didático  (e 

intuitivo) de uma cifra utilizando as Funções Afins. O valor didático desse exemplo reside no 

fato de que podemos trabalhar várias noções básicas sobre essas funções, tais como: definição 

(exibir exemplos de Funções Afins), imagem de um elemento do domínio, cálculo da Função 

Inversa,  imagem  inversa de um  elemento, etc. O professor pode ampliar as aplicações desse 

exemplo, buscando relacionar outros conceitos. Por exemplo, em França (2014), Capítulo 3, 

 
 
120 

pode-se encontrar atividades que exploram vários conceitos relacionados às Funções Afins (e 

outras  funções)  por  meio  de  um  exemplo  de  método  de  criptografia  baseado  na  função  em 

questão. Por esse motivo, sugerimos ao leitor a consulta a esse trabalho. Esta seção e a Seção 

4.3 são fortemente inspiradas no Capítulo 3 de França (2014). 

4.2.1 Um método criptográfico intuitivo baseado em Funções Afins 

Inicialmente,  iremos  utilizar  mais  uma  vez  a  Tabela  8  de  pré-codificação.  O  método 

criptográfico  que  apresentamos  possui  como  espaço  de 

texto  comum  o  alfabeto                    

{1, 2, 3, 4, ..., 26}. Ele é uma cifra de  blocos com comprimento 1, isto é, codifica  letra por 

letra.  Seu  espaço  de  texto  cifrado  é  um  subconjunto  (finito)  de  ℕ.  Ou  seja,  cada  letra  será 

codificada em um número. Assim, a mensagem codificada passa a ser representada por uma 

sequência de números separados por um traço (parecido com a separação de blocos no RSA). 

A seguir, apresentamos um guia de desenvolvimento e aplicação do método. 

Roteiro 1 – Processo de codificação do método 

Etapa  1:  Nesta  etapa  iremos  escolher,  como  exemplo,  uma  mensagem  curta  para  ser 

codificada  por  um  método  criptográfico  simples  baseado  em  funções  afins.  Assim, 

suponhamos  que  queremos  codificar  a  mensagem  CRIPTOGRAFIA  NO  PROFMAT.  A 

vantagem  desse  método  é  que  sua  simplicidade  torna  possível  utilizar  exemplos  de 

codificação  com  mensagens  longas  sem  se  preocupar  com  cálculos  extensos.  Logo,  é  uma 

ótima alternativa para trabalhar em sala de aula com variados tipos de exemplos. 

Etapa 2: Aqui inicia-se o processo de pré-codificação. Usando a Tabela 8, substituímos cada 

letra da mensagem CRIPTOGRAFIA NO PROFMAT pelo número que lhe é correspondente, 

separando-os por um traço (-). Logo, a mensagem passará a ser: 

3-18-9-16-20-15-7-18-1-6-9-1-14-15-16-18-15-6-13-1-20. 

Etapa  3:  Aqui  iremos  utilizar  o  conhecimento  sobre  funções  afins  para  desenvolver  um 

processo  de  codificação  criptográfica,  isto  é,  uma  função  de  codificação  criptográfica.  A 

função  de  codificação  que  iremos  utilizar  será  uma  Função  Afim.  Para  obtê-la,  começamos 

escolhendo  um  par  ordenado  (𝑎, 𝑏)  (com  𝑎  e  𝑏  inteiros  para  evitar  números  fracionários, 

raízes,  etc).  Depois,  consideraremos  a  função  de  codificação  criptográfica  como  sendo  

𝑓(𝑥) = 𝑎𝑥 + 𝑏,  onde  a  variável  𝑥,  de  acordo  com  a  Tabela  8,  será  um  número  natural 

 
 
121 

pertencente  ao  conjunto  {1, 2, 3, … , 26}.  Sendo  assim,  tomemos,  por  exemplo,  o  par  (2,  1) 

como chave de codificação, isto é, nossa função de codificação será 𝑓(𝑥) = 2𝑥 + 1. 

Etapa 4 Da Etapa 2 temos que a mensagem CRIPTOGRAFIA NO PROFMAT passa a ser 

representada pela sequência de números (blocos)  

3-18-9-16-20-15-7-18-1-6-9-1-14-15-16-18-15-6-13-1-20. 

Da  Etapa  3  temos  que  cada  um  desses  blocos  será  codificado  por  meio  da  função            

𝑓(𝑥) = 2𝑥 + 1,  onde  iremos  calcular  a  imagem  de  cada  número  que  compõe  a  mensagem. 

Cada  uma  dessas  imagens  será  a  codificação  do  número  (bloco)  correspondente.  Devemos 

respeitar a sequência dos números, e os resultados devem ser separados por traço na mesma 

ordem. Esta nova sequência é a codificação da mensagem original.  

Agora utilizaremos  nosso conhecimento sobre cálculo do valor de uma  Função Afim 

num ponto 𝑥 para codificar cada bloco da mensagem original. Calculando a imagem de cada 

bloco da mensagem 3-18-9-16-20-15-7-18-1-6-9-1-14-15-16-18-15-6-13-1-20, obtemos: 

Tabela 9 – Codificando a Mensagem 

Bloco (𝒙) 

Função de codificação (𝒇(𝒙) = 𝟐𝒙 + 𝟏) 

Bloco codificado (𝒚 = 𝒇(𝒙)) 

3 

18 

9 

16 

20 

15 

7 

14 

6 

𝑓(3) = 2 ⋅ 3 + 1 = 7 

𝑓(18) = 2 ⋅ 18 + 1 = 37 

𝑓(9) = 2 ⋅ 9 + 1 = 19 

𝑓(16) = 2 ⋅ 16 + 1 = 33 

𝑓(20) = 2 ⋅ 20 + 1 = 41 

𝑓(15) = 2 ⋅ 15 + 1 = 31 

𝑓(7) = 2 ⋅ 7 + 1 = 15 

𝑓(14) = 2 ⋅ 14 + 1 = 29 

𝑓(6) = 2 ⋅ 6 + 1 = 13 

7 

37 

19 

33 

41 

31 

15 

29 

13 

 
 
122 

13 

1 

𝑓(13) = 2 ⋅ 13 + 1 = 27 

𝑓(1) = 2 ⋅ 1 + 1 = 3 

27 

3 

                                                             Fonte: Autoria própria 

Daí, a mensagem codificada passará a ser: 

7-37-19-33-41-31-15-37-3-13-19-3-29-31-33-37-31-13-27-3-41. 

Substituímos cada número pela sua imagem por meio da função 𝑓(𝑥) = 2𝑥 + 1. 

Portanto, a mensagem CRIPTOGRAFIA NO PROFMAT será substituída por: 

7-37-19-33-41-31-15-37-3-13-19-3-29-31-33-37-31-13-27-3-41. 

Veja  que,  nestas  condições,  a  chave  utilizada  para  codificar  a  mensagem  foi  o  par 

ordenado  (2,  1).  Mas,  por  que  fixamos  esse  par  como  ordenado?  Porque  no  caso  em  que 

𝑎 ≠ 𝑏, temos que (𝑎, 𝑏) ≠ (𝑏, 𝑎). Logo, temos duas chaves distintas! 

Roteiro 2 – Processo de decodificação do método 

Codificada  a  mensagem,  nosso  proceder  agora  será  desenvolver  a  função  de 

decodificação  criptográfica  para  o  nosso  método.  Ora,  se  o  bloco  𝑥  foi  substituído  por  sua 

imagem  𝑓(𝑥),  o  que  devemos  fazer  para  recuperar  𝑥?  Como  sabemos  do  estudo  sobre 

funções,  𝑥  é  recuperado  quando  calculamos  a  imagem  inversa  dele.  Ou  seja,  se  𝑦 = 𝑓(𝑥), 

então 𝑥 = 𝑓−1(𝑦) (é a imagem de 𝑦 pela função inversa de 𝑓). Portanto, para decodificarmos 

a  mensagem,  precisamos  saber  a  função  inversa  da  função  de  codificação  (claro,  se  ela 

existir). No caso da  função afim, a  sua  inversa sempre  vai  existir, pois as  funções afins  são 

bijetivas. 

Etapa  1:  Bom,  temos  que  a  função  de  codificação  criptográfica  é  𝑓(𝑥) = 2𝑥 + 1.  Então, 

devemos determinar a função inversa da função 𝑓(𝑥) = 2𝑥 + 1. Isolando 𝑥 nessa igualdade, 

temos  𝑥 = 𝑓(𝑥)−1

2
𝑓 −1(𝑥)   = 𝑥−1
2

.  

= 𝑦−1
2

.  Segue  então  que  𝑓−1(𝑦)   = 𝑦−1
2

.  Portanto,  a  função  inversa  de  𝑓  é 

 
 
123 

Etapa 2: Como já temos a função de decodificação criptográfica, basta calcular a imagem de 

cada número na mensagem codificada para obter a mensagem original. Ou seja, calcularemos 

a imagem de cada número na sequência  

7-37-19-33-41-31-15-37-3-13-19-3-29-31-33-37-31-13-27-3-41 

por meio da função 𝑓−1(𝑥)   = 𝑥−1
2

. Isso é mostrado na tabela a seguir. 

Tabela 10 – Decodificando a Mensagem 

Bloco (𝒚)  Função de decodificação (𝑓−1(𝑦)   = 𝑦−1
2

) 

Bloco codificado (𝒙 = 𝑓−1(𝑦)) 

7 

37 

19 

33 

41 

31 

15 

29 

13 

27 

𝑓−1(7) =

7 − 1
2

=

6
2

= 3 

𝑓−1(37) =

37 − 1
2

=

36
2

= 18 

𝑓−1(19) =

19 − 1
2

=

18
2

= 9 

𝑓−1(33) =

𝑓−1(41) =

𝑓−1(31) =

33 − 1
2

=

41 − 1
2

=

31 − 1
2

=

32
2

40
2

30
2

= 16 

= 20 

= 15 

𝑓−1(15) =

15 − 1
2

=

14
2

= 7 

𝑓−1(29) =

29 − 1
2

=

28
2

= 14 

𝑓−1(13) =

13 − 1
2

=

12
2

= 6 

𝑓−1(27) =

27 − 1
2

=

26
2

= 13 

3 

18 

9 

16 

20 

15 

7 

14 

6 

13 

 
 
3 

𝑓−1(3) =

3 − 1
2

=

2
2

= 1 

1 

                                                             Fonte: Autoria própria 

124 

Assim,  tendo  decodificado  cada  número,  fica  fácil  recuperar  a  mensagem.  Basta 

substituir  os  números  na  mensagem  7-37-19-33-41-31-15-37-3-13-19-3-29-31-33-37-31-13-

27-3-41 codificada por seus correspondentes na tabela anterior. A mensagem torna-se então: 

3-18-9-16-20-15-7-18-1-6-9-1-14-15-16-18-15-6-13-1-20. 

Por meio da tabela de pré-codificação (Tabela 8), podemos observar as letras correspondentes 

a esses números e obter a mensagem original. 

CRIPTOGRAFIA NO PROFMAT. 

Agora  um  detalhe  técnico:  como  a  função  de  decodificação  consiste  na  inversa  da  função 
𝑥 − 1
𝑓(𝑥) = 2𝑥 + 1, temos que a chave de decodificação é (1
2
2

), pois 𝑓−1(𝑥) = 𝑥−1
, − 1
2
2

= 1
2

. 

De  modo geral, se codificarmos uma  mensagem  com chave  (𝑎, 𝑏), com  𝑎 ≠ 0, temos que a 

chave  de  decodificação  será  (1
𝑎

, − 𝑏
𝑎

𝑓 −1(𝑥) = 𝑥−𝑏
𝑎

= 1
𝑎

𝑥 + (− 𝑏
𝑎

). 

),  pois  se  𝑎 ≠ 0,  a  inversa  da  função  𝑓(𝑥) = 𝑎𝑥 + 𝑏  é 

Os  Exemplos  4.28  e  4.29  a  seguir  trazem  mais  algumas  alternativas  para  explorar  a 

relação entre criptografia e funções afins por meio do método descrito anteriormente. Juntos, 

os  roteiros  desenvolvidos  nesta  seção  e  os  Exemplos  4.28  e  4.29  constituem  um  excelente 

guia  para  tratar  a  relação  entre  funções  afins  e  criptografia  em  sala  de  aula,  trabalhando  os 

conceitos  matemáticos  envolvidos  por  meio  da  resolução  de  problemas  e  codificação 

criptográfica. 

Exemplo  4.28  Codifique  com  base  na  Tabela  8  e  na  chave  (3,  10),  a  mensagem:  O 

SEGREDO DO COFRE É SUA DATA DE NASCIMENTO.  

Solução:  Com  base  na  tabela  de  pré-codificação,  a  mensagem  dada  torna-se  a  seguinte 

sequência de blocos:  

15-19-5-7-18-5-4-15-4-15-3-15-6-18-5-5-19-21-1-4-1-20-1-4-5-14-1-19-3-9-13-5-14-20-15. 

 
 
125 

Como  a  chave  de  codificação  é  função  de  codificação  (3,  10),  segue  que  a  função  de 

codificação criptográfica é a  função 𝑓(𝑥) = 3𝑥 + 10. Assim, calculando a imagem de todos 

os  números  que  aparecem  na  sequência  anterior,  correspondente  à  mensagem  original, 

teremos: 

Tabela 11 – Codificação da Mensagem do Exemplo 4.28 

𝑥 

1 

3 

4 

5 

6 

7 

9 

13 

14 

15 

18 

19 

20 

21 

𝑓(𝑥)  13 

19 

22 

25 

28 

31 

37 

49 

52 

55 

64 

67 

70 

73 

Fonte: Autoria própria 

Logo, a mensagem codificada será dada por: 

55-67-25-31-64-25-22-55-22-55-19-55-28-64-25-25-67-73-13-22-13-70-13-22-25-52-13-67-

19-37-49-25-52-70-55. 

Exemplo 4.29 Vamos supor que um estudante A está utilizando esse método de criptografia 

com  funções  afins  para  mandar  mensagens  secretas  para  outro  estudante  B  na  sala  de  aula. 

Um terceiro estudante, C, está interessado em saber o conteúdo das mensagens trocadas por A 

e B. No entanto, C não possui a chave de decodificação envolvida no processo, pois ele é um 

intruso  nessa  situação.  Obstinado  a  quebrar  o  código  utilizado  por  A  e  B,  C  descobriu,  de 

alguma forma, que por meio da função de codificação utilizada por A, o 1 passa a ser o 52, e o 

5  passa  a  ser  188.  Pergunta-se:  com  essa  nova  informação,  C  tem  condições  de  quebrar  o 

código utilizado pelos estudantes A e B? Suponha que C sabe que o método utilizado por A e 

B  é  este  baseado  em  funções  afins,  e  que  a  tabela  de  pré-codificação  é  a  mesma  que  a 

apresentada nesta seção.  

Solução: Sim! Veja por que: como C sabe que A e B estão codificando usando uma função do 

tipo  𝑓(𝑥) = 𝑎𝑥 + 𝑏,  então  ele  sabe  que  basta  conhecer  os  valores  de  𝑎  e  𝑏  para  obter  as 

funções de codificação e decodificação criptográficas. Ora, com a  informação que C possui, 

ele  pode  concluir  que  𝑓(1) = 52  e  𝑓(5) = 188.  Logo,  substituindo  essas  informações  na 

expressão  𝑓(𝑥) = 𝑎𝑥 + 𝑏,  obtêm-se:  𝑎 + 𝑏 = 52 e 5𝑎 + 𝑏 = 188.  Portanto,  para  saber  os 

valores de 𝑎 𝑒 𝑏, C só precisa resolver o sistema a seguir: 

 
 
126 

𝑎 + 𝑏 = 52
{
5𝑎 + 𝑏 = 188

Subtraindo a primeira equação da segunda, temos 4𝑎 = 188 − 52 = 136. O que implica que 
𝑎 = 136
4

= 34 ⇒ 𝑏 = 52 − 𝑎 = 52 − 34 = 18. Daí, C conclui que 𝑎 = 34 e 𝑏 = 18. Logo, a 

função  utilizada  para  criptografar  as  mensagens  é  𝑓(𝑥) = 34𝑥 + 18.  Com  esta  função  em 

mãos, o estudante C pode facilmente decifrar as mensagens trocas por A e B. Claro, supondo 

que A e B não modifiquem algum elemento na utilização desse método de criptografia.  

A  seguir,  apresentaremos  outro  exemplo  didático  de  um  método  intuitivo  utilizando 

funções. Desta vez, trataremos da Função Quadrática. 

4.3 Funções Quadráticas e Criptografia 

Uma Função Quadrática (ou Função Polinomial do 2º grau) é toda função  𝑓: ℝ → ℝ, 

tal  que,  existem  números  reais  𝑎, 𝑏 e 𝑐, sendo 𝑎 ≠ 0, com  𝑓(𝑥) = 𝑎𝑥2 + 𝑏𝑥 + 𝑐.  Quando 

𝑏 = 𝑐 = 0, temos a função quadrática 𝑓(𝑥) = 𝑎𝑥2 que é o caso mais simples de tais funções. 

Alguns  exemplos  de  funções  quadráticas  são:  𝑓(𝑥) = 𝑎𝑥2 + 𝑏𝑥 (𝑛𝑜 𝑐𝑎𝑠𝑜 𝑒𝑚 𝑞𝑢𝑒 𝑐 = 0), 

𝑓(𝑥) = 𝑎𝑥2 + 𝑐,  (𝑞𝑢𝑎𝑛𝑑𝑜 𝑏 = 0),  etc.  Lembrando  sempre  que  o  coeficiente  𝑎  deve  ser 

diferente de zero para que tenhamos certeza que a função 𝑓(𝑥) = 𝑎𝑥 2 + 𝑏𝑥 + 𝑐 é quadrática. 

Se  tratando  da  Teoria  das  Funções  Quadráticas,  deixaremos  de  abordar  grande  parte 

dos conceitos habitualmente vistos no ensino básico. A razão para isso, como já explicitado, é 

que  tais  conceitos  não  são  necessários  para  o  desenvolvimento  e  entendimento  do  conteúdo 

exposto.  Trataremos  de  mencionar  aquilo  que  realmente  importa  e  que  assume  um  papel 

central  na  aplicação  de  criptografia  apresentada.  Assim  sendo,  temas  como:  gráfico,  forma 

canônica,  teorema  de  caracterização,  valores  máximos  e  mínimos,  etc.,  não  serão 

desenvolvidos  como  de  costume.  Quando  necessário,  faremos  menção  a  algum  desses 

conceitos diretamente no texto em que o mesmo for citado, ou então em nota de rodapé. No 

caso  do  leitor  interessado  em  revisar  o  assunto,  as  mesmas  referências  dadas  na  Seção  4.2 

também servem para um estudo introdutório sobre Funções Quadráticas.  

 
 
 
 
 
127 

4.3.1 Um método criptográfico intuitivo baseado em Funções Quadráticas 

Semelhante ao que fizemos na Seção 4.2, nosso propósito nesta seção é descrever um 
método  bem  elementar  de  criptografia  com  base  na  Função  Quadrática35.  Para  isto,  nossa 

tabela  de  pré-codificação  continua  sendo  a  mesma  usada  no  caso  da  Função  Afim.  Para  o 

método criptográfico que apresentamos, valem as mesmas informações dadas para o método 

da seção anterior, isto é, ele possui espaço de texto comum {1, 2, 3, 4, ..., 26}, ele é uma cifra 

de blocos com comprimento 1 e seu espaço de texto cifrado é um subconjunto finito de ℕ. O 

roteiro apresentado a seguir é semelhante ao desenvolvido na Seção 4.3.1 para funções afins. 

Por  isso,  seremos  mais  sucintos  no  desenvolvimento  do  roteiro  para  evitar  repetições  de 

ideias. 

Roteiro 1 – Processo de codificação do método 

Etapa 1: Suponhamos que queremos codificar a mensagem A VIDA É UM SOPRO. Usando 

a Tabela 8, substituímos cada  letra pelo número que  lhe é correspondente, separando-os por 

um traço (-), como fizemos na Seção 4.2. Logo, a mensagem passará a ser: 

1-22-9-4-1-5-21-13-19-15-16-18-15. 

Etapa 2: Agora, precisamos codificar cada número (bloco) que forma a mensagem. Entra em 

cena  a  questão  da  escolha  da  função  de  codificação  criptográfica.  No  caso  presente,  esta 

função será a Função Quadrática  𝑓(𝑥) = 𝑎𝑥2 + 𝑏𝑥 + 𝑐 (𝑎 ≠ 0) com domínio restringido ao 

conjunto {1, 2,, ..., 26}. Então, começamos escolhendo os coeficientes 𝑎, 𝑏 e 𝑐. Em termos de 

chave  de  codificação,  isto  significa  escolher  uma  tripla  ordenada  (𝑎, 𝑏, 𝑐)  de  números  reais 

(que no nosso caso serão escolhidos de  modo que os valores da  função sejam  naturais, para 

simplificar e evitar exageros). Escolhemos então a chave (2, 1, 1). Ou seja,  vamos utilizar a 

função 𝑓(𝑥) = 2𝑥2 + 𝑥 + 1 como função de codificação criptográfica. 

Etapa 3:  Escolhida a função de codificação criptográfica 𝑓(𝑥) = 2𝑥2 + 𝑥 + 1, basta calcular 

a imagem de cada número da sequência que forma a mensagem original, que pela Etapa 1 é 

1-22-9-4-1-5-21-13-19-15-16-18-15. 

35 Rigorosamente falando, e isto se aplica também para o caso  já tratado utilizando Função Afim, não usamos 
realmente uma Função Quadrática, de acordo com a definição dada. Isso porque o domínio utilizado por nós não 
é o conjunto dos números reais. O que fazemos é restringir o domínio da função ao conjunto {1, 2, 3, .., 26} e 
usar  como  lei  de  formação  desta  função  a  expressão  𝑓(𝑥) = 𝑎𝑥2 + 𝑏𝑥 + 𝑐.  Mas  isto  não  representa  nenhum 
incomodo para a descrição e aplicação do método estudado.  

 
                                                             
128 

A Tabela 12 a seguir resume os cálculos realizados. 

Tabela 12 – Codificando a Mensagem 

Bloco (𝒙) 

Função de codificação  

Bloco codificado 

(𝒇(𝒙) = 𝟐𝒙𝟐 + 𝒙 + 𝟏) 

𝑓(1) = 2 ⋅ 12 + 1 + 1 = 4 

𝑓(22) = 2 ⋅ 222 + 22 + 1 = 991 

𝑓(9) = 2 ⋅ 92 + 9 + 1 = 172 

𝑓(4) = 2 ⋅ 42 + 4 + 1 = 37 

𝑓(5) = 2 ⋅ 52 + 5 + 1 = 56 

𝑓(21) = 2 ⋅ 212 + 21 + 1 = 904 

𝑓(13) = 2 ⋅ 132 + 13 + 1 = 352 

𝑓(19) = 2 ⋅ 192 + 19 + 1 = 742 

𝑓(16) = 2 ⋅ 162 + 16 + 1 = 529 

𝑓(18) = 2 ⋅ 182 + 18 + 1 = 667 

𝑓(15) = 2 ⋅ 152 + 15 + 1 = 466 

1 

22 

9 

4 

5 

21 

13 

19 

16 

18 

15 

(𝒚 = 𝒇(𝒙)) 

4 

991 

172 

37 

56 

904 

352 

742 

529 

667 

466 

                                                             Fonte: Autoria própria 

A mensagem codificada passará a ser a sequência de blocos: 

4-991-172-37-4-56-904-352-742-466-529-667-466. 

 
 
 
 
 
129 

Roteiro 2 – Processo de decodificação do método 

Para  recuperarmos  a  mensagem  original  necessitamos  da  função  de  decodificação 

criptográfica. Ora,  já sabemos que essa  função é  a  inversa da  função de codificação. Então, 

temos  que  calcular  a  inversa  da  função  𝑓(𝑥) = 2𝑥2 + 𝑥 + 1.  Aqui  esbarramos  num  ponto 

importante. Como vimos na Seção 4.1, a fim de que uma função tenha inversa é necessário, e 

suficiente  que  ela  seja  bijetiva.  É  de  nosso  conhecimento  que  a  função  quadrática  não  é 
bijetiva  em  toda  a  reta,  isto  é,  em  ℝ,  por  não  ser  injetiva36.  Porém,  é  fácil  vencer  esta 

dificuldade. Basta considerar a função definida em um dos intervalos  (−∞, 𝑥𝑣] ou [𝑥𝑣, +∞), 

pois  neste caso a função será  bijetiva.  𝑥𝑣 indica a abcissa do vértice da parábola, gráfico da 

função  quadrática  em  questão.  A  imagem  (que  será  igual  ao  contradomínio)  da  função  será 
[𝑦𝑣, +∞) quando 𝑎 > 0, e (−∞, 𝑦𝑣] quando 𝑎 < 0.37 Onde 𝑦𝑣 indica a ordenada do vértice da 
parábola,  gráfico  da  função  quadrática  em  questão.  Voltando  ao  caso  da  função  de 
codificação,  o  gráfico  da  mesma  é  uma  parábola  com  vértice  (− 1
4

; 7
).  Como  só  atribuímos 
8

valores  naturais  para  𝑥,  segue  que  o  domínio  de  𝑓  está  contido  em  [− 1
4

, +∞),  segue  então 

que  existe  a  inversa  de  𝑓.  Portanto,  existe  a  função  de  decodificação  criptográfica.  Como  é 
fácil  ver,  o  domínio  da  inversa  de  𝑓  será  um  subconjunto  de  [7
8

, +∞).  Calculemos  então  a 

função inversa de 𝑓. Essa será nossa Etapa 1 do processo de decodificação. 

Etapa  1:  Temos  que  𝑓(𝑥) = 𝑦 = 2𝑥2 + 𝑥 + 1  é  a  função  de  codificação  criptográfica. 

Queremos calcular 𝑥 em função de 𝑦. A igualdade  

𝑦 = 2𝑥2 + 𝑥 + 1 

torna-se  a  equação  do  segundo  grau  2𝑥2 + 𝑥 + 1 − 𝑦 = 0  na  incógnita  𝑥  (caso  seja 

necessário, é  importante revisar as equações do 2º grau e o método de resolução utilizado a 

seguir). Calculando as raízes dessa equação em função de 𝑦, teremos: 

𝑥 =

−1 ± √12 − 4.2. (1 − 𝑦)
4

=

−1 ± √1 − 8(1 − 𝑦)
4

⟹ 𝑥 =

−1 + √1 − 8(1 − 𝑦)
4

ou 𝑥 =

−1 − √1 − 8(1 − 𝑦)
4

. 

36Como  o  gráfico  da  função  quadrática  é  uma  parábola,  dois  elementos  do  domínio,  simétricos  em  relação  a 
abcissa do vértice dessa parábola, terão mesma imagem. Logo, a função é injetiva em ℝ. 
37 Os símbolos 𝑥𝑣 𝑒 𝑦𝑣 representam, respectivamente, a abcissa e a ordenada do vértice da parábola, gráfico da 
função quadrática 𝑓. 

 
 
                                                             
130 

Como o domínio de 𝑓 é [− 1
4

, +∞), segue que 𝑥 = −1+√1−8(1−𝑦)

4

.  

Portanto, temos que  

𝑥 = 𝑓−1(𝑦) =

−1 + √1 − 8(1 − 𝑦)
4

. 

A função inversa de 𝑓, com domínio [7
8

, +∞), é:  

𝑓−1(𝑥) =

−1 + √1 − 8(1 − 𝑥)
. 
4

Etapa  2:  Nesta  etapa  realizamos  o  processo  de  decodificação  dos  blocos  que  constituem  a 

mensagem  original  codificada.  Sendo  𝑓 −1(𝑥) = −1+√1−8(1−𝑥)

    a  função  de  decodificação, 

4

basta aplicá-la aos blocos que forma a mensagem codificada para obter a mensagem original. 

Não  faremos  as  contas  aqui,  mas  o  leitor  pode  se  certificar  de  que  realmente  recuperamos 

todos  os  blocos  codificados  calculando  a  imagem  de  todos  os  números  na  mensagem 

codificada  por  meio  de  𝑓−1.    Por  exemplo,  o  primeiro  bloco  da  mensagem  codificada  é  4. 

Logo, para decodificar esse bloco, basta substituí-lo na função 𝑓−1, obtendo  

𝑓−1(4) =

−1 + √1 − 8(1 − 4)
4

=

−1 + √1 − 8(−3)
4

=

−1 + √1 + 24
4

=

−1 + 5
4

= 1. 

Ou seja, o bloco original correspondente ao bloco 4 é o 1. Repetindo esses cálculos para todos 

os blocos, recuperamos a mensagem. A tabela a seguir resume o processo de decodificação: 

Tabela 13 – Decodificando a Mensagem 

𝑦 

4 

991 

172 

37 

56 

904 

352 

742 

529 

667 

466 

𝑓 −1(𝑦)  1 

22 

9 

4 

5 

21 

13 

19 

16 

18 

15 

Fonte: Autoria própria 

A mensagem decodificada passa a ser a sequência 1-22-9-4-1-5-21-13-19-15-16-18-15 

que  corresponde  à  mensagem  original  A  VIDA  É  UM  SOPRO  pela  Tabela  8,  e  o  processo 

está encerrado.  

 
131 

O  exemplo  a  seguir  trata  de  um  caso  simples  do método  desenvolvido  nesta  seção  e 

pode ser bastante utilizado em sala de aula para exercitar as noções de quadrados perfeitos e 

raízes quadradas. 

Exemplo  4.30  (A  função  𝑓(𝑥) = 𝑥2)  Neste  exemplo,  nossa  função  de  codificação 

criptográfica  é  𝑓: ℝ+ →  ℝ+dada  por  𝑓(𝑥) = 𝑥2.  Note  que  esta  função  é  quadrática,    com 

mesma  lei  de  formação,  porém  com  domínio  e  contradomínio  restringidos  ao  conjunto  dos 

números  reais  não  negativos.  Assim,  existe  a  função  de  decodificação,  pois  a  função  é 

bijetiva. Neste exemplo, podemos trabalhar  não só a ideia de  Função Quadrática (no ensino 

médio), mas também os conceitos de quadrados de números naturais, radiciação e operações 

inversas (no ensino fundamental). Pretendemos criptografar a mensagem A MATEMÁTICA 

É A RAINHA DAS CIÊNCIAS usando como método elementar as Funções Quadráticas. Em 

particular,  utilizaremos  a  função  𝑓: ℝ+ → ℝ+  dada  por  𝑓(𝑥) = 𝑥 2.  Usando  a  Tabela  8,  a 

mensagem original será convertida em: 

1-13-1-20-5-13-1-20-9-3-1-5-1-18-1-9-14-8-1-4-1-19-3-9-5-14-3-9-1-19. 

Agora, para codificar a mensagem precisamos calcular o quadrado dos números que a 

forma, isto é, calcular a imagem de cada bloco da mensagem pela função 𝑓(𝑥) = 𝑥2. A tabela 

a seguir resume esses simples cálculos: 

Tabela 14 – Codificação da Mensagem do Exemplo 4.30 

𝑥 

𝑥2 

1 

1 

13 

20 

5 

9 

169 

400 

25 

81 

3 

9 

18 

14 

8 

4 

19 

324 

196 

64 

16 

371 

Fonte: Autoria própria 

A mensagem criptografada será:  

1-169-1-400-25-169-1-400-81-9-1-25-1-324-1-81-196-64-1-16-1-371-9-81-25-196-9-81-1-371. 

Para recuperarmos a mensagem, necessitamos da função inversa de 𝑓. Como sabemos, 

a  operação  inversa  da  potenciação  é  a  radiciação.  Logo,  a  função  inversa  de  𝑓(𝑥) = 𝑥2  é 

𝑓(𝑥) = √𝑥  (veja  que  como  √𝑥  não  está  definido  para  𝑥 < 0,  necessitamos  restringir  o 
contradomínio  de  𝑓  à  ℝ+).  Precisamos  calcular  a  raiz  quadrada  de  todos  os  números  que 

formam  a  mensagem  codificada  (esta  é  uma  ótima  oportunidade  para  treinar  o  cálculo  de 

raízes quadradas). Teremos então a seguinte tabela: 

 
132 

Tabela 15 – Decodificação da Mensagem do Exemplo 4.30 

𝑦 

√𝑦 

1 

1 

169 

400 

25 

81 

13 

20 

5 

9 

9 

3 

324 

196 

64 

16 

371 

18 

14 

8 

4 

19 

Fonte: Autoria própria 

Substituindo  os  blocos  na  mensagem  codificada  por  seus  correspondentes,  decodificados, 

obtemos:  

1-13-1-20-5-13-1-20-9-3-1-5-1-18-1-9-14-8-1-4-1-19-3-9-5-14-3-9-1-19. 

Que representa a mensagem A MATEMÁTICA É A RAINHA DAS CIÊNCIAS. O processo 

está encerrado! 

Observação 4.3 Na prática em sala de aula, o professor pode explorar mais exemplos como 

esses  com  o  intuito  de  revisar  e  exercitar  tópicos  já  estudados.  No  caso  anterior,  estávamos 

tratando de funções, mas o exemplo nos levou a revisar outras noções igualmente importantes. 

Assim,  com  base  no que  fizemos  no exemplo  anterior, podemos trabalhar com potências de 

expoentes  mais  altos,  assim  como  trabalhar  com  raízes  cúbicas,  quartas,  quintas,  etc.,  sem 

contar,  claro,  que  podemos  ampliar  esses  exercícios  de  criptografia  para  o  caso  de  outras 

funções,  como  as  polinomiais  de  grau  𝑛,  funções  racionais,  exponenciais,  logarítmicas,  etc. 

Como  é  fácil  ver  através  dos  exemplos  analisados  anteriormente,  não  é  necessário  falar  em 

função para trabalharmos com exemplos semelhantes em sala de aula no ensino fundamental. 

Digamos  que  estamos  no  fundamental  e  os  alunos  não  conhecem  ainda  as  funções.  O 

professor  pode,  e  deve  quando  necessário,  adaptar  as  atividades  ao  nível  e  bagagem  de 

conhecimento  da  turma.  Assim,  sem  mencionar  funções,  o  professor  pode,  por  exemplo, 

trabalhar fórmulas ou expressões algébricas e desenvolver atividades/exercícios, semelhantes 

àqueles  desenvolvidos  com  funções,  envolvendo  criptografia.  Desse  modo,  temos  a 

oportunidade de inserir o assunto criptografia nas séries iniciais do ensino fundamental. É só 

uma questão de adaptação! 

Na  seção  a  seguir,  investigaremos  um  pouco  a  relação  entre  matrizes  e  os  métodos 

criptográficos. 

 
 
 
133 

4.4 Matrizes e Criptografia 

Apesar  das  aplicações  de  Matrizes  à  Criptografia  serem  mais  bem  exploradas  (e 

entendidas) no campo da Álgebra Linear, é possível tratarmos de aspectos elementares dessas 

aplicações  somente  com  os  conceitos  básicos  sobre  Matrizes,  visto  num  curso  básico  de 

matemática.  Portanto,  nesta  seção  faremos  uma  breve  revisão  sobre  o  conceito  e  as 

propriedades das matrizes, finalizando com uma aplicação muito interessante em criptografia, 

a cifra de Hill.  

4.4.1 Algumas noções sobre Matrizes 

Definição 4.21. Dados os números naturais 𝑚 e 𝑛, uma Matriz real 𝐴 = [𝑎𝑖𝑗] de ordem 𝑚 por 

𝑛 é um quadro (tabela) formado por 𝑚x𝑛 números reais dispostos em 𝑚 linhas e 𝑛 colunas. O 

elemento genérico 𝑎𝑖𝑗 da matriz 𝐴 se encontra na intersecção da 𝑖-ésima linha com a 𝑗-ésima 

coluna de 𝐴. 

Uma Matriz 𝐴 = [𝑎𝑖𝑗] de ordem 𝑚 por 𝑛 é usualmente representada por: 

𝑎11    𝑎12    …    𝑎1𝑛
 𝑎21    𝑎22    …   𝑎2𝑛
⋮          ⋮                ⋮
𝑎𝑚1    𝑎𝑚2    …    𝑎𝑚𝑛

[

]. 

Para  indicar  a  Matriz  𝐴 = [𝑎𝑖𝑗] de ordem 𝑚 por 𝑛  usaremos  a  notação  mais  simples 

𝐴 = [𝑎𝑖𝑗]

𝑚𝑥𝑛

,  bem  comum  nos  livros  de  ensino  médio.  A  seguir  apresentaremos  algumas 

matrizes especiais por meio de exemplos.  

Exemplo 4.31 (Matriz Linha e Matriz Coluna) Uma Matriz que só possui uma linha, isto é, 

uma matriz 𝐴 = [𝑎𝑖𝑗]

1𝑥𝑛

, é chamada de Matriz Linha. Uma denominação semelhante é dada 

às matrizes com apenas uma coluna. 

Exemplo 4.32 (Matriz Nula) Chama-se Matriz Nula toda Matriz 𝐴 = [𝑎𝑖𝑗]

tal que 𝑎𝑖𝑗 = 0 

𝑚𝑥𝑛

para  todo  1 ≤ 𝑖 ≤ 𝑚  e  todo  1 ≤ 𝑗 ≤ 𝑛.  Ou  seja,  Matriz  Nula  é  aquela  que  só  possui 

elementos nulos. Iremos indicar a Matriz Nula de ordem 𝑚 por 𝑛 pelo símbolo 𝒪𝑚𝑥𝑛, 

 
 
134 

𝒪 = [

0     0    …     0
0     0    …     0
⋮       ⋮             ⋮
0      0     …    0

]. 

Exemplo 4.33 (Matriz Quadrada) Uma classe muito importante de matrizes são as chamadas 

Matrizes Quadradas. Uma Matriz  𝐴 = [𝑎𝑖𝑗]

𝑚𝑥𝑛

 chama-se quadrada quando possui o número 

de  linhas  igual  ao  número  de  colunas,  isto  é,  𝑚 = 𝑛.  Neste  caso,  dizemos  apenas  Matriz 

quadrada 𝐴 de ordem 𝑚. A Matriz a seguir é quadrada de ordem 3: 

𝐴 = [

1     4     7
2     5     8
3     6     9

]. 

Definição 4.22 A diagonal principal de uma Matriz quadrada 𝐴 de ordem 𝑚 é o conjunto dos 

elementos 𝑎𝑖𝑗 com 𝑖 = 𝑗. Ou seja, é o conjunto {𝑎11, 𝑎22, … , 𝑎𝑚𝑚}. Da mesma forma, chama-

se diagonal secundária o conjunto dos elementos 𝑎𝑖𝑗 com 𝑖 + 𝑗 = 𝑚 + 1, a saber, o conjunto 

{𝑎1𝑚, 𝑎2(𝑚−1), … , 𝑎𝑚1}. 

Exemplo  4.34  A  diagonal  principal  e  a  diagonal  secundária  da  Matriz  𝐴  a  seguir  são, 

respectivamente, os conjuntos {1, 7, 9} e {3, 5, 7}. 

𝐴 = [

1     4     5
2     7     8
3     6     9

]. 

Exemplo  4.35  (Matriz  Diagonal)  Quando  em  uma  Matriz  quadrada  𝐴 = [𝑎𝑖𝑗]  de  ordem  𝑚 

todos os elementos que não estão na diagonal principal são nulos, isto é, 𝑎𝑖𝑗 = 0 para 𝑖 ≠ 𝑗, a 

mesma é chamada de Matriz Diagonal. 

𝐴 = [

1     0     0
0     7     0
0     0     9

]         𝒪2𝑥2 = [

0 0
0 0

] 

Em particular, a Matriz Nula quadrada de ordem 𝑚 é uma Matriz Diagonal. 

Exemplo 4.36 (Matriz Identidade) Matriz Identidade de ordem 𝑚, simbolizada por 𝕀𝑚, é toda 

Matriz  diagonal  em  que  𝑎𝑖𝑗 = 1 para 𝑖 = 𝑗.  Ou  seja,  Matriz  Identidade  é  uma  Matriz 

Diagonal onde na diagonal principal só consta elementos iguais a 1. 

 
135 

𝕀𝑚 = [

1     0    …     0
0     1    …     0
⋮       ⋮     ⋱     ⋮
0      0     …    1

]. 

Definição  4.23  (Igualdade  de  Matrizes)  Dadas  as  matrizes  𝐴 = [𝑎𝑖𝑗]

  e  𝐵 = [𝑏𝑖𝑗]

, 

𝑚𝑥𝑛

𝑚𝑥𝑛

diremos  que  𝐴 = 𝐵  quando 𝑎𝑖𝑗 = 𝑏𝑖𝑗   para todo 1 ≤ 𝑖 ≤ 𝑚  e todo 1 ≤ 𝑗 ≤ 𝑛.  Ou  seja,  para 

que duas matrizes 𝐴 e 𝐵 sejam iguais é necessário, e suficiente, que sejam de mesma ordem e 

que os elementos correspondentes (aqueles que ocupam o  mesmo  lugar  nas  matrizes) sejam 

iguais. 

Exemplo  4.37  Para  que  a  matriz  𝑀 = [

5
2
7 11

]  seja  igual  à  matriz   𝑁 = [

2

𝑥
𝑦 + 1 11

] 

devemos ter 𝑥 = 5 e 𝑦 = 6. 

Denotando  por  ℳ(𝑚𝑥𝑛)  o  conjunto  das  matrizes  𝐴 = [𝑎𝑖𝑗]

,  é  sabido  que 

𝑚𝑥𝑛

podemos  definir  operações  nesse  conjunto  muito  semelhantes  às  operações  com  números 

reais,  por  exemplo.  Iremos  revisar  as  operações  de  Adição,  Subtração  e  Multiplicação  de 

matrizes, multiplicação de uma matriz por um número real e inversa de uma matriz.  

Definição 4.24 (Adição de Matrizes) Dadas as matrizes 𝐴 = [𝑎𝑖𝑗]

 e 𝐵 = [𝑏𝑖𝑗]

𝑚𝑥𝑛

𝑚𝑥𝑛

, chama-

se  Matriz  Soma  de  𝐴 e 𝐵,  a  Matriz   𝑀 + 𝑁 =   [𝑎𝑖𝑗 + 𝑏𝑖𝑗]  de  ordem  𝑚 𝑝𝑜𝑟 𝑛,  formada 

somando os elementos correspondentes em 𝐴 e 𝐵. 

Exemplo 4.38 Considere as matrizes 𝐴 = [

−5 8
4
3

] e 𝐵 = [

1 2
4 5

]. Temos: 

𝐴 + 𝐵 = [

−5 8
4
3

] + [

1 2
4 5

] = [

−4 10
9
7

]. 

Definição 4.25 (Diferença de Matrizes) A Matriz Simétrica (ou oposta) de 𝐴 = [𝑎𝑖𝑗]

 é a 

𝑚𝑥𝑛

Matriz −𝐴 = [−𝑎𝑖𝑗]

𝑚𝑥𝑛

 tal que 𝐴 + (−𝐴) = (−𝐴) + 𝐴 = 𝒪𝑚𝑥𝑛. Chama-se Matriz diferença 

das  matrizes  𝐴 = [𝑎𝑖𝑗]

  e  𝐵 = [𝑏𝑖𝑗]

𝑚𝑥𝑛

𝑚𝑥𝑛

  a  Matriz  𝑀 + (−𝑁) =   [𝑎𝑖𝑗 + (−𝑏𝑖𝑗)],  obtida 

somando 𝐴 com a Matriz simétrica de 𝐵. 

Exemplo 4.39 Considere as matrizes 𝐴 = [

−5 8
4
3

] e 𝐵 = [

−7 2
3
4

]. Temos: 

𝐴 − 𝐵 = 𝐴 + (−𝐵) = [

−5 8
4
3

] + [

7 −2
−4 −3

] = [

2
6
−1 1

]. 

 
136 

Definição 4.26 (Multiplicação de um número real por uma Matriz) Dados um número real  𝛼 

e  uma  Matriz  𝐴 = [𝑎𝑖𝑗]

𝑚𝑥𝑛

,  chama-se  Matriz  produto  de  𝛼  por  𝐴  a  Matriz                            

𝛼 ⋅ 𝐴 = [𝛼. 𝑎𝑖𝑗]

𝑚𝑥𝑛

formada multiplicando todos os elementos de 𝐴 pelo número real 𝛼. 

Exemplo 4.40 Se 𝛼 = 4 e 𝐴 = [

3 2
1 0

], então 𝛼 ⋅  𝐴 = 4 ⋅ [

3 2
1 0

] = [

4 ⋅ 3 4 ⋅ 2
4 ⋅ 1 4 ⋅ 0

] = [

12 8
0
4

]. 

Definição  4.27  (Multiplicação  de  Matrizes)  Dadas  as  matrizes  𝐴 = [𝑎𝑖𝑗]

e 𝐵 = [𝑏𝑗𝑘]

, 

𝑛𝑥𝑝

𝑚𝑥𝑛

chama-se  Matriz  Produto  de  𝐴 por 𝐵,  a  Matriz   𝐴 ⋅ 𝐵 =   [𝑐𝑖𝑘]  de  ordem  𝑚 por 𝑝,  onde 

𝑐𝑖𝑘 = 𝑎𝑖1𝑏1𝑘 + 𝑎𝑖2𝑏2𝑘 + 𝑎𝑖3𝑏3𝑘 + ⋯ + 𝑎𝑖𝑛𝑏𝑛𝑘,  com  1 ≤ 𝑖 ≤ 𝑚  e  1 ≤ 𝑘 ≤ 𝑝.  Ou  seja,  para 

dar origem ao elemento 𝑐𝑖𝑘 da Matriz 𝐴 ⋅ 𝐵 multiplicamos a i-ésima linha de 𝐴 pela k-ésima 

coluna de 𝐵. 

Observação  4.4  A  multiplicação  de 𝐴 = [𝑎𝑖𝑗]

  por 𝐵 = [𝑏𝑗𝑘]

𝑞𝑥𝑝

𝑚𝑥𝑛

só  está definida  no  caso 

em que o número de colunas de 𝐴 for igual ao número de linhas de 𝐵 (𝑛 = 𝑞). Daí, a matriz 

𝐴 ⋅ 𝐵 terá 𝑚 linhas e 𝑝 colunas. 

Exemplo 4.41 Seja 𝐴 = [

2 0
1 3

] e 𝐵 = [

2
7       0
3 −4     11

]. Tem-se: 

𝐴 ⋅ 𝐵 = [

2 0
1 3

] . [

2
7       0
3 −4     11

] = [

2 ⋅ 2 + 0 ⋅ 3 2 ⋅ 7 + 0 ⋅ (−4)      2 ⋅ 0 + 0 ⋅ 11
1 ⋅ 2 + 3 ⋅ 3 1 ⋅ 7 + 3 ⋅ (−4)     1 ⋅ 0 + 3 ⋅ 11

] =

14       0
4
[
11 −5     33

]. 

Exemplo  4.42  Dada  a  Matriz  𝐴 = [𝑎𝑖𝑗]

𝑚𝑥𝑛

e  as  matrizes  identidades  𝕀𝑛 e 𝕀𝑚,  temos              

𝐴 ⋅  𝕀𝑛 = 𝕀𝑚 ⋅ 𝐴 = 𝐴. Com efeito, seja 𝑐𝑖𝑘 um elemento genérico de 𝐴 ⋅ 𝕀𝑛. Tem-se: 

𝑐𝑖𝑘 = 𝑎𝑖1 ⋅ 0 + 𝑎𝑖2 ⋅ 0 + ⋯ + 𝑎𝑖,(𝑘−1) ⋅ 0 + 𝑎𝑖𝑘𝐼𝑘𝑘 + 𝑎𝑖,(𝑘+1) ⋅ 0 + ⋯ + 𝑎𝑖𝑛 ⋅ 0. 

Onde  𝐼𝑖𝑘  é  um  elemento  genérico  de  𝕀𝑛.  Logo,  𝑐𝑖𝑘 = 𝑎𝑖𝑘𝐼𝑘𝑘 = 𝑎𝑖𝑘 ⋅ 1 = 𝑎𝑖𝑘.  Donde 

concluímos que 𝐴.⋅ 𝕀𝑛 = 𝐴. De modo análogo prova-se que 𝕀𝑚 ⋅ 𝐴 = 𝐴. 

Definição  4.28  (Matriz  Invertível)  Seja  𝐴 = [𝑎𝑖𝑗]  uma  Matriz  quadrada  de  ordem  𝑚.  Se 

existir uma Matriz 𝐵 tal que 𝐴 ⋅ 𝐵 = 𝐵 ⋅ 𝐴 = 𝕀𝑚, então 𝐴 é dita Invertível. 

Observação  4.5  A  Matriz  𝐵  na  definição  anterior,  quando  existe,  é  única.  Com  efeito,  se 

existisse outra Matriz 𝐶 tal que 𝐴 ⋅ 𝐶 = 𝐶 ⋅ 𝐴 = 𝕀𝑚, então  

 
137 

𝐶 = 𝐶 ⋅ 𝕀𝑚 = 𝐶 ⋅ (𝐴 ⋅ 𝐵) = (𝐶. 𝐴). 𝐵 = 𝕀𝑚. 𝐵 = 𝐵. 

Da  mesma  forma,  𝐶 = 𝕀𝑚 ⋅ 𝐶 = (𝐵 ⋅ 𝐴) ⋅ 𝐶 = 𝐵 ⋅ (𝐴 ⋅ 𝐶) = 𝐵 ⋅ 𝕀𝑚 = 𝐵.  Portanto,  𝐶 = 𝐵,  o 

que mostra que 𝐵 é única. 

Exemplo  4.43  Seja  𝐴 = [

1 3
2 7

].  A  Matriz  𝐵 = [

7 −3
1
−2

]  é  tal  que  𝐴 ⋅ 𝐵 = 𝐵 ⋅ 𝐴 = 𝕀2. 

Logo, 𝐴 é invertível.  

Definição  4.29  Seja  dada  uma  Matriz  𝐴 = [𝑎𝑖𝑗]  invertível  de  ordem  𝑚.  A  matriz  𝐵 tal  que  

𝐴 ⋅ 𝐵 = 𝐵 ⋅ 𝐴 = 𝕀𝑚  chama-se  Inversa  da  Matriz  𝐴  e  será  denotada  por  𝐵 = 𝐴−1.    Portanto,  
𝐴 ⋅ 𝐴−1 = 𝐴−1 ⋅ 𝐴 = 𝕀𝑚. 

Do exposto anteriormente temos que se a inversa da matriz 𝐴 existe, então ela é única. 

Assim,  𝐴  é  invertível  se  admite  inversa.  É  claro  que  𝐴−1  também  deve  ser  uma  matriz 

quadrada de ordem 𝑚, caso contrário não faria sentido a igualdade 𝐴 ⋅ 𝐴−1 = 𝐴−1 ⋅ 𝐴. 

Exemplo  4.44  A  inversa  da  matriz  𝐴 = [

1 3
0 2

]  é  𝐴−1 = [

1 − 3
2
0 1/2

].  Com  efeito,  seja      

𝐴−1 = [

𝑎 𝑏
𝑐 𝑑

]. Da igualdade 𝐴 ⋅ 𝐴−1 = 𝕀2, temos: 

1 3
[
0 2

] . [

𝑎 𝑏
𝑐 𝑑

] = [

1 0
0 1

] ⟹ [

𝑎 + 3𝑐 𝑏 + 3𝑑

2𝑐

2𝑑

] = [

1 0
0 1

]. 

Pela  condição  de  igualdade  de  matrizes,  teremos  as  igualdades:  2𝑐 = 0 𝑒 2𝑑 = 1.  Logo, 
𝑐 = 0 e 𝑑 = 1
2

. Temos também 𝑎 + 3𝑐 = 1 ⇒ 𝑎 = 1, e 𝑏 + 3𝑑 = 0 ⇒ 𝑏 + 3
2

= 0 ⇒ 𝑏 = − 3
. 
2

Conclusão: 𝑎 = 1, 𝑏 = − 3
2

, 𝑐 = 0 e 𝑑 = 1
. Assim, 𝐴−1 = [
2

1 − 3
2
1

0

2

]. 

4.4.2 A Cifra de Hill 

Outro  método  clássico  de  criptografia  é  a  chamada  Cifra  de  Hill.  Esta  cifra  foi 

inventada em 1929 por Lester S. Hill, e se baseia em  Álgebra Linear e Aritmética Modular. 

Veja, por exemplo, Howard e Horres (2001), Capítulo 11, Seção 11.16. Nossa descrição aqui 

frisa  o  aspecto  teórico  básico  desta  cifra  no  que  tange  as  operações  básicas  com  matrizes. 

Nesse sentido, as obras Tavares et al. (2017), Loureiro (2014), Brandão (2017) e Jesus (2013) 

 
 
138 

são  ótimas  referências.  Uma  abordagem  mais  ampla  pode  ser  encontrada  nos  livros  de 

criptografia, por exemplo, Buchmann (2002). 

A  cifra  de  Hill  é  uma  cifra  em  blocos.  Logo,  antes  de  codificarmos  a  mensagem,  a 

mesma  é  dividida  em  blocos.  Consideremos  então  uma  mensagem  M  a  ser  codificada.  No 

caso  do  alfabeto  utilizado  ser  o  usual,  substituímos  todas  as  letras  da  mensagem  por  seus 

valores numéricos de acordo com a Tabela 8. Em seguida, escolhemos a chave de codificação, 

que será uma matriz quadrada 𝐴, invertível, de ordem 𝑛 e com todos os elementos inteiros. A 

mensagem M é então dividida em blocos de tamanho 𝑛. Cada bloco desses será representado 

por uma matriz coluna  

𝑏1
𝑏2
𝑏3
⋮
𝑏𝑛]
[

. 

Onde  (𝑏1, 𝑏2, 𝑏3, … , 𝑏𝑛)  é  a  sequência  de  letras  que  formam  um  bloco  da  mensagem.  Para 

codificarmos  o  bloco  (𝑏1, 𝑏2, 𝑏3, … , 𝑏𝑛)  multiplicamos  a  matriz  𝐴  pela  matriz  anterior 

formada  pelo  bloco  em  questão,  com  a  restrição  de  que  os  inteiros  maiores  que  25  nesse 

produto devem ser substituídos pelo seu resto na divisão por 26.  A matriz produto obtida será 

do tipo 𝑛x1. A mensagem codificada será representada pela sequência de blocos codificados, 

seguindo  a  ordem  dos  blocos  da  mensagem  original,  isto  é,  não  podemos  trocar  blocos  de 

lugar.  O  exemplo  a  seguir  ilustra  este  método.  O  mesmo  será  desenvolvido  passo  a  passo 

como forma de guia para auxiliar o professor na aplicação em sala de aula. 

Antes  da  aplicação  de  exemplos  que  envolvam  qualquer  método  elementar  de 

criptografia em sala de aula, é preciso verificar se os conceitos matemáticos envolvidos foram 

bem  desenvolvidos  e  entendidos  pelos  alunos,  pois  assim  os  mesmos  terão  melhores 

condições  de  apreciar  a  matemática  envolvida  e  exercitar  os  conceitos  estudados.  Desta 

forma,  para  uma  boa  aplicação  da  Cifra  de  Hill,  o  aluno  deve  possui  pelo  menos  o 

conhecimento  básico  sobre  matrizes,  tipos  especiais  de  matrizes,  operações  entre  matrizes  e 

matriz  inversa  (Cobrimos  todo  esse  conteúdo  na  Seção  4.4.1).  Assim,  fica  como  primeira 

etapa para o professor, o desenvolvimento deste conteúdo como pré-requisito para a aplicação 

de atividades envolvendo a cifra em questão. Feito isso, podemos seguir o roteiro abaixo para 

trabalhar os processos de codificação e decodificação da Cifra de Hill. 

 
 
 
 
 
 
 
 
 
139 

Exemplo  4.45  Por  meio  da  Cifra  de  Hill,  iremos  codificar,  e  posteriormente  decodificar,  a 

palavra MATEMÁTICA. 

Roteiro 1 - Processo de codificação da Cifra de Hill 

Etapa 1: Por simplicidade, vamos codificar a palavra MATEMÁTICA. É claro que a escolha 

é  livre,  mas  palavras  pequenas  facilitam  o  entendimento  da  cifra  e  simplificam  os  cálculos 

realizados. Em termos didáticos isso é importante, pois caso contrário a utilização desta cifra 

em sala de aula pode ficar desinteressante e os cálculos enfadonhos. 

Etapa 2: Nesta etapa começamos a pré codificar a palavra escolhida na Etapa 1. Por meio da 

Tabela  8,  a  palavra  MATEMÁTICA  passa  a  ser  representada  pela  sequência  de  números     

13-1-20-5-13-1-20-9-3-1.  

Etapa 3: Nesta etapa devemos escolher a chave de codificação. Como visto anteriormente no 

texto,  esta  chave  é  uma  matriz  quadrada  de  ordem  𝑛  só  com  elementos  inteiros.  Mais  uma 

vez, por simplicidade, iremos escolher uma matriz quadrada 𝐴 de ordem 2, como segue. 

𝐴 = [

1
0
−1 2

] 

Etapa  4:  Como  a  chave  de  codificação  é  uma  matriz  quadrada  de  ordem  2,  então  devemos 

dividir a sequência 13-1-20-5-13-1-20-9-3-1, obtida na Etapa 2, em blocos de comprimento 2: 

(13-1)-(20-5)-(13-1)-(20-9)-(3-1). 

Caso a  mensagem tivesse um  número  impar de  letras, e quiséssemos dividi-la em  blocos de 

comprimento 2, poderíamos adicionar uma letra qualquer (ou símbolo) ao final da mesma. 

Etapa 5: Os blocos obtidos  na Etapa 4 passarão a ser representados, respectivamente, pelas 

seguintes matrizes-coluna: 

13
[
1

] , [

20
5

] , [

13
1

] , [

20
9

] , [

3
1

]. 

Etapa  6:  As  etapas  anteriores  transformaram  a  palavra  MATEMÁTICA  em  uma  sequência 

de  blocos  representados  por  matrizes  de  ordem  2  𝑥  1.  Como  sabemos,  para  realizar  a 

codificação  da  mensagem  original  devemos  codificar  cada  um  desses  blocos.  A  codificação 

de  cada  bloco  será  dada  multiplicando  a  matriz-chave  de  codificação  pela  matriz  que 

representa o bloco a ser codificado. Por isso, quando escolhemos a matriz-chave como sendo 

 
 
quadrada  de  ordem  2  dividimos  a  sequência  13-1-20-5-13-1-20-9-3  em  blocos  de 

comprimento  2,  pois  assim  a  multiplicação  da  matriz-chave  pela  matriz-bloco  pode  ser 

140 

realizada, veja Observação 4.4. 

A codificação de cada um dos blocos [

13
1

] , [

20
5

] , [

Codificação do bloco [

𝟏𝟑
𝟏

] 

13
1

] , [

20
9

] , [

3
1

]será dada da seguinte forma: 

Multiplicamos a matriz [

] pela matriz [

13
1

]. Teremos:  

0
1
[
−1 2

] = [

1 ⋅ 13 + 0 ⋅ 1
(−1) ⋅ 13 + 2 ⋅ 1

] = [

13 + 0
−13 + 2

] = [

13
−11

] 

1
0
−1 2
13
1

] ⋅ [

Codificação do bloco [

𝟐𝟎
𝟓

] 

Multiplicamos a matriz [

1
0
−1 2

] pela matriz [

20
5

]. Teremos:  

0
1
[
−1 2

] ⋅ [

20
5

] = [

1 ⋅ 20 + 0 ⋅ 5
(−1) ⋅ 20 + 2 ⋅ 5

] = [

20 + 0
−20 + 10

] = [

20
−10

] 

Codificação do bloco [

𝟐𝟎
𝟗

] 

Multiplicamos a matriz [

] pela matriz [

20
9

]. Teremos:  

0
1
[
−1 2

] = [

1 ⋅ 20 + 0 ⋅ 9
(−1) ⋅ 20 + 2 ⋅ 9

] = [

20 + 0
−20 + 18

] = [

20
−2

] 

1
0
−1 2
20
9

] ⋅ [

Codificação do bloco [

𝟑
𝟏

] 

Multiplicamos a matriz [

] pela matriz [

3
1

]. Teremos:  

1
0
−1 2
3
0
1
[
1
−1 2

] ⋅ [

] = [

1 ⋅ 3 + 0 ⋅ 1
(−1) ⋅ 3 + 2 ⋅ 1

] = [

3 + 0
−3 + 2

] = [

3
−1

] 

 
 
 
 
 
141 

Etapa  7:  Das  codificações  da  Etapa  6,  temos  que  a  sequência  de  blocos,  que  representa  a 

mensagem original, 

13
[
1

] , [

20
5

] , [

13
1

] , [

20
9

] , [

3
1

], 

passa  a  ser  codificada  na  sequência  [

13
−11

],  [

20
−10

],[

13
−11

],  [

20
−2

],  [

3
−1

].  Ou  seja,  a  palavra 

MATEMÁTICA, codificada, será indicada pela sequência de blocos a seguir: 

13-(-11)-20-(-10)-13-(-11)-20-(-2)-3-(-1). 

Com  o  término  da  Etapa  7,  o  processo  de  codificação  está  encerrado.  Note  que  não 

usamos  a  regra  de  substituir  um  número  maior  que  25  por  seu  resto  na  divisão  por  26  no 

produto das matrizes. Isso se deu unicamente porque não obtivemos números maiores que 25. 

Mas como essa regra vale no geral para a cifra de Hill, é muito importante que a destaquemos. 

Logicamente,  este  é  apenas  um  exemplo,  e  o  leitor  está  livre  para  desenvolver  os  seus 

próprios com base no método geral e, se necessário, usar a regra. Vale a mesma observação 

para o processo de decodificação que realizaremos a seguir.  

Roteiro 2 - Processo de decodificação da Cifra de Hill 

Observação  inicial:  O  processo  de  decodificação  pode  ser  facilmente  realizado,  levando-se 

em  consideração  a  seguinte  observação:  Para todas  as  matrizes  𝐴 e 𝐵,  sendo  𝐴 invertível  de 

ordem 𝑛, e 𝐵 de ordem 𝑛 por 𝑝, vale que: 

𝐴 ⋅ 𝐵 = 𝐶 ⟺ 𝐴−1 ⋅ (𝐴 ⋅ 𝐵) = 𝐴−1 ⋅ 𝐶 ⟺ 𝐵 = 𝐴−1 ⋅ 𝐶 

Assim  sendo, para recuperarmos os blocos da mensagem original,  basta  multiplicar a  matriz 

inversa de A por cada uma das matrizes-colunas formadas com os blocos codificados e repetir 

a mesma regra da codificação: cada elemento do produto, maior que 25, deve ser substituído 

por seu resto na divisão por 26. 

Etapa  1:  No  nosso  caso,  a  inversa  será  uma  matriz  quadrada  de  ordem  2.  Logo,  da  mesma 

forma  como  fizemos  na  codificação,  separamos  a  sequência  que  representa  a  mensagem 

codificada  em  blocos  de  tamanho  2  e  os  escrevemos  como  matrizes  de  duas  linhas  e  uma 

coluna.  Assim,  como  a  mensagem  codificada  é  13-(-11)-20-(-10)-13-(-11)-20-(-2)-3-(-1), 

temos que os blocos são os seguintes: 

 
142 

13
[
−11

] , [

20
−10

] , [

13
−11

] , [

20
−2

] , [

3
−1

] 

Etapa 2: Precisamos calcular a inversa da matriz 𝐴 = [

0
1
−1 2

]. Seja 𝐴−1 = [

𝑥 𝑦
𝑡
𝑧

] a inversa 

da matriz 𝐴. Pela Definição 4.28, temos que  

𝐴 ⋅ 𝐴−1 = [

1
0
−1 2

] ⋅ [

𝑥 𝑦
𝑡
𝑧

] = [

1 0
0 1

] 

Assim,  [

1 ⋅ 𝑥 + 0 ⋅ 𝑧
(−1) ⋅ 𝑥 + 2 ⋅ 𝑧

1 ⋅ 𝑦 + 0 ⋅ 𝑡
(−1) ⋅ 𝑦 + 2 ⋅ 𝑡

] = [

1 0
0 1

igualdade de matrizes podemos concluir que  

𝑥

𝑦

] ⇒ [

−𝑥 + 2𝑧 −𝑦 + 2𝑡] = [

1 0
0 1

]. Da 

𝑥 = 1, 𝑦 = 0, −𝑥 + 2𝑧 = 0 e − 𝑦 + 2𝑡 = 1. 

Da  terceira  equação,  segue  que  2𝑧 = 𝑥 ⇒ 𝑧 = 𝑥
2

= 1
2
.  Conclusão:  𝑥 = 1, 𝑦 = 0 𝑒 𝑧 = 𝑡 = 1
concluímos  que  2𝑡 = 1 + 𝑦 = 1 + 0 = 1 ⇒ 𝑡 = 1
. 
2
2

.  Da  mesma  forma,  da  quarta  equação, 

Portanto, 𝐴−1 = [

1 0
1
1

]. 

2

2

Etapa  3:  Calculada  a  matriz  𝐴−1  na  Etapa  2,  já  temos  a  chave  de  decodificação.  Para 

decodificar a mensagem  

13
[
−11

] , [

20
−10

] , [

13
−11

] , [

20
−2

] , [

3
−1

] 

devemos decodificar cada um dos blocos que a forma. Para fazer isso, multiplicamos 𝐴−1 por 

cada um desses blocos. Assim, pela observação inicial, recuperamos os blocos originais, e o 

processo está encerrado. A decodificação desses blocos será dada da seguinte forma: 

Decodificação do bloco [

𝟏𝟑
−𝟏𝟏

] 

Multiplicamos a matriz [

1 0
1
1

2

2

] pela matriz [

13
−11

]. Teremos:  

[

1 0
1
1
2
2

] ⋅ [

13
−11

] = [

1 ⋅ 13 + 0 ⋅ (−11)
1
1
2
2

⋅ (−11)

⋅ 13 +

] = [

13 + 0

13
2

+

−11
2

] = [

13
1

] 

 
 
 
143 

Decodificação do bloco [

𝟐𝟎
−𝟏𝟎

] 

Multiplicamos a matriz [

1 0
1
1

2

2

] pela matriz [

20
−10

]. Teremos:  

[

1 0
1
1
2
2

] ⋅ [

20
−10

] = [

1 ⋅ 20 + 0 ⋅ (−10)
1
1
2
2

⋅ (−10)

⋅ 20 +

] = [

20 + 0

20
2

+

−10
2

] = [

20
5

] 

Decodificação do bloco [

𝟐𝟎
−𝟐

] 

Multiplicamos a matriz [

1 0
1
1

2

2

] pela matriz [

20
−2

]. Teremos:  

[

1 0
1
1
2
2

] ⋅ [

20
−2

] = [

1 ⋅ 20 + 0 ⋅ (−2)
1
1
2
2

⋅ (−2)

⋅ 20 +

] = [

20 + 0
−2
20
2
2

+

] = [

20
9

] 

Decodificação do bloco [

𝟑
−𝟏

] 

Multiplicamos a matriz [

1 0
1
1

2

2

] pela matriz [

3
−1

]. Teremos:  

[

1 0
1
1
2
2

] ⋅ [

3
−1

] = [

1 ⋅ 3 + 0 ⋅ (−1)
1
1
2
2

⋅ (−1)

⋅ 3 +

] = [

3 + 0
−1
3
2
2

+

] = [

3
1

] 

O processo de decodificação nos dá a sequência de blocos [

] , [

13
1

20
5

] , [

13
1

] , [

20
9

] , [

3
1

]. 

Esta  sequência  de  blocos  dá  origem  a  sequência  13-1-20-5-13-1-20-9-3-1  que  é  a  nossa 

palavra  original  MATEMÁTICA  de  acordo  com  a  Tabela  8.  Pronto!  Recuperamos  a 

mensagem original.  

Os roteiros anteriores podem ser usados para quaisquer exemplos utilizando a Cifra de 

Hill. É claro que o professor está livre para desenvolver o roteiro que achar mais conveniente 

para trabalhar atividades que envolvam esta cifra em sala de aula. O que propomos é um guia 

 
 
 
 
144 

simples  que  auxilia  na  realização  dos  processos  de  codificação  e  decodificação  e  que  deixa 

claro como os conceitos de matrizes estão inseridos nesses processos. 

Na  próxima  seção  continuaremos  nosso  estudo,  agora  com  foco  em  probabilidade  e 

sua relação com a criptografia. 

4.5 Probabilidade e Criptografia 

Nesta  seção  ampliamos  as  aplicações  da  matemática  básica  a  criptografia  estudando 

brevemente  a  relação  entre  probabilidade  e  sigilo  perfeito.  Como  fizemos  na  Seção  4.4, 

revisaremos brevemente algumas noções sobre probabilidade, encerrando com uma aplicação 

em  criptografia.  Esta  relação  é  mais  bem  desenvolvida  em  livros  especializados  em 

criptografia, como Terada (2000), Pellegrini (2019) e Buchmann (2002).  No entanto, fizemos 

um genuíno esforço para abordar esse assumo de modo mais simples e didático no contexto 

da matemática básica. 

4.5.1 Noções básicas sobre probabilidade 

“Experiências  que,  repetidas  sob  as  mesmas  condições,  produzem  geralmente 

resultados  diferentes  são  chamadas  de  Aleatórias”  (LIMA  et  al.,  2006b,  p.  82).  Assim,  por 

exemplo,  experiências  como:  jogar  um  dado  e  observar  a  face  voltada  pra  cima;  jogar  uma 

moeda e observar se deu cara ou coroa; retirar uma bola de uma urna que contêm várias bolas 

de cores diferentes e observar sua  cor; retirar uma carta de um  baralho e observar seu  nipe; 

etc., são todas aleatórias. 

Nas  experiências  aleatórias  podemos  destacar  o  conjunto  de  todos  os  resultados 

possíveis  de  ocorrer.  Esse  conjunto  será  denotado  por  S  e  chamado  de  Espaço  Amostral. 

Assim, por exemplo, na experiência de retirar uma carta de um baralho comum e observar seu 

nipe, o Espaço Amostral é {Ouro, Espadas, Paus, Copas}, pois esses são os únicos resultados 

possíveis da experiência.  

Todo subconjunto do Espaço Amostral S será chamado de Evento. “Diremos que um 

evento ocorre quando o resultado da experiência pertence ao evento” (LIMA et al., 2006b, p. 

82). Dentre os eventos de S podemos destacar os eventos chamados triviais, que são o evento 

 
 
 
145 

∅  (evento  nulo ou  evento  vazio)  que  nunca  ocorre,  e o  próprio  S  (evento  certo)  que  sempre 

ocorre. 

Exemplo  4.46  Lança-se  um  dado  normal  e  observa-se  a  face  voltada  para  cima.  Nesta 

experiência temos o Espaço Amostral S = {1, 2, 3, 4, 5, 6}. Como o número de subconjuntos 

de  S  é  26 = 64,  segue  que  existem  64  eventos  possíveis.  Dentre  eles,  podemos  destacar  os 

eventos  triviais  ∅,  S;  o  evento  {2,  4,  6}  que  ocorre  se  o  resultado  da  experiência  for  um 

número par, e o evento {1, 3, 5} que ocorre quando o resultado da experiência é um número 

ímpar. 

Se  considerarmos  𝐴 e 𝐵  eventos  de  S,  as operações  entre  conjuntos  nos  possibilitará 

falar dos eventos 𝐴 ∪ 𝐵, 𝐴 ∩ 𝐵, 𝐴 − 𝐵 e 𝐴𝑐. Quando 𝐴 e 𝐵 ocorrem ao mesmo tempo, então 

𝐴 ∩ 𝐵 ocorre. Se ao menos um dos eventos 𝐴 e 𝐵 ocorre, então o evento 𝐴 ∪ 𝐵 ocorre. É fácil 

ver que o evento 𝐴 − 𝐵 só ocorre se 𝐴 ocorrer e 𝐵 não. Por fim, 𝐴𝑐 ocorre se, e somente se 𝐴 

não ocorrer.  

Definição 4.30 Sejam  𝐴 e 𝐵 eventos de S. Dizemos que 𝐴 e 𝐵 são mutualmente excludentes 

(ou mutualmente exclusivos) quando eles não ocorrem simultaneamente. Ou seja, 𝐴 ∩ 𝐵 = ∅. 

Exemplo  4.47  No  lançamento  de  um  dado,  os  eventos  A  =  {2,  4,  6}  e  B  =  {1,  3,  5}  são 

mutualmente excludentes. 

Definir  uma  probabilidade  (ou  uma  distribuição  de  probabilidade)  num  Espaço 

Amostral S significa definir uma função 𝑝: 𝑆 → ℝ. A definição a seguir é baseada na dada por 

Lima et al. (2006b). 

Definição 4.31 Uma probabilidade em S é uma função 𝑝: 𝑆 → ℝ que faz corresponder a cada 

evento  A  de  S  um  número  real  𝑝(𝐴) ∈ ℝ,  chamado  a  probabilidade  de  A,  que  satisfaz  as 

seguintes condições: 

(i) 

(ii) 

qualquer que seja o evento 𝐴 ⊂ 𝑆, tem-se 0 ≤ 𝑝(𝐴) ≤ 1;  

a probabilidade do evento certo é 1, isto é, 𝑝(𝑆) = 1; 

(iii) 

se 𝐴 e 𝐵 são eventos mutualmente excludentes, então 𝑝(𝐴 ∪ 𝐵) = 𝑝(𝐴) + 𝑝(𝐵). 

Da definição anterior é possível provar facilmente as seguintes propriedades:  

  𝑝(∅) = 0;  

  𝑝(𝐴𝑐) = 1 − 𝑝(𝐴) , qualquer que seja o evento 𝐴 ⊂ 𝑆; 

 
146 

  𝑝(𝐴 ∪ 𝐵) = 𝑝(𝐴) + 𝑝(𝐵) − 𝑝(𝐴 ∩ 𝐵),  para todos os  eventos 𝐴, 𝐵 ⊂ 𝑆.  Se  𝐴 e 𝐵  são 

eventos  quaisquer,  temos  que  𝑝(𝐴 ∩ 𝐵) = 𝑝(𝐴) ⋅ 𝑝(𝐵/𝐴),  onde  𝑝(𝐵/𝐴)  é  a 

probabilidade  de  𝐵  ocorrer  sabendo  que  𝐴 ocorreu,  e  será  definida  mais  adiante. 

Quando 𝐴 e 𝐵 são eventos mutualmente excludentes, temos     

𝑝(𝐴 ∩ 𝐵) = 𝑝(𝐴) ⋅ 𝑝(𝐵). 

  Se 𝐴 ⊂ 𝐵, então 𝑝(𝐴) ≤ 𝑝(𝐵).  

A  prova  dessas  propriedades  podem  ser  encontradas  em  Lima  et  al.  (2006),  ou  em 

qualquer outro livro que trate do assunto. 

Para  indicar  a  probabilidade  de  um  evento  elementar  𝑎 ∈ 𝑆  usamos  a  notação  𝑝(𝑎), 

embora  o  mais  correto  fosse  𝑝({𝑎}),  apenas  por  simplicidade  de  notação.  Além  disso,  para 

definirmos  uma  probabilidade  em  𝑆  é  suficiente  definirmos  uma  probabilidades  sobre  seus 

eventos  elementares.  Da  mesma  forma,  a  probabilidade  de  um  evento  𝐴  é  a  soma  das 

probabilidades dos seus eventos elementares. 

Exemplo 4.48 Se considerarmos o conjunto das letras do alfabeto usual  Σ = {𝐴, 𝐵, 𝐶, … , 𝑍} e 

a experiência que consiste em selecionar uma letra desse conjunto para ser codificada por um 

determinado método criptográfico, então, por exemplo, a probabilidade de escolhermos B (ou 

resumidamente,  a  probabilidade  de  B)  será  indicada  por  𝑝(𝐵)  ao  invés  de  𝑝({𝐵}).  Uma 

probabilidade  possível  de  ser  definida  em  Σ  é  aquela  tal  que  𝑝(∅) = 0, 𝑝(Σ) = 1  e         
𝑝(𝐴) = 𝑝(𝐵) = 𝑝(𝐶) = ⋯ = 𝑝(𝑍) = 1
26

  Verifica-se  facilmente  que  todas  as  condições  da 

definição de probabilidade são satisfeitas. 

Definição 4.32 Um Espaço Amostral S será dito equiprovável quando todos os seus eventos 

elementares  tiverem  a  mesma  probabilidade  de  ocorrer.  Equivalentemente,  o  modelo  de 

probabilidade usado em S é dito equiprobabilístico.  

Assim, se S é equiprovável e possui  𝑛 eventos elementares, então a probabilidade de 

cada um dos eventos elementares será  1
𝑛

. Com efeito, suponhamos 𝑆 = {𝑎1, 𝑎2, … , 𝑎𝑛}.  Como 

a probabilidade de S é a soma das probabilidades dos eventos elementares, segue que: 

𝑃(𝑆) = 𝑃(𝑎1) + 𝑃(𝑎2) + ⋯ + 𝑃(𝑎𝑛). 

 
Como  𝑃(𝑎1) = 𝑃(𝑎2) = ⋯ = 𝑃(𝑎𝑛),  segue  que  𝑃(𝑆) = 𝑛𝑃(𝑎𝑛).  Logo,  𝑃(𝑎𝑛) = 𝑃(𝑆)

𝑛

147 

= 1
𝑛

. 

Concluímos assim que a probabilidade de qualquer evento elementar é  1
𝑛

. Disso resulta que se 

𝐴 é um evento de S com 𝑥 elementos, então  

𝑃(𝐴) = 𝑥
𝑛

= 𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝐴
. 
𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝑆

De fato, sendo 𝐴 = {𝑏1, 𝑏2, … , 𝑏𝑥}, temos: 

𝑃(𝐴) = 𝑃(𝑏1) + 𝑃(𝑏2) + ⋯ + 𝑃(𝑏𝑥) =

+

1
𝑛

1
1
⏟        
𝑛
𝑛
𝑥 𝑝𝑎𝑟𝑐𝑒𝑙𝑎𝑠

+ ⋯ +

=

𝑥
𝑛

 . 

Chegamos  assim  à  famosa  fórmula  de  calcular  probabilidades,  que  assegura  que  a 

probabilidade  de  um  evento  ocorrer  é  a  razão  entre  o  número  de  resultados  favoráveis  ao 

evento,  dividido  pelo  número  de  resultados  possíveis  da  experiência.  No  entanto,  é  preciso 

ressaltar, como os cálculos anteriores deixam claro, que essa maneira de pensar no cálculo da 

probabilidade de um evento A só é válida se o espaço amostral S for equiprovável. 

Exemplo  4.49  No  experimento  que  consiste  em  retirar  uma  carta  de  um  baralho  normal  e 

observar  seu  nipe,  temos  que  o  Espaço  amostral  é  equiprovável,  pois  consideramos  que 

qualquer nipe tem a  mesma chance de ser escolhido. Logo, a probabilidade de sair qualquer 
nipe é 1
4

= 25%. 

Para  encerrar  essas  considerações  sobre  probabilidade,  abordaremos  o  importante 

conceito  de  Probabilidade  Condicional.  Antes  de  definirmos  esse  conceito,  vamos  resolver 

um problema que retrata muito bem o significado de probabilidade condicional. 

Exemplo  4.50  Numa  urna  existem  10  bolas  idênticas  numeradas  de  1  à  10.  Considere  a 

experiência  que  consiste  em  retirar  uma  bola  dessa  urna  e  observar  seu  número.  O  Espaço 

Amostral dessa experiência é S = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. Se  𝐴 é o evento {número da 

bola  retirada  é  par},  isto  é,  𝐴  =  {2,  4,  6,  8,  10},  então  a  probabilidade  de  𝐴  ocorrer  é     

𝑃(𝐴) = 5
10

= 1
2

= 50%.  Esta  é  a  probabilidade  de  𝐴  ocorrer  antes  de  ser  realizada  a 

experiência. Agora, suponhamos que realizada a experiência, tenhamos a informação de que a 

bola sorteada não foi a de número 5. Pergunta-se: qual a probabilidade de 𝐴 neste caso? Com 

a informação de que a bola sorteada não foi a de número 5, a probabilidade de 𝐴 se modifica. 

Isso ocorre porque como agora temos a certeza que o evento  𝐵 = {1, 2, 3, 4, 6, 7, 8, 9, 10} 

 
148 

ocorreu,  então temos  9  casos  possíveis  de  ocorrer,  sendo  que  5  deles  são  favoráveis.  Daí,  a 

probabilidade  de  𝐴  se  torna  𝑃(𝐴) = 5
9

≅ 55,5%.  Assim,  podemos  dizer  que  o  novo  espaço 

amostral é B, e a probabilidade de A é calculada em B. Assim, o número de casos possíveis 

passa a ser igual ao número de elementos de B. Da mesma forma, veja que os casos que são 

favoráveis  à  ocorrência  de  A  são  todos  os  elementos  que  pertencem  a  interseção  𝐴 ∩ 𝐵. 

Enfim,  dizemos  neste  caso  que  5
9
ocorreu, e escrevemos  𝑃(𝐴\𝐵) = 5
9

  é  a  probabilidade  de  A  na  certeza  (ou  sabendo)  que  B 

. Temos então a seguinte definição:  

Definição 4.33 Sejam 𝐴 e 𝐵 eventos quaisquer de um Espaço Amostral S, com  𝑃(𝐵) ≠ 0. A 

probabilidade condicional de 𝐴 ocorrer sabendo que B ocorreu é dada por: 

𝑃(𝐴\𝐵) = 𝑃(𝐴∩𝐵)
𝑃(𝐵)

. 

Observação  4.6  A  justificativa  para  o  uso  dessa  fórmula  no  cálculo  da  probabilidade 

condicional  𝑃(𝐴\𝐵)  é  bem  simples.  De  fato,  como  comentamos  no  Exemplo  4.50,  sabendo 

que B ocorreu, o espaço amostral agora é B. Analogamente, os casos favoráveis não são mais 

todos os elementos de 𝐴, mas sim os elementos de 𝐴 ∩ 𝐵. Assim: 

𝑃(𝐴\𝐵) =

𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝐴 ∩ 𝐵
𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝐵

𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝐴∩𝐵

=

𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝑆
𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝐵

=

𝑛º 𝑑𝑒 𝑒𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 𝑑𝑒 𝑆

𝑃(𝐴 ∩ 𝐵)
𝑃(𝐵)

. 

A  seguir,  investigaremos  um  pouco  a  relação  entre  probabilidade  e  criptografia  por 

meio do conceito de Sigilo Perfeito. Veremos que a abordagem desse conceito também é uma 

ótima oportunidade para falar de criptografia e probabilidade em sala de aula. 

4.5.2 Sigilo Perfeito e Probabilidade 

As  noções  básicas  de  probabilidade  podem  ser  apreciadas  em  vários  campos  da 

ciência,  inclusive  em  criptografia.  O  conceito  de  Sigilo  Perfeito,  tão  importante  na  área  de 

criptografia,  é  definido  com  base  em  probabilidade  condicional.  A  ideia  de  sigilo  perfeito  é 

extremamente simples: suponhamos que um indivíduo 𝐴 desenvolva um método criptográfico 

para se comunicar com outro indivíduo 𝐵. Um intruso 𝐶 pretende interceptar a comunicação 

entre  𝐴  e  𝐵.  O  indivíduo  𝐴  codifica  uma  mensagem  (texto  comum)  𝑥  e  o  manda  para  𝐵. 

Supondo  que  𝐶  possa  ler  a  mensagem  codificada,  o  método  utilizado  por  𝐴  e  𝐵  terá  sigilo 

 
 
149 

perfeito se o intruso 𝐶 nada puder concluir a respeito de 𝑥 com base no texto cifrado em sua 

posse  (BUCHMANN,  2002).  A  formulação  matemática  dessa  ideia  requer  a  utilização  de 

probabilidades  definidas  nos  conjuntos  (espaços)  de  texto  comum  𝒫,  texto  cifrado  𝒞  e  de 

chaves 𝒦. 

Sendo  assim,  consideremos  um  criptossistema  onde  o  espaço  de  texto  comum,  o 

espaço de texto cifrado e o espaço das chaves são finitos. Temos: 

(i)  Com relação ao conjunto 𝒫 podemos considerá-lo como um espaço Amostral. De fato,  𝒫 

é  o  espaço  amostral  da  experiência  que  consiste  em  escolher  um  texto  comum  𝑥 ∈ 𝒫. 

Veja que os eventos elementares desse espaço são os textos comuns 𝑥. Portanto, podemos 

definir  uma  probabilidade  em  𝒫,  e  denotaremos  por  𝑝𝒫(𝑥)  a  probabilidade  de  𝑥  ser 

escolhido em 𝒫. 

(ii) Para  codificar  um  texto  comum  𝑥  é  preciso  de  uma  chave  𝑘 ∈ 𝒦.  Olhando  𝒦  como 

espaço amostral,  a saber, aquele correspondente à experiência que consiste em  escolher 

uma  chave  para  a  codificação,  cujos  eventos  elementares  são  as  chaves,  definiremos 

𝑝𝒦(𝑘) como sendo a probabilidade da chave  𝑘 ser escolhida. A escolha da chave  𝑘 não 

depende de 𝑥.  

Dados  um  texto  comum  𝑥  e  uma  chave  𝑘 ∈ 𝒦,  a  probabilidade  de  𝑥  e  𝑘  serem 

escolhidos  simultaneamente,  ou o  que  é  equivalente,  a  probabilidade  de  𝑥  ser  escolhido  e  a 

chave de codificação utilizada ser 𝑘, é dada por 

𝑝({𝑥} ∩ {𝑘}) = 𝑝(𝑥) ⋅ 𝑝(𝑘) = 𝑝𝒫(𝑥) ⋅ 𝑝𝒦(𝑘). 

Onde a probabilidade do texto comum 𝑥 ser codificado é igual a 𝑝𝒫(𝑥), e denotada por  𝑝(𝑥), 

e  a  probabilidade  de  uma  chave  𝑘  ser  escolhida  para  a  codificação  é  𝑝𝒦(𝑘),  denotada  por 

𝑝(𝑘). Por fim, considere o seguinte evento:  codificando x com a chave k obtém-se c,  isto é, 

𝐸𝑘(𝑥) = 𝑐.  Veja  que  este  evento  é  equivalente  ao  seguinte:  O  texto  c  é  o  resultado  da 

codificação  do  texto  x,  o  qual  denotaremos  apenas  por  𝑐.  Então,  resumidamente,  𝑝(𝑐)  é  a 

probabilidade de o texto cifrado ser 𝑐. 

Voltando  ao  problema  do  intercâmbio  de  mensagens  de  𝐴  e  𝐵,  imaginemos  que  o 

intruso 𝐶 consiga obter um dos textos cifrados 𝑐. É de se supor que 𝐶 conhece a probabilidade 

definida  no  espaço  𝒫  utilizado  por  𝐴  e  𝐵,  pois  ele  pode  muito  bem  conhecer  a  linguagem 

utilizada por 𝐴 e 𝐵 (BUCHMANN, 2002). Neste caso, 𝐶 pode usar probabilidade e se fazer a 

 
150 

seguinte  pergunta:  qual  a  probabilidade  de  um  texto  comum  𝑥  ter  sido  escolhido  para 

codificação,  sabendo  que  o  texto  cifrado  correspondente  foi  𝑐.  Ou  seja,  𝐶  está  procurando 

respostas  para  a  probabilidade  condicional  𝑝(𝑥/𝑐)  para  os  𝑥 ∈ 𝒫.  Nessa  análise,  duas 

possibilidades podem ocorrer: ou 𝐶 descobre que para determinado 𝑥 a probabilidade 𝑝(𝑥/𝑐) 

é grande, isto é, há muitas chances de o texto comum correspondente à 𝑐 ser 𝑥, e com isso ele 

passa  a  descartar  outros  textos  com  probabilidade  muito  pequena,  ou  então  𝐶  não  descobre 

nada com relação aos textos comuns. Isso ocorre quando a probabilidade  𝑝(𝑥/𝑐) não fornece 

nenhuma informação a respeito das chances de 𝑥 ser o texto comum correspondente a 𝑐. Veja 

que  isso  ocorre  quando  os  eventos  {𝑥}  e  {𝑐}  são  independentes.  Nestas  condições             

 𝑝(𝑥/𝑐)   = 𝑝(𝑥). 

Buchmann (2002) apresenta uma definição de sigilo perfeito (um caso simples de um 

resultado  mais  geral)  com  base  num  caso  semelhante  à  segunda  possibilidade  para  𝐶  dada 

anteriormente. Segundo Buchmann (2002), se considerarmos um método criptográfico onde o 

espaço  de  chaves  é  um  espaço  Amostral  equiprovável,  e  os  conjuntos  𝒞  e  𝒦  tem  a  mesma 

quantidade  de  elementos,  então  este  método 

terá  sigilo  perfeito  se,  e  só  se                          

𝑝(𝑥/𝑐)   = 𝑝(𝑥). Um resultado mais geral é conhecido como Teorema de Shannon e pode ser 

encontrado  em  Buchmann  (2002).  Para  nossos  interesses,  é  suficiente  o  caso  mais  simples. 

Assim,  vemos  muito  facilmente  que  as  probabilidades  condicionais  são  extremamente 

importantes para a criptografia. 

Essa  pequena  explicação  da  relação  entre  probabilidade  e  sigilo  perfeito  deve  servir 

como  motivação  para  abordar  o  assunto  dentro  do  conteúdo  de  probabilidade.  O  próximo 

exemplo é baseado em um exposto em Buchmann (2002). 

Exemplo  4.51  Digamos  que  num  criptossistema  tenhamos  𝒫 = {𝑥, 𝑦},  𝒦 = {𝛼, 𝛽}  e          

𝒞 = {𝑋, 𝑌}. Definamos as seguintes probabilidades: 

Em 𝒫: 𝑝(∅) = 0, 𝑝(𝒫) = 1, 𝑝(𝑥) = 3
5

𝑒 𝑝(𝑦) = 2
5

; 

Em 𝒦: 𝑝(∅) = 0, 𝑝(𝒦) = 1, 𝑝(𝛼) = 𝑝(𝛽) = 1
. 
2

Vamos mostrar que este criptossistema possui sigilo perfeito. Inicialmente, como a função de 

codificação  é  uma  permutação,  ela  pode  ser  definida  como  𝐸𝛼(𝑥) = 𝑌, 𝐸𝛼(𝑦) = 𝑋,       
𝐸𝛽(𝑥) = 𝑋 e 𝐸𝛽(𝑦) = 𝑌. Então, escolhe-se um texto comum, escolhe-se uma chave e efetua-

se a codificação. O diagrama de árvore abaixo mostra todas as possibilidades: 

 
Figura 20 – Diagrama de árvore para o problema do Exemplo 4.52 

151 

Fonte: Autoria própria 

Calculemos  as  probabilidades  𝑝(𝑥\𝑋), 𝑝(𝑥\𝑌), 𝑝(𝑦\𝑌)  e  𝑝(𝑦\𝑋).  Pelo  diagrama  anterior, 

esses cálculos ficam muito fáceis. Então, temos:  

𝑝(𝑥\𝑋) =

𝑝(𝑥 ∩ 𝑋)
𝑝(𝑋)

=

3

5
⋅ 1
2

⋅ 1
2
+ 2
5

3

5

𝑝(𝑥\𝑌) =

3

=

10
+ 2
10

3

10

=

3

10
5

10

=

3
5

= 𝑝(𝑥). 

= 𝑝(𝑥). 

⋅ 1
2

3
5

𝑝(𝑦\𝑋) =

𝑝(𝑦 ∩ 𝑋)
𝑝(𝑋)

=

2

5

2

𝑥 1
2
+ 3
5

2

10
+ 3
5

2

5

=

2
5

=

𝑥 1
2

= 𝑝(𝑦). 

5
𝑥 1
2

𝑝(𝑦\𝑌) =

2
5

= 𝑝(𝑦). 

As  probabilidades  acima  mostram  que  o  criptossistema  em  questão  possui  sigilo  perfeito. 

Veja  que  se  o  espaço  das  chaves  não  é  equiprovável,  então  o  criptossistema  não  possuirá 

sigilo perfeito. 

Exemplo  4.52  (One  –  time  Pad  de  Vernam)  One  –  time  Pad  de  Vernam  é  o  nome  de  um 

método de criptografia, com sigilo perfeito, inventado em 1917 por Gilbert Sandford Vernam 
(1890 - 1960)38. Este método é usado para codificar sequências de 𝑛 bits em sequências de 𝑛 

bits.  Ou  seja,  ele  codifica  sequências  com  𝑛  termos,  onde  cada  termo  é  1  ou  0,  em  outra 

sequência de  mesma espécie. O conjunto de todas as sequências de  𝑛 bits será representado 

pelo  símbolo  {0, 1}(𝑛).  Por  exemplo,  01011100  é  um  elemento  de  {0, 1}(8).  A  chave  de 

38 Engenheiro americano. 

 
 
 
    
    
                                                             
152 

codificação para o One – time Pad de Vernam também é uma sequência de 𝑛 bits. Escolhido o 

texto comum  𝑥 ∈ {0, 1}(𝑛) e a chave  𝑘 ∈ {0, 1}(𝑛), o texto cifrado 𝑐 correspondente a 𝑥 será 

obtido por 𝑐 = 𝑥 ⨁ 𝑘, sendo ⨁ uma operação no conjunto {0, 1} definida segundo a tabela a 

seguir: 

Tabela 16 – Operação com Números Binários 

𝑎 

0 

0 

1 

1 

𝑏 

0 

1 

0 

1 

𝑎⨁𝑏 

0 

1 

1 

0 

Fonte: Autoria própria 

Dadas  duas  sequências  de  𝑛  bits,  (𝑥1, 𝑥2, … , 𝑥𝑛)  e  (𝑦1, 𝑦2, … , 𝑦𝑛),  definimos 
(𝑥1, 𝑥2, … , 𝑥𝑛) ⨁ (𝑦1, 𝑦2, … , 𝑦𝑛) =   (𝑥1⨁𝑦1, 𝑥2⨁𝑦2, … , 𝑥𝑛⨁𝑦𝑛). Para decodificar 𝑐 usamos a 

mesma fórmula, pois  𝑐 ⨁ 𝑘 = (𝑥 ⨁ 𝑘) ⨁ 𝑘 = 𝑥 ⨁ (𝑘 ⨁ 𝑘) = 𝑥  ⨁ 0 = 𝑥, onde 0 representa 

a  sequência  nula  (0,  0,  0,  ...,  0)  de  {0, 1}(𝑛).  Assim,  por  exemplo,  se  𝑥 = 1001010 𝑒 𝑘 =

1101100, então 𝑐 = 0100110.  

Na  igualdade  𝑐 ⨁ 𝑘 = (𝑥 ⨁ 𝑘) ⨁ 𝑘 = 𝑥 ⨁ (𝑘 ⨁ 𝑘) = 𝑥 ⨁ 0 = 𝑥  usamos  o  fato  de 

que a operação ⨁ goza da propriedade associativa, e que o simétrico de qualquer elemento 𝑘 

é  ele  próprio.    Essas  propriedades  são  de  verificação  imediata.  Assim,  por  exemplo,  dado 

𝑘 ∈ {0, 1}(𝑛), seja  𝑘𝑖 o i-ésimo termo de  𝑘. Logo, 𝑘 ⨁ 𝑘 temo como  i-ésimo termo 𝑘𝑖 ⨁ 𝑘𝑖. 

Sendo que 𝑘𝑖 ∈ {0, 1}, se 𝑘𝑖 = 0, então 𝑘𝑖 ⨁  𝑘𝑖 = 0. Se 𝑘𝑖 = 1, então 𝑘𝑖 ⨁  𝑘𝑖 = 0. Portanto, 

os termos de 𝑘 ⨁ 𝑘 são todos iguais a zero, isto é, 𝑘 ⨁ 𝑘 = 0 = (0, 0, 0, ..., 0). 

O  Exemplo  4.51  está  ligado  diretamente  com  o  exposto  sobre  criptografia  e 

probabilidade  e,  juntamente  com  a  teoria  exposta,  serve  como  base  motivacional  para 

introduzir o assunto nas discussões sobre as aplicações de probabilidade. Já o Exemplo 4.52 

visa  apresentar  um  tipo  de  criptossistema  que  possui  sigilo  perfeito.  Para  trabalharmos  este 

último exemplo em aulas de matemática, podemos modificar o método apresentado de modo 

 
 
153 

a  torná-lo  mais  simples.  Como  sugestão,  poderíamos  pensar  em  representar  as  letras  do 

alfabeto através de sequências de bits distintas, digamos, com 5 bits. Assim, por exemplo, se o 

P  fosse  representado  por  10010, o  A  por  01011 e  o  Z  por  11001,  poderíamos  representar  a 

palavra PAZ como 10010.01011.11001. Usando 11010 como chave de codificação, a palavra 

PAZ  codificada  passaria  a  ser  representada  por  01000.10001.00010.  A  codificação  do 

alfabeto pode ser feita usando representação na base 2 (representação binária).  

Na  prática,  trabalha-se  com  algo  semelhante  em  computação,  onde  existem  os 
chamados  códigos  binários,  que  codificam  em  sequências  de  bits.39  Por  exemplo,  o  código 

ASCII (American Standard Code  for Information Interchange) é um tipo especial de código 

binário que codifica um total de 128 caracteres, entre letras latinas maiúsculas e minúsculas, 

sinais de pontuação, símbolos matemáticos, etc., em sequências de 7 bits. Nesta sequência de 

7 bits que representa cada símbolo, adiciona-se um novo bit para formar uma sequência de 8 

bits,  que  é  chamada  de  byte.  Na  tabela  a  seguir,  temos  uma  parte  dos  símbolos  do  código 

ASCII. Para mais informações, consulte as referências dadas em notas de rodapé nesta página. 

39 Conheça mais sobre códigos binários em:  
<https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_bin%C3%A1rio#:~:text=O%20sistema%
20bin%C3%A1rio%20ou%20de,natural%20%C3%A9%20o%20sistema%20bin%C3%A1rio>  e 
<https://www.portaleducacao.com.br/conteudo/artigos/nutricao/compreendendo-o-codigo-binario/48352 >.  
Acesso em: 09 jun. 2020. 

 
 
 
 
 
 
 
 
 
 
 
                                                             
154 

Tabela 17 – O Código ASCII 

Fonte: <http://vamosblablar.blogspot.com/2011/11/tabela-de-codigo-ascii.html>. 

Acesso em: 10 jun. 2020 

 
 
 
 
 
 
 
 
155 

5 CONSIDERAÇÕES FINAIS 

Tendo  como  tema  central  a  Criptografia,  o  presente  trabalho  se  empenhou  em 

desenvolver  e  investigar  a  relação  dessa  ciência  com  alguns  tópicos  de  matemática 

tradicionalmente abordados no ensino  básico. Diante do estudo realizado, ficou nítida que a 

relação entre matemática e criptografia pode ser uma importante aliada do professor nas suas 

aulas. 

A  criptografia  faz  parte  da  cultura  humana  desde  os  tempos  mais  remotos.  Como 

vimos, com o surgimento da criptografia de chave pública, a matemática passou a ser o pilar 

de sustentação de toda teoria que assegura confiança e segurança aos métodos criptográficos. 

Em  nível  elementar,  a  teoria  que  garante  a  segurança  imposta  pela  criptografia  deriva  de 

conceitos  simples  de  matemática  que  são  aprendidos  até  o  fim  do  Ensino  Médio.  Portanto, 

não  é  difícil  falar  de  criptografia  na  escola  e,  mais  ainda,  de  suas  aplicações  no  nosso 

cotidiano.  Ao  fazer  isso,  levamos  o  aluno  a  conhecer  essa  importante  inteligência  que  nos 

proporciona  a  segurança  necessária  nas  nossas  transações  bancárias,  comerciais,  compras  e 

trocas de mensagens pela internet, etc. Mais fundamental ainda é fazer com que o aluno seja 

levado a perceber o quão significativa é a matemática para nossa vida. Não é só uma questão 

de  explorar  determinados  conceitos  de  matemática  em  criptografia,  e  sim  educar  e  situar os 

estudantes no meio tecnológico e computacional o mais cedo possível. 

Nesse  sentido,  nosso  trabalho  frisou  três  pontos  principais  sobre  matemática  e 

criptografia: o contexto histórico, a aritmética básica e o método RSA, e métodos e conceitos 

elementares  de  criptografia  definidos  com  base  em  temas  da  matemática  do  Ensino  Médio. 

Tudo  isso  sempre  com  a  intenção  de  trabalhar  os  conteúdos  matemáticos  dentro  do  tema 

criptografia.  Isto  nos  possibilitou  ampliar  os  horizontes  de  nossa  imaginação  frente  às 

aplicações da matemática, pois a priori é difícil de imaginar como determinados temas, como 

Probabilidades, por exemplo, estejam relacionados com algo como criptografia. Essa relação 

inesperada  entre  determinados  conteúdos  de  matemática  e  criptografia  torna-se  elemento 

fundamental de inspiração, motivação e atração nas aulas de matemática.  

Para que nossos objetivos fossem alcançados e essa relação entre matemática básica e 

criptografia fosse desenvolvida da melhor forma possível de acordo com os propósitos deste 

trabalho, foi necessário desenvolver o tema de modo que o leitor (principalmente o professor) 

tivesse condições de introduzir a criptografia e tratá-la nos vários níveis da educação básica. 

 
156 

Assim,  numa excursão ao presente trabalho, iniciamos conhecendo um pouco da história da 

criptografia (é sempre bom começar um tema novo em nossas aulas tratando da sua história), 

como a mesma surgiu e como se desenvolveu ao longo do tempo. Neste caso, ao analisarmos 

a  história  da  criptografia,  também  aprendemos  os  conceitos  básicos  e  alguns  dos  métodos 

clássicos  dessa  ciência.  Sem  contar  que  é  por  meio  da  história  que  passamos  a  entender 

melhor porque a criptografia foi criada e porque ela foi responsável por enormes avanços na 

tecnologia das comunicações. De épocas de grandes Reis e Rainhas, passando pelas grandes 

Guerras  Mundiais,  até  a  modernidade  da  internet,  a  criptografia  sempre  foi  o  assunto 

dominante quando se tratava do sigilo nos envios de mensagens, sendo personagem principal 

de  vários  episódios  marcantes  na  história  da  humanidade.  É  sem  dúvidas  uma  ótima  ideia 

começar a falar de criptografia a partir de sua história. 

A aritmética básica surge em seguida no nosso estudo como requisito obrigatório para 

entender a funcionalidade de um dos métodos de criptografia mais importantes na atualidade, 

o RSA. Sem precisar expandir o estudo da Teoria Elementar dos Números, nos preocupamos 

em  apenas  frisar  aqueles  conceitos  mais  importantes  para  o  entendimento  do  RSA.  Desta 

forma, concluímos que muitos dos conceitos necessários para a compreensão do método RSA 

derivam  de  noções  simples  que  aprendemos  desde  cedo  na  escola,  como  Divisibilidade, 

Números  Primos  e  Máximo  Divisor  Comum.  Assim  sendo,  é  possível  tratar  a  relação  entre 

aritmética básica e criptografia sem ter um conhecimento avançado em matemática. Ou seja, 

como  deixamos  claro  no  trabalho,  é  possível  levarmos  a  discussão  sobre  criptografia  e 

matemática também para o ensino fundamental. Melhor ainda é o fato de que boa parte do que 

expomos  neste trabalho pode ser aplicado  nesta  fase do ensino, com algumas  modificações. 

Conclui-se então que criptografia e  matemática também pode ser tema a ser  bem trabalhado 

nas  aulas  de  matemática  no  ensino  fundamental,  expandindo  ainda  mais  as  utilidades  dessa 

relação no ensino. 

Finalizamos o nosso trabalho tratando de desenvolver o nosso objetivo principal que 

buscou relacionar determinados tópicos de  matemática do Ensino Médio com a criptografia. 

Vimos  que  assuntos  como  Matrizes,  Funções  Afins,  Funções  Quadráticas  e  Probabilidades 

são tópicos que aparecem  com  muita  frequência  nos estudos sobre criptografia. Destacamos 

esses  tópicos,  entre outros,  e  passamos  a  investigar  conceitos  e  métodos  criptográficos  com 

base  nos  mesmos.  Isso  fez  com  que  surgissem  as  relações,  e  aplicações,  dos  conteúdos 

matemáticos  na  criptografia.  Passamos  então  a  explorar  essas  relações  buscando  deixar 

 
157 

evidente  de  que  forma  o  conteúdo  em  questão  podia  ser  relacionado,  em  particular  com  o 

método criptográfico em questão.  

Desse modo, como mais um auxílio para o professor em sala de aula, desenvolvemos 

em algumas seções roteiros relacionados à aplicação de determinados métodos criptográficos 

na  codificação  de  mensagens.  Tais  roteiros  funcionam  como  guias  para  a  aplicação  de 

atividades envolvendo criptografia. No Capítulo 3 esse guia constitui-se dos Algoritmos 3.1 e 

3.2  que  ensinam,  passo  a  passo,  o  funcionamento  do  método  RSA  e,  portanto,  pode  ser 

utilizado para trabalhar este método com os alunos. No Capítulo 4 desenvolvemos guias para 

a utilização de métodos criptográficos relacionados a funções afins e quadráticas, Seções 4.2.1 

e 4.3.1, e matrizes, Seção 4.4.2. De modo geral,  fica claro que as relações apresentadas e os 

exemplos dados funcionarão como fonte principal de atividades (essa é a intenção) que serão 

elaboradas pelo próprio professor (e de acordo com o nível e experiência de cada turma) em 

sala de aula. Entretanto, é preciso destacar que tais atividades só serão bem confeccionadas e 

aplicadas se o professor estiver disposto a adentrar e estudar o tema criptografia e matemática 

na temática proposta por esse trabalho e nos trabalhos dados nas referências. Só assim ele será 

capaz de extrair essas aplicações do texto e agregá-las a suas aulas. 

Assim,  deste  breve  estudo  sobre  matemática  e  criptografia,  fica  a  certeza  de  que  a 

criptografia é um tema inovador em sala de aula (apesar de ser uma ciência bem antiga) que, 

corretamente  tratado,  fornece  ao  professor  uma  ferramenta  poderosíssima  para  melhorar  a 

qualidade  do  ensino  e  aprendizagem  em  matemática,  tornando  suas  aulas  mais  criativas, 

atrativas, com mais rendimentos e mais próxima da realidade do aluno. Os  benefícios para o 

aluno são inúmeros. Podemos inclui, entre outras coisas, o desenvolvimento do seu raciocínio 

lógico-dedutivo e de suas habilidades de resolução de problemas. Sem contar que trabalhar o 

tema criptografia na educação básica fornece uma ótima oportunidade para que o aluno possa 

ser inserido no campo dessas ciências que dominam a tecnologia da computação.   

Ao concluir um trabalho desta magnitude, esperamos acima de tudo que o mesmo seja 

útil. Em outras palavras, esperamos que o exposto aqui sirva de suporte para o professor para 

os fins a que foi destinado e que isto reflita em melhorias para o ensino de matemática, que é 

o  nosso  propósito.  Caso  contrário,  de  nada  valeu  tudo  isso.  Portanto,  esperamos  que  este 

estudo  abra  um  leque  de  possibilidades  e  sirva  de  base  motivacional  e  conceitual  para  o 

desenvolvimento de outros trabalhos que tratem de buscar novas estratégias para a  melhoria 

do  ensino  de  matemática  por  meio  da  criptografia.  E,  reiterando,  tudo  isso  só  será  bem 

 
158 

desenvolvido  (e  com  bons  resultados)  se  estivermos  dispostos  a  encarar  as  dificuldades  e 

procurar  sempre  estudar  e  explorar  o  tema  em  busca  de  elementos  que  possam  apontar 

caminhos para a criação de estratégias para abordar a criptografia em  sala de aula. De outra 

forma, essas ideias ficarão apenas no papel. 

Como  sugestão  para  trabalhos  futuros,  podemos  destacar  algumas  ideias  que 

certamente  seriam  bem  vindas  em  sala  de  aula.  No  ensino  fundamental  pode-se  facilmente 

trabalhar  a  história  da  criptografa  como  forma  de  inserir  os  alunos  nesse  nosso  tema. 

Animações em slides; confecções de dispositivos clássicos de criptografia; leituras de relatos 

históricos  envolvendo  trocas  secretas  de  mensagens  (como  a  história  de  Maria,  a  rainha  da 

Escócia,  veja  Singh  (2004));  utilização  de  filmes  com  o  tema  criptografia;  trabalhos  com 

cifras  primitivas;  etc.,  tudo  isso  leva  o  aluno  a  perceber  a  importância  da  criptografia  no 

passado e no presente e como a matemática ajudou no desenvolvimento de métodos cada vez 

mais seguros de codificação. As atividades envolvendo cifras clássicas e métodos primitivos 

de  criptografia  são  ótimas  alternativas  para  explicar,  na  prática,  como  os  mesmos 

funcionavam.  

No  ensino  médio,  o  presente  estudo  já  dá  inúmeras  sugestões  de  trabalhos  a  serem 

realizados com o tema criptografia. Como sugestão para testar o funcionamento dos métodos 

criptográficos  na  prática,  pode-se  pensar  na  implementação  de  alguns  deles,  na  forma  de 

algoritmos,  em  alguma  linguagem  de  programação.  Por  exemplo,  o  RSA,  por  meio  dos 

Algoritmos 3.1 e 3.2 pode ser implementado e com isso o aluno pode utilizá-lo na prática para 

codificar  mensagens.  Não  é  algo  simples,  pois  se  trata  do  RSA,  principal  sistema  de 

criptografia utilizado hoje em dia, mas já existem muitas referências de como fazer isso, e o 

professor de matemática, com ajuda de um profissional da computação, pode levar facilmente 

o RSA para a sala de aula.  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
159 

REFERÊNCIAS 

ALENCAR  FILHO, Edgard de.  Teoria Elementar dos Números. 3ª  ed. São Paulo: Nobel, 
1989. 

ALENCAR FILHO, Edgard de. Teoria Elementar dos Conjuntos. 13ª ed. São Paulo: Nobel, 
1972. 

BRANDÃO,  Mariana  Martins  Durões.  Uma  Adaptação  da  Cifra  de  Hill  para  Estudo  de 
Matrizes.  91f.  Dissertação  (Mestrado  Profissional  em  Matemática  em  Rede  Nacional  - 
PROFMAT), Universidade Federal de Ouro Preto, Ouro Preto/MG, 2017.  

BALESTRI, Rodrigo. Matemática 1: Interação e Tecnologia. 2ª ed. São Paulo: LEYA, 2016. 

BUCHMANN,  Johannes  A.  Introdução  à  Criptografia.  1ª  ed.  São  Paulo:  BERKELEY, 
2002. 

BESSELAAR, Jose’ Van Den. Heródoto, o pai da história. V. 24, n. 49, Jan./mar. 1962. (4 - 
26). 

BIANCHINI,  Edwaldo.    Matemática  Bianchini,  9º  ano.  9ª  ed.  São  Paulo:  MODERNA, 
2018. 

BRASIL,  Ministério  da  Educação.  Secretaria  de  Educação  Especial.  Grafia  Braille  para  a 
Língua Portuguesa. Brasília, DF: SEESP, 2006. 

BROUSSEAU, Guy. Fondement et Méthodes de la Didactique des Mathématiques. In J. 
Brun  (Ed),  Didactique  des  Mathématiques,  p.  45  –  144.  Lausanne:  Delachaux  et  Niestlê, 
1996.  Citado  por  PINHEIRO,  Felipa  Margarida  Dias  Lima.  Contextualização  do  Saber: 
Formação  Inicial  dos  Professores  de  1º  e  2º  Ciclo  do  Ensino  Básico.  159f.  Dissertação 
(Mestrado em Ciências da Educação), Universidade de Lisboa, Instituto de Educação, Lisboa, 
2012.  

BROOKSHEAR, J. Glenn. Ciência da Computação: uma visão abrangente. 11ª ed. Porto 
Alegre: BOOKMAN, 2013. 

BRASIL. Base Nacional  Comum Curricular: Ensino Médio. Brasília:  MEC/Secretaria de 
Educação Básica, 2017. 

CARNEIRO,  Framilson  José  Ferreira.  Criptografia  e  Teoria  dos  Números.  1ª  ed.  Rio  de 
Janeiro: CIÊNCIA MODERNA, 2017. 

COUTINHO,  S.  C.  Números  Inteiros  e  Criptografia  RSA.  2ª  ed.  Rio  de  Janeiro:  IMPA, 
2005. 

COUTINHO, S. C. Criptografia. Programa de Iniciação Científica da OBMEP. 1ª ed. Rio de 
Janeiro: IMPA/OBMEP, 2009. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
160 

COSTA,  Renata.  Como  funciona  o  código  Braille?  Nova  Escola,  2009.  Disponível  em: 
<https://novaescola.org.br/conteudo/397/como-funciona-sistema-braille>.  Acesso em: 19 out. 
2019. 

DANTE, Luiz Roberto. Matemática, 1ª série. 1ª ed. São Paulo: Ática, 2006. 

DANTE, Luiz Roberto. Matemática, volume único. 1ª ed. São Paulo: Ática, 2011. 

DAINEZE, Kelly Cristina Santos Alexandre de Lima.  Números Primos e Criptografia: da 
relação  com  a  educação  ao  sistema  RSA.  56f.  Dissertação  (Mestrado  Profissional  em 
Matemática em Rede Nacional - PROFMAT), Universidade Federal Rural do Rio de Janeiro, 
Seropédica/RJ, 2013. 

FIARRESGA,  Victor  Manuel  Calhabrês.  Criptografia  e  Matemática,  2010.  161f. 
Dissertação  (Mestrado  em  Matemática  para  Professores)  –  Faculdade  de  Ciências  – 
Universidade de Lisboa, Lisboa, 2010.  

FREITAS,  Rosiane  de.  et  al.  Cifra  de  César  –  Princípios  de  criptografia  como  trote 
educacional 
em: 
ao 
<http://cleilaclo2018.mackenzie.br/docs/LAWCC/188504.pdf>. Acesso em: 10 set. 2019. 

da  mulher.  Disponível 

comemoração 

dia 

em 

e 

FRANÇA,  Waldizar  Borges  de  Araújo.  A  utilização  da  Criptografia  para  uma 
Aprendizagem Contextualizada e Significativa. 63f. Dissertação (Mestrado Profissional em 
Matemática), Universidade de Brasília - UNB, Brasília, 2014.  

FRANCISCO,  Wagner de  Cerqueria e. Código Morse. Brasil Escola, 2019. Disponível em: 
<https://brasilescola.uol.com.br/geografia/codigo-morse.htm>. Acesso em 29 out. 2019. 

GIOVANNI  JÚNIO, José  Ruy; CASTRUCCI, Benedicto.  A Conquista da Matemática, 9º 
ano. 4ª ed. São Paulo: FTD, 2018. 

HOWARD,  Anton;  RORRES,  Chris.  Álgebra  linear  com  aplicações.  8  ed.  Porto  Alegre: 
Bookman, 2001. 

HEFEZ, Abramo. Curso de Álgebra, vol. 1. 5ª ed. Rio de Janeiro: IMPA, 2014.  

IEZZI, Gelson; DOLCE, Osvaldo; DEGENSZAJN, David; PÉRIGO, Roberto.  Matemática, 
volume único. 1ª ed. São Paulo: ATUAL, 2002. 

IEZZI, Gelson; HAZZAN, Samuel.  Fundamentos de Matemática Elementar, vol.4. 7ª ed. 
São Paulo: ATUAL, 1993. 

JULIO,  Eduardo  Pagani;  BRAZIL,  Wagner  Gaspar;  ALBUQUERQUE,  Célio  Vinicius 
Neves. Esteganografia e Suas Aplicações. In:      . VII Simpósio Brasileiro em Segurança 
da Informação e de Sistemas Computacionais: Livro Texto dos Minicursos. Brasília, DF: 
Sociedade Brasileira de Computação – SBC, 2007. p. 54 – 102. 

JESUS,  André  Luís  Neris  de.  Criptograﬁa  na  Educação  Básica:  utilização  da  criptograﬁa 
como  elemento  motivador  para  o  ensino  aprendizagem  de  matrizes.  82f.  Dissertação 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
161 

(Mestrado  Proﬁssional  em  Rede  Nacional  em  Matemática  -  PROFMAT),  Universidade 
Federal do Vale do São Francisco, Juazeiro/BH, 2013. 

LIMA,  Elon  Lages;  CARVALHO,  Paulo  Cezar  Pinto;  WAGNER,  Eduardo;  MORGADO, 
Augusto César. A Matemática do Ensino Médio, vol. 1. 9ª ed. Rio de Janeiro: SBM, 2006. 

LIMA,  Elon  Lages;  CARVALHO,  Paulo  Cezar  Pinto;  WAGNER,  Eduardo;  MORGADO, 
Augusto César. A Matemática do Ensino Médio, vol. 2. 6ª ed. Rio de Janeiro: SBM, 2006. 

LIMA, Elon Lages. Curso de Análise, vol. 1. 14ª ed. Rio de Janeiro: IMPA, 2013. 

LOUREIRO,  Flávio  Ornellas.  Tópicos  de  Criptografia  para  o  Ensino  Médio.  43f. 
Dissertação  (Mestrado  em  Matemática)  Universidade  Estadual  do  Norte  Fluminense  Darcy 
Ribeiro – UENF. Campos dos Goytacazes/RJ, 2014.  

MALAGUTTI,  Pedro  Luiz.  Atividade  de  Contagem  a  Partir  da  Criptografia.  Rio  de 
Janeiro: IMPA, 2015. 

MEDEIROS, Willa da Silva. Números Primos e Criptografia RSA: uma descrição da mais 
bela  relação  em  teoria  dos  números.  70f.  Monografia  (Licenciatura  Plena  em  Matemática), 
Universidade do Estado do Rio Grande do Norte – UERN. Patu/RN, 2017. 

MARTINEZ,  Fábio  Brochero;  MOREIRA,  Carlos  Gustavo;  SALDANHA,  Nicolau; 
TENGAN,  Eduardo.  Teoria  dos  Números:  um  passeio  com  primos  e  outros  números 
familiares pelo mundo inteiro. 2ª ed. Rio de Janeiro: IMPA, 2013. 

MONTEIRO, Luiz H. Jacy. Elementos de Álgebra. Rio de Janeiro: AO LIVRO TÉCNICO, 
1969. 

PORTO,  Gabriella.  Código  Morse.  Info  Escola,  [entre  2006  e  2019].  Disponível  em:              
< https://www.infoescola.com/comunicacao/codigo-morse/>. Acesso em: 19 out. 2019. 

PELLEGRINI,  Gerônimo.  Introdução  à  Criptografia  e  seus  Fundamentos,  29  de  nov.  de 
2019. 411f. Notas de aula. 

PEREIRA,  Nádia  Marques  Ikeda.  Criptografia:  uma  nova  proposta  de  ensino  de 
matemática  no  ciclo  básico.  76f.  Dissertação  (Mestrado  Profissional  em  Matemática  em 
Rede Nacional - PROFMAT), Universidade Estadual Paulista “Júlio de Mesquita Filho”, Ilha 
Solteira/SP, 2015.  

SANTOS, José Plínio de Oliveira. Introdução à teoria dos Números. 3ª ed. Rio de Janeiro: 
IMPA, 2014. 

SOUSA,  Lana  Priscila.  Criptografia  RSA:  A  teoria  dos  números  posta  em  prática.  75f. 
Dissertação  (Mestrado  Profissional  em  Matemática  em  Rede  Nacional  -  PROFMAT), 
Universidade Federal do Ceará, Fortaleza/CE, 2015.  

SPINA,  André  Vinícius.  Números  primos  e  criptografia.  52f.  Dissertação  (Mestrado  em 
Matemática), Universidade Estadual de Campinas, São Paulo, 2014. 

 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
162 

OKUMURA,  Mirella  Kiyo.  Números  Primos  e  Criptografia  RSA.  54f.  Dissertação 
(Programa de Mestrado Profissional em Matemática), Instituto de Ciências  Matemática e de 
Computação – ICMC, Universidade de São Paulo, São Paulo/SP, 2014. 

SAUTOY,  Marcus  Du.  A  música  dos  números  primos:  a  história  de  um  problema  não 
resolvido na matemática. Rio de Janeiro: ZAHAR, 2007. 

SHOKRANIAN, Salahoddin. Criptografia Para Iniciantes. Brasília: UNB, 2005.  

SINGH, Simon. O livro dos códigos. 4ª ed. Rio de Janeiro: Record, 2004. 

TERADA,  Routo.  Segurança  de  Dados:  criptografia  em  redes  de  computador.  São  Paulo: 
EDGARD BLÜCHER LTDA, 2000.  

TAVARES, Naiara Pereira; FELIX, Francisca Edna Ferreira; GONÇALVES, Maria Cassiana 

Pereira; CORDEIRO JUNIOR, Reginaldo  Amaral. Criptografia: uma  ferramenta de ensino 

das  operações  matriciais.  In:  IV  CONGRESSO  NACIONAL  DE  EDUCAÇÃO,  2017,       

João 

Pessoa/PB. 

Anais... 

João 

Pessoa/PB: 

REALIZE, 

2017.        

 
 
 
 
 
 
 
 
 
