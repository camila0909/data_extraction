 UNIVERSIDADE FEDERAL DO CEARÁ 

CENTRO DE CIÊNCIAS 

DEPARTAMENTO DE MATEMÁTICA 

PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA EM REDE NACIONAL 

FRANCISCO ALBERTO CAVALCANTE DE CASTRO 

O MÉTODO BIJETIVO E A FÓRMULA DE CAYLEY SOBRE ÁRVORES 

FORTALEZA 

2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
FRANCISCO ALBERTO CAVALCANTE DE CASTRO 

O MÉTODO BIJETIVO E A FÓRMULA DE CAYLEY SOBRE ÁRVORES 

Dissertação  apresentada  ao  Programa  de  Pós-
Graduação  em  Matemática  em  Rede  Nacional 
em  Ensino  da  Matemática  da  Universidade 
Federal do Ceará em parceria com a Sociedade 
Brasileira  de  Matemática,  como  requisito 
parcial  à  obtenção  do  título  de  Mestre  em 
Matemática.  Área  de  concentração:  Ensino  da 
Matemática. 

Orientador:  Prof.  Dr.  Fabrício  Siqueira 
Benevides. 

FORTALEZA 

2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
FRANCISCO ALBERTO CAVALCANTE DE CASTRO 

O MÉTODO BIJETIVO E A FÓRMULA DE CAYLEY SOBRE ÁRVORES 

Dissertação  apresentada  ao  Programa  de  Pós- 
Graduação  em  Matemática  em  Rede  Nacional 
em  Ensino  da  Matemática  da  Universidade 
Federal do Ceará em parceria com a Sociedade 
Brasileira  de  Matemática,  como  requisito 
parcial  à  obtenção  do  título  de  Mestre  em 
Matemática.  Área  de  concentração:  Ensino  da 
Matemática. 

Orientador:  Prof.  Dr.  Fabricio  Siqueira 
Benevides. 

Aprovada em: 25/10/2018. 

BANCA EXAMINADORA 

________________________________________ 

Prof. Dr. Fabrício Siqueira Benevides (Orientador) 

Universidade Federal do Ceará (UFC) 

_________________________________________ 

Prof. Dr. Marcelo Ferreira de Melo 

Universidade Federal do Ceará (UFC) 

_________________________________________ 

Prof. Dr. Ulisses Lima Parente 

Universidade Estadual do Ceará (UECE) 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Aos  meus  pais,  Elena  e  José  Bento,  pelo  amor,  apoio  e  ajuda  incondicional 

durante toda a sua vida.  

À  minha  filha  Maitê  e  à  minha  esposa  Cleciane  pelo  amor,  incentivo  e  apoio 

incondicional. Amigas amorosas de todas as horas. 

Aos meus irmãos Alex Márcio e Joselena, por sempre estarem ao meu lado. 

À minha sogra e meu sogro, Conceição e Geraldo, por terem me abraçado como 

um filho. 

orientação. 

Ao Sr. Edmilson Moreira, que por toda a minha vida, foi pai e amigo.  

Ao  Prof.  Dr.  Fabrício  Siqueira  Benevides,  pela  compreensão  e  excelente 

Aos  meus  amigos  que  sempre  me  proporcionaram,  além  de  lazer,  momentos  de 

reflexão e união.  

Aos  professores,  Dr.  Juvêncio  Nobre  e  Dr.  Mauricio  Mota,  do  departamento  de 
Estatística  da  Universidade  Federal  do  Ceará,  que  marcaram  minha  vida,  sendo  base  para 
minha formação como graduado e certamente, contribuíram de forma intensiva para a minha 
formação como ser humano.  

Aos meus colegas de trabalho da Escola Ageu Romero e do Centro Integrado de 
Ensino de Paraipaba. Em especial aos professores Josielson Melo e Wilker Moreira, que além 
de amigos, foram meus dois influenciadores e exemplos no colegiado.  

À CAPES, pelo apoio financeiro com a manutenção da bolsa de auxílio. 

À CREDE 2, de Itapipoca, e a toda gestão da Escola Ageu Romero, na pessoa do 

então diretor Hildeberto Lima, por me cederem tempo para a conclusão deste trabalho. 

À  gestão  do  Centro  Integrado  de  Ensino  de  Paraipaba,  em  especial  ao  Diretor 

Itamar Marques, pela compreensão durante todo o curso. 

Aos  professores  participantes  da  banca  examinadora,  Prof.  Dr.  Marcelo  Ferreira 
de  Melo  e    Prof.  Dr.  Ulisses  Lima  Parente  pelo  tempo,  pelas  valiosas  colaborações  e 
sugestões. 

Aos colegas da turma de mestrado, pelas reflexões, críticas e sugestões recebidas. 

Em especial, ao meu grande amigo Daniel Mitchel.  

Aos  meus  professores  do  ensino  fundamental  e  do  ensino  médio  pelo  ensino  de 

qualidade que me proporcionaram.  

 
 
 
 
 
“De que me irei ocupar no céu, durante toda a eternidade, 

se  não  me  derem  uma  infinidade  de  problemas  de 

Matemática  para 

resolver?” 

(AUGUSTIN  LOUIS 

CAUCHY) 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

O objetivo deste trabalho é apresentar o Princípio Bijetivo como método de contagem e usá-lo 

para demonstrar a fórmula da Cayley sobre a quantidade de árvores rotuladas com um dado 

conjunto de vértices.  Esse é um  método interessante de contagem  que  consiste em  observar 

que  a  existência  de  uma  bijeção  entre  dois  conjuntos  finitos  implica  que  tais  conjuntos 

possuem  a  mesma  quantidade  de  elementos.  Para  entende-lo  melhor,  faremos  um  breve 

revisão  sobre  funções  e,  sem  seguida,  apresentamos  várias  aplicações.  E  para  entender  a 

fórmula  de  Cayley  precisamos  apresentar  alguns  conceitos  introdutórios  sobre  Teoria  dos 

Grafos. A prova dessa fórmula é feita usando o chamado Código de Prüfer, que também será 

apresentado aqui. 

Palavras-chave: Teorema de Cayley. Árvores. Grafos. Princípio bijetivo. 

 
 
 
 
 
ABSTRACT 

The goal of this thesis if to present the Bijective Principle as a method for counting and use it 

to prove Cayley’s formula about the number of labeled trees on a given set of vertices. This 

method  is  an  interesting  counting  technic  that  relies  on  the  fact  that  whenever  there  is  a 

bijection between two finite sets, they must have the same number of elements. To understand 

this in details, we will first briefly review the concept of function and we shall present various 

applications. And to understand Cayley’s formula we will need to present some introductory 

concepts from Graph Theory. The proof that Cayley’s formula hold uses the so called Prüfer’s 

Code, that we will also present here.  

Keywords: Cayley's theorem. Trees. Graphs. Bijective principle. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÁRIO 

1    INTRODUÇÃO .................................................................................................................. 9 

2    FUNÇÃO BIJETIVA ........................................................................................................ 10 

3    PRINCÍPIO BIJETIVO ................................................................................................... 12 

4    GRAFOS ........................................................................................................................... 22 

4.1 História dos grafos ............................................................................................................ 22 

4.2 Definição e conceitos básicos de grafos ........................................................................... 26 

5    TEOREMA DE CAYLEY ................................................................................................ 29 

5.1 O Código de Prüfer .......................................................................................................... 30 

5.2 Prova do Teorema de Cauley usando Código de Prüfer ............................................... 34 

5.3 Outros resultados .............................................................................................................. 35 

6    CONCLUSÃO ................................................................................................................... 36 

      REFERÊNCIA .................................................................................................................. 38 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
9 

1 INTRODUÇÃO 

Este trabalho visa apresentar uma prova do teorema de Cayley sobre a quantidade de 

árvores  geradoras  de  um  grafo  rotulado,  assim  como  a  resolução  de  outros  problemas  que 

envolvem o método do principio bijeitvo. Para isso, revisamos  os  conceitos de função,  com 

foco  em  definir  o  conceito  de  bijeção  para  depois,  introduzirmos  o  principio  bijetivo.  Ao 

longo  do  estudo,  abordaremos  cada  um  destes  temas  em  capítulos  diferentes,  para  enfim, 

introduzirmos o chamado Código de Prüfer e utilizá-lo para provar o teorema de Cayley.  

No segundo capítulo serão introduzimos conceitos essenciais relacionados a funções, 

com ênfase na apresentação do conceito de bijeção. 

No  terceiro  capítulo  escreveremos  sobre  o  Princípio  Bijetivo  como  método  de 

contagem.  Este  método  é  apresentado  por  meio  de  aplicações,  e  também  é  utilizado  na 

resolução de situações problema.  

No  quarto  capítulo  introduziremos  as  principais  definições  e  propriedades  sobre 

grafos, para que possamos entender o enunciado do Teorema de Cayley. Grafos são estruturas 

combinatórias que possuem inúmeras aplicações, por exemplo, na ciência da computação e no 

estudo  de  redes  complexas,  inclusive  redes  sociais.  O  objetivo  aqui  é  apresentar  apenas  os 

conceitos básicos, como a definição de árvore geradora e grafo rotulado, haja vista que esse 

conhecimento é essencial para o estudo aqui apresentado. 

No quinto capítulo, faremos uma apresentação do Código de Prüfer, que é usado para 

codificar a estrutura de uma árvore com n vértices em uma sequência de n-2 naturais de 1 até 

n. Mostramos como codificar e decodificar tais árvores para, enfim, utilizá-lo juntamente com 

todos  os  conhecimentos  obtidos  nos  capítulos  anteriores  para  provar  a  fórmula  de  Cayley. 

Apresentamos também algumas variações e generalizações do Teorema de Cayley.  

 
 
 
 
 
10 

2 FUNÇÃO BIJETIVA 

Neste  capítulo,  admitiremos  que  o  leitor  possui  conhecimento  prévio  de  teoria  dos 

conjuntos e suas operações elementares. Introduziremos a linguagem de função.  

Uma  função  𝑓  é  uma  lei  que  para  cada  elemento  𝑥  em  um  conjunto  𝐴 chamado 

domínio,  faz  corresponder  exatamente  um  elemento,  chamado  de  imagem  de  𝑥  por  𝑓  e 

denotado por 𝑓(𝑥), em(pertencente) um conjunto 𝐵, chamado contradomínio. A formalização 

matemática para a definição de função é dada da seguinte maneira.  

Dados dois conjuntos 𝐴 e 𝐵 não vazios, uma função 𝑓: 𝐴 → 𝐵 (lê-se  𝑓 de 𝐴 em 𝐵) é 

uma lei que associa a cada elemento 𝑥 ∈ 𝐴, um único elemento 𝑦 = 𝑓(𝑥) ∈ 𝐵. 

Também podemos pensar em um função como o conjunto de pares ordenados (𝑥, 𝑦) 

pertencentes a 𝐴 × 𝐵, tais que 𝑦 é o elemento associado a 𝑥. Em símbolos, em toda função, as 

duas condições abaixo devem ser satisfeitas: 

(𝑖) (𝑥, 𝑦1) ∈ 𝑓  e  (𝑥, 𝑦2) ∈ 𝑓   ⇒   𝑦1 =   𝑦2 ; 

(𝑖𝑖) ∀ x ∈ 𝐴; ∃ y  ∈ 𝐵:  (𝑥, 𝑦) ∈ 𝑓. 

Uma função 𝑓 é denominada injetiva quando, para todos 𝑥1 ∈ 𝐴 e x2 ∈ 𝐴, temos que 
se  𝑓(𝑥1) = 𝑓(𝑥2)  então  𝑥1 = 𝑥2.  Isso  é  equivalente  a  dizer  que  se  𝑥1 ≠ 𝑥2  então  𝑓(𝑥1) ≠

𝑓(𝑥2). 

Uma função 𝑓 é denominada de sobrejetiva quando, para qualquer 𝑦 ∈ 𝐵 existe pelo 

menos um 𝑥 ∈ 𝐴 tal que 𝑓(𝑥) = 𝑦.  

Quando  uma  função  𝑓  é  sobrejetiva  e  injetiva  ao  mesmo  tempo  a  chamamos  de 

função  bijetiva  e  também  dizemos  que  há  uma  relação  biunívoca  entre  o  domínio  e  o 

contradomínio da função.  

Em  outras  palavras,  todo  elemento  pertencente  ao  domínio  de  uma  função  bijetiva 

está relacionado a um único elemento de seu contradomínio e vice-versa.  

Um  exemplo  de  função  bijetiva  é  a  função  𝑓: 𝐴 → 𝐴, que  tem  como  sua  lei  de 

formação  𝑓(𝑥) = 𝑥,  onde  𝐴  é  um  conjunto  não  vazio  qualquer.  Nesta  função,  a  imagem  de 

cada elemento é o próprio elemento. Ela é chamada de função identidade. 

Como exemplo de função não bijetiva temos a função 𝑓: ℝ → ℝ , onde ℝ é conjunto 

dos números reais  e  𝑓(𝑥) = 𝑥2 para todo  𝑥 em  ℝ. Em particular temos  𝑓(−1) = (−1)2 =

1  e 𝑓(1) =   12 = 1. Ou seja, existem dois valores, tais que suas imagens são iguais, logo a 

função  não  é  injetiva  e,  portanto,  não  é  bijetiva.  Note  que  usamos  𝑓(−1)  e  𝑓(1)  como 

 
 
11 

exemplo particular e isso é suficiente para justificar o fato da função não ser injetiva. Porem, 

neste caso, existe uma infinidade de valores que evidenciam o fato da função não ser injetiva 

(e portanto, não ser bijetiva).  

Vejamos  a  função  𝑓: ℕ → ℤ  onde  𝑓(𝑥) = 𝑥.  Observe  que  esta  função  não  é 

sobrejetiva, haja vista que não há valor em ℕ associado a valor negativo em ℤ. E, portanto, ela 

não  é  sobrejetiva.  Apesar  de  sua  lei  de  formação  ser  igual  à  da  função  identidade,  aqui  o 

contradomínio não é igual ao domínio. 

Vamos  mostrar,  em  seguida,  que  se  𝑓: 𝐴 → 𝐵  é  bijetiva  então  existe  g: 𝐵 → 𝐴 

bijetiva.  

De  fato,  como  𝑓  é  bijetiva,  em  particular  𝑓  é  sobrejetiva.  Logo,  dado  qualquer 

elemento  𝑏  de  𝐵,  existe  algum  𝑎  de  𝐴  tal  que  𝑓(𝑎) = 𝑏.  Como  𝑓  é  também  injetiva,  𝑎  é 

único; isto é, 𝑎 é o único elemento  de  𝐴 com  a propriedade de que  𝑓(𝑎) = 𝑏. Ou seja, não 

existe ambiguidade. Esse elemento 𝑎 será chamado 𝑔(𝑏), ou seja, definimos 𝑔(𝑏) = 𝑎. Essa 

regra associa cada elemento de 𝐵 a um único elemento de 𝐴, em outras palavras, define uma 

função 𝑔: 𝐵 → 𝐴. Esta função é chamada inversa de 𝑓 e é comumente denotada por 𝑓−1. 

Sempre  que  uma  função  for  bijetiva,  existe  uma  função  que  faz  exatamente  o 

contrário da função original, levando os elementos do conjunto 𝐵 aos elementos do conjunto 

𝐴, e a esta função damos  o nome de função inversa. Podemos dizer  que se uma função  𝑓 é 

bijetiva, se somente se, é invertível.  

Para  aprofundar-se  um  pouco  nos  estudos  de  funções,  recomendamos  a  leitura  do 

capitulo  inicial  do    livro  Curso  de  análise  vol.  1,  do  brasileiro  Elon  Lages  Lima  (1919  – 

2017). 

 
 
 
12 

3 PRINCÍPIO BIJETIVO 

Neste trabalho, o conceito de bijeção será aplicado na contagem de elementos de um 

conjunto. A contagem teve seu inicio, praticamente quando surgiu a humanidade, pois desde 

então, se fez necessário uma contagem, embora primitiva, de algumas coisas. O exemplo das 

pedrinhas para contar carneiros, foi uma maneira encontrada de contar fazendo comparações. 

Havia  ali  uma  bijeção  entre  o  conjunto  das  pedrinhas  e  o  conjunto  dos  carneiros.  Eis  o 

princípio  bijetivo.  Isso  porque,  usamos  como  postulado  que  a  existência  de  uma  função 

bijetiva  entre  dois  conjuntos  finitos  implica  que  esses  dois  conjuntos  possuem  a  mesma 

quantidade  de  elementos.  Em  geral,  a  existência  da  bijeção  entre  dois  conjuntos  quaisquer 

implica que eles possuem a mesma cardinalidade. Vejamos a seguinte situação. 

Em  uma  sala  de  aula,  há  um  determinado  número  de  assentos.  Um  grupo  de 

estudantes entra na sala e o instrutor pede para todos sentarem. Depois de uma rápida olhada 

ao  redor  da  sala,  o  instrutor  declara  que  há  uma  bijeção  entre  o  conjunto  de  alunos  e  o 

conjunto de assentos, onde cada aluno está emparelhado com o assento onde está sentado. O 

que o instrutor observou para chegar a essa conclusão foi o seguinte: 

1.  Cada aluno está em algum assento (não havia ninguém em pé); 

2.  Nenhum aluno está em mais de um assento; 

3.  Cada assento tem alguém sentado nele (não havia assentos vazios); e  

4.  Nenhum assento tem mais de um aluno.  

O  instrutor  concluiu  que  a  quantidade  de  assentos  é  igual  à  quantidade  de  alunos, 

sem ter que contar nenhum dos conjuntos.  

Se houver uma bijeção entre dois conjuntos finitos então eles têm o mesmo número 

de elementos.  

Muitos  conjuntos,  para  os  quais  parece  ser  difícil  contar  a  quantidade  de  seus 

elementos  diretamente,  podem  ser  facilmente  analisados  e  terem  seus  elementos  contados, 

mapeando-os de forma bijetiva para outro conjunto que pode ter seus elementos contados de 

forma  mais  simples.  Esta  é  uma  ideia  muito  usada  e  sugere  que:  “se  parece  difícil  contar  o 

número de elementos de um conjunto, tente encontrar uma representação dele que seja mais 

simples”.  

Uma  bijeção  também  pode  ser  referida  como  uma  mudança  de  variável,  pois  uma 

mudança  de  variável  é  uma  técnica  básica  usada  para  simplificar  problemas  nos  quais  as 

 
 
 
13 

variáveis  originais  são  substituídas  por  outras  variáveis. A  intenção  é  que,  quando  expresso 

em novas variáveis, o problema possa se tornar mais simples, ou equivalente a um problema 

já estudado anteriormente ou melhor compreendido. 

Como  um  segundo  exemplo,  podemos  imaginar  que,  em  uma  situação,  temos  um 

determinado  número  de  chaves  e  também  de  cadeados.  Se  cada  chave  abre  exatamente  um 

cadeado do grupo e cada cadeado é aberto por exatamente uma dessas chaves, então há uma 

bijeção, pois a cada chave está associada a um e apenas um cadeado e vice-versa. Logo, pelo 

princípio bijeitvo, o número de cadeados é igual ao número de chaves. 

Usando uma linguagem  técnica, podemos  enunciar o principio bijetivo  da maneira 

descrita  a  seguir.  Para  um  conjunto  qualquer  A,  usaremos  a  notação  |𝐴|  para  representar  o 

número cardinal que expressa o tamanho do conjunto A.  

 Sejam  𝐴  e  𝐵  conjuntos  não  vazios.  Temos  que  |𝐴| = |𝐵|  se,  e  somente  se,  existe 

𝑓: 𝐴  → 𝐵, tal que 𝑓 é bijetiva. 

Lembramos também que um conjunto 𝐴 é dito finito se 𝐴 é vazio (conjunto que não 

possui  elementos)  ou  existe  uma  função  𝑓: 𝐼𝑛 → 𝐴  que  é  bijetiva  onde  𝐼𝑛  é  o  conjunto  dos 
números naturais de 1 até n, para algum natural n. Neste caso, teremos |𝐴| = |𝐼𝑛| = 𝑛.   

Vejamos alguns exemplos de aplicação do princípio bijetivo para contagem.     

Exemplo 1:  

Quantas sequências de 5 algarismos podem ser feitas com os dígitos 1, 8, 9 em que 

o digito 1 aparece exatamente três vezes e os demais aparecem uma vez?  

Para  solucionar  este  problema,  vamos  estabelecer  uma  função  que  associe  a  cada 

sequência que satisfaz o enunciado a uma outra sequência de (apenas) dois dígitos distintos do 

conjunto {1, 2, 3, 4, 5}, onde o primeiro digito indica a posição do 8 na sequência original e o 

segundo digito indica a posição do 9.  

Vejamos  a  sequência  (1, 8, 1, 1 , 9).  Veja  que  o  número  8  ocupa  a  posição  2,  e  o 

número  9  ocupa  a  posição  5.  Portanto  a  sequência  (1, 8, 1, 1 , 9)  está  associada  à  sequência 

(2, 5).  Assim  definimos  uma  função  𝑓: 𝐴  → 𝐵  onde  𝐴  é  o  conjunto  formado  por  todas 

sequências que satisfazem o enunciado e 𝐵 = {(𝑎, 𝑏) ∶ 𝑎 ≠ 𝑏, 𝑎, 𝑏  ∈ {1,2, … , 5}}. 

Para concluirmos que existe uma bijeção entre 𝐴 e 𝐵, basta mostrarmos que a função 

𝑓: 𝐴 → 𝐵 é invertível. Para isso basta perceber que, ao mesmo tempo em que cada sequência 

 
 
 
 
 
 
14 

de 5 dígitos está associada a uma única sequência de  2 dígitos, cada sequência de  2 dígitos 

está associada a uma única sequência de 5 dígitos. Pois sabendo as posições dos dígitos 8 e 9, 

os demais dígitos  da sequencia  original  são iguais  a 1. Assim,  uma sequência  do enunciado 

não pode gerar duas ou mais sequências de 2 dígitos diferentes, assim como uma sequência de 

2  dígitos  não  pode  gerar  duas  ou  mais  sequências  diferentes  de  5  dígitos  que  satisfazem  o 

enunciado. Portanto, a função é invertível, sendo assim, bijetiva. 

Como  a  quantidade  de  elementos  do  conjunto  𝐵  é  fácil  de  ser  contada,  tendo  ele 

exatamente  5 · 4 = 20 elementos,  pelo  principio  bijetivo,  o  conjunto  𝐴  possui  a  mesma 

quantidade de elementos do conjunto 𝐵, totalizando 20 elementos. 

Logo concluímos que existem 20 sequências que satisfazem o enunciado.  

 □ 

Observação:  uma  maneira  alternativa  que  resolver  o  problema  acima  é  usando  a 

fórmula  de  permutações  com  elementos  repetidos.  A  vantagem  da  solução  acima  é  que  não 

requer  este  conhecimento,  mas  ela  não  funciona  a  todos  os  problemas  de  permutação  com 

elementos repetidos.  

Outro exemplo de aplicação direta do principio bijetivo é mostrado a seguir. 

Exemplo 2:  

Em  um  torneio  de  futebol,  1500  equipes  competem  entre  si.  Os  organizadores 

informam às equipes que cada jogo deve ter um vencedor (ou seja, não há empates) e que a 

equipe que perde um jogo é imediatamente excluída do torneio. Quantos jogos serão jogados 

até o campeão ser conhecido? 

Queremos concluir que o número de jogos neste campeonato não depende da ordem 

ou  da  maneira  em  que  acontecem  os  confrontos.  Vamos  considerar  dois  conjuntos.  Um 

conjunto 𝐴, cujos elementos são todos os jogos em uma determinada edição do campeonato 

(até o campeão ser conhecido) e um conjunto 𝐵, que contém todos os perdedores até fim do 

último jogo. Veja que a escolha do conjunto 𝐵 não foi arbitrária, pois queremos mostrar que o 

número de elementos nos conjuntos 𝐴 e 𝐵 são iguais. Vejamos um exemplo com 4 times.  

Se temos quatro times, X, Y, Z, W então teremos 3 times que perderão em algum dos 

jogos  pois  apenas  um  time  é  campeão.  Digamos  que  X  foi  o  campeão  após  a  seguinte 

sequência de jogos. O time X ganha no jogo X contra Y. O time Z ganha no jogo Z contra W. 

O time X ganha no jogo X contra Z. Neste caso, aconteceram exatamente 3 jogos, logo 𝐴  =

 {{𝑋, 𝑌}, {𝑍, 𝑊}, {𝑋, 𝑍}}  e  há  3  times  que  perderam  em  algum  jogo,  logo  𝐵 = {𝑌, 𝑍, 𝑊}.  E 

temos uma função bijetiva 𝑓: 𝐴 → 𝐵, que indica o perdedor de cada jogo. 

 
15 

Agora, argumentamos que temos uma bijeção entre A e B em qualquer campeonato. 

Dessa forma, o número de jogos será igual ao número de times perdedores. De fato, considere 

a  função  𝑓: 𝐴 → 𝐵  que  associa  cada  jogo  ao  perdedor  daquele  jogo.  Temos  que  cada  jogo 

apresenta  um  único  perdedor,  e  jogos  distintos  apresentam  perdedores  distintos  pois  o 

perdedor de um jogo não participa de nenhum outro jogo do campeonato. Do mesmo modo, a 

cada  perdedor  está  associado  um  único  jogo  (aquele  em  que  o  perdedor  foi  eliminado  do 

campeonato),  ou  seja,  um  time  não  pode  ser  perdedor  em  dois  jogos  diferentes.  Portanto, 

𝑓 é bijetiva.  

Como  temos  1500  times, e  apenas 1 será o vencedores, teremos  1499  perdedores. 

Essa é quantidade de elementos do conjunto 𝐵. Como 𝑓 é bijetiva, pelo principio bijetivo, o 

conjunto  𝐴  também  possui  1499  elementos.  Logo,  chegamos  ao  fim  do  problema,  e 

concluímos que serão realizados 1499 jogos até o campeão ser conhecido.  

 □ 

A seguir vejamos um problema da Olimpíada Brasileira de Matemática, como mais 

um exemplo de utilização do Principio bijetivo. 

Exemplo 3: 

Quantos números inteiros positivos entre 10 e 1000 possuem seus dígitos em ordem 

estritamente crescente? (Por exemplo, 47 e 126 são números desse tipo; 52 e 566 não). 

 Solução: 

Como não precisamos nos preocupar com o número 1000, pois ele não satisfaz às 

condições do problema, vamos considerar 2 grupos, números de 10 a 99 e números de 100 a 

999.   Repare  que  os algarismos deverão  ser  distintos,  e  que  ao  escolher  dois  algarismos 

distintos  existe somente um  número  com  dígitos em  ordem  crescente  que pode ser formado 

por algarismos distintos.  

Vamos contar primeiro os número de 10 a 99 que satisfazem o enunciado. Para isso, 

observe que existe uma bijeção entre dois conjuntos: o conjunto formado pelos números em 

questão e  o  conjunto  formado  pelos  conjuntos  de  dois  algarismos  distintos.  A  bijeção  é  a 

função que associa cada número ao seu conjunto de algarismos e o fato disso ser uma bijeção 

é consequência imediata da discussão do parágrafo anterior.  Assim concluímos que existem 

tantos  números  de  10  a  99  satisfazendo  o  enunciado  quanto  às  formas  de  escolher  dois 

algarismos distintos.  

 
 
 
Analogamente,    existem  tantos  números  de  100  a  1000  satisfazendo  o  enunciado 

quanto  as  formas  de  escolher  3  algarismos  distintos.  Portanto,  pelo  princípio  bijetivo,  a 

resposta é 

2) + (9
(9

3) = 36 + 84 = 120.  

 □ 

16 

Exemplo 4:  

Seja  𝑃(𝑛)  o  número  de  maneiras  de  expressar  𝑛  como  uma  soma  de  inteiros 

positivos,  e  𝑃(𝑛, 𝑚)  o  número  de  maneiras  de  expressar  𝑛  como  a  soma  de  exatamente  𝑚 

inteiros  positivos.  Prove  que  𝑃(𝑛) =  𝑃(2𝑛, 𝑛).  Observação:  aqui  a  ordem  em  que  as 

parcelas aparecem na soma deve ser ignorada. 

Solução: 

Vamos definir 𝑃′(𝑛, 𝑚) como o número de maneiras de expressar 𝑛 como uma soma 

de exatamente 𝑚 números que podem ser inteiros positivos ou zeros. Assim 𝑃′(2,2) =  2, já 

𝑞ue 1  +  1 = 2 e 0 + 2 = 2 são as duas únicas maneiras possíveis.  

Vamos provar primeiro que 𝑃(𝑛) = 𝑃′(𝑛, 𝑛). Primeiro veja que se escrevermos 𝑛 =

 𝑎1 + 𝑎2 + ⋯ + 𝑎𝑘;   𝑘 ≤ 𝑛,  então  é  só  acrescentar  𝑛 − 𝑘  zeros  que  ele  se  tornara  uma  das 

maneiras que são  contadas em  𝑃′(𝑛, 𝑛). Assim  existe uma função que tem como  domínio  o 

conjunto que contem todas as maneiras de expressar 𝑛 como uma soma de inteiros positivos, 

e contradomínio o conjunto que contém todas as maneiras de expressar 𝑛 como uma soma de 

exatamente 𝑛 números que podem ser inteiros positivos ou zeros.  

Observe  que  essa  lei  é invertível,  pois  nas  𝑃′(𝑛, 𝑛)  maneiras  de  expressar  𝑛  como 

uma  soma  de  exatamente  𝑛  números  que  podem  ser  inteiros  positivos  ou  zeros  é  só  retirar 

todos os zeros da soma para obter um correspondente entre as 𝑃(𝑛) maneiras, e portanto tal 

lei é bijetiva. Pelo principio bijetivo, os dois conjuntos tem a mesma quantidade de elementos, 

𝑃(𝑛) = 𝑃′(𝑛, 𝑛), como queríamos. 

Assim  basta  mostrar  𝑃′(𝑛, 𝑛) = 𝑃(2𝑛, 𝑛).  Observe  que  𝑃(2𝑛, 𝑛)  é  a  quantidade  de 

maneiras de expressar 2𝑛 como a soma de (exatamente) 𝑛 inteiros positivos, ou seja, que são 

maiores ou iguais a 1. Considere uma de tais maneiras e subtraia 1 de cada um dos n números. 

Obtemos, então, 𝑛 números maiores ou iguais  a zero cuja soma é igual a n. E este processo 

também é invertível. Em outras palavras 𝑃(2𝑛, 𝑛) = 𝑃′(𝑛, 𝑛). 

 □ 

 
 
Observe  que  na  situação  acima,  foi  usado  bijeção  duas  vezes,  não  para  contar 

diretamente,  mas  para  garantir  que  𝑃′(𝑛, 𝑛) = 𝑃(𝑛)  e,  depois,  que 𝑃(2𝑛, 𝑛) = 𝑃′(𝑛, 𝑛). 

Contudo, não obtemos um fórmula direta para nenhum desses valores. 

17 

Continuamos com mais um exemplo. 

Exemplo 5: 

 Uma  rua  possui  um  estacionamento  em  fila  com  N  vagas  demarcadas  junto  ao 

meio-fio  de  um  dos  lados.  Os  N  automóveis  são  numerados  de  acordo  com  sua  ordem  de 

chegada ao estacionamento, sendo que o primeiro carro é denominado de carro 1, o segundo 

de  carro  2  e  assim  por  diante,  até  o  carro  N.  Os  carros  devem  ser  acomodados, 

sucessivamente, pela ordem em que chegam no estacionamento. Cada carro deve justapor-se 

a  um  carro  já  estacionado,  ou  seja,  uma  vez  estacionado  o  carro  1  em  qualquer  uma  das 

vagas,  os  seguintes  vão  se  colocando  imediatamente  à  frente  do  carro  mais  avançado  ou 

atrás do carro mais recuado. Quantas configurações finais distintas podem ser obtidas desta 

maneira, após terem sido estacionados todos os carros? 

Solução: 

 Veja que quando estacionamos o carro 1, restringimos quantos carros estacionarão à 

frente e quantos atrás dele. Da mesma forma, se sabemos quantos carros pararam à frente do 

carro 1, sabemos também em qual vaga o carro 1 estacionou.  Contudo, ignorando a posição 

do  carro  1,  vamos  argumentar  que  a  configuração  dos  carros  é  determinada  de  forma  única 

após identificarmos, para cada carro diferente do carro 1 se ele estacionou a frente ou atrás do 

carro 1. 

Mais  precisamente,  chamaremos  de  configuração  uma  sequência  de  𝑛  algarismos 

distintos  representando  os  números  dos  carros  na  ordem  em  que  aparecem  na  rua 

(satisfazendo  o  problema).  Digamos  que  as  vagas  também  sejam  numeradas  de  1  até  𝑛,  do 

início (frente) ao fim (trás) da rua, temos. Daí, por exemplo, se há 3 carros estacionados de 

forma que o carro  1 ocupe a vaga  2, o carro  2 ocupe a vaga  3 e o carro  3 ocupe a vaga  1, 

então  temos  a  configuração  (3,  1,  2).  Veja  que,  pelas  restrições  do  problema,  nem  toda 

permutação dos números 1, 2, . . . , 𝑛 é uma configuração válida. 

 Observe um exemplo com 4 carros. Se ao final do processo a fila de carros estiver 

com a configuração (2, 1, 3, 4), onde cada algarismo representa cada carro numerado, temos 

 
18 

que o carro 1 parrou na segunda posição da rua, em seguida o carro 2 parou à sua frente (na 

primeira posição da fila), depois o carro 3 parou atrás do carro 1 (na terceira posição) e, por 

fim, o carro 4 parrou atrás de 3 (na última posição da fila). Podemos, então, transformar essa 

configuração na sequência (frente, atrás, atrás). 

De  modo  geral,  definiremos  uma  função  entre  o  conjunto  das  configurações  e  o 

conjunto  das  sequências  de  palavras  compostas  pelas  palavras  “frente”  e  “atrás”,  com 

 𝑛 − 1 termos. Em seguida mostraremos que essa função é uma bijeção.  

Dada  uma  configuração,  vamos  começar  ignorando  a  posição  em  que  o  carro  1 

estacionou. E, depois, a escolha de cada carro com número de 2 até 𝑛 determina cada palavra 

da  sequência,  dependendo  se  ele  está  à  frente  ou  atrás  do  carro  1,  sendo  a  primeira  palavra 

associada  á  escolha  do  carro  2,  a  segunda  palavra  associada  á  escolha  carro  3  e  assim 

sucessivamente até o 𝑛-ésimo carro.  

Para provar que a função definida acima é bijetiva, encontraremos sua inversa e para 

isso,  basta  perceber  que  dada  uma  sequencia  de  𝑛 − 1  palavras  “frente/atrás”,  é  possível 

encontrar uma única configuração dos carros que corresponde a tal sequência.  

Para isso, basta observar que, existindo 𝑘 palavras "frente”, então o carro de número 

1  ocupa  a  (𝑘 + 1)-ésima  vaga.  E  depois  de  identificar  a  vaga  ocupada  pelo  carro  1, 

preenchemos em ordem as posições dos outros carros. 

Agora  basta  contar  a  quantidade  das  sequências  acima,  que  claramente  é  igual  a  

2𝑛−1,  onde  2  corresponde  às  possibilidade,  "atrás"  ou  “frente”,  para  cada  palavra  e  𝑛 − 1 

corresponde  ao  número  de  palavras  na  sequência.  Concluímos  assim  a  solução  deste 

problema. Pelo Princípio Bijetivo, o número de configurações também é 2𝑛−1.  

 □ 

Alternativamente, podemos resolver este problema sem utilizar o Principio Bijetivo, 

caso tenhamos estudado a noção de “combinação” e o triângulo de Pascal.  

Consideramos  para  cada  número  𝑚  de  1  até  𝑛,  o  caso  em  que  o  primeiro  carro 

estacionou na vaga de número 𝑚 e iremos determinar o número de maneiras de estacionar os 

𝑚 − 1 carros nas 𝑛 − 1 vagas anteriores. Usando combinação chegamos ao valor 𝐶𝑛−1
bais escolher quais carros irão estacionar à frente do carro 1. Somando isso sobre os possíveis 

𝑚−1, pois 

 
 
 
  
valores de 𝑚 teremos um total de ∑

𝑛
𝑚=1

𝑚−1
𝐶𝑛−1

 configurações. Essa soma corresponde à soma 

dos elementos da linha 𝑛 − 1 do triangulo de Pascal, e é igual a 2𝑛−1. □ 

Outro  problema  interessante  é  o  seguinte.  Embora  bastante  simples,  se  utiliza  com 

19 

clareza do principio bijetivo.  

Exemplo 6: 

 De quantas maneiras podemos ordenar n objetos?  

Este problema poderia ter o seguinte enunciado: existem quantas permutações de um 

conjunto com n objetos? 

Solução: 

 Imaginemos  inicialmente  dois  conjuntos.  Um  conjunto  𝑃  que  contém  todas  as 

permutações possíveis dos 𝑛 objetos e o conjunto  

𝐴 = {1, 2, … , 𝑛} × {1, 2, … , 𝑛 − 1} × {1, 2, … , 𝑛 − 2} × … × {1, 2} × {1}. 

Vamos  concluir  que  existe  uma  bijeção  entre  os  conjuntos  𝑃 e  𝐴 e,  portanto,  pelo 

principio bijeivo, eles possuem a mesma quantidade de elementos.  E como 𝐴 possui 

 𝑛 · (𝑛 − 1) · (𝑛 − 2) · … · 1 = 𝑛!, 

elementos. Segue que 𝑃 também possui 𝑛! elementos.  

 Perceba  que  cada  elemento  do  conjunto  𝐴  é  formado  𝑛  “coordenadas”.  Considere 

agora, um elemento de 𝑃, ou seja, uma enumeração dos objetos de 1 a 𝑛, e vamos associá-lo a 

um  elemento  de  𝐴.  A  primeira  coordenada  do  elemento  de    𝐴  é  a  posição  do  objeto  1  na 

enumeração. Feito isso, exclua o objeto 1 da lista, e observar a posição do objeto 2 entre os 

que sobraram. Essa será a segunda coordenada do elemento de 𝐴. Depois exclua o objeto 2 e 

continue esse processo até restar apenas o objeto 𝑛 na lista.  Esta correspondência é bijetiva. 

Assim, chegamos à solução deste problema. 

 □ 

Outro  problema  bastante  recorrente  em  trabalhos  nesta  área  é  o  problema  das 

permutações circulares.  

 
O  Conceito  de  Permutação  Circular  consiste  em  permutar  elementos  que  estão 

organizados  sobre  um  círculo.  Esse  tipo  de  permutação  é  um  pouco  diferente,  pois  para 

algumas disposições dos elementos, mesmo trocando todos eles de lugar, as posições relativas 

20 

entre eles no círculo não se alteram. 

Exemplo 7: 

Quantas permutações circulares de n objetos existem? 

Solução:  

Baseado no problema anterior, agora basta mostrarmos que cada permutação circular 

corresponde  a  exatamente  𝑛  permutações,  e  para  isso  devemos  escolher  um  elemento  para 

ocupar a primeira posição da permutação.  

Agora,  iremos  determinar  dois  conjuntos.  Um  que  possui  todas  as  permutações 

circulares que possui um elemento fixo na primeira posição e outro que possui as sequências 

possíveis  geradores  pelos  valores  que  representam  a  posição  de  cada  objeto  em  relação  ao 

objeto fixo. Observe que há uma bijeção entre esses conjuntos, pois cada permutação circular 

está associada á uma única sequência de valores. E vice-versa. Assim, pelo principio bijetivo, 

esses conjuntos possuem a mesma quantidade de elementos.  

Como  a  sequência  é  gerada  a  partir  de  𝑛 − 1  elementos,  pois  não  precisamos 

permutar  o  elementos  fixo,  basta  permutarmos  os  𝑛 − 1  elementos  que  restaram.  Portanto, 

𝑝 = (𝑛 − 1)! é a solução deste problema. □ 

Mostraremos  a  seguir,  uma  prova  de  um  resultado  que  envolve  números  binomiais. 

Por isso, daremos agora a definição de um número binomial. 

O  número  binomial,  de  um  número  natural  𝑛,  na  classe  𝑘,  com  𝑘  também  natural, 

consiste no número de combinações de 𝑛 termos, 𝑘 a 𝑘. O número binomial de um número 𝑛, 

na classe 𝑘, pode ser escrito como: 

(

𝑛
𝑘

) =  

𝑛!
𝑘! · (𝑛 − 𝑘)!

. 

A prova que iremos mostrar é sobre a simetria dos números binomiais.  

Exemplo 8: Mostre que para todo natural 𝑛 e todo 𝑘 tal que 1 ≤ 𝑘 ≤ 𝑛 temos: 

(

𝑛
𝑘

) =   (

𝑛
𝑛 − 𝑘

).  

 
 
 
 
 
 
21 

Prova: 

 De maneira geral, notamos que os dois valores contam o número de subconjuntos de 

tamanho 𝑘 e 𝑛  −  𝑘, respectivamente, de qualquer conjunto de elementos 𝑛.  

Note que, em um processo de escolha de 𝑘 objetos de um conjunto,  ao escolhermos 

𝑘 elementos de um conjunto com 𝑛 elementos, deixariamos de escolher 𝑛 –  𝑘 elementos, de 

modo que cada quantidade de elementos escolhidos está associado a uma única quantidade de 

elementos  que  não  foi  escolhida,  notabilinando  assim,  uma  bijeção  entre  os  dois  conjuntos. 

Assim, pelo pricípio bijeitvo, esse conjuntos possuem as mesmas quantidades de elementos, e 

portanto provamos que 

(

𝑛
𝑘

) =   (

𝑛
𝑛 − 𝑘

).  

□ 

As  aplicações  do  Principio  Bijetivo  citadas  nos  mostram  que,  por  muitas  vezes, 

tomamos decisões corretas em determinados problemas sem saber que, de maneira intuitiva, 

estamos nos aproveitando deste principio.  

No nosso contexto, o Principio Bijetivo será ferramenta importante para entendermos 

a prova do Teorema de Cayley usando Código de Prüfer. 

 
 
 
 
 
4 GRAFOS 

22 

Neste capítulo serão introduzidos alguns conceitos básicos de Teoria de Grafos, com 

uma introdução histórica e posteriormente com a exposição das principais definições que nos 

serão úteis para a compreensão da prova do Teorema de Cayley sobre árvores usando Código 

de Prüfer.  

4.1 História dos grafos 

Os grafos foram usados pela primeira vez como uma maneira matemática de modelar 

e  solucionar  um  problema  curioso  e  divertido.  Em  uma  cidade  da  antiga  Prússia  de  nome 

Königsberg, situada na região onde hoje se localiza a cidade de Kaliningrado, na Rússia, há 

quatro ilhas. Havia interligando essas ilhas, sete pontes, como na imagem abaixo: 

Figura 1: Esboço do problema de Königsberg 

O  problema  consistia  em  saber  se  era  possível  ou  não  atravessar  cada  uma  das  sete 

pontes passando por cada ponte uma única vez.   

Em 1735, o matemático suíço  Leonhard Euler  (1707-1783) solucionou  o problema e 

estabeleceu seu nome como pioneiro no estudo de teoria dos grafos. Na solução apresentada, 

Euler  percebeu  inteligentemente  que  as  particularidades  e  as  características  geométricas  das 

ilhas eram irrelevantes, e assim, determinou que cada ilha, ficaria representada simplesmente 

por um ponto (cuja posição no espaço também é irrelevante). Estes pontos são chamados de 

vértices.  

 
 
 
 
 
 
23 

Figura 2: Leonhard Euler 

Com  essa  percepção,  Euler  reduziu  o  problema  a  simplesmente  seguir  percursos 

entre  vértices,  que  representavam  as  ilhas,  e  passando  pelas  arestas,  que  representam  as 

pontes, exatamente uma vez. Veja a seguir, a representação gráfica do problema da ponte de 

Königsberg:  

Figura 3: Grafo do problema de Königsberg 

Embora  simples,  uma  imagem  estabelecida  através  de  vértices  e  arestas,  tornou-se 

uma  maneira  útil  de  resolver  problemas  que,  a  princípio,  seriam  potencialmente  muito 

complicados.  

Com essa estratégia Euller resolveu um problema-geral: para qualquer que seja o grafo 

decidir se existe uma trilha que saia de um vértice, passe por todas as arestas exatamente uma 

vez e retorne ao vértice inicial, e encontrar tal trilha caso ela exista. 

 
 
 
24 

Um grafo composto por dois conjuntos:  um conjunto constituído por vértices e outro 

conjunto constituído de arestas;  cada aresta está associada a um par não orientado de vértices. 

Os dois vértices representam as duas extremidades da aresta.  

Ao analisar o problema da ponte de Königsberg, Euler observou que para haver um 

percurso que nos possibilitasse atravessar cada ponte uma única vez, todo vértice deveria ter 

um  número  par  de  arestas  incidentes  a  ele,  quantidade  essa  que  posteriormente  viria  a  ser 

denominado  grau  de  um  vértice.  Detectado  isso,  Euler  olhou  para  a  representação  do 

problema das pontes de Konigsberg em forma de grafo e notou que existem vértices de grau 

ímpar (de fato, a situação é mais grave ainda pois, neste caso, todos os vértices possuem grau 

ímpar).  Assim,  Euler  concluiu  o  problema  da  ponte  de  Königsberg,  e  determinou  que  não 

existe caminho que satisfazia as condições iniciais.  

O termo grafo foi introduzido pelo matemático inglês James Joseph Sylvester em um 

artigo publicado em 1878 na revista britânica Nature sobre diagramas moleculares. 

Figura 4: James Joseph Sylvester 

O matemático húngaro judeu Dénes König escreveu o primeiro livro texto no campo 

de Teoria dos Grafos, em 1936.  

 
 
25 

Figura 5: Dénes König 

Porém, em 1969, o americano formado no Brooklyn College, Frank Harary, publicou 

aquela  que  foi  considerada  a  grande  obra  do  assunto  para  a  época,  intitulada  Teoria  dos 

Grafos,  a  obra  permitiu  que  matemáticos,  químicos,  engenheiros  eletricistas  e  cientistas 

sociais  se  utilizassem  de  técnicas  uteis  às  suas  respectivas  áreas.  Um  aspecto  interessante 

sobre o livro é que Harary doou todos os royalties para financiar o Prêmio Pólya. Este prêmio 

é mantido pela Society for Industrial and Applied Mathematics (SIAM), e tem como primeiro 

homenageado o matemático húngaro George Pólya. É atualmente concedido em anos pares.  

Figura 6: Frank Harary 

De 1735 ao século  XXI, vários avanços  ocorreram  no campo  da teoria dos grafos, e 

muitas ciências se desenvolveram com esse avanço.  

Ao  longo  dos  anos,  os  grafos  se  mostraram  ser  mais  que  uma  ferramenta  útil  à 

resolução de problemas. As redes sociais, dentro de seus interesses veem nessa área, a grande 

aliada no desenvolvimento de suas estruturas, facilitando na capitação de clientes, baseando-

se no interesse do indivíduo. Equipados com esse conhecimento, sabendo não apenas do que 

você gosta e do que não gosta, mas também do que seus amigos gostam e do que não gostam, 

 
 
 
26 

as empresas podem personalizar os anúncios que apresentam para seus clientes por meio de 

seus “feeds”, Facebook, Twitter ou qualquer rede similar. 

Na engenharia de trânsito e logística, o uso de teoria dos grafos é essencial. Uma rede 

de transporte permite fluxos de pessoas, cargas ou informações, que estão ocorrendo. A teoria 

de  grafos  oferece  possibilidades  de  representar  os  deslocamentos  de  transportes  como 

ligações, que podem ser consideradas em vários aspectos como conexões, caminhos e ciclos 

urbanos. 

Certamente, a computação foi o campo da ciência que mais se utilizou e se utiliza da 

teoria dos grafos, porém, são inúmeras as áreas de aplicação dessa teoria. Ao longo dos anos, 

mais  situações  e  acontecimentos  nos  remetem  ao  uso  da  teoria  por  oferecer  a  base  de 

estruturas  de  representação,  para  diversos  problemas  como  listas,  árvores,  pilhas,  filas  e 

outras.  

4.2 Definição e conceitos básicos de grafos 

De maneira formal, um grafo, 𝐺 = (𝑉, 𝐸) , consiste de um conjunto finito e não vazio, 

𝑉 = 𝑉(𝐺), de elementos chamados vértices e de um conjunto finito, 𝐸 = 𝐸(𝐺), de pares não 

ordenados de elementos distintos de 𝑉(𝐺), chamados arestas.  

Figura 7: Imagem de um grafo simples 

A  Figura  7  mostra  um  grafo  cujo  conjunto  de  vértices  é  formado  pelos 

elementos 𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓. Alguns desses vértices estão ligados, formando arestas. Deste modo, 

temos que este grafo é constituído dos conjuntos: 

 𝑉 = {𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓}; e 

 𝐸 = {{𝑎, 𝑏}, {𝑏, 𝑐}, {𝑏, 𝑓}, {𝑐, 𝑒}, {𝑐, 𝑓}, {𝑒, 𝑑}, {𝑒, 𝑓}, {𝑓, 𝑎}}. 

 
 
 
 
27 

Por simplicidade, vamos representar uma aresta {𝑥, 𝑦} simplesmente por 𝑥𝑦. O grafo 

da Figura 7 é um exemplo de grafo simples, pois não possui mais de uma aresta ligando dois 

vértices e também não possui um laço, ou seja, uma aresta que liga o vértice a ele mesmo.  

Um  multigrafo  pode  possuir  mais  de  uma  aresta  ligando  dois  vértices,  pois  o 

conjunto de arestas é substituído por um multiconjunto. Na Figura 8 a seguir, além, de possuir 

essa característica, a representação possui um laço no vértice A e no vértice D, ou seja, uma 

aresta ligando esses vértices a ele mesmo. 

Figura 8: Imagem de um grafo laço  

Dados dois grafos 𝐺 e 𝑇, um isomorfismo será uma bijeção f de 𝐺(𝑉) em 𝑇(𝑉), tal 

que  dois  vértices  quaisquer  𝑣 e  𝑢  são  adjacentes  em  𝐺  se,  e  somente  se,  𝑓(𝑣)  e  𝑓(𝑢)  são 

adjacentes em 𝑇. Assim, podemos dizer que dois grafos serão isomorfos se for possível alterar 

os nomes de um deles de modo que os dois grafos fiquem iguais. Para verificar se dois grafos 

𝐺 e 𝑇 são isomorfos, basta analisar todas as bijeções de 𝐺(𝑉) em 𝑇(𝑉). 

Um grafo simples no qual para todos os pares de vértices existe uma aresta os ligando 

é denominado de grafo  completo. Veja na Figura 8 que o vértice B apresenta seis  arestas o 

ligando  a  outros  vértices,  enquanto  o  vértice  C  possui  apenas  duas  arestas.  Dizemos  que  o 

grau de B é 6 e o grau de C é 2.  

Um passeio é uma  sequência de vértices que  apresenta a seguinte propriedade:  se  𝑢 

e 𝑣 são vértices consecutivos desta sequência, então 𝑢𝑣 é uma aresta do grafo. Uma aresta de 

um passeio é qualquer aresta 𝑢𝑣 do grafo, onde 𝑢 é o sucessor de 𝑣 no passeio. 

Uma trilha  é  um  passeio  sem  arestas  repetidas,  ou  seja,  um  passeio  que  apresenta 

todas  as  arestas  diferentes  entre si. Um  caminho  é  uma  trilha  que,  adicionalmente,  não 

apresenta em sua estrutura, vértices repetidos.  

Um  ciclo  é  a  união  de  um  caminho  com  uma  aresta  unindo  o  último  vértice  ao 

primeiro do caminho, e que tenha pelo menos duas arestas. Entende-se por comprimento ao 

 
 
 
número de aresta do caminho ou ciclo. Dizemos que um arco 𝑣𝑤 pertence a um dado ciclo se 

28 

o vértice 𝑣 é o sucessor de 𝑢 no ciclo, ou vice-versa.  

Uma floresta é um grafo que não contém ciclos. 

Observemos agora o gráfico da Figura 9. 

Figura 9: Imagem de uma árvore 

O grafo acima é conexo, o que significa que há pelo menos um caminho ligando cada 

par de vértices deste grafo. Um grafo conexo sem ciclos é chamado de árvore. Cada vértice 

de grau 1 de uma árvore é chamado de folha.  

Dado  um  grafo,  podemos  selecionar  alguns  vértices  e  formar  uma  árvore.  Uma 

árvore  que  possui  todos os  vértices  de  um  grafo  é  dita  árvore  geradora.  Essa  definição  será 

muito importante para o próximo capítulo.  

 
 
 
 
 
 
 
5 TEOREMA DE CAYLEY 

29 

Arthur  Cayley  (1821–1895),  foi  um  matemático  professor  na  Universidade  de 

Cambridge,  Inglaterra. Considerado um dos grandes matemáticos do século XIX, contribuiu 

em  diversas  áreas  para  o  desenvolvimento  da  matemática.  Obteve  destacados  trabalhos  no 

ramo  da  teoria  das  funções  elípticas,  geometria  analítica  e  álgebra.  Seu  trabalho  sobre  as 

árvores apareceu em 1889. 

Figura 10: Imagem de Arthur Cayley 

Em seu teorema sobre arvores e grafos, Cayley afirma que se apresentado um grafo 

completo rotulado de 𝑛 vértices, ele possui 𝑛𝑛−2 árvores geradoras distintas. Quando dizemos 

que  um  grafo  é  rotulado,  nos  referimos  ao  fato  que  cada  vértice  possui  um  rótulo  único 

associado  a  ele.  Em  problemas  de  contagem,  o  termo  rotulado  enfatiza  que  estamos 

distinguindo grafos isomórficos na contagem. 

Abaixo temos um exemlo de gráfico rotulado. 

Figura 11: Imagem de um grafo rotulado  

 
 
 
 
 
 
30 

O termo  rotulado enfatiza que não  estamos  identificando  gráficos isomórficos. Nós 

fixamos  o conjunto de vértices, e duas  árvores  são contadas  como  iguais, se somente se, os 

mesmos pares de vértices forem adjacentes. Uma árvore geradora de um grafo conectado G é 

um subgráfico de abrangência de G que é uma árvore. O teorema poderia ter sido enunciado 
da seguinte maneira: um grafo completo 𝐾𝑛 tem 𝑛𝑛−2 árvores de abrangência. 

Aqui estão as 16 árvores rotuladas em quatro vértices. 

Figura 12: Imagem das 16 árvores rotuladas em quatro vértices.  

Iremos provar esse teorema usando o Código de Prüfer, que consiste em associar um 

código, ou seja, um nome único, para cada uma dessas árvores. 

5.1 O Código de Prüfer 

 A  prova  que  iremos  apresentar  não  é  a  prova  original  de  Cayley,  mas  uma  que  se 

utiliza  do  código  de  Prüfer.  O  código  recebe  esse  nome  em  homenagem  a  Heinz  Prüfer 

(1918). O código de Prüfer é uma sequência gerada a partir de uma árvore cujos vértices são 

numerados  com  valores  distintos,  removendo  todas  as  folhas  da  árvore  uma  a  uma,  numa 

ordem  pré-determinada,  até  restarem  apenas  dois  vértices.  Especificamente,  considere,  sem 

perda  da  generalidade,  uma  árvore  rotulada  𝑇  em  que  os  rótulos  dos  vértices  formam  o 

conjunto  {1, 2, . . . , 𝑛 }.  Vamos  à  codificação,  ou  seja,  como  obter  a  sequência  à  partir  dessa 

árvore. A codificação mapeia a árvore T em uma sequência de  𝑛 –  2 números inteiros onde 

cada número varia de 1 a 𝑛. 

Defina 𝑇1 = 𝑇 e para cada 𝑖, com 1 ≤ 𝑖 ≤ 𝑛 − 1, no passo 𝑖 defina 𝑣𝑖 como a folha 
de menor rótulo  de  𝑇𝑖, defina  𝑠𝑖 como  o rótulo do vizinho  de  𝑣𝑖  e  𝑇𝑖+1 = 𝑇𝑖 − {𝑣𝑖}  como  a 
árvore  obtida  removendo-se  o  vértices  𝑣𝑖  e  (consequentemente)  a  aresta  {𝑣𝑖, 𝑠𝑖}  de  𝑇𝑖.  A 

sequência  𝑆 = (𝑠1, 𝑠2, … , 𝑠𝑛−2)  é  o  código  de  Prüfer.  Veja  que,  em  cada  passo,  o  valor  que 

 
 
 
 
 
 
 
31 

adicionamos  na  sequência  S  é  𝑠𝑖  que  é  vizinho  de  𝑣𝑖  e  nunca  o  próprio  valor  de  𝑣𝑖.  Veja 

também  que,  apesar  de  termos  definido  𝑠𝑛−1,  este  valor  não  faz  parte  do  código  de  Prüfer. 

Fazemos  isso  porque    𝑠𝑛−1  sempre  será  igual  a  𝑛,  logo  essa  informação  é  redundante.  Isso 

ocorre  porque  toda  árvore  (com  pelo  menos  dois  vértices)  tem  pelo  menos  dois  vértices  de 

grau  1,  como  já  enfatizamos  nesse  trabalho,  de  modo  que  o  vértice  𝑛  nunca  será  o  menor 

vértice de grau 1, e portanto, nunca será eliminado. 

Por exemplo, considere a seguinte árvore: 

Figura 13: Imagem da árvore geradora de um código de Prüfer. 

Primeiro  removemos  a  folha  1,  por  ser  o  menor  valor  (dentre  as  folhas  e, 

coincidentemente, neste caso, dentre todos os vértices),  e adicionamos 4 à sequência, por ser 

vizinha da folha retirada. Depois removemos a folha 2 e adicionamos 4 (novamente). Então 

nós removemos a folha 4 e adicionamos 3. Agora que estamos apenas com as folhas 3 e 5. Se 

removermos  3  ficamos  com  apenas  5  mas  este  5  não  será  adicionado  ao  código,  então 

paramos com a sequência (4, 4, 3). 

Esse método nos dá uma função 𝑓 que associa cada árvore com vértices {1, 2, . . . , 𝑛} 

a uma sequência de 𝑛 − 2 termos onde cada termo pertence ao conjunto {1, 2, . . . , 𝑛}. Veja que 

os valores da sequência não precisam ser distintos, como no exemplo acima. O fato de que a 

partir de uma árvore como acima o código de Prüfer está bem definido é consequência do fato 

mencionado  no  capítulo  anterior  de  que  toda  árvore  tem  pelo  menos  duas  folhas.  Veja  que, 

como os rótulo são distintos, em cada passo da codificação, o vértice vizinho à folha de menor 

rótulo está unicamente determinado. 

Para mostrar que tal função é bijetiva nos resta provar que existe uma função inversa 

que associa cada sequência com 𝑛 –  2 valores no conjunto {1, 2, . . . , 𝑛} a uma única árvore de 

vértices {1, 2, . . . , 𝑛} (cujo código de Prüfer é tal sequência). Ao processo de obter a árvore a 

partir da sequência, chamamos de decodificação.  

 
 
 
 
32 

Considere  uma  sequência  𝑆 = (𝑠1, … , 𝑠𝑛−2)  onde  1 ≤ 𝑠𝑖 ≤ 𝑛,  para  todo  𝑖.  Defina 
𝑠𝑛−1 =  𝑛  e  considere  a  sequência  𝑆1 = (𝑠1, … , 𝑠𝑛−2, 𝑠𝑛−1).  Vamos  construir  a  árvore  com 

vértices  1, 2, . . . , 𝑛,  adicionando  uma  arestas  de  cada  vez  (de  modo  que  nos  passos 

intermediários  teremos  florestas  𝐹1, … , 𝐹𝑛−1.  No  primeiro  passo,  definimos  𝑉1  como  o 

subconjunto  dos  números  {1, 2, . . . , 𝑛}  que  não  é  usado  na  sequência  𝑆  e  𝑥1  como  o  menor 
elemento de 𝑉1. Incluímos em 𝐹1 apenas a aresta {𝑠1, 𝑥1}. Em cada passo seguinte, para  2 ≤
𝑖 ≤ 𝑛 − 1, defina 𝑆𝑖 =   (𝑠𝑖, … , 𝑠𝑛−1), defina 𝑉𝑖 como o subconjunto dos números {1, 2, . . . , 𝑛} 
que não são usados em  𝑆𝑖 e nem estão no conjunto {𝑥1, … , 𝑥𝑖−1},  defina  𝑥𝑖 como o menor 
elemento de 𝑉𝑖 e seja 𝐹𝑖 a floresta obtida adicionando-se a aresta {𝑠𝑖, 𝑥𝑖} a 𝐹𝑖−1. Veja que, em 

cada  passo,  também  podemos  obter  o  conjunto  𝑉𝑖  à  partir  de  𝑉𝑖−1:  basta  remover  𝑥𝑖−1 

(sempre)  e  acrescentar  𝑠𝑖−1  no  caso  em  que  este  não  aparece  novamente  entre  𝑠𝑖, … , 𝑠𝑛. 

Finalmente, seja 𝑇 = 𝐹𝑛−1. Afirmamos que o código de Prüfrer da árvore 𝑇 é 𝑆. 

Como exemplo, vamos encontrar a árvore associada ao código Prüfer (7, 4, 4, 1, 7, 1). 

(Exemplo  extraído  de  um  trabalho  do  professor  Edson  Prestes,  da  Universidade  Federal  do 

Rio Grande do Sul).  

Inicialmente temos 𝑆  =   (7, 4, 4, 1, 7, 1). Como 𝑆 tem 6 termos, temos que 𝑛 − 2 =

6,  logo  𝑛 = 8.  Logo,  𝑆_1 = (7, 4, 4, 1, 7, 1, 8)  e    𝑉1 = {2, 3, 5, 6, 8}.  Temos  que  o  primeiro 
elemento  de  𝑆  é  7,  e  o  menor  elemento  de  𝑉 é  2,  esse  valores  formarão  a  aresta  {𝑠1, 𝑥1} =
 {7,2}. No segundo passo, procuramos o menor rótulo diferente de  𝑥1 e que não pertence na 
subsequência  𝑆_2  =   (4, 4, 1, 7, 1, 8).  Temos  então  que  𝑉2 = {3, 5, 6, 8}  e  𝑥2 = 3,  a  aresta 

adicionada será {4, 3}. Continuando da mesma forma, teremos a tabela abaixo.  

𝑖 

1 

2 

3 

4 

5 

6 

7 

𝑆𝑖 

𝑉𝑖 

𝑥𝑖 

Nova arestas de 𝐹𝑖 

(7, 4, 4, 1, 7, 1,8) 

{2, 3, 5, 6, 8} 

(4, 4, 1, 7, 1,8) 

{3, 5, 6, 8} 

(4, 1, 7, 1,8) 

(1, 7, 1,8) 

(7, 1,8) 

(1,8) 

(8) 

{5, 6, 8} 

{4, 6, 8} 

{6, 8} 

{7, 8} 

{1} 

2 

3 

5 

4 

6 

7 

{7, 2} 

{4, 3} 

{4, 5} 

{1, 4} 

{7, 6} 

{1,7} 

{8,1} 

Logo, de acordo com as arestas obtidas, temos a seguinte árvore.  

 
 
 
33 

Figura 14: Imagem de um grafo obtido de uma decodificação de uma sequencia de Prüfer. 

Como exercícios, sugerimos que o leitor aplique o método de codificação na árvore 

acima e verifique que a sequência obtida é a sequência 𝑆 acima.  

Nos  resta  justificar,  de  modo  geral,  porque  o  processo  de  decodificação  nos  dá  a 

função inversa da função de codificação. Para isso, usando a notação definida acima, vamos 

primeiro verificar alguns fatos sobre 𝑣𝑖, 𝑠𝑖 e 𝑇𝑖. Veja que 𝑣𝑘, 𝑣𝑘+1, … , 𝑣𝑛−1 e 𝑛 são os vértices 

da árvore 𝑇𝑘. E que o conjunto formado pelos pares {𝑣𝑖, 𝑠𝑖}, 𝑘 ≤ 𝑖 ≤ 𝑛 − 1, é o conjunto das 

arestas de 𝑇𝑘. 

O número de vezes que um vértice 𝑚 ocorre entre 𝑣1, 𝑣2,. . . , 𝑣𝑛−2 é 𝑔𝑟𝑎𝑢(𝑚)   − 1. 
Isso  acontece  porque  𝑚  ocorre  𝑔𝑟𝑎𝑢(𝑣) − 1  vezes  entre  as  arestas  {𝑣𝑖, 𝑠𝑖}, 1  ≤  𝑖  ≤  𝑛  −

 1 e exatamente uma vez em 𝑣1, 𝑣2,. . . , 𝑣𝑛−1, 𝑠𝑛−1. Similarmente, o número de vezes que um 

vértice 𝑚 ocorre entre 𝑠𝑘, 𝑠𝑘+1, ..., 𝑠𝑛−2 é o seu grau subtraído de uma unidade. Em particular, 

os vértices de grau 1 são aqueles elementos de 𝑉 que não estão em 

{𝑣1, 𝑣2, . . . , 𝑣𝑛−1}   ∪   {𝑠𝑘, 𝑠𝑘+1, . . . , 𝑠𝑛−1}, 

e  isso  significa  que  𝑣𝑘,  o  vértice  de  menor  grau,  é  o  menor  elemento  de  {1, 2, . . . , 𝑛}  não 

contido no conjunto acima. Em particular, 𝑣1 é o menor elemento de 𝑉 que não pertence a S, e 

podemos determinar exclusivamente 𝑣𝑘 de 𝑆 e 𝑣1, 𝑣2, . . . , 𝑣𝑛−1.  

Assim, provamos que existe bijeção entre o conjunto de todas as árvores com vértices 

cujos rótulos estão no conjunto dos inteiros {1, 2, … , 𝑛} e o conjunto de todas as (𝑛 − 2)-uplas 

formadas por esses inteiros.  

A prova do terorema de Cayley a seguir, se utilizara dessa bijeção.  

 
 
 
 
 
 
 
 
 
34 

5.2 Prova do Teorema de Cauley usando Código de Prüfer 

Teorema de Cayley: Dado um grafo completo rotulado de n vértices, ele possui nn-2 

árvores geradoras distintas. 

Prova: Como demonstrado anteriormente, o código de Prüfer nos fornece uma bijeção 

entre o conjunto de todas as árvores com vértices cujos rótulos estão no conjunto dos inteiros 

{1, 2, … , 𝑛}  e  o  conjunto  de  todas  as  (𝑛 − 2)-uplas  formadas  por  esses  inteiros.  Como  há 𝑛 

possibilidades de escolha para ocupar cada posição na (𝑛 − 2)-upla, onde 𝑛 é o rótulo de grau 

𝑛 − 1,  e  há  (𝑛 − 2)  posições  no  Código,  então,  há  𝑛𝑛−2  distintas  𝑛-uplas  e,  portanto, 

árvores. □  

 
 
 
 
 
35 

5.3 Outros resultados  

Também podemos adaptar  a fórmula de Cayley para contar florestas enraizadas. 

A diferença entre árvore e floresta é que a primeira é conexa e a segunda não precisa 

ser conexa (mas poderia). Observe que toda floresta é uma união disjunta de árvores, o que 

justifica a nomenclatura. 

Uma árvore é denominada enraizada se um vértice é escolhido como  especial. Esse 

vértice é chamado raiz. Uma árvore que não é enraizada é denominada livre.   

Se  quisermos  contar  árvores  enraizadas  rotuladas  com  𝑛  vértices,  podemos  apenas 

multiplicar  por  𝑛  o  total  de  árvores  rotuladas,  para  as  possíveis  escolhas  da  raiz.  Assim,  o 

número de árvores enraizadas rotuladas em 𝑛 vértices é 𝑛 ∙ 𝑛𝑛−2 =  𝑛𝑛−1.  

O número de florestas rotuladas em 𝑛 vértices com exatamente 𝑘 componentes onde 

cada componente é enraizada é dado por (𝑛−1

𝑘−1) ∙ 𝑛𝑛−𝑘. Note que, se 𝑘  =  1 temos 

   (𝑛−1

𝑘−1) ∙ 𝑛𝑛−𝑘 =   (𝑛−1

1−1) ∙ 𝑛𝑛−1 = (𝑛−1

0 ) ∙ 𝑛𝑛−1 =  1 ∙ 𝑛𝑛−1 = 𝑛𝑛−1. 

 Além disso, temos outro resultado interessante. O número total de florestas rotuladas 

em  𝑛 vértices  é  dado  por  (𝑛 + 1)𝑛−1,    pois  cada  floresta  enraizada  rotulada  pode  ser 

transformada  em  uma  árvore  rotulada  com  um  vértice  extra,  adicionando  um  vértice  com  o 

rótulo 𝑛  +  1 e conectando-o a todas as raízes das árvores na floresta.  

 
 
 
 
 
 
6 CONCLUSÃO 

36 

Neste  trabalho,  observamos  uma  interessante  maneira  de  provar  o  teorema  de 

Cayley,  um  teorema  simples  matematicamente  falando,  mas  que  seria  muito  difícil  de  ser 

provado  sem  o  uso  do  princípio  bijetivo,  ou  seja,  através  de  outros  métodos  de  contagem 

usualmente apresentados no Ensino Médio. Apresentamos alguns dos conceitos fundamentais 

sobre a teoria dos grafos. Foi feito um estudo sobre a fórmula de Cayley para a contagem de 

árvores geradoras de um grafo completo. Para um grafo completo com 𝑛 vértices, constatou-

se que o número de árvores  geradoras  rotuladas é dado pela fórmula  𝑛𝑛−2. A demonstração 

proposta por Prüfer em 1918, para essa contagem, é dada por um algoritmo que se baseia na 

construção  de  sequências  numéricas  de  acordo  com  uma  numeração  dos  vértices  do  grafo 

dado,  estabelecendo  uma  bijeção  entre  o  conjunto  de  sequências  e  o  número  de  árvores 

geradoras do grafo completo.  

A utilização de função, princípio bijetivo, grafos e código de Prüfer nos mostra como 

a matemática é coesa e interligada entre seus ramos. Essa ligação nos faz ter a certeza de que 

a matemática nos oferece ainda, muitos caminhos a serem desvendados. 

Estudar  funções  é  sempre  um  caminho  de  novas  aprendizagens,  já  que  praticamente 

toda  a  matemática  fala  em  linguagens  de  conjuntos,  que  nos  levam  às  funções.  Revisar 

conceitos e nos apropriar formalmente de conceitos já definidos, anteriormente  de maneiras 

não sólidas, nos enriquece.   

O  presente  trabalho  também  nos  fez  inteirar-se  sobre  o  princípio  bijetivo,  de 

entendimento simples, mas muito útil na contagem de elementos de conjuntos de uma forma 

interessante e inteligente, haja vista que se utiliza de outro conjunto. 

Em  teoria  dos  grafos,  que  iniciamos  no  problema  tradicional  sobre  as  pontes  de 

Konigsberg,  com  o  matemático  suíço  Leonard  Euler,  o  trabalho  mostrou  a  importância  de 

uma  teoria  relativamente  recente.  Foi  abordada  a  relação  desta  ferramenta  com  a  realidade 

atual  e  um  pouco  do  seu  desenvolvimento  histórico,  assim  como  definições  básicas  e  suas 

aplicações.  Vimos,  no  estudo  de  grafos,  conceitos  que  partiram  desde  a  sua  definição, 

passando por ciclos, nós, por exemplo, até chegarmos ao conceito o qual utilizaríamos para o 

objetivo final deste trabalho, a prova do teorema de Cayley. Lembrando que isso é apenas a 

ponta do icebergue, uma vez que há livros inteiros sobre Teoria dos Grafos. 

 O  código  de  Prúfer,  que  se  utiliza  de  uma  técnica  acessível,  sistemática  e  de  fácil 

compreensão, se apresentou neste trabalho como algo muito interessante, curioso e útil. 

 
 
Apresentados algo pouco estudado no Ensino Médio e desconhecido por muitos. 

 Diante do apresentado, este trabalho, além de mostrar definições básicas de função e 

grafos, mostrou também a utilização dessas áreas para uma maneira elegante e interessante de 

provarmos o teorema de Cayley.   

37 

 
 
 
REFERÊNCIA 

38 

BONDY,  J.  A.,  MURTY,  U.  R.  S..  Graph  theory  with  applications.  5°  edn.  New  York: 

North Holland, 1982 

C.L.  Lucchesi.  Introdução  à  Teoria  dos  Grafos.  12º  Colóquio  Brasileiro  de  Matemática. 

IMPA (Instituto de Matemática Pura e Aplicada), 1979. 

Elon  Lages  Lima.  Curso  de  Análise.  Rio  de  Janeiro:  IMPA,  2012.  Volume  1.  (Projeto 

Euclides) 

IEZZI,  Gelson;  MURAKAMI,  Carlos.  Fundamentos  de  Matemática  elementar  1: 

conjuntos e funções. 8º Ed, São Paulo: Editora Atual, 2004. 

GUIDORIZZI, H. Um Curso de Cálculo. Rio de janeiro: LTC, 2001. 4.v. 

HARARY, F.. Graph Theory, 1º edn. Menlo Park: Addison Wesley Pub. Co. Inc. 1969 

LEITHOLD, L.: O Cálculo com Geometria Analítica. Harbra, 1994. 2, v. 

MIRANDA  PINHEIRO,  C.  A.  O  ensino  de  análise  combinatória  a  partir  de  situações-

problema.  2008.  164f.  Dissertação  (Mestrado  em  Educação)  -    Universidade  do  Estado  do 

Pará, 2008. 

MUNIZ  NETO,  Antonio  Caminha.  Tópicos  de  Matemática  Elementar:  combinatória/ 

Caminha Muniz Neto. 2ºed. Rio de Janeiro: SBM, 2016. 

SHINE, Carlos. Programa Olímpico de Treinamento: curso de combinatória – Nível 3. 

Aula 1. Disponível em: 

<https://www.urantiagaia.org/educacional/matematica/combinatoria3/Aula01-Contagem.pdf > 

. Acesso em: 01 de julho de 2018. 

SHINE, Carlos. Programa Olímpico de Treinamento: curso de combinatória – Nível 3. 

Aula 2. Disponível em:  

<https://www.urantiagaia.org/educacional/matematica/combinatoria3/Aula02-

Bijecoes_e_Contagem.pdf> . Acesso em: 01 de julho de 2018. 

 
 
 
39 

SILVA COSTA, E. R. Uma proposta de ensino de análise combinatória  para alunos do 

Ensino Médio. 2013. 107f. Dissertação (Mestrado). Universidade  Federal de Lavras. Minas 

Gerais, 2013. 

STEWART, J. Cálculo. 3° Ed.. São Paulo: Pioneira Thomson Learning, 2006. V.1. 

VAN LINT, J.H; WILSON, R.M. A Course in Combinatorics. Cambridge University Press, 

2001. 

 
