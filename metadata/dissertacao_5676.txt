Osório Cabo Winter

Relações de Recorrência: Para Além de P.A. e P.G.

Santo André, 2013

Universidade Federal do ABC

Centro de Matemática, Computação e Cognição

Osório Cabo Winter

Relações de Recorrência: Para Além de P.A. e P.G.

Orientador: Prof. Dr. Rafael de Mattos Grisi

Dissertação de mestrado apresentada ao Centro

de Matemática, Computação e Cognição para

obtenção do título de Mestre em Matemática

Este exemplar corresponde a versão final da dissertação

defendida pelo aluno Osório Cabo Winter,

e orientada pelo Prof. Dr. Rafael de Mattos Grisi.

Santo André, 2013

Folha de AprovaçãoSubstituir pelo pdf da folha de aprovação assinada pela banca.A G R A D E C I M E N T O S

Agradeço a DEUS, que sempre me iluminou, além de ter me dado condições de

concluir mais esta etapa da minha vida com saúde, paz e sabedoria.

A minha mãe, Olga, que sempre me apoiou e acreditou no meu trabalho.

Aos meus ﬁlhos, Gustavo, Gabriel e Gabriela que souberam suportar esse período

de dedicação e entrega, sem poder passear, viajar nas férias, sem ter a minha pre-

sença e a atenção que tanto mereciam.

À minha esposa, Berenice, que, com muita paciência e sabedoria dispensou-me a

sua total dedicação e apoio em todos os momentos tendo, ainda, a sensibilidade de

compensar a minha ausência junto aos meus ﬁlhos.

Aos professores do PROFMAT-UFABC, que nos incentivaram, com dedicação, a

suprir nossas deﬁciências e alcançar nosso objetivo, auxiliando-nos no que foi pre-

ciso.

Em especial, ao meu orientador Prof. Dr. Rafael de Mattos Grisi, pela excepcional

paciência, ajuda, orientação e empenho no desenvolvimento e sem o qual não exis-

tiria este trabalho.

Aos idealizadores e a CAPES, pois se propuseram e alcançaram a formação dessa

primeira turma, sendo que foi fundamental o apoio ﬁnanceiro para cada um dos

mestrandos.

iii

R E S U M O

Este trabalho tem a ﬁnalidade de mostrar que o ensino de equações de recorrên-

cia no ensino médio pode ir além do tradicional estudo das progressões aritméticas

(P.A.) e progressões geométricas (P.G.), partindo da apresentação de problemas moti-

vadores e encerrando cada capítulo com atividades propostas para veriﬁcação. Para

isso estudaremos alguns problemas clássicos, cuja solução passa pelo estudo de re-

lações de recorrência. Dentre eles estudares o problema das Torres de Hanoi , o

problema de Josephus e o da procriação de coelhos. Mostraremos técnicas para estu-

dar e resolver alguns tipos de equações e problemas de valor inicial. Para terminar

exploraremos a conexão entre computação e equações de recorrência no estudo do

tempo de execução de algoritmos recursivos, em especial algoritmos de ordenamento

e busca em listas.

Palavras-chave: Recorrência, Algoritmos, Complexidade

v

A B S T R A C T

This work aims to show that the teaching of recurrence equations in high school

can go far beyond the traditional study of arithmetic progressions and geometric

progressions, based on the presentation of motivating problems and ending each

chapter with proposed activities for veriﬁcation. In order to do that, we’ll study some

classical problems whose solution involves recurrence relations. Among them are the

problem of the Towers of Hanoi, the problem of Josephus and the breeding of rabbits.

We will show techniques to study and solve some types of recurrence equations and

initial value problems. To ﬁnish we will explore the connection between computation

and recurrence equations in the study of the running time of recursive algorithms,

especially algorithms for sorting and searching.

Keywords: Recurrence, algorithm, complexity

vii

C O N T E Ú D O

Introdução

1

1 recursividade e relações de recorrência

3

1.1 Problemas Recursivos

3

1.1.1 M. C. Escher
1.2 Relação de recorrência
1.3 Relações de Recorrência para Alguns dos Problemas Iniciais

11

8

1.3.1 O problema das Torres de Hanoi
17
1.3.2 O problema de Josephus
1.3.3 O problema dos coelhos
25

23

1.4 Atividades

14

2 conceitos teóricos

29

2.1 Relações de Recorrência

29

2.1.1 Classiﬁcação das Equações de Recorrência

31

2.2 Equações Lineares de 1a ordem

32

Somas Telescópicas

2.2.1
2.2.2 Equações de 1a Ordem com Coeﬁciente Constante
37
2.2.3

Solução do Problema das Torres de Hanói

33

2.3 Solução do Problema de Josephus
2.4 Equações lineares de 2a ordem

40

38

2.4.1 Encontrando a Sequência de Fibonacci

44

2.5 Mudança de variáveis
2.6 Atividades

50

44

3 análise de algoritmos

51

3.1 Algoritmos e Complexidade

51

3.1.1 Análise de Complexidade

52

3.2 Comportamento Assintótico
3.3 Algoritmos de Ordenação de Listas

53

56

14

34

ix

Conteúdo

3.3.1 Ordenação por Seleção (Selection Sort)
3.3.2 Ordenação por Flutuação (Bubble Sort)
3.3.3 Ordenação por Intercalação (Merge Sort)

57

59

62

3.4 Algoritmos de Busca

3.4.1 Busca Sequencial
3.4.2 Busca Binária

65

66

65

3.5 Atividades

69

x

I N T R O D U Ç Ã O

Ao iniciar o estudo com a proposta de problemas tradicionais ou que façam re-

ferência a algo que pode interessar aos alunos, normalmente, levam os mesmos a

reﬂetirem sobre os problemas apresentados e assim despertar interesse pelos assun-

tos que devem surgir e serem apresentados logo em seguida aos exercícios.

A apresentação do conteúdo, leva os alunos a tentarem associar e utilizar aquilo

que está sendo trabalhado na resolução dos problemas que estão aguardando para

serem resolvidos.

Um algoritmo é um procedimento consistindo de um conjunto de regras, provido

de clareza, as quais devem ser cumpridas em uma sequência ﬁnita de operações.

Uma ferramenta útil e poderosa, não só na matemática, mas também para a com-

putação, é a recursividade e um algoritmo recursivo pode ser explorado através das

relações dele gerado e que podem ser utilizados na resolução dos problemas aqui

propostos .

Vamos apresentar uma forma de trabalhar sobre o assunto proposto com os alunos

do ensino médio.

Iniciamos o capítulo 1 apresentando alguns problemas para motivar e despertar o
interesse pela resolução dos mesmos. Utilizamos problemas tradicionais como “as

torres de Hanoi”, “O problemas dos coelhos”, onde aparece a conhecida sequência

de Fibonacci, e “o problema de Josephus”. Em seguida, apresentamos a deﬁnição

de recursão e alguns trabalhos que mostram o chamado efeito droste de autoria de

Maurits Cornelis Escher , um artista gráﬁco holandês, conhecido pelas suas xilogra-

vuras, litograﬁas e meios-tons, que tendem a representar construções impossíveis .

Os fractais que tiveram impulso no seu estudo, e que receberam essa denominação

na década de setenta. Depois apresentamos a solução dos problemas iniciais, de

forma prática, em ordem do grau de diﬁculdade e acrescentando-se aos problemas o

contexto baseado nos relatos da história da matemática, encerrando o capítulo com

algumas atividades propostas visando aprofundamento no assunto tratado.

1

Introdução

No segundo capítulo, são apresentados os conceitos teóricos relacionados equa-

ções de recorrência. Apresentaremos algumas técnicas de resolução para problemas

de valor inicial, apresentando a solução geral para os mesmos, além de outros exem-

plos de aplicação

No terceiro capítulo tratamos de uma aplicação prática das relações de recorrência:

a análise de complexidade de algoritmos. Estudaremos o tempo de execução de di-

versos algoritmos, analisando sua ordem de grandeza. Para exempliﬁcar, estudamos

alguns métodos de ordenação de listas (Selection Sort, Bubble Sort e Merge Sort)

passando ao estudo de métodos de busca (Busca Sequencial e Busca Binária).

2

R E C U R S I V I D A D E E R E L A Ç Õ E S D E R E C O R R Ê N C I A

1

“De que me irei ocupar no céu, durante

toda a Eternidade, se não me derem uma

inﬁnidade de problemas de Matemática

para resolver? ”

— Augustin Louis Cauchy

1.1

problemas recursivos

Considere os problemas abaixo.

Problema 1. Torres de Hanói

É um jogo que consiste em uma base de madeira onde estão ﬁrmados três hastes

verticais, e um certo número n de discos de madeira, de diâmetros diferentes, fu-

rados no centro e podemos chamar de A, B e C, as três hastes, conforme a ﬁgura

abaixo.

3

nDiscosABCrecursividade e relações de recorrência

No começo do jogo os discos estão todos na haste A, em ordem decrescente de

tamanho, com o menor disco sobre os demais. O objetivo é mover todos os discos,

de A para C, podendo utilizar a haste B, deixando-os na mesma ordem e obedecendo

às seguintes regras:

1. Somente um disco pode ser posto de cada vez;

2. Um disco maior nunca pode ser posto sobre um disco menor.

Assim, responda: Qual o número de movimentos necessários para se cumprir essa

tarefa se o número de discos é cinco?

Problema 2. O Problema de Josephus (Roleta Romana)

Um grupo de soldados é circundado por uma força inimiga esmagadora. Não

há esperança de vitória e só existe um cavalo disponível para escapar! Os soldados

entram num acordo para determinar qual deles deverá escapar para trazer ajuda.

Para tanto eles irão utilizar o método da roleta romana para selecionar o soldado

sortudo. O procedimento funciona da seguinte forma:

1. Os soldados se dispõe em círculo respeitando certa sequência ﬁxa.

2. Um número n > 0 é sorteado. Um dos nomes dos soldados também é sorteado.

3. Começando-se pelo soldado cujo nome foi sorteado, eles iniciam uma conta-
gem sequencial ao longo do círculo em sentido horário. Quando a contagem

alcança o n-ésimo soldado, ele é retirado do círculo ( portanto eliminado da

escolha) e a contagem reinicia com o soldado seguinte.

4. O processo continua de maneira que, toda vez que n é alcançado, outro soldado
é eliminado do círculo (lembre-se, todo soldado retirado do círculo não entra

mais na contagem).

5. O último soldado que restar deverá montar o cavalo e escapar.

Pergunta-se: Em qual posição do circulo deve ﬁcar o soldado para que possa

escapar da força inimiga?

4

1.1 problemas recursivos

Problema 3. O Problema dos Coelhos

Um sitiante resolve criar coelhos e para iniciar essa criação adquire um casal de

coelhos recém nascidos e recebe as seguintes instruções:

1. No primeiro mês tem-se apenas um casal;

2. Casais reproduzem-se somente após o segundo mês de vida;

3. Não há problemas genéticos no cruzamento consanguíneo;

4. Todos os meses, cada casal fértil dá à luz um novo casal;

5. Os coelhos nunca morrem.

Pergunta-se: Quantos casais de coelhos podem ser gerados a partir de um casal

de coelhos em um ano?

Problema 4. Ordenando Listas

Seja a lista não ordenada:

23, 27, 41, 19, 91, 62, 54, 26, 38, 12, 10, 11

.

}

{

Pergunta-se: Quantas comparações, no mínimo, devem ser feitas entre os elemen-

tos da lista dada de modo a deixá-la na forma ordenada crescente?

Problema 5. Busca em Listas

Vamos considerar o seguinte jogo: um jogador A pensa em um número de 1 a
1000, e um jogador B tem que acertar este número “chutando” o menor número de
vezes possível. A cada chute do jogador B, o jogador A vai dizer apenas se o número

escolhido por ele é maior ou menor que o número dito por B.

Pergunta-se:

Qual o número máximo de chutes que o jogador B precisará dar para descobrir o

número escolhido por A? Qual o estratégia que ele deve utilizar para isso?

5

recursividade e relações de recorrência

Apesar de a primeira vista os problemas acima parecerem não relacionados, suas

soluções são exemplos de uma importante classe de problemas matemáticos: os

problemas recursivos.

Um objeto é denominado recursivo quando sua deﬁnição é parcialmente feita em

termos dele mesmo. A recursividade (ou recursão) é encontrada principalmente

na matemática, mas está presente em diversas situações do cotidiano. Por exemplo,

quando um objeto é colocado entre dois espelhos planos, apontados um para o outro,

surge uma imagem recursiva (uma imagem do objeto reﬂetida do outro espelho) e

sucessivamente surge a mesma ﬁgura reﬂetida mais de uma vez.

Outro exemplo, de recursividade, é quando uma ﬁgura apresenta a si mesma na

própria ﬁgura, como na Figura 1.

Figura 1: Forma visual de recursão conhecida como efeito Droste.

Na matemática e na ciência da computação, a recursão constrói uma classe de

objetos ou métodos deﬁnindo alguns casos base ou métodos simples, para então

deﬁnir regras que descrevam casos complexos em termos de casos mais simples.

A deﬁnição formal dos números naturais, por exemplo, diz que zero é um número

natural, e todo número natural tem um sucessor, que é também um número natural.

Neste caso, um número natural é deﬁnido como sucessor de outro, que é deﬁnido

da mesma forma, seguindo assim até atingirmos o zero, que foi deﬁnido a princípio.

6

1.1 problemas recursivos

Ou seja, o 51 é sucessor do 50, que por sua vez é sucessor do 49, e assim por diante
até chegar ao zero, que é o primeiro elemento deﬁnido.

Deﬁnições como essa, frequentemente encontradas na matemática, são exemplos

de deﬁnições recursivas, pois um objeto é deﬁnido a partir de um objeto anterior.

Tais problemas possuem portanto a seguinte propriedade: cada instância do pro-

blema contém uma instância menor do mesmo problema. Dizemos assim que estes

problemas possuem estrutura recursiva, e para resolvê-los podemos aplicar o se-

guinte método:

•

•

se a instância em questão é pequena, resolva-a diretamente;

senão, reduza-a a uma instância menor do mesmo problema, e aplique o mé-

todo à instância menor.

Exemplo 1.1. Permutação

A recursividade pode ser utilizada para gerar todas as possíveis permutações de

um conjunto de símbolos. Por exemplo, existem seis permutações no conjunto de

símbolos A, B e C: ABC, ACB, BAC, BCA, CBA e CAB. O conjunto de permuta-

ções de n símbolos é gerado tomando-se cada símbolo por vez e preﬁxando-o a todas

as permutações que resultam dos (n

esquematizados da seguinte forma.

−

1) símbolos restantes. Tais passos podem ser

Se n = 1, então só existe uma permutação possível.

Se n > 1 siga os passos abaixo para cada elemento do conjunto:

•

•

– Retire o elemento escolhido;

– Gere todas as permutações possíveis dos (n

1) elementos restantes;

−

– Junte o elemento escolhido a cada permutação gerada.

Na computação, a aplicação de tal método gera os chamados algoritmos recursivos.

Dentre os exemplos importantes do uso da recursividade em ciência da computação

está um método comum de simpliﬁcação que consiste em dividir um problema em
subproblemas do mesmo tipo, denominada de divisão e conquista. No capítulo 3
trataremos de uma solução utilizando tal método.

7

recursividade e relações de recorrência

Outro conjunto importante de objetos que podem ser deﬁnidos recursivamente são

os fractais, onde versões menores de um mesmo objeto são recursivamente “colados”
no objeto anterior, formando a ﬁgura que conhecemos por fractal. As ﬁguras 2 e 3
mostram estágios intermediários da construção de fractais.

Figura 2: Quatro fases na construção de um Floco de neve de Koch, como em muitos outros
fractais, os estágios são obtidos através de uma deﬁnição recursiva.

Figura 3: O Triângulo de Sierpinski é formado dividindo um triângulo em 4 triângulos de
mesmo tamanho e retirando o triângulo central. Este procedimento é repetido indeﬁnida-

mente para cada triângulo restante.

A próxima seção é lúdica e será dedicada a um artista que usou a matemática

como fonte de inspiração para muitas de suas obras, e onde elementos recursivos

são frequentemente encontrados.

1.1.1 M. C. Escher

Maurits Cornelis Escher foi um artista holandês do início do século XX, que ﬁcou

conhecido pela forte presença de elementos matemáticos em suas obras. Nascido

8

1.1 problemas recursivos

em Leenward, Holanda em junho de 1898, era ﬁlho de um engenheiro civil, que o
encorajou desde cedo a aprender artes ligadas à carpintaria. Neste período aprendeu

técnicas que o ajudariam muito nos seus trabalhos futuros.

Escher era considerado um aluno fraco na escola, mas seus interesses por gra-

vuras apareceram ainda cedo. Durante seus anos na escola secundária, que nunca

concluiu, Escher começou a fazer lineo-gravuras, com a companhia de um amigo.O
seu primeiro trabalho, Pássaro numa gaiola, de 1916, não fez sucesso entre seus
professores.

O fascínio de Escher pela matemática ﬁca clara em parte signiﬁcativa de suas

obras. Conceitos como rotações, translações, simetrias e até mesmo o inﬁnito, estão

presentes em vários de seus trabalhos. É interessante observar no entanto que Escher

não tinha nenhuma formação matemática, tendo ele mesmo dito diversas vezes que

não se considerava um matemático. Mas não deixava de reconhecer a proximidade

de seu trabalho com a matemática.

Seus trabalhos chegaram a ser expostos em uma edição do ICM (International

Congress of Mathematicians), onde travou contato com matemáticos famosos como

Penrose e Coxeter. Este último chegou a usar ilustrações de Escher em um de seus
artigos cientíﬁcos. Maiores detalhes podem ser encontrados em [2].

Durante sua vida, fez 448 litograﬁas, xilogravuras e gravuras em madeira e mais

de 2000 desenhos e esboços. [3]

A seguir, apresentamos três de seus trabalhos.

O primeiro (Figura 4), conhecido como Fractal do Lagarto, traz uma estrutura re-
cursiva bastante clara. Cada “anel” de lagartos é repitido sistematicamente para
dentro, reduzindo sua área. De acordo com [4], “...cada elemento (em forma de rép-
til) deste padrão, dirigindo-se para o centro, é sistemática e continuamente reduzida

a metade...”. Tal padrão pode ser repetido até ﬁcar inﬁnitamente pequeno, dependo

principalmente da habilidade do gravador, e da qualidade e precisão dos materiais
disponíveis. No caso desta ﬁgura, retirada de [4], a precisão é extraordinária. O
menor dos répteis tem 2mm, e está desenhado inteiramente, com pernas, cabeça e
cauda.

9

recursividade e relações de recorrência

Escher se deteve no estudo dos contrastes e paradoxos visuais, os loopings eternos,

expondo padrões que se replicam e se reﬂetem ao inﬁnito (antecipando o que veio a
ser a geometria fractal de Mandelbrot de 1970).

Figura 4: A gravura em madeira: Cada vez mais pequeno I (1956) - M.C.Escher

Na segunda (Figura 5), temos: "As componentes reduzem-se de dentro para fora.
As seis maiores, três anjos brancos e três demónios pretos, estão ordenadas radial-

mente em volta do centro. O disco está dividido em seis setores, onde dominam os

anjos, frente a um fundo preto e os demónios, frente a um branco. O céu e o inferno
aparecem alternadamente seis vezes.". [3]

A terceira (Figura ?? mostra a Escher desenhando a si mesmo, em uma simples,

mas bonita alusão ao conceito de recorrência.

10

1.2 relação de recorrência

Figura 5: Limite Circular IV (1960) - M.C.Escher

Figura 6: Desenhando-se (1948) - M.C.Escher

1.2 relação de recorrência

Uma relação de recorrência para a sequência (an) é uma equação que expressa an
1), n = 2, 3, 4, 5 . . ., assim uma

em função de um ou mais termos anteriores (a1, . . . , an

−

11

recursividade e relações de recorrência

sequência é uma solução de uma relação de recorrência se os seus termos satisfazem

esta relação de recorrência e as condições iniciais.

As condições iniciais para uma sequência especiﬁcam os termos que precedem o

primeiro termo onde a relação de recorrência atua.

Exemplo 1.2. Função Fatorial

Esta função é um dos exemplos clássicos de recursividade e, por isso, de citação

quase obrigatória. Eis sua deﬁnição recursiva:

(cid:40)

n! =

1

(n

n

·

−

1)!

,

,

se n = 0;
se n > 0.

Outra forma de apresentar é, fazendo F(n) = n!, temos que F(n) pode ser deﬁnida

por

F(n) =

(cid:40)

1

F(n

n

·

−

1)

,

,

se n = 0;
se n > 0.

Assim, podemos veriﬁcar que

n! = n

(n

1)

·

−

(n

−

2)

·

3

2

·

·

1,

· · ·

onde n é um número natural.

Seguindo a deﬁnição acima, vamos determinar, por exemplo, o cálculo de 4!.

4! = 4.3!

= 4.[3.(3

1)! ]

−

= 4.3.2!

= 4.3.[2.(2

1)! ]

−

= 4.3.2.1!

= 4.3.2.1.(1

1)!

−

= 4.3.2.1.0!

= 4.3.2.1.1

= 24.

12

Dois exemplos bastante conhecidos de relações de recorrência presentes no currí-

culo atual do ensino médio são as chamadas progressões aritmética e geométrica.

1.2 relação de recorrência

Exemplo 1.3. Progressão Aritmética - P.A.

Entre as sequências numéricas, se destacam aquelas conhecidas como progressões

aritméticas (P.A.), onde cada termo (a partir do segundo) desse tipo de sequência é

determinado pela soma do termo anterior com um valor real (r) chamado de razão

r = an+1 −

an, n = 1, 2, 3, 4, . . .

Assim a sequência an é dada por

a2 = a1 + r,

a3 = a2 + r,

a4 = a3 + r,
...

an = an

1 + r,

−

onde a1 é um valor dado (condição inicial), sendo que a fórmula explicita (ou solução
fechada) é:

an = a1 + (n

1)r.

−

Exemplo 1.4. Progressão Geométrica - P.G.

Outro grupo de sequências, chamado de progressão geométrica (P.G.), onde cada

elemento, a partir do segundo, é determinado pelo produto do termo anterior com

13

recursividade e relações de recorrência

uma constante real, chamada de razão q = an+1/an, para n = 1, 2, 3, 4, . . ., e quando
não se trata de P.G. quase nula (q = 0). Assim a sequência (an) é dada por

q,

q,

q,

a2 = a1 ·
a3 = a2 ·
a4 = a3 ·
...

an = an

q,

1 ·

−

onde a1 é um valor dado (condição inicial), sendo que a fórmula explicita (ou solução
fechada) é:

an = a1 ·

qn

1.

−

1.3 relações de recorrência para alguns dos problemas iniciais

A seguir, falaremos dos problemas das Torres de Hanoi e de Josephus. O problema
de ordenação dos elementos da lista (Problema 4) e o problema de procura de um
número em uma lista dada (Problema 5) serão tratados no terceiro capítulo devido
a necessidade de veriﬁcação dos diferentes métodos de ordenação e de busca que

podem ser utilizados para a resolução dos mesmos e que naquele capítulo serão

abordados.

1.3.1 O problema das Torres de Hanoi

O problema das Torres de Hanói vem servindo de exemplo no estudo de recorrên-

cias há muito tempo. Considerações sobre ele foram feitas pelo matemático francês
François Édouard Anatole Lucas (1842-1891), professor no Lycée Saint Louis e poste-
riormente no Lycée Charlemagne, ambos em Paris. Édouard Lucas tratou das Torres
de Hanóiem suas notas Récréations mathématiques - quatrième volume de 1883, e pos-
teriormente de forma mais elaborada, em 1889, no livro Jeux Scientiﬁques pour servir

14

1.3 relações de recorrência para alguns dos problemas iniciais

à lt’Histoire, à lÉnseignement et à la Pratique du Calcule et du Dessin - Premiére sèrie no
3 [5].

De acordo com [6], o problema Torres de Hanói tem sua origem em uma antiga
lenda hindu, passada na cidade sagrada de Bernares na Índia. Conta a lenda que
em Bernares existia um tempo com 3 torres sagradas do bramanismo, e que no
início dos tempos os monges teriam recebido uma pilha de 64 discos de ouro de
diâmetro distintos, cada qual com um furo no meio. Os discos estavam empilhados

em uma das torres de modo que acima de cada disco estivesse apenas um disco de

diâmetro menor. Os monges receberam então a incumbência de transferir a pilha

de discos para uma segunda torre, com o auxílio da terceira torre, seguindo apenas

duas regras: os discos deveriam ser movimentados individualmente, e um disco

maior nunca deveria ﬁcar sobre um disco menor. O ﬁm da tarefa marcaria então o

ﬁm do mundo.

Vamos agora tentar modelar o problema de forma recursiva, para no próximo

capítulo resolvê-lo.

Comecemos estudando o problema para uma quantidade de discos igual a 4. Para

um total de n discos denotaremos a quantidade de movimentos por Q(n). Assim:

Se n = 1 , então Q(1) = 1. Ou seja, a quantidade de movimentos para levar o único

disco do pino A para o pino C é de apenas um movimento.

Se n = 2, onde 1 é o disco menor e 2 o disco maior, então os passos são: levar o
disco 1 para o pino B (1B), levar o disco 2 para o pino C (2C) e colocar o disco 1
sobre o 2 em C (1C), então Q(2) = 3.

Para n = 3, sendo os discos 1, 2 e 3, ordenados de forma crescente, temos que a
ordem e a menor quantidade de movimentos para colocar os discos no pino C são:

1C, 2B, 1B, 3C, 1A , 2C e 1C, sendo Q(3) = 7;

Para n = 4 , onde a ordem crescente é 1, 2, 3 e 4. Os movimentos são: 1B, 2C, 1C,

3B, 1A, 2B, 1B, 4C, 1C, 2A, 1A, 3C, 1B, 2C e 1C, assim Q(4) = 15.

Assim, temos como resposta do problema: são necessários 15 movimentos para

levar os quatro discos da haste A para a C.

Vamos desconstruir a solução acima. Para n = 4 observe que os primeiros passos

(1B, 2C, 1C, 3B, 1A, 2B, 1B) são os mesmos utilizados no caso n = 3 mudando apenas

15

recursividade e relações de recorrência

as torres utilizadas. Estes passos transferem os três discos menores da torre A para
a B. A seguir movemos o disco 4 para a torre C. E terminamos fazendo a sequência
(1C, 2A, 1A, 3C, 1B, 2C e 1C) que repete o procedimento de n = 3 para levar os pinos

de B para C.

Esta mesma análise é válida para n = 3 e para n = 2.

Deste modo podemos generalizar o problema e tratar o caso geral para n discos.

Neste caso, para n discos, primeiro movemos os (n

1) discos menores para o

−

pino B, depois colocamos o disco n no pino C, e teminamos colocando os (n

1)

−

discos do pino B sobre o disco n no pino C. Assim temos

e

Q(n) = Q(n

1) + 1 + Q(n

1)

−

−




Q(n) = 2Q(n

1) + 1, n

2.

≥

−



Q(1) = 1.

Cálculos que apresentaremos no capítulo 2 nos permitem concluir que

Q(n) = 2n

1, n

−

≥

1 (fórmula explicita ou solução fechada).

Construindo uma tabela para alguns valores de n obtemos

n

Q(n)

Q(n)

1

2

3

4

5

2.0 + 1 = 1
21

1 = 1

−

2.1 + 1 = 3
22

1 = 3

−

2.3 + 1 = 7
23

1 = 7

−

2.7 + 1 = 15
24

1 = 15

−

2.15 + 1 = 31
25

1 = 31

−

· · ·

· · ·

· · ·

No caso dos monges, onde n = 64, a quantidade de movimentos é Q(64) = 264

1 =
18.446.744.073.709.551.615. Supondo que cada movimento leve 1 microssegundo (sig-
niﬁca efetuar 1 000 000 de movimentos em um segundo) , então o tempo necessário
para efetuar todos os movimentos é de um pouco mais de 213.503.982 dias que é um
número maior que 584.942 anos.

−

No próximo capítulo iremos veriﬁcar e provar as equações explícitas apresenta-

das aqui, utilizando algumas técnicas conhecidas pelos alunos e outras que serão

apresentadas com essa ﬁnalidade.

16

1.3 relações de recorrência para alguns dos problemas iniciais

1.3.2 O problema de Josephus

Segundo Jane Bichmacher de Glasman em [7], Yossef ben Matitiahu Ha-Cohen,
um dos líderes da 1a Revolta Judaica contra o Império Romano termina seus dias

em Roma, onde adota o nome de Flavius Josephus. Lá escreve a história e apologia

da Nação Judaica e de si mesmo, suspeito tanto aos olhos de seus correligionários,

quanto aos olhos dos romanos.

Em 20 de julho de 67 EC (Era Comum, o mesmo que depois de Cristo, DC), dia
da queda de Jotapata ( aldeia judaica), ocorre o mais suspeito episódio da vida de

Josephus, descrito por ele na terceira pessoa.

”...Depois da queda da cidade, fugindo em meio aos inimigos, ele [Jo-

sephus] desceu a um poço muito profundo ao lado do qual havia uma
caverna espaçosa, que não podia ser vista do alto. Lá encontrou 40 dos
mais valentes dos seus, que também ali se tinham refugiado e que tinham

todo o necessário para vários dias(...). Dois dias assim se passaram; no

terceiro, uma mulher o denunciou(...). Vespasiano mandou Paulino e Ga-

licano, dois tribunos, garantir-lhe que o trataria bem, exortando-o a sair;

ele não quis fazê-lo, porque, não estando persuadido da clemência dos

romanos, e sabendo do seu ressentimento pelo mal que lhes havia feito,
temia que quando o tivessem em seu poder, procurassem vingar-se.” [7]

Não conseguindo convencê-lo a se entregar, os romanos decidiram incendiar a

caverna, só não o fazendo porque Vespasiano o queria vivo, e convida Josephus a

se render, prometendo poupá-lo. Perante seus companheiros, aceitar tal proposta

seria uma traição: todos prefeririam morrer a se entregar. Josephus dissuadiu-os do

suicídio e propôs que se estrangulassem reciprocamente numa ordem determinada

por sorteio.

”Para ver quem deverá ser morto por primeiro por aquele que o se-

guirá; continuemos a fazer sempre do mesmo modo, a ﬁm de que ne-

nhum de nós se mate por si mesmo, mas receba a morte das mãos de
outro.” [7]

Restaram vivos somente ele e um companheiro, como ele mesmo tenta explicar,

constrangido:

17

recursividade e relações de recorrência

”Isso continuou até que restavam somente Josephus e outro; o que acon-
teceu, talvez, por uma especial proteção de Deus ou por casualidade.” [7]

Teria havido um truque ao tirar a sorte? Feito prisioneiro, Josephus prediz a Vespa-

siano que ele ostentaria em breve a púrpura imperial; quando tal se conﬁrmou, em
69 EC, foi liberto, como recompensa, e passou a ser protegido dos romanos.

solução:
situação apresenta pelo próprio Josephus segundo a escritora. Vamos apresentar a re-

O problema inicial é uma das variantes encontradas na literatura da

solução do problema para o número sorteado 2 e considerando o início da contagem
para exclusão pelo soldado 1 (primeiro soldado).

Seja n o número de soldados, onde cada número natural representa um soldado

e sua posição no círculo inicial e vamos representar por J(n) o soldado vitorioso

(aquele que ﬁca por último).

Assim: Para n = 1, existe somente o soldado 1 , logo J(1) = 1;

Para n = 2, existem os soldados 1 e 2, sendo que o primeiro elimina o soldado 2,

então J(2) = 1.

Veriﬁcando-se para n = 2m a solução é J(2m) = 1.

Demonstração:

Para m = 0 ou 1 já estão veriﬁcados, então para m = 2, 3, 4, 5, . . ., pode-se veriﬁ-
car que após a primeira rodada de eliminação os soldados “pares” são eliminados
(sempre) e a quantidade de soldados restantes é n = 2m
1 que é par e fazendo a
renumeração dos soldados somente o soldado 1 não é renumerado. Com uma nova
rodada de eliminação, restam n = 2m
2 soldados, sendo n par e, de maneira aná-

−

−

loga, renomeando-se os soldados restantes a partir do segundo soldado e fazendo as

demais rodadas de eliminação continuam restando um número par de soldados do
tipo n = 2m, até chegar a n = 20 = 1 que tem como vencedor o primeiro soldado (1)
então,

J(2m) = J(2m

1) = J(2m

2) =

−

−

= J(21) = J(20) = 1.

· · ·

Iniciando a construção de uma tabela de resultados de J(n) para n = 18, tem-se:

n

J(n)

3

1

1

2

1

4

1

5

6

7

8

1

9

10

11

12

13

14

15

16

17

18

1

18

1.3 relações de recorrência para alguns dos problemas iniciais

Para n = 2m + 1, onde m = 1, 2, 3, 4, . . . (observe que para m = 0, o caso já foi
1 + 1 e

estudado) a quantidade de soldados pares é 2m

1 e de soldados ímpar é 2m

−

−

fazendo a primeira rodada de eliminação, os pares são eliminados e o último soldado
(que é ímpar) elimina o soldado 1, assim restam (2m
1 soldados.
Voltamos assim à situação de n = 2m
1, onde o vencedor é o primeiro soldado, mas
com a diferença de que desta vez o primeiro soldado é o de número 3, já que o
soldado de número 1 havia sido eliminado. Segue assim que e J(2m + 1) = 3.

1 = 2m

1 + 1)

−

−

−

−

Assim, fazendo J(2m + 1) = 3 a tabela ﬁca:

n

J(n)

1

1

2

1

3

3

4

1

5

3

6

7

8

1

9

3

10

11

12

13

14

15

16

17

18

1

3

Para n = 2m + 2, onde m = 2, 3, 4, 5, . . . (pois, para m = 0, 1 já foram veriﬁcadas as

soluções) o número de soldados é par, assim após a primeira rodada de eliminação
restam os soldados “impares”, com um total de 2m
1 + 1 soldados. O próximo sol-
dado eliminado é o de número 3. Isso nos deixa mais uma vez com um total de 2m
1

−

−

soldados, mas desta vez o soldado número 5 é o primeiro da ﬁla. Segue assim que

J(2m + 2) = 5, e podemos mais uma vez atualizar nossa tabela.

n

J(n)

1

1

2

1

3

3

4

1

5

3

6

5

7

8

1

9

3

10

11

12

13

14

15

16

17

18

5

1

3

5

Para n = 2m + 3, onde m = 2, 3, 4, . . ., seguindo o mesmo raciocínio, após uma
primeira rodada de eliminações restam os soldados “impares” em um total de 2m
1 +
2 soldados. A seguir, assim como no caso n = 2m + 1, como o total de soldados era
ímpar, o soldado 1 é eliminado pelo último soldado, e seguindo a regra o soldado 3
1 soldados, sendo o de número 7 o primeiro
elimina o número 5. Restando agora 2m
da sequência. Assim, J(2m + 3) = 7 para m = 2, 3, 4, . . . e a tabela ﬁca:

−

−

n

J(n)

1

1

2

1

3

3

4

1

5

3

6

5

7

7

8

1

9

3

10

11

12

13

14

15

16

17

18

5

7

1

3

5

Analogamente, a construção da tabela com número n de soldados o J(n) em cada

caso será:

Para n = 2m + 4, (com m = 3, 4, 5, . . .) temos J(2m + 4) = J(2m + 3) + 2 = 7 + 2 = 9;

Para n = 2m + 5, (com m = 3, 4, 5, . . .) temos J(2m + 5) = J(2m + 4) + 2 = 9 + 2 = 11;

•

•

19

recursividade e relações de recorrência

Para n = 2m + 6, (com m = 3, 4, 5, . . .) temos J(2m + 6) = J(2m + 5) + 2 = 11 + 2 = 13;

Para n = 2m + 7, (com m = 3, 4, 5, . . .) temos J(2m + 7) = J(2m + 6) + 2 = 13 + 2 = 15;

•

•

• · · ·
Assim, pode-se construir todos os valores possíveis de n, onde a tabela ﬁca:

n

J(n)

1

1

2

1

3

3

4

1

5

3

6

5

7

7

8

1

9

3

10

11

12

5

7

9

13

11

14

13

15

15

16

17

18

1

3

5

A seguir, daremos outro argumento para cálculo de J(n) e mostraremos que, escre-

1

vendo n = 2m + p , onde m é o maior número natural possível e p

−
, o soldado vencedor será J(n) = 2p + 1. Ou seja, o soldado que irá montar o cavalo

}
e buscar ajuda será aquele que ocupa a posição 2p + 1, sendo que a quantidade de
soldados é n = 2m + p , onde m é o maior expoente da base 2 menor ou igual a n.

∈ {

0, 1, 2, . . . , 2m

−

1

segunda análise

Iniciamos com o caso n = 2m onde, seguindo os mesmos

argumentos da análise anterior veriﬁcamos que

J(2m) = 1.

Voltamos nossa atenção para o caso onde n = 2k é par, mas não da forma n = 2m.

Neste caso existem k soldados “pares” e k soldados “ímpares”.

Após uma primeira rodada de eliminações os soldados pares são eliminados res-

tando apenas k soldados impares. Isso relaciona a instância 2k com a instância k do

mesmo problema a não ser por uma pequena diferença: os soldados restantes são to-

dos ímpares, e na representação que estabelecemos usamos enumeração sequencial

sem desconsiderar nenhum número.

Para resolver o problema vamos mudar a etiqueta de cada soldado restante de modo

a recuperar a representação que queremos. Para isso o soldado 1 receberá a etiqueta

1(cid:48), o soldado 3 receberá a etiqueta 2(cid:48), o 5 ﬁcará com a etiqueta 3(cid:48) e assim por diante.

Observe a Figura 7 para entender melhor o processo que acabamos de descrever.

Segue assim que o soldado escolhido na instância 2n será o mesmo que da instân-

cia n, mas agora com nova etiqueta. Ou seja,

J(2n) = [J(n)](cid:48) = 2J(n)

1.

−

(1.1)

20

1.3 relações de recorrência para alguns dos problemas iniciais

Figura 7: Reenumeração de etiquetas no problema de Josephus - caso n par

Seja n ímpar da forma n = 2k + 1, então existem k soldados “pares” e k + 1 soldados

“ímpares”. Do mesmo modo que antes, a primeira rodada elimina todos os soldados

pares, mas desta vez o último soldado é ímpar, fazendo com que o soldado de
número 1 seja o próximo eliminado. Desta forma eliminados todos os k soldados
pares, mais o soldado número 1, ﬁcando com apenas k soldados ímpares, sendo
o soldado 3 o primeiro da sequência. Mais uma vez, para podermos chamar a

instância k do problema precisamos reenumerar os soldados, atribuindo a eles uma
nova etiqueta, como indicado na Figura 8.

Figura 8: Reenumeração de etiquetas no problema de Josephus - caso 2n + 1 ímpar

Segue assim que

J(2n + 1) = [J(n)](cid:48)(cid:48) = 2J(n) + 1.

Tome agora n ímpar, mas da forma n = 2k

1. Neste caso existem k

−

“pares” e k soldados “ímpares”. Assim como no caso anterior, começamos eliminado

todos os pares, o que nos deixa com k soldados ímpares. Como queremos relacionar

21

(1.2)

1 soldados

−

12345672k2k−12k−22k−32k−42k−5Início2arodada××××××13572j−12k−11"2"3"4"j"k"12345672k+12k2k−12k−22k−32k−4Início2arodada×××××××35792j+12k+11!!2!!3!!4!!j!!k!!recursividade e relações de recorrência

a instância 2k
o soldado 1.

−

1 com a instância k, faremos a mudança de etiqueta antes de eliminar

Note agora que precisamos reenumerar os soldados de forma consistente com a

representação que adotamos inicialmente. Na nossa representação original, sempre
que existem mais de 2 soldados na ﬁla, o segundo soldado é sempre o primeiro a ser
eliminado. Nós já eliminamos todos os soldados pares, e dos k soldados restantes o
primeiro a ser eliminado será o soldado 1. Com isso, para que a nova enumeração
seja consistente, precisamos que o soldado 1 receba a etiqueta 2(cid:48)(cid:48)(cid:48). A Figura 9 deve
esclarecer os argumentos acima.

1

−

(1.3)

Figura 9: Reenumeração de etiquetas no problema de Josephus - caso 2n

Segue que

J(2k

−

1) = [J(k)](cid:48)(cid:48)(cid:48) = 2J(k)

3.

−

Das equações (1.1) e (1.3) temos que

J(2k) = 2J(k)

1

e

J(2k

−

e portanto

J(2k) = 2J(k)

1

−

−

2 + 2 = [2J(k)

Agora, se n = 2k isto é o mesmo que

1) = 2J(k)

3,

−

3] + 2 = J(2k

1) + 2

−

−

−

J(n) = J(n

1) + 2

−

(1.4)

Do mesmo modo, as equações (1.2) e (1.1) dizem que

J(2k + 1) = 2J(k) + 1

e

J(2k) = 2J(k)

1,

−

22

12345672k−12k−22k−32k−42k−52k−6Início2arodada××××××2k−11352j−32k−31"""2"""3"""4"""j"""k"""1.3 relações de recorrência para alguns dos problemas iniciais

de onde segue que

J(2k + 1) = 2J(k)

−

1 + 1 + 1 = [2J(k)

−

1] + 2 = J(2k) + 2.

Assim, se n = 2k + 1 temos

que é igual a (1.4).

Resumidamente, temos

J(n) = J(n

1) + 2,

−

(cid:40)

J(n) =

1

,

se n = 2m para algum m

J(n

−

1) + 2 ,

se n

3 e n

= 2m,

m

∀

≥

≥

0;

≥
0.

(1.5)

1.3.3 O problema dos coelhos

O título Liber Abaci que signiﬁca o "Livro do Cálculo", é um livro histórico sobre
aritmética escrito por Leonardo Fibonacci (ou Leonardo de Pisa) em 1202. A segunda
edição, de 1228, é a que hoje é conhecida.

A teoria contida em Liber Abaci é ilustrada com muitos problemas que represen-

tam uma grande parte do livro. Nele aparece um problema que envolve o cresci-

mento de uma população hipotética de coelhos com base em pressupostos idealiza-

dos. A solução, de geração em geração, era uma sequência de números que mais

tarde conhecida como sequência de Fibonacci. A sequência numérica era conhecida

por matemáticos indianos já no século VI, mas foi o Liber Abaci que a introduziu no
Ocidente. (Ver [8])

solução:
primeiro mês, um único casal jovem.

Ao ﬁxar como mês um o início do processo, tem-se, no início do

Já no segundo mês, esse casal será adulto.

Considerando-se que um par adulto produz um novo par a cada mês, no início do

terceiro mês existirão dois pares de coelhos, sendo um par adulto e outro recém-

nascido.

No início do quarto mês o par adulto produzirá mais um par, enquanto que o

outro par completará um mês de vida e ainda não estará apto a reproduzir. Assim,

23

(cid:54)
recursividade e relações de recorrência

existirão três pares de coelhos, sendo um par adulto, um par com um mês de idade

e mais um par recém-nascido.

No início do quinto mês existirão dois pares adultos, sendo que cada um deles

já reproduz um novo par e mais um par que completou um mês de vida. Logo,

existirão cinco pares.

No início do sexto mês existirão três pares adultos, sendo que cada um reproduz

um novo par e mais dois pares que completam um mês de vida. Logo, existirão oito

pares.

Seguindo-se o mesmo raciocínio para os outros meses, obtém-se a famosa Sequên-
cia de Fibonacci, cujos primeiros termos são: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, . . .,
tal sequência recebe o nome “Fibonacci” devido ao apelido dado a Leonardo de Pisa

por Baldassare Boncompagni, seu editor de trabalhos no século XIX, que signﬁca

“ﬁlho de Bonaccio”.

Fibonacci tornou-se conhecido devido a este problema que existia no seu livro "Li-

ber Abaci". A solução deste problema é uma sequência numérica e um matemático

francês, Edouard Lucas, ao editar um trabalho seu, ligou o nome de Fibonacci a essa
sequência. [9]

Uma análise rápida mostra que cada termo da sequência acima é dado recursiva-

mente pela expressão:

F(0) = 0

F(1) = 1

F(n) = F(n

1) + F(n

2), n

2

≥

−

−

onde n é a quantidade de meses.

24

No nosso problema queremos saber quantos pares de coelhos um casal pode ter

em 12 meses, assim temos:

1.4 atividades

F(12) = F(12

1) + F(12

2)

−

−

F(12) = F(11) + F(10)

F(11) = 89

F(10) = 55

F(12) = 89 + 55

F(12) = 144.

Os valores para F(10) e F(11) são calculados da mesma forma, a partir dos valores de

F(9) e F(8), que por sua vez são calculados a partir dos valores anteriores, seguindo

assim até chegar a F(0) e F(1) que são conhecidos.

Tal raciocínio ﬁca melhor explicitado na tabela abaixo.

n

F(n)

0

0

1

1

2

1

3

2

4

3

5

5

6

8

7

8

9

13

21

34

10

55

11

89

12

144

Temos assim nossa resposta: Partindo de um casal de coelhos serão gerados em doze
meses um total de 143 casais de coelhos.

A sequência de Fibonacci tem uma solução explicita dada por
(cid:34)(cid:32)

(cid:33)n(cid:35)

(cid:33)n

(cid:32)

F(n) =

√5
5

1 + √5
2

1

√5
−
2

−

,

que será verﬁcada no próximo capítulo.

Para encerrar o capítulo, vamos deixar alguns exercícios propostos aos leitores

para a veriﬁcação de outras relações de recorrência com a ﬁnalidade de enriquecer o

assunto tratado aqui.

1.4 atividades

1. A visita que M. C. Escher fez à Alhambra (Espanha), em 1922, inspirou os
seus trabalhos seguintes. Conheça Alhambra visitando a página http://pt.

wikipedia.org/wiki/Alhambra e em seguida, a página oﬁcial de M.C.Escher

em http://www.mcescher.com para veriﬁcar e apreciar o trabalho do mesmo.

25

recursividade e relações de recorrência

2. Faça uma pesquisa na internet sobre Fractal e veja alguns fractais feitos com o

uso do computador.

3. O lixo em um depósito sanitário decompõe-se a uma taxa de 5% ao ano. Se 100
toneladas de lixo são inicialmente depositadas no depósito, quanto permanece
não decomposto após 20 anos (ou seja, no início do 21o ano)? (Dica: Enuncie e
resolva uma relação de recorrência.)

4. Membros antigos da Sociedade de Pitágoras deﬁniram números ﬁgurados como
sendo o número de pontos em certa conﬁguração geométrica. Os primeiros nú-
meros triangulares são 1, 3, 6, e 10, e são semelhantes ao diagrama da ﬁgura
abaixo:

Figura 10: Números Triangulares

Observe que cada número da sequência refere-se à quantidade de pontos que

são os vértices dos triângulos existentes.

Construa geometricamente mais alguns números triangulares e encontre a fór-

mula para o n-ésimo número triangular.

5. Os primeiros números quadráticos são 1, 4, 9, 16, e são deﬁnidos pelas ﬁguras

abaixo.

Mostre que o n-ésimo número quadrático é dado por n2.

6. Os primeiros números pentagonais (veja a ﬁgura anterior) são 1, 5, 12, 22, e são

semelhantes ao diagrama da ﬁgura abaixo:

Encontre a fórmula para o n-ésimo número pentagonal.

26

1.4 atividades

Figura 11: Números Quadráticos

Figura 12: Números Pentagonais

7. De quantas maneiras podemos formar palavras com n letras utilizando o alfa-
se as letras a e b não devem aparecer juntas?

a, b, c, d

beto

{

}

8. (Itália/1996) Dado o alfabeto com três letras a, b, c, encontre o número de pala-

vras com n letras contendo um número par de a’s. Considere n

2 .

≥

9. Conheça e resolva algumas das variantes do problema de Josephus apresenta-

dos no site: http://www.calendario.cnt.br/Paginas/Josefo.htm

27

C O N C E I T O S T E Ó R I C O S

2

“Ao tentar resolver o problema, encontrei

obstáculos dentro de obstáculos. Por

isso, adotei uma solução recursiva.”

— Um aluno

2.1 relações de recorrência

Uma relação de recorrência, ou equação de recorrência é uma equação que deﬁne

uma sequência recursivamente. Mais formalmente, vale a seguinte deﬁnição.

Deﬁnição 2.1. Uma relação de recorrência de ordem k é uma equação do tipo

xn = f1 ·

xn

1 + f2 ·

−

xn

−

2 +

+ fk ·

xn

−

· · ·

k + g(n),

k + 1,

n

≥

onde

x1, x2, . . . , xk,

são valores dados, também chamados de condições iniciais, e

fi = fi(i, xn

1, . . . , xn

k),

−

−

i = 1, . . . , k,

são funções também ﬁxadas.

29

conceitos teóricos

Os exemplos mais conhecidos de relações de recorrência de ordem 1 são as pro-
gressões aritmética e geométrica. A equação de Fibonacci apresentada no capítulo

anterior, onde

é um exemplo de equação de segunda ordem.

xn = xn

1 + xn

2,

−

−

Uma solução de uma equação de recorrência é uma função que expressa xn como

função do índice n. Ou seja:

Deﬁnição 2.2. Uma solução da equação de recorrência

xn = f1 ·
é uma função F : N

xn

→

−

xn

1 + f2 ·
R tal que

2 +

−

+ fk ·

xn

−

· · ·

k + g(n),

k + 1,

n

≥

xn = F(n),

n

1.

≥

Neste capítulo introduziremos alguns tipos especiais de equações de recorrência,

e estudaremos algumas técnicas para encontrar sua solução. Para começar vamos

tratar das já conhecidas P.A. e P.G..

Exemplo 2.1. Solução de uma P.A.

Para encontrar a solução de uma P.A. do tipo

podemos proceder da seguinte maneira.

an = an

1 + r,

−

a2 =
a3 =
a4 =

a1 + r
a2 + r
a3 + r

= a1 + r + r = a1 + 2r
= a1 + 2r + r = a1 + 3r

an = an

−

1 + r = an

−

...
2 + 2r =

· · ·

= a1 + (n

1)r.

−

E desta forma, a solução de uma P.A. de razão r e primeiro termo a1 é dado por

an = a1 + (n

1)r;

−

1.

n

≥

30

Outro modo de encontrar a solução de uma P.A. é através da chamada soma teles-

cópica, mas este assunto será tratado um pouco mais a frente.

2.1 relações de recorrência

Exemplo 2.2. Solução de uma P.G. Considere uma P.G. de razão q e valor inicial x1
dada por

Procedendo de maneira análoga a uma P.A., encontramos que

xn = q

xn

1.

−

·

x2 =
x3 =
x4 =

q

q

q

x1 ·
x2 ·
x3 ·

= x1 ·
= x1 ·

·

·

q
q2
...

q =

x1 ·
q = x1 +

q2
q3

·

xn = xn

1 ·

−

q = xn

q2 =

2 ·

−

· · ·

= x1 ·

qn

1.

−

e portanto

xn = x1 ·

qn

1.

−

2.1.1 Classiﬁcação das Equações de Recorrência

Relações de recorrência são objetos complexos, cuja solução explícita pode reque-

rer técnicas complicadas e soﬁsticadas de cálculo. Existem, inclusive, diversas equa-

ções cuja solução explícita não sabemos calcular. Podemos, no entanto, classiﬁcar

equações de recorrência em classes, cujas soluções podem ser encontradas por técni-

cas similares.

Deﬁnição 2.3. Considere uma relação (equação) de recorrência de ordem k dada por

xn = f1 ·

xn

1 + f2 ·

−

xn

−

2 +

+ fk ·

xn

−

· · ·

k + g(n),

k + 1.

n

≥

Quando g(n) = 0, para todo n, dizemos que a equação é homogênea;

Quando g(n)

= 0, para algum n, dizemos que a equação não é homogênea;

Quando fi = f (i), 0 < i

≤

n, diremos que a equação é linear;

•

•

•

31

(cid:54)
conceitos teóricos

•

•

Quando fi é constante, diremos que a equação é linear com coeﬁcientes cons-
tantes;

Quando fi = fi(i, xn
ção não linear;

−

1, . . . , xn

−

k), para algum i = 1, . . . , k, trata-se de uma equa-

Ao longo do primeiro capítulo vimos alguns exemplos de equações de recorrência

lineares. Neste trabalho trataremos apenas deste tipo de equações, nos concentrando

principalmente em equações lineares de primeira ordem.

Seguem abaixo alguns exemplos para ﬁxação das deﬁnições acima

Exemplo 2.3. Classiﬁcação de algumas equações de recorrência

A equação de Fibonacci

xn+2 = xn+1 + xn

é uma equação linear de ordem 2 homogênea de coeﬁcientes constantes.

F(n) = rF(n

1) (1

F(n

−
não linear homogênea.

−

1)), conhecida como equação logística é uma equação

−

1 + 3 é uma equação linear de ordem 1, não homogênea de coeﬁcientes

xn = 2xn
constantes.

−

xn = nxn

1 + n2xn

−

−

2 é uma equação linear não homogênea.

•

•

•

•

2.2

equações lineares de 1 a ordem

De acordo com a deﬁnição 2.3 uma relação de recorrência de primeira ordem é

uma equação do tipo

x n = f (n) x n

1 + g(n).

−

Os exemplos mais comuns, e constantes do currículo atual do ensino médio, são

as progressões aritmética e geométrica (P.A. e P.G.), já mencionadas diversas vezes

32

2.2 equações lineares de 1 a ordem

neste texto. Para encontrar uma P.A. fazemos f (n) = 1 e g(n) = r (a razão da P.A.)

para todo n. No caso de uma P.G. invertemos esta lógica, fazendo f (n) = q (a razão

da P.G.) e g(n) = 1 para todo n.

As soluções para estes dois tipos de equação foram dadas no início deste capítulo,

e já são bem conhecidas por estudantes de ensino médio.

A seguir enumeraremos alguns tipos especiais de equações de primeira ordem, e

algumas técnicas usadas para encontrar sua solução explícita.

2.2.1 Somas Telescópicas

Considere uma equação linear de primeira ordem da forma

x n+1 = x n + g(n).

(2.1)

Escrevendo esta equação para os vários índices de 1 até n obtemos

x n+1 = x n + g(n)

x n = x n

x n

−

1 = x n
...
...

1 + g(n

2 + g(n

−

−

1)

2)

−

−

x 3 = x 2 + g(2)

x 2 = x 1 + g(1).

Somando todas estas expressões encontramos

x n+1 + ( x n +

· · ·

+ x 2 ) = ( x n +

· · ·

+ x 2 ) + x 1 + g(1) + g(2) +

+ g(n

1),

−

· · ·

que pode ser simpliﬁcada até

x n+1 = x 1 +

n
∑
k=1

g(k).

Encontramos assim que a solução da equação (2.1) é dada por

x n = x 1 +

n
1
∑
−
k=1

g(k).

(2.2)

33

conceitos teóricos

Exemplo 2.4. P.A. como Soma Telescópica

Observe que uma P.A. de razão r é uma equação to tipo de (2.1), onde g(n) = r

para todo n. Deste modo temos que

xn = x1 +

n
1
∑
−
k=1

r = x1 + (n

1)r.

−

Esta técnica, onde somamos equações simpliﬁcando termos similares, é conhecida

como soma telescópica, e é bastante utilizada na solução de diversas equações de

recorrência, como veremos a seguir.

2.2.2 Equações de 1a Ordem com Coeﬁciente Constante

Vamos agora considerar equações do tipo

xn+1 = q

·

xn + g(n),

(2.3)

onde q

∈

R é uma constante.

Para resolver esta equação, primeiro reescreva (2.3) como

e liste todas as equações para indices de 1 a n, obtendo

xn+1 −

q

·

xn = g(n),

xn+1 −
xn −
q
·
1 −

q

·

−

xn

q

·
xn

xn

xn = g(n)

−

−

1 = g(n

2 = g(n
...
...

1)

2)

−

−

q

q

x3 −
x2 −

·

·

x2 = g(2)

x1 = g(1).

Observe que neste momento não podemos nos aproveitar da soma telescópica,

pois todo termo xi aparece na equação anterior como q

xi, impedindo o cancela-

·

34

2.2 equações lineares de 1 a ordem

mento. Para resolver este problema, multiplique cada equação acima por 1, q, q2, . . . , qn

1,

−

respectivamente, obtendo

xn+1 −
q2
xn −
·
1 −

q3

·

−

q

·
xn

xn

q

·
xn

q2

·

2

qn

−

qn

·
−

e somando obtemos

1

qn

−

x3 −
·

x2 −

1

qn

·

·

xn = g(n)

−

−

1 = q
·
2 = q2
...
x2 = qn
x1 = qn

g(n

1)

−

g(n

2)

−

·

−

−

g(2)

g(1).

2

1

·

·

(cid:24)(cid:24)(cid:24)q
·
(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
q2
xn
·

−

xn = g(n)

−

(cid:24)(cid:24)(cid:24)q
xn+1 −
·
(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
q2
xn −
xn
1 = q
·
·
(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
2 = q2
q3
xn
1 −
·
...
(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
x2 = qn
qn
·
x1 = qn
qn

−

−

1

1

·

2

−

(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
qn
x3 −
·
(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
qn
−
·

x2 −

g(n

1)

−

g(n

2)

−

·

−

−

g(2)

g(1)

2

1

·

·

xn+1 −

qnx1 = g(n) + q

g(n

·

−

1) +

· · ·

+ qn

−

1

g(1).

·

Ou seja,

ou ainda

xn+1 = qnx1 +

n
∑
k=1

k

qn

−

g(k),

·

xn+1 = qnx1 +

n
1
∑
−
k=0

qk

·

g(n

k).

−

Exemplo 2.5. Considere a equação




xn+1 = 3xn + 1 para n



x1 = 2

1

.

≥

(2.4)

(2.5)

35

conceitos teóricos

Neste caso temos g(n) = 1, x1 = 2 e q = 3 o que nos leva a

xn+1 = 3n

= 2

= 2

·

·

1

·

·

3k

2 +

n
1
∑
−
k=0
3n + (1 + 32 +
3n

1

3n +

−
2

+ 3n

1)

−

· · ·

e portanto

=

5
2 ·

3n

−

1
2

xn =

5
2

3n

−

1

1
2

,

−

n

1

≥

Uma classe interessante de equações de primeira ordem com coeﬁcientes constan-

tes são as chamadas Progressões Aritmético-Geométricas (P.A.G.), dadas por

xn+1 = q

xn + r

·

qn,

·

1.

n

≥

(2.6)

Neste caso, temos uma equação linear de primeira ordem e coeﬁciente constante,

onde g(n) = r

·

qn, e portanto a solução é dada por

x1 +

n
∑
k=1

k

qn

−

qk

r

·

·

xn+1 = qn

= qn

·

·

qn

x1 + r

n
∑
k=1
x1 + r n qn

= qn
= qn [x1 + n r]

·

Temos assim que a solução de (2.6) é dada por

xn = qn

1 [x1 + (n

−

1) r] .

−

Tendo em mãos a solução geral é fácil agora perceber que uma progressão aritmético-

geométrica recebe este nome pois é construída multiplicando os termos de uma P.A.

(x1, x1 + r, x1 + 2r, . . . , x1 + (n

1)r, . . .)

−

36

2.2 equações lineares de 1 a ordem

pelos termos respectivos de uma P.G.

(1, q, q2, . . . , qn

1, . . .),

−

gerando a sequência

(xn) = (x1, q[x1 + r], q2[x1 + 2r], . . . , qn

1[x1 + (n

−

1)r], . . .).

−

Mais sobre P.A.G. pode ser encontrado em [10]

Exemplo 2.6. Considere a P.A.G. dada por




an+1 = 2 an + 3

2n

·

, n

1

≥



a1 = 1

Neste caso a solução geral é dada por

an = 2n

−

1 [1 + 3(n

1)] ,

−

e a sequência (an) é dada por (1, 8, 28, 80,

).

· · ·

Vamos agora partir para a solução dos problemas apresentados no Capítulo 1. Lá
descrevemos o problema e encontramos as equações de recorrências que modelam a

solução. A seguir vamos apresentar a solução ﬁnal, fechada para o problema.

2.2.3 Solução do Problema das Torres de Hanói

Este problema foi descrito na Seção 1.1, e na seção 1.3.1 encontramos a relação de
recorrência que o modela. Lembrando, se Q(n) representa o mínimo de movimentos

necessários para se mover os pinos de uma torre para a outra, então




Q(n) = 2Q(n

1) + 1, n

2

≥

−



Q(1) = 1

Temos assim que o problema é modelado por uma relação de recorrência de ordem
1, não-homogênea e de coeﬁciente constante. Poderíamos agora simplesmente evocar

37

conceitos teóricos

as equações (2.4) ou (2.5) e apresentar o resultado ﬁnal. Mas para ﬁxar melhor a
técnica, vamos repetir a solução apresentada no caso especíﬁco desta equação.

Lembrando, queremos usar a soma telescópica, mas o fator 2 multiplicando o
termo do lado direito da equação não permite. O que fazemos então é multiplicar
1) + 1 por 2k de modo a corrigir os termos

as equações do tipo Q(n

k) = 2Q(n

k

−
e possibilitar a soma telescópica. Temos então que

−

−

Q(n) = 2Q(n

1) + 1

−

2) + 2

3) + 22

−

−

2Q(n

1) = 22Q(n

−

22Q(n

−

2) = 23Q(n
...
3Q(3) = 2n

−

2n

−

2Q(2) + 2n

3

−

2n

−

2Q(2) = 2n

−

1Q(1) + 2n

−

2

Somando agora todas as equações obtemos

Q(n) = 2n

−

1Q(1) + 1 + 2 + 22 +

+ 2n

−

2

· · ·
2 + 2n

1

−

= 1 + 2 + 22 +

= 2n

1

−

+ 2n

−

· · ·

Deste modo concluímos que o número de movimentos necessários para mover n

pinos entre duas torres no jogo das Torres de Hanói usando a estratégia descrita é

de

2.3

Q(n) = 2n

1.

−

solução do problema de josephus

Do mesmo modo que o problema das torres, este problema foi apresentado na
seção 1.1 e sua relação de recorrência encontrada em 1.3.2. Resumidamente, temos

(cid:40)

J(n) =

1

,

se n = 2m para algum m

J(n

−

1) + 2 ,

se n

3 e n

= 2m,

m

∀

≥

≥

0;

≥
0.

(2.7)

Temos então que a sequência J(1), J(2), . . . segue uma espécie de progressão arit-
mética de razão 2 e primeiro termo 1, mas que se reinicia sempre que chega a um
termo cujo índice é potência de 2.

38

(cid:54)
Para entender isso melhor ﬁxe m

naturais entre 2m e 2m+1

−

≥
1, dada por

2.3 solução do problema de josephus

0 e considere a sequência de todos os valores

2m, 2m + 1, 2m + 2, . . . , 2m+1

2, 2m+1

1.

−

−

Todo número n neste conjunto pode ser representado por n = 2m + p, com p
1, 2, . . . , 2m

∈
(por que?), e m é portanto o expoente da maior potência de 2

1

{
−
menor que n.

}

Reescrevendo a equação (2.7) encontramos

(cid:40)

J(2m + p) =

1
J(2m + p

−

,

1) + 2 ,

se p = 0;
se 0 < p < 2m.

Para simpliﬁcar, faça F(p) = J(2m + p) temos

(cid:40)

F(p) =

1

,

F(p

−

1) + 2 ,

se p = 0;
se 0 < p < 2m.

Assim, para 0

≤

p < 2m+1 temos

F(p) = 2p + 1,

e portanto

(2.8)

(2.9)

J(2m + p) = 2p + 1,

(2.10)

para todo m

0 e 0

p

≤

≤

2m

1.

−

≥

Se quisermos escrever (2.10) em função apenas de n, precisamos primeiro determi-

nar m e p em função de n.

Comecemos determinando m. Observe primeiro que pela própria deﬁnição de m

e p temos

e portanto

Segue que

e

p < 2m,

0

≤

2m

≤

n = 2m + p < 2m+1.

log2(2m)

≤

log2 n < log2(2m+1),

m

≤

log2 n < m + 1.

39

conceitos teóricos

Concluímos então que log2n é um número real entre m e m + 1, sendo estritamente
menor que m + 1. Portanto, se tomarmos apenas a parte inteira de log2 n encontramos
justamente m. Ou seja,

m =

log2 n

,

(cid:99)

(cid:98)

onde

x

(cid:99)

(cid:98)

denota a parte inteira de x.

Temos assim que n = 2(cid:98)

log2 n

(cid:99) + p, o que implica que

p = n

−

2(cid:98)

log2 n

(cid:99).

Juntanto tudo temos que

para todo n

1.

≥

J(n) = 2

(cid:104)

n

−

2(cid:98)

log2 n

(cid:99)

(cid:105)

+ 1,

(2.11)

2.4

equações lineares de 2 a ordem

Considere a equação de segunda ordem dada por

Deﬁna o vetor coluna

x n+1 = a x n + b x n

1 .

−

v n =

(cid:32)

(cid:33)

,

x n+1
x n

(cid:32)

x n+1
x n

(cid:33)

(cid:32)

=

a x n + b x n
x n

1

−

(cid:33)

=

(cid:32)

a

(cid:33) (cid:32)

b

1 0

(cid:33)

.

x n
x n

−

1

A =

(cid:32)

a

(cid:33)

b

1 0

,

v n = A v n

1 ,

−

com v 0 =

(cid:32)

(cid:33)

.

x 1
x 0

e observe que

Ou seja, se

então

40

2.4 equações lineares de 2 a ordem

Segue assim que v n é uma espécie de P.G. matricial, e seguindo a mesma técnica

que usamos para encontrar a solução de uma P.G., temos

v n = A n v 0 .

Infelizmente, calcular potência de matrizes pode se tornar uma tarefa árdua, cujas

técnicas vão além do escopo deste trabalho. Mas apesar disso, esta pequena desco-

berta pode servir de fonte de inspiração. Se podemos escrever uma equação linear
de ordem 2 não-homogênea e com coeﬁcientes constantes como uma P.G. matricial,
é razoável esperar que as soluções da equação sejam similares as soluções de uma

P.G..

Com isso em mente, vamos então buscar uma solução do tipo x n = c q n. Substi-

tuindo em x n+1 = a x n + b x n

1 obtemos

−
c q n+1 = a c q n + b c q n

1 .

−

e dividindo por c q n

1 obtemos

−

−
O polinômio em q dado por p(q) = q 2

q 2

a q

b = 0.

−
a q

−

−

da relação de recorrência, suas raízes determinam soluções possíveis para a equação.

b é chamado de equação característica

No caso em que o polinômio tem duas raízes, q 1 e q 2 obtemos duas soluções
2. Desta forma, a solução geral pode ser escrita

1 e x n = c 2 q 2

distintas: x n = c 1 q n
como

x n = c 1 q n

1 + c 2 q n
2 ,

e as constante c 1 , c 2 dependem das condições iniciais do problema.

Vejamos um exemplo para deixar as coisas mais claras.

Exemplo 2.7. Vamos resolver a equação






a n = 5 a n

1 −
a 0 = 0, a 1 = 2

−

6 a n

2 , n

−

2

.

≥

Supondo a k = q k, com q

= 0 obtemos

q n

−

5q n

−

1 + 6q n

−

2 = 0

41

(cid:54)
conceitos teóricos

e dividindo por q n

2 obtemos

−

q 2

−

5q + 6 = 0,

cujas raízes são 2 e 3.

Do problema temos que a 0 = 0 e a 1 = 2, então

Ou seja




a 0 = c 1 30 + c 2 20 = 0



a 1 = c 1 31 + c 2 21 = 2

.






c 1 + c 2

= 0

,

3c 1 + 2c 2 = 2

e encontramos c 1 = 2 e c 2 =

2. Portanto

−

a n = 2

3 n

·

2

·

−

2 n = 2

3 n

·

−

2 n+1 .

Considere agora o caso em que o polinômio p(q) = q2

b possua apenas uma
raíz q1. Neste caso encontramos apenas soluções do tipo xn = c1qn
1 , mas isso não
parece ser suﬁciente. De fato, tendo duas condições iniciais, estas podem não ser

aq

−

−

compatíveis com a solução encontrada. O que fazer neste caso?

Para resolver este problema tome F(n) uma solução qualquer de xn + 1 = axn +

bxn

−

1, e deﬁna

yn =

F(n)
an .

Temos assim que F(n) = ynqn

1 , e como F(n) é uma solução da recorrência, segue que

F(n + 1)qn+1

1 = aF(n)qn

1 + bF(n

1)qn
1

1

.

−

−

Antes de continuar, lembre que, se q1 é a única raíz de q2
(soma das raízes) e

−
1 (produto das raízes). Com isso obtemos

b = q2

aq

−

−

b, então a = 2q1

yn+1qn+1

1 = 2ynqn+1

1 −

1qn+1
1

,

yn

−

e

42

yn+1 = 2yn −

yn

1.

−

2.4 equações lineares de 2 a ordem

Rearrumando os termos obtemos

yn+1 −

yn = yn −

yn

1.

−

Observe que portanto a sequência (yn −
concluímos que yn é uma P.A., e assim

yn

−

1)n

≥

1 é constante. Fazendo yn −

yn

−

1 = r

yn = nr + y0.

Concluímos assim que F(n) = r n qn

1 + y0 qn

1 , e fazendo y0 = c1 e r = c2 temos

F(n) = c1 qn

1 + c2 n qn
1 ,

e como F(n) era uma solução qualquer segue que toda solução tem esta forma.

Exemplo 2.8. Queremos resolver a equação: an −
a1 = 2.

4an

−

1 + 4an

−

2 = 0, com a0 = 0 e

Temos que a equação característica que associada a esta equação de recorrência é

q2

−

4q + 4 = 0,

que possui q = 2, como raiz dupla da equação.

Assim, a solução é dada por

an = c12n + c2.n2n.

Usando as condições iniciais encontramos






a0 = c120 + c2 ·
a1 = c121 + c2 ·

0

1

·

·

20 = 0

21 = 2

O que nos leva a c1 = 0 e c2 = 1, nos dando a solução

an = n 2n.

43

conceitos teóricos

2.4.1 Encontrando a Sequência de Fibonacci

No problema dos coelhos vimos que a relação de recorrência era dada por

onde tínhamos como condições iniciais que f1 = f2 = 1.

fn = fn

1 + fn

2,

−

−

n

2

≥

Temos assim uma relação de recorrência homogênea linear de segunda ordem,

cuja equação característica é q2

(cid:32)

q

−

q

−
−
1 + √5
2

1 = 0. Ou seja,

(cid:33) (cid:32)

1

√5
−
2

q

−

(cid:33)

= 0,

cujas raízes são

Assim, se

q1 =

1 + √5
2

e

q2 =

1

√5
−
2

.

fn = c1

(cid:33)n

(cid:32)

1 + √5
2

(cid:32)

1

+ c2

√5
−
2

(cid:33)n

podemos determinar c1 e c2 utilizando o seguinte sistema




f1 = c1



f2 = c1

(cid:16) 1+√5
2
(cid:16) 1+√5
2

o que nos leva a

(cid:17)

+ c2

(cid:16) 1

(cid:17)2

+ c2

(cid:17)

√5
−
2
(cid:16) 1

√5
−
2

(cid:17)2

= 1

= 1

1
√5
e a solução explícita para a sequência de Fibonacci ﬁca

1
√5

c1 =

c2 =

−

e

fn =

1
√5

(cid:33)n

(cid:32)

1 + √5
2

1
√5

−

(cid:32)

1

(cid:33)n

.

√5
−
2

2.5 mudança de variáveis

Em alguns casos podemos fazer uso de soluções conhecidas para tratar de proble-

mas novos. Considere o exemplo a seguir.

44

2.5 mudança de variáveis

Exemplo 2.9. Tome a seguinte equação de recorrência:

T(n) = 1 + T(n

1) + T(n

2),

n

2,

≥

−

−

onde T(1) = T(2) = 0.

Trata-se de uma recorrência linear não homogênea de segunda ordem, onde

T(1) = 0, T(2) = 0, T(3) = 1, T(4) = 2, T(5) = 4, T(6) = 7,

T(7) = 12, T(8) = 20, T(9) = 33, T(10) = 54, T(11) = 88.

Observando os termos da sequência T(n) - 0, 0, 1, 2, 4, 7, 12, 20, 33, 54, 88, . . . - e os

da sequência de Fibonacci - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, . . . - veriﬁcamos que pode

ser possível escrever

onde an é o n-ésimo termo da sequência de Fibonacci.

T(n) = an −

1,

1,

n

≥

De fato, observe que

T(n) = T(n

1) + T(n

2) + 1

−

⇐⇒

−

T(n) + 1 = (T(n

1) + 1) + (T(n

2) + 1),

−

−

e fazendo an = T(n) + 1 temos

e a1 = a2 = 1.

Portanto

an = an

1 + an

2,

−

−

n

2

≥

an =

(cid:33)n

(cid:32)

1 + √5
2

1
√5

1
√5

−

(cid:32)

1

(cid:33)n

.

√5
−
2

Ou seja, o termo geral da sequência T(n) é dado por

T(n) =

(cid:33)n

(cid:32)

1 + √5
2

1
√5

1
√5

−

(cid:32)

1

√5
−
2

(cid:33)n

1.

−

No exemplo, fazendo an = T(n) + 1 encontramos uma sequência cuja solução já era

conhecida, e assim resolvemos uma equação aparentemente nova.

45

conceitos teóricos

A técnica utilizada no problema anterior é conhecida como mudança de variáveis

e consiste de alterar os termos de uma sequência de modo a encontrar uma nova

sequência cuja solução sabemos encontrar, e a partir desta resolver a equação origi-

nal.

Alguns problemas recursivos são resolvidos quando divididos em dois ou mais

subproblemas de mesmo tamanho. Resolvendo-os recursivamente utilizamos seus

resultados para resolver o problema original, estratégia conhecida como “dividir e

conquistar”.

Exemplos de equações de recorrência que surgem em problemas como este serão

dados logo a seguir, mas resolver deste tipo pode depender de técnicas um pouco

mais avançadas. No entanto, se nos concentrarmos apenas em uma parte da sequên-

cia, o método da mudança de variável pode ser utilizado.

Veja alguns exemplos abaixo.

Exemplo 2.10. Considere a recorrência:

F(n) = F

(cid:17)

(cid:16) n
2

+ 4

Podemos observar que não tem sentido tomar n no conjunto

, pois
n/2 não pertence a esse conjunto quando n é ímpar, nem de tomar n no conjunto
pois (n/2)/2 não pertence a esse conjunto quando n/2 é ímpar, con-

1, 2, 3, 4, 5, . . .

2, 4, 6, 8, . . .

}

{

}

{
tudo se nessa recorrência tomamos n pertencente ao conjunto
potências inteiras de 2, então a sequência ﬁca bem deﬁnida.

21, 22, 23, 24, . . .

das

}

{

Assim, podemos fazer n = 2k e reescrever a recorrência da seguinte forma:

F(n) = F(2k) = F(2k

−

1) + 4, para k = 1, 2, 3, 4, . . .

Como sabemos, há muitas funções F deﬁnidas sobre as potências inteiras de 2
que satisfazem essa recorrência. Para cada número i, há somente uma função F que
satisfaz a recorrência e tem valor inicial F(20) = i. Se i = 6, por exemplo, teremos:

n

F(n)

1

6

2

4

8

10

14

18

16

22

32

26

. . .

. . .

46

2.5 mudança de variáveis

Para determinação da fórmula explicita faça G(k) = F(2k). Temos assim

e G(k) é uma P.A., de onde concluímos que

G(k) = G(k

1) + 4,

−

E como G(0) = F(20) = 6 temos

G(k) = 4k + G(0).

F(2k) = 4k + 6.

Como n = 2k, temos que k = log2 n. Ou seja

F(n) = 6 + 4 log2 n.

Exemplo 2.11. Considere a recorrência

T(n) = 2.T

(cid:17)

(cid:16) n
2

+ 1, n > 1 e T(1) = 0.

Mais uma vez, faça n = 2k e deﬁna G(k) = T(2k). Neste caso temos, para k > 0

G(k) = T(2k) = 2T(2k

1) + 1 = 2G(k

−

1) + 1

−

e G(0) = T(1) = 0.

Assim temos

G(k) = 2G(k

−
= 2 [2G(k

1) + 1

2) + 1] + 1

−
2) + 2 + 1

3) + 1] + 2 + 1

−
3) + 22 + 2 + 1

= 22G(k

−
= 22 [2G(k

−

= 23G(k

=

· · ·
= 2mG(k

m) + 2m

1 + 2m

2 +

−

−

−

+ 2 + 1

· · ·

=

· · ·

= 2kG(0) + 2k

1 + 2k

2 +

−

−

+ 2 + 1

· · ·

47

conceitos teóricos

e assim

Deste modo, como n = 2k temos

G(k) = 1 + 2 +

+ 2k

−

1 = 2k

1.

−

· · ·

T(n) = n

1.

−

Exemplo 2.12.

T(n) = 2.T

(cid:17)

(cid:16) n
2

+ n, n > 1 e T(1) = 1.

Como nos exemplos anteriores, faça n = 2k e deﬁna G(k) = T(2k). Temos agora,

para k > 0

e G(0) = T(1) = 1.

Assim temos

G(k) = T(2k) = 2T(2k

1) + 2k = 2G(k

−

1) + 2k

−

1) + 2k

G(k) = 2G(k

(cid:104)

= 2

−
2G(k

2) + 2k

1(cid:105)

−

+ 2k

2(cid:105)

−

+ 2

2k

·

−
2) + 2

2k

·
3) + 2k

−
3) + 3

2k

·

= 22G(k
= 22 (cid:104)

−
2G(k

−

= 23G(k

=

· · ·
= 2mG(k

m) + m

−

2k

·

=

· · ·

= 2kG(0) + k

2k

·

e assim

Deste modo, como n = 2k e k = log2 n temos

G(k) = 2k + k

2k

·

T(n) = (n + 1) log2 n.

48

2.5 mudança de variáveis

Voltaremos a este exemplo quando contarmos o número de comparações realiza-

das pelo algoritmo de ordenação merge sort, que será visto no capítulo 3.

Antes das atividades propostas que encerram o capítulo, vamos ver mais um exem-

plo.

Exemplo 2.13. Seja a recorrência T(n) = n + T(n/3), para n

2, e T(1) = 1.

≥

Neste caso, a instância n está relacionado com a instância n/3, de modo que a
relação só faz sentido para n = 3k. Façamos então esta substituição. Encontramos

assim

T(3k) = 3k + T(3k

1),

e T(30) = 1.

−

Assim, se F(k) = T(3k) temos

Expandindo obtemos

F(k) = 3k + F(k

−

1),

e F(0) = 1.

F(k) = F(k

= F(k

= F(k

=

· · ·
= F(k

−

−

−

−

1) + 3k

2) + 3k

1 + 3k

−

3) + 3k

2 + 3k

1 + 3k

−

−

m) + 3k

−

m+1

3k

·

=

· · ·

= F(0) + 3 + 32 +

= 1 + 3 + 32 +

=

1

3k+1
−
2

· · ·

3k

·

+

3k

· · ·
+

·

Agora, como n = 3k temos

T(n) =

3n

1

.

−
2

49

conceitos teóricos

2.6 atividades

1. Escreva os cinco primeiros termos das seguintes sequências:

a) S(1) = 10 e S(n) = S(n

1) + 10, para n

2.

b) T(1) = 1 e T(n) = n

·

1), para n

−
T(n

−

≥
2.

≥
1)W(n

c) W(1) = 2; W(2) = 3 e W(n) = W(n

−

2), para n

3.

≥

−

2. Encontre o termo geral an das sequências expressas por:

a) ak −
b) 2ak −

3ak

−
3ak

1 = 0, a0 = 1, k

1;

≥

1 = 0, a0 = 2, k

1.

≥

−

3. Calcule uma fórmula explicita para a recorrência F(n) = F(n/2) + 4, com valor

inicial F(1) = 2.

4. Mostre que F(n) = log2 n + 3, para n = 1, 2, 22, 23, . . . é uma solução da recorrên-

cia F(n) = F(n/2) + 1.

5. Dada a sequência de Fibonacci F(n) veriﬁque que F(n + 1) + F(n

para n

2.

≥

2) = 2F(n),

−

6. Considere a recorrência F(n) = 2F(n/2) + 2n para n = 21, 22, 23, . . .. Resolva a

recorrência adotando F(1) = 0.

7. Sabe-se que G é uma função deﬁnida no conjunto

tal que
G(1) = 5 e G(n) = 2G(n/2) + 7n para n > 1. Determine a expressão explícita de

20, 21, 22, 23, . . .

}

{

G.

8. Considere a recorrência F(n) = F(3n/4) + 88. Exiba e prove uma fórmula fe-
chada para a função F que está deﬁnida sobre as potências inteiras de 4/3, tem

F(1) = 77 e satisfaz a recorrência.

50

A N Á L I S E D E A L G O R I T M O S

3

“Devemos mudar nossa atitude

tradicional em relação à construção de

programas. Em vez de imaginar que

nossa principal tarefa é instruir o

computador sobre o que ele deve fazer,

vamos imaginar que nossa principal

tarefa é explicar a seres humanos o que

queremos que o computador faça.”

— D. E. Knuth

Este capítulo será dedicado a comentar algumas aplicações de recursividade e rela-

ções de recorrência na computação. Teremos como base os problemas de ordenação
e busca (Problemas 4 e 5 apresentados no Capítulo 1). Vamos analisar mais de uma
estratégia de solução para cada problema, e compararemos a eﬁciência das mesmas.

3.1 algoritmos e complexidade

Um algoritmo é um procedimento consistindo de um conjunto de regras que es-

peciﬁcam uma sequência ﬁnita de operações, que produz uma solução para um

problema ou classe de problemas.

Os algoritmos recursivos, nosso alvo de estudo neste capítulo, são muito usados

na computação, sendo uma poderosa técnica de programação. Lembrando, são al-

goritmos que para resolver um dado problema, reduz o problema a uma instância

menor, resolvendo ela da mesma forma, até reduzir a um caso trivial.

51

análise de algoritmos

Um importante problema no dia a dia da computação é lidar com limitações im-

postas pela tecnologia, ou mesmo pelo problema atacado. Ao se escrever um pro-

grama para decidir se um corretor da bolsa deve ou não vender uma ação, é impor-

tante que este programa rode em tempo muito curto, pois estas decisões são tomadas

em questão de segundos. Ao mesmo tempo, limitações tecnológicas impedem que

algumas operações sejam feitas em tempo muito curto. É importante portanto que

saibamos medir os recursos necessários para que um algoritmo possa resolver um

problema. Tais medidas compõe o que chamamos de complexidade de um algo-

ritmo. A complexidade de um algoritmo depende principalmente do tamanho, do

formato da entrada, e do tempo de execução.

No caso de algoritmos recursivos, a complexidade de um algoritmo será represen-

tada por uma ou mais equações de recorrência. A análise de complexidade de um

algoritmo é uma medida que tem parâmetros especíﬁcos do algoritmo, sendo que

seu estudo depende da solução das relações de recorrência para prever a limitação

do desempenho do algoritmo.

Neste trabalho nos concentraremos apenas do cálculo do tempo de execução.

3.1.1 Análise de Complexidade

A analise do custo de um algoritmo é feita mensurando os recursos necessários

em termos de tempo de execução e de espaço. Esse tempo está ligado ao tamanho

da entrada e assim procura-se deﬁnir o algoritmo mais eﬁciente calculando o tempo

de execução do algoritmo identiﬁcando a operação básica, isto é, a operação mais

custosa (cop) e tempo de execução da mesma multiplicada pela quantidade de vezes

que é executada em uma entrada. Assim

T(n)

cop

·

≈

C(n),

onde C(n) é o número de vezes que a operação é realizada.

Podemos exempliﬁcar, dizendo que na multiplicação de matrizes, a adição e a

multiplicação são as operações mais custosas, enquanto que em um algoritmo de

ordenação, a comparação é essa operação.

52

3.2 comportamento assintótico

3.2 comportamento assintótico

A eﬁciência dos algoritmos dá-se pela comparação dos mesmos em termos da cha-

mada comportamento assintótico de suas funções de custo. Estamos interessados em

como a função se comporta quando o tamanho da entrada é muito grande, interes-

sando muito pouco a forma exata da função.

Antes de deﬁnir o que entendemos por comportamento assintótico, vamos consi-
derar um exemplo. Observando as funções f (x) = x e g(x) = x2, podemos veriﬁcar

a medida que x cresce, os valores de f e g também crescem ilimitadamente. E para

x suﬁcientemente grande teremos g(x) sempre maior que f (x). De fato, a diferença

entre as duas aumenta a medida que x cresce, uma vez que

g(x)

−

f (x) = x2

x = x(x

1),

−

−

que é positivo e crescente para x > 1.

Este fato não muda se multiplicarmos f por qualquer constante constante positiva,

por maior que ela seja. Observe que

g(x)

−

c f (x) = x2

cx = x(x

c),

−

−

que é crescente e positiva para x > c.

Isso indica que f e g têm comportamento diferentes em relação às taxas de cresci-

mento. Diremos neste caso que g cresce mais rápido que f .

Devido aos recursos necessários do ponto de vista computacional, a análise quanto

ao trabalho requerido pelo algoritmo é tratado utilizando as seguintes medidas de

complexidade:

•

•

•

no pior caso é previsto o uso máximo das operações básicas necessárias para

se executar um dado algoritmo, sendo esta veriﬁcação mais útil para nossa

análise, pois não pressupõe nada sobre o formato da entrada;

O caso médio corresponde ao número médio de operações usadas para resol-

ver o problema em todas suas instâncias para um determinado tamanho de

entrada;

no melhor caso a quantidade de operações é considerada a menor necessária

para execução do algoritmo.

53

análise de algoritmos

Essas medidas de complexidade podem ser feitas usando a chamada notação as-

sintótica, nela se estuda o comportamento das funções para valores arbitrariamente

grandes de suas variáveis, sendo chamadas de ordem de complexidade. A notação O

descreve o limite superior sobre o algoritmo tratado. Para o limite inferior é utilizado
a notação Ω e quando ambas tem o mesmo valor usa-se a notação Θ.

Vamos exempliﬁcar a análise de complexidade:

Seja g(n) uma função não negativa deﬁnida em R+.

O(g(n)) representa o conjunto de funções de menor ou mesma velocidade de cres-

cimento que g(n). Mais precisamente, diremos que f (n)

tantes positivas n0 e c tais que f (n)

c

·

≤

g(n) para todo n

∈

≥

O(g(n)) se existem cons-

n0.

As seguintes aﬁrmações são verdadeiras:

O(n2);

n

∈

(100n + 52)

O(n2);

∈

n(n

1)

−

∈

O(n2)

n3 /
∈

O(n2);

(n4 + n + 1) /
∈

O(n2).

Por outro lado, note que:

54

3.2 comportamento assintótico

que g(n). Da mesma forma, diremos que f (n)

Ω(g(n)) representa o conjunto de funções de maior ou mesma ordem de grandeza
Ω(g(n)) se existem constantes positi-
n0.

vas n0 e c tais que f (n)

g(n) para todo n

∈

c

≥

·

≥

As seguintes aﬁrmações são verdadeiras:

n3

Ω(n2);

∈
1)

n(n

Ω(n2);

−
∈
(200n + 10) /
∈
Θ(g(n)) representa o conjunto de funções que tem a mesma ordem de grandeza
Θ(g(n)) se existem constantes positivas n0, c1 e c2 tais

Ω(n2).

que g(n). Diremos que f (n)
que c1 ·

c2 ·
As seguintes aﬁrmações são verdadeiras:

g(n) para todo n

g(n)

f (n)

≤

≤

∈

≥

n0.

(n2 + 3)

∈
(n2 + log2 n)
∈
(200n + 10) /
∈

Θ(n2);

Θ(n2);

Θ(n2).

Os algoritmos recursivos podem ser escritos como uma recorrência ou utilizando

procedimentos iterativos, com o qual se pode determinar a complexidade da resolu-

ção do problema.

55

análise de algoritmos

3.3 algoritmos de ordenação de listas

Vamos agora tratar do problema 4 colocado no Capítulo 1. Como é fácil de perce-
ber, a pergunta colocada não possui resposta direta e simples. A resposta depende

de fato de como decidimos ordenar a lista em questão. Cada pessoa usa sua própria

estratégia para fazer o ordenamento, e cada uma dessas formas acarretará em um

número distinto de comparações.

Mas este não é um problema apenas teórico. Na prática, uma lista de nomes ou

de números pode ser mais útil quando está ordenada, principalmente quando neces-

sitamos acessar os dados de modo mais eﬁciente. Pessoas ordenam suas coleções de

CD para facilitar a busca quando necessário, por exemplo.

Suponha então uma lista com n elementos, que por simplicidade pensaremos que

são números, e que o nosso trabalho é ordená-los de forma crescente. Chamaremos

de C(n) a quantidade de comparações realizadas entre os elementos da lista.

Existem vários algoritmos que servem para colocar os elementos de uma dada

sequência em ordem utilizando permutações entre os elementos da própria lista.

Entre os métodos conhecidos vamos destacar e apresentar três.

56

3.3 algoritmos de ordenação de listas

3.3.1 Ordenação por Seleção (Selection Sort)

Este algoritmo é baseado na estratégia de localizar o menor elemento da lista e

colocá-lo na primeira posição da lista, e em seguida fazer o mesmo para a lista

restante.

Para isso pegamos o primeiro elemento da lista e o comparamos cada um dos

elementos seguintes. Cada vez que encontramos um elemento menor do que o ele-

mento que escolhemos, fazemos a troca, colocando o elemento maior no local onde

estava o outro, e usando este novo elemento para as próximas comparações. Ao

terminar, estaremos então com o menor elemento da lista. Basta agora colocá-lo no

primeiro lugar da lista. Em seguida faz-se os mesmos procedimentos com os elemen-

tos não organizados da lista (que agora são n

1), recursivamente, até se chegar aos

dois últimos elementos da lista, onde o menor deles ﬁca como penúltimo elemento

−

e o outro é o maior elemento da lista ﬁcando em última posição concluindo, assim,

a ordenação da lista.

Exemplo 3.1. A seguir, uma solução para o problema de ordenação (problema 4,
proposto no início do capítulo 1) usando a ordenação por seleção em uma lista com
12 elementos, sendo que o símbolo (
) signiﬁca a comparação entre os elementos
apresentados e a seta ((cid:32)) mostra para onde o elemento vai após a comparação. Os
procedimentos estão ilustrados na ﬁgura a seguir.

(cid:108)

Lista:

{

23, 27, 41, 19, 91, 62, 54, 26, 38, 12, 10, 11

.

}

Os resultados: 1o até o 10o, são chamados de ordenação parcial enquanto o resul-

tado ﬁnal é uma ordenação completa (existem outras formas de ordenação parcial

que não são relevantes a esse estudo).

Podemos veriﬁcar que nesta lista, com 12 elementos, o número de comparações

foi: 11+10+9+8+7+6+5+4+3+2+1 = 66.

Assim a resposta para o problema 3 do capitulo 1, será: O número de comparações
usando o método selection sort , são de 66 comparações para a ordenação da referida
lista.

57

análise de algoritmos

58

3.3 algoritmos de ordenação de listas

Considere uma lista de n elementos e denote por C(n) o total de comparações

feitas pelo algoritmo para ordenar esta lista.

−

Observe agora que em uma lista com n elementos são feitas inicialmente (n

1)

comparações para colocar o menor elemento na primeira posição. Feito isso resta or-

denar os outros n

1 elementos, e necessitará um total de C(n

1) comparações. No

−

−

caso onde n = 1 (a lista tem apenas um elemento) não é necessário fazer comparações.

Concluímos assim que

Abrindo temos que

C(n) = C(n

1) + (n

−
C(1) = 0.

1)

−

C(n) = C(n

= C(n

=

· · ·

1) + (n

2) + (n

−

−

−

−

1)

2) + (n

1)

−

= C(1) + 1 + 2 +

+ (n

1)

−

· · ·

= 1 + 2 +
n(n

+ (n

1)

−

· · ·
1)

=

−
2

Neste caso diz-se que a complexidade desse algoritmo é de ordem quadrática. Ou

seja, C(n)

∈

O(n2) , pois esses resultados crescem de forma similar.

É interessante observar que neste método não existe diferença entre as situações

pior, média ou melhor, pois são realizadas todas as comparações necessárias partindo

do primeiro elemento não ordenado.

3.3.2 Ordenação por Flutuação (Bubble Sort)

Este método de ordenação tem uma estratégia similar ao algoritmo anterior, mas

com uma técnica distinta. A ideia é localizar o maior elemento e levá-lo ao ﬁnal

da lista. Para fazer isso a ideia é comparar o primeiro elemento com o segundo,

colocando-os em ordem crescente, em seguida comparar o segundo com o terceiro

elemento colocando-os em ordem crescente, na segunda e terceira posição da lista,

fazendo assim até comparar (e se necessário trocar) os dois último elementos da lista.

59

análise de algoritmos

Note que ao passarmos pelo maior elemento da lista, este elemento ganhará todas as

comparações subsequentes, forçando a troca e passando para a comparação seguinte.

Com isso, ao ﬁnal do processo, o maior elemento estará no ﬁnal da lista.

Inicia-se novamente o processo nos n

1 elementos ainda não ordenados, recursi-

vamente, até restar apenas um elemento (caso trivial).

−

Exemplo 3.2. Agora ilustraremos a aplicação do método de ordenação por bolha na
mesma lista apresentada no problema 4 do capítulo 1. Ao ﬁnal poderemos observar
que a resposta ao problema utilizando o método selection sort ou o método bubble
sort necessitam de 66 comparações para a ordenação da lista dada.

60

3.3 algoritmos de ordenação de listas

Considere agora uma lista de n elementos. Assim como no algoritmo de ordena-

ção por seleção, a ordenação por ﬂutuação faz na primeira passagem um total de

n

−

1 comparações (todos os pares consecutivos de posições), e em seguida ordena

recursivamente os elementos restante. Assim, se C(n) é o total de comparações, então

C(n) = C(n

1) + (n

1)

−

−

C(1) = 0.

C(n) =

n2

n

,

−
2

e

assim como no selection sort.

A vantagem deste algoritmo está na possibilidade de pararmos os algoritmo antes.

Note que se ao passar fazendo as comparações em cada par de posições consecuti-

vas, nenhum par de elementos trocar de posição é por que a lista já está ordenada!

Com isso podemos colocar um gatilho em nosso algoritmo para terminar a execução

quando, em alguma instância, nenhum troca de posições for feita.

61

análise de algoritmos

Assim, se a lista já estiver ordenada deste o início, o algoritmo fará apenas n

comparações.

1

−

A complexidade deste método é portanto, no pior caso é O(n2), enquanto que no

melhor caso é O(n).

3.3.3 Ordenação por Intercalação (Merge Sort)

Criado por John Von Neumann em 1945, o merge sort, ou ordenação por interca-
lação, é um exemplo de algoritmo de ordenação do tipo “dividir para conquistar”.

Estratégia esta que consiste em dividir o problema de forma balanceada (gerando
subproblemas de mesmo tamanho) para conquistar o objetivo. [11]

A idéia do merge sort é dividir o problema em duas listas de mesmo tamanho

(com uma diferença de um elemento se o total de elementos é ímpar), ordená-los

recursivamente, e depois fundir as duas listas de modo ordenado.

Abrindo a recursão, podemos dividir este método em três etapas para efetuar a

ordenação de uma lista. (ver [11]):

1. Divisão dos dados da lista em duas listas menores , sendo que estas listas se

dividem até que cada lista tenha exatamente um elemento;

2. Faz-se as comparações entre cada dupla de elementos que originaram as listas

ﬁnais;

3. Refazer as listas da etapa imediatamente anterior combinando as duas metades

em uma lista organizada.

Uma parte essencial deste algoritmo está em como realizar a fusão das listas orde-

nadas. Para isso, ele começa pegando o primeiro elemento da primeira lista como

elemento de comparação. Sabemos que todos os demais elementos da primeira lista

são maiores que o escolhido, de modo que se um elemento da outra lista que está
sendo comparada é menor que ele, então é menor que todos os da lista 1. Come-
çamos então comparando o elemento escolhido com os elementos da lista 2. Se o
elemento da lista 2 for menor que o escolhido ele é colocado em uma lista auxiliar,
Isso segue até encontrarmos um elemento maior.
na primeira posição disponível.

Neste momento o elemento de comparação vai para a lista auxiliar, e o elemento

62

3.3 algoritmos de ordenação de listas

seguinte da lista 1 (maior) toma o lugar dele, como elemento de comparação. Este
procedimento segue até que todos os elementos estejam na lista auxiliar, que estará

ordenada.

Exemplo 3.3. Aplicando este método na lista utilizada pelo problema 4 do capítulo
1, tem-se:

Observamos que neste método, a quantidade de comparações foi:

4 + 8 + 6 + 9 = 27,

ou seja, neste método efetuou-se menos comparações, em relação aos métodos utili-

zados anteriormente, podendo ser visto como uma melhor opção que as anteriores.

Funcionamento para uma lista com n elementos

Antes de mais nada é importante localizar o pior e melhor caso deste algoritmo.

Podemos deﬁnir o que é melhor e pior caso para a ordenação por mistura da seguinte

maneira.

63

análise de algoritmos

Melhor Caso - nunca é necessário trocar elementos após comparações.

Pior Caso - sempre é necessário trocar elementos após comparações.

Vamos nos concentrar na análise do pior caso, e como o algoritmo sempre divide
a lista pela metade, vamos considerar n = 2k. Como estamos interessados no com-

portamento assintótico da função, este caso é o suﬁciente para nossa análise.

Assim, no pior caso, ao fazer a fusão de duas listas de tamanho n/2, como o

algoritmo sempre troca de elemento ao comparar, o total de comparações feitas é n

(deixamos como exercício a veriﬁcação dessa aﬁrmação.)

Para ordenar uma lista de tamanho n o merge sort divide a lista em duas de

tamanho n/2, ordena cada uma delas recursivamente, e funde as duas.

Desta maneira, o o total de comparações do Merge sort no pior caso é dado por

(cid:40)

C(n) =

1
,
(cid:1) + n ,
2C (cid:0) n

2

se n = 1;

se n

2;

≥

(3.1)

Esta equação já foi resolvida no exemplo 2.12, onde encontramos que

C(n) = (n + 1) log2 n,

e portanto C(n)

O(n log2 n).

∈

Veriﬁcando o funcionamento para n elementos, temos:

Figura 13: Exemplo de funcionamento do algoritmo de ordenação por intercalação

64

3.4 algoritmos de busca

3.4 algoritmos de busca

É um algoritmo, utilizado em computação com a ﬁnalidade de fazer uma busca

para encontrar um registro ou elemento desejado, chamado de chave, em uma lista

(pode ser uma tabela, vetor de registros, uma árvore ...). A operação de busca é uma

das três operações mais frequentes numa lista, junto com a inserção e a remoção de

um elemento da lista.

As técnicas de busca que mostraremos são as de busca sequencial e busca binária.

3.4.1 Busca Sequencial

É a forma mais simples de busca. Ela é aplicável a uma tabela ordenada ou não,

porém a eﬁciência da operação de busca melhora se os registros estiverem ordena-

dos, pois podemos parar a busca quando encontramos um registro maior que o que

buscamos.

funcionamento:
da lista, iniciando pelo primeiro da lista até encontrar o elemento procurado ou até

A chave procurada é comparada com cada um dos elementos

chegar ao ﬁnal dos elementos da lista, retornando com o resultado da procura.

O algoritmo tem um tempo de processamento máximo quando a chave é o úl-

timo item da lista, ou quando não é um elemento da lista. Nos dois casos, todos

os elementos da lista são comparados a chave, totalizando assim n comparações. É

claro que a chave poderia ser o primeiro item da lista, o que acarretaria apenas uma

comparação; no entanto, se a chave estiver no meio da lista serão necessárias apro-
ximadamente n/2 comparações. Obviamente, existem muitas possibilidades e seria

interessante que tivéssemos alguma forma de estimar o valor médio da quantidade

de processamento demandada. Tal estimativa requer informações sobre a lista típica

sobre a qual se realiza a busca, bem como uma relação típica entre o valor procu-

rado e a lista dada. Porém, uma medida para o comportamento médio é geralmente

muito difícil de sua determinação, não só para este algoritmo especíﬁco, mas para a

maioria dos algoritmos.

Pesquisa com sucesso:

65

análise de algoritmos

melhor caso: C(n) = 1;

pior caso: C(n) = n;

•

•

caso médio: C(n) = (n + 1)/2.

•
Pesquisa sem sucesso: C(n) = n + 1 no pior caso.

O algoritmo de pesquisa sequencial é a melhor escolha para o problema de pes-

quisa em tabelas com até 25 registros. [12]

3.4.2 Busca Binária

É um algoritmo aplicado somente quando os dados estiverem ordenados na lista

e não permite a existência de duplicidade (elementos duplicados) na lista. A busca

binária é quase sempre mais eﬁciente que a busca sequencial. Entretanto, um algo-

ritmo de busca sequencial tem uma grande vantagem: se a lista a ser pesquisada não

estiver ordenada, o algoritmo de busca sequencial funcionará, mas o de busca biná-

ria, não. Devemos ordenar a lista para então usarmos o algoritmo de busca binária,

assim, devemos considerar o número de operações envolvidas no procedimento de

ordenação.

funcionamento da busca binária:
na tabela:

Para saber se uma chave está presente

1. Compare o elemento procurado (chave) com o registro que está na posição do

meio da lista;

2. Se a chave é menor então o registro procurado está na primeira metade da lista;

3. Se a chave é maior então o registro procurado está na segunda metade da lista;

4. Repita até que a chave seja encontrada ou que se constate que a chave não

existe na lista.

Exemplo 3.4. Tomemos como exemplo o problema 5 do capítulo 1, supondo que o
jogador A tenha escolhido o valor 356.

66

3.4 algoritmos de busca

Ou seja, estamos buscando o elemento 356 na lista de números de 1 a 1000.

Solução:

1. Como o número deve estar entre 1 e 1000, o resultado escolhido será
1000/2=500, sendo que será dito que o número chave é menor que o valor
dado.

2. Agora temos que o número está entre 1 e 500. Assim, o método diz para
escolher 500/2=250. Como resposta teremos que a chave é um número maior
que o valor apresentado.

3. Temos agora que a chave está entre 250 e 500, logo pela busca binária temos
que (250+500)/2= 375, que é o valor escolhido pelo método. Como resposta
teremos que a chave é um número menor que o valor apresentado.

4. Agora, pela busca temos que o número a ser passado está entre 250 e 375, ou
seja, (250+375)/2= 312,5 (neste caso usaremos o 312) e será dito que o número
continua sendo maior que esse valor.

5. Continuando, temos que: (312+375)/2=343,5 (usamos 343) e a chave ainda é

um número maior.

6. Agora, temos:

(343+375)/2=359 e nos será dito que a chave é um número

menor.

7. Logo, (343+359)/2= 351, onde a chave é um número maior que este.

8. Então, (351+359)/2= 355 e novamente seremos informados que a chave é maior.

9. Agora, (355+359)/2= 357 é o número dado pela busca binária e ainda não

chegamos ao resultado procurado.

10. Temos aqui: (355+357)/2= 356, que é o resultado procurado. Assim, veriﬁ-
cando a quantidade de operações, temos que foram necessárias dez chutes

para chegar ao resultado correto.

A Figura 14 a seguir mostra o exemplo anterior em forma de diagrama esquemá-

tico.

67

análise de algoritmos

Figura 14: Diagrama esquemático da busca realizada no exemplo 3.4.

análise da complexidade:
do algoritmo. Não é difícil perceber que a pior situação é aquela em que temos que

A primeira coisa a fazer é localizar o pior caso

reduzir o tamanho das listas ao mínimo para encontrar o elemento procurado, assim

como no exemplo acima.

Neste caso o algoritmo escolhe o número médio, faz uma comparação e escolhe

uma lista de tamanho n/2, onde realiza uma busca nos mesmos moldes. Assim

T(n) =




T (cid:0) n

2

(cid:1) + 1,



1,

se n

2

≥

se n = 1.

Assim como no caso do merge sorte consideraremos, sem perda de generalidade que
n = 2k. Fazendo então esta substituição temos

T(2k) =




T(2k

−

1) + 1,

se k

1

≥



1,

se k = 0.

Segue facilmente que

T(2k) = kT(20) = k,

68

3.5 atividades

e como k = log2 n, então

T(n) = log2 n.

3.5 atividades

1. O algoritmo de busca binaria é utilizado na lista a seguir; x tem o valor "Cui-

abá". Enumere os elementos com os quais x é comparado.

(Brasília, Campinas, Ipu, Nova Iguaçu, Petrolina, São Paulo, Xerém)

2. Um algoritmo de busca binária é usado na lista a seguir, tendo como valor de

busca x = "margarina". Indique com quais elementos x é comparado.

(açúcar, chocolate, manteiga, margarina, nata, ovos)

3. Em cada passo do algoritmo selection sort, o índice do item de valor máximo
em uma lista deve ser determinado. Isto requer comparações entre os elemen-

tos da lista. Quantas comparações são necessárias no pior caso para determinar
o maior elemento de uma lista não ordenada com 17 elementos?

4. A parte do algoritmo merge sort que executa o merge requer a comparação
entre elementos das duas listas ordenadas a ﬁm de escolher qual elemento

será incluído na lista ordenada, que será a combinação das duas "metades

já ordenadas". Quando o ﬁm de uma das listas é alcançado, os elementos

restantes da outra lista podem ser adicionados à nova lista sem a necessidade

de mais comparações. Dadas as duas listas, nos itens abaixo, execute um merge

e conte o número de comparações necessárias para executá-lo.

a) 5, 7, 9 e 1, 3, 4

b) 1, 6, 7 e 2, 3, 5

c) 0, 1, 3, 5, 7, 11 e 2, 8, 9, 10, 12

69

B I B L I O G R A F I A

[1] WIKIPEDIA. Wikipedia - M.C.Escher.

http://pt.wikipedia.org/wiki/

Maurits_Cornelis_Escher, 2013.

[2] SCHATTSCHNEIDER, D. The mathematical side of m. c. escher. Notices of the

AMS, v. 57, n. 6, p. 706–718, Junho/Julho 2010.

[3] FOUNDATION, M. Site Oﬁcial de M.C.Escher. http://www.mcescher.com,

2013.

[4] MARTA; FELIPE. Trabalho da disciplina “Seminário Temático” - Universidade
de Lisboa. http://www.educ.fc.ul.pt/docentes/opombo/seminario/escher/
browser.html, 2002.

[5] LUCAS, É. Jeux scientiﬁques pour servir à l’histoire, à l’enseignement et à la pratique

du calcul et du dessin- la tour d’hanoi. 3. Paris: Chambon & Baye, 1889.

[6] C.R.MORAES. Estruturas de dados e algoritmos, uma abordagem didática. São Paulo:

Editora Berkeley, 2001.

[7] DE GLASMAN, J. B. Revista Morasha - Flávio Josefo, entre Roma e Jeru-
salém. http://www.morasha.com.br/conteudo/artigos/artigos_view.asp?a=
862&p=4, setembro 2010.

[8] WIKIPEDIA. Wikipédia - Liber Abaci. http://pt.wikipedia.org/wiki/Liber_

Abaci, 2013.

[9] BOYER, C. B. História da matemática. São Paulo: Edgar Blucher, 1974.

[10] PAIVA, R. E. B.

Progressões aritmético-geométricas (pag) e progressões
geométrico-aritméticas (pga). Revista do Professor de Matemática, , n. 73, p. 47–49,
setembro 2010.

[11] GRAHAM, R. L.; KNUTH, D. E.; PATASHINIK, O. Concrete mathematics. New

York: Addison-Wesley Publishing Company, 1990.

71

Bibliograﬁa

[12] TOFOLLO, T.

Notas de

Dispo-
nível em http://www.decom.ufop.br/toffolo/site_media/uploads/2011-1/
bcc202/slides/21._pesquisa.pdf.

aula

aula de bcc202

21.

-

[13] POLLMAN, H. S. Equações de recorrência. Revista Eureka!, , n. 9, p. 33, 2000.

[14] CORMEN, T. H.; LEISERSON, C. E.; RIVEST, R. L.; STEIN, C. Algoritmos - teoria

e prática. 2. ed. Rio de Janeiro: Editora Campus, 2002.

[15] SZWARCFTITER, J. L.; MARKERNZON, L. Estruturas de dados e seus algoritmos.

Rio de Janeiro: LTC Editora S.A., 1994.

[16] GERSTING, J. L. Fundamentos matemáticos para a ciência da computação. 3. ed. Rio

de Janeiro: LTC Editora S.A., 1993.

[17] PARDO, T. A. S. Métodos de Busca - Slides de curso. http://wiki.icmc.usp.

br/images/7/7c/M%C3%A9todos_de_busca_-_parte1_2010.pdf, 2008.

[18] ROBERTSON, J. O. . E. F. Mactutor history of mathematics - François Edou-
ard Anatole Lucas. http://www-history.mcs.st-andrews.ac.uk/Biographies/
Lucas.html, dezembro 1996.

[19] MIYAZAWA, F. K. Notas de aula de complexidade de algoritmo. Dispo-
nível em http://www.dcc.ufrj.br/~francisco_vianna/livros/Apostila.de.
Algoritmos.-UNICAMP.pdf, 2013.

72

