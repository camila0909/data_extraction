Universidade Federal da Para(cid:237)ba

Centro de CiŒncias Exatas e da Natureza

Programa de P(cid:243)s-Gradua(cid:231)ªo em MatemÆtica

Curso de Mestrado em MatemÆtica

Criptogra(cid:28)a RSA e a Teoria dos
Nœmeros †

por

Roberval da Costa Lima

sob orienta(cid:231)ªo do

Prof. Dr. Bruno Henrique Carvalho Ribeiro

Trabalho de conclusªo apresentado ao Corpo

Docente do Programa de P(cid:243)s-Gradua(cid:231)ªo em

MatemÆtica em Rede Nacional PROFMAT

CCEN - UFPB, como requisito parcial para

obten(cid:231)ªo do t(cid:237)tulo de Mestre em MatemÆtica.

Agosto/2013

Joªo Pessoa - PB

†Este trabalho contou com apoio (cid:28)nanceiro da CAPES.

L732c

Lima, Roberval da Costa.

Criptogra(cid:28)a RSA e a Teoria dos Nœmeros / Roberval da

Costa Lima.(cid:21) Joªo Pessoa, 2013.

76f.

Orientador: Bruno Henrique Carvalho Ribeiro

Disserta(cid:231)ªo (Mestrado) - UFPB/CCEN

1. MatemÆtica. 2. Criptogra(cid:28)a RSA. 3. Teoria dos nœmeros.

4. CongruŒncias. 5. Pequeno Teorema de Fermat.

UFPB/BC

CDU: 51(043)

Agradecimentos

Ao meu orientador Prof. Bruno Henrique C. Ribeiro pela paciŒncia, pela com-

preensªo e pela orienta(cid:231)ªo deste trabalho.

Ao Prof. Ant(cid:244)nio de Andrade e Silva pelo incentivo, insistente e sistemÆtico.

Infelizmente, nªo fui seu aluno, mas, tenho por ele uma grande admira(cid:231)ªo. Grande

Prof. Andrade.

Aos meus professores de diversas Øpocas por mostrarem com maestria a beleza da

matemÆtica, cito aqui o nome de alguns: Joªo Montenegro, Lenimar, Marivaldo, Ab-

doral (in memoriam), Marsicano (in memoriam), Chianca (in memoriam), Antonio

Carlos (UFPE-1993), Jorge Hounie (UFPE-1993) e Roberto Bedregal (UFPE-1993).

A minha esposa Jucilene e minhas (cid:28)lhas Juciane e Jucielen pela compreensªo e

apoio na realiza(cid:231)ªo desse mestrado.

Aos colegas de curso, especialmente, Alysson Espedito, Diego e Aldeck pela ajuda

nos grupos de estudo durante todo o mestrado.

Dedicat(cid:243)ria

Aos meus pais, Joªo Bento de Lima

(in memoriam) e Irene da Costa

Lima. Minha esposa Jucilene e mi-

nhas (cid:28)lhas Juciane e Jucielen.

Resumo

Neste trabalho apresentamos o conceito de criptogra(cid:28)a, diferenciamos a cripto-

gra(cid:28)a simØtrica da criptogra(cid:28)a assimØtrica e mostramos como funciona a criptogra(cid:28)a

RSA. AlØm disso, destacamos os principais resultados matemÆticos que justi(cid:28)cam o

funcionamento desse criptossistema e sua seguran(cid:231)a, tais como: congruŒncias, Teo-

rema de Euler, Pequeno Teorema de Fermat, Teorema de Wilson, CritØrio de Euler

para res(cid:237)duos quadrÆticos, Lei de Reciprocidade QuadrÆtica e testes de primalidade.

Palavras chaves: Criptogra(cid:28)a RSA, teoria dos nœmeros, congruŒncias, Pequeno

Teorema de Fermat.

vi

Abstract

In this work we present the concept of cryptography, highlighting the di(cid:27)erences

between symmetric encryption and asymmetric encryption. We also show how RSA

encryption works. Moreover, we study the main mathematical results that justify

the operation of this cryptosystem and its security, such as: congruences, Euler’s

theorem, Fermat’s Little Theorem, Wilson’s Theorem, Euler’s criterion for quadratic

residues, Law of Quadratic Reciprocity and primality tests.

Keywords: RSA Encryption, number theory, congruence, Fermat’s Little Theo-

rem.

vii

SumÆrio

1 CongruŒncias

1.1 AritmØtica dos Restos

. . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 Os Teoremas de Euler e Wilson . . . . . . . . . . . . . . . . . . . . .

1

1

9

1.3 Res(cid:237)duos QuadrÆticos . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

2 Nœmeros Primos

27

2.1 Como Encontrar Nœmeros Primos . . . . . . . . . . . . . . . . . . . . 27

2.2 Teste de Primalidade . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

3 Criptogra(cid:28)a RSA

39

3.1 Criptossistemas SimØtricos e AssimØtricos

. . . . . . . . . . . . . . . 39

3.2 Gera(cid:231)ªo das Chaves . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

3.3 Codi(cid:28)ca(cid:231)ªo e Decodi(cid:28)ca(cid:231)ªo . . . . . . . . . . . . . . . . . . . . . . . 43

3.4 Seguran(cid:231)a do RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

3.5 Assinatura Digital . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

3.6 Aplica(cid:231)ªo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

4 Criptogra(cid:28)a RSA no Ensino MØdio

54

4.1 MatemÆtica BÆsica . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

4.1.1 Divisªo Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . 54

4.1.2 MÆximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . 55

viii

4.1.3 CongruŒncia . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

4.2 Criptogra(cid:28)a RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

ReferŒncias BibliogrÆ(cid:28)cas

64

ix

Introdu(cid:231)ªo

Este trabalho tem como objetivo principal explorar a matemÆtica necessÆria

para implementa(cid:231)ªo do sistema criptogrÆ(cid:28)co RSA. AlØm disso, deve servir como

fonte inspiradora para estimular professores e alunos do ensino mØdio a ver que

a matemÆtica, mesmo tªo abstrata, como Ø o caso dos resultados apresentados,

principalmente nos cap(cid:237)tulo 1 e 2, possui uma aplica(cid:231)ªo extremamente simples e

inusitada como a criptogra(cid:28)a RSA.

A criptogra(cid:28)a Ø o estudo de mØtodos que permitam escrever mensagens em cifras

ou c(cid:243)digos, de modo que apenas os leg(cid:237)timos destinatÆrios sejam capazes de deco-

di(cid:28)car e ler as mensagens. Hoje em dia mais e mais pessoas e empresas utilizam a

internet para se comunicar, tornando o uso da criptogra(cid:28)a para manter o sigilo dessa

comunica(cid:231)ªo cada vez mais importante. Por exemplo, bancos comerciais necessitam

garantir que as transa(cid:231)ıes entre seus clientes e o banco tenha a mÆxima seguran(cid:231)a

poss(cid:237)vel. No caso dos bancos essa seguran(cid:231)a Ø ainda mais importante, pois, quase

todas as suas transa(cid:231)ıes passam pela internet e envolvem grandes valores monetÆ-

rios, mesmo aquelas realizadas nas agŒncias bancÆrias. Nosso trabalho serÆ baseado

na criptogra(cid:28)a RSA. Esse sistema criptogrÆ(cid:28)co funciona da seguinte maneira: sªo

criadas duas chaves, uma chave de codi(cid:28)ca(cid:231)ªo que serÆ pœblica e uma chave de

decodi(cid:28)ca(cid:231)ªo que serÆ privada. Assim, se um usuÆrio A deseja enviar uma mensa-

gem para um usuÆrio B, entªo A usa a chave de codi(cid:28)ca(cid:231)ªo de B para codi(cid:28)car a

mensagem e envia essa mensagem codi(cid:28)cada para B, quando B recebe a mensagem

x

codi(cid:28)cada usa sua chave de decodi(cid:28)ca(cid:231)ªo, que apenas ele conhece, e decodi(cid:28)ca a

mensagem codi(cid:28)cada, obtendo assim a mensagem original.

Ao longo dos trŒs primeiros cap(cid:237)tulos procuramos mostrar de forma sistemÆtica

e formal os principais resultados matemÆticos que tornam poss(cid:237)vel a implementa(cid:231)ªo

do sistema criptogrÆ(cid:28)co RSA. E, no œltimo cap(cid:237)tulo tentamos explorar esse criptos-

sistema com um enfoque menos formal de modo que seja poss(cid:237)vel expor esse assunto

para alunos do ensino mØdio.

Para desenvolver os conteœdos aqui estudados assumimos como conhecidos alguns

t(cid:243)picos elementares da teoria dos nœmeros, entre outros, citamos o princ(cid:237)pio de

indu(cid:231)ªo, o algoritmo da divisªo euclidiana e o mÆximo divisor comum. No entanto,

no œltimo cap(cid:237)tulo abordamos informalmente o algoritmo da divisªo euclidiana e o

mÆximo divisor comum.

A implementa(cid:231)ªo da criptogra(cid:28)a RSA estÆ totalmente baseada na aritmØtica das

congruŒncias. Da(cid:237), come(cid:231)amos nosso trabalho desenvolvendo os principais resulta-

dos sobre as congruŒncias. Na se(cid:231)ªo 1 do primeiro cap(cid:237)tulo descrevemos os aspectos

aritmØticos das congruŒncias, mostrando como sªo feitas as manipula(cid:231)ıes com con-

gruŒncias e introduzindo o conceito de classe de equivalŒncia, muito œtil em algumas

demonstra(cid:231)ıes, como foi o caso da demonstra(cid:231)ªo do teorema de Euler e o teorema

de Wilson. Na se(cid:231)ªo 2, introduzimos o conceito de equa(cid:231)ªo modular e a fun(cid:231)ªo (cid:28) de

Euler. Nesta se(cid:231)ªo apesar do t(cid:237)tulo dÆ a entender que o objetivo principal seria o

Teorema de Euler e o Teorema de Wilson, aqui demonstramos o Pequeno Teorema

de Fermat que serÆ usado para justi(cid:28)car o funcionamento do sistema RSA, apre-
sentamos o conceito de ordem de um elemento do conjunto Zn, alguns resultados

sobre essa ordem e a de(cid:28)ni(cid:231)ªo de raiz primitiva. Na se(cid:231)ªo 3, estudamos os res(cid:237)duos

quadrÆticos, introduzimos o S(cid:237)mbolo de Legendre, demonstramos o CritØrio de Eu-

ler e a Lei de Reciprocidade QuadrÆtica, esses resultados nªo sªo necessÆrios para a

xi

implementa(cid:231)ªo do sistema RSA, mas, sªo utilizados para demonstrar um dos testes

de primalidade estudados no cap(cid:237)tulo 2.

No cap(cid:237)tulo 2 estudamos, na se(cid:231)ªo 1, como encontrar nœmeros primos com mais

de 100 algarismos. Aqui apresentamos a fun(cid:231)ªo π(x), o teorema dos nœmeros primos

e (cid:28)zemos uma estimativa do nœmero de nœmeros primos com 100 algarismos que

devemos testar para encontrar um nœmero primo com 100 algarismos. Na se(cid:231)ªo 2

demonstramos alguns testes de primalidade e apresentamos, mas, nªo demonstramos

o teste AKSL. Na verdade Ø nessa se(cid:231)ªo e na se(cid:231)ªo 3 do cap(cid:237)tulo 1 que reside a

matemÆtica mais so(cid:28)sticada. Essa matemÆtica estÆ intimamente ligada (cid:224) seguran(cid:231)a

do sistema RSA, pois, para di(cid:28)cultar a fatora(cid:231)ªo de n = pq necessitamos ter certeza

que os nœmeros, p e q, escolhidos sejam realmente primos.

No cap(cid:237)tulo 3 apresentamos, na se(cid:231)ªo 1, uma visªo geral sobre o que Ø um sistema

criptogrÆ(cid:28)co diferenciando os criptossistemas simØtricos e assimØtricos. Nas se(cid:231)ıes

2 e 3 descrevemos, passo a passo, como funciona o sistema RSA e nas se(cid:231)ıes 4 e

5 abordamos alguns aspectos ligados a seguran(cid:231)a do sistema RSA e o conceito de

assinatura digital. E, por (cid:28)m, na se(cid:231)ªo 6 (cid:28)zemos dois exemplos para que o leitor

veja como funciona esse sistema criptogrÆ(cid:28)co.

O cap(cid:237)tulo 4 apresenta a criptogra(cid:28)a RSA com uma abordagem informal. Bus-

cando atravØs de exemplos mostrar toda a matemÆtica necessÆria (cid:224) implementa(cid:231)ªo

desse sistema, sem a preocupa(cid:231)ªo de justi(cid:28)car porque esse sistema funciona e sem

nos preocuparmos com a seguran(cid:231)a. A abordagem dada aos conteœdos apresentados

nesse cap(cid:237)tulo tem como prop(cid:243)sito facilitar a compreensªo do sistema RSA para

professores e alunos do ensino mØdio.

O presente trabalho teve as se(cid:231)ıes 1 e 2 do cap(cid:237)tulo 1 baseadas em [3, 5] e a

se(cid:231)ªo 3 foi in(cid:29)uenciada por [6]. JÆ o cap(cid:237)tulo 2 foi inspirado em [1, 4]. As se(cid:231)ıes 1

e 2 do cap(cid:237)tulo 3 teve forte in(cid:29)uŒncia de [7, 8] e as demais se(cid:231)ıes foram baseadas

xii

em [2]. O cap(cid:237)tulo 4 Ø uma adapta(cid:231)ªo feita pelo autor desse trabalho do conteœdo

apresentado no cap(cid:237)tulo 3 para que seja poss(cid:237)vel aplicÆ-lo no ensino mØdio.

xiii

Cap(cid:237)tulo 1

CongruŒncias

Apresentaremos neste cap(cid:237)tulo as congruŒncias. Como o sistema criptogrÆ(cid:28)co

RSA usa essencialmente a aritmØtica dos restos entªo daremos a esse cap(cid:237)tulo uma

aten(cid:231)ªo maior, mostrando os principais resultados sobre as congruŒncias. AlØm

disso, as congruŒncias estªo relacionadas com todos os resultados usados, tanto

para justi(cid:28)car porque o sistema RSA funciona quanto para demonstrar os testes de

primalidade.

1.1 AritmØtica dos Restos

Aqui mostraremos que a de(cid:28)ni(cid:231)ªo de congruŒncia nos darÆ uma aritmØtica para

os restos da divisªo euclidiana por um dado nœmero inteiro positivo. Veremos no

cap(cid:237)tulo 3 que essa aritmØtica Ø fundamental para a criptogra(cid:28)a RSA.

De(cid:28)ni(cid:231)ªo 1.1.1 Dados a, b e n nœmeros inteiros, com n > 1. Dizemos que a e b

sªo congruentes m(cid:243)dulo n se na divisªo euclidiana por n deixam o mesmo resto. E

nesse caso escrevemos

a ≡ b mod n.

1

AritmØtica dos Restos

Cap(cid:237)tulo 1

Na pr(cid:243)xima proposi(cid:231)ªo teremos um mØtodo para estabelecer se um dado nœmero

inteiro Ø ou nªo congruente a outro nœmero inteiro. Alguns autores usam essa

proposi(cid:231)ªo como de(cid:28)ni(cid:231)ªo de congruŒncia.

Proposi(cid:231)ªo 1.1.1 Seja n ∈ Z, com n > 1. Sejam a, b ∈ Z. Entªo

a ≡ b mod n ⇔ n|(a − b)

Demonstra(cid:231)ªo: Se a ≡ b mod n, entªo existem q1, q2, r ∈ Z tais que a = q1n + r

e b = q2n + r, com 0 ≤ r < n. Assim, a − b = q1n − q2n = (q1 − q2)n. Portanto,

temos que n|(a − b). Reciprocamente, suponha que n|(a − b). Em seguida, divida a
e b por n. Assim, existem c1, c2, r1, r2 ∈ Z tais que a = c1n + r1, com 0 ≤ r1 < n e

b = c2n + r2, com 0 ≤ r2 < n. Da(cid:237), resulta que a − b = (c1 − c2)n + r1 − r2, alØm

disso, temos que n|(a − b). Portanto, a − b ≡ r1 − r2 mod n e a − b ≡ 0 mod n.

Mas, pela de(cid:28)ni(cid:231)ªo de congruŒncia temos que: como a − b Ø congruente a r1 − r2,

temos que esses nœmeros deixam o mesmo resto na divisªo euclidiana por n, por

outro lado, como a − b Ø congruente a 0, temos que eles deixam o mesmo resto na

divisªo euclidiana por n, assim, temos que r1 − r2 e 0 deixam o mesmo resto na

divisªo euclidiana por n. Portanto, obtemos r1 − r2 ≡ 0 mod n, mas, sabemos que

0 ≤ r1 < n e 0 ≤ r2 < n, assim, obtemos r1 = r2. Logo, temos que a ≡ b mod n

como quer(cid:237)amos demonstrar.

A proposi(cid:231)ªo a seguir nos diz que a congruŒncia Ø uma rela(cid:231)ªo de equivalŒncia
sob o conjunto Z. AlØm de ser de fundamental import(cid:226)ncia para podermos desen-

volver os principais resultados das congruŒncias ela Ø essencial para estabelecermos

o conjunto das classes de equivalŒncia e desenvolver a aritmØtica das classes de equi-

valŒncia. AlØm disso, ela estabelece uma equivalŒncia entre as congruŒncias e as

classes de equivalŒncia, que serÆ muito œtil em muitas demonstra(cid:231)ıes como veremos

adiante.

2

AritmØtica dos Restos

Cap(cid:237)tulo 1

Proposi(cid:231)ªo 1.1.2 Seja n ∈ Z, com n > 1. Para todos a, b, c ∈ Z, tem-se que:

(1) a ≡ a mod n,

(2) Se a ≡ b mod n, entªo b ≡ a mod n,

(3) Se a ≡ b mod n e b ≡ c mod n, entªo a ≡ c mod n.

Demonstra(cid:231)ªo:

(1) Como n|0, temos que n|(a − a). Da(cid:237), obtemos que a ≡ a mod n.
(2) Se a ≡ b mod n, entªo n|(a − b), isto Ø, existe um q ∈ Z tal que a − b = qn.
Da(cid:237), temos que b − a = (−q)n, com (−q) ∈ Z, assim, temos que n|(b − a). Logo,

b ≡ a mod n.

(3) Se a ≡ b mod n e b ≡ c mod n, entªo teremos que n|(a − b) e n|(b − c), o que

implica n|[(a − b) + (b − c)] = (a − c). Logo, temos que a ≡ c mod n.

A proposi(cid:231)ªo seguinte mostra que a rela(cid:231)ªo de equivalŒncia dada pela congruŒncia
Ø compat(cid:237)vel com as opera(cid:231)ıes de soma e produto em Z. Esta compatibilidade Ø

fundamental na manipula(cid:231)ªo aritmØtica dos restos.

Proposi(cid:231)ªo 1.1.3 Sejam a, b, c, d, n ∈ Z, com n > 1.

Se a ≡ b mod n e

c ≡ d mod n, entªo

a + c ≡ b + d mod n

e

ac ≡ bd mod n.

Demonstra(cid:231)ªo: Como a ≡ b mod n e c ≡ d mod n, temos que n|(a − b) e

n|(c − d), o que implica n|(a − b) + (c − d) = (a + c) − (b + d). Da(cid:237), obtemos

a + c ≡ b + d mod n. Por outro lado, como n|(a − b) e n|(c − d), temos que existem

q1 e q2 nœmeros inteiros tais que a − b = q1n e c − d = q2n o que implica a = b + q1n

e c = d + q2n. Da(cid:237), multiplicando membro a membro as duas igualdade obtemos

ac = bd + (bq2 + dq1 + q1q2)n, isto Ø, ac − bd = (bq2 + dq1)n o que implica n|(ac − bd).

Portanto, temos que ac ≡ bd mod n.

3

AritmØtica dos Restos

Cap(cid:237)tulo 1

As duas proposi(cid:231)ıes que se seguem mostram que vale a lei do cancelamento

na adi(cid:231)ªo e em certos casos espec(cid:237)(cid:28)cos vale, tambØm, a lei do cancelamento na

multiplica(cid:231)ªo.

Proposi(cid:231)ªo 1.1.4 Sejam a, b, c, n ∈ Z, com n > 1. Entªo

a + c ≡ b + c mod n ⇔ a ≡ b mod n.

Demonstra(cid:231)ªo: Como a + c ≡ b + c mod n temos, pela Proposi(cid:231)ªo 1.1.1, que

n|[(a + c) − (b + c)] = (a − b). Portanto, pela Proposi(cid:231)ªo 1.1.1 temos que a ≡ b

mod n. Reciprocamente, se a ≡ b mod n, entªo pela Proposi(cid:231)ªo 1.1.1 n|(a − b) =

[(a + c) − (b + c)]. Logo, pela Proposi(cid:231)ªo 1.1.1 temos que a + c ≡ b + c mod n.

Proposi(cid:231)ªo 1.1.5 Sejam a, b, c, n ∈ Z, com n > 1 e mdc(c, n) = 1. Entªo

ac ≡ bc mod n ⇔ a ≡ b mod n.

Demonstra(cid:231)ªo: Como ac ≡ bc mod n, temos que n|(ac − bc) = (a − b)c. Como

mdc(c, n) = 1 e n|(a − b)c, teremos que n|(a − b). Sendo assim, obtemos a ≡

b mod n. Reciprocamente, se a ≡ b mod n, entªo n|(a − b). Da(cid:237), temos que

n|(a − b)c = (ac − bc). Logo, temos que ac ≡ bc mod n.

Proposi(cid:231)ªo 1.1.6 Sejam a, b, c, n ∈ Z, com n > 1 e mdc(c, n) = d. Entªo

ac ≡ bc mod n ⇒ a ≡ b mod n
d .

Demonstra(cid:231)ªo:

Se ac ≡ bc mod n, entªo existe k ∈ Z tal que ac − bc =
d . Mas, mdc( c

d = k n
d ) = 1 (aqui usamos
um resultado sobre mdc que nªo demonstramos. O leitor interessado poderÆ ver

(a − b)c = kn. Da(cid:237), temos que (a − b) c

d , n

uma demonstra(cid:231)ªo em [3]), o que implica n

d divide a − b, isto Ø, a ≡ b mod n

d como

quer(cid:237)amos demonstrar.

4

AritmØtica dos Restos

Cap(cid:237)tulo 1

De(cid:28)ni(cid:231)ªo 1.1.2 Um sistema completo de res(cid:237)duos m(cid:243)dulo n Ø um conjunto S de n

nœmeros que deixam todos os restos poss(cid:237)veis da divisªo euclidiana desses nœmeros

por n.

Proposi(cid:231)ªo 1.1.7 Seja S = {r1, r2, . . . , rn} ⊆ Z um sistema completo de res(cid:237)duos
m(cid:243)dulo n e sejam a, b ∈ Z, com mdc(a, n) = 1, entªo

S(cid:48) = {ar1 + b, ar2 + b, . . . , arn + b}

tambØm Ø um sistema completo de res(cid:237)duos m(cid:243)dulo n.

Demonstra(cid:231)ªo: Como {r1, r2, . . . , rn} Ø um sistema completo de res(cid:237)duos e a, b ∈
Z, temos para cada i = 1, 2, . . . , n, que ari + b ≡ rj mod n, para algum j =
(cid:48)s formam um sistema completo de res(cid:237)duos,

1, 2, . . . , n. Por outro lado, como os ri

se i (cid:54)= j, temos que ri (cid:54)≡ rj mod n. Como mdc(a, n) = 1 temos pela Proposi(cid:231)ªo

1.1.5 que ari

(cid:54)≡ arj mod n e, da(cid:237), pela Proposi(cid:231)ªo 1.1.4, temos que ari + b (cid:54)≡

arj + b mod n. Portanto, provamos que os elementos do conjunto S(cid:48) sªo dois a dois

incongruentes e como S(cid:48) possui n elementos que sªo congruentes aos elementos de

S, conclu(cid:237)mos que {ar1 + b, ar2 + b, . . . , arn + b} Ø um sistema completo de res(cid:237)duos.

Como dado a ∈ Z, pelo algoritmo da divisªo euclidiana, temos que existem
q, r ∈ Z tais que a = qn + r, com 0 ≤ r < n, entªo a Proposi(cid:231)ªo anterior nos

garante que qualquer sistema completo de res(cid:237)duos m(cid:243)dulo n tem seus elementos

congruentes aos elementos do conjunto {0, 1, 2, . . . , n − 1}, em alguma ordem.

A pr(cid:243)xima de(cid:28)ni(cid:231)ªo servirÆ para estabelecermos uma nova forma de lidarmos

com as congruŒncias, em alguns casos simpli(cid:28)cando os cÆlculos em algumas de-

monstra(cid:231)ıes.

5

AritmØtica dos Restos

Cap(cid:237)tulo 1

De(cid:28)ni(cid:231)ªo 1.1.3 Dado a ≡ b mod n, temos que ∃k ∈ Z tal que a − b = kn. Cha-

mamos de classe de equivalŒncia de a em rela(cid:231)ªo a congruŒncia m(cid:243)dulo n o conjunto

a = {a + kn : k ∈ Z}.

A pr(cid:243)xima proposi(cid:231)ªo nos mostra como relacionar as congruŒncias com as classes

de equivalŒncia. Ela nos permite passar de uma forma de nota(cid:231)ªo para outra. Isto

Ø, mostra a rela(cid:231)ªo de equivalŒnca entre as duas formas de tratar com os restos da

divisªo euclidiana por um dado nœmero.

Proposi(cid:231)ªo 1.1.8 Sejam a, b, n ∈ Z, n > 1. Entªo, a ≡ b mod n se, e somente

se, a = b.

Demonstra(cid:231)ªo: Se x ∈ a, entªo existe k ∈ Z tal que x = a+kn, isto Ø, x−a = kn,

o que implica x ≡ a mod n. Como a ≡ b mod n, pela Proposi(cid:231)ªo 1.1.2 item (3),
temos que x ≡ b mod n. Portanto, existe k(cid:48) ∈ Z tal que x − b = k(cid:48)n. Logo, x ∈ b.
Por outro lado, se x ∈ b, entªo existe um c ∈ Z tal que x = b + cn, isto Ø, x − b = cn.

Portanto, x ≡ b mod n. Como a ≡ b mod n, novamente pela Proposi(cid:231)ªo 1.1.2 item
(2) e (3), temos que x ≡ a mod n. Da(cid:237), temos que existe c(cid:48) ∈ Z tal que x − a = c(cid:48)n,

isto Ø, x = a + c(cid:48)n. Logo, x ∈ a. Portanto, temos que a = b. Reciprocamente, se
a = b, entªo a + 0n = a ∈ b, isto Ø, existe k ∈ Z tal que a = b + kn. Da(cid:237), temos que

a − b = kn, isto Ø, a ≡ b mod n.

De(cid:28)ni(cid:231)ªo 1.1.4 O conjunto de todas as classes de equivalŒncia Ø chamado de con-
junto quociente de Z pela rela(cid:231)ªo de congruŒncia m(cid:243)dulo n. E serÆ denotado por
Zn.

Proposi(cid:231)ªo 1.1.9 Se n ∈ Z e n > 1, entªo Zn = {0, 1, 2, . . . , n − 1} Ø um conjunto

contendo exatamente n classes de equivalŒncias.

6

AritmØtica dos Restos

Cap(cid:237)tulo 1

Sejam a, b ∈ Z tais que 0 ≤ a < b < n. Entªo b − a (cid:54)= 0 e
Demonstra(cid:231)ªo:
n (cid:45) (b − a). Portanto, teremos que a (cid:54)≡ b mod n. Logo, pela Proposi(cid:231)ªo anterior
temos que a (cid:54)= b. Assim, {0, 1, 2, . . . , n − 1} ⊆ Zn Ø um conjunto com exatamente
n elementos. Para provar a igualdade Ø su(cid:28)ciente mostrar que: dado a ∈ Z entªo
a ∈ {0, 1, 2, . . . , n − 1}. Pelo algoritmo da divisªo temos que, ∃q, r ∈ Z tais que

a = qn + r, com 0 ≤ r < n. Da(cid:237), teremos que a ≡ r mod n, com 0 ≤ r < n, isto Ø,

a = r ∈ {0, 1, 2, . . . , n − 1} como quer(cid:237)amos mostrar.

Proposi(cid:231)ªo 1.1.10 Seja n ∈ Z. Se a = b e c = d, entªo

(1) a + c = b + d

(2) ac = bd

Demonstra(cid:231)ªo: Segue imediato da Proposi(cid:231)ªo 1.1.3 e da Proposi(cid:231)ªo 1.1.8.

De(cid:28)ni(cid:231)ªo 1.1.5 Seja n um nœmero inteiro, n > 1. De(cid:28)nimos a soma e o produto

de duas classes de equivalŒncia por

(1) a + b = a + b

(2) a · b = ab

Observe que a Proposi(cid:231)ªo 1.1.10 nos garante que estas opera(cid:231)ıes estªo de(cid:28)nidas.

De(cid:28)ni(cid:231)ªo 1.1.6 Dado a ∈ Zn. Dizemos que b Ø o inverso multiplicativo de a

quando a · b = 1.

Essa de(cid:28)ni(cid:231)ªo Ø muito importante, pois, como veremos adiante o conjunto de
todos os elementos que possuem inverso em Zn Ø fechado com rela(cid:231)ªo a multiplica(cid:231)ªo.

7

AritmØtica dos Restos

Cap(cid:237)tulo 1

Proposi(cid:231)ªo 1.1.11 A classe a tem inverso multiplicativo em Zn se, e somente se,

a e n sªo coprimos.

Demonstra(cid:231)ªo:

Se a tem inverso multiplicativo em Zn, entªo existe b ∈ Zn tal

que a · b = 1, isto Ø, ab = 1. Portanto, temos que ab ≡ 1 mod n. Da(cid:237), temos que
n|(ab − 1), isto Ø, existe q ∈ Z tal que ab − 1 = qn. Assim, obtemos que existem
b, q ∈ Z tais que ba − qn = 1. Logo, temos que a e n sªo coprimos. Reciprocamente,
se a e n sªo coprimos, entªo existem x, y ∈ Z tais que xa + yn = 1. Assim, temos

que n|(xa − 1), isto Ø, xa ≡ 1 mod n. Portanto, temos que xa = x · a = 1, ou seja,
existe um x ∈ Zn que Ø o inverso multiplicativo de a.

De(cid:28)ni(cid:231)ªo 1.1.7 Os elementos invert(cid:237)veis de Zn formam um conjunto que chama-
mos de conjunto reduzido de res(cid:237)duos m(cid:243)dulo n. E serÆ denotado por Z∗
n.

Proposi(cid:231)ªo 1.1.12 Se a, b ∈ Z∗

n, entªo ab ∈ Z∗
n.

Demonstra(cid:231)ªo: Como a, b ∈ Z∗

n temos que ∃x, y ∈ Z∗

n tais que a · x = 1 e b · y = 1.

Portanto, teremos que ab · xy = abxy = axby = a · x · b · y = 1 · 1 = 1. Portanto
temos que ab ∈ Z∗
n.

Na Proposi(cid:231)ªo anterior provamos que o conjunto Z∗

n Ø fechado com rela(cid:231)ªo ao

produto.

Proposi(cid:231)ªo 1.1.13 Seja b ∈ Z∗
ab ∈ Z∗
n.

n. Entªo, ∀a ∈ Z tal que mdc(a, n) = 1 tem-se que

Demonstra(cid:231)ªo: Como b ∈ Z∗
n temos pela Proposi(cid:231)ªo 1.1.11, que mdc(b, n) = 1,
da(cid:237), temos que existem x1, y1 ∈ Z tais que bx1 + ny1 = 1. Mas, mdc(a, n) = 1, da(cid:237),
existem x2, y2 ∈ Z tais que ax2 + ny2 = 1. Assim, multiplicando membro a membro

as duas œltimas igualdades obtemos x1x2(ab) + (x2y1a + x1y2b + y1y2n)n = 1, o que

8

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

implica mdc(ab, n) = 1. Portanto, novamente pela Proposi(cid:231)ªo 1.1.11, temos que
ab ∈ Z∗

n como quer(cid:237)amos demonstrar.

Nesta se(cid:231)ªo descrevemos os principais resultados sobre as congruŒncias e (cid:28)zemos

uma rela(cid:231)ªo entre as congruŒncias e as classes de equivalŒncia. Estes resultados

serªo fundamentais para provarmos os resultados apresentados nas duas pr(cid:243)ximas

se(cid:231)ıes.

1.2 Os Teoremas de Euler e Wilson

Nesta se(cid:231)ªo introduzimos o conceito de equa(cid:231)ªo modular e a fun(cid:231)ªo (cid:28) de Euler.

AlØm disso, demonstramos o teorema de Euler, o teorema de Wilson e o pequeno

teorema de Fermat que serÆ usado para justi(cid:28)car o funcionamento do sistema RSA.

TambØm estudamos um pouco sobre raiz primitiva e sobre a ordem de um elemento
do conjunto Zn.

Proposi(cid:231)ªo 1.2.1 Sejam a, n ∈ Z, com n > 1, entªo a congruŒncia aX ≡ 1

mod n possui uma solu(cid:231)ªo x0 se, e somente se, a e n sªo coprimos. AlØm disso, x

Ø outra solu(cid:231)ªo da congruŒncia se, e somente se, x ≡ x0 mod n.

Demonstra(cid:231)ªo:
Isto Ø,
ax0 ≡ 1 mod n. Assim, n|(ax0 − 1), isto Ø, ∃y ∈ Z tal que ax0 − 1 = yn. Assim,

Suponha que x0 seja solu(cid:231)ªo da congruŒncia acima.

teremos que x0a−yn = 1. Portanto, temos que a e n sªo coprimos. Reciprocamente,
se a e n sªo coprimos, entªo existem x0, y ∈ Z tais que x0a+yn = 1, assim, podemos
escrever ax0 − 1 = (−y)n, onde (−y) ∈ Z. Da(cid:237), temos que ax0 ≡ 1 mod n. Logo,

x0 Ø solu(cid:231)ªo da congruŒncia aX ≡ 1 mod n.

AlØm disso, se x Ø outra solu(cid:231)ªo da congruŒncia aX ≡ 1 mod n, entªo ax ≡ 1

mod n. Por outro lado, x0, tambØm Ø solu(cid:231)ªo, isto Ø, ax0 ≡ 1 mod n. Sendo assim,

9

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

temos que ax ≡ ax0 mod n. Como mdc(a, n) = 1 temos pela Proposi(cid:231)ªo 1.1.5, que

podemos cancelar o a e obter x ≡ x0 mod n, como quer(cid:237)amos demonstrar.

De(cid:28)ni(cid:231)ªo 1.2.1 Seja n um nœmero natural com n > 1. Chamamos de fun(cid:231)ªo (cid:28) de

Euler, denotada por φ(n), a fun(cid:231)ªo de(cid:28)nida pelo nœmero de elementos invert(cid:237)veis
em Zn.

Observe que φ(n) ≤ n − 1. AlØm disso, temos que φ(n) = n − 1 se, e somente

se, n Ø um nœmero primo.

Mais adiante mostraremos como calcular φ(n) em geral. Iremos agora veri(cid:28)car

algumas propriedade da fun(cid:231)ªo (cid:28) de Euler.

Teorema 1.2.1 Sejam m, n ∈ N, com mdc(m, n) = 1. Entªo

φ(mn) = φ(m)φ(n).

Demonstra(cid:231)ªo: Vamos dispor os nœmeros de 1 atØ mn da seguinte forma:

1 m + 1 2m + 1 · · ·

(n − 1)m + 1

2 m + 2 2m + 2 · · ·

(n − 1)m + 2

3 m + 3 2m + 3 · · ·
...
...
. . .
m 2m

...
3m · · ·

(n − 1)m + 3
...
nm

Se na linha r, onde estªo os termos r, m + r, 2m + r, ..., (n − 1)m + r, tivermos

mdc(m, r) = d > 1, entªo nenhum termo dessa linha serÆ primo com mn, uma vez

que estes termos, sendo da forma km + r, com 0 ≤ k ≤ n − 1, sªo todos divis(cid:237)veis

por d. Logo, para encontrarmos os naturais desta tabela que sªo primos com mn,

devemos olhar na linha r somente se mdc(m, r) = 1. Portanto, temos φ(m) linhas

em que todos os elementos sªo primos com m.

10

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

Agora devemos procurar em cada uma dessas φ(m) linhas, quantos elementos

sªo primos com n, uma vez que todos sªo primos com m. Como mdc(m, n) = 1 os

elementos r, m + r, 2m + r, ..., (n − 1)m + r formam um sistema completo de res(cid:237)duos

m(cid:243)dulo n. Logo, cada uma destas linhas possui φ(n) elementos primos com n e,

portanto, como eles sªo primos com m, eles sªo primos com mn. Isto nos garante

que φ(mn) = φ(m)φ(n).

Lema 1.2.1 Se p Ø um nœmero primo e r ∈ N, entªo temos

φ(pr) = pr − pr−1 = pr(1 − 1

p ).

Demonstra(cid:231)ªo: De 1 atØ pr, temos pr nœmeros naturais. Temos que excluir desses

os nœmeros que nªo sªo primos com pr, ou seja, todos os mœltiplos de p, que sªo

p, 2p, ..., pr−1p, cujo nœmero Ø pr−1. Portanto, φ(pr) = pr − pr−1.

Teorema 1.2.2 Para n = pα1

1 pα2

2 pα3

3 · · · pαr

r , com pi primo e αi∈ N, i = 1, . . . , r,

temos

φ(n) = n(1 − 1
p1

)(1 − 1
p2

) · · · (1 − 1
pr

).

Demonstra(cid:231)ªo: O Teorema 1.2.1 nos garante que φ(n) = φ(pα1
φ(pα1

2 ) · · · φ(pαr
resultado assim: φ(n) = pα1

r ). Por outro lado, o Lema 1.2.1, permite escrever este œltimo
) · · · pαr

1 )φ(pα2

3 · · · pαr

) = pα1

2 pα3

1 pα2

r ) =

)pα2

1 pα2

1 (1 − 1
p1

r (1 − 1
2 (1 − 1
pr
p2
). Portanto, teremos que φ(n) = n(1 − 1
p1

r (1 −

2 · · · pαr
) · · · (1 − 1
pr

)

)(1 − 1
p2

1
p1

)(1 − 1
p2

) · · · (1 − 1
pr

como quer(cid:237)amos demonstrar.

Teorema 1.2.3 (Euler) Sejam n, a ∈ Z, com mdc(a, n) = 1. Entªo,

aφ(n) ≡ 1 mod n.

11

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

Seja Z∗

n = {r1, r2, . . . , rφ(n)} o conjunto dos elementos inver-
Demonstra(cid:231)ªo:
t(cid:237)veis de Zn. AlØm disso, temos que aφ(n) · r1 · r2 · · · rφ(n) = ar1 · ar2 · · · arφ(n).
Como mdc(a, n) = 1 temos pela Proposi(cid:231)ªo 1.1.13, que ari ∈ Z∗

n, para cada

i ∈ {1, 2, . . . , φ(n)}. Por outro lado, se i (cid:54)= j, tem-se que ri (cid:54)= rj, o que implica

ari (cid:54)= arj, pois, mdc(a, n) = 1. Assim, teremos que ar1·ar2 · · · arφ(n) = r1·r2 · · · rφ(n).

Portanto, aφ(n) · r1 · r2 · · · rφ(n) = r1 · r2 · · · rφ(n). Logo, multiplicando cada membro da
is, obtemos aφ(n) = 1, isto Ø, aφ(n) ≡ 1

œltima igualdade pelo respectivo inverso dos r(cid:48)

mod n como quer(cid:237)amos demonstrar.

CorolÆrio 1.2.1 (Pequeno Teorema de Fermat) Sejam a, p ∈ Z, com p primo

e mdc(a, p) = 1. Entªo

ap−1 ≡ 1 mod p.

Demonstra(cid:231)ªo: Como φ(p) = p − 1 e mdc(a, p) = 1, o resultado segue direto do

Teorema 1.2.3.

Proposi(cid:231)ªo 1.2.2 Sejam a, n ∈ Z, com a > 1 e n > 1. Entªo

∃r ∈ Z, r > 0, tal que ar ≡ 1 mod n ⇔ mdc(a, n) = 1

Se mdc(a, n) = 1, entªo o Teorema de Euler nos garante que
Demonstra(cid:231)ªo:
existe φ(n) = r ∈ Z tal que ar ≡ 1 mod n. Reciprocamente, suponha que

mdc(a, n) > 1. Entªo a equa(cid:231)ªo aX − nY = 1 nªo possui solu(cid:231)ªo e, da(cid:237), a equa(cid:231)ªo

modular aX ≡ 1 mod n nªo possui solu(cid:231)ªo. Consequentemente, nªo pode existir
r ∈ Z, r > 0 tal que ar ≡ 1 mod n. Logo, conclu(cid:237)mos que mdc(a, n) = 1.

O pr(cid:243)ximo lema servirÆ para provarmos o teorema de Wilson.

Lema 1.2.2 Seja a ∈ Z, com a > 4 um nœmero composto, entªo a|(a − 1)!.

12

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

Seja a ∈ Z um nœmero composto e a > 4. Entªo existem
Demonstra(cid:231)ªo:
a1, a2 ∈ Z tais que a = a1a2, com 1 < a1 ≤ a2 < a. Sendo assim, teremos que

(a − 1)! = 1 · · · a1 · · · a2 · · · (a − 1). Portanto, temos que a|(a − 1)! como quer(cid:237)amos

demonstrar.

Teorema 1.2.4 (Wilson) Seja p ∈ Z, p > 1. Entªo

p Ø um nœmero primo ⇔ (p − 1)! ≡ p − 1 mod p.

Se p Ø um nœmero primo entªo 1, 2, . . . , p − 1 sªo os elementos
Demonstra(cid:231)ªo:
invert(cid:237)veis de Zp. AlØm disso, se x ∈ Zp Ø tal que x2 = 1, entªo x2 ≡ 1 mod p, isto
Ø, p|(x2 − 1) = (x − 1)(x + 1). Da(cid:237), temos p|(x − 1) ou p|(x + 1). Mas, 0 ≤ x < p

e p Ø primo. Assim, teremos que x = 1 ou x = p − 1. Logo, todos os elementos
de Z∗

p, com excessªo de 1 e p − 1, possuem inverso diferente dele pr(cid:243)prio. Portanto,

temos que: 2 · · · (p − 2) = 1. Assim, obtemos 2 · · · (p − 2) ≡ 1 mod p. Logo, temos

que (p − 1)! = 1 · 2 · · · (p − 2)(p − 1) ≡ p − 1 mod p. Reciprocamente, suponha

que (p − 1)! ≡ p − 1 mod p e que p > 4 nªo Ø primo. Entªo pelo Lema 1.2.2
podemos garantir que p|(p − 1)!. Como p > 4 p (cid:45) (p − 1). Sendo assim, temos
que p (cid:45) [(p − 1)! − (p − 1)]. Logo, (p − 1)! (cid:54)≡ p − 1 mod p o que contradiz nossa

hip(cid:243)tese. Agora observe que 3! = 6 (cid:54)≡ 3 mod 4, 2! = 2 ≡ 2 mod 3 e 1! ≡ 1 mod 2.

Portanto, se (p − 1)! ≡ p − 1 mod p entªo p Ø um nœmero primo.

Observe que o Teorema de Wilson caracteriza todos os nœmeros primos, isto Ø,

todo nœmero que obedece o teorema Ø um nœmero primo e, reciprocamente, todo

nœmero primo obedece esse teorema.

Os resultados apresentados atØ o (cid:28)nal dessa se(cid:231)ªo serªo utilizados para provarmos

alguns testes de primalidade apresentados no cap(cid:237)tulo 2. A seguir descreveremos
alguns resultados sobre a ordem de um elemento de Zn e sobre a raiz primitiva

m(cid:243)dulo n.

13

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

Pelo Teorema de Euler temos que se a, n ∈ Z, com mdc(a, n) = 1 e n > 1, entªo

aφ(n) ≡ 1 mod n. Portanto, existe um menor expoente k tal que ak ≡ 1 mod n.

Este menor valor de k poderÆ ser menor do que φ(n). Por exemplo, mdc(3, 8) = 1,

assim, pelo Teorema de Euler, temos que 3φ(8) ≡ 1 mod 8, mas, 32 ≡ 1 mod 8 e

2 < 4 = φ(8).

De(cid:28)ni(cid:231)ªo 1.2.2 O menor inteiro positivo k para o qual ak ≡ 1 mod n, onde

mdc(a, n) = 1, Ø chamado de ordem de a m(cid:243)dulo n e denotado por ordna.

Proposi(cid:231)ªo 1.2.3 Seja k = ordna. Entªo

ah ≡ 1 mod n ⇔ k|h.

Demonstra(cid:231)ªo: Dados h, k ∈ Z, com k (cid:54)= 0, entªo pelo algoritmo da divisªo
temos que existem q, r ∈ Z tais que h = qk + r, com 0 ≤ r < k. Sendo assim,

temos que ah = aqk+r = (ak)qar. Por outro lado, k = ordna, isto Ø, ak ≡ 1 mod n.

Portanto, conclu(cid:237)mos que ah = aqk+r = (ak)qar ≡ 1qar ≡ ar mod n. AlØm disso,

ah ≡ 1 mod n, por hip(cid:243)tese. Logo, temos ar ≡ 1 mod n. Mas, como 0 ≤ r < k e

k por de(cid:28)ni(cid:231)ªo Ø o menor inteiro positivo tal que ak ≡ 1 mod n, temos que r = 0.
Portanto, h = qk, isto Ø, k|h. Reciprocamente, se k | h, entªo existe q ∈ Z tal que

h = qk, da(cid:237), ah = aqk = (ak)q ≡ 1q = 1 mod n.

CorolÆrio 1.2.2 ordna|φ(n).

Demonstra(cid:231)ªo: Pelo Teorema de Euler, temos que aφ(n) ≡ 1 mod n, se mdc(a, n) =

1. Da(cid:237), o Teorema que acabamos de demonstrar nos garante que ordna|φ(n).

Proposi(cid:231)ªo 1.2.4 Seja k = ordna. Entªo at ≡ ah mod n, se, e somente se, t ≡ h

mod k.

14

Os Teoremas de Euler e Wilson

Cap(cid:237)tulo 1

Demonstra(cid:231)ªo:

Primeiro vamos supor que at ≡ ah mod n e t ≥ h. Assim

podemos escrever: at = ahat−h e como ah ≡ at mod n, temos que ah ≡ ahat−h

mod n. Por outro lado, temos mdc(a, n) = 1 o que implica mdc(ah, n) = 1. Por-

tanto, podemos cancelar ah, nesta œltima congruŒncia, obtendo 1 ≡ at−h mod n.

Da(cid:237), pela Proposi(cid:231)ªo 1.2.3, temos que k|(t − h), isto Ø, t ≡ h mod k. Reciproca-
mente, se t ≡ h mod k, entªo, k|(t − h) o que implica que existe m ∈ Z tal que

t = h + mk. Portanto, temos que at

.
= ah+mk. Por outro lado, como k = ordna

temos que ak ≡ 1 mod n. Assim, obtemos at = ah+mk = ah(ak)m ≡ ah1m = ah

mod n como quer(cid:237)amos provar.

CorolÆrio 1.2.3 Se k = ordna, entªo os nœmeros 1, a, a2, . . . , ak−1 sªo incongru-

entes m(cid:243)dulo n.

Demonstra(cid:231)ªo: Suponha que dois destes nœmeros sejam congruentes m(cid:243)dulo n,

isto Ø, at ≡ ah mod n, onde t, h ∈ {0, 1, 2, . . . , k − 1}. Pela Proposi(cid:231)ªo 1.2.4, temos

que t ≡ h mod k. Portanto, temos que k|(t − h), mas, como t, h ∈ {0, 1, 2, . . . , k −

1}, teremos que t − h = 0, isto Ø, t = h. Assim, conclu(cid:237)mos que os nœmeros

1, a, a2, . . . , ak−1 sªo todos incongruentes m(cid:243)dulo n.

De(cid:28)ni(cid:231)ªo 1.2.3 Quando ordna = φ(n) dizemos que a Ø uma raiz primitiva m(cid:243)dulo

n.

Proposi(cid:231)ªo 1.2.5 Se a Ø uma raiz primitiva, entªo os nœmeros a, a2, . . . , aφ(n) for-

mam um sistema reduzido de res(cid:237)duos m(cid:243)dulo n.

Demonstra(cid:231)ªo:

Como a Ø uma raiz primitiva m(cid:243)dulo n temos que ordna =

φ(n). Pelo CorolÆrio 1.2.3, sabemos que 1, a, a2, . . . , aφ(n)−1 sªo todos incongruentes

m(cid:243)dulo n. Por outro lado, como mdc(a, n) = 1 temos, pela Proposi(cid:231)ªo 1.1.11, que
os nœmeros 1, a, a2, . . . , aφ(n)−1 sªo todos invert(cid:237)veis em Zn. Da(cid:237) formam um sistema

15

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

reduzido de res(cid:237)duos m(cid:243)dulo n. Assim, pela Proposi(cid:231)ªo 1.1.12 conclu(cid:237)mos que os

nœmeros a, a2, . . . , aφ(n) formam um sistema reduzido de res(cid:237)duos m(cid:243)dulo n.

1.3 Res(cid:237)duos QuadrÆticos

Nesta se(cid:231)ªo estudaremos os res(cid:237)duos quadrÆticos, apresentamos o s(cid:237)mbolo de Le-

gendre, demonstramos o CritØrio de Euler e a Lei de Reciprocidade QuadrÆtica, pois,

estes resultados serªo utilizados nas demonstra(cid:231)ıes de alguns testes de primalidade

estudados no cap(cid:237)tulo 2.

De(cid:28)ni(cid:231)ªo 1.3.1 Sejam a, n ∈ N, com n > 1 e mdc(a, n) = 1. Dizemos que a

Ø um res(cid:237)duo quadrÆtico m(cid:243)dulo n se a congruŒncia x2 ≡ a mod n tiver solu(cid:231)ªo.

Caso contrÆrio, dizemos que a nªo Ø um res(cid:237)duo quadrÆtico m(cid:243)dulo n ou que a Ø um

res(cid:237)duo nªo-quadrÆtico.

Teorema 1.3.1 Sejam a, p ∈ N, com p > 3 primo e 1 ≤ a ≤ p − 1. Caso a con-

gruŒncia x2 ≡ a mod p tenha solu(cid:231)ªo, tem exatamente duas solu(cid:231)ıes incongruentes

m(cid:243)dulo p.

Demonstra(cid:231)ªo: Se x1 Ø solu(cid:231)ªo da congruŒncia, entªo −x1 tambØm serÆ solu(cid:231)ªo

pois, (−x1)2 = x2
e, como p Ø (cid:237)mpar e p (cid:45) x1 (pois p | (x2

1. AlØm disso, se x1 ≡ −x1 mod p entªo ter(cid:237)amos 2x1 ≡ 0 mod p
1 − a) e p (cid:45) a), isto Ø imposs(cid:237)vel. Precisamos
mostrar que s(cid:243) existem essas duas solu(cid:231)ıes incongruentes. Seja y uma solu(cid:231)ªo de

e, portanto, x2

x2 ≡ a mod p, isto Ø, y2 ≡ a mod p. Como x1 Ø solu(cid:231)ªo temos x2

1 ≡ y2 ≡ a mod p
1 − y2 = (x1 + y)(x1 − y) ≡ 0 mod p. Logo, p|(x1 + y) ou p|(x1 − y),
o que implica y ≡ −x1 mod p ou y ≡ x1 mod p. Com isto mostramos que, caso

exista uma solu(cid:231)ªo, existem exatamente duas solu(cid:231)ıes incongruentes.

16

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

Teorema 1.3.2 (Lagrange) Seja f (x) = cnxn +cn−1xn−1 +· · ·+c2x2 +c1x+c0 um

polin(cid:244)mio com coe(cid:28)cientes naturais tal que mdc(cn, p) = 1, em que p Ø primo. Nestas

condi(cid:231)ıes a congruŒncia f (x) ≡ 0 mod p, tem no mÆximo n solu(cid:231)ıes incongruentes.

(cid:201) claro que quando n > p a congruŒncia acima nªo tem mais do que p solu(cid:231)ıes

distintas m(cid:243)dulo p.

Demonstra(cid:231)ªo: A demonstra(cid:231)ªo serÆ feita por indu(cid:231)ªo em n. Para n = 1 temos

a congruŒncia linear

f (x) = c1x + c0 ≡ 0 mod p.

Como mdc(c1, p) = 1 temos que c1 Ø invert(cid:237)vel em Zp, isto Ø, existe x0 ∈ Zp tal

que c1x0 = 1. Da(cid:237), temos que x = x0(p − c0) Ø solu(cid:231)ªo de f (x) = c1x + c0 ≡ 0

mod p, de fato, obtemos f (x0(p − c0)) = c1(x0(p − c0)) + c0 ≡ c1x0p − c1x0c0 + c0 ≡

p − c0 + c0 = p ≡ 0 mod p.

Se y0 tambØm for solu(cid:231)ªo de f (x) = c1x + c0 ≡ 0 mod p, entªo teremos que

c1y0 + c0 ≡ c1(x0(p − c0)) + c0 mod p o que implica c1x0(p − c0) ≡ c1y0 mod p.

Logo, obtemos x0(p − c0) ≡ y0 mod p, isto Ø, as duas solu(cid:231)ıes sªo a mesma m(cid:243)dulo

p.

Portanto, para n = 1 temos exatamente uma solu(cid:231)ªo nªo congruente m(cid:243)dulo n.

Logo, o resultado Ø vÆlido para n = 1.

Suponhamos o resultado verdadeiro para todo polin(cid:244)mio de grau menor que n.

Devemos mostrar que o resultado seja verdadeiro para todo polin(cid:244)mio de grau n.

Suponha, por absurdo, que o nœmero de solu(cid:231)ıes incongruentes m(cid:243)dulo p seja n + 1.

Considere x0, x1, . . . , xn estas n + 1 solu(cid:231)ıes. (cid:201) fÆcil ver que

f (x) − f (x0) = cn(xn − xn

0 ) + cn−1(xn−1 − xn−1

0

) + · · · + c1(x − x0) = (x − x0)h(x),

uma vez que (xi − xi

0) Ø divis(cid:237)vel por x − x0, para todo i = 1, 2, . . . , n, e que h(x) Ø
um polin(cid:244)mio de grau n − 1 tendo cn como coe(cid:28)ciente de xn−1. Para k = 1, 2, . . . , n

17

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

temos que f (xk) ≡ f (x0) mod p (pois, xk e x0 sªo solu(cid:231)ıes), da(cid:237), teremos que

(xk − x0)h(xk) = f (xk) − f (x0) ≡ 0 mod p. AlØm disso, temos que xk (cid:54)≡ x0 mod p.

Portanto, temos que h(xk) ≡ 0 mod p, isto Ø, h(x) tem n solu(cid:231)ıes incongruentes

m(cid:243)dulo p, contradizendo a hip(cid:243)tese de indu(cid:231)ªo. Logo, f (x) possui no mÆximo n

solu(cid:231)ıes incongruentes m(cid:243)dulo p como quer(cid:237)amos demonstrar.

Teorema 1.3.3 Seja p um primo (cid:237)mpar. Entªo o conjunto {1, 2, . . . , p − 1} possui

p−1
2

res(cid:237)duos quadrÆticos e p−1
2

res(cid:237)duos nªo-quadrÆticos.

Demonstra(cid:231)ªo: Observe que, pelo Teorema 1.3.1, para cada a ∈ {1, 2, . . . , p − 1}

se x1 Ø solu(cid:231)ªo da congruŒncia x2 ≡ a mod p, entªo existe exatamente uma outra

solu(cid:231)ªo x2 que Ø incongruente (cid:224) x1. Sendo assim, formaremos pares de nœmeros

incongruentes que correspondem a um res(cid:237)duo quadrÆtico diferente. AlØm disso,

cada nœmero x de 1 atØ p − 1 Ø incongruente com todos os outros nœmeros desse
intervalo e p (cid:45) x2 (pois, p Ø primo e p (cid:45) x), entªo 1 ≤ x2 ≤ p − 1. Portanto, para cada

dois nœmeros distintos do conjunto {1, 2, · · · , p − 1} teremos um res(cid:237)duo quadrÆtico
distinto. Logo, teremos exatamente p−1
2

res(cid:237)duos quadrÆticos e p−1
2

res(cid:237)duos nªo-

quadrÆticos.

Proposi(cid:231)ªo 1.3.1 Seja p um nœmero primo. Entªo

x2 ≡ −1 mod p possui solu(cid:231)ªo ⇔ p = 2 ou p ≡ 1 mod 4.

Demonstra(cid:231)ªo: Se p = 2 entªo 1 Ø solu(cid:231)ªo da congruŒncia. Vamos construir uma

solu(cid:231)ªo para o caso p ≡ 1 mod 4.

Para p um primo (cid:237)mpar podemos escrever o Teorema de Wilson da seguinte

forma:

(1 · 2 · · · j · · · ( p−1

2 )( p+1

2 ) · · · (p − j) · · · (p − 2) · (p − 1)) ≡ −1 mod p

18

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

Observe que o produto (p−1)! estÆ dividido em duas partes, cada uma com o mesmo

nœmero de fatores. Assim, podemos reescrever este produto formando pares, uma

vez que para cada fator j na primeira parte temos o fator (p − j) na segunda. Logo,

o Teorema de Wilson pode ser escrito como segue

p−1

2(cid:89)

j=1

j(p − j) ≡ −1 mod p.

Como j(p − j) ≡ −j2 mod p temos que

p−1

2(cid:89)

j=1

(−j2) = (−1)

p−1
2

(cid:18)

p−1

2(cid:89)

j=1

(cid:19)2

j

≡ −1 mod p.

Observe que se p ≡ 1 mod 4, entªo p−1
2

Ø par e, portanto,

x =

p−1

2(cid:89)

j=1

j =

(cid:18)p − 1
2

(cid:19)
!

Ø uma solu(cid:231)ªo de x2 ≡ −1 mod p.

Reciprocamente, suponha que a congruŒncia x2 ≡ −1 mod p tenha solu(cid:231)ªo e

que p > 2. Elevando ambos os membros (cid:224) potŒncia p−1

2 obtemos:

(x2)

p−1
2 ≡ (−1)

p−1

2 mod p.

Mas, pelo Pequeno Teorema de Fermat, (x2)

p−1

2 = x(p−1) ≡ 1 mod p. Assim, temos

que (−1)

p−1

2 ≡ 1 mod p, da(cid:237), conclu(cid:237)mos que p−1
2

Ø par. Portanto, p ≡ 1 mod 4

como quer(cid:237)amos demonstrar.

De(cid:28)ni(cid:231)ªo 1.3.2 Para p um primo (cid:237)mpar e a um nœmero natural relativamente

primo com p, de(cid:28)nimos o S(cid:237)mbolo de Legendre por

(cid:0) a
p

(cid:1) =




1,

se a Ø um res(cid:237)duo quadrÆtico m(cid:243)dulo p



−1,

se a nªo Ø um res(cid:237)duo quadrÆtico m(cid:243)dulo p

19

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

Teorema 1.3.4 (CritØrio de Euler) Se p for um primo (cid:237)mpar e a um natural

relativamente primo com p, entªo

(cid:0) a
p

(cid:1) ≡ a

p−1

2 mod p.

Demonstra(cid:231)ªo: Pelo Pequeno Teorema de Fermat temos que ap−1 ≡ 1 mod p,

assim, teremos (a

p−1
2 − 1)(a

p−1

2 + 1) ≡ 0 mod p. Como p Ø primo temos que p |

p−1

2 − 1 ou p | a

a

p−1

2 + 1. Portanto, temos que a

p−1

2 ≡ ±1 mod p.

Assim, devemos mostrar que a

p−1

2 ≡ 1 mod p se, e somente se, a Ø um res(cid:237)duo

quadrÆtico m(cid:243)dulo p.

Se a Ø um res(cid:237)duo quadrÆtico, digamos a ≡ b2 mod p, com 1 ≤ b ≤ p − 1,

novamente pelo Pequeno Teorema de Fermat temos que a

p−1

2 ≡ bp−1 ≡ 1 mod p.

Por outro lado, o Teorema 1.3.3 nos garante que de 1 atØ p − 1 temos exatamente

p−1
2

res(cid:237)duos quadrÆticos m(cid:243)dulo p que sªo solu(cid:231)ıes incongruentes da congruŒncia

f (x) = x

p−1

2 − 1 ≡ 0 mod p, mas, pelo Teorema 1.3.2, essa congruŒncia possui no

mÆximo p−1
2

solu(cid:231)ıes incongruentes m(cid:243)dulo p. Portanto, as solu(cid:231)ıes incongruentes

m(cid:243)dulo p de f (x) sªo exatamente todos os res(cid:237)duos quadrÆticos m(cid:243)dulo p. Logo,

p−1

2 ≡ 1 mod p se, e somente se, a Ø um res(cid:237)duo quadrÆtico m(cid:243)dulo p.

a

Iremos agora demonstrar algumas propriedades do s(cid:237)mbolo de Legendre que serªo

utilizadas mais adiante.

CorolÆrio 1.3.1 O s(cid:237)mbolo de Legendre possui as seguintes propriedades:

1. Se a ≡ b mod p, entªo (cid:0) a

p

(cid:1) = (cid:0) b

p

(cid:1).

2. Se p (cid:45) a, entªo (cid:0) a2

p

(cid:1) = 1.

3. (cid:0) −1

p

(cid:1) = (−1)

p−1
2 .

4. Se p (cid:45) a e p (cid:45) b, entªo (cid:0) ab

p

(cid:1) = (cid:0) a

p

(cid:1)

(cid:1)(cid:0) b
p

20

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

Demonstra(cid:231)ªo: Observe que o item 1 Ø imediato da de(cid:28)ni(cid:231)ªo de congruŒncia e

o item 2 segue da de(cid:28)ni(cid:231)ªo do S(cid:237)mbolo de Legendre e do fato que a Ø solu(cid:231)ªo da

congruŒncia x2 ≡ a2 mod p, isto Ø, a2 Ø res(cid:237)duo quadrÆtico m(cid:243)dulo p. O item 3

segue do CritØrio de Euler:

(cid:0) −1
p

(cid:1) ≡ (−1)

p−1

2 mod p ⇒ (cid:0) −1

p

(cid:1) = (−1)(p−1),

pois, p > 2 e ambos os lados da congruŒncia sªo iguais a ±1. Da mesma forma,

aplicando o CritØrio de Euler temos que

(cid:0) ab
p

(cid:1) ≡ (ab)

p−1
2 = a

p−1
2 b

p−1

2 ≡ (cid:0) a

p

(cid:1)(cid:0) b
p

(cid:1) mod p,

o que mostra que (cid:0) ab

p

(cid:1) = (cid:0) a

p

(cid:1)(cid:0) b
p

(cid:1), pois novamente ambos os lados da congruŒncia

sªo iguais a ±1.

Lema 1.3.1 (Lema de Gauss) Sejam p > 2 um nœmero primo e a um nœmero

natural primo relativo com p. Seja s o nœmero de elementos do conjunto

{a, 2a, 3a, . . . , p−1

2 a}

tais que seu resto m(cid:243)dulo p Ø maior do que p−1

2 . Entªo

(cid:0) a
p

(cid:1) = (−1)s.

Demonstra(cid:231)ªo: Como o conjunto Z∗
si(cid:231)ªo 1.1.13, que para cada j = 1, 2, . . . , p−1
onde (cid:15)j ∈ {−1, 1} e mj ∈ {1, 2, . . . , (p−1)

2 } temos, pela Propo-
2 podemos escrever aj ≡ (cid:15)jmj mod p
2 }. Temos que se i (cid:54)= j entªo mi (cid:54)= mj donde

p = {±1, ±2, . . . , ± p−1

{m1, m2, . . . , m (p−1)

2

} = {1, 2, . . . ,

(p − 1)
2

}.

De fato, se mi = mj temos ai ≡ aj mod p ou ai ≡ −aj mod p. Mas, pela
Proposi(cid:231)ªo 1.1.11 temos que a ∈ Z∗
p e, alØm disso, temos que 0 < i, j ≤ p−1
2 .
Portanto, temos que a primeira possibilidade implica i = j e a segunda Ø imposs(cid:237)vel.
Agora, multiplicando as congruŒncias aj ≡ (cid:15)jmj mod p, para j = 1, 2, . . . , p−1
2 ,

obtemos

21

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

a1a2 · · · a p−1

2 ≡ (cid:15)1(cid:15)2 · · · (cid:15) (p−1)

m1m2 · · · m (p−1)

2

mod p

2

Portanto, temos que a
2 ∈ Z∗
Mas, 1, 2, . . . , p−1
CritØrio de Euler teremos que (cid:0) a

(p−1)

2 1 · 2 · · · · · ( p−1

2 ) ≡ (cid:15)1(cid:15)2 · · · (cid:15) (p−1)

2

(p−1)

p, entªo temos que a

2 ≡ (cid:15)1(cid:15)2 · · · (cid:15) (p−1)

1 · 2 · · · · · ( p−1

2 ) mod p.
mod p. Da(cid:237), pelo

2

2

p

mod p. Mas, ambos os lados

(cid:1) ≡ (cid:15)1(cid:15)2 · · · (cid:15) (p−1)
dessa congruŒncia pertencem a {−1, 1}. AlØm disso, p Ø um nœmero primo (cid:237)mpar,
entªo ambos os lados da congruŒncia sªo iguais, isto Ø, (cid:0) a
temos que (cid:0) a

(cid:1)= (cid:15)1(cid:15)2 · · · (cid:15) (p−1)
(cid:1)= (−1)s, em que s Ø o nœmero de elementos j ∈ {1, 2, . . . , p−1

2 } tais que
(cid:15)j = −1 (observe que (cid:15)j = −1 signi(cid:28)ca que aj ≡ (cid:15)jmj ≡ −mj ≡ (p − mj) mod p,
onde mj ∈ {1, 2, . . . , p−1

2 }, isto Ø, aj deixa resto maior que p−1

2 ), como quer(cid:237)amos

. Logo,

p

p

2

demonstrar.

O pr(cid:243)ximo resultado Ø chamado Lei de Reciprocidade QuadrÆtica. Para p e q

primos (cid:237)mpares, a Lei de Reciprocidade QuadrÆtica nos diz que as congruŒncias

x2 ≡ p mod q e x2 ≡ q mod p sªo ambas solœveis ou ambas insolœveis a menos que

p e q sejam congruentes a 3 m(cid:243)dulo 4, caso em que uma terÆ solu(cid:231)ªo e a outra nªo.

Teorema 1.3.5 (Lei de Reciprocidade QuadrÆtica) .

1. Se p e q sªo primos (cid:237)mpares distintos, entªo

(cid:0) p
q

(cid:1)(cid:0) q
p

(cid:1) = (−1)

p−1
2

q−1
2 .

2. Se p Ø um nœmero primo (cid:237)mpar, entªo

(cid:1) = (−1)

(p2−1)

8 =

(cid:0) 2
p




1,

se p ≡ ±1 mod 8



−1,

se p ≡ ±3 mod 8

Demonstra(cid:231)ªo: Para provarmos o item 1 do teorema vamos mostrar que

(∗)

( p−1

2 )( q−1

2 ) =

(cid:23)

(cid:22) ip
q

+

(cid:88)

1≤i≤ q−1
2

(cid:88)

1≤i≤ p−1
2

(cid:23)

(cid:22) iq
p

22

Res(cid:237)duos QuadrÆticos

e que

Cap(cid:237)tulo 1

(∗∗)

(cid:0) p
q

(cid:1) = (−1)rq e (cid:0) q

p

(cid:1) = (−1)rp, com rq =

(cid:23)

(cid:22) ip
q

(cid:88)

1≤i≤ q−1
2

e rp =

(cid:88)

1≤i≤ p−1
2

(cid:23)

(cid:22) iq
p

Assim, de (∗∗) obtemos (cid:0) p
q
(cid:22) ip
(cid:88)
q

rp =

(cid:88)

+

(cid:23)

(cid:1)(cid:0) q
p
(cid:22) iq
p

(cid:1) = (−1)rq (−1)rp = (−1)rq+rp e de (∗) temos que rq +
(cid:23)
(cid:1) =

). Portanto, temos que (cid:0) p

= (

)(

(cid:1)(cid:0) q
p

q

p − 1
2

q − 1
2

1≤i≤ q−1
2
2 )( q−1

(−1)( p−1

1≤i≤ p−1
2

2 ) o que demonstra o item 1 do teorema.

e ( p

2). Assim, teremos que ( p−1

Para provarmos a f(cid:243)rmula (∗) considere o ret(cid:226)ngulo de vØrtices (0, 0), ( p
2 , q

2 , 0), (0, q
2)
2 ) Ø o nœmero de pontos com ambas as co-
ordenadas inteiras no interior desse ret(cid:226)ngulo. Por outro lado, observe que a reta
y = i intercepta a reta x = p

q (cid:99) pontos com coorde-

2 )( q−1

q i, i) e possui (cid:98) ip
(cid:23)

nadas inteiras, assim, temos que

conta o nœmero de tais pontos que

q y no ponto ( p
(cid:22) ip
(cid:88)
q

1≤i≤ q−1
2

q y do ret(cid:226)ngulo, alØm disso, a reta x = i intercepta
p (cid:99) pontos com coordenadas inteiras, logo,

p i) e possui (cid:98) iq

estªo acima da diagonal x = p
a reta x = p
q y no ponto (i, q
(cid:23)

(cid:88)

(cid:22) iq
p

conta o nœmero de tais pontos abaixo desta diagonal (note que como p

1≤i≤ p−1
2
e q sªo primos, nªo hÆ pontos com ambas as coordenadas inteiras na diagonal).

Para mostrar (∗∗), basta veri(cid:28)car que rp =

(cid:88)

(cid:23)

(cid:22) iq
p

≡ s mod 2, em que s

1≤i≤ p−1
2

Ø como no Lema de Gauss aplicado para a = q. Pois, nesse caso teremos que s e
(cid:1) = (−1)s = (−1)rp. E de
rp sªo ambos pares ou ambos (cid:237)mpares o que implica (cid:0) q
forma anÆloga podemos provar que rq ≡ s mod 2, basta trocar q por p.

p

Seja ri o resto da divisªo de iq por p, de modo que iq = (cid:98) iq

p (cid:99)p + ri. Somando e

utilizando a nota(cid:231)ªo da demonstra(cid:231)ªo do Lema de Gauss, obtemos

(cid:88)

q

i = p

(cid:88)

1≤i≤ (p−1)

2

1≤i≤ (p−1)

2

(cid:23)

(cid:22) iq
p

+

(cid:88)

ri≤ p
2

mi +

(cid:88)

ri≥ p
2

(p − mi).

Como mi ≡ −mi mod 2, p e q sªo (cid:237)mpares temos, m(cid:243)dulo 2, que

23

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

(cid:88)

i ≡

(cid:88)

1≤i≤ p−1
2

1≤i≤ p−1
2

(cid:23)

(cid:22) iq
p

+

(cid:88)

ri≤ p
2

mi +

(cid:88)

ri≥ p
2

(1 + mi) mod 2

E como {m1, m2, . . . , m (p−1)

2

} = {1, 2, . . . , p−1

2 }, conclu(cid:237)mos, assim, que

(cid:88)

ri≤ p
2

mi +

(cid:88)

ri≥ p
2

(cid:88)

mi =

1≤i≤ (p−1)

2

i e

(cid:88)

ri≥ p
2

1 = s. Portanto, teremos que

(cid:88)

i ≡

(cid:88)

1≤i≤ (p−1)

2

1≤i≤ (p−1)

2

(cid:23)

(cid:22) iq
p

+

(cid:88)

1≤i≤ (p−1)

2

i +

(cid:88)

ri≥ p
2

1 mod 2.

Logo, obtemos

(cid:23)

(cid:22) iq
p

(cid:88)

1≤i≤ (p−1)

2

≡ s mod 2 o que encerra a demonstra(cid:231)ªo do item 1.

Para demonstrarmos o item 2, observe que pelo CritØrio de Euler temos que
(cid:1) ≡ 2

2 mod p. Assim, primeiro provamos que

(p−1)

(cid:0) 2
p

p−1
2 ≡ (−1)

2

p2−1

8 mod p.

(1.3)

Como p Ø um nœmero primo (cid:237)mpar, temos que deverÆ ser congruente a 1, 3, 5 ou 7

m(cid:243)dulo 8. Vamos analisar cada caso antes de demonstrarmos (1.3).

Quando p ≡ 1 mod 8 temos que existe k ∈ Z tal que p − 1 = 8k o que implica

p + 1 = 8k + 2. Portanto, temos que

p2−1
8 = (p+1)(p−1)

8

= (8k+2)(8k)
8

= 2k(4k + 1).

Quando p ≡ 7 mod 8 temos que existe k ∈ Z tal que p − 7 = 8k o que implica

p − 1 = 8k + 6 e p + 1 = 8k + 8. Portanto, temos que

p2−1
8 = (p+1)(p−1)

8

= (8k+8)(8k+6)
8

= 2(k + 1)(4k + 3).

Logo, se p ≡ ±1 mod 8 (observe que −3 ≡ 5 mod 8), temos que p2−1
8

Ø par. Da(cid:237),

temos (−1)

p2−1

8 = 1.

Quando p ≡ 3 mod 8 temos que existe k ∈ Z tal que p − 3 = 8k o que implica

p − 1 = 8k + 2 e p + 1 = 8k + 4. Portanto, temos que

24

Res(cid:237)duos QuadrÆticos

Cap(cid:237)tulo 1

p2−1
8 = (p+1)(p−1)

8

= (8k+4)(8k+2)
8

= (2k + 1)(4k + 1).

Quando p ≡ 5 mod 8 temos que existe k ∈ Z tal que p − 5 = 8k o que implica

p − 1 = 8k + 4 e p + 1 = 8k + 6. Portanto, temos que

p2−1
8 = (p+1)(p−1)

8

= (8k+6)(8k+4)
8

= (4k + 3)(2k + 1).

Logo, se p ≡ ±3 mod 8 (observe que −1 ≡ 7 mod 8), temos que p2−1
8

Ø (cid:237)mpar.

Da(cid:237), temos (−1)

p2−1

8 = −1.

Para provarmos (1.3), consideramos o fato de que para i (cid:237)mpar, temos p − i ≡
i(−1)i mod p e para i par, temos i ≡ i(−1)i mod p. Portanto, teremos as p−1
2

congruŒncias

p − 1 ≡ 1(−1)1 mod p

2 ≡ 2(−1)2 mod p

p − 3 ≡ 3(−1)3 mod p

4 ≡ 4(−1)4 mod p

...
2 (−1)

t ≡ p−1

p−1

2 mod p.

Caso p−1
2

seja par a œltima congruŒncia acima serÆ

t = p−1

2 ≡ p−1

2 (−1)

p−1

2 mod p.

E, caso p−1
2

seja (cid:237)mpar, a œltima congruŒncia serÆ

t = p − p−1

2 ≡ p−1

2 (−1)

p−1

2 mod p.

Observe que os nœmeros na coluna da esquerda das congruŒncias acima sªo 2, 4, 6, . . . , p−

1. Assim, multiplicando todas estas congruŒncias teremos

2 · 4 · 6 · · · (p − 1) ≡ (−1)1+2+3+···+ p−1

2 ( p−1

2 )! mod p.

25

Res(cid:237)duos QuadrÆticos

Observe que

2 · 4 · 6 · · · (p − 1) = 2

Portanto, teremos que

p−1

2 ( p−1

2 )!

Cap(cid:237)tulo 1

e

1 + 2 + 3 + · · · + p−1

2 =

p−1

2 ( p−1
2 +1)
2

= p2−1
8

.

2

p−1

2 ( p−1

2 )! ≡ (−1)

p2−1
8 ( p−1

2 )! mod p.

Como mdc(( p−1
termo ( p−1

2 )!, p) = 1 temos, pela Proposi(cid:231)ªo 1.1.5, que podemos cancelar o

2 )! em ambos os lados da congruŒncia acima obtendo

p−1
2 ≡ (−1)

2

p2−1

8 mod p.

O que conclui a demonstra(cid:231)ªo de (1.3).

Como ( 2

p ) ≡ 2

p−1
2 ≡ (−1)

p2−1
8 mod p temos que ( 2

p ) = (−1)

p2−1
8

, pois, p Ø um

nœmero primo (cid:237)mpar e ambos os membros da œltima congruŒncia assumem apenas

os valores 1 ou −1.

Logo, com os resultados apresentados conclu(cid:237)mos a demonstra(cid:231)ªo do item 2 da

Lei de Reciprocidade QuadrÆtica.

26

Cap(cid:237)tulo 2

Nœmeros Primos

Neste cap(cid:237)tulo veremos porque o interesse pelos nœmeros primos aumentou signi-

(cid:28)cativamente nas œltimas dØcadas devido ao seu uso na criptogra(cid:28)a RSA. Garantir

que um dado nœmero natural Ø um nœmero primo passou a ter uma import(cid:226)ncia nªo

puramente acadŒmica e passou a ter um valor econ(cid:244)mico signi(cid:28)cativo. Isto porque

a seguran(cid:231)a do sistema RSA reside na di(cid:28)culdade de fatorar n = pq quando p e q

sªo primos com mais de 100 algarismos.

2.1 Como Encontrar Nœmeros Primos

Para encontrarmos nœmeros primos em um dado intervalo escolhemos um nœmero

(cid:237)mpar qualquer desse intervalo e veri(cid:28)camos se este nœmero Ø primo. Se o nœmero nªo

for primo entªo escolhemos outro nœmero (cid:237)mpar qualquer desse intervalo, diferente

do anterior, e testamos novamente se esse nœmero Ø primo. Esse processo deve ser

repetido atØ encontrarmos um nœmero primo.

Portanto, precisamos veri(cid:28)car se o processo de busca pelo nosso nœmero primo

descrito acima Ø viÆvel. Para descobrir isso necessitamos responder a seguinte per-

gunta: quantos nœmeros devemos escolher atØ encontrarmos um nœmero primo?

27

Como Encontrar Nœmeros Primos

Cap(cid:237)tulo 2

Para nos ajudar a responder essa pergunta, iremos enunciar uma de(cid:28)ni(cid:231)ªo e um

teorema.

De(cid:28)ni(cid:231)ªo 2.1.1 Dado x > 0 um nœmero real. π(x) serÆ o nœmero de nœmeros

primos que sªo menores ou iguais a x.

Teorema 2.1.1 (Teorema dos Nœmeros Primos) Dado x > 0 um nœmero real.

Entªo

limx→∞

π(x)
x
log(x)

= 1.

Demonstra(cid:231)ªo: Uma demonstra(cid:231)ªo pode ser encontrada em [4].

A pr(cid:243)xima proposi(cid:231)ªo nos mostra como calcular o nœmero de nœmeros primos

positivos que sªo menores ou iguais a um dado nœmero natural. Infelizmente essa

f(cid:243)rmula nªo Ø muito e(cid:28)ciente para nœmeros grandes.

Proposi(cid:231)ªo 2.1.1 Dado m > 1 inteiro. Entªo

π(m) =

m
(cid:88)

j=2

(cid:98)

(j − 1)! + 1
j

− (cid:98)

(j − 1)!
j

(cid:99)(cid:99)

Ø o nœmero de nœmeros primos que sªo menores ou iguais a m.

Demonstra(cid:231)ªo: Se j Ø um nœmero primo, entªo pelo Teorema de Wilson, temos
(j − 1)! ≡ j − 1 ≡ −1 mod j. Isto Ø, j|[(j − 1)! + 1]. Assim, temos que existe k ∈ Z
tal que (j − 1)! + 1 = kj. Da(cid:237), obtemos k = (j−1)!+1

. Portanto,

e k − 1

j = (j−!)!

j

j

teremos

(cid:98) (j−1)!+1
j

− (cid:98) (j−1)!

j

(cid:99)(cid:99) = (cid:98)k − (cid:98)k − 1

j (cid:99)(cid:99) = (cid:98)k − (k − 1)(cid:99) = 1.

Se j nªo Ø um nœmero primo e j > 5, entªo pelo Lema 1.2.2 temos que j|(j − 1)!,
j = (j−1)!+1
isto Ø, existe k ∈ Z tal que (j − 1)! = kj. Da(cid:237), obtemos k = (j−1)!

e k + 1

.

j

j

Logo, teremos

28

Como Encontrar Nœmeros Primos

Cap(cid:237)tulo 2

(cid:98) (j−1)!+1
j

− (cid:98) (j−1)!

j

(cid:99)(cid:99) = (cid:98)k + 1

j − k(cid:99) = 0.

Agora, se j = 4, entªo

(cid:98) 3!+1

4 − (cid:98) 3!

4 (cid:99)(cid:99) = (cid:98) 7

4 − 1(cid:99) = 0.

Como as parcelas do somat(cid:243)rio da f(cid:243)rmula indicada para π(m) Ø igual a 1 se j Ø

primo e zero se j nªo Ø primo temos que este somat(cid:243)rio nos dÆ exatamente o nœmero

de nœmeros primos que sªo menores ou iguais a m, como quer(cid:237)amos demonstrar.

Por outro lado, o teorema acima nos garante que

log(x) Ø uma boa aproxima-
(cid:231)ªo de π(x) quando x for su(cid:28)cientemente grande. Portanto, podemos calcular a

x

probabilidade de que um nœmero x escolhido aleatoriamente seja primo, isto Ø,

x
log(x)

x = 1

P =

log(x) . Sendo assim, teremos que examinar aproximadamente log(x)
nœmeros pr(cid:243)ximos de x para acharmos um nœmero primo da mesma ordem de gran-

deza de x. Logo, para encontrarmos um nœmero primo com 100 algarismo, por

exemplo, devemos testar log(10100) ≈ 230 nœmeros aproximadamente. Como nªo

precisamos testar os nœmeros pares teremos que testar aproximadamente 115 nœme-

ros. (cid:201) claro que, como se trata de probabilidade, entªo esses nœmeros sªo apenas

uma mØdia das tentativas reais.

102

log(102) ≈ 22. Isto quer dizer que a diferen(cid:231)a entre
12% do valor de π(102), isto Ø,

Observe que para x = 102, por exemplo, temos que π(102) = 25, mas, temos que
log(102) e π(102) Ø aproximadamente
log(x) tem uma margem de erro de aproximadamente
12% do valor de π(x). Por outro lado, quando x = 1022 temos que π(1022) =
201.467.286.689.315.906.290 e π(1022) − 1022

log(1022) = 4.060.704.006.019.620.994, da(cid:237),
esse percentual cai para aproximadamente 2%. Portanto, para nœmeros com 100

102

x

algarismos, isto Ø, para x = 10100, Ø de se esperar que

x

log(x) seja uma boa aproxima(cid:231)ªo

de π(x).

Como os nœmeros que devemos testar sªo muito grandes temos que Ø fundamental

termos testes de primalidade e(cid:28)cientes e que nos garanta que o nœmero testado

29

Teste de Primalidade

Cap(cid:237)tulo 2

seja realmente um nœmero primo. Na pr(cid:243)xima se(cid:231)ªo iremos explorar alguns dos

principais testes de primalidade conhecidos. Como veremos no pr(cid:243)ximo cap(cid:237)tulo a

seguran(cid:231)a do sistema RSA estÆ intimamente ligada a di(cid:28)culdade de se fatorar um

nœmero muito grande, se o nœmero que escolhermos nªo for primo teremos que o

nœmero que usaremos para o sistema terÆ um fator primo com pelo menos metade

do nœmero de algarismos necessÆrios para garantir a seguran(cid:231)a do sistema.

2.2 Teste de Primalidade

A partir da dØcada de 60, apareceram inœmeras tentativas de obter um algoritmo

e(cid:28)ciente para o teste de primalidade de um nœmero natural. A import(cid:226)ncia desse

problema vem crescendo muito nos œltimos anos devido (cid:224) utiliza(cid:231)ªo crescente de

nœmeros primos nos algoritmos de criptogra(cid:28)a, como os algoritmos RSA e El Gam-

mal. O ponto chave da seguran(cid:231)a do sistema de criptogra(cid:28)a RSA Ø a di(cid:28)culdade de

se fatorar um nœmero muito grande. Nos dias de hoje, para que o sistema RSA seja

considerado seguro Ø necessÆrio que o nœmero escolhido para chave contenha dois

primos com aproximadamente 100 algarismos cada. Portanto, para escolher esses

nœmeros gigantes precisamos ter certeza que os nœmeros escolhidos sejam realmente

primos.

Um algoritmo muito antigo foi criado por Erat(cid:243)stenes, matemÆtico grego do

sØculo III a.C., esse algoritmo Ø o crivo de Erat(cid:243)stenes e serve para determinar

todos os nœmeros primos inferiores a um nœmero n dado arbitrariamente. O crivo

consiste em listar todos os nœmeros de 2 atØ n, em seguida retira-se dessa lista todos

os mœltiplos de cada nœmero primo menor ou igual a raiz quadrada de n, deixando

Ø claro esses primos.

Mostraremos como funciona o processo calculando todos os primos menores que

110. Primeiro escrevemos todos os nœmeros de 2 atØ 110. Como 2 Ø primo, riscamos

30

Teste de Primalidade

Cap(cid:237)tulo 2

todos os nœmeros mœltiplos de 2, maiores que 2. Depois, riscamos todos os mœltiplos

de 3, maiores que 3. Depois, riscamos todos os mœltiplos de 5, maiores que 5. E

por (cid:28)m, riscamos todos os mœltiplos de 7, maiores que 7. Como o pr(cid:243)ximo nœmero

primo Ø 11 e 112 = 121 > 110, paramos o processo no nœmero primo 7. Assim, todos

os nœmeros da lista que nªo foram riscados sªo todos os primos menores que 110.

2

12//

22//

32//

42//

52//

62//

72//

82//

92//

3

13

23

33//

43

53

63//

73

83

93//

4/

14//

24//

34//

44//

54//

64//

74//

84//

94//

5

15//

25//

35//

45//

55//

65//

75//

85//

95//

6/

16//

26//

36//

46//

56//

66//

76//

86//

96//

7

17

27//

37

47

57//

67

77//

87//

97

8/

18//

28//

38//

48//

58//

68//

78//

88//

98//

9/

19

29

39//

49//

59

69//

79

89

99//

10//

20//

30//

40//

50//

60//

70//

80//

90//

100////

11

21//

31

41

51//

61

71

81//

91//

101 102//// 103 104//// 105//// 106//// 107 108//// 109 110////

Observe que o crivo de Erat(cid:243)stenes nos diz que para veri(cid:28)carmos se um dado

nœmero n Ø primo, devemos veri(cid:28)car se esse nœmero Ø divis(cid:237)vel por algum primo

menor ou igual que a raiz quadrada de n. O que Ø muito œtil quando n nªo Ø um

nœmero muito grande. Mas, quando o nœmero Ø muito grande esse processo demanda

muito tempo para sua execu(cid:231)ªo. Portanto, para criptogra(cid:28)a RSA esse teste Ø inœtil.

Outro teste de primalidade Ø o Teorema de Wilson. Mas, devido a di(cid:28)culdade

de se calcular nœmeros fatoriais, tambØm, tem um tempo de execu(cid:231)ªo muito longo

quando estamos testando nœmeros muito grandes. Logo, para o sistema RSA nªo

31

Teste de Primalidade

serve.

Cap(cid:237)tulo 2

JÆ o Pequeno Teorema de Fermat se constitui numa ferramenta importante para

que possamos veri(cid:28)car se um nœmero Ø composto sem a necessidade de fatorÆ-lo.

O Teorema de Fermat a(cid:28)rma que: se p Ø um nœmero primo e a Ø um nœmero

inteiro tal que mdc(a, p) = 1, entªo ap−1 ≡ 1 mod p. Portanto, se mdc(a, n) = 1 e

an−1 (cid:54)≡ 1 mod n, entªo n Ø um nœmero composto. Mas, Ø importante observar que
mdc(1, n) = mdc(n − 1, n) = 1 e 1n−1 ≡ (n − 1)n−1 ≡ 1 mod n, ∀n ∈ Z positivo e
(cid:237)mpar, alØm disso, dado a ∈ Z, com mdc(a, n) = 1, tem-se que an−1 ≡ b mod n,

com 0 ≤ b < n. Assim, devemos testar se bn−1 (cid:54)≡ 1 mod n para algum 1 < b < n−1

para concluir que n Ø composto.

SerÆ que podemos usar o Pequeno Teorema de Fermat para veri(cid:28)car se um dado

nœmero Ø primo? Isto Ø, se um nœmero (cid:237)mpar n que satisfaz bn−1 ≡ 1 mod n, para

algum 1 < b < n − 1, podemos concluir que n Ø um nœmero primo? Infelizmente isso

nªo Ø verdade. Por exemplo, 2340 ≡ 1 mod 341. Mas, sabemos que 341 = 11 · 31, Ø

composto. Isto nos leva a seguinte de(cid:28)ni(cid:231)ªo.

De(cid:28)ni(cid:231)ªo 2.2.1 Dizemos que n Ø pseudoprimo na base a quando Ø composto e

satisfaz an−1 ≡ 1 mod n, com mdc(a, n) = 1.

Usar o Pequeno Teorema de Fermat para determinar se um dado nœmero Ø primo

tem uma boa probalidade de acerto, pois, entre 1 e 109 existem 50.847.534 primos,

mas apenas 5.597 pseudoprimos para a base 2. AlØm disso, essa compara(cid:231)ªo tÆ

levando em conta apenas a base dois. Se testarmos para a base trŒs, por exemplo,

temos que 3340 ≡ 56 mod 341. Portanto, trŒs Ø uma testemunha de que 341 Ø um

nœmero composto. Temos que hÆ apenas 1.272 pseudoprimos para as bases 2 e 3

entre 1 e 109.

Observe que necessitamos analisar apenas as bases a tais que 1 < a < n − 1, isso

32

Teste de Primalidade

Cap(cid:237)tulo 2

nos leva a tentar testar todas as bases nessas condi(cid:231)ıes, mas, isso Ø impraticÆvel se

o nœmero testado Ø muito grande. Da(cid:237), procuramos um processo mais e(cid:28)ciente.

Uma rec(cid:237)proca do Pequeno Teorema de Fermat foi descoberta por Lucas em

1876. Ela serÆ nosso primeiro teste de primalidade.

Proposi(cid:231)ªo 2.2.1 (Teste 1) Seja n > 1 um nœmero inteiro. Suponha que existe

um nœmero inteiro a > 1 tal que:

(i) an−1 ≡ 1 mod n,

(ii) am (cid:54)≡ 1 mod n, para m = 1, 2, . . . , n − 2.

Entªo n Ø primo.

Demonstra(cid:231)ªo: Primeiro, observe que an−1 ≡ 1 mod n implica que a Ø invert(cid:237)vel
em Zn. Da(cid:237), pelo Proposi(cid:231)ªo 1.1.11, temos que mdc(a, n) = 1. Assim, pela de(cid:28)ni(cid:231)ªo

1.2.2, temos que os itens (1) e (2) nos garantem que ordna = n − 1. AlØm disso, pelo

Teorema de Euler, temos que aφ(n) ≡ 1 mod n. Mas, sabemos que φ(n) ≤ n − 1 e

pelo CorolÆrio 1.2.2, temos n − 1 = ordna|φ(n), entªo obtemos φ(n) = n − 1, isto Ø,

n Ø um nœmero primo.

Apesar de ser conclusivo o teste apresenta di(cid:28)culdade de implementa(cid:231)ªo para

nœmeros muito grandes. Em 1891, Lucas reformulou sua rec(cid:237)proca para o Pequeno

Teorema de Fermat e apresentou a seguinte proposi(cid:231)ªo.

Proposi(cid:231)ªo 2.2.2 (Teste 2) Seja n > 1 um nœmero inteiro. Suponha que existe

um nœmero inteiro a > 1 tal que:

(i) an−1 ≡ 1 mod n,

(ii) am (cid:54)≡ 1 mod n, para todo divisor m de n − 1.

33

Teste de Primalidade

Entªo n Ø primo.

Cap(cid:237)tulo 2

Demonstra(cid:231)ªo: Basta observar que a Proposi(cid:231)ªo 1.2.3 nos garante que se ar ≡ 1

mod n, entªo ordna|r. Da(cid:237), para veri(cid:28)car se ordna = n − 1 Ø necessÆrio e su(cid:28)ciente

veri(cid:28)carmos se am (cid:54)≡ 1 mod n, para todo divisor m de n − 1. Da(cid:237), o restante da

demonstra(cid:231)ªo segue como foi feita no Teste 1.

A princ(cid:237)pio parece ser mais fÆcil a execu(cid:231)ªo desse teste do que o anterior, pois,

ter(cid:237)amos que testar um nœmero bem menor de congruŒncias. Mas, sua di(cid:28)culdade

de implementa(cid:231)ªo reside na di(cid:28)culdade de se conhecer todos os divisores de n − 1.

Em 1967, Brillharte e Selfridge tornaram o teste de Lucas mais (cid:29)ex(cid:237)vel.

Proposi(cid:231)ªo 2.2.3 (Teste 3) Seja n > 1 um nœmero inteiro. Supıe-se que, para

todo fator primo q de n − 1, exista um nœmero inteiro a = a(q) > 1, tal que:

(i) an−1 ≡ 1 mod n,

(ii) a

n−1
q

(cid:54)≡ 1 mod n.

Entªo n Ø primo.

Demonstra(cid:231)ªo:

Como φ(n) ≤ n − 1, basta mostrar que (n − 1)|φ(n). Da(cid:237),

conclu(cid:237)mos que φ(n) = n − 1, isto Ø equivalente a dizer que n Ø um nœmero primo.
Sendo assim, suponha que (n − 1) (cid:45) φ(n). Entªo existe um nœmero primo q e um

nœmero inteiro r ≥ 1 tais que qr divide n − 1, mas, nªo divide φ(n).

pela Proposi(cid:231)ªo 1.2.3, que k|(n − 1) e k (cid:45) n−1

Sejam a = a(q) e k = ordna. Como an−1 ≡ 1 mod n e a

(cid:54)≡ 1 mod n temos,
q . Logo, temos que qr|k. Por outro lado,
o Teorema de Euler nos garante que aφ(n) ≡ 1 mod n (lembre que (i) garante que

n−1
q

mdc(a, n) = 1), entªo pela Proposi(cid:231)ªo 1.2.3 temos que k|φ(n). Portanto, chegamos

a conclusªo que qr|φ(n), o que Ø uma contradi(cid:231)ªo. Logo, temos que φ(n) = n − 1,

o que Ø equivalente a dizer que n Ø um nœmero primo.

34

Teste de Primalidade

Cap(cid:237)tulo 2

Na busca por testes de primalidade mais e(cid:28)cientes do ponto de vista compu-

tacional e tendo em vista que a maior di(cid:28)culdade dos primeiros testes reside na

di(cid:28)culdade de se fatorar n − 1. Foram descobertos testes que supıem somente o

conhecimento de fatora(cid:231)ªo parcial de n − 1.

O pr(cid:243)ximo teste foi demonstrado por Pocklington em 1914.

Proposi(cid:231)ªo 2.2.4 (Teste 4) Seja n − 1 = qkR, em que q Ø um nœmero primo,

k ≥ 1 e q nªo divide R. Supıe-se a existŒncia de um nœmero inteiro a > 1 tal que:

(i) an−1 ≡ 1 mod n,

(ii) mdc(a

n−1

q − 1, n) = 1.

Entªo todo fator primo de n Ø da forma mqk + 1, com m ≥ 1.

Demonstra(cid:231)ªo:

Se p Ø um fator primo de n, entªo p divide n e como, por

hip(cid:243)tese, an−1 ≡ 1 mod n temos que n divide an−1 − 1. Portanto, temos que p

divide (an−1 − 1), isto Ø, an−1 ≡ 1 mod p. AlØm disso, por hip(cid:243)tese, temos que

n−1

n−1

mdc(a

q − 1, n) = 1 entªo p nªo divide a

temos que ordpa divide n − 1, mas nªo divide n−1

q − 1. Portanto, pela Proposi(cid:231)ªo 1.2.3
q . Logo, temos que qk divide a
ordem de a m(cid:243)dulo p. Por outro lado, o Teorema de Euler nos garante que ap−1 ≡ 1

mod p. Da(cid:237), temos que ordpa divide p − 1. Assim, podemos concluir que qk divide
p − 1, isto Ø, existe m ∈ Z tal que p − 1 = mqk. Conclu(cid:237)mos assim que se p Ø um

fator primo de n, entªo p = 1 + mqk, para algum k ≥ 1.

CorolÆrio 2.2.1 (Teste 5) Se n − 1 = F R, com F > R e para todo fator primo

q de F, existe a > 1 tal que an−1 ≡ 1 mod n e mdc(a

n−1

q − 1, n) = 1. Entªo, n Ø

primo.

Demonstra(cid:231)ªo: Seja q um fator primo de F e qk a maior potŒncia de q que divide

F . Assim, pela Proposi(cid:231)ªo anterior todo fator primo de n deve ser da forma 1+mqk,

35

Teste de Primalidade

Cap(cid:237)tulo 2

isto Ø, todo fator primo de n Ø c(cid:244)ngruo a 1 m(cid:243)dulo qk. Como q Ø um fator primo

qualquer de F temos que qualquer fator primo de n Ø c(cid:244)ngruo a 1 m(cid:243)dulo F , isto

Ø, todo fator primo de n Ø da forma 1 + tF para algum nœmero inteiro t ≥ 1. Como

F > R e 1 + tF Ø um fator primo de n temos que 1 + tF >

√

n, o que Ø um absurdo.

Logo, n Ø um nœmero primo.

CorolÆrio 2.2.2 (Teste 6 - Teste de PØpin) Seja Fn = 22n + 1. Entªo Fn Ø

primo se, e somente se, 3

Fn−1

2 ≡ −1 mod Fn.

Demonstra(cid:231)ªo:

Se 3

Fn−1

2 ≡ −1 mod Fn, entªo temos que (3

Fn−1
2

)2 ≡ (−1)2

mod Fn, isto Ø, 3Fn−1 ≡ 1 mod Fn. AlØm disso, 2 Ø o œnico fator primo que divide

Fn − 1 e como 3

Fn−1

2 ≡ −1 mod Fn podemos concluir que todas as hip(cid:243)teses da

Proposi(cid:231)ªo 2.2.3 estªo satisfeitas. Logo, Fn Ø um nœmero primo. Reciprocamente,

se Fn Ø um nœmero primo, entªo pelo CritØrio de Euler temos que

Fn−1

2 ≡

3

(cid:17)

(cid:16) 3
Fn

mod Fn.

AlØm disso, pela Lei de Reciprocidade QuadrÆtica, temos que

( 3
Fn

)( Fn

3 ) = (−1)( 3−1

2 )( Fn−1

2

) = 1, isto Ø, temos que ( 3
Fn

) = ( Fn

3 ).

Observe que Fn = 22n + 1 ≡ 2 mod 3. De fato, provaremos por indu(cid:231)ªo em n. Para
n = 1, temos 221 + 1 = 5 ≡ 2 mod 3. Portanto, para n = 1 a congruŒncia estÆ

veri(cid:28)cada.

Suponha que a congruŒncia seja vÆlida para n = k. Entªo basta provar que vale
para n = k+1. Observe que, 22k+1 +1 = 22·2k +1 = 22k ·22k +1 = (22k −1)·22k +22k +1.
Como, por hip(cid:243)tese de indu(cid:231)ªo, 22k + 1 ≡ 2 mod 3 temos que 22k − 1 ≡ 0 mod 3.
Portanto, temos que 22k+1 + 1 = (22k − 1) · 22k + 22k + 1 ≡ 2 mod 3.

Logo, pelo princ(cid:237)pio de indu(cid:231)ªo, temos que Fn = 22n + 1 ≡ 2 mod 3. Da(cid:237),

pelo CorolÆrio 1.3.1 item 1 temos que ( Fn

3 ) = ( 2

3). Mas, pelo item 2 da Lei de

36

Teste de Primalidade

Cap(cid:237)tulo 2

Reciprocidade QuadrÆtica, obtemos ( 2

3) = −1. Logo, podemos concluir que 3

Fn−1

2 ≡

( 3
Fn

) = ( Fn

3 ) = ( 2

3) = −1 mod Fn como quer(cid:237)amos demonstrar.

Teorema 2.2.1 (Teste 7 - Proth (1878)) Seja n = h·2k +1, com 2k > h. Entªo
n Ø um nœmero primo se, e somente se, existe um inteiro a com a n−1

2 ≡ −1 mod n.

Demonstra(cid:231)ªo: Se n Ø um nœmero primo, entªo podemos tomar a qualquer com
(cid:1) = −1, pois, pelo Teorema 1.3.3 metade dos inteiros entre 1 e n − 1 serve como a.
(cid:0) a
n
AlØm disso, pelo CritØrio de Euler, temos que ( a
concluir que existe um inteiro a com a n−1
F = 2k e observe que a n−1
2 ≡ −1 mod n implica que n|a n−1
2 +1, da(cid:237), nenhum fator primo de n divide a n−1
primo de n divide a n−1
(pois, tal fator dividiria 2, mas, n Ø (cid:237)mpar). Portanto, mdc(a n−1
outro lado, a n−1

2 + 1, isto Ø, todo fator
2 +1−2 = a n−1

2 ≡ −1 mod n. Reciprocamente, tome

2 ≡ −1 mod n implica que (a n−1

2 )2 ≡ (−1)2 mod n, isto Ø, an−1 ≡ 1

2 mod n. Assim, podemos

2 − 1, n) = 1. Por

n ) ≡ a n−1

2 −1

mod n. Assim, pelo CorolÆrio 2.2.1, temos que n Ø primo.

A grande maioria dos 100 maiores primos conhecidos estªo nas condi(cid:231)ıes do

teorema de Proth, segundo [4]. Isto acontece porque primos desta forma sªo mais

frequentes e sua primalidade Ø facilmente demonstrada usando este teste.

O pr(cid:243)ximo teorema justi(cid:28)ca a aplica(cid:231)ªo de um algoritmo utilizado atualmente

para determinar se um dado nœmero Ø primo. Com este algoritmo Ø poss(cid:237)vel deter-

minar com certeza absoluta se um dado nœmero Ø primo. Todos os algoritmos que

tomavam por fundamento os testes anteriores davam apenas uma probabilidade de

que o nœmero testado seria um nœmero primo, claro que, essa probabilidade era bem

alta, mas, nªo se tinha garantia absoluta de que o nœmero testado seria um nœmero

primo.

A demonstra(cid:231)ªo desse teorema utiliza resultados matemÆticos que foge ao obje-

tivo deste trabalho, por esse motivo nªo faremos sua demonstra(cid:231)ªo aqui. Mas, quem

37

Teste de Primalidade

Cap(cid:237)tulo 2

desejar estudar um pouco mais o assunto recomendamos [4], onde pode ser vista uma

demonstra(cid:231)ªo desse teorema e todos os resultados utilizados nessa demonstra(cid:231)ªo.

Teorema 2.2.2 (Teste 8 - AKSL) Sejam N, r, v ∈ Z, maiores que 1. Seja S um

conjunto (cid:28)nito com s elementos. Suponha que:

1. N e r sªo primos relativos e v = ordrN .

2. mdc(N, a − b) = 1, para quaisquer elementos a, b ∈ S, com a (cid:54)= b.

(cid:18) s + t − 1

(cid:19)

√

≥ N

3.

s

t

2 , para todo t divisor de φ(r) que seja mœltiplo de v.

4. (x + a)N ≡ xN + a mod (xr − 1, N ), para todo a ∈ S.

Entªo N Ø potŒncia de um nœmero primo.

38

Cap(cid:237)tulo 3

Criptogra(cid:28)a RSA

Neste cap(cid:237)tulo iremos estudar o funcionamento da criptogra(cid:28)a RSA. A criptogra-

(cid:28)a de chave pœblica RSA foi desenvolvida por R. L. Rivest, A. Shamir e L. Adleman

em 1978. Observe que as iniciais dos nomes dos autores deram origem ao nome do

c(cid:243)digo.

Como veremos neste cap(cid:237)tulo a seguran(cid:231)a da criptogra(cid:28)a RSA reside na di(cid:28)cul-

dade de fatorar um nœmero grande (nœmero com pelo menos 231 algarismos) em

seus fatores primos.

3.1 Criptossistemas SimØtricos e AssimØtricos

A palavra criptogra(cid:28)a tem origem no grego, cryptos signi(cid:28)ca oculto, secreto e

grapho signi(cid:28)ca escrita. Assim, criptogra(cid:28)a Ø o estudo de mØtodos que permitam

escrever mensagens em cifras ou c(cid:243)digos, de modo que apenas os leg(cid:237)timos destina-

tÆrios sejam capazes de decodi(cid:28)car e ler as mensagens.

Um dos mais simples exemplos de criptogra(cid:28)a consiste em transladar o alfabeto

em um certo nœmero de vezes, por exemplo, fazer a primeira letra assumir a posi(cid:231)ªo

da terceira, a segunda assumir a posi(cid:231)ªo da quarta, e assim por diante, atØ que

39

Criptossistemas SimØtricos e AssimØtricos

Cap(cid:237)tulo 3

a penœltima ocupa a posi(cid:231)ªo da primeira e a œltima ocupa a posi(cid:231)ªo da segunda.

Um c(cid:243)digo semelhante a esse foi usado pelo imperador romano Jœlio Cesar para se

comunicar com suas tropas em combate pela Europa.

Um criptossistema Ø um conjunto de procedimentos que torna poss(cid:237)vel a cripto-

gra(cid:28)a. Todo sistema criptogrÆ(cid:28)co consiste basicamente dos seguintes elementos:

1. Um alfabeto.

2. A mensagem original.

3. A chave de codi(cid:28)ca(cid:231)ªo.

4. O procedimento ou fun(cid:231)ªo de codi(cid:28)ca(cid:231)ªo.

5. A mensagem codi(cid:28)cada.

6. A chave de decodi(cid:28)ca(cid:231)ªo.

7. O procedimento ou fun(cid:231)ªo de decodi(cid:28)ca(cid:231)ªo.

Quando a chave ou a fun(cid:231)ªo de decodi(cid:28)ca(cid:231)ªo Ø facilmente deduzida da chave ou

fun(cid:231)ªo de codi(cid:28)ca(cid:231)ªo serÆ necessÆrio manter tal chave em sigilo, sendo conhecida

apenas pelos usuÆrios leg(cid:237)timos do criptossistema. Neste caso, o sistema Ø dito

criptossistema simØtrico ou de chave secreta. O cifrÆrio de Cesar Ø um exemplo de

criptossistema simØtrico. Uma desvantagem desse tipo de sistema Ø que se o nœmero

de usuÆrio for grande o sistema perde a seguran(cid:231)a, pois, a chave secreta passa a ser

de conhecimento de todos os usuÆrios do sistema. Por isso, esse tipo de sistema Ø

recomendado apenas quando o nœmero de usuÆrio nªo excede a dois.

O criptossistema de chave pœblica Ø caracterizado pelo fato de ser muito dif(cid:237)cil

obter a chave de decodi(cid:28)ca(cid:231)ªo a partir da chave de codi(cid:28)ca(cid:231)ªo, da(cid:237), o sistema Ø

dito criptossistema assimØtrico ou de chave pœblica. Esse tipo de criptossistema foi

40

Criptossistemas SimØtricos e AssimØtricos

Cap(cid:237)tulo 3

proposto em 1976 por W. Di(cid:30)e e M. E. Hellman da Universidade de Stanford e,

independentemente, por R. C. Merkle da Universidade da California. O criptossis-

tema de chave pœblica possui uma chave de codi(cid:28)ca(cid:231)ªo pœblica, de conhecimento

de todos e uma chave de decodi(cid:28)ca(cid:231)ªo secreta, de conhecimento apenas do receptor

da mensagem. Neste tipo de sistema criptogrÆ(cid:28)co vÆrios receptores podem man-

ter comunica(cid:231)ªo com vÆrios transmissores diferentes. Isto Ø poss(cid:237)vel porque cada

transmissor e cada receptor possui uma chave de codi(cid:28)ca(cid:231)ªo e uma chave de deco-

di(cid:28)ca(cid:231)ªo.

Para entender melhor como a comunica(cid:231)ªo entre vÆrias pessoas acontece, vamos

supor que n pessoas estªo usando um determinado criptossistema de chave pœblica.

Vamos representar uma pessoa qualquer que esteja usando esse criptossistema, por

ui, com i = 1, 2, . . . , n. Logo, se um usuÆrio ui deseja mandar uma mensagem

para um usuÆrio uj, entªo o usuÆrio ui codi(cid:28)ca a mensagem com a chave pœblica

do usuÆrio uj. Assim, quando o usuÆrio uj receber a mensagem serÆ capaz de

decodi(cid:28)cÆ-la atravØs de sua chave secreta de decodi(cid:28)ca(cid:231)ªo.

Observe que a chave de codi(cid:28)ca(cid:231)ªo de qualquer usuÆrio Ø pœblica, entªo qualquer

pessoa pode mandar uma mensagem para outro usuÆrio desse sistema, alØm disso,

cada usuÆrio do sistema possui sua pr(cid:243)pria chave de decodi(cid:28)ca(cid:231)ªo que nesse caso Ø

conhecida apenas por ele, garantindo assim que a seguran(cid:231)a do sistema independa

do nœmero de usuÆrios desse sistema. E, isso realmente Ø muito vantajoso, pois, com

as novas tecnologias, principalmente, a internet, temos uma comunica(cid:231)ªo entre um

nœmero cada vez maior de pessoas. Assim, ter um sistema que admita um nœmero

qualquer de usuÆrios sem comprometer a seguran(cid:231)a do sistema Ø sem dœvida uma

grande vantagem. E, isso torna os criptossistemas de chave pœblica a œnica op(cid:231)ªo

conhecida no momento para transmissªo de mensagens com a mÆxima seguran(cid:231)a

poss(cid:237)vel.

41

Gera(cid:231)ªo das Chaves

Cap(cid:237)tulo 3

Nas pr(cid:243)ximas se(cid:231)ıes mostraremos todos os passos que devem ser seguidos para

quem deseja utilizar o sistema RSA, inclusive mostrando os fundamentos matemÆ-

ticos que justi(cid:28)cam porque o sistema funciona.

3.2 Gera(cid:231)ªo das Chaves

Nesta se(cid:231)ªo descreveremos como obter as chaves de codi(cid:28)ca(cid:231)ªo e decodi(cid:28)ca(cid:231)ªo

do criptossistema RSA.

Para gerar a chave de codi(cid:28)ca(cid:231)ªo na criptogra(cid:28)a RSA cada usuÆrio escolhe dois

nœmeros primos, p e q, distintos e extremamente grandes. A diferen(cid:231)a entre esses

nœmeros primos nªo pode ser pequena, da(cid:237), a escolha de um nœmero com 104 e outro

com 127 algarismos, respectivamente, nos garante uma enorme dist(cid:226)ncia entre os

dois nœmeros primos escolhidos, di(cid:28)cultando assim a fatora(cid:231)ªo do nœmero n = pq.

Depois da escolha dos nœmeros primos, calculamos

n = pq

e

φ(n) = (p − 1)(q − 1) = n + 1 − (p + q).

Em seguida, escolhemos um nœmero t ∈ Z, 1 < t < φ(n), tal que mdc(t, φ(n)) = 1.

Obtemos assim a chave de codi(cid:28)ca(cid:231)ªo kc = (t, n).

E, para obter a chave de decodi(cid:28)ca(cid:231)ªo determinamos r ∈ Z, 0 < r < φ(n), tal

que tr ≡ 1 mod φ(n), ou seja, r Ø o inverso multiplicativo de t m(cid:243)dulo φ(n).

Obtemos assim a chave de decodi(cid:28)ca(cid:231)ªo kd = (r, n).

42

Codi(cid:28)ca(cid:231)ªo e Decodi(cid:28)ca(cid:231)ªo

Cap(cid:237)tulo 3

Agora o usuÆrio divulga a chave de codi(cid:28)ca(cid:231)ªo kc = (t, n) e mantØm em segredo

a chave de decodi(cid:28)ca(cid:231)ªo kd = (r, n). Como foi dito na se(cid:231)ªo anterior cada usuÆ-

rio deve proceder como descrito acima para obter suas chaves de codi(cid:28)ca(cid:231)ªo e de

decodi(cid:28)ca(cid:231)ªo.

3.3 Codi(cid:28)ca(cid:231)ªo e Decodi(cid:28)ca(cid:231)ªo

Primeiramente, a mensagem Ø convertida em uma sequŒncia numØrica, atravØs

de uma correspondŒncia biun(cid:237)voca entre os s(cid:237)mbolos usados na mensagem original
e um subconjunto (cid:28)nito de N. Esta etapa chamaremos de prØ-codi(cid:28)ca(cid:231)ªo, para

distingui-la da codi(cid:28)ca(cid:231)ªo propriamente dita.

Essa sequŒncia numØrica Ø quebrada em blocos m de nœmeros naturais, onde

1 ≤ m < n. A escolha dos blocos nªo Ø œnica, mas certos cuidados devem ser

tomados. Tais como:

1. Nªo devemos escolher blocos que comecem por zero, pois, perder(cid:237)amos in-

forma(cid:231)ªo ao codi(cid:28)car a mensagem e nªo ter(cid:237)amos como corrigir um erro na

decodi(cid:28)ca(cid:231)ªo a partir desse bloco.

2. Nªo escolher blocos que correspondam a alguma unidade lingu(cid:237)stica, como

palavra, letra ou qualquer outra, pois, isso facilitaria a quebra do c(cid:243)digo.

Depois, cada bloco m Ø codi(cid:28)cado como segue

kc(m) ≡ mt mod n.

Note que kc(m) Ø o resto da divisªo euclidiana de mt por n.

E, (cid:28)nalmente, a decodi(cid:28)ca(cid:231)ªo de kc(m) serÆ

kd(kc(m)) ≡ (kc(m))r mod n.

43

Codi(cid:28)ca(cid:231)ªo e Decodi(cid:28)ca(cid:231)ªo

Cap(cid:237)tulo 3

Note que kd(kc(m)) Ø o resto da divisªo euclidiana de (mt)r = mtr por n.

Observe que ap(cid:243)s a mensagem ser separada em blocos para a codi(cid:28)ca(cid:231)ªo, esses

blocos devem permanecer separados e mantidos na mesma ordem em que foram

formados a partir da mensagem original. Depois, da decodi(cid:28)ca(cid:231)ªo de todos os blocos,

estes devem ser reunidos novamente obedecendo a ordem estebelecida anteriormente

para obter a mensagem original.

Portanto, a criptogra(cid:28)a RSA tem como alfabeto de entrada um alfabeto numØrico
e os blocos que constituem a mensagem sªo elementos do conjunto Zn. Na œltima

se(cid:231)ªo deste cap(cid:237)tulo apresentaremos dois exemplos para tornar a teoria mais clara.

(cid:201) fÆcil ver porque a decodi(cid:28)ca(cid:231)ªo do RSA funciona. De fato, seja kc(m) ≡ mt

mod n a codi(cid:28)ca(cid:231)ªo de um bloco m. Queremos mostrar que kd(kc(m)) ≡ m mod n.

Primeiro mostraremos que kd(kc(m)) ≡ m mod p.

Como tr ≡ 1 mod φ(n) temos que existe i ∈ N tal que tr = 1 + iφ(n).

Se mdc(m, p) = 1, usando o Pequeno Teorema de Fermat temos que mp−1 ≡

1 mod p, da(cid:237), elevando ambos os membro dessa congruŒncia ao expoente i(q −

1), obtemos (mp−1)i(q−1) = mi(p−1)(q−1) ≡ 1 mod p, assim, multiplicando ambos

os membros dessa œltima congruŒncia por m obtemos, m1+i(p−1)(q−1) ≡ m mod p.

Mas, 1 + i(p − 1)(q − 1) = 1 + iφ(n) = tr. Logo, temos que kd(kc(m)) ≡ mtr =

m1+i(p−1)(q−1) ≡ m mod p.

Se mdc(m, p) = p, entªo esta œltima congruŒncia Ø verdadeira, pois, ambos os

lados Ø congruente a zero m(cid:243)dulo p. Assim, teremos kd(kc(m)) ≡ m mod p para

qualquer bloco m da mensagem original.

De modo, anÆlogo encontramos kd(kc(m)) = (mt)r = mtr ≡ m mod q.

Observe que kd(kc(m)) ≡ m mod p e kd(kc(m)) ≡ m mod q implicam que

44

Seguran(cid:231)a do RSA

Cap(cid:237)tulo 3

p|[kd(kc(m)) − m] e q|[kd(kc(m)) − m]. Como p e q sªo primos temos que n =

pq|[kd(kc(m)) − m], isto Ø,

kd(kc(m)) ≡ m mod n.

Como vimos a matemÆtica que justi(cid:28)ca o sistema de RSA Ø bem simples. E

para garantir a seguran(cid:231)a do sistema, Ø necessÆrio que os nœmeros primos escolhidos

sejam grandes. Consequentemente o nœmero n terÆ sua decomposi(cid:231)ªo em fatores

primos computacionalmente inviÆvel. (cid:201) nessa escolha que reside a necessidade de

uma matemÆtica mais so(cid:28)sticada, como vimos no cap(cid:237)tulo anterior.

3.4 Seguran(cid:231)a do RSA

Um ponto fundamental para a seguran(cid:231)a da criptogra(cid:28)a RSA refere-se (cid:224) escolha

adequada dos primos p e q. Assim, para di(cid:28)cultar a fatora(cid:231)ªo de n a nossa escolha

deve obedecer aos seguintes par(cid:226)metros:

1. Os nœmeros primos p e q nªo podem ser pr(cid:243)ximos um do outro. Suponha que

n tenha a algarismos. Entªo para costruir n, escolha um primo p entre 4a
100 algarismos e, em seguida, escolha um primo q pr(cid:243)ximo de 10a

10 e
p algarismos.

45a

2. AlØm disso, precisamos ter certeza que os nœmeros p − 1, q − 1, p + 1 e q + 1

possuem fatores primos grandes.

3. E, tambØm, devemos ter mdc(p − 1, q − 1) pequeno.

Veremos como Ø poss(cid:237)vel quebrar o c(cid:243)digo RSA. Isto Ø, como decodi(cid:28)car a men-

sagem conhecendo apenas a chave pœblica do sistema.

Observe que a chave de codi(cid:28)ca(cid:231)ªo kc = (t, n) Ø a chave pœblica, isto Ø, qualquer

usuÆrio conhece. Portanto, uma forma de quebrar o c(cid:243)digo RSA seria calcular r

45

Assinatura Digital

Cap(cid:237)tulo 3

conhecendo apenas t e n. Mas, como vimos na Se(cid:231)ªo 2, r Ø o inverso multiplicativo

de t m(cid:243)dulo φ(n). Portanto, seria necessÆrio calcular φ(n). Mas, temos que n = pq,

em que p e q sªo nœmeros primos, entªo obtemos φ(n) = (p − 1)(q − 1). Isto Ø,

devemos conhecer a fatora(cid:231)ªo de n.

Outra forma de quebrar o c(cid:243)digo RSA seria calcular a raiz t-Øsima de mt m(cid:243)dulo

n. PorØm sabemos que este problema Ø computacionalmente inviÆvel guando n Ø

grande.

Portanto, para conseguir quebrar o c(cid:243)digo do RSA Ø necessÆrio fatorar n ou

calcular a raiz t-Øsima de mt m(cid:243)dulo n. Mas, atØ o momento nªo se conhece um

algoritmo e(cid:28)ciente que consiga resolver um desses problemas com a tecnologia atual.

Logo, o sistema RSA tem se mostrado seguro.

3.5 Assinatura Digital

Uma caracter(cid:237)stica importante do sistema RSA Ø que kd(kc(m)) = kc(kd(m)),

isto Ø, kd e kc comutam. De fato, temos que kc(m) ≡ mt mod n. Da(cid:237), teremos que

kd(kc(m)) ≡ (mt)r = mtr = (mr)t ≡ kc(kd(m)) mod n.

Esta propriedade possibilita enviarmos mensagens com "assinaturas digitais".

Vejamos como isso funciona.

Suponha que um usuÆrio i deseja enviar uma mensagem m assinada para um

usuÆrio j. Entªo o usuÆrio i usa sua chave secreta kd,i(m), depois usa a chave pœblica

do usuÆrio j kc,j(kd,i(m)) e envia esta para j.

Para que o usuÆrio j possa ler a mensagem deve proceder da seguinte forma:

aplica a sua chave secreta kd,j e depois aplica a chave pœblica do usuÆrio i kc,i, da(cid:237),

obtem a mensagem original m.

46

Aplica(cid:231)ªo

Cap(cid:237)tulo 3

Observe que dessa forma o usuÆrio j pode ter certeza que foi de fato o usuÆrio

i quem mandou a mensagem m, pois, a chave kd,i usada no processo Ø conhecida

apenas pelo usuÆrio i.

Severino Coller Coutinho no seu livro Nœmeros Inteiros e Criptogra(cid:28)a RSA des-

creve como um especialista em seguran(cid:231)a de computadores descobriu um mØtodo

para "quebrar"o c(cid:243)digo RSA.

Recentemente descobiu-se que o uso pouco cuidadoso da tØcnica de

autentica(cid:231)ªo de assinaturas torna vulnerÆveis certos mØtodos de chave

pœblica como o RSA. No (cid:28)nal de 1995, um consultor em assuntos de

seguran(cid:231)a de computadores (mas formado em biologia!) descobriu que

Ø poss(cid:237)vel usar o sistema de assinaturas para quebrar o RSA. O mØtodo

consiste em enviar uma mensagem assinada e marcar o tempo que o sis-

tema leva para con(cid:28)rmar a assinatura. Fazendo isto para mensagens de

tamanhos ligeiramente diferentes, Ø poss(cid:237)vel obter informa(cid:231)ıes su(cid:28)cientes

para encontrar a chave de decodi(cid:28)ca(cid:231)ªo do sistema RSA que esteja sendo

usado. Portanto, a seguran(cid:231)a do RSA nªo depende exclusivamente da

nossa capacidade de inventar novos algoritmos de fatora(cid:231)ªo. HÆ muitos

outros fatores importantes, que nªo tŒm um carÆter puramente matemÆ-

tico.

3.6 Aplica(cid:231)ªo

Nos exemplos abaixo iremos usar o nœmero 99 para representar o espa(cid:231)o em
branco entre as palavras e a correspondŒncia entre o alfabeto F = {A, B, C, . . . , Z}

e o conjunto {10, 11, 12, . . . , 35}, como segue abaixo:

47

Aplica(cid:231)ªo

Cap(cid:237)tulo 3

A B C D E F G H I

J K L M

10 11 12 13 14 15 16 17 18 19 20 21 22

N O P Q R S T U V W X Y Z

23 24 25 26 27 28 29 30 31 32 33 34 35

Antes de come(cid:231)armos com os exemplos, vamos provar uma a(cid:28)rma(cid:231)ªo que nos

garante a validez dos cÆlculos realizados para codi(cid:28)car e decodi(cid:28)car as mensagens.

Essa a(cid:28)rma(cid:231)ªo nos diz que dada uma potŒncia qualquer em uma congruŒncia m(cid:243)dulo

n, podemos substituir a base da potŒncia pelo resto da divisªo euclidiana dessa base

por n.

A(cid:28)rma(cid:231)ªo 1 Dados a, b, t e n nœmeros naturais, com n > 1 e 0 ≤ b < n. Entªo

(an + b)r ≡ br mod n.

Demonstra(cid:231)ªo: Basta observar que (an + b)r = (an)r + kr−1(an)r−1b + · · · +

k1(an)br−1 + br ≡ 0 + 0 + · · · + 0 + br = br mod n.

Exemplo 3.6.1 Vamos codi(cid:28)car e decodi(cid:28)car, pelo mØtodo RSA, a mensagem "BOA

NOITE". Sabendo que n = 7597, t = 4947 e φ(n) = 7420.

Solu(cid:231)ªo: Assim, devemos transformar a mensagem em uma sequŒncia numØrica

atravØs da correspondŒncia dada no in(cid:237)cio dessa Se(cid:231)ªo. Portanto a mensagem serÆ

112410992324182914.

Em seguida quebramos esse nœmero nos seguintes blocos: 112 − 4109 − 923 −

241 − 82 − 914.

Vamos agora codi(cid:28)car a mensagem.

kc(112) ≡ 1124947 = 112 · (1122)2473 = 112 · 125442473 ≡ 112 · 4947 · (49472)1236 =

554064 · 244728091236 ≡ 7080 · (28722)618 = 7080 · 8248384618 ≡ 7080 · (56392)309 =

48

Aplica(cid:231)ªo

Cap(cid:237)tulo 3

7080 · 31798321309 ≡ 7080 · 4876 · (48762)154 = 34522080 · 23775376154 ≡ 1312 ·

(43632)77 = 1312 · 1903576977 ≡ 1312 · 5284 · (52842)38 = 6932608 · 2792065638 ≡

4144 · (16812)19 = 4144 · 282576119 ≡ 4144 · 7274 · (72742)9 = 30143456 · 529110769 ≡

6157 · 5568 · (55682)4 = 34282176 · 310026244 ≡ 4512 · (68642)2 = 4512 · 471144962 ≡

4512 · 54992 = 4512 · 30239001 ≡ 4512 · 2941 = 13269792 ≡ 5430 mod 7597.

kc(4109) ≡ 41094947 = 4109 · (41092)2473 = 4109 · 168838812473 ≡ 4109 · 3347 ·

(33472)1236 = 13752823·112024091236 ≡ 2253·(44312)618 = 2253·19633761618 ≡ 2253·

(31132)309 = 2253 · 9690769309 ≡ 2253 · 4594 · (45942)154 = 10350282 · 21104836154 ≡

3168 · (3702)77 = 3168 · 13690077 ≡ 3168 · 1542 · (1543)25 = 75132288 · 365226425 ≡

5555 · 5704 · (57042)12 = 31685720 · 3253561612 ≡ 6230 · (52622)6 = 6230 · 276886446 ≡

6230 · (51762)3 = 6230 · 267909763 ≡ 6230 · 3954 · 39542 = 24633420 · 15634116 ≡

3946 · 7087 = 27965302 ≡ 745 mod 7597.

kc(923) ≡ 9234947 = 923 · (9232)2473 = 923 · 8519292473 ≡ 923 · 1065 · (10652)1236 =

982995 · 11342251236 ≡ 2982 · (22722)618 = 2982 · 5161984618 ≡ 2982 · (36212)309 =

2982 · 13111641309 ≡ 2982 · 6816 · (68162)154 = 20325312 · 46457856154 ≡ 3337 ·

(22012)77 = 3337 · 484440177 ≡ 3337 · 5112 · (51122)38 = 17058744 · 2613254438 ≡

3479 · (64612)19 = 3479 · 4174452119 ≡ 3479 · 6603 · (66032)9 = 22971837 · 435996099 ≡

6106 · 426 · (4262)4 = 2601156 · 1814764 ≡ 2982 · (67452)2 = 2982 · 454950252 ≡

2982 · 41892 = 2982 · 17547721 ≡ 2982 · 6248 = 18631536 ≡ 3692 mod 7597.

kc(241) ≡ 2414947 = (2413)1649 = 139975211649 ≡ 3847 · (38472)824 = 3847 ·

14799409824 ≡ 3847 · (4532)412 = 3847 · 205209412 ≡ 3847 · (904)103 = 3847 ·

65610000103 ≡ 3847·2308·(23082)51 = 8878876·532686451 ≡ 5580·1367·(13672)25 =

7627860·186868925 ≡ 472·7424·(74242)12 = 3504128·5511577612 ≡ 1911·(71382)6 =

1911 · 509510446 ≡ 1911 · (55622)3 = 1911 · 309358443 ≡ 1911 · 860 · 8602 =

1643460 · 739600 ≡ 2508 · 2691 = 6749028 ≡ 2892 mod 7597.

49

Aplica(cid:231)ªo

Cap(cid:237)tulo 3

kc(82) ≡ 824947 = (823)1649 = 5513681649 ≡ 4384·(43842)824 = 4384·19219456824 ≡

4384 · (66432)412 = 4384 · 44129449412 ≡ 4384 · (60732)206 = 4384 · 36881329206 ≡

4384 · (54912)103 = 4384 · 30151081103 ≡ 4384 · 6185 · (61852)51 = 27115040 ·

3825422551 ≡ 1347·3330·(33302)25 = 4485510·1108890025 ≡ 3280·4877·(48772)12 =

15996560 · 2378512912 ≡ 4875 · (65192)6 = 4875 · 424973616 ≡ 4875 · (73402)3 =

4875 · 538756003 ≡ 4875 · 5273 · 52732 = 25705875 · 27804529 ≡ 5224 · 7106 =

37121744 ≡ 2802 mod 7597.

kc(914) ≡ 9144947 = 914 · (9142)2473 = 914 · 8353962473 ≡ 914 · 7323 · (73232)1236 =

6693222 · 536263291236 ≡ 265 · (67032)618 = 265 · 44930209618 ≡ 265 · (15512)309 =

265 · 2405601309 ≡ 265 · 4949 · (49492)154 = 1311485 · 24492601154 ≡ 4801 · (74702)77 =

4801 · 5580090077 ≡ 4801 · 9352 · (9353)25 = 4197154225 · 81740037525 ≡ 1650 ·

1160 · (11602)12 = 1914000 · 134560012 ≡ 7153 · (9313)4 = 7153 · 8069544914 ≡

7153 · (11512)2 = 7153 · 13248012 ≡ 7153 · 29232 = 7153 · 8543929 ≡ 7153 · 4901 =

35056853 ≡ 4295 mod 7597.

Portanto, a mensagem codi(cid:28)cada tem a seguinte seguŒncia de blocos: 5430 − 745 −

3692 − 2892 − 4295. Pr(cid:243)ximo passo, encontrar a chave de decodi(cid:28)ca(cid:231)ªo.
Isto Ø,
encontrar r tal que 4947r ≡ 1 mod 7420. Da(cid:237), conclu(cid:237)mos que ∃i ∈ Z tal que

4947r − 7420i = 1.

Assim devemos aplicar o algoritmo de Euclides para determinar o mÆximo divisor

comum de 4947 e 7420. Portanto, teremos

• 2473 = 7420 − 4947

• 1 = 4947 − 2 · 2473

Da(cid:237), temos que

1 = 4947 − 2 · 2473 = 4947 − 2 · (7420 − 4947) = 3 · 4947 − 2 · 7420.

50

Aplica(cid:231)ªo

Cap(cid:237)tulo 3

Logo, obtemos r = 3, assim, a chave de decodi(cid:28)ca(cid:231)ªo Ø kd = (3, 7597). Agora

calculamos kd(5430), kd(745), kd(3692), kd(2892), kd(2802) e kd(4295).

kd(5430) ≡ 54303 = 5430 · 54302 = 5430 · 29484900 = 5430 · (7597 · 3881 + 943) ≡

5430 · 943 = 5120490 = 7597 · 674 + 112 ≡ 112 mod 7597.

kd(745) ≡ 7453 = 745 · 7452 = 745 · 555025 = 745 · (7597 · 73 + 444) ≡ 745 · 444 =

330780 = 7597 · 43 + 4109 ≡ 4109 mod 7597.

kd(3692) ≡ 36923 = 3692 · 36922 = 3692 · 13630864 = 3692 · (7597 · 1794 + 1846) ≡

3692 · 1846 = 6815432 = 7597 · 897 + 923 ≡ 923 mod 7597.

kd(2892) ≡ 28923 = 2892 · 28922 = 2892 · 8363664 = 2892 · (7597 · 1100 + 6964) ≡

2892 · 6964 = 20139888 = 7597 · 2651 + 241 ≡ 241 mod 7597.

kd(2802) ≡ 28023 = 2802 · 28022 = 2802 · 7851204 = 2802 · (7597 · 1033 + 3503) ≡

2802 · 3503 = 9815406 = 7597 · 1292 + 82 ≡ 82 mod 7597.

kd(4295) ≡ 42953 = 4295 · 42952 = 4295 · 18447025 = 4295 · (7597 · 2428 + 1509) ≡

4295 · 1509 = 6481155 = 7597 · 853 + 914 ≡ 914 mod 7597.

Portanto, a mensagem original Ø 112 − 4109 − 923 − 241 − 82 − 914, isto Ø, 11 − 24 −

10 − 99 − 23 − 24 − 18 − 29 − 14, que signi(cid:28)ca BOA NOITE.

Exemplo 3.6.2 A chave pœblica utilizada pelo Banco de Toulouse para codi(cid:28)car

suas mensagens Ø a seguinte: n = 10403 e t = 8743. Recentemente os computadores

do banco receberam, de local indeterminado, a seguinte mensagem:

4746 − 8214 − 9372 − 9009 − 4453 − 8198

O que diz a mensagem mandada ao Banco de Toulouse?

Solu(cid:231)ªo: Para resolver esse problema devemos fatorar 10403 para obtermos φ(n).

Para isso, iremos usar o algoritmo de Fermat.

51

Aplica(cid:231)ªo

√

Seja a1 = (cid:98)

10403(cid:99) = 101. Como a2

1 (cid:54)= n temos que tomamos a2 = a1 + 1 = 102

Cap(cid:237)tulo 3

e calculamos s1 = (cid:112)a2
Portanto, temos que φ(10403) = 102 · 100 = 10200.

2 − n = 1. Logo, temos que n = (a2 + s1)(a2 − s1) = 103 · 101.

Queremos calcular r ∈ Z tal que 8743r ≡ 1 mod 10200. Assim, devemos aplicar

o algoritmo de Euclides para determinar o mdc(8743, 10200). Portanto, teremos

• 1457 = 10200 − 8743

• 1 = 8743 − 6 · 1457

Da(cid:237), obtemos

1 = 8743 − 6 · (10200 − 8743) = 7 · 8743 − 6 · 10200.

Portanto, obtemos r = 7, assim, temos que a chave de decodi(cid:28)ca(cid:231)ªo Ø kd =

(7, 10403).

Agora podemos decifrar a mensagem

kd(4746) ≡ 47467 = 4746 · (47462)3 ≡ 4746 · 20213 = 4746 · 2021 · 20212 ≡

100 · 6465 ≡ 1514 mod 10403

kd(8214) ≡ 82147 = 8214 · (82142)3 ≡ 8214 · 63413 = 8214 · 6341 · 63412 ≡

7556 · 686 ≡ 2722 mod 10403

kd(9372) ≡ 93727 = 9372 · (93722)3 ≡ 9372 · 18553 = 9372 · 1855 · 18552 ≡

1647 · 8035 ≡ 1029 mod 10403

kd(9009) ≡ 90097 = 9009 · (90092)3 ≡ 9009 · 82783 = 9009 · 8278 · 82782 ≡

7798 · 723 ≡ 9931 mod 10403

kd(4453) ≡ 44537 = 4453 · (44532)3 ≡ 4453 · 10913 = 4453 · 1091 · 10912 ≡

22 · 4339 ≡ 1831 mod 10403

52

Aplica(cid:231)ªo

Cap(cid:237)tulo 3

kd(8198) ≡ 81987 = 8198 · (81982)3 ≡ 8198 · 38243 = 8198 · 3824 · 38242 ≡

4913 · 6761 ≡ 14 mod 10403.

Portanto, a mensagem recebida pelo banco foi 1514−2722−1029−9931−1831−14,

isto Ø, 15 − 14 − 27 − 22 − 10 − 29 − 99 − 31 − 18 − 31 − 14 que signi(cid:28)ca FERMAT

VIVE.

53

Cap(cid:237)tulo 4

Criptogra(cid:28)a RSA no Ensino MØdio

Neste cap(cid:237)tulo iremos abordar a criptogra(cid:28)a RSA numa linguagem que seja pos-

s(cid:237)vel um aluno do ensino mØdio entender e aplicar esse criptossistema. Primeiro

mostaremos a matemÆtica necessÆria para a implementa(cid:231)ªo do sistema. Num se-

gundo momento, mostraremos como funciona o sistema, atravØs de dois exemplos.

4.1 MatemÆtica BÆsica

Como jÆ vimos no cap(cid:237)tulo anterior a base para a criptogra(cid:28)a RSA estÆ na arit-

mØtica dos restos. Portanto, necessitaremos calcular o resto da divisªo euclidiana.

O aluno aprende a usar o algoritmo da divisªo euclidiana desde o quarto ano do

ensino fudamental. Mas, para implementar o RSA sªo necessÆrios muitos cÆlculos,

assim, aconcelhamos o uso de uma calculadora, caso contrÆrio, o processo poderÆ

ser muito moroso.

4.1.1 Divisªo Euclidiana

Iremos ilustrar com um exemplo como proceder para encontrar o resto da divisªo

euclidiana usando uma calculadora simples. Imagine que vocŒ queira saber quanto

54

MatemÆtica BÆsica

Cap(cid:237)tulo 4

Ø o resto da divisªo de 2013 por 13. Para isso iremos executar trŒs passos:

1. Divida 2013 por 13, isto Ø, 2013

13 = 154, 846....

2. Multiplica 154 por 13, isto Ø, 154 · 13 = 2002.

3. O resto procurado Ø a diferen(cid:231)a entre 2013 e 2002, isto Ø, r = 2013−2002 = 11.

Esse procedimento para encontrar o resto da divisªo tem sua justi(cid:28)cativa formal

no seguinte teorema.

Teorema 4.1.1 (Algoritmo da Divisªo Euclidiana) Sejam a e b dois nœmeros

naturais com 0 < a < b. Nestas condi(cid:231)ıes, existem œnicos q e r nœmeros naturais

tais que

b = aq + r, com 0 ≤ r < a.

Esse Teorema foi demonstrado por Euclides, matemÆtico grego do sØculo III a.C.,

por isso Ø chamado algoritmo da divisªo euclidiana. Com esse Teorema Euclides

provou que o procedimento que (cid:28)zemos acima para encontrar o resto da divisªo

euclidiana de 2013 por 13 Ø sempre poss(cid:237)vel ser repetido para quaisquer dois nœmeros

naturais.

4.1.2 MÆximo Divisor Comum

O procedimento para calcular o mÆximo divisor comum de dois nœmeros descrito

abaixo era apresentado nos livros do sexto ano do ensino fundamental na dØcada de

1980, hoje caiu no esquecimento. Mais uma vez iremos ilustrar com um exemplo,

como calcular o mÆximo divisor comum de 2013 e 13, procedendo da seguinte forma:

1. Divida 2013 por 13, isto Ø, 2013

13 = 154, 846....

2. Escreva 11 = 2013 − 154 · 13.

55

MatemÆtica BÆsica

Cap(cid:237)tulo 4

3. Divida 13 por 11, isto Ø 13

11 = 1, 1818....

4. Escreva 2 = 13 − 1 · 11.

5. Divida 11 por 2, isto Ø, 11

2 = 5, 5.

6. Escreva 1 = 11 − 5 · 2.

7. Como 2 dividido por 1 deixa resto zero, temos que o mÆximo divisor comum

de 2013 e 13 Ø 1.

AlØm disso, devemos escrever o mÆximo divisor comum encontrado como combi-

na(cid:231)ªo linear de 2013 e 13, isto Ø, serÆ necessÆrio encontrarmos dois nœmeros naturais,

t e s, tais que 1 = 2013t−13s ou 1 = 13s−2013t. Para isso procederemos da seguinte

forma:

1. Partindo da œltima igualdade temos 1 = 11 − 5 · 2.

2. Substituindo 2 = 13−1·11 na igualdade acima obtemos 1 = 11−5·(13−1·11) =

11 − 5 · 13 + 5 · 11 = 6 · 11 − 5 · 13.

3. Substituindo 11 = 2013 − 154 · 13 na œltima igualdade acima obtemos 1 =

6 · (2013 − 154 · 13) − 5 · 13 = 6 · 2013 − 929 · 13.

4. Da(cid:237), obtemos t = 6 e s = 929.

4.1.3 CongruŒncia

Pela De(cid:28)ni(cid:231)ªo 1.1.1 apresentada no Cap(cid:237)tulo 1, temos que 2013 ≡ 13 mod 100,

pois, o resto da divisªo euclidiana de 2013 por 100 Ø 13.

Uma consequŒncia imediata da de(cid:28)ni(cid:231)ªo de congruŒncia e do algoritmo da divisªo

euclidiana Ø que, dado qualquer nœmero natural a, esse nœmero serÆ congruente

m(cid:243)dulo n a um œnico nœmero natural b tal que 0 ≤ b < n.

56

Criptogra(cid:28)a RSA

Cap(cid:237)tulo 4

Vejamos como calcular a seguinte potŒncia 3744 ≡ x mod 120, entªo procedemos

como segue:

1. Escrevemos 3744 = (372)22

2. Calculamos 372 = 1369 e tomamos o resto da divisªo euclidiana por 120, isto

Ø, 1369 − 11 · 120 = 49.

3. Escrevemos (372)22 = 136922 ≡ 4922 = (492)11 mod 120

4. Calculamos 492 = 2401 e tomamos o resto da divisªo euclidiana por 120, isto

Ø, 2401 − 20 · 120 = 1.

5. Escrevemos 3744 = (372)22 = 136922 ≡ 4922 = (492)11 = 240111 ≡ 111 = 1

mod 120. Logo, temos que 3744 ≡ 1 mod 120.

Estamos preparados para implementar o sistema RSA. Aqui abordamos toda a

matemÆtica necessÆria na implementa(cid:231)ªo do sistema RSA. (cid:201) claro que a matemÆtica

que garante o funcionamento do sistema, bem como a matemÆtica que garante sua

seguran(cid:231)a Ø bem mais so(cid:28)sticada e foi parcialmente abordada nos cap(cid:237)tulos 1 e 2

deste trabalho.

4.2 Criptogra(cid:28)a RSA

Nos exemplos abaixo iremos usar o nœmero 99 para representar o espa(cid:231)o em
branco entre as palavras e a correspondŒncia entre o alfabeto F = {A, B, C, . . . , Z}

e o conjunto {10, 11, 12, . . . , 35}, como segue abaixo:

A B C D E F G H I

J K L M

10 11 12 13 14 15 16 17 18 19 20 21 22

57

Criptogra(cid:28)a RSA

Cap(cid:237)tulo 4

N O P Q R S T U V W X Y Z

23 24 25 26 27 28 29 30 31 32 33 34 35

Iremos ilustrar com dois exemplos, o funcionamento do sistema RSA.

Exemplo 4.2.1 Queremos codi(cid:28)car e decodi(cid:28)car a seguinte mensagem: SEJA FE-

LIZ.

Solu(cid:231)ªo: Vamos transformar a mensagem em uma sequŒncia numØrica atravØs da

correspondŒncia dada no in(cid:237)cio dessa Se(cid:231)ªo, onde o nœmero 10 corresponde a letra

A, por exemplo. Portanto a mensagem serÆ 28141910991514211835.

Para chave de codi(cid:28)ca(cid:231)ªo vamos escolher n = 11 · 13 = 143 e t = 77. Assim,

temos que kc = (77, 143) Ø a chave de codi(cid:28)ca(cid:231)ªo que iremos usar.

Como φ(143) = (11 − 1)(13 − 1) = 120 devemos quebrar o nœmero que forma

a mensagem em blocos de modo que cada bloco m, com 1 < m < φ(143) = 120,

seja diferente de qualquer unidade lingu(cid:237)stica. Assim, uma poss(cid:237)vel quebra seria:

2 − 81 − 41 − 9 − 109 − 91 − 51 − 42 − 11 − 83 − 5.

Vamos agora codi(cid:28)car a mensagem original.

kc(2) = 277 = (211)7 = 20487 ≡ 467 = 46 · (462)3 = 46 · 21163 ≡ 46 · 1143 =

46 · 114 · 1142 = 5244 · 12996 ≡ 96 · 126 = 12096 ≡ 84 mod 143.

kc(81) = 8177 = 81·(812)38 = 81·656138 ≡ 81·12638 = 81·(1262)19 = 81·1587619 ≡

81 · 319 = 81 · 3 · (36)3 = 243 · 7293 ≡ 100 · 143 = 1400 · 196 ≡ 113 · 53 = 5989 ≡ 126

mod 143.

kc(41) = 4177 = 41 · (412)38 = 41 · 168138 ≡ 41 · (1082)19 = 41 · 1166419 ≡

41·81·(812)9 = 3321·65619 ≡ 32·126·(1262)4 = 4032·158764 = 28·34 = 2268 ≡ 123

mod 143.

58

Criptogra(cid:28)a RSA

Cap(cid:237)tulo 4

kc(9) = 977 = 92·(93)25 = 81·72925 ≡ 81·14·(142)12 = 1134·19612 ≡ 133·(532)6 =

133 · 28096 ≡ 133 · 926 = 133 · (922)3 = 133 · 84643 ≡ 133 · 273 = 133 · 27 · 272 =

3591 · 729 ≡ 16 · 14 = 224 ≡ 81 mod 143.

kc(109) = 10977 = 109 · (1092)38 = 109 · 1188138 ≡ 109 · (122)19 = 109 · 14419 ≡

109 · 119 = 109 mod 143

kc(91) = 9177 = 91 · (912)38 = 91 · 828138 ≡ 91 · (1302)19 = 91 · 1690019 ≡

91 · 26 · (262)9 = 2366 · 6769 ≡ 78 · 104 · (1042)4 = 8112 · 108164 ≡ 104 · 914 =

104 · (912)2 = 104 · 82812 ≡ 104 · 1302 = 1757600 ≡ 130 mod 143.

kc(51) = 5177 = 51·(512)38 = 51·260138 ≡ 51·(272)19 = 51·72919 ≡ 51·14·(142)9 =

714 · 1969 ≡ 142 · 53 · (532)4 = 7526 · 28094 ≡ 90 ·( 922)2 = 90 · 84642 ≡ 90 · 272 =

65610 ≡ 116 mod 143.

kc(42) = 4277 = 42 · (422)38 = 42 · 176438 ≡ 42 · (482)19 = 42 · 230419 ≡ 42 · 16 ·

(162)9 = 672 · 2569 ≡ 100 · 113 · (1132)4 = 11300 · 127694 ≡ 3 · (422)2 = 3 · 17642 ≡

3 · 482 = 6912 ≡ 48 mod 143.

kc(11) = 1177 = 112 ·(113)25 = 121·133125 ≡ 121·44·(442)12 = 5324·193612 ≡ 33·

(772)6 = 33·59296 ≡ 33·(662)3 = 33·43563 ≡ 33·66·662 = 2178·4356 ≡ 33·66 =≡ 33

mod 143.

kc(83) = 8377 = 83·(832)38 = 83·688938 ≡ 83·(252)19 = 83·62519 ≡ 83·53·(532)9 =

4399 · 28099 ≡ 109 · 92 · (922)4 = 10028 · 84644 ≡ 18 ·( 272)2 = 18 · 7292 ≡ 18 · 142 =

3528 ≡ 96 mod 143.

kc(5) = 577 = 5 · (54)19 = 5 · 62519 ≡ 5 · 53 · (532)9 = 265 · 28099 = 122 · 92 · (922)4 =

11224 · 84644 ≡ 70 · (272)2 = 70 · 142 = 13720 ≡ 135 mod 143.

Portanto, a mensagem codi(cid:28)cada tem a seguinte sequŒncia de blocos: 84 − 126 −

123 − 81 − 109 − 130 − 116 − 48 − 33 − 96 − 135. Pr(cid:243)ximo passo encontrar a chave

59

Criptogra(cid:28)a RSA

de decodi(cid:28)ca(cid:231)ªo.

Cap(cid:237)tulo 4

Como φ(n) = (11 − 1) · (13 − 1) = 120 devemos encontrar um nœmero natural r,
tal que 77r ≡ 1 mod 120, isto Ø, 77r − 120i = 1, para algum i ∈ N. Assim, devemos

calcular o mdc(77, 120).

• 43 = 120 − 77

• 34 = 77 − 43

• 9 = 43 − 34

• 7 = 34 − 3 · 9

• 2 = 9 − 7

• 1 = 7 − 3 · 2

Fazendo sucessivas substitui(cid:231)ıes nas igualdades acima e percorrendo o sentido

de baixo para cima, obtemos o seguinte resultado:

• 1 = 7 − 3 · (9 − 7) = 7 − 3 · 9 + 3 · 7 = 4 · 7 − 3 · 9

• = 4 · (34 − 3 · 9) − 3 · 9 = 4 · 34 − 15 · 9

• = 4 · 34 − 15 · (43 − 34) = 19 · 34 − 15 · 43

• = 19 · (77 − 43) − 15 · 43 = 19 · 77 − 34 · 43

• = 19 · 77 − 34 · (120 − 77) = 53 · 77 − 34 · 120.

Portanto, obtemos 1 = 53 · 77 − 34 · 120, isto Ø, r = 53. Logo, temos que

kd = (53, 143) Ø a chave de decodi(cid:28)ca(cid:231)ªo.

60

Criptogra(cid:28)a RSA

Cap(cid:237)tulo 4

Vamos agora decodi(cid:28)car os blocos: 84 − 126 − 123 − 81 − 109 − 130 − 116 − 48 −

33 − 96 − 135. Se nossos cÆlculos estiverem certos devemos encontrar como resultado

a seguinte sequŒncia: 2 − 81 − 41 − 9 − 109 − 91 − 42 − 11 − 83 − 5.

kd(84) = 8453 = 84 · (842)26 = 84 · 705626 ≡ 84 · (492)13 = 84 · 240113 ≡ 84 · 113 ·

(1132)6 = 9492 · 127696 ≡ 54 · (422)3 = 54 · 17643 ≡ 54 · 48 · 482 = 2592 · 2304 ≡

18 · 16 = 288 ≡ 2 mod 143.

kd(126) = 12653 = 126 · (1262)26 = 126 · 1587626 ≡ 126 · 32 · (36)4 = 1134 · 7294 ≡

133 · (142)2 = 133 · 1962 ≡ 133 · 532 = 373597 ≡ 81 mod 143.

kd(123) = 12353 = 123 · (1232)26 = 123 · 1512926 ≡ 123 · (1142)13 = 123 · 1299613 ≡

123 · 126 · (1262)6 = 15498 · 158766 ≡ 54 · 36 = 39366 ≡ 41 mod 143.

kd(81) = 8153 = 81 · (812)26 = 81 · 656126 ≡ 81 · (1262)13 = 81 · 1587613 ≡

81 · 36 · 37 = 59049 · 2187 ≡ 133 · 42 = 5586 ≡ 9 mod 143.

kd(109) = 10953 = 109 · (1092)26 = 109 · 1188126 ≡ 109 · (122)13 = 109 · 14413 ≡

109 · 113 = 109 mod 143.

kd(130) = 13053 = 130 · (1302)26 = 130 · 1690026 ≡ 130 · (262)13 = 130 · 67613 ≡

130 · 104 · (1042)6 = 13520 · 108166 ≡ 78 · (912)3 = 78 · 82813 ≡ 78 · 130 · 1302 =

10140 · 16900 ≡ 130 · 26 = 3380 ≡ 91 mod 143.

kd(116) = 11653 = 116·(1162)26 = 116·1345626 ≡ 116·(142)13 = 116·53·(532)6 =

6148 · 28096 ≡ 142 · (922)3 = 142 · 84643 ≡ 142 · 27 · 272 = 3834 · 729 ≡ 116 · 14 =

1624 ≡ 51 mod 143.

kd(48) = 4853 = 48 · (482)26 = 48 · 230426 ≡ 48 · (162)13 = 48 · 25613 ≡ 48 · 113 ·

(1132)6 = 5424 · 127696 ≡ 133 · (422)3 = 133 · 17643 ≡ 133 · 48 · 482 = 6384 · 2304 ≡

92 · 16 = 1472 ≡ 42 mod 143.

61

Criptogra(cid:28)a RSA

Cap(cid:237)tulo 4

kd(33) = 3353 = 33 · (332)26 = 33 · 108926 ≡ 33 · (882)13 = 33 · 774413 ≡

33 · 22 · (222)6 = 726 · 4846 ≡ 11 · (552)3 = 11 · 30253 ≡ 11 · 22 · 222 = 242 · 484 ≡

99 · 55 = 5445 ≡ 11 mod 143.

kd(96) = 9653 = 96 · (962)26 = 96 · 921626 ≡ 96 · (642)13 = 96 · 409613 ≡

96 · 92 · (922)6 = 8832 · 84646 ≡ 109 · (272)3 = 109 · 7293 ≡ 109 · 14 · 142 = 1526 · 196 ≡

96 · 53 = 5088 ≡ 83 mod 143.

kd(135) = 13553 = 135 · (1352)26 = 135 · 1822526 ≡ 135 · (642)13 = 135 · 409613 ≡

135·92·(922)6 = 12420·84646 ≡ 122·(272)3 = 122·7293 ≡ 122·14·142 = 1708·196 ≡

135 · 53 = 7155 ≡ 5 mod 143.

Portanto, a mensagem decodi(cid:28)cada tem a seguinte sequŒncia de blocos: 2 − 81 −

41 − 9 − 109 − 91 − 51 − 42 − 11 − 83 − 5. Assim, a mensagem original Ø formada

pelas dezenas: 28 − 14 − 19 − 10 − 99 − 15 − 14 − 21 − 18 − 35, que ap(cid:243)s aplicarmos

a correspondŒncia dada no in(cid:237)cio dessa Se(cid:231)ªo obtemos a frase: SEJA FELIZ.

Exemplo 4.2.2 A mensagem 51 − 307 − 269 − 365 − 71 − 158 foi codi(cid:28)cada pelo

sistema RSA usando chave kc = (169, 391). Sabendo que φ(391) = 352 decodi(cid:28)que

a mensagem.

Solu(cid:231)ªo: Devemos encontrar a, b ∈ N tais que 352a − 169b = 1.

• 14 = 352 − 2 · 169

• 1 = 169 − 12 · 14

Portanto, obtemos 1 = 169 − 12 · (352 − 2 · 169) = 25 · 169 − 12 · 352.

Isto

Ø, b = 25. Logo, temos que kd = (25, 391) Ø a chave de decodi(cid:28)ca(cid:231)ªo. Vamos

decodi(cid:28)car a mensagem 51 − 307 − 269 − 365 − 71 − 158.

62

Criptogra(cid:28)a RSA

Cap(cid:237)tulo 4

kd(51) = 5125 = 51 · (513)8 = 51 · 1326518 ≡ 51 · (1022)4 = 51 · 104044 ≡

51 · (2382)2 = 51 · 566442 ≡ 51 · 3402 = 51 · 115600 ≡ 51 · 255 = 13005 ≡ 102

mod 391.

kd(307) = 30725 = 307 · (3072)12 = 307 · 9424912 ≡ 307 · (184)3 = 307 · 1049763 ≡

307 · 188 · 1882 = 57716 · 35344 ≡ 239 · 154 = 36806 ≡ 52 mod 391.

kd(269) = 26925 = 269 · (2692)12 = 269 · 7236112 ≡ 269 · (263)4 = 269 · 175764 ≡

269 · (3722)2 = 269 · 1383842 ≡ 269 · 3612 = 269 · 130321 ≡ 269 · 118 = 31742 ≡ 71

mod 391.

kd(365) = 36525 = 365 · (3652)12 = 365 · 13322512 ≡ 365 · (2852)6 = 365 · 812256 ≡

365 · (2882)3 = 365 · 829443 ≡ 365 · 523 = 365 · 140608 ≡ 365 · 239 = 87235 ≡ 42

mod 391.

kd(71) = 7125 = 71 · (713)8 = 71 · 3579118 ≡ 71 · (1462)4 = 71 · 213164 ≡

71 · (2022)2 = 71 · 408042 ≡ 71 · 1402 = 71 · 19600 ≡ 71 · 50 = 3550 ≡ 31 mod 391.

kd(158) = 15825 = 158 · (1582)12 = 158 · 2496412 ≡ 158 · (3312)6 = 158 · 1095616 ≡

158 · (813)2 = 158 · 5314412 ≡ 158 · 722 = 819072 ≡ 318 mod 391.

Portanto, a mensagem decodi(cid:28)cada tem a seguinte sequŒncia de blocos: 102 −

52 − 71 − 42 − 31 − 318. Assim, a mensagem original Ø formada pelas dezenas:

10 − 25 − 27 − 14 − 23 − 13 − 18, que ap(cid:243)s aplicarmos a correspondŒncia dada no

in(cid:237)cio dessa Se(cid:231)ªo obtemos a frase: APRENDI.

63

ReferŒncias BibliogrÆ(cid:28)cas

[1] Ribenboim, P., Nœmeros Primo. Velhos MistØrios e Novos Recordes, 1 ed. Rio

de Janeiro: IMPA 328 pp. (2012).

[2] Coutinho, S. C., Nœmeros Inteiros e Criptogra(cid:28)a RSA, 2 ed. Rio de Janeiro:

IMPA 226 pp. (2011).

[3] Hefez, A., Elementos de AritmØtica, 2 ed. Rio de Janeiro: IMPA 169 pp. (2006).

[4] Martinez, F. B., Moreira, C. G., Tengan, E., Teoria dos Nœmeros: Um Passeio

Com Primos e Outros Nœmeros Familiares Pelo Mundo Inteiro, 1 ed. Rio de

Janeiro: IMPA 450pp (Projeto Euclides). (2010).

[5] Gon(cid:231)alves, A., Introdu(cid:231)ªo (cid:224) `lgebra, 5 ed. Rio de Janeiro: IMPA 194 pp (Pro-

jeto Euclides). (2006)

[6] Santos J. P. O., Introdu(cid:231)ªo (cid:224) Teoria dos Nœmeros, 3 ed. Rio de Janeiro: IMPA

198 pp (Cole(cid:231)ªo MatemÆtica UniversitÆria). (2010).

[7] Silva, A. de A. e, Nœmeros, Rela(cid:231)ıes e Criptogra(cid:28)a, Texto usado pelo autor na

disciplina MatemÆtica Elementar na UFPB, 186pp.

[8] Souza, B. A., Teoria dos Nœmeros e o RSA, Disserta(cid:231)ªo de Mestrado apresen-

tada ao Instituto de MatemÆtica, Estat(cid:237)stica e Computa(cid:231)ªo Cient(cid:237)(cid:28)ca, UNI-

CAMP, (2004).

64

