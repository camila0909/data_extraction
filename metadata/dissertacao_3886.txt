UNIVERSIDADE FEDERAL DO RECÔNCAVO DA BAHIA

CENTRO DE CIÊNCIAS EXATAS E TECNOLÓGICAS

MESTRADO EM MATEMÁTICA

ARITMÉTICA MODULAR
NOS CÓDIGOS DE BARRAS

LUCIANA MOTA CERQUEIRA

CRUZ DAS ALMAS
2015

ARITMÉTICA MODULAR
NOS CÓDIGOS DE BARRAS

LUCIANA MOTA CERQUEIRA

Trabalho de conclusão de curso apresentado ao
curso de Mestrado Proﬁssional em Matemática
do Centro de Ciências Exatas e Tecnológicas da
Universidade Federal do Recôncavo da Bahia e a
Sociedade Brasileira de Matemática, como parte
dos requisitos para a obtenção do título de mes-
tre.

Orientador: Profo Dr. Eleazar Gerardo Madriz Lozada

CRUZ DAS ALMAS
2015

Aos meus pais,
às minhas irmãs, meu irmão e à minha noiva
com muito amor.

"Agradeço todas as diﬁculdades que enfrentei;
não fosse por elas,
eu não teria saído do lugar.
As facilidades nos impedem de caminhar.
Mesmo as críticas,
pois nos auxiliam muito."
Chico Xavier

AGRADECIMENTOS

A Deus, fonte de Luz e Sabedoria, que sempre está ao meu lado, dando-me força e perseve-

rança em minhas realizações.

Aos meus pais, que sempre foram alicerces em minha jornada. Às minhas irmãs Sandra e
Lucélia, pelo amor e companheirismo, e ao meu irmão Luciano Júnior, por caminharmos lado-
lado nessa batalha, ajudando-me e compartilhando das mesmas emoções.

À minha noiva Jamile, pela paciência, cumplicidade, companheirismo e sabedoria.

Ao meu orientador professor Eleazar Madriz, pela paciência, competência e sabedoria.

A todos os professores do PROFMAT, pólo UFRB, que participaram desse projeto, pela

competência, paciência e dedicação.

Aos meus queridos colegas de turma do PROFMAT 2012, pelo incentivo, carinho, compa-

nheirismo, alegrias e pelas trocas valiosas de experiências.

A todos amigos e colegas que direta ou indiretamente contribuíram para a realização deste

trabalho, os meus sinceros agradecimentos.

RESUMO

Devido às suas características de baixo custo, facilidade de implantação, utilização e, princi-
palmente, a qualidade de informação e redução de tempo de operação dos sistemas, os códigos
de barras têm sido usados desde pequenas atividades que necessitam de identiﬁcação de do-
cumentos à comercialização e controle de produtos. Daí a utilização dos códigos de barras é
algo pertinente ao nosso dia-a-dia, bem como no âmbito escolar. Identiﬁcar, através do número
do código de barras, a origem, o fabricante e o tipo de produto, são tarefas que podem ser apli-
cadas na escola. Os códigos de barras, no Brasil utilizam-se os códigos EAN-13, que contêm 13
dígitos, sendo o último dígito aquele que veriﬁca os 12 anteriores, de modo que, se um desses
for digitado incorretamente, certamente o produto não será identiﬁcado. Isso é devido ao pro-
cesso de veriﬁcação do erro, onde utiliza-se a matemática, em especial a aritmética modular e
o produto vetorial. Neste trabalho evidenciamos como os códigos de barras são uma aplicação
da matemática interessante, que pode ser aplicada, de forma fácil e estimuladora, aos alunos
dos ensinos fundamental II e médio.

Palavras-chave: Códigos de barras, Dígito de veriﬁcação, Aritmética Modular

ABSTRACT

Due to its characteristics: low price, facility of implementation and use and, mainly, the qua-
lity of information and reduction of operation time of systems, the bar codes are being used for
small and big activities such as the ones that need identiﬁcation documents and commerciali-
zation and control of products. This way bar codes usage is something very important to our
routine and school environment. Identify the origin, producer and kind of product through bar
codes are tasks that can be applied at school. The bar codes used in Brazil are codes EAN-13,
with 13 digits, the last one being the digit that veriﬁes the other 12 before, in a way that if one
of these ﬁrst digits is typed in a wrong way, certainly the product is not going to be identiﬁed.
This is due to the veriﬁcation process of the mistake, where we use the mathematics, especially
the modular arithmetic and the vector product. In this project we enhance how interesting
is the mathematics application of bar codes, being applied in an easy and stimulating way to
elementary and high school students.

Keywords: Bar codes, Veriﬁcation digit, Modular arithmetic.

SUMÁRIO

Introdução

1 Preliminares

.

.

.

.

.

1.1 Divisibilidade .
.
1.2 Máximo Divisor Comum .
.
1.3 Números Primos
.
1.4 Congruências . .

.
.
1.4.1 Propriedades das Congruências

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.

.
.

.
.

.
.

2 Os Códigos de Barras

2.1 O que são códigos de barras? . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . .
2.2 Composição de um Código de Barras Linear

.
.
2.2.1 As Partes do Código de Barras . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 O Código UPC-A .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 O Código EAN-13 .
2.5 Como é feita a leitura do Código de Barras
. . . . . . . . . . . . . . . . . . . . .
2.6 Codiﬁcação do Código de Barras UPC-A . . . . . . . . . . . . . . . . . . . . . .
.
2.7 Codiﬁcação do Código de Barras EAN-13 . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

.
.

.
.

3 Detecção de Erros

Sistemas de Identiﬁcação Modular (SIM)

3.1
3.2 O Dígito Veriﬁcador .

.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.1 O Dígito Veriﬁcador do Código EAN-13 . . . . . . . . . . . . . . . . . . .
3.2.2 O Dígito Veriﬁcador do Código UPC-A . . . . . . . . . . . . . . . . . . .
3.3 Detectando Erros .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Generalização dos Detectores de Erros . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

.

.

.

.

.

.

.

.

.

9

12

15
. 15
. 18
. 20
. 20
. 21

25
. 25
. 27
. 27
. 29
. 29
. 30
. 31
. 33

36
. 36
. 38
. 38
. 40
. 42
. 46

4 Atividades Propostas

. .

. .
.

4.1 Atividade 1 - Reconhecendo um Código de Barras . . . . . . . . . . . . . . . . .
4.1.1 Objetivo Geral . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.2 Objetivos Especíﬁcos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.3 Público Alvo .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.4 Pré-Requisitos .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.5 Materiais Necessários
4.1.6 Proposta da Atividade . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
4.2.1 Objetivo Geral . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 Objetivos Especíﬁcos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.3 Público Alvo .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.4 Pré-Requisitos .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.5 Materiais Necessários
4.2.6 Proposta da Atividade . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.2 Atividade 2 - Cálculo do Dígito Veriﬁcador . . . . . . . . . . . . . . . . . . . .

. .
.

. .

Referências

56
. 56
. 56
. 56
. 57
. 57
. 57
. 57
. 58
. 58
. 59
. 59
. 59
. 59
. 59

63

LISTA DE FIGURAS

.
.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 26
. 26

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

. 27

2.1 Códigos 1D e 2D .
.
2.2 Códigos Bidimensionais .

.

.

.

2.3 Códigos Lineares .

.

.

.

.

2.4 Exemplo de Códigos Lineares . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 27

2.5 Composição do Código de Barras 1 . . . . . . . . . . . . . . . . . . . . . . . . . .
2.6 Composição do Código de Barras 2 . . . . . . . . . . . . . . . . . . . . . . . . . .

. 28
. 28

2.7 Código UPC-A .

2.8 Código EAN-13 .

.

.

.

.

.

.

.

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 29

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 30

2.9 Exemplo de Scanner
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.10 Exemplo de código UPC-A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

.

. 30
. 31

2.11 Codiﬁcação dos códigos .

2.12 Codiﬁcação do EAN-13 .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 31

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 35

3.1 Cálculo do Dígito Veriﬁcador no Código EAN-13 . . . . . . . . . . . . . . . . . .

. 39

3.2 Dígito Veriﬁcador do Código UPC-A . . . . . . . . . . . . . . . . . . . . . . . . .

. 41

3.3 Código ISBN .

.

.

.

.

.

.

4.1 Exemplo da Atividade I

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 50

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 58

INTRODUÇÃO

O surgimento dos códigos de barras devem-se, em especial, às atividades comerciais, onde
o preço de cada produto era colocado manualmente e, quando vendido, tinha que ser digitado

numa máquina pela operadora, o que ocasionava um processo lento e passível a erros. Daí,

diante desse problema de logística, um dono de supermercado sugeriu a uma universidade

que resolvesse esse problema, surgindo assim, nessa busca, o código de barras.

Por causa das suas características de baixo custo, facilidade de implantação, utilização e

principalmente a qualidade de informação e redução de tempo de operação dos sistemas, o

código de barras tem sido usado na automação desde pequenas atividades que necessitam de
identiﬁcação de documentos até a comercialização e controle de produtos.

O surgimento do primeiro código de barras data de Outubro de 1949. Era formado por qua-

tro linhas brancas sobre um fundo preto, depois convertido em círculos com mesmos centros
para facilitar a leitura, a partir de qualquer ângulo. Quanto mais linhas se adicionassem, mais

informação podia ser codiﬁcada. Assim, em 1952 a primeira patente de um código de barras

foi registrada por Bernard Silver e Norman Joseph Woodland.

Porém, esse acontecimento só teve seu real valor reconhecido quando, após várias décadas,

o aumento dos componentes eletrônicos e avanços na tecnologia a laser permitiram a produção

de sistemas de leitura de baixo custo.

12

Dentre as diversas ﬁrmas solicitadas para que elaborassem um código adequado e viável,

que pudesse ser utilizado no dia-a-dia, quem acabou apresentando o resultado mais viável foi

Gerge J. Laurer, engenheiro do International Business Machines (IBM).

O primeiro código de barras foi utilizado em 1974 e foi chamado de Código Universal de

Produtos, com sigla UPC (Universal Product Code).Este código é adotado atualmente nos Es-

tados Unidos e Canadá. Ele consiste de uma sequência de 12 dígitos, traduzidos para barras

da forma que estamos acostumados a ver em vários objetos ou itens.

Em decorrência do grande sucesso do código UPC, fabricantes e distribuidores de vários

países da Europa formaram um conselho para estudar a possibilidade de desenvolver um sis-

tema que padronizasse a numeração de produtos, parecido ao sistema do UPC, que é regu-
lamentado pelo UCC (Uniform Code Council). Em 1977, formou-se uma entidade sem ﬁns

lucrativos, a EAN (European Article Numbering Association) para atender esta demanda.

A elaboração do código EAN deparou-se com um problema bastante delicado, que era o
de ser necessário adicionar um dígito a cada código com a ﬁnalidade de identiﬁcar o país de

origem, já que tal tecnologia seria expandida por todo o mundo. O problema era fazer isto de

forma que a mesma máquina leitora pudesse ler, sem distinção, os códigos UPC e EAN.

A solução encontrada foi à seguinte: os países que utilizavam o código UPC antigo, EUA

e Canadá, são identiﬁcados com um 0 (zero), na frente, resultando no novo código UPC-A (o

mesmo código UPC, apenas com um zero antes para identiﬁcar os países que já utilizavam

o código UPC, Estados Unidos e Canadá), e o resto da codiﬁcação é feita utilizando o sistema
anterior. Para outros países, os primeiros dois ou três dígitos (da esquerda para a direita), iden-

tiﬁcam o país.

O código utilizado no Brasil é o EAN (European Article Number), que possui os primei-
ros três dígitos identiﬁcando o país. Todos os produtos produzidos no Brasil começam com a

sequência 789. Alguns países adotam este mesmo sistema, dando-lhe outro nome. Por exem-

plo, no Japão o sistema é conhecido como JAN (Japanese Article Numbering).

Observando que a matemática presente nos códigos de barras é a mesma apresentada nos

13

ensinos fundamental e médio e acreditando que contextualizando os conceitos matemáticos

com o objeto de estudo, algo que já faz parte do cotidiano do aluno, é possível por em prática,

nas salas de aula, algo abstrato.

A utilização dos códigos de barras como objeto de pesquisa e de aprendizagem matemática

é rica no sentido de envolver alunos em diferentes níveis de ensino.

Neste trabalho utilizaremos apenas os códigos de barras que identiﬁcam produtos, que são

os códigos UPC-A e EAN-13.

Este trabalho está dividido em 4 capítulos, sendo o primeiro destinado aos conteúdos ma-

temáticos fundamentais para o desenvolvimento desse trabalho. Tais como Divisibilidade,
Máximo Divisor Comum, Números Primos, Congruências e Produto Escalar Vetorial.

O segundo capítulo é destinado aos Códigos de Barras, contendo: Deﬁnições e composição

de um código de barras; Como são feitas as leituras desses códigos de barras e o processo de
codiﬁcação dos códigos UPC-A e EAN-13.

O terceiro capítulo é destinado à detecção de erros, contendo os Sistemas de Identiﬁcação

Modular (SIM) e sobre o Dígito Veriﬁcador .

No quarto capítulo são propostas atividades com o tema, incluindo sequências didáticas

e suas respectivas soluções, que podem ser aplicadas para alunos do ensino fundamental II e

médio.

14

CAPÍTULO 1

PRELIMINARES

PARA a realização deste trabalho, faz-se necessário deﬁnir alguns conceitos e propriedades

da Teoria dos Números, em especial a Aritmética Modular. As deﬁnições e propriedades
aqui deﬁnidas e demonstradas estão de acordo com [1] , [2], [3] e [4]. Denotaremos por Z o
conjunto dos números inteiros e consideremos suas operações de adição e multiplicação, com

sua relação de ordem e propriedades.

1.1 Divisibilidade

O conceito de divisibilidade e suas propriedades serão fundamentais para o desenvolvi-

mento deste trabalho.

Deﬁnição 1.1. (Módulo ou Valor Absoluto) Para todo m ∈ Z, deﬁne-se módulo ou valor absoluto de
m, denota-se |m|, através das seguintes condições:

|m| = m, se m (cid:62) 0

e

|m| = −m, se m < 0

Em particular, |m| = 0 se, e somente se, m = 0.

15

Deﬁnição 1.2. Sejam dois números inteiros x e y, com x (cid:54)= 0, diz-se que x divide y, escreve-se x|y, se
existe um inteiro z tal que y = xz. Podemos escrever, também, que x é divisor de y ou y é divisível por
x.

No caso em que x não divide y, escreve-se x (cid:45) y.

Exemplo 1.1. Podemos aﬁrmar que 3|6 pois, 6 = 2.3, enquanto 3 (cid:45) 7 pois não existe nenhum inteiro z
que satisfaça a igualdade 7 = 3.z.

Nas proposições a seguir, apresentamos as propriedades da divisibilidade que serão utili-

zadas nesse trabalho.

Proposição 1.1. Sejam os inteiros x, y e z, com x (cid:54)= 0 . Tem-se que:

• i) x|x

• ii) se x|y e y|x, então |x| = |y|

• iii) se x|y e y|z, então x|z

• iV) se x|y e x|z, então x|(y + z)

• v) se x|y , x|z e y (cid:62) z, então x|(y − z)

Demonstração:
i), ii) e iii) Ver propriedades d1,d2 e d3 em [1], página 31.

iv) e v) Ver proposição 3.1.3 e 3.1.4 em [2] páginas 31 e 32.

Proposição 1.2. Sejam os inteiros a, b, x, y e z, com x (cid:54)= 0. Tem-se que:

• i) Se x|y, então x|yz.

• ii) Se x|y e x|z , então x|(ay + bz).

16

(cid:4)

Demonstração:
i) Se x|y, implica que existe um inteiro k tal que y = x.k. Multiplicando-se a igualdade por

z, teremos:

y.z = x.k.z ⇒ y.z = x.(k.z) ⇒ x|yz

ii) Pela hipótese, x|y implica que existe um inteiro k1 tal que y = k1.x e x|z implica que

existe um inteiro k2 tal que z = k2.x. Daí, temos:

y = k1.x ⇒ ay = ak1x

e

z = k2.x ⇒ bz = bk2x

Somando-se as igualdades, teremos:

ay + bz = ak1x + bk2x = x(ak1 + bk2) ⇒ x|(ay + bz)

(cid:4)

Proposição 1.3. Sejam os inteiros x, y, z e w, com x (cid:54)= 0 e z (cid:54)= 0. Tem-se que, se x|y e z|w, então
(x.z)|(y.w) .

Demonstração: Ver em proposição 3.1.2 em [2], página 31.

Proposição 1.4. Sejam os inteiros x e y, com y (cid:54)= 0. Tem-se que se x|y, então |x| (cid:54) |y|.

Demonstração: Ver proposição 3.1.6 em [2], página 32.

(cid:4)

Nem sempre um inteiro x divide a outro inteiro y, porém com o próximo teorema, que
é conhecido como Algoritmo da divisão ou Algoritmo de Euclides, veremos como trabalhar

quando temos dois números e que um não é divisível pelo outro.

Teorema 1.1. Sejam x e y dois inteiros, com y > 0. Existem dois únicos números inteiros q e r, tais que

y = x.q + r , com 0 (cid:54) r < x

17

Os elementos q e r são denominados, respectivamente, de quociente e resto da divisão de x

por y.

Demonstração:

Ver Teorema 1, páginas 102 e 103 em [1] ou Teorema 3.2.1, páginas 35 e 36 em [2].

(cid:4)

1.2 Máximo Divisor Comum

Deﬁnição 1.3. Sejam os inteiros x e y. Um número inteiro positivo d diz-se máximo divisor comum de
x e y, denotado por mdc(x, y), se veriﬁca:

i) d|a e d|b;

ii) Se existe um inteiro z, de modo que z|x e z|y, então z|d, donde z (cid:54) d.

A partir da Deﬁnição 1.3, podemos deﬁnir quando dois números serão denominados pri-

mos entre si.

Deﬁnição 1.4. Dois números inteiros x e y são denominados primos entre si se mdc(x, y) = 1.

Proposição 1.5. Sejam dois inteiros x e y, temos que se x = yq + r e d = mdc(x, y), então
d = mdc(y, r).

Demonstração:

Por hipótese, temos que d = mdc(x, y), logo d|x e d|y.

Como d|y, implica que d|yq.

Note que x = yq + r é o mesmo que x − yq = r

Portanto, como d|x e d|yq, pela Proposição 1.1, item (v), temos que d|(x − yq), ou seja, d|r.

Proposição 1.6. Se d = mdc(x, y), então mdc(ax, ay) = ad, para todo a ∈ N.

18

Demonstração: Aplicando o Teorema 1.1 a x e y, e fazendo divisões sucessivas até obtermos

resto zero, temos que:

x = yq1 + r1

y = r1q2 + r2

· · ·

rn−2 = (rn−1)qn + rn

rn−1 = (rn)qn+1

Multiplicando-se as equações anteriores por a, membro-a-membro, temos:

ax = ayq1 + ar1

ay = ar1q2 + ar2

· · ·

arn−2 = (arn−1)qn + arn

arn−1 = (arn)qn+1

Então, pela Proposição 1.5, temos que:

ad = arn = mdc(arn−1, arn) = · · · = mdc(ay, ar1) = mdc(ax, ay)

(cid:4)

Proposição 1.7. Sejam x, y e z ∈ Z. Se x|yz e mdc(x, y) = 1, então x|z.

Demonstração:
Como, por hipótese, temos que mdc(x, y) = 1, pela Proposição 1.6, temos que

mdc(xz, yz) = z. Por outro lado, temos que x|yz, logo x|xz. Daí, x|mdc(xz, yz), o que implica
x|z.

(cid:4)

19

1.3 Números Primos

A importância dos números primos reside em um resultado central na teoria de números:
aﬁrmar que todo número inteiro natural, maior do que 1, pode ser escrito como um produto

de fatores primos.

Os números primos possuem signiﬁcativa parcela de importância nos teoremas envolvendo

os erros de veriﬁcação dos códigos de barras.

Deﬁnição 1.5. Um número inteiro positivo p, diferente de 0 e 1, ou seja, p (cid:62) 2 e que é divisível apenas
por 1 e por si próprio é chamado número primo.

No caso em que o número não seja primo, dizemos que ele é composto.

Proposição 1.8. Seja p primo e x e y inteiros. Se p | xy então p | x ou p | y.

Demonstração:
Vamos supor que x (cid:54)= 0 e y (cid:54)= 0. No caso em que x = 0 ou y = 0, o resultado é imediato,

pois p|0.

Admitiremos que p (cid:45) x. De fato, dado um inteiro c, tem-se que c|x e c|p, então c = 1 ou

c = p, pois p é primo.

Porém, como p (cid:45) x, temos que c = 1, pois c = p implica p | x. A Proposição 1.7 nos garante

que p|y.

(cid:4)

1.4 Congruências

Esta seção é de suma importância para o desenvolvimento tema do trabalho, em especial o
sistema de identiﬁcação de erros, que é baseado na aritmética modular. Daí a ﬁnalidade de um

estudo das congruências e suas propriedades.

Deﬁnição 1.6. Sejam x, y e m números inteiros, com m > 0. Dizemos que x e y são congruentes
módulo m, se m|(x − y). Denota-se por x ≡ y(mod m).

No caso em que x não é congruente a y módulo m, ou seja, m (cid:45) (x − y), escreve-se x (cid:29)

y(mod m).

20

1.4.1 Propriedades das Congruências

Proposição 1.9. Sejam x e y números inteiros, temos que x ≡ y(mod m) se, e somente se, os restos das
divisões de x e y por m são iguais.

Demonstração:
(⇒)
Pelo algoritmo da divisão, Teorema 1.1, existem q1, q2, r1, r2 ∈ Z, com 0 (cid:54) r1, r2 < m , de

modo que x = m.q1 + r1 e y = m.q2 + r2.

Subtraindo-se x e y temos:

x − y = (m.q1 + r1) − (m.q2 + r2)

= mq1 − mq2 + r1 − r2

m.(q1 − q2) − (r2 − r1)

Então, como x ≡ y(mod m) implica m|(x − y). Note que m|m(q1 − q2). Consequente-
mente, pela Proposição 1.2, m|[(x − y) − m(q1 − q2)]. Daí, teremos m|(r2 − r1). Porém, como
|r1 − r2| < m, só será possível se r2 − r1 = 0, ou seja, se r1 = r2.

(⇐)

Por hipótese, os restos das divisões de x e y são iguais, logo, pelo Teorema 1.1 podemos

escrever:

x = mq1 + r e y = mq2 + r, donde q1, q2 e r são inteiros, com 0 (cid:54) r < m.

Daí, subtraindo-se x e y, temos:

x − y = (mq1 + r) − (mq2 + r) = mq1 + r − mq2 − r = mq1 − mq2 = m.(q1 − q2)

Logo m|(x − y), ou seja, x ≡ y(mod m)

(cid:4)

A proposição a seguir contém algumas propriedades das congruências módulo m.

21

Proposição 1.10. Sejam x, y, z e m números inteiros, com m > 0. Então:

• (i) x ≡ x(mod m)

• (ii) Se x ≡ y(mod m) então y ≡ x(mod m).

• (iii) Se x ≡ y(mod m) e y ≡ z(mod m), então x ≡ z(mod m)

Demonstrações:
(i) De fato, como m|0, implica m|(x − x).

(ii) Se x ≡ y(mod m), então m|(x − y), ou seja, existe um inteiro a tal que m = (x − y).a.
Daí, podemos escrever m = −(y − x).a, pois −(y − x) = (x − y).Logo, temos que: m|(y − x),
o que implica y ≡ x(modm).

(iii) Sejam a, b ∈ Z. Se x ≡ y(mod m), então m|(x − y). Logo, m = (x − y).a. De modo

análogo, podemos escrever y ≡ z(mod m). Daí m|(y − z) e, por ﬁm, m = (y − z).b

Note que, pela Proposição 1.2, m|[(x − y) + (y − z)], ou seja, m|(x − z). Portanto,

x ≡ z(mod m).

(cid:4)

A noção de congruência torna-se mais útil e valiosa pelo fato de ser uma relação que é com-
patível com as operações de adição e multiplicação no conjunto Z , conforme as proposições a
seguir:

Proposição 1.11. Sejam os inteiros x, y, z e m, de modo que m > 1. Se x ≡ y(mod m), então:

i) (x + z) ≡ (y + z) (mod m)

ii) (x − z) ≡ (y − z) (mod m)

iii) xz ≡ yz (mod m)

Demonstração:
(i) Como x ≡ y (mod m), pela Deﬁnição 1.6, então m|(x − y), o que implica em
m|(x + z − z − y) , ou seja, m|[(x + z) − (y + z)]. Logo (x + z) ≡ (y + z) (mod m).

22

(ii) Já que x ≡ y (mod m), pela Deﬁnição 1.6, temos que m|(x − y) = (x − z + z − y), ou

seja, m|[(x − z) − (y − z)]. Portanto, (x − z) ≡ (y − z) (mod m).

(iii) Como x ≡ y (mod m), pela Deﬁnição 1.6, temos que m|(x − y). Pela Proposição 1.2,
item (i), temos que se m|(x − y), então m|(x − y)z, isso é, m|(xz − yz). Daí, pela deﬁnição 1.6,
temos que xz ≡ yz (mod m).

(cid:4)

Proposição 1.12. Sejam os inteiros x , y , z , a , b e m , com m > 1. Se x ≡ y (mod m) e
a ≡ b (mod m), então:

i) (x + a) ≡ (y + b)(mod m)

ii) xa ≡ yb (mod m)

Demonstração:
(i) Sabemos que x ≡ y (mod m) e a ≡ b (mod m), logo m|(x − y) e m|(a − b), logo, pela pro-
posição 1.1 item (v), temos que m|[(x − y) + (a − b)] e assim m|[(x + a) − (y + b)]. Portanto,
(x + a) ≡ (y + b)(mod m).

(ii) Agora, como x ≡ y (mod m) e a ≡ b (mod m), m|(x − y) e m|(a − b), assim pela propo-
sição 1.2, temos que m|[a(x − y) + y(a − b)], ou seja,m|(xa − ya + ya − yb). Logo, m|(xa − yb),
o que implica xa ≡ yb (mod m).

(cid:4)

Teorema 1.2. Sejam os inteiros a e m. Temos que, ab (cid:29) 0(mod m) , para todo b ∈ {1, ..., m − 1} se, e
somente se, mdc(a, m) = 1.

Demonstração:
(⇒)
Vamos supor que mdc(a, m) = d > 1. Então, d|a e d|m. Portanto, existem os inteiros x e y,
tais que a = dx e m = dy, de modo que 1 (cid:54) y < m, pois se y = m, implica que ab ≡ 0(mod m),

23

o que é contrário à hipótese.

Fazendo b = y, temos que:

ab = ay = dxy = xdy = xm ≡ 0(mod m)

Ou seja, como m|xm, implica que xm ≡ 0(mod m). Logo, ay ≡ 0(mod m).

Porém, como 1 (cid:54) b < m, pois ab (cid:29) 0(mod m), teremos uma contradição.

Portanto, d = 1, isso é, mdc(a, m) = 1.

(⇐)
Como mdc(a, m) = 1, então temos que m (cid:45) a.

Seja 1 (cid:54) b < m, tal que ab ≡ 0(mod m). Daí, temos que m|ab e mdc(a, m) = 1.

Pela proposição 1.7, temos que m|b. Um absurdo, pois 1 (cid:54) b < m. Logo, ab (cid:29) 0(mod m).

(cid:4)

Como os sistemas de identiﬁcação utilizam, em sua maioria, o produto escalar entre dois

vetores, aqui neste trabalho usaremos a deﬁnição de acordo com [5].

Deﬁnição 1.7. Sejam dois vetores α e β, com α = (a1, a2, a3) e β = (b1, b2, b3). O produto escalar
entre os vetores α e β, denotado por α · β, deﬁne-se por:

α · β = a1b1 + a2b2 + a3b3

Em suma, os conteúdos aqui vistos serão de grande importância para melhor entendimento

do tema do trabalho, que são os códigos de barras e detecção de erros de digitação.

24

CAPÍTULO 2

OS CÓDIGOS DE BARRAS

Neste capítulo veremos como reconhecer um código de barras, bem como ele é constituído,

os tipos de códigos de barras existentes e os mais utilizados. Destina-se, também, o modo como

os códigos de barras são lidos e como são codiﬁcados os códigos EAN-13 e UPC-A. As referên-
cias utilizadas neste capítulo estão de acordo com [6] e [7], basicamente, bem como de [8] a [13].

2.1 O que são códigos de barras?

Segundo [7], os códigos de barras são composições de linhas paralelas e verticais, pretas e

brancas e de espessuras e alturas diferentes. Essas linhas, que são as barras, contêm dados do
produto. Os códigos de barras são representados por números apenas ou por números e letras,

a depender do tipo do código de barras adotado.

Existem dois tipos de códigos de barras: o código bidimensional e os códigos lineares. A prin-
cipal diferença entre o código bidimensional (2D) do código de barras linear (1D) é que os li-

neares guardam em seus códigos apenas números e referências, pequenas palavras, enquanto

o código 2D tem capacidade de armazenar diversos dados. As diferenças, com relação à capa-

cidade de armazenação de dados, entre os códigos 1D e 2D podem, também, serem vistas na
Figura 2.1 (disponível em [11]):

25

Figura 2.1: Códigos 1D e 2D

A Figura 2.2, disponível em [10], contém os principais tipos de códigos de barras bidimen-

sionais:

Figura 2.2: Códigos Bidimensionais

Na Figura 2.3, que encontra-se em [8], temos os códigos de barras lineares mais utilizados:

26

Figura 2.3: Códigos Lineares

2.2 Composição de um Código de Barras Linear

O código de barras é composto por várias barras paralelas e verticais, contendo uma sequên-

cia de números, de modo a permitir a leitura pela máquina e pelo homem. A Figura 2.4, dis-
ponível em [12], contém um exemplo de um código de barras linear:

Figura 2.4: Exemplo de Códigos Lineares

2.2.1 As Partes do Código de Barras

Na Figura 2.5, temos as partes de um código, de acordo com as barras:

Os separadores servem, basicamente, para indicar a extremidade do código. Notemos, pela
Figura 2.5, que existem três separadores, e que o separador "central” delimita o código em duas
partes: lado direito e lado esquerdo. Daí, a principal função dos separadores é permitir que a

máquina leitora reconheça de qual lado o código está sendo lido.

27

Figura 2.5: Composição do Código de Barras 1

As zonas de silêncio são as margens ou os espaços antes do dígito inicial e ﬁnal. Estas não

podem ser excluídas pois a interpretação do código será impossibilitada.

Na Figura 2.6, temos as partes de um código, de acordo com os números que aparecem

abaixo das barras:

Figura 2.6: Composição do Código de Barras 2

Então:

• Os três primeiros dígitos do código de barras representam o país onde o produto foi
fabricado. Cada país tem a sua numeração correspondente. No caso do Brasil, esses três

números são 789.

28

• Os quatro dígitos seguintes, determinam a empresa que fabricou o produto.

• Os cinco dígitos, seguintes aos que caracterizam a empresa, são os que caracterizam o

produto.

• O último dígito tem uma função diferenciada, pois permite veriﬁcar possíveis erros de

digitação, denominado dígito veriﬁcador.

As posições acima descritas, são determinadas segundo [9], que organiza e padroniza os

códigos.

2.3 O Código UPC-A

Segundo [6], o código UPC foi aceito formalmente em maio de 1973. Inicialmente chamava-

se de UPC (Universal Product Code), fora adotado nos Estados Unidos e Canadá e continha

apenas 12 dígitos, conforme o exemplo da Figura 2.7, disponível em [13]:

Figura 2.7: Código UPC-A

2.4 O Código EAN-13

Baseado no UPC-A, o código EAN-13 (European Article Numbering) foi elaborado a partir
da necessidade de se adicionar um dígito a cada código, de modo a permitir a identiﬁcação do

país de origem do produto, de forma que a mesma máquina leitora pudesse ler códigos UPC e

EAN.

Na Figura 2.8, temos um exemplo de um código de barras EAN-13:

29

Figura 2.8: Código EAN-13

2.5 Como é feita a leitura do Código de Barras

O código de barras é lido através de equipamento apropriado chamado scanner, ver Figura

2.9, disponível em <http://www.megsystem.com.sg/BarCodeScanner-1000CCD.html>

Figura 2.9: Exemplo de Scanner

30

2.6 Codiﬁcação do Código de Barras UPC-A

Inicialmente, vamos analisar a estrutura dos códigos UPC-A pela Figura 2.10:

Figura 2.10: Exemplo de código UPC-A

Segundo [6] e [7], as barras representam, cada uma, uma sequência de sete dígitos, que al-

ternam entre 0 e 1, que é a linguagem utilizada pelo computador, que são associados de acordo

com a cor e espessura da barra.

Existem quatro tipo de espessuras para as duas cores das listras (pretas e brancas), que são:

ﬁna, média, grossa e muito grossa. Portanto, para cada cor e espessura da barra é associado
um dígito, conforme a Tabela 1 a seguir:

Espessura
Fina
Média
Grossa
Muito Grossa

Barra Branca Barra Preta

0
00
000
0000

1
11
111
1111

A Figura 2.11, disponível em [7], contém uma situação que auxilia numa melhor compre-

ensão dos fatos citados acima:

Figura 2.11: Codiﬁcação dos códigos

31

No exemplo dado no início dessa seção, iniciando após as barras limites (separadores), as
quatro primeiras listras: uma listra branca grossa, uma preta média, uma branca ﬁna e uma
preta ﬁna são representadas, respectivamente, pela sequência 0001101. Esta sequência repre-
senta o número 0, o primeiro do código da ﬁgura.

Procedendo de modo análogo, veriﬁcamos que o dígito seguinte, o 1, é representado pela
sequência de listras: branca média, preta média, branca média e preta ﬁna, o que corresponde
à sequência: 0011001.

O scanner consegue distinguir a direita da esquerda.

Isto ocorre porque os dígitos são

codiﬁcados de maneira diferente quando estão do lado direito ou do lado esquerdo do código
de barras. Isso é feito conforme à seguinte Tabela 2, adaptada de [6]:

Dígito do lado esquerdo do lado direito

0
1
2
3
4
5
6
7
8
9

0001101
0011001
0010011
0111101
0100011
0110001
0101111
0111011
0110111
0001011

1110010
1100110
1101100
1000010
1011100
1001110
1010000
1000100
1001000
1110100

A codiﬁcação de um certo número à direita é obtida de sua codiﬁcação à esquerda, quando

trocamos cada 0 por 1 e vice versa.

O processo de identiﬁcação ﬁca mais claro quando entendemos que, cada sequência do lado

esquerdo tem um número ímpar de dígitos iguais a 1 e, logo, cada uma das que estão à direita

tem um número par.

Daí, veriﬁcando a paridade de cada sequência de sete dígitos, a máquina identiﬁca imedia-

tamente de que lado está lendo o código.

32

2.7 Codiﬁcação do Código de Barras EAN-13

A codiﬁcação dos Códigos de Barras EAN-13 é análoga à codiﬁcação dos Códigos de Barras

UPC-A.

Na elaboração do código EAN fora encontrada uma diﬁculdade: a necessidade de adicio-

nar um dígito a cada código de tal forma que a mesma leitora ótica pudesse ler, sem distinção,

os códigos EAN e UPC. Daí, a solução encontrada foi: Os países que utilizam o código UPC

antigo, que são EUA e Canadá, são identiﬁcados com um 0 na frente, e o resto da codiﬁcação é
feita utilizando-se o sistema anterior.

Para os demais países, os primeiros dois ou três dígitos identiﬁcam o país. No caso do Bra-

sil, os códigos de barras de produtos produzidos começam com a sequência 789. Como era
necessário adicionar um dígito e, também, manter o mesmo padrão de tamanho do código de

barras, para não ter que modiﬁcar todas as leitoras, a ideia utilizada foi fazer com que o novo

dígito estivesse implícito na forma de escrita de todos os outros.

Logo, não foi modiﬁcada a codiﬁcação do lado direito, permitindo assim que todas as lei-

toras continuassem a identiﬁcar o lado correspondente, porém, a codiﬁcação do lado esquerdo

varia de acordo com o dígito inicial. Um dígito do lado esquerdo pode ser agora codiﬁcado com
um número par ou número ímpar de dígitos iguais a 1, de acordo a Tabela 3, disponível em [6]:

dígito lado esquerdo ímpar

0
1
2
3
4
5
6
7
8
9

0001101
0011001
0010011
0111101
0100011
0110001
0101111
0111011
0110111
0001011

lado esquerdo par
0100111
0110011
0011011
0100001
0011101
0111001
0000101
0010001
0001001
0010111

lado direito
1110010
1100110
1101100
1000010
1011100
1001110
1010000
1000100
1001000
1110100

33

Por ﬁm, para cada dígito inicial, escolhe-se uma alternância diferente de pares e ímpares,

de acordo com o seguinte critério contido na Tabela 4, segundo [6]:

dígito inicial
0
1
2
3
4
5
6
7
8
9

1o
ímpar
ímpar
ímpar
ímpar
ímpar
ímpar
ímpar
ímpar
ímpar
ímpar

2o
ímpar
ímpar
ímpar
ímpar
par
par
par
par
par
par

3o
ímpar
par
par
par
ímpar
par
par
ímpar
ímpar
par

4o
ímpar
ímpar
par
par
ímpar
ímpar
par
par
par
ímpar

5o
ímpar
par
ímpar
par
par
ímpar
ímpar
ímpar
par
par

6o
ímpar
par
par
ímpar
par
par
ímpar
par
ímpar
ímpar

Veremos um exemplo, uma pipoca doce produzida no Brasil, que é identiﬁcada pelo código
7898927019426. Como começa com 789, o primeiro dígito, que estará implícito na codiﬁcação
dos demais, é o 7.

Por consequência, deve-se usar do lado esquerdo, a seguinte ordem de codiﬁcação (obtida

na Tabela 4):

(8) ímpar - (9) par - (8) ímpar - (9) ímpar - (2) ímpar - (7) par
Consultando a Tabela 3, temos:

8 → 0110111
9 → 0010111
8 → 0110111
9 → 0010111
2 → 0010011
7 → 0010001

Para os dígitos do lado direito não é preciso nos preocuparmos com a paridade, e direta-

mente da Tabela 2, obtemos a seguinte codiﬁcação:

0 → 1110010

34

1 → 1100110
9 → 1110100
4 → 1011100
2 → 1101100
6 → 1010000

Portanto, o código de barras correspondente é:

Figura 2.12: Codiﬁcação do EAN-13

Sumariando, o código de barras nada mais é do que um número identiﬁcador do produto.
Apenas um número escrito em uma linguagem diferente: uma linguagem que se comunica

com barras pretas e brancas.

35

CAPÍTULO 3

DETECÇÃO DE ERROS

Os códigos de barras podem e devem ser controlados para tornar possível a detecção de er-

ros de codiﬁcação. Isso signiﬁca que quando, por exemplo, um caixa do supermercado digitar

um número errado do código que identiﬁca o produto, esse erro de codiﬁcação deve ser "avi-
sado". Para isso, criou-se um grupo de algarismos, denominados algarismo de testes, algarismo
de controle ou dígito de veriﬁcação, e que representam o último dígito do código. O conteúdo aqui
contido, está de acordo com [6], [7] e [14].

3.1 Sistemas de Identiﬁcação Modular (SIM)

Para identiﬁcarmos, de maneira rápida, um produto, livro ou pessoa, utilizamos um nú-
mero. Esses números são chamados de números de identiﬁcação, tais como o Registro de Iden-

tidade (RG), o Cadastro de Pessoas Físicas (CPF), identiﬁcação de livros, cuja sigla é ISBN(International

Standard Book Number)), códigos de barras, contas bancárias e outras situações. Em geral,

esses números de identiﬁcação contêm apenas algarismos (são os códigos numéricos) ou alga-
rismos e letras (são os códigos alfanuméricos).

De modo a evitar e detectar fraudes ou que um código seja transmitido de forma errada, os

sistemas de identiﬁcação utilizam o dígito veriﬁcador para tal. Geralmente, o dígito veriﬁcador
é o último dígito do código. Como seu valor é calculado utilizando Aritmética Modular, daí

entitulam-se esses sistemas como Sistemas de Identiﬁcação Modular.

36

Em um sistema que utiliza-se a aritmética modular, um número de identiﬁcação é escrito

da forma:

a1a2a3...an A,

onde A é o dígito veriﬁcador, ai o dígito do número de identiﬁcação, com ai ∈ {0, 1, 2, ..., 9},

i ∈ {1, 2, ..., n} e A ∈ {1, 2, ..., 9}

Tomando-se pi com pi ∈ {0, 1, 2, ..., k − 1} e i ∈ {1, 2, ..., n}, temos que o valor de A é

calculado através da seguinte congruência:

p1a1 + p2a2 + .... + pnan + A ≡ 0 (mod k)

onde os elementos p1, p2, ..., pn são os pesos, que são escolhidos inicialmente.

Esse sistema é denominado de sistema módulo k e a soma p1a1 + p2a2 + .... + pnan + A de

soma teste, que representaremos por S, isso é,

S = p1a1 + p2a2 + .... + pnan + A

No exemplo a seguir, teremos um melhor entendimento sobre o funcionamento do sistema

de identiﬁcação modular.

Exemplo 3.1. Uma empresa utiliza três dígitos, a1a2a3, para identiﬁcar cada produto que é vendido.
Para certiﬁcar-se que estes números serão transmitidos de maneira correta, acrescenta-se um quarto
dígito em cada número, gerando assim o código de identiﬁcação a1a2a3 A. A empresa utiliza um sistema
módulo 10 com pesos 3,1,3. Portanto, para calcularmos o dígito veriﬁcador devemos resolver a equação
3a1 + a2 + 3a3 + A ≡ 0(mod10). Então, um produto identiﬁcado pelo número 123, temos que A = 6 ,
pois A deve satisfazer à congruência:

3.1 + 1.2 + 3.3 + A ≡ 0(mod 10)

3 + 2 + 9 + A ≡ 0(mod 10)

14 + A ≡ 0(mod 10)

Logo, A = 6 pois 14 + 6 = 20 e 20 ≡ 0(mod 10). Daí, o código de identiﬁcação desse produto é
1236. Porém, o código 2468 é um código inválido, pois 3.2 + 1.4 + 3.6 + 8 = 6 + 4 + 18 + 8 = 36 e
36 (cid:29) 0(mod 10).

37

3.2 O Dígito Veriﬁcador

O dígito veriﬁcador não é um número aleatório, tampouco faz parte da sequência dos dí-

gitos que contém informações sobre o produto. Ele é obtido através de um algoritmo, que

obtém-se a partir dos dígitos anteriores, seguindo os padrões do sistema adotado, com a ﬁna-
lidade de certiﬁcar a validade de um código numérico.

3.2.1 O Dígito Veriﬁcador do Código EAN-13

Todo código de barras possui um dígito de veriﬁcação, que funciona como um detector de
erros. Esse dígito normalmente é o último algarismo da sequência. Para descobrir quual é esse

dígito, utilizaremos o algoritmo a seguir:

Algoritmo:

1) Suponhamos que um determinado produto está identiﬁcado, no sistema EAN-13, por

uma dada sequência de dígitos a1a2a3...a12a13.

Como os primeiros dígitos identiﬁcam o país de origem, o fabricante e o produto espe-
cíﬁco, os primeiros doze dígitos da sequência estão determinados naturalmente por um

método padrão, a cargo de uma autoridade classiﬁcadora em cada país. Assim sendo,
chamaremos o décimo terceiro dígito de veriﬁcação, por x.

2) Para facilitar o entendimento, escrevemos esta sequência como um vetor:

α = (a1, a2, a3, ..., a12, x)

Os códigos de formato EAN-13 utilizam-se de um vetor ﬁxo, denominado vetor de pesos,
identiﬁcado por:

β = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1).

3) Calcula-se, então, o produto escalar entre esses dois vetores:

α · β = (a1, a2, a3, ..., a12x) · (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1)

38

α · β = a1 + 3a2 + a3 + 3a4 + a5 + 3a6 + a7 + 3a8 + +a9 + 3a10 + a11 + 3a12 + x

.

4) Agora, o dígito veriﬁcador x é determinado de tal forma que a soma obtida é um múltiplo

de 10 (pois trata-se de uma operação feita no sistema decimal de base 10), isto é,

Ou também,

α · β ≡ 0(mod 10)

a1 + 3a2 + a3 + 3a4 + a5 + 3a6 + a7 + 3a8 + +a9 + 3a10 + a11 + 3a12 + x ≡ 0(mod10)

Por exemplo, no caso do código da Figura 3.1, os números que indicam o país de origem,
o fabricante e o produto são 789, 6422 e 51322, respectivamente e como pode se notar, o dígito
veriﬁcador é 7.

Figura 3.1: Cálculo do Dígito Veriﬁcador no Código EAN-13

Através da aplicação do algoritmo, citado anteriormente, faz-se a conﬁrmação desse fato.

Sendo α = (7, 8, 9, 6, 4, 2, 2, 5, 1, 3, 2, 2, x) e β = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) , então:

α · β = (7.1) + (8.3) + (9.1) + (6.3) + (4.1) + (2.3) + (2.1) + (5.3) + (1.1) + (3.3) + (2.1) + (2.3) + (x.1)

39

α · β = 7 + 24 + 9 + 18 + 4 + 6 + 2 + 15 + 1 + 9 + 2 + 6 + x

Como 103 + x ≡ 0(mod 10), logo x = 7. O que mostra que a identiﬁcação do produto está

correta, pois 7 é o menor inteiro que torna esta soma um múltiplo de 10.

α · β = 103 + x

Agora, se ao digitar esse código de barras, houvesse um erro de digitação humano no quarto
dígito e o código fosse assim transmitido: 7891422513227. O computador, programado para
fazer a leitura utilizando o algoritmo, detectaria o erro, pois:

α · β = (7 · 1) + (8 · 3) + (9 · 1) + (1 · 3) + (4 · 1) + (2 · 3) + (2 · 1) + (5 · 3) + (1 · 1) + (3 · 3) + (2 · 1) + (2 · 3) + (7 · 1)

α · β = 7 + 24 + 9 + 3 + 4 + 6 + 2 + 15 + 1 + 9 + 2 + 6 + 7

α · β = 95

e

95 (cid:29) 0(mod 10)

Logo, a leitura desse código pelo computador não seria feita, pois, como visto, fora come-

tido um erro, não sendo identiﬁcado pelo computador programado para aplicar o algoritmo
de veriﬁcação de códigos de barras EAN-13.

3.2.2 O Dígito Veriﬁcador do Código UPC-A

Com o código UPC-A é muito semelhante. Como utiliza apenas 12 dígitos (pois usa apenas
um para identiﬁcar o país de origem do artigo), o vetor de pesos utilizado pelo UPC apresenta
um dígito a menos:

40

β = (3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1)

Por exemplo, vamos utilizar o código UPC-A da Figura 3.2 (disponível em:

<http://www.manutencaoesuprimentos.com.br/conteudo/5585-codigo-de-barras-universal/>)

Figura 3.2: Dígito Veriﬁcador do Código UPC-A

Como α = (0, 2, 1, 2, 0, 0, 9, 7, 8, 1, 5, 9) e β = (3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1), então:

α · β = (0 · 3) + (2 · 1) + (1 · 3) + (2 · 1) + (0 · 3) + (0 · 1) + (9 · 3) + (7 · 1) + (8 · 3) + (1 · 1) + (5 · 3) + (9 · 1)

α · β = 0 + 2 + 3 + 2 + 0 + 0 + 27 + 7 + 24 + 1 + 15 + 9

Como 90 ≡ 0(mod 10), tem-se que a identiﬁcação do produto está correta.

α · β = 90

Porém, se houvesse um erro de digitação humana, uma "permutação de posições"entre os
2o e 3o dígitos, e o código fosse assim transmitido: 012200978159, o computador, através do
algoritmo que fora programado para fazer a leitura dos códigos, acusaria que o código foi

digitado errado, pois:

α · β = (0 · 3) + (1 · 1) + (2 · 3) + (2 · 1) + (0 · 3) + (0 · 1) + (9 · 3) + (7 · 1) + (8 · 3) + (1 · 1) + (5 · 3) + (9 · 1)

41

α · β = 0 + 1 + 6 + 2 + 0 + 0 + 27 + 7 + 24 + 1 + 15 + 9

α · β = 92

e

92 (cid:29) 0(mod 10)

3.3 Detectando Erros

Segundo [6], existem diversos tipos de erros que podem ser cometidos ao digitar um vetor
de identiﬁcação, ao qual denominamos de α na seção anterior, tais como a embalagem do pro-
duto estar úmida ou amassada.

Os erros num único dígito e as transposições são os mais frequentes. O erro único ou singular
é o mais comum, pois representa mais de 79% dos erros cometidos. Esse erro acontece quando,
por exemplo, tenta-se digitar um código 2356 e, ao invés disso, digita-se 2456.

Já os erros de transposição adjacente, que correspondem a pouco mais de 10% do total de
erros cometidos ao digitar acontecem quando, por exemplo, ao invés de digitar o código 2468,
digita-se 2648.

Com uma porcentagem de quase 1%, estão os erros de transposição alternada, ou seja,

acontecem quando ao tentar digitar, por exemplo o código 13579, é digitado 17539.

Ainda segundo esses estudos, a chance de ocorrer mais de um erro ao digitar um número é

muito pequena.

Na Tabela 5 abaixo, abreviando a tabela publicada em [6], estão os tipos de erros e as

frequências relativas de cada um:

42

TIPO DE ERRO
...a...(cid:55)→...b...
erro único
...ab...(cid:55)→...ba...
erro de transposição adjacente
erro de transposição alternada ...abc...(cid:55)→...cba...

outros erros

Frequência relativa (%)
79,1
10,2
0,8
9,9

Por meio de alguns exemplos, obteremos uma melhor compreensão desses erros.

Exemplo 3.2. Considere o código de barras 7898532698238. Suponha que houve um erro de digitação
na posição a1, e que o código foi assim transmitido: 8898532698238. Sendo α = (8, 8, 9, 8, 5, 3, 2, 6, 9, 8, 2, 3, 8)
o vetor que representa esse código e β = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1) o vetor de pesos, temos que o
computador detectaria o erro, pois:

α · β = 8 + 24 + 9 + 24 + 5 + 9 + 2 + 18 + 9 + 24 + 2 + 9 + 8

α · β = 151 (cid:29) 0(mod 10)

Porém, se mais de um erro for cometido na digitação, o erro provavelmente ainda será de-

tectado, mas já não se pode ter certeza, pois eles poderiam se "compensar mutuamente"e a

soma poderia ainda continuar sendo um múltiplo de 10.

Supondo que além do erro cometido no dígito da posição a1, ocorresse outro erro com o
dígito da posição a6 , e o código fosse assim transmitido: 8898592698238. Da mesma forma o
computador teria detectado o erro, pois:

α · β = 8 + 24 + 9 + 24 + 5 + 27 + 2 + 18 + 9 + 24 + 2 + 9 + 8

α · β = 169 (cid:29) 0(mod 10)

Agora, vamos supor que os erros foram cometidos com os dígitos da posições a7 e a13, e
o código foi digitado da seguinte forma: 7898534698236. Pelo algoritmo do dígito veriﬁcador,
teríamos:

α · β = 7 + 24 + 9 + 24 + 5 + 9 + 4 + 18 + 9 + 24 + 2 + 9 + 6

43

Portanto, o erro não seria detectado pelo computador.

α · β = 150 ≡ 0(mod 10)

Exemplo 3.3. Consideremos o código de barras 9788531404580. Ao digitar o código 9788531404580
ocorreu um erro de transposição adjacente entre os elementos a5 e a6, e que o código digitado foi 9788351404580.

Sendo α = (9, 7, 8, 8, 5, 3, 1, 4, 0, 4, 5, 8, 0) o vetor que representa esse código e β = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1)

o vetor de pesos, temos que o computador teria detectado o erro, pois:

α · β = 9 + 21 + 8 + 24 + 3 + 15 + 1 + 12 + 12 + 5 + 24

Exemplo 3.4. Consideremos o código de barras 9781402002380.

α · β = 134 (cid:29) 0(mod 10)

Vamos supor que, ao digitar o código 9781402002380, o erro cometido foi entre os elementos
a11 e a12, e que o número de fato digitado foi 9781402002830. Ao efetuar a veriﬁcação, teríamos:

α · β = (9, 7, 8, 1, 4, 0, 2, 0, 0, 2, 8, 3, 0) · (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1)

α · β = (9 · 1) + (7 · 3) + (8 · 1) + (1 · 3) + (4 · 1) + (0 · 3) + (2 · 1) + (0 · 3) + (0 · 1) + (2 · 3) + (8 · 1) + (3 · 3) + (0 · 1)

α · β = 9 + 21 + 8 + 3 + 4 + 0 + 2 + 0 + 0 + 6 + 8 + 9 + 0

E como 70 é um múltiplo de 10, o sistema não teria detectado o erro.

α · β = 70 ≡ 0(mod 10)

Pelos exemplos vistos anteriormente, percebemos que o algoritmo utilizado não detecta
100% dos erros de transposições e possui algumas falhas de segurança. Pela proposição a se-
guir, é possível demonstrar que a transposição de dois dígitos consecutivos ai e ai+1 não é
detectada se, e somente se, 5|(|ai − ai+1|).

44

Proposição 3.1. A transposição de dois dígitos consecutivos ai e ai+1 não é detectada, neste sistema de
codiﬁcação, se e somente se, 5|(|ai − ai+1|).

Demonstração

Vamos supor que o código

foi digitado como

α = (a1, a2, ..., ai, ai+1, ..., a12, x)

α(cid:48) = (a1, a2, ..., ai+1, ai, ..., a12, x)

e que não tenha sido detectado o erro. Assim, teríamos duas possibilidades:

• se i for ímpar, implica que devemos multiplicar ai por 1

• se i for par, implica que devemos multiplicar ai por 3

Seja β o vetor de pesos adotado, ou seja β = (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1). Fazendo o pro-

duto entre os vetores α · β e α(cid:48) · β, temos que se α · β ≡ 0(mod 10) e α(cid:48) · β ≡ 0(mod 10), então:

a1 + 3a2 + a3 + 3a4 + ... + ai + 3ai+1 + ... + 3a12 + x ≡ 0(mod 10)

e

a1 + 3a2 + a3 + 3a4 + ... + ai+1 + 3ai + ... + 3a12 + x ≡ 0(mod 10)

Fazendo α · β − α(cid:48) · β, temos:

α · β − α(cid:48) · β = ai + 3ai+1 − ai+1 − 3ai ≡ 0(mod 10)

α · β − α(cid:48) · β = 2ai+1 − 2ai ≡ 0(mod 10)

α · β − α(cid:48) · β = 2(ai+1 − ai) ≡ 0(mod 10)

Portanto,

10|2(ai+1 − ai)

45

O que implica

5|(|ai − ai+1|)

3.4 Generalização dos Detectores de Erros

Nesta seção estudaremos outros detectores de erros, mas para tal, adotaremos a seguinte

linguagem:

• Chamaremos de D será o conjunto que contém os valores que os dígitos utilizados no

sistema de identiﬁcação podem assumir na codiﬁcação.
Temos que D = {x ∈ Z |0 (cid:54) x (cid:54) k − 1} , donde k é um número inteiro positivo e k > 1.

• α = (a1, a2, a3, ..., an−1), donde n é um número inteiro positivo, será o vetor de informa-
ção. No caso em que α = (a1, a2, a3, ..., an−1, an), ou seja, acrescido do dígito veriﬁcador
an, será o vetor de identiﬁcação.

Deﬁnição 3.1. Consideremos β = (p1, ..., pn) com pi ∈ D , 1 (cid:54) i (cid:54) n um vetor de pesos e c ∈ D
um número inteiro ﬁxado. Dados dois inteiros positivos k e n e um conjunto de números a1, a2, .., an−1
de modo que ai ∈ D , 1 (cid:54) i (cid:54) n, deﬁne-se o número de veriﬁcação an como o único elemento de D que
veriﬁca a equação:

a1 p1 + a2 p2 + ... + ai pi + ... + an pn ≡ c(mod k)

ou, simplesmente:

n
∑
i=1

ai pi ≡ c(mod k)

Daí, um sistema de codiﬁcação de acordo com a Deﬁnição 3.1 será denotado por:

M = (D, k, n, c, β)

Donde D = {0, 1, ..., k − 1}.
Como exemplo, temos o sistema utilizado por bancos (alguns) para codiﬁcar o número da

conta de seus clientes que é composto por 9 dígitos, sendo que o último é o dígito veriﬁcador.

46

Consideremos um banco com o sistema de codiﬁcação M = (D, 10, 9, 0, β) onde D é o
conjunto dos dígitos de 0 a 9 e β = (7, 3, 9, 7, 3, 9, 7, 3, 9) é o vetor de pesos previamente deﬁnido
pelo banco. Se tomarmos o número de certa conta bancária como 67 − 127345 − 7 , usando o
algoritmo para veriﬁcação temos que:

(6, 7, 1, 2, 7, 3, 4, 5, 7).(7, 3, 9, 7, 3, 9, 7, 3, 9) = 6.7 + 7.3 + 1.9 + 2.7 + 7.3 + 3.9 + 4.7 + 5.3 + 7.9

= 42 + 21 + 9 + 14 + 21 + 27 + 28 + 15 + 63 = 240 ≡ 0(mod 10)

(cid:4)

O teorema a seguir descreve a capacidade que tem um sistema deﬁnido da forma M =

(D, k, n, c, β), para detectar os erros mais comuns.

Teorema 3.1. (Capacidade de detecção de erros) Consideremos k um inteiro positivo e β = (p1, ..., pn)
um vetor de pesos. Suponhamos que um vetor de identiﬁcação α = (a1, ..., an) (onde tem-se que ai ∈
{0, 1, ..., k} , para todo índice i ∈ {1, 2, ..., n} satisfaz a condição:

α · β = a1 p1 + ... + an.pn ≡ c(mod k)

Então,

• (1) Todo erro consistente numa única alteração (erro singular) na posição i-ésima será detectado

se, e somente se, mdc(pi, k) = 1.

• (2) Todo erro de transposição da forma ...ai...aj... −→ ...aj...ai... será detectado se, e somente se,

mdc(pi − pj, k) = 1 , (comi (cid:54)= j)

Demonstração:

(1)
Vamos supor que ai , na posição i, foi trocado por bi. Denotaremos α(cid:48) como vetor resultante

desse erro e β = {p1, ..., pn} o vetor de pesos. Daí, o erro não será detectado se, e somente, se

α · β ≡ c (mod k)

47

e

α(cid:48) · β ≡ c (mod k)

α · β − α(cid:48) · β ≡ 0 (mod k)

Logo,

Mas

α · β − α(cid:48) · β = (ai − bi)pi ≡ 0 (mod k)

De modo que o erro será detectado se, e somente,

( ⇐ ) Vamos supor que mdc(pi, k) = 1 e que o erro não foi detectado. Daí, k|(ai − bi)pi.

k|(ai − bi)pi

Como, por hipótese, pi e k são primos, temos que k|(ai − bi).

Mas, 0 (cid:54) ai, bi < k , ou seja, ai − bi = 0 ⇒ ai = bi. O que é um absurdo, pois, por hipótese,

ai (cid:54)= bi

(⇒) Vamos supor que todo erro é detectado e que mdc(pi, k) = d (cid:54)= 1.

Sejam bi = ai +

k
d

ou bi = ai −

k
d

.

Aﬁrmação: 0 (cid:54) bi < k

De fato, se k (cid:54) bi e bi < 0 ⇒ k (cid:54) ai ±

k
d

. Daí:

k (cid:54) ai +

k
d

< 0 ⇒ k −

k
d

<

k
d

⇒ k <

k
d

+

k
d

⇒ k <

2k
d

⇒ dk < 2k ⇒ d < 2

O que é um absurdo, pois d é um número inteiro e d (cid:54)= 1.

48

Então, ai − bi = (±

que é um absurdo!

k
d

)pi = k · (±

pi
d

), isto é, o erro que substitui ai por bi não é detectado, o

(2)
Sejam α = (a0, ..., ai, ..., aj, ..., an) e α(cid:48) = (a0, ..., aj, ..., ai, ..., an) os vetores resultantes da troca

e β = {p1, ..., pn} o vetor de pesos. Neste caso, o erro não será detectado se, e somente se,

isto é

α · β ≡ α(cid:48) · β(mod k)

k|(ai − aj)(pi − pj)

(⇐) Vamos supor que mdc(pi − pj, k) = 1 e que o erro não foi detectado.

Então, temos que k|(ai − aj)(pi − pj).

Como, por hipótese, pi − pj e k são primos, segue que k|(ai − aj).

Mas, 0 (cid:54) ai, aj < m ⇒ ai − aj ⇒ ai = aj, o que é um absurdo!!!

(⇒) Vamos supor que todo erro é detectado e mdc(pi − pj, k) = d (cid:54)= 1.

Usando as ideias anteriores, temos que:

aj = ai ±

k
d

Daí, o erro de transposição cometido trocando-se ai por aj não é detectado, chegando assim

a um absurdo.

(cid:4)

Como consequência do resultado encontrado, temos que a melhor forma de ter-se total cer-

teza que o sistema de codiﬁcação será capaz de detectar os erros únicos e todos os erros de
transposições é tomarmos k um número primo.

49

Um exemplo dessa consequência é o sistema universal adotado para a classiﬁcação de livros
ISBN (International Standard Book Number). O módulo adotado neste sistema é 11, mas aﬁm
de simpliﬁcar a notação, utiliza-se como conjunto de valores D os dígitos de 0 a 9. Os vetores de
identiﬁcação têm 10 componentes. β = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) será o vetor de pesos. Assim,
na notação em que estamos utilizando, este sistema será (D, 11, 10, 0, β).

Por exemplo, vejamos o código da Figura 3.3:

Figura 3.3: Código ISBN

O livro possui o número ISBN 85-904198-1-9. Sendo α = (8, 5, 9, 0, 4, 1, 9, 8, 1, 9) o vetor que
representa o código desse livro e β = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) o vetor de peso do ISBN, temos
que o dígito ﬁnal de veriﬁcação é 9 porque:

α · β = (8, 5, 9, 0, 4, 1, 9, 8, 1, 9) · (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

= 8.10 + 5.9 + 9.8 + 0.7 + 4.6 + 1.5 + 9.4 + 8.3 + 1.2 + 9.1

= 80 + 45 + 72 + 0 + 24 + 5 + 36 + 24 + 2 + 9

= 297 ≡ 0(mod 11)

Porém, ao determinarmos o dígito veriﬁcador de um livro cujo código é 0387960535, nos
depararemos com um pequeno problema. Para isso, fazendo α = (0, 3, 8, 7, 9, 6, 0, 3, 5, f ) e

50

β = (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) chamaremos o dígito veriﬁcador de um número f ∈ D, ou seja,
f ∈ {0, 1, ..., 9} Daí:

α · β = (0, 3, 8, 7, 9, 6, 0, 3, 5, f ) · (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

0.10 + 3.9 + 8.8 + 7.7 + 9.6 + 6.5 + 0.4 + 3.3 + 5.2 + f

0 + 27 + 64 + 49 + 54 + 30 + 0 + 9 + 10 + f

Ou seja, como 11|243 + f , implica que existe um número inteiro g tal que:

243 + f ≡ 0(mod 11)

243 + f = 11.g ⇒ f = 11.g − 243

Portanto, g deve ser escolhido de tal forma que torne verdadeira a igualdade. Em particu-
lar, temos que se g = 23, implica f = 10. Porém, como f ∈ D, associaremos o dígito 10 ao
símbolo X.

Daí, o código do livro citado será ISBN 0-387-96035-X.

É possível perceber que, se atribuirmos um número primo ao número k e o conjunto D for-
mado por inteiros menores que k tendo todos os componentes pi do vetor de peso β primos
com k , multiplicar por pi , módulo k , terá com resultado uma permutação do conjunto D, ou
seja, uma bijeção de D em si mesmo. Com isso, temos um método mais geral para deﬁnir o
vetor de pesos β.

Consideremos um vetor de informação α = (a1, ..., an−1), sem o dígito veriﬁcador an. Po-
demos escolher n permutações d1, ..., dn do conjunto D e deﬁnir um vetor de pesos por ω =
d1, ..., dn, ﬁxarmos um número c ∈ D e escolhermos um dígito de veriﬁcação de forma que
satisfaça a igualdade:

ω(α) = d1(a1) + ... + dn(an) ≡ c(mod k)

51

Isso é, o dígito veriﬁcador an será deﬁnido pela igualdade:

(cid:32)

an = d−1
n

c −

(cid:33)

di(ai)

n=1
∑
i=1

Como exemplo dessa codiﬁcação, que encontra-se em [6], paginas 12-13, se um código
usado pela IBM (International Business Machines) que utiliza como conjunto D os números
de 0 a 9, k = 10 , um valor qualquer c ∈ D e a permutação

δ =

(cid:18)0 1 2 3 4 5 6 7 8 9
0 2 4 6 8 1 3 5 7 9

(cid:19)

Quando o número de componentes de α for ímpar utiliza-se o vetor de pesos: γ = (I, δ, I, δ, ..., δ, I).

Daí, a equação veriﬁcação será:

an + δ(an−1) + an−2 + δ(an−3) + ... ≡ c(mod10)

an = (c − (δ(an−1) − an−2 − δ(an−3) − ...)(mod10)

Quando o número de componentes de α é par utiliza-se o vetor de pesos: γ = (δ, I, δ, I, ..., δ, I).

Logo, a equação que determina o dígito veriﬁcador será idêntica e com fórmula parecida

com o caso anterior.

Como aplicação desse sistema, temos o método de determinação dos cartões de crédito.
Ainda em MILIES 2009, páginas 12-13, tomemos como exemplo, um determinado cartão tem o
número 5745 5195 0431 5412. Aplicando o sistema de veriﬁcação IBM teremos:

5
7
↓ σ ↓ I
7
1

4
5
↓ σ ↓ I
7
8

5
1
↓ σ ↓ I
1
1

5
9
↓ σ ↓ I
1
9

0
4
↓ σ ↓ I
4
0

3
1
↓ σ ↓ I
1
6

5
4
↓ σ ↓ I
9
1

1
2
↓ σ ↓ I
2
2

Efetuando os cálculos teremos:

1 + 7 + 8 + 5 + 1 + 1 + 9 + 5 + 0 + 4 + 6 + 1 + 1 + 4 + 2 + 2 = 60 ≡ 0(mod 10)

52

De forma geral, o código IBM generalizado utiliza a mesma permutação com o vetor pesos:

γ =

(cid:16)

δn−1, δn−2, ..., δ, δ0(cid:17)

onde δ0 = I. A equação é então:

e

n
∑
i−1

(cid:32)

δi−1(an+1−i) ≡ c(mod 10)

an =

c −

(cid:33)

δi−1

n
∑
i−1

(an+1−i)(mod 10)

(cid:4)

O próximo teorema servirá de resposta para seguinte pergunta: será que existe algum có-

digo, trabalhando módulo 10, que identiﬁque tanto os erros singulares e de transposições? A
resposta para tal pergunta será negativa, como veremos a seguir.

Teorema 3.2. Se um sistema numérico de detecção de erros, com um módulo par, detecta todo erro único
de digitação, então para todo par de índices i, j existe um erro de transposição entre as posições i e j que
não é detectada pelo sistema.

Demonstração:
Já que o módulo é par, então iremos trabalhar com os números de 0 a 2k − 1 e com con-
gruências em módulo 2k. Considerando os dígitos como elementos de Z2k (com o objetivo de
simpliﬁcar os argumentos).

Suponha que o sistema transforma o vetor (a1, ..., an) num outro vetor, cuja notação será

(σ1(a1), ..., σn(an))

Tendo a capacidade de detecção do erro único de digitação, então a aplicação na posição

i-ésima x (cid:55)→ σi(x) deve ser uma permutação de Z2k

Para que o sistema detecte todo erro de transposição entre as posições i e j é necessário que

53

para todo par de elementos diferentes a , b ∈ Z2k, ou seja, esta aplicação σ = σi − σj é uma

σi(a) + σi(b) (cid:54)= σj(a) + σi(b)

permutação em Z2k.

Porém, como k ∈ [0, 2k − 1], temos que:

0 + 1 + 2 + ... + 2k − 1 =

(2k − 1)2k
2

= 2k.k − k ≡ k(mod 2k)

Como 2k.k − k ≡ k(mod 2k) , então 0 + 1 + 2 + ... + 2k − 1 ≡ k(mod 2k).

Logo

k = ∑
x∈Z2k

·x =

k = ∑
x∈Z2k

·σ(x)

k = b · ∑
x∈Z2k

·(σi(x) − σj(x))

k = ∑
x∈Z2k

·σi(x) − ∑
x∈Z2k

·σj(x)

k = k − k

k = 0

Mas, isso é uma contradição, pois k é um inteiro positivo.

(cid:4)

Nos últimos anos, o desenvolvimento dos sistemas automáticos para leitura de números,
rápidos, conﬁáveis e relativamente baratos, permitiu a justaposição dos algarismos de controle

ao número de um código, para detectar erros mais comuns. Os sistemas não corrigem os erros,

54

porém "avisam´´ que eles foram cometidos.

Quando um código é digitado, o computador no qual está instalado o sistema de identiﬁca-

ção aplica o algoritmo teste, para veriﬁcar se o último algarismo é de fato o mesmo algarismo
que o algoritmo aplica ao código sem proteção.

55

CAPÍTULO 4

ATIVIDADES PROPOSTAS

Aﬁm de aplicar o conteúdo visto nesse trabalho, as atividades a seguir terão como ﬁnali-

dade fazer com que a matemática tenha maior aplicabilidade no dia-a-dia dos alunos. Com
essa proposta, espera-se que os mesmos consigam associar o conteúdo visto em sala de aula

com situações do seu cotidiano.

4.1 Atividade 1 - Reconhecendo um Código de Barras

Nessa atividade iremos reconhecer um código de barras, bem como entender a sua estru-

tura e funcionalidade.

4.1.1 Objetivo Geral

Reconhecer a importância dos códigos de barras em sala de aula, aﬁm de mostrar o quanto

seria mais lento o reconhecimento de um produto sem que utilizasse um código para identiﬁcá-
lo.

4.1.2 Objetivos Especíﬁcos

• Identiﬁcar um código de barras

• Reconhecer e classiﬁcar os números ali contidos

56

• Compreender a sua funcionalidade no cotidiano

4.1.3 Público Alvo

Alunos do 6o ano do ensino fundamental II

4.1.4 Pré-Requisitos

Os alunos deverão saber interpretar informações, associando-as ao contexto do trabalho.

4.1.5 Materiais Necessários

Os materiais a serem utilizados nessa atividade são:

• lápis e borracha - para anotar (e apagar, se for o caso) as informações necessárias;

• papel ofício (para colar os códigos de barras selecionados)

• tesoura (para fazer os recortes de códigos de barras);)

• cola (para colar os códigos de barras)

4.1.6 Proposta da Atividade

Inicialmente, temos que entender o que é um código de barras e qual a sua funcionalidade.

Portanto, para isso usaremos um exemplo e faremos passo-a-passo a atividade proposta.

Solicitar que os alunos tragam códigos de barras, em seguida que eles identiﬁquem os nú-

meros que caracterizam o país de origem, a empresa fabricante, o produto e o dígito veriﬁcador.

1o passo: Solicitar os materiais necessários para realização da atividade.

2o passo: Deverá ser feita uma explanação, pelo docente, sobre o que são os códigos de

barras, para que servem, sua estrutura e onde são utilizados.

3o passo: Dividir a turma em grupos com, no máximo 5 alunos.

57

4o passo: Será feita a interpretação dos códigos trazidos por cada aluno. Os alunos devem
recortar os códigos trazidos, colá-los nas folhas de papel ofício e anotar todas as informações

contidas nos códigos por eles trazidos, tais como país de origem, os números que representam

a empresa, o produto e o dígito veriﬁcador.

Exemplo 4.1. Considere o código de barras da Figura 4.1:

Figura 4.1: Exemplo da Atividade I

• 789 são os dígitos que caracterizam o país, nesse caso o Brasil;

• 8357 representam os dígitos que caracterizam a empresa;

• 4100 caracterizam o produto;

• 5 é o dígito veriﬁcador

4.2 Atividade 2 - Cálculo do Dígito Veriﬁcador

Nesta atividade, iremos entender o que é o dígito veriﬁcador, sua importância e como

determiná-lo.

Como sugestão, o docente deverá aplicar a atividade anterior, aﬁm de explicar o que são

códigos de barras e sua funcionalidade.

4.2.1 Objetivo Geral

Reconhecer a importância do dígito veriﬁcador, que é fator determinante para a veracidade

de um código de barras, bem como determiná-lo por um algoritmo.

58

4.2.2 Objetivos Especíﬁcos

• Reconhecer o dígito veriﬁcador em um código de barras;

• Compreender a funcionalidade do dígito veriﬁcador;

• Entender e aplicar o algoritmo utilizado para determinação do dígito veriﬁcador.

4.2.3 Público Alvo

Alunos do 7o ano do ensino fundamental II.

4.2.4 Pré-Requisitos

• Realizar as operações com números naturais, tais como adição, subtração, multiplicação

e divisão;

• Reconhecer quando um número é divisível pelo outro, aplicando os critérios de divisibi-

lidade;

• Compreender informações contidas nos códigos de barras;

• Entender e aplicar um algoritmo.

4.2.5 Materiais Necessários

Lápis, borracha e uma folha contendo os códigos de barras.

4.2.6 Proposta da Atividade

Os alunos irão reconhecer a importância do dígito veriﬁcador e determiná-lo através de

um algoritmo. Para isso, veremos o exemplo a seguir, passo-a-passo, de como deve ser feita a

atividade.

Exemplo 4.2. Consideremos o código 789162731405. Determine o dígito veriﬁcador desse código.

Sugere-se que a atividade seja feita em duplas, aﬁm de proporcionar uma discussão acerca
do resultado encontrado. Solicitar códigos de barras, que podem ser trazidos pelo professor

59

ou solicitado, previamente, aos alunos.

Deve-se explicar como é feita a veriﬁcação da validade do código, isso é, explicando como

é feito o algoritmo para a determinação do mesmo.

Segundo [7] , algoritmo é uma sequência de instruções que podem ser executadas mecani-

camente, por uma pessoa ou uma máquina (computador).

1o passo: Suponhamos que estamos usando o código de barras dado no exemplo e quere-

mos saber qual é o dígito ﬁnal (veriﬁcador).

2o passo: Somamos todos os dígitos das posições ímpares (primeira, terceira, quinta, etc).

Portanto:

7 + 9 + 6 + 7 + 1 + 0 = 30

3o passo: Multiplicamos todos os dígitos das posições pares (segunda, quarta, sexta, etc)

por 3 e somamos esses produtos:

8x3 + 1x3 + 2x3 + 3x3 + 4x3 + 5x3 = 69

4o passo: Somamos os dois resultados das etapas anteriores. Daí:

30 + 69 = 99

5o passo: Determine o número que deve ser adicionado ao resultado da soma para se criar

um múltiplo de 10. Portanto:

99 + 1 = 100

Portanto, o dígito veriﬁcador é 1.

Aﬁm de dinamizar mais a atividade, seria interessante que o professor solicitasse que eles
troquem um dos dígitos do código de barras e depois veriﬁquem se o resultado obtido coincide

com o dígito veriﬁcador.

60

CONCLUSÃO

Indubitavelmente, a presença da matemática é notória em vários segmentos da tecnologia
que surgiu ou que ainda irá surgir. O surgimento dos códigos de barras foi de suma importân-

cia para que uma ida ao supermercado, por exemplo, e registrar suas compras, deixasse de ser

algo tão lento, contribuindo, então, para o progresso, em particular, do comércio mundial.

Como fora exposto neste trabalho, a presença do código de barras tornou-se uma tecnologia

indispensável nos dias atuais, auxiliando as empresas no controle e identiﬁcação de produtos,

bem como na agilização do atendimento ao cliente, atendimento bancário e entre diversos se-

tores.

Os códigos de barras devem ser controlados para tornar possível a detecção de erros de

codiﬁcação. Isso signiﬁca que quando, por exemplo, um caixa do supermercado digitar um

número errado do código que identiﬁca o produto, esse erro de codiﬁcação deve ser "avisado".
Para isso, criou-se um grupo de algarismos, denominados dígitos veriﬁcadores.

Neste sentido, ao abordar o tema Aritmética Modular nos Códigos de Barras, reiteramos

conceitos matemáticos imprescindíveis para a realização do tema, sendo aplicados nos Siste-
mas de Identiﬁcação Modular (SIM) e na Detecção de Erros.

Por ﬁm, foram propostas duas situações de aprendizagem articulando o real e o ﬁctício,

onde além de proporcionar um ambiente investigativo e criativo, será possível fazer conexões

61

entre diversos conceitos matemáticos, suas diferentes formas de pensamento, e ainda, promo-

ver a relação da Matemática com outras áreas do saber e da atualidade, valorizando a tendência

atual.

62

REFERÊNCIAS BIBLIOGRÁFICAS

[1] DOMINGUES; H. Hygino:Fundamentos de aritmética; São Paulo, Atual, 1991.

[2] HEFEZ, Abramo: Elementos de Aritmética; 2a ed, Rio de Janeiro, SBM, 2011.

[3] HEFEZ, Abramo: Iniciação à Aritmética - Programa de Iniciação Cientíﬁca, OBMEP, Ed.

da SBM, Rio de Janeiro-RJ, 2012.

[4] OLIVEIRA, Krerley Irraciel Martins: FERNANDEZ, Adán José Carcho: Iniciação à Mate-

mática: um curso com problemas e soluções, 2a ed., Rio de Janeiro, SBM, 2010.

[5] AVRITZER, Dan: Geometria Analítica e Álgebra Linear: uma visão geométrica. Belo Hori-

zonte. Editora UFMG, 2009.

[6] POLCINO MILIES, C. A matemática dos códigos de barras. Programa de Iniciação Cientí-

ﬁca da OBMEP. Rio de Janeiro: OBMEP, 2009, v., p. 131-179.

[7] FINI, Maria Inês: Controle dos Códigos de Identiﬁcação. Revista do Professor - Atualida-

des, SEESP, Edição no2, p. 70 - 75, 2009.

[8] BARCODE ISLAND. Disponível em: <http://www.barcodeisland.com/ean13.phtml>.

Acesso em: 01 de dezembro de 2015.

[9] GS1

BRASIL

(Associação

Brasileira

de

Automação).

Disponível

em:

<http://www.gs1br.org>. Acesso em: 01 de dezembro de 2015.

63

[10] Portal ItDirect. Disponível em: <http://itdirectbrasil.blogspot.com.br/2013/01/codigos-

2d-ou-qr-code.html>. Acesso em: 01 de dezembro de 2015.

[11] QR codes

e Realidade Aumentada,

por Martha Gabriel. Disponível

em:

<http://pt.slideshare.net/marthagabriel/qr-codes-realidade-aumentada-por-martha-

gabriel>. Acesso em: 01 de dezembro de 2015.

[12] Código de Barras Code 128, Código 128, GS1 128, EAN 128, UPC 128. Disponível em:

<http://www.code128.com.br/tag/codigos-de-barras>. Acesso em: 01 de dezembro de

2015.

[13] Código de Barras EAN. Disponível em: <https://www.codigodebarrasean.com/codigo-

de-barras-imagem-ean.html>. Acesso em: 01 de dezembro de 2015.

[14] COSTA, F. R. A. Sistemas de Identiﬁcação Modular: uma aplicação no ensino funda-
mental. 2014. 22 f. Trabalho de Conclusão de Curso do Mestrado Proﬁssional em Matemá-
tica - PROFMAT. Ouro Branco, MG: Universidade Federal de São João del-Rei.

64

