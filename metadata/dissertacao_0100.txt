UNIVERSIDADE ESTADUAL DO CEARÁ

FACULDADE DE EDUCAÇÃO, CIÊNCIAS E LETRAS DO SERTÃO CENTRAL

PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA

MESTRADO PROFISSIONAL EM MATEMÁTICA

GUSTAVO NOGUEIRA LEITE

PYTHON E FORTRAN COMO FERRAMENTA NA RESOLUÇÃO DE PROBLEMAS

DE MATEMÁTICA E FÍSICA

QUIXADÁ – CEARÁ

2020

GUSTAVO NOGUEIRA LEITE

PYTHON E FORTRAN COMO FERRAMENTA NA RESOLUÇÃO DE PROBLEMAS DE

MATEMÁTICA E FÍSICA

Dissertação apresentada ao Curso de Mestrado
Proﬁssional em Matemática do Programa de
Pós-Graduação em Matemática do Faculdade de
Educação, Ciências e Letras do Sertão Central
da Universidade Estadual do Ceará, como requi-
sito parcial à obtenção do título de mestre em
Matemática. Área de Concentração: Matemática

Orientador: Prof. Dr.
Oliveira

Jobson de Queiroz

Co-Orientador: Prof. Dr. Antonio Joel
Ramiro de Castro

QUIXADÁ – CEARÁ

2020

 
 
 
 
 
 
 
 
 
 
 
 
 
GUSTAVO NOGUEIRA LEITE

PYTHON E FORTRAN COMO FERRAMENTA NA RESOLUÇÃO DE PROBLEMAS DE

MATEMÁTICA E FÍSICA

Dissertação apresentada ao Curso de Mestrado
Proﬁssional em Matemática do Programa de
Pós-Graduação em Matemática do Faculdade
de Educação, Ciências e Letras do Sertão
Central da Universidade Estadual do Ceará,
como requisito parcial à obtenção do título de
mestre em Matemática. Área de Concentração:
Matemática

Aprovada em: 20 de Dezembro de 2020

BANCA EXAMINADORA

Prof. Dr. Jobson de Queiroz Oliveira (Orientador)
Universidade Estadual do Ceará UECE

Prof. Dr. Antonio Joel Ramiro de Castro (Co-Orientador)
Universidade Federal do Ceará - UFC

Prof. Dr. Ulisses Lima Parente
Universidade Estadual do Ceará UECE

Prof. Dr. Otávio Paulino Lavor
Universidade Federal Rural do Semi-Árido - UFERSA

AGRADECIMENTOS

Se você participou dessa jornada, de modo direto ou indireto, sinta-se agradecido.

“ This statement is true, I guess. ”

“ Estaremos sempre sob o mesmo céu. ”

(...)

RESUMO

O uso das linguagens de programação tem aumentado enormemente em diversas áreas. Por essa

razão neste trabalho é feita uma contextualização histórica da linguagem de programação Python

e Fortran motivados pela aplicabilidade tanto em Matemática quanto em Física. Também é

dedicada uma parte deste trabalho para a manipulação básica de cada uma das linguagens. Foram

escolhidos cinco problemas, três problemas de Matemática e dois problemas de Física para

serem resolvidos de maneira algorítmica, apresentando a solução desses problemas utilizando as

duas linguagens em questão. Esse estudo é signiﬁcativo devido ao grande emprego de recursos

computacionais nas diversas áreas da Matemática, tanto em setores acadêmicos quanto em

setores comerciais. Por este motivo, a motivação deste trabalho é aplicar as linguagens de

computação como instrumento para cálculos matemáticos, conhecer as linguagens Fortran e

Python e suas usabilidades.

Palavras-chave: Python. Fortran. Linguagens de Programação. Matemática. Física.

ABSTRACT

The use of programming languages has increased enormously in several areas. For this reason,

in this work, a historical contextualization of Python and Fortran programming language is done,

motivated by applicability in Mathematics and Physics. Part of this work is also dedicated to

basic manipulation from each languages. Five problems, three Mathematics problems and two

Physics problems were chosen to be solved in an algorithmic way, presenting the solution of

these problems using two languages in question. This study is signiﬁcant due to large use of

computational resources in various areas of Mathematics, both in academic and commercial

sectors. For this reason, the motivation of this work is to apply computer languages as an

instrument to mathematical calculations, know Fortran and Python languages and their usability.

Keywords: Python. Fortran. Programming languages. Math, Physic.

LISTA DE FIGURAS

Figura 1 – Onda senoidal. .

Figura 2 – Multiplots.

.

.

Figura 3 – Usando grids.

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Figura 4 – Gráﬁco da interpolação de um conjunto de dados extraídos da função

f (x) = sin (x)/x.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Figura 5 – Aproximando função f (x) = ex pelo método de spline cúbico. . . . . .

Figura 6 – Área sob uma curva . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Figura 7 – Divisão dos intervalos . . . . . . . . . . . . . . . . . . . . . . . . . . . .

34

35

36

62

71

77

83

Figura 8 – Soluções aproximadas.

. . . . . . . . . . . . . . . . . . . . . . . . . . . 101

Figura 9 – Solução da equação y(cid:48) = y, y(0) = 1 usando método de Euler. . . . . . 102

Figura 10 – Solução da equação y(cid:48) = y, y(0) = 1 usando método de Euler com

regra trapezoidal.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

Figura 11 – Comparação dos métodos de Euler, Euler com regra trapezoidal e Runge-

Kutta na solução da equação y(cid:48) = y − t2 + 1, y(0) = 0.5.

. . . . . . . 109

Figura 12 – Movimento em uma dimensão.

. . . . . . . . . . . . . . . . . . . . . . . 127

Figura 13 – Movimento de projétil em uma dimensão com resistência. . . . . . . . . 129

Figura 14 – Diagrama de corpo livre para um projétil.

. . . . . . . . . . . . . . . . 129

Figura 15 – Trajetória de um projétil com e sem resistência.

. . . . . . . . . . . . . 133

Figura 16 – Um pêndulo de massa m, sob a ação da força da gravidade. . . . . . . . 134

Figura 17 – Pêndulo com amortecimento. . . . . . . . . . . . . . . . . . . . . . . . . 137

Figura 18 – Energia cinética, potencial e total.

. . . . . . . . . . . . . . . . . . . . . 138

Figura 19 – Pêndulo com um torque externo. . . . . . . . . . . . . . . . . . . . . . . 138

Figura 20 – Posição para amplitude igual a 1,2.

. . . . . . . . . . . . . . . . . . . . 139

Figura 21 – Velocidades para amplitude igual a 1,2.

. . . . . . . . . . . . . . . . . . 139

Figura 22 – Energia para amplitude igual a 1,2.

. . . . . . . . . . . . . . . . . . . . 139

LISTA DE TABELAS

Tabela 1 – Operadores Aritméticos.

. . . . . . . . . . . . . . . . . . . . . . . . . .

Tabela 2 – Operadores de comparação.

. . . . . . . . . . . . . . . . . . . . . . . .

Tabela 3 – Operadores lógicos.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Tabela 4 – Manipulação de strings. . . . . . . . . . . . . . . . . . . . . . . . . . . .

Tabela 5 – Funções para Listas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Tabela 6 – Palavras chaves da linguagem.

. . . . . . . . . . . . . . . . . . . . . . .

Tabela 7 – Operadores aritméticos. . . . . . . . . . . . . . . . . . . . . . . . . . . .

Tabela 8 – Operadores relacionais.

. . . . . . . . . . . . . . . . . . . . . . . . . . .

Tabela 9 – Algumas funções matemáticas . . . . . . . . . . . . . . . . . . . . . . .

Tabela 10 – Valores para alguns pontos de ln x . . . . . . . . . . . . . . . . . . . . .

Tabela 11 – Esquema de diferenças divididas para um conjunto de pontos

. . . . .

Tabela 12 – Tabela Romberg .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

20

20

20

22

24

39

43

43

55

60

64

89

LISTA DE CÓDIGOS-FONTE

Código-fonte 1 – Tipo e operação com inteiros.

. . . . . . . . . . . . . . . . . . . .

Código-fonte 2 – Tipo e operação com ﬂutuantes. . . . . . . . . . . . . . . . . . . .

Código-fonte 3 – Variáveis e operação com string.

. . . . . . . . . . . . . . . . . .

Código-fonte 4 – Deﬁnição e exemplo com Lista.

. . . . . . . . . . . . . . . . . . .

Código-fonte 5 – Deﬁnição e exemplo com Tuplas.

. . . . . . . . . . . . . . . . . .

Código-fonte 6 – Deﬁnição e exemplo de sintaxe dos condicionais.

. . . . . . . . .

Código-fonte 7 – Deﬁnição e exemplo de sintaxe do laço for.

. . . . . . . . . . . . .

Código-fonte 8 – Deﬁnição e exemplo de sintaxe do laço while.

. . . . . . . . . . .

Código-fonte 9 – Deﬁnição e exemplo de sintaxe de funções. . . . . . . . . . . . . .

Código-fonte 10 – Exemplo de uso da biblioteca math. . . . . . . . . . . . . . . . . .

Código-fonte 11 – Arrays em Numpy.

. . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 12 – Gráﬁco onda senoidal usando matplotlib . . . . . . . . . . . . . .

Código-fonte 13 – Usando subplot. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 14 – Usando grid.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 15 – Programa principal . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 16 – Soma dois números.

. . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 17 – Maior valor armazenado em inteiro de quatro bytes.

. . . . . . .

19

19

21

22

25

26

27

28

29

30

31

33

35

36

37

37

39

Código-fonte 18 – Maior número que pode ser armazenado pelo tipo de dado inteiro. 39

Código-fonte 19 – Dado tipo real.

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 20 – Exemplo character . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 21 – Sintaxe if... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 22 – Exemplo usando if.

. . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 23 – Sintaxe if... else. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 24 – Exemplo usando if... else.

. . . . . . . . . . . . . . . . . . . . . .

Código-fonte 25 – Sintaxe de if... else if... else.

. . . . . . . . . . . . . . . . . . . . .

Código-fonte 26 – Exemplo usando if... else if... else. . . . . . . . . . . . . . . . . . .

Código-fonte 27 – Sintaxe de if... aninhada. . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 28 – Exemplo usando if... aninhado.

. . . . . . . . . . . . . . . . . . .

Código-fonte 29 – Sintaxe de do loop.

. . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 30 – Fatorial dos números de 1 a 10.

. . . . . . . . . . . . . . . . . . .

Código-fonte 31 – Declaração de parada.

. . . . . . . . . . . . . . . . . . . . . . . .

40

41

44

44

45

45

46

46

47

47

48

49

50

Código-fonte 32 – Declaração de array.

. . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 33 – Declaração de array bidimensional. . . . . . . . . . . . . . . . . .

Código-fonte 34 – Adição de arrays em Fortrab . . . . . . . . . . . . . . . . . . . .

Código-fonte 35 – Slicing arrays em Fortran . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 36 – Cáculo area de um círculo. . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 37 – Usando sub-rotina.

. . . . . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 38 – Interpolação de Lagrange . . . . . . . . . . . . . . . . . . . . . .

Código-fonte 39 – Interpolação de Lagrange com múltiplos argumentos . . . . . . .

Código-fonte 40 – Interpolação usando Polinômio de Lagrange . . . . . . . . . . . .

50

51

51

52

53

54

58

59

60

Código-fonte 41 – Interpolação usando Polinômio de Lagrange . . . . . . . . . . . .

61

Código-fonte 42 – Interpolação usando Método de Newton . . . . . . . . . . . . . .

Código-fonte 43 – Polinômio interpolador passando pelos pontos dados. . . . . . . .

Código-fonte 44 – Interpolação usando Método de spline cúbico . . . . . . . . . . .

63

64

68

Código-fonte 45 – Interpolação de Lagrange . . . . . . . . . . . . . . . . . . . . . .

71

Código-fonte 46 – Interpolação de Lagrange com múltiplos argumentos . . . . . . .

Código-fonte 47 – Interpolação usando método de Newton . . . . . . . . . . . . . .

Código-fonte 48 – Interpolação usando Método de spline cúbico . . . . . . . . . . .

Código-fonte 49 – Integração de uma função usando o método dos trapézios . . . .

Código-fonte 50 – Integração de uma função usando o método de Simpson . . . . .

72

73

74

78

82

Código-fonte 51 – Integração de uma função usando o método dos Trapézio Adap-

tativo .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

84

Código-fonte 52 – Integração de uma função usando o método de Simpson Adaptativo 86

Código-fonte 53 – Integração de uma função usando o método de romberg . . . . .

Código-fonte 54 – Integração de uma função usando o método dos trapézios . . . .

89

91

Código-fonte 55 – Integração de uma função usando o método dos trapézios Adaptivo 92

Código-fonte 56 – Integração de uma função usando o método de Simpson . . . . .

93

Código-fonte 57 – Integração de uma função usando o método de Simpson Adaptivo 94

Código-fonte 58 – Integração de uma função usando o método de romberg . . . . .

96

Código-fonte 59 – Método de Euler.

. . . . . . . . . . . . . . . . . . . . . . . . . . . 101

Código-fonte 60 – Método de Euler usando a regra trapezoidal.

. . . . . . . . . . . 102

Código-fonte 61 – Método de Runge-Kutta de terceira ordem.

. . . . . . . . . . . . 107

Código-fonte 62 – Método de Runge-Kutta de terceira ordem.

. . . . . . . . . . . . 108

Código-fonte 63 – Método de Runge-Kutta de terceira ordem.

. . . . . . . . . . . . 109

Código-fonte 64 – Método de Runge-Kutta para um sistema de k equações. . . . . . 113

Código-fonte 65 – Método de Runge-Kutta para um sistema de k equações usando

a biblioteca numpy. . . . . . . . . . . . . . . . . . . . . . . . . . . 115

Código-fonte 66 – Método de Euler.

. . . . . . . . . . . . . . . . . . . . . . . . . . . 115

Código-fonte 67 – Método de Euler usando a regra trapezoidal.

. . . . . . . . . . . 116

Código-fonte 68 – Método de Runge-Kutta de terceira ordem.

. . . . . . . . . . . . 117

Código-fonte 69 – Método de Runge-Kutta de quarta ordem. . . . . . . . . . . . . . 118

Código-fonte 70 – Comparação dos métodos de Euler, Euler com trapezoidal e Runge-

Kutta na solução da equação y(cid:48) = y − t2 + 1, y(0) = 0.5. . . . . 119

Código-fonte 71 – Método de Runge-Kutta para um sistema de k equações. . . . . . 122

Código-fonte 72 – Simular movimento de projétil em uma dimensão.

. . . . . . . . 126

Código-fonte 73 – Movimento de projétil em uma dimensão com resistência.

. . . . 128

Código-fonte 74 – Trajetória de um projétil com e sem resistência. . . . . . . . . . . 131

Código-fonte 75 – Movimento de um pêndulo sob ação da gravidade.

. . . . . . . . 135

Código-fonte 76 – Simular movimento de projétil em uma dimensão.

. . . . . . . . 140

Código-fonte 77 – Trajetória de um projétil com e sem resistência. . . . . . . . . . . 141

Código-fonte 78 – Movimento de um pêndulo sob ação da gravidade.

. . . . . . . . 144

SUMÁRIO

INTRODUÇÃO .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

NOÇÕES BÁSICAS DE PROGRAMAÇÃO . . . . . . . . . . . . . . . .

Condicionais e Laços

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Noções Python .

Variáveis .

String .

Listas .

Tuplas

.

.

.

.

.

.

.

.

. .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

Funções

. .

Bibliotecas .

.

.

.

.

.

.

Noções Fortran .

Sintaxe básica .

Tipos de dados .

Variáveis .

.

Operadores .

.

.

Condicionais .

Loops .

Arrays

.

.

.

.

. .

.

.

.

.

.

.

.

Procedimentos .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

21

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

41

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Funções intrínsecas

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

INTERPOLAÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Polinômios de Lagrange . . . . . . . . . . . . . . . . . . . . . . . . . . .

Diferenças divididas de Newton . . . . . . . . . . . . . . . . . . . . . . .

Interpolação por Spline Cúbico . . . . . . . . . . . . . . . . . . . . . . .

Implementação em Fortran . . . . . . . . . . . . . . . . . . . . . . . . .

INTEGRAÇÃO DE FUNÇÕES . . . . . . . . . . . . . . . . . . . . . . .

O Método dos Trapézios . . . . . . . . . . . . . . . . . . . . . . . . . . .

O Método de Simpson . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Quadratura Adaptativa . . . . . . . . . . . . . . . . . . . . . . . . . . .

Método de Romberg . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Implementação em Fortran . . . . . . . . . . . . . . . . . . . . . . . . .

15

18

18

18

22

24

25

28

30

36

36

38

43

44

48

50

52

55

56

56

62

65

71

77

77

79

82

87

91

1

2

2.1

2.1.1

2.1.2

2.1.3

2.1.4

2.1.5

2.1.6

2.1.7

2.2

2.2.1

2.2.2

2.2.3

2.2.4

2.2.5

2.2.6

2.2.7

2.2.8

2.2.9

3

3.1

3.2

3.3

3.4

4

4.1

4.2

4.3

4.4

4.5

5

5.1

5.2

5.3

5.4

6

6.1

6.2

6.3

7

EQUAÇÕES DIFERENCIAIS ORDINÁRIAS . . . . . . . . . . . . . . .

Método de Euler .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

99

99

Métodos de Runge-Kutta . . . . . . . . . . . . . . . . . . . . . . . . . . 103

Sistema de equações diferenciais

. . . . . . . . . . . . . . . . . . . . . . 112

Implementação em Fortran . . . . . . . . . . . . . . . . . . . . . . . . . 115

PROPOSTA DE ATIVIDADE NO ENSINO MÉDIO . . . . . . . . . . . 125

Movimento de projétil

. . . . . . . . . . . . . . . . . . . . . . . . . . . . 125

Pêndulo .

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

Implementação em Fortran . . . . . . . . . . . . . . . . . . . . . . . . . 140

CONSIDERAÇÕES FINAIS . . . . . . . . . . . . . . . . . . . . . . . . 146

REFERÊNCIAS .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149

15

1 INTRODUÇÃO

A Linguagem de Programação (LP) é uma mecanismo utilizado em computação

para escrever programas - algoritmo -, isto é, conjuntos de instruções sequenciadas a serem

seguidas pelo computador para realizar um determinado processo. Dito de outro modo, a LP é a

comunicação entre o indivíduo que deseja resolver um determinado problema e o computador

escolhido para ajudá-lo na solução. Sendo assim, a LP deve fazer a ligação entre o pensamento

humano - por muitas vezes não muito bem estruturado - e a precisão exigida para o processamento

da máquina.

Desenvolver e implementar um algoritmo faz necessário descrevê-lo de forma que o

computador possa executá-lo. Dessa forma, a LP precisa integrar, suportar a deﬁnição de ações -

rotinas - e prover meios para especiﬁcar operações básicas de computação, além de permitir que

usuários especiﬁquem como estas rotinas devem ser sequenciados para resolver um problema.

Uma linguagem de programação pode ser entendida como uma notação usada para especiﬁcar

algoritmos com precisão.

As primeiras LP conhecidas eram códigos de máquina complicados que eram in-

seridos manualmente nas primeiras máquinas de computação. Uma das LP mais antigas, o

FORTRAN foi desenvolvido por uma equipe de programadores da IBM liderada por John

Backus (IBM, 2011), e foi publicado pela primeira vez em 1957. O nome FORTRAN é um

acrônimo para FORmula TRANslation, porque foi projetado para permitir a tradução fácil da

matemática fórmulas em código.

Muitas vezes referida como uma linguagem cientíﬁca, FORTRAN foi a primeira lin-

guagem de alto nível, usando o primeiro compilador já desenvolvido. Antes do desenvolvimento

do FORTRAN, os programadores de computador eram obrigados a programar em código de

máquina, o que era uma tarefa extremamente difícil e demorada, sem mencionar a terrível tarefa

de depurar o código. O objetivo durante seu design era criar uma linguagem de programação que

fosse: simples de aprender, adequada para uma ampla variedade de aplicações, independente

de máquina, e permitiria que expressões matemáticas complexas fossem declaradas de forma

semelhante à notação algébrica regular e ainda quase tão eﬁciente na execução quanto a lingua-

gem assembly. Como FORTRAN era muito mais fácil de codiﬁcar, os programadores foram

capazes de escrever programas mais rápido do que antes, enquanto a eﬁciência de execução foi

pouco reduzida, isso permitiu que eles se concentrassem mais nos aspectos de resolução de um

problema e menos na codiﬁcação .

16

Desde sua criação em 1954 e seu lançamento comercial em 1957 como o progenitor

do software, Fortran se tornou o primeiro padrão de linguagem de computador, "ajudou a abrir as

portas para a computação moderna"e pode muito bem ser o produto de software mais inﬂuente

em história. O Fortran liberou os computadores do domínio exclusivo dos programadores e os

abriu para quase todo mundo. Ainda está em uso mais de 50 anos após sua criação.

Pela primeira vez, FORTRAN tornou o código compreensível para pessoas com

experiência em outras áreas além da computação, abrindo a programação para matemáticos e

cientistas. Alguém que sabia álgebra no ensino médio, mas nada sobre computadores, provavel-

mente poderia descobrir as declarações do Fortran. Fortran iniciou o processo de abstração do

software do hardware em que era executado. Os programas de linguagem de máquina anteriores

tinham que ser escritos para um computador especíﬁco, enquanto um programa Fortran poderia

ser executado em qualquer sistema com um compilador Fortran.

A linguagem de programação Python foi criada em 1991 por Guido Van Rossumem,

no Instituto Nacional de Pesquisa para Matemática e Ciência da Computação da Holanda (CWI)

cujo público alvo originalmente eram físicos e engenheiros (ROSSUM, 1995), com a ﬁnalidade

de ser uma linguagem simples e de fácil compreensão. Além de simples, Python é uma linguagem

muito poderosa, de alto nível que possui um modelo de desenvolvimento aberto, comunitário e

gerenciado pela Python Software Foudation (PSF), sem ﬁns lucrativos. Conta com bibliotecas

poderosas desenvolvidas em comunidades de colaboradores. Pode ser usada para desenvolver e

administrar grandes sistemas.

A linguagem Python se destaca pela facilidade de programação e versatilidade.

Python é uma linguagem de uso geral, que pode ser utilizada para diversas aplicações, como o

tratamento de dados cientíﬁcos, no caso de interesse desta dissertação em soluções numéricas.

Apresenta uma sintaxe simples, tornando os programas mais legíveis, o que também facilita o

aprendizado da linguagem.

A ciência da computação costumava ser uma área reservada apenas ao ensino su-

perior, mas agora está se tornando amplamente adotada nos currículos das escolas primárias e

secundárias. Muitos países pela Europa estão começando a introduzir a codiﬁcação como uma

habilidade básica ao lado da leitura, escrita e aritmética.

Portanto, levando em conta todo o exposto, o presente trabalho tem a proposta de

relacionar o ensino de matemática e física com a utilização da linguagem de programação

Python e Fortran através de resolução de problemas, pois é cada vez mais recorrente o acesso a

tecnologias e as transformações que estas possibilitam à sociedade. Nesse contexto as práticas

17

de ensino podem tentar usufruir desses recursos tecnológicos para dar um maior dinamismo e

tornar a aprendizagem mais prazerosa e signiﬁcativa.

Por ﬁm, o trabalho está organizado da seguinte forma: no capítulo 02, apresentamos

uma introdução as linguagens de programação Python e FORTRAN. Nos capítulos seguintes

resolvemos alguns problemas de análise numérica, sendo eles, o problema de interpolação

polinomial no capítulo 03, integração numérica no capítulo 04, equações diferenciais ordinárias

no capítulo 05 e dois problemas de física para serem aplicados no ensino médio, movimento em

uma e duas dimensões, com e sem atrito, e o pendulo no capítulo 06. Terminamos apresentando,

no capítulo 07, algumas considerações ﬁnais sobre este trabalho.

18

2 NOÇÕES BÁSICAS DE PROGRAMAÇÃO

Programação de computador é o processo de projetar e construir um programa

de computador executável para realizar um resultado de computação próprio ou para realizar

uma tarefa especíﬁca. A programação envolve tarefas como: análise, geração de algoritmos,

precisão dos algoritmos de criação de perﬁl e consumo de recursos, e a implementação de

algoritmos em uma linguagem de programação escolhida (comumente referida como codiﬁcação).

O código-fonte de um programa é escrito em uma ou mais linguagens inteligíveis para os

programadores, ao invés do código de máquina, que é executado diretamente pela unidade

central de processamento. O objetivo da programação é encontrar uma sequência de instruções

que automatizará o desempenho de uma tarefa (que pode ser tão complexa quanto um sistema

operacional) em um computador, geralmente para resolver um determinado problema.

2.1 Noções Python

Python usa tipagem dinâmica, isto é, o tipo de uma variável é inferido pelo interpre-

tador em tempo de execução. Quando uma variável é criada através de atribuição, o interpretador

deﬁne um tipo para a variável, com as operações que podem ser aplicadas. Para uma descrição

mais completa a respeito das operações e funções básicas de Python, consultar (BORGES, 2014).

Todas noções básicas de programação em Python discutidas nessa dissertação são facilmente

encontradas em manuais e livros disponíveis na literatura (MENEZES, 2010; TELECOMUNI-

CAÇOES; TUTORIAL; GRUPO, 2011; BEAZLEY; JONES, 2013; LABAKI; WOISKI, v. 2,

2003).

2.1.1 Variáveis

Variáveis são pequenos espaços reservados de memória, utilizados para armazenar,

atribuir e manipular dados. Os tipos (ou classe) de dados básicos são: tipo inteiro, armazena

números inteiros; tipo float, ﬂutuante, armazena números em formato decimal; e tipo string,

armazena um conjunto de caracteres. Cada variável pode armazenar apenas um tipo de dado por

vez.

Observação a ser feita é que, em Python, ao contrário de outras linguagens, não é

preciso declarar o tipo de cada variável no início do programa. Quando se faz uma atribuição

de valor, automaticamente a variável se torna do tipo do valor armazenado. Alguns exemplos

apresentados a seguir:

Código-fonte 1 – Tipo e operação com inteiros.

19

1 # Define valores . Somente inteiros

2 a = 5; b = 2

3

4 print ( " a + b = " , a + b )

5 print ( " a - b = " , a - b )

6 print ( " a * b = " , a * b )

7 print ( " a // b = " , a // b )

8

9 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

10 a + b =

11 a - b =

12 a * b =

13 a // b =

7

3

10

2

Fonte: Elaborado pelo autor.

As variáveis a e b se tornam variáveis do tipo(classe) inteiro, ‘int’, como

especiﬁcado na linha 2 na Saída do programa Tipo e operação com inteiros, código 1. Deve-se

frisar, o modo como são deﬁnidos as operações básicas de soma, subtração, multiplicação e

divisão("//"), nesse caso aplicados aos inteiros.

Código-fonte 2 – Tipo e operação com ﬂutuantes.

1 # Define valores . Somente flutuantes

2 c = 5.0; d = 2.0

3

4 print ( " c + d = " , c + d )

5 print ( " c - d = " , c - d )

6 print ( " c * d = " , c * d )

7 print ( " c / d = " , c / d )

8

9 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

10 c + d =

11 c - d =

7.0

3.0

12 c * d =

10.0

13 c / d =

2.5

Fonte: Elaborado pelo autor.

As variáveis c e d se tornam variáveis do tipo(classe) ﬂutuante, ‘flot’, como

especiﬁcado na linha 2 na Saída do programa Tipo e operação com ﬂutuantes, código 2. Deve-se

frisar, o modo como são deﬁnidos as operações básicas de soma, subtração, multiplicação e

divisão("/"), nesse caso aplicados aos ﬂutuantes

20

Tabela 1 – Operadores Aritméticos.

Operador

Descrição

Exemplo

+
-
*
/
%
**

soma
subtração
multiplicação
divisão
resto da divisão
potenciação

5 + 5 = 10
7 - 2 = 5
2 * 2 = 4
4 / 2 = 2
10 % 3 = 1
4**2 = 16

Fonte: Elaborado pelo autor.

Tabela 2 – Operadores de comparação.

Operador

Descrição

Exemplo

<
<=
>
>=
==
!=

menor que
menor ou igual
maior
maior ou igual
igual
diferente

a < 10
b <= 5
c > 4
d >= 2
e == 1
f != 16

Fonte: Elaborado pelo autor.

Tabela 3 – Operadores lógicos.

Operador Descrição

Exemplo

Not
And
Or

NÃO
E
OU

not a
(a<=10) and (c=8)
(a<=15) or (c=18)

Fonte: Elaborado pelo autor

Os tipos numéricos básicos utilizados em Python, são números inteiros (int), núme-

ros decimais (float) e, por sua vez, números longos (long) e números complexos (complex).

Com isso, a linguagem também possui seus operadores aritméticos, lógicos, de comparação,

como descritos nas tabelas 1, 2 e 3.

21

2.1.2 String

A atribuição de valor para uma variável pode ser conseguido utilizando o comando

input(...), que solicita ao usuário o valor a ser atribuído à variável. O comando input(...),

sempre vai retornar uma string. Nesse caso, para retornar dados do tipo inteiro ou float, é

preciso converter o tipo do valor lido. Para isso, utiliza-se o int (string) para converter para

o tipo inteiro, ou float (string) para converter para o tipo float. Como mostra os exemplos

a seguir

Código-fonte 3 – Variáveis e operação com string.

1 nome = input ( " Inserir seu nome : " )

2 print ( " O nome inserido foi : " , nome )

3

4 num = int ( input ( " Adicione um n ú mero : " ) )

5 print ( " O n ú mero inserido foi : " , num )

6

7 altura = float ( input ( " Inserir sua altura ( m ) : " ) )

8 print ( " A altura inserida foi : " , altura , " m . " )

9 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

10 Inserir seu nome : Fulano de Beltrano

11 O nome inserido foi :

Fulano de Beltrano

12

13 Adicione um n ú mero : 125

14 O n ú mero inserido foi :

125

15

16 Inserir sua altura : 1.72

17 A altura inserida foi : 1.72 m .

Fonte: Elaborado pelo autor.

Os nomes das variáveis em Python devem ser iniciados com uma letra, porém podem

possuir outros tipos de caracteres, como números e símbolos. O símbolo sublinha ( _ ), ou

"underline", também é aceito no início de nomes de variáveis.

Uma string nada mais é do que uma sequência de caracteres simples. Em Python,

strings são utilizadas com aspas simples (‘...’) ou aspas duplas ("..."), como escrita nos

exemplos 1, 2 e 3 acima. A saber, para exibir uma string, utiliza-se do comando print(). Ou

seja, os argumentos da função print(), como feitos nos exemplos acima, que são escritas em

22

aspas simples ou duplas trata-se de strings. Outro exemplo básico e usual nos cursos iniciais

de programação é escrever o primeiro código para mostrar a frase "Hello, World!", que se faz

em Python apenas com o comando print("Hello, World!").

A manipulação de strings se faz mediante diferentes métodos, ou funções. A

seguir são listadas algumas dessas funções de manipulação:

Tabela 4 – Manipulação de strings.

Método

len()

Descrição

Retorna o tamanho da string.

split()

Transforma a string em uma lista,
utilizando os espaços como referência.

Exemplo
teste = “Apostila de Python”
len(teste)
18
m = "cana de açúcar"
m.split()
[’cana’, ’de’, ’açúcar’]

Fonte: Elaborado pelo autor

As strings são abreviadas pela sigla "str", já os inteiros são abreviados pela

sigla "int"(abreviação do inglês "integer"). As funções como type() e print() são tipos

embutidos no Python como vimos nos exemplos acima.

2.1.3 Listas

Na linguagem Python, uma Lista é uma coleção de valores indexada, identiﬁcada,

onde cada valor tem sua posição identiﬁcada por um índice; a saber, o índice 0 denota primeiro

item na lista, o índice 1 denota o segundo item, e assim por diante. A notação usada para designar

uma lista, são os colchetes, ([ ]), e por sua vez os elementos devem ser postos e separados por

virgulas.

Um exemplo de lista cujos elementos postos entre colchetes e os itens adicionados

são separados por vírgula, é mostrado no código a seguir

Código-fonte 4 – Deﬁnição e exemplo com Lista.

1 nomeLista = [ elemento1 , elemento2 , ... , elementoN ]

2

3 L = [3 , ' abacate ' , 9.7 , [5 , 6 ] , " Python " , (3 , 'j ') ]

4 print ( L [2])

5 print ( L [3])

6 print ( L [3][1])

7

8 frutas = [ ' Manga ' , ' Laranja ' , ' Abacaxi ' , ' Mamao ' , ' Goiaba ']

9 print ( type ( frutas ) )

10 print ( frutas [4])

11

12 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

23

13 9.7

14 [5 , 6]

15 6

16 type ' list '

17 Goiaba

Fonte: Elaborado pelo autor

Na linha 1 do código acima temos a deﬁnição de lista, onde nomeLista trata-se da

variável na qual armazenamos a informação de todo conteúdo que ﬁca a direita da igualdade. Os

elementos da lista, elemento1 até o elementoN, são separados por vírgulas.

Da linha 3 até a linha 6, temos o exemplo 1 de lista. Neste, L é a variável que

armazenamos a informação contida na lista. Note que uma lista pode ter elementos inteiros,

string, como também uma "sub-lista"e assim por diante, desde que sejam separadas por

virgulas. Na linha 4, pede-se para que seja impressa, pela função print(), o elemento [2] da

lista L, representado por L[2]. O mesmo se repete para a linha 5. Vejamos agora que há uma

"sub-lista"em L, localizado na posição [3], e com isso, a linha 6, pede para que seja impressa na

tela o conteúdo da sub-lista que ﬁca na posição [1].

Na linha 8 temos o exemplo 2, onde criamos a variável do tipo lista chamada

‘frutas’ contendo cinco nomes como os seus itens. Como já visto antes a função type() (Linha

9) traz o tipo de variável. Observe que na linha 10 imprimimos um item da lista acessando o

índice [4].

Outra característica das listas em Python é que elas são mutáveis, podendo ser altera-

das depois de terem sido criadas. Dito de outro modo, podemos adicionar, remover e até mesmo

alterar os itens de uma lista, bem como fazer as operações básicas como soma(concatenação) de

listas, por exemplo, deﬁnindo as variáveis

a = [0,1,2]

b = [3,4,5]

c = a + b

print(c) → [0, 1, 2, 3, 4, 5];

24

multiplicação(repetição) de listas,

L = [1,2]

R = L * 4

print(R) → [1, 2, 1, 2, 1, 2, 1, 2];

fatiamento etc. Resumidos na tabela (5) estão algumas funções básicas de manipulação de listas.

Tabela 5 – Funções para Listas.

Função

Descrição

Exemplo

len()

min()

max()

sum()

retorna o tamanho da lista.

retorna o menor valor da lista.

retorna o maior valor da lista.

retorna soma dos elementos da lista.

append()

adiciona um novo valor na no ﬁnal da lista.

sort()

ordena em ordem crescente

L = [1, 2, 3, 4]
len(L) → 4
L = [10, 40, 30, 20]
min(L) → 10
L = [10, 40, 30, 20]
max(L) → 40
L = [10, 30, 20]
sum(L) → 60
L = [1, 2, 3]
L.append(100)
L → [1, 2, 3, 100]
L = [3, 5, 2, 4, 1, 0]
L.sort()
L → [0, 1, 2, 3, 4, 5]

Fonte: Elaborado pelo autor

2.1.4 Tuplas

Assim como nas lista, uma tupla é uma coleção de valores indexada, identiﬁcada,

onde cada valor tem sua posição identiﬁcada por um índice; a saber, análogo ao anterior, o índice

0 denota primeiro item na tupla, o índice 1 denota o segundo item, e assim por diante. A notação

usada para designar uma tupla, são os parenteses, (

), e por sua vez os elementos devem

ser postos e separados por virgulas. A diferença entre Listas e Tuplas, é que nesta última são

imutáveis, ou seja, seus elementos não podem ser alterados.

Uma tupla é imutável, ou seja, após ser criada, ela não pode ser alterada. Vejamos

como deﬁne-se e se usa no código abaixo

25

Código-fonte 5 – Deﬁnição e exemplo com Tuplas.

1 nomeTupla = ( valor1 , valor2 , ... , valorN )

2

3 naipesBaralho = ( ' Copas ' , ' Espadas ' , ' Paus ' , ' Ouros ')

4 print ( naipesBaralho )

5

6 t = (10 ,20 ,30 ,40 ,50)

7 a ,b ,c ,d , e = t

8 print ( " a = " ,a , " b = " ,b )

9 print ( " d + e = " ,d + e )

10 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

11 ( ' Copas ' , ' Espadas ' , ' Paus ' , ' Ouros ')

12 a = 10 b = 20

13 d + e = 90

Fonte: Elaborado pelo autor.

Na linha 1 do código acima temos a deﬁnição de tupla, onde nomeTupla trata-se da

variável na qual armazenamos a informação de todo conteúdo que ﬁca a direita da igualdade. Os

elementos da tupla, valor1 até o valorN, são separados por vírgulas.

Na linha 3 temos o exemplo 1 de tupla. Neste, naipesBaralho é a variável que

armazenamos a informação contida na tupla. Na linha 6 é dado o exemplo 2 de tupla, T é a

variável que armazena a informação da tupla. Vejamos que na linha 7, está respectivamente

associando-se para cada elemento da tupla as novas variáveis a,b, c, d e e. Em seguida pede-se

para que seja impressa, pela função print() os valores das respectivas variáveis.

2.1.5 Condicionais e Laços

Facilmente se encontra em programas escritos em Python que certos conjuntos de

instruções sejam executados de forma condicional, para casos em que se quer validar entradas de

dados respeitando certas condições. Para esses casos condicionais chamamos de estrutura de

decisão. Essas permitem modicar o curso do ﬂuxo de execução de um programa, a depender do

valor (Verdadeiro/Falso)(True/false) de um teste lógico. Em Python as estruturas de decisão são

as seguintes:

• if (se): é usado para decidir se determinado trecho do programa deve ou não ser executado.

Está associado a uma condição, e será executado se o valor da condição for verdadeiro.

26

• if..else (se..senão): é usado se determinado trecho de código uma condição for verda-

deira e se a outra condição for falsa.

• if..elif..else (se..senão..senão se): usado quando há diversas condições, cada uma

associada a um trecho de código, via comando elif.

A sintaxe é mostrada no código a seguir juntamente com um exemplo de aplicação

adaptado de (BORGES, 2014):

Código-fonte 6 – Deﬁnição e exemplo de sintaxe dos condicionais.

1 # Sintaxe

2 if < condi ç ão >:

3

< bloco de c ó digo >

4 elif < condi ç ão >:

5

< bloco de c ó digo >

6 elif < condi ç ão >:

7

< bloco de c ó digo >

8 else :

< bloco de c ó digo >

9

10

11 # Exemplos de Sinatxe condicionais

12 temp = int ( input ( " Entre com a temperatura : " ) )

13 if temp < 0:

14

print ( " Congelando ... " )

15 elif temp <= 20:

16

print ( " Frio " )

17 elif temp <= 25:

18

print ( " Normal " )

19 elif temp <= 35:

20

print ( " Quente " )

21 else :

22

print ( " Muito quente ! " )

23 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

24 Entre com a temperatura : 23

25 Normal

Fonte: Elaborado pelo autor.

Com relação as sintaxes, escritas da linha 1 à linha 9 temos

• <condição>: sentença que possa ser avaliada como verdadeira ou falsa.

27

• <bloco de código>: sequência de linhas de comando.

• As clausulas elif e else são opcionais e podem existir vários elifs para o mesmo if,

porém apenas um else ao ﬁnal.

No exemplo, iniciado na linha 12 à linha 22, é pedido ao usuário que “Entre com a temperatura:”,

o valor de entrada é convertido para inteiro, quando dado a temperatura ao programa, “23” é a

entrada digitada, inicia a execução dos condicionais do algoritmo e, “Normal” é a resposta do

programa.

Laços de repetição, também chamados de loop, são usadas para repetir um bloco do

código enquanto dada condição for verdadeira. Cada repetição do bloco é chamada de iteração.

Há dois laços de repetição em Python: o laço for, usado para executar um número ﬁxo de

iterações, e o laço indeterminado while, usado quando não se sabe as iterações necessárias antes

do início do laço. Para a repetição do laço for, é preciso que a coleção iterada contenha mais

itens. Por outro lado, o laço while veriﬁca a condição lógica antes de cada iteração e só continua

se essa condição for verdadeira.

Código-fonte 7 – Deﬁnição e exemplo de sintaxe do laço for.

1 # Sintaxe la ç o ' for ':

2 for < refer ê ncia > in < sequ ê ncia >:

3

4

5

< bloco de c ó digo >

continue

break

6 else :

< bloco de c ó digo >

7

8

9 # Exemplo la ç o ' for ':

Soma de 0 a 99

10 s = 0

11 for x in range (1 , 100) :

12

s = s + x

13 print s

14 # - - - - - - - - - - - - - - - -

15 4950

Fonte: Elaborado pelo autor.

Da linha 1 à 7, mostra a estrutura de aplicação do laço for. Por outro lado, da linha 9 à 15 é

dado um exemplo para o laço for, para fazer a soma de todos os elementos compreendidos entre

0 e 99 dado que a iteração seja verdadeira. A função range(m, n, p), muito usada em laços

por retornar uma lista de inteiros, varrendo valores entre m e n, em passos de comprimento p do

laço.

Código-fonte 8 – Deﬁnição e exemplo de sintaxe do laço while.

28

1 # Sintaxe la ç o ' while ':

2 while < condi ç ão >:

3

4

5

< bloco de c ó digo >

continue

break

6 else :

< bloco de c ó digo >

7

8

9 # Exemplo la ç o ' while ': Soma de 0 a 99

10 soma = 0

11 x = 1

12 while x < 100:

13

14

soma = soma + x

x = x + 1

15 print s

Fonte: Elaborado pelo autor.

Da linha Da linha 1 à 7, mostra a estrutura de aplicação do laço while, o código dentro do laço

while é repetido enquanto a condição estiver sendo avaliada como verdadeira. Assim como no

exemplo anterior aplicado ao laço for, o exemplo proposto ao laço while se propõe a somar

todos os elementos compreendidos entre o mesmo intervalo, e isso é feito enquanto a condição

se manter verdadeira e não não há como determinar quantas iterações vão ocorrer sem sequência

a seguir. A saída do programa Deﬁnição e exemplo de sintaxe do laço while é análoga. Ambas

sintaxes e exemplos foram adaptados (BORGES, 2014).

2.1.6 Funções

Em Python uma função é uma rotina de instruções que calcula um ou mais resultados,

podendo receber parâmetros pré-determinados. Vimos acima algumas funções prontas da

linguagem, como o print(), input(), type() etc. como mostrados na tabela (5).

Funções são deﬁnidas pelo uso da palavra-chave def, conforme a sintaxe e exemplos

29

a seguir:

Código-fonte 9 – Deﬁnição e exemplo de sintaxe de funções.

1 # Sintaxe de ' fun ç ã o ':

2 def func ( parametro1 , parametro2 ,...) :

< bloco de c ó digo >

return valor

3

4

5

6 # Fun ç ã o para imprimir o maior entre 2 valores

7 def maior (x , y ) :

if x > y :

return x

return y

8

9

10

11

12 maior (4 , 7)

13 7

14

15 def fatorial ( n ) :

p = 1

for i in range (1 , n + 1) :

p *= i

return p

16

17

18

19

20

21 for i in range (1 , 6) :

print (i , ' -> ' , fatorial ( i ) )

22

23

24 # Sa í da fatorial

25 1 -> 1

26 2 -> 2

27 3 -> 6

28 4 -> 24

29 5 -> 120

Fonte: Elaborado pelo autor.

Da linha 1 à 4 representa a sintaxe, forma estrutural de deﬁnir uma função em Python.

o fator func() é a função que pode receber os parâmetros 1, 2, ..., N se assim forem declarados.

O <bloco de código> na sintaxe pode ser melhor visualizado no exemplo para imprimir o maior

entre 2 valores e também em fatorial.

30

2.1.7 Bibliotecas

Python também conta com um enorme conjunto de funções prontas para serem

aplicadas em algoritmos, agrupamento de módulos, bibliotecas, que simpliﬁcam a usabilidade

evitando a reescrição desnecessária de comandos básico por já estarem agrupados nesses módu-

los(bibliotecas) de acesso livre.

O uso desses módulos são feitos chamando-os (importando-os) no início do script

com comando import <nome_do_módulo>. Como também é possível importar do módulo

apenas a função desejada. Para isso, utilizamos o comando from <nome_do_módulo> import

função, e a função estará disponível para utilização. Por exemplo, uso de funções matemáticas

numéricas básicas da biblioteca math que contém representações logarítmicas, exponenciais,

hiperbólicas, trigonométricas, conversões angulares etc,

Código-fonte 10 – Exemplo de uso da biblioteca math.

1 # Exemplo de uso da bilioteca math '

2 import math

3 x = 5

4 math . sqrt ( x )

5 # 2.2360679774997898

6 math . sin ( x )

7 # -0.95892427466313845

8 math . log ( x )

9 # 1.6094379124341003

10 math . cos ( x )

11 # 0.28366218546322625

Fonte: Elaborado pelo autor.

As constantes π e e, exponencial, são deﬁnidos, podem ser usadas pelo nome quando o módulo

é importado. Abaixo, estão listadas algumas funções desse módulo:

• math.factorial(x) - Retorna o valor de x fatorial. Se x negativo, retorna um erro.

• math.modf(x) - Retorna o valor inteiro e o valor fracionário de x.

• math.exp(x) - Retorna e exponencial de x.

• math.log(x,base) - Retorna o log de x na base pedida.

• math.log1p(x) - Retorna o log natural de x.

• math.sqrt(x) - Retorna a raiz quadrada de x.

31

• math.degrees(x) - Converte o ângulo x de radianos para graus.

• math.radians(x) - Converte o ângulo x de graus para radianos.

NumPy, abreviação de Numerical Python, bibliotecas Python para computação

numérica, é um módulo de manipulação numérica. É um software de código aberto, open

source, dedicado a criação e manipulação de matrizes, matrizes multidimensionais. Fornece uma

variedade de funções de alto nível para lidar com matrizes complexas.

NumPy, trata-se de uma biblioteca que inclui uma classe chamada de array, esses

são os objetos de trabalho e manipulação desta biblioteca, ou seja, pode-se pensar que esses

arrays são arranjos variáveis com número arbitrário de elementos e homogêneos, os elementos

são do mesmo tipo, semelhante às listas da linguagem Python como discutidos nas seções

anteriores; As classes matriciais são também objetos de manipulação desta biblioteca, assim

como as várias funções auxiliares do pacote. Outra abordagem interessante desta biblioteca é a

vetorização desses arrays e matrizes. Essas, arrays e matrizes, podem ser unidimensionais

(1D), bidimensionais (2D), tridimensionais (3D) ou N-dimensionais.

Exemplo da classe de arrays (BORGES, 2014) é posto a seguir

Código-fonte 11 – Arrays em Numpy.

1 import numpy as np

2

3 # Criando arranjos

4 a = np . array ([0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8])

5

6 # Arranjo criado a partir de um intervalo

7 b = np . arange (0. , 4.5 , .5)

8

9 # Arranjo de 1 ' s de dimens ã o 2 x3

10 c = np . ones ((2 , 3) )

11

12 # Arranjos podem gerar novos arranjos

13 d = np . round ( numpy . cos ( z ) , 1)

14

15 # Multiplicando cada elemento por um escalar

16 d1 = 5 * d

17

18 # Somando arranjos elemento por elemento

19 e = b + d

32

20

21 # Redimensionando o arranjo

22 b . shape = 3 , 3

23

24 # Arranjo transposto

25 b . transpose ()

Fonte: Elaborado pelo autor.

a saída completa é mostrado na listagem abaixo

[0 1 2 3 4 5 6 7 8]

[ 0.

0.5 1. 1.5 2.

2.5 3. 3.5 4. ]

[[ 1.

1.

1.]

[ 1.

1.

1.]]

[ 1.

0.9 0.5 0.1 -0.4 -0.8 -1. -0.9 -0.7]

[ 0.

2.5 5. 7.5 10.

12.5 15. 17.5 20.

]

[ 1.

1.4 1.5 1.6 1.6 1.7 2. 2.6 3.3]

[[ 0.

0.5 1. ]

[ 1.5 2.

2.5]

[ 3.

3.5 4. ]]

[[ 0.

1.5 3. ]

[ 0.5 2.

3.5]

[ 1.

2.5 4. ]]

Matplotlib é um dos pacotes Python mais populares usados para visualização de

dados. É uma biblioteca de plataforma cruzada para fazer gráﬁcos 2D de dados em arrays.

Matplotlib é escrito em Python e usa NumPy, a extensão matemática numérica do Python. Ele

fornece uma API orientada a objetos que ajuda a incorporar gráﬁcos em aplicativos usando kits

de ferramentas Python GUI, como PyQt, WxPythonotTkinter. Ele pode ser usado em shells

Python e IPython, notebook Jupyter e servidores de aplicativos da web também.

Matplotlib tem uma interface procedural chamada Pylab, que foi projetada para

se assemelhar ao MATLAB, uma linguagem de programação proprietária desenvolvida pela

MathWorks. Matplotlib junto com NumPy pode ser considerado o equivalente de código aberto

do MATLAB. Foi originalmente escrito por John D. Hunter em 2003.

33

Vamos exibir um gráﬁco de linha simples de ângulo em radianos vs. seu valor de

seno em Matplotlib. Para começar, o módulo Pyplot do pacote Matplotlib é importado, com um

alias1 plt por uma questão de convenção.

1 import matplotlib . pyplot as plt

Em seguida, precisamos de uma matriz de números para plotar. Várias funções de

array são deﬁnidas na biblioteca NumPy que é importada com o apelido np.

2 import numpy as np

Agora obtemos o objeto ndarray de ângulos entre 0 e 2π usando a função arange

da biblioteca NumPy.

4 x = np . arange (0 , math . pi * 2 , 0 ,05)

O objeto ndarray serve como valores no eixo x do gráﬁco. Os valores de seno cor-

respondentes dos ângulos em x a serem exibidos no eixo y são obtidos pela seguinte declaração:

5 y = np . sin ( x )

Os valores dos dois arrays são plotados usando a função plot().

6 plt . plot (x , y )

Podemos deﬁnir o título do gráﬁco e os rótulos dos eixos x e y.

7 plt . xlabel ( " Â ngulo " )

8 plt . ylabel ( " Seno " )

9 plt . title ( " Onda senoidal " )

A janela do visualizador de Plot é chamada pela função show():

10 plt . show ()

O programa completo segue no código 12:

Código-fonte 12 – Gráﬁco onda senoidal usando matplotlib

1 from matplotlib import pyplot as plt

2 import numpy as np

3 import math # para defini ç ã o de pi

4 x = np . arange (0 , math . pi *2 , 0.05)

1 O termo alias, que signiﬁca segundo nome ou apelido é utilizado para abreviar comandos complexos que são

usados repetidamente.

34

5 y = np . sin ( x )

6 plt . plot (x , y )

7 plt . xlabel ( " Â ngulo " )

8 plt . ylabel ( " Seno " )

9 plt . title ( " Onda senoidal " )

10 plt . show ()

Fonte: Elaborado pelo autor.

Quando o código 12 acima é executada, o gráﬁco na imagem (1) é exibido.

Figura 1 – Onda senoidal.

Fonte: Elaborado pelo autor

A função subplot() retorna o objeto de eixos em uma determinada posição da

grade. A chamada desta função é:

1 plt . subplot ( nrows , ncols , index )

Na ﬁgura, a função cria e retorna um objeto Axes2, no índice de posição de uma

grade de nrows por ncol. Os índices vão de 1 a nrows * ncols, incrementando na ordem da

linha principal.

2 O objeto Axes é a região da imagem com o espaço de dados. Uma determinada ﬁgura pode conter muitos eixos,

mas um determinado objeto Axes só pode estar em uma ﬁgura. Os eixos contém dois objetos de eixo.

35

Código-fonte 13 – Usando subplot.

1 import matplotlib . pyplot as plt

2

3 # plot uma linha , criando implicitamente a subplot (1 , 1 , 1)

4 plt . subplot (2 , 1 , 1)

5 plt . plot ( range (12) )

6

7 # cria o segundo subplot com fundo amarelo

8 plt . subplot (2 1 , 2 , facecolor = 'y ')

9 plt . plot ( range (12) )

Fonte: Elaborado pelo autor.

O código 13 acima gera a imagem (2) seguinte.

Figura 2 – Multiplots.

Fonte: Elaborado pelo autor

A função grid() do objeto de eixos deﬁne a visibilidade da grade dentro da ﬁgura

como ligada ou desligada.

36

Código-fonte 14 – Usando grid.

1 import matplotlib . pyplot as plt

2 import numpy as np

3 fig , eixos = plt . subplots (1 ,3 , figsize = (12 ,4) )

4 x = np . arange (1 ,11)

5 eixos [0]. plot (x , x ** 3 , 'g ' , lw = 2)

6 eixos [0]. grid ( True )

7 eixos [0]. set_title ( ' grade padr ã o ')

8 eixos [1]. plot (x , np . exp ( x ) , 'r ')

9 eixos [1]. grid ( color = 'b ' , ls = ' -. ' , lw = 0 ,25)

10 eixos [1]. set_title ( ' grade personalizada ')

11 eixos [2]. plot (x , x )

12 eixos [2]. set_title ( ' sem grade ')

13 fig . tight_layout ()

14 plt . show ()

Fonte: Elaborado pelo autor.

O código 14 acima gera a imagem (3) seguinte.

Figura 3 – Usando grids.

Fonte: Elaborado pelo autor

2.2 Noções Fortran

2.2.1 Sintaxe básica

Um programa Fortran é composto de uma coleção de unidades de programa, como

um programa principal, módulos e subprogramas ou procedimentos externos.

Cada programa contém um programa principal e pode ou não conter outras unidades

de programa. A sintaxe do programa principal é a seguinte:

37

Código-fonte 15 – Programa principal

1 program nomePrograma

2

3

4

implicit none

! declara ç õ es de declara ç ã o de tipo

! declara ç õ es execut á veis

5 end program nomePrograma

Fonte: Elaborado pelo autor.

Vamos escrever um programa que adiciona dois números e imprime o resultado.

Código-fonte 16 – Soma dois números.

1 program somaNumeros

2

3

4

5

6

7

8

9

10

11

12

! Este programa simples adiciona dois n ú meros

implicit none

! Declara ç õ es de tipo

real :: a , b , result

! Declara ç õ es de vari á veis

a = 12.0

b = 15.0

resultado = a + b

print * , 'O total é ' , resultado

13 end program somaNumeros

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, ele produz o seguinte resultado

O total é 27.0000000.

Notemos que:

• Todos os programas FORTRAN comaçam com a palavra-chave program e termina com a

palavra-chave end program seguida pelo nome do programa.

• A instrução implicit none permite que o compilador veriﬁque se todos os tipos de

38

variáveis foram declarados corretamente. Devemos sempre usar implicit none no início

de cada programa.

• Os comentário em FORTRAN são iniciados com o ponto de exclamação (!). Todos os

caracteres após serão ignorados pelo compilador.

• O comando print*, exibe dados na tela.

• O recuo das linhas de código é uma boa prática para manter um programa legível.

• FORTRAN permite letras maiúsculas e minusculas mas não faz distinção entre elas, exceto

em strings

O conjunto de caracteres básicos de FORTRAN contém:

• as letras A...Z e a...z.

• os dígitos 0...9.

• o caractere sublinhado _.

• os caracteres especiais =:+espaço em branco-*/()[],.$’!"%&;<>?

Um identiﬁcador é um nome usado para identiﬁcar uma variável, procedimento ou

qualquer outro item deﬁnido pelo usuário. Um nome em FORTRAN deve seguir as seguintes

regras:

• Não pode ter mais de 31 caracteres

• Deve ser composto de caracteres alfanuméricos (todas as letras do alfabeto e os dígitos 0 a

9) e sublinhados (_)

• O primeiro caractere de um nome deve ser uma letra.]

• FORTRAN não diferencia maiúsculas e minúsculas.

Palavras-chaves são palavras especiais, reservadas para a linguagem. Essas palavras

reservadas não podem ser usadas como identiﬁcadores ou nomes.

A tabela a seguir lista as palavras-chaves de FORTRAN.

2.2.2 Tipos de dados

FORTRAN fornece cinco tipos de dados intrínsecos, no entanto podemos criar

nossos tipos de dados. Os cinco tipos são:

• Integer

• Real

• Complex

• Logical

• Character

39

Tabela 6 – Palavras chaves da linguagem.

allocatable
block data
common
data
endﬁle
end do
end program
entry
function
inout
intrinsic
namelist
optional
print
real
save
then
While

allocate
call
complex
deallocate
else
end function
end select
equivalence
go to
inquire
kind
nullify
out
private
recursive
select case
type
Write

assign
case
contains
default
else if
end if
end subroutine
exit
if
integer
len
only
parameter
program
result
stop
type()

assignment
character
continue
do
elsewhere
end interface
end type
external
implicit
intent
logical
open
pause
public
return
subroutine
use

backspace
close
cycle
double precision
end block data
end module
end where
format
in
interface
module
operator
pointer
read
rewind
target
Where

Fonte: (TUTORIALS POINT, 2021)

Os tipo integer podem conter apenas valores inteiro. O exemplo a seguir extrai o

maior valor que pode ser armazenado em um número inteiro de quatro bytes.

Código-fonte 17 – Maior valor armazenado em inteiro de quatro bytes.

1 program tipoInteiro

2

3

4

5

implicit none

integer :: maiorNumero

print * , huge ( maiorNumero )

6 end program tipoInteiro

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

2147483647

A função huge() fornece o maior número que pode ser armazenado pelo tipo de

dado especiﬁcado. Podemos também especiﬁcador o numero de bytes usando o especiﬁcador

kind.

Código-fonte 18 – Maior número que pode ser armazenado pelo tipo de dado inteiro.

1 program tipoInteiro

2

implicit none

40

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

! inteiro de dois bytes

integer ( kind = 2 ) :: int2

! inteiro de quatro bytes

integer ( kind = 4 ) :: int4

! inteiro de oito bytes

integer ( kind = 8 ) :: int8

! inteiro de dezesseis bytes

integer ( kind = 16 ) :: int16

print * , huge ( int2 )

print * , huge ( int4 )

print * , huge ( int8 )

print * , huge ( int16 )

20 end program tipoInteiro

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

32767

2147483647

9223372036854775807

170141183460469231731687303715884105727

2147483647.

O tipo real armazena os números de ponto ﬂutuante, como 2.0, 3.1415, -100, 876.

FORTRAN 90/95 (esse que estamos estudando) oferece controle sobre a precisão

dos tipos de dados reais e inteiros por meio do especiﬁcador kind.

O exemplo a seguir mostra o uso de dados real type.

Código-fonte 19 – Dado tipo real.

1 programa numerosReais

2

3

4

5

implicit none

! vari á veis reais

real :: p , q , realResultado

41

6

7

8

9

10

11

12

13

14

15

16

17

18

19

! vari á veis inteiras

integer :: i , j , intResultado

! atribui ç ã o de valores

p = 2.0

q = 3.0

i = 2

j = 3

! divis ã o de ponto flutuante

realResultado = p / q

intResultado = i / j

print * , realResultado

print * , intResultado

20 end program numerosReais

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

0.666666687

0

O tipo complex é usado para armazenar números complexos. Um número complexo

possui duas partes, a parte real e a parte imaginaria. Não discutiremos aqui esse tipo.

Existem apenas dois valores lógicos: .true. e .false..

O character type armazena caracteres e strings. O comprimento da string pode

ser especiﬁcado pelo especiﬁcador len. Por exmeplo:

Código-fonte 20 – Exemplo character

1 character ( len = 40 ) :: nome

2 nome = " FORTRAN é legal "

Fonte: Elaborado pelo autor.

2.2.3 Variáveis

Uma variável é um nome dado a uma área de armazenamento que nossos programas

podem manipular. Cada variável deve ter um tipo especíﬁco, que determina o tamanho da

memória, a faixa de valores que podem ser armazenados e o conjuntos de operações que podem

ser aplicadas.

Variáveis são declaradas no inicio de um programa (ou subprograma). A sintaxe

42

para declarações de variáveis é a seguinte:

1 tipo da vari á vel :: nome da vari á vel

Por exemplo:

1 integer :: total

2 real :: media

3 character ( len = 80) :: menssagem

Depois, podemos atribuir valores a essas variáveis, como:

1 total =1000

2 media = 7.0

3 menssagem = " Fortran é legal "

As constantes referem-se aos valores ﬁxos que o programa não pode alterar durante

a execução. Esses valores ﬁxos são também chamados de literais.

Constantes podem ser de qualquer tipos de dados básicos, como uma constante

inteira, uma constante ﬂutuante, um constante de caracteres ou literal de strings. Existem

apenas duas constantes lógicas: .true. e .false.. As constantes são tratadas como variáveis

comuns, exceto que seus valores não podem ser modiﬁcados após seu deﬁnição.

Existem dois tipos de constantes:

• Constantes literais.

• Constantes nomeadas.

Uma constante literal tem um valor, mas não tem um nome. Uma constante nomeada

tem um valor e um nome também. Assim, 1234, 3.1415926 e .true. são exemplos de

constantes literais do tipo, integer, real e logical respectivamente.

As constantes nomeadas devem ser declaradas no inicio de um programa ou proce-

dimento, assim como uma declaração de tipo de variável, indicando seu nome e seu tipo. As

constantes nomeadas são declaradas com o atributo parameter. Por exemplo:

1 real , parameter :: PI = 3.1415926

2.2.4 Operadores

Um operador é um símbolo que informa ao compilador para executar operações

matemáticas ou lógicas especíﬁcas. FORTRAN oferece os seguintes tipo de operadores:

43

• Operadores aritméticos

• Operadores relacionais

• Operadores lógicos

A tabela 7 mostra todos os operadores aritméticos. Suponhamos que a variável A

tenha o valor 5 e a variável B tenho a o valor 3, então:

Tabela 7 – Operadores aritméticos.

Operador

Descrição

Exemplo

+
-
*
/
**

Operador de adição
Operador de subtração
Operador de multiplicação
Operador de divisão
Operador de exponenciação

A + B → 8
A - B → 2
A * B → 15
A/B → 1
A**B → 125

Fonte: Elaborado pelo autor

A tabela 8 mostra todos os operadores relacionais suportados em FORTRAN.

Tabela 8 – Operadores relacionais.

Operador Descrição

Exemplo

==

/=

>

<

>=

<=

Veriﬁca se os valores de dois operandos
são iguais ou não
Veriﬁca se os valores de dois operados
são iguais ou não, sendo a negação do
operador anterior
Veriﬁca se o valor do operando esquerdo
é maior que o valor do operando direito,
se sim, a condição retorna verdadeiro
Veriﬁca se o valor do operando esquerdo
é menor que o valor do operando direito,
se sim, a condição retorna verdadeiro
Veriﬁca se o valor do operando esquerdo
é maior ou igual ao valor do operando
direito, se sim, a condição retorna verdadeiro
Veriﬁca se o valor do operando esquerdo
é menor ou igual ao valor do operando
direito, se sim, a condição retorna verdadeiro

A == B não é verdadeiro

A /= B é verdadeiro

A > B é verdadeiro

A < B não é verdadeiro

A >= B é verdadeiro

A <= B não é verdadeiro

Fonte: Elaborado pelo autor

44

2.2.5 Condicionais

As estruturas condicionais requerem que o programador especiﬁque uma ou mais

condições a serem avaliadas ou testadas pelo programa, junto com uma instrução ou instruções

a serem executadas, se a condição for determinada como verdadeira, e opcionalmente, outras

instruções a serem executadas se a condição é determinada como falsa.

Uma instrução if... then consiste em uma expressão lógica seguida por uma ou

mais instruções e terminada por uma instrução end if. A sintaxe básica de uma instrução if...

then é:

Código-fonte 21 – Sintaxe if... .

1 if ( express ã o l ó gica ) then

2

intru ç ã o

3 end if

Fonte: Elaborado pelo autor.

Código-fonte 22 – Exemplo usando if.

1 program exemploIF

2

3

4

5

6

7

8

9

10

11

12

13

implicit none

! declara ç ã o de variaveis

integer :: a = 10

! verifica ç ã o l ó gica usando a instru ç ã o if

if ( a < 20 ) then

! se a condi ç ã o for verdadeira

! imprime na tela a seguinte mensagem

print * , " a é menor que 20 "

end if

print * , " Valor de a é " , a

14 end program exemploIF

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

a é menor que 20

45

Valor de a é 10

Uma instrução if...

then pode ser seguida por uma instrução else opcional,

que é executada quando a expressão lógica é falsa. A sintaxe básica de uma instrução if...

then..

else é:

Código-fonte 23 – Sintaxe if... else.

1 if ( express ã o l ó gica ) then

instru ç õ es

2

3 else

4

outras intru ç õ es

5 end if

Fonte: Elaborado pelo autor.

Código-fonte 24 – Exemplo usando if... else.

1 program exemploIfElse

2

3

4

5

6

7

8

9

10

11

12

13

14

15

implicit none

! declara ç ã o de vari á veis

integer :: a = 100

!

verifica ç ã o l ó gica usando a instru ç ã o if

if ( a < 20 ) then

! se a condi ç ã o for verdadeira

! imprime na tela a seguinte mensagem

print * , " a é menor que 20 "

else

print * , " a n ã o é menor que 20 "

end if

print * , " Valor de a é " , a

16 end program exemploIfElse

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

a não é menor que 20

Valor de a é 100

Uma construção de instrução if pode ter uma ou mais construções else-if opci-

onais. Quando a condição if falha, o else-if imediatamente seguido é executado. Quando

o else-if também falha, a instrução else-if seguinte (se houver) é executada e assim por

diante. O else opcional é colocado no ﬁnal e é executado quando nenhuma das instruções acima

46

for verdadeira.

• Todas as intruções else são opcionais.

• else-if pode ser usado uma ou mais vezes.

• else deve sempre ser colocado no ﬁnal da construção e deve aparecer apenas uma vez.

A sintaxe de uma instrução if...

else if... else é:

Código-fonte 25 – Sintaxe de if... else if... else.

1 if ( express ã o l ó gica 1) then

2

! bloco 1

3 else if ( express ã o l ó gica 2) then

4

! bloco 2

5 else if ( express ã o l ó gica 3) then

! bloco 3

6

7 else

8

! bloco 4

9 end if

Fonte: Elaborado pelo autor.

Código-fonte 26 – Exemplo usando if... else if... else.

1 program exemploIfElseIfE ls e

2

3

4

5

6

7

8

9

10

11

12

13

14

implicit none

! declara ç ã o de vari á veis

integer :: a = 100

! verifica ç ã o l ó gica usando a instru ç ã o if

if ( a ==

10 ) then

! se a condi ç ã o for verdadeira

! imprime na tela a seguinte mensagem

print * , " Valor de a é 10 "

else if ( a == 20 ) then

! condi ç ã o if else if é verdadeira

print * , " Valor de a é 20 "

else if ( a ==

30 ) then

47

15

16

17

18

19

20

21

22

! condi ç ã o if else if é verdadeira

print * , " Valor de a é 30 "

else

! se nenhumas das condi ç õ es é verdadeira

print * , " N ã o corresponde a nenhum dos valores "

end if

print * , " O valor exato de a é " , a

23 end program exemploIfElseIf E lse

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

Não corresponde a nenhum dos valores

Valor exato de a é 100

Podemos usar uma instrução if ou else if dentro de outra instrução if ou else

if. A sintaxe de uma instrução if aninhada é a seguinte:

Código-fonte 27 – Sintaxe de if... aninhada.

1 if ( express ã o l ó gica 1) then

2

3

4

5

! É executada quando a express ã o l ó gica 1 é verdadeira

if ( express ã o l ó gica 2) then

! É executada quando a express ã o l ó gica 2 é verdadeira

end if

6 end if

Fonte: Elaborado pelo autor.

Código-fonte 28 – Exemplo usando if... aninhado.

1 program exemploIfAninhado

2

3

4

5

6

7

8

9

implicit none

! declara ç ã o de variav é is

integer :: a = 100 , b = 200

! verifica ç ã o l ó gica usando a instru ç ã o if

if ( a ==

100 ) then

! if for verdadeiro , verifica a condi ç ã o seguinte

if ( b == 200 ) then

! if interno for verdadeiro

print * , " Valor de a é 100 e o valor de b é 200 "

48

end if

end if

print * , " Valor exato de a é " , a

print * , " Valor exato de b é " , b

10

11

12

13

14

15

16

17 end program exemploIfAninhado

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

Valor de a é 100 e o valor de b é 200

Valor exato de a é 100

Valor exato de b é 200

2.2.6 Loops

Pode existir uma situação em que precisemos executar um bloco de código várias

vezes. Em geral, as instruções são executadas sequencialmente: a primeira instrução em uma

função é executada primeiro, seguida pela segunda e assim por diante. Uma instrução de loop

nos permite executar uma instrução ou grupo de instruções várias vezes.

A construção do loop permite que uma instrução ou série de instruções, seja execu-

tada iterativamente, enquanto uma determinada condição for verdadeira. A forma geral do do

loop é:

Código-fonte 29 – Sintaxe de do loop.

1 do var = start , stop [ , step ]

2

! instru ç õ es

3 end do

Fonte: Elaborado pelo autor.

Onde

• a variável var deve ser um inteiro.

• start é o valor inicial

• stop é o valor ﬁnal

• step é o incrimento, se for omitido, a variável é aumentada de um

O programa a seguir calcula o fatorial dos números de 1 a 10.

Código-fonte 30 – Fatorial dos números de 1 a 10.

49

1 program fatorial

2

3

4

5

6

7

8

9

10

11

12

implicit none

! define vari á veis

integer :: fat = 1

integer :: i

! computar fatorial

do i = 1 , 10

fat = fat * i

! imprime os valores

print * , i , fat

end do

13 end program fatorial

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte resultado

1

2

3

4

5

6

7

8

9

1

2

6

24

120

720

5040

40320

362880

10 3628800

As instruções de controle de loop alteram a execução de sua sequência normal.

Quando a execução deixa um escopo, todos os objetos automáticos que foram criados nesse

escopo são destruídos. Se desejamos que a execução do programa termine, podemos inserir uma

instrução de parada.

Código-fonte 31 – Declaração de parada.

50

1 program exemploStop

2

3

4

5

6

7

8

9

implicit none

integer :: i

do i = 1 , 10

if ( i == 5) then

stop

end if

print * , i

10

end do

11 end program exemploStop

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte

1

2

3

4

2.2.7 Arrays

Os arrays podem armazenar uma coleção sequencial de tamanho ﬁxo de elementos

do mesmo tipo. Um array é usada para armazenar uma coleção de dados, mas geralmente é

mais útil pensar em um array como uma coleção de variáveis do mesmo tipo. Todos os array

consiste, em locais de memória contíguos. O endereço mais baixo corresponde ao primeiro

elemento e o endereço mais alto ao último elemento.

Os arrays podem ser unidimensionais (como vetores), bidimensionais (como matri-

zes) e FORTRAN permite arrays com até 7 dimensões.

Os arrays são declarados com o atributo dimension. Por exemplo, para declarar

um array unidimensional chamado vetor, de números reais contendo 5 elementos, escrevemos:

Código-fonte 32 – Declaração de array.

1 real , dimension (5) :: vetor

Fonte: Elaborado pelo autor.

51

Os elementos individuais dos arrays são referenciados especiﬁcando seus índices.

O primeiro elemento de um array possui índice um. O vetor declarado no exemplo acima

contem cinco variáveis reais: vetor(1), vetor(2), vetor(3), vetor(4) e vetor(5).

Para criar um array bidimensional 5x5 de inteiros, podemos escrever:

Código-fonte 33 – Declaração de array bidimensional.

1 integer , dimension (5 , 5) :: matriz

Fonte: Elaborado pelo autor.

Podemos atribuir valores a membros individuais, como:

1 vetor (1) = 2.0

ou usando um loop

1 do i = 1 , 5

2

vetor ( i ) = i * 2.0

3 end do

Devido a seus objetivos computacionais, as operações matemáticas com arrays são

diretas no Fortran. As operações com array da mesma forma e tamanho são muito semelhantes

à álgebra de matrizes/vetores. Em vez de percorrer todos os índices com loops, pode-se escrever

adição (e subtração):

Código-fonte 34 – Adição de arrays em Fortrab

1 real , dimension (2 ,3) :: A , B , C

2 real , dimension (5 ,6 ,3) :: D

3 A

4 B

5 C

6 D

7

= 3.

= 5.

! Atribui ç ã o de valor ú nico a toda o array

! Escrita equivalente para atribui ç ã o

= A + B ! Todos os elementos de C agora t ê m valor 8.

= A + B ! O compilador gerar á um erro . As formas e

! dimens õ es n ã o s ã o as mesmas

Fonte: Elaborado pelo autor.

“Fatiar” arrays é uma operação válida em fortran, como podemos ver no código 35

abaixo.

52

Código-fonte 35 – Slicing arrays em Fortran

1 integer :: i , j

2 real , dimension (3 , 2) :: Mat = 0.

3 real , dimension (3)

:: Vec1 = 0. , Vec2 = 0. , Vec3 = 0.

4 i = 0

5 j = 0

6 do i = 1 ,3

7

8

9

do j = 1 ,2

Mat (i , j ) = i + j

end do

10 end do

11 Vec1 = Mat (: ,1)

12 Vec2 = Mat (: ,2)

13 Vec3 = Mat (1:2 ,1) + Mat (2:3 ,2)

Fonte: Elaborado pelo autor.

Fortran 90/95 fornece vários procedimentos para manipulação de array, mas por

fugirem ao propósito elementar dessas notas, não veremos aqui.

2.2.8 Procedimentos

Um procedimento é um grupo de instruções que executam uma tarefa bem deﬁnida

e podem ser chamados de seu programa. Informações (ou dados) são passados para o programa

de chamada, para o procedimento como argumentos. Existem dois tipos de procedimentos -

• Funções

• Sub-rotinas

Uma função é um procedimento que retorna um único valor. Uma função não deve

modiﬁcar seus argumentos. A quantidade retornada é conhecida como valor da função e é

denotada pelo nome da função. A sintaxe de um função é:

1 function nome ( arg1 , arg2 , ...)

2

3

[ declara ç õ es , incluindo aquelas para os argumentos ]

[ intru ç õ es ]

4 end function nome

O exemplo a seguir mostra uma função chamada areaCirculo. Ela calcula a área

de um círculo com raio r.

53

Código-fonte 36 – Cáculo area de um círculo.

1 function calculaArea ( r )

2

3

4

5

6

7

8

9

10

! fun ç ã o que calcula a area de um circulo

! com raio r

implicit none

real , parameter :: PI = 3.1415926

real :: calculaArea

real :: r

calcula area = PI * r **2

11 end function calculaArea

12

13 program areaCirculo

14

15

16

17

18

19

20

implicit none

real :: area

real :: raio = 2.0

area = calculaArea ( r )

print * , " A á rea de um c í rculo com raio " , r , " é " , area .

21 end program areaCirculo

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte

A área de um círculo com raio 2.0 é 12.5663710.

Notemos que devemos especiﬁcar implicit none tanto no programa principal

como no procedimento.

Uma sub-rotina não retorna um valor, mas pode modiﬁcar seus argumentos. Sua

sintaxe é:

1 subroutine nome ( arg1 , arg2 , ...)

2

3

[ declara ç õ es , incluindo aquelas para os argumentos ]

[ intru ç õ es ]

4 end subroutine nome

Precisamos chamar uma sub-rotina usando a instrução call. O exemplo a seguir mostra a

deﬁnição e o uso de uma sub-rotina swap que altera os valores de seus argumentos.

Código-fonte 37 – Usando sub-rotina.

54

1 subroutine swap (x , y )

implicit none

real :: x , y , temp

temp = x

x = y

y = temp

2

3

4

5

6

7

8

9 end subroutine swap

10

11 program main

implicit none

real :: a , b

a = 2.0

b = 3.0

print * , " Antes de chamar swap "

print * , " a = " , a

print * , " b = " , b

call swap (a , b )

print * , " Depois de chamar swap "

print * , " a = " , a

print * , " b = " , b

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26 end program main

Fonte: Elaborado pelo autor.

Quando compilamos e executamos o programa acima, produz o seguinte

Antes de chamar swap

a = 2.00000000

b = 3.00000000

Depois de chamar swap

a = 3.00000000

b = 2.00000000

55

2.2.9 Funções intrínsecas

As funções intrínsecas são algumas funções comuns e importantes fornecidas como

parte da linguagem Fortran. Já vimos algumas dessas funções nas seções anteriores. Na tabela 9,

fornecemos breves descrições de algumas dessas funções.

Tabela 9 – Algumas funções matemáticas

Retorna o valor absoluto de x
Retorna o arco cosseno no intervalo (0, π), em radianos.
Retorna o arco seno no intervalo (−π/2, π/2), em radianos
Retorna o arco tangente no intervalo (−π/2, π/2), em radianos
Retorna o cosseno de x, x em radianos.
Retorna o cosseno hiperbólico de x.
Retorna o exponencial de x.
Retorna o logaritmo natural de x.

abs(x)
acos(x)
asin(x)
atan(x)
cos(x)
cosh(x)
exp(x)
log(x)
log10(x) Retorna o logaritmo comum (base 10) de x.
sin(x)
sinh(x)
sqrt(x)
tan(x)
tanh(x)

Retorna o seno de x, x em radianos.
Retorna o seno hiperbólico de x.
Retorna a raiz quadrada de x.
Retorna a tangente de x, x em radianos.
Retorna a tangente hiperbólica de x.

Fonte: Adaptado de (TUTORIALS POINT, 2021)

O Fortran foi originalmente desenvolvido por uma equipe da IBM em 1957 para

cálculos cientíﬁcos. Desenvolvimentos posteriores o transformaram em uma linguagem de

programação de alto nível. Nestas notas, aprendemos os conceitos básicos do Fortran e seu

código de programação.

56

3 INTERPOLAÇÃO

Nesse capítulo, trataremos sobre interpolação de um polinômio de grau k a k + 1

pontos dados. A interpolação polinomial será utilizada como uma maneira de “aproximar” uma
função, ou seja, dado f : [a, b] → R uma função e uma partição de seu domínio

a = x0 < x1 < · · · < xk−1 < xk = b

e conhecidos k + 1 valores discretos correspondentes a esses pontos da partição

f (xi) = yi,

i = 0, 1, · · · , k,

abordamos o problema de construir o polinômio pm(x) de menor grau que interpola todos os

pontos de (xi, yi), ou seja,

pm(x) = yi,

i = 0, 1, · · · , k,

Assumiremos que a < b e que k (cid:62) 1.

Dados k + 1 pontos, podemos interpolar um polinômio de grau k, que é único (por

que?). A pergunta é: quanto se perde ao se trocar a função f pelo polinômio interpolador? Para

k = 1 o polinômio interpolador é a função de primeiro grau que passa pelo pontos (x0, f (x0)) e

(x1, f (x1)). Para quaisquer valores de k, a função se anula em todos os pontos x0, x1, · · · , xk da

partição.

3.1 Polinômios de Lagrange

Considere o polinômio

(x − x0) · · · (x − xi−1)(x − xi+1) · · · (x − xk),

que tem grau k e se anula em x0, · · · , xi−1, xi+1, · · · , xk. Temos que

Li(x) =

(x − x0) · · · (x − xi−1)(x − xi+1) · · · (x − xk)
(xi − x0) · · · (xi − xi−1)(xi − xi+1) · · · (xi − xk)

vale 1 em xi e zero nos demais pontos x0, · · · , xi−1, xi+1, · · · , xk. A soma desses polinômios é

um polinômio de grau k, logo

c0L0(x) + c1L1(x) + · · · + ckLk(x)

57

é um polinômio de grau k, que vale c0 em x0, c1 em x1, · · · , ck em xk. Portanto, basta tomar os
c(cid:48)
is iguais a f (xi):

p(x) = f (x0)L0(x) + f (x1)L1(x) + · · · + f (xk)Lk(x).

Os polinômios Li são conhecidos como polinômio de Lagrange.

Para mostrar a unicidade, suponhamos que Pk e Qk são dois polinômios de grau

menor ou igual a k interpoladores de f nos pontos da partição dada. Então o polinômio

Rk(x) = Pk(x) − Qk(x)

anula-se, pelo menos, nos pontos xi, i = 0, 1, · · · , k. Como Rk é um polinômio de grau menor ou

igual a k, ele só pode ter k + 1 se for identicamente nulo. Logo, Pk(x) = Qk(x), para todo o x.

As expressões

Pk(x) =

k
∑
i=0

f (xi)Li(x)

e

Li(x) =

k
∏
j=0, j(cid:54)=i

x − x j
xi − x j

deﬁnem a fórmula de Lagrange para calcular o polinômio interpolador de f nos pontos

a = x0 < x1 < · · · < xk−1 < xk = b

(3.1)

(3.2)

No caso particular k = 1, com 2 pontos de interpolação, (x0, y0) e (x1, y1), o polinô-

mio interpolador se reduz a

p1(x) =

1
∑
i=0

f (xi)li(x) = f (x0)L0(x) + f (x1)L1(x) onde

L0(x) =

L1(x) =

1
∏
j=0, j(cid:54)=0

x − x j
xi − x j

=

x − x1
x0 − x1

,

1
∏
j=0, j(cid:54)=1

x − x j
xi − x j

=

x − x0
x1 − x0

ou seja

uma reta passando pelos pontos.

p1(x) =

x − x1
x0 − x1

y0 +

x − x0
x1 − x0

y1

(3.3)

No caso k = 2, o polinômio interpolador corresponde a uma parábola deﬁnido pelos

três pontos x0, y0, (x1, y1) e (x2, y2):

p2(x) =

2
∑
i=0

f (xi)li(x) = f (x0)L0(x) + f (x1)L1(x) + f (x2)L2(x) onde

58

L0(x) =

L1(x) =

L2(x) =

2
∏
j=0, j(cid:54)=0

2
∏
j=0, j(cid:54)=1

2
∏
j=0, j(cid:54)=2

x − x j
xi − x j

x − x j
xi − x j

x − x j
xi − x j

=

=

=

(x − x1)(x − x2)
(x0 − x1)(x0 − x2)

(x − x0)(x − x2)
(x1 − x0)(x1 − x2)

(x − x0)(x − x1)
(x2 − x0)(x2 − x1)

,

,

,

ou seja

p2(x) =

(x − x1)(x − x2)
(x0 − x1)(x0 − x2)

y0 +

(x − x0)(x − x2)
(x1 − x0)(x1 − x2)

y1 +

(x − x0)(x − x1)
(x2 − x0)(x2 − x1)

y2

(3.4)

A equação (3.1) é codiﬁcado no código (38). Ao receber k pontos, nos arrays x e y,

a função Lagrange retorna o valor pk(xi).

Código-fonte 38 – Interpolação de Lagrange

1 def lagrange (x , y , k , xi ) :

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

"""

Calcula o Polinomio de Lagrange de k pontos no ponto xi

x [] - coordenadas x dos pontos

y [] - coordenadas y dos pontos

k

- numero de pontos

xi

- argumento

"""

yi = 0

for i in range (1 , k +1) :

p = 1

for j in range (1 , k +1) :

if ( j != i ) :

p *= ( xi - x [ j ]) /( x [ i ] - x [ j ])

yi += p * y [ i ]

return yi

Fonte: Elaborado pelo autor.

A variante lagrange1, apresentada no código (39), recebe um array xi de ki argu-

mentos de interpolação, para os quais ele retorna os valores Pk(xi) por meio do array yi.

Código-fonte 39 – Interpolação de Lagrange com múltiplos argumentos

59

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

def lagrange1 (x , y , k , xi , yi , ki ) :

"""

Calcula o polinomio de Lagrange de ni pontos

x [] - coordenadas x dos pontos

y [] - coordenadas y do spontos

k - numero de pontos

xi [] - argumentos da interpolacao

yi [] - saida ( pk ( xi ) )

ki - numero de pontos de interpolacao

"""

yf = [0]* k

# calcula valores constantes

for i in range ( k ) :

p = 1

for j in range ( k ) :

if ( j != i ) :

p *= ( x [ i ] - x [ j ])

yf [ i ] = y [ i ] / p

# loop nos ki pontos

for l in range ( ki ) :

xk = xi [ l ]

yk = 0 e0

for i in range ( k ) :

p = 1 e0

for j in range ( k ) :

if ( j != i ) :

p *= ( xk - x [ j ])

yk += p * yf [ i ]

yi [ l ] = yk

Fonte: Elaborado pelo autor.

60

Como exemplo de uso do código (38), seja dada a seguinte tabela

Tabela 10 – Valores para alguns pontos de ln x

x
ln x

.40
-.916291

.50
-.693147

.70
-.356675

.80
-.223144

Fonte: Adaptado de (CHAPMAN, 2018)

onde vamos calcular o valor estimado de ln 0.60 usando o código (38), obtendo a aproximação

ln 0.60 ≈ −0.509975. O valor real é ln 0.60 = −0.510826, um erro de 0.000850. O código

vemos abaixo (40)

Código-fonte 40 – Interpolação usando Polinômio de Lagrange

1 import math

2

3 # def lagrange (...)

4

5 k = 4

6 x = [0]* k

7 y = [0]* k

8

# numero de pontos

9 x = [.4 , .5 , .7 , .8]

10 y = [ -.916291 , -.693147 , -.356675 , -.223144]

11

12 xi = .60

13

14 yi = lagrange (x , y , k , xi )

# valor estimado

15 a = math . log ( xi )

# valor correto

16

17 print ( yi )

18 print ( a )

# -0.5099754999999999

# -0.5108256237659907

19 print ( abs ( yi - a ) )

#

0 .00 0 850 1 237659 90806 7

Fonte: Elaborado pelo autor.

No programa do código (41), temos a interpolação de um conjunto de pontos de

dados extraídos da função f (x) = sin x/x e avaliados para vários argumentos e a plotagem do

gráﬁco

61

Código-fonte 41 – Interpolação usando Polinômio de Lagrange

1 import numpy as np

2 import matplotlib . pyplot as plt

# bibliotecas p / plot

3

4 def lagrange1 (...) : ...

5

6 k = 8

7 y = [0]* k

# numero de pontos

8 x = [.15 , .2 , .3 , .5 , .8 , 1.1 , 1.4 , 1.7]

9 for i in range ( k ) :

y [ i ] = np . sin ( x [ i ]) / x [ i ]

# f ( x ) = sen ( x ) / x

10

11

12 # numero de pontos de interpolacao

13 ki = 100

14 h = abs ( x [k -1] - x [0]) /( ki -1)

15 xi = [0]* ki

16 for i in range ( ki ) :

xi [ i ] = x [0]+ i * h

17

18

19 yi = [0]* ki

20 lagrange1 (x , y , k , xi , yi , ki )

21

22 xa = np . linspace ( x [0] , x [k -1] , 100)

23 ya = np . sin ( xa ) / xa

24

25 plt . plot (x , y , " ko " , label = " Dados " )

26 plt . plot ( xa , ya , "k - - " , label = " f ( x ) = sen ( x ) / x " )

27 plt . plot ( xi , yi , "b - " , label = " Interpolacao " )

28

29 plt . grid ( True )

30 plt . legend ()

31 plt . show ()

Fonte: Elaborado pelo autor.

Na ﬁgura 4, temos a plotagem dos dados do código e sua concordância (41), usamos

as bibliotecas numpy e matplotlib.

Figura 4 – Gráﬁco da interpolação de um conjunto de dados extraídos da função

f (x) = sin (x)/x.

62

Fonte: Elaborado pelo autor

3.2 Diferenças divididas de Newton

Suponha que Pn(x) seja o enésimo polinômio de Lagrange que concorda com a

função f nos pontos x0, x1, · · · , xn. Embora este polinômio seja único, existem representações

algébricas alternativas que são úteis em certas situações. O método das diferenças divididas de

Newton consiste em construir o polinômio interpolador da forma

Pn(x) = a0 + a1(x − x0) + · · · + an(x − x0) · · · (x − xn−1),

(3.5)

para constantes apropriadas a0, a1, · · · , an. Para determinar a primeira dessas constantes a0,

observemos que Pn(x) passa pelo ponto (x0, f (x0)), daí

a0 = Pn(x0) = f (x0)

Da mesma forma, quando Pn(n) é avaliado em x1 os únicos termos diferentes de zero

em Pn(x1) são os termos constantes e lineares,

f (x0) + a1(x1 − x0) = Pn(x1) = f (x1)

daí

a1 =

f (x1) − f (x0)
x1 − x0

(3.6)

A diferença dividida de ordem zero da função f em relação a xi, denotada por f [xi],

é simplesmente o valor de f em xi

f [xi] = f (xi)

63

As diferenças divididas restantes são deﬁnidas recursivamente; a diferença dividida

de ordem 1 de f em relação a xi e xi+1 é denotado por f [xi, xi+1] e deﬁnido como

f [xi, xi+1] =

f [xi+1] − f [xi]
xi+1 − xi

(3.7)

A diferença dividida de ordem 2, f [xi, xi+1, xi+2], é deﬁnida como

f [xi, xi+1, xi+2] =

f [xi+1, xi+2] − f [xi, xi+1]
xi+2 − xi

Similarmente, após a (k − 1)-ésima diferença dividida

f [xi, xi+1, xi+2, · · · , xi+k−1]

e

f [xi+1, xi+2, · · · , xi+k−1, xi+k]

determinamos a k-ésima diferença dividida em relação a xi, xi+1, xi+2, · · · , xi+k

f [xi, xi+1, · · · , xi+k−1, xi+k] =

f [xi+1, xi+2, · · · , xi+k] − f [xi, xi+1, · · · , xi+k−1]
xi+k − xi

(3.8)

O processo termina com a n-ésima diferença dividida

f [x0, x1, · · · , xn] =

f [x1, x2, · · · , xn] − f [x0, x1, · · · , xn−1]
xn − x0

(3.9)

Uma inspeção cuidadosa dos coeﬁcientes obtidos nos mostra que

ak = f [x0, x1, x2, · · · , xk],

para cada k = 0, 1, · · · , n. Isto nos permite esquematizar o método conforme apresentado na

tabela (11) abaixo

O método de Newton (3.8 e 3.9) é codiﬁcado em (42). Ao receber n pontos de dados

nas listas x e y, a função metodoNewton retorna os coeﬁcientos do polinômio de interpolação.

Código-fonte 42 – Interpolação usando Método de Newton

1 def metodoNewton (x , y , n , p ) :

2

3

4

5

6

7

8

9

10

"""

x [] - coordenadas x de pontos de dados

y [] - coordenadas y de pontos de dados

n - n ú mero de pontos de dados

p [] - coeficientes do polin ô mio de interpola ç ã o

"""

F = [[0] * n for _ in range ( n ) ]

for i in range ( n ) :

64

11

12

13

14

15

16

17

18

F [ i ][0] = y [ i ]

for i in range (1 , n ) :

for j in range (1 , i +1) :

F [ i ][ j ] = ( F [ i ][ j -1] - F [i -1][ j -1]) /( x [ i ] - x [i - j ])

for i in range ( n ) :

p [ i ] = F [ i ][ i ]

Fonte: Elaborado pelo autor.

Tabela 11 – Esquema de diferenças divididas para um conjunto de pontos

xi

x0

f [xi]

f [x0]

x1

f [x1]

x2

f [x2]

x3

f [x3]

x4

f [x4]

f [xi−1, xi]

f [xi−2, xi−1, xi]

f [xi−3, xi−2, xi−1, xi]

f [x0, x1] =

f [x1] − f [x0]
x1 − x0

f [x1, x2] =

f [x2] − f [x1]
x2 − x1

f [x2, x3] =

f [x3] − f [x2]
x3 − x2

f [x3, x4] =

f [x4] − f [x3]
x4 − x3

f [x0, x1, x2] =

f [x1, x2] − f [x0, x1]
x2 − x0

f [x1, x2, x3] =

f [x2, x3] − f [x1, x2]
x3 − x1

f [x2, x3, x4] =

f [x3, x4] − f [x2, x3]
x4 − x2

f [x0, x1, x2, x3] =

f [x1, x2, x3] − f [x0, x1, x2]
x3 − x0

f [x1, x2, x3, x4] =

f [x2, x3, x4] − f [x1, x2, x3]
x4 − x1

Fonte: Adaptado de (BEU, 2014)

Como exemplo do método de diferenças divididas vamos encontrar o polinômio que

passe pelos pontos (1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), (8, 21).

Código-fonte 43 – Polinômio interpolador passando pelos pontos dados.

1 n = 8

2 x = [1 ,2 ,3 ,4 ,5 ,6 ,7 ,8]

3 y = [1 , 1 , 2 , 3 , 5 , 8 , 13 , 21]

4 p =[0]* n

5

6 metodoNewton ( x1 , y1 , n , p )

7 print ( p )

Fonte: Elaborado pelo autor.

Ao executar o código acima, temos a saída:

[1, 0.0, 0.5, -0.16666666666666666, 0.08333333333333333,-0.025,

0.006944444444444445, -0.0015873015873015873] que representa o polinômio

65

P(x) = 1 +

(x − 1)(x − 2)
2

−

(x − 1)(x − 2)(x − 3)
6

+

−

(x − 1)(x − 2)(x − 3)(x − 4)(x − 5)
40

(x − 1)(x − 2)(x − 3)(x − 4)
12
(x − 1)(x − 2)(x − 3)(x − 4)(x − 5)(x − 6)
144
(x − 1)(x − 2)(x − 3)(x − 4)(x − 5)(x − 6)(x − 7)
630

−

+

.

3.3

Interpolação por Spline Cúbico

Suponha que uma função f deﬁnida em um intervalo [a, b] seja suﬁcientemente

suave e o intervalo seja subdividido pelos pontos a ≤ x0 < x1 < · · · < xn−1 < xn ≤ b. Uma por

spline cúbico interpolador S de f é uma função que satisfaz as seguintes condições:

1. S(x) ∈ C2[a, b],

2. S(x) é um polinômio de grau 3, em cada subintervalo [xi, xi+1].

3. S(xi) = f (xi) para cada i = 0, 1, · · · , n, ou seja,

S(x) =






S1(x),

x0 ≤ x ≤ x1

· · ·

Si(x),

xi−1 ≤ x ≤ xi

· · ·

Sn(x), xn−1 ≤ x ≤ xn

onde Si(x) = ai + bix + cix2 + dix3 (di (cid:54)= 0), i = 1, · · · , n.

Para determinar S(x) precisamo determinar ai, bi, ci, di para cada i, de tal modo:

• Si(xi−1) = f (xi−1) e Si(xi) = f (xi) para cada i = 1, · · · , n.
• S(cid:48)

i(xi) = S(cid:48)
i (xi) = S(cid:48)(cid:48)

i+1(xi) pra cada i = 1, · · · , n − 1.
i+1(xi) pra cada i = 1, · · · , n − 1.

• S(cid:48)(cid:48)

Podemos ver que há n + n + (n − 1) + (n − 1) = 4n − 2 condições, mas precisamos

determinar 4n coeﬁcientes então adicionamos duas condições de contorno para resolver este

problema.

1. S(cid:48)(cid:48)(x0) = S(cid:48)(cid:48)(xn) = 0, ou

66

2. S(cid:48)(x0) = f (cid:48)(x0) e S(cid:48)(xn) = f (cid:48)(xn)

As condições dadas acimas são suﬁcientes para nossos objetivos.

Existem vários métodos que podem ser usados para encontrar a função spline S(x)

de acordo com suas condições correspondentes. Uma vez que existem 4n coeﬁcientes para

determinar com 4n condições, podemos facilmente inserir os valores que conhecemos nas 4n

condições e então resolver o sistema de equações. Observemos que todas as equações são

lineares em relação aos coeﬁcientes, então isso é viável e os computadores podem fazer isso

muito bem.

Os coeﬁcientes ai, bi, ci e di das splines podem ser determinados, em princípio, a

partir das condições de continuidade e interpolação nos números xi:

S(xi) = f (xi)

(3.10)

A segunda derivada do spline, S(cid:48)(cid:48)

i (x), é uma função linear deﬁnida no intervalo

[xi−1, xi] pela equação

i (x) − S(cid:48)(cid:48)(xi−1)
S(cid:48)(cid:48)
x − xi−1

=

S(cid:48)(cid:48)(xi) − S(cid:48)(cid:48)(xi−1)
xi − xi−1

,

(3.11)

Os termos xi − xi−1 são usados repetidamente neste desenvolvimento, por isso é

conveniente introduzir a notação mais simples

para i = 1, · · · , n − 1. Da equação (3.11), temos que

hi = xi − xi−1

S(cid:48)(cid:48)
i (x) =

(x − xi−1)S(cid:48)(cid:48)(xi) + (xi − x)S(cid:48)(cid:48)(xi−1)
hi

(3.12)

Integrando a Equação 3.12 duas vezes, obtém-se sucessivamente a primeira derivada e a própria

spline:

S(cid:48)
i(x) =

(x − xi−1)2S(cid:48)(cid:48)(xi) − (xi − x)2S(cid:48)(cid:48)(xi)
2hi

+C1
i ,

Si(x) =

(x − xi−1)3S(cid:48)(cid:48)(xi) + (xi − x)3S(cid:48)(cid:48)(xi−1)
6hi

+C1

i x +C2
i .

(3.13)

(3.14)

As constantes de integração C1

i e C2

i podem ser determinadas usando

Si(xi−1) = f (xi−1),

Si(xi) = f (xi)

resultando no sistema:

h2
i
6






S(cid:48)(cid:48)(xi−1) +C1
h2
i
6

S(cid:48)(cid:48)(xi) +C1

i xi−1 +C2

i = f (xi−1)

i (xi) +C2

i = f (xi)

Resolvendo esse sistema para C1

i e C2

i resulta

C1

i =

f (xi) − f (xi−1)
hi

−

C2

i =

xi f (xi−1) − xi−1 f (xi)
hi

+

hi
6
hi
6

[S(cid:48)(cid:48)(xi) − S(cid:48)(cid:48)(xi−1)],

[xi−1S(cid:48)(cid:48)(xi) − xiS(cid:48)(cid:48)(xi−1)]

67

(3.15)

(3.16)

Após a substituição das constantes de integração de volta na equação (3.14) obtém-se os coe-
ﬁcientes polinomiais da spline Si(x) em termos das segundas derivadas S(cid:48)(cid:48)(xi) nos pontos de

interpolação:






di =

ci =

bi =

ai =

S(cid:48)(cid:48)(xi) − S(cid:48)(cid:48)(xi−1)
6hi

,

xiS(cid:48)(cid:48)(xi−1) − xi−1S(cid:48)(cid:48)(xi)
2hi

,
i S(cid:48)(cid:48)(xi−1)

i−1S(cid:48)(cid:48)(xi) − x2
x2
2hi

i S(cid:48)(cid:48)(xi−1) − x3
x3

i−1S(cid:48)(cid:48)(xi)

6hi

+

+

f (xi) − f (xi−1)
hi

− dih2
i ,

xi f (xi−1) − xi−1 f (xi)
hi

−

cih2
i
3

.

(3.17)

Para a deﬁnição completa das splines, ainda é necessário determinar os valores S(cid:48)(cid:48)(xi)

das segundas derivadas e isso pode ser feito usando a continuidade da primeira derivada,

i(xi) = S(cid:48)
S(cid:48)

i+1(xi)

Usando as equações (3.13) e (3.15), resulta em,

hi
6

S(cid:48)(cid:48)(xi−1) +

hi + hi+1
3

S(cid:48)(cid:48)(xi) +

hi+1
6

S(cid:48)(cid:48)(xi+1) =

f (xi+1) − f (xi)
hi+1

−

f (xi) − f (xi−1)
hi

.

(3.18)

O sistema de equações (3.18) compreende n − 1 equações para as n + 1 deriva-
das S(cid:48)(cid:48)(xi) e, consequentemente, para sua determinação inequívoca, duas equações adicionais

precisam ser fornecidas. Usando

S(cid:48)(cid:48)(x0) = S(cid:48)(cid:48)(xn) = 0

ﬁcamos com o seguinte sistema linear descrito pela equação vetorial Ax = b, onde A é a matriz

(n + 1) × (n + 1)



1

0

h1 2(h1 + h2)

0

h2

A =

h2

2(h2 + h3)

· · ·

h3
. . .

0

...

hn−1 2(hn−1 + hn) hn

· · ·

0

0

1















0
...

0

















(3.19)

68

e b e x são os vetores
















b = 6

f (x2) − f (x1)
h2

0

−
...

f (x1) − f (x0)
h1

f (xn) − f (xn−1)
hn

−

f (xn−1) − f (xn−2)
hn−1

0
















e x =





















S(cid:48)(cid:48)(x0)
S(cid:48)(cid:48)(x1)
...
S(cid:48)(cid:48)(xn)

Essencialmente, a implementação da interpolação de spline cúbica envolve:

1. Avaliação da segunda derivada S(cid:48)(cid:48)(xi) resolvendo o sistema acima.

2. Cálculo dos coeﬁcientes spline ai, bi, ci e di usando as equações (3.17),

3. Avaliação do interpolante para um determinado conjunto de argumentos.

O código abaixo implementa essas ideias. A entrada é representada pelos array x e

y, transmitindo as n coordenadas dos pontos interpolados. Para resolver o sistema (3.19) para as

segundas derivadas das splines nos nós de interpolação, usamos um método não abordado nesse

trabalho.

Código-fonte 44 – Interpolação usando Método de spline cúbico

1 import numpy as np

2 import matplotlib . pyplot as plt

3

4 def splineMetodo (x , y , n , a , b , c , d ) :

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

"""

Calcula os coeficientes das splines c ú bicas para n pontos de dados

x [] - coordenadas x dos pontos

y [] - coordenadas y dos pontos

n

- n ú mero de pontos

a [] , b [] , c [] , d [] -

cooeficientes da spline c ú bica

"""

h = [0]*( n +1)

bb = [0]*( n +1)

# usado para resolver sistema

# m é todo n ã o abordado nesse trabalho

l = [0]*( n +1)

69

u = [0]*( n +1)

z = [0]*( n +1)

S = [0]*( n +1)

for i in range (1 , n +1) :

h [ i ] = x [ i ] - x [i -1]

for i in range (1 , n ) :

btmp1 = ( y [ i +1] - y [ i ]) / h [ i +1]

btmp2 = ( y [ i ] - y [i -1]) / h [ i ]

bb [ i ] =6*( btmp1 - btmp2 )

l [0] = 1

u [0] = 0

z [0] = 0

for i in range (1 , n ) :

l [ i ] = 2*( x [ i +1] - x [i -1]) -h [ i ]* u [i -1]

u [ i ] = h [ i +1]/ l [ i ]

z [ i ] = ( bb [ i ] - h [ i ]* z [i -1]) / l [ i ]

l [ n ] = 1

z [ n ] = 0

S [ n ] = 0

for i in range (n , 0 , -1) :

S [i -1] = z [i -1] - u [ i ]* S [ i ]

d [i -1] = ( S [ i ] - S [i -1]) /(6* h [ i ])

c [i -1] = ( x [ i ]* S [i -1] - x [i -1]* S [ i ]) /(2* h [ i ])

b [i -1] = ( x [i -1]**2* S [ i ] - x [ i ]**2* S [i -1]) /(2* h [ i ]) +\

( y [ i ] - y [i -1]) / h [ i ] - d [i -1]* h [ i ]* h [ i ]

a [i -1] = ( x [ i ]**3* S [i -1] - x [i -1]**3* S [ i ]) /(6* h [ i ]) +\

( x [ i ]* y [i -1] - x [i -1]* y [ i ]) / h [ i ] - ( c [i -1]* h [ i ]**2) /3.

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57 def polinomio (a , b , c , d , p , x ) :

58

return a [ p ]+ x *( b [ p ]+ x *( c [ p ]+ x * d [ p ]) )

70

59

60 x = [0 , 1 , 2 , 3]

61 y = np . exp ( x )

62 n = 3

63

64 a = [0]* n

65 b = [0]* n

66 c = [0]* n

67 d = [0]* n

68

69 splineMetodo (x , y , n , a , b , c , d )

70 print ( " a = " , a )

71 print ( " b = " , b )

72 print ( " c = " , c )

73 print ( " d = " , d )

74

75 x1 = np . arange (0 , 3 , .1)

76 plt . plot ( x1 , np . exp ( x1 ) )

77

78 xx1 = np . arange (0 ,1.1 ,.1)

79 xx2 = np . arange (1 ,2.1 ,.1)

80 xx3 = np . arange (2 ,3 ,.1)

81

82 plt . plot ( xx1 , polinomio (a , b , c , d , 0 , xx1 ) )

83 plt . plot ( xx2 , polinomio (a , b , c , d , 1 , xx2 ) )

84 plt . plot ( xx3 , polinomio (a , b , c , d , 2 , xx3 ) )

85 plt . legend ([ r " $y = e ^ x$ " , " [0 , 1] " ," [1 , 2] " ," [2 , 3] " ])

86

87 plt . grid ( True )

88 plt . show ()

Fonte: Elaborado pelo autor.

Aproximando a exponencial f (x) = ex, usando os pontos (0, 1), (1, e), (2, e2) e

(3, e3) usando método spline, obtemos:

S(x) =





1.0 + 1.60833x − 0.16492x2 + 0.27487x3

para

x ∈ [0, 1]

−0.63312 + 6.13864x − 4.51070x21.72346x3

para

x ∈ [1, 2]

28.63663 − 37.83076x + 17.49020x2 − 1.94336x3 para

x ∈ [2, 3]

A spline e sua concordância com f (x) = ex são mostrados na ﬁgura (5)

Figura 5 – Aproximando função f (x) = ex pelo método de spline cúbico.

71

Fonte: Elaborado pelo autor

3.4

Implementação em Fortran

Os códigos seguintes mostram a implementações FORTRAN equivalentes das fun-

ções Python desenvolvidas durante esse capítulo. As rotinas correspondentes têm nomes,

parâmetros e funcionalidades idênticos.

Código-fonte 45 – Interpolação de Lagrange

1 function lagrange (x , y , k , xi )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

! Calcula o Polinomio de Interpolacao de Lagrange

! de k pontos no ponto xi

! x [] - coordenadas x dos pontos

! y [] - coordenadas y dos pontos

! k

- numero de pontos

! xi

- argumento

implicit none

real ( kind = 8 ) , dimension ( k ) :: x , y

integer :: k , i , j

real ( kind = 8 ) :: xi , yi , lagrange , p

yi = 0

do i = 1 , k

p = 1. e0

do j = 1 , k

if ( j /= i ) then

p = p *( xi - x ( j ) ) /( x ( i ) - x ( j ) )

72

end if

end do

yi = yi + p * y ( i )

end do

lagrange = yi

20

21

22

23

24

25

26

27

28 end function lagrange

Fonte: Elaborado pelo autor.

Código-fonte 46 – Interpolação de Lagrange com múltiplos argumentos

1 subroutine lagrange1 (x , y , k , xi , yi , ki )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

! Calcula o polinomio de Lagrange de ni pontos

! x [] - coordenadas x dos pontos

! y [] - coordenadas y do spontos

! k - numero de pontos

! xi [] - argumentos da interpolacao

! yi [] - saida ( pk ( xi ) )

! ki - numero de pontos de interpolacao

implicit none

integer :: k , ki

real ( kind = 8 ) , dimension ( k ) :: x , y , xi , yi

real ( kind = 8 ) , dimension ( k ) :: yf

real ( kind = 8 ) :: p , xk , yk

integer :: i , j , l

! calcula valores constantes

do i = 1 , k

p = 1. e0

do j = 1 , k

if ( j /= i ) then

p = p * ( x ( i ) -x ( j ) )

end if

73

end do

yf ( i ) = y ( i ) / p

end do

! loop nos ki pontos

do l = 1 , ki

xk = xi ( l )

yk = 0. e0

do i = 1 , k

p = 1. e0

do j = 1 , k

if ( j /= i ) then

p = p * ( xk - x ( j ) )

end if

end do

yk = yk + p * yf ( i )

end do

yi ( l ) = yk

end do

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47 end subroutine

Fonte: Elaborado pelo autor.

Código-fonte 47 – Interpolação usando método de Newton

1 subroutine metodoNewton (x , y , n , p )

2

3

4

5

6

7

8

9

10

11

12

implicit none

integer :: n

real ( kind = 8 ) , dimension ( n ) :: x , y

real ( kind = 8 ) , dimension ( n ) :: p

real ( kind = 8 ) , dimension (0: n -1 , 0: n -1) :: F

integer :: i , j

do i = 0 , n -1

74

F (i , 0) = y ( i +1)

end do

do i = 1 , n -1

do j = 1 , i

F (i , j ) = ( F (i , j -1) - F (i -1 , j -1) ) /( x ( i +1) -x (i - j +1) )

end do

end do

do i = 0 , n -1

p ( i +1) = F (i , i )

end do

13

14

15

16

17

18

19

20

21

22

23

24

25

26 end subroutine metodoNewton

27

28 program main

implicit none

integer , parameter :: n = 8

integer :: i

real ( kind = 8 ) , dimension ( n ) :: x , y , p

x = (/1 , 2 , 3 , 4 , 5 , 6 , 7 , 8/)

y = (/1 , 1 , 2 , 3 , 5 , 8 , 13 , 21/)

p = (/0 , 0 , 0 ,0 ,0 ,0 ,0 ,0/)

call metodoNewton (x , y , n , p )

do i = 1 , n

print * , p ( i )

end do

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46 end program main

Fonte: Elaborado pelo autor.

Código-fonte 48 – Interpolação usando Método de spline cúbico

1 subroutine splineMetodo (x , y , n , a , b , c , d )

75

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

! Calcula os coeficientes das splines c ú bicas para n pontos de

dados

! x [] - coordenadas x dos pontos

! y [] - coordenadas y dos pontos

! n

- n ú mero de pontos

! a [] , b [] , c [] , d [] -

!

cooeficientes da spline c ú bica

implicit none

integer :: n

real ( kind = 8 ) , dimension (0: n ) :: x , y

real ( kind = 8 ) , dimension ( n ) :: a , b , c , d

real ( kind = 8 ) , dimension (0: n ) :: h , bb

! usado para resolver o sistema

! m é todo n ã o abordado nesse trabalho

real ( kind = 8 ) , dimension (0: n ) :: l , z , u , S

integer :: i

do i = 1 , n

h ( i ) = x ( i ) -x (i -1)

end do

do i = 1 , n -1

bb ( i ) = 6*(( y ( i +1) -y ( i ) ) / h ( i +1) -( y ( i ) -y (i -1) ) / h ( i ) )

end do

l (0) = 1. e0

u (0) = 0. e0

z (0) = 0. e0

do i = 1 , n -1

l ( i ) = 2*( x ( i +1) -x (i -1) ) -h ( i ) * u (i -1)

u ( i ) = h ( i +1) / l ( i )

z ( i ) = ( bb ( i ) -h ( i ) * z (i -1) ) / l ( i )

end do

76

38

39

40

41

42

43

44

45

46

47

48

49

50

51

l ( n ) = 1. e0

z ( n ) = 0. e0

S ( n ) = 0. e0

do i = n , 1 , -1

S (i -1) = z (i -1) - u ( i ) * S ( i )

d ( i ) = ( S ( i ) - S (i -1) ) /(6* h ( i ) )

c ( i ) = ( x ( i ) * S (i -1) -x (i -1) * S ( i ) ) /(2* h ( i ) )

b ( i ) = ( x (i -1) * x (i -1) * S ( i ) -x ( i ) * x ( i ) * S (i -1) ) /(2* h ( i ) ) +&

&( y ( i ) -y (i -1) ) / h ( i ) -d ( i ) * h ( i ) * h ( i )

a ( i ) = ( x ( i ) * x ( i ) * x ( i ) * S (i -1) -x (i -1) * x (i -1) * x (i -1) * S ( i ) ) /(6* h ( i

) ) &

&+( x ( i ) * y (i -1) -x (i -1) * y ( i ) ) / h ( i ) -( c ( i ) * h ( i ) * h ( i ) ) /3. e0

end do

52 end subroutine splineMetodo

53

54 program main

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

implicit none

integer , parameter :: n = 3

real ( kind = 8 ) , dimension ( n ) :: a , b , c , d

real ( kind = 8 ) , dimension (0: n ) :: x , y

integer :: i

x = (/0. e0 , 1. e0 , 2. e0 , 3. e0 /)

do i = 0 , n

y ( i ) = exp ( x ( i ) )

end do

call splineMetodo (x , y , n , a , b , c , d )

do i = 1 , n

print * , a ( i ) , b ( i ) , c ( i ) , d ( i )

end do

72 end program main

Fonte: Elaborado pelo autor.

77

4 INTEGRAÇÃO DE FUNÇÕES

Para obter o valor da integral deﬁnida

(cid:90) b

a

f (x) dx,

basta achar uma função F(x) tal que F (cid:48)(x) = f (x)|, de forma que

(cid:90) b

a

f (x) dx = F(b) − F(a).

Se f (x) for desconhecida, exceto em alguns pontos ou não for integrável, ou no caso em que f (x)

é conhecido, mas a forma de f (x) é tão complicada que é muito difícil integrá-la e encontrar um

valor, podemos tentar encontrar o valor numérico da integral até um grau desejado de precisão.

Este problema é denominado integração numérica ou quadratura.

4.1 O Método dos Trapézios

Partindo da interpretação geométrica da integral deﬁnida, como a área delimitada

pelo gráﬁco de uma função f , o eixo x e pelas retas verticais x = a e x = b, a abordagem

algorítmica mais simples é substituir o gráﬁco de f por uma linha poligonal (como mostrado na

ﬁgura 6) e somar as áreas trapezoidais assim formadas.

Figura 6 – Área sob uma curva

y

f1

x1

h

f2

x2

fi

xi

h

fi+1

fn

xi+1 xn

x

Fonte: Elaborado pelo autor.

Dividimos o intervalo [a, b] em intervalos de tamanhos iguais, denotado por xi =

a, x1, · · · , xn−1, xn = b de modo que

xi = x0 + ih,

i = 0, 1, · · · , n,

78

onde

h = (b − a)/n.

Substituindo as integrais de cada um dos n subintervalos (xi, xi+1) pela correspon-

dente área trapezoidal, a integral será, aproximadamente

(cid:90) a

b

f (x)dx ≈

h
2

( f0 + f1) + · · · +

h
2

( fi + fi+1) + · · · +

h
2

( fn−1 + fn).

Colocando h em evidência e organizando, ﬁcamos

(cid:90) a

b

f (x)dx ≈ h

(cid:34)

f0
2

+

n−1
∑
i=1

fi +

(cid:35)

.

fn
2

Nosso resultado será tanto mais preciso quanto menor for o tamanho de h.

O valor da integral de uma determinada função f num intervalo [a, b] pela fórmula

do trapézio pode ser dado de acordo com o seguinte implementação em python3.

Código-fonte 49 – Integração de uma função usando o método dos trapézios

1 def regraTrapz ( func , a , b , n ) :

2

3

4

5

6

7

8

9

10

11

"""

Calcula a integral da funcao func no intervalo

[a , b ] usando o metodo dos trapezios com n pontos

"""

h = (b - a ) / n

soma = ( func ( a ) + func ( b ) ) /2

for i in range (1 , n ) :

soma += func ( a + i * h )

return h * soma

Fonte: Elaborado pelo autor.

Para exempliﬁcar o uso do método, ilustremos com um exemplo cujo resultado é

bem conhecido.

(cid:90) 1

0

1

1 + x2 dx =

π
4

.

(4.1)

Como ainda não falamos em estimativas de erro para o método, nossa escolha em

relação ao tamanho dos intervalos da partição e ao número de algarismos signiﬁcativos será

arbitrária.

Dividindo o intervalo [0, 1] em 10 intervalos iguais, e usando a implementação acima,

obtemos que

π ≈ 3.1399,

com 5 algarismos signiﬁcativos,

79

valor à distância de aproximadamente 1.6 × 10−3 do valor verdadeiro.

4.2 O Método de Simpson

Antes, aproximamos a função f , em cada subintervalo, por uma reta coincidindo

com a função nos extremos. Agora, consideraremos polinômios quadráticos como forma de

aproximar a função.

Com o objetivo de calcular a integral deﬁnida

(cid:90) a

b

f (x)dx,

começamos dividindo o intervalo [a, b] em n subintervalos de tamanhos

de tal modo que

h = (b − a)/n,

xi = a + ih,

i = 0, 1, · · · , n.

Assumindo que os valores fi ≡ f (xi) são conhecidos, aproximamos a função f por

um polinômio de grau menor ou igual a n, usando interpolação polinomial de Lagrange, tal que

Pn(xi) = fi

Pn−1(x) =

n
∑
i=0

∏n
∏n

j(cid:54)=i(x − x j)
j(cid:54)=i(xi − x j)

fi.

(4.2)

Fazendo a mudança de variável t = (x − a)/h, podemos escrever x = a + th, assim a

expressão acima ﬁca

n
∏
j(cid:54)=i

(x − x j) = hn−1

n
∏
j(cid:54)=i

(t − j),

(xi − x j) = hn−1

∏
j(cid:54)=i

n
∏
j(cid:54)=i

(i − j) = (−1)n−ihn−1

i−1
∏
j=0

(i − j)

n
∏
j=i+1

( j − i)

= (−1)n−ihn−1i!(n − i)!.

O polinômio toma a forma

Pn(x) =

∏n

i(cid:54)= j(t − j)
(−1)n−ii!(n − i)!

fi,

n
∑
i=0

e obtemos a aproximação da integral:

(cid:90) a

b

f (x)dx ≈

(cid:90) a

b

Pn(x)dx =

n
∑
i=0

Ai fi,

onde os coeﬁcientes Ai são dados por (e usando a mudança de variável):

Ai =

(cid:90) a

b

∏n

i(cid:54)= j(t − j)
(−1)n−ii!(n − i)!

=

h
(−1)n−ii!(n − i)!

(cid:90) n

0

n
∏
j(cid:54)=i

(t − j)dt.

80

(4.3)

(4.4)

(4.5)

Notemos que os coeﬁcientes (ou pesos) Ai dependem somente de n; em particular, não dependem

da função f a ser integrada nem do intervalo de integração.

Se n=1, então

A0 =

h
(−1)1−00!(1 − 0)!

A1 =

h
(−1)1−11!(1 − 1)!

(cid:90) 1

0

(cid:90) 1

0

1
∏
j(cid:54)=0

(t − j)dt = −h

(cid:90) 1

0

(t − 1)dt =

h
2

,

1
∏
j(cid:54)=1

(t − j)dt = h

(cid:90) 1

0

tdt =

h
2

,

e obtemos

(cid:90) x2

x1

f (x)dx ≈

h
2

( f1 + f2).

(4.6)

Dividindo o intervalo [a, b] em n subintervalo de igual comprimento b−a

n , decompomos a integral

numa soma de n parcelas,

(cid:90) a

b

f (x)dx =

(cid:90) x1

a

f (x)dx + · · · +

(cid:90) b

xn−1

f (x)dx =

n−1
∑
i=0

(cid:90) xi+1

xi

f (x)dx

(4.7)

A cada uma dessas parcelas da soma 4.7 podemos aplicar a fórmula 4.6, isto é,

Assim, obtêm-se

(cid:90) xi+1

xi

f (x)dx ≈

f (xi) + f (xi+1)
2

h.

(cid:90) a

b

f (x)dx ≈

n−1
∑
i=0

f (xi) + f (xi+1)
2

h.

O somatório 4.8 pode ser representado na forma

(cid:90) a

b

f (x)dx ≈ h

(cid:34)

f (a)
2

+

n−1
∑
i=1

f (xi) +

(cid:35)

,

f (b)
2

(4.8)

(4.9)

81

obtido anteriormente de maneira puramente geométrica.

Para n = 2, os correspondentes coeﬁcientes são dados por

A0 =

h
(−1)2−00!(2 − 0)!

A1 =

h
(−1)2−11!(2 − 1)!

A2 =

h
(−1)2−22!(2 − 2)!

(cid:90) 2

0

(cid:90) 2

0

(cid:90) 2

0

2
∏
j(cid:54)=0

(t − j)dt =

h
2

(cid:90) 2

0

(t − 1)(t − 2)dt =

h
3

,

2
∏
j(cid:54)=1

(t − j)dt = −h

(cid:90) 2

0

t(t − 2)dt =

4h
3

,

2
∏
j(cid:54)=2

(t − j)dt =

h
2

(cid:90) 2

0

t(t − 1)dt =

h
3

,

resultando

(cid:90) b

a

f (x)dx ≈

h
3

( f0 + 4 f1 + f2).

(4.10)

Tal como se fez para a regra dos trapézios (ver seção 4.1), subdividimos o intervalo
[a, b] em n partes. Dado que a regra de Simpson utiliza 3 pontos, o número n (cid:62) 2 deverá ser par.

Em cada um dos subintervalos

[xi, xi+2] = [a + ih, a + (i + 2)h]

é aplicada a equação 4.10. Tem-se

(cid:90) b

a

f (x)dx ≈

=

h
3
h
3

Fazendo

[( f0 + 4 f1 + f2) + ( f2 + 4 f3 + f4) + · · · + ( fn−2 + 4 fn−1 + fn)]

[ f0 + fn + 4( f1 + f3 + · · · + fn−1) + 2( f2 + f4 + · · · + fn−2)].

σ1 =

n/2
∑
i=1

f (x2i−1), σ2 =

n/2−1
∑
i=1

f (x2i),

(4.11)

obtemos a fórmula da Regra de Simpson:

(cid:90) b

a

f (x)dx ≈

h
3

( f0 + 4σ2 + 2σ1 + fn).

Usando as fórmulas 4.11 e 4.2, implementamos o código 50 abaixo. Os argumentos

da função regraSimpson são: func recebe o nome da função que será integrada, enquanto a e b

são os limites de integração. Se o número de pontos n for ímpar, ele é automaticamente corrigido

para o valor par mais alto, de modo que a fórmula de Simpson possa ser aplicada corretamente,

como descrito no texto.

Código-fonte 50 – Integração de uma função usando o método de Simpson

1 def regraSimpson ( func , a , b , n ) :

82

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

"""

Calcula a integral da funcao func no intervalo

[a , b ] usando o metodo de Simpson com n ( par ) pontos

"""

if ( n % 2 == 1) :

# verifica se n e par

n += 1

h = (b - a ) / n

s1 = s2 = 0 e0

for i in range (1 , n //2) :

# soma em indice par

s1 += func ( a +2* i * h )

for i in range (1 , n //2+1) :

# soma em indice impar

s2 += func ( a +(2* i -1) * h )

return ( h /3) *( func ( a ) +4* s2 +2* s1 + func ( b ) )

Fonte: Elaborado pelo autor.

Para comparar com a regra do Trapézio, calculemos a mesma integral 4.1, usando a

mesma divisão de intervalos. Usaremos 9 algarismos signiﬁcativos. Obtemos

π = 4

(cid:90) 1

0

1

1 + x2 dx ≈ 3.14159261,

com erro de 4.0 × 10−8, resultado bem melhor que o obtido anteriormente.

4.3 Quadratura Adaptativa

As implementações regraTrapz e regraSimpson apresentadas na seção anterior

além de exigirem o número de pontos de integração, não fornecem uma estimativa de erro para

a integral. Pode-se implementar um procedimento automático de quadratura, no qual todos

os subintervalos de [a, b] são continuamente subdivididos até que uma precisão suﬁciente seja

alcançada. No entanto essa abordagem não é necessário em regiões onde a função é suave.

Uma alternativa é a quadratura adaptativa. A quadratura adaptativa é uma técnica

em que o intervalo [a, b] é dividido em n subintervalos [xi, xi+1], para i = 0, 1, · · · , n e uma regra

de quadratura, como a regra trapezoidal, é usada em cada subintervalo para calcular

83

I f ( f ) =

(cid:90) xn+1

xi

f (x)dx.

No entanto, na quadratura adaptativa, um subintervalo [xi, xi+1] é subdividido se for determinado

que a regra da quadratura não calculou Ii( f ) com precisão suﬁciente.

Vamos estabelecer uma relação recursiva entre as aproximações consecutivas. De

acordo com a Figura 7, que mostra as grades de integração para os primeiros quatro estágios

do processo de redução pela metade, a avaliação do integrando é necessária somente nos novos

pontos de integração (indicados por círculos) que dividem os subintervalos anteriores. Os valores

da função já empregada são reutilizados implicitamente pela aplicação da relação de recorrência

entre duas aproximações consecutivas da integral.

Figura 7 – Divisão dos intervalos

h0

b

a

n0 = 1

n1 = 2

n2 = 4

h1

h2

h3

n3 = 8

Fonte: Adaptado de (BEU, 2014)

As três primeiras aproximações produzidas pela regra trapezoidal são

T0 = h0

T1 = h1

T2 = h2

(cid:20) f (a)
2
(cid:20) f (a)
2
(cid:20) f (a)
2

+

(cid:21)

,

f (b)
2

h0 = b − a,

+ f (a + h1) +

(cid:21)

,

f (b)
2

h1 =

h0
2

,

+ f (a + h2) + f (a + 2h2) + f (a + 3h2) +

(cid:21)

,

f (b)
2

h2 =

h2
2

.

(4.12)

A sequência acima pode ser escrita como

T0 =

Tk =

h0
2
1
2

[ f (a) + f (b)],
(cid:34)

Tk−1 + hk−1

nk−1
∑
i=1

h0 = b − a,

n0 = 1,

(cid:18)

(cid:18)

f

a +

i −

(cid:19)(cid:35)

hk−1

,

(cid:19)

1
2

84

(4.13)

hk = hk−1/2,

nk = 2nk−1,

k = 1, 2, · · · ,

onde hk = (b − a)/nk é o espaçamento após a etapa de divisão k, com nk = 2k representando o

número correspondente de subintervalos ou, equivalentemente, o número de novos pontos de

integração relevantes para a próxima aproximação da integral.

O processo recursivo (4.13) é continuado até que duas aproximações consecutivas

se tornem indistinguíveis para uma dada precisão, isto é, até que sua diferença relativa, |Tk −

Tk−1/|Tk| seja menor que uma tolerância pré-deﬁnida ε. Para evitar a divisão na situação

particular quando Tk = 0, o critério de convergência pode ser convenientemente formulado como

|Tk − Tk−1| (cid:54) ε|Tk|.

(4.14)

A função integralTrapzAdaptive (código 51) implementa o algoritmo adaptativo

descrito com base na regra trapezoidal.

Código-fonte 51 – Integração de uma função usando o método dos Trapézio Adaptativo

1 def in tegral Trapz Adapti ve ( func , a , b , eps = 1e -6) :

2

3

4

5

6

7

8

9

10

11

12

13

14

15

"""

Calcula a integral da funcao func no intervalo [a , b ]

com precisao eps usando o metodo trapezoidal adaptativo

"""

kmax = 30

# numero maximo de interacoes

h = b - a

n = 1

t0 = 0.5* h *( func ( a ) + func ( b ) )

# aproximacao inicial

for k in range (1 , kmax +1) :

sumf = 0 e0

for i in range (1 , n +1) :

sumf += func ( a +( i -0.5) * h )

85

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

t = 0.5*( t0 + h * sumf )

# nova aproximacao

if ( k > 1) :

# checando a convergencia

if ( abs (t - t0 ) <= eps * abs ( t ) ) :

break

if ( abs ( t ) <= eps and abs ( t ) <= abs (t - t0 ) ) :

break

h *= 0.5

n *= 2

t0 = t

if ( k >= kmax ) :

print ( " Maximo de interacoes excedido ! " )

return t

Fonte: Elaborado pelo autor.

A partir das três primeiras aproximações da regra trapezoidal (4.12), aproximações

consecutivas da fórmula de Simpson podem ser expressas da seguinte forma

S1 =

S2 =

h1
3
h2
3

[ f (a) + 4 f (a + h1) + f (b)] =

4T1 − T0
3

,

[ f (a) + 4 f (a + h2) + 2 f (a + h2) + 4 f (a + 3h2) + f (b)] =

4T2 − T1
3

.

Daí, obtemos a relação

Sk =

4Tk − Tk−1
3

.

(4.15)

(4.16)

Assim, segue que o algoritmo recursivo com base na regra de Simpson pode ser descrito ainda

em termos de aproximações trapezoidais:

T0 =

Tk =

Sk =

[ f (a) + f (b)],
(cid:34)

Tk−1 + hk−1

h0
2
1
2
4Tk − Tk−1
3

nk−1
∑
i=1

h0 = b − a,

n0 = 1,

(cid:18)

(cid:18)

f

a +

i −

(cid:19)(cid:35)

hk−1

,

(cid:19)

1
2

(4.17)

,

hk = hk−1/2,

nk = 2nk−1,

k = 1, 2, · · · .

Código-fonte 52 – Integração de uma função usando o método de Simpson Adaptativo

1 def in te gr a lS im p so nA da p t i v e ( func , a , b , eps = 1e -6) :

86

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

"""

Calcula a integral da funcao func no intervalo [a , b ] com

precisao eps usando o metodo de Simpson adaptativo

"""

kmax = 30

h = b - a

n = 1

# numero maximo de interacoes

s0 = t0 = 0.5* h *( func ( a ) + func ( b ) )

# aproximacao inicial

for k in range (1 , kmax +1) :

sumf = 0 e0

for i in range (1 , n +1) :

sumf += func ( a +( i -0.5) * h )

t = 0.5*( t0 + h * sumf )

s = (4* t - t0 ) /3

# nova aproximacao

if ( k > 1) :

if ( abs (s - s0 ) <= eps * abs ( s ) ) :

break

if ( abs ( s ) <= eps and abs ( s ) <= abs (s - s0 ) ) :

break

h *= 0.5

n *= 2

s0 = s

t0 = t

if ( k >= kmax ) :

print ( " Maximo de interacoes excedido ! " )

return s

Fonte: Elaborado pelo autor.

Os argumentos, variáveis e constantes da função integralSimpsonAdaptive, im-

plementando no código 52 mantêm os mesmos signiﬁcados que foram atribuídas na função

87

integralTrapzAdaptive, no código 51.

4.4 Método de Romberg

Nesta seção, ilustraremos como o método de Richardson aplicada aos resultados

da regra trapezoidal pode ser usada para obter aproximações de alta precisão com pouco custo

computacional.

Na seção 4.3 encontramos a seguinte relação

Sk =

4Tk − Tk−1
3

entre as aproximações Tk da regra trapezoidal (4.12) e as aproximações correspondentes Sk

dadas pela fórmula de Simpson (4.15). A ﬁm de generalizar esse resultado, renomeamos as

aproximações trapezoidais como Rk,0:

R0,0 = h0

R1,0 = h1

R2,0 = h2

(cid:20) f (a)
2
(cid:20) f (a)
2
(cid:20) f (a)
2

+

(cid:21)

,

f (b)
2

h0 = b − a,

+ f (a + h1) +

(cid:21)

,

f (b)
2

h1 =

h0
2

,

+ f (a + h2) + f (a + 2h2) + f (a + 3h2) +

(cid:21)

,

f (b)
2

h2 =

h1
2

.

(4.18)

Reescrevendo a (4.13) em termos dessa mudança, ﬁcamos

(cid:34)

Rk−1,0 + hk−1

Rk,0 =

1
2

nk−1
∑
i=1

(cid:18)

(cid:18)

f

a +

i −

(cid:19)

1
2

(cid:19)(cid:35)

hk−1

,

k = 1, 2, · · ·

(4.19)

e as duas primeiras aproximações produzidas pela fórmula de Simpson são:

[ f (a) + 4 f (a + h1) + f (b)] =

4R1,0 − R0,0
3

,

[ f (a) + 4 f (a + h2) + 2 f (a + h2) + 4 f (a + 3h2) + f (b)]

(4.20)

R1,1 =

R2,1 =

=

h1
3
h2
3
4R2,0 − R1,0
3

.

Então, a relação geral (4.16) entre as aproximações baseadas na fórmula de Simpson

e a regra trapezoidal assume a forma:

Rk,1 =

4Rk,0 − Rk−1,0
3

=

4Rk,0 − Rk−1,0
4 − 1

,

k = 1, 2, · · · .

(4.21)

88

Semelhante ao que foi feito para obter a equação (4.10), tomamos n = 4 (conhecida

como Regra de Boole - 5 pontos), temos

A0 =

h
(−1)4−00!(4 − 0)!

A1 =

h
(−1)4−11!(4 − 1)!

A2 =

h
(−1)4−22!(4 − 2)!

A2 =

h
(−1)4−33!(4 − 3)!

A2 =

h
(−1)4−44!(4 − 4)!

(cid:90) 4

0

(cid:90) 4

0

(cid:90) 4

0

(cid:90) 4

0

(cid:90) 4

0

4
∏
j(cid:54)=0

(t − j)dt =

h
24

(cid:90) 4

0

(t − 1)(t − 2)(t − 3)(t − 4)dt =

14h
45

,

4
∏
j(cid:54)=1

(t − j)dt =

−h
6

(cid:90) 4

0

t(t − 2)(t − 3)(t − 4)dt =

64h
45

,

4
∏
j(cid:54)=2

(t − j)dt =

h
4

(cid:90) 4

0

t(t − 1)(t − 3)(t − 4)dt =

8h
15

,

4
∏
j(cid:54)=3

(t − j)dt =

−h
6

(cid:90) 4

0

t(t − 1)(t − 2)(t − 4)dt =

4
∏
j(cid:54)=4

(t − j)dt =

h
24

(cid:90) 4

0

t(t − 1)(t − 2)(t − 3)dt =

64h
45

,

14h
45

,

resultando

(cid:90) b

a

f (x)dx ≈

2h
45

(7 f0 + 32 f1 + 12 f2 + 32 f3 + 7 f4).

(4.22)

Esta primeira aproximação com base na fórmula de Boole pode ser expressa da

seguinte forma (semelhamte ao processo feito na equação (4.12))

R2,2 =

2h2
45

[7 f (a) + 32 f (a + h2) + 12 f (a + 2h2) + 32 f (a + 3h2) + 7 f (b)]

(4.23)

e podemos relacionar com a equação (4.20)

R2,2 =

16R2,1 − R1,1
15

=

42R2,1 − R1,1
42 − 1

.

(4.24)

Pode-se provar [veja (PETERSDORFF, 1993)] que vale a relação de recorrência abaixo:

Rk, j

4 jRk, j−1 − Rk−1, j−1
4 j − 1

,

j = 1, 2, · · · ,

k = 1, 2, · · · ,

(4.25)

As estimativas computadas Rk, j podem ser convenientemente organizadas em uma

tabela

A coluna j contém as aproximações baseadas na fórmula de Newton-Cotes de

ordem 2 j para números sucessivamente duplicados de subintervalos (tamanhos de subintervalos

reduzidos à metade).

A avaliação da integral pode ser alcançada completando a tabela 12 recursivamente de

cima para baixo, determinando para cada linha k as aproximações com base em todas as fórmulas

89

Tabela 12 – Tabela Romberg

Trapezoidal

Simpson Boole

. . .

R0,0
R1,0
R2,0
...

R1,1
R2,1
...

R2,2

. . .

nk

1
2
22
...

Fonte: Adaptado de (BEU, 2014)

de Newton-Cotes aplicáveis na respectiva malha de 2k pontos de integração. Especiﬁcamente,

os elementos da matriz são avaliados na ordem R + 0, 0, (R1,0, R1,1), (R2,0, R2,1, R2,2), · · · .

A essência do método de Romberg consiste, portanto, em preencher recursivamente

a matriz de aproximações Rk, j da integral e pode ser lançada sob a forma:

R0,0 =

[ f (a) + f (b)],

h0 = b − a,

n0 = 1,
(cid:35)

h0
2
(cid:34)

Rk−1,0 + hk−1

f (a + (i − 1/2)kk−1)

,

Rk,0 =

1
2
4 jRk, j−1 − Rk−1, j−1
4 j − 1

Rk, j =

nk−1
∑
i=1

,

j = 1, 2, · · · , k, hk =

hk−1
2

, nk = 2nk−1.

(4.28)

(4.26)

(4.27)

O processo iterativo deve ser continuado até que a diferença relativa entre duas

aproximações diagonais consecutivas se torne menor do que uma tolerância predeﬁnida ε:

|Rk,k − Rk−1,k−1| ≤ ε|Rk,k|.

(4.29)

Código-fonte 53 – Integração de uma função usando o método de romberg

1 import math

2

3 def rombergMetodo ( func , a , b , eps = 1e -6) :

4

5

6

7

8

9

10

11

"""

Integra a fun ç ã o Func no intervalo [a , b ] com eps de precis ã o

relativa usando o m é todo adaptativo de Romberg

"""

kmax = 30

r1 = [0]*( kmax +1)

r2 = [0]*( kmax +1)

90

h = b - a

n = 1

# aproxima ç ã o inicial

r1 [0] = 0.5* h *( func ( a ) + func ( b ) )

for k in range (1 , kmax +1) :

sumf = 0 e0

for i in range (1 , n +1) :

sumf += func ( a +( i -0.5) * h )

# f ó rmula trapezoidal

r2 [0] = 0.5*( r1 [0] + h * sumf )

f = 1 e0

for j in range (1 , k +1) :

f *=4

r2 [ j ] = ( f * r2 [j -1] - r1 [j -1]) /( f -1)

# verifica ç ã o de converg ê ncia

if ( k > 1) :

if ( abs ( r2 [ k ] - r1 [k -1]) <= eps * abs ( r2 [ k ]) ) :

break

if ( abs ( r2 [ k ]) <= eps and

abs ( r2 [ k ]) <= abs ( r2 [ k ] - r1 [k -1]) ) :

break

h *= 0.5

n *=2

for j in range (0 , k +1) :

r1 [ j ] = r2 [ j ]

if ( k >= kmax ) :

print ( " rombergMetodo : n ú mero m á ximo de intera ç õ es excedido ! " )

k -=1

return r2 [ k ]

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50 def func ( x ) :

91

return x **3 * math . exp ( - x )

51

52

53 a = 0 e0

54 b = 1 e0

55 eps = 1e -10

56

57 print ( " romberg = " , rombergMetodo ( func , a , b , eps ) )

Fonte: Elaborado pelo autor.

O método de Romberg, nas equações (4.26) - (4.29) é implementado no código

abaixo. Os parâmetros das funções, integralTrapzAdaptive e integralSimpsonAdaptive,

são semelhantes as funções anteriores.

4.5

Implementação em Fortran

Os códigos seguintes mostram a implementações Fortran equivalentes das funções

Python desenvolvidas durante o texto. As rotinas correspondentes têm nomes, parâmetros e

funcionalidades idênticos.

Código-fonte 54 – Integração de uma função usando o método dos trapézios

1 function regraTrapz (a , b , n )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

! Calcula a integral da funcao func no intervalo

! [a , b ] usando o metodo dos trapezios com n pontos

implicit none

real ( kind = 8 ) :: a , b

integer :: n

real ( kind = 8 ) :: func

real ( kind = 8 ) :: regraTrapz

real ( kind = 8 ) :: h , soma ! , fa , fb , fi

integer :: i

92

h = (b - a ) /( n *1.0)

soma = ( func ( a ) + func ( b ) ) /2

do i = 1 ,n -1

soma = soma + func ( a + i * h )

end do

regraTrapz = h * soma

17

18

19

20

21

22

23

24

25 end function regraTrapz

Fonte: Elaborado pelo autor.

Código-fonte 55 – Integração de uma função usando o método dos trapézios Adaptivo

1 function i ntegra lTrap zA da p t iv e (a , b )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

! Calcula a integral da funcao func no intervalo [a , b ]

! com precisao eps usando o metodo trapezoidal adaptativo

implicit none

real ( kind = 8 ) :: a , b , eps

real ( kind = 8 ) :: i nt eg ra lT r a pz Ad a p ti ve

integer :: kmax = 30 , n , k , i

real ( kind = 8 ) :: h , t0 , sumf , t

real ( kind = 8 ) :: func

eps = 1. e -10

h = b - a

n = 1

t0 = 0.5* h *( func ( a ) + func ( b ) )

! aproximacao inicial

do k = 1 , kmax

sumf = 0. e0

do

i = 1 , n

sumf = sumf + func ( a +( i -0.5) * h )

end do

93

t = 0.5*( t0 + h * sumf )

! nova aproximacao

if ( k > 1 ) then

! checando convergencia

if ( abs (t - t0 ) <= eps * abs ( t ) ) then

exit

end if

if ( abs ( t ) <= eps . and . abs ( t ) <= abs (t - t0 ) ) then

exit

end if

end if

h = h *0.5

n = n *2

t0 = t

end do

if ( k >= kmax ) then

print * , " Maximo de interacoes excedido ! "

end if

int egralT rapzA daptiv e = t

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49 end function integ ralTra pz Ada p tiv e

Fonte: Elaborado pelo autor.

Código-fonte 56 – Integração de uma função usando o método de Simpson

1 function regraSimpson (a , b , n )

2

3

4

5

6

7

8

9

10

! Calcula a integral da funcao func no intervalo

! [a , b ] usando o metodo de Simpson com n ( par ) pontos

implicit none

real ( kind = 8 ) :: a , b

integer :: n

94

real ( kind = 8 ) :: h , s1 , s2 , func

real ( kind = 8 ) :: regraSimpson

integer :: i

if ( mod (n , 2) == 1 ) then

n = n +1

end if

h = (b - a ) / n

s1 = 0. e0

s2 = 0. e0

n = n /2

do i = 1 , n -1

! soma em indice par

s1 = s1 + func ( a +2* i * h )

end do

do i = 1 , n

! soma em indice impar

s2 = s2 + func ( a +(2* i -1) * h )

end do

regraSimpson = ( h /3) *( func ( a ) +4* s2 +2* s1 + func ( b ) )

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35 end function regraSimpson

Fonte: Elaborado pelo autor.

Código-fonte 57 – Integração de uma função usando o método de Simpson Adaptivo

1 function in t eg ra lS i mp so nA d a p t i v e (a , b )

2

3

4

5

6

7

8

9

! Calcula a integral da funcao func no intervalo [a , b ] com

! precisao eps usando o metodo de Simpson adaptativo

implicit none

real ( kind = 8 ) :: a , b , eps

real ( kind = 8 ) :: i n t eg r a l S i mp s o n Ad a p t iv e

95

integer :: kmax = 30

integer :: n , i , k

real ( kind = 8 ) :: h , s0 , t0 , sumf

real ( kind = 8 ) :: t , s

real ( kind = 8 ) :: func

eps = 1. e -6

h = b - a

n = 1

s0 = 0.5* h *( func ( a ) + func ( b ) )

t0 = s0

do k = 1 , kmax

sumf = 0. e0

do i = 1 , n

sumf = sumf + func ( a +( i -0.5) * h )

end do

t = 0.5*( t0 + h * sumf )

s = (4* t - t0 ) /3

if ( k > 1 ) then

if ( abs (s - s0 ) <= eps * abs ( s ) ) then

exit

end if

if ( abs ( s ) <= eps . and . abs ( s ) <= abs (s - s0 ) ) then

exit

end if

end if

h = h * 0.5

n = n * 2

s0 = s

t0 = t

end do

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

96

if ( k >= kmax ) then

print * , " Maximo de interacoes excedido ! "

end if

i nt eg ra l Si mp s on Ad ap t iv e = s

49

50

51

52

53

54

55 end function i nt eg r al Si mp s on A d a pt i v e

Fonte: Elaborado pelo autor.

Código-fonte 58 – Integração de uma função usando o método de romberg

1 function rombergMetodo (a , b , eps )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

! Integra a fun ç ã o Func no intervalo [a , b ] com eps

! de precis ã o usando o m é todo adaptativo de Romberg

implicit none

real ( kind = 8 ) :: a , b , eps

integer , parameter :: kmax = 30

real ( kind = 8 ) , dimension ( kmax +1) :: r1 , r2

real ( kind = 8 ) :: h

integer :: n

integer :: i , j , k

real ( kind = 8 ) :: sumf , f , rombergMetodo

real ( kind = 8 ) :: func

h = b - a

n = 1

r1 (1) = 0.5* h *( func ( a ) + func ( b ) )

do k = 2 , kmax +1

sumf = 0. e0

do i = 1 , n

sumf = sumf + func ( a +( i -0.5) * h )

end do

97

r2 (1) = 0.5 * ( r1 (1) + h * sumf )

f = 1. e0

do j = 2 , k +1

f = f * 4

r2 ( j ) = ( f * r2 (j -1) - r1 (j -1) ) /( f -1)

end do

! verifica ç ã o de converg ê ncia

if ( k > 1 ) then

if ( abs ( r2 ( k ) - r1 (k -1) ) <= eps * abs ( r2 ( k ) ) ) then

exit

end if

if ( abs ( r2 ( k ) ) <= eps . and . &

& abs ( r2 ( k ) ) <= abs ( r2 ( k ) - r1 (k -1) ) ) then

exit

end if

end if

h = h * 0.5

n = n * 2

do j = 1 , k +1

r1 ( j ) = r2 ( j )

end do

end do

if ( k >= kmax ) then

print * , " rombergMetodo : n ú mero m á ximo de intera ç õ es excedido ! "

end if

rombergMetodo = r2 ( k +1)

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61 end function rombergMetodo

62

63 function func ( x )

64

65

66

implicit none

98

real ( kind = 8 ) :: x , func

func = x * x * x * exp ( - x )

67

68

69

70 end function

71

72 program main

73

74

75

76

77

78

79

80

81

82

83

84

85

86

implicit none

real ( kind = 8 ) :: a , b , eps

real ( kind = 8 ) :: romberg

real ( kind = 8 ) :: rombergMetodo

a = 0. e0

b = 1. e0

eps = 1. e -10

romberg = rombergMetodo (a , b , eps )

print * , romberg

87 end program

Fonte: Elaborado pelo autor.

99

5 EQUAÇÕES DIFERENCIAIS ORDINÁRIAS

As primeiras equações diferenciais são tão antigas quanto o cálculo diferencial.

As equações diferenciais estão entre as ferramentas matemáticas mais importantes usadas na

produção de modelos nas ciências físicas, biologia e engenharia.

A importância particular dos métodos numéricos para resolver equações diferenciais

ordinárias (EDOs) ou seus sistemas é devido ao fato de que muitas das leis da natureza são

convenientemente expressas na forma diferencial. As equações clássicas de movimento de

partículas, as equações de difusão de massa ou transporte de calor ou a equação de onda de

Schrödinger são apenas alguns exemplos que ilustram a extraordinária diversidade de fenômenos

físicos essencialmente diferentes, que são modelados por meio de equações diferenciais.

A análise tradicional resolve os casos triviais e pode produzir uma visão inestimável

para a solução dos mais complexos. Mas o ponto principal é que esses casos devem ser tratados

numericamente.

Infelizmente, não existe um método que solucione todas as equações diferencias.

Cada equação tem uma característica própria, e um método que funciona bem em uma que pode

funcionar mal ou mesmo falhar em outra.

O que faremos é desenvolver algumas ideias gerais sobre a solução numérica de

equações diferenciais e implementar essas ideias em um código que funcione bem para uma am-

pla variedade de problemas. Os problemas que iremos considerar serão de dois tipos: problemas

com condição inicial e problemas com condições de fronteira.

5.1 Método de Euler

O método de Euler é a técnica de aproximação mais elementar para resolver proble-

mas de valor inicial. Embora raramente seja usado na prática, a simplicidade de sua derivação

pode ser usada para ilustrar as técnicas envolvidas na construção de algumas das técnicas mais

avançadas, sem a álgebra complicada que acompanha essas construções. O objetivo do método

de Euler é obter aproximações para o problema de valor inicial

dy
dt

= f (t, y)

a (cid:54) t (cid:54) b,

y(a) = y0.

(5.1)

Uma aproximação contínua para a solução y(t) não será obtida; em vez disso,

aproximações para y serão geradas em vários valores, chamados pontos de malha, no intervalo

100

[a, b]. Uma vez que a solução aproximada é obtida nos pontos, a solução aproximada em outros

pontos do intervalo pode ser encontrada por interpolação. Primeiro fazemos a estipulação de

que os pontos da malha são igualmente distribuídos ao longo do intervalo [a, b]. Esta condição é

garantida escolhendo um número inteiro positivo N e selecionando os pontos da malha

ti = a + ih,

para i = 0, 1, 2, · · · , N.

(5.2)

A distância comum entre os pontos h = (b − a)/N = ti+1 − ti é chamada de tamanho do passo.

Assumimos que a solução existe, é única, ﬁnita e expansível em uma série de Taylor

nas proximidades do ponto inicial a:

y(t) = y(a) +

t − a
1!

y(cid:48)(a) +

(t − a)2
2!

y(cid:48)(cid:48)(a) + · · · .

(5.3)

A expansão de Taylor (5.3) fornece um procedimento para avaliar a solução y(t) em

determinados pontos da malha t0,t1, · · · ,tm, · · · como uma sequência de soluções do problema

inicial. Especiﬁcamente, propagar a solução de tm para tm+1 é equivalente a resolver a equação

diferencial (5.1) sujeita à condição inicial

y(tm) = ym,

que é realizado com base na expansão

ym+1 = ym + hy(cid:48)

m +

h2
2

y(cid:48)(cid:48)
m + · · · ,

(5.4)

onde ym ≡ t(tm), y(cid:48)

m ≡ y(cid:48)(tm), y(cid:48)(cid:48) ≡ y(cid:48)(cid:48)(tm) e assim sucessivamente.

Tomando a aproximação linear da série de Taylor, obtém assim, o método de Euler

ym+1 = ym + h f (tm, ym), m = 0, 1, 2, · · · .

(5.5)

Vemos na ﬁgura 8 mostrando que a aplicação repetida do método de Euler equivale

a substituir a curva y = y(t) pela função linear por partes conectando os pontos (t0, y0), (t1, y1),

(t2, y2) , · · · . O segmento inicial representa a reta tangente à solução exata que passa pelo ponto

inicial (t0, y0). Em geral, a solução propagada ym+1 pode ser considerada como a extrapolação

em linha reta da solução particular da equação passando pelo ponto anterior (tm, ym), no entanto,

não necessariamente satisfazendo a condição inicial y(t0) = y0.

Uma maneira prática de superar a baixa precisão do método de Euler é aumentar a

ordem da aproximação aplicando uma variação do método, que opera com duas estimativas de

101

Figura 8 – Soluções aproximadas.

y

∆m+1

ym+1

y = y(t)

∆m

ym

h

tm

tm+1

t

y0

t0

h

y1

t1

Fonte: Elaborado pelo autor

solução em cada etapa de propagação. Primeiro, começando do valor ym, calculamos um valor

estimado inicial ym+1 através do método de Euler

ym+1 = ym + h f (tm, ym), m = 0, 1, 2, · · · .

Em seguida melhoramos a estimativa inicial usando a regra trapezoidal,

ym+1 = ym +

h
2

[ f (tm, ym) + f (tm+1, ym+1)].

(5.6)

(5.7)

O método de Euler e suas variantes é implementado nas funções Euler1 e Euler2,

no código abaixo.

Código-fonte 59 – Método de Euler.

1 def euler ( funcao , y0 , a , b , n ) :

2

3

4

5

6

7

8

9

10

11

12

"""

Aproxima a solucao de y '= f (y , t ) pelo metodo de Euler .

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

funcao : Lado direito da equacao diferencial y '= f (t , y ) ,

y ( t0 ) = y0

y0 : Valor inicial y ( t0 ) = y0 onde t0 e a entrada no

indice 0 no array t

a , b : Intervalo onde sera feita a aproximacao

n : Quantidade de pontos entre a e b

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

y : Aproximacao y [ n ] da solucao y ( tn ) calculada pelo

metodo de Euler .

102

"""

y = [0]* n

y [0] = y0

h = (b - a ) / n

for i in range (n -1) :

y [ i +1] = y [ i ] + funcao ( y [ i ] , a + i * h ) * h

return y

13

14

15

16

17

18

19

20

21

22

23

24

Fonte: Elaborado pelo autor.

Figura 9 – Solução da equação y(cid:48) = y, y(0) = 1 usando método de Euler.

Fonte: Elaborado pelo autor

Código-fonte 60 – Método de Euler usando a regra trapezoidal.

1 def euler2 ( fun , y0 , a , b , n ) :

2

3

4

5

6

7

8

9

"""

Mesmos parametros da funcao euler anterior

"""

y = [0]* n

y2 = [0]* n

103

10

11

12

13

14

15

16

17

18

19

20

21

y [0] = y0

y2 [0] = y0

h = (b - a ) / n

for i in range (n -1) :

ti = a + i * h

y2 [ i +1] = y [ i ] + fun ( y [ i ] , ti ) * h

y [ i +1] = y [ i ] + ( fun ( y [ i ] , ti ) + fun ( y2 [ i +1] , ti + h ) ) * h /2

return y

Fonte: Elaborado pelo autor.

Figura 10 – Solução da equação y(cid:48) = y, y(0) = 1 usando método de Euler com regra

trapezoidal.

Fonte: Elaborado pelo autor

5.2 Métodos de Runge-Kutta

Os métodos de Runge-Kutta são uma família de métodos que generalizam o método

de Euler com a regra trapezoidal. Os métodos usam várias avaliações de f entre cada etapa de

uma forma inteligente que leva a uma maior precisão.

Se a função f , deﬁnida na equação (5.1) é um número suﬁciente de vezes diferen-

ciável, a solução exata y(t) pode ser expandida em uma série de Taylor sobre o ponto t = a de

acordo com a equação (5.3). As sucessivas derivadas que ocorre na série, pode ser calculada

observando que

104

y(cid:48)(cid:48) =

y(cid:48) = f (t, y),
d
dt
d
dt

y(cid:48)(cid:48)(cid:48) =

f (t, y) = ft + fyy(cid:48) = ft + fy f ,

( ft + fy f ) = ftt + fty f + fy( ft + ty f ) + f ( fyt + fyy f ),

= ftt + 2 fty f + ft fy + f 2

y f + tyy f 2.

É claro que, em geral, a diﬁculdade de calcular as derivadas torna-se cada vez mais

difícil com a ordem crescente da derivada. Para evitar a diﬁculdade de calcular as derivadas de

ordem superior expressas em termos das derivadas parciais de f , substituiremos as derivadas

pelo número necessário de valores funcionais de f em pontos intermediários.

Na série de Taylor, dado na equação (5.1), desconsiderando as derivadas de ordem

maiores que 2, teremos

ym+1 = ym + hy(cid:48)

m +

y(cid:48)(cid:48)
m,

(5.8)

h2
2
h2
2

= ym + h f +

Pelo teorema do valor médio

( ft + f fy).

ym+1 = ym + h f (c, ym(c)).

Aqui, usamos a média ponderada de f (tm, ym) e f (tm + αh, ym + β h f (tm, ym)) como substituto

de f (tm, ym) , ou seja

ym+1 = ym + h f (c, ym(c)) = ym + h(A f (tm, ym) + B f (tm + αh, ym + β h f (tm, ym))).

Escrevendo

ﬁcamos

k1 = h f (tm, ym),

k2 = h f (tm + αh, ym + β k1),

ym+1 = ym + h f (c, ym(c)) = ym + Ak1 + Bk2.

Aplicando a fórmula de Taylor para funções de duas variáveis em k2

k2 = h( f + αh ft + β k1 fy + · · · ),

daí

ym+1 = ym + Ah f + Bh( f + αh ft + β k1 fy + · · · ),

ym+1 = ym + h(A + B) f + h2B(α ft + β f fy) + · · · ,
h2
2

ym+1 = ym + h(A + B) f +

(2αB ft + 2β B f fy) + · · · .

105

(5.9)

Comparando a equação (5.9) com a equação (5.8), tiramos que

A + B = 1,

2αB = 1,

2β B = 1.

Como temos quatro incógnitas e apenas três equações, não podemos determinar A, B, α, β

unicamente. Mas, podemos tomar uma solução particular

obtemos a solução

A = B =

1
2

, α = β = 1

ym+1 = ym +

1
2

(k1 + k2),

k1 = h f (tm, ym),

k2 = h f (tm + h, ym + k1),

ou seja, o método de Euler com regra trapezoidal.

De maneira geral, representando ym+1 como combinação linear temos

ym+1 = ym +

p
∑
i=1

wiki,

onde wi são os pesos e ki toma valores proporcionais a f (t, y) com

e

ki = h f (εi, ηi),

εi = tm + αih,

ηi = ym +

i−1
∑
j=i

βi jk j,

(5.10)

(5.11)

sendo αi, βi j e wi parâmetros que devem ser determinados de forma a maximizar a concordância

entre a combinação linear (5.11), e a série de Taylor (5.3). Colocando

α1 = 0,

β11 = 0,

ε1 = tm, η1 = ym,

(5.12)

temos então

k1 = h f (tm, ym),

k2 = h f (tm + α2h, ym + β21k1),

k3 = h f (tm + α3h, ym + β31k1 + β32k2),
...

106

(5.13)

vemos que várias quantidades são calculadas de uma maneira direta com base apenas nas

quantidades já disponíveis.

Para p = 1, obtemos a fórmula do método de Euler. Para p = 2, o método de Euler

com regra trapezoidal.

Para p = 3, temos a relação

ym+1 = ym + h(w1k1 + w2k2 + w3k3).

(5.14)

E combinando as equações (5.13) e (5.14), obtemos

,

α2w2 + α3w3 =

w1 + w2 + w3 = 1,
1
2
1
6
1
3

2 + w3α 2

w3β32α2 =

3 =

w2α 2

,

,

(5.15)

um sistema de 4 equações e 6 incógnitas. Tomamos a seguintes solução

w1 =

1
6

, w2 =

4
6

, w3 =

1
6

α2 =

1
2

, α3 = 1

β21 =

1
2

,

β31 = −1,

β32 = 2.

Com esses valores, as equações formam o método de Runge-Kutta de ordem 3

ym+1 = ym +

1
6

(k1 + 4k2 + k3),

k1 = h f (tm, ym),
h
2

k2 = h f (tm +

, ym +

k1
2

),

(5.16)

k3 = h f (tm + h, ym − k1 + 2k2).

A implementação desse método encontra-se no código 61 abaixo.

Código-fonte 61 – Método de Runge-Kutta de terceira ordem.

1 def rungeKutta3 ( funcao , y0 , a , b , n ) :

107

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

"""

Semelhante as fun ç õ es euler anteriores

"""

y = [0]* n

y [0] = y0

h = (b - a ) / n

for i in range (n -1) :

ti = a + i * h

k1 = h * funcao ( ti , y [ i ])

k2 = h * funcao ( ti + h /2 , y [ i ]+ k1 /2)

k3 = h * funcao ( ti +h , y [ i ] - k1 +2* k2 )

y [ i +1] = y [ i ] + ( k1 +4* k2 + k3 ) /6

return y

Fonte: Elaborado pelo autor.

A variante mais importante e amplamente usada é o método Runge-Kutta de quarta

ordem (p = 4) Seguindo o mesmo raciocínio para a determinação dos coeﬁcientes αi, βi j e wi

como no caso p = 2, resulta um sistema não linear de 10 equações com 13 incógnitas que não

possuem uma solução única. Vários conjuntos de coeﬁcientes estão em uso, sendo preferidos

aqueles que apresentam simplicidade ou favorecem o uso de armazenamento eﬁciente. A variante

comumente empregada do método Runge-Kutta de quarta ordem é deﬁnida pelas relações abaixo,

e cuja implementação encontra-se no código 62.

ym+1 = ym +

1
6

(k1 + 2k2 + 2k3 + k4),

k1 = h f (tm, ym),
h
2

k2 = h f (tm +

k3 = h f (tm + h

, ym

h
2

k1
2
k2
2

),

, ym +

),

(5.17)

k4 = h f (tm + h, ym + k3).

108

Código-fonte 62 – Método de Runge-Kutta de terceira ordem.

1 def rungeKutta4 ( funcao , y0 , a , b , n ) :

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

"""

Par â metros semelhantes aos anteriores

"""

y = [0]* n

y [0] = y0

h = (b - a ) / n

for i in range (n -1) :

ti = a + i * h

k1 = h * funcao ( ti , y [ i ])

k2 = h * funcao ( ti + h /2 , y [ i ]+ k1 /2)

k3 = h * funcao ( ti + h /2 , y [ i ]+ k2 /2)

k4 = h * funcao ( ti +h , y [ i ]+ k3 )

y [ i +1] = y [ i ] + ( k1 +2* k2 +2* k3 + k4 ) /6

return y

Fonte: Elaborado pelo autor.

Como exemplo, consideremos o problema de valor inicial

cuja solução é




y(cid:48) = y − t2 + 1,

0 ≤ t ≤ 1,



y(0) = 0.5,

y(t) = (1 + t)2 −

et .

1
2

Obteremos uma aproximação de y(1), aplicando os métodos de Euler, Euler com regra Tra-

pezoidal e Runge-Kutta, com passo h = 0.1 e compararemos os respectivos erros na ﬁgura

11.

Figura 11 – Comparação dos métodos de Euler, Euler com regra trapezoidal e

Runge-Kutta na solução da equação y(cid:48) = y − t2 + 1, y(0) = 0.5.

109

Fonte: Elaborado pelo autor

Código-fonte 63 – Método de Runge-Kutta de terceira ordem.

1 import numpy as np

2 import matplotlib . pyplot as plt

3

4 # def euler (...)

5

6 # def eulerTrap (...) :

7

8 # def rungeKutta4 (...) :

9

10 # valor inicial

11 y0 = 0.5

12 def fun (t , y ) :

# y ' = f (y , t ) = y - t ^2+1

return y - t **2+1

13

14

15

16 def solucao ( t ) :

return 1+2* t + t **2 - np . exp ( t ) /2

17

18

19 a = 0

20 b = 1

21

22 # h = (b - a ) / n = 1/10 = 0.1

23 n = 10

24

110

25 yEuler = euler ( fun , y0 , a , b , n )

26 yEulerTrap = eulerTrap ( fun , y0 , a , b , n )

27 yRunge4 = rungeKutta4 ( fun , y0 , a , b , n )

28

29 t = [ a + i *( b - a ) / n for i in range ( n ) ]

30 yExato = [ solucao ( i ) for i in t ]

31

32 plt . plot (t , yEuler , 'b . - ')

33 plt . plot (t , yEulerTrap , 'k -. ')

34 plt . plot (t , yRunge4 , 'c : ')

35 plt . plot (t , yExato , 'r - - ')

36

37 plt . legend ([ ' Euler ' , ' Euler Trap ' , ' Runge - Kutta ' , ' Exato ' ])

38

39 plt . grid ( True )

40 plt . show ()

41

42 print ( " {: >3} {: >6} {: >6} {: >6} " . format ( " i " ," euler " ," exato " ," erro " ) )

43 for i in range ( n ) :

erro = abs ( yEuler [ i ] - yCorreto [ i ])

print ( " {} {:.5 f } {:.5 f } {:.5 e } " . format ( t [ i ] , yEuler [ i ] , yCorreto [ i ] ,

erro ) )

44

45

46

47 print ( " \ n {: >3} {: >6} {: >6} {: >6} " . format ( " i " ," euler trap " ," exato " ,"

erro " ) )

48 for i in range ( n ) :

erro = abs ( yEulerTrap [ i ] - yCorreto [ i ])

print ( " {} {:.5 f } {:.5 f } {:.5 e } " . format ( t [ i ] , yEulerTrap [ i ] , yCorreto [

i ] , erro ) )

49

50

51

52 print ( " \ n {: >3} {: >6} {: >6} {: >6} " . format ( " i " ," runge - kutta " ," exato " ,"

erro " ) )

53 for i in range ( n ) :

erro = abs ( yRunge4 [ i ] - yCorreto [ i ])

print ( " {} {:.5 f } {:.5 f } {:.5 e } " . format ( t [ i ] , yRunge4 [ i ] , yCorreto [ i ] ,

erro ) )

54

55

56

57 # saida

58 i

euler

exato

erro

111

59 0.0

60 0.1

61 0.2

62 0.3

63 0.4

64 0.5

65 0.6

66 0.7

67 0.8

68 0.9

69

70 i

71 0.0

72 0.1

73 0.2

74 0.3

75 0.4

76 0.5

77 0.6

78 0.7

79 0.8

80 0.9

81

82 i

83 0.0

84 0.1

85 0.2

86 0.3

87 0.4

88 0.5

89 0.6

90 0.7

91 0.8

92 0.9

0.50000

0.50000

0.00000 e +00

0.57500

0.65741

8.24145 e -02

0.65194

0.82930

1.77361 e -01

0.72944

1.01507

2.85635 e -01

0.80623

1.21409

4.07860 e -01

0.88123

1.42564

5.44412 e -01

0.95357

1.64894

6.95369 e -01

1.02264

1.88312

8.60482 e -01

1.08806

2.12723

1.03917 e +00

1.14967

2.38020

1.23052 e +00

euler trap

exato

erro

0.50000

0.50000

0.00000 e +00

0.65700

0.65741

4.14541 e -04

0.82844

0.82930

8.63621 e -04

1.01372

1.01507

1.34992 e -03

1.21221

1.21409

1.87631 e -03

1.42319

1.42564

2.44583 e -03

1.64588

1.64894

3.06174 e -03

1.87940

1.88312

3.72751 e -03

2.12278

2.12723

4.44680 e -03

2.37497

2.38020

5.22352 e -03

runge - kutta

exato

erro

0.50000

0.50000

0.00000 e +00

0.65741

0.65741

1.65962 e -07

0.82930

0.82930

3.44923 e -07

1.01507

1.01507

5.37779 e -07

1.21409

1.21409

7.45476 e -07

1.42564

1.42564

9.69002 e -07

1.64894

1.64894

1.20939 e -06

1.88312

1.88312

1.46771 e -06

2.12723

2.12723

1.74508 e -06

2.38020

2.38020

2.04264 e -06

Fonte: Elaborado pelo autor.

112

5.3 Sistema de equações diferenciais

Até agora, nos concentramos em como resolver uma única equação diferencial de

primeira ordem. Na prática, duas ou mais dessas equações, acopladas, são necessárias para

modelar um problema, e talvez até equações de ordem superior. Nesta seção, veremos como os

métodos que desenvolvemos acima podem ser facilmente adaptados para lidar com sistemas de

equações e equações de ordem superior.

Muitos problemas práticos envolvem não uma, mas duas ou mais equações dife-

renciais. Por exemplo, muitos processos evoluem no espaço tridimensional, com equações

diferenciais separadas em cada dimensão espacial.

Considerando, por exemplo as três equações com condições iniciais

x(cid:48) = xy + cos z,

x(0) = x0,

y(cid:48) = 2 − t2 + z2y,

y(0) = y0,

z(cid:48) = sint − x + y,

z(0) = z0 .

(5.18)

(5.19)

(5.20)

Se nós introduzirmos os vetores (cid:126)x = (x, y, z), (cid:126)x0 = (x0, y0, z0) e os vetores de funções (cid:126)f (t, (cid:126)x) =
( f1(t, (cid:126)x, f2(t, (cid:126)x), f3(t, (cid:126)x))) deﬁnido por

x(cid:48) = f1(t, (cid:126)x) = f1(t, x, y, z) = xy + cos z,

y(cid:48) = f2(t, (cid:126)x) = f2(t, x, y, z) = 2 − t2 + z2y,

z(cid:48) = f3(t, (cid:126)x) = f3(t, x, y, z) = sint − x + y,

podemos escrever as equações (5.18-5.20) simplesmente como

(cid:126)x = (cid:126)f (t, (cid:126)x), (cid:126)x(0) = (cid:126)x0.

Assim, o método de Euler, o método de Euler com regra trapezoidal e os métodos de

Runge-Kutta generalizam naturalmente para sistemas de equações diferenciais.

Com isso, as fórmulas anteriores se escrevem:

Método de Euler

Método de Euler com regra trapezoidal

(cid:126)xm+1 = (cid:126)xm + h f (tm, (cid:126)xm).

(cid:126)xm+1 = (cid:126)xm +

1
2

((cid:126)k1 +(cid:126)k2),

(cid:126)k1 = h f (tm, (cid:126)xm),
(cid:126)k2 = h f (tm + h, (cid:126)xm +(cid:126)k1).

(5.21)

(5.22)

113

(5.23)

Método de Runge-Kutta de terceira ordem

(cid:126)xm+1 = (cid:126)xm +

1
6

((cid:126)k1 + 4(cid:126)k2 +(cid:126)k3),

(cid:126)k1 = h f (tm, (cid:126)xm),

(cid:126)k2 = h f (tm +

h
2
(cid:126)k3 = h f (tm + h, (cid:126)xm −(cid:126)k1 + 2(cid:126)k2).

, (cid:126)xm +

),

k(cid:126)k1
2

Método de Runge-Kutta de quarta ordem

(cid:126)xm+1 = (cid:126)xm +

1
6

((cid:126)k1 + 2(cid:126)k2 + 2(cid:126)k3 +(cid:126)k4),

(cid:126)k1 = h f (tm, (cid:126)xm),

(cid:126)k2 = h f (tm +

h
2

(cid:126)k3 = h f (tm + h

),

(5.24)

(cid:126)k1
, (cid:126)xm +
2
(cid:126)k2
2

, (cid:126)xm

h
2

),

(cid:126)k4 = h f (tm + h, (cid:126)xm +(cid:126)k3).

Código-fonte 64 – Método de Runge-Kutta para um sistema de k equações.

1 def sumVec ( vl , n ) :

"""

vl : lista de vetores de tamanho n

retorna a soma dessa lista de vetores

"""

v = [0]* n

for l in vl :

for i in range ( n ) :

v [ i ] += l [ i ]

return v

2

3

4

5

6

7

8

9

10

11

12

13 def multVecEsc ( escalar , vetor ) :

14

15

16

17

18

19

"""

Multiplica um escalar por um vetor

"""

n = len ( vetor )

resultado = [0]* n

for i in range ( n ) :

resultado [ i ] = escalar * vetor [ i ]

return resultado

20

21

22

23

24 def rungeKuttaVec ( funcao , y0 , a , b , n , k ) :

114

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

"""

k : sistema de k equa ç õ es diferenciais

"""

y = [[0]* k ]* n

y [0] = y0

h = (b - a ) / n

for i in range (n -1) :

ti = a + i * h

vk1 = multVecEsc (h , funcao ( ti , y [ i ]) )

vk2 = multVecEsc (h , funcao ( ti + h /2 , sumVec ([ y [ i ] , multVecEsc

(1/2 , vk1 ) ] , k ) ) )

vk3 = multVecEsc (h , funcao ( ti + h /2 , sumVec ([ y [ i ] , multVecEsc

(1/2 , vk2 ) ] , k ) ) )

vk4 = multVecEsc (h , funcao ( ti +h , sumVec ([ y [ i ] , vk3 ] , k ) ) )

y [ i +1] = sumVec ([ y [ i ] , multVecEsc (1/6 , sumVec ([ vk1 ,

multVecEsc (2 , vk2 ) , multVecEsc (2 , vk3 ) , vk4 ] , k ) ) ] , k )

return y

Fonte: Elaborado pelo autor.

Usando a blilioteca numpy, a implementação é quase direta, como podemos ver no

código 65 abaixo.

115

Código-fonte 65 – Método de Runge-Kutta para um sistema de k equações usando a

biblioteca numpy.

1 import numpy as np

2

3 def rungeKuttaVec ( funcao , y0 , a , b , n , k ) :

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

y = np . zeros (( n , k ) )

y [0] = y0

h = (b - a ) / n

for i in range (n -1) :

ti = a + i * h

k1 = h * funcao ( ti , y [ i ])

k2 = h * funcao ( ti + h /2 , y [ i ]+ k1 /2)

k3 = h * funcao ( ti + h /2 , y [ i ]+ k2 /2)

k4 = h * funcao ( ti +h , y [ i ]+ k3 )

y [ i +1] = y [ i ] + ( k1 +2* k2 +2* k3 + k4 ) /6

return y

Fonte: Elaborado pelo autor.

5.4

Implementação em Fortran

Os códigos seguintes mostram a implementações FORTRAN equivalentes das fun-

ções Python desenvolvidas durante esse capítulo. As rotinas correspondentes têm nomes,

parâmetros e funcionalidades idênticos.

Código-fonte 66 – Método de Euler.

1 subroutine euler ( funcao , y0 , a , b , n , y )

2

3

! Aproxima a solucao de y '= f (t , y ) pelo metodo de Euler .

116

!

! Parametros

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

! funcao : funcao

!

!

Lado direito da equacao diferencial y '= f (t , y ) ,

y ( t0 ) = y0

! y0 : numero

!

!

Valor inicial y ( t0 ) = y0 onde t0 e a entrada no

indice 0 no array t

! a , b : numeros

!

Intervalo onde sera feita a aproximacao

! n : numero inteiro

Quantidade de pontos entre a e b

!

!

! Retorno

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

! y : array

!

!

Aproximacao y [ n ] da solucao y ( tn ) calculada pelo

metodo de Euler .

implicit none

real ( kind = 8 ) :: funcao

real ( kind = 8 ) :: y0 , a , b , h , ti

integer :: n , i

real ( kind = 8 ) , dimension ( n ) :: y

y (1) = y0

h = (b - a ) / n

do i = 1 , n -1

ti = a +( i -1) * h

y ( i +1) = y ( i ) + funcao ( ti , y ( i ) ) * h

end do

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39 end subroutine euler

Fonte: Elaborado pelo autor.

Código-fonte 67 – Método de Euler usando a regra trapezoidal.

1 subroutine euler2 ( funcao , y0 , a , b , n , y )

117

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

! Aproxima a solucao de y '= f (t , y ) pelo metodo de Euler

! com trapezoidal .

implicit none

real ( kind = 8 ) :: funcao

real ( kind = 8 ) :: y0 , a , b , h , ti

integer :: n , i

real ( kind = 8 ) , dimension ( n ) :: y , y2

y (1) = y0

y2 (1) = y0

h = (b - a ) / n

do i = 1 , n -1

ti = a +( i -1) * h

y2 ( i +1) = y ( i ) + funcao ( ti , y ( i ) ) * h

y ( i +1) = y ( i ) + ( funcao ( ti , y ( i ) ) + funcao ( ti +h , y2 ( i +1) ) ) * h /2

end do

24 end subroutine euler2

Fonte: Elaborado pelo autor.

Código-fonte 68 – Método de Runge-Kutta de terceira ordem.

1 subroutine rungeKutta3 ( funcao , y0 , a , b , n , y )

2

3

4

5

6

7

8

! Aproxima a solu ç ã o de y '= f (y , t ) pelo m é todo de Runge - Kutta

! de terceira ordem .

implicit none

real ( kind = 8 ) :: funcao

118

real ( kind = 8 ) :: y0 , a , b , h , ti

integer :: n , i

real ( kind = 8 ) , dimension ( n ) :: y

real ( kind = 8 ) :: k1 , k2 , k3

y (1) = y0

h = (b - a ) / n

do i = 1 , n -1

ti = a +( i -1) * h

k1 = h * funcao ( ti , y ( i ) )

k2 = h * funcao ( ti + h /2 , y ( i ) + k1 /2)

k3 = h * funcao ( ti +h , y ( i ) - k1 +2* k2 )

y ( i +1) = y ( i ) + ( k1 +4* k2 + k3 ) /6

end do

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28 end subroutine rungeKutta3

Fonte: Elaborado pelo autor.

Código-fonte 69 – Método de Runge-Kutta de quarta ordem.

1 subroutine rungeKutta4 ( funcao , y0 , a , b , n , y )

2

3

4

5

6

7

8

9

10

11

12

13

14

! Aproxima a solu ç ã o de y '= f (y , t ) pelo m é todo de Runge - Kutta

! de quarta ordem .

implicit none

real ( kind = 8 ) :: funcao

real ( kind = 8 ) :: y0 , a , b , h , ti

integer :: n , i

real ( kind = 8 ) , dimension ( n ) :: y

real ( kind = 8 ) :: k1 , k2 , k3 , k4

y (1) = y0

119

15

16

17

18

19

20

21

22

23

24

25

26

27

28

h = (b - a ) / n

do i = 1 , n -1

ti = a +( i -1) * h

k1 = h * funcao ( ti , y ( i ) )

k2 = h * funcao ( ti + h /2 , y ( i ) + k1 /2)

k3 = h * funcao ( ti + h /2 , y ( i ) + k2 /2)

k4 = h * funcao ( ti +h , y ( i ) + k3 )

y ( i +1) = y ( i ) + ( k1 +2* k2 +2* k3 + k4 ) /6

end do

29 end subroutine rungeKutta4

Fonte: Elaborado pelo autor.

Código-fonte 70 – Comparação dos métodos de Euler, Euler com trapezoidal e

Runge-Kutta na solução da equação y(cid:48) = y − t2 + 1, y(0) = 0.5.

1 ! subroutine euler (...)

2 ! subroutine eulerTrap (...)

3 ! subroutine rungeKutta4 (...)

4

5 function fun (t , y )

6

7

8

9

10

11

12

implicit none

real ( kind = 8 ) :: t , y , fun

fun = y - t * t +1

13 end function fun

14

15 function solucao ( t )

16

17

18

implicit none

120

real ( kind = 8 ) :: t , exp , solucao

solucao = 1+2* t + t *t - exp ( t ) /2

19

20

21

22

23 end function solucao

24

25 program main

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

implicit none

real ( kind = 8 ) :: a , b , y0 , fun , solucao

integer , parameter :: n = 10

real ( kind = 8 ) , dimension ( n ) :: yEuler , yEulerTrap , yRunge4 ,

yCorreto

integer :: i

real ( kind = 8 ) :: h , ti , er

external fun , solucao

a = 0. e0

b = 1. e0

y0 = 0.5 e0

h = (b - a ) / n

call euler ( fun , y0 , a , b , n , yEuler )

call eulerTrap ( fun , y0 , a , b , n , yEulerTrap )

call rungeKutta4 ( fun , y0 , a , b , n , yRunge4 )

do i = 1 , n

ti = a +( i -1) * h

yCorreto ( i ) = solucao ( ti )

end do

print 100

100 format (3 x , " i " , 5x , " euler " , 5x , " exato " , 5x , " erro " )

do i = 1 , n

er = abs ( yEuler ( i ) - yCorreto ( i ) )

print 200 , " ! " , i , yEuler ( i ) , yCorreto ( i ) , er

200 format (1 x , a1 , 2x , i3 , 5x , f7 .5 , 5x , f7 .5 , 5x , e10 .5)

121

end do

print 110

110 format (3 x , " i " , 5x , " euler trap " , 5x , " exato " , 5x , " erro " )

do i = 1 , n

er = abs ( yEulerTrap ( i ) - yCorreto ( i ) )

print 210 , " ! " , i , yEulerTrap ( i ) , yCorreto ( i ) , er

210 format (1 x , a1 , 2x , i3 , 5x , f7 .5 , 5x , f7 .5 , 5x , e10 .5)

end do

print 120

120 format (3 x , " i " , 5x , " runge - kutta " , 5x , " exato " , 5x , " erro " )

do i = 1 , n

er = abs ( yRunge4 ( i ) - yCorreto ( i ) )

print 220 , " ! " , i , yRunge4 ( i ) , yCorreto ( i ) , er

220 format (1 x , a1 , 2x , i3 , 5x , f7 .5 , 5x , f7 .5 , 5x , e10 .5)

end do

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75 end program main

76

77 ! saida

78 ! i

euler

exato

erro

79 !

80 !

81 !

82 !

83 !

84 !

85 !

86 !

87 !

88 !

1

2

3

4

5

6

7

8

9

0.50000

0.50000

.00000 E +00

0.65000

0.65741

.74145 E -02

0.81400

0.82930

.15299 E -01

0.99140

1.01507

.23671 E -01

1.18154

1.21409

.32548 E -01

1.38369

1.42564

.41945 E -01

1.59706

1.64894

.51877 E -01

1.82077

1.88312

.62354 E -01

2.05385

2.12723

.73383 E -01

10

2.29523

2.38020

.84967 E -01

89 ! i

euler trap

exato

erro

90 !

91 !

92 !

93 !

94 !

95 !

1

2

3

4

5

6

0.50000

0.50000

.00000 E +00

0.65700

0.65741

.41454 E -03

0.82844

0.82930

.86362 E -03

1.01372

1.01507

.13499 E -02

1.21221

1.21409

.18763 E -02

1.42319

1.42564

.24458 E -02

122

96 !

97 !

98 !

99 !

7

8

9

1.64588

1.64894

.30617 E -02

1.87940

1.88312

.37275 E -02

2.12278

2.12723

.44468 E -02

10

2.37497

2.38020

.52235 E -02

100 ! i

runge - kutta

exato

erro

101 !

102 !

103 !

104 !

105 !

106 !

107 !

108 !

109 !

110 !

1

2

3

4

5

6

7

8

9

0.50000

0.50000

.00000 E +00

0.65741

0.65741

.16596 E -06

0.82930

0.82930

.34492 E -06

1.01507

1.01507

.53778 E -06

1.21409

1.21409

.74548 E -06

1.42564

1.42564

.96900 E -06

1.64894

1.64894

.12094 E -05

1.88312

1.88312

.14677 E -05

2.12723

2.12723

.17451 E -05

10

2.38020

2.38020

.20426 E -05

Fonte: Elaborado pelo autor.

Código-fonte 71 – Método de Runge-Kutta para um sistema de k equações.

1 subroutine rungeKuttaMetodo ( y0 , a , b , n , k , s )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

! y0 : valor inicial

! y ' = f (t , y ) , a <= t <= b

! n : pontos entre a e b

! k : equa ç õ es

! s : solu ç ã o

implicit none

integer :: n , k

real ( kind = 8 ) , dimension (n , k ) :: s

real ( kind = 8 ) , dimension ( k ) :: y0

real ( kind = 8 ) :: a , b , h

real ( kind = 8 ) :: ti

real ( kind = 8 ) , dimension ( k ) :: k1 , k2 , k3 , k4

integer :: i

h = (b - a ) / n

s (1 ,:) = y0 (:)

123

20

21

22

23

24

25

26

27

28

29

30

31

do i = 1 , n -1

ti = a +( i -1) * h

call func ( ti , s (i ,:) , k , k1 )

call func ( ti + h /2. e0 , s (i ,:) + k1 * h /2. e0 , k , k2 )

call func ( ti + h /2. e0 , s (i ,:) + k2 * h /2. e0 , k , k3 )

call func ( ti +h , s (i ,:) + k3 *h , k , k4 )

s ( i +1 ,:) = s (i ,:) + ( k1 +2. e0 * k2 +2. e0 * k3 + k4 ) * h /6. e0

end do

32 end subroutine rungeKuttaMetodo

33

34 subroutine func (t , x , k , outv )

! k equa ç õ es

! y ' = f (t , y )

implicit none

integer :: k

real ( kind = 8 ) , dimension ( k ) :: x , outv

real ( kind = 8 ) :: t

outv (1) = x (2)

outv (2) = -x (1)

35

36

37

38

39

40

41

42

43

44

45

46 end subroutine func

47

48 program main

49

50

51

52

53

54

55

56

57

58

implicit none

integer , parameter :: n = 100 , k = 2

real ( kind = 8 ) :: a , b

real ( kind = 8 ) , dimension (n , k ) :: solucao

real ( kind = 8 ) , dimension ( k ) :: y0

integer :: i , j

a = 0. e0

124

b = 10. e0

y0 = (/1. e0 , 1. e0 /)

call rungeKuttaMetodo ( y0 , a , b , n , k , solucao )

do i = 1 , n

do j = 1 , k

write (* , " ( i3 , i3 ) " , advance = " no " ) i , j

write (* , " ( es15 .7) " , advance = " no " ) solucao (i , j )

end do

print * , " "

end do

59

60

61

62

63

64

65

66

67

68

69

70

71

72 end program main

Fonte: Elaborado pelo autor.

125

6 PROPOSTA DE ATIVIDADE NO ENSINO MÉDIO

A ideia de uma simulação é programar as leis da física no computador e, em seguida,

deixar o computador calcular o que acontece em função do tempo, passo a passo, no futuro.

Essas leis geralmente serão as leis do movimento de Newton, e nosso objetivo será prever o

movimento de um ou mais objetos sujeitos a várias forças. As simulações nos permitem fazer

isso para quaisquer forças e quaisquer condições iniciais, mesmo quando não existe uma fórmula

explícita para o movimento.

6.1 Movimento de projétil

Vamos simular o movimento de um projétil, primeiro em uma dimensão e depois em

duas dimensões. Quando o movimento é puramente vertical, o estado do projétil é deﬁnido por

sua posição, y, e sua velocidade, vy. Essas quantidades são relacionadas por

vy =

dy
dt

≈

∆y
∆t

=

yﬁnal − yinicial
∆t

.

(6.1)

Em uma simulação de computador, já sabemos o valor atual de y e queremos prever

o valor futuro. Então, vamos resolver esta equação para yﬁnal

yﬁnal ≈ yinicial + vy∆t.

(6.2)

Da mesma forma, podemos prever o valor futuro de vy se conhecermos o valor atual,

bem como a aceleração:

ay =

≈

=

vy
dt

∆vy
∆t

vyﬁnal − vyinicial
∆t
vyﬁnal ≈ vyinicial + ay∆t.

,

(6.3)

(6.4)

Essas equações são válidas para qualquer objeto em movimento. Para um projétil se

movendo perto da superfície da terra sem resistência do ar, ay = −g (tomando a direção +y para

cima). Em geral, ay é dado pela segunda lei de Newton

ay =

∑ Fy
m

,

(6.5)

onde m é a massa do objeto e as várias forças podem depender de y, vy ou ambos.

Em uma simulação de computador de movimento unidimensional, a ideia é começar

com o estado da partícula em t = 0, então usar as equações (6.2) a (6.5) para calcular y e vy em

126

t = ∆t, depois repetir o cálculo para o próximo intervalo de tempo e o próximo, e assim por

diante. Felizmente, os computadores não se importam em fazer cálculos repetitivos.

Como regra geral, os computadores não podem lidar com o movimento contínuo.

Portanto, para fazer qualquer simulação de movimento físico real parecer realista, teremos que

“dividir” o movimento contínuo verdadeiro em muitos quadros separados por intervalos de tempo

muito pequenos. A situação não é diferente de assistir a um ﬁlme em que percebemos um

movimento contínuo quando, na realidade, estamos sendo expostos a uma sequência rápida de

imagens estáticas.

Com isso, podemos usar o seguinte código para simular o movimento do projétil em

uma dimensão sem resistência do ar:

Código-fonte 72 – Simular movimento de projétil em uma dimensão.

1 import matplotlib . pyplot as plt

2

3 g = 9.8 # m / s2 . ACelera ç ã o da gravidade .

4 y = 10 # m . Posi ç ã o inicial .

5 dt = 0.05

6 vy = 0 # m / s . Partindo do repouso

7 t = 0 # s . Tempo inicial

8

9 ay = -g

10 tempo = []

11 posicao =[]

12 velocidade =[]

13 while y > 0:

# guardar as posi ç õ es e velocidades

# e tempo para plotagem dos

# graficos

tempo . append ( t )

posicao . append ( y )

velocidade . append ( vy )

y += vy * dt

# usando vy antigo para calcular o novo y

vy += ay * dt

# usando ay para calular novo vy

t += dt

14

15

16

17

18

19

20

21 print ( " Posi ç ã o " )

22 for p in posicao :

print ( p )

23

24

25 print ( " Velocidade " )

127

26 for vi in velocidade :

print ( vi )

27

28

29 plt . subplot (1 ,2 ,1)

30 plt . plot ( tempo , posicao )

31 plt . xlabel ( " Tempo ( s ) " )

32 plt . ylabel ( " Altura ( m ) " )

33 plt . grid ( True )

34

35 plt . subplot (1 ,2 ,2)

36 plt . plot ( tempo , velocidade )

37 plt . xlabel ( " Tempo ( s ) " )

38 plt . ylabel ( " Velocidade ( m / s ) " )

39 plt . grid ( True )

40

41 plt . show ()

Fonte: Elaborado pelo autor.

A ﬁgura (12) mostra o gráﬁco do movimento. O primeiro tempo x posição e o

segundo, tempo x velocidade.

Figura 12 – Movimento em uma dimensão.

Fonte: Elaborado pelo autor

Não há muito sentido em escrever uma simulação de computador quando você pode

calcular a resposta exata com tanta facilidade. Então, vamos tornar o problema mais difícil

adicionando alguma resistência ao ar. Em velocidades normais, a força da resistência do ar é

aproximadamente proporcional a velocidade do projétil. Isso ocorre porque um projétil mais

128

rápido não apenas colide com mais moléculas de ar por unidade de tempo, mas também confere

mais impulso a cada molécula que atinge. Então, podemos escrever a magnitude de a força de

resistência como

F = cv,

(6.6)

para alguma constante c que depende do tamanho e forma do objeto e densidade do ar. A direção

da força dessa força é sempre oposto a direção de v. Nesse caso, a Lei de Newton, na equação

(6.5), pode ser expresso como:

∆vy
∆t

= −g +

c
m

vy.

(6.7)

Código-fonte 73 – Movimento de projétil em uma dimensão com resistência.

1 # (...) Dados iguais ao anterior

2

3 c = 2

4 m = 1

5 res = c / m

6

7 # (...)

8 while y > 0:

9

10

11

# (...)

vy += ( ay + res * vy ) * dt

# res ( resistencia )

t += dt

Fonte: Elaborado pelo autor.

Simular o movimento do projétil é apenas um pouco mais difícil em duas dimensões

do que em uma. Para fazer isso, precisaremos de uma variável x para cada variável y, e cerca de

duas vezes mais linhas de código para inicializar essas variáveis e atualizá-las dentro do loop de

simulação.

Considere agora um objeto esférico lançado com uma velocidade v formando um

ângulo θ com o solo horizontal. Na ausência de resistência do ar, a trajetória seguida por esse

projétil é conhecida como uma parábola. Isso decorre de escrever a lei de Newton separadamente

Figura 13 – Movimento de projétil em uma dimensão com resistência.

129

Fonte: Elaborado pelo autor.

para as coordenadas horizontal e vertical. O primeiro, linearmente com o tempo, enquanto

o último varia quadraticamente. Portanto, quando o tempo é eliminado, ﬁcamos com uma

equação quadrática que dá origem a uma trajetória parabólica. Vamos ver como a trajetória

muda quando a resistência do ar não é mais negligenciada. No caso de uma força resistiva que

cresce linearmente com a velocidade, podemos ainda separar o movimento entre as coordenadas

horizontal e vertical.

Figura 14 – Diagrama de corpo livre para um projétil.

y

(cid:126)v

FX

(cid:126)F

FY

x

Fonte: Elaborado pelo autor

Pelo diagrama de corpo livre, na imagem (14) a lei de Newton para as coordenadas

horizontais e verticais torna-se

∆vx
∆t
∆vy
∆t

= −

c
m

vx ,

= −g +

c
m

vy.

Imaginemos agora que estamos em uma situação em que a resistência do ar depende

130

quadraticamente da velocidade. Agora as equações que descrevem a evolução temporal das

componentes da velocidade não estão mais desacopladas. Em outras palavras, a equação para a

componente horizontal vx depende da componente vertical vy e vice versa.

A direção de (cid:126)F é oposta a direção de (cid:126)v, então podemos escrever a equação (6.6) em

forma vetorial (cid:126)F = −cv(cid:126)v e as componentes de (cid:126)F são

Fx = −cvvx

e Fy = −cvvy,

onde v =

(cid:113)

x + v2
v2
y.
Os componentes de aceleração ax e ay estão mudando constantemente conforme

os componentes de velocidade mudam. Mas, após um intervalo de tempo ∆t suﬁcientemente

curto, podemos considerar a aceleração como essencialmente constante. Se conhecermos as

coordenadas e as componentes da velocidade em algum horário, podemos encontrar essas

quantidades no tempo t + ∆t usando as fórmulas para aceleração constante. Durante um intervalo

de tempo ∆t, a aceleração média da componente x é ax =

∆vx
∆t

e a velocidade vx muda ∆vx = ax∆t.

Similarmente, vy muda por uma quantidade ∆vy = ay∆t. Logo as componentes horizontal e

vertical da velocidade no ﬁm do intervalo é

vx + ∆vx = vx + ax∆t

e

vy + ∆vy = vy + ay∆t.

(6.8)

Enquanto isto está acontecendo, o projétil está se movendo, ou seja, as coordenadas estão

mudando. A velocidade média na direção x durante o intervalo de tempo ∆t é a média de vx (no

início do intervalo) e vx + ∆vx (no ﬁm do intervalo), ou vx +

∆vx
2

. A coordenada x muda de

(cid:18)

∆x =

vx +

(cid:19)

∆vx
2

∆t = vx∆t +

1
2

ax(∆t)2,

e de igual modo para y.

Se tivermos um projétil lançado em um ângulo θ em relação ao solo, a componente

horizontal da velocidade é

e a componente vertical da velocidade

vx = v cos θ ,

vy = vsenθ .

A ﬁgura (15) mostra a trajetória de um projétil com e sem resistência do ar. Escolhe-

mos o valor c = 0.0012 para a constante. Velocidade inicial de 50m/s e um ângulo de 35◦ em

relação ao eixo x. Podemos ver que tanto o alcance da bola de beisebol quanto a altura máxima

alcançada são substancialmente menores do que o cálculo sem resistência. Calcular a trajetória

de um projétil e ignorar a resistência do ar é bastante irreal. A resistência do ar é uma parte

importante de lançamento.

131

Código-fonte 74 – Trajetória de um projétil com e sem resistência.

1 import math

2 import matplotlib . pyplot as plt

3

4 def trajetoriaProjetil (x , y , v , theta , t , m , c ,

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

tempo , posicao , velocidade ) :

"""

x , y

v

: posi ç ã o inicial

: velocidade inicial

theta

: â ngulo inicial

t

m

c

: tempo inicial

: massa do proj é til

: constante de resist ê ncia

tempo

: lista

para guardar os tempo para plotagem

posicao

: posi ç ã o sucessivas do proj é til

: posi ç ã o [0] -> componente horizontal

: posi ç ã o [1] -> componente vertical

velocidade

: lista com velocidades sucessivas do proj é til

: velocidade [0] -> componente horizontal

: velocidade [1] -> componente vertical

"""

vx = v * math . cos ( theta * math . pi /180)

vy = v * math . sin ( theta * math . pi /180)

res = c / m

posicaox = posicao [0]

posicaoy = posicao [1]

velocidadex = velocidade [0]

velocidadey = velocidade [1]

dt = 0.1

132

while y >= 0:

ax = - res * v * vx

ay = -g - res * v * vy

tempo . append ( t )

posicaox . append ( x )

posicaoy . append ( y )

velocidadex . append ( vx )

velocidadey . append ( vy )

vx += ax * dt

vy += ay * dt

x += ( vx + ax * dt /2) * dt

y += ( vy + ay * dt /2) * dt

t += dt

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49 g = 9.8

50 x = 0

51 y = 0

52 v = 50

53 theta = 35

54 t = 0

55 m = 0.145

56

57 tempo = []

# m / s2 . ACelera ç ã o da gravidade .

# m . Posi ç ã o inicial .

# m / s . velocidade

# 35* pi /180 radianos

# s . Tempo inicial

# kg

58 posicaoComRes = [[] , []]

59 velocidadeComRes = [[] , []]

60

61 posicaoSemRes = [[] , []]

62 velocidadeSemRes = [[] , []]

63

64 # calculo da trajetoria sem resistencia

65 trajetoriaProjetil (x , y , v , theta , t , m , 0 , tempo ,

posicaoSemRes , velocidadeSemRes )

66

67

68 # calculo da trajetoria com resistencia

69 tr ajetoriaProjetil (x , y , v , theta , t , m , 0.0012 , tempo ,

posicaoComRes , velocidadeComRes )

70

71

133

72 plt . plot ( posicaoComRes [0] , posicaoComRes [1])

73 plt . plot ( posicaoSemRes [0] , posicaoSemRes [1])

74 plt . xlabel ( " x ( m ) " )

75 plt . ylabel ( " y ( m ) " )

76 plt . legend ([ " Com resist ê ncia " , " Sem resist ê ncia " ])

77 plt . grid ( True )

78

79 plt . show ()

Fonte: Elaborado pelo autor.

Figura 15 – Trajetória de um projétil com e sem resistência.

Fonte: Elaborado pelo autor

6.2 Pêndulo

Agora exploraremos o comportamento de um pêndulo. Não há melhor exemplo de

sistema que parece simples à primeira vista, mas que acaba por conter camadas intrincadas de

complexidade.

A ﬁgura mostra a conﬁguração básica: um pivô ﬁxo, uma barra sem massa de

comprimento L e um corpo com massa m no ﬁnal, oscilando no plano da página. É mais fácil

analisar o movimento em termos de torque e aceleração angular. Lembremos a versão angular

da segunda lei de Newton

∑ τ = Iα.

(6.9)

No lado esquerdo desta equação está a soma de todos os torques atuando no objeto.

No lado direito, I é a inércia rotacional do objeto, mL2 para o pêndulo. A aceleração angular α é

Figura 16 – Um pêndulo de massa m, sob a ação da força da gravidade.

134

θ

L

m

(cid:126)Fg

Fonte: Elaborado pelo autor

deﬁnida análogo à aceleração comum

α =

∆ω
∆t

e ω =

∆θ
∆t

,

(6.10)

onde ω é a velocidade angular.

Pelo diagrama podemos ver que o torque devido a gravidade é

τg − LFgsenθ = −Lmgsenθ ,

(6.11)

onde o sinal de menos indica que o torque é negativo (sentido horário) quando θ é positivo e

vice-versa. Se não houver atrito ou outro torque atuando, então a lei de Newton (equação 6.9)

diz

−Lmgsenθ = mL2α ou α = −

g
L

senθ .

(6.12)

Como a massa m foi cancelada da equação (6.12), não haverá necessidade de

especiﬁcar uma massa em sua simulação de pêndulo. Podemos pensar que precisamos especiﬁcar

um comprimento L e também um valor de g (dependendo de qual planeta o pêndulo vive), mas

na verdade não precisa, porque ainda temos a liberdade de escolher nossas unidades para medir

distância e tempo. Nossa liberdade de escolher unidades signiﬁca que quaisquer que sejam os

valores reais de L e g, podemos simplesmente especiﬁcar que estamos usando unidades nas quais

ambas são iguais a 1. Essas unidades são chamadas de unidades naturais, porque são naturais

para a física que estamos estudando. Uma vantagem de usar unidades naturais é que a equação

(6.12) se torna simplesmente α = −senθ . Mas a vantagem real é que nossa simulação será

aplicável a qualquer pêndulo em qualquer planeta. O preço é que, para aplicar nossos resultados

135

a um pêndulo especíﬁco, podemos precisar convertê-los de unidades naturais em unidades mais

convencionais após executar a simulação.

Precisamos expressar a posição do pêndulo em coordenadas retangulares. Conside-

rando que a origem está no pivô e as direções x e y para a direita e para cima, respectivamente,

as fórmulas para x e y em termos de θ é

x = Lsenθ ,

y = −L cos θ .

A energia potencial do pêndulo pode ser modelada a partir da equação básica

Ep = mgh,

onde g é a aceleração da gravidade e h é a altura. Costumamos usar essa equação para modelar

objetos em queda livre. No entanto, o pêndulo é restringido pela haste ou corda e não está em

queda livre. Portanto, devemos expressar a altura em termos de θ , o ângulo e L, o comprimento

do pêndulo. Assim, h = L(1 − cos θ ). Logo, a energia potencial pode ser descrita por

Ep = mgL(1 − cos θ ).

A energia cinética é dado por Ec =

1
2

mv2 mas v = Lω, logo Ec =

1
2

mL2ω 2. Com

isso, implementamos o código 75 abaixo.

Código-fonte 75 – Movimento de um pêndulo sob ação da gravidade.

1 import math

2 import matplotlib . pyplot as plt

3

4 theta = 0

5 omega = 10* math . pi /180 # inicial em radianos

6 t = 0

7 tmax = 10

8

9 dt = 0.01

10

11 tempo = [ t ]

12 posicaox = [ math . sin ( theta ) ]

13 posicaoy = [ - math . cos ( theta ) ]

14 angulo = [ theta ]

15

136

16 energiaP = [1 - math . cos ( theta ) ]

17 energiaC = [ omega **2/2]

18 energiaTotal = [ energiaP [ -1]+ energiaC [ -1]]

19

20 while t <= tmax :

alpha = - math . sin ( theta )

omega += alpha * dt

theta += omega * dt

t += dt

posicaox . append ( math . sin ( theta ) )

posicaoy . append ( - math . cos ( theta ) )

angulo . append ( theta )

energiaP . append (1 - math . cos ( theta ) )

energiaC . append ( omega **2/2)

energiaTotal . append ( energiaP [ -1]+ energiaC [ -1])

tempo . append ( t )

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36 plt . subplot (1 ,2 ,1)

37 plt . plot ( tempo , posicaox )

38 plt . xlabel ( " t " )

39 plt . ylabel ( " x " )

40 plt . grid ( True )

41

42 plt . subplot (1 ,2 ,2)

43 plt . plot ( tempo , posicaoy )

44 plt . xlabel ( " t " )

45 plt . ylabel ( " y " )

46 plt . grid ( True )

47

48 plt . show ()

49

50 # grafico de energia cinetica , potencial e total

51 plt . plot ( tempo ,

energiaC )

52 plt . plot ( tempo , energiaP )

53 plt . plot ( tempo , energiaTotal )

54 plt . xlabel ( " tempo " )

55 plt . ylabel ( " energia " )

56 plt . legend ([ " Energia cin é tica " ," energia potencial " ," Energia Total " ])

137

57 plt . grid ( True )

58 plt . show ()

Fonte: Elaborado pelo autor.

Agora vamos adicionar mais algumas complicações: fricção para desacelerar o

pêndulo e um torque externo periódico que adiciona energia continuamente ao sistema. Uma

maneira simples de adicionar atrito é subtrair um termo proporcional a ω do lado direito da

equação (6.12) para a aceleração angular, ou seja

α = −

g
L

senθ − cω.

(6.13)

Uma força resistiva linear (ou torque) desta forma é chamada de amortecimento e o coeﬁciente c

é chamado de constante de amortecimento.

No código (75), basta alterar a linha 21 com algum valor de c.

1 alpha = - math . sin ( theta ) - c * omega

Os graﬁcos de energia tomam a forma agora como nas imagens 17 e 18.

Figura 17 – Pêndulo com amortecimento.

Fonte: Elaborado pelo autor

O amortecimento remove a energia do pêndulo, então o movimento “morre”. Mas

podemos manter o movimento, aplicando continuamente um torque externo ao pêndulo. Uma

maneira simples, porém interessante de fazer isso é adicionar um termo à equação (6.13) que

Figura 18 – Energia cinética, potencial e total.

138

Fonte: Elaborado pelo autor

seja senoidal no tempo, a saber

α = −

g
L

senθ − cω + Asen( f t).

(6.14)

Este termo adicional representaria uma força de torção suave para a frente e para trás aplicada no

pivô, que não é afetada pela posição e velocidade do pêndulo. As constantes A e f representam a

amplitude e a frequência angular desse torque.

Usando a constante de amortecimento igual a 0, 5, a amplitude igual a 0, 5 e a frequên-

cia igual a 2/3, e mais uma vez modiﬁcando a linha 21, vemos que, após um comportamento

“transitório” inicial, o movimento se torna periódico, como podemos vê na imagem 19.

1 alpha = - math . sin ( theta ) - c * omega + A * math . sin ( f * t )

Figura 19 – Pêndulo com um torque externo.

Fonte: Elaborado pelo autor.

Agora, aumentando a amplitude para 1,2, o pêndulo pode oscilar sobre o pivô e

o movimento se torna muito mais complexo. Em alguns casos, como vimos nesse exemplo,

o movimento nunca se estabiliza nem se torna periódico. Como o movimento parece tão

imprevisível, a palavra “caos” muitas vezes vem à mente.

Figura 20 – Posição para amplitude igual a 1,2.

139

Fonte: Elaborado pelo autor.

Figura 21 – Velocidades para amplitude igual a 1,2.

Fonte: Elaborado pelo autor.

Figura 22 – Energia para amplitude igual a 1,2.

Fonte: Elaborado pelo autor.

Caos é, na verdade, um termo técnico em dinâmica, usado para descrever um

140

comportamento imprevisível na prática, porque mesmo uma pequena mudança na condição

inicial resulta em uma mudança exponencialmente crescente no movimento.

6.3

Implementação em Fortran

Os códigos seguintes mostram as implementações em FORTRAN equivalentes das

funções Python desenvolvidas durante esse capítulo. As rotinas correspondentes têm nomes,

parâmetros e funcionalidades idênticos.

Código-fonte 76 – Simular movimento de projétil em uma dimensão.

1 program main

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

implicit none

real ( kind = 8 ) :: gravidade , y , vy , t , ay

real ( kind = 8 ) :: dt

integer , parameter :: N = 100

integer :: i

real ( kind = 8 ) , dimension ( N ) :: tempo

real ( kind = 8 ) , dimension ( N ) :: posicao

real ( kind = 8 ) , dimension ( N ) :: velocidade

gravidade = 9.8

y = 10. e0

vy = 0. e0

t = 0 e0

ay = - gravidade

dt = 1. e0 / N

do i =1 , N

tempo ( i ) = t

posicao ( i ) = y

velocidade ( i ) = vy

141

y = y + vy * dt

vy = vy + ay * dt

t = t + dt

end do

do i =1 , N

print * , i , tempo ( i ) , posicao ( i ) , velocidade ( i )

end do

28

29

30

31

32

33

34

35

36

37 end program main

Fonte: Elaborado pelo autor.

Código-fonte 77 – Trajetória de um projétil com e sem resistência.

1 subroutine trajetoriaProje til (x , y , v , theta , t , m , g , c , tempo ,

posicao , velocidade , N )

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

! x , y

! v

: posicao inicial

: velocidade inicial

! theta

: â ngulo inicial

! t

! m

! g

! c

: tempo inicial

: massa do proj é til

: acelera ç ã o da gravidade

: constantede resist ê ncia

! tempo

: lista

para guardar os tempo para plotagem

! posicao

: posicao sucessivas do proj é til

!

!

: posicao (1) -> componente horizontal

: posicao (2) -> componente vertical

! velocidade : lista com velocidades sucessivas do proj é til

!

!

: velocidade (1) -> componente horizontal

: velocidade (2) -> componente vertical

implicit none

real ( kind = 8 ) , parameter :: PI = 3.1415926

real ( kind = 8 ) :: x , y , v , theta

real ( kind = 8 ) :: t , m , c , dt , vx , vy

142

real ( kind = 8 ) :: res

real ( kind = 8 ) :: ax , ay , g

integer :: N , i

real ( kind = 8 ) , dimension (N , N ) :: posicao

real ( kind = 8 ) , dimension (N , N ) :: velocidade

real ( kind = 8 ) , dimension ( N ) :: tempo

real ( kind = 8 ) , dimension ( N ) :: posicaox

real ( kind = 8 ) , dimension ( N ) :: posicaoy

real ( kind = 8 ) , dimension ( N ) :: velocidadex

real ( kind = 8 ) , dimension ( N ) :: velocidadey

vx = v * cos ( theta * PI /180)

vy = v * sin ( theta * PI /180)

res = c / m

dt = 1. e0 / N

do i = 1 , N

ax = - res * V * vx

ay = -g - res * v * vy

tempo ( i ) = t

posicaox ( i ) = x

posicaoy ( i ) = y

velocidadex ( i ) = vx

velocidadey ( i ) = vy

vx = vx + ax * dt

vy = vy + ay * dt

x = x + ( vx + ax * dt /2) * dt

y = y + ( vy + ay * dt /2) * dt

t = t + dt

end do

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

143

do i = 1 , N

posicao (1 , i ) = posicaox ( i )

posicao (2 , i ) = posicaoy ( i )

velocidade (1 , i ) = velocidadex ( i )

velocidade (2 , i ) = velocidadey ( i )

end do

63

64

65

66

67

68

69

70

71 end subroutine trajetoriaP roj etil

72

73

74 program main

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

implicit none

real ( kind = 8 ) :: g , x , y , v , theta , t , m

real ( kind = 8 ) :: cComRes , cSemRes

integer , parameter :: N = 100

integer :: i

real ( kind = 8 ) , dimension (N , N ) :: posicaoSemRes

real ( kind = 8 ) , dimension (N , N ) :: velocidadeSemRes

real ( kind = 8 ) , dimension (N , N ) :: posicaoComRes

real ( kind = 8 ) , dimension (N , N ) :: velocidadeComRes

real ( kind = 8 ) , dimension ( N ) :: tempo

g = 9.8 e0

x = 0. e0

y = 0. e0

v = 50. e0

theta = 35. e0

t =0. e0

m = 0.145

100

101

cComRes = 0.0012

cSemRes = 0. e0

144

102

103

104

105

106

107

108

109

110

111

112

call trajetoriaProjetil (x , y , v , theta , t , m , g , cSemRes , &

tempo , posicaoSemRes , velocidadeSemRes , N )

call trajetoriaProjetil (x , y , v , theta , t , m , g , cComRes , &

tempo , posicaoComRes , velocidadeComRes , N )

do i = 1 , N

print * , tempo ( i ) , posicaoSemRes (1 , i ) , posicaoSemRes (2 , i )

end do

113 end program main

Fonte: Elaborado pelo autor.

Código-fonte 78 – Movimento de um pêndulo sob ação da gravidade.

1 program main

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

implicit none

real ( kind = 8 ) , parameter :: PI = 3.1415926

integer , parameter :: N = 100

real ( kind = 8 ) :: theta , omega , t , alpha

real ( kind = 8 ) :: c , A , f

real ( kind = 8 ) :: dt

integer :: i

real ( kind = 8 ) , dimension ( N ) :: tempo

real ( kind = 8 ) , dimension ( N ) :: posicaox

real ( kind = 8 ) , dimension ( N ) :: posicaoy

real ( kind = 8 ) , dimension ( N ) :: angulo

real ( kind = 8 ) , dimension ( N ) :: velocidade

real ( kind = 8 ) , dimension ( N ) :: energiaP

real ( kind = 8 ) , dimension ( N ) :: energiaC

real ( kind = 8 ) , dimension ( N ) :: energiaTotal

145

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

theta = 0. e0

omega = 10. e0 * PI / 180

t = 0. e0

c = 0.5

A = 1.2

f = 2. e0 /3

dt = 1. e0 / N

do i = 1 , N

alpha = - sin ( theta ) - c * omega + A * sin ( f * t )

omega = omega + alpha * dt

theta = theta + omega * dt

t = t + dt

posicaox ( i ) = sin ( theta )

posicaoy ( i ) = - cos ( theta )

angulo ( i ) = theta

velocidade ( i ) = omega

energiaP ( i ) = 1 - cos ( theta )

energiaC ( i ) = omega * omega / 2

energiaTotal ( i ) = energiaP ( i ) + energiaC ( i )

tempo ( i ) = t

end do

do i = 1 , N

print * , i , posicaox ( i ) , energiaTotal ( i )

end do

56 end program main

Fonte: Elaborado pelo autor.

146

7 CONSIDERAÇÕES FINAIS

A matemática computacional e a computação cientíﬁca estão preocupadas com a

computação, ou seja, o procedimento de realmente produzir números e gráﬁcos como soluções

para problemas deﬁnidos por modelos matemáticos. Com a introdução dos computadores em

meados da década de 1940, valeu a pena construir métodos numéricos, mesmo que a imple-

mentação exigisse milhões de operações aritméticas básicas. Em pouco tempo, a computação

cientíﬁca tornou-se uma terceira ferramenta cientíﬁca como um complemento às ferramentas

clássicas de teoria e experimentos.

(cid:114)

Para a equação quadrática x2 + ax + b = 0 existe uma fórmula simples para sua solu-
a
2

− b, que pode ser avaliada para a e b dados. Para equações de grau superior

a2
4

±

ção, x = −

contendo os termos x3 e x4, existem fórmulas explícitas para as soluções. No entanto, para

equações de grau superior, não existem tais fórmulas gerais. Assim, para equações polinomiais
gerais xn + an − 1xn−1 + · · · + a0 = 0, a solução x pode ser encontrada por meios analíticos se

n ≤ 4, mas algum procedimento numérico deve ser usado para avaliar as expressões matemáticas

envolvidas. Para n ≥ 5, uma solução aproximada deve ser encontrada aplicando um método

numérico diretamente à equação.

Dados n + 1 valores de função yi = f (xi), o problema de interpolação é encontrar um
polinômio p(x) = a0 + a1x + · · · + an + xn tal que p(xi) = f (xi). A solução para este problema é

única e pode ser deﬁnida por um sistema algébrico de equações lineares. Pode parecer que o

problema de interpolação não é grande coisa, devemos apenas resolver o sistema. No entanto,

para n grande, esse sistema não é muito fácil de resolver. Diferentes fórmulas para avaliar p(x)

foram desenvolvidas.

Com a introdução do cálculo diferencial e integral veio o problema de calcular o

valor de integrais deﬁnidas. Apenas para funções especiais f (x) é possível encontrar uma função

primitiva F(x) como dF/dx = f por meios analíticos. Às vezes, a fórmula explicita de f (x) nem

mesmo é conhecida, mas seus valores são conhecidos em certos pontos discretos. Portanto, é

necessário construir métodos numéricos para encontrar valores precisos da integral deﬁnida.

Se um corpo localizado em x0 quando t = 0 move-se com velocidade constante v,

o modelo matemático pode ser descrito como

dx
dt
inicial envolvendo uma equação diferencial e uma condição inicial. Aqui estamos procurando

= v, x(0) = x0. Este é um problema de valor

uma solução na forma de uma função x(t), e é facilmente encontrada como x(t) = x0 + vt, que é

uma expressão explícita que pode ser avaliada para qualquer valor de t. No entanto, quando os

147

coeﬁcientes dependem de t, em geral não existe uma forma explícita para a solução. É ainda

pior quando a equação diferencial não é linear. Nem ﬁca claro se existe uma solução e, se existe,

como encontrá-lo por meios analíticos. No entanto, existem métodos numéricos muitos eﬁcazes

baseadas na discretização, onde as derivadas são substituídas por fórmulas de diferenças ﬁnitas

de modo que a solução possa ser calculada com uma precisão muito alta. Euler provavelmente

foi o primeiro a usar um método de diferenças ﬁnitas para resolver uma equação diferencial.

Para sistemas de equações diferenciais ordinárias, uma longa série de variações no principio

básico foi posteriormente desenvolvido com os métodos de Runge-Kutta como um dos mais

importantes.

Imaginemos que uma pessoa veio do passado e devemos contar a ela as vantagens

da alfabetização. Teremos uma grande empreitada - ele conﬁa plenamente em sua memória e

não teve convívio com livros. Queremos explicar o mundo das ideias que podem ser encontradas

nos livros, mas tudo o que ele consegue ver são símbolos engraçados. Sabemos que a leitura

enriqueceu nossa vida, e queremos dizer isso. Mas temos medo que ele ria.

Agora imaginemos que somos enviado para o futuro, um futuro no qual os com-

putadores abrem a porta para a matemática como os livros abrem a porta para a alfabetização.

Nosso guia diz que existe uma fértil experiência humana em matemática, um conhecimento tão

gratiﬁcante quanto qualquer outra proporcionado pelos livros, uma vivência que nos foi negada.

Somos informado de uma bela paisagem matemática, mas tudo o que podemos ver são símbolos

engraçados. Nosso guia tenta nos mostrar que seremos uma pessoa melhor e rimos.

Estamos no prelúdio de uma revolução na matemática - como pensamos sobre ela,

como a praticamos e como a aprendemos. A revolução está centrada no computador como uma

ferramenta matemática, uma ferramenta que está se tornando reconhecida como fundamental

para a matemática, assim como os livros são para a alfabetização. A revolução matemática pode,

no devido tempo, se tornar tão importante quanto a revolução do computador que a precedeu e a

trouxe à existência.

Como em toda revolução, as pessoas estão tomando partido - algumas gostariam

de ver uma exploração completa do papel do computador na matemática humana, enquanto

outras acham que usar um computador na matemática é trapaça. Consideramos que desenvolver

uma pesquisa que alia os conhecimentos de uma linguagem de programação, e computação em

geral, com conhecimentos matemáticos é uma grande avanço para desenvolvermos habilidades

e resolvermos problemas que combinam percepções de uma ou mais disciplinas das ciências

naturais. Isso fornece uma combinação única de habilidades e conhecimentos teóricos e aplicados.

Essas habilidades pode nos mudar mais profundamente do que imaginamos. Ideias matemáticas

podem chegar a igualar palavras em riqueza de expressão, fornecendo uma nova linguagem

humana que não favorece nenhum território e não requer tradução.

148

REFERÊNCIAS

149

ARACHNOID.COM. Computer Math, Exploring a new frontier beyond the realm of hu-
man calculation. 2008. Disponível em: https://arachnoid.com/lutusp/computermath.html.
Acesso em: 3 dez 2020.

ARAÚJO, A. Matemática Computacional. Coimbra: Universidade de Coimbra, 2011.

BEAZLEY, D.; JONES, B. K. Python Cookbook: Recipes for Mastering Python 3 . [S.l.]:
"O’Reilly Media, Inc.", 2013.

BEU, T. Introduction to Numerical Programming: A Practical Guide for Scientists and
Engineers Using Python and C/C++. [S.l.]: Taylor & Francis, 2014. (Series in Computational
Physics).

BORGES, L. E. Python para desenvolvedores: aborda Python 3.3. [S.l.]: Novatec, 2014.

BOSE, S. K. Numerical Methods of Mathematics Implemented in Fortran. [S.l.]: Springer,
2019.

BURDEN, R.; FAIRES, J. Numerical Analysis. [S.l.]: Brooks/Cole, Cengage Learning, 2011.

CANTAO, L. A. P. Cálculo Numérico e Computacional - cnc. São Paulo: UNESP, 2010.

CHAPMAN, S. J. Fortran for scientists and engineers. [S.l.]: McGraw-Hill Education, 2018.

DEMIDOVICH, B.; MARON, I. Computational mathematics (translated by g. yankovsky).Mir,
Moskva, v. 1, 1987.

DEPARTAMENT OF PHYSICS, UNIVERSITY IN ST. LOUIS. Disponível em: https://web.
physics.wustl.edu/~wimd/topic01.pdf. Acesso em: 2 dez 2020.

DICKINSON SCHOLAR. VPython for Introductory Mechanics: Complete Version. 2019.
Disponível em: https://scholar.dickinson.edu/vpythonphysics/?utm_source=scholar.dickinson.
edu%2Fvpythonphysics%2F1&utm_medium=PDF&utm_campaign=PDFCoverPages. Acesso
em: 12 dez 2020.

DOMINGUES, R. O.; SIQUEIRA, A. S.Teoria, Implementaçao e Comparaçao de Métodos
de Integraçao Numérica. [S.l.: s.n.], 2016.

FOURIER.ENG.HMC.EDU. Disponível em: http://fourier.eng.hmc.edu/e176/lectures/ch6/ch6.
html. Acesso em: 20 nov 2020.

GRAÇA, M.; LIMA, P. Apontamentos de Matemática Computacional. Lisboa: [s.n.], 2016.

GUSTAFSSON, B.Scientific Computing from a Historical Perspective. [S.l.]: Springer, 2018.
v. 17.

HÜROL, S. Numerical Methods for Solving Systems of Ordinary Differential Equations .
2013. 135f. Tese (Doutorado em Matemática) – Eastern Mediterranean University, 2013.

IBM. 2011. Disponível em: https://www.ibm.com/ibm/history/ibm100/us/en/icons/fortran/.
Acesso em: 6 nov 2020.

KANSCHAT, G.Numerical Analysis of Ordinary Differential Equations. 2018. Disponível
em: https://www.mathsim.eu/~gkanscha/notes/ode.pdf. Acesso em: 12 dez 2020.

150

LABAKI, J.; WOISKI, E. Introdução a python–módulo a. Grupo Python, UNESP-Ilha Sol-
teira, v. 2, 2003.

MENEZES, N. N. C. Introdução a programação com Python. São Paulo: Novatec, 2010.

PETERSDORFF, T. von. A short proof for romberg integration.The American Mathematical
Monthly, v. 100, n. 8, p. 783–785, 1993. Disponível em: http://www.jstor.org/stable/2324787.
Acesso em: 12 dez 2020.

RAY, S. S. Numerical analysis with algorithms and programming. [S.l.]: CRC Press, 2018.

ROSSUM, G. van. Python Tutorial. 1995. Disponível em: https://ir.cwi.nl/pub/5007/05007D.
pdf.

SOLOMON, J. Numerical algorithms: methods for computer vision, machine learning, and
graphics. [S.l.]: CRC press, 2015.

STOER, J.; BULIRSCH, R. Introduction to numerical analysis. [S.l.]: Springer Science &
Business Media, 2013. v. 12.

TELECOMUNICAÇOES, C. d. E. de; TUTORIAL, P. de E.; GRUPO, P. Tutorial de introduçao
ao python. 2011.

TRINITY COLLEGE DUBLIN,
2016. Disponível
em: https://www.tcd.ie/Physics/people/Charles.Patterson/teaching/PY2050_CP/New_Scripts/
Projectile_Motion.pdf. Acesso em: 5 nov 2020.

THE UNIVERSITY OF DUBLIN.

TUTORIALS POINT. Matplotlib Tutorial. 2020. Disponível em: https://www.tutorialspoint.
com/matplotlib/index.htm. Acesso em: 17 dez 2020.

TUTORIALS POINT. Fortran Tutorial. 2021. Disponível em: https://www.tutorialspoint.
com/fortran/index.htm. Acesso em: 24 nov 2020.

UNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL.Recursos Educacionais Abertos
de Matemática. 2020. Disponível em: https://www.ufrgs.br/reamat/CalculoNumerico/index.
html. Acesso em: 7 nov 2020.

UNIVERSITETET I OSLO. Numerical Solution of Differential Equations. 2008. Dispo-
nível em: https://www.uio.no/studier/emner/matnat/math/MAT-INF1100/h08/kompendiet/
differential-eqs.pdf. Acesso em: 9 nov 2020.

WEBER STATE UNIVERSITY.Python Manual. 2018. Disponível em: http://physics.weber.
edu/schroeder/scicomp/PythonManual.pdf. Acesso em: 21 dez 2020.

WIKIPEDIA. Divided differences . 2015. Disponível em: https://en.wikipedia.org/wiki/
Divided_differences. Acesso em: dez 2020.

WIKIVERSITY.Cubic Spline Interpolation. 2020. Disponível em: https://en.wikiversity.org/
wiki/Cubic_Spline_Interpolation. Acesso em: dez 2020.

