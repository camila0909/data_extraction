Programa de Pós-Graduação em
Matemática em Rede Nacional

Decomposição de números fatoriais em
fatores primos: algoritmos para
situações complementares ao Teorema
de Legendre

Leonardo Henrique Melo de Carvalho

Rio Claro
2022

Universidade Estadual Paulista “Júlio de Mesquita Filho”
Instituto de Geociências e Ciências Exatas
Câmpus de Rio Claro

Decomposição de números fatoriais em
fatores primos: algoritmos para
situações complementares ao Teorema
de Legendre

Leonardo Henrique Melo de Carvalho

Dissertação apresentada como parte dos requisitos para
obtenção do título de Mestre em Matemática, junto ao
Programa de Pós-Graduação – Mestrado Profissional em
Matemática em Rede Nacional, do Instituto de Geociên-
cias e Ciências Exatas da Universidade Estadual Paulista
“Júlio de Mesquita Filho”, Câmpus de Rio Claro.

Orientador
Prof. Dr. Jamil Viana Pereira

Rio Claro
2022

C331dCarvalho, Leonardo Henrique Melo de    Decomposição de números fatoriais em fatores primos: : algoritmospara situações complementares ao Teorema de Legendre / LeonardoHenrique Melo de Carvalho. -- Rio Claro, 2022    90 p. : il., tabs. + 1 CD-ROM    Dissertação (mestrado profissional) - Universidade EstadualPaulista (Unesp), Instituto de Geociências e Ciências Exatas, RioClaro    Orientador: Jamil Viana Pereira    1. Legendre. 2. Fatores primos. 3. Teorema Fundamental daAritmética. 4. Aritmética. 5. Teorema de Legendre. I. Título.Sistema de geração automática de fichas catalográficas da Unesp. Biblioteca do Instituto deGeociências e Ciências Exatas, Rio Claro. Dados fornecidos pelo autor(a).Essa ficha não pode ser modificada.TERMO DE APROVAÇÃO

Leonardo Henrique Melo de Carvalho

Decomposição de números fatoriais em fatores primos:
algoritmos para situações complementares ao
Teorema de Legendre

Dissertação aprovada como requisito parcial para a obtenção do
grau de Mestre no Curso de Pós-Graduação – Mestrado Profissional
em Matemática em Rede Nacional, do Instituto de Geociências e Ci-
ências Exatas da Universidade Estadual Paulista “Júlio de Mesquita
Filho”, pela seguinte banca examinadora:

Prof. Dr. Jamil Viana Pereira
Orientador

Prof. Dr. Robinson Alves Lemos
FACSAL/UNEMAT/Tangará da Serra (MT)

Profa. Dra. Suzete Maria Silva Afonso
IGCE/UNESP/Rio Claro (SP)

Rio Claro, 05 de abril de 2022

Agradecimentos

De inicio, agradeço minha família pelo tempo e o amor empregado para que esse
trabalho fosse possível. Vocês mais do que ninguém representam o que há de mais vital
e importante em minha vida. Em especial, deixo agradecimentos a Lucilene de Carvalho
(mãe), João Carlos Batista de Carvalho (pai), Israel Henrique de Carvalho (irmão) e Luzia
Totero Carvalho (avó).

Segundo, não poderia deixar de agradecer a minha esposa Ana Paula Brandão Carva-
lho de Melo. Por mais, que ainda seja curto o caminho que juntos percorremos, este por
si só já é capaz de concretizar uma certeza... somos almas além do tempo. O amor que
respalda nossas vidas está em tudo e não diferentemente, está nesse momento.

Em terceiro, quero agradecer aos meus professores. A estes, não me restrinjo há algum
período. Dedico a todos... Todos vocês foram e são extremamente importantes em minha
formação. Em cada ação do meu cotidiano, seja profissional ou pessoalmente, tenho em
vocês um exemplo. Em especial, gostaria de agradecer a dois professores que marcaram
minha jornada.

Primeiramente, a professora Sibeli Frolini, que mais que ser minha professora, me
trilhou para a área da pesquisa e me incentivou a fazer o mestrado. Segundo, ao professor
Jamil Viana Pereira, meu orientador nesse trabalho, a este deixo meus agradecimentos
pela confiança e por ter insistido em pontos de minha formação que me tornaram o
profissional que sou hoje.

Por fim, agradeço aos meus amigos. Amigos que formei durante minha vida. De
fato, não são muitos, mas são importantes em minha jornada. Destes destaco, Gustavo
Henrique Massarente, que se mostrou mais que um simples companheiro, mas um dos
irmãos que a vida, as vezes, nos felicita.

Assim, finalizo dedicando a Deus. Ele se manifesta em todas as pessoas anteriormente

citadas. Agradeço pelas bençãos e a significância que trouxe a minha vida.

Meu muito obrigado a todos.

“A matemática é o alfabeto no qual Deus escreveu o Universo.”
Galileu Galilei

Resumo

O principal objetivo desse trabalho é desenvolver um algoritmo baseado no Teorema
de Legendre, que conta quantos fatores primos existem na decomposição do fatorial de
um número natural n, bem como, descrever uma atividade que envolvesse Teoria dos
Números e programação computacional básica, voltada para estudantes da educação bá-
sica. Detalhamos a construção dos objetos do Teorema de Legendre sobre o ponto de
vista das duas funções envolvidas. Em seguida, descrevemos dois algoritmos que tratam
situações complementares ao Teorema de Legendre, sendo um deles apresentado no livro
“Aritmética” da coleção PROFMAT HEFEZ (2016), que teve sua base teórica explicitada
detalhadamente, complementando o que foi apresentado na referência e outro desenvol-
vido de forma independente pelos autores do trabalho, com sua respectiva base teórica
construída em detalhes. Por fim, foi construída uma atividade voltada aos estudantes de
educação básica que integrasse aspectos da Teoria do Números, aprendidos durante essa
fase de ensino, bem como, ideias de programação básica usando o “VisualG”.

Palavras-chave: Legendre, Fatores primos, Teorema Fundamental da Aritmética, Arit-
mética, Teorema de Legendre.

Abstract

The goal of this work is to develop an algorithm based on Legendre’s Theorem, which
counts how many prime factors there are in the factorial decomposition of a natural num-
ber n, as well as to describe an activity that involves Number Theory and computer
programming adressed for basic education students. We seek to understand the construc-
tion of Legendre’s Theorem objects from the point of view of the two functions involved.
Next, we describe two algorithms that deal with situations that are complementary to
Legendre’s Theorem, one of which presented in the book “Aritmética” HEFEZ (2016) of
the PROFMAT collection, which had its theoretical basis explained,and a complemen-
tary one, independently developed by the authors, with the respective theoretical basis
built in detail. Finally, the construction of an activity for basic education students was
described, integrating aspects of Number Theory learned during this teaching phase with
basic programming ideas using “VisualG”.

Keywords: Legendre, Prime factors, Fundamental Theorem of Arithimetic, Arithimetic,
Theorem’s Legendre.

Lista de Figuras

4.1 Fluxograma relacionado aos passos lógicos interpretados no algoritmo apre-
sentado por Abramo Hefez, encontrado no Livro Aritmética da coleção
PROFMAT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

4.2 Fluxograma relacionado aos passos lógicos interpretados no algoritmo das

matrizes, desenvolvido de forma inédita pelos autores. . . . . . . . . . . . . 44
. . . . . . . . . . . . . . . . 47
. . . . . . . . . . . . . 47
. . . . . . . . 47
. . . . . . . . . . . 48

4.3 Variação α × p × t para o Algorítimo p-ádica.
4.4 Variação α × p × t para o Algorítimo das matrizes.
4.5 Sobreposição dos dados apresentados pelas Figuras 4.3 e 4.4.
4.6 Histograma de frequência baseado na Observação 4.50.

5.1 Fluxograma dos divisores . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.2 Fluxograma do MDC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
5.3 Fluxograma do MMC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.4 Fluxograma da classificação entre primos e compostos . . . . . . . . . . . . 64
5.5 Fluxograma do TFA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

Sumário

1 Introdução

10

2 Apresentação dos objetos de estudo e suas propriedades

11
2.1 A função que conta fatores primos . . . . . . . . . . . . . . . . . . . . . . . 11
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.2 A função fatorial
. . . . . . . 14
2.3 Composição da função que conta fatores primos com a fatorial

3 A equação Ep (n) = α

16
3.1 Estudo da equação fixando p e n . . . . . . . . . . . . . . . . . . . . . . . 16
3.2 Estudo da equação fixando p e α . . . . . . . . . . . . . . . . . . . . . . . 17
3.3 Estudo da equação fixando n e α . . . . . . . . . . . . . . . . . . . . . . . 17

4 A equação Ep (n!) = α

4.1 Estudo da solução fixando p e n (Teorema de Legendre)
4.2 Estudo da solução fixando p e α

19
. . . . . . . . . . 19
. . . . . . . . . . . . . . . . . . . . . . . 26
4.2.1 Algoritmo p-ádica . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.2.2 Algoritmo das matrizes, construído pelos autores
. . . . . . . . . . 34
. . . . . . . . . . . . . . 46
4.2.3 Duelo computacional: p-ádica X matrizes
. . . . . . . . . . . . . . . . . . . . . . . 49

4.3 Estudo da solução fixando n e α.

5 Uso de linguagem de programação no processo de ensino e aprendizagem

51
5.1 O “Pensamento computacional” e o ensino da matemática . . . . . . . . . 51
5.1.1 Pensamento computacional . . . . . . . . . . . . . . . . . . . . . . . 51
. . . . . . . . . 52
5.1.2 Ensino da matemática: pensamento computacional
5.2 Ação nacional de educação e o pensamento computacional
. . . . . . . . . 53
5.3 Proposta de atividade envolvendo conceitos de teoria dos números . . . . . 54
5.3.1
Software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
5.3.2 Condições iniciais . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
5.4 Desenvolvimento de algoritmos auxiliares . . . . . . . . . . . . . . . . . . . 55
5.4.1 Divisores de um n natural
. . . . . . . . . . . . . . . . . . . . . . . 55
5.4.2 Mínimo Divisor Comum de dois naturais . . . . . . . . . . . . . . . 58
. . . . . . . . . . . . . . 60
5.4.3 Minimo Múltiplo Comum de dois naturais
5.4.4 Classificando os naturais entre primos e compostos
. . . . . . . . . 63
5.4.5 Teorema Fundamental da Aritmética . . . . . . . . . . . . . . . . . 65
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
1ª etapa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

5.5 Atividade final

5.5.1

SUMÁRIO

9

5.5.2
5.5.3
5.5.4
5.5.5
5.5.6

2ª etapa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
. . . . . . . . . . . . . . . . . . . . . . . . . . . 75
3ª, 4ª e 5ª etapas
6ª, 7ª e 8ª etapas
. . . . . . . . . . . . . . . . . . . . . . . . . . . 75
9ª, 10ª e 11ª etapas . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
12ª e 13ª etapas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

A Função Gama

B Linhas de programação - Algoritmo p-ádica e algoritmo das matrizes

79

83

1 Introdução

O presente trabalho tem seu principal objetivo relacionado ao Teorema de Legendre
que conta a quantidade de fatores de um dado p primo existentes no fatorial de um n
natural. Além disso, descrever uma aplicação prática, voltada ao ensino da matemática
na educação básica, que aborde algumas temáticas de Teoria dos Números.

Iniciamos nossas investigações trazendo resultados sobre duas funções, uma que rela-
ciona um n natural com quantidade de fatores de um dado p primo em sua decomposição
(Ep (n)), e outra que associa um dado natural n com seu fatorial (! (n)).

As análises descritas acima produziram resultados que foram usados de base para o
seguimento do trabalho. Como o teorema em questão tem seu resultado sobre o fatorial
de um número natural, passamos a analisar as propriedades da composição entre as duas
funções descritas anteriormente.

Logo após, estratificamos nossa análise em alguns casos de conveniência. Como a
função composta (Ep◦! (n)) possui três variáveis (p, n e α) cada caso trabalha fixando
duas e tomando a outra como variável livre. Esse procedimento foi realizado tanto para
a função Ep (n) como para a Ep◦! (n).

No momento em que abordamos o caso de p e α, para a função Ep◦! (n), introduzimos
dois algoritmos que buscam encontrar os valores de n natural que satisfazem a equação.
Um dos algoritmos foi encontrado no livro “Aritmética” da coleção PROFMAT, escrito
por (HEFEZ, 2016)1. O outro algoritmo foi construído de forma independente pelos
autores do trabalho e traz uma roupagem diferente da encontrada nos textos do livro de
Abramo Hefez.

Por fim, o trabalho segue com uma atividade prática, voltada ao ensino da matemá-
tica na educação básica. A atividade explora temáticas da Teoria dos Números aplicada
ao ensino de programação básica. Nela buscamos descrever um projeto que poderia ser
desenvolvido durante as aulas de matemática que visassem o ensino de conceitos como
MDC, MMC, Teorema fundamental da Aritmética, conceito de divisores e classificação
de naturais em compostos e primos a partir da criação de linhas de programação compu-
tacionais.

1Matemático egípcio, naturalizado brasileiro, que atua como professor titular no Instituto de Mate-

mática da Universidade Federal Fluminense.

10

2 Apresentação dos objetos de
estudo e suas propriedades

2.1 A função que conta fatores primos

Nesse capítulo, fixado um primo, investigaremos o funcionamento da função que, a
cada número natural, associa a quantidade de fatores do primo fixado. Para tanto, foca-
remos nas propriedades e caracterização de tal função, apresentando exemplos para maior
compreensão.

Para inicio do trabalho denota-se N como o conjunto dos Naturais, N = {1, 2, 3, 4, ...},
além disso, classificamos um número natural como primo, quando o mesmo possui apenas
dois divisores naturais distintos. A fim de caracterizarmos nossa função, teremos como
base o Teorema Fundamental da Aritmética (TFA1), enunciado abaixo e seguido por
algumas colocações relevantes à função que desejamos definir.

Teorema 2.1. (Teorema Fundamental da Aritmética - TFA1)Todo número natural n ≥ 2
possui uma decomposição única por fatores primos, isto é, dado n ≥ 2 existem únicos
primos distintos p1, , p2, ..., pr e naturais α1, α2, ..., αr tais que n = pα1

1 pα2

2 ...pαr
r

.

Corolário 2.2. Fixado p primo e n ∈ N existem únicos q ∈ N e α ∈ N ∪ {0} tais que
mdc(p, q) = 1 e n = pαq.

Demonstração. Vamos iniciar com a existência, se n = 1, tome α = 0 e q = 1. Se n ≥ 2 e
p não divide n, tome α = 0 e q = n. E, se n ≥ 2 e p divide n, na decomposição do TFA,
.
existem primos p, p1, p2, ..., pr e naturais α, α1, α2, ..., αr tais que n = pαpα1
2 ...pαr
r
Assim, basta tomar q = pα1

1 pα2

.

1 pα2

2 ...pαr
r

Para provar a unicidade, seja n = pαq e n = pα′q′, com mdc(p, q) = 1 e mdc(p, q′) = 1.

Então, supondo α ≥ α′ temos

pαq = pα′q′ ⇒

pα−α′q = q′ ⇒
pα−α′ | q′.

Como mdc(p, q′) = 1, então α = α′ levando q = q′, provando a unicidade da decom-

posição de n.

1Teorema demonstrado no Apêndice A.

11

A função que conta fatores primos

12

É a partir da colocação anterior que daremos inicio às tratativas da função que conta
fatores primos, sendo esta bem definida como exposto no Corolário 2.2. Nela buscamos
encontrar a quantidade máxima de fatores de um primo fixado, na decomposição de n ∈ N.
Definição 2.3. Fixando p primo e adotando n ∈ N, temos que a função Ep : N → N∪{0}
é definida por Ep (n) = α, se n = pαq, com mdc(p, q) = 1.
Observação 2.4. Tomando o Corolário 2.2 e a Definição 2.3, segue,

i) Ep (n) = 0 se e, só se, p ∤ n.

ii) Escrever n = pαq, com mdc(p, q) = 1, é equivalente dizer que α é a potência de p,

tal que, pα divide n.

iii) Tomando p e p′ primos distintos, então Ep (p) = 1 e Ep (p′) = 0.

iv) Ep não é injetiva. Basta tomar p primo e α ∈ N e q, q′ ∈ N primos com p e entre si,

então m = pαq e n = pαq′ são distintos e Ep (m) = Ep (n) = α.

v) Ep não é monótona. Basta fixar α > 0 e tomar a = pα, b = pα + 1, c = pα+1 − 1 e
d = pα+1, então a < b < c < d e Ep (a) = α > 0 = Ep (b), enquanto Ep (c) = 0 <
α + 1 = Ep (d).

Após as considerações tomadas dispomos da proposição abaixo, que expõe as propri-

edades dessa função.

Proposição 2.5. Fixado p primo, a função Ep : N → N ∪ {0}, possui as seguintes
propriedades:

P1. Ep (mn) = Ep (m) + Ep (n).

P2. Ep é sobrejetiva.

P3. Se Ep (m) = α1 e Ep (n) = α2, com α1 ̸= α2, então Ep (m + n) = min {α1, α2}.

P4. Se Ep (m) = Ep (n) = α, então Ep (m + n) ≥ α e Ep (m + n) pode assumi um valor

α + r, r ≥ 1.

Demonstração.

P1. Se Ep (m) = α1 e Ep (n) = α2, então

m = pα1q, com mdc(p, q) = 1
n = pα2q′, com mdc(p, q′) = 1.

Notamos que mdc(p, qq′) = 1, assim,

mn = pα1qpα2q′ ⇒
mn = pα1+α2qq′ ⇒
Ep (mn) = α1 + α2 ⇒
Ep (mn) = Ep (m) + Ep (n) .

A função fatorial

13

P2. Tomando α = 0 temos Ep(n) = 0 para p ∤ n, e dado α ∈ N , temos α = Ep (pα).

P3. Segue da definição de Ep que,

m = pα1q, com mdc(p, q) = 1
n = pα2q′, com mdc(p, q′) = 1.

Então, supondo sem perda de generalidade que α1 < α2, podemos escrever que

m + n = pα1q + pα2q′ ⇒
m + n = pα1 (cid:16)

q + pα2−α1q′(cid:17)

.

Segue da igualdade anterior que Ep (n + m) ≥ α1. Para ocorrer Ep (n + m) > α1, o
número q + pα2−α1q′ deve ser divisível por p , o que implicaria em q ser divisível por
p, uma contradição. Portanto, Ep (n + m) = α1.

P4. A demonstração de que Ep (n + m) ≥ α é análoga a realizada no item P3. Em

particular, para n = pα e m = pα (pr − 1), r ≥ 1 tem-se

Ep (n + m) = Ep (pα + pα (pr − 1)) = Ep

(cid:16)

pα+r(cid:17) = α + r.

Exemplo 2.6. Tomando m = 72 e n = 73, temos que E7 (m) = E7 (m + n) = 2. Agora,
dado m = 5 · 22 e n = 11 · 22, então E2 (m) = E2 (n) = 2, já Ep (m + n) = 6.

Segue dos itens acima a caracterização da função. Nela podemos definir, Ep : N →

N ∪ {0} como,

□

Ep (n) =






0; se p ∤ n
α; se pα | n e pα+1 ∤ n, com α > 0

.

2.2 A função fatorial

Uma vez que a função fatorial é parte importante do conteúdo abordado nesse trabalho,

apresentaremos a seguir sua definição e algumas propriedades.

Definição 2.7. A função f : N → N é definida para f (1) = 1 e para n ≥ 2 recursivamente
por f (n) = n · f (n − 1). A notação usual para f (n) é n!.

Observação 2.8. Analisando a definição recursiva de n! é possível obter que n! =
n (n − 1) (n − 2) ...3 · 2 · 1.

Sobre sua monotonicidade expomos o seguinte.

Proposição 2.9. A função fatorial é estritamente crescente.

Composição da função que conta fatores primos com a fatorial

14

Demonstração. Por definição,

(n + 1)! = (n + 1) · n! ⇒

(n + 1)!
n!

= n + 1 > 1.

Tomando o resultado acima, dispomos dois corolários.

Corolário 2.10. A função fatorial é injetiva.

Corolário 2.11. Tomando a Proposição 2.9 e os casos em que 2! = 2 e 3! = 6, temos
que Ep não é sobrejetiva.

Embora não seja necessário para a proposta desse trabalho, um fato curioso e desvelado
durante a pesquisa acerca da função fatorial, é que ela pode ser estendida do conjunto
números naturais para o conjunto dos reais positivos. Não detalharemos as características
sobre tal função, mas deixaremos essa discussão à ser feita em no Apêndice A.

2.3 Composição da função que conta fatores primos

com a fatorial

Passaremos a trabalhar uma composição entre a função Ep e a função fatorial. Para

representar tal composição utilizaremos a notação E!
p

, observe que E!
p

(n) = Ep (n!).

Definição 2.12. Fixando p primo e adotando n ∈ N, temos que a função E!
p
é definida por Ep (n!) = α, se n! = pαq, com mdc(p, q) = 1.

: N → N∪{0}

Note que a definição apresentada é análogo à Definição 2.3, uma vez que n! ∈ N.

Assim, tomamos as propriedades dessa composição.

Proposição 2.13. Fixado p primo e E!
p

: N → N ∪ {0}, valem as seguintes propriedades:

P1. Ep (n!) = Ep

!

n!
(n − m)!

+ Ep ((n − m)!).

P2. E!
p

é crescente 2.

P3. Se p ≤ n < 2p, então Ep (n!) = 1.

P4. E!
p

P5. E!
p

não é injetiva.

não é sobrejetiva.

2Seja f uma função, tal que, f : A → B e f (a) = b, onde a ∈ A e b ∈ B. Tomando a′ ∈ A

– a > a′ e f (a) > f (a′), então f é estritamente crescente.
– a > a′ e f (a) ≥ f (a′), então f é crescente.
– a > a′ e f (a) < f (a′), então f é estritamente decrescente.
– a > a′ e f (a) ≤ f (a′), então f é decrescente.

 
Composição da função que conta fatores primos com a fatorial

15

P6. Dado p primo fixo, Ep (n!) = 0 se, e só se, n < p.

Demonstração.

P1. Como n! =

n!

(n − m)! · (n − m)!, aplicando o item P1 da Proposição 2.5, temos

Ep (n!) = Ep

!

n!
(n − m)!

+ Ep ((n − m)!) .

P2. Tomando m > n e p primo, temos que a quantidade de fatores p na decomposição
de n! existem em igual ou maior quantidade na decomposição de m!. Implicando
que a função seja crescente.

P3. Observe que E2 (2!) = E2 (3!) = 1, logo há validade quando p = 2.

Agora, se p > 2, temos que p2 | (2p)! e p3 ∤ (2p)!, logo Ep ((2p)!) = 2. Como
Ep ((2p)!) = Ep ((2p − 1)!) + Ep (2p), temos Ep ((2p − 1)!) = 1. Assim,

p ≤ n ≤ 2p − 1 ⇒
p! ≤ n! ≤ (2p − 1)! ⇒

Ep (p!) ≤ Ep (n!) ≤ Ep ((2p − 1)!) ⇒

1 ≤ Ep (n!) ≤ 1 ⇒
Ep (n!) = 1.

P4. Tomemos como contraposição o caso em que p = 2, onde E2 (2!) = E2 (3!) = 1.

P5. Suponhamos Ep ((p2 − 1)!) = α. Pelo item P1 da Proposição 2.5 calculamos o valor

de Ep ((p2)!).

(cid:16)(cid:16)

p2(cid:17)!(cid:17) = Ep

(cid:16)

p2(cid:17) + Ep

(cid:16)(cid:16)

p2 − 1(cid:17)!(cid:17)

Ep

= 2 + α.

Assim, dado que a função é crescente, temos que, não existe n, tal que, Ep (n!) =
α + 1.

P6. Ep (n!) = 0 se, e só se, p ∤ n!, é equivalente a n < p.

□

 
3 A equação Ep (n) = α

Note que a equação, possui os valores p primo, n ∈ N e α ∈ N ∪ {0}, então fixaremos
dois desses valores e encontraremos o terceiro em função dos fixados. Buscando uma
organização, dividimos nos diferentes casos:

Tabela 3.1: Localização e assunto-chave das subseções da Seção 3.

Caso
p e n previamente fixados
p e α previamente fixados
n e α previamente fixados

Localização
Subseção 3.1
Subseção 3.2
Subseção 3.3

Fonte: Autoria nossa.

3.1 Estudo da equação fixando p e n

Fixados n ∈ N e p primo, temos α, como variável livre e desejamos determinar possíveis
expressões de α que resolvam a equação Ep (n) = α. Uma condição interessante e de fácil
observação está no caso em que n é primo. Se n é distinto de p, então α = 0 e se n é igual
a p, então α = 1.

Visando uma melhor organização subdividiremos nossas abordagens como segue abaixo:

Tabela 3.2: Indicativo e localização de cada caso abordado na subseção 3.1.

Fixando

Localização
n = 1 e p primo Proposição 3.2
Proposição 3.3
Proposição 3.4

n ≥ 2 e p primo

Fonte: Autoria nossa.

Observação 3.1. Temos que o TFA garante condições para discutirmos casos em que
n ≥ 2, o caso n = 1 deve ser estudado separadamente.

Proposição 3.2. Fixado n = 1 e p primo, temos Ep (n) = 0.

Demonstração. Dado n = 1 e p primo, então n = p0 · 1, com mdc(n, 1) = 1. Logo,
Ep (n) = 0.

Proposição 3.3. Fixados n ∈ N, n ≥ 2 e p primo, mdc(n, p) = 1 se, e somente se,
Ep(n) = 0.

16

Estudo da equação fixando p e α

17

Demonstração. Se mdc(n, p) = 1 então p não divide n, logo Ep(n) = 0. Reciprocamente,
se Ep (n) = 0, então n = p0 · 1, com mdc(n, p) = 1.

Proposição 3.4. Fixados n ∈ N, n ≥ 2 e p primo, então existe única solução α ∈ N∪{0}
para a equação Ep (n) = α.

Demonstração. Consequência direta da Definição 2.3 e do Corolário 2.2.

3.2 Estudo da equação fixando p e α

Fixados α ∈ N ∪ {0} e p primo, temos n, como variável livre e desejamos determinar

possíveis expressões de n que resolvam a equação Ep (n) = α.

Proposição 3.5. Fixados α ∈ N ∪ {0} e p primo, existem infinitas soluções do tipo
n = pαq, com mdc(p, q) = 1 para a equação Ep (n) = α.

Demonstração. Ep (n) = α, se n = pαq, sendo mdc(p, q) = 1. Fixado p e α ∈ N ∪ {0},
existem infinitos q que satisfazem tal condição, portanto existem infinitas soluções do tipo
n = pαq, com mdc(p, q) = 1.

3.3 Estudo da equação fixando n e α

Fixados n ∈ N e α ∈ N ∪ {0}, temos p primo, como variável livre e desejamos deter-

minar possíveis expressões de p que resolvam a equação Ep (n) = α.

Visando uma melhor organização subdividiremos nossas abordagens como seguem

abaixo:

Tabela 3.3: Indicativo e localização de cada caso abordado na subseção 3.3.

Fixando
n = 1 e α = 0
n = 1 e α > 0
n ≥ 2 e α = 0
n primo e α > 0

Localização
Proposição 3.6
Proposição 3.7
Proposição 3.8
Proposição 3.9
n composto e α > 0 Proposição 3.10
Fonte: Autoria nossa.

Proposição 3.6. Fixando n = 1 e α = 0, então a equação Ep (n) = α possui infinitas
soluções.

Demonstração. Para todo p primo, temos n = p0 · 1, implicando em Ep (1) = 0.

Proposição 3.7. Fixando n = 1 e α > 0, então a equação Ep (n) = α não possui solução.

Demonstração. Sendo α > 0 e p primo, temos pαq > 1, para todo q ∈ N.

Estudo da equação fixando n e α

18

Agora tomando n ≥ 2 atrelamos nossas colocações às garantias existente pelo TFA.

Disso, propomos os resultados que seguem.

Proposição 3.8. Fixados n ≥ 2 e α = 0, a equação Ep (n) = α possui infinitas soluções.

Demonstração. Se p é um primo que não aparece na decomposição de n, então n = p0 · q,
com mdc(p, q) = 1. Logo, Ep (n) = 0. Como existem infinitos primos nessas condição,
então Ep (n) = 0 tem infinitas soluções.

Proposição 3.9. Fixando n primo e:

i. α = 1, então p = n é solução única da equação Ep (n) = α.

ii. α > 1, então não existe p primo que satisfaça a equação Ep (n) = α.

Demonstração. Sejam n e p primos e α ∈ N, pα | n se, e só se, n = p e α = 1. Por
consequência, se α > 1, então não existe p primo, tal que, pα | n.

Proposição 3.10. Fixados n composto, tal que, n = pα1
e α ∈ N, temos:

1 pα2

2 ...pαu
u

(decomposição do TFA),

i. caso α = αs, para algum s ∈ {1, 2, ..., u}, então p = ps é solução de Ep(n) = α,

observando que pode haver mais que uma solução.

ii. caso α ̸= αs, para todo s ∈ {1, 2, ..., u}, então não existe primo p solução de Ep(n) =

α.

Demonstração. Adotando n = pα1
1 ...pαu
u
datos a solução são p1, p2, ..., pu, então ps é solução se, e só se, α = αs.

com s ∈ {1, 2, ..., u}, temos que os únicos candi-

4 A equação Ep (n!) = α

Nesse momento, investigaremos as soluções da equação quando tomamos a forma
fatorial de n ∈ N. Para tanto, prossigamos como na seção anterior, quando fixamos
algumas variáveis e outras não.

Tabela 4.1: Localização e assunto-chave das subseções da Seção 4.

Caso
p e n previamente fixados
p e α previamente fixados
n e α previamente fixados

Localização
Subseção 4.1
Subseção 4.2
Subseção 4.3

Fonte: Autoria nossa.

4.1 Estudo da solução fixando p e n (Teorema de Le-

gendre)

Para uma melhor organização tome a tabela abaixo que destaca os resultados principais

abordados nesse momento.

Tabela 4.2: Resultados principais da sub-seção 4.1.

Estudo

Resultado

Existência e unicidade Proposição 4.1
Teorema 4.5
Teorema 4.10

Caracterização

Fonte: Autoria nossa.

Tomemos Ep (n!) = α, com n ∈ N e p primo fixos. Portanto, temos α como variável
livre e desejamos determinar possíveis expressões de α ∈ N ∪ {0} que resolvam a equação.
Fica evidente que n! pode e deve ser entendido como um valor natural sobre o ponto
de vista da função. Isso concerne para o entendimento que as propriedades no estudo da
equação Ep (n) = α sejam parcialmente conservadas. Inicialmente, tomemos a condição
que segue.

Proposição 4.1. Fixos p primo e n ∈ N, sempre existirá uma única solução na equação
Ep (n!) = α.

Demonstração.

Existência:

19

Estudo da solução fixando p e n (Teorema de Legendre)

i. n < p, então p ∤ n!, logo Ep (n!) = 0.

ii. n = p, então p | n! e p2 ∤ n!, logo Ep (n!) = 1.

iii. n > p, então existe α ∈ N, tal que, pα | n e pα+1 ∤ n, logo Ep (n!) = α.

Unicidade:
Diretamente da decomposição de n! dada pelo TFA.

20

□

Além da existência e unicidade, um dos resultados de Legendre fornece uma caracte-

rização da solução. Vamos fixar alguns conceitos antes de chegarmos a ele.

Definição 4.2. Sejam a ∈ N ∪ {0} e b ∈ N temos que
da divisão de a por b. Matematicamente,

(cid:21)
, representa o quociente inteiro

(cid:20) a
b

a = b ·

(cid:21)

(cid:20)a
b

+ r, com 0 ≤ r < b.

Lema 4.3. Sejam p primo, s ∈ N e k ∈ N ∪ {0}, se ps ∤ (k + 1), então

#

" k
ps

=

" k + 1
ps

#

.

Demonstração. Se ps ∤ (k + 1), então (k + 1) = ps
Manipulando algebricamente, temos que:

#

" k + 1
ps

+ r, com 0 < r < ps.

(k + 1) = ps

k = ps

#

#

" k + 1
ps
" k + 1
ps

+ r ⇒

+ r − 1.

Como 0 < r < ps, então 0 ≤ r − 1 < ps − 1. Assim, concluindo que,

#

" k
ps

=

#

" k + 1
ps

.

O Lema abaixo, pode ser entendido como um complemento do Lema 4.3.

Lema 4.4. Sejam p primo, s ∈ N e k ∈ N∪{0}, se ps | (k + 1), então

#

" k
ps

=

#

" k + 1
ps

−1.

Demonstração. Se ps | (k + 1), então ps ∤ k. Usando isso, temos

k = ps

k + 1 = ps

#

#

" k
ps
" k
ps

+ r, com 0 < r < ps ⇒

+ (r + 1) , com 1 < r + 1 ≤ ps.

Estudo da solução fixando p e n (Teorema de Legendre)

21

Como ps | (k + 1) implica que r + 1 = ps. Então,
#

k + 1 = ps

+ ps ⇒

k + 1 = ps

#

!

+ 1

⇒

" k
ps
 " k
ps
#
" k + 1
ps
" k + 1
ps

#

⇒

− 1.

#

" k
ps

+ 1 =

#

" k
ps

=

Teorema 4.5. (Teorema de Legendre) Sendo n, u ∈ N e p primo, tal que, pu ≤ n < pu+1,
então:

Ep (n!) =

#

" n
p

+

#

" n
p2

+ ... +

#

.

" n
pu

Demonstração. Fixando p primo, procedemos por indução sobre n.

#

" 1
p

Para n = 1 temos p0 ≤ 1 < p e Ep (1!) = 0 =
Para k ∈ N ∪ {0}, seja u, tal que, pu ≤ k < pu+1 e suponhamos como hipótese de

.

indução que

Ep (k!) =

#

" k
p

+ ... +

#

.

" k
pu

Avaliemos Ep ((k + 1)!). Uma vez que pu ≤ k < pu+1, temos que k + 1 ≤ pu+1.
Dividiremos a demostração em dua partes, que depende da divisibilidade pelas potências
de ps, s ∈ {1, 2, ..., u + 1}.

i) Se ps ∤ k + 1, para todo s = 1, 2, ..., u, u + 1, então pelo Lema 4.3,

#

" k
ps

=

" k + 1
ps

#
.

Além disso, Ep (k + 1) = 0, pois p ∤ k + 1.
Temos então,

#

Ep ((k + 1)!) = Ep (k + 1) + Ep (k!)
#
" k
pu
" k + 1
pu

" k
p
" k + 1
p

+ ... +

+ ... +

= 0 +

=

#

#

,

pois

#

" k + 1
pu

=

#

" k
pu

≥ 1 e

#

" k + 1
pu+1

=

#

" k
pu+1

= 0.

Portanto, nesse caso o resultado é valido para todo k + 1.
Se não acontece i), seja j ∈ {1, 2, ..., u, u + 1}, o maior índice, tal que, pj | k + 1.

Estudo da solução fixando p e n (Teorema de Legendre)

22

ii)-A Supondo j < u + 1, tomemos i ∈ {1, 2, ..., j} e i′ ∈ {j + 1, j + 2, ..., u + 1}.

Note que, pi′ ∤ k + 1. Assim, pelo Lema 4.3,

e, pelo Lema 4.4,

#

" k
pi′

=

#

" k + 1
pi′

.

#

" k
pi

=

#

" k + 1
pi

− 1

Além disso, Ep (k + 1) = j, pois pj é a maior potência, tal que, pj | k + 1.
Portanto,

Ep ((k + 1)!) = Ep (k + 1) + Ep (k!)
" k
#
pj

+ ... +

= j +

#

+

= j +

− 1 + ... +

− 1 +

= j − j +

#

+ ... +

+ ... +

#

" k
pu
" k + 1
pj+1

#

" k
pj+1
" k + 1
pj
" k + 1
pu

#

#

#

" k
p
" k + 1
p
" k + 1
p

#

+ ... +

#

" k + 1
pu

=

#

" k + 1
p

+ ... +

#

" k + 1
pu

.

Observe que

#

" k + 1
pu

=

#

" k
pu

≥ 1 e que

#

" k + 1
pu+1

=

#

" k
pu+1

= 0.

ii)-B Agora, se j = u + 1 e i ∈ {1, 2, ..., u, u + 1}, temos pelo Lema 4.4 que,
" k
pi

" k + 1
pi

− 1.

=

#

#

Além do que Ep (k + 1) = u + 1. Assim,

Ep ((k + 1)!) = Ep (k + 1) + Ep (k!)
" k
p2

= (u + 1) +

#

#

#

#

+

" k
p
" k + 1
p
" k + 1
p
" k + 1
p2

#

+

#

" k
pu+1

− 1 + ... +

+ ... +

" k
pu
#
" k + 1
p2
#

− 1 +

+

" k + 1
p2

+ ... +

#

+ ... +

#

" k + 1
pu

+

#

" k + 1
pu
" k + 1
pu+1

#

+ ... +

#

" k + 1
pu+1

.

= (u + 1) +

= (u + 1) +

+

=

=

#

#

" k + 1
p
" k + 1
p

#

" k + 1
pu
" k + 1
pu+1

+

− 1 +

#

" k + 1
pu+1

− 1

#

− (u + 1)

Estudo da solução fixando p e n (Teorema de Legendre)

23

#

Sendo,

" k
pu+1

" k + 1
pu+1
Portanto, nesse caso o resultado é valido para k + 1.

− 1, implicando que

" k + 1
pu+1

=

#

#

= 1 e

#

" k + 1
pu+2

= 0.

A seguir exploraremos uma outra forma apresentar o Teorema de Legendre. Nessa
nova abordagem tomaremos a decomposição p-ádica de α, bem como, alguns resultados
preliminares para melhor embasamento.

Proposição 4.6. Seja n = nupu + nu−1pu−1 + ... + n1p + n0, com 0 ≤ ns < p, s =
0, 1, 2, ..., u.

i) Se nl = p − 1, com l = 0, 1, 2, ..., v, v < u e nv+1 < p − 1, então n + 1 = nupu +

nu−1pu−1 + ... + pv+1 (nv+1 + 1).

ii) Se ns = p − 1, para todo s = 0, 1, 2, ..., u, então n + 1 = pu+1.

iii) Se n0 < p − 1, então n + 1 = nupu + nu−1pu−1 + ... + n1p + n′
0

, com n′
0

= n0 + 1.

iv) Se n0 > 0, então n − 1 = nupu + nu−1pu−1 + ... + n1p + n′
0

, sendo n′
0

= n0 − 1.

v) Se nl = 0, com l = 0, 1, 2, ..., v, v < u e nv+1 > 0, então n − 1 = nupu + nu−1pu−1 +

... + pv+1 (nv+1 − 1) + (p − 1) (pv + ... + p + 1).

Demonstração.

i) Tomando as hipóteses da Proposição, temos que:

n + 1 = nupu + nu−1pu−1 + ... + nv+1pv+1 + (p − 1) pv−1 + ... + (p − 1) p + (p − 1) + 1

= nupu + nu−1pu−1 + ... + nv+1pv+1 + (p − 1) (pv + ... + p + 1) + 1

= nupu + nu−1pu−1 + ... + nv+1pv+1 + (p − 1)

= nupu + nu−1pu−1 + ... + pv+1 (nv+1 + 1) .

!

  pv+1 − 1
p − 1

+ 1

ii) Tomando as hipóteses temos que,

= (p − 1) (cid:16)

n + 1 = (p − 1) pu + (p − 1) pu−1 + ... + (p − 1) p + (p − 1) + 1
pu + pu−1 + ... + p + 1(cid:17) + 1
 pu+1 − 1
p − 1

= (p − 1)

+ 1

!

= pu+1 − 1 + 1
= pu+1.

iii) Segue de forma trivial.

Estudo da solução fixando p e n (Teorema de Legendre)

24

iv) Segue de forma trivial.

v) Tomando a hipótese estabelecida:

n − 1 = nupu + nu−1pu−1 + ... + nv+1pv+1 − 1

= nupu + nu−1pu−1 + ... + pv+1 (nv+1 − 1 + 1) − 1
= nupu + nu−1pu−1 + ... + pv+1 (nv+1 − 1) + pv+1 − 1
= nupu + nu−1pu−1 + ... + pv+1 (nv+1 − 1) + (p − 1) (pv + ... + p + 1) .

Proposição 4.7. Seja n ∈ N e p um primo fixado, a decomposição de um n na forma
n = nupu + nu−1pu−1 + ... + n1p + n0, com 0 ≤ ns < p, sendo s = 0, 1, 2, ..., u, existe e é
única.

Demonstração.

□

Existência:
Provemos por indução. Fixado um p primo qualquer, quando n = 1, temos n0 = 1 e

nt = 0 para t ≥ 1.

Seja s = 1, 2, ..., u, n ∈ N e p primo, tomemos como hipótese de indução que n =

nupu + nu−1pu−1 + ... + n1p + n0, sendo 0 ≤ ns < p, s = 0, 1, 2, ..., u.

Pela Proposição 4.6, temos garantido a caracterização do sucessor de n, o que prova

sua existência.
Unicidade:
Provemos por indução.
Se n = 1, temos n0 = 1 e nt = 0, t ≥ 1.
Suponhamos que exista alguma outra decomposição com algum nt ̸= 0. Daí ntpt > 1

o que contradiz Pu

r=0 nrpr = 1.

Sendo k ∈ N suponhamos a unicidade para todo n ≤ k, assim k = nupu + nu−1pu−1 +

... + n1p + n0 de forma única, bem como os valores menores que k.

Avaliemos k + 1.
Suponhamos,

k + 1 = rlpl + rl−1pl−1 + ... + r1p + r0
k + 1 = smpm + sm−1pm−1 + ... + s1p + s0.

Daí, se r0 > 0 e s0 > 0 temos pela Proposição 4.6 item iv) que

k = rlpl + rl−1pl−1 + ... + r1p + r0 − 1
k = smpm + sm−1pm−1 + ... + s1p + s0 − 1.

Como, por hipótese, a representação de k é única.

Estudo da solução fixando p e n (Teorema de Legendre)

25

r0 − 1 = s0 − 1 ⇒ r0 = s0.
r1p = s1p ⇒ r1 = s1.

...

rlpl = smpm ⇒ rl = sm ⇒ l = m.

Se r0 > 0 e s0 = 0, temos pela Proposição 4.6 no item iv) que k = rlpl + rl−1pl−1 +
... + r1p + r0 − 1 e pelo item v) que o termo independente de k é p − 1. Daí, segue que
r0 − 1 = p − 1 o que é uma contradição, pois 0 < r0 < p.

Caso em que r0 = 0 e s0 > 0 é análogo.
Por fim, se rl = 0, com l = 0, 1, 2, ..., v e st = 0, com t = 0, 1, 2, ..., v′, temos pela

Proposição 4.6 item v), que

k = rlpl + rl−1pl−1 + ... + pv+1 (rv+1 − 1) + (p − 1) (pv + ... + p + 1)
k = smpm + sm−1pm−1 + ... + pv′+1 (sv′+1 − 1) + (p − 1) (cid:16)

pv′ + ... + p + 1(cid:17)

Como k tem decomposição única segue que v = v′, portanto,

pv+1 (rv+1 − 1) = ps+1 (sv′+1 − 1) ⇒ rv+1 = sv′+1.
rv+2pv+2 = sv+2pv+2 ⇒ rv+2 = sv+2.

...

rlpl = smpm ⇒ rl = sm.

□

Definição 4.8. Seja n ∈ N, p primo, temos n = nupu + nu−1pu−1 + ... + n1p + n0, com
s = 1, 2, ..., u e 0 ≤ ns < p, como a forma p-ádica de n.

Proposição 4.9. Se n = nupu + nu−1pu−1 + ... + n1p + n0, com p primo e 0 ≤ ns < p
sendo s = 1, 2, ..., u, então n ≥ (nu + nu−1 + ...n1 + n0).

Demonstração. Provemos por indução. Tendo n = 1, então n0 = 1 ficando provado.

Supondo com hipótese de indução que para algum k ∈ N temos k = kupu + ku−1pu−1 +
... + k1p + k0, com 0 ≤ ks < p, s = 0, 1, 2, ..., u e k ≥ ku + ku−1 + ... + k1 + k0. Avaliando
para o caso k + 1 temos da Proposição 4.6 que

i) k + 1 = kupu + ku−1pu−1 + ... + k1p + k0 + 1, quando k0 < p − 1.

ii) k + 1 = kupu + ku−1pu−1 + ... + pv+1 (kv+1 + 1), quando k0 = k1 = ... = kv−1 = kv =

p − 1 e kv+1 < p − 1, para algum v < u.

iii) k + 1 = pu+1, quando k0 = k1 = ... = ku−1 = ku = p − 1.

Estudo da solução fixando p e α

26

No caso i), temos da hipótese de indução que k ≥ ku + ku−1 + ... + k1 + k0, implicando

que k + 1 ≥ ku + ku−1 + ... + k1 + k0 + 1.

Caso aconteça ii), temos da hipótese de indução

k ≥ ku + ku−1 + ... + kv+1 + (v + 1) (p − 1) ⇒

k + 1 ≥ ku + ku−1 + ... + kv+1 + (v + 1) (p − 1) + 1 ≥ ku + ku−1 + ... + kv+1 + 1.

Por fim, o caso iii) é trivial pois k + 1 > 1.

Teorema 4.10. Seja n ∈ N, p primo, n = nupu+nu−1pu−1+...+n1p+n0, com 0 ≤ ns < p,
para s = 1, 2, ..., u. Então,

Ep (n!) = n − (n0 + n1 + ...nu−1 + nu)

p − 1

.

Demonstração. Segue das hipóteses que

#

#

" n
p
" n
p2

...
#

" n
pu

= nupu−1 + nu−1pu−2 + ... + n1

= nupu−2 + nu−1pu−3 + ... + n2

= nu.

Tomando o Teorema de Legendre (4.5), temos:

Ep (n!) =

#

" n
p

+

#

" n
p2

+ ... +

#

" n
pu

= nu · pu−1 + nu−1 · pu−2 + ... + n1 + nu · pu−2 + nu−1·u−3 +... + n2 + ... + nu
pu−2 + pu−3 + ... + p + 1(cid:17) + ... + n1
(cid:16)
= nu

(cid:16)

pu−1 + pu−2 + ... + p + 1(cid:17) + nu−1
pu − 1
p − 1

pu−1 − 1
p − 1

+ nu−1 ·

p − 1
p − 1

= nu ·
= nu · pu + nu−1 · pu−1 + ... + n1 · p + n0 − (nu + nu−1 + ... + n1 + n0)
p − 1

+ ... + n1 ·

= n − (n0 + n1 + ... + nu−1 + nu)
p − 1

.

Observe que a Proposição 4.9 garante que o numerador não é negativo.

4.2 Estudo da solução fixando p e α

Para uma melhor organização tome a tabela que segue. Nela estão destacados os

principais resultados abordados nesse momento.

Estudo da solução fixando p e α

27

Tabela 4.3: Resultados principais da sub-seção 4.2.

Estudo
Existência

Resultado
Proposição 4.11
Caracterização Corolário 4.12

Fonte: Autoria nossa.

Tomemos Ep (n!) = α, com p e α previamente fixados. Portanto, temos n, como
variável livre e desejamos determinar possíveis expressões de n que resolvam a equação.

Proposição 4.11. Fixados α ∈ N ∪ {0} e p primo,

i) se α = 0, então a equação possui exatamente p − 1 soluções distintas.

ii) se α > 0 e existir n′ ∈ N, tal que, Ep (n′!) = α, então a equação possui exatamente

p soluções naturais distintas, sendo a menor delas múltipla de p.

Demonstração.

i) Se α = 0, então Ep (n!) = α para n = 1, 2, ..., p − 1.Além disso, se n ≥ p, então

Ep (n!) > α. Logo, existem p − 1 soluções distintas.

ii) Como Ep (n!) = α possui solução natural temos pelo Princípio da Boa Ordenação
(PBO) que o conjunto de soluções da equação possui menor elemento n0. Assim,
como Ep (n0!) = α, temos que p | n0. De fato, se p ∤ n0, temos Ep ((n0 − 1)!) =
Ep (n0!), o que contradiz n0 ser o menor elemento. Temos então que p | n0.
Daí, para 1 ≤ m ≤ p − 1, temos que p ∤ n0 + m. Portanto, a quantidade de fatores
p em (n0 + m)! é igual à quantidade em n0!, isto é,

Ep (n0!) = Ep ((n0 + 1)!) = ... = Ep ((n0 + p − 1)!) = α.

Observe que se n ≥ n0 + p, Ep (n!) > α. Portanto, n0, n0 + 1, ..., n0 + p − 1 são as
únicas soluções da equação.

□

Corolário 4.12. Seja α ∈ N, p primo fixos, se existir solução para Ep (n!) = α, então
escrevendo n = mp + r, com 0 ≤ r < p, todas as soluções da equação são dadas por
mp, mp + 1, ..., mp + p − 1, isto é

Ep ((mp)!) = Ep ((mp + 1)!) = ... = Ep ((mp + p − 1)!) = α.

Demonstração. Basta observar que a demonstração do item ii) da Proposição 4.11, onde
menor solução é um múltiplo de p.

Prosseguindo, abordaremos dois algoritmos que descrevem o processo para se obter o
menor n natural que satisfaz a equação.

Estudo da solução fixando p e α

28

4.2.1 Algoritmo p-ádica

Baseado no livro de Aritmética da coleção do PROFMAT, escrito por (HEFEZ, 2016)1,
esse algoritmo descreve uma forma para aferirmos a existência ou não de solução para
equação, bem como, caso exista, quem são os naturais que á satisfazem. Além do mais,
essa seção apresenta detalhamentos ausentes no livro referenciado, deixando as condições
teóricas do algoritmo evidentes. Assim, trazendo maior solidez para as etapas em que o
algoritmo é desenvolvido.

Para iniciarmos, seja m ∈ N, tal que,

m = mupu + mu−1pu−1 + ... + m1p + m0,

sendo 0 ≤ ms < p, para s =, 1, 2, ..., u, com mu ̸= 0, buscando soluções do tipo mp

Lema 4.13. Sejam α ∈ N e p primo, fixos. Tomando m ∈ N, onde m = mupu +
mu−1pu−1 + ... + m1p + m0 com 0 ≤ ms < p, para s = 0, 1, 2, ..., u e mu ̸= 0; α =
αtpt + αt−1pt−1 + ... + α1p + α0, com 0 ≤ αl < p, para l = 0, 1, 2, ..., t e αt
̸= 0, se
Ep ((mp)!) = α, então

α (p − 1) = mu

(cid:16)

pu+1 − 1(cid:17) + mu−1 (pu − 1) + ... + m0 (p − 1) .

Além disso, t ≥ u.

Demonstração. Dado que mp é solução e aplicando o Teorema 4.10, temos que

α = Ep ((mp)!) = mp − (m0 + m1 + ...mu−1 + mu)

p − 1

⇒

α (p − 1) = mp − (m0 + m1 + ...mu−1 + mu) ⇒
α (p − 1) = mupu+1 + mu−1pu + ... + m1p2 + m0p − mu − mu−1 − ... − m1p − m0 ⇒
α (p − 1) = mu

pu+1 − 1(cid:17) + mu−1 (pu − 1) + ... + m0 (p − 1) .

(cid:16)

Para provar que t ≥ u, aplica-se a igualdade (pn+1 − 1) = (p − 1) (pn + pn−1 + ... + p + 1),

obtendo

α = mu

(cid:16)

pu + pu−1 + ... + p + 1(cid:17) + mu−1

(cid:16)

pu−1 + pu−2 + ... + p + 1(cid:17) + ... + m1 (p − 1) + m0.

Logo, pu está na decomposição de α e disto concluímos que t ≥ u.

Lema 4.14. Seja p primo, se 0 ≤ ms < p, para s = 1, 2, ..., u − 1, então mu−1 (pu − 1) +
... + m0 (p − 1) < pu+1 − 1.

Demonstração. Tomando que 0 ≤ ms < p, para s = 1, 2, ..., u − 1, temos ms (ps+1 − 1) ≤
(p − 1) (ps+1 − 1), portanto

1Matemático egípcio, naturalizado brasileiro, que atua como professor titular no Instituto de Mate-

mática da Universidade Federal Fluminense.

Estudo da solução fixando p e α

29

mu−1 (pu − 1) + ... + m0 (p − 1) ≤ (p − 1) (pu − 1) + ... + (p − 1) (p − 1) ⇒
mu−1 (pu − 1) + ... + m0 (p − 1) ≤ (p − 1) (cid:16)
⇒
mu−1 (pu − 1) + ... + m0 (p − 1) < (p − 1) (cid:16)

⇒

(cid:17)
pu + pu−1 + ... + p + 1 − u
pu + pu−1 + ... + p + 1(cid:17)
!
  pu+1 − 1
p − 1

⇒

mu−1 (pu − 1) + ... + m0 (p − 1) < (p − 1)

mu−1 (pu − 1) + ... + m0 (p − 1) < pu+1 − 1.

Corolário 4.15. Tomando as hipóteses do Lema 4.13 temos que mu =
α ≥ mu (pu + pu−1 + ... + p + 1).

#

" α (p − 1)
pu+1 − 1

e

Demonstração. Usando o Lema 4.13, temos

α (p − 1) = mu

(cid:16)

pu+1 − 1(cid:17) + mu−1 (pu − 1) + ... + m0 (p − 1) ⇒

α (p − 1)
(pu+1 − 1)

= mu +

1
(pu+1 − 1)

Tomando o Lema 4.14 temos que

(mu−1 (pu − 1) + ... + m0 (p − 1)) .

(4.1)

0 ≤

1
(pu+1 − 1)

(mu−1 (pu − 1) + ... + m0 (p − 1)) < 1.

Portanto, a parte inteira de ambos os lados da equação (4.1) mu =

particular

" α (p − 1)
pu+1 − 1

#
, em

mu ≤

α (p − 1)
pu+1 − 1 ⇒

α ≥ mu

(cid:16)

pu + pu−1 + ... + p + 1(cid:17)

.

Proposição 4.16. Fixados p primo e α ∈ N, tome u ∈ N, tal que, mu =

#

" α (p − 1)
pl − 1

e

= 0, para l > u + 1. Então m = mupu + mu−1pu−1 + ... + m1p + m0, para
0 ≤ ms < p, s = 1, 2, ..., u, é solução de Ep ((mp)!) = α se, e só se, m′ = m − mupu é
solução de Ep (m′!) = α′, com α′ = α − mu (pu + pu−1 + ... + p + 1) α′ ≥ 0.

#

" α (p − 1)
pu+1 − 1

̸= 0

Demonstração. Observe inicialmente, que o Corolário 4.15 garante que α′ ≥ 0 e conse-
quentemente que a equação Ep (m′!) = α′ é bem definida.

Estudo da solução fixando p e α

30

Como

#

" α (p − 1)
p − 1

= α ̸= 0 e a sequência xn = α (p − 1)
pn+1 − 1

existirá mu nas condições exigidas. Note que, utilizando o Teorema 4.10,

converge para zero, sempre

Ep ((mp)!) = Ep (((mupu + m′) p)!)

=

(mupu + m′) p − (mu + mu−1 + ... + m1 + m0)
p − 1

= m′p − (mu−1 + ... + m1 + m0)
p − 1
(cid:16)
= Ep ((m′p)!) + mu
= Ep ((m′p)!) + α − α′.

+ mu (pu+1 − 1)
p − 1
pu + pu−1 + ... + p + 1(cid:17)

Isto é,

Ep ((mp)!) = Ep ((m′p)!) + α − α′.

Logo, Ep ((mp)!) = α se, e só se, Ep ((m′p)!) = α′.

Proposição 4.17. Tomando as notações do Lema 4.13 e α = pt + pt−1 + ... + p, com
t > 0 temos que a equação não possui solução.

Demonstração. Segue do Lema 4.13 e do fato que nj ≤ p − 1 que,

α (p − 1) ≤ (p − 1) (cid:16)

pu+1 + pu + ... + p + 1 − (u + 1)(cid:17)

⇒

α ≤ pu+1 + pu + ... + p + 1 − (u + 1) < pu+1 + pu + ... + p + 1 ⇒

pt + pt−1 + ... + p + 1 < pu+1 + pu + ... + p + 1 ⇒
t < u + 1.

Como t ≥ u, chega-se a única possibilidade t = u daí,

mu =

#

" α (p − 1)
pu+1 − 1

=

=

" (pu + pu−1 + ... + p) (p − 1)
pu+1 − 1
#

#

" pu+1 − p
pu+1 − 1

= 0.

O que é uma contradição pois mu ̸= 0.

Por fim, note que o Corolário 4.15 garante que a nova constante α′ nunca será negativa
e a quantidade de reduções a problemas equivalentes são finitas, uma vez a cada passo,
tem-se α′ < α, levando a uma sequência α > α′ > ... > α(h) > α(h+1) = 0.

Estudo da solução fixando p e α

31

Algoritmo 1. Para resolver Ep (n!) = α, com p, primo, e α ∈ N ∪ {0} fixados pre-
viamente, inicia-se buscando m = mupu + mu−1pu−1 + ... + m1p + m0 com mu ̸= 0 e
0 ≤ ms < p para s = 1, 2, ..., u, tal que, Ep ((mp)!) = α. Para isso, seguimos os passos
abaixo:

1º: Decomponha α na forma p-ádica e avalie as situações abaixo:

i) Se α respeita a Proposição 4.17 segue que a equação não possui solução.
ii) Se não ocorre i), então tome a Proposição 4.16 e reduza para o caso Ep ((m′p)!) =

α′.

2º: Tomando Ep ((m′p)!) = α′ reinicie os passos do algoritmo.

Repita os passos do algoritmo até que:

1: Encontre-se, para alguma redução, um valor de α(h), que atenda a decomposição

exposta na Proposição 4.17.

2: Encontre-se uma redução h, tal que, α(h) = 0.

Ao concluir o processo tem-se os coeficientes mu, mu−1, ..., m1 e m0 e, consequente-

mente, encontra-se m = mupu + mu−1pu−1 + ... + m1p + m0.

Visualmente podemos expor as condições acima no fluxograma que segue.

Figura 4.1: Fluxograma relacionado aos passos lógicos interpretados no algoritmo apresentado
por Abramo Hefez, encontrado no Livro Aritmética da coleção PROFMAT.

Fonte: Autoria nossa.

A seguir tomemos os exemplos que seguem afim de mostrar na prática o algoritmo

exposto.

Estudo da solução fixando p e α

32

Exemplo 4.18. Encontre os valores de n que satisfazem E7 (n!) = 25.

Solução.
1º Passo: Decomponha α

25 = 3 · 7 + 4

2º Passo: Existência de solução
Como 3 · 7 + 4 ̸= 11, então temos solução.

3º Passo: Encontrando o maior coeficiente

m1 =

#

" 25 (7 − 1)
72 − 1

= 3.

4º Passo: Construção do caso equivalente
Como α′ = 25 − 3 (7 + 1) = 1, temos que E7 (n!) = 25 é equivalente a E7 (n′!) = 1. E

guardamos o valor µ1 = 3 · 7 = 21.

Repetindo os processos para o caso E7 (n′!) = 1.

5º Passo: Decomponha α′

1 = 1 · 110

6º Passo: Existência de solução
Como 1 · 110 ̸= 11, então temos solução.

7º Passo: Encontrando o maior coeficiente

m0 =

#

" 1 (7 − 1)
7 − 1

= 1.

8º Passo: Construção do caso equivalente
Como α′′ = 1 − 1 (1) = 0, então guardamos o valor µ2 = 1.

Assim, concluímos que m = 21 + 1 = 22. Portanto, mp = 154 é a menor solução da

equação, concluindo que o conjunto

{154, 155, 156, 157, 158, 159, 160}

representa todas soluções.

Exemplo 4.19. Encontre os valores de n que satisfazem E11 (n!) = 855.

♢

Estudo da solução fixando p e α

33

Solução.
1º Passo: Decomponha α

855 = 7 · 112 + 8

2º Passo: Existência de solução
Como 7 · 112 + 8 ̸= 112 + 11 = 132, então temos solução.

3º Passo: Encontrando o maior coeficiente

m2 =

" 855 (11 − 1)
113 − 1

#

= 6.

4º Passo: Construção do caso equivalente
Como α′ = 855 − 6 (112 + 11 + 1) = 57, temos que E11 (n!) = 855 é equivalente a

E11 (n′!) = 57. E guardamos o valor µ1 = 6 · 112 = 726.

Repetindo os processos para o caso E11 (n′!) = 57.

5º Passo: Decomponha α′

57 = 5 · 11 + 2

6º Passo: Existência de solução
Como 5 · 11 + 2 ̸= 11, então temos solução.

7º Passo: Encontrando o maior coeficiente

m1 =

#

" 57 (11 − 1)
112 − 1

= 4.

8º Passo: Construção do caso equivalente
Como α′′ = 57 − 4 (11 + 1) = 9, temos que E11 (n′!) = 57 é equivalente a E11 (n′′!) = 9.

E guardamos o valor µ2 = 4 · 11 = 44.

Repetindo os processos para o caso E11 (n′′!) = 9.

9º Passo: Decomponha α′′

9 = 9 · 110

10º Passo: Existência de solução
Como 9 ̸= 110 = 1, então temos solução.

Estudo da solução fixando p e α

34

11º Passo: Encontrando o maior coeficiente

m0 =

#

" 9 (11 − 1)
111 − 1

= 9.

12º Passo: Construção do caso equivalente
Como α′′′ = 9 − 9 = 0, então guardamos µ3 = 9 · 110 = 9

Assim, concluímos que m = 726 + 44 + 9 = 779. Portanto, mp = 8569 é a menor

solução da equação, concluindo que o conjunto

{8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579}

representa todas soluções.

Exemplo 4.20. Encontre os valores de n que satisfazem E3 (n!) = 92.

Solução.
Iniciemos, tomando que 92 = 34 + 32 + 2, portanto α não possui a decomposição igual

a Proposição 4.17.

Tomando a Proposição 4.16, temos que

♢

m4 =

#

" 92 (3 − 1)
35 − 1

= 0.

Reduzindo o índice do coeficiente para 3, temos

m4 =

#

" 92 (3 − 1)
34 − 1

= 2.

E, que α′ = 92 − 2 (33 + 32 + 3 + 1) = 12. Portanto, reduzimos nosso problema para

o caso E3 ((3m′)!) = 12.

Tomando 12 = 32 + 3, portanto α possui a decomposição igual a Proposição 4.17,

concluindo que não existe solução.

♢

4.2.2 Algoritmo das matrizes, construído pelos autores

A partir de agora, apresentaremos um algoritmo diferente do apresentado por (HEFEZ,
2016) no livro Aritmética da coleção PROFMAT e, cuja parte teórica foi refinada nesse
trabalho. Apesar de não sabermos se consiste em um método inédito, vale ressaltar que
se trata de uma construção independente desenvolvida pelos autores, sendo que todos os
resultados foram modelados ao decorrer da construção do trabalho.

Para tanto, tomemos o mesmo principio utilizado no Algoritmo p-ádica, onde focamos
em encontrar o menor natural solução da equação. Para isso, iniciemos com a definição
abaixo.

Estudo da solução fixando p e α

35

Definição 4.21. Tomando p primo, seja M 1 a matriz p × p, formada pelos primeiros p2
múltiplos de p ordenados de forma crescente e dispostos em linhas, M 2 a matriz formada
pelos p2 seguintes, da mesma forma que a anterior, e assim sucessivamente, isto é,









M 1 =

p
p2 + p
...

p2
· · ·
· · · 2p2
...
. . .
p2 (p − 1) + p p2 (p − 1) + 2p · · ·
p3

2p
p2 + 2p
...









;









M 2 =

p3 + p
p3 + p2 + p
...

p3 + p2
· · ·
· · · p3 + 2p2
. . .
p3 + p2 (p − 1) + p p3 + p2 (p − 1) + 2p · · ·

p3 + 2p
p3 + p2 + 2p
...

...
2p3









E Lk a matriz p × p, onde lk
ij

= Ep

(cid:16)

mk
ij

(cid:17), onde mk

ij

é elemento da matriz M k.

Observação 4.22. Temos para k = 1 a matriz M 1, cujos elementos são os p2 primeiros
múltiplos de p, começando em p e terminando em p3. Já para k = 2, temos a matriz
M 2, formada por p2 múltiplos de p, começando em p3 + p e terminando em 2p3. E
recorrentemente para os demais valores de k.

De forma genérica estamos tomando que,

M k =









11 mk
mk
12
21 mk
mk
22
...
...
p1 mk
mk
p2

· · · mk
1p
· · · mk
2p
...
. . .
· · · mk
pp









⇒ Lk =











(cid:16)

(cid:16)

Ep
Ep

(cid:16)

Ep

(cid:17)

(cid:17)

(cid:17)

mk
11
mk
21
...
mk
p1

(cid:16)

(cid:16)

Ep
Ep

(cid:16)

Ep

mk
12
mk
22
...
mk
p2

(cid:17)

(cid:17)

(cid:17)

· · · Ep
· · · Ep
. . .
· · · Ep

(cid:16)

(cid:16)

(cid:16)

mk
1p
mk
2p
...
mk
pp

(cid:17)

(cid:17)

(cid:17)











.

Exemplo 4.23. Para p = 3, temos:

M 1 =

M 2 =

M 3 =
















3
9
6
12 15 18
21 24 27

30 33 36
39 42 45
48 51 54

57 60 63
66 69 72
75 78 81


 ⇒ L1 =








 ⇒ L2 =








 ⇒ L3 =







M 4 =






90
87
84
93
99
96
102 105 108


 ⇒ L4 =






















=

=

=








E3 (3) E3 (6) E3 (9)
E3 (12) E3 (15) E3 (18)
E3 (21) E3 (24) E3 (27)
E3 (30) E3 (33) E3 (36)
E3 (39) E3 (42) E3 (45)
E3 (48) E3 (51) E3 (54)
E3 (57) E3 (60) E3 (63)
E3 (66) E3 (69) E3 (72)
E3 (75) E3 (78) E3 (81)
E3 (84) E3 (87) E3 (90)
E3 (93) E3 (96) E3 (99)
E3 (102) E3 (105) E3 (108)
























;

;

;

1 1 2
1 1 2
1 1 3

1 1 2
1 1 2
1 1 3

1 1 2
1 1 2
1 1 4







=




1 1 2
1 1 2
1 1 3



 .

Estudo da solução fixando p e α

36

Observação 4.24. No exemplo 4.23, note que:

que coincide com a soma dos elementos destacados na matriz

E3 (9!) = E3 (9) + E3 (6) + E3 (3) = 4,

L1 =






E3 (3) E3 (6) E3 (9)
E3 (12) E3 (15) E3 (18)
E3 (21) E3 (24) E3 (27)






=






1 1 2
1 1 2
1 1 3



 .

E

E3 (21!) = E3 (21) + E3 (18) + E3 (15) + E3 (12) + E3 (9) + E3 (6) + E3 (3) = 9,

o que também coincide com a soma dos elementos destacados na matriz abaixo

L1 =






E3 (3) E3 (6) E3 (9)
E3 (12) E3 (15) E3 (18)
E3 (21) E3 (24) E3 (27)











=

1 1 2
1 1 2
1 1 3



 .

Logo, o somatório de alguns elementos da matriz L1 ordenados de forma crescente e
dispostos em linhas, parece coincidir com o cálculo da E3 (n!) sendo quando n é múltiplo
de 3.

Usando o que já esta definido vamos em busca de uma caracterização plena dos ele-

.

mentos de mk
ij
Proposição 4.25. Tomando p primo, k = 2, 3, 4, ... e duas matrizes consecutivas temos
que

mk
ij

= mk−1
ij

+ p3,

com i, j = {1, 2, ..., p}.
Demonstração. Tomando a Definição 4.21 note que sempre existirão p2 múltiplos de p
entre mk
ij

, implicando que mk

= p · p2. Portanto

e mk−1
ij

ij − mk−1
mk
ij

ij
= mk−1
ij

+ p3.

Proposição 4.26. Tomando p primo e i, j = 1, 2, ..., p, temos que os elementos de M 1
são caracterizados por m1
ij
Demonstração. Tomando i = j = 1, temos que m1
= p, conforme a Definição 4.21.
11
Agora, por recorrência suponhamos que para algum i = 2, 3, ..., p e j = 1, 2, ..., p − 1,
temos valido m1
ij

= (i − 1) p2 + jp. Logo,

= (i − 1) p2 + jp.

m1
ij
m1

+ p = (i − 1) p2 + jp + p ⇒
= (i − 1) p2 + (j + 1) p.

i(j+1)

Por fim, por recorrência suponhamos que para algum i = 2, 3, ..., p − 1 e j = p temos

valido m1
ip

= (i − 1) p2 + p2. Logo,

+ p = (i − 1) p2 + p2 + p ⇒

m1
ip
m1

= ip2 + p.

(i+1)1

Estudo da solução fixando p e α

37

Lema 4.27. Tomando M k, tal que, k ∈ N e i, j = 1, 2, ..., p, com p primo, temos que

mk
ij

= (i − 1) p2 + jp + (k − 1) p3.

Demonstração. Tomando a Proposição 4.25, podemos dispor que:

= m1
ij
= m1
ij
= m2
ij

m1
ij
m2
ij
m3
ij

...

+ p3
+ p3

mk−1
ij
mk
ij

= mk−2
ij
= mk−1
ij

+ p3
+ p3

Somando todos os elementos do membro da direita e todos os elementos do membro da
esquerda, temos que:

k
X

s=1
k−1
X

s=1

ms
ij

= m1
ij

+

ms
ij

= m1
ij

+

k−1
X

s=1
k−1
X

s=1

k
X

s=1

ms

ij −

ms
ij

+ (k − 1) p3 ⇒

ms
ij

+ (k − 1) p3 −

k−1
X

s=1

ms

ij ⇒

mk
ij

= m1
ij

+ (k − 1) p3.

Tomando a Proposição 4.26 concluímos que,

mk
ij
mk
ij

= m1
+ (k − 1) p3 ⇒
ij
= (i − 1) p2 + jp + (k − 1) p3.

Proposição 4.28. Tomando n ∈ N, múltiplo de p, a decomposição

n = (i − 1) p2 + jp + (k − 1) p3,

com i, j = 1, 2, ..., p e k ∈ N existe e é única.

Demonstração.

A existência segue do Lema 4.27, uma vez que as matrizes M k contém todos os múl-

tiplos de p.

Tomemos que n admita duas formas de decomposição, tal que,

n = (i − 1) p2 + jp + (k − 1) p3
n = (i′ − 1) p2 + j′p + (k′ − 1) p3.

Estudo da solução fixando p e α

38

Então,

0 = (i − i′) p2 + (j − j′) p + (k − k′) p3 ⇒
0 = j − j′ + (i − i′) p + (k − k′) p2 ⇒

j′ − j = (i − i′) p + (k − k′) p2 ⇒

p | (j′ − j) .

Dado que j, j′ = 1, 2, ..., p, temos que 0 ≤ |j′ − j| ≤ p − 1. Logo,

p | (j′ − j) ⇒
j′ = j.

Assim, tendo j′ = j e dispondo de raciocínio análogo temos que 0 ≤ |i′ − i| ≤ p − 1,

logo i′ = i. Por fim, dispondo que j′ = j e i′ = i, temos

0 = (k − k′) p ⇒
0 = k − k′ ⇒
k′ = k.

Ficando devidamente provada a unicidade.

□

Corolário 4.29. Fixos p primo e α ∈ N, se existir n′!, tal que, Ep (n′!) = α, então
!(cid:17) = α, sendo mk
o menor natural solução da equação
existem i, j e k, tais que, Ep
Ep (n!) = α.

mk
ij

(cid:16)

ij

Demonstração. Segue do Corolário 4.12, que a menor solução é um múltiplo de p, logo o
Lema 4.27 e a Proposição 4.28 garantem que tal múltiplo coincide com algum mk
ij

.

Proposição 4.30. Fixado p primo e dados i, j ∈ {1, 2, ..., p} e k ∈ N, tem-se

Ep

(cid:16)

mk
ij

!(cid:17) =

r
X

l=1

Ep (lp) ,

sendo r o natural, tal que, mk
ij

= r · p.

Demonstração. Tomando o item P1 da Proposição 2.13 note que

Ep

(cid:16)

mk
ij

!(cid:17) = Ep (1) + Ep (2) + ... + Ep

(cid:16)

(cid:17)

.

mk
ij

Tomando o item i da Observação 2.4, concluímos que

Ep

(cid:16)

mk
ij

!(cid:17) = Ep (p) + Ep (2p) + ... + Ep

(cid:16)

(cid:17) =

mk
ij

r
X

l=1

Ep (lp) ,

sendo r o natural, tal que, mk
ij

= r · p.

Estudo da solução fixando p e α

39

Vejamos agora um resultado que fornece os valores dos elementos da matriz Lk, mostrando
que a lei de formação sempre terá um comportamento parecido com o visto no Exemplo
4.23.

Proposição 4.31. Tomando p primo, i, j = 1, 2, ..., p e k ∈ N. Se mk
ij
(k − 1) p3, temos três possíveis casos:

= (i − 1) p2 + jp +

Ep

(cid:16)

mk
ij

(cid:17) =






1, se 1 ≤ i ≤ p e 1 ≤ j < p.
2, se 1 ≤ i ≤ p − 1 e j = p.
3 + Ep (k) , se i, j = p.

Demonstração. Seja o caso em que 1 ≤ i ≤ p e 1 ≤ j < p. Como 1 ≤ j < p implica que
p ∤ j e, por consequência, p ∤ (j + p (i − 1) + p2 (k − 1)).

= jp+p2 (i − 1)+p3 (k − 1) = p (j + p (i − 1) + p2 (k − 1)),

Tomando o Lema 4.27 mk
ij
(cid:17) = 1.

(cid:16)

então Ep

mk
ij

Os demais casos seguem de forma análoga ao descrito acima, no último caso é neces-

sário escrever Ep (kp3) = 3 + Ep (k).

Assim, caracterizamos qualquer matriz de ordem k como exposto abaixo.

Corolário 4.32. Seja k ∈ N e p primo, temos que












Lk =

...

1 1 · · · 1
1 1 · · · 1
...
...
. . .
1 1 · · · 1
1 1 · · · 1 3 + Ep (k)

2
2
...
2












Definição 4.33. Tome a matriz modelada no Corolário 4.32. Definimos Lk
ij
elementos lk
e todos elementos da linha i tal que j′ ≤ j.

a soma dos
i′j′, de forma que, sejam somados todos elementos das linhas i′, tal que, i′ < i

Exemplo 4.34. Tomando p = 3 e k = 6, temos que

L6 =






1 1 2
1 1 2
1 1 4



 .

Portanto, L6
13

= 1 + 1 + 2 = 4. E, para a mesma matriz,

L6 =






1 1 2
1 1 2
1 1 4



 .

Logo, L6
31

= 2 (1 + 1 + 2) + 1 = 9.

Corolário 4.35. Tomando Lk, com k ∈ N, p primo e i, j = 1, 2, ..., p, temos que

Estudo da solução fixando p e α

i) Se i < p, desde que não ocorra, simultaneamente, i = p − 1 e j = p, então Lk

(i+1)j

Lk
ij

+ (p + 1).

ii) Se i = p − 1 e j = p, então Lk

(i+1)j

= Lk
ij

+ (p + 2) + Ep (k).

40

=

Demonstração. Para o caso i), pelo Corolário 4.32, temos Lk
= Lk
Lk
pp − Lk
ij
implicando que Lk

+ (p + 1). Para o caso ii) temos que Lk

+ (p + 2) + Ep (k).

(i+1)j

= Lk
ij

(i+1)j

(i+1)j − Lk
ij

= p + 1, portanto,
= p − 1 + 3 + Ep (k),

(p−1)p

Proposição 4.36. Tomando p primo e i, j = 1, 2, ..., p, desde que i e j não valham p
simultaneamente, e k ∈ N, temos que

Lk
ij

= i (p + 1) + (p + 1 − j)

#

 " j
p

!

− 1

Demonstração. Tomando i = 1 e j < p temos que

Lk
ij

= j = 1 (p + 1) + (p + 1 − j)

#

 " j
p

!

− 1

Suponhamos como hipótese de indução que para um i′ < p temos Lk
i′j

= i′ (p + 1) +

(p + 1 − j)

#

 " j
p

!

− 1

e usando o item i) do Corolário 4.35 temos que,

Lk

(i′+1)j

= Lk
i′j

+ (p + 1) = i′ (p + 1) + (p + 1 − j)

#

 " j
p

!

− 1

+ (p + 1) ⇒

Lk

(i′+1)j

= (i′ + 1) (p + 1) + (p + 1 − j)

#

 " j
p

!

− 1

.

Tomando j = p, dado i < p temos do Corolário 4.32 que

Lk
ip

= i (p + 1) = i (p + 1) + (p + 1 − p)

#

 " p
p

!

− 1

Agora, tomando i = p e j < p, temos do Corolário 4.32 que existem p − 1 linhas com

soma p + 1 e na linha p temos j termos unitários.

= (p − 1) (p + 1) + j = p (p + 1) + (p + 1 − j)

Logo, Lk
pj
Assim, concluímos ser válido.

#

 " j
p

!
.

− 1

Sobre a Proposição 4.36 notamos duas circunstâncias interessantes. Essas estão regis-

tradas e discutidas no que segue abaixo.

Corolário 4.37. Considerando as hipótese da Proposição 4.36, temos:

i) Se j = p, então Lk
ip

= i (p + 1).

ii) Se j < p, então Lk
ij

= (i − 1) (p + 1) + j.

Estudo da solução fixando p e α

41

Quanto a soma de uma matriz, de forma integral Lk, fica evidente que o valor de k
= 3 + Ep (k). Assim, iniciaremos a

influenciará. Isso por que, temos que o elemento lk
pp
discussão a cerca desses possíveis resultados.

Definição 4.38. Tomando k ∈ N e a matriz caracterizada no Corolário 4.32, definimos
.
Sk como a soma de todos os termos da matriz Lk. Particularmente, note que Sk = Lk
pp

Proposição 4.39. Tomando k ∈ N e p primo, temos que Sk = p2 + p + 1 + Ep (k).

Demonstração. Tomando que Sk = Lp(p−1) + lk
pp

e a Proposição 4.36 temos que,

Sk = p (p + 1) + (p + 1 − p + 1)

= p (p + 1) − 2 + Ep (k) + 3
= p2 + p + 1 + Ep (k) .

#

 " p − 1
p

!

− 1

+ Ep (k) + 3

Lema 4.40. Seja p primo, k ∈ N e u ∈ N, tais que, pu ≤ k < pu+1 temos,

ou

Sl = k

(cid:16)

p2 + p + 1(cid:17) + Ep (k!) ,

k
X

l=1

k
X

l=1

Sl = k

(cid:16)

p2 + p + 1(cid:17) +

#

" k
p

+

#

" k
p2

+ ... +

#

.

" k
pu

Demonstração. Usando a Proposição 4.39, podemos escrever que:

S1 = p2 + p + 1 + Ep (1)
S2 = p2 + p + 1 + Ep (2)

...

Sk = p2 + p + 1 + Ep (k)

Integrando os termos do membro da direita e os da esquerda, temos que

Sl = k

(cid:16)

p2 + p + 1(cid:17) + Ep (1) + Ep (2) + ... + Ep (k) .

k
X

l=1

Tomando o item P1, da Proposição 2.5, temos que:

Sl = k

(cid:16)

p2 + p + 1(cid:17) + Ep (k!) ,

k
X

l=1

ou, utilizando o Teorema de Legendre 4.5

k
X

l=1

Sl = k

(cid:16)

p2 + p + 1(cid:17) +

#

" k
p

+

#

" k
p2

+ ... +

#

.

" k
pu

Estudo da solução fixando p e α

42

Após o desenvolvimento teórico, apresentamos os principais resultados desta seção.

Proposição 4.41. Fixado p primo, temos

Ep

(cid:16)

mk
ij

!(cid:17) =

k−1
X

l=1

Sl + Lk
ij.

Demonstração. Com argumento análogo ao da demonstração da Proposição 4.30, pode-
mos escrever

Ep

(cid:16)

mk
ij

(cid:16)

(cid:17)

!(cid:17) = Ep (1) + Ep (2) + ... + Ep
mk
ij
(cid:16)
= Ep (p) + Ep (2p) + ... + Ep
mk
ij
(cid:17) + Ep
(cid:17) + ... + Ep
= Ep
= S1 + S2 + ... + Sk−1 + Lk
ij.

m1
12

m1
11

(cid:16)

(cid:16)

(cid:17)

(cid:17)

(cid:16)

mk
ij

Corolário 4.42. A equação Ep (n!) = α, tem solução se, e só se, existir i, j e k, tal que

α =

k−1
X

l=1

Sl + Lk
ij

= k

(cid:16)

p2 + p + 1(cid:17) + Ep (k!) + i (p + 1) + (p + 1 − j)

#

 " j
p

!

− 1

.

Demonstração. Basta observar o Corolário 4.29, existindo solução, haverá uma solução
escrita como múltiplo de p.

Corolário 4.43. Fixados p primo e α ∈ N, se α =

Ep

(cid:16)

mk
pp

!(cid:17) = α.

k
P
l=1

Sl, para algum k ∈ N, então

Lema 4.44. Fixados p primo e α ∈ N seja k ∈ N, tal que,

k−1
P
l=1

Sl < α <

k
P
l=1

Sl. Temos:

i) Se α −

k−1
P
l=1

Sl ≥ p2 + p − 1, então Ep (n!) = α não possui solução.

ii) Se α −

Sl < p2 + p − 1 e α −

k−1
P
l=1

possui solução.

k−1
P
l=1

Sl ≡ p mod (p + 1), então Ep (n!) = α não

iii) Se α −

k−1
P
l=1

Sl < p2 + p e α −

k−1
P
l=1

Sl ≡ 0 mod (p + 1), então Ep

(cid:16)

mk
ij

!(cid:17) = α, com j = p

α −

k−1
P
l=1
p + 1

Sl

.

e i =

iv) Se α −

k−1
P
l=1

Sl < p2 + p e α −

Ep

(cid:16)

mk
ij

!(cid:17) = α, com i =

α −

Sl ≡ j mod (p + 1), com j = {1, 2, ..., p − 1}, então

k−1
P
l=1
k−1
P
l=1
p + 1

Sl − j

+ 1.

Estudo da solução fixando p e α

43

Demonstração.

i) Tomando o Corolário 4.32 temos α −

Sl ≤ (p − 1) (p + 1) + p − 1, implicando

k−1
P
l=1
Sl ≤ p2 + p − 2. Logo, se α −

k−1
P
l=1

que α −
possui solução.

k−1
P
l=1

Sl ≥ p2 + p − 1, então Ep (n!) = α não

ii) Dado i + j < 2p e o Corolário 4.37, note que não existe i e j, tal que, Lk

ij ≡

p mod (p + 1), implicando que a equação Ep

(cid:16)

mk
ij

!(cid:17) = α não tem solução.

iii) Basta tomar o item i) do Corolário 4.37 garantindo que

Lk
ij

= i (p + 1) =

α −

!

k−1
P
l=1

Sl

p + 1

(p + 1)

= α −

k−1
X

l=1

Sl

e a Proposição 4.41 que garante Ep

(cid:16)

mk
ip

!(cid:17) = α.

iv) Análogo a iii), utilizando o item ii) do Corolário 4.37.

□

Algoritmo 2. Dada Ep (n!) = α, com p primo e α ∈ N ∪ {0} fixos, siga os passos que
seguem, a fim de encontrar os valores de i, j e k, que com a aplicação do Lema 4.27,
possibilita encontrar o menor natural n qua satisfaz a equação.

1º Passo: Aplique o Lema 4.40.

Se α =

k
P
l=1

Sl adote i = j = p e aplique o Lema 4.27 e vá para o 4º passo.

Se

k−1
P
l=1

Sl < α <

k
P
l=1

Sl, então obtêm-se o valor de k e vá para o 2º passo.

2º Passo: Aplique o Lema 4.44.

Se respeitar os itens i) ou ii), então a equação não possui solução.

Se respeitar os itens iii) ou iv) prossiga para o 3º passo.

3º passo: Divida por p + 1.

Se for divisível acuse j = p e i =

Sl

α −

k−1
P
l=1
p + 1

e vá para o 4º passo.

Se não for divisível acuse α −
e vá para o 4º passo.

k−1
P
l=1

Sl ≡ j mod (p + 1), e i =

α −

Sl − j

k−1
P
l=1
p + 1

+ 1.

4º Passo: Aplique o Lema 4.27 a fim de obter o valor de n

 
Estudo da solução fixando p e α

44

Indique que as soluções possíveis são dadas pelo conjunto abaixo:

{n, n + 1, ..., n + (p − 1)} .

Simplificando, por meio de um diagrama temos que:

Figura 4.2: Fluxograma relacionado aos passos lógicos interpretados no algoritmo das matrizes,
desenvolvido de forma inédita pelos autores.

Fonte: Autoria nossa

A seguir tomemos dois exemplos, mostrando a prática do algoritmo desenvolvido.

Exemplo 4.45. Encontre os valores de n que satisfaz E7 (n!) = 25.

Estudo da solução fixando p e α

45

Solução.
1º Passo: Condição do α

Assim, logo k = 1.

25 < 57 =

1
X

r=1

Sr,

2º Passo: Condição de existência
Dado que, 25 < 112 + 11, temos que a equação possuí solução.

3º Passo: Divisibilidade
25 = 3 · (7 + 1) + 1, então i − 1 = 3, logo i = 4 e j = 1.

4º Passo: Menor natural solução
Portanto, m1
41

= 7 + 72 (4 − 1) + 73 (1 − 1) = 154.

5º Passo: Solução
Logo, o conjunto

representa todas soluções.

{154, 155, 156, 157, 158, 159, 160}

Exemplo 4.46. Encontre os valores de n que satisfazem E11 (n!) = 855.

Solução.
1º Passo: Condição do α

6
X

r=1

Sr = 798 < 855 < 931 =

7
X

r=1

Sr,

Assim, logo k = 7.

2º Passo: Condição de existência
Dado que, 57 < 112 + 11, temos que a equação possuí solução.

3º Passo: Divisibilidade
57 = 4 · (11 + 1) + 9, então i − 1 = 4, logo i = 5 e j = 9.

4º Passo: Menor natural solução
Portanto, m7
59

= 11 · 9 + 112 (5 − 1) + 113 (7 − 1) = 8569.

5º Passo: Solução
Logo, o conjunto

{8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579}

representa todas soluções.

♢

♢

Estudo da solução fixando p e α

46

4.2.3 Duelo computacional: p-ádica X matrizes

Nesse momento estamos interessados em testar computacionalmente o Algoritmo da p-
ádica, proposto por Abramo Hefez, e o das matrizes, desenvolvido de forma independente
nesse trabalho.

Observação 4.47. A análise é baseada em um recorte de eventos.

Observação 4.48. Entendemos como mais eficiente, o algoritmo que desenvolve um
tempo de processamento2 inferior, em comparação ao outro, sobre as mesmas condições.

Para desenvolvimento dos testes foram confeccionadas duas sequências de linhas de
programação3 com auxilio do VisualG. As mesmas tem por objetivo, encontrar as soluções
para a equação Ep (n!) = α, sendo fixos diferentes valores de α ∈ N ∪ {0} e p primo. Para
cada variação marca-se o tempo (variável t), em ms (milissegundos).

Marcado o tempo para os casos em que α e p primo variam constituímos pontos com
três coordenadas (α, p , t), assim gerando dois gráficos tridimensionais, exposto a seguir.

2Tempo em que o algoritmo levou, desde seu inicio até seu termino, para exibir a resposta.
3Linhas disponíveis no Apêndice B

Estudo da solução fixando p e α

47

Figura 4.3: Variação α×p×t para o Algorítimo
p-ádica.

Figura 4.4: Variação α×p×t para o Algorítimo
das matrizes.

Fonte: Autoria nossa

Fonte: Autoria nossa

Para os dados apresentados nas Figuras 4.3 e 4.4, foram tomados valores de α entre 1
e 100 e p primos entre 2 e 100, uma quantidade de 25 primos. Por fim, para cada variação
α × p foi registrado o tempo (t) gasto para obtermos a solução. Logo, temos plotados
2500 pontos para cada gráfico.

Sobrepondo as superfícies apresentadas nas Figuras 4.3 e 4.4, passamos a perceber

uma similaridade para os tempos de processamento.

Figura 4.5: Sobreposição dos dados apresentados pelas Figuras 4.3 e 4.4.

Fonte: Autoria nossa

Afim de entendermos os eventos dispostos no gráfico da Figura 4.5 dividiremos nossa

analise em três momentos:

i. Tempo médio desenvolvido em ambos os algoritmos para os pontos plotados.

ii. Subtração entre o tempo do Algoritmo das matrizes pelo da p-ádica.

iii. Para os casos em que cada algoritmo é mais eficiente analisamos a amplitude entre

os tempos.

Estudo da solução fixando p e α

48

Observação 4.49. Nesse recorte não buscamos caracterizar as circunstancias em que α
e p primo tornam um algoritmo ou outro mais eficiente.

Dado os 2500 pontos, para cada algoritmo, conseguimos obter que o tempo médio do
Algoritmo p-ádica é cerca de 26,86 ms e o Algoritmo das matrizes 27,76 ms. A partir
desses dados, temos que o Algoritmo p-ádica tem uma média de tempo 3% menor quando
comparado ao Algoritmo das matrizes.

Obtidos os tempos de processamento para cada algoritmo, os mesmos foram tabelados.
Após isso, foi efetuada a subtração entre o tempo de processamento do Algoritmo das
matrizes pelo tempo do Algoritmo p-ádica.

Observação 4.50. Tomando os valores da subtração entre o tempo de processamento do
Algoritmo das matrizes pelo Algoritmo p-ádica, temos que

i. Positivos e maiores que 1: Algoritmo da p-ádica mais eficiente. (924 casos)

ii. Valores entre -1 e 1: a diferença entre os tempos de processamento não foram

consideradas significativas4. (783 casos)

iii. Negativos e menores que -1: algoritmo das matrizes mais eficiente. (793 casos)

Figura 4.6: Histograma de frequência baseado na Observação 4.50.

Fonte: Autoria nossa

Abaixo segue uma tabela que mostram 4 pontos que não foram abordados no Histo-

grama disposto na Figura 4.6.

4Devido as limitações do software utilizado para 783 casos em que a diferença entre os valores é nula,

não conseguimos concluir se os tempos realmente são iguais ou ficaram após serem arredondados.

Estudo da solução fixando n e α.

49

Tabela 4.4: Tabela dos quatro valores retirados para a construção do Histograma representado na
Figura 4.6, por conta de suas disparidades com os demais pontos. Da esquerda para direita temos
na primeira coluna os valores de α e p primo fixados, segunda coluna o tempo de processamento
do Algoritmo das matrizes e na terceira o tempo para o Algoritmo p-ádica e na quarta coluna
a diferença entre os tempos da segunda pela terceira coluna.

Casos (α, p) Algoritmo das matrizes Algoritmo p-ádica Diferença

(33, 2)
(19, 2)
(80, 13)
(15, 2)

47
62
74
157

156
16
16
31

-109
46
58
126

Fonte: Autoria nossa.

Os pontos citados acima foram retirados da análise, pois os mesmos produzem re-
sultados, após a diferença, que destoam significadamente da grande maioria dos demais
pontos.

Com base nos dados destacados, observamos que nenhum dos algoritmos se sobressai de
forma significativa ao outro, nessa análise. Imaginamos que cada um deles deve funcionar
melhor em uma determinada situação, embora essa seja uma especulação nossa, sem
aprofundamento.

4.3 Estudo da solução fixando n e α.

Tomemos Ep (n!) = α, com α e n previamente fixados . Portanto, temos os valores de
p primo como variável livre e desejamos determinar tais valores que satisfazem a equação.
Visando uma melhor organização subdividiremos nossas abordagens como seguem

abaixo:

Tabela 4.5: Indicativo e localização de cada caso abordado na Sub-seção 4.3.

Estudo

Existência

Caracterização

Resultado
Proposição 4.51
Proposição 4.52
Lema4.53
Lema4.55

Fonte: Autoria nossa.

Pelo TFA temos que n! = pα1

1 pα2

2 ...pαs
s

. Logo, fica de fácil observação que para p ser

solução da equação fica necessário que o mesmo seja menor ou igual a n!.

Proposição 4.51. Fixados n ∈ N e α = 0, temos infinitas soluções para a equação
Ep (n!) = α.

Demonstração. Se p é primo e p > n, então p não aparece na decomposição de n!.

Proposição 4.52. Fixados n, α ∈ N se p é, tal que,
equação Ep (n!) = α.

#

" n
p

> α, então p não satisfaz a

Demonstração. De fato, suponha que Ep (n!) = α. Pelo Teorema de Legendre (4.5),
α =

, com pu ≤ n < pu+1, implicando que

+ ... +

≤ α.

+

#

#

#

#

" n
p

" n
p2

" n
pu

" n
p

Estudo da solução fixando n e α.

50

Lema 4.53. Fixados n, α ∈ N, se p satisfaz a equação Ep (n!) = α, então

n + 1
α + 1 ≤ p ≤ n.

Demonstração. Tomando n = p

#

" n
p

+ r, com 0 ≤ r < p e a Proposição 4.52 temos,

≤ α ⇒

#

" n
p

=

n − r
p
n − r
p
−r ≤ pα − n ⇒
r ≥ n − pα.

≤ α ⇒

Como r < p, temos

Logo, n + 1

α + 1 ≤ p ≤ n.

n − pα ≤ p − 1 ⇒

n + 1 ≤ p + pα ⇒
n + 1 ≤ p (1 + α) ⇒
n + 1
α + 1 ≤ p.

Observação 4.54. Com base no Lema 4.53 e Teorema de Legendre 4.5, deve-se testar

(cid:21)
, um primo no referido intervalo será solução se, e só se,

os primos do intervalo

valer a igualdade α =

(cid:20) n + 1
α + 1 , n
" n
" n
+
p2
p

#

#

+ ... +

" n
pu

#
, com pu ≤ n < pu+1.

Lema 4.55. Fixados n, α ∈ N, para cada p primo no intervalo do Lema 4.53, tome
#
.
u ∈ N tal que pu ≤ n < pu+1, então p é solução se, e só se, α =

+ ... +

+

#

#

" n
p

" n
p2

" n
pu

Demonstração. Se p é solução então ele respeita o Lema 4.53, como o Teorema de Legendre
" n
4.5, implicando que α =
pu
" n
p

, com pu ≤ n < pu+1, então Ep (n!) = α, sendo p primo

#
, com pu ≤ n < pu+1.

" n
p2
#

" n
pu

" n
p2

Se α =

+ ... +

+ ... +

" n
p

+

+

#

#

#

#

solução da equação e, portanto, respeitando o Lema 4.53.

5 Uso de linguagem de programação
no processo de ensino e
aprendizagem

Nesse capítulo estudaremos a ideia de pensamento computacional, bem como, sua
relação com o ensino da matemática, focando no ambiente da educação básica. Vale
dispor que ao final do capítulo, descreveremos uma atividade elaborada pelos autores, que
seja aplicável aos estudantes desse ciclo, que mescle a ideia de pensamento computacional,
como linhas de programação e conceitos matemáticos.

5.1 O “Pensamento computacional” e o ensino da

matemática

Como inicio de nossas abordagens investigaremos o que seria e como ocorre o pen-
samento computacional e qual sua associação com o ensino da matemática. Para isso
tomaremos de pesquisadores referências nessas discussões, a fim de garantir um embasa-
mento teórico a nossa atividade.

5.1.1 Pensamento computacional

Encontrar uma definição para pensamento computacional, que agrade a todos estudi-

osos da área vem sendo um processo complicado, como aponta VALENTE (2016).

Pensando sobre um ponto de vista cronológico, o termo (pensamento computacional)
surge com Jannette M. Wing, que coloca-o como o processos de raciocínio que envolve
a resolução de problemas, bem como sua formulação, onde um computador (humano ou
máquina), possa resolve-lo (WING (2014)).

Esse processo de raciocínio pode ser entendido sobre qualquer ação, por exemplo, uma
criança que deva escolher entre seus objetos aqueles que porá em sua bolsa (ideia de
escolhas e prioridades). Ou o ato de tentar encontra algo perdido recriando os passos
anteriores (WING (2014)).

É fato que o termo pensamento computacional nos remete a ideia de tecnologias digi-
tais, mas como aponta WING (2014) e VALENTE (2016) essa associação não é necessária.
Todos desenvolvemos pensamento computacional assim que nos propomos a resolver ou
gerar uma problemática.

VALENTE (2016) deixa claro que, apesar da introdução de tecnologias digitais, no
processo de pensamento computacional, não ser pré requisito, nem determinante para um

51

O “Pensamento computacional” e o ensino da matemática

52

sucesso ou não, a inserção de tais tecnologias promovem uma melhoria em todo processo.
Pensando para crianças, podemos entender a melhoria do pensamento computacional
quando vinculado a tecnologia, sobre o que aponta VALENTE (2016) destacando que
a presença das tecnologias digitais de informação e comunicação vem reestruturando o
funcionamento de setores ligado a organização econômica, social e cultural, o que pode
ser percebido em nossas ações rotineiras de intercomunicação e pela forma como atuamos
em transações financeiras. E Papert, que destaca o estimulo a criatividade das crianças
e, dessa forma, dos estudantes.

O processo do pensamento computacional fundamentasse na abstração. Este permite
que criemos padrões, generalizações e passemos a entender as propriedades formadoras
de um único objeto ou seu conjunto.

So, the most important and high-level thought process in computatio-
nal thinking is the abstraction process. Abstraction is used in defining
patterns, generalizing from specific instances, and parameterization. It
is used to let one object stand for many. It is used to capture essential
properties common to a set of objects while hiding irrelevant distinctions
among them. For example, an algorithm is an abstraction of a process
that takes inputs, executes a sequence of steps, and produces outputs to
satisfy a desired goal. WING (2014)

Assim, pensar computacionalmente, vem de um estimulo da abstração e pela neces-
sidade e/ou vontade de solucionar, bem como criar, problemas, sejam esses de qualquer
natureza. Pensar nesse processo, significa entender como o computador (homem ou má-
quina) processa e organiza as informações para uma otimização das ações que podem ser
tomadas frente a tais circunstâncias.

5.1.2 Ensino da matemática: pensamento computacional

Investigar a relação entre pensamento computacional e o ensino da matemática, passa
pelos entendimentos do que seria o pensamento computacional e como o processo de ensino
da matemática se desenvolveu nos últimos anos.

Inicialmente, é perceptível que o uso de computadores trouxe uma reflexão sobre a ação
do homem para a resolução de problemas. Sendo válida a ideia de quando a utilidade do
homem ou da máquina é conveniente e para quais problemas.

Apear do vinculo que os termos “computador” e “ pensamento computacional” pos-
suem, quase que de forma evidente, o pensamento computacional não se restringe a ideia
de programar um computador para fazer tarefas, das simples as mais complexas. Este
pelo simples ato de raciocinar a solução ou criação de um problema.

SOUTO (2017) destaca a colocação de Onuchic, aonde ressalta que na década de 1930 a
matemática começava se desvincilhar da ideia de repetição e memorização passando a dar
mais importância a forma com que o estudante aprende e se posta frente as dificuldades
encontradas.

Assim concluí SOUTO (2017), que essa mudança de pensamento traz um questiona-
mento sobre a prática de como resolver problemas, sendo esta de importância fundamental
para o desenvolvimento do estudante como um todo, envolvendo as partes técnicas e cri-
ativas, como a elaboração de hipóteses e reflexões.

Tomando a necessidade de discutir o ensino da matemática e a crescente presença dos
meios digitais em nossa sociedade, é sensível a necessidade de estudarmos como estender

Ação nacional de educação e o pensamento computacional

53

e aplicar, de forma significativa, o pensamento computacional no ensino, particularizando
nesse caso ao estudo da matemática.

Dessa forma, concluímos que a discussão entre pensamento computacional e ensino
da matemática permeia uma necessidade atual que o processo de ensino e aprendizagem
deve modelar-se. Mais que isso, pensar em como inserir a tecnologia digital (um dos meios
pelo qual o pensamento computacional pode ser desenvolvido), de forma significativa, é
discussão fundamental para alicerçar uma educação de qualidade e contextualizada com
as recentes demandas sociais, econômicas.

5.2 Ação nacional de educação e o pensamento com-

putacional

Como vimos, ter em mente o Pensamento computacional pode ser de grande valia
para o sistema educacional. Isso, por que, como aponta Papert, este pode estimular a
criatividade das crianças e, dessa forma, dos estudantes.

Além disso, vimos que os meios digitais estão inseridos em todas as ações sociais,
econômicas e culturais, por isso, fica de extrema importância integrar tal realidade as
vivências dos estudantes, assim produzindo um maior interesse por parte dos mesmos as
práticas de ensino.

Ações de integração, como a descrita anteriormente, é algo que já vem sendo executado
em alguns países. Exemplo disso, é o programa “Computer Science is for Everone”, lan-
çado pelo governo dos Estados Unidos da América, que visa uma das maneiras de adaptar
o uso de tecnologia aos diferentes contextos do nosso dia-a-dia (VALENTE (2016)).

Outro exemplo dessa prática esta no relatório “European Schoolnet”. Nele ficam evi-
dentes que, dos 20 países pesquisados, 13 já alteraram suas diretrizes educacionais, sendo
destes, a Inglaterra a instituir Ciências da Computação, Tecnologia da Informação e o Le-
tramento digital, como obrigatórios no currículo da educação básica (VALENTE (2016)).
No Brasil, os avanos frente a essas tendências, ficam relativas a construção da BNCC
(Base Nacional Comum Curricular). Neste documento, é possível notar a existência de
habilidades que ressaltam o uso de ferramentas tecnológicas, bem como, aspectos do pen-
samento computacional, em assuntos antes trabalhados por meio repetição e memorização.
A primeira e segunda competências gerais, destacadas a seguir, mostram as preocu-

pações destacadas anteriormente.

Reconhecer que a Matemática é uma ciência humana, fruto das neces-
sidades e preocupações de diferentes culturas, em diferentes momentos
históricos, e é uma ciência viva, que contribui para solucionar proble-
mas científicos e tecnológicos e para alicerçar descobertas e construções,
inclusive com impactos no mundo do trabalho. (BNCC (2018))

Utilizar processos e ferramentas matemáticas, inclusive tecnologias di-
gitais disponíveis, para modelar e resolver problemas cotidianos, sociais
e de outras áreas de conhecimento, validando estratégias e resultados.
(BNCC (2018))

Apesar da BNCC trazer uma formalidade ao inicio desse processo, é necessário que o
mesmo conte com a logística de formação do professor e o entendimento sobre os meios

Proposta de atividade envolvendo conceitos de teoria dos números

54

avaliativos (VALENTE (2016)).

Quanto a capacitação do docente, é necessário que seja feita de forma inicial (durante
os cursos de licenciatura) e continuada, visando manter o profissional atualizado para as
novidades e tendências a serem aplicadas e, nas quais, seus estudantes estão em constante
contato.

Quanto aos meios de avaliação VALENTE (2016) cita a pesquisa realizada por Brennan
e Resnick (2012). Nesse trabalho os autores desenvolvem três fases de avaliação, que
diferem entre observação e montagem do portfólio.

Portanto, passamos a entender que o processo de desenvolvimento - significativo - do
pensamento computacional, esta sendo promovido como parte das políticas educacionais
do alguns países, bem como no Brasil por intermédio da BNCC. Apesar disso, necessitamos
estruturar a camada dos docentes, para que estejam qualificados às novas demandas que
aparecerão, garantindo qualidade e contextualidade ao processo de ensino e aprendizagem
nacional.

5.3 Proposta de atividade envolvendo conceitos de

teoria dos números

Com os conhecimentos confrontados e as ideias estabelecidas anteriormente, descreve-
remos uma possível atividade que pode ser aplicada para estudantes da educação básica
que busquem, visando o conceito de pensamento computacional, introduzir os conceitos
de programação básica, fazendo uso de conteúdos tradicionais da matemática, recorren-
temente desenvolvidos pelos currículos educacionais pelo Brasil.

5.3.1 Software

Para a execução das linhas de programação faremos uso do “VisualG”. A escolha do

programa em questão, vêem dos pontos destacados a seguir:

i. Uso do Portugol 1, auxiliando em uma familiaridade maior com a língua matriz dos

estudantes (Português).

ii. “Layout” simples e amigável para um primeiro contato com a ideia de programação.

iii. Blocos lógicos com palavras indicadores de abertura e fechamento.

Entendemos que todas as condições acima garante uma melhor adaptação a maioria
dos estudantes da educação básica que não possuem um contato tão direto com formas de
linguagem de programação.Assim, a escolha deste programa vem nesse sentido. Segundo
o site do programa

Foi propositadamente criado para ajudar aos alunos iniciantes em pro-
gramação, mas pode ser utilizado por professores e outros autodidatas.
(VISUALG)

1O VisuAlg é um programa que permite criar, editar, interpretar e que também executa os algorit-
mos em portugol (estruturado português) como se fosse um “programa” normal de computador. É um
programa de livre uso e distribuição GRÁTIS, e DOMÍNIO PÚBLICO, usado para o ensino de lógica de
programação em várias escolas e universidades no Brasil e no exterior.

Desenvolvimento de algoritmos auxiliares

55

5.3.2 Condições iniciais

Para que uma melhor aplicação dessa atividade, fica necessário garantir sentenças

prévias em três partes o docente, o estudante e a instituição.

Em carácter do docente, assim como o apontado por VALENTE (2016), fica necessário
uma formação inicial, bem como, a continuada. É de fundamental importância que tenha
domínio sobre o software e as técnicas utilizadas, bem como, mantenha-se em estudos
constantes, afim de suprir quaisquer dúvidas que venham a surgir por parte dos estudantes.
Para os docentes que não estão familiarizados com tal linguagem, recomenda-se um

estudo prévio visando cobrir essas falhas.

Apesar disso, vale ressaltar, que essa atividade pode ser aplicação sem o uso necessário
da tecnologia, apesar da ideia ser o uso de programação básica, não existe uma necessidade
de transpô-la ao computador, podendo assim, ser desenvolvida por meio de fluxogramas
que busquem trabalhar a resolução de devidos problemas2.

Quanto aos estudantes, para garantir a boa prática, é necessário que se mostre ativo,
quanto a prática de pesquisa e estudos. Uma vez assim, o mesmo se manterá familiarizado
ao software a ser utilizado, gerando facilidades progressivas para as atividades.

E, por último, em termos de infra-estrutura, é necessário que as instituições tenham ou
passem a ter equipamentos compatíveis e habilitados, desenvolver um meio que incentive
as condições de aprendizagem e garantir o bem estar do estudante, como do docente, de
forma geral.

5.4 Desenvolvimento de algoritmos auxiliares

Esses algoritmos devem ser estruturados para que possam ser utilizados no produto
final da atividade. Fica claro que o uso desse algoritmos, bem como, suas aplicações
fica reservada ao docente que ministrará as aulas. Podendo este, desenvolve-los de forma
separada ou de forma conjunta.

Cada linha de programação contará com:

• Um bloco de referencial teórico: representa os conceitos que o docente deverá
explorar com os estudantes de forma prévia garantindo o máximo de compreensão.

• Os passos lógicos que descrevem a evolução do raciocínio para a construção das

linhas de programação.

• Fluxograma, que funciona como material auxiliar que pode ser usado pelo docente

como uma etapa introdutória na construção final da linha de programação.

• Linha de programação, com comentários, desenvolvidas no ambiente do VisualG.

5.4.1 Divisores de um n natural

Para a construção das linhas de comando, necessitamos entender os passos lógicos e

os embasamentos teóricos que guiam a construção do algoritmo.

2Tais fluxogramas encontram-se anexados a seguir, na subseção referente a cada algoritmo.

Desenvolvimento de algoritmos auxiliares

56

REFERENCIAL TEÓRICO

Definição 5.1. Sejam n, d, k ∈ N, d é divisor de k se, e só se, n = d · k.

Proposição 5.2. Seja n ∈ N e D = {1, d2, ..., di, n} conjunto de todos os divisores de
n, tais que, ds > ds−1, para s = 1, 2, ...i, então di ≤

.

n
2

Demonstração. Tomemos n = di·k, com k ≥ 2. Suponhamos di >
implicando que n > n, o que é um absurdo.

n
2

, então di·k >

n
2 ·k,

1º: Entender quem é o número a ser trabalhado.

PASSOS LÓGICOS

2º: Testar desde o número 2 até a metade do número do 1º passo se algum é divisor.

3º: Registrar os que foram classificados como divisores no 2º passo.

Tomando o referencial e os passos lógicos podemos estruturar o fluxograma como

segue.

Figura 5.1: Fluxograma dos divisores

Por fim, propomos a construção do algorítimo conforme segue,

Fonte: Autoria nossa

Desenvolvimento de algoritmos auxiliares

57

LINHAS DE PROGRAMAÇÃO

Var
// ambiente variáveis.
n,c,j: inteiro
Inicio
// j recebe 1
j<-1
enquanto j = 1 faca
// Digita na tela os caracteres e pula linha.

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// Digita na tela os caracteres e pula linha.
DIVISORES
// Digita na tela os caracteres e pula linha.

escreval(“|

|”)

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// Pede-se o número a ser trabalhado.
escreva(“Digite o número desejado:”)
// guarda a variável n.

leia(n)

// digita na tela os caracteres e pula linha.
escreval(“Os divisores de ",n,"são:”)
// digita na tela o número 1 sem pular linha.
escreva("1,")
// Atribui a c valores de 2 até a metade de n.
para c de 2 ate n div 2 faca

se (n MOD c = 0) entao

// Se c dividir n dita c na tela sem pular linha.

escreva(c,",")

fimse
fimpara
// Digita na tela a variável n e pula linha.
escreval(n,".")
escreval("Digite 1 para recomeçar e 2 para finalizar o algorítimo:")
// Se j guarda 1, então recomeça o algoritmo, se não finaliza o algoritmo.

leia(j)
fimenquanto
Fimalgoritmo

Tomando as linhas de programação vemos que os comandos são bem simples. Iniciamos
definindo o número que estaremos analisando. Após isso, abrimos um ambiente “para”,
que iniciará seus trabalhos com a variável c adquirindo valor 2 e finalizando quando
adquirir a metade do valor analisado.

Esse loop serve para testarmos todos os possíveis candidatos a divisores. Quando a
variável c recebe um dos possíveis candidatos este é testado dentro do ambiente “se”, que
valida ele ser ou não um divisor.

Caso seja, o mesmo é escrito como uma das soluções e o algorítimo volta a funcionar

para um novo valor de c. Isso se repetirá ate o ambiente “para” finalizar suas ações.

Desenvolvimento de algoritmos auxiliares

58

Note que o ambiente “enquanto” colocado no inicio do algorítimo garante a possibi-
lidade de se realizar uma nova análise, digitando 1 para recomeçar ou 2 para finalizar o
algoritmo.

5.4.2 Mínimo Divisor Comum de dois naturais

Para a construção das linhas de comando, necessitamos entender os passos lógicos e

os embasamentos teóricos que guiam a construção do algoritmo.

REFERENCIAL TEÓRICO

Definição 5.3. Sejam a, b, d ∈ N. Se d é o maior divisor a e b ao mesmo tempo,
então mdc(a, b) = d.

PASSOS LÓGICOS

1º: Entender quem são os números a serem trabalhados.

2º: Descobrir os números que são divisores de ambos.

3º: Dentre os números encontrados acima qual deles é o maior.

4º: Acusar o número encontrado no passo anterior como o mdc dos números selecio-

nados.

Tomando o referencial e os passos lógicos podemos estruturar o fluxograma como

segue.

Figura 5.2: Fluxograma do MDC

Fonte: Autoria nossa

Desenvolvimento de algoritmos auxiliares

59

Por fim, propomos a construção do algorítimo conforme segue,

LINHAS DE PROGRAMAÇÃO

Var
v: vetor [1..2] de inteiro
d,mdc,b,j, indice: inteiro

// Variável vetor.
// Variável inteira.

Inicio
// j recebe 1
j<-1

enquanto j = 1 faca
// Digita na tela os caracteres sem pular linha.

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// Digita na tela os caracteres sem pular linha.

escreval(“|

MDC

// Digita na tela os caracteres sem pular linha.

|”)

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// mdc recebe 1
mdc<-1
// Atribui valor 1 e 2 para variável indice.
para indice de 1 ate 2 faca

escreval("Digite o ", indice, "º número:")

// Guarda a variável v [indice].

leia(v[indice])

fimpara
// d recebe 1
d<-1
// Enquanto o quociente da divisão de v [1] por d e v [2] por d for maior que 0.
enquanto (v[1] div d > 0) e (v[2] div d > 0) faca

se ((v[1] MOD d = 0) e (v[2] MOD d = 0)) entao

se d>=mdc entao

// Se d é divisor de v [1] e v [2] e maior ou igual que mdc, então mdc atribui d.

mdc<-d

fimse

fimse

// d recebe o valor de seu sucessor.
d<-d + 1
// Ao fechar o ambiente enquanto teremos o maior divisor comum de v [1] e v [2].
fimenquanto

Desenvolvimento de algoritmos auxiliares

60

// Digita na tela os caracteres e pula linha.
escreval("mdc(",v[1],",",v[2],") = ",mdc,".")

// Se j guarda 1, então recomeça o algoritmo, se não finaliza o algoritmo.
escreval("Digite 1 para recomeçar e 2 para finalizar o algorítimo:")

leia(j)
fimenquanto
Fimalgoritmo

Tomando as Linhas de Programação acima, vemos algumas estruturas que caracteri-

zam os quatro passos abordados antes da apresentação das linhas propriamente.

O algoritmo inicia com uma variável j inteira seguida por um ambiente “enquanto”,
este funciona como um loop, onde o usuário pode escolher entre fechar o programa ou
reaplica-lo.

Logo após a apresentação o usuário deve escolher dois números, que serão os avaliados.
Depois disso, temos um ambiente “enquanto”, este serve para efetivar um loop dos divi-
sores que funciona até que encontremos um valor d, tal que, a divisão de v [indice], com
indice= 1, 2, por d seja inferior a 0. Enquanto isso ocorrer, os valores de d são testados
no ambiente “se”.

Assim, até que a condição dos ambientes “se” e “enquanto” não seja quebrada, o

algoritmo continua rodando, até que todos os pontos sejam satisfeitos.

5.4.3 Minimo Múltiplo Comum de dois naturais

Tomando a sequência abordada nas seção anteriores, focaremos em explicitar como
se dá a construção das linhas de programação voltadas a resolução do MMC entre dois
números.

REFERENCIAL TEÓRICO

Definição 5.4. Sejam a, b, m ∈ N. Se m é o menor múltiplo de a e b, ao mesmo
tempo, então mmc(a, b) = m.

Proposição 5.5. Seja a, b, ∈ N, então mdc(a, b) · mdc (a, b) = ab.

Note que tendo a construção do MDC podemos utilizar as mesmas linhas de programa-
ção porém com uma finalização visando a divisão entre o produto dos números apontados
no inicio do algorítimo pelo MDC deles.

Desenvolvimento de algoritmos auxiliares

61

PASSOS LÓGICOS

1º: Entender quem são os números a serem trabalhados.

2º: Efetuar as linhas do MDC.

3º: Efetuar o produto dos números apontados.

4º: Acusar o MMC como a divisão entre o valor do 3º passo e 2º passo.

Tomando o referencial e os passos lógicos podemos estruturar o fluxograma como

segue.

Figura 5.3: Fluxograma do MMC

Por fim, propomos a construção do algorítimo conforme segue,

Fonte: Autoria nossa

LINHAS DE PROGRAMAÇÃO

Var
v: vetor [1..2] de inteiro
mdc,d,j,l,indice: inteiro

// Variável vetor.
// Variável inteira.

Inicio
// j recebe 1
j<-1

Desenvolvimento de algoritmos auxiliares

62

enquanto j = 1 faca
// Digita na tela os caracteres e pula linha.

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// Digita na tela os caracteres e pula linha.

escreval(“|

MMC

// Digita na tela os caracteres e pula linha.

|”)

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// mdc recebe 1
mdc<-1
// Atribui valor 1 e 2 para variável indice.
para indice de 1 ate 2 faca

escreval("Digite o ", indice, "º número:")

// Guarda a variável v [indice].

leia(v[indice])

fimpara
// d recebe 1
d<-1

// Enquanto o quociente da divisão de v [1] por d e v [2] por d for maior que 0.
enquanto (v[1] div d > 0) e (v[2] div d > 0) faca

se ((v[1] MOD d = 0) e (v[2] MOD d = 0)) entao

se d>=mdc entao

// Se d é divisor de v [1] e v [2] e maior ou igual que mdc, então mdc atribui d.

mdc<-d

fimse

fimse

// d recebe o valor de seu sucessor.
d<-d + 1
// Ao fechar o ambiente enquanto teremos o maior divisor comum de v [1] e v [2].
fimenquanto
// A variável l recebe o valor do produto entre v [1] e v [2].
l<- v[1]*v[2]
// Digita na tela o valor do mmc calculado.
escreval("mmc( ",v[1],", ", v[2],") = ", l div mdc)
escreval("Digite 1 para recomeçar e 2 para finalizar o algorítimo:")
// Se j guarda 1, então recomeça o algoritmo, se não finaliza o algoritmo.

leia(j)
fimenquanto
Fimalgoritmo

Do mesmo jeito que apontando nas Linhas de Programação do MDC note que o
primeiro ambiente “enquanto” garante que o programa será executado quantas vezes for
conveniente ao usuário.

Logo após a abertura do algorítimo, temos o entendimento dos números que serão
analisados notados por v [1] e v [2]. Após isso, temos o ambiente “enquanto” que encontra
o valor do MDC dos números analisados.

Por fim, tomando o Referencial teórico que concluímos, com simples operações o valor

Desenvolvimento de algoritmos auxiliares

63

do MMC.

5.4.4 Classificando os naturais entre primos e compostos

Temos como objeto descrever a construção, desde os passos lógicos até as efetivas linhas
de programação, de um algorítimo responsável pela descriminação de números naturais,
indicando ser primo ou composto.

Para a construção do algoritmo tomemos a proposição abaixo, bem como a observação
na sequência, que sintetizam a ideia dos passos lógicos usados nas linhas de programação.

REFERENCIAL TEÓRICO

Proposição 5.6. Sejam a ∈ N e D = {1, d2, ..., dn} o conjunto de todos os divisores
de a, tal que, d2 > 1 e dj > dj−1, com j = 3, 4, ...n. Se d2 = a, então a é primo.

Demonstração. Se d2 = n, então este é o último divisor de n. Portanto n tem
apenas dois divisores, logo é primo.

Observação 5.7. Tomando as condições da Proposição 5.6, se d2 ̸= a, então a é
composto.

Note que as consequências do exposto acima descrevem uma maneira de testarmos se
um número é primo ou composto. Vale ressaltar que existem mais formas de se pensar
em primos, mas para o que buscamos nesse momento essa será suficiente.

1º: Entender quem é o número a ser trabalhado.

PASSOS LÓGICOS

2º: Sabendo que em ordem crescente o 1 é o primeiro divisor, descobrir quem é o

próximo divisor.

3º: Ver se o número obtido no 2º passo é igual ou diferente do 1º passo.

4º: Se igual então o número é primo e se é diferente é composto.

Tomando o referencial e os passos lógicos podemos estruturar o fluxograma como

segue.

Desenvolvimento de algoritmos auxiliares

64

Figura 5.4: Fluxograma da classificação entre primos e compostos

Por fim, propomos a construção do algorítimo conforme segue,

Fonte: Autoria nossa

LINHAS DE PROGRAMAÇÃO

Var
n,c,j: inteiro

// Variável inteira.

É PRIMO OU COMPOSTO?

Inicio
// j recebe 1
j<-1
enquanto j=1 faca
// Digita na tela os caracteres e pula linha.
escreval( - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ")
// Digita na tela os caracteres e pula linha.
escreval("|
// Digita na tela os caracteres e pula linha.
escreval(- - - - - - - - - - - - - - - - - - - - - - - - - - - - - ")
// Digita na tela os caracteres sem pular linha.
escreva("Digite o número:")
// Guarda a variável n.
leia(n)
// c atribui 2.
c<-2
enquanto (n MOD c <> 0) faca
// Enquanto c não for divisor de n, c recebe o valor de seu sucessor.

|")

c<-c+1
fimenquanto

Desenvolvimento de algoritmos auxiliares

65

se c=n entao

// Se c é igual a n, então digita “é primo”.
escreval(n,"é primo.")
senao

// Se c é diferente de n, então digita “é composto”.

escreval(n,"é composto.")

fimse

escreval("Digite 1 para recomeçar e 2 para finalizar o algorítimo:")
// Se j guarda 1, então recomeça o algoritmo, se não finaliza o algoritmo.
leia(j)
fimenquanto
Fimalgoritmo

Tomando as linhas de programação, notamos uma sentença que se repete desde o
primeiro algorítimo desenvolvido, onde o ambiente “enquanto” funciona para reiniciar o
algorítimo após a verificação inicial dada.

A partir desse momento, todas as linhas de programação seguem a Proposição 5.6 e
a Observação 5.7. Para iniciar apresentamos a primeira variável c, na qual atribuímos o
valor inicial de 2. Ela entra em um loop.

Este ambiente é repetido até que encontremos um valor de c que divida o número
acusado no inicio. Seguimos para um ambiente “se”, que avalia o divisor c encontrado
sendo que se este for igual ao número iniciado temos um valor primo do contrário este é
composto.

5.4.5 Teorema Fundamental da Aritmética

Temos como objetivo apresentar o algoritmo que fornece a decomposição em fatores
primos expressas pelo TFA (Teorema Fundamental da Aritmética), muito comumente
utilizado e desenvolvido em sala de aula, por professores e estudantes.

Este, além de ser amplamente citado ao decorrer do trabalho, também é de extrema

importância para o decorrer do processo de ensino.

REFERENCIAL TEÓRICO

Teorema 5.8. (Teorema Fundamental da Aritmética - TFA)Todo número natural n ≥
2 possui uma decomposição única por fatores primos, isto é, dado n ≥ 2 existem únicos
primos distintos p1, , p2, ..., pr e naturais α1, α2, ..., αr tais que n = pα1

1 pα2

2 ...pαr
r

.

Desenvolvimento de algoritmos auxiliares

66

PASSOS LÓGICOS

1º: Entender quem é o número a ser trabalhado.

2º: Entender quem são os possíveis divisores primos.

3º: Ver se o número obtido no 2º passo divide o número do 1º passo. Se este não

dividir testa-se outro número.

4º: Se o número do 1º passo for divisível pelo primo divisor encontrado no 2º passo,

repetimos o algorítimo para o quociente da divisão.

Tomando o referencial e os passos lógicos podemos estruturar o fluxograma como

segue.

Figura 5.5: Fluxograma do TFA

Por fim, propomos a construção do algorítimo conforme segue,

Fonte: Autoria nossa

Desenvolvimento de algoritmos auxiliares

67

LINHAS DE PROGRAMAÇÃO

Var
n,c,m,j: inteiro

// Variável inteira.

Inicio
// j recebe 1
j<-1
enquanto j = 1 faca
// Digita na tela os caracteres e pula linha.

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// Digita na tela os caracteres e pula linha.

escreval(“|

TFA

|”)

// Digita na tela os caracteres e pula linha.

escreval(“ - - - - - - - - - - - - - - - - - - - - - - - - - - - - ”)

// Digita na tela os caracteres sem pular linha.
escreva("Digite o número a ser fatorado:")
// Guarda a variável n.

leia(n)

para m de 2 ate n div 2 faca
// c recebe 2
c<-2
enquanto (m MOD c <> 0) faca

// Enquanto c não for divisor de m, c recebe o valor de seu sucessor.

c<-c + 1

fimenquanto
se c = m entao

// Repita os comandos abaixo até m não for divisor de n.

repita

se (n MOD m = 0) entao

// Se m divide n, digite na tela os caracteres.

escreval(n,"| ",m)

// n atribui o quociente da divisão de n por m.

n<-n div m

fimse

ate n MOD m <> 0

fimse

fimpara
escreval("_|")
escreval(1)
escreval("Digite 1 para recomeçar e 2 para finalizar o algorítimo:")
// Se j guarda 1, então recomeça o algoritmo, se não finaliza o algoritmo.

leia(j)
fimenquanto
Fimalgoritmo

Atividade final

68

Iniciamos o algorítimo com o ambiente “enquanto” para efeitos de reiniciar-lo, caso
haja necessidade de avaliarmos outro número. Seguimos com o ambiente “para” e o
ambiente “se” que avaliam quais número são primos. Após isso, entramos no ambiente
“se” que avalia se o primo é divisor do número atribuído inicialmente. Se este for divisível
ele fica registrado como divisor do número.

Após isso, o algorítimo reinicia tomando o quociente da divisão efetuada anteriormente.
Isso se repete até o momento em que o primo obtido for igual ao quociente da última
divisão.

5.5 Atividade final

Com os algoritmos desenvolvidos anteriormente, construiremos uma atividade cujo
o produto final seja a criação de linhas de programação que disponham de todas as
caraterísticas dos diferentes números naturais.

ATIVIDADE: "RG DOS NÚMEROS"

Título do projeto: RG dos números naturais.

Publico Alvo: Alunos da educação básica.

Tempo: Depende da turma e suas experiências anteriores com linhas de programa-
ção. Apesar disso, damos uma projeção mínima de 1 ano.

Avaliação: A avaliação partirá de duas frentes:

– Análise do portfólio;

– Análise das linhas de programação desenvolvidas; e,

– Envolvimento nas atividades.

Justificativa: Tomando o que foi discutido, anteriormente, entendemos que a ati-
vidade segue em proporcionar um desenvolvimento de conceitos matemáticos, por
meio da integração entre tecnologia digital e pensamento computacional. Uma vez
que o ensino da matemática encontra-se em estágio de mudanças e com índices bem
abaixo do médio (segundo avaliações governamentais), essa atividade vem para res-
gatar e ensinar conceitos fundamentais da matemática, visando um bom seguimento
no curso da educação básica. Capacitando o estudante há evoluir seu potencial de
abstração para qualquer problemática.

Objetivos:

– Geral: Realizar com o estudante a criação de linhas de programações capazes
de fornecer características dos números escolhidos como, por exemplo, se é
primo ou composto, quais são seus divisores, condições especiais, escrita por
extenso e outras mais.

Atividade final

69

– Específicos:

i. Entendimento de MDC e MMC.
ii. Conceito de divisibilidade.
iii. Classificação dos Números Naturais.
iv. Posição relativa a reta numérica.
v. Conhecimento básico em programação3.

Recurso:

i. Computadores com o VisualG instalado.

ii. Lousa.

iii. Datashow4.

Habilidade:

i. (EF06MA04) Construir algoritmo em linguagem natural e representá-lo por
fluxograma que indique a resolução de um problema simples (por exemplo, se
um número natural qualquer é par).

ii. (EF06MA05) Classificar números naturais em primos e compostos, estabelecer
relações entre números, expressas pelos termos "é múltiplo de", "é divisor de",
"é fator de", e estabelecer, por meio de investigações, critérios de divisibilidade
por 2, 3, 4, 5, 6, 8, 9, 10, 100 e 1000.

iii. (EF06MA06) Resolver e elaborar problemas que envolvam as ideias de múltiplo

e de divisor.

iv. (EM13MAT405) Utilizar conceitos iniciais de uma linguagem de programação
na implementação de algoritmos escritos em linguagem corrente e/ou matemá-
tica.

Metodologia:

ETAPA
1ª Etapa
2ª Etapa

3ª Etapa

DESCRIÇÃO
Apresentação do Projeto e seu seguimento
Desenvolvimento das ferramentas básicas relacionadas
ao programa VisualG. Aconselha-se o uso de exercícios
básicos que desenvolvam essas ferramentas
Explicação teórica e aplicada sobre o conceito dos divi-
sores de um dado número n. Focando em exemplos que
levem a discussão na quantidade dos divisores de cada
número.

TEMPO
2 aula
1 mês

0,5 mês

3Aconselha-se que o professor explique conceitos básicos de programação e teste alguns exemplos

simples antes de abordar a atividade em sua completude.

4Esse item é opcional, mas entendesse que com ele o professor possa auxiliar de forma geral a sala,

fazendo com que todos caminhem juntos e suas dúvidas sejam devidamente sanadas.

Atividade final

70

4ª Etapa

5ª Etapa

6ª Etapa

7ª Etapa

8ª Etapa

9ª Etapa

Desenvolvimento do fluxograma, por parte dos estudan-
tes, capazes de descrever as linhas de programação a
serem construídas.
Desenvolvimento da linha de programação responsável
por encontrar os devidos divisores.
Construção teórica e prática relacionada a temática de
MMC e MDC.
Desenvolvimento do fluxograma, por parte dos estudan-
tes, capazes de descrever as linhas de programação a
serem construídas.
Desenvolvimento da linha de programação responsável
por encontrar os devidos o MMC e MDC de dois dife-
rentes valores naturais.
Evidenciar a classificação entre primos e compostos que
existe para qualquer número natural. Formalizar a exis-
tência do TFA.

10ª Etapa Desenvolvimento do fluxograma, por parte dos estudan-
tes, capazes de descrever as linhas de programação a
serem construídas.

11ª Etapa Desenvolvimento da linha de programação responsável
por classificar números naturais maiores que 1 em pri-
mos ou compostos.
Explicação do produto final.

12ª Etapa
13ª Etapa Agrupamento das linhas de programação construídas

anteriormente para geração do produto final.

14ª Etapa Discussão de fechamento

0,5 mês

1 mês

0,5 mês

0,5 mês

1 mês

1 mês

0,5 mês

1 mês

2 aulas
1 mês

4 aulas

5.5.1 1ª etapa

Nesse momento o docente deve expor para os estudantes como a atividade funcionará.
Será importante que o mesmo descreva com detalhe o tempo de cada tarefa, bem como,
o que será produzido em cada uma delas.
Isso, mostrará ao mesmo [estudante] que
o conhecimento será desenvolvido com o passar do tempo, de forma que todos, mesmos
aqueles sem prática ou contato com programação, possam seguir e desenvolver a atividade.

5.5.2 2ª etapa

Durante o período programado, é fundamental que a primeira ação do docente seja
inserir o estudante frente ao que seria essa linguagem de programação e para o que é
usada.

Evidenciar partes do cotidiano e propor discussões acessíveis desencadeará um processo
de interesse nos estudantes. Vale ressaltar que o docente deve fornecer acesso a literaturas
exteriores, de forma, a dar suporte aos estudantes que queiram desenvolver essa prática
fora do ambiente escolar.

Atividade final

71

Visando essa ideia pode ser aconselhado como literatura externa

• http://www.inf.ufsc.br/~bosco.sobral/ensino/ine5201/Visualg2_manual.pdf

• https://nte.ufsm.br/images/identidade_visual/introducaoalgoritmos.pdf

Além do mais, o docente deve exercitar a ideia de variável, função, operadores e
comandos de repetição, dando ênfase aos que serão utilizados na construção das linhas de
programação.

Exercícios: exemplos de abordagens

Abaixo seguem os exercícios e suas soluções que estarão presentes na 3ª etapa da

atividade.

Construa linhas de comando que operem dois
números com operações diversas.

Proposta de resolução:

// Variável inteira.

Var
n,m: real
o: caracter
Inicio
escreval("Digite o 1º número:") // Digita na tela os caracteres e pula linha.

// Variável carcater.

leia(n)

// Guarda a variável n.

escreval("Digite o 2º número:") // Digita na tela os caracteres e pula linha.

leia(m)

// Guarda a variável m.

escreval("Digite a operação desejada, sendo:")

//Pede a operação desejada.

escreval("+: soma;")
escreval(-: subtração;")
escreval("/: divisão;")
escreval("*: multiplicação;")

// Lista a operação de soma.

// Lista a operação de subtração.

// Lista a operação de divisão.

// Lista a operação de multiplicação.

leia(o)

escolha o

// Guarda a operação desejada.

caso "+"

// Caso a operação seja soma.

escreval(n,"+",m,"=",n + m)

// Armasse a operação e digita-se o resul-

caso "−"

// Caso a operação seja subtração.

escreval(n,"−",m,"=",n − m)

// Armasse a operação e digita-se o resul-

caso "∗"

// Caso a operação seja multiplicação.

escreval(n,"∗",m,"=",n ∗ m)

// Armasse a operação e digita-se o resul-

tado.

tado.

tado.

caso "/"

// Caso a operação seja divisão.

Atividade final

72

escreval(n,"/",m,"=",n/m)

// Armasse a operação e digita-se o resultado.

fimescolha
Fimalgoritmo

Descreva a criação de linhas de programação que
descrevam uma dada tabuada.

Proposta de resolução:

Var
n,l: real
Inicio
escreval("Digite o valor da tabuada à ser calculada:")

// Variável real.

de multiplicação a ser calculada.

leia(n)

// Guarda a variável n.

// Pede-se o valor da tabuada

l<-1
escreval(n,"x0 = 0")

// l recebe 1.

// Escreve a notação de tabuada e o resultado para o caso em

que a multiplicação é feita por 0.

enquanto l<11 faca

escreval(n,"x",l,"=",l∗n)

// Enquanto l for menor que 11, escreve-se a notação

de multiplicação e seus respectivos resultados.

l<-l+1
fimenquanto
Fimalgoritmo

// l recebe o valor de seu sucessor.

Construa linhas de comando que calculem a média de
um estudante indicando se o mesmo está aprovado ou
não, tomando que o peso da primeira avaliação é 3 e
as demais peso 1, existem 4 avaliações e a média para
aprovação é 6 ou superior.

Proposta de resolução:

Var
a,b,c,d,m,s: real
Inicio
escreval("Digite sua primeira nota:")

// Variável real.

// Pede-se a primeira nota.

Atividade final

73

leia(a)

// Guarda-se o valor da primeira nota.

escreval("Digite sua segunda nota:")

// Pede-se a segunda nota.

leia(b)

// Guarda-se o valor da segunda nota.

escreval("Digite sua terceira nota:")

// Pede-se a terceira nota.

leia(c)

// Guarda-se o valor da terceira nota.

escreval("Digite sua quarta nota:")

// Pede-se a quarta nota.

leia(d)

// Guarda-se o valor da quarta nota.

// m recebe o triplo do valor de b.

// s recebe o valor da soma das notas.

m<-3 ∗ b
s<- a + m + c + d
escreval("Sua média é", s/6)
se s/6>=6 entao

// A média ponderada é calculada e digitada.

escreval("Portanto, está aprovado.")

// Se a média é igual ou superior a 6

digita-se aprovado.

senao

escreval("Portanto, está reprovado.")

// Se a média é inferior a 6 digita-

se reprovado.
fimse
Fimalgoritmo

Construa linhas de comando que indique qual a
relação de maior ou menor entre dois números.

Proposta de resolução:

// Variável vetor.

// Variável inteiro.

Var
v: vetor [1..2] de real
i: inteiro
Inicio
i<-1
repita

// i recebe 1.

escreval(i,"º número:")

leia(v[i])

// Defini-se os dois valores (v [1] e v [2]) a serem ordenados.

i<-i+1

ate i = 3
se v[1]>v[2] entao

escreval(v[1],">",v[2])
senao

// Digita-se caso v [1] > v [2].

escreval(v[1],"<",v[2])

// Digita-se caso v [1] < v [2].

fimse
Fimalgoritmo

Atividade final

74

Em um mercado o quilo da batata custa 4, 00, a alface
custa 1, 60 a unidade e o quilo da carne 30, 00.
Construa uma linha de programação que calcule o
quanto seria gasto em uma compra desses itens em
quantidades variadas.

Proposta de resolução:

Var
b,c,r,s,t: real
a: inteiro
Inicio
escreval("Quantos quilos de batatas foram comprados?")

// Variável real.
// Variável inteiro.

// Pede-se a quantidade

a ser comprada.
leia(b)

// Guarda-se a quantidade de Kg de batatas.

escreval("Quantos maços de alface foram comprados?")

// Pede-se a quantidade a

ser comprada.
leia(a)

// Guarda-se a quantidade maços de alface.

escreval("Quantos quilos de carne foram comprados?")

// Pede-se a quantidade a

ser comprada.
leia(c)

// Guarda-se a quantidade de Kg de carne.

// Custo da batata.
r<-4 ∗ b
// Custo da alface.
s<-a ∗ 1.6
t<-c ∗ 30
// Custo da carne.
escreval("Será gasto",r +s+t,"no mercado.")
Fimalgoritmo

// Escreve-se o valor total da compra.

Construa as linhas de programação capazes de
classificar em par ou impar qualquer número natural.

Proposta de resolução:

Var
n: inteiro
Inicio

// Variável inteira.

escreval("Digite o valor a ser analisado:")

// Pede-se o número a ser analisado.

leia(n)

// Guarda-se o valor de n.

se n MOD 2 = 0 entao

escreval(n, "é par.")
senao

// Se 2 divide n, então digita “é par”.

Atividade final

75

escreval(n, "é impar.")

// Se 2 não divide n, então digita “é impar”.

fimse
Fimalgoritmo

5.5.3 3ª, 4ª e 5ª etapas

Nessas etapas o docente tem que tanto atacar os conceitos teóricos que envolvem a
ideia de divisores como algumas aplicações do cotidiano do estudante que envolvam esse
conceito.

É fundamental decorrer da relação entre teoria e prática, pois dessa forma se cria um
elo de significância maior, estabelecida entre o estudante e o conteúdo a ser desenvolvido.
Logo após o docente deve discutir com os alunos características dos divisores. Para
isso, aconselha-se estimular que os estudantes busquem e deixem registrados os divisores
de alguns números da escola do professor.

Depois disso, cabe ao professor chamar atenção para algumas propriedade e caracte-

rísticas de evidência como, por exemplo,

• O fato de alguns números só possuírem dois divisores distintos; e,

• Números escritos na potência dois terem certo padrão na quantidade de divisores.

Feito estas análises o professor deve pedir aos estudantes que desenvolvam um fluxo-
grama que descreva o processo de obtenção dos divisores de um número natural qualquer.
Como esse fluxograma, o aluno deve ser questionado sobre quais funções, operadores
e comandos de repetição deve dispor para trazer o produto desenvolvido na 4ª etapa para
a linguagem de programação do VisualG.

5.5.4

6ª, 7ª e 8ª etapas

As etapas que seguem tem desenvolvimento muito semelhante ao empregado na Sub-

seção 5.5.3.

Como temas de discussão, o docente pode lançar temas como os que decorrem abaixo
para aguçar o estudante e dar uma dimensão de como as ferramentas de MMC e MDC
podem e são utilizadas em variadas tarefas.

Assim, aconselhamos discussões como, por exemplo,

• Movimento de astros: Os astros como, por exemplo, os que compõe o Sistema
Solar, se alinham em determinado ponto sobre a descrição de períodos específicos.
A fim de descobrir tais momentos podemos nos valer dos conceitos relativos a MMC.

• Otimização: muitos exemplos de otimização como, por exemplo, o corte de tecidos
ou peças em partes iguais sobre as maiores dimensões, são solucionados com técnicas
simples envolvendo MDC.

• Sistemas de criptografias: sistemas de que exigem alto nível de segurança exigem
senhas e padrões de difícil acesso, a não ser, que tenhamos a chave do código. Devido
as dificuldades de se obter e encontrar os números primos, estes se mostram bem
interessantes para compor tais sistemas de segurança.

Atividade final

76

5.5.5 9ª, 10ª e 11ª etapas

Para desenvolvimento do Teorema Fundamental da Aritmética, aconselhamos um pro-

cedimento análogo ao até agora empregado nas Subseções 5.5.3 e 5.5.4.

Chamamos a atenção para as discussões teóricas envolvendo esse teorema. Vale res-
saltar ao estudante os casos em que n = 0 e n = 1, sendo n ∈ N o número decomposto
pelo TFA.

Essas discussões auxiliaram no desenvolvimento, tanto do fluxograma como da própria

linguagem de programação.

5.5.6

12ª e 13ª etapas

Nessa parte final, o docente deverá auxiliar os estudantes a agrupar as linhas de
programação construídas no decorrer do trabalho. A seguir deixamos uma possível forma
de agrega-las, tomando as linhas de programação sugeridas anteriormente.

LINHAS DE PROGRAMAÇÃO

Var
n,j,c,m,a,s,mdc,mdcr,d,b,t,r,q: inteiro
Inicio
j<-1
enquanto j = 1 faca

escreval("Digite o número que deseja conhecer:")

leia(n)

escreval(“- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
escreval(“
")
escreval(“- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")

RG DOS NÚMEROS

escreval("Nome:", n)

se n=1 entao

escreval("( ) Par (X) Impar")
escreval("Sucessor: 2")
escreval("Antecessor: 0")
escreval("mdc(1,2) = 1.")
escreval("Decomposição: Não existe decomposição.")
escreval("1: recomeçar/2: finalizar")

leia(j)

fimse

se n=0 entao

escreval("(X) Par ( ) Impar")
escreval("Sucessor: 1")
escreval("Antecessor: -")
escreval("Decomposição: Não existe decomposição.")
escreval("1: recomeçar/2: finalizar")

Atividade final

77

leia(j)

fimse

se n>=2 entao
c<-2
enquanto (n MOD c <> 0) faca

c<-c+1
fimenquanto
se c=n entao

escreval("(X) Primo ( ) Composto")
senao

escreval("( ) Primo (X) Composto")

fimse

se n MOD 2 = 0 entao

escreval("(X) Par ( ) Impar")
senao

escreval("( ) Par (X) Impar")

fimse

se n=2 entao

escreval("2 é o único par primo existente.")

fimse
escreval("Antecessor:", n-1)
escreval("Sucessor:", n+1)
escreva("Divisores: 1,")

para m de 2 ate n div 2 faca

se (n MOD m = 0) entao
escreva(m,",")

fimse

fimpara

escreval(n, ".")

a<- n-1
s<- n+1
mdc<-1
d<-1

enquanto (a div d>0) e (n div d>0) faca

se ((a MOD d=0) e (n MOD d=0)) entao

se d>=mdc entao

mdc<-d

fimse

fimse

d<-d+1
fimenquanto

Atividade final

78

escreval("mdc(",a,",",n,") = ",mdc,".")
b<-1
mdcr<-1

enquanto (s div b>0) e (n div b>0) faca

se ((s MOD b=0) e (n MOD b=0)) entao

se b>=mdc entao

mdc<-b

fimse

fimse

b<-b+1
fimenquanto

escreval("mdc(",s,",",n,") = ",mdcr,".")
escreva("Decomposição:")
q<-2

enquanto (n MOD q <> 0) faca
q<-q+1
fimenquanto

se q=n entao

escreval("Sem decomposição")
senao

para t de 2 ate n div 2 faca
r<-2

enquanto (t MOD r <> 0) faca
r<-r+1

fimenquanto

se r=t entao
repita

se (n MOD t = 0) entao
escreva(t,".")
n<-n div t
fimse

ate n MOD t <> 0

fimse

fimse
escreval()

fimpara

escreval("1: recomeçar/2: finalizar")

leia(j)

fimse
fimenquanto
Fimalgoritmo

A Função Gama

Iniciamos tomando a definição dessa função .

Definição A.1. A função Γ : (0, ∞) → R é definida para cada x, por Γ (x) = R ∞
0

tx−1e−tdt.

A fim de estabelecer demonstrações plausíveis e completas tomemos dois resultados

importantes.

Propriedade A.2. A função Γ é bem definida.

Demonstração. Tomando f (x) = tx−1e−t, temos que ela é continua e o Teorema de Wei-
erstrass garante que é limitada no intervalo [0, L], portanto R ∞

L tx−1e−tdt existe.

Abordando R ∞

L tx−1e−tdt.

t

2 > tx−1 ⇒
e
−t
2 > e−ttx−1 ≥ 0 ⇒

e

Z ∞

−t
2 dt >

e

!

−t
2 dt

e

>

L
 Z b

L

lim
b→∞

−2 lim
b→∞

(cid:16)

−b
2 − e

e

−L
2

(cid:17)

>

2e

−L
2 >

Z ∞

L
Z ∞

L
Z ∞

1
Z ∞

1

e−ttx−1dt ≥ 0 ⇒

e−ttx−1dt ≥ 0 ⇒

e−ttx−1dt ≥ 0 ⇒

e−ttx−1dt ≥ 0.

Como, para x > 0, temos R L

0 tx−1e−tdt e R ∞

L tx−1e−tdt convergem, Γ (x) também con-

verge.

O Lema a seguir será usado posteriormente, nas propriedades de Γ.

Lema A.3. R ∞

−∞ e−x2dx =

√

π.

Demonstração. Tomando A = R ∞

−∞ e−x2dx = R ∞

−∞ e−y2dy e que A converge. Assim,

A2 =

=

(cid:18)Z ∞

e−x2dx
Z ∞

−∞

Z ∞

(cid:19) (cid:18)Z ∞

−∞

(cid:19)

e−y2dx

e−(x2+y2)

dxdy.

−∞

−∞

79

Função Gama

80

Adotando, sobre coordenadas polares que x = r cos θ, y = r sen θ, temos que:

A2 =

Z 2π

Z ∞

0

−∞

e−r2rdrdθ.

Fazendo a mudança de variável u = r2, que implica du
2

= rdr temos,:

Z 2π

Z ∞

A2 =

e−u
2 dudθ

0
0
Z ∞
= π
e−udu
 Z b

0

= π lim
b→∞

0

!

e−udu

= π.

Portanto,

A =

Z ∞

−∞

e−x2dx =

√

π.

A função possui as quatro propriedades abaixo.

Proposição A.4. A função Gama, expressa por Γ, possui como propriedades:

P1. Γ (1) = 1.

P2. Γ (x + 1) = xΓ (x).

P3. Γ

(cid:18) 1
2

(cid:19)

=

√

π.

P4. Γ (n + 1) = n!.
Demonstração.

P1. Tomemos Γ (x) = R ∞
0

tx−1e−tdt, com x = 1.

Γ (1) =

Γ (1) =

Z ∞

0
Z ∞

0

Γ (1) = lim
b→∞

t1−1e−tdt ⇒

e−tdt ⇒
 Z b

!

e−tdt

⇒

0
−e−t|b
0

(cid:17)

−e−b −
1

(cid:18)

−

eb

Γ (1) = lim
b→∞
Γ (1) = lim
b→∞

(cid:16)

(cid:16)

Γ (1) = lim
b→∞

Γ (1) = 1.

(cid:16)

⇒
−e0(cid:17)(cid:17)
(cid:19)

⇒

+ 1

⇒

Função Gama

81

P2.

Γ (x + 1) =

Z ∞

0

Γ (x + 1) = lim
b→∞

Usando integral por partes e adotando,

txe−tdt ⇒
 Z b

!

txe−tdt

.

0

u = tx → du = xtx−1dt
dv = e−tdt → v = −e−t,

.

temos,

Γ (x + 1) = lim
b→∞

 Z b

0

!

txe−tdt

⇒

Γ (x + 1) = lim
b→∞

−txe−t|b

0 −

!

−e−txtx−1dt

⇒

Z b

0

Γ (x + 1) = lim
b→∞

Γ (x + 1) = lim
b→∞

Γ (x + 1) = lim
b→∞

 −bx
eb
  −bx
eb
Z b

x

0

!

e−txtx−1dt

⇒

Z b

+

0

!

!

e−txtx−1dt

⇒

+ lim
b→∞

 Z b

0

!

e−ttx−1dt

⇒

Γ (x + 1) = x

Z ∞

0

e−txtx−1dt ⇒

Γ (n + 1) = xΓ (x) .

P3. Para essa demonstração tomemos o Lema A.3.

Z −∞

∞

e−x2dx =

√

π.

Observando que a função e−x2 é par, podemos reescrever:

Z ∞

2

0

e−x2dx =

√

π.

Substituindo x2 = u, implicando que du = dx
√
2
u

, temos que:

Z ∞

2

0

u

Z ∞

0

1

du =

e−u
√
2
u
2 −1e−udu =
(cid:18) 1
2

=

Γ

(cid:19)

√

√

√

π ⇒

π ⇒

π.

 
 
Função Gama

82

P4. Provemos por indução finita.

Tomando para n = 1, fica trivial utilizando o item P1.
Por hipótese de indução tomemos ser válida para um k, sendo Γ (k) = (k − 1)!.
Provemos implicar para o caso k + 1, utilizando o item P2.

Γ (k + 1) = k · Γ (k) ⇒
Γ (k + 1) = k · (k − 1)! = k!.

□

B Linhas de programação -
Algoritmo p-ádica e algoritmo das
matrizes

LINHAS DE PROGRAMAÇÃO: ALGORÍTIMO P-ÁDICA

Var

a, p, m, c, s, n, v, mult, guardar, somaf im, t, q, k, u, quociente, f, soma, r, alpha: inteiro

Inicio

n<-2
enquanto n <= 100 faca

c<-2
enquanto (n MOD c <> 0) faca

c<-c + 1

fimenquanto
se c = n entao
p<-n
alpha<-1

enquanto alpha <= 100 faca

cronometro on
a<-alpha
somaf im<-0

repita

s<-a
m<-0

repita

m<-m + 1
a<-a div p

ate a = 0

t<-m
u<-m − 1

se u = 0 entao

guardar<-s
somaf im<-somaf im + guardar
a<-0

fimse
se u <> 0 entao

83

Linhas de programação - Algoritmo p-ádica e algoritmo das matrizes

84

k<-1
soma<-0

repita

k<-p*k
soma<-k + soma
u<-u − 1

ate u = 0

r<-soma

se s = soma entao

escreval(p,,alpha)
a<-0

fimse

se s <> soma entao

repita

m<-t
v<-p − 1
k<-1

repita

k<-p*k
m<-m − 1

ate m = 0

q<-k − 1
v<-v*s
quociente<- v div q
t<-t − 1
ate quociente > 0

f <-t
k<-1

repita

k<-k*p
t<-t − 1

ate t = 0
guardar<-quociente*k
k<-1
soma<-0
t<-f

repita

k<-k*p
soma<-k + soma
t<-t − 1

ate t = 0
soma<-soma + 1
mult<-quociente*soma
a<-s − mult
somaf im<-somaf im + guardar

fimse

fimse

ate a=0

Linhas de programação - Algoritmo p-ádica e algoritmo das matrizes

85

se s<>r entao

escreval(p,,alpha)

fimse
alpha<-alpha+1

cronometro off

fimenquanto

fimse

n<-n + 1

fimenquanto
Fimalgoritmo

A seguir temos as linhas de programação do algoritmo das matrizes.

LINHAS DE PROGRAMAÇÃO: ALGORÍTIMO DAS MATRIZES

Var

p, a, t, k, d, l, soma, somaa, r, b, s, m, n, solucao, i, j, h, f, g, q, z, repetir, c, num: inteiro

Inicio
num<-2

enquanto num <= 10 faca

c<-2

enquanto (num MOD c <> 0) faca

c<-c + 1

fimenquanto

se c = num entao
a<-1

enquanto a<=10 faca

cronometro on
p<-num
t<- p*p + p + 1
g<-p + 1
b<-p*p + p − 1

se a < t entao

k<-1

p ∗ p∗(k − 1)

se a<=b entao

se a MOD g <> 0 entao
se a MOD g = p entao

",a)

escreval(p,"
senao
h<-a div g
j<-a MOD g
i<-h + 1
solucao<- p ∗ j + p ∗ p∗(i − 1)+p ∗

escreval(p,"

",a)

fimse

fimse

se a MOD g = 0 entao

j<-p
i<- a div g

Linhas de programação - Algoritmo p-ádica e algoritmo das matrizes

86

p ∗ p∗(k − 1)

solucao<- p ∗ j + p ∗ p∗(i − 1)+p ∗

1

p ∗ p∗(k − 1)

k<-

escreval(p,"

",a)

fimse

fimse

se a > b entao
escreval(p,"

fimse

",a)

fimse

se a = t entao

k<-1
j<-p
i<-p
solucao<- p∗j+p∗p∗(i−1)+p∗p∗p∗(k−1)
escreval(p,"

",a)

fimse

se a > t entao

repita

d<-0
l<-0
n<-t ∗ k
repita

l<-k div p
d<-d + l
k<-k div p

ate l<=0
k<-n div t
soma<- n + d
k<-k + 1
ate a<=soma

k<-k − 1

se soma = a entao

j<-p
i<-p
solucao<- p ∗ j + p ∗ p∗(i − 1)+p ∗

escreval(p,"

",a)

fimse

se soma<>a entao

k<-k − 1
m<-t ∗ k
r<-0

repita

s<-k div p
r<-r + s
k<-k div p

ate s<=0

Linhas de programação - Algoritmo p-ádica e algoritmo das matrizes

87

somaa<-m + r
k<- m div t
f <- a − somaa

se f <=b entao

se f MOD g <> 0 entao
se f MOD g = p entao

escreval(p,"
senao

",a)

k<-k + 1
h<-f div g
j<-f MOD g
i<-h + 1
solucao<- p ∗

escreval(p,"

",a)

fimse

fimse

se f MOD g = 0 entao

k<-k + 1
j<-p
i<- f div g
solucao<- p∗j+p∗p∗(i−1)+p∗

escreval(p,"

",a)

fimse

fimse

se f > b entao
escreval(p,"

",a)

fimse

fimse

j + p ∗ p∗(i − 1)+p ∗ p ∗ p∗(k − 1)

p ∗ p∗(k − 1)

fimse

a<-a + 1
cronometro off

fimenquanto

fimse
num<-num + 1

fimenquanto
Fimalgoritmo

Referências Bibliográficas

[LDB 1996]

LDB: Leis de diretrizes básicas. 1996

[BNCC 2018] BNCC: Base Nacional Comum Curricular. Bd. 3◦ versao. 2018. – 598 S

[Instituto Federal de educaç ao 2022]

ao, ciência e t. Instituto Federal de educaç
MANUAL DO VISUALG. 2022. – URL http://www.inf.ufsc.br/~bosco.sobral/
ensino/ine5201/Visualg2_manual.pdf

[HEFEZ 2016] HEFEZ, Abramo: Aritmética. 2016

[Olimpédia ] Olimpédia: Formula de Polignac

[Parreira 2017] Parreira, Fábio: INTRODUÇÃO A ALGORITMOS. 2017. – URL
http://www.inf.ufsc.br/~bosco.sobral/ensino/ine5201/Visualg2_manual.pdf

[RAMIREZ 2005] RAMIREZ, Julieth Paola S.:

FUNCAO GAMA.

In: UNI-

CAMP/IMECC (2005)

[Sensagent ]

Sensagent: definition − de polignac s formula

[SOUTO 2017]

SOUTO, Flavia Cristine F.: O ensino de matemática e a resolução
de problemas contextualizados nos anos iniciais do ensino fundamental. In: Encontro
Paranaense de Educacao Matemática (2017)

[VALENTE 2016] VALENTE, José A.: Integração do pensamento computacional no
currículo da educação básica: diferentes estratégias usadas e questões de formação de
professor e avaliação do aluno. In: e−Curriculum (2016)

[VISUALG ] VISUALG: VisualG

[Wikipédia 2021] Wikipédia: Formula de Legendre. 2021. – URL https://pt.

abcdef.wiki/wiki/Legendre’s_formula

[WING 2014] WING, Jeannette M.: Computational Thinking Benefits Society. In:

Microsoft Research (2014)

