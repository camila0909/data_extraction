UNIVERSIDADE FEDERAL DE SANTA CATARINA
BIBLIOTECA UNIVERSIT´ARIA

Gra¸ca Aparecida Prestes Sabadin

C ´ODIGOS CORRETORES DE ERROS

Florian´opolis

2019

Gra¸ca Aparecida Prestes Sabadin

C ´ODIGOS CORRETORES DE ERROS

Disserta¸c˜ao submetida ao Pro-
grama de Mestrado Proﬁs-
sional em Matem´atica da Uni-
versidade Federal de Santa
Catarina para a obten¸c˜ao
do Grau de Mestre em Ma-
tem´atica.
Orientador: Prof. Dr. Edu-
ardo Tengan

Florian´opolis

2019

Ficha de identificação da obra elaborada pelo autor, através do Programa de Geração Automática da Biblioteca Universitária da UFSC.Sabadin, Graça Aparecida Prestes   Códigos Corretores de Erros / Graça AparecidaPrestes Sabadin ; orientador, Eduardo Tengan, 2019.   79 p.   Dissertação (mestrado profissional) -Universidade Federal de Santa Catarina, Centro deCiências Físicas e Matemáticas, Programa de PósGraduação em Matemática, Florianópolis, 2019.   Inclui referências.    1. Matemática. 2. Códigos Lineares. 3. Código deHamming. 4. Códigos Cíclicos. 5. Código de ReedSolomon. I. Tengan, Eduardo. II. UniversidadeFederal de Santa Catarina. Programa de Pós-Graduaçãoem Matemática. III. Título.Gra¸ca Aparecida Prestes Sabadin
C ´ODIGOS CORRETORES DE ERROS

O presente trabalho em n´ıvel de mestrado foi avaliado e aprovado por banca exami-

nadora composta pelos seguintes membros:

Banca Examinadora

Prof. Dr. Abdelmoubine Amar Henni
Universidade Federal de Santa Catarina.

Prof. Dr. Eliezer Batista
Universidade Federal de Santa Catarina.

Prof. Dr. Giuliano Boava
Universidade Federal de Santa Catarina.

Certiﬁcamos que esta ´e a vers˜ao original e ﬁnal do trabalho de conclus˜ao que foi

julgado adequado para obten¸c˜ao do t´ıtulo de mestre em Matem´atica.

Prof. Dra. Maria Inez Cardoso Gon¸calves
Coordenadora
Universidade Federal de Santa Catarina

Prof. Dr. Eduardo Tengan
Orientador
Universidade Federal de Santa Catarina

Florian´opolis, 12 de setembro 2019 .

`A minha fam´ılia.

AGRADECIMENTOS

Ao meu orientador, Professor Dr. Eduardo Tengan, por ser um grande mestre, n˜ao
s´o pelo seu saber, mas principalmente por sua generosidade e paciˆencia, com que conduziu
esse trabalho, a ele minha eterna gratid˜ao e respeito.

Aos Professores da banca examinadora pelas contribui¸c˜oes.

Ao professor Dr. Celso Melchiades Doria, por acreditar e lutar pelo PROFMAT.

Aos professores do Profmat, pela dedica¸c˜ao na realiza¸c˜ao das aulas.

Aos colegas de mestrado, pela amizade e companheirismo.

Obrigada, Antˆonio, por teres feito minha inscri¸c˜ao no ENA. Obrigada, Waldir, pelo
apoio ao emprestar-me todos os livros para a realiza¸c˜ao do curso. Obrigada, Valmir´e e
Angelita, pelo companheirismo nesta jornada. (Valmir´e, valeu as in´umeras caronas.)

`A CAPES, pelo apoio ﬁnanceiro.

Queira
Basta ser sincero e desejar profundo
Vocˆe ser´a capaz de sacudir o mundo, vai
Tente ou. . . tra vez
Tente
E n˜ao diga que a vit´oria est´a perdida
Se ´e de batalhas que se vive a vida
Tente outra vez

(Raul Seixas, 1975)

RESUMO

Este trabalho ´e dedicado ao estudo de c´odigos corretores de erros, os quais tˆem como base
matem´atica a aritm´etica e a ´algebra linear. Ser˜ao abordados os c´odigos lineares, tendo
como exemplo o C´odigo de Hamming, e uma subclasse dos c´odigos lineares que s˜ao os
c´odigos c´ıclicos onde apresentaremos o C´odigo de Reed-Solomon.

Palavras-chave: C´odigos corretores de erros, C´odigos Lineares: C´odigo de Hamming,

C´odigo C´ıclicos: C´odigo de Reed-Solomon

ABSTRACT

This work is dedicated to the study of error correcting codes, which are mathematically
based on arithmetic and linear algebra. Linear codes will be addressed, taking as an
example the Hamming Code, as well as a subclass of linear codes, the cyclic ones, of
which we shall present the Reed-Solomon Code.

Keywords: Error Correction Codes, Linear Codes: Hamming Code, Cyclic Code: Reed-

Solomon Code

LISTA DE FIGURAS

Figura 1 Claude Shannon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

Figura 2 Richard Hamming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

Figura 3 Teoria C´odigos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

Figura 4 Cubo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

Figura 5 Esferas S1 e S2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

Figura 6 Volume da bola (“camadas de cebola”) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

Figura 7 Empacotamento de Esferas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

SUM ´ARIO

INTRODU ¸C ˜AO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
TEORIA DE C ´ODIGOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
DECODIFICA ¸C ˜AO, DETEC ¸C ˜AO E CORRE ¸C ˜AO DE ERROS . . . . . . . . . . .
O PROBLEMA PRINCIPAL DA TEORIA DE C ´ODIGOS . . . . . . . . . . . . . . .
28
C ´ODIGOS LINEARES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

25

MATRIZ GERADORA E MATRIZ DE PARIDADE . . . . . . . . . . . . . . . . . . . .
EXEMPLO: C ´ODIGOS DE HAMMING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ALGORITMO DE DECODIFICA ¸C ˜AO PARA OS C ´ODIGOS DE HAM-
MING BIN ´ARIOS: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MATRIZ GERADORA E MATRIZ DE PARIDADE NA FORMA CAN ˆO-

34

36

39

NICA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DISTˆANCIA M´INIMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
44
C ´ODIGOS C´ICLICOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
POLIN ˆOMIO GERADOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

42

47

51
MATRIZ GERADORA E MATRIZ DE PARIDADE . . . . . . . . . . . . . . . . . . . .
C ´ODIGOS DE REED-SOLOMON (RS) . . . . . . . . . . . . . . . . . . . . . . . . . 57

ORDEM E ELEMENTO PRIMITIVO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C ´ODIGOS DE REED-SOLOMON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DISTˆANCIA M´INIMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

ALGORITMO DE PETERSON-GORENSTEIN-ZIERLER (PGZ) . . . . . . . .

57

60

61

62

63

1

2

2.1

2.2

3

3.1

3.2

3.3

3.4

3.5

4

4.1

4.2

5

5.1

5.2

5.3

5.4

5.4.1 Descri¸c˜ao do algoritmo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5.4.2 Exemplos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

69
CONCLUS ˜AO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

6

Referˆencias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

19

1 INTRODU ¸C ˜AO

Os c´odigos corretores de erros est˜ao presentes em toda a parte no nosso cotidiano,

como por exemplo: Wi-ﬁ, CDs, DVDs, QRCode, transmiss˜ao de dados via sat´elite, teleco-

munica¸c˜oes, etc. A ideia b´asica da teoria ´e a codiﬁca¸c˜ao da informa¸c˜ao enviada, a qual ´e

feita adicionando informa¸c˜oes redundantes `a mensagem inicial, de modo que o receptor da

mensagem consiga identiﬁcar poss´ıveis erros causados pelo ru´ıdo na transmiss˜ao e desta

forma possa recuperar a mensagem inicial.

Historicamente, a teoria teve in´ıcio com os trabalhos de Shannon e Hamming por

volta de 1950. Claude Elwood Shannon (1916–2001), matem´atico e nesta ´epoca funcion´a-

rio da empresa Bell Labs, publicou em 1948 um artigo cient´ıﬁco chamado “A mathematical

theory of communication” no Bell System Journal. Este trabalho ´e considerado o marco

inicial da Teoria de Informa¸c˜oes, na qual a teoria dos c´odigos corretores tem papel im-

portant´ıssimo. Neste artigo, Claude Shannon questiona sobre qual ´e a melhor maneira de

codiﬁcar uma informa¸c˜ao.

Figura 1 – Claude Shannon

Richard Wesley Hamming (1915–1998), matem´atico, funcion´ario da Bell Labs de

1946 a 1976, e colega de trabalho de Claude Shannon, investigou durante anos o problema

de corre¸c˜ao de erros e em 1950 publicou o algoritmo chamado “Hamming Code”, o qual ´e

utilizado em in´umeras ´areas da computa¸c˜ao. Outras importantes contribui¸c˜oes de Richard

Hamming para a teoria dos c´odigos corretores de erros s˜ao: Distˆancia de Hamming e

Empacotamento de Esferas, assuntos que tamb´em ser˜ao abordadas neste trabalho. Em

1976, ele mudou-se para a Naval Postgraduate School, onde foi professor adjunto at´e 1997

quando se tornou professor em´erito. No Youtube ´e poss´ıvel assistir a in´umeras aulas do

20

Figura 2 – Richard Hamming

professor Richard Hamming, sendo uma delas sobre c´odigos corretores de erros. Assista

em https://youtu.be/BZh07Ew32UA

Em seguida, faremos uma breve descri¸c˜ao dos t´opicos abordados neste trabalho.

No cap´ıtulo 2, ser˜ao apresentados os conceitos, deﬁni¸c˜oes, termos utilizados e alguns

exemplos da teoria b´asica de c´odigos corretores de erros.

Os c´odigos lineares s˜ao a classe de c´odigos mais utilizada e apresentaremos no ca-

p´ıtulo 3 deﬁni¸c˜oes necess´arias para o seu desenvolvimento. Em especial, trataremos de

um dos principais c´odigos lineares, o c´odigo de Hamming, desenvolvido por Richard Ham-

ming, o qual ´e utilizado amplamente nas telecomunica¸c˜oes, no processamento de sinal e

nas mem´orias dos computadores, devido `a sua simplicidade, pois permite a transferˆencia

e armazenamento de dados de forma eﬁciente e segura.

No Cap´ıtulo 4, veremos uma subclasse dos c´odigos lineares, os c´odigos c´ıclicos, e

apresentaremos as deﬁni¸c˜oes necess´arias para a sua cria¸c˜ao. Dentre os in´umeros c´odigos

c´ıclicos que existem estudaremos no cap´ıtulo seguinte o C´odigo de Reed-Solomon (RS).

Os C´odigos Reed-Solomon tiveram a importante aplica¸c˜ao de codiﬁcar as imagens

digitais enviadas pela sonda espacial Voyager, em 1977, tornando-se difundida nas comu-

nica¸c˜oes por sat´elite. Vers˜oes mais modernas foram e s˜ao utilizadas nas miss˜oes Mars

Pathﬁnder, Galileo, Mars Exploration Rover e Cassini.

A codiﬁca¸c˜ao Reed-Solomon ´e amplamente utilizada em sistemas de armazenamento

em massa para corrigir os erros de rajada associados a defeitos de m´ıdia. Sendo um com-

ponente importante do CD, primeiro uso de uma forte codiﬁca¸c˜ao em produto de consumo

produzido em larga escala. S˜ao utilizados tamb´em em c´odigos de barras bidimensionais,

permitindo a leitura mesmo que uma parte do c´odigo de barras esteja daniﬁcada.

Para a decodiﬁca¸c˜ao e detec¸c˜ao de erros no c´odigo Reed-Solomon, utilizaremos o

algoritmo de Peterson-Gorenstein-Zieler, desenvolvido por Daniel Gorenstein e Neal Zier-

ler, o qual foi descrito em um relat´orio do MIT Lincoln Laboratory de Zierler em janeiro

de 1960, e cuja descri¸c˜ao se encontra no livro “Error Correcting Codes”, de W. Wesley

Peterson (1961).

21

22

23

2 TEORIA DE C ´ODIGOS

A situa¸c˜ao geral considerada em Teoria de C´odigos pode ser esquematizada na se-

guinte ﬁgura:

mensagem enviada

codiﬁca¸c˜ao

mensagem codiﬁcada

canal de transmiss˜ao

mensagem decodiﬁcada

decodiﬁca¸c˜ao

mensagem recebida

Figura 3 – Teoria C´odigos

As mensagens codiﬁcadas e recebidas s˜ao palavras formadas por uma sequˆencia de

s´ımbolos de um mesmo alfabeto. Para o envio da mensagem ser´a utilizado um canal

de transmiss˜ao que poder´a ter ru´ıdo, desta forma a mensagem recebida poder´a conter

erros ou s´ımbolos apagados e ser´a diferente da mensagem enviada. O estudo dos c´odigos

tem como objetivo encontrar c´odigos que enviem o maior n´umero de palavras com maior

rapidez, e que tenha capacidade de detectar e corrigir erros de modo eﬁciente.

Vamos deﬁnir alguns termos utilizados na teoria dos c´odigos.

Deﬁni¸c˜ao 2.0.1. (a) Um alfabeto ´e um conjunto ﬁnito de s´ımbolos Aq = {a1, . . . , aq}.

(b) Uma palavra ´e uma sequˆencia ﬁnita de elementos do alfabeto Aq.

(c) Um c´odigo q-´ario ´e um conjunto ﬁnito de palavras sobre um alfabeto de q elementos.

Ao logo do texto nos referiremos a c´odigo q-´ario como c´odigo.

(d) Se todas as palavras do c´odigo C tˆem o mesmo comprimento n, isto ´e, se C ⊂ An
q ,

ent˜ao C diz-se um c´odigo uniforme.

(e) Denotamos por (n, M )q um c´odigo uniforme q-´ario com M palavras de comprimento

n.

Um alfabeto pode ser qualquer conjunto ﬁnito de s´ımbolos `a nossa escolha. S˜ao
tamb´em alfabetos os an´eis Z/(m) = {0, 1, . . . , m − 1} (com m ≥ 2 um n´umero inteiro).
Quando Z/(2) = {0, 1} o c´odigo diz-se bin´ario, e se Z/(3) = {0, 1, 2} o c´odigo diz-se
tern´ario. Note-se que Z/(2) e Z/(3) tˆem estrutura de corpo.

Utilizaremos a nota¸c˜ao x1x2 . . . xn para a palavra (x1, x2, . . . , xn) ∈ An

q , assim um
vetor (¯1, ¯0, ¯1) ∈ (Z/(2))3 ser´a denotado por 101, e que tamb´em omitiremos as barras (se

24

n˜ao houver perigo de confus˜ao).

O conjunto das letras A = {a, b, c, . . . , w, y, z} ´e um alfabeto, e o conjunto de todas

as palavras portuguesas formam um c´odigo P sobre A que n˜ao ´e uniforme. Nem todas as

palavras no alfabeto A s˜ao palavras do c´odigo P ; assim se recebermos uma palavra que n˜ao

pertence a P , sabemos que ocorreu um erro na transmiss˜ao. Por exemplo, suponhamos

que recebamos a palavra “calend´aris”, percebemos que ela n˜ao pertence a P , ent˜ao o

erro foi detectado e corrigiremos “calend´aris” para a palavra mais pr´oxima em P , que ´e

“calend´ario”. Isto motiva introduzirmos a seguinte deﬁni¸c˜ao de distˆancia entre palavras:

Deﬁni¸c˜ao 2.0.2. Sejam x = x1x2 . . . xn, y = y1y2 . . . yn ∈ An
Hamming entre as palavras x e y por:

q . Deﬁne-se a distˆancia de

d(x, y) = # {i : xi (cid:54)= yi} .

Ou seja, d(x, y) ´e o n´umero de coordenadas em que x e y diferem, ou ainda, d(x, y) ´e o

n´umero m´ınimo de trocas de s´ımbolos necess´arias para obter y a partir de x.

Deﬁni¸c˜ao 2.0.3. Seja C um c´odigo contendo pelo menos duas palavras. Deﬁne-se a

distˆancia m´ınima de C por:

d(C) = min{d(x, y) : x, y ∈ C, x (cid:54)= y}.

Se C ´e um c´odigo q-´ario com M palavras de comprimento n e distˆancia m´ınima d(C) = d,

dizemos que C ´e um c´odigo (n, M, d)q. Os n´umeros n, M e d dizem-se parˆametros de

C.

O parˆametro d(C) ser´a muito importante para discutirmos capacidade de detec¸c˜ao

de erros de um c´odigo C.

Proposi¸c˜ao 2.0.4. A distˆancia de Hamming ´e uma m´etrica, isto ´e, veriﬁca as seguintes

propriedades:

(i) d(x, y) ≥ 0 ∀x, y ∈ An
q ;

(ii) d(x, y) = 0 ⇔ x = y;

(iii) simetria: d(x, y) = d(y, x) ∀x, y ∈ An
q ;

(iv) desigualdade triangular: d(x, y) ≤ d(x, z) + d(z, y) ∀x, y, z ∈ An
q .

Estas propriedades s˜ao consequˆencia direta da deﬁni¸c˜ao de distˆancia de Hamming.

25

Exemplo 2.0.5 (Distˆancia de Hamming). Deﬁnimos o seguinte c´odigo composto pelos

vetores:

v0 = (0, 0, 0)

v1 = (0, 0, 1)

v2 = (0, 1, 0)

v3 = (0, 1, 1)

v4 = (1, 0, 0)

v5 = (1, 0, 1)

v6 = (1, 1, 0)

v7 = (1, 1, 1).

Temos que as distˆancias entre os vetores s˜ao:

v0

v1

v2

v3

v4

v5

v6

v7

v0

v1

v2

v3

v4

v5

v6

v7

0

1

1

2

1

2

2

3

1

0

2

1

2

1

3

2

1

2

0

1

2

3

1

2

2

1

1

0

3

2

2

1

1

2

2

3

0

1

1

2

2

1

3

2

1

0

2

1

2

3

1

2

1

2

0

1

3

2

2

1

2

1

1

0

A distˆancia deste c´odigo pode ser observada geometricamente no cubo, sendo cada um

dos seus v´ertices um dos vetores. Para calcularmos a distˆancia entre os vetores devemos

veriﬁcar qual o menor n´umero de arestas necess´arias para conect´a-los. Assim, por exemplo,

os vetores que est˜ao `a distˆancia 1 de v0 s˜ao facilmente encontrados: v1, v2 e v4.

v1

v0

v5

v4

v7

v6

v3

v2

Figura 4 – Cubo

2.1 DECODIFICA ¸C ˜AO, DETEC ¸C ˜AO E CORRE ¸C ˜AO DE ERROS

A seguir, veremos maneiras de, encontrado um erro na mensagem enviada (ou seja,

a palavra recebida n˜ao pertence ao c´odigo), determinar os casos em que conseguiremos

corrigi-lo para a palavra mais pr´oxima no c´odigo. A formula¸c˜ao precisa do problema ´e

dada pela

26

Deﬁni¸c˜ao 2.1.1 (Decodiﬁca¸c˜ao por distˆancia m´ınima). Recebida a palavra y ∈ An
q ,
procurar x(cid:48) ∈ C tal que

d (x(cid:48), y) = min{d(x, y) : x ∈ C}.

Por C ser ﬁnito, o conjunto {d(x, y) : x ∈ C} tamb´em ´e ﬁnito e o m´ınimo na
deﬁni¸c˜ao anterior sempre existe, embora, em geral, n˜ao haja um ´unico x(cid:48) ∈ C que esteja

a esta distˆancia m´ınima de y.

Deﬁni¸c˜ao 2.1.2. Seja C um c´odigo e sejam s e t n´umeros inteiros positivos.

(a) Diz-se que C detecta s erros se e s´o se, quando ocorrem s erros ou menos, a palavra

recebida n˜ao pertence ao c´odigo C.

(b) Diz-se que C corrige t erros se e s´o se o m´etodo de decodiﬁca¸c˜ao por distˆancia

m´ınima corrige t, ou menos, erros.

Exemplo 2.1.3. Na nota¸c˜ao do Exemplo 2.0.5, considere as seguintes esferas, de acordo

a ﬁgura abaixo:

S1 = {x : d(x, v1) ≤ 1}

= {v1, v0, v5, v3}, vetores que est˜ao `a distˆancia no m´aximo 1 de v1.

S2 = {x : d(x, v2) ≤ 1}

= {v0, v2, v3, v6}, vetores que est˜ao `a distˆancia no m´aximo 1 de v2.

S1

v5

v1

v0

v3

S2

v2

v6

Figura 5 – Esferas S1 e S2

(a) Seja C = {001, 010} = {v1, v2} c´odigo formado pelos vetores v1 e v2. Como d(001, 010) =

2, conclui-se que d(C) = 2 e portanto (3, 2, 2)2 s˜ao os parˆametros deste c´odigo.

(b) Se a palavra 001 do c´odigo ´e enviada e ocorrem dois erros na transmiss˜ao dos s´ımbolos

e a palavra y recebida ´e 010, como y ∈ C os erros n˜ao s˜ao detectados. Por outro

lado, modiﬁcando uma letra em qualquer palavra em C obtemos palavras que n˜ao

pertencem a C. Logo, C detecta um erro mas n˜ao detecta 2.

27

(c) Se uma palavra do c´odigo (001 ou 010) ´e enviada e a palavra recebida ´e v0 = 000,

conclu´ımos que ocorreu um erro na transmiss˜ao pois v0 n˜ao pertence ao c´odigo, mas

n˜ao conseguimos corrigir o erro pelo fato de existir uma ambiguidade, visto que v0 ∈ S1

e v0 ∈ S2, conforme a ﬁgura. Logo, o c´odigo n˜ao corrige um erro.

(d) Entretanto, se uma palavra do c´odigo (001 ou 010) ´e enviada e a palavra recebida ´e

v5 = 101, conclu´ımos que ocorreu um erro na transmiss˜ao pois v5 n˜ao pertence ao

c´odigo, e a palavra ´e decodiﬁcada por v1 = 001, pois ´e a ´unica palavra de C que est´a

`a distˆancia no m´aximo 1 de v5.

Teorema 2.1.4. Seja C um c´odigo com distˆancia m´ınima d(C). Ent˜ao:

(a) C detecta s erros se e s´o se d(C) ≥ s + 1;

(b) C corrige t erros se e s´o se d(C) ≥ 2t + 1.

Demonstra¸c˜ao. (a) Suponhamos que d(C) ≥ s + 1. Seja x ∈ C a palavra enviada e

suponhamos que ocorrem no m´aximo s erros na transmiss˜ao e y (cid:54)= x ´e a palavra

recebida. Portanto 0 < d(x, y) ≤ s. Como 0 < d(x, y) < d(C), conclui-se que y /∈ C

e os s erros s˜ao detectados. Reciprocamente, se d(C) ≤ s, ent˜ao existem palavras

x, y ∈ C tais que d(x, y) = d(C) ≤ s. Logo ´e poss´ıvel x ser a palavra enviada,

ocorrerem d(C) erros e recebermos a palavra y. Como y ∈ C, estes erros n˜ao s˜ao

detectados (observe o item (b) do Exemplo 2.1.3).

(b) (⇐=) Suponhamos que d(C) ≥ 2t+1. Seja x ∈ C a palavra enviada e suponhamos que

ocorrem t erros na transmiss˜ao e y (cid:54)= x ´e a palavra recebida. Portanto 0 < d(x, y) ≤ t.

Para qualquer c ∈ C, com c (cid:54)= x, temos

d(x, c) ≤ d(x, y) + d(y, c)

(2.1)

logo

d(y, c) ≥ d(x, c) − d(x, y) ≥ d(C) − t ≥ 2t + 1 − t = t + 1 > d(x, y),

(2.2)

e assim, usando o m´etodo de decodiﬁca¸c˜ao por distˆancia m´ınima, y ´e decodiﬁcado

corretamente por x (observe o item (d) do Exemplo 2.1.3).

(b) (=⇒) Seja C um c´odigo que corrige t erros e suponhamos por absurdo d = d(C) ≤ 2t.

Ent˜ao existem x, x(cid:48) ∈ C tais que d (x, x(cid:48)) = d(C) ≤ 2t.

28

Sem perda de generalidade, podemos tamb´em assumir que x e x(cid:48) diferem precisamente

nas primeiras d = d(C) coordenadas. Seja

y = x1 · · · xt
(cid:124) (cid:123)(cid:122) (cid:125)
como x(cid:48)

xt+1 · · · xd
(cid:125)
(cid:123)(cid:122)
(cid:124)
como x

xd+1 · · · xn
(cid:123)(cid:122)
(cid:125)
(cid:124)
como x e x(cid:48)

(2.3)

a palavra recebida. Temos d (y, x(cid:48)) = d − t ≤ t = d(y, x). H´a dois casos a considerar.

t

x

d − t

y

x(cid:48)

• Se d (y, x(cid:48)) < d(y, x) e x ´e a palavra transmitida ent˜ao y ´e decodiﬁcada incorre-

tamente por x(cid:48).

• Se d (y, x(cid:48)) = d(y, x), n˜ao podemos decidir entre x e x(cid:48) na decodiﬁca¸c˜ao por

distˆancia m´ınima.

(observe o item (c) do Exemplo 2.1.3).

Corol´ario 2.1.5. Seja C um c´odigo de distˆancia m´ınima d(C) = d. Ent˜ao C detecta
precisamente d − 1 erros e corrige precisamente (cid:4) d−1

(cid:5) erros.

2

2.2 O PROBLEMA PRINCIPAL DA TEORIA DE C ´ODIGOS

O principal problema na Teoria de C´odigos ´e determinar o maior n´umero de palavras

poss´ıvel que um c´odigo q-´ario de comprimento n e distˆancia m´ınima d pode conter (a ﬁm

de enviar mais mensagens, corrigir mais erros e ter uma taxa de transmiss˜ao maior). Ou

seja, para q, n e d ﬁxos, determinar

Aq(n, d) := max{M : ∃ c´odigo q-´ario (n, M, d)}.

(2.4)

Determinar Aq(n, d) para parˆametros n e d arbitr´arios ´e um problema extremamente dif´ıcil

e conhecem-se poucos resultados concretos. Faremos no lugar uma estimativa.

Usando a distˆancia de Hamming d, se c ∈ An

q e r ´e um inteiro n˜ao negativo, a bola

(ou esfera) de centro c e raio r ´e o subconjunto de An

q deﬁnido por:

Br(c) = (cid:8)x ∈ An

q : d(x, c) ≤ r(cid:9) .

Sendo Aq um conjunto ﬁnito, An

q e qualquer subconjunto deste tamb´em o s˜ao.

29

Deﬁne-se o volume de um subconjunto S de An

q por:

vol(S) = #S.

Exemplo 2.2.1 (Volume de B2(00000) ⊂ A5
4). Neste caso o centro da bola ´e o vetor
00000 e o raio ´e dois, queremos calcular o volume do conjunto formado pelos vetores que

est˜ao `a distˆancia no m´aximo 2 do centro da bola.

O ´unico vetor que est´a `a distˆancia zero do centro ´e o pr´oprio centro 00000.

Os vetores que est˜ao `a distˆancia 1 do centro s˜ao todos os que diferem em exatamente

uma coordenada do vetor 00000, como, por exemplo, 10000, 01000, 00100, . . . , 20000,
(cid:1) = 5 maneiras de escolha de posi¸c˜ao
02000, . . . , 00030, 00003. Para encontr´a-los, h´a (cid:0)5
do d´ıgito distinto, que pode ser qualquer um dos 4 − 1 = 3 valores 1, 2, 3. Logo, o n´umero

1

destes vetores ´e 5 · 3 = 15.

Os vetores que est˜ao `a distˆancia 2 do centro s˜ao todos que diferem em exatamente

duas coordenadas do centro, por exemplo, 11000, 02300, . . . . Podemos escolher as posi¸c˜oes
destas coordenadas de (cid:0)5
(cid:1) = 10 maneiras; da´ı basta multiplicar por 32 = 9, pois temos 3
possibilidades para uma das coordenadas e 3 possibilidades para a outra.

2

O volume ´e dado pela quantidade total dos vetores que est˜ao `a distˆancia 0, 1 e 2 do

centro da bola. Assim,

vol (B2(00000)) =

(cid:19)

(cid:18)5
0

(4 − 1)0 +

(cid:19)

(cid:18)5
1

(4 − 1)1 +

(cid:19)

(cid:18)5
2

(4 − 1)2

= 1 + 15 + 90 = 106

Geometricamente, podemos pensar na bola como formada por “camadas de cebola”,

conforme ﬁgura abaixo, sendo c o centro da bola:

1

1

c

Figura 6 – Volume da bola (“camadas de cebola”)

30

No caso geral, temos

Lema 2.2.2. O volume da bola Br(c) ´e

vol (Br(c)) =

r
(cid:88)

j=0

(cid:19)

(cid:18)n
j

(q − 1)j

onde 0 ≤ r ≤ n e c ∈ An
q .

Demonstra¸c˜ao. A bola Br(c) ´e a uni˜ao disjunta dos conjuntos

(cid:8)x ∈ An

q : d(x, c) = j(cid:9)

com j = 0, 1, . . . , r. Portanto

vol (Br(c)) =

r
(cid:88)

j=0

# (cid:8)x ∈ An

q : d(x, c) = j(cid:9) .

Seja c = (c1, . . . , cn). Como

• d(x, c) = j se e somente se x e c diferem exatamente em j coordenadas,

• (cid:0)n

j

(cid:1) ´e o n´umero de maneiras diferentes de escolher j coordenadas em n e

• q − 1 ´e o n´umero de s´ımbolos em Aq\ {ci}, isto ´e, o n´umero de escolhas para a

coordenada xi (cid:54)= ci,

conclui-se que

# (cid:8)x ∈ An

q : d(x, c) = j(cid:9) =

(cid:19)

(cid:18)n
j

(q − 1)j.

Caso r ≥ n tem-se obviamente que Br(c) = An

q , cujo volume ´e qn.

Agora podemos apresentar uma cota superior para o n´umero de palavras de um

c´odigo.

Teorema 2.2.3 (Estimativa de Hamming ou Majorante de Empacotamento de Esferas).

Para q ≥ 2 e 2t + 1 ≤ d ≤ n, sendo t o n´umero de erros que o c´odigo corrige, temos

Aq(n, d) ≤

qn
vol (Bt(c))

.

Demonstra¸c˜ao. Seja C um c´odigo (n, M, d)q com M = Aq(n, d) e d ≥ 2t + 1. Assim, as

M bolas de raio t e centro nas M palavras do c´odigo s˜ao disjuntas duas a duas. Ent˜ao

vol

(cid:32)

(cid:91)

c∈C

(cid:33)

Bt(c)

=

(cid:88)

c∈C

vol (Bt(c)) = M vol (Bt(c))

uma vez que as bolas com o mesmo raio tˆem volumes iguais. Como vol (cid:0)An
igualdade acima implica que M vol (Bt(c)) ≤ qn.

q

(cid:1) = qn, a

Exemplo 2.2.4. Seja C1 = {000, 111} = {v0, v7} na nota¸c˜ao do Exemplo 2.0.5. A

distˆancia m´ınima ´e d(C1) = 3, o n´umero de palavras ´e M = 2 e como d ≥ 2t + 1, temos

31

que o C1 corrige t = 1 erro.

O vol (B1(000)) = 4, ent˜ao

vol

(cid:32)

(cid:91)

c∈C

(cid:33)

B1(c)

= M vol (B1(c)) = 2 · 4 = 8 ≤ 23.

Observe a ﬁgura abaixo:

v0

1

1

v7

3

Figura 7 – Empacotamento de Esferas

32

33

3 C ´ODIGOS LINEARES

C´odigos Lineares formam a classe de c´odigos mais utilizada. Denotando por Fq o

corpo com q elementos, temos

Deﬁni¸c˜ao 3.0.1. Um c´odigo linear q-´ario de comprimento n ´e um subespa¸co vetorial
de Fn
q .

Seja k a dimens˜ao do c´odigo C e seja v1, v2, . . . , vk uma de suas bases. Todo elemento

de C se escreve de modo ´unico da seguinte forma: α1v1 +· · ·+αkvk, onde αi s˜ao elementos
de Fq para i = 1, . . . , k. Assim, M = |C| = qk. Resumindo

Proposi¸c˜ao 3.0.2. Seja C um c´odigo linear de comprimento n sobre Fq. Ent˜ao: |C| =
qdim C, isto ´e, dim C = logq |C|.

Como o n´umero de palavras que C cont´em est´a diretamente relacionado com a

sua dimens˜ao, deﬁnimos os parˆametros de um c´odigo linear como sendo (n, k, d)q (ou

simplesmente (n, k, d), ou ainda (n, k)), onde k = dim C, e n e d s˜ao respectivamente o

comprimento e a distˆancia m´ınima. Portanto, um c´odigo linear (n, k, d)q ´e tamb´em um
c´odigo (n, qk, d)q.

Um c´odigo linear cont´em necessariamente o vetor nulo.

Deﬁni¸c˜ao 3.0.3. Seja C um c´odigo linear. Deﬁnimos o peso w(x) de x ∈ C como sendo

−→
0 ). Deﬁnimos o peso

o n´umero de entradas n˜ao nulas do vetor x, ou seja, w(x) = d(x,

m´ınimo de C por:

w(C) = min{w(x) : x ∈ C\{

−→
0 }},

se C (cid:54)= {

−→
0 }, e w(C) = 0 se C = {

−→
0 }.

Veremos que podemos calcular a distˆancia m´ınima de um c´odigo linear C utilizando

o peso m´ınimo.

Teorema 3.0.4. Seja C (cid:54)= {

−→
0 } um c´odigo linear. Ent˜ao

d(C) = w(C).

Demonstra¸c˜ao. Como C (cid:54)= {

−→
0 }, C cont´em pelo menos duas palavras e, de acordo com

a deﬁni¸c˜ao de distˆancia m´ınima, d(C) = min{d(x, y) : x, y ∈ C, x (cid:54)= y}. Sejam ent˜ao

x, y ∈ C tais que d(x, y) = d(C). Portanto:

d(C) = d(x, y) = w(x − y) ≥ w(C).

34

Na desigualdade usou-se o fato de x − y ∈ C, por C ser linear, e x − y (cid:54)=

−→
0 . Seja

agora x ∈ C tal que w(x) = w(C). Portanto

w(C) = w(x) = d(x,

−→
0 ) ≥ d(C).

Na desigualdade usou-se o fato de

−→
0 ∈ C, por C ser linear.

Por deﬁni¸c˜ao, para calcular a distˆancia m´ınima d(C) de um c´odigo qualquer C

contendo M palavras ´e preciso calcular a distˆancia d(x, y) para (cid:0)M
palavras. Se C ´e linear, o teorema anterior diz-nos que basta calcular o peso w(x) de M −1

(cid:1) = M (M −1)

pares de

2

2

palavras.

A seguir veremos como codiﬁcar uma mensagem para envi´a-la e em seguida como

veriﬁcar se a mensagem recebida pertence ao c´odigo.

3.1 MATRIZ GERADORA E MATRIZ DE PARIDADE

Em todo o texto vamos escrever vetores no formato de vetores colunas.

Deﬁni¸c˜ao 3.1.1. Seja C um c´odigo linear q-´ario (n, k).

• Seja β = {v1, . . . , vk} uma base ordenada de C. Considere a matriz G, cujas colunas

s˜ao os vetores vi = (vi1, . . . , vin), i = 1, . . . , k, isto ´e,

G =



|





v1

|

. . . vk







.

|

|

Dizemos que G ´e uma matriz geradora de C.

• Suponha que C seja o n´ucleo de uma transforma¸c˜ao linear sobrejetora H : Fn

. A matriz de paridade de C ´e a matriz de H nas bases canˆonicas de Fn

q →
q e

Fn−k
q
Fn−k
q

.

Acima, como H : Fn

q → Fn−k

q

´e sobrejetora, ent˜ao, pelo teorema do n´ucleo e da

imagem, temos que

dim Fn

q = dim(ker(H)) + dim(im(H))

⇐⇒ n = dim C + n − k

⇐⇒ dim C = k.

Para existir uma matriz geradora devemos ter dim C > 0 e para existir uma matriz de

paridade devemos ter dim C < n.

Uma matriz geradora tem n linhas e k colunas, e uma matriz de paridade tem n − k

linhas e n colunas.

Seja C um c´odigo linear de dimens˜ao k e comprimento n, e seja G a matriz geradora

de C, associada `a base β. O c´odigo ser´a a imagem da transforma¸c˜ao linear injetiva deﬁnida

35

por:

Se x =

T : Fk

q −→ Fn

q

x (cid:55)−→ Gx.



, temos que





T (x) = Gx = x1v1 + x2v2 + · · · + xkvk,







x1
...
xk

Ent˜ao, T (Fk

q (mensagem que ser´a enviada) ´e
codiﬁcada por T , transformando-se numa sequˆencia chamada de c´odigo do canal, que

q ) = C, assim, qualquer vetor x ∈ Fk

´e o resultado da transforma¸c˜ao.

Uma matriz de paridade H(n−k)×n de um c´odigo linear C com matriz geradora G ´e

uma matriz que detecta se um vetor y de Fn

q ´e uma palavra do c´odigo. Assim,

Hy = 0 ∈ Fn−k

q ⇐⇒ y ∈ C ⊂ Fn
q .

A partir disto, temos que, dado y ∈ Fn

q , a imagem deste elemento pela matriz de
, ´e chamada sintoma de y. Logo, os elementos que pertencem ao

paridade, Hy ∈ Fn−k

q

c´odigo C tˆem por sintoma o vetor nulo. No caso de Hy (cid:54)= 0, assumimos que ocorreram

erros na transmiss˜ao de y, pois neste caso y (cid:54)∈ C.

Recebido y ∈ C, para encontrar o vetor x ∈ Fk

q , que foi codiﬁcado por T , devemos
resolver o sistema Gx = y, o qual pode ser bem trabalhoso se a matriz geradora n˜ao

estiver na forma canˆonica (o que veremos em breve na se¸c˜ao 3.4).

A seguir, veremos como exemplo o C´odigo de Hamming, um c´odigo especial por ser

perfeito (i.e., um c´odigo que atinge a cota m´axima dada no teorema 2.2.3). Isto que

possibilita uma taxa mais alta de transmiss˜ao para c´odigos de seu comprimento e ainda

possui distˆancia m´ınima 3, o que possibilita a detec¸c˜ao de at´e dois erros e a corre¸c˜ao de

um.

36

3.2 EXEMPLO: C ´ODIGOS DE HAMMING

Seja H uma matriz cujas colunas s˜ao todos os vetores n˜ao nulos do espa¸co vetorial
Fr
2. Portanto H tem r linhas e 2r − 1 colunas. Al´em disso, como os vetores da base
canˆonica −→e1 , . . . , −→er s˜ao colunas de H, a matriz identidade Ir ´e uma submatriz de H com
determinante det (Ir) = 1 (cid:54)= 0, portanto, as r linhas de H s˜ao linearmente independentes,

e H ´e uma matriz de paridade de um c´odigo bin´ario.

Deﬁni¸c˜ao 3.2.1. Seja H uma matriz r × (2r − 1) cujas colunas s˜ao todos vetores em
Fr
2

−→
0 }. O c´odigo bin´ario Ham(r, 2) com esta matriz de paridade H diz-se um c´odigo

(cid:114) {

de Hamming bin´ario de redundˆancia r.

Lema 3.2.2. Seja r ≥ 2. A distˆancia m´ınima do c´odigo de Hamming ´e 3. Ent˜ao
Ham(r, 2) tem parˆametros (2r − 1, 2r − r − 1, 3).

Demonstra¸c˜ao. Por constru¸c˜ao, Ham(r, 2) tem comprimento |Fr
2

(cid:114) {

−→
0 }| = 2r − 1 e di-

mens˜ao k = n − r = 2r − r − 1. S´o falta ver que a distˆacia m´ınima ´e d = 3. Sejam

ci, com i = 1, · · · , 2r − 1, as colunas de uma matriz de paridade H para Ham(r, 2). Por

constru¸c˜ao, ci (cid:54)= cj para quaisquer i (cid:54)= j, e nenhuma coluna ´e o vector nulo, logo quais-

quer duas colunas de H s˜ao linearmente independentes. Por outro lado ci = (0, ..., 0, 0, 1),

cj = (0, ..., 0, 1, 0) e ck = (0, ..., 0, 1, 1) s˜ao colunas de H, se r ≥ 2. Como ck = ci +cj , estas

trˆes colunas s˜ao linearmente dependentes. Logo, pelo Teorema 3.5.1 d(Ham(r, 2)) = 3.

Exemplo 3.2.3. Para r = 2, Ham(2, 2) tem parˆametros (3, 1, 3). Para r = 3, Ham(3, 2)

tem parˆametros (7, 4, 3).

Exemplo 3.2.4. Vamos ver o C´odigo de Hamming Ham(3, 2).







0 0 0 1 1 1 1

H =

0 1 1 0 0 1 1

1 0 1 0 1 0 1







Esta ´e a matriz paridade de um c´odigo Ham(3, 2). Para facilitar a decodiﬁca¸c˜ao as colunas
da matriz cont´em a representa¸c˜ao bin´aria dos n´umeros 1 a 23 −1, os quais est˜ao ordenadas

em ordem crescente.

Assim, o c´odigo bin´ario Ham(3, 2) ´e dado pelas palavras-c´odigo que s˜ao solu¸c˜oes do

sistema linear







0 0 0 1 1 1 1

0 1 1 0 0 1 1

1 0 1 0 1 0 1







37

(3.1)




















0


0




0

=


















x1

x2

x3

x4

x5

x6

x7

·

Logo, temos o seguinte sistema linear:





x4+ x5+ x6+ x7 = 0

x2+ x3+

x6+ x7 = 0

(3.2)

x1

+ x3

+ x5

+ x7 = 0

Resolvendo o sistema temos:





x1 = x3 + x5 + x7

x2 = x3 + x6 + x7

x4 = x5 + x6 + x7

(3.3)

O sistema apresenta 4 vari´aveis independentes (x3, x5, x6 e x7), que se referem ao

c´odigo da fonte, e 3 vari´aveis dependentes (x1, x2 e x4), que representam a redundˆancia

acrescentada, o que torna poss´ıvel detectar e corrigir poss´ıveis erros. Assim, o c´odigo

Ham(3, 2) transforma uma palavra-c´odigo de 4 d´ıgitos em uma palavra-c´odigo de 7 d´ıgitos

com o acr´escimo de uma redundˆancia de 3 d´ıgitos.

Para encontrarmos a matriz G, geradora do c´odigo, note que temos o seguinte sis-

tema:

x1 = 1x3 + 1x5 + 0x6 + 1x7

x2 = 1x3 + 0x5 + 1x6 + 1x7

x3 = 1x3 + 0x5 + 0x6 + 0x7

x4 = 0x3 + 1x5 + 1x6 + 1x7

x5 = 0x3 + 1x5 + 0x6 + 0x7

x6 = 0x3 + 0x5 + 1x6 + 0x7

(3.4)






O sistema equivale ao seguinte produto de matrizes:

x7 = 0x3 + 0x5 + 0x6 + 1x7

38


















=


















x1

x2

x3

x4

x5

x6

x7



































1 1 0 1

1 0 1 1

1 0 0 0

0 1 1 1

0 1 0 0

0 0 1 0

0 0 0 1



















x3

x5

x6

x7

·

Logo, a matriz geradora ´e dada por

G =

0 1 1 1



































1 1 0 1

1 0 1 1

1 0 0 0

0 1 0 0

0 0 1 0

0 0 0 1

Esta matriz geradora G gera 16 palavras-c´odigos como veremos a seguir:



0




0




0




0

·

=



0




0




0




1

·

=



0


0






0






0






0




0




0



1


1






0






1






0




0




1



































1 1 0 1

1 0 1 1

1 0 0 0

0 1 1 1

0 1 0 0

0 0 1 0

0 0 0 1

1 1 0 1

1 0 1 1

1 0 0 0

0 1 1 1

0 1 0 0

0 0 1 0

0 0 0 1



































...

(3.5)

(3.6)

(3.7)

39

(3.8)



1




1




1




1

·

=



1


1






1






1






1




1




1


















1 1 0 1



1 0 1 1

1 0 0 0

0 1 1 1

0 1 0 0

0 0 1 0

0 0 0 1
















Na tabela abaixo encontramos todas estas 16 palavras-c´odigos.

x3x5x6x7 x3 + x5 + x7, x3 + x6 + x7, x3, x5 + x6 + x7, x5, x6, x7

0 0 0 0

0 0 0 1

0 0 1 0

0 0 1 1

0 1 0 0

0 1 0 1

0 1 1 0

0 1 1 1

1 0 0 0

1 0 0 1

1 0 1 0

1 0 1 1

1 1 0 0

1 1 0 1

1 1 1 0

1 1 1 1

0 0 0 0 0 0 0

1 1 0 1 0 0 1

0 1 0 1 0 1 0

1 0 0 0 0 1 1

1 0 0 1 1 0 0

0 1 0 0 1 0 1

1 1 0 0 1 1 0

0 0 0 1 1 1 1

1 1 1 0 0 0 0

0 0 1 1 0 0 1

1 0 1 1 0 1 0

0 1 1 0 0 1 1

0 1 1 1 1 0 0

1 0 1 0 1 0 1

0 0 1 0 1 1 0

1 1 1 1 1 1 1

3.3 ALGORITMO DE DECODIFICA ¸C ˜AO PARA OS C ´ODIGOS DE HAMMING BI-

N ´ARIOS:

Suponha que as colunas de H est˜ao ordenadas por ordem crescente, isto ´e, a i-´esima
coluna ´e o n´umero i ∈ {1, . . . , n = 2r−1} escrito na base 2, logo se ei = (0, . . . , 0, 1, 0 . . . , 0)
com 1 na coordenada i, o sintoma S (ei) ´e a representa¸c˜ao bin´aria de i. Assim, temos o

seguinte algoritmo de decodiﬁca¸c˜ao para Ham(r, 2):

Este algoritmo corrige no m´aximo um erro. Ver Lema 3.2.2.

(1) Recebido y ∈ Fn

2 , calcular o sintoma S(y) = Hy.

40

(2) Se S(y) = 0, assumir que n˜ao ocorreram erros de transmiss˜ao e decodiﬁcar y por y.

(3) Se S(y) (cid:54)= 0, ent˜ao S(y) ´e uma coluna de H e, se estas est˜ao por ordem crescente,

assumir que ocorreu um erro na coordenada i correspondente ao n´umero S(y) na base

2, e decodiﬁcar y por y − ei.

Por que o algoritmo funciona?

Suponha que a palavra y ´e enviada e a mensagem r ´e recebida e que ocorreu um

erro na i-´esima coordenada de y, foi trocado um por zero ou zero por um.

Ent˜ao,

r = y + ei,

o vetor ei possui zeros em todas as coordenadas exceto na i-´esima posi¸c˜ao. Observemos

que saber a posi¸c˜ao do erro ´e suﬁciente para determinar a mensagem y, pois

visto que os c´odigos s˜ao bin´arios. Desta forma,

y = r − ei,

H · r = H · (y + ei) = H · y + H · ei

Como y ´e uma palavra do c´odigo, temos que H · y = 0. Ent˜ao,

Assim,

H · r = H · ei

H · ei = H ·



0
...








0






1






0


...






0

Conclu´ımos que Hei ´e a i-´esima coluna da matriz H, localizamos o erro e decodiﬁcamos

y.

Exemplo 3.3.1. Seja C = Ham(3, 2). Supondo que recebemos o vetor y = 1111010, com
y ∈ F7

2, calcularemos o sintoma S(y) = H · y.







S(y) =

0 0 0 1 1 1 1



0 1 1 0 0 1 1

1 0 1 0 1 0 1





41



1


1






1






1






0




1




0

·



0


1




0

=

Encontramos o sintoma S(y) (cid:54)= 0, de acordo com o algoritmo de decodiﬁca¸c˜ao,

S(y) ´e uma coluna de H, as quais est˜ao em ordem crescente, assim podemos assumir que

ocorreu um erro na coordenada i correspondente ao n´umero S(y) na base 2. Neste caso

assumimos que ocorreu um erro na coordenada 2, pois (010)2 = (2)10 e decodiﬁcamos y

por y − e2.

Assim,

y =



1


1






1






1






0




1




0



0


1






0






0






0




0




0

−



1


0






1






1






0




1




0

=

E o vetor ´e decodiﬁcado corretamente por 1011010.

Para encontrarmos qual o vetor que foi enviado precisamos resolver o sistema Gx =

y:


















1 1 0 1

1 0 1 1

1 0 0 0

0 1 1 1

0 1 0 0

0 0 1 0

0 0 0 1



























x3

x5

x6

x7

·










=



1


0






1






1






0




1




0

(3.9)

42






1x3 + 1x5 + 0x6 + 1x7 = 1

1x3 + 0x5 + 1x6 + 1x7 = 0

1x3 + 0x5 + 0x6 + 0x7 = 1

0x3 + 1x5 + 1x6 + 1x7 = 1

0x3 + 1x5 + 0x6 + 0x7 = 0

0x3 + 0x5 + 1x6 + 0x7 = 1

0x3 + 0x5 + 0x6 + 1x7 = 0

(3.10)

e ent˜ao encontramos x3 = 1, x5 = 0, x6 = 1 e x7 = 0, assim, o vetor (palavra) enviado(a)

foi 1010.

3.4 MATRIZ GERADORA E MATRIZ DE PARIDADE NA FORMA CAN ˆONICA

Como a matriz G geradora de um c´odigo linear C n˜ao ´e ´unica, pois depende da

escolha da base β, temos que duas matrizes geradoras de um mesmo c´odigo C podem ser

obtidas uma da outra por uma sequˆencia de opera¸c˜oes. Ent˜ao, de acordo com o estudo

de ´algebra linear, s˜ao permitidas as seguintes opera¸c˜oes:

(a) Permuta¸c˜ao de duas colunas.

(b) Multiplica¸c˜ao de uma coluna por um escalar n˜ao nulo.

(c) Adi¸c˜ao de um m´ultiplo escalar de uma coluna a outra.

Podemos tamb´em permutar as coordenadas, ou seja, permutar as linhas, obtendo um

c´odigo isomorfo ao original.

Desta forma, podemos sempre encontrar uma matriz geradora na forma canˆonica,

isto ´e, de modo que as primeiras k linhas de G formem uma matriz identidade de ordem

k,

G =

(cid:34)

Ik×k

(cid:35)

B(n−k)×k

Assim, se tivermos um c´odigo deﬁnido por uma matriz geradora G que n˜ao est´a na

forma canˆonica, poderemos efetuar opera¸c˜oes elementares por colunas nesta at´e obter uma

matriz na forma canˆonica. O subespa¸co gerado pelas colunas da matriz padr˜ao obtida ´e

o mesmo e, portanto, temos o mesmo c´odigo.

Estando a matriz geradora na forma canˆonica, a codiﬁca¸c˜ao ter´a a seguinte forma:

43

T (x) =





















,





















x1

x2
...
xk

c1

c2
...
cn−k

onde os ci’s s˜ao combina¸c˜oes lineares das primeiras coordenadas. Neste caso, (x1, . . . , xk)

s˜ao os d´ıgitos da mensagem e (c1, . . . , cn−k) s˜ao os d´ıgitos de veriﬁca¸c˜ao ou de

redundˆancia. Dado um vetor codiﬁcado y ∈ C, a mensagem x ´e obtida simplesmente

apagando os d´ıgitos de veriﬁca¸c˜ao.

Se G ´e uma matriz geradora na forma canˆonica, ent˜ao uma matriz de paridade para

C ser´a

Se o c´odigo for bin´ario, isto ´e, sobre o alfabeto F2, teremos B = −B.

(cid:104)

H =

−B I(n−k)

(cid:105)

,

Exemplo 3.4.1. Seja C ⊂ F6

7 gerado pelo conjunto S = {122100, 012210, 001221}.

Vamos determinar uma matriz geradora e uma matriz paridade para C. Seja M a

matriz cujas colunas s˜ao os vetores do conjunto S, aplicaremos o m´etodo de elimina¸c˜ao

de Gauss a M .

M =





























1 0 0

2 1 0

2 2 1

1 2 2

0 1 2

0 0 1

c2(cid:55)→5c3+c2−→





























1 0 0

2 1 0

2 0 1

1 5 2

0 4 2

0 5 1

c1(cid:55)→5c2+c1−→





























1 0 0

0 1 0

2 0 1

5 5 2

6 4 2

4 5 1

c1(cid:55)→5c3+c1−→





























1 0 0

0 1 0

0 0 1

1 5 2

2 4 2

2 5 1

= ¯M .

Como ¯M foi obtida de M aplicando apenas opera¸c˜oes nas colunas, ¯M e M tˆem o

mesmo espa¸co gerado pelas colunas, assim, a matriz geradora G na forma canˆonica para

44

o c´odigo C ´e:

Como a matriz B ´e

G =

B =





























1 0 0

0 1 0

0 0 1

1 5 2

2 4 2

2 5 1

.













1 5 2

2 4 2

2 5 1

e para a matriz paridade, precisamos de −B, temos que

−1 −5 −2

6 2 5



















−B =

−2 −4 −2

=

5 3 5

,







−2 −5 −1

5 2 6

pois C ⊆ F6

7, ent˜ao, a matriz de paridade H na forma canˆonica ´e:







6 2 5 1 0 0

H =

5 3 5 0 1 0

.

5 2 6 0 0 1







Assim, para enviarmos a mensagem x = (101), iremos codiﬁc´a-la utilizando a matriz

geradora G.

Gx =





























1 0 0

0 1 0

0 0 1

1 5 2

2 4 2

2 5 1



1


0




1

·

=



1


0






1






3




4




3

= y.

Recebido o vetor y, calculamos o sintoma S(y) = Hy e encontramos que Hy = 0, logo

y ∈ C e para encontrarmos a mensagem enviada basta apagar os d´ıgitos de redundˆancia,

´ultimos trˆes d´ıgitos do vetor.

3.5 DISTˆANCIA M´INIMA

Teorema 3.5.1. Seja C um c´odigo (n, k) sobre Fq, com matriz de paridade H. Ent˜ao

45

(i) d(C) ≥ d se, e somente se quaisquer d − 1 colunas de H s˜ao linearmente indepen-

dentes,

(ii) d(C) ≤ d se, e somente se existem d colunas de H linearmente dependentes.

Demonstra¸c˜ao. Pelo Teorema 3.0.4, sabemos que d(C) = w(C). Designemos c1, . . . , cn as
colunas da matriz paridade de H. Seja x = (x1, . . . , xn) uma palavra do c´odigo C ∈ Fn
q
com peso w(x) = e > 0 e suponhamos que as componentes de x n˜ao nulas se encontram

nas coordenadas i1, . . . , ie. Como C = ker(H), temos:

x ∈ C ⇐⇒ Hx =

−→
0 ⇐⇒

xici =

−→
0

n
(cid:88)

i=1

⇐⇒ xi1ci1 + · · · + xiecie =

−→
0

com xi1, . . . , xie (cid:54)= 0

⇐⇒ existem e = w(x) colunas de H linearmente dependentes.

(i) Por deﬁni¸c˜ao de peso m´ınimo, w(C) ≥ d se, e somente se w(x) ≥ d para todas as

palavras de c´odigo x ∈ C\{

−→
0 }, ou seja, se e somente se C n˜ao cont´em nenhuma

palavra x n˜ao nula com peso w(x) ≤ d − 1. Esta ´ultima aﬁrma¸c˜ao equivale a dizer

que quaisquer d − 1 colunas de H s˜ao linearmente independentes.

(ii) Analogamente `a al´ınea (i), w(C) ≤ d se, e somente se existe uma palavra n˜ao nula x

do c´odigo C com 0 < w(x) ≤ d, o que ´e equivalente a existir um conjunto linearmente

dependente de d colunas de H.

Juntando as duas aﬁrma¸c˜oes deste teorema, podemos dizer que a distˆancia m´ınima

de um c´odigo linear C com a matriz de paridade H ´e dada por:

d(C) = n´umero m´ınimo de colunas de H linearmente dependentes

Exemplo 3.5.2. Seja C o c´odigo linear bin´ario com a seguinte matriz de paridade



1 0 1 1 1





H =

0 1 1 0 1

0 0 0 1 1







Qual a distˆancia m´ınima de C?

Designemos por ci a coluna i de H. A matriz H tem trˆes linhas, ou seja, cada coluna
´e um vetor em F3
2. Assim, quaisquer 4 colunas s˜ao linearmente dependentes, portanto,

d(C) ≤ 3. Por outro lado

46

(a) Como n˜ao h´a colunas nulas, qualquer coluna ´e linearmente independente;

(b) Como n˜ao h´a colunas repetidas, isto ´e, como ci

(cid:54)= cj se i (cid:54)= j, ent˜ao ci + cj (cid:54)= (cid:126)0
para i (cid:54)= j, onde ci ´e a coluna i de H, e quaisquer duas colunas s˜ao linearmente

independentes;

(c) Como c1 + c2 + c3 = (cid:126)0 (ou c2 + c4 + c5 = (cid:126)0), h´a trˆes colunas linearmente dependentes.

Logo, pelo Teorema 3.5.1, d(C) = 3.

47

4 C ´ODIGOS C´ICLICOS

Os c´odigos c´ıclicos s˜ao uma subclasse dos c´odigos lineares. S˜ao c´odigos de f´acil

implementa¸c˜ao, pois requerem menos informa¸c˜oes para a obten¸c˜ao das palavras de c´odigo

e tˆem bons algoritmos de codiﬁca¸c˜ao e de decodiﬁca¸c˜ao. S˜ao exemplos de c´odigos c´ıclicos

os c´odigos de Hamming bin´arios, os c´odigos de Golay G11 e G23, os c´odigos BCH, Reed-

Solomon e Goppa, sendo que neste texto desenvolveremos apenas o C´odigo Reed-Solomon.

Deﬁni¸c˜ao 4.0.1. Um c´odigo C diz-se c´ıclico se:

(i) C ´e linear (portanto C ´e subespa¸co de algum Fn

q ) e

(ii) se x = (x1, x2, . . . , xn−1, xn) ∈ C, ent˜ao (xn, x1, x2, . . . , xn−1) ∈ C.

x ∈ Fn

O vetor (xn, x1, x2, . . . , xn−1) ∈ Fn
q diz-se um desvio c´ıclico (shift, em inglˆes) de
q , e iremos denot´a-lo por σ(x). Portanto, um c´odigo ´e c´ıclico se ´e linear e se cont´em
os desvios c´ıclicos de todas as palavras de c´odigo. Assim, se C ´e um c´odigo c´ıclico , ent˜ao
σi(c) ∈ C para todo c ∈ C e todo i ∈ Z.

Exemplo 4.0.2.

• Os c´odigos triviais

−→
0 e Fn

q s˜ao c´ıclicos.

• C1 = {0000, 1010, 0101, 1111} ⊂ F4

2 ´e um c´odigo c´ıclico (veja exemplo 4.1.9).

• C2 = {0000, 1001, 0110, 1111} ⊂ F4

2 n˜ao ´e c´ıclico, pois n˜ao cont´em todos os desvios,

embora seja linear, gerado pelos vetores 1001 e 0110.

• C3 = {0000, 1010, 0101} ⊂ F4

2 n˜ao ´e c´ıclico porque n˜ao ´e linear, pois falta o vetor

1111 = 1010 + 0101, mas cont´em todos os desvios c´ıclicos.

4.1 POLIN ˆOMIO GERADOR

Iremos
Apresentaremos algumas no¸c˜oes de ´algebra que utilizaremos em seguida.
considerar os an´eis de polinˆomios Fq[t] e quocientes deste, por isso vamos assumir que R
´e um anel comutativo com unidade.

Deﬁni¸c˜ao 4.1.1. O subconjunto n˜ao vazio I ⊂ R diz-se um ideal de R se ´e fechado para

a soma e para o produto por qualquer elemento de R, mais precisamente, se a + b ∈ I e

ar ∈ I para todo o a, b ∈ I e r ∈ R.

Dado a ∈ R, o conjunto dos m´ultiplos de a, (a) := {ar : r ∈ R}, ´e um ideal,

chamado de ideal gerado por a. Esse gerador a pode n˜ao ser ´unico.

48

{(cid:80)

Em geral, o conjunto das R-combina¸c˜oes lineares de a1, . . . , aN , ou seja, (a1, . . . , aN ) :=

i airi : ri ∈ R}, ´e um ideal, e {a1, . . . , aN } ´e um conjunto gerador.

Deﬁni¸c˜ao 4.1.2. Um ideal I ∈ R diz-se um ideal principal se I = (a) para algum

a ∈ R. Se todos os ideais s˜ao principais, R diz-se um anel de ideais principais.

Exemplo 4.1.3. No anel dos inteiros Z:

• O conjunto dos n´umeros pares ´e um ideal e tamb´em ´e principal: (2) = {2x : x ∈ Z}.

O inteiro −2 tamb´em ´e um gerador deste ideal.

• O conjunto dos m´ultiplo de trˆes ´e um ideal principal: (3) = {3x : x ∈ Z}, que

tamb´em pode ser representado por (15, 12) = {15x + 12y : x, y ∈ Z}.

Vamos trabalhar no anel dos polinˆomios Fq[t] e o pr´oximo teorema mostra que os

ideais neste anel s˜ao todos principais.

Teorema 4.1.4. Fq[t] ´e um anel de ideais principais. Assim, se I (cid:54)= {0} ´e um ideal,
ent˜ao I = (g(t)), onde g(t) ´e um polinˆomio mˆonico de grau m´ınimo em I. Al´em disso,

este g(t) ´e ´unico.

Demonstra¸c˜ao. Seja I (cid:54)= {0} um ideal de Fq[t]. Seja g(t) um polinˆomio n˜ao nulo de grau
m´ınimo em I. Sem perda de generalidade, podemos assumir que g(t) ´e mˆonico (caso n˜ao

seja, multiplicamos g(t) pelo inverso do coeﬁciente do termo l´ıder). O objetivo ´e ver se

este g(t) ´e um gerador do ideal I.

Seja a(t) um elemento em I qualquer. Pelo algoritmo da divis˜ao de Fq[t], existem
polinˆomios q(t) e g(t) tais que a(t) = g(t)q(t) + r(t), com grau(r(t)) < grau(g(t)) ou

r(t) = 0, portanto r(t) = a(t) − g(t)q(t), que pertence a I, pois a(t) ∈ I e g(t) ∈ I. Como

g(t) tem grau m´ınimo entre os polinˆomios n˜ao nulos em I, ent˜ao o resto r(t) ´e nulo e

a(t) = g(t)q(t) ∈ (g(t)). Como a(t) ∈ I ´e arbitr´ario, conclui-se que I ⊂ (g(t)). E como

g(t) ∈ I, tamb´em se veriﬁca a inclus˜ao inversa I ⊃ (g(t)), assim I = (g(t)).

Precisaremos tamb´em do seguinte lema:

Lema 4.1.5. Seja g(t) ∈ Fq[t] tal que g(t) | tn − 1. Ent˜ao a(t) ≡ g(t)x(t) (mod tn − 1)
para algum x(t) ∈ Fq[t] se e somente se g(t) divide a(t) em Fq[t].

Demonstra¸c˜ao. Seja h(t) ∈ Fq[t] tal que g(t)h(t) = tn − 1. Ent˜ao:

a(t) ≡ g(t)x(t)

(mod tn − 1)

=⇒ a(t) = g(t)x(t) + (tn − 1)y(t) para algum y(t) ∈ Fq[t]

=⇒ a(t) = g(t)x(t) + g(t)h(t)y(t) = g(t)(x(t) + h(t)y(t))

ou seja, g(t) divide a(t).

Se g(t) | a(t)

a(t) = g(t)x(t) =⇒ a(t) − g(t)x(t) ≡ 0

(mod tn − 1)

=⇒ a(t) ≡ g(t)x(t)

(mod tn − 1)

49

Vamos ver algebricamente a condi¸c˜ao combinat´oria dos desvios c´ıclicos da Deﬁni-

¸c˜ao 4.0.1.

Considere o anel quociente

Rn =

Fq[t]
(tn − 1)

Este anel tem uma estrutura natural de espa¸co vetorial sobre Fq. Considere a aplica¸c˜ao
linear sobre Fq

ϕ : Fn

q −→ Rn

a = (a0, a1, . . . , an−1) (cid:55)−→ a(t) = a0 + a1t + · · · + an−2tn−2 + an−1tn−1

Como cada classe de Rn tem um ´unico representante em Fq[t] de grau menor ou igual a
n − 1 (a saber, o resto da divis˜ao por tn − 1), a aplica¸c˜ao ϕ ´e um isomorﬁsmo de espa¸cos

vetoriais, al´em disso:

ϕ(σ(a)) = ϕ (an−1, a0, a1, . . . , an−2)

= an−1 + a0t + · · · + an−2tn−1 = ta(t)

onde se usou tn = 1, em Rn, no ´ultimo passo. Portanto:

ϕ(σ(a)) = tϕ(a)

Ou seja, tomar o shift σ(a) em Fn

q corresponde `a multiplica¸c˜ao por t em Rn.

Um jeito de criar c´odigos c´ıclicos ´e tomar um subconjunto C ⊂ Fn

q n˜ao vazio, de

modo que I = ϕ(C) seja um ideal de Rn.

A seguir vamos relacionar os ideais de Fq[t] com os ideais em Rn.
Considere a aplica¸c˜ao quociente, que ´e um homomorﬁsmo de an´eis (fun¸c˜ao que

preserva produto, soma, 1)

π : Fq[t] −→ Rn =

Fq[t]
(tn − 1)

50

Lema 4.1.6. Se J ´e um ideal em Fq[t] ent˜ao π(J) ´e um ideal em Rn. Se I ´e um ideal
em Rn, ent˜ao π−1(I) ´e um ideal em Fq[t] que cont´em tn − 1.

Demonstra¸c˜ao. O resultado segue da deﬁni¸c˜ao de ideal, tendo em conta que a imagem e

a pr´e-imagem de conjuntos s˜ao, respectivamente:

e

π(J) := {π(j) ∈ Rn : j ∈ J}

π−1(I) := {i ∈ Fq[t] : π(i) = [i] ∈ I}

A t´ıtulo de exemplo vamos demonstrar que π−1(I) ´e um ideal de Fq[t].

Dado π−1(I) ⊆ F[t], tome f, g ∈ π−1(I) ⇐⇒ π(g) ∈ I e π(f ) ∈ I. Como o ideal I ´e

fechado por soma, temos π(g) + π(f ) ∈ I =⇒ π(g + f ) ∈ I =⇒ g + f ∈ π−1(I).

Dados λ ∈ Fq[t], f ∈ π−1(I), devemos mostrar que λf ∈ π−1(I), ou seja, π(λf ) ∈ I.

Como π(λf ) = π(λ) · π(f ) e π(λ) ∈ Rn e π(f ) ∈ I ent˜ao π(λ) · π(f ) ∈ I.

Pode-se veriﬁcar que, como consequˆencia deste lema, a aplica¸c˜ao π deﬁne uma cor-
respondˆencia biun´ıvoca entre os ideais no quociente Rn e os ideais contendo tn − 1 no anel
de polinˆomios Fq[t]. Como consequˆencia do lema acima, temos

Teorema 4.1.7. Rn ´e um anel de ideais principais. Assim, se I (cid:54)= {0} ´e um ideal em Rn,

ent˜ao I = (g(t)), onde g(t) ´e um polinˆomio mˆonico de grau m´ınimo em I. Al´em disso,
este g(t) ´e ´unico, g(t) | tn − 1, e assim t (cid:45) tn − 1 =⇒ g0 = g(0) (cid:54)= 0.

Deﬁni¸c˜ao 4.1.8. Dado um ideal I ⊂ Rn, tal que π−1(I) = (g(t)), o polinˆomio g(t) ∈ Fq[t]
´e chamado polinˆomio gerador do c´odigo c´ıclico C = ϕ−1(I).

Exemplo 4.1.9. Considere

π : F2[t] −→ R4 = F2[t]/(t4 − 1)

Onde R4 =

F2[t]
(t4 − 1)

= {a0 + a1t + a2t2 + a3t3 | ai ∈ F2}, cujos elementos s˜ao dados pelos

poss´ıveis restos na divis˜ao por t4 − 1. Este espa¸co vetorial possui 24 elementos:

51

0 + 0t + 0t2 + 0t3 = (0000)
1 + 0t + 0t2 + 0t3 = (1000)
0 + 1t + 0t2 + 0t3 = (0100)
0 + 0t + 1t2 + 0t3 = (0010)
0 + 0t + 0t2 + 1t3 = (0001)
1 + 1t + 0t2 + 0t3 = (1100)
1 + 0t + 1t2 + 0t3 = (1010)
1 + 0t + 0t2 + 1t3 = (1001)
0 + 1t + 1t2 + 0t3 = (0110)
0 + 1t + 0t2 + 1t3 = (0101)
0 + 0t + 1t2 + 1t3 = (0011)
1 + 1t + 1t2 + 0t3 = (1110)
1 + 1t + 0t2 + 1t3 = (1101)
1 + 0t + 1t2 + 1t3 = (1011)
0 + 1t + 1t2 + 1t3 = (0111)
1 + 1t + 1t2 + 1t3 = (1111)

Agora, considere o ideal I = {0, 1 + t2, t + t3, 1 + t + t2 + t3} ⊂ R4. De acordo com
o Lema 4.1.6, π−1(I) = (1 + t2, t + t3, 1 + t + t2 + t3, t4 − 1), mas como t + t3 = t(1 + t2),
1 + t + t2 + t3 = (1 + t2)(t + 1) e t4 − 1 = (t2 + 1)(t2 − 1), ou seja, todos estes polinˆomios
s˜ao m´ultiplos de (1 + t2), ent˜ao π−1(I) = (1 + t2) ⊂ F2[t]. Logo, o polinˆomio gerador do
c´odigo c´ıclico ϕ(I) = {0000, 1010, 0101, 1111} ´e g(t) = t2 + 1 ∈ F2[t].

A seguir, veremos como encontrar a matriz geradora e a matriz paridade dos c´odigos

c´ıclicos.

4.2 MATRIZ GERADORA E MATRIZ DE PARIDADE

Teorema 4.2.1. Seja g(t) = g0 + g1t + g2t2 + · · · + grtr o polinˆomio gerador do c´odigo
c´ıclico C ⊂ Rn. Ent˜ao

52

Gn×(n−r) =






















g0

0

g1 g0
...
gr

g1
...
gr

0
...
...
0

0
...
0






















· · ·
0
...
. . .
. . .
0
. . . g0

0
...
...
0

g1 g0
...
. . .
. . . gr
0
· · ·

g1
...
gr

=



|





g(t)

|

tg(t) . . .

|
tn−r−1g(t)







|

|

|

´e uma matriz geradora de C e dim C = n − r = n − grau(g(t)), ou seja, o grau de g(t) ´e

a redundˆancia do c´odigo C.

Demonstra¸c˜ao. Queremos provar que as colunas da matriz geradora s˜ao linearmente inde-

pendentes. Sejam v1, v2, . . . , vn−r os vetores coluna da matriz geradora e λ1, λ2, . . . , λn−r

escalares. Os vetores v1, v2, . . . , vn−r s˜ao linearmente independentes se

λ1v1 + λ2v2 + · · · + λn−rvn−r = 0

=⇒ λ1 = λ2 = · · · = λn−r = 0.

Olhando para as primeiras r + 2 coordenadas, teremos o seguinte sistema linear

λ1g0 = 0

λ1g1 + λ2g0 = 0
...

. . .

λ10 + λ2gr + · · · + λn−rg0 = 0

mas como g0 (cid:54)= 0, pelo Teorema 4.1.7, ent˜ao

λ1g0 = 0 =⇒ λ1 = 0

λ1g1 + λ2g0 = 0 =⇒ λ2 = 0
...

λ10 + λ2gr + · · · + λn−rg0 = 0 =⇒ λn−r = 0

Logo, as colunas da matriz geradora s˜ao linearmente independentes. Veremos que as

colunas tamb´em formam um conjunto gerador, como espa¸co vetorial, do c´odigo C. Seja

a(t) ∈ C = (g(t)). Ent˜ao grau(a(t)) < n e, pelo Lema 4.1.5, a(t) = g(t)x(t) para algum
polinˆomio x(t) ∈ Fq[t]. Como grau(a(t)) = grau(g(t)x(t)) = grau(g(t))+grau(x(t)), ent˜ao

53

grau(x(t)) < n − r, ou seja,

x(t) = x0 + x1t + · · · + xn−r−1tn−r−1

e

a(t) = g(t)x(t) = x0g(t) + x1tg(t) + · · · + xn−r−1tn−r−1g(t),

ou seja, a(t) ´e combina¸c˜ao linear de g(t), tg(t), . . . , tn−r−1g(t), que s˜ao precisamente as

colunas da matriz G. Uma vez que as n − r colunas de G formam uma base de C,

conclui-se que C tem dimens˜ao n − r.

Deﬁni¸c˜ao 4.2.2. Se C ´e um c´odigo c´ıclico, de comprimento n, com polinˆomio gerador

g(t), ent˜ao h(t) =

∈ Fq[t] diz-se o polinˆomio de paridade de C.

tn − 1
g(t)

Uma vez que g(t) ´e mˆonico, ent˜ao h(t) tamb´em ´e, pois h(t)g(t) = tn − 1.

Teorema 4.2.3. Seja C um c´odigo c´ıclico, de comprimento n e dimens˜ao k, com polinˆo-
mio de paridade h(t) = h0 + h1t + · · · + hktk. Ent˜ao a matriz

H(n−k)×n =













hk hk−1

0
...
0

0

hk
. . .
· · ·

· · ·

· · ·

h0

0

hk−1
. . .
0

· · ·

h0
. . .
hk hk−1

· · ·

0
. . .
· · ·

· · ·

· · ·
...
h0

0

0

0

· · ·

0

hk

hk−1

· · · h0













´e a matriz de paridade para C.

Demonstra¸c˜ao. Como h(t) ´e um polinˆomio mˆonico, temos que hk = 1 (cid:54)= 0. Portanto, H
´e a matriz de uma transforma¸c˜ao sobrejetora H : Fn

, pois sua imagem cont´em

q → Fn−k

q

as primeiras n − k colunas, que s˜ao linearmente independentes j´a que hk (cid:54)= 0 (veja a

demonstra¸c˜ao de independˆencia linear das colunas de G no teorema anterior, em que

obtemos um sistema triangular). Logo pelo teorema do n´ucleo e da imagem temos que a

dim ker H = k, que ´e igual a dim C = n − r = k, pelo Teorema 4.2.1. Assim, para mostrar

que H ´e uma matriz paridade para C, basta ver que Hc = 0 se c ∈ C.

Temos h(t)g(t) = tn − 1. Ilustraremos a ideia da prova para um caso menor, por

exemplo

(h0 + h1t + h2t2 + h3t3)(g0 + g1t + g2t2) = t5 − 1

⇐⇒ h0g0 + (h0g1 + h1g0)t + (h0g2 + h1g1 + h2g0)t2

+(h1g2 + h2g1 + h3g0)t3 + (h2g2 + h3g1)t4 + h3g2t5 = t5 − 1

54

Comparando os coeﬁcientes, obtemos

h2g0 + h1g1 + h0g2 = 0 −→ Termos de grau 2

h3g0 + h2g1 + h1g2 = 0 −→ Termos de grau 3

h3g1 + h2g2 = 0 −→ Termos de grau 4

Assim, em nota¸c˜ao matricial,



g0

0

(cid:34)

h3 h2 h1 h0

(cid:35)

0

0 h3 h2 h1 h0

·

0

0












(cid:34)

(cid:35)

0 0 0

0 0 0

=










g1 g0

g2 g1 g0

0

0

g2 g1

0

g2

No caso geral, g(t)h(t) = tn −1 e comparando coeﬁcientes, temos, para 1 ≤ i ≤ n−1,

g0hi + g1hi−1 + · · · + gih0 = 0

Logo, em nota¸c˜ao matricial, obtemos HG = 0.

Exemplo 4.2.4. Seja g(t) = 1 + 8t + 5t2 + 3t3 + t4 ∈ F11[t] o polinˆomio gerador do c´odigo
c´ıclico em R10 = F11[t]/(t10 − 1). Utilizaremos o teorema acima para determinar a matriz
geradora G. A redundˆancia do c´odigo c´ıclico gerado por este polinˆomio ´e igual a 4, pois

o grau(g(t)) = 4, enquanto a dim(C) = n − grau(g(t)) = 10 − 4 = 6. Desta forma, temos

que a matriz geradora ´e

G =


























1 0 0 0 0 0

8 1 0 0 0 0

5 8 1 0 0 0

3 5 8 1 0 0

1 3 5 8 1 0

0 1 3 5 8 1

0 0 1 3 5 8

0 0 0 1 3 5

0 0 0 0 1 3

0 0 0 0 0 1


























Vamos encontrar a matriz paridade.

h(t) =

t10 − 1

1 + 8t + 5t2 + 3t3 + t4 = 10 + 8t + 7t2 + 6t3 + 4t4 + 8t5 + t6 ∈ F11[t]



1 8 4 6 7 8 10








0 1 8 4 6 7

0 0 1 8 4 6

0 0 0 1 8 4

8

7

6

55










0

0

10

0

0

0

8

10

0

10

8

7

H =

Note que HG = 0.

Observa¸c˜ao 4.2.5. As divis˜oes de polinˆomios foram feitas com aux´ılio do programa PA-

RI/GP.

56

57

5 C ´ODIGOS DE REED-SOLOMON (RS)

Os c´odigos de Reed-Solomon s˜ao c´odigos c´ıclicos que foram introduzidos por Irving

S. Reed e Gustave Solomon em 1960. A vantagem deste c´odigo ´e que com uma boa es-

colha do polinˆomio gerador ´e poss´ıvel controlar a distˆancia m´ınima e desta forma corrigir

erros acumulados. Eles s˜ao muito utilizados em sistemas de transmiss˜ao de dados como

comunica¸c˜ao via sat´elite, comunica¸c˜oes de miss˜oes espaciais, aDSL, WiMAX (similar ao

Wi-Fi), DVB (Transmiss˜ao de V´ıdeo Digital), sistemas RAID 6 (sistema de armaneza-

mento) e sistemas de telecomunica¸c˜oes como DWDM (tecnologia que usa m´ultiplos lasers

para transmitir muitos comprimentos de onda de luz simultaneamente), tecnologias de

consumo como CDs, DVDs, QRCode.

5.1 ORDEM E ELEMENTO PRIMITIVO

Para encontrarmos o polinˆomio gerador de um c´odigo de Reed-Solomon, precisamos

de um elemento primitivo, ent˜ao vamos ver a deﬁni¸c˜ao:

Deﬁni¸c˜ao 5.1.1. Seja α ∈ F×
q .

(i) A ordem ord(α) de α ´e o menor inteiro d > 0 tal que αd = 1.

(ii) Dizemos que α ´e um elemento primitivo de Fq se, e somente se, {αt, t ∈ N} = F×
q .

Teorema 5.1.2. Seja α ∈ F×
q .

(i) Se d ∈ N ´e tal que αd = 1 ent˜ao ord(α) | d.

(ii) αq−1 = 1.

(iii) ord(α) ´e um divisor de q − 1.

(iv) O elemento α ´e primitivo se, e s´o se, ord(α) = q − 1.

Demonstra¸c˜ao.

q e seja d um n´umero inteiro tal que αd = 1. Sejam
r e s inteiros tais que d = ord(α)s + r e 0 ≤ r < ord(α) (pelo algoritmo da divis˜ao).

(i) Fixemos α ∈ F×

Ent˜ao

1 = αd = αord(α)s+r = (αord(α))sαr = αr

Portanto r = 0, por deﬁni¸c˜ao de ord(α), ou seja, ord(α) divide d.

58

(ii) Seja α (cid:54)= 0 e F×

q = {b1, · · · , bq−1}. Como α (cid:54)= 0, tamb´em temos que F×

q =

{αb1, · · · , αbq−1}. Assim, multiplicando todos os elementos de F×

q , temos

b1 · · · bq−1 = (αb1) · · · (αbq−1) =⇒ b1 · · · bq−1 = (αq−1)(b1 · · · bq−1)

Logo, obt´em-se αq−1 = 1.

Pelos itens (i) e (ii), conclu´ımos que ord(α) divide q − 1.

(iii) Para todo α ∈ F×

q temos {αt, t ∈ N} ⊂ F×

q . Note que

{αt, t ∈ N} = {1, α, α2, · · · , αord α−1}

´e um conjunto com ord(α) elementos. De fato, para qualquer t ∈ N temos αt =
αr onde r ´e o resto na divis˜ao de t por ord(α); por outro lado, os elementos
1, α, α2, · · · , αord α−1 s˜ao distintos pois caso αi = αj com 0 ≤ i < j < ord(α),
ent˜ao αj−i = 1 com 0 < j − i < ord(α), o que ´e um absurdo. Assim, α ´e um
elemento primitivo em Fq, isto ´e, {αt, t ∈ N} = F×

q , se, e somente se, ord(α) = q − 1.

Exemplo 5.1.3. Vamos encontrar os elementos primitivos de F11. Temos
F11 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, ent˜ao ϕ(11) = 10 (n´umero de elemento que s˜ao primos
com 11). Para encontrarmos as ordens dos elementos procuramos os divisores de 10, que

s˜ao {1, 2, 5, 10}, as poss´ıveis ordens.

Vamos come¸car procurando ord11 2: sabemos que 210 ≡ 1 (mod 11), pelo Pequeno
Teorema de Fermat (PTF), mas precisamos testar tamb´em para 25, 22 e 21. Temos 25 =
32 ≡ 10 (mod 11), 22 ≡ 4 (mod 11) e 21 ≡ 2 (mod 11). Logo, ord11 2 = 10 = ϕ(11),
ent˜ao 2 ´e elemento primitivo de F11.

Da mesma forma, para ord11 3 temos que 310 ≡ 1 (mod 11), pelo PTF; 35 = 243 ≡ 1
(mod 11); 32 ≡ 9 (mod 11); 31 ≡ 3 (mod 11). Logo, ord11 3 = 5 (cid:54)= ϕ(11), assim, 3 n˜ao ´e
elemento primitivo de F11.

Continuando desta forma, obtemos a seguinte tabela:

Elemento de F×

11 Ordem Primitivo?

59

1

2

3

4

5

6

7

8

9

10

1

10

5

5

5

10

10

10

5

2

n˜ao

sim

n˜ao

n˜ao

n˜ao

sim

sim

sim

n˜ao

n˜ao

Desta forma, encontramos todos os elementos primitivos de F11 que s˜ao: 2, 6, 7 e 8.

Exemplo 5.1.4. Encontrar um elemento primitivo de F9 =

F3[x]
(x2 + 1)

.

Temos que x2 + 1 ´e um polinˆomio irredut´ıvel em F3[x], pois n˜ao possui ra´ızes em F3.

Assim,

F3[x]
(x2 + 1)

= {a0 + a1t | ai ∈ F3 e t2 = −1 = 2}

= {0, 1, 2, t, 2t, 1 + t, 1 + 2t, 2 + t, 2 + 2t},

que s˜ao os poss´ıveis restos na divis˜ao por x2 + 1. Para encontrarmos as ordens dos

elementos procuramos os divisores de 8, ou seja, 8, 4, 2, 1, que s˜ao as poss´ıveis ordens.

Ordem de t: t2 = 2; t4 = t2 · t2 = 2 · 2 = 4 = 1.
Desta forma, a ord(t) = 4. Assim, t n˜ao ´e elemento primitivo de F9.
Ordem de (1 + t):

(1 + t)2 = 1 + 2t + t2 = 1 + 2t + 2 = 3 + 2t = 0 + 2t = 2t;

(1 + t)4 = (1 + t)2(1 + t)2 = 2t · 2t = 4t2 = 4 · 2 = 8 = 2;

(1 + t)8 = (1 + t)4(1 + t)4 = 2 · 2 = 4 = 1

Desta forma, ord(1 + t) = 8. Logo 1 + t ´e elemento primitivo de F9.

Continuando desta forma, obtemos a seguinte tabela:

60

Elemento de F×

9 Ordem Primitivo?

1

2

t

2t

1 + t

2 + t

1 + 2t

2 + 2t

1

2

4

4

8

8

8

8

n˜ao

n˜ao

n˜ao

n˜ao

sim

sim

sim

sim

Assim, os elementos primitivos de F9 s˜ao: 1 + t, 2 + t, 1 + 2t e 2 + 2t.

5.2 C ´ODIGOS DE REED-SOLOMON

Deﬁni¸c˜ao 5.2.1. Um c´odigo Reed-Solomon q-´ario ´e um c´odigo c´ıclico de comprimento

q − 1, com polinˆomio gerador

g(t) = (t − α1)(t − α2) · · · (t − αδ−1)

com 2 ≤ δ ≤ q − 1, onde α ´e um elemento primitivo de Fq.

Observa¸c˜ao 5.2.2.

(i) Se α ´e um elemento primitivo de Fq, o polinˆomio tq−1−1 ∈ Fq[t]

tem a seguinte fatora¸c˜ao

tq−1 − 1 = (t − 1)(t − α)(t − α2) · · · (t − αq−2).

Pois tq−1 − 1 tem 1, α, α2, · · · , αq−2 como ra´ızes pelo teorema 5.1.2 item (ii).

Ent˜ao, o polinˆomio g(t) ´e um divisor de tq−1 − 1 e g(t) ´e o polinˆomio gerador de um

c´odigo c´ıclico e suas ra´ızes s˜ao todas distintas.

(ii) Como o grau(g(t)) = δ − 1, a dimens˜ao de C ´e dim(C) = (q − 1) − (δ − 1) = q − δ,

pelo Teorema 4.2.1.

(iii) N˜ao existem c´odigos Reed-Solomon bin´arios, pois 2 ≤ δ ≤ q − 1 =⇒ q ≥ 3.

Exemplo 5.2.3. Como 2 ´e um elemento primitivo de F11, vamos escolher o seguinte
polinˆomio gerador:

g(t) = (t − 2)(t − 22)(t − 23)(t − 24) = 1 + 8t + 5t2 + 3t3 + t4

o qual ´e o polinˆomio gerador de um c´odigo Reed-Solomon de parˆametros (10, 6). Note

que este polinˆomio foi utilizado no Exemplo 4.2.4.

61

G =


























1 0 0 0 0 0

8 1 0 0 0 0

5 8 1 0 0 0

3 5 8 1 0 0

1 3 5 8 1 0

0 1 3 5 8 1

0 0 1 3 5 8

0 0 0 1 3 5

0 0 0 0 1 3

0 0 0 0 0 1


























e o polinˆomio de paridade ´e o mesmo do Exemplo 4.2.4.

Como d(C) ≥ δ, pelo Teorema 5.3.2, o qual veremos em seguida, podemos determi-

nar que a distˆancia m´ınima deste c´odigo ´e d(C) ≥ 5, pois δ − 1 = 4, temos que δ = 5,

neste caso poderemos corrigir at´e dois erros de transmiss˜ao.

5.3 DISTˆANCIA M´INIMA

Observe que os polinˆomios c(t) em Rn, m´ultiplos de g(t), s˜ao aqueles que se anulam

nas ra´ızes de g(t). Logo,

Proposi¸c˜ao 5.3.1. Seja C um c´odigo Reed-Solomon q-´ario, com polinˆomio gerador g(t) =
(t − α1)(t − α2) · · · (t − αδ−1). Ent˜ao

C = {c(t) ∈ Rq−1 : c(αi) = 0, ∀i = 1, . . . , δ − 1}.

Teorema 5.3.2. Seja C um c´odigo Reed-Solomon de parˆametros (q − 1, q − δ)q. Ent˜ao

d(C) ≥ δ.

Demonstra¸c˜ao. Seja g(t) = (t − α1)(t − α2) · · · (t − αδ−1) o polinˆomio gerador de C.
Suponhamos, por absurdo, que d(C) = d < δ e seja c(t) = c0 + c1t + · · · + cn−1tn−1 ∈ C
com peso w(c(t)) = d. Seja c = (c0, c1, . . . , cn−1) ∈ Fn
q o vetor correspondente a c(t). Pela
Proposi¸c˜ao 5.3.1, c(αi) = 0 para qualquer i = 1, . . . , δ − 1. Por outro lado,

c(αi) = c0 + c1αi + · · · + cn−1(αi)n−1 = (1, αi, (αi)2, . . . , (αi)n−1) · c.

62

Portanto Ac = 0, onde A ´e a matriz de Vandermonde

A =


α1
1

α2
1


...
...



1 αδ−1

(α1)2
(α2)2
...
(αδ−1)2

· · ·

· · ·

· · ·










(α1)n−1
(α2)n−1
...
(αδ−1)n−1

uma matriz com δ − 1 linhas e n colunas. Sejam i1, . . . , id os ´ındices tais que cij (cid:54)= 0. Seja
A(cid:48) a matriz formada pelas colunas i1 + 1, i2 + 1, . . . , id + 1 de A. Ent˜ao A(cid:48) tem δ − 1 linhas
e d colunas. Como d ≤ δ − 1, a matriz A(cid:48)(cid:48) formada pelas d primeiras linhas de A(cid:48) ´e uma

matriz quadrada d × d e





ci1
...
cid
portanto det(A(cid:48)(cid:48)) = 0, pois (ci1, . . . , cid) ´e uma solu¸c˜ao n˜ao nula do sistema linear homo-
gˆeneo A(cid:48)(cid:48)x = 0. Por outro lado, como

= 0









A(cid:48)(cid:48)

A(cid:48)(cid:48) =










(α1)i1
(α2)i1
...
(αd)i1

(α1)i2
(α2)i2
...
(αd)i2

. . .

· · ·

. . .










(α1)id
(α2)id
...
(αd)id

usando as propriedades de multilinearidade do determinante nas colunas obt´em-se

det(A(cid:48)(cid:48)) =

d
(cid:89)

j=1

αij det










1
αi1
...
(αd−1)i1

1
αi2
...
(αd−1)i2

· · ·

· · ·

· · ·










1
αid
...
(αd−1)id

d
(cid:89)

=

αij (cid:89)

(αil − αik)

j=1

1≤k<l≤d

Logo, det(A(cid:48)(cid:48)) (cid:54)= 0, pois αil (cid:54)= αik, porque α ´e um elemento primitivo e d ≤ δ − 1 ≤ q − 2.
Como n˜ao podemos ter simultaneamente det(A(cid:48)(cid:48)) = 0 e det(A(cid:48)(cid:48)) (cid:54)= 0, conclu´ımos que

d ≥ δ.

5.4 ALGORITMO DE PETERSON-GORENSTEIN-ZIERLER (PGZ)

O c´odigo c´ıclico tamb´em ´e um c´odigo linear, o qual j´a vimos o algoritmo de codiﬁ-

ca¸c˜ao e detec¸c˜ao de erro. Nesta se¸c˜ao veremos o algoritmo de Peterson-Gorenstein-Zierler

63

para corre¸c˜ao de erros do C´odigo de Reed-Solomon.

5.4.1 Descri¸c˜ao do algoritmo

A mensagem transmitida ´e vista como os coeﬁcientes de um polinˆomio p(t) em Fq[t],

que ´e divis´ıvel por um polinˆomio gerador g(t). Sejam

p(t) =

q−2
(cid:88)

i=0

citi

δ−1
(cid:89)

(t − αj),

g(t) =

j=1
onde α ´e um elemento primitivo de Fq. Seja

e(t) =

q−2
(cid:88)

i=0

eiti

o erro e y(t) o polinˆomio recebido, de modo que

y(t) = p(t) + e(t)

Se h´a ν erros em potˆencias distintas ik de t, ent˜ao

e(t) =

ν
(cid:88)

k=1

eiktik

O objetivo do decodiﬁcador ´e encontrar as posi¸c˜oes dos erros ik e os valores de erro nessas
posi¸c˜oes eik. Para isto, deﬁnimos

64

Deﬁni¸c˜ao 5.4.1. Seja ν ≤ (cid:98) δ−1

2 (cid:99), o n´umero de erros a serem corrigidos.

(a) As s´ındromes S1, . . . , Sδ−1 s˜ao deﬁnidas como

Sj = y(αj)

(b) Os localizadores de erro X1, . . . , Xν s˜ao deﬁnidos por

Xk = αik

(c) Os valores de erro Y1, . . . , Yν s˜ao deﬁnidos como

Yk = eik

(d) O polinˆomio localizador de erros Λ(x) ´e deﬁnido como

ν
(cid:89)

Λ(x) =

(1 − xXk) = 1 + Λ1x1 + Λ2x2 + · · · + Λνxν

k=1

Note que os zeros de Λ(x) s˜ao os rec´ıprocos X −1
k .

O algoritmo seguir´a os seguintes passos:

1. Calcular as s´ındromes Sj para o polinˆomio recebido y(t);

2. Determinar o polinˆomio do localizador de erros Λ(x) a partir das s´ındromes Sj;

3. Calcular as ra´ızes X −1

k = α−ik do polinˆomio de localiza¸c˜ao do erro Λ(x), obtendo assim

as posi¸c˜oes ik dos erros;

4. Calcular os valores de erro Yk, logo o polinˆomio de erro e(t) = (cid:80)

1≤k≤ν Yktik

5. Corrigir os erros, obtendo a mensagem original p(t) = y(t) − e(t).

Antes de vermos o caso geral, vejamos um caso particular com δ = 5 e ν = 2. Note
primeiro que como g(t) | p(t) e g(t) = (t − α1)(t − α2)(t − α3)(t − α4), de y(t) = p(t) + e(t)

temos que as s´ındromes Sj s˜ao da seguinte forma:






S1 = y(α) = e(α)

S2 = y(α2) = e(α2)

S3 = y(α3) = e(α3)

S4 = y(α4) = e(α4)

(5.1)

Note que o polinˆomio de erro e(t) = e0 + e1t + · · · + eq−2tq−2 tem no m´aximo ν = 2
coeﬁcientes n˜ao nulos. Suponhamos que saibamos as posi¸c˜oes do erro, por exemplo e(t) =
e1t + e5t5, vamos mostrar que conhecendo estas posi¸c˜oes podemos encontrar o erro e(t).
Como




S1 = y(α) = e(α) = e1α + e5α5



S2 = y(α2) = e(α2) = e1α2 + e5α10

basta resolver o sistema em e1 e e5

(cid:34)

α α5
α2 α10

(cid:35) (cid:34)

e1

e5

(cid:35)

(cid:34)

=

(cid:35)

S1 = e(α)
S2 = e(α2)

.

65

(5.2)

(5.3)

Para descobrir onde est´a o erro, deﬁnimos Xk = αik e Yk = eik, neste caso, temos:

X1 = α, X2 = α5, Y1 = e1 e Y2 = e5. O polinˆomio localizador de erro ser´a o seguinte:

Λ(x) = (1 − xX1)(1 − xX2) = 1 − x(X1 + X2) + x2X1X2 = 1 + Λ1x1 + Λ2x2

com Λ1 = −(X1 + X2) e Λ2 = X1X2 e as s´ındromes ser˜ao dadas por Sj = e(αj) =
Y1X j

1 + Y2X j

2, ou seja,

S1 = Y1X 1

1 + Y2X 1
2

S2 = Y1X 2

1 + Y2X 2
2

S3 = Y1X 3

1 + Y2X 3
2

S4 = Y1X 4

1 + Y2X 4
2

Veriﬁquemos que os coeﬁcientes Λi satisfazem

(cid:34)

S1 S2

(cid:35) (cid:34)

Λ2

S2 S3

Λ1

(cid:35)

(cid:34)

=

(cid:35)

−S3

−S4

(5.4)

Substituindo as express˜oes das s´ındromes e dos Λi’s em S1Λ2 + S2Λ1, obtemos

(Y1X 1

1 + Y2X 1

2 )(X1X2) − (Y1X 2

1 + Y2X 2

2 )(X1 + X2) =

Y1X 2

1 X2 + Y2X1X 2

2 − Y1X 3

1 − Y1X 2

1 X2 − Y2X1X 2

2 − Y2X 3

2 =

= −Y1X 3

1 − Y2X 3

2 = −S3

E substituindo em S2Λ2 + S3Λ1

(Y1X 2

1 + Y2X 2

2 )(X1X2) − (Y1X 3

1 + Y2X 3

2 )(X1 + X2) =

= Y1X 3

1 X2 + Y2X1X 3

2 − Y1X 4

1 − Y1X 3

1 X2 − Y2X1X 3

2 − Y2X 4

2 =

66

= −Y1X 4

1 − Y2X 4

2 = −S4

Resolvendo (5.4) encontraremos Λ(x), cujos zeros s˜ao os inversos de X −1

k , que nos d˜ao as
posi¸c˜oes dos erros. Da´ı substituindo em (5.2), encontraremos os valores dos erros Yk e,

assim, a mensagem enviada.

Teorema 5.4.2.

(i) Os coeﬁcientes Λi do polinˆomio de localiza¸c˜ao do erro satisfazem

o sistema linear



S1

S2

· · ·

Sν








S3
S2
...
...
Sν Sν+1

· · · Sν+1
...

· · · S2ν−1





Λν















Λν−1
...
Λ1



















−Sν+1

−Sν+2
...
−Sν+ν










=

(ii) Os valores de erro Yk satisfazem o sistema linear










X 1
1
X 2
1
...
X δ−1
1

X 1
2
X 2
2
...
X δ−1
2

· · · X 1
ν
· · · X 2
ν
...

· · · X δ−1

ν














Y1















Y2
...
Yν












S1








S2
...
Sδ−1

=

Demonstra¸c˜ao. Note inicialmente que, como p(t) ´e divis´ıvel pelo gerador g(t), p(αj) = 0

para j = 1, 2, . . . , δ − 1, temos

Sj = y(αj) = p(αj) + e(αj)

= e(αj) =

ν
(cid:88)

k=1

(cid:0)αj(cid:1)ik =

eik

ν
(cid:88)

k=1

YkX j
k

(5.5)

o que prova (ii). Por outro lado, como X −1

k ´e raiz de Λ(x), temos

Λ(X −1

k ) = 1 + Λ1X −1

k + Λ2X −2

k + · · · + ΛνX −ν

k = 0

Multiplicando ambos os lados por YkX j+ν
obtemos

k

(j ´e qualquer n´umero tal que 1 ≤ j ≤ ν)

YkX j+ν
k
⇐⇒ YkX j+ν

(1 + Λ1X −1
k + Λ1YkX j+ν−1

k

k + Λ2X −2

k + · · · + ΛνX −ν

+ Λ2YkX j+ν−2

k

k ) = 0
+ · · · + ΛνYkX j

k = 0

Somando de k = 1 a ν, temos

ν
(cid:88)

(YkX j+ν

k + Λ1YkX j+ν−1

k

67

+ · · · + ΛνYkX j

k) = 0

⇐⇒

(cid:32) ν

(cid:88)

k=1

k=1

(cid:33)

YkX j+ν
k

+ Λ1

(cid:32) ν

(cid:88)

k=1

(cid:33)

YkX j+ν−1
k

+ · · · + Λν

(cid:33)

YkX j
k

= 0

(cid:32) ν

(cid:88)

k=1

Note que estes somat´orios s˜ao agora equivalentes aos valores da s´ındrome por (5.5), por-

tanto

o que prova (i).

Sj+ν + Λ1Sj+ν−1 + · · · + Λν−1Sj+1 + ΛνSj = 0

Vamos acompanhar a prova acima no caso particular com δ = 7 e ν = 3. Note que

g(t) | p(t) e

e neste caso teremos que

6
(cid:89)

(t − αj),

g(t) =

j=1

(i) Os coeﬁcientes Λi do polinˆomio de localiza¸c˜ao do erro satisfazem o seguinte sistema

linear



S1 S2 S3





S2 S3 S4

S3 S4 S5







=









Λ3





Λ2

Λ1









−S4





−S5

−S6

(ii) Os valores de erro Yk satisfazem o seguinte sistema linear















X 1
X 2
X 3
X 4
X 5
X 6

1 X 1
1 X 2
1 X 3
1 X 4
1 X 5
1 X 6

2 X 1
3
2 X 2
3
2 X 3
3
2 X 4
3
2 X 5
3
2 X 6
3





















=



Y1





Y2

Y3

















S1













S2

S3

S4

S5

S6

Como p(αj) = 0 para j = 1, 2, . . . , 6, temos

Sj = y(αj) = p(αj) + e(αj)

= e(αj) =

ν
(cid:88)

k=1

(cid:0)αj(cid:1)ik =

eik

6
(cid:88)

k=1

YkX j
k

68

Calculando as s´ındromes, temos

S1 = Y1X 1

1 + Y2X 1

2 + Y3X 1
3

S2 = Y1X 2

1 + Y2X 2

2 + Y3X 2
3

S3 = Y1X 3

1 + Y2X 3

2 + Y3X 3
3

S4 = Y1X 4

1 + Y2X 4

2 + Y3X 4
3

S5 = Y1X 5

1 + Y2X 5

2 + Y3X 5
3

S6 = Y1X 6

1 + Y2X 6

2 + Y3X 6
3

o que nos d´a o item (ii). Mas,

Λ(x) = 1 + Λ1x + Λ2x2 + Λ3x3

s˜ao as ra´ızes de Λ(x), assim, multiplicando ambos os lados das equa-

onde X −1

1 , X −1

2 , X −1
3

¸c˜oes

Λ(X −1

1 ) = 1 + Λ1X −1

1 + Λ2X −2

1 + Λ3X −3

1 = 0

Λ(X −1

2 ) = 1 + Λ1X −1

2 + Λ2X −2

2 + Λ3X −3

2 = 0

Λ(X −1

3 ) = 1 + Λ1X −1

3 + Λ2X −2

3 + Λ3X −3

3 = 0

respectivamente por Y1X 1+3

1

, Y2X 1+3

2

e Y3X 1+3

3

, obtemos

Y1X 4

1 + Λ1Y1X 3

1 + Λ2Y1X 2

1 + Λ3Y1X1 = 0

Y2X 4

2 + Λ1Y2X 3

2 + Λ2Y2X 2

2 + Λ3Y2X2 = 0

Y3X 4

3 + Λ1Y3X 3

3 + Λ2Y3X 2

3 + Λ3Y3X3 = 0

Somando as trˆes equa¸c˜oes, temos

(Y1X 4

1 + Y2X 4
1 + Y2X 2

2 + Y3X 4
2 + Y3X 2

+ Λ2(Y1X 2

3 ) + Λ1(Y1X 3

1 + Y2X 3

2 + Y3X 3
3 )

3 ) + Λ3(Y1X1 + Y2X2 + Y3X3) = 0

Notemos que os coeﬁcientes dos Λi s˜ao equivalentes aos valores das s´ındromes, assim

S4 + Λ1S3 + Λ2S2 + Λ3S1 = 0

e analogamente para as demais equa¸c˜oes do item (i).

69

5.4.2 Exemplos

Exemplo 5.4.3. Como α = 3 ´e um elemento primitivo de F7 podemos escolher o seguinte
polinˆomio gerador:

g(t) = (t − 3)(t − 32)(t − 33)(t − 34) ∈ F7

g(t) = t4 + 6t3 + 3t2 + 2t + 4

Como δ − 1 = 4, logo δ = 5 e o c´odigo corrige at´e 2 erros. Assim, temos a seguinte matriz

geradora

G6×2 =

















4 0













2 4

3 2

6 3

1 6

0 1

O polinˆomio e matriz paridade deste c´odigo s˜ao

h(t) =

t6 − 1
t4 + 6t3 + 2t + 4

= t2 + t + 5










H4×6 =

1 1 5 0 0 0



0 1 1 5 0 0

0 0 1 1 5 0

0 0 0 1 1 5








Seja y = c1 + c2 uma palavra do c´odigo

y =



4


2






3






6




1




0

+



0


4






2






3




6




1



4


6






5






2




0




1

=

70

Temos

Hy =










1 1 5 0 0 0

0 1 1 5 0 0

0 0 1 1 5 0

0 0 0 1 1 5










Hy = 0, assim y ∈ C.

Vamos acrescentar um erro na palavra:

y =



4


6






5






2




0




1



0


0






1






0




0




0

+

=

Como

Hy =










1 1 5 0 0 0

0 1 1 5 0 0

0 0 1 1 5 0

0 0 0 1 1 5












4


6






5






2




0




1



4


6






6






2




0




1



4


6






6






2




0




1











0


0


0


0

=











5


1


1


0

=

temos Hy (cid:54)= 0, ent˜ao y /∈ C.

Suponhamos que existem 2 erros.
Para ν = 2. Vamos calcular as s´ındromes: como y(t) = 4 + 6t + 6t2 + 2t3 + t5,

S1 = y(α1) = 2

S3 = y(α3) = 1

S2 = y(α2) = 4

S4 = y(α4) = 2

Para localizar os erros, resolvemos

(cid:34)

S1 S2

(cid:35) (cid:34)

Λ2

S2 S3

Λ1

(cid:35)

(cid:34)

=

(cid:35)

−S3

−S4

(5.6)

Logo

(cid:34)

2 4

4 1

(cid:35) (cid:34)

Λ2

(cid:35)

Λ1

=

(cid:34)

(cid:35)

−1

−2

(cid:34)

(cid:35)
6

5

=

71

L2(cid:55)→5L1+L2
−→

(cid:34)

(cid:35)

2 4 6

0 0 0

(cid:34)

(cid:35)

2 4 6

4 1 5

que ´e um sistema indeterminado, assim conclu´ımos que ν < 2.

Suponhamos ent˜ao que existe um erro. Para ν = 1:

S1 · Λ1 = −S2 =⇒ 2 · Λ1 = −4 =⇒ Λ1 = −2 = 5

Substituindo no polinˆomio localizador de erro, temos Λ(x) = 1 + x.Λ1 = 1 + 5x.

Temos candidatas a ra´ızes α, α2, α3, α4:

Λ(α1) = 2

Λ(α3) = 3

Λ(α2) = 4

Λ(α4) = 0

Desta forma, Λ(α4) = 0. Assim,

1
X1

= α4 =⇒ X1 = α−4 = α2

Desta forma, encontramos que o erro est´a na posi¸c˜ao 2.

e(t) = e2t2

y(t) = p(t) + e2t2

Temos: y(α) = e2α2, como α2 = 2 e y(α) = 2. De

2 = 2e2 =⇒ e2 = 1,

encontramos que o valor do erro ´e 1.

Logo, e(t) = 1 · t2 e corrigimos: p(t) = y(t) − e(t)



4


6






6






2




0




1



0


0






1






0




0




0

−

=



4


6






5






2




0




1

72

Exemplo 5.4.4. Seja g(t) = 1 + 8t + 5t2 + 3t3 + t4 ∈ F11 do Exemplo 5.2.3, vamos
encontrar uma palavra pertencente ao c´odigo fazendo

c1 + 3c3 =



























1

8



5



3



1


0



0



0


0


0

+ 3



0


0






1






8






5




3






1






0




0




0

=



1


8






8






5






5




9






3






0




0




0

∈ C.

Vamos colocar dois erros na mensagem de maneira que

y =



1


8






8






5






5




9






3






0




0




0

+


























0

0

0

0

0

0

0

2

0

−1




























1


8






8






5






5




9






2






0




2




0

=

(cid:54)∈ C.

Assim,

y(t) = 1 + 8t + 8t2 + 5t3 + 5t4 + 9t5 + 2t6 + 2t8 = g(t) + 3t2g(t) − t6 + 2t8

Temos α = 2, ent˜ao vamos calcular as s´ındromes e em seguida substituir na express˜ao

do teorema 5.4.2(i):

S1 = y(α1) = 8

S3 = y(α3) = 7

S2 = y(α2) = 3

S4 = y(α4) = 3

Logo

(cid:34)

8 3

3 7

(cid:35) (cid:34)

Λ2

(cid:35)

Λ1

=

(cid:34)

(cid:35)

−7

−3

(cid:34)

(cid:35)
4

8

=

Resolvendo o sistema encontramos Λ1 = −1 e Λ2 = 5, substituimos estes valores em

Λ(x) = (1 − xX1)(1 − xX2) = 1 + Λ1x1 + Λ2x2 = 1 + (−x) + 5(x2)

73

cujas ra´ızes s˜ao: x =

, x =

1
X1

1
X2

Temos as seguintes candidatas a ra´ızes de Λ(x) = 5x2 −x+1: α, α2, . . . , α10. M´odulo

11, temos

α = 2 −→ 5 · 22 − 2 + 1 = 19 (cid:54)= 0

α2 = 4 −→ 5 · 42 − 4 + 1 = 77 = 0

α4 = 5 −→ 5 · 52 − 5 + 1 = 121 = 0

α6 = −2 −→ 5 · (−2)2 − (−2) + 1 = 1 (cid:54)= 0

Encontramos as ra´ızes α2 e α4. Assim, Λ(α2) = Λ(α4) = 0. Portanto

1
X1

= α2 =⇒ X1 = α−2 = α8

e

1
X2

= α4 =⇒ X2 = α−4 = α6

Desta forma, encontramos as posi¸c˜oes dos erros, os quais encontram-se nas posi¸c˜oes
6 e 8, assim, e(t) = e6t6 + e8t8. Precisamos encontrar o valor do erro, para isso, a partir
de

y(t) = p(t) + e6t6 + e8t8

resolveremos o seguinte sistema:




8 = y(α) = e6α6 + e8α8



3 = y(α2) = e6α12 + e8α16

Como α6 = −2 = 9, α8 = 3, α12 = 4 e α16 = 9, temos:




8 = 9e6 + 3e8



3 = 4e6 + 9e8

Resolvendo o sistema encontramos e6 = −1 e e8 = 2. Assim, encontramos o erro, e(t) =
−1t6 + 2t8. E a mensagem original ´e

y(t) − e(t) = y(t) + t6 − 2t8

A seguir, veremos um exemplo com distˆancia m´ınima d(C) = 7, podendo corrigir

at´e trˆes erros.

Observa¸c˜ao 5.4.5. Os c´alculos foram feitas com aux´ılio do programa PARI/GP.

74

Exemplo 5.4.6. Seja α = 6 um elemento primitivo de F11, ent˜ao o seguinte polinˆomio
ser´a o gerador do c´odigo de Reed-Solomon de parˆametros (10,4). A redundˆancia do c´odigo

c´ıclico ser´a igual a 6, pois o grau(g(t)) = 6, enquanto a dim(C) = n−grau(g(t)) = 10−6 =

4.

g(t) = (t − 6)(t − 62)(t − 63)(t − 64)(t − 65)(t − 66)

= 6 + 3t + 8t2 + 9t3 + t4 + 4t5 + t6

Assim, a matriz geradora ´e

G =



















































6 0 0 0

3 6 0 0

8 3 6 0

9 8 3 6

1 9 8 3

4 1 9 8

1 4 1 9

0 1 4 1

0 0 1 4

0 0 0 1

E o polinˆomio e a matriz paridade ´e

h(t) =

t10 − 1

6 + 3t + 8t2 + 9t3 + t4 + 4t5 + t6 = 9 + t + 4t2 + 7t3 + t4















1 7 4 1 9 0 0 0 0 0

0 1 7 4 1 9 0 0 0 0

H =

0 0 1 7 4 1 9 0 0 0

0 0 0 1 7 4 1 9 0 0

0 0 0 0 1 7 4 1 9 0

0 0 0 0 0 1 7 4 1 9















Vamos encontrar uma palavra do c´odigo e adicionar dois erros:

75

2c1 + c3 = 2



6


3






8






9






1




4






1






0




0




0



0


0






6






3






8




9






1






4




1




0

+

=


























10

10


























1

6

0

6

3

4

1

0

∈ C.

y =


























10

10




























0


0






2






0






0




0






0






0




1




0

+

=

1

6

0

6

3

4

1

0


























10

10


























1

6

2

6

3

4

2

0

(cid:54)∈ C.

y(t) = 1 + 6t + 2t2 + 10t3 + 10t4 + 6t5 + 3t6 + 4t7 + 2t8

= 2g(t) + t2g(t) + 2t2 + t8

Temos α = 6, precisamos calcular as s´ındromes para descobrir quantos erros e a

localiza¸c˜ao dos erros. Como

g(x) =

6
(cid:89)

(x − αj),

j=1

calcularemos as seguintes s´ındromes S(αi) para i = 1, 2, . . . , 6:

S1 = y(α1) = 10

S3 = y(α3) = 8

S5 = y(α5) = 3

S2 = y(α2) = 1

S4 = y(α4) = 0

S6 = y(α6) = 10

76

Assume-se que o decodiﬁcador conhece o n´umero de erros ν, e por tentativa, come-

¸cando pelo maior valor de ν, iremos testar se o sistema possui solu¸c˜ao. Neste caso, como

n − k ≥ 2ν e n − k = 6, vamos resolver o seguinte sistema para ν = 3:



S1 S2 S3





S2 S3 S4

S3 S4 S5







=









Λ3





Λ2

Λ1









−S4





−S5

−S6

Substituindo os valores, temos





10 1 8





1

8





8 0

0 3

Resolvendo o sistema













=



Λ3





Λ2

Λ1














0

8


1

=

0

−3

−10







1

8

10 1 8 0







8 0 8

0 3 1

L2(cid:55)→L1+L2−→

10 1 8 0

0

9 8 8

0 3 1







8


10 1 8 0













L3(cid:55)→8L1+L3
−→





0

0

9 8 8

8 1 1



10 1 8 0

L3(cid:55)→4L2+L3
−→





0

0

9 8 8

0 0 0







Neste caso, uma linha da matriz ´e toda zero e o sistema ´e indeterminado, conclu´ımos

que o n´umero de erros ´e menor e testaremos para ν = 2 (como neste exemplo foram

inseridos 2 erros j´a era sabido que ν = 2), resolvendo o seguinte sistema:

(cid:34)

S1 S2

(cid:35) (cid:34)

Λ2

S2 S3

Λ1

(cid:35)

(cid:34)

=

(cid:35)

−S3

−S4

Substituindo os valores, temos

(cid:34)

10 1

(cid:35) (cid:34)

Λ2

(cid:35)

1

8

Λ1

(cid:34)

(cid:35)

−8

−0

(cid:34)

(cid:35)
3

0

=

=

Resolvendo o sistema encontramos Λ1 = 4 e Λ2 = 1, substituindo estes valores no

polinˆomio localizador de erro, temos

Λ(x) = 1 + Λ1x1 + Λ2x2 = 1 + 4x1 + 1x2

Precisamos encontrar as ra´ızes do polinˆomio de localiza¸c˜ao de erro, para isso ´e necess´ario

fazer tentativa com as candidatas a ra´ızes, as quais s˜ao: α, α2, α3, · · · , α10, sendo α = 6.

77

α = 6 −→ 1 + 4.6 + 62 = 61 = 6 (cid:54)= 0

α2 = 3 −→ 1 + 4.3 + 32 = 22 = 0

α3 = 7 −→ 1 + 4.7 + 72 = 78 = 1 (cid:54)= 0

α4 = 9 −→ 1 + 4.9 + 92 = 118 = 8 (cid:54)= 0

α5 = 10 −→ 1 + 4.10 + 102 = 141 = 9 (cid:54)= 0

α6 = 5 −→ 1 + 4.5 + 52 = 46 = 2 (cid:54)= 0

α7 = 8 −→ 1 + 4.8 + 82 = 97 = 2 (cid:54)= 0

α8 = 4 −→ 1 + 4.4 + 42 = 33 = 0

Desta forma, temos: Λ(α2) = Λ(α8) = 0. Assim,

1
X1

= α2 =⇒ X1 = α−2 = α8

e

1
X2

= α8 =⇒ X2 = α−8 = α2

Desta forma, encontramos que os erros est˜ao nas posi¸c˜oes 2 e 8, assim, e(t) = e2t2 + e8t8.

Falta, ent˜ao, encontrarmos o valor dos erros utilizando a seguinte equa¸c˜ao:

Temos

y(t) = p(t) + e2t2 + e8t8




10 = y(α) = e2α2 + e8α8



3 = y(α2) = e2α4 + e8α16

Como α2 = 3, α4 = 9, α8 = 4 e α16 = 5, obtemos:




10 = 3e2 + 4e8



1 = 9e2 + 5e8

Resolvendo o sistema temos: e2 = 2 e e8 = 1. Logo, e(t) = 2t2 + 1t8. Assim, a

78

mensagem original ´e



y(t) − e(t) = y(t) − 2t2 − 1t8 =

10

10




























0


0






2






0






0




0






0






0




1




0

−

=

1

6

2

6

3

4

2

0

















































10

10


























1

6

0

6

3

4

1

0

79

6 CONCLUS ˜AO

Na perspectiva desta autora, a teoria dos c´odigos corretores de erros foi um campo

de pesquisa desaﬁador, sobretudo sua aplicabilidade em trabalhos de alunos no Ensino

M´edio. Para tanto, foi necess´ario o aprofundamento e revis˜ao dos diferentes conceitos de

aritm´etica e ´algebra linear. Outro desaﬁo foi a necessidade de apropria¸c˜ao do conheci-

mento de softwares livres, tais como PARI/GP e Python.

Os algoritmos de codiﬁca¸c˜ao e decodiﬁca¸c˜ao de C´odigos Lineares, principalmente

os C´odigos de Hamming, podem ser trabalhados no ensino m´edio como aplica¸c˜ao de

opera¸c˜oes com matrizes e resolu¸c˜oes de sistema lineares, enquanto os c´odigos c´ıclicos

podem ser trabalhados no estudo de polinˆomios, sendo necess´ario o estudo de aritm´etica

modular. Para os c´odigos c´ıclicos ´e indicado o uso de algum software, como por exemplo,

o Python ou PARI/GP.

Seria interessante que na disciplina Recursos Computacionais no Ensino de Mate-

m´atica do PROFMAT fossem trabalhados estes softwares.

80

81

REFERˆENCIAS

FERNANDEZ, C. d. S.; HEFEZ, A. Introdu¸c˜ao `a ´Algebra Linear. Rio de Janeiro:
SBM. (Cole¸c˜ao PROFMAT), 2016.

HAMMING, Richard. Dispon´ıvel em: <http://sci-humor.blogspot.com/2014/01/you-
and-your-research-lecture-by.html>. Acesso em: 11 julho. 2019.

HEFEZ, A.; VILLELA, M. L. T. C´odigos corretores de erros. Rio de Janeiro:
Instituto de Matem´atica Pura e Aplicada, 2008.

MARTINEZ, F. B. et al. Teoria dos n´umeros: um passeio com primos e outros
n´umeros familiares pelo mundo inteiro. Rio de Janeiro: Instituto de Matem´atica
Pura e Aplicada, 2010.

SHANNON, Claude. Dispon´ıvel em: <https://pt.wikipedia.org/wiki/Claude Shannon>.
Acesso em: 12 julho. 2019.

TWUM, F. et al. Reed solomon encoding: Simpliﬁed explanation for programmers.
International Journal of Computer Science and Information Security, LJS
Publishing, v. 14, n. 12, p. 469, 2016.

VENTURA, J. Notas de Combinat´oria e Teoria de C´odigos. 2011. Dispon´ıvel em:
<https://www.math.tecnico.ulisboa.pt/˜jventura/CTC/ctc1415.html>. Acesso em: 28
nov. 2018.

