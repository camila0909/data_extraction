Uma abordagem de dígitos veriﬁcadores e códigos
corretores no Ensino Fundamental

Daniel Alves Machado

SERVIÇO DE PÓS-GRADUAÇÃO DO ICMC-USP

Data de Depósito:

Assinatura: ______________________

Daniel Alves Machado

Uma abordagem de dígitos veriﬁcadores e códigos
corretores no Ensino Fundamental

Dissertação apresentada ao Instituto de Ciências
Matemáticas e de Computação – ICMC-USP,
como parte dos requisitos para obtenção do título
de Mestre – Programa de Mestrado Proﬁssional em
Matemática. VERSÃO REVISADA

Área de Concentração: Matemática

Orientador: Prof. Dr. Marcelo Rempel Ebert

USP – São Carlos
Junho de 2016

Ficha catalográfica elaborada pela Biblioteca Prof. Achille Bassi
e Seção Técnica de Informática, ICMC/USP,
com os dados fornecidos pelo(a) autor(a)

Machado, Daniel Alves

M149u

Uma abordagem de dígitos verificadores e

códigos corretores no Ensino Fundamental / Daniel
Alves Machado; orientador Marcelo Rempel Ebert. –
São Carlos – SP, 2016.

63 p.

Dissertação (Mestrado - Programa de Pós-graduação

em Mestrado Profissional em Matemática em Rede
Nacional) – Instituto de Ciências Matemáticas e de
Computação, Universidade de São Paulo, 2016.

1. Dígitos verificadores. 2. Códigos corretores.
3. Códigos lineares. 4. Métrica de Hamming. I. Ebert,
Marcelo Rempel, orient. II. Título.

Daniel Alves Machado

An approach to check digits and error-correcting codes in
middle school

Master dissertation submitted to the Instituto de
Ciências Matemáticas e de Computação – ICMC-USP,
in partial fulﬁllment of the requirements for the degree
of the Master – Program in Mathematics Professional
Master. FINAL VERSION

Concentration Area: Mathematics

Advisor: Prof. Dr. Marcelo Rempel Ebert

USP – São Carlos
June 2016

Dedico este trabalho ao meu aﬁlhado Matheus Alexandre, para que
sempre acredite em seus sonhos e nunca deixe de estudar.

AGRADECIMENTOS

Ao meu orientador, professor Marcelo Rempel Ebert, por me orientar na elaboração do

trabalho.

A Madelaine Pires, pela ajuda com a correção ortográﬁca e gramatical.

À minha família e a minha namorada Carolina Binbanco, pelo apoio e paciência.

Aos alunos e à equipe da EMEF Eponina de Brito Rossetto, que possibilitaram a aplicação

da proposta pedagógica elaborada.

Aos meus companheiros de turma, pela ajuda mútua no decorrer do curso.

À professora Vanessa Rolnik Artioli, pelo ensinamento de como utilizar o programa

Latex.

Ao professor Luís Amilo, que sempre me inspirou.

A CAPES pelo apoio ﬁnanceiro.

“A Matemática apresenta invenções tão sutis
que poderão servir não só para satisfazer os curiosos como,
também para auxiliar as artes e poupar trabalho aos homens.”
(Descartes)

RESUMO

MACHADO, D. A.. Uma abordagem de dígitos veriﬁcadores e códigos corretores no En-
sino Fundamental. 2016. 63 f. Dissertação (Mestrado – Programa de Mestrado Proﬁssional em
Matemática) – Instituto de Ciências Matemáticas e de Computação (ICMC/USP), São Carlos –
SP.

Este trabalho, elaborado por meio de pesquisa bibliográﬁca, apresenta um apanhado sobre os
dígitos veriﬁcadores presentes no Cadastro de Pessoas Físicas (CPF), no código de barras, e no
sistema ISBN; faz uma introdução sobre a métrica de Hamming e os códigos corretores de erros;
cita a classe de códigos mais utilizada, que são os códigos lineares, e deixa a sugestão de uma
proposta pedagógica para professores de matemática aplicarem no Ensino Fundamental, podendo
ser ajustada também para o Ensino Médio. No apêndice A, são propostos alguns exercícios que
podem ser trabalhados com os alunos em sala de aula.

Palavras-chave: Dígitos veriﬁcadores, Códigos corretores, Códigos lineares, Métrica de Ham-
ming.

ABSTRACT

MACHADO, D. A.. Uma abordagem de dígitos veriﬁcadores e códigos corretores no En-
sino Fundamental. 2016. 63 f. Dissertação (Mestrado – Programa de Mestrado Proﬁssional em
Matemática) – Instituto de Ciências Matemáticas e de Computação (ICMC/USP), São Carlos –
SP.

This work, based on the attached references, presents an overview of the check digits that
appear in the Brazilian document CPF, in the bar code and the ISBN system. Moreover, it
makes an introduction to the Hamming metric and error-correcting codes. In particular, some
considerations about linear codes are done and it makes a suggestion of a pedagogical approach
to apply it in middle school and can also be adjusted to high school. In the Appendix A are
proposed some exercises to students.

Key-words: Check digits, Error-correcting codes, Linear codes, Hamming metric.

LISTA DE ILUSTRAÇÕES

.

.

.

.

.

.

.

.

Figura 1 – CPF .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 2 – Unidades da Federação . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 3 – Código de Barras
Figura 4 – Código EAN-13 de Alguns Países
. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 5 – Código ISBN .
Figura 6 – Disco de centro v = (0, 0) e raio r = 1 . . . . . . . . . . . . . . . . . . . .
Figura 7 – Disco de centro v = (1, 1) e raio r = 1 . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 8 – Tabela ASCII

.

.

.

.

.

22
23
24
25
26
32
33
63

SUMÁRIO

INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

DÍGITOS VERIFICADORES PRESENTES NO COTIDIANO . . . . 21
Cadastro de Pessoa Física (CPF) . . . . . . . . . . . . . . . . . . . . . 22
Códigos de barras . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
International Standard Book Number (ISBN) . . . . . . . . . . . . . 26

CÓDIGOS CORRETORES DE ERROS . . . . . . . . . . . . . . . . 29
Códigos .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
Métrica de Hamming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

.

.

.

.

.

CÓDIGOS LINEARES . . . . . . . . . . . . . . . . . . . . . . . . . . 35
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Decodificação .

.

PROPOSTA DO TEMA . . . . . . . . . . . . . . . . . . . . . . . . . 45
Primeira etapa: Dígitos verificadores de erros no CPF . . . . . . . . 45
Segunda etapa: Dígito verificador de erro no código de barras . . . 46
Terceira etapa: Linguagem de computadores . . . . . . . . . . . . . . 46
Quarta etapa: Noção de códigos corretores
. . . . . . . . . . . . . . 46
. . . . . . . . . . . . . . . . . . . . 47
Quinta etapa: Códigos corretores
Percepções pessoais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

1

2
2.1
2.2
2.3

3
3.1
3.2

4
4.1

5
5.1
5.2
5.3
5.4
5.5
5.6

Referências . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

APÊNDICE A
A.1
A.2
A.3
A.4

Capítulo 2 .
Capítulo 3 .
Capítulo 4 .
Soluções .
.

.
.
.
.

EXERCÍCIOS SUGERIDOS . . . . . . . . . . . . . . . 53
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

.
.
.
.

.
.
.
.

.
.
.
.

ANEXO A
A.1

ANÉIS E CORPOS . . . . . . . . . . . . . . . . . . . . . . 59
Classes residuais de inteiros . . . . . . . . . . . . . . . . . . . . . . . . 60

ANEXO B

TABELA ASCII . . . . . . . . . . . . . . . . . . . . . . . . 63

19

CAPÍTULO

1

INTRODUÇÃO

Os códigos estão presentes na vida das pessoas, e nós os utilizamos a todo momento,
para pagar uma conta, para comprar um produto, para se comunicar; o nosso próprio alfabeto é
um exemplo de código.

Os códigos numéricos estão presentes nos documentos pessoais, códigos postais, boletos
bancários, entre outros. Seu uso possui algumas vantagens, como poder registrar uma quantidade
maior de informações, e ser entendido em qualquer idioma, contudo, sua principal desvantagem
é a diﬁculdade de detectar a presença de erros.

Para contornar essa desvantagem, alguns códigos acrescentam dígitos veriﬁcadores,
que são obtidos por meio de operações matemáticas com os demais dígitos do código, alguns
exemplos de dígitos veriﬁcadores e seus algoritmos de cálculo serão apresentados no Capítulo 2,
baseado em (FINI, 2009).

Os dígitos veriﬁcadores permitem apenas detectar alguns tipos de erros, mas não oferece
formas para corrigi-los, para isso, é preciso acrescentar dígitos de redundância, semelhantes
aos dígitos veriﬁcadores, porém em maior quantidade. No Capítulo 3, baseado em (HEFEZ;
VILLELA, 2002) e em (MILIES, 2009), serão apresentados alguns conceitos da métrica de
Hamming, lemas e propriedades que indicarão a quantidade de erros que podem ser detectados e
corrigidos por um código; essa capacidade de correção está relacionada à quantidade de dígitos
de redundância que serão acrescentados.

A classe dos códigos que é mais utilizada para detecção e correção de erros é a classe dos
códigos lineares, que será apresentada no Capítulo 4, baseado em (HEFEZ; VILLELA, 2002),
nele estão formas de codiﬁcar as palavras, veriﬁcar se a palavra recebida pertence ou não ao
código, e um algoritmo para corrigir erros que estejam dentro da capacidade de correção do
código.

Por ﬁm, será apresentada uma proposta pedagógica, no Capítulo 5, com sugestão de

20

Capítulo 1. Introdução

aplicação no Ensino Fundamental, utilizando recursos presentes no cotidiano dos alunos, tudo
de forma simples e coerente com o nível fundamental de ensino.

21

CAPÍTULO

2

DÍGITOS VERIFICADORES PRESENTES NO
COTIDIANO

O uso de códigos numéricos é cada vez mais comum no cotidiano, eles aparecem na
identiﬁcação de produtos (códigos de barras), nos códigos postais, nos documentos pessoais, tais
como Registro Geral (RG), Título de Eleitor, Cadastro de Pessoa Física (CPF), Carteira Nacional
de Habilitação (CNH), entre outros.

O uso de códigos numéricos é vantajoso, pois pode ser entendido em todos os idiomas
e possibilita registrar uma quantidade maior de informação do que se utilizássemos apenas
nomes, por exemplo, se alguém se chama “José da Silva” e algum membro do governo precisa
localizá-lo, provavelmente haverá vários outros homônimos, tornando difícil a diferenciação de
cada um deles, entretanto o número do CPF é único e o “José da Silva” correto, será facilmente
identiﬁcado. Por outro lado, é mais difícil perceber, visualmente, erros de digitação em códigos
numéricos, por exemplo, se alguém digita o CPF “213.453.966-98”, como podemos veriﬁcar se
houve erro de digitação ou não? Com palavras é mais fácil de visualizar; se for digitada a palavra
“sabpnete”, por exemplo, é fácil perceber que há um erro de digitação e que a palavra correta era
“sabonete”.

Pensando nisso, foram criados dígitos veriﬁcadores de erros que permitem veriﬁcar, na
maioria das vezes, se houve erro de digitação nos códigos numéricos, esses dígitos veriﬁcadores
são resultados de operações matemáticas com os demais dígitos do código. Mostraremos nas
próximas seções, como são calculados os dígitos veriﬁcadores presentes no CPF, nos códigos de
barras e no sistema ISBN (International Standard Book Number), esses códigos estão associados
ao sistema EAN (European Article Number), norma que garante o reconhecimento do código
em todos os países, nesse sistema os códigos possuem de oito a treze algarismos.

22

Capítulo 2. Dígitos veriﬁcadores presentes no cotidiano

2.1 Cadastro de Pessoa Física (CPF)

“CPF é um banco de dados gerenciado pela Secretaria da Receita Federal do Brasil -
RFB que armazena informações cadastrais de contribuintes obrigados à inscrição no CPF, ou de
cidadãos que se inscreveram voluntariamente.” (RFB, 2015)

Figura 1 – CPF

Fonte: RFB (2015).

Seu código é da forma EAN-11, composto por onze algarismos, dos quais:

∙ Os oito primeiros algarismos representam o número-base.

∙ O nono algarismo indica a unidade da Federação em que o CPF foi cadastrado.

∙ Os dois últimos algarismos são dígitos veriﬁcadores.

A relação do nono algarismo com a unidade da Federação em que foi realizado o cadastro

está representada na ﬁgura 2.

Os dígitos veriﬁcadores são obtidos através dos algarismos anteriores, se eles estiverem
em desacordo com a lei de formação, signiﬁca que o número de CPF é inválido, ou seja, há erro
no número apresentado. Por outro lado, se os dígitos veriﬁcadores estiverem de acordo com a lei
de formação, então o número de CPF é válido, o que não signiﬁca, necessariamente, que haja
uma pessoa cadastrada com ele no banco de dados da Receita Federal.

Seja X1X2X3X4X5X6X7X8X9X10X11 um número de CPF em que Xi representa o algarismo
de posição i, com i variando de 1 a 11, a escolha dos dígitos veriﬁcadores é dada pelas regras:

Cálculo do primeiro dígito veriﬁcador:

∙ Multiplica-se os nove primeiros algarismos (ordenados da esquerda para a direita) pelos
números (1, 2, 3, 4, 5, 6, 7, 8, 9), ou seja, multiplica-se X1 por 1, X2 por 2, X3 por 3, ..., X9
por 9.

∙ Soma-se os resultados obtidos pelas multiplicações.

2.1. Cadastro de Pessoa Física (CPF)

23

Figura 2 – Unidades da Federação

Fonte: Fini (2009, p. 74).

∙ Divide-se a soma obtida por 11.

∙ O resto dessa divisão será o primeiro dígito veriﬁcador, ou seja, será o valor de X10

Observação 1. Se o resto obtido for 10, o dígito veriﬁcador será 0.

Cálculo do segundo dígito veriﬁcador:

∙ Multiplica-se os dez primeiros algarismos (ordenados da esquerda para a direita), incluindo
agora o primeiro dígito veriﬁcador obtido no passo anterior, pelos números (0, 1, 2, 3, 4, 5,
6, 7, 8, 9), ou seja, multiplica-se X1 por 0, X2 por 1, X3 por 2, ..., X10 por 9.

∙ Soma-se os resultados obtidos pelas multiplicações.

∙ Divide-se a soma obtida por 11.

∙ O resto dessa divisão será o segundo dígito veriﬁcador, ou seja, será o valor de X11

Observação 2. Se o resto obtido for 10, o dígito veriﬁcador será 0.

Exemplo 1. Vamos analisar o número “213.453.966-98”, apresentado na introdução deste
capítulo, e veriﬁcar se os dígitos veriﬁcadores estão em concordância com as regras apresentadas,
caso não estejam, vamos encontrar os dígitos corretos. Como o nono dígito é igual a 6, podemos
aﬁrmar que esse cadastro foi realizado no estado de Minas Gerais.

Para o primeiro dígito veriﬁcador,temos:

24

Capítulo 2. Dígitos veriﬁcadores presentes no cotidiano

(2 × 1) + (1 × 2) + (3 × 3) + (4 × 4) + (5 × 5) + (3 × 6) + (9 × 7) + (6 × 8) + (6 × 9) =

= 2 + 2 + 9 + 16 + 25 + 18 + 63 + 48 + 54 = 237

237 = (11 × 21) + 6

Logo, o primeiro dígito veriﬁcador é igual a 6.

Para o segundo dígito veriﬁcador,temos:

(2 × 0) + (1 × 1) + (3 × 2) + (4 × 3) + (5 × 4) + (3 × 5) + (9 × 6) + (6 × 7) + (6 × 8) +

(6 × 9) =

= 0 + 1 + 6 + 12 + 20 + 15 + 54 + 42 + 48 + 54 = 252

252 = (11 × 22) + 10

Logo, o segundo dígito veriﬁcador é igual a 0.

Portanto, o número “213.453.966-98” não representa um CPF válido, o código correto

deveria ser “213.453.966-60”.

2.2 Códigos de barras

O código de barras é da forma EAN-13, composto por 13 algarismos dos quais os três
primeiros representam o país de origem, o último é um dígito veriﬁcador e os intermediários
identiﬁcam o código da empresa fabricante e o código do produto.

Figura 3 – Código de Barras

Fonte: http://http://goo.gl/htsZ5m Acesso em 02 nov. 2015

Na ﬁgura 4 apresentamos uma tabela com os códigos identiﬁcadores de alguns países, o

código referente ao Brasil é “789”.

O último algarismo, que corresponde ao dígito veriﬁcador, é gerado automaticamente
por meio de operações matemáticas com os algarismos anteriores, mostraremos agora como é
calculado o dígito veriﬁcador dos códigos de barras.

2.2. Códigos de barras

25

Figura 4 – Código EAN-13 de Alguns Países

Fonte: Fini (2009, p. 73).

Seja X1X2X3X4X5X6X7X8X9X10X11X12X13 um número de código de barras em que Xi
representa o algarismo de posição i, com i variando de 1 a 13, a escolha do dígito veriﬁcador é
dada pelas regras:

∙ Multiplica-se os doze primeiros algarismos (ordenados da esquerda para a direita) pelos
números (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3), ou seja, multiplica-se X1 por 1, X2 por 3, X3 por
1, ..., X12 por 3.

∙ Soma-se os resultados obtidos pelas multiplicações.

∙ Se a soma obtida for um número divisível por 10, o dígito veriﬁcador será “0”.

∙ Se a soma obtida não for um número divisível por 10, a diferença de 10 pelo resto da

divisão efetuada será o dígito veriﬁcador.

Exemplo 2. Vamos analisar o número “7898357417892”, apresentado no início desta seção, e
veriﬁcar se o dígito veriﬁcador está em concordância com as regras apresentadas.

Como o código formado pelos três primeiros dígitos é igual a 789, podemos aﬁrmar que

o produto foi fabricado no Brasil.

Para o dígito veriﬁcador,temos:

(7 × 1) + (8 × 3) + (9 × 1) + (8 × 3) + (3 × 1) + (5 × 3) + (7 × 1) + (4 × 3) + (1 × 1)+

26

Capítulo 2. Dígitos veriﬁcadores presentes no cotidiano

+(7 × 3) + (8 × 1) + (9 × 3) = 7 + 24 + 9 + 24 + 3 + 15 + 7 + 12 + 1 + 21 + 8 + 27 = 158

158 = (10 × 15) + 8

Como a soma não é um número divisível por 10, façamos a diferença de 10 pelo resto da

divisão:

10 − 8 = 2

Logo, o dígito veriﬁcador do código de barras é “2” e está de acordo com a ﬁgura

apresentada.

2.3

International Standard Book Number (ISBN)

O ISBN - International Standard Book Number - é um sistema internacional
padronizado que identiﬁca numericamente os livros segundo o título, o autor, o
país, a editora, individualizando-os inclusive por edição. Utilizado também para
identiﬁcar software, seu sistema numérico é convertido em código de barras, o
que elimina barreiras linguísticas e facilita a circulação e comercialização das
obras. (ISBN, 2015)

Os códigos do sistema ISBN são da forma EAN-13, com treze algarismos que trazem informações
sobre o título do livro, editora, preﬁxo EAN e dígito veriﬁcador, conforme ﬁgura abaixo:

Figura 5 – Código ISBN

Fonte: ISBN (2015).

O último algarismo, que corresponde ao dígito veriﬁcador, é gerado automaticamente, as

regras para o cálculo são as mesmas aplicáveis aos códigos de barras, logo:

Seja X1X2X3X4X5X6X7X8X9X10X11X12X13 um número do sistema ISBN em que Xi repre-
senta o algarismo de posição i, com i variando de 1 a 13, a escolha do dígito veriﬁcador é dada
pelas regras:

∙ Multiplica-se os doze primeiros algarismos (ordenados da esquerda para a direita) pelos
números (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3), ou seja, multiplica-se X1 por 1, X2 por 3, X3 por
1, ..., X12 por 3.

2.3. International Standard Book Number (ISBN)

27

∙ Soma-se os resultados obtidos pelas multiplicações.

∙ Se a soma obtida for um número divisível por 10, o dígito veriﬁcador será “0”.

∙ Se a soma obtida não for um número divisível por 10, a diferença de 10 pelo resto da

divisão efetuada será o dígito veriﬁcador.

Exemplo 3. Vamos veriﬁcar se o dígito veriﬁcador do código “978-85-333-0400-5” está correto.

Para o dígito veriﬁcador, temos:

(9 × 1) + (7 × 3) + (8 × 1) + (8 × 3) + (5 × 1) + (3 × 3) + (3 × 1) + (3 × 3) + (0 × 1)+

+(4 × 3) + (0 × 1) + (0 × 3) = 9 + 21 + 8 + 24 + 5 + 9 + 3 + 9 + 0 + 12 + 0 + 0 = 100

100 ÷ 10 = 10

Como a soma é um número divisível por 10, o dígito veriﬁcador correto é “0”, isso
signiﬁca que o código ISBN apresentado não é válido, o código correto deveria ser “978-85-333-
0400-0”.

29

CAPÍTULO

3

CÓDIGOS CORRETORES DE ERROS

3.1 Códigos

Vamos apresentar os elementos básicos de um código:

∙ Alfabeto, que representaremos por A é um conjunto ﬁnito cujos elementos são todos
os símbolos que utilizaremos para formar as palavras, representaremos por “q = |A|” a
quantidade de elementos de A, sendo chamado de código q-ário. Podemos citar como
exemplo os códigos binários, A = {0, 1}, e os códigos ternários, A = {0, 1, 2}.

∙ Palavras são sequências ﬁnitas de símbolos do alfabeto A.

∙ Comprimento é o número de letras, que representaremos por n, de uma palavra. Para
facilitar a construção de um sistema de veriﬁcação e correção de erros, convencionaremos
que todas as palavras tenham o mesmo comprimento, isso é sempre possível, basta
adicionarmos símbolos neutros às palavras.

∙ Um código q-ário C, composto por palavras, de nossa escolha, com comprimento n, é um
subconjunto de An, ou seja, dentre todas as palavras de comprimento n que podem ser
formadas com o alfabeto A, escolhemos algumas que possuirão sentido.

O exemplo de código mais simples que podemos imaginar é a Língua Portuguesa, cujo
alfabeto é composto por 26 letras mais o espaço, que consideraremos como uma letra, nossa
maior palavra, “pneumoultramicroscopicossilicovulcanoconiótico”, é composta por 46 letras, se
acrescentássemos espaços à esquerda de todas as outras palavras da língua poderíamos deixar
todas com comprimento 46.

Entretanto, nosso idioma não é bom para detectar e corrigir erros, por exemplo, se
enviássemos a palavra “árvore” e o receptor recebesse a palavra “árvpre”, seria fácil perceber

30

Capítulo 3. Códigos corretores de erros

que foi cometido um erro e que a palavra mais próxima é “árvore”, já se a palavra enviada fosse
“pato” e a recebida fosse “aato”, podemos detectar que há erro, mas como saber se a palavra
correta é “rato”, “gato”, “jato”, “pato”, “mato”, ou tantas outras? Ou ainda, se a palavra recebida
fosse “rato”, como seria possível identiﬁcar o erro? Uma solução para problemas como esse
consiste em usar códigos numéricos que veremos mais adiante.

Sempre que enviamos uma mensagem estamos sujeitos a interferências eletromagnéticas,
chamadas de ruídos, que podem causar erros, um mecanismo que possibilita detectar e corrigir
esses erros consiste em codiﬁcar a mensagem acrescentando redundâncias, semelhante aos
dígitos veriﬁcadores que foram estudados no capítulo anterior. Tal teoria será apresentada no
Capítulo 4.

3.2 Métrica de Hamming

Deﬁnição 1. Dados dois elementos u e v ∈ An = A × A × · · · × A
(cid:125)

(cid:124)

(cid:123)(cid:122)
n vezes

u e v é deﬁnida como

, a distância de Hamming entre

d(u, v) = |{i : ui ̸= vi, 1 ≤ i ≤ n}|.

Exemplo 4. Em {0, 1}4, temos

d(0101, 1001) = 2

d(1000, 1111) = 3

d(1100, 1101) = 1

d(0000, 1111) = 4

d(1101, 1101) = 0

Como veremos na proposição abaixo, a distância de Hamming satisfaz as três proprieda-

des de métrica e chamaremos de métrica de Hamming.

Proposição 1. Dados u, v e w ∈ An, valem as seguintes propriedades:

1. Positividade: d(u, v) ≥ 0, a igualdade só vale se, e somente se, u = v.

2. Simetria: d(u, v) = d(v, u).

3. Desigualdade Triangular: d(u, v) ≤ d(u, w) + d(w, v).

Demonstração. (1) e (2) seguem imediatamente da deﬁnição.

(3) A contribuição das i-ésimas coordenadas de u e v para d(u, v) é igual a zero se ui = vi,

e igual a um se ui ̸= vi.

3.2. Métrica de Hamming

31

No caso em que a contribuição é zero, certamente a contribuição das i-ésimas coordenadas
a d(u, v) é menor ou igual a das i-ésimas coordenadas a d(u, w) + d(w, v), que será igual a 0, 1
ou 2.

No caso em que a contribuição é um, temos que ui ̸= vi e, portanto, não podemos
ter ui = wi e wi = vi. Por consequência, temos que a contribuição das i-ésimas coordenadas a
d(u, w)+d(w, v) é maior ou igual a 1 que é a contribuição das i-ésimas coordenadas a d(u, v).

Vamos deﬁnir agora o conceito de disco e esfera.

Deﬁnição 2. Sejam a ∈ An e um número real r > 0, deﬁnimos o disco e a esfera de centro em a
e raio r como sendo os respectivos conjuntos

D(a, r) = {u ∈ An : d(u, a) ≤ r},

S(a, r) = {u ∈ An : d(u, a) = r}.

Disco e esfera são conjuntos ﬁnitos, veremos um lema que mostrará as suas cardinalidades

que representaremos por |D(a, r)| e |S(a, r)|, respectivamente.

Lema 1. Para todo a ∈ An e todo número natural r ≥ 0, temos que

|D(a, r)| =

(cid:19)

(q − 1)i,

(cid:18)n
i

r
∑
i=0

em que n é o comprimento das palavras e q é a quantidades de letras presentes no alfabeto.

r
(cid:83)
i=0

Demonstração. Primeiro é preciso notar que S(a, i) ∩ S(a, j) = /0 quando i ̸= j, com isso ﬁca
(cid:1)(q − 1)i De

S(a, i). Para ﬁnalizar, bastar provar que |S(a, i)| = (cid:0)n
i

fácil perceber que D(a, r) =

fato, como temos q letras presentes no alfabeto, tomada qualquer letra de a, temos exatamente
(q − 1) diferentes possibilidades de substituí-la para formar uma palavra diferente de a. Se
quisermos que a distância da nova palavra a a seja i, teremos que fazer i alterações em a, ou seja,
pelo princípio multiplicativo, temos (q − 1)i possibilidades. Finalmente, para esgotar todas as
possibilidades, levando em conta a posição de cada letra, é preciso multiplicar o resultado por
(cid:0)n
i

(cid:1), logo

|S(a, i)| =

(q − 1)i.

(cid:19)

(cid:18)n
i

É interessante notar que o disco e a esfera adotados na métrica de Hamming são diferentes
de discos e esferas convencionais, vejamos alguns exemplos gráﬁcos da métrica de Hamming
aplicada no A2 em que A = {−6, −5, −4, −3, −2, −1, 0, 1, 2, 3, 4, 5, 6}.

Exemplo 5. Seja v = (0, 0). Todos os pares ordenados cuja distância de Hamming a v é menor
ou igual a 1, devem ser da forma (0, y) ou da forma (x, 0), conforme a ﬁgura 6.

32

Capítulo 3. Códigos corretores de erros

Figura 6 – Disco de centro v = (0, 0) e raio r = 1

Fonte: Elaborada pelo autor.

Exemplo 6. Seja v = (1, 1) Todos os pares ordenados cuja distância de Hamming a v é menor
ou igual a 1, devem ser da forma (1, y) ou da forma (x, 1), conforme a ﬁgura 7.

Deﬁnição 3. Seja C um código, a distância mínima de C é o número

d = min{d(u, v) : u, v ∈ C e u ̸= v}.

Lema 2. Seja C um código com distância mínima d. Se c e c′ são palavras distintas de C, então

D(c, κ) ∩ D(c′, κ) = /0.

3.2. Métrica de Hamming

33

Figura 7 – Disco de centro v = (1, 1) e raio r = 1

Fonte: Elaborada pelo autor.

κ =

(cid:21)

(cid:20)d − 1
2

Aqui κ é deﬁnido por

onde [x] denota a parte inteira de x.

Demonstração. Vamos supor, por absurdo, que existe t pertencente a D(c, κ) ∩ D(c′, κ), então
d(t, c) ≤ κ e d(t, c′) ≤ κ. Pelas propriedades de simetria e desigualdade triangular, temos

d(c, c′) ≤ d(c,t) + d(t, c′) ≤ 2κ ≤ d − 1

o que é um absurdo, pois d(c, c′) ≥ d. Logo D(c, κ) ∩ D(c′, κ) = /0.

34

Capítulo 3. Códigos corretores de erros

A distância mínima d de um código é extremamente importante, pois a partir dela
podemos deﬁnir a quantidade de erros que podem ser detectados e a quantidade de erros que
podem ser corrigidos, conforme o teorema a seguir.

Teorema 1. Seja C um código com distância mínima d. Então C pode corrigir até κ =

erros e detectar no máximo d − 1 erros.

(cid:21)

(cid:20)d − 1
2

Demonstração. Suponha que ao transmitirmos uma palavra c do código cometemos t erros com
t ≤ κ, recebendo a palavra r, então d(r, c) = t ≤ κ. Pelo Lema 2, r /∈ D(c′, κ), para toda palavra
c′ ̸= c. Isso determina c univocamente a partir de r.

Por outro lado, dada uma palavra do código, sempre que forem cometidos até d − 1 erros,
a palavra recebida não coincidirá com outra palavra do código, e assim, a detecção do erro será
possível.

Exemplo 7. Seja um código C, com distância mínima d = 8, então C detecta até 8 − 1 = 7 erros

e corrige no máximo κ =

= 3 erros.

(cid:21)

(cid:20)8 − 1
2

Como a distância mínima está ligada à capacidade de detectar e corrigir erros, quanto
maior for essa distância, maior será a quantidade de erros que poderão ser detectados e corrigidos,
é fundamental poder calcular d ou pelo menos determinar uma cota superior.

35

CAPÍTULO

4

CÓDIGOS LINEARES

A classe dos códigos mais utilizadas é a classe dos códigos lineares, introduzida a seguir.

Deﬁnição 4. Seja K um corpo1 ﬁnito com q elementos. Um código C ⊂ Kn é dito linear se:

1. (000 · · · 0) ∈ C;

2. dados u1, u2 ∈ C, u1 − u2 ∈ C;

Exemplo 8. Tomando o corpo K = Z2 = {[0], [1]}, tem-se que Z5
C = {(00000), (01011), (10110), (11101)} ⊂ Z5

2 é um código linear. 2

2 também é um corpo e que

Dada uma matriz G = (Ik|Ak×(n−k))k×n com entradas num corpo K, podemos considerar

a aplicação dada por

TG : Kk → Kn

u = (x1 · · · xk) ↦→ TGu = uG = (x1 · · · xk, uA).

Proposição 2. C = ImTG é um código linear.

Demonstração. É claro que:

1. (000...0) ∈ ImTG.

2. Dados v1, v2 ∈ ImTG, existem u1, u2 ∈ Kn tais que TGu1 = v1 e TGu2 = v2. Assim, existe

u = u1 − u2 ∈ Kk tal que TG(u) = TG(u1 − u2) = TGu1 − TGu2 = v1 − v2.

1 Ver Anexo A.
2 Aqui e no que segue usaremos a notação k = [k], k = 0, 1.

36

Capítulo 4. Códigos lineares

Deﬁnição 5. Se C é um código linear, com C = ImTG, a matriz G = (Ik|Ak×(n−k))k×n com
entradas num corpo K, é dita matriz de codiﬁcação na forma padrão de C.

Nos próximos dois exemplos, vamos apresentar uma matriz geradora G = (Ik|Ak×(n−k))k×n,

na forma padrão e o código linear associado C.

Exemplo 9. Considere a matriz na forma padrão

(cid:32)

G =

1 0 1 1 0
0 1 0 1 1

(cid:33)

,

e a aplicação dada por

TG : K2 → K5

u = (x1 x2) ↦→ TGu = uG = (x1 x2 x1 (x1 + x2) (x2)).

Tomando K = Z2, temos que C = ImTG = {(00000), (01011), (10110), (11101)} ⊂ Z5
digo linear associado.

2 é o có-

Exemplo 10. Considere a matriz na forma padrão






G =

1 0 0 1 1 0
0 1 0 1 0 1
0 0 1 0 1 1






e a aplicação dada por

u = (x1 x2 x3) ↦→ TGu = uG = (x1 x2 x3 (x1 + x2) (x1 + x3) (x2 + x3)).

TG : K3 → K6

Tomando K = Z2, temos que

C = ImTG = {(000000), (001011), (010101), (100110), (011110), (101101), (110011), (111000)} ⊂ Z6
2

é o código linear associado.

Deﬁnição 6. A transposta da matriz A = [ai, j]m,n

i, j=1 é a matriz At = [a j,i]n,m

j,i=1

A seguinte deﬁnição será utilizada para detectar se uma palavra pertence ou não ao

código.

Deﬁnição 7. Seja G = (Ik|Ak×(n−k))k×n uma matriz de codiﬁcação na forma padrão, deﬁne-se a
matriz teste de paridade por H = (−At|I)(n−k)×n.

Proposição 3. Sejam G = (Ik|Ak×(n−k))k×n uma matriz geradora do código C = Im(TG), escrita
na forma padrão, e H a matriz teste de paridade do código C. Então v = (v1...vn) ∈ C se, e
somente se, Hvt = 0.

Demonstração. (⇒) Suponha que v ∈ Im( fG). Logo existe u ∈ Rk tal que

37

Como

logo

v = uG = (u1...uk)(Ik|A) = (u, uA).






vt =

ut

(uA)t






,

n×1

Hvt = (−At|I)






ut

(uA)t


 = −Atut + (uA)t = −(uA)t + (uA)t = 0.


(⇐) Suponha que Hvt = 0 em que v = (z, w), com z ∈ Rk e w ∈ Rn−k. Assim

Hvt = (−At|I)











zt

wt

n×1

= −Atzt + wt = 0.

Logo wt = Atzt, i.e., w = zA. Portanto, v = (z, w) = (z, zA) = zG ∈ C.

Exemplo 11. Seja um código linear C gerado pela matriz

e com matriz teste de paridade

(cid:32)

G =

(cid:33)

1 0 1 1 0
0 1 0 1 1






H =

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1




 .

Sejam os vetores v = (11101) e v′ = (10111), temos:

∙ Hvt = (000)t, logo v ∈ C.

∙ Hv′t = (001)t, logo v′ /∈ C.

Deﬁnição 8. Seja x ∈ Kn, o peso de x é o número inteiro

ω(x) = |{i : xi ̸= 0, 1 ≤ i ≤ n, i ∈ N}|.

Em outras palavras, ω(x) = d(x, 0), em que d é a métrica de Hamming.

Deﬁnição 9. Deﬁne-se o peso de um código linear C como sendo o número inteiro

ω(C) := min{ω(x) : x ∈ C ∖ {0}}.

38

Capítulo 4. Códigos lineares

Proposição 4. Seja C ∈ Kn um código linear com distância mínima d. Temos que

1. Para todo x, y pertencente a Kn, d(x, y) = ω(x − y).

2. d = ω(C).

Demonstração. O item (1) segue diretamente das deﬁnições de métrica de Hamming e da de
peso de um elemento. Para o item (2), temos que, como C é um código linear, para todo par de
elementos x, y em C com x ̸= y, temos que z = x − y pertence a C ∖ {0} e d(x, y) = ω(z).

Exemplo 12. Tomando o código linear C = {(00000), (01011), (10110), (11101)} ⊂ Z5

2, temos

ω(00000) = 0;

d(01011, 00000) = ω(01011) = 3;

d(10110, 00000) = ω(10110) = 3;

d(11101, 00000) = ω(11101) = 4;

d(01011, 10110) = ω(01011 − 10110) = 4;

d(01011, 11101) = ω(01011 − 11101) = 3;

d(10110, 11101) = ω(10110 − 11101) = 3;

ω(C) = 3.

Logo, d = 3 = ω(C).

A proposição anterior é importante, pois fornece outra forma de calcular a distância
mínima de um código, se inicialmente era preciso tomar duas a duas todas as M palavras do
(cid:1) cálculos, agora, com a equivalência
código e calcular a distância entre elas, efetuando assim (cid:0)M
2
de distância mínima e peso do código, basta calcular o peso de todas as palavras, exceto (00...00),
efetuando assim M − 1 cálculos, o que gera um custo computacional bem menor que o inicial.

4.1 Decodificação

Deﬁnição 10. Dados um código C com matriz teste de paridade H e um vetor v ∈ Kn, deﬁne-se
o vetor Hvt como sendo a síndrome de v.

Deﬁnição 11. A diferença entre o vetor recebido r e o vetor transmitido c é chamada de vetor
erro e, ou seja

e = r − c.

4.1. Decodiﬁcação

39

Exemplo 13. Se, em um determinado código C ⊂ Z8
e tenha sido recebida a palavra (00101011), temos

2, tenha sido transmitida a palavra (10101010)

e = (10101010) − (00101011) = (10000001).

É importante notar que o número de erros presente na palavra recebida é igual ao peso

do vetor erro.

Seja H a matriz teste de paridade do código, como Hct = 0, temos o seguinte resultado

Het = H(rt − ct) = Hrt − Hct = Hrt − 0 = Hrt.

Isso signiﬁca que o vetor erro tem a mesma síndrome da palavra recebida.

Chamemos de hi a i-ésima coluna de H e e = (α1...αn) o vetor erro, então

n
∑
i=1

αihi = Het = Hrt.

Deﬁnição 12. Seja v ∈ Kn e C um código linear, então deﬁnimos o conjunto

v +C = {v + c : c ∈ C}.

Lema 3. Os vetores u e v de Kn têm a mesma síndrome se, e somente se, u ∈ v +C.

Demonstração. Hut = Hvt ⇔ H(u − v)t = 0 ⇔ u − v ∈ C ⇔ u ∈ v +C.

Na próxima proposição apresentaremos algumas propriedade que os conjuntos v + C

gozam.

Proposição 5. Seja C um (n, k)-código linear. Temos que

1. v +C = v′ +C ⇔ v − v′ ∈ C;

2. (v +C) ∩ (v′ +C) ̸= /0 ⇔ v +C = v′ +C;

3. (cid:83)
v∈Kn

(v +C) = Kn;

Demonstração. Vamos demonstrar somente o item 1, sendo que as demonstrações dos itens 2 e
3 são análogas.

Suponha que v + C = v′ + C. Dado x ∈ v + C = v′ + C, existem c1, c2 ∈ C tais que

x = v + c1 = v′ + c2. Logo v − v′ = c2 − c1 ∈ C.

Reciprocamente, suponha v − v′ ∈ C. Se x ∈ v +C, então existe c1 ∈ C tal que x = v + c1.
Ainda como x = v − v′ + v′ + c1 e v − v′ ∈ C, segue que x ∈ v′ +C. Portanto, temos que v +C ⊂
v′ +C.

40

Capítulo 4. Códigos lineares

Por outro lado, Se x ∈ v′ + C, então existe c2 ∈ C tal que x = v′ + c2. Ainda, como

x = v′ − v + v + c2 e v′ − v ∈ C, segue que x ∈ v +C. Portanto, temos que v′ +C ⊂ v +C.

Deﬁnição 13. Deﬁne-se classe lateral de v segundo C como v +C.

Exemplo 14. Tomando o código linear C = {(00000), (01011), (10110), (11101)} ⊂ Z5
as classes laterais

2,temos

(00000) +C = {(00000), (01011), (10110), (11101)};

(00001) +C = {(00001), (01010), (10111), (11100)};

(00010) +C = {(00010), (01001), (10100), (11111)};

(00100) +C = {(00100), (01111), (10010), (11001)};

(01000) +C = {(01000), (00011), (11110), (10101)};

(10000) +C = {(10000), (11011), (00110), (01101)};

(10001) +C = {(10001), (11010), (00111), (01100)};
...

(11111) +C = {(11111), (10100), (01001), (00010)};

Com base no item (1), podemos aﬁrmar

v +C = C ⇔ v ∈ C.

Deﬁnição 14. Um vetor peso mínimo numa classe lateral é chamado de elemento líder dessa
classe.

Proposição 6. Seja C um código linear em Kn com distância mínima d. Se u ∈ Kn é tal que

ω(u) ≤ κ =

(cid:20)d − 1
2

(cid:21)

,

então u é o único elemento líder de sua classe.

Demonstração. Vamos supor que existam u e u′, com u ̸= u′, com ω(u) ≤
(cid:20)d − 1
2

tais que u e u′ pertençam à mesma classe de C. Logo u − u′ ∈ C e

(cid:21)

(cid:21)

(cid:20)d − 1
2

e ω(u′) ≤

ω(u − u′) ≤ ω(u) + ω(u′) ≤

(cid:21)

(cid:20)d − 1
2

+

(cid:21)

(cid:20)d − 1
2

≤ d − 1.

Pela Proposição 4 (1) d(u, u′) = ω(u − u′) e, por hipótese, u − u′ ∈ C, temos que d(u, u′) ≤
d − 1 < d o que é um absurdo, logo u = u′.

4.1. Decodiﬁcação

41

Observação 3. Para encontrar os líderes de classe é preciso tomar todos os elementos u que

= κ. A Proposição 6 nos garante que são líderes de uma e somente

satisfaçam ω(u) ≤

uma classe.

(cid:21)

(cid:20)d − 1
2

Para executar o algoritmo de decodiﬁcação que apresentaremos a seguir, primeiro é
necessário montar uma tabela em que colocaremos todos os elementos u ∈ Kn tais que ω(u) ≤ κ
acompanhados de suas respectivas síndromes, Hut, feito isso, podemos seguir os passos.

1. Calcular a síndrome s da palavra recebida r, ou seja st = Hrt.

2. Comparar s com as síndromes da tabela.

3. Se s estiver na tabela, tomar (cid:96), o elemento líder da classe determinada por s, e substituir r

por r − (cid:96).

4. Se s não estiver na tabela, então na palavra recebida estão presentes mais do que κ erros.

Sejam r, c e e, respectivamente, a palavra recebida, a palavra transmitida e o vetor erro, como
Hrt = Het, o algoritmo acima é válido, pois a síndrome de r determina a classe lateral em que e
se encontra e, se ω(e) ≤ κ, a Proposição 6 nos garante que e é o único elemento (cid:96) líder de sua
classe e está presente na tabela, bastando calcular c = r − e = r − (cid:96).

Exemplo 15. Seja um código linear C ⊂ Z6
paridade H dada por

2, com distância mínima d = 3, matriz teste de



H =




1 1 0 1 0 0
1 0 1 0 1 0
0 1 1 0 0 1




 .

e capacidade de correção κ =

(cid:21)

(cid:20)3 − 1
2

= 1. Vamos tomar todos os possíveis vetores cujo peso é

menor ou igual a 1 e calcular suas respectivas síndromes.

Líder

Síndrome

000000
100000
010000
001000
000100
000010
000001

000
110
101
011
100
010
001

Suponha que tenham sido recebidas as palavras r = (001011), r′ = (111101) e r′′ =

(011001), vamos analisar o que acontece em cada caso.

42

Capítulo 4. Códigos lineares

∙ Para a palavra recebida r = (001011), calculamos sua síndrome Hrt = (000)t, logo r

pertence ao código e aceitamos r como sendo a palavra transmitida.

∙ Para a palavra recebida r′ = (111101), calculamos sua síndrome Hr′t = (101)t, logo

e = (010000) e a palavra transmitida é r′ − e = (111101) − (010000) = (101101).

∙ Para a palavra recebida r′′ = (011001), calculamos sua síndrome Hr′′t = (111)t que não

aparece na tabela, logo, em r, foram cometidos mais do que κ erros.

Exemplo 16. Seja um código linear C ⊂ Z9
paridade H dada por

2, com distância mínima d = 6, matriz teste de

H =
















1 0 1 0 0 0 0 0 0
1 1 0 1 0 0 0 0 0
0 1 0 0 1 0 0 0 0
1 0 0 0 0 1 0 0 0
1 1 0 0 0 0 1 0 0
0 1 0 0 0 0 0 1 0
1 1 0 0 0 0 0 0 1
















.

e capacidade de correção κ =

(cid:21)

(cid:20)6 − 1
2

= 2. Vamos tomar todos os possíveis vetores cujo peso é

menor ou igual a 2 e calcular suas respectivas síndromes.

4.1. Decodiﬁcação

43

Líder

Síndrome

Líder

Síndrome

000000000
000000001
000000010
000000100
000001000
000010000
000100000
001000000
010000000
100000000
100000001
100000010
100000100
100001000
100010000
100100000
101000000
110000000
010000001
010000010
010000100
010001000
010010000

0000000
0000001
0000010
0000100
0001000
0010000
0100000
1000000
0110111
1101101
1101100
1101111
1101001
1100101
1111101
1001101
0101101
1011010
0110110
0110101
0110011
0111111
0100111

010100000
011000000
001000001
001000010
001000100
001001000
001010000
001100000
000100001
000100010
000100100
000101000
000110000
000010001
000010010
000010100
000011000
000001001
000001010
000001100
000000101
000000110
000000011

0010111
1110111
1000001
1000010
1000100
1001000
1010000
1100000
0100001
0100010
0100100
0101000
0110000
0010001
0010010
0010100
0011000
0001001
0001010
0001100
0000101
0000110
0000011

Suponha que tenham sido recebidas as palavras r = (111011010), r′ = (011110101) e

r′′ = (110000111), vamos analisar o que acontece em cada caso.

∙ Para a palavra recebida r = (111011010), calculamos sua síndrome Hrt = (0000000)t,

logo r pertence ao código e aceitamos r como sendo a palavra transmitida.

∙ Para a palavra recebida r′ = (011110101), calculamos sua síndrome Hr′t = (1000010)t,
logo e = (001000010) e a palavra transmitida é r′ − e = (011110101) − (001000010) =
(010110111).

∙ Para a palavra recebida r′′ = (110000111), calculamos sua síndrome Hr′′t = (1011101)t

que não aparece na tabela, logo, em r, foram cometidos mais do que κ erros.

45

CAPÍTULO

5

PROPOSTA DO TEMA

O público-alvo desta proposta são alunos da Educação Básica, mais especiﬁcamente,
alunos do oitavo ano do Ensino Fundamental1. O tempo de aplicação é de quatro a cinco aulas
com duração de cinquenta minutos cada.

Os pré-requisitos para os estudantes são conhecimentos do sistema decimal posicional e

domínio das quatro operações.

A proposta se divide em cinco etapas e utilizará recursos presentes no cotidiano dos

alunos, tais como CPF e código de barras.

5.1 Primeira etapa: Dígitos verificadores de erros no CPF

O professor deve solicitar aos alunos que levem anotado o número do CPF de duas

pessoas diferentes.

Em um primeiro momento, o professor explicará aos alunos como é formado o número do
CPF, especialmente o dígito que representa a unidade da Federação em que o CPF foi cadastrado
e o processo de cálculo dos dígitos veriﬁcadores.

Cada aluno deverá aplicar o algoritmo do cálculo dos dígitos veriﬁcadores para os dois

números de CPF que anotou, e veriﬁcar se eles estão corretos.

Feita a primeira etapa, cada aluno escreverá em um papel os números de CPF que levou,

mas, omitirá os dígitos veriﬁcadores.

Os números de CPF serão trocados entre os alunos, o objetivo agora é que cada um
calcule os dígitos veriﬁcadores dos CPFs que receberam para, em seguida, conferir com os
números originais, se aplicaram o algoritmo corretamente, caso haja erros, o professor auxiliará
cada aluno a identiﬁcar o erro cometido.

1 A proposta também pode ser adaptada para aplicação no Ensino Médio.

46

Capítulo 5. Proposta do tema

5.2 Segunda etapa: Dígito verificador de erro no código

de barras

O professor deve solicitar que os alunos levem três embalagens diferentes que possuam
código de barras, se for possível, dentre essas três embalagens, duas devem ser da mesma marca,
mas de produtos diferentes.

A atividade se inicia com o professor explicando aos alunos as informações contidas nos
códigos de barras, indicando os algarismos referentes ao país de origem, a empresa que produziu
o produto, o código do produto e o dígito veriﬁcador, para esse último, o professor mostrará qual
o processo que deve ser aplicado para calcular o dígito veriﬁcador.

Cada aluno deverá observar o país de origem de cada produto, bem como reparar que

produtos de mesma marca possuem parte dos códigos iguais.

Os alunos deverão escolher duas embalagens e aplicar o algoritmo para conﬁrmar se o

dígito veriﬁcador está correto.

Para ﬁnalizar essa etapa, o professor passará na lousa um número de código de barras
com o dígito veriﬁcador omitido. Os alunos deverão identiﬁcar o país de origem do produto e
calcular qual o dígito veriﬁcador que corresponde ao código.

5.3 Terceira etapa: Linguagem de computadores

O professor explicará aos alunos o conceito de números binários, a quantidade de
algarismos utilizados, a relação entre a posição do algarismo e a potência de base 2 a que o
algarismo deve ser multiplicado.

O próximo passo será construir com os alunos os quinze primeiros números do sistema

binário, fazendo comparativos com o sistema decimal.

Na sequência, os alunos aprenderão sobre a operação de adição no sistema binário. Para
facilitar esse aprendizado, o professor fará um comparativo com a adição no sistema decimal e
usará os quinze primeiros números que foram construídos no passo anterior.

Para ﬁnalizar essa etapa, será apresentado aos alunos os códigos binários2 corresponden-
tes às letras do alfabeto e, para que possam visualizar como são as informações que o computador
trabalha, cada aluno deverá escrever seu nome em linguagem computacional.

5.4 Quarta etapa: Noção de códigos corretores

Essa atividade será realizada com o auxílio do editor de textos Word.

2

Esta tabela está presente no Anexo B

5.5. Quinta etapa: Códigos corretores

47

O professor explicará o conceito de distância de Hamming entre palavras e mostrará

alguns exemplos simples.

O próximo passo será digitar no editor de textos a palavra “paralelepíprdo”, o editor

acusará erro e mostrará como sugestão a palavra “paralelepípedo”.

Neste momento o professor questionará os alunos por que o editor não apresentou outra

palavra como sugestão e fará a relação com a distância entre as palavras.

A próxima palavra a ser digitada será “ventilsdur” e o editor mostrará como sugestão a
palavra “ventilador”, os alunos deverão analisar a distância entre as duas palavras e reﬂetir por
que a sugestão de correção foi única.

A última palavra a ser digitada será “hato”, o editor acusará erro, porém haverá mais
de uma sugestão de correção, os alunos deverão reﬂetir por que isso ocorre e relacionar com a
distância entre as palavras.

Para ﬁnalizar, os alunos deverão comparar as palavras digitadas e reﬂetir, com a mediação
do professor, por que as duas primeiras palavras possuíam apenas uma sugestão, enquanto a
última possuía várias? O computador poderia corrigir automaticamente todas as palavras? Se
alguém enviasse a palavra “rato” e o destinatário recebesse a palavra “gato”, como identiﬁcaria o
erro?

5.5 Quinta etapa: Códigos corretores

A teoria de Códigos Corretores de erro é uma ferramenta matemática desenvolvida para

detectar e corrigir erros.

Utilizando o que foi apresentado nas etapas anteriores, o professor construirá com os
alunos uma palavra em Z2 com três dígitos de informação e mais três dígitos de checagem, esta
palavra será da forma: (x1; x2; x3; x1 + x2; x1 + x3; x2 + x3).

Com uma breve explicação do professor sobre as somas utilizadas na construção dos
dígitos de checagem (xn + xk = 0 se a soma for par e xn + xk = 1 se a soma for ímpar, com
1 ≤ n ≤ 3, 1 ≤ k ≤ 3 e n ̸= k), os alunos deverão codiﬁcar todas as oito palavras possíveis do
código.

Com as palavras em mãos, o professor questionará: “se fosse recebida a palavra ‘101101’,
ela pertence ao código?” os alunos deverão responder que sim e concluir que a palavra recebida
não contém erro.

Continuando com as veriﬁcações, o professor apresentará a palavra “011100 e os alunos
deverão veriﬁcar que ela não pertence ao código, logo há erro na palavra transmitida, para
corrigi-la, eles precisarão encontrar qual a palavra do código que possui a menor distância com
a palavra recebida (desde que essa distância seja única), após os cálculos das distâncias, será

48

Capítulo 5. Proposta do tema

concluído que a palavra pode ser corrigida por “011110”.

A próxima palavra a ser apresentada será “111111”, que os alunos facilmente identiﬁca-
rão que a palavra contém erro, pois não pertence ao código, porém, nesse caso, ao calcularem
as distâncias com as palavras do código, eles verão que não é possível corrigi-la, pois a menor
distância com as palavras do código não é única.

Para ﬁnalizar a atividade, o professor explicará que o conteúdo trabalhado nessas ativida-
des é o que acontece, claro que de forma mais avançada, quando enviamos um e-mail, ligamos
para alguém que está em outro país, recebemos uma imagem pela televisão, entre outros.

5.6 Percepções pessoais

A proposta foi aplicada no 8oA da Escola Municipal de Ensino Fundamental Professora
Eponina de Britto Rossetto e as percepções do professor que aplicou são apresentadas a seguir.

Na primeira etapa, os alunos se mostraram interessados ao descobrir que o nono dígito de
CPF representa a Unidade da Federação em que foi realizado o cadastro, eles ﬁzeram, inclusive,
comparações com os números levados e o estado de origem dos respectivos donos.

Outro fato que chamou a atenção dos estudantes foi descobrir que os dois últimos dígitos
são obtidos por meio de operações matemáticas básicas envolvendo os algarismos anteriores,
operações estas que, apesar de elementares, possuem uma grande utilidade no cotidiano que a
grande maioria não sabia que existia.

Um fator fundamental para o bom desenvolvimento dessa etapa foi que os alunos puderam
comprovar, com número de CPF próprio ou de parentes, que os dígitos veriﬁcadores realmente
apresentam a relaçao ensinada.

Na segunda etapa, semelhante à primeira, os alunos se mostraram curiosos com o
signiﬁcado de cada grupo de dígitos do código de barras, ﬁzeram comparações de códigos de
produtos de mesma marca e produtos de marcas diferentes, perceberam que todos os códigos por
eles levados se iniciam com o número “789”, indicando que o produto é fabricado no Brasil.

Tanto na primeira etapa, quanto na segunda, o professor deu dicas e estimulou que os alu-
nos desenvolvessem a soma utilizando cálculo mental, em primeiro momento, eles apresentaram
diﬁculdade nesse desenvolvimento, entretanto, com o passar do tempo, os estudantes passaram a
dominar melhor o cálculo mental e a utilizá-lo com maior propriedade.

A terceira etapa se mostrou a mais trabalhosa de todo processo, alguns alunos entenderam
muito rápido e conseguiram escrever mais do que os números solicitados, entretanto, outros
apresentaram maior diﬁculdade em entender a correspondência existente entre números binários
e decimais, necessitando de uma intervenção maior do professor.

Após escreverem os 15 primeiros números em base binária, o professor forneceu uma

5.6. Percepções pessoais

49

folha que apresenta os códigos binários de todas as letras do alfabeto português, diferenciando
maiúsculas e minúsculas, e solicitou que eles escrevessem o primeiro nome utilizando os códigos
binários, essa parte foi realizada de forma autônoma e bem ágil.

Na quarta etapa os alunos conseguiram entender rapidamente o conceito de distância
entre palavras e apresentaram conclusões sobre as palavras sugeridas pelo corretor ortográﬁco,
associando-as com as distâncias entre elas.

Na quinta etapa os alunos apresentaram um pouco de diﬁculdade para entender o signi-
ﬁcado dos dígitos de redundância, mas não apresentaram diﬁculdade para construir o código
proposto pelo professor e para calcular as distâncias das palavras apresentadas.

Com a mediação do professor, os estudantes puderam concluir que quando uma palavra
é a única do código que possui a menor distância com a palavra recebida, então é possível
corrigir o erro, mas quando é mais de uma palavra que possui a menor distância com a palavra
apresentada, então o erro não pode ser corrigido.

51

REFERÊNCIAS

– Atualidades,

I. Controle
p.

FINI, M.
sor
5199819-Controle-dos-codigos-de-identiﬁcacao.html>. Acesso em: 29 out. 2015.
tado 3 vezes nas páginas 19, 23 e 25.

Profes-
em: <http://docplayer.com.br/
Ci-

de
2009. Disponível

identiﬁcação. Revista

dos
70–75,

códigos

do

HEFEZ, A.; VILLELA, M. L. T. Códigos corretores de erros. Rio de Janeiro: Instituto de
Matematica Pura e Aplicada, 2002. Citado 3 vezes nas páginas 19, 59 e 61.

ISBN, A. B. do. International Standard Book Number. [S.l.], 2015. Disponível em: <http:
//www.isbn.bn.br/website/o-que-e-isbn>. Acesso em: 29 out. 2015. Citado na página 26.

MILIES, C. P. Breve introdução à teoria dos códigos corretores de erros. Colóquio de Mate-
mática da Região Centro-Oeste, 2009. Disponível em: <http://http://www.sbm.org.br/docs/
coloquios/CO-1-09.pdf>. Acesso em: 29 out. 2015. Citado na página 19.

RFB, R. F. do B. Cadastro de Pessoa Física. [S.l.], 2015. Disponível em: <http://www.receita.
fazenda.gov.br/PessoaFisica/cpf/PerguntasRespostas/PerguntasRespostas.htm#1>. Acesso em: 1
nov. 2015. Citado na página 22.

53

APÊNDICE

A

EXERCÍCIOS SUGERIDOS

A seguir, apresentamos alguns exercícios que podem ser utilizados pelo professor em

sala de aula

A.1 Capítulo 2

Exercício 1. Em cada item abaixo, descubra qual a Unidade da Federação foi realizado o
cadastro do CPF, bem como os dois dígitos veriﬁcadores correspondentes:

a) 785.963.196-XY
b) 282.934.448-XY

c) 179.236.740-XY
d) 876.977.448-XY

Exercício 2. Com relação aos códigos de barras abaixo, descubra o país de origem do produto,
bem como o dígito veriﬁcador correspondente:

a) 528734232957X
b) 619445623112X

c) 750776823109X
d) 789654819895X

Exercício 3. Em cada código ISBN abaixo, descubra se o dígito veriﬁcador está correto, caso
não esteja, escreva qual deveria ser de modo a tornar o código válido:

a) 978-85-244-0312-5
b) 978-85-85818-08-7

c) 978-85-7542-643-8
d) 978-85-7600-352-6

A.2 Capítulo 3

Exercício 4. Dado o alfabeto A = {0, 1}, escreva todas as palavras de comprimento n = 4.

Exercício 5. Calcule a distância de Hamming, nos inteiros, das palavras:

a) (110011) e (011001).

54

APÊNDICE A. Exercícios sugeridos

b) (2352) e (2253).

c) (22110) e (12000).

d) (11101) e (10101).

Exercício 6. Dado o alfabeto A = {0, 1, 2, 3, 4, 5}, calcule a quantidade de elementos que per-
tencem:

a) Ao disco de centro (21113) e raio r = 4.

b) Ao disco de centro (0000) e raio r = 3.

c) Á esfera de raio (1225) e raio r = 2.

d) Á esfera de raio (443522) e raio r = 4.

Exercício 7. Seja C um código com distância mínima d = 13, qual a quantidade máxima de
erros que podem ser detectados? Qual a quantidade máxima que pode ser corrigida?

Exercício 8. Calcule κ para códigos com distância mínima apresentada abaixo

a) d = 4.

b) d = 1.

c) d = 2.

d) d = 6.

A.3 Capítulo 4

Exercício 9. Calcule o peso das seguintes palavras:

a) (01111001).
b) (11001100011).
c) (11111111).
d) (0110000101).

e) (0000000).
f) (11010100011).
g) (100010000).
h) (110011001111).

Exercício 10. Seja um código linear C ⊂ Z6

2, com matriz geradora






G =

1 0 0 0 1 1
0 1 0 1 0 1
0 0 1 1 1 0




 .

Codiﬁque todas as palavras de comprimento n = 3.

Exercício 11. Seja um código linear C ⊂ Z6

2, com matriz teste de paridade







H =

0 1 1 1 0 0
1 0 1 0 1 0
1 1 0 0 0 1


 .

A.4. Soluções

55

Calcule a síndrome das palavras abaixo e diga se elas pertencem ou não ao código C.

a) (111111).
b) (101101).
c) (001101).
d) (101011).

e) (110010).
f) (111000).
g) (110110).
h) (010110).

Exercício 12. Seja um código linear C ⊂ Z5

2, com matriz teste de paridade






H =

1 0 1 0 0
0 1 0 1 0
1 1 0 0 1




 .

e distância mínima d = 3. Corrija, se possível, as seguintes palavras recebidas:

a) 11111.
b) 01000.
c) 10101.
d) 11010.
e) 11101.

f) 11011.
g) 01111.
h) 10001.
i) 10000.
j) 00001.

Exercício 13. Seja um código linear C ⊂ Z8

2, com matriz teste de paridade

H =














0 1 1 0 0 0 0 0
1 0 0 1 0 0 0 0
1 1 0 0 1 0 0 0
1 1 0 0 0 1 0 0
1 0 0 0 0 0 1 0
0 1 0 0 0 0 0 1














.

e distância mínima d = 5. Corrija, se possível, as seguintes palavras recebidas:

a) 10011110.
b) 11110010.
c) 01100001.
d) 11111111.
e) 11101101.

f) 10101110.
g) 10011111.
h) 11111100.
i) 11110011.
j) 11111110.

A.4 Soluções

Exercício 1.

a) Minas Gerais, X = 2, Y = 0
b) São Paulo, X = 0, Y = 0

c) Rio Grande do Sul, X = 6, Y = 0
d) São Paulo, X = 0, Y = 5

Exercício 2.

a) Líbano, X = 9
b) Tunísia, X = 6

c) México, X = 5
d) Brasil, X = 7

56

APÊNDICE A. Exercícios sugeridos

Exercício 3.

a) Correto
b) 978-85-85818-08-1

c) 978-85-7542-643-2
d) Correto

Exercício 4. (0000), (0001), (0010), (0100), (1000), (0011), (0101), (0110), (1001), (1010),
(1100), (0111), (1101), (1011), (1110), (1111)

Exercício 5. a) d((110011), (011001)) = 3.

b) d((2352), (2253)) = 2.

c) d((22110), (12000)) = 3.

d) d((11101), (10101)) = 1.

Exercício 6. a) 4651.

b) 671.

c) 150.

d) 9375.

Exercício 7. Podem ser detectados no máximo 12 erros e corrigidos no máximo 6 erros.

Exercício 8. a) κ = 1.

b) κ = 0.

c) κ = 0.

d) κ = 2.

Exercício 9.

a) ω(01111001) = 5.
b) ω(11001100011) = 6.
c) ω(11111111) = 8.
d) ω(0110000101) = 4.

e) ω(0000000) = 0.
f) ω(11010100011) = 6.
g) ω(100010000) = 2.
h) ω(110011001111) = 8.

Exercício 10. (000000), (001110), (010101), (100011), (011011), (101101), (110110), (111000)

Exercício 11.

a) (111). Não pertence.
b) (000). Pertence.
c) (011). Não pertence.
d) (110). Não pertence.

e) (101). Não pertence.
f) (000). Pertence.
g) (000). Pertence.
h) (011). Não pertence.

Exercício 12.

a) 11110.
b) 00000.
c) 10101.
d) 11110.
e) 10101.

f) 01011.
g) 01011.
h) 10101.
i) 00000.
j) 00000.

A.4. Soluções

57

Exercício 13.

a) 10011110.
b) 11110011.
c) 01101101.
d) 11110011.
e) 01101101.

f) 10011110.
g) 10011110.
h) Não pode ser corrigido.
i) 11110011.
j) 10011110.

59

ANEXO

A

ANÉIS E CORPOS

Este anexo é baseado em (HEFEZ; VILLELA, 2002)

Deﬁnição 15. Um conjunto A é chamado de anel se ele é munido de duas operações,

e

+ : A × A → A

(a, b) ↦→ a + b

· : A × A → A

(a, b) ↦→ a · b

chamadas de adição e multiplicação, respectivamente, e além disso, devem satisfazer as seguintes
propriedades:

1. Associatividade da adição:

∀a, b, c ∈ A, (a + b) + c = a + (b + c).

2. Elemento neutro para a adição:

Existe um elemento chamado zero e denotado por 0, tal que

∀a ∈ A, a + 0 = 0 + a = a.

3. Elemento inverso para a adição:

Dado a ∈ A, existe um elemento chamado simétrico de a e denotado por −a, tal que

a + (−a) = (−a) + a = 0.

60

ANEXO A. Anéis e corpos

4. Comutatividade da adição:

∀a, b ∈ A, a + b = b + a.

5. Associatividade da multiplicação:

∀a, b, c ∈ A, (a · b) · c = a · (b · c).

6. Elemento neutro para a multiplicação:

Existe um elemento chamado unidade e denotador por 1, tal que

∀a ∈ A, a · 1 = 1 · a = a.

7. Distributividade da multiplicação em relação à adição:

∀a, b, c ∈ A, a · (b + c) = a · b + a · c.

Se vale a comutatividade da multiplicação, isto é,

∀a, b ∈ A, a · b = b · a,

o anel é dito comutativo.

Deﬁnição 16. Corpo é um anel em que todo elemento não nulo é invertível.

A.1 Classes residuais de inteiros

Chama-se classe residual de Z módulo m, a classe formada pelos restos das divisões dos

inteiros por m, ou seja

Zm = {[0], [1], ..., [m − 1]},

se i, j = 0, 1, ..., m − 1 e, se i ̸= j, então [i] ̸= [ j].

Dado a ∈ Z, pelo algoritmo da divisão euclidiana, existem inteiros q e r univocamente
determinados pelas condições a = mq + r com 0 ≤ r ≤ m − 1, o que implica haver um único
inteiro r com 0 ≤ r ≤ m − 1, tal que [a] = [r].

Logo Zm é um anel ﬁnito com exatamente m elementos.

Exemplo 17. Para m = 2, vamos montar as tabelas de adição e de multiplicação do anel
Z2 = {[0], [1]}:

+
[0]
[1]

·

[0]
[1]

[0]
[0]
[1]

[0]
[0]
[0]

[1]
[1]
[0]

[1]
[0]
[1]

A.1. Classes residuais de inteiros

61

Como [1] é o único elemento não nulo de Z2 e é invertível em relação à multiplicação, então Z2
é um corpo.

Exemplo 18. Para m = 5, vamos montar as tabelas de adição e de multiplicação do anel
Z5 = {[0], [1], [2], [3], [4]}:

+
[0]
[1]
[2]
[3]
[4]

·

[0]
[1]
[2]
[3]
[4]

[0]
[0]
[1]
[2]
[3]
[4]

[0]
[0]
[0]
[0]
[0]
[0]

[1]
[1]
[2]
[3]
[4]
[0]

[1]
[0]
[1]
[2]
[3]
[4]

[2]
[2]
[3]
[4]
[0]
[1]

[2]
[0]
[2]
[4]
[1]
[3]

[3]
[3]
[4]
[0]
[1]
[2]

[3]
[0]
[3]
[1]
[4]
[2]

[4]
[4]
[0]
[1]
[2]
[3]

[4]
[0]
[4]
[3]
[2]
[1]

Como [1], [2], [3] e [4] são invertíveis em relação à multiplicação, com inversos [1], [3], [2] e [4],
respectivamente, então Z5 é um corpo.

Proposição 7. [a] ∈ Zm é invertível se, e somente se, MDC(a, m) = 1.

Demonstração. Vamos supor que [a] seja invertível. Logo, existe [b] ∈ Z tal que [a] · [b] = 1. O
que implica [a · b] = [1] e, consequentemente, a · b ≡ 1 mod m, logo m|a · b − 1 que é o mesmo
que dizer que existe um inteiro s tal que

s · m + a · b = 1.

Por outro lado, MDC(a, m)|a e MDC(a, m)|m isso implica, pela equação acima, que MDC(a, m)|1.
Logo MDC(a, m) = 1.

Reciprocamente, se o MDC(a, m) = 1, então existem inteiros b e c tais que b·a+c·m = 1
(para mais detalhes, veja (HEFEZ; VILLELA, 2002)). Logo, b · a ≡ 1 mod m, o que implica
[a] · [b] = [a · b] = [1] e, por consequência, [a] é invertível.

Proposição 8. O anel Zm é um corpo se, e somente se, m é um número primo.

Demonstração. Zm será um corpo se, e somente se, todos os elementos [1], [2], ..., [m − 1] fo-
rem invertíveis, entretanto, pela Proposição 7, isso só ocorrerá se MDC(1, m) =MDC(2, m) =
... =MDC(m − 1, m) = 1, o que é equivalente a m ser um número primo.

63

ANEXO

B

TABELA ASCII

A seguir apresentamos a tabela ASCII que contém alguns códigos binários.

Figura 8 – Tabela ASCII

Fonte: http://goo.gl/g0OpzN Acesso em 5 fev. 2016

