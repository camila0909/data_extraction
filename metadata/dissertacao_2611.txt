UNIVERSIDADE FEDERAL DO CEARÁ

CENTRO DE CIÊNCIAS

PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA

MESTRADO PROFISSIONAL EM MATEMÁTICA - PROFMAT

RICARDO PEREIRA DE ANDRADE

TESTES DE PRIMALIDADE: UMA ANÁLISE MATEMÁTICA DOS ALGORITMOS

DETERMINÍSTICOS E PROBABILÍSTICOS

FORTALEZA

2017

RICARDO PEREIRA DE ANDRADE

TESTES DE PRIMALIDADE: UMA ANÁLISE MATEMÁTICA DOS ALGORITMOS

DETERMINÍSTICOS E PROBABILÍSTICOS

Dissertação apresentada ao Curso de Mestrado
Proﬁssional em Matemática - PROFMAT do
Programa de Pós-Graduação em Matemática
do Centro de Ciências da Universidade Federal
do Ceará, como requisito parcial à obtenção
do título de mestre em Matemática. Área de
Concentração: Matemática

Orientador: Prof. Dr. Marcelo Ferreira
de Melo

FORTALEZA

2017

Dados Internacionais de Catalogação na Publicação Universidade Federal do CearáBiblioteca UniversitáriaGerada automaticamente pelo módulo Catalog, mediante os dados fornecidos pelo(a) autor(a)A57tAndrade, Ricardo Pereira de.    Testes de primalidade : uma análise matemática dos algoritmos determinísticos eprobabilísticos / Ricardo Pereira de Andrade. – 2017.    51 f.      Dissertação (mestrado) – Universidade Federal do Ceará, Centro de Ciências,Departamento de Matemática, Programa de Pós-Graduação em Matemática em RedeNacional, Fortaleza, 2017.     Orientação: Prof. Dr. Marcelo Ferreira de Melo.    1. Algoritmo. 2. Teste de Primalidade. 3. Números Primos. I. Título.                                                                                                                                 CDD 510RICARDO PEREIRA DE ANDRADE

TESTES DE PRIMALIDADE: UMA ANÁLISE MATEMÁTICA DOS ALGORITMOS

DETERMINÍSTICOS E PROBABILÍSTICOS

Dissertação apresentada ao Curso de Mestrado
Proﬁssional em Matemática - PROFMAT do
Programa de Pós-Graduação em Matemática
do Centro de Ciências da Universidade Federal
do Ceará, como requisito parcial à obtenção
do título de mestre em Matemática. Área de
Concentração: Matemática

Aprovada em:

BANCA EXAMINADORA

Prof. Dr. Marcelo Ferreira de Melo (Orientador)
Universidade Federal do Ceará (UFC)

Prof. Dr. Antônio Caminha Muniz Neto
Universidade Federal do Ceará (UFC)

Prof. Dr. Ângelo Papa Neto
Instituto Federal de Educação, Ciência e Tecnologia
do Ceará (IFCE)

Aos meus pais José e Neves, ao meu irmão Ro-

naldo, a minha esposa Gislene, a minha cunhada

Gisleuda, a toda minha família e a Deus, por me

renovar a cada manhã.

AGRADECIMENTOS

A todos os meus familiares que me incentivaram e sempre acreditaram em minha

capacidade, em especial, a minha esposa Gislene.

Agradeço a todos os professores por me proporcionar o conhecimento não apenas

racional, mas a manifestação do caráter e afetividade da educação no processo de formação

proﬁssional, por tanto que se dedicaram a mim, não somente por terem me ensinado, mas por

terem me feito aprender.

Ao Prof. Dr. Marcelo Ferreira de Melo por me orientar neste trabalho.

Por ﬁm, todos que, direta ou indiretamente, contribuiram para a realização e conclu-

são deste sonho o meu muito obrigado.

“O problema de distinguir os números primos dos

números compostos e de exprimir estes últimos

à custa de fatores primos deve ser considerado

como um dos mais importantes e úteis em Arit-

mética.”

(K. F. Gauss)

RESUMO

Este trabalho apresenta os principais testes de primalidade através de um estudo sobre a base

matemática utilizada para garantir a validade de cada método, bem com uma analise da comple-

xidade computacional dos mesmos.

Palavras-chave: Algoritmo. Teste de Primalidade. Números Primos.

ABSTRACT

This work presents the main tests of primality through a study on the mathematical basis used to

guarantee the validity of each method, as well as an analysis of the computational complexity of

the same.

Keywords: Algorithm. Primality test. Prime numbers.

LISTA DE TABELAS

Tabela 4.3.1–Complexidade das etapas do AKS . . . . . . . . . . . . . . . . . . . . . .

Tabela 7.0.1–Tempo gasto por cada algoritmo no teste de primalidade . . . . . . . . . . .

35

50

LISTA DE ALGORITMOS

Algoritmo 3.1.1–Identiﬁca o menor valor em uma lista de n elementos . . . . . . . . . .

Algoritmo 3.2.1–Calcula o fatorial de um número n . . . . . . . . . . . . . . . . . . . .

Algoritmo 3.3.1–Determina o valor da potência modular ab (mod m)

. . . . . . . . . .

Algoritmo 3.3.2–Determina o máximo divisor comum de a e b . . . . . . . . . . . . . .

Algoritmo 4.1.1–Divisões Sucessivas . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Algoritmo 4.2.1–Teorema de Wilson . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Algoritmo 4.3.1–Veriﬁca se um número n é uma potência própria . . . . . . . . . . . . .
Algoritmo 4.3.2–Encontra o menor r tal que ordr(n) > log2

2 n . . . . . . . . . . . . . . .
Algoritmo 4.3.3–Calcula o mdc(a, n) para a ≤ r . . . . . . . . . . . . . . . . . . . . . .

Algoritmo 4.3.4–Veriﬁca a congruência (x + a)n ≡ (xn + a) (mod (xr − 1, n)) . . . . . .

Algoritmo 4.4.1–Lucas-Lehmer .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Algoritmo 5.1.1–Solovay-Strassen . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Algoritmo 5.1.2–Calcula o Símbolo de Jacobi

. . . . . . . . . . . . . . . . . . . . . . .

Algoritmo 5.2.1–Miller-Rabin .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

23

25

27

27

30

33

35

36

36

37

39

42

42

46

1

2

2.1

2.2

2.3

2.4

3

3.1

3.2

3.3

4

4.1

4.2

4.3

4.4

5

5.1

5.2

6

6.1

7

SUMÁRIO

INTRODUÇÃO .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

PRELIMINARES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Números Primos

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Aritmética Modular . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Teoremas de Fermat e Euler . . . . . . . . . . . . . . . . . . . . . . . . .

Resíduos Quadráticos

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

ANÁLISE DE ALGORITMOS . . . . . . . . . . . . . . . . . . . . . . .

Função de Complexidade

. . . . . . . . . . . . . . . . . . . . . . . . . .

Notação Assintótica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Operações Matemáticas . . . . . . . . . . . . . . . . . . . . . . . . . . .

TESTES DETERMINÍSTICOS . . . . . . . . . . . . . . . . . . . . . . .

Divisões Sucessivas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Teorema de Wilson . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

AKS .

.

.

.

.

.

Lucas-Lehmer

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

TESTES PROBABILÍSTICOS . . . . . . . . . . . . . . . . . . . . . . .

Solovay-Strassen .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Miller-Rabin .

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

CERTIFICADO DE PRIMALIDADE . . . . . . . . . . . . . . . . . . .

Teste de Lucas .

.

CONCLUSÃO .

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

REFERÊNCIAS .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12

14

14

15

17

20

23

23

24

26

29

29

32

33

38

41

41

44

48

48

50

52

12

1 INTRODUÇÃO

Os números primos desempenham um papel fundamental na Matemática, pois todo

número natural maior que 1 ou é primo ou é formado pelo produto de fatores primos (chamado

composto).

Por isso, descobrir um método eﬁcaz para veriﬁcação da primalidade de um número

é um problema que tem captado o interesse de matemáticos desde a antiguidade. O Crivo de

Eratóstenes é o algoritmo mais antigo que se tem conhecimento; no entanto, sua complexidade

de tempo o torna inviável para encontrar primos grandes (COUTINHO, 2004).

Nos últimos anos, com o advento de sistemas de criptograﬁa, que são baseados

na diﬁculdade da fatoração de números grandes, a necessidade de identiﬁcar números primos

ganhou importância prática.

O sistema RSA, nome formado pelas iniciais de seus três idealizadores, Rivest,

Shamir e Adleman, é um algoritmo que utiliza essa diﬁculdade de fatoração e o fato de que todo

número natural pode ser escrito com o produto de fatores primos de forma única, a menos da

ordem, para criar uma chave pública, que é formada pelo produto de dois números primos. Dessa

forma, diﬁcilmente a criptograﬁa será revertida sem a chave privada, ou seja, os números primos

usados na multiplicação.

Atualmente, existem diversos algoritmos que permitem determinar se um dado

número é primo ou composto, os quais estão divididos em duas categorias: determinísticos – que

retornam a primalidade com total conﬁabilidade – e probabilísticos – que estão corretos quando

veriﬁcam que um número é composto, mas podem errar ao aﬁrmar que um número é primo,

sendo neste caso, possivelmente primos.

Em aplicações criptográﬁcas, são utilizados testes de primalidade probabilísticos ou

randomizados, uma vez que estes apresentam um desempenho superior aos testes determinísticos

e têm um percentual de erro irrelevante para situações práticas, pois a tarefa de identiﬁcação dos

fatores do produto resultante de números provavelmente primos continua sendo extremamente

trabalhosa.

Sem a pretensão de ser uma revisão bibliográﬁca exaustiva concernindo a testes de

primalidade, este trabalho se pautará no estudo dos principais algoritmos – determinísticos e

probabilísticos - através de uma análise da eﬁciência e dos conceitos matemáticos utilizados para

a validação da solução.

Sendo assim, iniciamos esta pesquisa apresentando, no capítulo 2, conceitos e

13

teoremas sobre números inteiros, os quais serão imprescindíveis para a compreensão dos capítulos

posteriores. Para que possamos fazer a análise dos algoritmos mostrados, faz-se necessário

entender como é determinada a complexidade de execução dos mesmos, assunto que trataremos

no terceiro capítulo. No capítulo 4, abordaremos dos testes de primalidade determinísticos,

desde métodos simples como o crivo de Eratóstenes e divisões sucessivas, a soluções mais

soﬁsticadas tais como os testes AKS e de Lucas-Lehmer. Os algoritmos probabilísticos serão

analisados no capítulo 5, dentre os quais os de Solovay-Strassen e Miller-Rabin (o mais utilizado

atualmente). No capítulo seguinte, mostraremos o Teorema de Lucas, que funciona como uma

espécie de “certiﬁcado de primalidade”, pois se conseguirmos fazer o número passar pelo teste

podemos aﬁrmar que o mesmo é primo. Por ﬁm, concluímos fazendo um estudo comparativo da

complexidade de execução dos diversos algoritmos apresentados.

14

2 PRELIMINARES

Neste capítulo, apresentaremos os conceitos, propriedades e resultados sobre núme-

ros inteiros que serão necessários no decorrer do texto.

2.1 Números Primos

Deﬁnição 2.1.1. Sejam a e b números inteiros. Dizemos que a divide b, ou que a é um divisor

de b ou, ainda b é um múltiplo de a e denotado por a | b, se e somente se existe um inteiro c tal

que b = ac. Quando a não divide b representamos por a (cid:45) b.

Notamos que c é único quando a (cid:54)= 0, pois se existisse d satisfazendo b = ad,

teríamos: 0 = ac − ad = a(c − d) ⇒ c − d = 0 ⇒ c = d.

Deﬁnição 2.1.2. Sejam a e b números inteiros não simultaneamente nulos. Um natural d chama-

se máximo divisor comum de a e b, denotado por mdc(a, b) ou (a, b) se possuir as seguintes

propriedades:

(i) d é divisor comum de a e de b, e

(ii) d é um múltiplo de todo divisor comum de a e b.

Deﬁnição 2.1.3. Um inteiro positivo p > 1 é um número primo, se e somente se, possui apenas

dois divisores: 1 e p. Quando não é primo, p diz-se composto.

Deﬁnição 2.1.4. Sejam a e b números inteiros não nulos. Se (a, b) = 1, dizemos que a e b são

primos entre si.

Teorema 2.1.1 (Teorema Fundamental da Aritmética). Seja n ≥ 2 um número natural. Podemos

escrever n de uma única forma como um produto n = p1.p2...pr onde r ≥ 1 é um natural e

p1 ≤ p2 ≤ ... ≤ pr são primos.

Prova: Mostramos a existência da fatoração de n em primos por indução. Se n é primos
escrevemos r = 1 e p1 = n. Sendo n composto podemos escrever n = ab com a, b ∈ N e

1 < a, b < n. Por hipótese de indução, a e b se decompõem como o produto de primos. Juntando

as fatorações de a e b (e reordenando os fatores) obtemos uma fatoração de n. Para provar a

unicidade, vamos supor por absurdo que n possui duas fatorações diferentes n = p1.p2...pr =

q1.q2...qs, com p1 ≤ p2 ≤ ... ≤ pr e q1 ≤ q2 ≤ ... ≤ qs. Como p1 | q1.q2...qs, temos que p1 | qi

para algum valor de i tal que 1 ≤ i ≤ s. Logo, como qi é primo, então p1 = qi. Da mesma forma,

15

q1 = p j para algum j tal que 1 ≤ j ≤ r. Mas, como p1 = qi ≥ q1 = p j ≥ p1, então p1 = q1.
Assim, n
p1

= p2...pr = q2...qs e a hipótese de indução garante que pi = qi para todo i, o que

contradiz o fato de n ter duas fatorações.

Teorema 2.1.2 (Euclides). Existem inﬁnitos números primos.

Prova: Suponhamos, por absurdo, que p1, p2, ..., pm fossem todos os primos existentes. Assim,

o número p1.p2...pm + 1 não seria divisível por nenhum primo pi, contrariando o Teorema

2.1.1.

Proposição 2.1.3. Sejam a e n números naturais maiores do que 1. Se an − 1 é primo, então

a = 2 e n é primo.

Prova: Se a > 2, então a − 1 > 1 e (a − 1) | (an − 1), portanto, an − 1 não é primo. Consequen-

temente, an − 1 primo implica a = 2. Por outro lado, suponha, que n não é primo, digamos,

n = rs com r > 1 e s > 1. Como (2r − 1) | ((2r)s − 1) = 2n − 1, segue que 2n − 1 não é primo.

Logo, an − 1 primo implica n é primo.

Os números da forma Mp = 2p − 1 são denominados números de Mersenne; quando
são primos, os chamamos de primos de Mersenne. Portanto, não necessariamente, Mp = 2p − 1
é primo sempre que p for primo; por exemplo, 211 − 1 = 2047 = 23 × 89.

2.2 Aritmética Modular

Deﬁnição 2.2.1. Sejam a, b e m números inteiros, m > 1. Então, se diz que a é congruente a b

módulo m, e escreve-se a ≡ b (mod m), se, e somente se, m | a − b.

Deﬁnição 2.2.2. Denotaremos a classe de equivalência de a módulo m por ¯a = {r ∈ Z |
r ≡ a (mod m)} e o conjunto das classes de equivalência módulo m por Zm. Assim, Zm =
{¯0, ¯1, ...,

¯m − 1}.

Deﬁnição 2.2.3. Um conjunto S = {n0, n1, ..., nm−1} ⊂ Z é um sistema completo de resíduos

(SCR) módulo m se, e somente se,

(i) para i (cid:54)= j temos ni (cid:54)≡ n j (mod m),
(ii) dado a ∈ Z existe n ∈ S tal que a ≡ n (mod m).

Deﬁnição 2.2.4. Seja S um sistema completo de resíduos módulo m. O subconjunto S(cid:48) = {a |

a ∈ S e (a, m) = 1} de S chama-se um sistema reduzido de resíduos (SRR) módulo m.

Teorema 2.2.1 (Teorema Chinês dos Restos). Sejam n1, n2, n3, ..., nk números inteiros tais que

(ni, n j) = 1, para i (cid:54)= j. O sistema de congruências

16

x ≡ a1 (mod n1)

x ≡ a2 (mod n2)

x ≡ a3 (mod n3)

...

x ≡ ak (mod nk)

admite uma solução simultânea, que é única módulo o inteiro n = n1n2n3...nk.

Prova: Seja n = n1n2n3...nk. Para cada r = 1, 2, 3, ..., k, seja Nr = n
nr

= n1n2...nr−1nr+1...nk, ou

seja, Nr é o produto de todos os ni, exceto o nr. Como (ni, n j) = 1, a congruência Nrx ≡ 1

(mod nr) admite uma única solução, que chamaremos de xr, pois (Nr, nr) = 1, e divide 1. A

solução do sistema será:

¯x = a1N1x1 + a2N2x2 + a3N3x3 + ... + akNkxk

De fato, basta observar que:

(a) Ni ≡ 0 (mod nr), para i (cid:54)= r, pois nr divide Ni;

(b) ¯x = a1N1x1 + a2N2x2 + a3N3x3 + ... + akNkxk ≡ arNrxr (mod nr);

(c) Como escolhemos xr, satisfazendo Nrx ≡ 1 (mod nr), temos necessariamente, ¯x ≡ ar.1 ≡ ar

(mod nr).

Resta-nos mostrar que a solução é única módulo n = n1n2n3...nk. Suponhamos que exista uma

outra solução y, isto é, ¯x ≡ a (mod nr) ≡ y, para r = 1, 2, 3, ..., k. Assim, nr divide ¯x − y, para

cada valor de r. Como (ni, n j) = 1, temos que n = n1n2n3...nk divide ¯x − y. Portanto, ¯x ≡ y

(mod n).

Proposição 2.2.2. Se A é um subconjunto dos inteiros fechado para adição e subtração, então

A é igual a dZ, o conjunto dos múltiplos de d, para algum inteiro d.

Prova: Se A = {0} então d = 0 e está provado. Caso contrário, seja d o valor absoluto do menor

elemento não nulo de A. O conjunto A contém todos os múltiplos de d, uma vez que contém

{±d} e é fechado para adição e subtração. Além disso, A não pode conter nenhum elemento x

que não seja divisível por d, pois poderiamos subtrair o múltiplo mais próximo de d para obter

um elemento diferente de zero com valor absoluto menor que d.

17

Lema 2.2.1. Sejam a e b números inteiros, então o conjunto aZ + bZ = {ax + by | x, y ∈ Z} é
igual a dZ onde d = (a, b).

Prova: O conjunto aZ + bZ é fechado para adição e subtração, então aZ + bZ = cZ para algum
inteiro c. Se d = (a, b) então todo elemento de aZ + bZ é divisível por d, logo, d | c. Por outro
lado, a e b são elementos de cZ, ou seja, são divisíveis por c. Isso signiﬁca que c é um divisor

comum de a e b, donde c | d. Portanto, c = d.

Lema 2.2.2. Se (a, n) = 1 então existe um inteiro a−1 tal que a.a−1 ≡ 1 (mod n).

Prova: Pelo Lema 2.2.1, o conjunto aZ + nZ é igual a Z, o conjunto dos números inteiros. Em

particular, isso signiﬁca que existem inteiros x e y tal que ax + ny = 1. Assim, a.x ≡ 1 (mod n),

como desejado.

Lema 2.2.3. Sejam b, c e n inteiros positivos tal que (c, n) = 1 e a congruência xb ≡ c (mod n)

tem k > 0 soluções, então a congruência xb ≡ 1 (mod n) também tem k soluções.

Prova: Seja x0 uma solução de xb ≡ c (mod n). Devemos ter (x0, n) = 1, uma vez que (x0

b, n) =

(c, n) podendo ser maior que 1, contrariando nossa hipótese. De acordo com o Lema 2.2.2 existe

um número x0
solução de xb ≡ c (mod n) e xb ≡ 1 (mod n) é dada pelo mapeamento y (cid:55)→ y.x0

−1 ≡ 1 (mod n). Assim, uma correspondência entre o conjunto

−1 tal que x0.x0

−1.

2.3 Teoremas de Fermat e Euler

Lema 2.3.1. Seja p um número primo, então os números (cid:0)p
k

(cid:1), onde 0 < k < p, são todos divisíveis

por p.

Prova: Para k = 1, temos (cid:0)p
1

(cid:1) = p. Podemos, então, supor 1 < k < p, assim, k! | p(p − 1)...(p −

k + 1). Como (k!, p) = 1, decorre que k! | (p − 1)...(p − k + 1), e o resultado se segue, pois
(cid:0)p
k

(cid:1) = p (p−1)...(p−k+1)

.

k!

Teorema 2.3.1 (Pequeno Teorema de Fermat). Dado um número primo p, tem-se que p divide o
número ap − a, para todo a ∈ N.

Prova: Vamos provar por indução sobre a. O resultado vale para a = 1, pois p | 1p − 1 = 0.

Supondo que é válido para a, iremos prová-lo para a + 1. Usando o binômio de Newton, temos:
(cid:1)a. Pelo Lema 2.3.1 e a hipótese de indução o
(a + 1)p − (a + 1) = ap − a + (cid:0)p
1

(cid:1)ap−1 + ... + (cid:0) p
p−1

segundo membro da igualdade acima é divisível por p. Portanto, demonstra-se o resultado.

18

Reescrevendo esse teorema obtemos um método para mostrar que um dado número

n não é primo.

Teorema 2.3.2. Seja n um inteiro positivo. Se existe a inteiro tal que n não divide an − a então

n não é primo. O número a é dito testemunha da não primalidade de n (testemunha de Fermat).

Exemplo 2.3.1. O número n = 10 não é primo, pois 210 = 1024 (cid:54)≡ 2 (mod 10).

Corolário 2.3.1. Se p é um número primo e se a é um número inteiro não divisível por p, então

p divide ap−1 − 1.

Prova: Usando o Teorema 2.3.1, temos: p | ap − a = a(ap−1 − 1) e (a, p) = 1, segue-se, imedi-

atamente, que p divide ap−1 − 1.

Deﬁnição 2.3.1. Um número composto n é dito pseudoprimo na base a > 1 se an−1 ≡ 1 (mod n).

Denotaremos o número a por não-testemunha de Fermat de n.

Exemplo 2.3.2. O número n = 341 = 11×31 é pseudoprimo na base 2, pois 210 ≡ 1 (mod 11) ⇒

2340 ≡ 1 (mod 11) e 25 ≡ 1 (mod 31) ⇒ 2340 ≡ 1 (mod 31), ou seja, 2340 ≡ 1 mod 341.

Proposição 2.3.3. Seja n um número composto, se existe uma testemunha de Fermat x tal que

(x, n) = 1, então pelo menos metade dos elementos de {1, 2, ..., n − 1} são testemunha de Fermat

de n.

Prova: Se (x, n) = 1 e x é uma testemunha de Fermat de n, então xx−1 ≡ c (mod n) para algum

c (cid:54)= 1 satisfazendo (c, n) = 1. Assim, pelo Lema 2.2.3 mostramos que existem tantas testemunhas

de Fermat quanto não-testemunhas.

Deﬁnição 2.3.2. Um número composto n é dito número de Carmichael se an ≡ a (mod n) para

todo inteiro a, ou equivalentemente, se n é pseudoprimo na base a para todo a.

Lema 2.3.2. Se p é primo, então para algum k > 0 o número de x ∈ {1, 2, ..., p − 1} satisfazendo

xk ≡ 1 (mod p) é no máximo k.

Prova: Vamos provar, de forma mais geral, que para um polinômio não nulo P(x) = a0 + a1x +
... + akxk, o número de x ∈ {1, 2, ..., p − 1} satisfazendo P(x) ≡ 0 (mod p) é no máximo k.

Usando indução em k, para k = 0 é trivial. Supondo a tal que P(a) ≡ 0 (mod p), ou seja,

P(a) = (x − a)Q(x) + c, onde Q(x) é um polinômio de grau k − 1 com coeﬁcientes inteiros. A

congruência P(a) ≡ 0 (mod p) implica que c é divisível por p. Se b satisfaz P(b) ≡ 0 (mod p)

19

mas Q(b) (cid:54)≡ 0 (mod p) então p é um divisor de (b − a)Q(b) mas não é de Q(b), logo, b ≡ a

(mod p). Segue que cada b ∈ {1, 2, ..., p − 1} satisfazendo P(b) ≡ 0 (mod p) satisfaz b = a ou

Q(b) ≡ 0 (mod p). Pela hipótese de indução, no máximo k − 1 elementos de {1, 2, ..., p − 1}

satisfazem a segunda congruência.

Lema 2.3.3. Se n é um número de Carmichael, então n tem, no mínimo, três fatores primos

distintos e não é divisível pelo quadrado de nenhum primo.

Prova: Supondo p primo e p2 | n, escrevendo n = pkq onde k > 1 e p (cid:45) q. Usando o Teorema

Chinês dos Restos, podemos encontrar um x tal que x ≡ p + 1 (mod pk) e x ≡ 1 (mod q). Como

x não tem fator comum com pk ou q, e n = pkq temos que (x, n) = 1. Para provar que xn−1 (cid:54)≡ 1

(mod n), basta mostrar que xn−1 (cid:54)≡ 1 (mod p2) ou, equivalentemente, xn (cid:54)≡ x (mod p2). A
(cid:1)pk implica (p + 1)p ≡ 1 (mod p2), donde temos xn ≡ 1 (mod p2),
fórmula (p + 1)p = ∑
ou seja, xn (cid:54)≡ x (mod p2). Portanto, x é uma testemunha de Fermat.

p
k=0

(cid:0)p
k

Se n = pq com p < q, sem perda de generalidade, pelo Lema 2.3.2 temos x ∈ {1, 2, ..., q − 1}

tal que a congruência xp−1 (cid:54)≡ 1 (mod q). Daí, xn−1 = xpq−1 = xpq−1xp−1 ≡ xp−1 (cid:54)≡ 1 (mod q).

Como q é um divisor de n, temos que xn−1 (cid:54)≡ 1 (mod n), ou seja, x é uma testemunha de Fermat,

então n não é um número de Carmichael.

Deﬁnição 2.3.3. Seja ϕ(m) o número de elementos de um sistema reduzido de resíduos módulo

m, m ≥ 2, que corresponde à quantidade de números naturais entre 0 e m − 1 que são primos
com m. Fazendo ϕ(1) = 1, está deﬁnida uma importante função ϕ : N → N, conhecida como

função Fi de Euler.

Proposição 2.3.4. Para todo m ≥ 2 temos que ϕ(m) ≤ m − 1, onde ϕ(m) = m − 1 se, e somente

se, m é um número primo.

Prova: De fato, se m é primo então o sistema reduzido módulo m é formado por 1, 2, 3, ..., m −

1 ⇔ ϕ(m) = m − 1.

Teorema 2.3.5 (Teorema Euler-Fermat). Sejam m, a ∈ Z, com m > 1 e (a, m) = 1 então aϕ(m) ≡ 1

(mod m).

Prova: Sejam r1, r2, r3, ..., rϕ(m) um sistema reduzido de resíduos módulo m, ou seja, (ri, m) = 1

para todo i. Como (a, m) = 1 então ar1, ar2, ar3, ..., arϕ(m) também forma um sistema reduzido

módulo m. Assim, temos:

aϕ(m)r1.r2.r3...rϕ(m) ≡ ar1.ar2.ar3...arϕ(m) ≡ r1.r2.r3...rϕ(m) (mod m). Logo, aϕ(m) ≡ 1 (mod m).

20

Deﬁnição 2.3.4. Sejam m, a ∈ N∗, com m > 1 e (a, m) = 1, a ordem k de a em relação a m é
deﬁnida com sendo: ordm(a) = min{k ∈ N∗ | ak ≡ 1 (mod m)}

Proposição 2.3.6. Sejam a, m ∈ N e (a, m) = 1. Temos que ordm(a) | ϕ(m).

Prova: Supondo que ordm(a) (cid:45) ϕ(m) então, pela divisão euclidiana, temos que ϕ(m) = ordm(a)q+

r, com 0 < r < ordm(a). Assim, usando o Teorema 2.3.5, temos:
1 ≡ aϕ(m) ≡ aordm(a)q+r ≡ (aordm(a))qar ≡ ar (mod m), o que é um absurdo, pois a ordm(a) é o
menor expoente não nulo k tal que ak ≡ 1 (mod m).

2.4 Resíduos Quadráticos

Deﬁnição 2.4.1. Sejam a ∈ Z, p primo e p (cid:45) a. Se a congruência X 2 ≡ a (mod m) tem solução

então dizemos que a é um resíduo quadrático módulo p, caso contrário, diremos que a é um

resíduo não quadrático módulo p.

Proposição 2.4.1. Seja p > 2 um primo tal que p (cid:45) a. Então p | a

p−1
2 − 1 ou p | a

p−1
2 + 1, não

ocorrendo as duas situações simultaneamente.

Demonstração. Usando o Pequeno Teorema de Fermat temos:

(i) (a

(ii) (a

p−1
2 − 1)(a
p−1
2 − 1) + (a

p−1
2 + 1) = ap−1 − 1 ≡ 0 (mod m), ou seja, uma das situações ocorre.

p−1
2 + 1) = 2a

p−1
2 = 2(ap−1)

1
2 ≡ 2 (mod p), logo, não são simultaneas.

Lema 2.4.1. Sejam a, p ∈ Z em que p > 2 é primo e p (cid:45) a. Se x0 ∈ R∗ = {1, 2, ..., p − 1} é uma
solução da congruência X 2 ≡ a (mod p), então p − x0 também é uma solução, não congruente

com x0.

Prova: Supondo x0 uma solução, ou seja, x2
0 ≡ a (mod p). Além disso, se x1 ∈ R∗ é tal que x2
x2
p | x2

0 − x2

0 ≡ a (mod p), temos: (p − x0)2 = p2 − 2px0 + x2

1 ≡ a (mod p), então x2

0 ≡ x2

0 ≡
1 (mod p) ⇒

1 ⇒ p | x0 − x1 ou p | x0 + x1 ⇒ x1 = x0 ou x1 = p − x0, pois 1 ≤ x0, x1 ≤ p − 1.

Finalmente, se x0 fosse congruente a x1 teríamos:
x0 ≡ p − x0 (mod p) ⇒ p | 2x0 ⇒ p | x0 ⇒ p | x2

0 ⇒ p | a, o que é um absurdo.

Teorema 2.4.2 (Critério de Euler). Sejam a, p ∈ Z em que p > 2 é primo e p (cid:45) a. Então temos:

21

(i) p | a

(ii) p | a

p−1
2 − 1 ⇔ a é um resíduo quadrático módulo p;
p−1
2 + 1 ⇔ a não é um resíduo quadrático módulo p.

Prova: Seja R∗ um conjunto reduzido de resíduos módulo p. Se r ∈ R∗, temos que a congruência

rX ≡ a (mod p) possui uma única solução s ∈ R∗.

Supondo que a não é um resíduo quadrático módulo p, então a congruência X 2 ≡ a (mod p)

não tem solução. Assim, s (cid:54)= r. Agrupando aos pares os elementos de R∗ e usando o Teorema de

Wilson (demonstrado no capítulo 4) temos: −1 ≡ (p − 1)! ≡ a

p−1
2

(mod p) ⇒ p | a

p−1
2 + 1.

Agora, suponhamos que a é um resíduo quadrático módulo p, então a congruência X 2 ≡ a

(mod p) tem uma solução e pelo Lema 2.4.1, temos duas soluções r e s, tais que s = p − r. Como

r2 ≡ a (mod p), então rs = r(p − r) = rp − r2 ≡ −a (mod p). Agrupando os outros elementos

de R∗ aos pares, x e y tais que xy ≡ a (mod p), temos:

−1 ≡ (p − 1)! ≡ −aa

p−3
2 ≡ −a

p−1
2

(mod p) ⇒ 1 ≡ a

p−1
2

(mod p) ⇒ p | a

p−1
2 − 1.

Para concluir a demonstração vamos usar a Proposição 2.4.1. Assim, temos:

Se p | a

Se p | a

p−1

2 − 1 ⇒ p (cid:45) a
2 + 1 ⇒ p (cid:45) a

p−1

p−1
2 + 1 ⇒ a tem que ser um resíduo quadrático módulo p.
p−1
2 − 1 ⇒ a não pode ser um resíduo quadrático módulo p.

Deﬁnição 2.4.2. Seja p > 2 um número primo. Dado um número inteiro a deﬁne-se o Símbolo

de Legendre, denotado por

(cid:16) a
p

(cid:17)

, como sendo

( a
p) =





1

0

se a é um resíduo quadrático módulo p

se p | a

−1 se a é um resíduo não quadrático módulo p

Proposição 2.4.3. Sejam a, b, p ∈ N, com p primo ímpar e (a, p) = (b, p) = 1. Tem-se que:

(cid:17)

(cid:16) a
p

(i)

p−1
2

≡ a

(mod p)

(ii) Se a ≡ b (mod p), então
(cid:16) a
p

(cid:17) (cid:16) b
p

(cid:16) a.b
p

(iii)

=

(cid:17)

(cid:17)

(cid:17)

(cid:16) a
p

(cid:17)

(cid:16) b
p

=

Prova: Observe que a propriedade (i) é o Critério de Euler, Teorema 2.4.2, utilizando-se o

Símbolo de Legendre. Donde, temos:

(a)

(b)

(c)

(cid:17)

(cid:17)

(cid:17)

(cid:16) a
p
(cid:16) a
p
(cid:16) a
p

= 1 ⇔ p | a

p−1
2 − 1 ⇔ 1 ≡ a
p−1
2 ⇔ 0 ≡ a

p−1
2

(cid:17)

(cid:16) a
p

(mod p) ⇔
p−1
2

(mod p) ⇔

= 0 ⇔ p | a ⇔ p | a

= −1 ⇔ p | a

p−1
2 + 1 ⇔ −1 ≡ a

p−1
2

(mod p) ⇔

≡ a
(cid:16) a
(cid:17)
p
(cid:17)
(cid:16) a
p

p−1
2

≡ a

(mod p)
p−1
2

(mod p)

p−1
2

≡ a

(mod p)

A propriedade (ii) é uma consequência imediata do item anterior. Assim,

(cid:17)

(cid:16) a
p

≡ a

p−1
2 ≡ b

p−1
2 ≡

(cid:17)

(cid:16) b
p

(mod p)

Finalmente, para o item (iii), como (ab)

p−1
2 = a

p−1
2 .b

p−1
2 ,

(cid:17)

(cid:16) a
p

p−1
2

≡ a

(mod p) e

(cid:17)

(cid:16) b
p

p−1
2

≡ b

22

(mod p) concluímos que
(cid:16) ab
p

p−1
2 = a

≡ (ab)

p−1
2 .b

(cid:17)

p−1
2 ≡

(cid:16) a
p

(cid:17) (cid:16) b
p

(cid:17)

(mod p).

Deﬁnição 2.4.3. Seja a um inteiro relativamente primo com um número ímpar n = pα1
o Símbolo de Jacobi, denotado por (cid:2) a
n
(cid:21)
(cid:17)α2
(cid:2) a
n

(cid:3), é deﬁnido por:
(cid:17)αk

, onde os símbolos

(cid:17)α1 (cid:16) a
p2

(cid:16) a
p1

(cid:16) a
pk

(cid:16) a
pi

(cid:3) =

...

=

(cid:17)

(cid:20)

a
αk
pα1
1 pα2
2 ...p
k

são símbolos de Legen-

1 pα2

2 ...pαk

k

dre.

3 ANÁLISE DE ALGORITMOS

Neste capítulo, apresentaremos os conceitos, exemplos e métodos utilizados para o

23

estudo da complexidade de algoritmos.

3.1 Função de Complexidade

Segundo Cormen (2002), um algoritmo é uma sequencia de passos computacionais

bem deﬁnidos que toma algum valor ou conjunto de valores como entrada e transforma em

algum valor de saída (resultado).

Para comparar a eﬁciência dos algoritmos é usada uma medida chamada de comple-

xidade computacional, que indica o custo ao se executar um algoritmo, sendo esse custo formado,

basicamente, por consumo de memória (espaço utilizado) e tempo (duração de sua execução).

No presente estudo, desejamos medir o tempo de execução, por isso adotaremos

um modelo matemático no qual as instruções são executadas uma após a outra. O tempo de

execução de um algoritmo será representado por uma função f , onde f (n) representa o tempo

necessário para executar um algoritmo para uma entrada n, que será dado pelo número de

operações executadas.

Objetivando simpliﬁcar o processo de contagem do número de instruções do algo-

ritmo e facilitar a determinação da lei de formação da função f , as operações de atribuição (←)

e retorno (retorna) não serão consideradas.

Exemplo 3.1.1. O código abaixo identiﬁca o menor elemento de uma lista com n elementos, no

qual o trecho (4-6) é executado n − 1 vezes, portanto, temos que f (n) = n − 1.

Algoritmo 3.1.1: Identiﬁca o menor valor em uma lista de n elementos
1 início
2

menor ← lista[1];
para i de 2 até n faça

se (lista[i] < menor) então
menor ← lista[i];

ﬁm

ﬁm
retorna menor;

3

4

5

6

7

8
9 ﬁm

24

No exemplo anterior, o tempo de execução é uniforme para qualquer tamanho de

entrada n, mas existem algoritmos que dependem de outros fatores, como os de ordenação, nos

quais o tempo gasto será menor se a lista de elementos estiver quase ordenada. Por isso, a função

de complexidade pode ser obtida em três situações: pior caso, melhor caso e caso médio.

Exemplo 3.1.2. Fazer uma busca sequencial por um determinado elemento em uma lista de n

elementos. Portanto, a função f (n), considerando os três casos, é dada por:

- pior caso: f (n) = n, quando o elemento procurado é o último a ser consultado ou não está na

lista;

- melhor caso: f (n) = 1, o elemento é o primeiro da lista;
2 , considera a probabilidade de 1

- caso médio: f (n) = n+1

n para encontrar cada elemento.

Na análise de um algoritmo, devemos veriﬁcar o comportamento do mesmo no pior

caso e para uma entrada n indeﬁnidamente grande, pois, para valores de n pequenos, qualquer

algoritmo gastará pouco tempo.

Na maioria dos casos, determinar a função f (n) não é uma tarefa fácil, sendo

assim, buscamos mostrar que a complexidade do algoritmo é limitada a uma função conhecida,

categorizando-o em classes de complexidade (notação assintótica).

3.2 Notação Assintótica

Deﬁnição 3.2.1. Uma função f (n) domina assintoticamente uma função g(n) se existem duas

constantes c e m tais que, para n ≥ m, temos |g(n)| ≤ c. | f (n)|, que pode ser representada por

g(n) é O( f (n)) ou g(n) = O( f (n)).

Exemplo 3.2.1. Mostre que f (n) = 2n + 10 é O(n).

Podemos realizar uma manipulação para encontrar c e m:

2n + 10 ≤ c.n ⇒ c.n − 2n ≥ 10 ⇒ (c − 2)n ≥ 10 ⇒ n ≥ 10
c−2

Assim, para que f (n) ≤ c.n, tomando c = 4 temos que m = 5.

Exemplo 3.2.2. Seja f (n) = n2 + 2n + 1, quando c = 3 e m = 2, temos que: f (n) ≤ 3n2, para

n ≥ m = 2, ou seja, f (n) = O(n2).

Exemplo 3.2.3. Para mostrar que f (n) = 2n+2 é O(2n), basta tomar c = 4 para qualquer m,

pois 2n+2 = 22.2n = 4.2n.

Figura 1 – Comportamento assintótico de funções

25

Fonte – Ziviani (1999)

De acordo com Ziviani (1999), os problemas possuem as seguintes funções de

complexidade, que representam a razão de crescimento do tempo de execução de acordo com o

tamanho da entrada n:

• Constante: f (n) = O(1)

• Logarítimica: f (n) = O(log2 n)
• Linear: f (n) = O(n)

• Linear-Logarítmica: f (n) = O(n log2 n)
• Quadrática: f (n) = O(n2)

• Cúbica: f (n) = O(n3)

• Exponencial: f (n) = O(2n).

O algoritmo para cálculo do fatorial de n tem como função de complexidade f (n) =

3n, pois a cada iteração (linhas 4 a 7) são executadas 3 (três) instruções (1 comparação, 1

multiplicação e 1 adição). Assim, usando a notação assintótica, temos que: f (n) = O(n).

Algoritmo 3.2.1: Calcula o fatorial de um número n
1 início
2

resultado ← 1;
contador ← 1;
enquanto contador ≤ n faça

resultado ← resultado × contador;
contador ← contador + 1;

ﬁm
retorna resultado;

3

4

5

6

7

8
9 ﬁm

26

Observe no exemplo anterior, que contamos cada operação de multiplicação e adição

como apenas uma única instrução, ou seja, consideramos que a complexidade dessas operações

é O(1). Porém, para valores de n relativamente grandes, tanto adição quanto multiplicação tem

custos computacionais que inﬂuenciam no desempenho do algoritmo. Sendo assim, faz-se mister

compreendermos a complexidade das operações matemáticas básicas, para que possamos obter

uma análise algorítmica contemplando todos os fatores que determinam a eﬁciência de uma

solução.

3.3 Operações Matemáticas

Proposição 3.3.1. Seja n um número natural com k dígitos quando representado no sistema

binário (k bits), então k = (cid:98)log2 n(cid:99) + 1.

Prova: Sejam m e M os valores mínimo e máximo de possíveis para n, respectivamente. Assim,

m = 100...0
(cid:124) (cid:123)(cid:122) (cid:125)
k dígitos

m = 111...1
(cid:124) (cid:123)(cid:122) (cid:125)
k dígitos

= 1.2k−1 + 0.2k−2 + ... + 0.21 + 0.20 = 2k−1 e

= 1.2k−1 + 1.2k−2 + ... + 1.21 + 1.20 = 1.(2k−1)

2−1 = 2k − 1.

Daí, 2k−1 ≤ n ≤ 2k − 1 ⇔ 2k−1 ≤ n < 2k ⇔ k − 1 ≤ log2 n < k ⇔ k − 1 = (cid:98)log2 n(cid:99).
Logo, k = (cid:98)log2 n(cid:99) + 1.

Proposição 3.3.2. Dados dois números m e n com k dígitos na base 2, a adição (ou subtração)

será realizada em O(k) = O(log2 n).

Prova: Sendo a adição (subtração) obtida operando-se dígito a dígito, teremos que executar k

operações. Assim, f (n) = f (m, n) = k, ou seja, sua complexidade é O(log2 n).

Proposição 3.3.3. Dados dois números m e n com k dígitos no sistema binário, a multiplicação

será determinada em O(k2).

Prova: Sabemos que cada bit de m é multiplicado por cada bit de n sendo realizadas k2 multipli-

cações e, que posteriormente são efetuadas k − 1 somas. Donde temos f (m, n) = k2 + k − 1, que

em notação assintótica é O(k2).

Na multiplicação de números complexos, Gauss observou que o produto (a + bi)(c +

di) podia ser calculado usando 3 multiplicações e 5 adições em vez de 4 multiplicações e 4

adições (adição é mais rápida). Tomando os valores x = ac, y = bd e z = (a + b)(c + d) temos

27

que (a + bi)(c + di) = (x − y) + (z − x − y)i. Usando a mesma ideia para números inteiros, o

algoritmo Karatsuba-Ofman reduz a complexidade da multiplicação para O(klog2 3).

Utilizando-se método de Newton-Raphson, para o cálculo do inverso e transformando

a divisão em uma multiplicação, veriﬁcou-se que a divisão inteira tem a mesma complexidade de

tempo que a multiplicação. Da mesma forma, o custo de tempo para computar raiz quadrada (ou

módulo) é proporcional ao da multiplicação.

Exemplo 3.3.1. Sejam a, b e m números naturais, sendo a e m com k-bits e b com w-bits, o

código abaixo mostra que ab (mod m) tem complexidade O(k2w), onde a representação binária

de b é bw−1bw−2...b1b0.

Algoritmo 3.3.1: Determina o valor da potência modular ab (mod m)
1 início
2

resultado ← 1;
para i de w − 1 até 0 faça

3

4

5

6

7

8

9
10 ﬁm

resultado ← resultado × resultado (mod m);
se (bi = 1) então

resultado ← resultado × a (mod m);

ﬁm

ﬁm
retorna resultado;

Para cada uma das w iterações (linha 3 a 8) temos 2 produtos e 2 módulos, dando

com função de custo f (a, b, m) = w × 4k2. Assim, assintoticamente, temos O(k2w).

Exemplo 3.3.2. Dados a e b números inteiros, podemos calcular (a, b), o máximo divisor comum

de a e b, usando o algoritmo de Euclides.

Algoritmo 3.3.2: Determina o máximo divisor comum de a e b
1 início
2

enquanto b (cid:54)= 0 faça
r ← a (mod b);
a ← b;
b ← r;

ﬁm
retorna a;

3

4

5

6

7
8 ﬁm

Analisando o código acima, concluímos que em poucas iterações o valor de b

será igual a 0(zero), portanto, a complexidade é determinada pelo módulo. Assim, fazendo

n = max{a, b}, teremos O(log2

2 n) como função de crescimento do algoritmo.

28

29

4 TESTES DETERMINÍSTICOS

Neste capítulo apresentamos os principais testes de primalidade determinísticos, ou

seja, algoritmos cujo resultado, seja ele primo ou composto, será incontestável.

4.1 Divisões Sucessivas

O mais simples dos testes de primalidade consiste em dividir um número n por todos

os números inteiros que estiverem na faixa que vai de 2 até n − 1. Se n for divisível por qualquer

um deles, então n é um número composto. Caso contrário, é um número primo.

Proposição 4.1.1. Seja n um número natural composto, então n tem um divisor primo p tal que

√

n.

p ≤

Prova: Seja p o menor divisor primo de n, então n = pk para algum k ∈ N. Como p ≤ k temos

que p2 ≤ pk ⇒ P2 ≤ n ⇒ p ≤

√

n.

Proposição 4.1.2. Se p é um número primo diferente de 2 e 3, então p é da forma 6k − 1 ou

6k + 1, onde k é um inteiro positivo.

Prova: Todo número ao ser dividido por 6 é de uma das formas: 6k, 6k + 1, 6k + 2, 6k + 3,

6k + 4 ou 6k + 5.

• n = 6k, n é múltiplo de 6, não é primo.

• n = 6k + 1, pode ser primo.

• n = 6k + 2, n = 2(3k + 1) ⇒ n é múltiplo de 2, 6k + 2 não é primo.

• n = 6k + 3, n = 3(2k + 1) ⇒ n é múltiplo de 3, 6k + 3 não é primo.

• n = 6k + 4, n = 2(3k + 2) ⇒ n é múltiplo de 2, 6k + 4 não é primo.

• n = 6k + 5 ⇒ n = 6k + 6 − 1 = 6(k + 1) − 1 = 6k

(cid:48)

− 1, pode ser primo.

Portanto, se n for primo ele não pode ser das formas 6k, 6k + 2, 6k + 3 e 6k + 4. Assim, n é

primo para 6k − 1 ou 6k + 1.

Utilizando a Proposição 4.1.1, Eratóstenes criou um método, chamado Crivo de

Eratóstenes, para listar os primos menores que um certo inteiro positivo n > 1, que consiste do

seguinte:

(a) Escreva uma lista com todos os inteiros entre 2 e n − 1;

(b) Para cada primo p ≤

√

n, elimina-se da lista todos os múltiplos pk de p, para k ≥ 2;

(c) Os números que sobrarem são os primos menores que n.

Exemplo 4.1.1. Determinar os números primos menores de 2 a 100.

30

2

3

4

5

6

7

8

9

10

11 12 13 14 15 16 17 18 19 20

21 22 23 24 25 26 27 28 29 30

31 32 33 34 35 36 37 38 39 40

41 42 43 44 45 46 47 48 49 50

51 52 53 54 55 56 57 58 59 60

61 62 63 64 65 66 67 68 69 60

71 72 73 74 75 76 77 78 79 80

81 82 83 84 85 86 87 88 89 90

91 92 93 94 95 96 97 98 99 100

De acordo com a proposiçoes 4.1.1 e 4.1.2, para veriﬁcarmos se um número é primo,

usando o método das divisões sucessivas, devemos dividir o número por 2 e por 3 e, depois,

faz-se as divisões por todos os inteiros na forma 6k ± 1 que sejam menores ou iguais à raiz

quadrada do número testado.

Algoritmo 4.1.1: Divisões Sucessivas
1 início
2

se (n (mod 2) = 0) ou (n (mod 3) = 0) então

retorna COMPOST O;

ﬁm
k ← 1;
enquanto (6k − 1) × (6k − 1) ≤ n faça

se (n (mod 6k − 1) = 0) ou (n (mod 6k + 1) = 0) então

retorna COMPOST O;

ﬁm
k ← k + 1;

ﬁm
retorna PRIMO;

3

4

5

6

7

8

9

10

11

12
13 ﬁm

Exemplo 4.1.2. Veriﬁque se o número 323 é primo ou composto.

√

Como

323 (cid:39) 17, 9722, então vamos dividir 323 por 2, 3, 5, 7, 11, 13 e 17. Se nenhum destes

31

números dividir 323, então ele será primo:

• Dividindo por 2 e por 3

- 323 = 2 × 161 + 1

- 323 = 3 × 107 + 2

• Para k = 1, dividimos por 6k − 1 = 5 e 6k + 1 = 7

- 323 = 5 × 64 + 3

- 323 = 7 × 46 + 1

• Para k = 2, temos 6k − 1 = 11 e 6k + 1 = 13

- 323 = 11 × 29 + 4

- 323 = 13 × 24 + 11

• Para k = 3, dividimos por 6k − 1 = 17 e 6k + 1 = 19 >

- 323 = 17 × 19 + 0

√

323

Portanto, o número 323 não é primo porque é divisível por 17.

Exemplo 4.1.3. Determine a primalidade do número 181.

√

Observe que

181 (cid:39) 13, 453, portanto devemos dividir 181 por 2, 3, 5, 7, 11 e 13. Se 181 não

for divisível por nenhum destes números, então ele será primo:

• Dividindo por 2 e por 3

- 181 = 2 × 90 + 1

- 181 = 3 × 60 + 1

• Para k = 1, dividimos por 6k − 1 = 5 e 6k + 1 = 7

- 181 = 5 × 36 + 1

- 181 = 7 × 25 + 6

• Para k = 2, temos 6k − 1 = 11 e 6k + 1 = 13

- 181 = 11 × 16 + 5

- 181 = 13 × 13 + 12

Assim, podemos aﬁrmar que o número 181 é primo.

Neste algoritmo, a complexidade é determinada pelas

custo O(log2

2 n) - função módulo - requerendo O(

√

n log2

2 n).

√
n
6 iterações (linhas 6 a 11) de

32

4.2 Teorema de Wilson

Proposição 4.2.1. Sejam a, m ∈ Z, com m > 1. A congruência aX ≡ 1 (mod m) possui solução
se, e somente se, (a, m) = 1. Além disso, se x0 ∈ Z é uma solução, então x é uma solução da

congruência se, e somente se, x ≡ x0 (mod m).

Prova: Seja x0 uma solução, então m | ax0 − 1 ⇔ aX − mY = 1, portanto, (a, m) = 1.

Por outro lado, se x0 e x são soluções da congruência aX ≡ 1 (mod m), então ax ≡ ax0 ≡ 1

(mod m), donde temos, x ≡ x0 (mod m).

Lema 4.2.1. Seja p um número primo. Os únicos elementos do conjunto R∗ = {1, 2, ..., p − 1}

que satisfazem a equação x2 ≡ 1 (mod p) são 1 e p − 1.

Prova: Tomando a ∈ R∗ de modo que a2 ≡ (mod p), isto é, p | a2 − 1. Como a ∈ R∗ e p | a + 1

ou p | a − 1 temos:

1 ≤ a ≤ p − 1 ⇒ 2 ≤ a + 1 ≤ p ⇒ p = a + 1 ⇒ a = p − 1.

Analogamente, considerando que p | a − 1 e a − 1 < p, para todo a ∈ R∗, concluímos que

a − 1 = 0 ⇒ a = 1.

Teorema 4.2.2 (Teorema de Wilson). Um número inteiro n > 1 é primo se, e somente se,

(n − 1)! ≡ −1 (mod n).

Prova: Suponha n primo, usando a Proposição 4.2.1 e o Lema 4.2.1, temos que cada fator de

(n − 2)! = 2.3.4...(n − 3)(n − 2) possui seu próprio inverso (módulo n) entre os outros fatores.

Assim,

(n − 2)! = 2.3.4...(n − 3)(n − 2) ≡ 1 (mod n) ⇔ (n − 1)! ≡ n − 1 ≡ −1 (mod n).

A recíproca será provada por contradição. Supondo que (n−1)! ≡ −1 (mod n) ⇔ n | (n−1)!+1

e que n não seja primo, ou seja, n = rs e 1 < r, s < n. Nestas condições r | (n − 1)! + 1 e, sendo r

um divisor de n, r | (n − 1)!. Portanto, r divide a diferença (n − 1)! + 1 − (n − 1)! = 1, absurdo,

uma vez que r > 1. Assim, n satisfazendo (n − 1)! ≡ −1 (mod n) deve ser primo.

Analisando o algoritmo abaixo, concluímos que este teste não é prático, pois são

necessárias n − 1 multiplicações módulo n para calcular (n − 1)!, fazendo com que sua comple-

xidade seja O(n log2

2 n).

33

Algoritmo 4.2.1: Teorema de Wilson
1 início
2

resultado ← 1;
numero ← 1;
enquanto numero ≤ n − 1 faça

resultado ← (resultado × numero) (mod n);
numero ← numero + 1;

ﬁm
se (resultado ≡ −1 (mod n)) então

retorna PRIMO;

ﬁm
retorna COMPOST O;

3

4

5

6

7

8

9

10

11
12 ﬁm

Exemplo 4.2.1. Veriﬁque se o número 6 é primo ou composto.

Sendo (6 − 1)! = 5! = 5 × 4 × ×3 × 2 × 1 = 120 = 6 × 20 ≡ 0 (mod 6).

Portanto, 6 não é um número primo.

Exemplo 4.2.2. Determine a primalidade do número 11.

Como (11 − 1)! = 10! = 10 × 9 × ... × 2 × 1, agrupando os termos inversos (módulo 11) temos:

10! = 1 × (2 × 6) × (3 × 4) × (5 × 9) × (7 × 8) × 10 ≡ −1 (mod 11).

Assim, o número 11 é primo.

4.3 AKS

Em 2002, no artigo chamado "PRIMES is in P", os indianos Manindra Agrawal,

Neeraj Kayal e Nitin Saxena apresentaram um teste determinístico, denominado AKS, capaz de

veriﬁcar a primalidade de um número em tempo polinomial.

O algoritmo AKS é composto pelos seis passos descritos abaixo. Dado um número

inteiro n > 1, temos:
1. Se n = ab para a ∈ N e b > 1, retorna COMPOSTO.
2. Encontre o menor r tal que ordr(n) > log2

2 n.

3. Se 1 < (a, n) < n para algum a ≤ r, retorna COMPOSTO.

4. Se n ≤ r, retorna PRIMO.
5. Para a = 1 até (cid:98)(cid:112)ϕ(r) log2 n(cid:99) faça: Se (x + a)n (cid:54)≡ (xn + a) (mod (xr − 1, n)) então retorna
COMPOSTO.

6. Retorna PRIMO.

34

O algoritmo baseia-se na equação de congruência (x + a)p ≡ (xp + a) (mod p) ⇔ p

é primo, que é uma generalização do Pequeno Teorema de Fermat.

Podemos veriﬁcar esta propriedade no Triângulo de Pascal, onde cada linha repre-

senta os coeﬁcientes da expansão binomial. Assim, se todos os números da linha, excetuando-se

os extremos, forem múltiplos da linha (número da linha) então o número que representa a linha

será primo.

Exemplo 4.3.1. Observe Triângulo de Pascal abaixo que 2, 3, 5 e 7 são números primos.

0:

1:

2:

3:

4:

5:

6:

7:

8:

9:

10:

1

1

1

1

1

1

1

1

1

1

1

1

2

3

4

5

6

7

8

9

10

1

3

6

10

15

21

28

36

45

1

4

10

20

35

56

84

1

5

15

35

70

126

120

210

1

6

21

56

126

252

1

7

28

84

1

8

36

1

9

210

120

45

1

10

1

Teorema 4.3.1. Sejam a ∈ Z, n ∈ N, n ≥ 2 e (a, n) = 1. Então n é primo se, e somente se,

(x + a)n ≡ (xn + a) (mod n)

Prova: Para 0 < k < n, o coeﬁciente de xk em (x + a)n − (xn + a) é (cid:0)n
(cid:1)an−k. Supondo que n é
k
(cid:1) = 0 (mod n), ou seja, todos os coeﬁcientes são 0 (zero). Por
primo, pelo Lema 2.3.1, temos (cid:0)n
k
outro lado, suponhamos que n é composto. Seja o primo p um fator de n e pq a maior potência
(cid:1) e (pq, an−p) = 1, logo, o coeﬁciente de xp não é 0
de p que divide n. Assim, pq não divide (cid:0)n
p
(zero). Portanto, n (cid:45) (x + a)n − (xn + a).

A congruência acima tem um tempo de execução exponencial. No entanto, para

um número r razoavelmente pequeno e adequadamente escolhido, podemos utilizar módulo

de xr − 1 para reduzir o número de testes necessários, pois teremos que examinar apenas o

resto da divisão de (x + a)n por xr − 1. Dessa forma, a congruência utilizada é a seguinte:

onde (mod (xr − 1, n)) signiﬁca aplicar (mod xr − 1) e ao resultado a congruência (mod n).

(x + a)n ≡ (xn + a) (mod (xr − 1, n))

35

Na análise deste algoritmo omitiremos a demonstração da equivalência acima e dos

demais resultados utilizados. Portanto, para uma explanação detalhada, consulte o artigo citado

no inicio desta seção (ou COUTINHO, 2004).

Neste trabalho, mostraremos, de forma resumida, os pontos que determinam a

complexidade do algoritmo, por isso vamos veriﬁcar o custo computacional envolvido em cada

de seus passos.

Tabela 4.3.1 – Complexidade das etapas do AKS

Etapa

Descrição

Complexidade

1
2
3
4
5

Identiﬁca se n é uma potência própria
Encontra um r tal que ordr(n) > log2
2 n
Calcula o mdc(a, n) para a ≤ r
Compara os valores de n e r
Veriﬁca (x + a)n ≡ (xn + a) (mod (xr − 1, n))

O(log3
2 n)
O(log7
2 n)
O(log6
2 n)
O(log2 n)
21/2
O(log
2 n)

Fonte – Elaborada pelo autor

Algoritmo 4.3.1: Veriﬁca se um número n é uma potência própria
1 início
2

baseFinal ← n;
para expoente de 2 até log2 n faça

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23
24 ﬁm

baseInicial ← 2;
enquanto baseFinal − baseInicial > 1 faça

baseMedia ← (baseInicial + baseFinal)/2;
resultado ← potencia(baseMedia, expoente);
se (resultado < n) então

baseInicial ← baseMedia;

ﬁm
senão se (resultado > n) então
baseFinal ← baseMedia;

ﬁm
senão

retorna V ERDADEIRO;

ﬁm

ﬁm
resultado ← potencia(baseMedia, expoente);
se (resultado = n) então

retorna V ERDADEIRO;

ﬁm

ﬁm
retorna FALSO;

36

O método acima veriﬁca a existência de potência própria, ou seja, se existem inteiros
positivos a > 1 e b > 1 de modo que n = ab. Observe que 2 ≤ b ≤ log2 n, pois o valor máximo
de b é obtido quando a for mínimo (a = 2).

Para encontrar o valor de r que satisfaz o item 2, basta determinar o menor r tal que

não exista k = ordr(n) onde 1 ≤ k ≤ log2
2.3.4 e 2.3.6 temos que log2

2 n. Por outro lado, do Teorema 2.3.5 e das Proposições
2 n < ordr(n) ≤ ϕ(r) ≤ r − 1 < r. Assim, o valor de r pode ser dado

pelo algoritmo abaixo.

Algoritmo 4.3.2: Encontra o menor r tal que ordr(n) > log2
1 início

2 n

2 n;

r ← log2
encontrado ← FALSO;
enquanto encontrado = FALSO faça
encontrado ← V ERDADEIRO;
k ← 1;
enquanto k < log2

2 n faça

resultado ← nk (mod r);
se (resultado = 1) ou resultado = r − 1 então

encontrado ← FALSO;

ﬁm
k ← k + 1;

ﬁm
r ← r + 1;

ﬁm
retorna r;

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16
17 ﬁm

Na execução da etapa 3, devemos veriﬁcar se existe a ≤ r tal que 1 < (a, n) < n, o

que pode ser feito usando o seguinte procedimento:

Algoritmo 4.3.3: Calcula o mdc(a, n) para a ≤ r
1 início
2

para a de 1 até r faça
mdc ← (a, n);
se (mdc (cid:54)= 1) e (mdc (cid:54)= n) então
retorna COMPOST O;

3

4

5

6

ﬁm

ﬁm

7
8 ﬁm

O quarto passo consiste em uma simples comparação entre os valores de r e n, não

sendo necessária a construção de nenhum algoritmo.

37

O teste da congruência consiste na veriﬁcação de (cid:98)(cid:112)ϕ(r) log2 n(cid:99) equações, que
necessitam de O(log2 n) multiplicações de r coeﬁcientes de tamanho O(log2 n). Portanto, cada
equação requer um custo de processamento de O(r log2
2 n), logo, a complexidade desta etapa é
dada por: O(r(cid:112)ϕ(r) log3
21/2
2 n) ∼= O(r
2 n).
Como dito anteriormente, log2
√
r e ϕ(r) < r. Assim, a expressão (cid:98)(cid:112)ϕ(r) log2 n(cid:99) <

2 n < ordr(n) ≤ ϕ(r) < r donde concluímos que
√
r = r pode ser substituída

2 n) ∼= O(log

log2 n <

2 log3

√
r

3

no algoritmo.

Algoritmo 4.3.4: Veriﬁca a congruência (x + a)n ≡ (xn + a) (mod (xr − 1, n))
1 início
2

para a de 1 até r faça

lado1 ← (x + a)n (mod n);
lado2 ← xn + a (mod n);
se (lado1 (cid:54)= lado2) então
retorna COMPOST O;

ﬁm

3

4

5

6

7

ﬁm

8
9 ﬁm

Proposição 4.3.2. Sejam n, r ∈ N então xn + a ≡ xn mod r + a (mod (xr − 1)).

Prova: Inicialmente, mostraremos que xr − 1 | xrq − 1. Por indução temos:

Sendo verdade para q = 1, vamos provar que vale para q + 1 supondo que xr − 1 | xrq − 1. Assim,

xr(q+1) − 1 = xrqxr − 1 = xrqxr − xr + xr − 1 = xr(xrq − 1) + xr − 1, logo, xr − 1 | xrq − 1.

Tomando n = rq + l onde l < r temos: xn + a = xrq+l + a = xrqxl + a = xl(xrq − 1) + xl + a.

Portanto, xn + a ≡ xl + a ≡ xn mod r + a (mod (xr − 1)).

Dentre todos os passos, este é o que apresenta o maior custo computacional. Usando

a proposição anterior, podemos facilmente calcular xn + a, mas ainda não temos mecanismo

semelhante para simpliﬁcar o termo (x + a)n.

Exemplo 4.3.2. Detemine a primalidade do número 341.

Analisando cada passo do algoritmo AKS temos:

(1) 341 não é uma potência;
(2) Para r = 77 temos ord77(341) > log2

2 341;
(3) Para a = 11 temos 1 < (11, 341) = 11 < 341, portanto, 341 é um número composto.

38

Exemplo 4.3.3. Veriﬁque se o número 31 é primo ou composto.

Executando o teste AKS obtemos:

(1) 31 não é uma potência;
(2) Para r = 29 temos ord29(31) > log2

2 31;

(3) Não existe a ≤ 29 tal que 1 < (a, 31) < 31;

(4) 31 > 29, nada podemos aﬁrmar;

(5) A congruência é verdadeira para todo 1 ≤ a ≤ 29;

(6) Logo, o número 31 é primo.

4.4 Lucas-Lehmer

O teste de Lucas-Lehmer é um teste de primalidade, para números de Mersenne,

originalmente desenvolvido por Edouard Lucas e posteriormente melhorado por Derrick Henry

Lehmer.

Teorema 4.4.1. Seja Sk a sequência deﬁnida por Sk = (2 +
n > 2, Mn = 2n − 1 é primo se, e somente se, Sn−2 é múltiplo de Mn.

√

3)2k

+ (2 −

√

3)2k

para k ∈ N. Seja

√

3)2n−2 + (2 −

√

3)2n−2

e Mn seja composto, com

Prova: Suponha, por absurdo, que Mn | (2 +
um fator primo p tal que p2 ≤ Mn. Assim, teremos:
√
3)2n−2 ≡ 0 (mod p) ⇔ (2 +
√

3)2n−2 + (2 −
√

(2 +

√

√

√

√

3)2n−2 ≡ −(2 −

√

3)2n−2 (mod p)

Como (2 +
√

(2 +

3)2n−2 ≡ −

3)(2 −

3) = 1, ou seja, 2 −

3)−1 então reescrevendo a equação
3)2n−1 ≡ −1 (mod p), o que signiﬁca que a
3 é igual a 2n. Absurdo, pois o valor máximo de ϕ(Mn) = p2 − 1 < 2n, logo, se

3)2n−2 (mod p) ⇔ (2 +

3 = (2 +
√

1
√

(2+

√

ordem de 2 +

3 ≡ 1 −

√

3 (mod Mn), já que pela reci-

Sn−2 é múltiplo de Mn então Mn é primo.

Supondo Mn primo, pelo Teorema 4.3.1 temos:

√

(1 +

3)Mn ≡ 1 + (

procidade quadrática

√

√

(cid:17) √

Mn−1
2

3)Mn ≡ 1 + 3
3 ≡ 1
(cid:17)
(cid:16) 3
= − (cid:0) Mn
(cid:1) = − (cid:0) −2
Mn
3
3
√
√
3)2 = 2(2 +
3). Assim, temos:
√
√

(cid:16) 3
Mn
(cid:1) = −1.

Note ainda que (1 +

√

√

[(1 +

(1 +

−1 ≡

3)2]2n−1 = 22n−1(2 +
3)Mn+1 = 2.2
√
(cid:16) 2
Mn

Mn−1

(cid:17)

2 (2 +

3)2n−1 ⇔ (1 +
√
3)2n−1 ⇔ −2 ≡ 2

3)2n
(cid:16) 2
M2
√

= 22n−1(2 +
√

(cid:17)

3)2n−1 (mod Mn)

(2 +
3)2n−1 (mod Mn),

3)2n−1 (mod Mn) ⇔ −1 ≡ (2 +

√

3)2n−1

uma vez que

(cid:17)

= (−1)

M2

n −1
8 = 1.

(2 +
(cid:16) 2
Mn

Daí, usando novamente a igualdade (2 +

√

3)(2 −

√

3) = 1 concluímos que:

√

3)2n−2 (mod Mn)

39

(2 +

(2 +

(2 +

(2 +

√

√

√

√

√

1
√

3)2n−1.(2 −
3)2n−1.
(2+
3)2n−2 ≡ −(2 −
√
3)2n−2 + (2 −
√

Portanto, Mn | (2 +

3)2n−2 ≡ −(2 −
√

3)2n−2 ≡ −(2 −

√

3)2n−2 (mod Mn)
3)2n−2 ≡ 0 (mod Mn)
3)2n−2
3)2n−2 + (2 −

√

3)2n−2 (mod Mn)

Proposição 4.4.2. Seja a sequência Sk = (2 +
por: S0 = 4 e Sk+1 = S2

k − 2.

, ou seja, Sn−2 é múltiplo de Mn.
√

√

3)2k

+ (2 −

3)2k

, Sk de forma recursiva é dada

Prova: Para k = 0, teremos S0 = (2 +

√

3)20 + (2 −

√

3)20 ⇔ S0 = 2 +

√

3 + 2 −

√

3 ⇔ S0 = 4.

De modo análogo, vamos escrever Sk+1 em função de Sk
√

√

√

Sk+1 = (2 +

= [(2 +

= [(2 +

= [(2 +

√

√

√

3)2k
3)2k
3)2k

3)2k+1 + (2 −
√
]2 + [(2 −
√

+ (2 −

3)2k+1 = (2 +
√
]2 + 2(2 +
√

3)2k
]2 − 2[(2 +
]2 − 2.12k

3)2k
3)2k

+ (2 −

√

= [(2 +

3)2k

3)(2 −
√

3)2k.2 + (2 −
√
3)2k

(2 −
√

3)]2k

√

3)2k.2

− 2(2 +

√

3)2k

(2 −

√

3)2k

3)2k

+ (2 −

√

3)2k

]2 − 2 = S2

k − 2

Algoritmo 4.4.1: Lucas-Lehmer
1 início
2

M ← 2n − 1;
S ← 4;
para i de 1 até n − 2 faça

S ← (S × S − 2) (mod M);

ﬁm
se (S = 0) então

retorna PRIMO;

ﬁm
retorna COMPOST O;

3

4

5

6

7

8

9

10
11 ﬁm

O código acima mostra que existem duas operações que determinam a sua complexi-

dade: a multiplicação de S × S e o módulo de M. O cálculo do módulo torna-se mais eﬁciente

utilizando, no sistema binário, a propriedade x ≡ [x (mod 2n)] + (cid:98)x/2n(cid:99) (mod 2n − 1), fazendo

o custo de cada repetição (linha 4 a 6) ser O(n log2 n). Portanto, como são necessárias n − 2
iterações teremos uma complexidade O(n2 log2 n) para este algoritmo.

Exemplo 4.4.1. Veriﬁque se M5 = 25 − 1 = 31 é um número primo.

Tomando S = 4 vamos atualizar o valor da expressão S ← (S × S − 2) (mod M5) 3 vezes:

• S ← (4 × 4 − 2) (mod 31) = 14

40

• S ← (14 × 14 − 2) (mod 31) = 8

• S ← (8 × 8 − 2) (mod 31) = 0

Portanto, o número 31 é primo.

Exemplo 4.4.2. Determine a primalidade do número M11 = 211 − 1 = 2047.

Atualizando 11 − 2 = 9 vezes a expressão S ← (S × S − 2) (mod M11) temos:

• S ← (4 × 4 − 2) (mod 2047) = 14

• S ← (14 × 14 − 2) (mod 2047) = 194

• S ← (194 × 194 − 2) (mod 2047) = 788

• S ← (788 × 788 − 2) (mod 2047) = 701

• S ← (701 × 701 − 2) (mod 2047) = 119

• S ← (119 × 119 − 2) (mod 2047) = 1877

• S ← (1877 × 1877 − 2) (mod 2047) = 240

• S ← (240 × 240 − 2) (mod 2047) = 282

• S ← (282 × 282 − 2) (mod 2047) = 1736

Portanto, o número 2047 não é primo, pois o valor ﬁnal de S é diferente de 0 (zero).

Note que, todo número Mn = 2n − 1 quando representado no sistema binário é da

forma 111...11
(cid:124) (cid:123)(cid:122) (cid:125)
n dígitos

. Essa característica juntamente com o baixo custo computacional do teste de

Lucas-Lehmer fazem com que os maiores números primos encontrados sejam todos primos de

Mersenne.

Atualmente, o maior primo conhecido é M74207281 = 274207281 − 1, com 22338618

dígitos, descoberto em 2016 por Curtis Cooper, através do GIMPS (Great Internet Mersenne

Prime Search), um projeto de computação distibuída para identiﬁcar primos de Mersenne.

41

5 TESTES PROBABILÍSTICOS

Os testes probabilísticos são aqueles que retornam uma resposta com um percentual

de conﬁabilidade e utilizam números gerados aleatoriamente para a sua execução. Neste capítulo

iremos analisar os dois principais algoritmos probabilísticos para determinar a primalidade de

um número: Solovay-Strassen e Miller-Rabin.

5.1 Solovay-Strassen

Desenvolvido por Robert Martin Solovay e Volker Strassen, este algoritmo permite

que dado um número ímpar possamos determinar se o mesmo é um número composto ou

provavelmente primo utilizando o Critério de Euler e o Símbolo de Jacobi.

Teorema 5.1.1. Seja n um número inteiro ímpar composto, existe um inteiro a tal que (a, n) = 1

n−1
2

e a

(cid:54)≡ (cid:2) a
n

(cid:3) (mod n).

Prova: Suponha que n = p1 p2...pr com r ≥ 2 e os pi
dos números (mod p1) não são resíduos quadráticos, então existe b ∈ Z tal que
= −1. Pelo
Teorema Chinês do Resto, algum a ∈ Z satisfaz a ≡ b (mod p1), donde, a ≡ 1 (mod p2...pr).

(cid:48)s primos ímpares distintos. Como metade

(cid:16) b
p1

(cid:17)

Assim, a é relativamente primo com p1 e p2...pr, logo, (a, n) = 1. Sendo
(cid:16) a
pi

= −1.

(cid:16) a
p1

=

=

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:16) 1
p1
Por absurdo, tomemos a

= 1 para i > 1, (cid:0) a
n
2 ≡ (cid:0) a
n

n−1

(cid:16) a
p1

(cid:17) (cid:16) a
(cid:16) a
(cid:1) =
p2
pr
(cid:1) (mod n), ou seja a

...

n−1
2 ≡ −1 (mod n) que pode ser reduzida

(cid:17)

(cid:16) a
p1

=

(cid:17)

(cid:16) b
p1

= −1 e

para módulo p2, pois p2 divide n. Portanto,

1 =

(cid:17)

(cid:16) a
p2

≡ a

n−1
2 ≡ −1 (mod p2) ⇔ 1 ≡ −1 (mod p2) ⇔ 2 ≡ 0 (mod p2).

Isto é uma contradição, pois o módulo p2 é maior que 2.
Agora, supondo que n possui um fator primo p repetido, então n = pkm sendo k ≥ 2 e (p, m) = 1.
Novamente do Teorema Chinês do Resto, existe um a ∈ Z satisfazendo a congruência a ≡ 1 + p

n−1

(mod p2), então a ≡ 1 (mod m), ou seja, a não é divisível por p e (a, m) = 1, logo, (a, n) = 1.
(cid:1) (mod n), elevando ao quadrado teremos a congruência an−1 ≡ 1 (mod n), que é
impossível. Pois reduzindo para módulo p2 (fator de n) obtemos an−1 ≡ 1 (mod p2). Assim,

2 ≡ (cid:0) a
n

Se a

a ≡ 1 + p (mod p2) ⇔ (1 + p)n−1 ≡ an−1 (mod p2) ⇔ (1 + p)n−1 ≡ 1 (mod p2).

Usando o binomial (1 + p)n−1 ≡ 1 + (n − 1)p (mod p2) teremos:

(1 + p)n−1 ≡ 1 (mod p2) ⇔ 1 + (n − 1)p ≡ 1 (mod p2) ⇔ (n − 1)p ≡ 0 (mod p2).

Portanto, n − 1 ≡ 0 (mod p), absurdo, pois n é múltiplo de p.

Vejamos o funcionamento deste método no código abaixo:

Algoritmo 5.1.1: Solovay-Strassen
1 início
2

para i de 1 até k faça

42

a ← RANDOMICO({2, 3, ..., n − 1});
j ← Jacobi(a, n);
se ( j = 0) ou (a

(cid:54)≡ j (mod n)) então

n−1
2

retorna COMPOST O;

ﬁm

ﬁm
retorna PRIMO;

3

4

5

6

7

8

9
10 ﬁm

Para calcular o Símbolo de Jacobi, indicado pela função Jacobi(a, n) (linha 4),

utilizamos o seguinte algoritmo:

Algoritmo 5.1.2: Calcula o Símbolo de Jacobi
1 início
2

j ← 1;
enquanto a (cid:54)= 0 faça

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20
21 ﬁm

enquanto a (mod 2) ≡ 0 faça

a ← a/2;
se (n ≡ 3 (mod 8)) ou (n ≡ 5 (mod 8)) então

j ← − j;

ﬁm

ﬁm
c ← n;
n ← a;
a ← c;
se (a ≡ 3 (mod 4)) ou (n ≡ 3 (mod 4)) então

j ← − j;

ﬁm

ﬁm
se (n = 1) então
retorna j;

ﬁm
retorna 0;

O custo computacional da funcão Jacobi(a, n) é de O(log2

2 n) uma vez que o execução

só é ﬁnalizada quando a = 0 (linha 3) e a cada iteração a e n trocam de valor.

Proposição 5.1.2. Seja n > 1 um inteiro ímpar. A quantidade de inteiros a tal que (a, n) = 1,

43

1 ≤ a ≤ n − 1 e a

n−1

2 ≡ (cid:2) a
n

(cid:3) (mod n) será:

(i) igual a n − 1, para n primo;

(ii) menor que n−1

2 , para n composto.

Prova: O item (i) é valido pelo Critério de Euler e o Símbolo de Legendre, conforme a Proposição
(cid:1) = 0, se (a, n) > 1. Assim,
2.4.3. Para provar (ii), sabemos que (cid:0) a
n

(cid:1) = ±1, se (a, n) = 1 e (cid:0) a
n

para os números de 1 até n − 1, temos os conjuntos disjuntos:

A = {1 ≤ a ≤ n − 1 | (a, n) = 1 e a

B = {1 ≤ a ≤ n − 1 | (a, n) = 1 e a

C = {1 ≤ a ≤ n − 1 | (a, n) > 1}.

n−1

2 ≡ (cid:0) a
n
(cid:54)≡ (cid:0) a
n

n−1
2

(cid:1) (mod n)},
(cid:1) (mod n)} e

O conjunto A não é vazio, pois 1 ∈ A, assim como C quando n é composto. Pelo Teorema 5.1.1,

também B provavelmente não é vazio. Tomando a ∈ A e b ∈ B temos que (ab, n) = 1 e portanto,

(ab)

n−1
2 ≡ a

n−1
2 b

Se ab (mod n) ∈ A, (ab)
para (a, n) = 1 temos (cid:0) a
n
Daí, (cid:0) b
n

(cid:1) ≡ b

n−1
2

n−1

2 ≡ (cid:0) a
n
n−1

n−1
2

(mod n). Logo, ab (mod n) ∈ A ou B.
(cid:1) ≡ (cid:0) a
(cid:1) (mod n) ⇒ (cid:0) a
n
n

(cid:1) b
(cid:1) ≡ (cid:0) a
2 ≡ (cid:0) ab
n
n
(cid:1) = ±1, podemos cancelar (cid:0) a
n

(cid:1) b
(mod n). Como
(cid:1) em ambos os membros da congruência.

(cid:1) (cid:0) b
n

(cid:1) (cid:0) b
n

n−1
2

(mod n), ou seja, b ∈ A. Absurso, portanto ab (mod n) ∈ B.

Sejam x, y ∈ A, se xb ≡ yb (mod n) ⇒ x ≡ y (mod n) ⇒ x = y, pois os números em A estão

estritamente entre 0 e n. Como o número de elementos de Ab = |A| e Ab ⊂ B temos que
|A| = |Ab| ≤ |B|. Assim, n − 1 = |A| + |B| + |C| ≥ |A| + |A| + 1 ⇒ n − 1 > 2|A| ⇒ |A| < n−1
2 .

Exemplo 5.1.1. Veriﬁcando a proposição acima para n = 15.
Note que, a = 3, 5, 6, 9, 10 e 12 o resultado será COMPOSTO, pois (cid:2) a
n

(cid:3) = 0. Para outros valores

de a temos:

• a = 2 ⇒ (cid:2) 2
15
• a = 4 ⇒ (cid:2) 4
15
• a = 7 ⇒ (cid:2) 7
15
• a = 8 ⇒ (cid:2) 8
15
• a = 11 ⇒ (cid:2) 11
15
• a = 13 ⇒ (cid:2) 13
15
• a = 14 ⇒ (cid:2) 14
15

(cid:3) = 1 e 27 ≡ 8 (mod 15)
(cid:3) = 1 e 47 ≡ 4 (mod 15)
(cid:3) = −1 e 77 ≡ 13 (mod 15)
(cid:3) = 1 e 87 ≡ 2 (mod 15)
(cid:3) = −1 e 117 ≡ 11 (mod 15)
(cid:3) = −1 e 137 ≡ 7 (mod 15)
(cid:3) = −1 e 147 ≡ 14 (mod 15)

Assim, o algoritmo retorna PRIMO apenas para a = 14, ou seja, a probabilidade de identiﬁcar

o número 15 como COMPOSTO é 12

13 (cid:39) 92, 3%.

44

O ponto principal do teste é a

n−1

2 ≡ (cid:0) a
n

(cid:1) (mod n) falha para algum a relativamente

primo com n. Pela Proposição 5.1.2, temos que a probabilidade de erro é 0% se n é um número

primo e menos de 50% se n é um número composto. Assim, quando o algoritmo retorna

COMPOST O o número é realmente composto, mas quando tem como resposta PRIMO existe a

possibilidade de ser composto.

Dessa forma, para que tenhamos um maior percentual de acerto devemos executar o

teste um k número de vezes. Sendo assim, quando o algoritmo retornar PRIMO a probabilidade

de veracidade será de pelo menos 1 − 1
2k .

Apesar de ser bastante eﬁciente este teste sempre fornece uma primalidade relativa,

mesmo que a probabilidade seja alta (aproximadamente 99, 9% para k = 10), ou seja, há casos

em que um número composto é declarado primo.

5.2 Miller-Rabin

Desenvolvido por Gary Lee Miller e Michael Oser Rabin utilizando os conceitos

de congruência e o Pequeno Teorema de Fermat. Originalmente era um teste determinístico,

supondo verdadeira a Hipótese de Riemann Estendida, sendo posteriormente transformado em

um algoritmo probabilístico.

Teorema 5.2.1. Seja n um primo ímpar tal que n − 1 = 2wm, onde 2w é a maior potência de 2 em

n−1. Dado a um inteiro tal que (a, n) = 1, então am ≡ 1 (mod n) ou existe r ∈ {0, 1, 2, ..., w−1}
tal que a2rm ≡ −1 (mod n).

Prova: Considere a sequência de potências (módulo n): am, a2m, a22m, ..., a2w−1m, a2wm. Se n
é um número primo, usando o Corolário 2.3.1 temos a2wm = an− ≡ 1 (mod n), ou seja, pelo

menos uma das potências acima é congruente a 1 módulo n.
Seja s ≥ 1 o menor expoente tal que a2sm ≡ 1 (mod n), temos:
a2sm − 1 = (a2s−1m − 1)(a2s−1m + 1) ⇒ n | a2s−1m − 1 ou a2s−1m + 1
Sendo s o menor expoente tal que a2sm − 1 é divisível n, então a2s−1m − 1 não é divisível por n.
Portanto, n | a2s−1m + 1 ⇒ a2s−1m ≡ −1 mod n ⇒ a2rm ≡ −1 mod n.

Proposição 5.2.2. Seja n um inteiro ímpar composto, o conjunto {1, 2, ..., n − 1} tem no máximo

n−1
4 números que são primos com n, mas não identiﬁcam n como composto no Teorema 5.2.1.

45

Prova: Sendo n − 1 = 2wm e particionando {1, 2, ..., n − 1} nos conjuntos X,Y, Z1, Z2, ..., Zw

deﬁnidos da seguinte forma:

• x ∈ X, se (x, n) (cid:54)= 1;

• x ∈ Y , se xm ≡ 1 (mod n);
• x ∈ Z j, se x2 jm ≡ 1 (mod n) e x2 j−1m (cid:54)≡ 1 (mod n) onde 1 ≤ j ≤ w;

Supondo n um número de Carmichael e n = p1 p2...pk a fatoração em primos de n, pelo Lema

2.3.3 temos k ≥ 3 e p1 p2...pk são todos distintos. De acordo com o Teorema Chinês dos Restos,

escolher um número x ∈ {1, 2, ..., n − 1} − X equivale a escolher xi ∈ {1, 2, ..., pi − 1} para cada
i = 1, 2, ..., k. O número x pertence a Y se, e somente, xm
i ≡ 1 (mod pi) para todo i. Sendo Ai o
conjunto de todos os inteiros u tal que para y ∈ {1, 2, ..., pi − 1} temos yu ≡ 1 (mod pi). Este
conjunto é fechado para adição e subtração, consequentemente é igual a dZ para algum d. Além

disso, pelo Pequeno Teorema de Fermat temos que pi − 1 ∈ Ai e o Lema 2.3.2 assegura que

(cid:1)k

Ai não contém nenhum número entre 0 e pi − 1, entao Ai = {pi − 1} ⇒ m (cid:54)∈ Ai. Assim, pelo
menos um y ∈ {1, 2, ..., pi − 1} satisfaz ym (cid:54)≡ 1 (mod pi) e no máximo metade dos elementos
de {1, 2, ..., pi − 1} veriﬁca ym ≡ 1 (mod pi) (Lema 2.2.3). Quando escolhemos ao acaso, para
cada i = 1, 2, ..., k, a probabilidade de cada um destes números xi satisfazerem xm
no máximo (cid:0) 1
8 , pois k ≤ 3.
2
Assim, aprobabilidade de que um aleatório x ∈ {1, 2, ..., n − 1} − X pertença a Y é no máximo 1
8 ,
logo |Y | ≤ n−1
8 .
Representando x ∈ Z j como uma k-tupla de números xi ∈ {1, 2, ..., pi − 1} temos x2 jm
(mod pi) que implica x2 j−1m
cia de k sinais (+/-), onde i-ésimo será + ou - de acordo com x2 j−1m

i ≡ 1
≡ ±1 (mod pi), então podemos associar a cada x ∈ Z j uma sequên-

, que é menor ou igual a 1

≡ +1 ou −1 (mod pi). Um

i ≡ (mod pi) é

i

i

elemento x ∈ Z j não é testemunha de Miller-Rabin se, e somente se, a sequência de sinais é
(−, −, ..., −), isto implica que cada uma das congruências y2 j−1m ≡ −1 (mod pi)(1 ≤ i ≤ k)

tem uma solução yi. Seja vi um elemento de {1, 2, ..., n − 1} tal que vi ≡ yi (mod pi) e vi ≡
(mod pi(cid:48)) para todo i(cid:48) (cid:54)= i. Se s e s(cid:48) são duas sequências de sinais cuja diferença é apenas o
i-ésimo sinal, então podemos deﬁnir 2k − 1 possibilidade de sequências que são subconjuntos de

Z j que tem cardinalidade de |Z j|/2k − 1. Em particular, a sequência (−, −, ..., −) tem cardinalidade

|Z j|/2k − 1 ≤ |Z j|/7.
Note que, X não contém não testemunha de Miller-Rabin, |Y | ≤ n−1

8 e cada conjunto Z j tem |Z j|

7

não testemunhas. Assim,

|Y | + n−1−|Y |

7 = 6|Y |

7 + n−1

7 ≤ 6×(n−1)

7 + n−1

7 = n−1

4

.

46

Algoritmo 5.2.1: Miller-Rabin
1 início
2

m ← n − 1;
w ← 1;
enquanto m (mod 2) ≡ 0 faça

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27
28 ﬁm

m ← m/2;
w ← w + 1;

ﬁm
para i de 1 até k faça

a ← RANDOMICO({2, 3, ..., n − 1});
x ← am (mod n);
se (x (cid:54)= 1) e (x (cid:54)= n − 1) então

contador ← 0;
para j de 1 até w − 1 faça
x ← x2 (mod n);
se (x = 1) então

retorna COMPOST O;

ﬁm
se (x = n − 1) então

contador ← contador + 1;

ﬁm

ﬁm
se (contador = 0) então

retorna COMPOST O;

ﬁm

ﬁm

ﬁm
retorna PRIMO;

Exemplo 5.2.1. Mostre que n = 1729 é um número composto.

• n − 1 = 1728 = 26 × 27, então w = 6 e m = 27;

• Tomando a = 671 temos:

67127 ≡ 1084 (mod 1729)

6712.27 ≡ 10842 ≡ 1065 (mod 1729)
67122.27 ≡ 10652 ≡ 1 (mod 1729)

Assim, n é declarado composto e o teste ﬁnaliza.

47

Exemplo 5.2.2. Veriﬁque a primalidade de n = 104513.

• n − 1 = 104512 = 26 × 1633, então w = 6 e m = 1633;

• Tomando a = 3 vamos analisar as congruências (mod n):

31633 ≡ 88958 (mod 104513)

32.1633 ≡ 889582 ≡ 10430 (mod 104513)
322.1633 ≡ 104302 ≡ 91380 (mod 104513)
323.1633 ≡ 913802 ≡ 29239 (mod 104513)
324.1633 ≡ 292392 ≡ 2781 (mod 104513)
325.1633 ≡ 27812 ≡ −1 (mod 104513)

Portanto, conclui-se que n é provavelmente primo.

Observe que, se um número passa pelo teste k vezes é provável que seja primo (com

pelo menos 1 − 1

4k de probabilidade. Caso o algoritmo retorne PRIMO temos uma probabilidade
de acerto de 75% na primeira veriﬁcação. Aplicando novamente, esse percentual vai para

93, 75% chegando a 99, 9% na quinta iteração. No entanto, não podemos garantir que o número

é realmente primo.

Analisando o tempo de execução deste algoritmo vemos que são necessárias log2 n
divisões por para encontrar os valores de w e m. Usando a representação binária de n essa divisão

pode ser acelerada deslocando-se para a esquerda em vez de realizar cada operação. No entanto,

o cálculo do módulo da exponencial (linha 10) tem custo de O(log3

2 n), então para k iterações o

algoritmo terá complexidade O(k log3

2 n).

Por apresentar um custo computacional relativamente baixo e sua probabilidade

de acerto aproximar-se de 100% mais rápido que o teste de Solovay-Strassen o método de

Miller-Rabin é o mais utilizado para a determinação de números primos.

48

6 CERTIFICADO DE PRIMALIDADE

Neste capítulo, discutiremos o teste proposto por Édouard Lucas para garantir que

um dado número n é realmente primo. Apesar de ser baseado no Pequeno Teorema de Fermat,

a primalidade é garantida utilizando-se a fatoração de n − 1 que, em geral, é um problema de

difícil solução. Sendo assim, consideraremos esse mecanismo um "certiﬁcado"para números

primos, em vez de um teste determinístico.

6.1 Teste de Lucas

Teorema 6.1.1. Sejam n e a números inteiros com n > 1 e 2 ≤ a ≤ n − 1. Se an−1 ≡ 1 (mod n)

n−1
p

e a

(cid:54)≡ 1 (mod n) para cada fator p de n − 1, então n é primo.

Prova: Da primeira condição temos que ordn(a) | n − 1, pois ordn(a) é o menor número k tal que
ak ≡ 1 (mod n). Ademais, a segunda condição mostra que ordn(a) não é divisor próprio de n − 1,

logo, ordn(a) = n − 1. Pela Proposição 2.3.6 temos que ordn(a) | ϕ(n), donde ϕ(n) ≥ n − 1

e usando a Proposição 2.3.4, ϕ(n) < n − 1 quando n é composto. Assim, n é um número

primo.

O Teste de Lucas pode ser descrito pelos seguintes passos:

1. Selecionamos uma base a para realizar o teste;

2. Veriﬁcamos se an−1 ≡ 1 (mod n) é válida;

3. Analisamos se a

n−1
p

(cid:54)≡ 1 (mod n) para cada fator primo p de n − 1.

Exemplo 6.1.1. Demonstre que o número 7 é primo.

Seguindo os passos do algoritmo temos:

• Escolhendo a base: a = 2;

• an−1 ≡ 1 (mod n): 26 = (23)2 ≡ 1 (mod 7), pois 8 ≡ 1 (mod 7);

n−1
p

• a

(cid:54)≡ 1 (mod n): Fatorando n − 1 = 6 = 2 × 3. Vamos veriﬁcar os 2 fatores primos:

- p = 2: 2

6

2 = 23 = 8 ≡ 1 (mod 7), a condição falhou.

• Note que, o objetivo do teste é encontrar uma base que valide os itens do algoritmo.

Portanto, vamos escolher uma nova base.

• Escolhendo a base: a = 3;

• an−1 ≡ 1 (mod n): 36 = (33)2 ≡ 1 (mod 7), pois 27 ≡ −1 (mod 7);

• Testando a

n−1
p

(cid:54)≡ 1 (mod n) para cada fator:

49

- p = 2: 3

6

2 = 33 = 27 ≡ −1 (cid:54)≡ 1 (mod 7)

- p = 3: 3

6

3 = 32 = 9 ≡ 2 (cid:54)≡ 1 (mod 7)

Assim, podemos aﬁrmar que 7 é um número primo, pois todas etapas do teste foram veriﬁcadas.

Exemplo 6.1.2. Veriﬁque que 41 é um número primo.

Fatorando n − 1 = 40 = 23 × 5 devemos encontrar 2 ≤ a ≤ 40 tal que:

• a40 ≡ 1 (mod 41)

• a20 (cid:54)≡ 1 (mod 41)

• a8 (cid:54)≡ 1 (mod 41)

Mas 220 ≡ 1 (mod 41), 38 ≡ 1 (mod 41), 420 ≡ 1 (mod 41) e 520 ≡ 1 (mod 41). Assim, uma

base possível é a = 6.

Uma grande vantagem do teste em questão é a possibilidade de veriﬁcar a validade

do caráter primo de um número retornado por um algoritmo.

50

7 CONCLUSÃO

Para que possamos compreender as vantagens e desvantagens de um teste em relação

a outro, vamos realizar uma análise comparativa entre os diversos algoritmos de identiﬁcação de

números primos apresentados nesta pesquisa. Nesta tarefa, usaremos apenas primos de Mersenne

para que sejam aplicados todos os métodos discutidos.

Vamos supor um computador que execute 109 operações por segundo (uma operação

a cada nanossegundo) para que possamos determinar o tempo dispendido por cada teste.

Ademais, para que tenhamos probabilidades semelhantes nos algoritmos Solovay-

Strassen e Miller-Rabin usaremos k = 10 e k = 5, respectivamente.

Tabela 7.0.1 – Tempo gasto por cada algoritmo no teste de primalidade

ALGORITMO

COMPLEXIDADE n = 25 − 1 = 31

n = 213 − 1 = 8191

n = 231 − 1 = 2147483647

Divisão Sucessiva

Teorema de Wilson

AKS

Lucas-Lehmer

Solovay-Strassen

Miller-Rabin

√

O(

n log2

2 n)

O(n log2

2 n)

21/2
O(log
2 n)
O(p2 log2 p)
O(k log3
2 n)
2 n)

O(k log3

136, 65

760, 86

15294, 78

44533652, 94

1384241, 49

2063731784677, 55

19825252, 21

496985158695, 9

4563497165980708, 95

58, 04

1215, 96

607, 98

625, 37

21969, 1

10984, 55

4760, 98

297909, 99

148954, 99

Fonte – Elaborada pelo autor

Pelos valores da tabela acima, podemos observar o bom desempenho dos algoritmos

Lucas-Lehmer, usado apenas para números de Mersenne e, Miller-Rabin, para números naturais

ímpares, uma vez que 2 (dois) é o único primo par.

Testes de primalidade e outras formas de determinar números primos são essenciais

para a Criptograﬁa, que utiliza esses números para o seu correto funcionamento. Portanto, o

estudo deste assunto contribui para o desenvolvimento de áreas como a Criptograﬁa e a Teoria

dos Números, inclusive da própria Matemática.

 REFERÊNCIAS  AGRAWAL, Manindra, KAYAL, Neeraj e SAXENA, Nitin. Primes is in P. Disponível em: <https://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf>. Acesso em: 20 mar. 2017.  ALMEIDA, Felipe Duerno do Couto. Implementação e análise de algoritmos acerca de números primos para uso em maratonas de programação. Monografia de Graduação. Brasília: UnB, 2016.  ASCENCIO, Ana Fernanda Gomes. Estruturas de dados: algoritmos, análise da complexidade e implementações em JAVA e C/C++. São Paulo: Pearson Prentice Hall, 2010.  CORMEN, Thomas H. Algoritmos: teoria e prática. 2ª Edição. Rio de Janeiro: Elsevier, 2002.  COUTINHO, S. C. Números Inteiros e Criptografia RSA. Instituto Nacional de Matemática Pura e Aplicada - IMPA, 2009.  COUTINHO, S. C. Primalidade em Tempo Polinomial: uma introdução ao algoritmo AKS. Universidade Federal do Rio de Janeiro, 2004.  HEFEZ, Abramo. Elementos de Aritmética. Textos Universitários, SBM 2006.  LEMOS, Manuel. Criptografia, Números Primos e Algoritmos. Universidade Federal de Pernambuco, 2010.  MOREIRA, Carlos Gustavo e SALDANHA, Nicolau. Primos de Mersenne (e outros primos muito grandes). 3ª Edição. Rio de Janeiro: IMPA, 1999  MARTINEZ, Fabio Brochero; et al. Teoria dos Números: um passeio com primos e outros números familiares pelo mundo inteiro. 2ª Edição. Rio de Janeiro: IMPA, 2011.  ZIVIANI, Nivio. Projeto de algoritmos com implementações em Pascal e C. 4ª Edição. São Paulo: Pioneira, 1999.     