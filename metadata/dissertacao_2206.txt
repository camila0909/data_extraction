COLÉGIO PEDRO II 

Pró-Reitoria de Pós-Graduação, Pesquisa, Extensão e Cultura 

Mestrado Profissional em Matemática em Rede Nacional 

Thiago Valladares da Silva 

CAMINHOS MÍNIMOS EM GRAFOS:  
Uma Proposta para Além da Sala de Aula 

Rio de Janeiro 
2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Thiago Valladares da Silva 

CAMINHOS MÍNIMOS EM GRAFOS:  
Uma Proposta para Além da Sala de Aula 

Dissertação  de  Mestrado  apresentada  ao 
Programa  de  Mestrado  Profissional  em 
Matemática  em  Rede  Nacional,  vinculado  à 
Pró-Reitoria  de  Pós-Graduação,  Pesquisa, 
Extensão e Cultura do Colégio Pedro II, como 
requisito  parcial  para  obtenção  do  título  de 
Mestre em Matemática. 

                              Orientador(a): Prof(a). Dra. Patrícia Erthal de Moraes 

Rio de Janeiro 
2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                       
 
                                                                       
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
COLÉGIO PEDRO II 

PRÓ-REITORIA DE PÓS-GRADUAÇÃO, PESQUISA, EXTENSÃO E CULTURA 

BIBLIOTECA PROFESSORA SILVIA BECHER  

CATALOGAÇÃO NA FONTE 

S586     Silva, Thiago Valladares da  

    Caminhos mínimos em grafos: uma proposta para além da sala de 
aula / Thiago Valladares da Silva. – Rio de Janeiro, 2018. 

                    77 f. 

         Dissertação (Mestrado Profissional em Matemática em Rede 
Nacional) – Colégio Pedro II. Pró-Reitoria de Pós-Graduação, Pesquisa, 
Extensão e Cultura. 
      Orientador: Patricia Erthal. 

                    1. Matemática – Estudo e ensino. 2. Grafo. 3. Algorítmo de Dijkstra. 
4. Algorítmo de Floyd-Warshall. I. Erthal, Patricia. II. Título.  
                                                                                                                 CDD 510 

Ficha catalográfica elaborada pelo Bibliotecário Andre Dantas – CRB7 5026 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                     
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
Thiago Valladares da Silva 

CAMINHOS MÍNIMOS EM GRAFOS 
Uma Proposta para Além da Sala de Aula 

Dissertação  de  Mestrado  apresentada  ao 
Programa  de  Mestrado  Profissional  em 
Matemática  em  Rede  Nacional,  vinculado  à 
Pró-Reitoria  de  Pós-Graduação,  Pesquisa, 
Extensão e Cultura do Colégio Pedro II, como 
requisito  parcial  para  obtenção  do  título  de 
Mestre em Matemática. 

Aprovado em: _____/_____/_____. 

Banca Examinadora: 

_________________________________________ 
Prof. Dra. Patrícia Erthal de Moraes – Colégio Pedro II 

_________________________________________ 
Prof. Dra. Christine Sertã Costa 

_________________________________________ 
Prof. Dra.  Emília Carolina Santana Teixeira Alves 

Rio de Janeiro 
2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Agradeço aos meus pais por terem feito de mim o homem que hoje sou. Se cheguei até 

aqui, devo isso a eles. 

Agradeço aos meus colegas pelas diversas vezes que estudamos, mesmo que à distância 

por intermédio de um aplicativo de mensagens instantâneas. Em especial, agradeço aos amigos 

Álvaro  Domingos,  Vinícius  Trevezzini  e  Denise  Tokuyama  pelos  diversos  momentos  de 

descontração que tivemos. A caminhada foi mais fácil por conta deles. 

Agradeço  a  todos  os  funcionários  da  PROPGEPEC  e  a  todo  corpo  docente  do 

PROFMAT/CPII, em especial ao Prof. Dr. Daniel Martins que também me incentivou a prestar 

o exame de acesso e a minha orientadora e amiga, a Prof. Dra. Patrícia Erthal, que me conduziu 

na árdua tarefa de escrever este trabalho. Meu muito obrigado a vocês. 

Agradeço à Capes pelo fomento fornecido durante o curso, sem o qual seria impossível 

conclui-lo. 

Agradeço a minha amada esposa que me incentivou a prestar a prova de acesso para o 

mestrado apesar de eu não demonstrar interesse. Agradeço a ela por ter estudado comigo diversas 

vezes, por compreender a ausência em algumas atividades devido ao tempo destinado aos estudos 

e por me dar suporte ao longo dessa jornada. Sem ela ao meu lado eu nunca teria chegado aqui. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
“Se  enxerguei  mais  longe,  foi  porque  me 
apoiei sobre ombros de gigantes. ” 

- Isaac Newton 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

SILVA, Thiago Valladares da. Caminhos Mínimos em Grafos: Uma Proposta para Além da 
Sala  de Aula.  2018.  77  f.  Dissertação  (Mestrado)  –  Colégio  Pedro  II,  Pró-Reitoria  de  Pós-
Graduação, Pesquisa, Extensão e Cultura, Programa de Mestrado Profissional em Matemática 
em Rede Nacional, Rio de Janeiro, 2018. 

O presente trabalho apresenta conceitos e resultados básicos acerca da Teoria dos Grafos e tem 
por objetivo fornecer a fundamentação teórica necessária para que o tema possa ser explorado e 
discutido com alunos do Ensino Médio. A partir da apresentação de um problema aparentemente 
simples e de fácil entendimento, O Problema de Caminho Mínimo em um Grafo, estuda-se dois 
algoritmos: o Algoritmo de Dijkstra e o Algoritmo de Floyd-Warshall. Com relação a esse último, 
é discutido um Problema de Alocação. Ao final do trabalho é apresentada uma proposta de oficina 
para alunos do Ensino Médio que tem por objetivo desenvolver os algoritmos citados ao longo 
do Trabalho, aplicando-os na resolução de um problema previamente sugerido. A intenção é que 
os  alunos,  a  partir  de  uma  situação  concreta,  construam  um  modelo  matemático  aplicando  a 
Teoria de Grafos, utilizem um algoritmo, compreendam passo a passo o seu funcionamento, para 
assim obterem uma solução desejada. 

Palavras-chave:  Grafo.  Problema de Caminho  Mínimo. Algoritmo de  Dijkstra. Algoritmo de 
Floyd-Warshall. 

 
 
 
 
 
 
ABSTRACT 

SILVA, Thiago Valladares da. Caminhos Mínimos em Grafos: Uma Proposta para Além da 
Sala de Aula. 77 f. Dissertação (Mestrado) – Colégio Pedro II, Pró-Reitoria de Pós-Graduação, 
Pesquisa,  Extensão  e  Cultura.  Programa  de  Mestrado  Profissional  em  Matemática  em  Rede 
Nacional, Rio de Janeiro, 2018. 

This  study  presents  concepts  and  basic  results  on  the  Graph Theory.  Its  main  objective  is  to 
provide the necessary theoretical basis so that the theme can be explored and discussed with High 
School students. Starting from the presentation of an apparently simple and easily understandable 
problem, the Shortest Path in a Graph problem, we study two algorithms: the Dijkstra Algorithm 
and the Floyd-Warshall Algorithm. Concerning the latter, it is discussed the Allocation Problem. 
By the end of the study, it is presented a proposition of a workshop for High School students, 
which aims to develop the algorithms cited throughout the study, applying them to the solution 
of a previoulsy suggested problem. The intention is that the students, starting from a concrete 
situation,  construct  a  mathematical  model  applying  the  Graph  Theory,  use  an  algorithm, 
understand each step of its operation, in order to obtain the desired solution. 

Keywords: Graph. Short Path Problem. Dijkstra Algorithm. Floyd-Warshall Algorithm. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÁRIO 

1 INTRODUÇÃO .................................................................................................................... 10 

2 TEORIA DOS GRAFOS ..................................................................................................... 12 

2.1 Resumo Histórico .............................................................................................................. 12 

2.2 Definições e Conceitos acerca da Teoria dos Grafos ........................................................ 15 

3 O PROBLEMA DE CAMINHO MÍNIMO EM UM GRAFO ........................................ 27 

3.1 O Algoritmo de Dijkstra ................................................................................................... 27 

3.1.1 Funcionamento do Algoritmo de Dijkstra ................................................................. 29 

3.2 O Algoritmo de Floyd-Warshall (ou Roy-Warshall) ........................................................ 34 

3.2.1 Funcionamento do Algoritmo de Floyd-Warshal ...................................................... 35 

3.2.2 Aplicações do Algoritmo de Floyd-Warshal.............................................................. 41 

4 UMA PROPOSTA PARA ALÉM DA SALA DE AULA ................................................. 44 

4.1 Tópico 1: O Problema Motivador ..................................................................................... 44 

4.2 Tópico 2: Algoritmos ........................................................................................................ 46 

4.3 Tópico 3: O Algoritmo de Dijkstra ................................................................................... 47 

4.4 Tópico 4: Aplicação do Algoritmo de Dijkstra ................................................................. 49 

4.5 Tópico 5: O Algoritmo de Floyd-Warshall ....................................................................... 55 

4.6 Tópico 6: Aplicação do Algoritmo de Floyd-Warshall ..................................................... 57 

5 CONSIDERAÇÕES FINAIS .............................................................................................. 70 

REFERÊNCIAS ...................................................................................................................... 71 

APÊNDICE A – FLUXOGRAMA DO ALGORITMO DE DIJKSTRA ........................... 72 

APÊNDICE B – PSEUDOCÓDIGO DO ALGORITMO DE DIJKSTRA ........................ 73 

APÊNDICE C – FLUXOGRAMA DO ALGORITMO DE FLOYD-WARSHAL ........... 74 

APÊNDICE D – PSEUDOCÓDIGO DO ALGORITMO DE FLOYD-WARSHALL ..... 75 

APÊNDICE F – SITUAÇÕES MOTIVADORAS PARA A INTRODUÇÃO DO CONCEITO DE 

ALGORITMOS ............................................................................................................ 76 

APÊNDICE G – RESUMO HISTÓRICO DO SURGIMENTO DOS ALGORITMOS .. 77 

 
 
1 INTRODUÇÃO 

10 

Uma busca constante de professores de matemática é a contextualização dos conteúdos 

de maneira a dar resposta a perguntas como “Onde é que usarei isso professor?” ou “Pra que 

serve  isso?”.  Por  vezes  cria-se  uma  situação  muito  artificial  para  justificar  o  ensino  de 

determinados conteúdos. De fato, há assuntos que tem pouquíssima ou nenhuma aplicação fora 

da matemática em si. Contudo, há aqueles que podem ser adaptados com relativa facilidade, de 

maneira significativa para o aluno. Neste trabalho apresentaremos um tópico que julgamos se 

encaixar no segundo grupo: a Teoria de Grafos. 

A  Teoria  dos  Grafos  é  um  assunto  que  remonta  ao  século  XVIII  e  possui  diversas 

aplicações  em  situações  reais.  Seu  conceito  foi  introduzido  pelo  matemático  suíço  Leonhard 

Euler  em  1736  para  resolver  um  problema  que  hoje  é  conhecido  como  “As  sete  pontes  de 

Köningsberg”.  Este  problema  constituiu  um  dos  primeiros  resultados  de  uma  nova  área  da 

matemática, a topologia. De maneira informal, um grafo pode ser interpretado como um conjunto 

de pontos no plano, denominado vértices, e um conjunto de segmentos, chamados de arestas, que 

conectam dois destes pontos. É possível modelar diversas situações concretas utilizando grafos, 

tais como: fluxo de dados em sistemas de computação, malha de tráfego urbano, aplicações em 

circuitos  elétricos,  modelos  de  química  orgânica,  coloração  de  mapas  entre  outras.  A 

simplicidade  desse  conceito,  a  quase  não  existência  de  pré-requisitos  necessários  para  o  seu 

entendimento e a sua vasta aplicabilidade tornam o assunto bastante atrativo para ser apresentado 

a alunos do ensino médio. 

Atribuindo valores às arestas podemos estabelecer a noção de custo de travessia entre os 

vértices de um grafo. Dependendo do problema modelado esse custo pode representar um valor 

monetário,  tempo,  fluxo  de  objetos,  distância,  entre outros.  Muitos  problemas  de  otimização, 

conhecidos  como  Problema  de  Caminhos  Mínimos,  têm  por  objetivo  minimizar  esse  custo. 

Existem diversos algoritmos utilizados para esse fim. Neste trabalho abordaremos dois deles, o 

Algoritmo de Dijkstra e o Algoritmo de Floyd-Warshall. 

A fim de introduzir o conceito de grafos para alunos do ensino médio, propomos uma 

oficina ao final deste trabalho. Nela apresentamos um problema de ordem prática que pode ser 

modelado  utilizando-se  um  grafo.  A  partir  deste  problema  é  possível  apresentar  os  conceitos 

iniciais de grafos, os algoritmos supracitados e levá-los a resolver esse problema utilizando-os. 

Essa  oficina  foi  elaborada  em  uma  sequência  de  tópicos  que  julgamos  necessários  para  tal 

 
 
 
 
 
11 

abordagem. O nosso objetivo é que, ao final da oficina, o aluno tenha desenvolvido um pouco do 

pensamento algorítmico além de ter se apropriado de um novo conceito matemático. 

Este trabalho está estruturado de modo que no capítulo 2 são estudados alguns conceitos 

introdutórios em Teoria dos Grafos bem como alguns de seus aspectos históricos. No capítulo 3 

apresentamos O Problema de Caminhos Mínimos em um Grafo e estudamos os algoritmos de 

Dijkstra e Floyd-Warshall, descrevendo em detalhes o funcionamento de cada um deles. Afim 

de aplicarmos a teoria apresentada nos capítulos anteriores, propomos, no capítulo 4, a oficina 

descrita acima. No capítulo 5 são feitas algumas considerações a respeito do trabalho como um 

todo, bem como as dificuldades apresentadas em sua elaboração. 

 
 
 
 
 
 
 
 
2 TEORIA DOS GRAFOS 

12 

Esse trabalho tem a intenção de ser o mais autocontido possível. Por conta disso foram 

elencados  alguns  conceitos  e  resultados  básicos  sobre  a  Teoria  de  Grafos  que  consideramos 

necessários para a compreensão do tema. Além disso, apresentaremos um apanhado histórico de 

sua origem. 

2.1 Resumo Histórico 

Nessa  seção  será  feita  uma  abordagem  histórica  acerca  da  Teoria  de  Grafos  que  foi 

elaborada com base em Boaventura e Jurkiewicz (2009). 

O primeiro registro de um problema envolvendo grafos remonta ao séc. XVIII. No ano 

de  1736  o  matemático  suíço  Leonhard  Euler  se  encontrava  na  cidade  de  Königsberg  (hoje 

Kaliningrd, na Rússia), onde um problema aparentemente simples, mas ainda sem solução, estava 

sendo discutido pelos intelectuais do local. No rio Preguel, que cortava a cidade, havia duas ilhas 

que eram interligadas por uma ponte. Essas ilhas ainda se interligavam às margens do rio por 

mais seis pontes (ver Figura 1). O problema consistia em encontrar um caminho com início em 

uma das margens que percorresse as sete pontes, sem repetição, e terminasse no ponto de partida. 

Figura 1 –  Cidade de Königsberg 

 Fonte: http://matematicacomge.blogspot.com.br/2015/01/as-sete-pontes-de-konigsberg.html 

Utilizando uma representação simplificada do problema, onde as massas de terra eram 

representadas  por  pontos  e  as  pontes  por  linhas,  Euler  demonstrou  que  tal  percurso  era 

 
 
  
 
 
 
 
impossível. Ele notou que o número de passagens de uma margem para uma ilha, ou entre as 

ilhas, era ímpar (ver Figura 2). 

Figura 2 – Representação das pontes de Königsberg 

13 

Fonte: http://matematicacomge.blogspot.com.br/2015/01/as-sete-pontes-de-konigsberg.html 

Se  o  número  de  pontes  com  extremidade  em  uma  massa  de  terra  é  ímpar,  em  algum 

momento se chegará a ela, mas não será possível sair, pois as demais pontes já foram utilizadas. 

Euler demonstrou que o percurso só seria possível se o número de ligações entre as massas de 

terra fosse um número par.  

O esquema utilizado por Euler é uma representação gráfica do que hoje se chama de grafo 

não orientado, ou simplesmente grafo. É possível compreender um grafo como uma estrutura 

composta  por elementos  de  dois  conjuntos:  um ao  qual  chamamos  de conjunto  de  vértices,  e 

outro,  chamado  conjunto  de  arestas,  onde  descrevemos  as  relações  entre  os  vértices. 

Graficamente,  representamos  os  vértices  por  pontos  e  as  arestas  por  segmentos  de  retas  que 

possuem os vértices como extremidade. 

Euler resolveu o problema das pontes de Königsberg mas não se preocupou em estudar a 

fundo  ou  achar  alguma  aplicação  para  esse  novo  tipo  de  estrutura.  Foi  apenas  que  1847  que 

Gustav Robert Kirchhoff publicou um resultado envolvendo circuitos elétricos que utilizava um 

modelo  de  grafos.  Dez  anos  mais  tarde,  Arthur  Cayley  utilizou  um  modelo  de  grafo  para 

determinar o número de isômeros diferentes de um hidrocarboneto com cadeia aberta.  

Francis  Guthrie  também  se  deparou  com  grafos  ao  analisar  um  suposto  fato  sobre 

coloração de mapas. Era de conhecimento de todos os cartógrafos da época que quatro  cores 

eram suficientes para colorir qualquer mapa. Guthrie enunciou esse “fato” como um teorema e 

tentou prova-lo utilizando grafos. Apesar de seus esforços, Guthrie não logrou êxito, e o teorema, 

que ficou conhecido como “problema das quatro cores”, ficou em aberto por mais de um século. 

 
 
 
 
 
 
Somente  em  1976,  com  o  uso  de  computadores  que  Kenneth  Appel e Wolfgang  Haken, 

demonstraram o teorema. 

A Teoria de Grafos se desenvolveu com mais intensidade a partir de 1950 com o advento 

da computação, como explica Boaventura e Jurkiewicz (2009, p. 5): 

14 

A  partir  da  década  de  1950  a  pesquisa  operacional  (...)  começou  a  utilizar 
intensamente  os  modelos  de  grafo  em  busca  de  melhores  soluções  para 
problemas de projeto, organização e distribuição. Essas aplicações, viabilizadas 
pela invenção do computador, promoveram uma grande divulgação desse tipo 
de modelagem (...). 

A  modelagem  de  problemas  por  grafos  é  empregada  hoje  em  diversos  campos  como 

gestão de recursos, planejamento de transportes, projetos de processadores eletrônicos, estudo de 

estrutura de DNA, otimização de recursos humanos, entre outros.  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
2.2 Definições e Conceitos acerca da Teoria dos Grafos 

15 

Nesta  seção  elencaremos  alguns  conceitos  e  definições  acerca  da  Teoria  de  Grafos. 

Utilizamos  como  base  para  esse  texto:  BOAVENTURA  (2009),  SCHEINERMAN  (2011)  e 

DIESTEL (2000). 

Definição 2.1: Um grafo não orientado, ou simplesmente um grafo, é um par 𝐺 = (𝑉, 𝐸), onde 

𝑉 é um conjunto finito e 𝐸 é um conjunto de subconjuntos de dois elementos de 𝑉. Os elementos 

de 𝑉 são chamados de vértices do grafo e os elementos de 𝐸 são as arestas do grafo que possuem 

como extremidades os vértices pertencentes a esse subconjunto de dois elementos. 

Para um grafo de 𝑛 vértices adotaremos 𝑉 = {1,2, … , 𝑛}, 𝑛 ∈ ℕ. 

Exemplo 2.1: Seja 𝐺 = (𝑉, 𝐸), onde 𝑉 = {1,2,3,4,5,6} e 𝐸 = {{1,2}, {2,4}, {4,5}, {1,6}, {4,6}, {5,6}}. 

De acordo com a definição 2.1, 𝐺 é um grafo pois 𝑉 é finito e 𝐸 é um conjunto de subconjuntos 

de  𝑉.  Nesse  exemplo,  o  grafo  possui  seis  vértices  e  seis  arestas.  Como  se  pode  imaginar,  é 

possível representar esse grafo por meio de uma figura. Para tanto assinalamos seis pontos no 

plano  e  os  rotulamos  de  1  a  6.  Para  cada  aresta  𝑒 = {𝑖, 𝑗} ∈ 𝐸  assinalamos  uma  curva  com 

extremos em 𝑖 e 𝑗. A figura a seguir representa três diagramas para o mesmo grafo do exemplo 

2.1. 

Figura 3 – Grafos 

Fonte: O autor, 2018 

No terceiro diagrama, o fato das linhas se cruzarem não constituem problema, pois a informação 

transmitida pelo desenho (vértices e ligações entre eles) não se altera. Contudo, os cruzamentos 

podem tornar a leitura do grafo um pouco mais difícil. 

Definição 2.2: Seja 𝐺 = (𝑉, 𝐸) um grafo e 𝑖, 𝑗 ∈ 𝑉. Dizemos que 𝑖 é adjacente a 𝑗 se, e somente 

se, existe {𝑖, 𝑗} ∈ 𝐸. A notação 𝑖~𝑗 significa que 𝑖 é adjacente a 𝑗. 

 
 
 
 
 
 
 
Definição 2.3 (Isomorfismo): Dois grafos  𝐺 = (𝑉, 𝐸) e 𝐺′ = (𝑉′, 𝐸′) são isomorfos se existe 

uma bijeção 𝜑: 𝑉 → 𝑉′ que preserva a adjacência dos vértices, isto é, se a aresta (𝑖, 𝑗) ∈ 𝐸 então, 

a aresta (𝜑(𝑖), 𝜑(𝑗)) ∈ 𝐸′. Escrevemos 𝐺 ≅ 𝐺′ para indicar que os grafos 𝐺 e 𝐺′ são isomorfos. 

16 

Exemplo 1: Considere os grafos da Figura 4. 

Figura 4 – Grafos Isomorfos 

𝐺 e 𝐺′ são isomorfos e a função que garante esse isomorfismo é 

Fonte: O autor, 2018 

𝜑: 𝑉 → 𝑉(cid:4593) 

𝑘 → 𝑘 

onde 𝑘 ∈ {1,2,3,4,5}. 

Definição 2.4 (Digrafo): Um grafo orientado, ou digrafo, é um par 𝐺 = (𝑉, 𝐸), onde 𝑉 é um 

conjunto finito e 𝐸 é o conjunto de pares ordenados (𝑖, 𝑗), com 𝑖, 𝑗 ∈ 𝑉. 

Apesar  da  semelhança  dessa  definição  com  a  Definição  2.1,  a  situação  é  completamente 

diferente.  Num  grafo  não  orientado,  se  existe  uma  aresta  unindo  dois  vértices  𝑖  e  𝑗  dizemos 

indistintamente que 𝑖~𝑗 e que 𝑗~𝑖. Em um grafo orientado, o par (𝑖, 𝑗) indica apenas que 𝑖~𝑗. 

Em outras palavras: a relação de adjacência não se dá nos dois sentidos. Para representar o sentido 

da relação graficamente orientamos as arestas por meio de setas. Veja o exemplo a seguir. 

Exemplo  2.2:  Sejam  𝑉 = {1,2,3,4,5,6}  e  𝐸 = {(1,2),(2,4),(4,5),(1,6),(4,6),(5,6)}  e  o  par  𝐺 =

(𝑉, 𝐸). Uma representação desse grafo pode ser vista na Figura 5. 

Figura 5 – Digrafo 

Fonte: O autor, 2018 

 
 
 
 
 
 
Definição 2.5 (Vizinhança e Grau de um Vértice): Dado um grafo 𝐺 = (𝑉, 𝐸) e 𝑖 ∈ 𝑉 chama-

se vizinhança de 𝑖, e denotamos por 𝑁(𝑖), o conjunto de todos os vértices que são adjacentes a 𝑖. 

17 

Isto é, 

Para o grafo do Exemplo 2.1, temos 

𝑁(𝑖) = {𝑗 ∈ 𝑉|𝑖~𝑗} 

𝑁(1) = {2,6}    𝑁(2) = {1,4}    𝑁(3) = ∅    

𝑁(4) = {2,5,6}    𝑁(5) = {4,6}     𝑁(6) = {1,4,5} 

Para o Exemplo 2.2, temos 

𝑁(1) = {2,6}    𝑁(2) = {4}    𝑁(3) = ∅    

𝑁(4) = {5,6}    𝑁(5) = {6}     𝑁(6) = ∅  

O grau de um vértice 𝑣, denotado por 𝑑𝑒𝑔(𝑖), é o número de vértices adjacentes a 𝑣, ou seja, 

Para o grafo do Exemplo 2.1, temos 

𝑑𝑒𝑔(𝑖) = |𝑁(𝑖)| 

𝑑𝑒𝑔(1) = 2     𝑑𝑒𝑔(2) = 2     𝑑𝑒𝑔(3) = 0     𝑑𝑒𝑔(4) = 3     𝑑𝑒𝑔(5) = 2     𝑑𝑒𝑔(6) = 3. 

O resultado a seguir relaciona os graus dos vértices ao número de arestas do grafo. 

Teorema 2.1: A soma dos graus dos vértices de um grafo é igual ao dobro do número de arestas 

desse grafo. Ou seja: 

(cid:3041)

(cid:3533) 𝑑𝑒𝑔(

𝑖) = 2. |𝐸| 

(cid:3036)(cid:2880)(cid:2869)

Demonstração. Como cada aresta de um grafo incide em dois vértices distintos, ao somarmos os 

graus  dos  vértices  estaremos  contando  a  mesma  aresta  em  dois  momentos,  de  onde  segue  a 

verificação do teorema. 

Corolário 2.1: Todo grafo 𝐺 possui um número par de vértices de grau ímpar. 

Demonstração: Seja G um grafo. Suponha por absurdo que o número de vértices de grau ímpar 

seja ímpar. Dessa forma, a soma dos graus desses vértices será um número ímpar 𝐼. Por outro 

lado, a soma dos graus dos vértices de grau par sempre será par. Seja 𝑃 esse valor. Logo a soma 

 
 
 
 
 
 
 
 
 
dos graus de todos os vértices será 𝐼 + 𝑃, que é um número ímpar. Absurdo, pois o Teorema 2.1 

garante que a soma dos graus é o dobro do número de arestas, portanto, um número par. 

18 

Definição  2.6  (Arestas  Paralelas  e  Multigrafo):  Duas  arestas  distintas  de  um  grafo  𝐺  são 

paralelas se possuírem os mesmos extremos. Um grafo que possui pelo menos um par de arestas 

paralelas é chamado de multigrafo, conforme a Figura 6. 

Figura 6 – Grafo com arestas paralelas 𝑒(cid:2869) e 𝑒(cid:2870) 

Fonte: O autor, 2018 

Definição 2.7 (Laço): Chama-se laço a aresta que liga um vértice a ele mesmo, conforme Figura 

7. 

Figura 7 –  Grafo com um laço 

Fonte: O autor, 2018 

Grafos que não possuem arestas paralelas nem laços são chamados de grafos simples. 

Definição 2.8 (Grafo Ponderado ou Valorado): Um grafo é dito ponderado, ou simplesmente 

valorado, quando a cada uma de suas arestas é atribuído um valor chamado de peso. Geralmente 

esse valor está associado ao custo da ligação entre os vértices. 

 
 
 
 
 
 
 
Exemplo 2.3: Podemos atribuir pesos ao grafo do exemplo 2.2, conforme a Figura 8. 

Figura 8 – Grafos Valorados 

19 

Fonte: O autor, 2018 

Definição 2.9 (Matriz de Adjacência de um Grafo): Dados um grafo 𝐺 = (𝑉, 𝐸), e 𝑖, 𝑗 ∈ 𝑉, 

chama-se matriz de adjacência de 𝐺, denotado por 𝐴(cid:3008), à matriz 

𝐴(cid:3008) = 𝑎(cid:3036)(cid:3037) = (cid:3420)

1, 𝑠𝑒 𝑖~𝑗 
0, 𝑠𝑒 𝑖 ≁ 𝑗

Essa definição nos diz que é possível organizar a informação das adjacências dos vértices de um 

grafo em uma matriz onde as entradas são apenas 0 ou 1. Se o vértice 𝑖 é adjacente ao vértice 𝑗 

temos  que  𝑎(cid:3036)(cid:3037) = 1,  caso  contrário  𝑎(cid:3036)(cid:3037) = 0.  Para  grafos  não  orientados,  𝐴(cid:3008) será  uma  matriz 

simétrica, uma vez que 𝑖~𝑗 implica que j~𝑖. 

Exemplo 2.4: Para os grafos dos exemplos 2.1 e 2.2 temos, respectivamente, as matrizes 

0 1 0 0 0 1
⎤
⎡
1 0 0 1 0 0
⎥
⎢
0 0 0 0 0 0
⎥
⎢
0 1 0 0 1 1
⎥
⎢
⎥
⎢
0 0 0 1 0 1
1 0 0 1 1 0⎦
⎣

    𝒆    

0 1 0 0 0 1
⎤
⎡
0 0 0 1 0 0
⎥
⎢
0 0 0 0 0 0
⎥
⎢
. 
0 0 0 0 1 1
⎥
⎢
⎥
⎢
0 0 0 0 0 1
0 0 0 0 0 0⎦
⎣

Num grafo valorado há uma outra matriz bastante utilizada chamada matriz dos pesos 

𝑃 = [𝑝(cid:3036)(cid:3037)], definida como 

𝑝(cid:3036)(cid:3037) = (cid:3420)

0, se não existe a aresta (𝑖, 𝑗)
𝑘, onde k é o peso da aresta (𝑖, 𝑗)

As matrizes de pesos dos grafos representados na Figura 8 são 

8 0 0 0 13
0
⎤
⎡
0
0 0 7 0
8
⎥
⎢
0
0 0 0 0
0
⎥
⎢
5
7 0 0 1
0
⎥
⎢
⎥
⎢
4
0 0 1 0
0
0 ⎦
⎣
13 0 0 5 4

    𝒆    

0
0
0

3
0 17 0 0
⎤
⎡
0
0 4
0
⎥
⎢
0
0 0
0
⎥
⎢
. 
0 0 15 2
0
⎥
⎢
⎥
⎢
1
0 0
0
0⎦
⎣
0 0
0

0
0
0
0
0

0
0

 
 
 
 
 
 
 
 
20 

A  matriz  de  adjacência  armazena  a  informação  de  adjacência  relacionando  vértice  a 

vértice. Também podemos armazenar essa informação relacionando arestas a vértices por meio 

de uma matriz, chamada matriz de incidência. Vejamos a definição. 

Definição 2.10 (Matriz de Incidência): Chama-se matriz de incidência do grafo 𝐺 = (𝑉, 𝐸), à 

matriz 𝐵 = [𝑏(cid:3036)(cid:3037)](cid:3040)×(cid:3041), onde 𝑚 é o número de vértices e 𝑛 é o número de arestas 𝐺, e 

𝑏(cid:3036)(cid:3037) = (cid:3420)

1, se a aresta j possui o vértice i como extremidade        
. 
0, se a aresta j não possui o vértice i como extremidade

A Figura 9 ilustra um exemplo.  

Figura 9 – Grafos 𝐺 e sua matriz de incidência 

Fonte: O autor, 2018 

Cada coluna dessa matriz representa uma aresta e conterá apenas dois elementos 1, uma 

vez que uma aresta contém apenas dois extremos. As linhas em que esses elementos se encontram 

indicam quais vértices são extremos dessa aresta. Caso o grafo seja orientado, o vértice-origem 

do arco é identificado com −1 e o vértice-fim com +1, como mostra a Figura 10. 

Figura 10 – Grafos orientado e sua matriz de incidência 

Fonte: O autor, 2018 

 
 
 
 
 
 
 
 
21 

Definição 2.11 (Percurso ou Passeio): Chama-se percurso ou passeio num grafo 𝐺 = (𝑉, 𝐸) a 

uma sequência formada por elementos de 𝑉 e de 𝐸, alternadamente 

(𝑖(cid:2869), 𝑒(cid:2869), 𝑖(cid:2870), 𝑒(cid:2870), … , , 𝑖(cid:3041)(cid:2879)(cid:2869), 𝑒(cid:3041)(cid:2879)(cid:2869), 𝑖(cid:3041)) 

de modo que 𝑒(cid:3038) = {𝑖(cid:3038), 𝑖(cid:3038)(cid:2878)(cid:2869)}, 𝑘 = 1, … , 𝑛 − 1. Em outras palavras, um percurso é determinado 

por uma coleção de vértices sucessivamente adjacentes.  

Considere o grafo da Figura 3. Nomeamos as arestas para descrever um percurso. 

Figura 11 – Descrição de percursos 

Fonte: O autor, 2018 

Podemos  destacar,  por  exemplo,  o  passeio  𝜃(cid:2869) = (4, 𝑒(cid:2874), 6, 𝑒(cid:2873), 1, 𝑒(cid:2869), 2, 𝑒(cid:2870), 4, 𝑒(cid:2871), 5).  Note 

que é possível repetir vértices. Quando o vértice inicial coincide com o vértice final temos um 

passeio fechado. O passeio 𝜃(cid:2870) = (4, 𝑒(cid:2874), 6, 𝑒(cid:2872), 5, 𝑒(cid:2871), 4) é fechado. O comprimento de um passeio 

num grafo não ponderado é igual ao número de arestas que ele possui. Em um grafo ponderado, 

o comprimento de um passeio é igual a soma dos pesos das arestas que esse passeio possui. 

Vejamos  agora  mais  algumas  definições  obtidas  quando  alguma  restrição  é  feita  ao 

passeio. 

Definição  2.12  (Trilha  ou  Cadeia):  Chama-se  trilha  ou  cadeia  ao  passeio  em  que  não  há 

repetição de arestas. 

O percurso 𝜃(cid:2869), por exemplo, é uma trilha. Note que não há repetição de arestas (apesar 

do vértice 4 se repetir). 

Definição 2.13 (Caminho): Um caminho é uma trilha que em que não há repetição de vértices. 

O percurso 𝜃(cid:2871) = (4, 𝑒(cid:2870), 2, 𝑒(cid:2869), 1, 𝑒(cid:2873), 6), por exemplo, é um caminho. 

Definição 2.14 (Ciclo): Um ciclo é um passeio fechado sem repetição de arestas e sem repetição 

de vértices a menos do inicial e do final. Por exemplo, o percurso fechado 𝜃(cid:2870) também é um ciclo. 

Num grafo ponderado, um ciclo é dito negativo se a soma das arestas que o compõe resultar num  

número negativo. 

 
 
 
 
 
 
 
 
 
 
22 

Se existe um caminho ligando 𝑖 a 𝑗, partindo de 𝑖, dizemos que 𝑗 é atingível a partir de  𝑖.  

Definição 2.15 (Fecho Transitivo): Num grafo não orientado 𝐺 = (𝑉, 𝐸), o fecho transitivo de 

um vértice 𝑖 em 𝐺, denotado por 𝑅(𝑖), é o conjunto de todos os vértices que são atingíveis a partir 

de 𝑖. 

Caso o grafo seja orientado haverá dois tipos desses fechos: 

Fecho Transitivo Direto: Seja 𝑖 um vértice de 𝐺. O conjunto de todos os vértices atingíveis a 

partir de 𝑖, denotado por 𝑅(cid:2878)(𝑖), é chamado fecho transitivo direto. Os elementos de 𝑅(cid:2878)(𝑖) são 

chamados de descendentes de 𝑖. 

Fecho Transitivo Inverso: Seja 𝑖 um vértice de 𝐺. O conjunto de todos os vértices 𝑗 para os quais 

𝑖 é atingível a partir de 𝑗, denotado por 𝑅(cid:2879)(𝑖), é chamado fecho transitivo inverso. Os elementos 

de 𝑅(cid:2879)(𝑖) são chamados de ascendentes de 𝑖. 

Definiremos  a  seguir  um  conceito  muito  importante  em  teria  dos  grafos  chamado 

conexidade.  Esse  conceito  classifica  os  grafos  de acordo  com  as  ligações  entre  seus  vértices. 

Vamos a ele. 

Definição 2.16 (Conexidade): Um grafo não orientado é dito conexo se existe um caminho que 

une dois vértices quaisquer desse grafo. Um grafo que não possui essa propriedade é chamado 

de desconexo. A Figura 12 ilustra um exemplo. 

Figura 12 – Grafo conexo 𝐺(cid:2869) e grafo desconexo 𝐺(cid:2870) 

Observe o grafo orientado apresentado na Figura 13. 

Fonte: O autor, 2018 

Figura 13 – Grafo 𝐺 

Fonte: O autor, 2018 

 
 
 
 
 
 
 
23 

Se escolhermos dois vértices quaisquer neste exemplo, sempre existe um caminho que os 

une. Contudo, esse caminho não ocorre nos dois sentidos. Tome por exemplo os vértices 6 e 4. 

Existem um caminho que une 6 a 4, mas não existe nenhum que une 4 a 6 (pois 4 só recebe 

arcos). Precisamos então estender a definição para grafos orientados. 

Para um grafo orientado, temos as seguintes classificações com relação a conexidade: não 

conexo, simplesmente conexo, semi-fortemente conexo e fortemente conexo.  Vamos a elas. 

Seja G um grafo orientado. 

  𝐺 é não conexo se, desconsiderando a orientação, existe pelo menos um par de vértices que 

não é ligado por nenhum tipo de caminho.  

  𝐺  é  simplesmente  conexo  se,  desconsiderando  a  orientação,  existem  caminhos  ligando 

quaisquer par de vértices.  

  𝐺 é dito semi-fortemente conexo se, para quaisquer vértices 𝑢 e 𝑣 existir um caminho de 𝑢 

até 𝑣 ou de 𝑣 até 𝑢. O grafo da figura 10 é desse tipo. 

  𝐺 é fortemente conexo se, para todo par de vértices 𝑢 e 𝑣, existe um caminho de 𝑢 até 𝑣 e 

existe um caminho de 𝑣 até 𝑢. Na figura abaixo mostramos alguns exemplos. 

Figura 14 – Grafo desconexo, simplesmente conexo e fortemente conexo 

Enunciaremos  agora  um  teorema  que  garante  a  conexidade  num  grafo  simples  não 

Fonte: O autor, 2018 

orientado. 

Teorema  2.2:  Seja  𝐺 = (𝑉, 𝐸)  um  grafo  com  𝑛  vértices.  Se  𝑑𝑒𝑔(𝑣) ≥

então 𝐺 é conexo. 

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

  para  todo  𝑣 ∈ 𝑉, 

Demonstração:  Suponha  por  absurdo  que  𝐺  seja  desconexo.  Então  existem  pelo  menos  dois 

vértices 𝑢, 𝑣 ∈ 𝑉 que não estão conectados. De cada um destes vértices partem pelo menos 

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

arestas, os conectando a pelo menos 

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

 vértices distintos como mostra a Figura 15. 

 
 
 
 
 
 
 
 
 
 
Figura 15 – Vértices adjacentes a 𝑢 e vértices adjacentes a 𝑣 

24 

Como  𝑢  e  𝑣  não  estão  conectados  𝑁(𝑢) ∩ 𝑁(𝑣) = ∅.  Observando  a  figura  12,  temos  que  𝐺 

Fonte: O autor, 2018 

possui, no mínimo, 2 + 2 ∙ (cid:4672)

(cid:3041)(cid:2879)(cid:2869)

(cid:2870)

(cid:4673) = 𝑛 + 1 vértices, o que é um absurdo. Logo, 𝐺 é conexo. 

Definição 2.17 (Subgrafo): Considere os grafos 𝐺 = (𝑉, 𝐸) e 𝐺′ = (𝑉′, 𝐸′). Se 𝐺′ é tal que 𝑉′ ⊆

𝑉 e 𝐸′ ⊆ 𝐸 dizemos que que 𝐺′ é um subgrafo de 𝐺 e 𝐺′ ⊆ 𝐺.  

Naturalmente, um grafo é subgrafo de si próprio. Informalmente dizemos que 𝐺 contém 

𝐺′. 𝐺 é chamado de supergrafo de 𝐺′. A figura 5 mostra um grafo e alguns exemplos de subgrafo. 

Figura 16 – Grafo 𝐺 e alguns subgrafos. 

Fonte: O autor, 2018 

O subgrafo 𝐺′ e 𝐺′′ são conexos. O primeiro é obtido pela eliminação da aresta {2,5} enquanto 

o segundo é obtido pela deleção dos vértices 3 e 4 e todas as arestas que neles incidem. Já 𝐺′′′ é 

desconexo e foi obtido pela supressão do vértice 2 e suas arestas. Um vértice pode ter todas as 

suas  arestas  deletadas  e  ser  mantido.  O  subgrafo  resultante  terá  um  vértice  isolado  e  será 

desconexo. 

Mostraremos agora que o problema inicial do passeio pela cidade de Koningsberg 

não possui solução. Mas primeiro definiremos Trilha Euleriana e Grafo Euleriano. 

Definição 2.18 (Trilha Euleriana e Grafo Euleriano): Uma trilha fechada é dita Euleriana se 

atravessa todas as arestas do grafo. Um grafo é dito Euleriano se possui uma Trilha Euleriana. 

 
 
 
 
 
 
25 

Teorema  2.3  (Caracterização  de  Grafos  Eulerianos):  Um  grafo  conexo  é  Euleriano  se,  e 

somente se, cada um de seus vértices possui grau par. 

Demonstração: 

(⇒) Se um grafo possui uma trilha euleriana, significa que, para percorrer todas as arestas, a 

trilha “entrou” e “saiu” pelo menos uma vez de cada vértice. Logo, todos os vértices têm grau 

par. 

(⇐) Seja 𝐺 um grafo conexo onde os graus de todos os vértices sejam pares e seja 

𝑇 = (𝑖(cid:2869), 𝑒(cid:2869), 𝑖(cid:2870), 𝑒(cid:2870), … , 𝑖(cid:3041)(cid:2879)(cid:2869), 𝑒(cid:3041)(cid:2879)(cid:2869), 𝑖(cid:3041)) 

a trilha de maior comprimento em 𝐺. Como 𝑇 não pode ser estendido, ele contém todas as arestas 

incidentes em 𝑖(cid:2869) e 𝑖(cid:3041). Por hipótese, o número de arestas é par. Logo, devemos ter forçosamente 

𝑖(cid:2869) = 𝑖(cid:3041) e 𝑇 é uma trilha fechada. Suponha que 𝑇 não seja uma trilha euleriana. Então 𝐺 possui 

uma aresta 𝑒 fora de 𝑇 mas incidente em um vértice de 𝑇, uma vez que 𝐺 é conexo. Sem perda 

de generalidade seja 𝑒 = {𝑢, 𝑖(cid:2870)}. Então o passeio 

possui comprimento maior do que 𝑇. Absurdo. 

𝑇′ = (𝑢, 𝑒, 𝑖(cid:2870), 𝑒(cid:2870), … , , 𝑖(cid:3041)(cid:2879)(cid:2869), 𝑒(cid:3041)(cid:2879)(cid:2869), 𝑖(cid:3041), 𝑒(cid:2869), 𝑖(cid:2870)) 

Dessa forma fica evidente que o problema das pontes de Köningsberg, introduzido na seção 2.1, 

não possui solução, uma vez que três de seus vértices possuem graus ímpar. 

Definição 2.19 (Árvores): Uma árvore é um grafo conexo e sem ciclos. Note que uma árvore é 

um grafo simples, uma vez que arestas paralelas e laços formam ciclos. A figura abaixo mostra 

alguns exemplos de árvores. 

Figura 17 – Exemplos de árvores. 

Fonte: O autor, 2018 

A estrutura de uma árvore está presente em diversas situações do cotidiano. Ela pode ser 

usada  para  representar,  por  exemplo,  o  organograma  de  uma  empresa  ou  um  fluxograma  de 

tomada de decisão. O teorema a seguir nos dará uma maneira de caracterizar uma árvore. 

 
 
 
 
 
26 

Teorema 2.4: Um grafo 𝐺 com 𝑛 vértices é uma árvore se: 

i.  existe exatamente um caminho simples entre cada par de vértices ou; 

ii.  é conexo e possui 𝑛 − 1 arestas ou; 

iii.  é conexo e a deleção de qualquer aresta torna o grafo desconexo. 

 Demonstração: 

i) Se existe exatamente um caminho entre cada par de vértices então 𝐺 é conexo. Suponha agora 

que 𝐺 não seja uma árvore. Então, 𝐺 possui pelo menos um ciclo. Mas em todo par de vértices 

de um ciclo existem pelo menos dois caminhos, absurdo. Logo, 𝐺 é uma árvore. 

ii) A prova se dá por indução. Para 𝑛 = 1 a verificação é imediata. Suponha agora que 𝐺 seja 

uma árvore com 𝑛 vértices e 𝑛 − 1 arestas. Seja 𝐺′ o grafo obtido a partir de 𝐺 ao acrescentar 

mais um vértice 𝑣(cid:3041)(cid:2878)(cid:2869)  de grau 1 a ele. Devemos mostrar que 𝐺′ é uma árvore. De fato, o acréscimo 

de 𝑣(cid:3041)(cid:2878)(cid:2869) a 𝐺 não gera um ciclo pois 𝑣(cid:3041)(cid:2878)(cid:2869) possui grau 1 e 𝐺′ é conexo pois 𝑣(cid:3041)(cid:2878)(cid:2869) está conectado a 

𝐺 que é conexo. Logo, 𝐺′ é uma árvore, o que encerra a prova. 

iii) Suponha por absurdo que 𝐺 não seja uma árvore. Como 𝐺 é conexo e não é uma árvore há 

um  ciclo  em  𝐺.  Mas  se  há  um  ciclo  em  𝐺,  a  deleção  de  uma  aresta  neste  ciclo  não  o  torna 

desconexo. Absurdo. Logo, 𝐺 é uma árvore. 

No capítulo seguinte veremos como podemos determinar  a menor distância entre dois 

vértices  de  um  grafo  ponderado  por  meio  de  dois  algoritmos:  O  Algoritmo  de  Dijkstra  e  o 

Algoritmo de Floyd-Warshall 

 
 
 
 
 
 
 
3 O PROBLEMA DE CAMINHO MÍNIMO EM UM GRAFO 

27 

Em  Teoria  dos  Grafos,  o  Problema  de  Caminho  Mínimo  consiste  em  determinar  a 

sequência de vértices que minimiza o custo de travessia entre dois vértices de um grafo valorado. 

Esse custo é determinado pela soma dos pesos das arestas que o compõe. Se não houver nenhum 

caminho que una os vértices em questão o problema não possui solução. Se o vértice de origem 

coincide com o vértice de destino e as arestas tem pesos não negativos1, a solução é única e tem 

comprimento zero. Utilizaremos distância para designar o custo de um caminho. 

Conforme Boaventura e Jurkiewicz (2009), podemos subdividir este problema em, pelo 

menos, três categorias de subproblemas de caminho mínimo: 

  Origem Única: determinar a menor distância entre um vértice e os demais; 

  Origem-Destino: determinar a menor distância entre dois vértices dados; 

  Par a Par: determinar a menor distância entre cada par de vértices do grafo.  

Existem  diversos  algoritmos  especializados  em  determinar  o  caminho  mínimo  em  um 

grafo. Como exemplo temos o Algoritmo de Bellmand-Ford, Algoritmo de Johnson, Algoritmo 

de  Dijkstra  e  Algoritmo  de  Floyd-Warshall.  Neste  capítulo  abordaremos  o  funcionamento  e 

aplicações  dos  dois  últimos,  que  tem  enfoque  nos  subproblemas  Origem-Destino  e  Par  a  Par 

respectivamente. 

3.1 O Algoritmo de Dijkstra2 

Edsger Wybe Dijkstra foi um matemático Holandês pioneiro no setor de programação 

computacional. Sua carreira como cientista de computação teve início em 1951. Após ter sido 

aprovado no exame de admissão para cursar física e matemática na University of Leiden, Dijkstra 

participou  de  um  curso  de  programação  em  Cambrige,  Inglaterra.  Em  1952,  o  diretor  do 

Mathematisch  Centrum  de  Amsterdã,  Aad  van  Wijngaarden,  tomou  conhecimento  de  sua 

participação no curso e ofereceu a ele uma vaga de meio período como programador. 

Em 1955, após três anos de trabalho como programador, Dijkstra decidiu abandonar a 

física para se tornar um programador em tempo integral, como ele mesmo relata: 

1 Alguns problemas em grafos, como aqueles que envolvem fluxos, utilizam arestas com pesos negativos 

em sua modelagem. 

2 Esta seção foi composta de que informações foram compiladas de diversas fontes de pesquisa entre elas: 

jornais, obituário, entrevista etc. 

 
 
 
 
 
 
                                                           
 
28 

(…) Eu conclui que o desafio intelectual de programar era muito maior que o 
desafio  intelectual de  física  teórica  e,  como  resultado,  eu  escolhi  programar. 
Programar era tão implacável. Se alguma coisa desse errado, quero dizer, um 
zero é um zero e um um é um um. Eu nunca usei o software de outra pessoa. Se 
alguma coisa desse errado, eu era o responsável. E foi isso que me desafiou. 
(DIJKSTRA, 2010, p. 42, tradução nossa)3 

Após  tomar  essa  decisão  Dijkstra  terminou  seus  estudos  o  mais  rápido  possível,  se 

graduando em 1956, uma vez que não se sentia mais bem-vindo na universidade: 

(…)  os físicos  me  consideraram um  desertor e os matemáticos  se  mostraram 
desdenhosos com relação a computação. Na cultura matemática daquele tempo 
seu trabalho tinha que lidar com o infinito para ser cientificamente respeitável. 
(DIJKSTRA, 2010, p. 42, tradução nossa) 

No  mesmo  ano,  a  construção  do  segundo  computador  automático  do  Mathematisch 

Centrum, o ARMAC, estava prestes a ser concluída. Para celebrar sua inauguração foi preparada 

uma apresentação que deveria ser simples o suficiente para que pessoas leigas em matemática 

pudessem entender. Dijkstra então projetou um programa que determina a menor distância entre 

duas cidades da Holanda, considerando uma malha ferroviária simplificada contendo apenas 64 

cidades. Nesse programa ele utilizou um algoritmo que desenvolveu, segundo ele próprio, em 

vinte minutos durante um passeio com sua noiva, enquanto estavam sentados descansando após 

uma caminhada. A demonstração foi um grande sucesso e esse algoritmo, que hoje é amplamente 

utilizado, leva seu nome. 

Dijkstra trabalhou como programador no Mathematisch Centrum até 1962, quando foi 

indicado para uma cadeira na Eindhoven University of Technology onde permaneceu até 1973. 

Na universidade, desenvolveu um sistema operacional para o sistema de computadores interno. 

A  elegância  e  estrutura  hierárquica  do  sistema  foi  reconhecida  e  tópico  de  interesse  no  1º 

Simpósio de Princípios de Sistemas Operacionais. 

Em  1973,  Dijkstra  deixou  a  universidade  para  se  tornar  um  pesquisador  associado 

na Burroughs Corporation, onde obteve total liberdade para efetuar sua pesquisa da maneira que 

desejasse.  

Em 1984 decidiu voltar a lecionar  e aceitou a Schlumberger Centennial Chair da The 

University of Texas at Austin onde permaneceu até sua aposentadoria em 1999. 

Suas contribuições cobrem diversas áreas da ciência da computação, incluindo sistemas 

operacionais, pesquisa em linguagens de programação, programação sequencial e concorrente, 

algoritmos para grafos entre outras. Ele ajudou a modelar a ciência da computação como ela é 

conhecida  hoje.  Muitas  de  suas  publicações  foram  fonte  de  pesquisa  para  novas  áreas  de 

3 Embora Dijkstra tenha falecido em 2002, a publicação desta entrevista foi feita somente em 2010. 

 
 
 
                                                           
conhecimento. Diversos conceitos e problemas que hoje são padrões em ciência da computação 

foram primeiramente identificados e/ou levam nomes cunhados por ele. 

Figura 18 – Edsger W. Dijkstra 

29 

Fonte: Dijkstra, 2010 

3.1.1 Funcionamento do Algoritmo de Dijkstra 

Seja 𝐺 = (𝑉, 𝐹) um grafo ponderado com arestas de pesos não negativos. O Algoritmo 

de  Dijkstra  oferece  uma  solução  para  determinar  o  menor  caminho  entre  dois  vértices  de  𝐺. 

Fixado o vértice de início 𝑖 e vértice final 𝑓 o algoritmo determina durante sua execução quais 

são os vértices de G que devem ser inseridos entre 𝑖 e 𝑓 para que se tenha o menor caminho. 

O funcionamento do algoritmo pode ser dividido em três etapas. Na primeira etapa ele 

cria as variáveis que serão atualizadas ao longo da execução: 

  𝑑(𝑗): é a menor distância do vértice de origem 𝑖 ao vértice 𝑗,  

  𝑎(𝑗): indica qual é o vértice que antecede o vértice  𝑗, na sequência de vértices que vai 

compor o caminho desejado. Quando não houver vértice antecedente, representaremos 

sua ausência com o algarismo zero. 

  Conjunto dos vértices fechados, 𝐹: é o conjunto que contém os vértices para os quais a 

menor distância já foi determinada;  

  Conjunto dos vértices abertos,  𝐴: é o conjunto que contém os vértices para os quais a 

menor distância ainda não foi determinada durante a execução do algoritmo. Note que 

𝐴 = 𝑉 − 𝐹. 

Seja 𝑃 = [𝑝(cid:3044)(cid:3038)] a matriz dos pesos do grafo atribuídos. Considere 𝑀 = [𝑚(cid:3044)(cid:3038)] obtida a 

partir da matriz 𝑃, onde  

𝑚(cid:3044)(cid:3038) = (cid:4688)

𝑝(cid:3044)(cid:3038), se 𝑞 é adjacente a 𝑘    
0, se 𝑞 = 𝑘                                
∞, se 𝑞 não é adjacente a 𝑘

 
 
 
 
 
 
30 

Utilizamos o símbolo ∞ (infinito) para diferenciar uma aresta de peso zero entre 𝑞 e 𝑘 da 

não existência de uma aresta entre esses vértices. Chamaremos 𝑀 de Matriz de Manejo. 

Inicialmente, 𝑑(𝑖) = 𝑎(𝑖) = 0, 𝐹 = {𝑖}, 𝐴 = 𝑉 − {𝑖} e, para todo 𝑗 ∈ 𝐴, temos 

𝑑(𝑗) = (cid:3420)

𝑚(cid:3036)(cid:3037), se 𝑚(cid:3036)(cid:3037) ≠ ∞
∞, se 𝑚(cid:3036)(cid:3037) = ∞ , 𝑎(𝑗) = (cid:3420)

𝑖, se 𝑚(cid:3036)(cid:3037) ≠ ∞
. 
0, se 𝑚(cid:3036)(cid:3037) = ∞

Na segunda etapa o algoritmo utiliza a matriz 𝑀 e procura iterativamente o vértice 𝑟 ∈ 𝐴 

mais próximo a 𝑖. Esse vértice, chamado “vértice da vez”, é então movido do conjunto 𝐴 para o 

conjunto 𝐹. Em seguida, para cada vértice 𝑠 ∈ 𝐴 ∩ 𝑅(cid:2878)(𝑟) adjacente ao vértice da vez, o algoritmo 

verifica se 𝑑(𝑠) é maior que a 𝑑(𝑟) + 𝑚(cid:3045)(cid:3046). Em caso afirmativo, o caminho do vértice inicial até 

o vértice 𝑠, passando por 𝑟 é menor que o caminho previamente existente. Nesse caso, a entrada 

𝑑(𝑠) do vértice 𝑠 é atualizada com o menor valor e a entrada 𝑎(𝑠) é atualizada com 𝑟. O algoritmo 

executa essa rotina até que 𝑓 o vértice da vez.4 

Na  terceira  e  última  etapa  o  algoritmo  criará  (se  possível)  um  vetor  que  contém  a 

sequência de vértices que descreve o menor caminho de 𝑖 até 𝑓. Quando o vértice 𝑓 for o vértice 

da vez teremos uma das seguintes situações: 

  O  valor  da  entrada  𝑎(𝑓)  é  nulo.  Se  isso  ocorrer  significa  que  nenhuma  das  iterações 

anteriores  encontrou  um  caminho  de  𝑖  até  𝑓.  Logo  o  valor  𝑑(𝑓)  não  foi  alterado  e 

permanece infinito, de onde segue que o vértice 𝑓 não é adjacente de nenhum outro vértice 

do grafo. 

  O valor da entrada 𝑎(𝑓) é não nulo. Nesse caso, 𝑓 é adjacente a algum vértice para o qual 

é possível traçar um caminho até ele a partir de 𝑖. O algoritmo então executa uma rotina 

para  varrer  os  vértices  anteriores  partindo  de  𝑓,  criando  um  vetor  𝐶  que  determina 

caminho mínimo. 

Fixado um vértice inicial 𝑖, o algoritmo busca iterativamente o primeiro vértice aberto 

mais próximo, o segundo mais próximo, o terceiro mais próximo e assim sucessivamente, até 

encontrar o vértice desejado 𝑓. Como a busca é feita pelo menor caminho e as arestas tem pesos 

não negativos, uma vez que o vértice esteja fechado, não há um caminho com menor distância 

até ele.  

Apresentamos  o  pseudocódigo  e  o  fluxograma  que  descrevem  o  funcionamento  do 

algoritmo no Apêndice A e B respectivamente. Para ilustrar o funcionamento do Algoritmo de 

Dijskstra, como explicado acima, vamos determinar o menor caminho entre os vértices 1 e 5 no 

grafo 𝐺 apresentado na Figura 19. 

4 É possível escrever o algoritmo de Dijkstra de maneira que ele obtenha a menor distância de um vértice a 
todos os outros, o que o caracterizaria como Origem Única. Para os fins deste trabalho, escolhemos uma versão que 
se encerra ao encontrar a menor distância até um vértice específico. 

 
                                                           
Figura 19 – Grafo 𝐺. 

31 

Fonte: O autor, 2018 

Baseado no grafo 𝐺 temos as seguistes matrizes de Peso e de Manejo: 

Figura 20: Matriz de Peso e de Manejo do Grafo 𝐺. 

Fonte: O autor, 2018 

A sequência de figuras 21 a 26 mostram o desenvolvimento do algoritmo. Inicialmente é 

preciso criar as variáveis que serão atualizadas em cada iteração. Atribuímos zero a 𝑑(1) e 𝑎(1). 

Se 𝑚(cid:2869)(cid:3037) = 0, definimos 𝑑(𝑗) = ∞ e 𝑎(𝑗) = { }. Caso contrário fazemos 𝑑(𝑗) = 𝑝(cid:2869)(cid:3037) e 𝑎(𝑗) = {1}.  

Por último, definimos o Conjunto dos Vértices Abertos e o Conjunto dos Vértices Fechados (ver 

Figura 13). 

Figura 21 – Inicialização do Algoritmo de Dijkstra 

Fonte: O autor, 2018 

 
 
 
 
32 

A partir do vértice de origem 1 devemos procurar o vértice mais próximo. Nesse caso o 

vértice  mais  próximo  é  2,  que  então  é  fechado.  Para  cada  vértice  aberto  adjacente  a  ele 

verificamos se sua distância até a origem é maior que a distância da origem até ele passando por 

2. Como não há nenhum arco unindo 3 e 7 à origem, a estimativa passando por 2 é melhor e as 

variáveis desses vértices devem ser atualizadas (Figura 22). 

Figura 22 – Algoritmo de Dijkstra após primeira iteração. 

Fonte: O autor, 2018 

 O próximo vértice a ser fechado é 3, pois possui a menor distância 𝑑(𝑗), 𝑗 ∈ 𝐴. Como 4 

e  8  não  possuem  estimativa  de  menor  distância,  o  caminho  passando  por  3  é  menor.  Como 

𝑑(7) > 𝑑(3) + 𝑚(cid:2871)(cid:2875), melhoramos a estimativa para o menor caminho de 1 para 7 e fazemos as 

devidas alterações. 

Figura 23 – Algoritmo de Dijkstra após terceira iteração. 

Fonte: O autor, 2018 

Prosseguimos  procurando  o  vértice  aberto  mais  próximo  da  origem.  Nessa  iteração 

fecharemos  o  vértice  6.  O  único  vértice  adjacente  a  6  é  5.  Como  𝑑(5) > 𝑑(6) + 𝑚(cid:2874)(cid:2873), 

atualizamos os valores de 𝑑(5) e 𝑎(5). 

 
 
 
 
 
 
Figura 24 – Algoritmo de Dijkstra após quarta iteração. 

33 

Fonte: O autor, 2018 

De  acordo  com  a  variável  𝑑(𝑗),  o  próximo  vértice  a  ser  fechado  é  7.  O  único  vértice 

adjacente  aberto  que  ele  possui  é  5.  Como  𝑑(5) > 𝑑(7) + 𝑚(cid:2875)(cid:2873),  melhoramos  a  estimativa  e 

fazemos as devidas alterações em 𝑑(5) e 𝑎(5). 

Figura 25 – Algoritmo de Dijkstra após quarta iteração. 

Finalmente,  fechamos o  vértice 5. Como 𝑎(5) ≠ { }, existe uma sequência de vértices 

adjacentes que liga 1 a 5 de custo total 𝑑(5). Além disso essa sequência possui o menor custo 

Fonte: O autor, 2018 

possível. 

Figura 26 – Algoritmo de Dijkstra finalizado. 

Fonte: O autor, 2018 

 
 
 
 
 
 
34 

Nesse ponto o algoritmo varrerá os valores de 𝑎(𝑗) a partir de 𝑎(5) e construirá o vetor 𝐶 que 

contém os endereços dos vértices que compõem esse caminho: 

𝑎(5) = 7;       𝑎(7) = 3;      𝑎(3) = 2;     𝑎(2) = 1. 

𝐶 = (1,2,3,7,5) 

Portanto, o menor caminho que une o vértice 1 ao 5 mede 12 unidades e ele segue a ordem 

1 → 2 → 3 → 7 → 5. 

Figura 27 – Caminho de menor distância do vértice 1 até o vértice 5. 

Fonte: O autor, 2018 

3.2 O Algoritmo de Floyd-Warshall (ou Roy-Warshall)5 

Ao contrário do algoritmo de Dijkstra, o algoritmo de Floyd-Warshall, ou ainda Roy -

Warshall, foi desenvolvido independentemente por três pessoas. O primeiro a se deparar com ele 

foi  o  professor  francês  Bernard  Roy  (1934-2017),  em  1959  quando  era  então  consultor  da 

Société de Mathématiques Appliquées (SMA). No campo de Grafos, sua principal contribuição 

se  deu  teoria  de  fluxos  em  redes  e  agendamento  de  projetos,  com  a  invenção  do  método  de 

Atividade  no  Vértice.  Uma  outra  grande  contribuição  foi  a  invenção  da  família  de  métodos 

ELECTRE (ELimination Et Choix Traduisant la Realité) utilizados amplamente no campo de 

análise decisões envolvendo múltiplos critérios.  

A segunda pessoa a elaborar o algoritmo foi Robert W. Floyd (1936-2001), no ano de 

1962. Ele foi um cientista computacional americano e vencedor do prêmio Turing, maior honraria 

em  ciência  da  computação,  em  1978.  Floyd  foi  uma  criança  prodígio  tendo  terminado  sua 

5 As informações desta seção foram compiladas de sites de universidades, artigos online, biografias não 

oficiais e obituários. 

 
 
 
 
 
 
                                                           
primeira graduação, em artes liberais, aos dezessete anos. Thomas Haigh descreve como foi sua 

transição para a ciência da computação: 

35 

Como  toda  criança  em  programas  avançados  ele  logo  perdeu  o  gosto  pela 
escola. Enquanto isso, conseguiu um emprego na Armour Research Foundation 
of Illinois Institute of Technology, primeiro como um operador de computador 
autodidata e depois como um programador sênior e analista. Ele recebeu seu 
bacharelado em física da University of Chicago em 1958 e publicou um artigo 
sobre interferência de rádio no mesmo ano. Não demorou muito para que seu 
amor  pela computação  ficasse claro. De fato, ele começou  a  publicar  artigos 
para revistas de computação em 1959. (HAIGH, 2004, p. 75, tradução nossa) 

Suas  maiores  contribuições  aconteceram  no  campo  de  análise  sintática  (theory  of  parsing), 

semântica  de  linguagens  de  programação,  verificação  automática  de  programas,  síntese  de 

programa automática e análise de algoritmos. 

No mesmo ano de 1962, Stephen Warshall (1935-2006) publicou um artigo descrevendo 

o  algoritmo  enquanto  trabalhava  na  Massachusetts  Computer  Associates.  Ele  recebeu  seu 

bacharelado em matemática pela Harvard University em 1956, aos 21 anos. Ele não fez questão 

de continuar os estudos para obter o grau de mestre pois os cursos oferecidos pela universidade 

não o interessavam. 

Figura 24 – Bernard Roy, Robert Floyd e Stephen Warshall 

Fonte: <http://www.lamsade.dauphine.fr/~roy/>; <https://cs.stanford.edu/memoriam/professor-

robert-w-floyd>; <https://en.wikipedia.org/wiki/Stephen_Warshall>   

3.2.1 Funcionamento do Algoritmo de Floyd-Warshal 

O algoritmo de Floyd-Warshal é um algoritmo que determina o caminho de menor custo 

entre  todos  os  vértices  de  um  grafo  ponderado  com  arestas  de  peso  positivo  ou  negativo.  O 

algoritmo  original  não  determina  quais  vértices  devem  ser  percorridos.  Contudo  é  possível 

 
 
 
 
 
36 

contornar  esse  problema  fazendo  algumas  alterações  simples  no  código.  Nesse  trabalho 

utilizaremos a versão modificada do algoritmo. Vale ainda ressaltar que estamos supondo um 

grafo simples sem ciclos negativos. Adiante explicaremos o porquê dessa escolha. 

Considere  um  grafo  𝐺 = (𝑉, 𝐸),  com  𝑛  vértices  rotulados  utilizando-se  os  números 

naturais 1,2, … , 𝑛. Com base na matriz de manejo 𝑀(cid:2868) = [𝑚(cid:3036)(cid:3037)

(cid:2868) ], o algoritmo cria uma matriz 𝑅(cid:2868) =

(cid:2868)] tal que 

[𝑟(cid:3036)(cid:3037)

(cid:2868) = (cid:4682)
𝑟(cid:3036)(cid:3037)

𝑗, se 𝑚(cid:3036)(cid:3037)
0, se 𝑚(cid:3036)(cid:3037)

(cid:2868) ≠ ∞
(cid:2868) = ∞.

Os índices superiores das matrizes, bem como de seus elementos, se referem a iteração na qual a 

matriz foi obtida. Inicialmente esses índices são zero, significando valores iniciais. Conforme as 

iterações do algoritmo acontecem, esses índices são atualizados. 

A matriz 𝑅 recebe o nome de matriz de roteamento do grafo e ela servirá para construir 

o vetor 𝐶 que contém em suas entradas os rótulos dos vetores que comprão o menor caminho. 

Para  cada  par  de  vértices  (𝑖, 𝑗)  ela  nos  informa  qual  é  o  vértice  seguinte  𝑟(cid:3036)(cid:3037)  na  sequência  de 

vértices que irá compor o menor caminho possível de 𝑖 até 𝑗. Se  𝑚(cid:3036)(cid:3037)

(cid:2868) = ∞, ou seja, não existe 

arco  (𝑖, 𝑗),  assinalamos  𝑟(cid:3036)(cid:3037)

(cid:2868) = 0,  o  que  nos  diz  que  não  existe  um  vértice  seguinte  a  𝑖  na 

composição do caminho. Se 𝑚(cid:3036)(cid:3037)

(cid:2868) ≠ ∞ então há duas possibilidades: 

 

 

 𝑚(cid:3036)(cid:3037)

(cid:2868) ≠ 0. Dessa forma existe o arco (𝑖, 𝑗).  

 𝑚(cid:3036)(cid:3037)

(cid:2868) = 0. Então, não existe o arco (𝑖, 𝑗), ou seja, 𝑚(cid:3036)(cid:3037)

(cid:2868)  é um elemento da diagonal principal. 

Em ambos os casos, o vértice seguinte na construção do caminho é o próprio vértice de destino 

𝑗.  

Por exemplo, seja 𝐺 um grafo de 5 vértices. Se no início da execução do algoritmo temos 

(cid:2868) = 18, significa que existe a o arco (2,5) e ele possui peso 18. Além disso o próximo vértice 

𝑚(cid:2870)(cid:2873)

no menor caminho 2 → 5 (por enquanto) é o próprio 5. Assim, 𝑟(cid:2870)(cid:2873)

(cid:2868) = 5. Suponha ainda, nesse 

mesmo grafo, que 𝑚(cid:2871)(cid:2872)

(cid:2868) = ∞. Então, não existe o arco (3,4). Logo, devemos ter 𝑟(cid:2871)(cid:2872)
A cada iteração, o algoritmo fixa o vértice de menor rótulo 𝑘 dessa lista, chamado vértice 

(cid:2868) = 0. 

intermediário. Então ele cria as matrizes 𝑀(cid:3038) e 𝑅(cid:3038) que serão atualizadas durante a execução. 

Cada elemento 𝑚(cid:3036)(cid:3037)

(cid:3038)  de 𝑀(cid:3038) e 𝑟(cid:3036)(cid:3037)

(cid:3038) de  𝑅(cid:3038) são tais que 

𝑚(cid:3036)(cid:3037)

(cid:3038) = 𝑚(cid:3036)(cid:3037)

(cid:3038)(cid:2879)(cid:2869) e 𝑟(cid:3036)(cid:3037)

(cid:3038) = 𝑟(cid:3036)(cid:3037)

(cid:3038)(cid:2879)(cid:2869). 

Em seguida, para cada par (𝑖, 𝑗), com 𝑖 e 𝑗 distintos de 𝑘, o algoritmo verifica se a distância 

entre esses vértices, passando pelo intermediário 𝑘, é menor que distância sem passar por ele. 

Em outras palavras, o algoritmo verifica se  

𝑚(cid:3036)(cid:3038)

(cid:3038)(cid:2879)(cid:2869) + 𝑚(cid:3038)(cid:3037)

(cid:3038)(cid:2879)(cid:2869) < 𝑚(cid:3036)(cid:3037)

(cid:3038)(cid:2879)(cid:2869). 

 
 
Em caso afirmativo, 𝑚(cid:3036)(cid:3037)

(cid:3038)  é substituída pelo valor da soma.  

37 

Por último, a matriz de roteamento é atualizada.  Sempre que 𝑚(cid:3036)(cid:3037)

(cid:3038)  for substituída, 𝑟(cid:3036)(cid:3037)

(cid:3038) é 

substituída  por  𝑟(cid:3036)(cid:3038)

(cid:3038)(cid:2879)(cid:2869).  Essa  escolha  está  de  acordo  com  a  definição  da  matriz  𝑅,  pois  se  ao 

tomarmos 𝑘 como intermediário, a distância 𝑖 → 𝑗 é melhorada, então 𝑟(cid:3036)(cid:3037)

(cid:3038) deve ser atualizada com 

o vértice seguinte a 𝑖, no caminho de 𝑖 até 𝑘, ou seja 𝑟(cid:3036)(cid:3038)

(cid:3038)(cid:2879)(cid:2869). 

Retomando o exemplo acima, considere que o algoritmo esteja na segunda iteração e que  
(cid:2869) . 
(cid:2869) < 𝑚(cid:2871)(cid:2873)
𝑚(cid:2871)(cid:2870)
(cid:2869)  na matriz 𝑀(cid:2870) e 𝑟(cid:2871)(cid:2873)

(cid:2870)  é substituída por 𝑚(cid:2871)(cid:2870)

(cid:2870)  é substituída por 𝑟(cid:2871)(cid:2870)

(cid:2869) , uma vez que o 

(cid:2869) + 𝑚(cid:2870)(cid:2873)

(cid:2869) + 𝑚(cid:2870)(cid:2873)

Então, 𝑚(cid:2871)(cid:2873)

caminho é mais curto tomando o vértice 2 como intermediário no caminho de 3 até 5. 

O processo para quando 𝑘 varrer todos os vértices do grafo e o algoritmo tem como saída 

as matrizes 𝑀(cid:3041) e 𝑅(cid:3041). É possível ainda criar uma rotina que obtém o caminho entre dois vértices 

após a execução do algoritmo. O fluxograma e pseudocódigo do  algoritmo se encontram nos 

apêndices C e D respectivamente. 

Utilizaremos  o  grafo  𝐺  da  Figura  25  para  um  exemplo  de  execução  do  algoritmo.  As 

matrizes 𝑀(cid:2868) e 𝑅(cid:2868) são mostradas ao lado do grafo. 

Figura 25 – Grafo 𝐺 e suas matrizes de Pesos e de Roteamento 

Para  esse  grafo  o  algoritmo  fará  cinco  iterações  tomando  o  vértice  1  como  primeiro 

Fonte: O autor, 2018 

intermediário. 

1ª Iteração (𝒌 = 𝟏): Para cada par de vértices (𝑖, 𝑗), com 𝑖, 𝑗 ≠ 1, o algoritmo verificará se a 

distância entre esses vértices, tendo 1 como intermediário, é menor que a distância entre eles, ou 

seja, se 𝑚(cid:3036)(cid:2869)

∞  ou  𝑚(cid:2869)(cid:3037)

(cid:2868) < 𝑚(cid:3036)(cid:3037)

(cid:2868) + 𝑚(cid:2869)(cid:3037)
(cid:2868) = ∞  a  estimativa  do  caminho  não  será  melhorada  pois  a  soma  𝑚(cid:3036)(cid:2869)

(cid:2868) . Em caso afirmativo, 𝑚(cid:3036)(cid:3037)

(cid:2868) . Sempre que 𝑚(cid:3036)(cid:2869)
(cid:2868) + 𝑚(cid:2869)(cid:3037)

(cid:2869) ← 𝑚(cid:3036)(cid:2869)

(cid:2868) + 𝑚(cid:2869)(cid:3037)

(cid:2869) ← 𝑟(cid:3036)(cid:2869)

(cid:2868) e 𝑟(cid:3036)(cid:3037)

(cid:2868)   nunca 

(cid:2868) =

poderá ser inferior a ∞. Assim temos: 

 
 
 
 
38 

(cid:2868) = ∞; 
(cid:2869) ← 10 e 𝑟(cid:2871)(cid:2870)
(cid:2868) = 𝑚(cid:2869)(cid:2872)
(cid:2868) = ∞; 

(cid:2869) ← 1; 
(cid:2868) = 𝑚(cid:2869)(cid:2873)

𝑖 = 2 𝑒 𝑗 = 2,3,4,5: Não há alterações na segunda linha pois 𝑚(cid:2870)(cid:2869)

𝑖 = 3 𝑒 𝑗 = 2: 𝑚(cid:2871)(cid:2869)

(cid:2868) + 𝑚(cid:2869)(cid:2870)

(cid:2868) = 7 + 3 < ∞ = 𝑚(cid:2871)(cid:2870)

(cid:2868) , então 𝑚(cid:2871)(cid:2870)

𝑖 = 3 𝑒 𝑗 = 3,4,5: Não há alterações na terceira linha pois 𝑚(cid:2869)(cid:2871)

(cid:2868) = ∞; 

𝑖 = 4 𝑒 𝑗 = 2,3,4,5: Não há alterações na quarta linha pois 𝑚(cid:2872)(cid:2869)

𝑖 = 5 𝑒 𝑗 = 2,3,4,5: Não há alterações na quinta linha pois 𝑚(cid:2873)(cid:2869)

(cid:2868) = ∞; 

Após a 1ª iteração temos as matrizes de manejo e de roteamento mostradas na Figura 26. 

Figura 26 – Matrizes de Pesos e de Roteamento após a 1ª iteração 

Fonte: O autor, 2018 

2ª Iteração (𝒌 = 𝟐):  

𝑖 = 1 𝑒 𝑗 = 1: Inicialmente supomos que trabalharíamos em grafos simples sem ciclos negativos. 

Fizemos essa suposição pois o algoritmo não consegue lidar com tais ciclos, pois de outra forma 

ele sempre conseguiria encontrar um caminho menor de um vértice a ele mesmo e entraria em 

loop.  Portanto,  𝑚(cid:3036)(cid:3036)

(cid:3038)  nunca sofrerá ajuste. Assim, 𝑚(cid:2869)(cid:2869)

(cid:2870)  não será atualizado. De agora em diante 

(cid:3038) . 
não analisaremos mais o caso 𝑚(cid:3036)(cid:3036)

𝑖 = 1 𝑒 𝑗 = 3: 𝑚(cid:2869)(cid:2870)

(cid:2869) = 3 + 5 < ∞ = 𝑚(cid:2869)(cid:2871)
(cid:2869) = ∞; 
(cid:2869) = 3 + 3 < ∞ = 𝑚(cid:2869)(cid:2873)

(cid:2869) + 𝑚(cid:2870)(cid:2871)
𝑖 = 1 𝑒 𝑗 = 4: Não há alterações pois 𝑚(cid:2870)(cid:2872)
(cid:2869) + 𝑚(cid:2870)(cid:2873)
𝑖 = 3 𝑒 𝑗 = 1,4: Não há alterações pois 𝑚(cid:2870)(cid:2869)
(cid:2869) + 𝑚(cid:2870)(cid:2873)

(cid:2869) = 𝑚(cid:2870)(cid:2872)
(cid:2869) = 10 + 3 > −4 = 𝑚(cid:2871)(cid:2873)

𝑖 = 1 𝑒 𝑗 = 5: 𝑚(cid:2869)(cid:2870)

𝑖 = 3 𝑒 𝑗 = 5: 𝑚(cid:2871)(cid:2870)

(cid:2869) , então 𝑚(cid:2869)(cid:2871)

(cid:2870) ← 8 e 𝑟(cid:2869)(cid:2871)

(cid:2870) ← 2; 

(cid:2870) ← 6 e 𝑟(cid:2869)(cid:2871)

(cid:2870) ← 2; 

(cid:2869) , então 𝑚(cid:2869)(cid:2873)
(cid:2869) = ∞; 

(cid:2869) , portanto não há alteração na distância (3,5); 

𝑖 = 4 𝑒 𝑗 = 1,3,5: Não há alterações na quarta linha pois 𝑚(cid:2872)(cid:2870)

(cid:2869) = ∞; 

𝑖 = 5 𝑒 𝑗 = 1,3,4: Não há alterações na quinta linha pois 𝑚(cid:2873)(cid:2870)

(cid:2869) = ∞. 

 
 
 
 
 
 
 
 
 
Figura 27 – Matrizes de Pesos e de Roteamento após a 2ª iteração 

39 

Fonte: O autor, 2018 

3ª Iteração (𝒌 = 𝟑):  

𝑖 = 1 𝑒 𝑗 = 2: 𝑚(cid:2869)(cid:2871)

𝑖 = 1 𝑒 𝑗 = 4: 𝑚(cid:2869)(cid:2871)

𝑖 = 1 𝑒 𝑗 = 5: 𝑚(cid:2869)(cid:2871)

𝑖 = 2 𝑒 𝑗 = 1: 𝑚(cid:2870)(cid:2871)

𝑖 = 2 𝑒 𝑗 = 4: 𝑚(cid:2870)(cid:2871)

(cid:2871) . 
(cid:2870) , sem alteração em 𝑚(cid:2869)(cid:2871)
(cid:2870) , então 𝑚(cid:2869)(cid:2872)

(cid:2870) + 𝑚(cid:2871)(cid:2870)
(cid:2870) + 𝑚(cid:2871)(cid:2872)
(cid:2870) + 𝑚(cid:2871)(cid:2873)
(cid:2870) + 𝑚(cid:2871)(cid:2869)
(cid:2870) + 𝑚(cid:2871)(cid:2872)
(cid:2870) + 𝑚(cid:2871)(cid:2873)

(cid:2870) > 𝑚(cid:2869)(cid:2871)
(cid:2870) = 8 + 4 < ∞ = 𝑚(cid:2869)(cid:2872)
(cid:2870) = 8 + (−4) < 6 = 𝑚(cid:2869)(cid:2873)
(cid:2870) = 5 + 7 < ∞ = 𝑚(cid:2870)(cid:2869)
(cid:2870) = 5 + 4 < ∞ = 𝑚(cid:2870)(cid:2872)
(cid:2870) = 5 + (−4) < 3 = 𝑚(cid:2870)(cid:2873)

(cid:2870) , então 𝑚(cid:2870)(cid:2869)
(cid:2870) , então 𝑚(cid:2870)(cid:2872)

(cid:2870) , então 𝑚(cid:2869)(cid:2873)

𝑖 = 2 𝑒 𝑗 = 5: 𝑚(cid:2870)(cid:2871)

(cid:2870) , então 𝑚(cid:2870)(cid:2873)
𝑖 = 4 𝑒 𝑗 = 1,2,5: Não há alterações na quarta linha pois 𝑚(cid:2872)(cid:2871)

(cid:2871) ← 1 e 𝑟(cid:2870)(cid:2873)
(cid:2870) = ∞; 

(cid:2871) ← 12 e 𝑟(cid:2869)(cid:2872)

(cid:2871) ← 𝑟(cid:2869)(cid:2871)

(cid:2870) = 2; 

(cid:2870) = 2; 

(cid:2871) ← 4 e 𝑟(cid:2869)(cid:2873)
(cid:2871) ← 12 e 𝑟(cid:2870)(cid:2869)
(cid:2871) ← 9 e 𝑟(cid:2870)(cid:2872)

(cid:2871) ← 𝑟(cid:2869)(cid:2871)
(cid:2871) ← 𝑟(cid:2870)(cid:2871)
(cid:2871) ← 𝑟(cid:2870)(cid:2871)

(cid:2870) = 3; 

(cid:2870) = 3; 

(cid:2871) ← 𝑟(cid:2870)(cid:2871)

(cid:2870) = 3; 

𝑖 = 5 𝑒 𝑗 = 1,2,4: Não há alterações na quarta linha pois 𝑚(cid:2873)(cid:2871)

(cid:2870) = ∞; 

Após a 3ª Iteração temos: 

Figura 28 – Matrizes de Pesos e de Roteamento após a 3ª iteração 

Fonte: O autor, 2018 

4ª Iteração (𝒌 = 𝟒):  

Como 𝑚(cid:2872)(cid:3037)

(cid:2871) = ∞ para todo 𝑗 ≠ 4, não haverá melhora nas estimativas tomando o vértice 4 como 

intermediário. Isso fica evidente ao observarmos na representação gráfica que o vértice 4 não é 

adjacente a nenhum outro. Assim, 

 
 
 
 
 
 
 
Figura 29 – Matrizes de Pesos e de Roteamento após a 4ª iteração 

40 

 5ª Iteração (𝒌 = 𝟓):  

Fonte: O autor, 2018 

(cid:2872) = 𝑚(cid:2873)(cid:2870)

(cid:2872) = 𝑚(cid:2873)(cid:2871)
(cid:2872) , então 𝑚(cid:2869)(cid:2872)
(cid:2872) = 𝑚(cid:2873)(cid:2871)

𝑖 = 1 𝑒 𝑗 = 4: 𝑚(cid:2869)(cid:2873)

𝑖 = 2 𝑒 𝑗 = 4: 𝑚(cid:2870)(cid:2873)

(cid:2872) = 4 + 3 < 12 = 𝑚(cid:2869)(cid:2872)

𝑖 = 1 𝑒 𝑗 = 1,2,3: Não há alterações pois 𝑚(cid:2873)(cid:2869)
(cid:2872) + 𝑚(cid:2873)(cid:2872)
𝑖 = 2 𝑒 𝑗 = 1,2,3: Não há alterações pois 𝑚(cid:2873)(cid:2869)
(cid:2872) = 1 + 3 < 9 = 𝑚(cid:2870)(cid:2872)
(cid:2872) + 𝑚(cid:2873)(cid:2872)
𝑖 = 3 𝑒 𝑗 = 1,2,3: Não há alterações pois 𝑚(cid:2873)(cid:2869)
(cid:2872) + 𝑚(cid:2873)(cid:2872)
𝑖 = 4 𝑒 𝑗 = 1,2,3: Não há alterações pois 𝑚(cid:2873)(cid:2869)
Finalmente, após as cinco iterações temos as matrizes: 

(cid:2872) = (−4) + 3 < 4 = 𝑚(cid:2871)(cid:2872)

𝑖 = 3 𝑒 𝑗 = 4: 𝑚(cid:2871)(cid:2873)

(cid:2872) = 𝑚(cid:2873)(cid:2870)
(cid:2872) , então 𝑚(cid:2870)(cid:2872)
(cid:2872) = 𝑚(cid:2873)(cid:2870)

(cid:2872) = 𝑚(cid:2873)(cid:2871)
(cid:2872) , então 𝑚(cid:2871)(cid:2872)
(cid:2872) = 𝑚(cid:2873)(cid:2871)

(cid:2872) = 𝑚(cid:2873)(cid:2870)

(cid:2872) = ∞; 
(cid:2873) ← 7 e 𝑟(cid:2869)(cid:2872)
(cid:2872) = ∞; 
(cid:2873) ← 4 e 𝑟(cid:2870)(cid:2872)
(cid:2872) = ∞; 

(cid:2872) = ∞; 

(cid:2873) ← 𝑟(cid:2869)(cid:2873)

(cid:2872) = 2; 

(cid:2873) ← 𝑟(cid:2870)(cid:2873)

(cid:2872) = 3; 

(cid:2873) ← −1 e 𝑟(cid:2871)(cid:2872)

(cid:2873) ← 𝑟(cid:2871)(cid:2873)

(cid:2872) = 5; 

Figura 30 – Matrizes de Pesos e de Roteamento após a 5ª iteração 

Fonte: O autor, 2018 

Na matriz 𝑀(cid:2873) temos o valor do custo mínimo para ir do vértice 𝑖 ao vértice 𝑗. Se algum 

(cid:2873) = ∞  então  o  vértice  𝑗  não  é atingível  a  partir  de  𝑖.  A matriz  de roteamento  fornecerá  os 

𝑚(cid:3036)(cid:3037)

vértices que irão compor o caminho 𝑖 → 𝑗.  

Vamos determinar a sequência de vértices que irão compor o caminho 1 → 5. Observando 

a  matriz  de  manejo  temos  𝑚(cid:2869)(cid:2873)
unidades.   Consultando agora a matriz 𝑅(cid:2873) temos 𝑟(cid:2869)(cid:2873)
primeiro devemos passar por 2. Buscamos agora qual é o vértice seguinte a 2 no caminho 2 → 5 

(cid:2873) = 4,  então  existe  o  trajeto  1 → 5  e  seu  custo  mínimo  é  de  4 

(cid:2873) = 2. Isso quer dizer que para chegar a 5, 

5: 𝑟(cid:2870)(cid:2873)

(cid:2873) = 3. Ou seja, para atingir 5 a partir de 2, devemos passar por 3. Devemos agora buscar 

 
 
 
 
qual é o próximo vértice no caminho 3 → 5. Consultando novamente a matriz encontramos 𝑟(cid:2871)(cid:2873)
5, que é o nosso vértice final. Então a sequência de vértices procurada é 1 → 2 → 3 → 5. 

(cid:2873) =

Figura 31 – Menor caminho que une o vértice 1 ao vértice 5. 

41 

Fonte: O autor, 2018 

3.2.2 Aplicações do Algoritmo de Floyd-Warshal 

Os algoritmos de caminho mínimo podem nos ajudar na tomada de decisão em 

diversas situações. Considere a seguinte:  

O dono de uma marca de chocolates que deseja expandir seus negócios comprou dez imóveis 

numa dada região. Em um desses imóveis ele estabelecerá a fábrica que irá produzir e distribuir 

os  chocolates.  Nos  demais  imóveis  serão  construídas  as  lojas  que  efetuarão  as  vendas  para o 

público. No grafo abaixo os vértices representam os terrenos e os pesos das arestas a distância 

entre eles em quilômetros. 

Figura 32 – Grafo que representa os imóveis comprados. 

 Em qual dos imóveis a fábrica deverá ser instalada? Por que? 

Fonte: O autor, 2018 

Para responder à pergunta acima devemos estabelecer algum tipo critério. A escolha do 

imóvel deve se dar de maneira que o custo de distribuição seja mínimo, dessa forma o lucro será 

 
 
 
 
 
 
 
máximo. Esse é um dos critérios mais recorrentes e é comumente chamado de critério de lucro 

(BOAVENTURA; JURKIEWICZ, 2009).  Em  geral, os custos  com distribuição são menores 

quando a distância entre os pontos de entrega também o são. Devemos então determinar o vértice 

cuja  soma  das  menores  distâncias  até  os  outros  vértices  é  mínima.  Para  isso,  basta  aplicar  o 

algoritmo de Floyd-Warshall e calcular a soma dos elementos de cada linha da matriz de saída6.  

42 

4 

6 

8 
7 
2 
6 

Figura 33 – Matrizes das menores distâncias e da distância acumulada. 
  D. A. 
184 
147 
131 
156 
212 
175 
152 
159 
133 
161 

9 
10 
3 
7 
5 
2 
1 
22  19 
13  26  36  29  23 
9 
0 
1 
13  24 
17  27  28  23 
4 
0 
9 
2 
20 
9 
13  23  24  19 
13 
0 
4 
3 
10  11  17  19  22  21 
26  17  13 
0 
4 
21  25  29  15  26 
0 
36  27  23  10 
5 
30  16  10 
0 
29  28  24  11  21 
6 
6 
25  10 
23  23  19  17  25 
4 
6 
0 
7 
15  26 
0 
6 
2 
7 
19  29  30  25 
8 
11 
0 
22  15  16  10  15 
9 
22  13 
9 
0 
26  11 
10  19  24  20  21  26  10 

4 

Fonte: O autor, 2018 

Ao  lado  da  matriz  de  distâncias  encontra-se  a  coluna  distância  acumulada  (D.A.). 

Podemos observar que o vértice 3 possui a menor distância acumulada dos outros vértices. Isso 

quer dizer que um veículo que faça o transporte da fábrica para as lojas percorrerá uma distância 

menor,  gerando  um  custo  de  transporte  menor  e,  por  consequência  um  maior  lucro  para  a 

empresa. Em teoria dos grafos  o vértice que tem essa propriedade é chamado de mediana do 

grafo. Esse tipo de problema é conhecido como problema de mediana ou minissoma. 

Um  outro  critério  bastante  empregado  é  o  critério  de  emergência.  Ele  é  aplicável  em 

situações onde o vértice onde se deseja alocar a instalação ficar o mais próximo possível dos 

outros vértices, como por exemplo a construção de um hospital, posto policial, quartel do corpo 

de bombeiros, etc. A ideia por trás dessa escolha é que o usuário (vértice) mais distante não tenha 

que esperar muito para ser atendido. Vamos apresentar um exemplo. 

Suponha que o grafo da Figura 31 representa a distribuição de casas numa região rural 

fictícia e deseja-se instalar um posto policial para atender a essas famílias. O local escolhido deve 

ficar o mais próximo possível de todas as casas. Para que isso aconteça, a maior distância do 

posto policial a uma dessas casas deve ser a menor possível, ou seja, estamos procurando o vértice 

6  

Para  obtenção  dos  valores  apresentados  na  Figura  32  utilizamos  uma  versão  do  algoritmo 
implementada  numa  planilha  excel.  Disponível  em:  <https://www.excelforum.com/excel-programming-vba-
macros/>. Acesso em: 12 Jan. 2018. 

 
 
 
 
 
 
 
 
 
 
 
 
                                                           
 
cuja maior distância em relação aos outros é a menor possível. Consultando novamente a matriz 

da Figura 33 podemos construir a tabela a seguir. 

Figura 34 – Maior distância do posto policial. 

43 

Vértice  Afastamento 

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 

36 
28 
24 
26 
36 
29 
25 
29 
22 
26 
Fonte: O autor, 2018 

Nessa matriz a coluna Afastamento representa a maior das distâncias de um vértice aos outros. 

Podemos observar que o vértice 9 apresenta a menor dessas distâncias. Portanto ele é o melhor 

candidato para a instalação do nosso posto policial. Um vértice com tal propriedade é chamado 

de centro do grafo e seu afastamento é o raio do grafo. 

 
 
 
 
4 UMA PROPOSTA PARA ALÉM DA SALA DE AULA 

44 

Este capítulo tem por objetivo apresentar uma proposta de oficina para alunos do ensino 

médio onde serão introduzidos alguns conceitos básicos da teoria de Grafos e uma aplicação dos 

algoritmos de Dijkstra e Floyd-Warshall. A partir de um problema contextualizado de caminhos 

mínimos o aluno será encorajado a encontrar soluções utilizando tais algoritmos.  

Para isso, sugerimos uma sequência de tópicos que podem ser trabalhados com alunos do 

2º ou 3º ano do ensino médio. É desejável, mas não necessariamente obrigatório, que esses alunos 

tenham conhecimento básico do conceito de Matrizes. A estrutura de desenvolvimento desses 

tópicos se relaciona com os conteúdos dos capítulos 2 e 3 desse trabalho pois acreditamos que os 

modelos apresentados possam ser construídos por esses alunos, seja para demonstrar aplicação, 

verificar resultados ou mesmo despertar interesse pelo tema. 

4.1 Tópico 1: O Problema Motivador 

Objetivo: Através de um problema motivador apresentar alguns conceitos básicos da teoria de 

Grafos; 

Desenvolvimento:  

  Apresentação do Problema Motivador: 

“O dono de uma loja de departamentos deseja expandir seus negócios numa região do interior de 

São Paulo. Ele pretende abrir sete lojas nas cidades de Piracicaba, Botucatu, Tatuí, Sorocaba, Itu, 

Jundiaí, Indaiatuba e um centro de distribuição em Campinas.  Sempre que se deseja fazer uma 

entrega do Centro de distribuição para uma das lojas aproveita-se a viagem para recolher notas 

fiscais nas demais lojas situadas ao longo do caminho por onde o entregador passará. A escolha 

do caminho utilizado pelo entregador deve ser feita de modo que a distância percorrida por ele 

seja a menor possível. A Figura 35 apresenta o mapa da região onde serão instaladas as lojas. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figura 35 – Mapa com as cidades onde as lojas serão abertas. 

45 

De posse dessas informações e das distâncias apresentadas na Figura 36 responda as perguntas 

Fonte: <https://www.google.com.br/maps> 

abaixo.  

a) Quantos quilômetros serão percorridos para fazer uma entrega para a loja situada em Tatuí? 

Por quais cidades esse entregador passará? 

b) Suponha agora que a central de distribuição possa ser instalada em qualquer uma das cidades. 

Em qual delas você a instalaria? Por que?” 

Figura 36 – Tabela com distâncias conhecidas. 

Cidades 
𝑃𝑖𝑟𝑎𝑐𝑖𝑐𝑎𝑏𝑎 ↔ 𝐵𝑜𝑡𝑢𝑐𝑎𝑡𝑢 
𝐵𝑜𝑡𝑢𝑐𝑎𝑡𝑢 → 𝐼𝑡𝑢 
𝐼𝑡𝑢 → 𝐵𝑜𝑡𝑢𝑐𝑎𝑡𝑢 
𝐵𝑜𝑡𝑢𝑐𝑎𝑡𝑢 ↔ 𝑇𝑎𝑡𝑢í 
𝑇𝑎𝑡𝑢í → 𝑆𝑜𝑟𝑜𝑐𝑎𝑏𝑎 
𝑆𝑜𝑟𝑜𝑐𝑎𝑏𝑎 → 𝑇𝑎𝑡𝑢í 
𝐼𝑡𝑢 ↔ 𝑆𝑜𝑟𝑜𝑐𝑎𝑏𝑎 
𝐼𝑡𝑢 ↔ 𝐽𝑢𝑛𝑑𝑖𝑎í 
𝐼𝑡𝑢 ↔ 𝐼𝑛𝑑𝑎𝑖𝑎𝑡𝑢𝑏𝑎 
𝐽𝑢𝑛𝑑𝑖𝑎𝑖𝑎 ↔ 𝐼𝑛𝑑𝑎𝑖𝑎𝑡𝑢𝑏𝑎 
𝐼𝑛𝑑𝑎𝑖𝑎𝑡𝑢𝑏𝑎 ↔ 𝐶𝑎𝑚𝑝𝑖𝑛𝑎𝑠 
𝐶𝑎𝑚𝑝𝑖𝑛𝑎𝑠 ↔ 𝐽𝑢𝑛𝑑𝑖𝑎í 
𝐶𝑎𝑚𝑝𝑖𝑛𝑎𝑠 ↔ 𝑃𝑖𝑟𝑎𝑐𝑖𝑐𝑎𝑏𝑎 

Distância (Km) 
115 
148 
164 
107 
61 
52 
38 
48 
27 
47 
28 
39 
71 

Fonte: O autor, 2018 

 

Introdução aos conceitos básicos de Teoria de Grafos 

Com  o  objetivo  de  modelar  o  problema  motivador,  serão  apresentados  os  conceitos 

fundamentais acerca da teoria de grafos abordados no Capítulo II. Espera-se que a introdução 

desse  novo  objeto  de  estudo,  associado  a  um  problema  de  ordem  prática,  propicie  uma 

aprendizagem significativa para alunos. Além disso, tais conceitos serão importantes tanto para 

 
 
 
a compreensão da modelagem como para o entendimento dos algoritmos que serão tratados nos 

46 

tópicos posteriores.  

  Modelagem do Problema 

A  partir  do  que  foi  visto  anteriormente,  o  problema  será  modelado  por  um  digrafo 

ponderado como o da figura a seguir. 

Figura 37 – Situação problema modelada por um grafo. 

  Relacionar o Problema Motivador com a determinação de um caminho mínimo entre dois 

Fonte: O autor, 2018 

vértices do grafo. 

4.2 Tópico 2: Algoritmos 

Objetivo: Conceituar o que é um algoritmo e descrever seus passos. 

Desenvolvimento:  

 

Sugerir que os alunos proponham soluções para algumas situações tais como atravessar 

uma rua, fazer uma pipoca, calcular uma média final escolar, procurar palavras no dicionário, 

etc, descrevendo de maneira eficiente um passo a passo de suas ações encadeadas logicamente. 

Duas sugestões de situações problema e seus respectivos algoritmos podem ser encontradas no 

Apêndices F.  

 

Conceituar algoritmo segundo BACKES (2011): “Um algoritmo pode ser definido como 

uma sequência finita e ordenada de instruções para solucionar um determinado problema.” 

 

Fazer um apanhado histórico da origem dos algoritmos. Uma sugestão de material para 

consulta encontra-se no apêndice G. 

 
 
 
 
 
 
  
47 

4.3 Tópico 3: O Algoritmo de Dijkstra 

Objetivo: Apresentar o passo a passo do Algoritmo de Dijkstra.  

Desenvolvimento:  

  Descrever a finalidade do algoritmo; 

  Apresentar  o  passo  a  passo  do  Algoritmo  de  Dijkstra,  fazendo  uma  adequação  de 

linguagem do conteúdo apresentado no capítulo 3 de maneira a torna-lo mais acessível para a 

compreensão dos alunos, o que será feito a seguir. 

Sejam 𝑖 e 𝑓 dois vértices em um grafo 𝐺 = (𝑉, 𝐸). Deseja-se determinar o custo do menor 

caminho que tem origem em 𝑖 e término em 𝑓. Note que o caminho possui orientação, uma vez 

que em um grafo orientado caminho 𝑖 → 𝑓 é distinto do caminho  𝑓 → 𝑖. 

Para o funcionamento do algoritmo, precisamos definir dois parâmetros relacionados com 

os vértices do grafo. Seja 𝑗 ∈ 𝑉: 

  𝑑(𝑗): é o comprimento do menor caminho que tem origem em 𝑖 e término em 𝑗; 

  𝑎(𝑗): indica qual é o vértice que antecede 𝑣 na sequência de vértices que vão compor o 

caminho desejado. 

Por exemplo, considere o grafo da Figura 38. 

Figura 38 – Grafo. 

Fonte: O autor, 2018 

Suponha que desejamos buscar o menor caminho do vértice 1 até o vértice 4. Por inspeção 

verificamos que o caminho procurado é (1,3,4) e ele mede 11 unidades de comprimento. Assim 

𝑑(4) = 11, 𝑎(4) = 3, 𝑎(3) = 1 e 𝑎(1) = ∄. 

Durante a execução do algoritmo obteremos sucessivamente o menor caminho do vértice 

de origem a cada vértice do grafo, até que o vértice de nosso interesse seja atingido. Dessa forma, 

os  vértices  podem  ser  classificados  de  duas  formas,  para  as  quais  definiremos  os  conjuntos 

abaixo: 

  Conjunto 𝐹 dos vértices fechados: formados pelos vértices 𝑗 para os quais já se obteve o 

menor caminho de 𝑖 a 𝑗. 

 
 
 
 
  Conjunto 𝐴 dos vértices abertos: é o complementar de 𝐹 em relação a 𝑉, ou seja, 𝐴 =

𝑉 − 𝐹 

O passo a passo do algoritmo será apresentado a seguir. 

48 

Algoritmo de Dijkstra 

Seja 𝑀 = [𝑚(cid:3036)(cid:3037)] a matriz de manejo associada ao grafo, 𝑖 o vértice de origem, 𝑓 o vértice 

de destino e 𝑗 um vértice qualquer. 

1º Passo: Fazemos 𝑑(𝑖) = 0, e 𝑎(𝑖) = ∄ 

2º Passo: Fazemos 𝑑(𝑗) = 𝑚(cid:3036)(cid:3037) se existe a aresta (𝑖, 𝑗). Caso contrário e 𝑑(𝑗) = ∞. 

3º Passo: Fazemos 𝑎(𝑗) = ∄ se 𝑑(𝑗) = ∞. Caso contrário 𝑎(𝑗) = 𝑖; 

4º Passo: Fazemos 𝐹 = {𝑖} e 𝐴 = 𝑉 − 𝐹; 

5º Passo: Seja 𝑟 ∈ 𝐴 tal que 𝑑(𝑟) seja mínimo; 

6º Passo: Fechamos o vértice 𝑟. O retiramos de 𝐴 e o incluímos em 𝐹; 

7º Passo: Se 𝑟 = 𝑓 o algoritmo cessa. Caso contrário faça: 

(1): Para todo vértice 𝑠 ∈ 𝐴  tal que 𝑠 sucessor de 𝑟 calcule a soma 𝑑(𝑟) + 𝑚(cid:3045)(cid:3046); 

(2): Caso alguma soma da etapa (1) seja inferior a 𝑑(𝑠), substitua 𝑑(𝑠) por essa soma e 

faça 𝑎(𝑠) = 𝑟.  

(3): Retorne para o 5º passo. 

 
 
 
 
 
49 

4.4 Tópico 4: Aplicação do Algoritmo de Dijkstra 

Objetivo: Responder ao item a) do problema motivador.  

Desenvolvimento:  

  Retomar o item a) do problema motivador: “Quantos quilômetros serão percorridos para 

fazer uma entrega para a loja situada em Tatuí? Por quais cidades esse entregador passará?” 

  Aplicar o passo a passo do algoritmo  

Podemos  responder  à  primeira  pergunta  aplicando-se  o  Algoritmo  de  Dijkstra.  Nesse 

caso, o custo será a distância entre Campinas e Tatuí e os vértices que constituirão esse menor 

caminho serão as cidades percorridas pelo entregador. A Matriz de Manejo relacionada ao grafo 

é 

𝑀 =

0

71 ∞
0

∞ ∞ ∞ 39 28
0
⎤
⎡
115 ∞ ∞ ∞ ∞ ∞
71
⎥
⎢
107 ∞ 148 ∞ ∞
∞ 115
⎥
⎢
61 ∞ ∞ ∞
∞ ∞ 107
⎥
⎢
38 ∞ ∞
∞ ∞
0
⎥
⎢
48 27
∞ ∞ 164 ∞ 38
0
⎥
⎢
⎥
⎢
47
0
∞ ∞ 48
∞
39 ∞
0 ⎦
⎣
47
∞ ∞ 27
∞
28 ∞

0
∞ 52

Seguindo a rotulação proposta na Figura 37 temos 𝑖 = 1 e 𝑓 = 4. Executando os 4 primeiros 

passos do algoritmo: 

1º Passo: 𝑑(1) = 0 e 𝑎(1) = ∄ 

2º Passo: 𝑑(2) = 71; 𝑑(7) = 39; 𝑑(8) = 28 𝑒 𝑑(3) = 𝑑(4) = 𝑑(5) = 𝑑(6) = ∞ 

3º Passo: 𝑎(2) = 𝑎(7) = 𝑎(8) = 1 𝑒 𝑎(3) = 𝑎(4) = 𝑎(5) = 𝑎(6) = ∄ 

4º Passo: 𝐹 = {1} 𝑒 𝐴 = {2,3,4,5,6,7,8} 

A Figura 39 indica o estado atual do algoritmo. Os vértices fechados serão assinalados 

em vermelho. 

Figura 39 – Inicialização do Algoritmo de Dijkstra. 

 
 
 
 
 
 
A  partir  do  5º  passo  buscaremos  sucessivamente  o  vértice  mais  próximo  da  origem. 

Consultando a tabela da Figura 39 temos que o menor dos 𝑑(8) é o mais próximo da origem. 

Fonte: O autor, 2018 

50 

Executando o 5º e 6º passo temos: 

5º Passo: Fazemos 𝑟 = 8; 

6º Passo: 𝐹 = {1,8} 𝑒 𝐴 = {2,3,4,5,6,7} 

7º Passo: Neste passo verificamos se o vértice 𝑟 selecionado é o nosso vértice de destino. Como 

isso não ocorre o algoritmo segue. As etapas (1) e (2) desse passo verificam se o comprimento 

do caminho 𝑖 → 𝑟 → 𝑠, onde 𝑠 é um vértice aberto e adjacente a 𝑟, é menor que o comprimento 

𝑑(𝑠) que não possui 𝑟 como intermediário. Em caso afirmativo atualizamos os valores 𝑑(𝑠) e 

𝑎(𝑠). Nesse caso, avaliaremos os vértices 6 e 7 que são os únicos vértices adjacentes e abertos a 

8.  

𝑟 = 8 ≠ 4,  

(1) 𝑠 = 6 ⇒ 𝑑(8) + 𝑚(cid:2876)(cid:2874) = 55 
𝑠 = 7 ⇒ 𝑑(8) + 𝑚(cid:2876)(cid:2875) = 75 

(2) Como 𝑑(6) = ∞ > 55 atualizamos 𝑑(6) = 55 e 𝑎(6) = 8 

Como 𝑑(7) = 39 < 75 não alteramos 𝑑(7) e 𝑎(7). 

(3) Retorne para o 5º Passo. 

O caminho 1 → 8 → 6 menor comprimento que o caminho 1 → 8 que não possui 6 como 

intermediário.  Logo,  melhoramos  a  estimativa da  menor  distância  de  1  até  6  e  atualizamos  o 

vértice anterior a 6 para 8, pois é passando por 8 que temos esse caminho. Finalmente o algoritmo 

retorna para o 5º Passo, onde um novo vértice mais próximo a origem é escolhido. A Figura 40 

mostra estado atual do algoritmo. Assinalamos a aresta (1,8) em vermelho para indicar que ela 

comporá o menor caminho de algum vértice (o vértice 8 até o momento). 

Figura 40 – 1ª iteração do Algoritmo de Dijkstra 

 
 
5º  Passo:  Consultando  a  tabela  da  Figura  40  observamos  que  𝑑(7)  é  o  mínimo  do  conjunto 

Fonte: O autor, 2018 

51 

{𝑑(𝑗), 𝑗 ∈ 𝐴}. Portanto 𝑟 = 7. 

6º Passo: 𝐹 = {1,7,8} 𝑒 𝐴 = {2,3,4,5,6} 

7º  Passo:  Como  𝑟 = 7 ≠ 4  o  algoritmo  prossegue.  O  único  vértice aberto  adjacente  a  7  é  6. 

Então: 

(1) 𝑠 = 6 ⇒ 𝑑(7) + 𝑚(cid:2875)(cid:2874) = 87 
(2) Como 𝑑(6) = 55 < 87 não alteramos 𝑑(6) e 𝑎(6). 

(3) Retorne para o 5º Passo. 

Figura 41 – 2ª iteração do Algoritmo de Dijkstra 

 5º  Passo:  Consultando  a  tabela  da  Figura  41  observamos  que  𝑑(6)  é  o  mínimo  do  conjunto 

Fonte: O autor, 2018 

{𝑑(𝑗), 𝑗 ∈ 𝐴}. Portanto 𝑟 = 6. 

6º Passo: 𝐹 = {1,6,7,8} 𝑒 𝐴 = {2,3,4,5} 

7º Passo: Como 𝑟 = 6 ≠ 4 o algoritmo prossegue. Os vértices abertos adjacentes a 6 são 3 e 5. 

Então: 

(1) 𝑠 = 3 ⇒ 𝑑(6) + 𝑚(cid:2874)(cid:2871) = 203 
𝑠 = 5 ⇒ 𝑑(6) + 𝑚(cid:2874)(cid:2873) = 93 

(2) Como 𝑑(3) = ∞ > 203 atualizamos 𝑑(3) = 203 e 𝑎(3) = 6 

      Como 𝑑(5) = ∞ > 93 atualizamos 𝑑(5) = 93 e 𝑎(5) = 6 

(3) Retorne para o 5º Passo. 

 
 
 
 
 
 
 
 
 
Figura 42 – 3ª iteração do Algoritmo de Dijkstra 

52 

5º  Passo:  Consultando  a  tabela  da  Figura  42  observamos  que  𝑑(2)  é  o  mínimo  do  conjunto 

Fonte:  O autor, 2018 

{𝑑(𝑗), 𝑗 ∈ 𝐴}. Portanto 𝑟 = 2. 

6º Passo: 𝐹 = {1,2,6,7,8} 𝑒 𝐴 = {3,4,5} 

7º  Passo:  Como  𝑟 = 2 ≠ 4  o  algoritmo  prossegue.  O  único  vértice  aberto  adjacente  a  2  é  o 

vértice 3. Então: 

(1) 𝑠 = 3 ⇒ 𝑑(2) + 𝑚(cid:2870)(cid:2871) = 186 
(2) Como 𝑑(3) = 203 > 203 atualizamos 𝑑(3) = 186 e 𝑎(3) = 2 

(3) Retorne para o 5º Passo. 

Figura 43 – 4ª iteração do Algoritmo de Dijkstra 

5º  Passo:  Consultando  a  tabela  da  Figura  43  observamos  que  𝑑(5)  é  o  mínimo  do  conjunto 

Fonte: O autor, 2018 

{𝑑(𝑗), 𝑗 ∈ 𝐴}. Portanto 𝑟 = 5. 

6º Passo: 𝐹 = {1,2,5,6,7,8} 𝑒 𝐴 = {3,4} 

 
 
 
 
7º  Passo:  Como  𝑟 = 5 ≠ 4  o  algoritmo  prossegue.  O  único  vértice  aberto  adjacente  a  5  é  o 

vértice 4. Então: 

53 

(1) 𝑠 = 4 ⇒ 𝑑(5) + 𝑚(cid:2873)(cid:2872) = 145 
(2) Como 𝑑(4) = ∞ > 145 atualizamos 𝑑(4) = 145 e 𝑎(4) = 5 

(3) Retorne para o 5º Passo. 

Figura 44 – 5ª iteração do Algoritmo de Dijkstra 

5º  Passo:  Consultando  a  tabela  da  Figura  44  observamos  que  𝑑(4)  é  o  mínimo  do  conjunto 

Fonte: O autor, 2018 

{𝑑(𝑗), 𝑗 ∈ 𝐴}. Portanto 𝑟 = 4. 

6º Passo: 𝐹 = {1,2,4,5,6,7,8} 𝑒 𝐴 = {3} 

7º Passo: Como 𝑟 = 4 o algoritmo o algoritmo cessa. 

Figura 45 – Algoritmo de Dijkstra finalizado. 

Portanto, a distância percorrida de Campinas até Tatuí será de 145 km. Para respondermos 

à segunda pergunta do item a) comporemos o caminho utilizando a informação na lista 𝑎(𝑣). 

Fonte: O autor, 2018 

 
 
 
 
Iniciamos por 𝑎(4) = 5, pois 4 é o nosso vértice destino. Verificamos então que 𝑎(5) = 6. O 

processo se repete até que 𝑎(𝑣) = 1, que é o nosso vértice de partida. Assim: 

54 

𝑎(4) = 5 

𝑎(5) = 6 

𝑎(6) = 8 

𝑎(8) = 1 

Portanto o caminho percorrerá os vértices 1, 8, 6, 5 e 4, sendo 1 e 4 os pontos de partida e de 

chegada respectivamente. Consultando a tabela da figura x verificamos que o caminhão passará 

nas cidades de Indaiatuba, Itu e Sorocaba, nesta ordem, antes de chegar em Tatuí. 

 
 
 
 
 
55 

4.5 Tópico 5: O Algoritmo de Floyd-Warshall 

Objetivo: Apresentar o passo a passo do Algoritmo de Floyd-Warshall.  

Desenvolvimento:  

  Apresentar historicamente Bernard Roy, Robert Floyd e Stephen Warshall. 

Explicar a finalidade do algoritmo bem como o seu passo a passo. Como no algoritmo de 

Dijkstra, foi feita uma adequação da linguagem  do conteúdo apresentado no capítulo 3 como 

descreveremos a seguir. 

Seja 𝐺 um grafo com 𝑛 vértices. Baseado na Matriz de Manejo de 𝐺, devemos construir 

uma outra matriz 𝑅(cid:3041)×(cid:3041) = [𝑟(cid:3036)(cid:3037)] denominada Matriz de Roteamento. Essa matriz fornecerá a “rota” 

que devemos estabelecer entre os vértices na construção do menor caminho entre dois vértices 

do grafo. Ela é definida como se segue: 

𝑟(cid:3036)(cid:3037) = (cid:3420)

𝑗, 𝑠𝑒 𝑒𝑥𝑖𝑠𝑡𝑒 𝑜 𝑎𝑟𝑐𝑜 (𝑖, 𝑗)        
0, 𝑠𝑒 𝑛ã𝑜 𝑒𝑥𝑖𝑠𝑡𝑒 𝑜 𝑎𝑟𝑐𝑜 (𝑖, 𝑗)

O elemento  𝑟(cid:3036)(cid:3037) indica qual é o vértice seguinte a 𝑖 no menor caminho de 𝑖 até 𝑗 (caso 

exista). Inicialmente temos que o menor caminho entre dois vértices é igual ao peso do arco que 

os une. Dessa forma, 𝑟(cid:3036)(cid:3037) = 𝑗 se existir o arco (𝑖, 𝑗), ou seja, o vértice seguinte a 𝑖 no caminho 𝑖 →

𝑗 é o próprio 𝑗. Caso não exista esse arco, não há inicialmente um caminho possível de 𝑖 até 𝑗 e 

indicamos a ausência desse caminho fazendo 𝑟(cid:3036)(cid:3037) = 𝑗. 

O algoritmo fará uma iteração para cada um de seus vértices e atualizará as matrizes de 

manejo e de roteamento. Em cada iteração 𝑘 será verificado, com base na matriz de manejo, se 

o comprimento do caminho do vértice 𝑖 até o vértice 𝑗, tendo 𝑘 como intermediário, é menor do 

que o comprimento já existente entre esses vértices. Em símbolos: 

𝑚(cid:3036)(cid:3038) + 𝑚(cid:3038)(cid:3037) < 𝑚(cid:3036)(cid:3037). 

Caso se verifique a última desigualdade substituímos o valor de 𝑚(cid:3036)(cid:3037) por 𝑚(cid:3036)(cid:3038) + 𝑚(cid:3038)(cid:3037) na 

matriz de manejo. Em seguida devemos atualizar a matriz de roteamento. Se para atingir 𝑗 a partir 

de 𝑖 devemos passar primeiro por 𝑘, então 𝑟(cid:3036)(cid:3037) deve ser atualizado com o vértice seguinte a 𝑖 no 

caminho 𝑖 → 𝑘, ou seja 𝑟(cid:3036)(cid:3038). 

Esse processo se repete em cada iteração para todo 𝑖, 𝑗 ≠ 𝑘, já que ao tomarmos 𝑘 como 

intermediário, não podemos tê-lo como vértice de origem ou de destino. 

Cabe ressaltar que se 𝑚(cid:3036)(cid:3038) = ∞ ou 𝑚(cid:3038)(cid:3037) = ∞, a distância de 𝑖 até 𝑗 não será melhorada 

(reduzida) pois o membro esquerdo da desigualdade será sempre maior. Isso pode ser útil quando 

executamos o algoritmo manualmente, poupando checagens desnecessárias.  

Para obter a sequências de vértices que determina o caminho mínimo de 𝑖 → 𝑗, devemos 

consultar o elemento 𝑟(cid:3036)(cid:3037) da matriz de roteamento. Se 𝑟(cid:3036)(cid:3037) = 𝑎, significa que o caminho passa por 

 
 
 
 
 
 
 
 
𝑎 depois de 𝑖. Devemos agora localizar o elemento 𝑟(cid:3028)(cid:3037), que indicará o próximo vértice depois de 

𝑎. Se 𝑟(cid:3028)(cid:3037) = 𝑏 então 𝑏 é o vértice seguinte a 𝑎 no caminho mínimo. Esse processo continua até 

56 

que 𝑟(cid:3051)(cid:3037) = 𝑗, gerando o caminho 

(𝑖, 𝑎, 𝑏, … , 𝑗) 

Abaixo temos o passo a passo do algoritmo. 

Algoritmo de Floyd-Warshall 

Seja 𝐺 = (𝑉, 𝐸) um grafo com 𝑛 vértices, onde 𝑉 = {1,2, … , 𝑛}. 

1º Passo: 𝑘 = min (𝑉). Remova 𝑘 de V. 

2º  Passo:  Para  todo  𝑚(cid:3036)(cid:3037),  com  𝑖, 𝑗 ≠ 𝑘,  verifique  se  𝑚(cid:3036)(cid:3038) + 𝑚(cid:3038)(cid:3037) < 𝑚(cid:3036)(cid:3037).  Em  caso  afirmativo 

substitua 𝑚(cid:3036)(cid:3037) por 𝑚(cid:3036)(cid:3038) + 𝑚(cid:3038)(cid:3037) e 𝑟(cid:3036)(cid:3037) por 𝑟(cid:3036)(cid:3038). 

3º Passo: Se 𝑘 = 𝑛 o algoritmo cessa. Caso contrário retorne ao 1º Passo. 

 
 
 
 
 
 
 
57 

4.6 Tópico 6: Aplicação do Algoritmo de Floyd-Warshall 

Objetivo: Responder ao item b) do problema motivador.  

Desenvolvimento:  

  Retomar o item b) do problema motivador: “Suponha agora que a central de distribuição 

possa ser instalada em qualquer uma das cidades. Em qual delas você a instalaria? Por 

que?” 

  Aplicar o passo a passo do algoritmo. 

É mais vantajoso instalar o centro de distribuição na cidade que seja mais próxima de 

todas as outras, pois assim o custo com combustível será o menor possível. Em outras palavras, 

estamos procurando uma cidade cuja soma das distâncias até as outras seja a menor possível. 

Podemos aplicar o algoritmo de Floyd-Warshall para determinar qual é a menor distância entre 

todas as cidades e em seguida calcular a soma dessas distâncias para cada cidade. Resgatando o 

grafo do problema motivador temos as seguintes matrizes de manejo e de roteamento. 

Figura 46 – Matrizes de Manejo e de Roteamento do Problema Motivador. 

Para este grafo temos 𝑉 = {1,2,3,4,5,6,7,8}. Vamos aplicar o algoritmo. 

Fonte: O autor, 2018 

1º Passo: min(𝑉) = 1. Excluímos o vértice 1 de 𝑉:  𝑉 = {2,3,4,5,6,7,8} 

1ª Iteração 

2º Passo:  

Para 𝑖 = 2 temos que  

𝑚(cid:2870)(cid:2869) + 𝑚(cid:2869)(cid:2875) < 𝑚(cid:2870)(cid:2875) 𝑒 𝑚(cid:2870)(cid:2869) + 𝑚(cid:2869)(cid:2876) < 𝑚(cid:2870)(cid:2876). 

Nos  outros,  𝑚(cid:2870)(cid:2871) = 𝑚(cid:2870)(cid:2872) = 𝑚(cid:2870)(cid:2873) = 𝑚(cid:2870)(cid:2874) = ∞,  logo  as  distâncias  não  serão  melhoradas. 

Substituímos os valores de 𝑚(cid:2870)(cid:2875) e 𝑚(cid:2870)(cid:2876) com os valores das respectivas somas: 

𝑚(cid:2870)(cid:2875) = 𝑚(cid:2870)(cid:2869) + 𝑚(cid:2869)(cid:2875) = 120 𝑒 𝑚(cid:2870)(cid:2876) =   𝑚(cid:2870)(cid:2869) + 𝑚(cid:2869)(cid:2876) = 99. 

 
 
 
 
 
  Em seguida substituímos o valor de 𝑟(cid:2870)(cid:2875) por 𝑟(cid:2870)(cid:2869) = 1, que é o vértice pelo qual se deve 

passar a partir de 2 para chegar a 1. O mesmo é feito com relação a 𝑚(cid:2870)(cid:2876). A Figura 46 ilustra essas 

mudanças  na  1ª  iteração.  A  cada  iteração  sempre  fixaremos  a  linha  e  coluna  𝑘  na  matriz  de 

manejo e a coluna 𝑘 na matriz de pesos de maneira a tornar o processo manual mais simples. 

Figura 47 – Matrizes de Manejo e de Roteamento durante a 1ª iteração do algoritmo. 

58 

Fonte: O autor, 2018 

Para 𝑖 = 3,4,5,6 temos 𝑚(cid:2871)(cid:2869) = 𝑚(cid:2872)(cid:2869) = 𝑚(cid:2873)(cid:2869) = 𝑚(cid:2874)(cid:2869) = ∞. Logo as distâncias 2,3,4,5 e 6, tomando 

o vértice 1 como intermediário, até os outros vértices não poderá ser melhorada (não há conexão 

desses vértices com o vértice 1). Assim, não alteraremos as linhas 2,3,4,5 e 6 nesta iteração. 

Para 𝑖 = 7 temos apenas  

𝑚(cid:2875)(cid:2869) + 𝑚(cid:2869)(cid:2870) < 𝑚(cid:2875)(cid:2870). 

Assim, 𝑚(cid:2875)(cid:2870) = 𝑚(cid:2875)(cid:2869) + 𝑚(cid:2869)(cid:2870) = 120 e 𝑟(cid:2875)(cid:2870) = 𝑟(cid:2875)(cid:2869) = 1 

Para 𝑖 = 8 temos apenas 

𝑚(cid:2875)(cid:2869) + 𝑚(cid:2869)(cid:2870) < 𝑚(cid:2875)(cid:2870). 

Assim, 𝑚(cid:2876)(cid:2870) = 𝑚(cid:2876)(cid:2869) + 𝑚(cid:2869)(cid:2870) = 99 e 𝑟(cid:2876)(cid:2870) = 𝑟(cid:2875)(cid:2869) = 1 

3º Passo: Como 𝑘 = 1 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo.  

Ao final da 1ª iteração temos as seguintes matrizes de manejo e de roteamento conforme 

mostrado na Figura 47. 

Figura 48 – Matrizes de Manejo e de Roteamento após a 1ª iteração.  

Fonte: O autor, 2018 

 
 
 
 
1º Passo: min(𝑉) = 2. Excluímos o vértice 2 de 𝑉:  𝑉 = {3,4,5,6,7,8} 

2ª Iteração 

2º Passo: 

Figura 49 – Matrizes preparadas para o início das comparações da 2ª iteração. 

59 

  Para 𝑖 = 1 e 

Fonte: O autor, 2018 

 𝑗 = 3: 𝑚(cid:2869)(cid:2870) + 𝑚(cid:2870)(cid:2871) < 𝑚(cid:2869)(cid:2871). Assim 𝑚(cid:2869)(cid:2871) = 𝑚(cid:2869)(cid:2870) + 𝑚(cid:2870)(cid:2871) = 186 e  𝑟(cid:2869)(cid:2871) =   𝑟(cid:2869)(cid:2870) = 2; 

𝑗 = 4,5,6,7,8: 𝑚(cid:2869)(cid:2870) + 𝑚(cid:2870)(cid:3037) > 𝑚(cid:2869)(cid:3037). Não há alterações a fazer. 

  Para 𝑖 = 3 e 

𝑗 = 1: 𝑚(cid:2871)(cid:2870) + 𝑚(cid:2870)(cid:2869) < 𝑚(cid:2871)(cid:2869). Portanto 𝑚(cid:2871)(cid:2869) = 𝑚(cid:2871)(cid:2870) + 𝑚(cid:2870) = 186 e  𝑟(cid:2871)(cid:2869) =   𝑟(cid:2871)(cid:2870) = 2; 

𝑗 = 4,5,6: não há nada a se fazer pois 𝑚(cid:2871)(cid:3037) = ∞; 

𝑗 = 7,8: 𝑚(cid:2871)(cid:2870) + 𝑚(cid:2870)(cid:2875) < 𝑚(cid:2871)(cid:2875) e 𝑚(cid:2871)(cid:2870) + 𝑚(cid:2870)(cid:2876) < 𝑚(cid:2871)(cid:2876). Então 

𝑚(cid:2871)(cid:2875) = 𝑚(cid:2871)(cid:2870) + 𝑚(cid:2870)(cid:2875) = 235 e  𝑟(cid:2871)(cid:2875) =   𝑟(cid:2871)(cid:2870) = 2; 

𝑚(cid:2871)(cid:2876) = 𝑚(cid:2871)(cid:2870) + 𝑚(cid:2870)(cid:2876) = 214 e  𝑟(cid:2871)(cid:2876) =   𝑟(cid:2871)(cid:2870) = 2. 

  Para 𝑖 = 4,5,6 não há nada a se fazer pois 𝑚(cid:3036)(cid:2870) = ∞. 

  Para 𝑖 = 7 e 

𝑗 = 1,4,5,6,8: 𝑚(cid:2875)(cid:2870) + 𝑚(cid:2870)(cid:3037) > 𝑚(cid:2875)(cid:3037) e não há nada a fazer; 

𝑗 = 3: 𝑚(cid:2875)(cid:2870) + 𝑚(cid:2870)(cid:2871) < 𝑚(cid:2875)(cid:2871). Então 𝑚(cid:2875)(cid:2871) = 𝑚(cid:2875)(cid:2870) + 𝑚(cid:2870)(cid:2871) = 235 e 𝑟(cid:2875)(cid:2871) =   𝑟(cid:2875)(cid:2870) = 1. 

  Para 𝑖 = 8 e 

𝑗 = 1,4,5,6,7: 𝑚(cid:2876)(cid:2870) + 𝑚(cid:2870)(cid:3037) > 𝑚(cid:2876)(cid:3037) e não há nada a fazer; 

𝑗 = 3: 𝑚(cid:2876)(cid:2870) + 𝑚(cid:2870)(cid:2871) < 𝑚(cid:2876)(cid:2871). Então 𝑚(cid:2876)(cid:2871) = 𝑚(cid:2876)(cid:2870) + 𝑚(cid:2870)(cid:2871) = 214 e 𝑟(cid:2876)(cid:2871) =   𝑟(cid:2876)(cid:2870) = 1. 

3º Passo: Como 𝑘 = 1 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo.  

 
 
 
 
 
 
 
 
Figura 50 – Matrizes de Manejo e de Roteamento após a 2ª iteração. 

60 

Fonte: O autor, 2018 

3ª Iteração 

1º Passo: min(𝑉) = 3. Excluímos o vértice de 𝑉:  𝑉 = {4,5,6,7,8} 

2º Passo: 

Figura 51 – Matrizes preparadas para o início das comparações da 3ª iteração. 

  Para 𝑖 = 1 e 

Fonte: O autor, 2018 

 𝑗 = 2,5,7,8: 𝑚(cid:2869)(cid:2871) + 𝑚(cid:2871)(cid:3037) > 𝑚(cid:2869)(cid:3037) e não há nada a fazer; 

𝑗 = 4,6: 𝑚(cid:2869)(cid:2871) + 𝑚(cid:2871)(cid:2872) < 𝑚(cid:2869)(cid:2872) e 𝑚(cid:2869)(cid:2871) + 𝑚(cid:2871)(cid:2874) < 𝑚(cid:2869)(cid:2874). Então, 

𝑚(cid:2869)(cid:2872) = 𝑚(cid:2869)(cid:2871) + 𝑚(cid:2871)(cid:2872) = 393 e  𝑟(cid:2869)(cid:2872) =   𝑟(cid:2869)(cid:2871) = 2; 

𝑚(cid:2869)(cid:2874) = 𝑚(cid:2869)(cid:2871) + 𝑚(cid:2871)(cid:2874) = 434 e  𝑟(cid:2869)(cid:2874) =   𝑟(cid:2869)(cid:2871) = 2; 

  Para 𝑖 = 2 e 

𝑗 = 1,5,7,8: 𝑚(cid:2870)(cid:2871) + 𝑚(cid:2871)(cid:3037) > 𝑚(cid:2869)(cid:3037) e não há nada a fazer; 

𝑗 = 4,6: 𝑚(cid:2870)(cid:2871) + 𝑚(cid:2871)(cid:2872) < 𝑚(cid:2870)(cid:2872) e 𝑚(cid:2870)(cid:2871) + 𝑚(cid:2871)(cid:2874) < 𝑚(cid:2870)(cid:2874). Então, 

𝑚(cid:2870)(cid:2872) = 𝑚(cid:2870)(cid:2871) + 𝑚(cid:2871)(cid:2872) = 263 e  𝑟(cid:2870)(cid:2872) =   𝑟(cid:2870)(cid:2871) = 3; 

𝑚(cid:2870)(cid:2874) = 𝑚(cid:2870)(cid:2871) + 𝑚(cid:2871)(cid:2874) = 434 e  𝑟(cid:2870)(cid:2874) =   𝑟(cid:2870)(cid:2871) = 3; 

 
 
 
 
 
61 

  Para 𝑖 = 4 e 

𝑗 = 1: 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2869) < 𝑚(cid:2872)(cid:2869). Portanto 𝑚(cid:2872)(cid:2869) = 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2869) = 393 e  𝑟(cid:2872)(cid:2869) =   𝑟(cid:2872)(cid:2871) = 3; 

𝑗 = 2: 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2870) < 𝑚(cid:2872)(cid:2870). Portanto 𝑚(cid:2872)(cid:2870) = 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2870) = 222 e  𝑟(cid:2872)(cid:2870) =   𝑟(cid:2872)(cid:2871) = 3; 

𝑗 = 5: Não há nada a fazer pois 𝑚(cid:2871)(cid:2873) = ∞; 

𝑗 = 6: 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2874) < 𝑚(cid:2872)(cid:2874). Portanto 𝑚(cid:2872)(cid:2874) = 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2874) = 255 e  𝑟(cid:2872)(cid:2874) =   𝑟(cid:2872)(cid:2871) = 3; 

𝑗 = 7: 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2875) < 𝑚(cid:2872)(cid:2875). Portanto 𝑚(cid:2872)(cid:2875) = 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2875) = 342 e  𝑟(cid:2872)(cid:2875) =   𝑟(cid:2872)(cid:2871) = 3; 

𝑗 = 8: 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2876) < 𝑚(cid:2872)(cid:2876). Portanto 𝑚(cid:2872)(cid:2876) = 𝑚(cid:2872)(cid:2871) + 𝑚(cid:2871)(cid:2876) = 321 e  𝑟(cid:2872)(cid:2876) =   𝑟(cid:2872)(cid:2871) = 3; 

  Para 𝑖 = 5 não há nada a fazer pois 𝑚(cid:2873)(cid:2871) = ∞; 

  Para 𝑖 = 6 e 

𝑗 = 1: 𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:2869) < 𝑚(cid:2874)(cid:2869). Portanto 𝑚(cid:2874)(cid:2869) = 𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:2869) = 450 e  𝑟(cid:2874)(cid:2869) =   𝑟(cid:2874)(cid:2871) = 1; 

𝑗 = 2: 𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:2870) < 𝑚(cid:2874)(cid:2870). Portanto 𝑚(cid:2874)(cid:2870) = 𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:2870) = 279 e  𝑟(cid:2874)(cid:2870) =   𝑟(cid:2874)(cid:2871) = 1; 

𝑗 = 4: 𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:2872) < 𝑚(cid:2874)(cid:2872). Portanto 𝑚(cid:2874)(cid:2872) = 𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:2872) = 271 e  𝑟(cid:2874)(cid:2872) =   𝑟(cid:2874)(cid:2871) = 1; 

𝑗 = 5: Não há nada a fazer pois 𝑚(cid:2871)(cid:2873) = ∞; 

𝑗 = 7,8:  𝑚(cid:2874)(cid:2871) + 𝑚(cid:2871)(cid:3037) > 𝑚(cid:2874)(cid:3037) e não há nada a fazer; 

  Para 𝑖 = 7 e 

𝑗 = 1,2,5,6,8:  𝑚(cid:2875)(cid:2871) + 𝑚(cid:2871)(cid:3037) > 𝑚(cid:2875)(cid:3037) e não há nada a fazer; 

𝑗 = 4: 𝑚(cid:2875)(cid:2871) + 𝑚(cid:2871)(cid:2872) < 𝑚(cid:2875)(cid:2872). Portanto 𝑚(cid:2875)(cid:2872) = 𝑚(cid:2875)(cid:2871) + 𝑚(cid:2871)(cid:2872) = 342 e  𝑟(cid:2875)(cid:2872) =   𝑟(cid:2875)(cid:2871) = 1; 

  Para 𝑖 = 8 e 

𝑗 = 1,2,5,6,7:  𝑚(cid:2876)(cid:2871) + 𝑚(cid:2871)(cid:3037) > 𝑚(cid:2876)(cid:3037) e não há nada a fazer; 

𝑗 = 4: 𝑚(cid:2876)(cid:2871) + 𝑚(cid:2871)(cid:2872) < 𝑚(cid:2876)(cid:2872). Portanto 𝑚(cid:2876)(cid:2872) = 𝑚(cid:2876)(cid:2871) + 𝑚(cid:2871)(cid:2872) = 321 e  𝑟(cid:2875)(cid:2872) =   𝑟(cid:2876)(cid:2871) = 1; 

3º Passo: Como 𝑘 = 3 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo. 

Figura 52 – Matrizes de Manejo e de Roteamento após a 3ª iteração. 

Fonte: O autor, 2018 

 
 
 
 
 
1º Passo: min(𝑉) = 4. Excluímos o vértice de 𝑉:  𝑉 = {5,6,7,8} 

4ª Iteração 

2º Passo: 

Figura 53 – Matrizes preparadas para o início das comparações da 4ª iteração. 

62 

  Para 𝑖 = 1 e 

Fonte: O autor, 2018 

𝑗 = 2,3,6,7,8:  𝑚(cid:2869)(cid:2872) + 𝑚(cid:2872)(cid:3037) > 𝑚(cid:2869)(cid:3037) e não há nada a fazer; 

𝑗 = 5: 𝑚(cid:2869)(cid:2872) + 𝑚(cid:2872)(cid:2873) < 𝑚(cid:2869)(cid:2873). Portanto 𝑚(cid:2869)(cid:2873) = 𝑚(cid:2869)(cid:2872) + 𝑚(cid:2872)(cid:2873) = 454 e  𝑟(cid:2869)(cid:2873) =   𝑟(cid:2869)(cid:2872) = 2; 

  Para 𝑖 = 2 e 

𝑗 = 1,3,6,7,8:  𝑚(cid:2870)(cid:2872) + 𝑚(cid:2872)(cid:3037) > 𝑚(cid:2870)(cid:3037) e não há nada a fazer; 

𝑗 = 5: 𝑚(cid:2870)(cid:2872) + 𝑚(cid:2872)(cid:2873) < 𝑚(cid:2869)(cid:2873). Portanto 𝑚(cid:2870)(cid:2873) = 𝑚(cid:2870)(cid:2872) + 𝑚(cid:2872)(cid:2873) = 283 e  𝑟(cid:2870)(cid:2873) =   𝑟(cid:2870)(cid:2872) = 3; 

  Para 𝑖 = 3 e 

𝑗 = 1,2,6,7,8:  𝑚(cid:2871)(cid:2872) + 𝑚(cid:2872)(cid:3037) > 𝑚(cid:2871)(cid:3037) e não há nada a fazer; 

𝑗 = 5: 𝑚(cid:2871)(cid:2872) + 𝑚(cid:2872)(cid:2873) < 𝑚(cid:2869)(cid:2873). Portanto 𝑚(cid:2871)(cid:2873) = 𝑚(cid:2870)(cid:2872) + 𝑚(cid:2872)(cid:2873) = 168 e  𝑟(cid:2871)(cid:2873) =   𝑟(cid:2871)(cid:2872) = 4; 

  Para 𝑖 = 5 e 

𝑗 = 1: 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2869) < 𝑚(cid:2873)(cid:2869). Portanto 𝑚(cid:2873)(cid:2869) = 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2869) = 445 e  𝑟(cid:2873)(cid:2869) =   𝑟(cid:2873)(cid:2872) = 4; 

𝑗 = 2: 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2870) < 𝑚(cid:2873)(cid:2870). Portanto 𝑚(cid:2873)(cid:2870) = 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2870) = 274 e  𝑟(cid:2873)(cid:2870) =   𝑟(cid:2873)(cid:2872) = 4; 

𝑗 = 3: 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2871) < 𝑚(cid:2873)(cid:2871). Portanto 𝑚(cid:2873)(cid:2871) = 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2871) = 159 e  𝑟(cid:2873)(cid:2871) =   𝑟(cid:2873)(cid:2872) = 4; 

𝑗 = 6: 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2874) > 𝑚(cid:2873)(cid:2874) e não há nada a fazer; 

𝑗 = 7: 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2875) < 𝑚(cid:2873)(cid:2875). Portanto 𝑚(cid:2873)(cid:2875) = 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2875) = 394 e  𝑟(cid:2873)(cid:2875) =   𝑟(cid:2873)(cid:2872) = 4; 

𝑗 = 8: 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2876) < 𝑚(cid:2873)(cid:2876). Portanto 𝑚(cid:2873)(cid:2876) = 𝑚(cid:2873)(cid:2872) + 𝑚(cid:2872)(cid:2876) = 373 e  𝑟(cid:2873)(cid:2869) =   𝑟(cid:2873)(cid:2872) = 4; 

  Para 𝑖 = 6 não há nada a fazer pois 𝑚(cid:2874)(cid:2872) + 𝑚(cid:2872)(cid:3037) > 𝑚(cid:2874)(cid:3037), para todo 𝑗 = 1,2,3,5,7,8; 

  Para 𝑖 = 7 e 

𝑗 = 1,2,3,6,8:  𝑚(cid:2875)(cid:2872) + 𝑚(cid:2872)(cid:3037) > 𝑚(cid:2875)(cid:3037) e não há nada a fazer; 

𝑗 = 5: 𝑚(cid:2875)(cid:2872) + 𝑚(cid:2872)(cid:2873) < 𝑚(cid:2875)(cid:2873). Portanto 𝑚(cid:2875)(cid:2873) = 𝑚(cid:2875)(cid:2872) + 𝑚(cid:2872)(cid:2873) = 403 e  𝑟(cid:2875)(cid:2873) =   𝑟(cid:2875)(cid:2872) = 1; 

  Para 𝑖 = 8 e 

 
 
𝑗 = 1,2,3,6,7:  𝑚(cid:2876)(cid:2872) + 𝑚(cid:2872)(cid:3037) > 𝑚(cid:2876)(cid:3037) e não há nada a fazer; 

𝑗 = 5: 𝑚(cid:2876)(cid:2872) + 𝑚(cid:2872)(cid:2873) < 𝑚(cid:2876)(cid:2873). Portanto 𝑚(cid:2876)(cid:2873) = 𝑚(cid:2876)(cid:2872) + 𝑚(cid:2872)(cid:2873) = 382 e  𝑟(cid:2876)(cid:2873) =   𝑟(cid:2876)(cid:2872) = 1; 

63 

3º Passo: Como 𝑘 = 4 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo.  

Figura 54 – Matrizes de Manejo e de Roteamento após a 4ª iteração. 

Fonte: O autor, 2018 

5ª Iteração 

1º Passo: min(𝑉) = 5. Excluímos o vértice de 𝑉:  𝑉 = {6,7,8} 

2º Passo: 

Figura 55 – Matrizes preparadas para o início das comparações da 5ª iteração. 

Fonte: O autor, 2018 

  Para 𝑖 = 1 não há nada a fazer pois 𝑚(cid:2869)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2869)(cid:3037), para todo 𝑗 = 2,3,4,6,7,8; 

  Para 𝑖 = 2 não há nada a fazer pois 𝑚(cid:2870)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2870)(cid:3037), para todo 𝑗 = 1,3,4,6,7,8; 

  Para 𝑖 = 3 não há nada a fazer pois 𝑚(cid:2871)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2871)(cid:3037), para todo 𝑗 = 1,2,4,6,7,8; 

  Para 𝑖 = 4 e 

𝑗 = 1,2,3,7,8: 𝑚(cid:2872)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2872)(cid:3037) e não há o que fazer; 

𝑗 = 6: 𝑚(cid:2872)(cid:2873) + 𝑚(cid:2873)(cid:2874) < 𝑚(cid:2872)(cid:2874). Portanto 𝑚(cid:2872)(cid:2874) = 𝑚(cid:2872)(cid:2873) + 𝑚(cid:2873)(cid:2874) = 99 e  𝑟(cid:2872)(cid:2874) =   𝑟(cid:2872)(cid:2873) = 5; 

 
 
 
 
 
 
64 

  Para 𝑖 = 6 e 

𝑗 = 1,2,3,7,8: 𝑚(cid:2874)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2872)(cid:3037) e não há o que fazer; 

𝑗 = 4: 𝑚(cid:2874)(cid:2873) + 𝑚(cid:2873)(cid:2872) < 𝑚(cid:2874)(cid:2872). Portanto 𝑚(cid:2874)(cid:2872) = 𝑚(cid:2874)(cid:2873) + 𝑚(cid:2873)(cid:2872) = 90 e  𝑟(cid:2874)(cid:2872) =   𝑟(cid:2874)(cid:2873) = 5; 

  Para 𝑖 = 7 não há nada a fazer pois 𝑚(cid:2875)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2875)(cid:3037), para todo 𝑗 = 1,2,3,4,6,8; 

  Para 𝑖 = 8 não há nada a fazer pois 𝑚(cid:2876)(cid:2873) + 𝑚(cid:2873)(cid:3037) > 𝑚(cid:2876)(cid:3037), para todo 𝑗 = 1,2,3,4,7,8; 

3º Passo: Como 𝑘 = 5 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo.  

Figura 56 – Matrizes de Manejo e de Roteamento após a 5ª iteração. 

Fonte: O autor, 2018 

6ª Iteração 

1º Passo: min(𝑉) = 6. Excluímos o vértice de 𝑉:  𝑉 = {7,8} 

2º Passo: 

Figura 57 – Matrizes preparadas para o início das comparações da 6ª iteração. 

Fonte: O autor, 2018 

  Para 𝑖 = 1 não há nada a fazer pois 𝑚(cid:2869)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2869)(cid:3037), para todo 𝑗 = 2,3,4,5,7,8; 

  Para 𝑖 = 2 não há nada a fazer pois 𝑚(cid:2870)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2870)(cid:3037), para todo 𝑗 = 1,3,4,5,7,8; 

  Para 𝑖 = 3 e 

 
 
 
 
 
 
65 

𝑗 = 1,2,4,5: 𝑚(cid:2871)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2871)(cid:3037) e não há nada a fazer; 

𝑗 = 7: 𝑚(cid:2871)(cid:2874) + 𝑚(cid:2874)(cid:2875) < 𝑚(cid:2871)(cid:2875). Portanto 𝑚(cid:2871)(cid:2875) = 𝑚(cid:2871)(cid:2874) + 𝑚(cid:2874)(cid:2875) = 196 e  𝑟(cid:2871)(cid:2875) =   𝑟(cid:2871)(cid:2874) = 6; 

𝑗 = 8: 𝑚(cid:2871)(cid:2874) + 𝑚(cid:2874)(cid:2876) < 𝑚(cid:2871)(cid:2876). Portanto 𝑚(cid:2871)(cid:2876) = 𝑚(cid:2871)(cid:2874) + 𝑚(cid:2874)(cid:2876) = 175 e  𝑟(cid:2871)(cid:2875) =   𝑟(cid:2871)(cid:2874) = 6; 

  Para 𝑖 = 4 e 

𝑗 = 1,2,3,5: 𝑚(cid:2872)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2872)(cid:3037) e não há nada a fazer; 

𝑗 = 7: 𝑚(cid:2872)(cid:2874) + 𝑚(cid:2874)(cid:2875) < 𝑚(cid:2872)(cid:2875). Portanto 𝑚(cid:2872)(cid:2875) = 𝑚(cid:2872)(cid:2874) + 𝑚(cid:2874)(cid:2875) = 147 e  𝑟(cid:2872)(cid:2875) =   𝑟(cid:2872)(cid:2874) = 5; 

𝑗 = 8: 𝑚(cid:2872)(cid:2874) + 𝑚(cid:2874)(cid:2876) < 𝑚(cid:2872)(cid:2876). Portanto 𝑚(cid:2872)(cid:2876) = 𝑚(cid:2872)(cid:2874) + 𝑚(cid:2874)(cid:2876) = 126 e  𝑟(cid:2872)(cid:2876) =   𝑟(cid:2872)(cid:2874) = 5; 

  Para 𝑖 = 5 e 

𝑗 = 1,2,3,4: 𝑚(cid:2873)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2873)(cid:3037) e não há nada a fazer; 

𝑗 = 7: 𝑚(cid:2873)(cid:2874) + 𝑚(cid:2874)(cid:2875) < 𝑚(cid:2873)(cid:2875). Portanto 𝑚(cid:2873)(cid:2875) = 𝑚(cid:2873)(cid:2874) + 𝑚(cid:2874)(cid:2875) = 86 e  𝑟(cid:2873)(cid:2875) =   𝑟(cid:2873)(cid:2874) = 6; 

𝑗 = 8: 𝑚(cid:2872)(cid:2874) + 𝑚(cid:2874)(cid:2876) < 𝑚(cid:2872)(cid:2876). Portanto 𝑚(cid:2873)(cid:2876) = 𝑚(cid:2873)(cid:2874) + 𝑚(cid:2874)(cid:2876) = 65 e  𝑟(cid:2873)(cid:2876) =   𝑟(cid:2873)(cid:2874) = 6; 

  Para 𝑖 = 7 e 

𝑗 = 1,2,8: 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2875)(cid:3037) e não há nada a fazer; 

𝑗 = 3: 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:2871) < 𝑚(cid:2875)(cid:2871). Portanto 𝑚(cid:2875)(cid:2871) = 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:2871) = 212 e  𝑟(cid:2875)(cid:2872) =   𝑟(cid:2875)(cid:2874) = 6; 

𝑗 = 4: 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:2872) < 𝑚(cid:2875)(cid:2872). Portanto 𝑚(cid:2875)(cid:2872) = 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:2872) = 138 e  𝑟(cid:2875)(cid:2872) =   𝑟(cid:2875)(cid:2874) = 6; 

𝑗 = 5: 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:2873) < 𝑚(cid:2875)(cid:2873). Portanto 𝑚(cid:2875)(cid:2873) = 𝑚(cid:2875)(cid:2874) + 𝑚(cid:2874)(cid:2873) = 86 e  𝑟(cid:2875)(cid:2873) =   𝑟(cid:2875)(cid:2874) = 6; 

  Para 𝑖 = 8 e 

𝑗 = 1,2,7: 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:3037) > 𝑚(cid:2875)(cid:3037) e não há nada a fazer; 

𝑗 = 3: 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:2871) < 𝑚(cid:2876)(cid:2871). Portanto 𝑚(cid:2876)(cid:2871) = 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:2871) = 191 e  𝑟(cid:2876)(cid:2871) =   𝑟(cid:2876)(cid:2874) = 6; 

𝑗 = 4: 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:2872) < 𝑚(cid:2876)(cid:2872). Portanto 𝑚(cid:2876)(cid:2872) = 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:2872) = 117 e  𝑟(cid:2876)(cid:2872) =   𝑟(cid:2876)(cid:2874) = 6; 

𝑗 = 5: 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:2873) < 𝑚(cid:2876)(cid:2873). Portanto 𝑚(cid:2876)(cid:2873) = 𝑚(cid:2876)(cid:2874) + 𝑚(cid:2874)(cid:2873) = 65e  𝑟(cid:2876)(cid:2873) =   𝑟(cid:2876)(cid:2874) = 6; 

3º Passo: Como 𝑘 = 6 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo.  

Figura 58 – Matrizes de Manejo e de Roteamento após a 6ª iteração. 

Fonte: O autor, 2018 

 
 
 
1º Passo: min(𝑉) = 7. Excluímos o vértice de 𝑉:  𝑉 = {8} 

7ª Iteração 

2º Passo: 

Figura 59 – Matrizes preparadas para o início das comparações da 7ª iteração. 

66 

Fonte: O autor, 2018 

  Para 𝑖 = 1 e 

𝑗 = 2,8: 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2869)(cid:3037) e não há nada a fazer; 

𝑗 = 3: 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2871) < 𝑚(cid:2869)(cid:2871). Portanto 𝑚(cid:2869)(cid:2871) = 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2871) = 251 e  𝑟(cid:2869)(cid:2871) =   𝑟(cid:2869)(cid:2875) = 7; 

𝑗 = 4: 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2872) < 𝑚(cid:2869)(cid:2872). Portanto 𝑚(cid:2869)(cid:2872) = 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2872) = 177 e  𝑟(cid:2869)(cid:2872) =   𝑟(cid:2869)(cid:2875) = 7; 

𝑗 = 5: 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2873) < 𝑚(cid:2869)(cid:2873). Portanto 𝑚(cid:2869)(cid:2873) = 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2873) = 125 e  𝑟(cid:2869)(cid:2873) =   𝑟(cid:2869)(cid:2875) = 7; 

𝑗 = 6: 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2874) < 𝑚(cid:2869)(cid:2874). Portanto 𝑚(cid:2869)(cid:2874) = 𝑚(cid:2869)(cid:2875) + 𝑚(cid:2875)(cid:2874) = 87 e  𝑟(cid:2869)(cid:2874) =   𝑟(cid:2869)(cid:2875) = 7; 

  Para 𝑖 = 2 e 

𝑗 = 1,3,4,5,8: 𝑚(cid:2870)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2870)(cid:3037) e não há nada a fazer; 

𝑗 = 5: 𝑚(cid:2870)(cid:2875) + 𝑚(cid:2875)(cid:2873) < 𝑚(cid:2870)(cid:2873). Portanto 𝑚(cid:2870)(cid:2873) = 𝑚(cid:2870)(cid:2875) + 𝑚(cid:2875)(cid:2873) = 206 e  𝑟(cid:2870)(cid:2873) =   𝑟(cid:2870)(cid:2875) = 1; 

𝑗 = 6: 𝑚(cid:2870)(cid:2875) + 𝑚(cid:2875)(cid:2874) < 𝑚(cid:2870)(cid:2874). Portanto 𝑚(cid:2870)(cid:2874) = 𝑚(cid:2870)(cid:2875) + 𝑚(cid:2875)(cid:2874) = 168 e  𝑟(cid:2870)(cid:2875) =   𝑟(cid:2870)(cid:2875) = 1; 

  Para 𝑖 = 3 e 

𝑗 = 1: 𝑚(cid:2871)(cid:2875) + 𝑚(cid:2875)(cid:2869) < 𝑚(cid:2871)(cid:2869). Portanto 𝑚(cid:2871)(cid:2869) = 𝑚(cid:2871)(cid:2875) + 𝑚(cid:2875)(cid:2869) = 186 e  𝑟(cid:2871)(cid:2869) =   𝑟(cid:2871)(cid:2875) = 6; 

𝑗 = 2,4,5,6,8: 𝑚(cid:2871)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2871)(cid:3037) e não há nada a fazer; 

  Para 𝑖 = 4 e 

𝑗 = 1: 𝑚(cid:2872)(cid:2875) + 𝑚(cid:2875)(cid:2869) < 𝑚(cid:2872)(cid:2869). Portanto 𝑚(cid:2872)(cid:2869) = 𝑚(cid:2872)(cid:2875) + 𝑚(cid:2875)(cid:2869) = 186 e  𝑟(cid:2872)(cid:2869) =   𝑟(cid:2872)(cid:2875) = 6; 

𝑗 = 2,3,5,6,8: 𝑚(cid:2872)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2871)(cid:3037) e não há nada a fazer; 

  Para 𝑖 = 5 e 

𝑗 = 1: 𝑚(cid:2873)(cid:2875) + 𝑚(cid:2875)(cid:2869) < 𝑚(cid:2873)(cid:2869). Portanto 𝑚(cid:2873)(cid:2869) = 𝑚(cid:2873)(cid:2875) + 𝑚(cid:2875)(cid:2869) = 186 e  𝑟(cid:2873)(cid:2869) =   𝑟(cid:2873)(cid:2875) = 5; 

𝑗 = 2: 𝑚(cid:2873)(cid:2875) + 𝑚(cid:2875)(cid:2870) < 𝑚(cid:2873)(cid:2870). Portanto 𝑚(cid:2873)(cid:2870) = 𝑚(cid:2873)(cid:2875) + 𝑚(cid:2875)(cid:2869) = 206 e  𝑟(cid:2873)(cid:2870) =   𝑟(cid:2873)(cid:2875) = 5; 

𝑗 = 3,4,6,8: 𝑚(cid:2873)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2873)(cid:3037) e não há nada a fazer; 

 
 
 
67 

  Para 𝑖 = 6 e 

𝑗 = 1: 𝑚(cid:2874)(cid:2875) + 𝑚(cid:2875)(cid:2869) < 𝑚(cid:2874)(cid:2869). Portanto 𝑚(cid:2874)(cid:2869) = 𝑚(cid:2874)(cid:2875) + 𝑚(cid:2875)(cid:2869) = 87 e  𝑟(cid:2874)(cid:2869) =   𝑟(cid:2874)(cid:2875) = 7; 

𝑗 = 2: 𝑚(cid:2874)(cid:2875) + 𝑚(cid:2875)(cid:2870) < 𝑚(cid:2873)(cid:2870). Portanto 𝑚(cid:2874)(cid:2870) = 𝑚(cid:2874)(cid:2875) + 𝑚(cid:2875)(cid:2870) = 168 e  𝑟(cid:2874)(cid:2870) =   𝑟(cid:2874)(cid:2875) = 7; 

𝑗 = 3,4,5,8: 𝑚(cid:2873)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2873)(cid:3037) e não há nada a fazer; 

  Para 𝑖 = 8 não há nada a fazer pois 𝑚(cid:2876)(cid:2875) + 𝑚(cid:2875)(cid:3037) > 𝑚(cid:2876)(cid:3037), para todo 𝑗 = 1,2,3,4,5,6,8; 

3º Passo: Como 𝑘 = 7 ≠ 8 o algoritmo prossegue e retornamos ao 1º Passo.  

Figura 60 – Matrizes de Manejo e de Roteamento após a 7ª iteração. 

Fonte: O autor, 2018 

1º Passo: min(𝑉) = 8. Excluímos o vértice de 𝑉:  𝑉 = {} 

8ª Iteração 

2º Passo: 

Figura 61 – Matrizes preparadas para o início das comparações da 8ª iteração. 

Fonte: O autor, 2018 

  Para 𝑖 = 1 e 

𝑗 = 2,7: 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2875) > 𝑚(cid:2869)(cid:3037) e não há nada a fazer; 

𝑗 = 3: 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2871) < 𝑚(cid:2869)(cid:2871). Portanto 𝑚(cid:2869)(cid:2871) = 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2871) = 219 e  𝑟(cid:2869)(cid:2871) =   𝑟(cid:2869)(cid:2876) = 8; 

 
 
 
 
 
 
68 

𝑗 = 4: 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2872) < 𝑚(cid:2869)(cid:2872). Portanto 𝑚(cid:2869)(cid:2872) = 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2872) = 205 e  𝑟(cid:2869)(cid:2872) =   𝑟(cid:2869)(cid:2876) = 8; 

𝑗 = 5: 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2873) < 𝑚(cid:2869)(cid:2873). Portanto 𝑚(cid:2869)(cid:2873) = 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2873) = 93 e  𝑟(cid:2869)(cid:2873) =   𝑟(cid:2869)(cid:2876) = 8; 

𝑗 = 6 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2873) < 𝑚(cid:2869)(cid:2874). Portanto 𝑚(cid:2869)(cid:2874) = 𝑚(cid:2869)(cid:2876) + 𝑚(cid:2876)(cid:2874) = 55 e  𝑟(cid:2869)(cid:2874) =   𝑟(cid:2869)(cid:2876) = 8; 

  Para 𝑖 = 2 e 

𝑗 = 1,3,7: 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:3037) > 𝑚(cid:2870)(cid:3037) e não há nada a fazer; 

𝑗 = 4: 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:2872) < 𝑚(cid:2870)(cid:2872). Portanto 𝑚(cid:2870)(cid:2872) = 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:2872) = 216 e  𝑟(cid:2870)(cid:2872) =   𝑟(cid:2870)(cid:2876) = 1; 

𝑗 = 5: 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:2873) < 𝑚(cid:2870)(cid:2873). Portanto 𝑚(cid:2870)(cid:2873) = 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:2873) = 164 e  𝑟(cid:2870)(cid:2873) =   𝑟(cid:2870)(cid:2876) = 1; 

𝑗 = 6: 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:2874) < 𝑚(cid:2870)(cid:2874). Portanto 𝑚(cid:2870)(cid:2874) = 𝑚(cid:2870)(cid:2876) + 𝑚(cid:2876)(cid:2874) = 126 e  𝑟(cid:2870)(cid:2874) =   𝑟(cid:2870)(cid:2876) = 1; 

  Para 𝑖 = 3 e 

𝑗 = 2,4,5,6,7: 𝑚(cid:2871)(cid:2876) + 𝑚(cid:2876)(cid:3037) > 𝑚(cid:2871)(cid:3037) e não há nada a fazer; 

𝑗 = 1: 𝑚(cid:2871)(cid:2876) + 𝑚(cid:2876)(cid:2869) < 𝑚(cid:2871)(cid:2869). Portanto 𝑚(cid:2871)(cid:2869) = 𝑚(cid:2871)(cid:2876) + 𝑚(cid:2876)(cid:2869) = 203 e  𝑟(cid:2871)(cid:2872) =   𝑟(cid:2871)(cid:2876) = 6; 

  Para 𝑖 = 4 e 

𝑗 = 2,3,5,6,7: 𝑚(cid:2872)(cid:2876) + 𝑚(cid:2876)(cid:3037) > 𝑚(cid:2872)(cid:3037) e não há nada a fazer; 

𝑗 = 1: 𝑚(cid:2872)(cid:2876) + 𝑚(cid:2876)(cid:2869) < 𝑚(cid:2872)(cid:2869). Portanto 𝑚(cid:2872)(cid:2869) = 𝑚(cid:2872)(cid:2876) + 𝑚(cid:2876)(cid:2869) = 154 e  𝑟(cid:2872)(cid:2869) =   𝑟(cid:2872)(cid:2876) = 5; 

  Para 𝑖 = 5 e 

𝑗 = 3,4,6,7: 𝑚(cid:2873)(cid:2876) + 𝑚(cid:2876)(cid:3037) > 𝑚(cid:2873)(cid:3037) e não há nada a fazer; 

𝑗 = 1: 𝑚(cid:2873)(cid:2876) + 𝑚(cid:2876)(cid:2869) < 𝑚(cid:2873)(cid:2869). Portanto 𝑚(cid:2873)(cid:2869) = 𝑚(cid:2873)(cid:2876) + 𝑚(cid:2876)(cid:2869) = 93 e  𝑟(cid:2873)(cid:2869) =   𝑟(cid:2873)(cid:2876) = 6; 

𝑗 = 2: 𝑚(cid:2873)(cid:2876) + 𝑚(cid:2876)(cid:2870) < 𝑚(cid:2873)(cid:2870). Portanto 𝑚(cid:2873)(cid:2870) = 𝑚(cid:2873)(cid:2876) + 𝑚(cid:2876)(cid:2870) = 164 e  𝑟(cid:2873)(cid:2870) =   𝑟(cid:2873)(cid:2876) = 6; 

  Para 𝑖 = 6 e 

𝑗 = 3,4,5,7: 𝑚(cid:2874)(cid:2876) + 𝑚(cid:2876)(cid:3037) > 𝑚(cid:2874)(cid:3037) e não há nada a fazer; 

𝑗 = 1: 𝑚(cid:2874)(cid:2876) + 𝑚(cid:2876)(cid:2869) < 𝑚(cid:2874)(cid:2869). Portanto 𝑚(cid:2874)(cid:2869) = 𝑚(cid:2874)(cid:2876) + 𝑚(cid:2876)(cid:2869) = 55 e  𝑟(cid:2874)(cid:2869) =   𝑟(cid:2874)(cid:2876) = 8; 

𝑗 = 2: 𝑚(cid:2874)(cid:2876) + 𝑚(cid:2876)(cid:2870) < 𝑚(cid:2873)(cid:2870). Portanto 𝑚(cid:2874)(cid:2870) = 𝑚(cid:2874)(cid:2876) + 𝑚(cid:2876)(cid:2870) = 126 e  𝑟(cid:2874)(cid:2870) =   𝑟(cid:2874)(cid:2876) = 8; 

  Para 𝑖 = 7 não há nada a fazer pois 𝑚(cid:2875)(cid:2876) + 𝑚(cid:2876)(cid:3037) > 𝑚(cid:2875)(cid:3037) para 𝑗 = 1,2,3,4,5,6; 

3º  Passo:  Como  𝑘 = 8  o  algoritmo  cessa.  Na  Figura  62  ilustra  as  matrizes  Manejo  e  de 

Roteamento após o término do algoritmo. 

 
 
 
 
 
 
 
 
 
  
Figura 62 – Matrizes de Manejo e de Roteamento ao fim do algoritmo. 

69 

Finalmente podemos  responder a pergunta do item b) do problema motivador. Vamos 

Fonte: O autor, 2018 

calcular, para cada cidade, a soma das distâncias até todas as outras. 

Figura 63 – Matriz de manejo e soma dos menores caminhos. 

Dessa forma, a cidade que é menos distante de todas as outras é a indicada pelo rótulo 6, ou seja, 

Fonte: O autor, 2018 

Itu. 

Figura 64 – Melhor escolha para alocar o centro de distribuição. 

Fonte: O autor, 2018 

Embora o desenvolvimento do algoritmo, indicando todas as comparações, seja longo, 

sua execução num quadro ou numa apresentação em slides é relativamente mais curta. 

 
 
 
 
 
 
5 CONSIDERAÇÕES FINAIS 

70 

Esse trabalho foi pensado de maneira a oferecer aos alunos um problema contextualizado 

em  que  eles  possam  aplicar  um  conceito  matemático  para  resolvê-lo.  Contudo,  qualquer 

problema que envolva determinar o caminho mínimo em um grafo pode ser utilizado em seu 

lugar.  

Os tópicos apresentados na última parte desse trabalho foram construídos de maneira a 

dar uma direção na condução de uma oficina sobre o assunto. Infelizmente, devido a problemas 

com o tempo, não foi possível aplica-los numa sala de aula, o que limitou de maneira significativa 

sua construção. Esperamos uma futura oportunidade para aplicação do mesmo e, de acordo com 

os resultados colhidos, remodela-los. 

É possível trabalhar em paralelo com a disciplina de informática educativa e implementar 

ambos  os  algoritmos  no  ambiente  Visualg,  utilizando  os  respectivos  fluxogramas  e  pseudo-

códigos descritos nos apêndices. Acreditamos que dessa forma o aluno consolidará o pensamento 

algorítmico e uma nova janela de opções acadêmicas será aberta para ele. 

 
 
 
 
 
  
71 

REFERÊNCIAS 

BACKES, André. Algoritmos e Fluxogramas. Notas de Aula. 

BOAVENTURA,  P.  Oswaldo;  JURKIEWICZ,  S.  Grafos:  Introdução  e  Prática.  2  ed.  São 
Paulo: Blucher, 2011. 

BOYER, Carl B. História da Matemática. Tradução de Elza Gomide. 2ª ed. São Paulo: Edgard 
Blücher, 1996. 

DIESTEL, R. Graph Theory. 2 ed. New York: Sping-Verlag, 2000. 

DIJKSTRA,  Edsger  W.;  MISA,  Thomas  J.  An  Interwiew  with  Edsger  W.  Dijkstra. 
Comunications of the ACM, v. 53, n. 8, p. 41-47, ago. 2010. 

BARROS,  Edson;  PAMBOUKIAN,  Sérgio;  ZAMBONI,  Lincoln,  Algoritmo  de  Dijkstra: 
Apoio diático na implementação, simulação e utilização computacional, São Paulo, 2007.   

FARIAS,  Gilberto;  MEDEIROS,  Eduardo  Santana.  Introdução  à  Computação,  [S.l.]:  2013.  
Versão  1.0.  Disponível  em  <  http://producao.virtual.ufpb.br/books/gilbertofarias/introducao-a-
computacao-livro/livro/livro.pdf>.  Acesso em: 12 de Janeiro de 2018. 

HAIGH, Thomas. Biographies. IEEE Annals of the History of Computing, p.75-83, Abr./Jun. 
2004. 

SCHIENERMAN, Edward R. Matemática Discreta: Uma introdução. Tradução de All Tasks. 
1 ed. São Paulo: Cengage Learning, 2011. 

 
 
 
 
 
 
 
 
 
 
 
APÊNDICE A – FLUXOGRAMA DO ALGORITMO DE DIJKSTRA 

72 

 
 
APÊNDICE B – PSEUDOCÓDIGO DO ALGORITMO DE DIJKSTRA 

73 

𝐷𝑖𝑗𝑘𝑠𝑡𝑟𝑎(𝑉, 𝑀, 𝑖, 𝑓) = (𝑑(𝑓), 𝐶)  

O  algoritmo  é  uma  função  que  com  quatro  parâmetros  de  entrada  (o  conjunto  de 

vértices, a matriz de manejo do grafo, o vértice inicial e o vértice final) e dois de saída 

(a distância mínima e o caminho percorrido). 

início 

𝑑(𝑖) = 0, 𝑎(𝑖) = 0 𝐹 = {𝑖}, 𝐴 = 𝑉 − 𝐹 

𝑑(𝑗) = (cid:3420)

𝑚(cid:3036)(cid:3037) 𝑠𝑒 𝑚(cid:3036)(cid:3037) ≠ ∞
∞ 𝑠𝑒 𝑚(cid:3036)(cid:3037) = ∞ , 𝑎(𝑗) = (cid:3420)

𝑖 𝑠𝑒 𝑚(cid:3036)(cid:3037) ≠ ∞
0 𝑠𝑒 𝑚(cid:3036)(cid:3037) = ∞

; ∀ 𝑗 ∈ 𝐴 

𝑟 ← 𝑗 | 𝑚í𝑛[𝑑(𝑗)], 𝑗 ∈ 𝐴 

enquanto 𝑟 ≠ 𝑓 fazer 

𝑟 ← 𝑣|𝑚í𝑛[𝑑(𝑗)], 𝑗 ∈ 𝐴 Busca o vértice aberto mais próximo da origem. 

𝐹 ← 𝐹 ∪ {𝑟}      ”Fecha” o vértice mais próximo da origem. 

𝐴 ← 𝐴 − {𝑟}       Remove o vértice fechado de A. 
𝑆 ← 𝐴 ∩ 𝑅(cid:2878)(𝑟)    Cria o conjunto 𝑆 dos vértices adjacentes a 𝑟 que ainda estão abertos. 

para todo 𝑠 ∈ 𝑆 fazer 

𝑝(cid:3046) = 𝑚í𝑛[𝑑(𝑠), 𝑑(𝑟) + 𝑚(cid:3045)(cid:3046)] ∀ 𝑠 ∈ 𝑆 Compara as distâncias. 
se 𝑝(cid:3046) < 𝑑(𝑠) então  

𝑑(𝑠) ← 𝑝(cid:3046)   Atualiza o valor da menor distância. 
𝑎(𝑠) ← 𝑟     Atualiza o parâmetro anterior. 

fim-se 

fim-para todo 

fim-enquanto 

𝐶 = ( ) 

𝑣 ← 𝑟 

enquanto 𝑣 ≠ 𝑖 e 𝑎(𝑣) ≠ 0 fazer 

𝐶 ← 𝐶 + (𝑣) e 𝑣 ← 𝑎(𝑣)  Insere o vértice 𝑣 no vetor caminho e atualiza 𝑣. 

fim-enquanto 

se 𝑣 = 𝑖 então 

O caminho mínimo de 𝑖 até 𝑓 existe, mede 𝑑(𝑓) e é 𝐶. 

Não existe caminho de 𝑖 até 𝑓. 

senão 

fim-se 

fim 

 
 
 
 
 
 
 
 
 
 
APÊNDICE C – FLUXOGRAMA DO ALGORITMO DE FLOYD-WARSHAL 

74 

 
 
 
75 

APÊNDICE D – PSEUDOCÓDIGO DO ALGORITMO DE FLOYD-WARSHALL  

𝑓𝑙𝑜𝑦𝑑𝑤𝑎𝑟𝑠ℎ𝑎𝑙𝑙(𝑀, 𝑅, 𝐴) = (𝑀∗, 𝑅∗, 𝐶) 

início  

𝑀(cid:2868) ← 𝑀, 𝑅(cid:2868) ← 𝑅 

para 𝑘 = 1, . . . , 𝑛 fazer 

O  Algoritmo  tem  como  entradas  a  matriz  de 

manejo,  a  matriz  de  roteamento  e  um  conjunto  de  pares 

ordenados para os quais se deseja saber o menor caminho. 

𝑀(cid:3038) ← 𝑀(cid:3038)(cid:2879)(cid:2869) e 𝑅(cid:3038) ← 𝑅(cid:3038)(cid:2879)(cid:2869)  Cria as matrizes de manejo e de roteamento que serão atualizadas. 

para todo 𝑖 ≠ 𝑘 fazer 

para todo 𝑗 ≠ 𝑘 fazer 

Se 𝑚(cid:3036)(cid:3038)

(cid:3038) + 𝑚(cid:3038)(cid:3037)

(cid:3038) < 𝑚(cid:3036)(cid:3037)

(cid:3038)  então     

(cid:3038)  
(cid:3038) + 𝑚(cid:3038)(cid:3037)

(cid:3038) ← 𝑚(cid:3036)(cid:3038)
𝑚(cid:3036)(cid:3037)
(cid:3038)  
(cid:3038) ← 𝑟(cid:3036)(cid:3038)
𝑟(cid:3036)(cid:3037)

fim-se 

fim-para todo 

Compara  se  a  distância  do  vértice    𝑖  ao  vértice  𝑗 

tomando 𝑘 como intermediário é menor que a distância 

existente  entre  esses  vértices.  Em  caso  afirmativo 

atualiza as matrizes de manejo e de roteamento. 

fim-para todo 

fim-para 

𝑀∗ ← 𝑀(cid:3041) , 𝑅∗ ← 𝑅(cid:3041) 

se 𝐴 = {} fazer 

𝐶 = {}    

senão 

para todo (𝑥, 𝑦) ∈ 𝐴 fazer 

∗  
𝑐 ← 𝑟(cid:3051)(cid:3052)

𝐶(cid:3051)(cid:3052) = (𝑥, 𝑐) 

enquanto 𝑐 ≠ 𝑛 fazer 

∗  
𝑐 ← 𝑟(cid:3051)(cid:3030)

𝐶(cid:3051)(cid:3052) ← (𝐶(cid:3051)(cid:3052), 𝑐) 

fim-enquanto 

fim-para-todo 

𝐶 = {𝐶(cid:3051)(cid:3052), ∀ (𝑥, 𝑦) ∈ 𝐴} 

fim-se 

fim 

Para todo par (𝑥, 𝑦) em 𝐴, descreve cria o vetor 𝐶(cid:3051)(cid:3052) que 

contém os rótulos dos vetores que compõe o caminho 

mínimo entre 𝑥 e 𝑦. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
76 

APÊNDICE  F  –  SITUAÇÕES  MOTIVADORAS  PARA  A  INTRODUÇÃO  DO 

CONCEITO DE ALGORITMOS 

 Situação A: “Como preparar uma pipoca?” 

Num primeiro momento, com a ajuda dos alunos, descreve-se o passo a passo do preparo de uma 
pipoca. Os passos sugeridos pelos alunos devem ser escritos no quadro, em ordem e ser o mais 
claro  possível.  Abaixo  temos  um  exemplo  de  uma  lista  de  passos  para  essa  tarefa. 
Preparo de uma Pipoca Salgada 

Início 

1º Passo: Pegar milho de pipoca e uma pipoqueira no armário; 

2º Passo: Adicionar o milho de pipoca e óleo à pipoqueira. Levar pipoqueira ao fogo; 

3º Passo: Mexer a manivela da pipoqueira até que parem os estouros; 

4º Passo: Servir a pipoca com sal a gosto. 

Fim 

Situação B: “Na escola de Pedro o ano letivo é dividido em três trimestres. Para compor a Média 
Anual (MA) calcula-se a média ponderada das três notas, atribuindo-se peso 3 às duas primeiras 
e peso 4 à última. Se a Média Anual for maior ou igual a 7, o aluno é aprovado na disciplina, 
caso  contrário,  o  aluno  deverá  fazer  a  Avaliação  Final  (AF).  Calcula-se  então  a  Média  Final 
(MF), obtida pela média ponderada entre a Média Anual e a Avaliação Final, com pesos 2 e 3 
respectivamente. Se a média final é maior ou igual a 5, o aluno é aprovado, caso contrário ele é 
retido naquela disciplina. ” 

Algoritmo Verificador de Aprovação/Reprovação 

Início 

1º Passo: Calcula-se a Média Anual (MA) das notas dos três trimestres; 

𝑀𝐴 =

3 ∗ 𝑁𝑜𝑡𝑎 𝐼 + 3 ∗ 𝑁𝑜𝑡𝑎 𝐼𝐼 + 4 ∗ 𝑁𝑜𝑡𝑎 𝐼𝐼𝐼
10

2º Passo: Se 𝑀𝐴 ≥ 7,0 o algoritmo cessa e o aluno está aprovado. Caso contrário o aluno deverá 

fazer a Avaliação Final (AF).  Vá para o 3º passo. 

3º Passo: Calcula-se a média final (MF) 

4º Passo: Se 𝑀𝐹 ≥ 5,0 o aluno é aprovado. Caso contrário ele é reprovado. 

𝑀𝐹 =

3 ∗ 𝑀𝐴 + 2 ∗ 𝑀𝐹
5

Fim 

 
 
 
 
  
 
APÊNDICE G – RESUMO HISTÓRICO DO SURGIMENTO DOS ALGORITMOS 

77 

A origem da palavra remete ao sobrenome do matemático persa Mohammed Ibn Musa 

al-Khwarizmi e seu significado encerra a descrição sistemática da maneira de se realizar alguma 

tarefa (BOYER, 1964). Dessa forma, qualquer conjunto finito de instruções que resolvem um 

problema é um algoritmo. A definição inclui não apenas algoritmos quem envolvam cálculos 

(como  o  Algoritmo  de  Euclides  para  obter  o  máximo  divisor  comum  de  um  número)  mas 

qualquer  conjunto  finito  de  regras  que  possa  ser  executado  por  uma  pessoa  contanto  que  ela 

possua  o  tempo  necessário  para  fazê-lo.  Essa  definição  abarca  todos  os  programas  de 

computadores existentes. Contudo, a implementação de algoritmos em máquinas ocorreu bem 

antes do surgimento de computadores como os conhecemos hoje. 

O primeiro registro que se tem da implementação de um algoritmo remonta à revolução 

industrial. Em 1801, o mecânico e tecelão francês Joseph Marie Jacquard (1752-1834) construiu 

um tear mecânico controlado por grandes cartões perfurados. 

Influenciado  por  Jacquard,  o  matemático  inglês  Charles  Babagge  propôs  em  1837  a 

construção  de  uma  máquina  de  propósito  mais  genérico  chamada  Máquina  Analítica.  Ele 

percebeu que poderia utilizar os cartões perfurados para armazenar ideias abstratas ou números, 

que poderiam ser acessados posteriormente, o que chamamos hoje num computador de memória. 

Infelizmente a Máquina Analítica nunca foi construída. 

Durante o período em que Babagge tentava construir a Máquina Analítica, Ada Byron, 

filha de Lord Byron, mostrou bastante interesse pelo projeto e propôs diversas melhorias como 

relata Farias: 

A condessa de Lovelace, Ada Byron, se interessou pela máquina analítica de 
Babbage e se comunicava com ele através de cartas e encontros. Ela passou a 
escrever programas que  a máquina  poderia ser  capaz  de executar, caso fosse 
construída. Ela foi a primeira a reconhecer a necessidade de loops e sub-rotinas. 
Por  esta  contribuição,  Ada  ficou  reconhecida  na  história  como  a  primeira 
programadora. (FARIAS; MEDEIROS, 2013, p. 9) 

Na primeira metade do século XX, Alan Turing formalizou o conceito de algoritmo como 

o  conhecemos  hoje  através  de  uma  invenção  sua,  a  Máquina  de  Turing.  Durante  a  Segunda 

Guerra  Mundial,  foi  chefe  do  setor  responsável  por  decifrar  a  máquina  de criptografia  alemã 

Enigma.  Suas  contribuições  delinearam  o  campo  da  ciência  da  computação,  sendo  aclamado 

como o pai da ciência da computação. 

 
 
 
 
