UNIVERSIDADE FEDERAL DO MARANH ˜AO
CENTRO DE CIˆENCIAS EXATAS E TECNOLOGIA

PROGRAMA DE MESTRADO PROFISSIONAL
EM MATEM ´ATICA EM REDE NACIONAL - PROFMAT

ADEILSON CARLOS DE LIMA ALVES

CRIPTOGRAFIA E SEGURANC¸ A RSA:
contextualiza¸c˜ao e aplica¸c˜ao

S˜ao Lu´ıs

2019

ADEILSON CARLOS DE LIMA ALVES

CRIPTOGRAFIA E SEGURANC¸ A RSA:
contextualiza¸c˜ao e aplica¸c˜ao

Disserta¸c˜ao apresentada ao Programa de Mestrado Proﬁssi-
onal em Matem´atica em Rede Nacional da Universidade Fe-
deral do Maranh˜ao como requisito parcial para a obten¸c˜ao
do grau de Mestre em Matem´atica.

Orientador: Prof. Dr. Jo˜ao de Deus Mendes da Silva

S˜ao Lu´ıs

2019

Ficha gerada por meio do SIGAA/Biblioteca com dados fornecidos pelo(a) autor(a).

N´ucleo Integrado de Bibliotecas/UFMA

Alves, Adeilson Carlos de Lima

CRIPTOGRAFIA E SEGURANC¸ A RSA: contextua-

liza¸c˜ao e aplica¸c˜ao / Adeilson Carlos de Lima Alves. - 2019

53 p.

Orientador(a): Jo˜ao de Deus Mendes da Silva.
Disserta¸c˜ao (Mestrado) - Programa de P´os-gradua¸c˜ao em

Rede - Matem´atica em Rede Nacional/ccet, Universidade
Federal do Maranh˜ao, S˜ao Lu´ıs, 2019.

1. Algoritmo 2. Aritm´etica modular 3. Cifra de C´esar 4. Crip-
tograﬁa RSA 5. Teoria dos N´umeros. I. Silva, Jo˜ao de Deus Mendes
da. II. T´ıtulo.

ADEILSON CARLOS DE LIMA ALVES

CRIPTOGRAFIA E SEGURANC¸ A RSA:
contextualiza¸c˜ao e aplica¸c˜ao

Disserta¸c˜ao apresentada ao PROFMAT/ Universidade Fe-
deral do Maranh˜ao como requisito parcial para a obten¸c˜ao
do grau de Mestre em Matem´atica.

Aprovado em: 9 de janeiro de 2019

BANCA EXAMINADORA

Prof. Jo˜ao de Deus Mendes da Silva (Orientador)
Doutor em Matem´atica
Universidade Federal do Maranh˜ao

Prof. Jo˜ao Coelho Silva Filho
Doutor em Matem´atica
Universidade Estadual do Maranh˜ao

Profa. Valeska Martins de Souza
Doutora em Matem´atica
Universidade Federal do Maranh˜ao

Dedico este trabalho aos meus pais, Aldeides e

Cleide, por serem muito mais que apenas pais

e sim educadores da vida.

AGRADECIMENTOS

Agrade¸co primeiramente a Deus, criador do universo e dono de toda sapiˆencia.

Ao meu orientador Prof. Dr. Jo˜ao de Deus Mendes da Silva pela singular

orienta¸c˜ao e dedica¸c˜ao neste trabalho.

Aos professores do PROFMAT, por contribuir na caminhada da busca de ad-

quirir mais conhecimentos em minha proﬁss˜ao e para que esse objetivo fosse alcan¸cado.

Ao PROFMAT, um programa de suma importˆancia na qualiﬁca¸c˜ao de docentes

do nosso Pa´ıs.

`A CAPES, pela ajuda ﬁnanceira (bolsa de estudo), a qual foi de uma im-

portˆancia singular.

A minha esposa Agizelle da Concei¸c˜ao Silva Alves, amiga de todas as horas,

que me acompanhou nesta caminhada.

`A minha fam´ılia por sempre acreditar na capacidade do meu trabalho e nunca

me deixar desistir desse sonho, em especial ao meu pai Aldeides Carlos Alves e minha m˜ae

Cleide de Lima ALves, que sempre me mantiveram na linha da busca do conhecimento,

onde acreditavam que o caminho da Educa¸c˜ao seria o melhor e o mais honesto para uma

vida mais digna.

Aos meus irm˜aos: Willian Lima Alves e Werbeth de Lima Alves, pelos incen-

tivos e estarem sempre no apoio em minha trajet´oria.

Aos meus colegas de turma, os quais passamos por grandes diﬁculdades, mas

que seguem com insistˆencia e perseveran¸ca em busca de mais conhecimentos para poder

retransmiti-los aos alunos.

“Meus ﬁlhos ter˜ao computadores, sim, mas an-
tes ter˜ao livros. Sem livros, sem leitura, os nos-
sos ﬁlhos ser˜ao incapazes de escrever, inclusive
a sua pr´opria hist´oria”.

Bill Gates

RESUMO

O presente trabalho discorre sobre Criptograﬁa e a Seguran¸ca RSA, fazendo uma contex-

tualiza¸c˜ao do tema para estimular a aprendizagem da matem´atica atrav´es de aplica¸c˜oes

pr´aticas aos alunos do Ensino Fundamental e Ensino M´edio. S˜ao abordados os conceitos

de criptograﬁa, seus m´etodos de encripta¸c˜ao, desencripta¸c˜ao e a importˆancia da seguran¸ca

na troca de informa¸c˜oes. A pesquisa se fundamenta, sobretudo, na Teoria dos N´umeros e

na rela¸c˜ao entre os n´umeros inteiros e o m´etodo de criptograﬁa RSA. A importˆancia do

tema e sua escolha se justiﬁcam por ser o RSA, entre os m´etodos conhecidos atualmente,

bastante utilizado em opera¸c˜oes simples como envio de e-mails, transa¸c˜oes banc´arias,

compras online e por satisfazer requisitos de seguran¸ca.

Palavras-chave: Algoritmo. Aritm´etica Modular. Cifra de C´esar. Criptograﬁa a RSA.

Teoria dos N´umeros.

ABSTRACT

The present paper deals with Cryptography and RSA (Rivest-Shamir-Adleman) Secu-

rity, making a theme contextualization to stimulate the learning of mathematics through

practical applications to Middle and High School students. This thesis discusses the cryp-

tography concepts, its methods of encryption, decryption and the importance of security

in the information exchange. The research is based mainly on the Numbers Theory and

the relationship between integers and the RSA encryption method. The importance of the

theme and its choice are justiﬁed by the fact that RSA, among the methods known nowa-

days, is widely used in simple operations, such as sending e-mails, banking transactions,

online purchases and meeting security requirements.

Keywords: Algorithm. Modular Arithmetic. Caesar Cipher. Encryption to RSA. Num-

bers Theory

SUM ´ARIO

Lista de Figuras

Lista de Tabelas

1 INTRODUC¸ ˜AO

2 A HIST ´ORIA DA CRIPTOGRAFIA

8

9

10

13

2.1 Cifra de substitui¸c˜ao ou Cifra de C´esar . . . . . . . . . . . . . . . . . . . . 13

2.2 Cifra de Vigen`ere . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.3 An´alise de frequˆencias

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.4 Disco de Cifras

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3 INTRODUC¸ ˜AO `A TEORIA DOS N ´UMEROS

17

3.1 N´umeros inteiros

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3.1.1 Divisor e M´ultiplo

. . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3.1.2 Primo e Composto . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

3.1.3 Algoritmo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

3.1.4 Custo da Fatora¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

3.1.5 Fatorando um n´umero . . . . . . . . . . . . . . . . . . . . . . . . . 20

3.2 Aritm´etica Modular . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.2.1 Algoritmo res´ıduo-mod-n . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3

Inversos modulares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3.1 Deﬁnindo inverso modular . . . . . . . . . . . . . . . . . . . . . . . 24

3.3.2 A existˆencia de inverso modular . . . . . . . . . . . . . . . . . . . . 24

3.3.3 A inexistˆencia de inverso modular . . . . . . . . . . . . . . . . . . . 26

3.4 Algoritmo Chinˆes do Resto . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

3.4.1 O Teorema Chinˆes do Resto . . . . . . . . . . . . . . . . . . . . . . 32

3.5 Potˆencias

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

3.5.1 Fun¸c˜oes Aritm´eticas

. . . . . . . . . . . . . . . . . . . . . . . . . . 35

3.5.2 Teorema de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

4 CRIPTOGRAFIA RSA

40

4.1 Algoritmo RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

4.2 Pr´e-Codiﬁca¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

4.3 Codiﬁcando e Decodiﬁcando . . . . . . . . . . . . . . . . . . . . . . . . . . 43

4.3.1 Codiﬁca¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

4.3.2 Decodiﬁcando . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

4.4 Seguran¸ca RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

5 APLICAC¸ ˜OES DE CRIPTOGRAFIA NA SALA DE AULA

48

5.1 Atividade 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

5.2 Atividade 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

5.3 Atividade 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

5.4 Reﬂex˜oes sobre a Atividade 1 . . . . . . . . . . . . . . . . . . . . . . . . . 51

5.5 Reﬂex˜oes sobre a Atividade 2 . . . . . . . . . . . . . . . . . . . . . . . . . 51

5.6 Reﬂex˜oes sobre a Atividade 3 . . . . . . . . . . . . . . . . . . . . . . . . . 52

6 CONSIDERAC¸ ˜OES FINAIS

Referˆencias

53

54

Lista de Figuras

2.1 Carreiras de Vigen`ere.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.2 Disco de Cifras.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

5.1 Sistema Criptogr´aﬁco de J´ulio C´esar.

. . . . . . . . . . . . . . . . . . . . . 48

5.2 Sistema Criptogr´aﬁco associando letras a n´umeros.

. . . . . . . . . . . . . 49

5.3 Disco de cifra. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

5.4 Carreiras de Chic´o.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

Lista de Tabelas

2.1 Alfabeto cifrado.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.2 Frequˆencia das letras no idioma portuguˆes (Brasil).

. . . . . . . . . . . . . 15

3.1 Res´ıduo inverso modular 11.

. . . . . . . . . . . . . . . . . . . . . . . . . . 25

3.2 Res´ıduo inverso modular 8. . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

3.3 Solu¸c˜oes do exemplo.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

4.1 Conversor de letra em n´umero. . . . . . . . . . . . . . . . . . . . . . . . . . 42

5.1 Codiﬁca¸c˜ao de Chic´o. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

10

1 INTRODUC¸ ˜AO

A presente disserta¸c˜ao tem como objetivo despertar o interesse dos alunos para

o aprendizado da Matem´atica, atrav´es da utiliza¸c˜ao de conceitos b´asicos deste componente

curricular, em situa¸c˜oes cotidianas que envolvam a seguran¸ca no envio e recebimento de

dados e informa¸c˜oes.

O momento que estamos vivendo, em que a comunica¸c˜ao e a tecnologia tˆem

ganhado espa¸co, principalmente entre os jovens, atrav´es da grande quantidade de redes

sociais, com a utiliza¸c˜ao em demasia da internet e a n˜ao menos importante exposi¸c˜ao a

que est˜ao sendo submetidos.

Desde os tempos mais remotos a intercepta¸c˜ao de dados sigilosos trazem ao

´apice da discuss˜ao a espionagem. Atualmente a necessidade de proteger essas informa¸c˜oes

sigilosas ´e cada vez maior em um mercado altamente competitivo no mundo globalizado.

Historicamente, reis e imperadores utilizou-se da intercepta¸c˜ao de informa¸c˜oes

para aumentar seus dom´ınios. Surgiu ent˜ao a ideia de ocultar mensagens, pr´atica conhe-

cida como esteganograﬁa, palavra do grego que signiﬁca “escrita coberta”. Os qu´ımicos se

apropriam muito bem da esteganograﬁa ao utilizar uma solu¸c˜ao a base de suco de lim˜ao

para escrever em uma folha de papel utilizando um pincel, mas quando aquecida a folha,

a mensagem ´e revelada (tamb´em conhecida como tintas invis´ıveis).

Foi necess´ario garantir que n˜ao haveria intermedi´ario nas informa¸c˜oes trocadas

entre o emissor e o receptor. Chamamos essa prote¸c˜ao de informa¸c˜oes de conﬁdencialidade,

na qual um emissor troca informa¸c˜oes com um ou mais destinat´arios. A problem´atica de

garantir o sigilo da comunica¸c˜ao ´e o principal objeto de estudo da criptograﬁa.

Em dias atuais, o artigo 3o, inciso II, da Lei 12.965/14, a Lei 12.737/12,

tamb´em conhecida como lei Carolina Dieckmann, e tamb´em o artigo 5o, inciso X, da Cons-

titui¸c˜ao Federal de 1988, garantem a prote¸c˜ao da privacidade e mostra a importˆancia que

o Governo Brasileiro tem dado `as quest˜oes relacionadas `a viola¸c˜ao e ao compartilhamento

de informa¸c˜oes privadas.

Logo, objetiva-se com esse trabalho, atrav´es de simples aplica¸c˜oes matem´aticas

e aliado ao que se pretende nos Parˆametros Curriculares Nacionais, fazer com que o aluno

compreenda conceitos, procedimentos e estrat´egias matem´aticas que permita o desen-

volvimento e a obten¸c˜ao de uma forma¸c˜ao cient´ıﬁca geral, al´em da aplica¸c˜ao de tais

conhecimentos na vida cotidiana, na interpreta¸c˜ao da ciˆencia e da atividade tecnol´ogica.

11

No ensino da Matem´atica, destacam-se dois aspectos b´asicos: um con-
siste em relacionar observa¸c˜oes do mundo real com representa¸c˜oes (es-
quemas, tabelas, ﬁguras); outro consiste em relacionar essas representa¸c˜oes
com princ´ıpios e conceitos matem´aticos. Nesse processo, a comunica¸c˜ao
tem grande importˆancia e deve ser estimulada, levando-se o aluno a falar
e a escrever sobre Matem´atica.
[...] O signiﬁcado da Matem´atica para
o aluno resulta das conex˜oes que ele estabelece entre ela e as demais
disciplinas, entre ela e seu cotidiano e das conex˜oes que ele estabelece
entre os diferentes temas matem´aticos. (BRASIL, 2007, p.19).

Unindo um tema moderno e a utiliza¸c˜ao de c´alculos matem´aticos que possibi-

litem entender a metodologia de codiﬁca¸c˜ao e decodiﬁca¸c˜ao existentes, ´e a receita ideal

para que se consiga ˆexito dentro e fora da sala de aula. Aﬁnal o objetivo do professor ´e

despertar no aluno o desejo de transformar o mundo que o contorna. Cabe ao professor

incentivar a pesquisa, o questionamento e a busca pelo conhecimento.

Para isso, apresentaremos no decorrer deste trabalho assuntos pertinentes `a

Criptograﬁa, tratando de um breve hist´orico sobre os prim´ordios e a evolu¸c˜ao da crip-

tograﬁa utilizamos o cap´ıtulo 2 para descrever sobre a Cifra de C´esar e suas poss´ıveis

altera¸c˜oes e veriﬁcamos que ao saber em qual l´ıngua materna a cifra foi escrita original-

mente, e fazendo uma an´alise de frequˆencias dessas letras, o embaralhamento das letras

ﬁca facilmente decifr´avel.

No cap´ıtulo 3 s˜ao abordadas as principais metodologias e t´ecnicas matem´aticas.

Trataremos sobre a fatora¸c˜ao de um n´umero, introduzindo as deﬁni¸c˜oes e nota¸c˜oes ele-

mentares.

Exemplos s˜ao abordados apenas para melhor entendimento da aplicabilidade

dos t´opicos, visando um f´acil entendimento e abordagem pr´atica para alunos da educa¸c˜ao

b´asica. Aritm´etica modular, inverso modular e o algoritmo do resto chinˆes, juntamente

com a fun¸c˜ao de Euler e o Pequeno Teorema de Fermat, ter´a grande utilidade para o

entendimento do RSA.

Faremos um estudo dos n´umeros inteiros e suas propriedades, dando ˆenfase

aos n´umeros primos.

12

No cap´ıtulo 4 abordaremos sobre a criptograﬁa RSA, descrevendo de forma

rigorosa e ﬁel o algoritmo conforme descrito no livro titulado Criptograﬁa e Seguran¸ca

de Redes, escrito por Stalling, e ainda, dando exemplo de como tratar as informa¸c˜oes e

aplicando uma codiﬁca¸c˜ao e depois decodiﬁcando uma mensagem e, com isso, mostrar o

que a torna t˜ao segura e aplic´avel nos dias atuais.

Sabendo que n˜ao existem mecanismos totalmente seguros e visando a defesa

de um poss´ıvel ataque a essas trocas de informa¸c˜oes ´e necess´ario garantir um tempo h´abil

que essas informa¸c˜oes permanecer˜ao seguras.

No cap´ıtulo 5 apresentaremos algumas atividades l´udicas para alunos na educa¸c˜ao

b´asica desenvolver na sala de aula ou mesmo em casa, visto que os conte´udos necess´arios

para desenvolver tais atividades foram abordados nos cap´ıtulos anteriores.

A teoria dos n´umeros contribuiu, e ainda contribui, de forma signiﬁcativa para

a seguran¸ca dessas informa¸c˜oes. Um sistema de criptograﬁa espec´ıﬁco chamado RSA ´e o

mais utilizado dos m´etodos de criptograﬁa e suas aplica¸c˜oes est˜ao em simples mensagens

de e-mails `as compras on-line.

13

2 A HIST ´ORIA DA CRIPTOGRAFIA

Ao longo da hist´oria, reis e rainhas e seus generais de guerra, sempre buscaram

formas seguras de se comunicar e de comandar seus ex´ercitos. A necessidade de n˜ao revelar

t´aticas e estrat´egias aos inimigos, motivou o desenvolvimento de c´odigos e t´ecnicas para

mascarar a mensagem, possibilitando apenas ao destinat´ario ler o conte´udo. Uma corrida

intelectual foi posta desde ent˜ao, de um lado, na¸c˜oes criaram departamentos para elaborar

c´odigos e, do outro lado, surgia os decifradores de c´odigos.

Observa-se ent˜ao que a matem´atica teve seu papel primordial ao longo do

tempo para a evolu¸c˜ao dos c´odigos, e “evolu¸c˜ao” ´e um termo bem apropriado, j´a que todo

c´odigo sempre est´a sob o ataque dos decifradores e no decorrer da hist´oria, os c´odigos

foram fundamentais para a decis˜ao que inﬂuenciaram no resultado das batalhas.

2.1 Cifra de substitui¸c˜ao ou Cifra de C´esar

Um dos c´odigos mais simples consiste em substituir uma letra do alfabeto pela

letra seguinte. Utilizava-se um alfabeto cifrado apenas rearranjando o alfabeto original,

mas tamb´em empregavam alfabetos que continham outros s´ımbolos, a essa cifra se d´a o

nome de Cifra de substitui¸c˜ao. Segundo COUTINHO (2014, p. 2) “um c´odigo semelhante

a este foi usado, por exemplo, pelo ditador romano J´ulio C´esar para se comunicar com seus

soldados romanos em combate pela Europa. Este parece ser o primeiro exemplo de c´odigo

secreto de que se tem not´ıcia” e por ser um dos primeiros m´etodos de codiﬁca¸c˜ao relatados

na hist´oria ´e que recebeu o nome do imperador. Esta cifra permaneceu invulner´avel por

s´eculos.

A B C D E F G H I

J K L M

B C D E F G H I

J K L M N

N O P Q R S T U V W X Y Z

O P Q R S T U V W X Y Z A

Tabela 2.1: Alfabeto cifrado.

Era comum deslocar as letras do alfabeto, por exemplo, como descrito na

Cifra de Vigen`ere

14

Tabela 2.1, o alfabeto utilizado para cifrar uma mensagem tem in´ıcio na letra b.

Utilizando-se da Tabela 2.1, podemos codiﬁcar a mensagem “Esta ´e a cifra

de c´esar” e ap´os codiﬁca¸c˜ao se torna “Ftub f b djgsb ef dftbs”.

2.2 Cifra de Vigen`ere

A cifra levou o sobrenome de Blaise de Vigen`ere, n˜ao por ter inventado, mas

por ter difundido. Vigen`ere foi um diplomata e cript´ografo francˆes que viveu entre 1523

e 1596. Iniciou sua carreira diplom´atica aos 17 anos e com o passar dos anos conheceu

criptologistas e tomou contato com livros de criptograﬁa.

Foi autor de v´arios livros na qual ganha destaque a obra Trait´e des Chiﬀres

ou Secr`etes mani`eres d’escrire (1586), onde explica detalhadamente seu c´odigo de cifra

de substitui¸c˜ao polialfab´etica com palavras-chave.

A imagem das Carreiras de Vigen`ere, Figura 2.1, ´e similar ao C´odigo de C´esar.

Consiste em ter uma palavra-chave, que ser´a usada para codiﬁcar, e a posi¸c˜ao de cada

s´ımbolo codiﬁcado ´e encontrado ao associar as letras da colunas (mensagem original) com

as letras das linhas (palavra-chave), fazendo uma esp´ecie de batalha-naval com as letras.

Figura 2.1: Carreiras de Vigen`ere.

Exemplo 2.1. Utilize a Figura 2.1 e codiﬁque a seguinte mensagem: ESTUDE MA-

TEMATICA com a palavra-chave: AMOR.

An´alise de frequˆencias

15

Como resultado da codiﬁca¸c˜ao dessa mensagem teremos:

EEHLDQARTQARTUQR

2.3 An´alise de frequˆencias

Os c´odigos baseados na Cifra de C´esar sofrem de um grande problema: s˜ao

muito f´aceis de decifrar (quebrar). Decifrar ou quebrar c´odigos signiﬁca ter capacidade de

ler a mensagem, ainda que n˜ao seja o verdadeiro destinat´ario. Para COUTINHO (2014, p.

2), “qualquer c´odigo que envolva substituir cada letra sistematicamente por outro s´ımbolo

qualquer sofre do mesmo problema”.

Essa facilidade ocorre porque a frequˆencia m´edia com que cada letra aparece

em um determinado texto de uma dada l´ıngua ´e razoavelmente constante. A Tabela 2.2

faz referˆencia a frequˆencia m´edia, em porcentagem, de cada letra em rela¸c˜ao `as palavras

na l´ıngua portuguesa.

Letra

%

Letra % Letra

%

Letra %

A

B

C

D

E

F

14,64

1,04

3,88

4,10

12,5

1,02

G

H

I

J

K

L

1,30

1,28

6,18

0,40

0,70

2,78

M

N

O

P

Q

R

4,75

10,73

10,73

2,52

1,20

6,53

S

T

U

V

X

Z

7,81

4,64

4,64

1,70

0,21

0,47

Tabela 2.2: Frequˆencia das letras no idioma portuguˆes (Brasil).

O sistema consiste em: conhecendo o idioma texto, encontrar um texto dife-

rente, na mesma l´ıngua, suﬁcientemente longo para preencher uma p´agina. Ent˜ao contar

a frequˆencia com que cada letra aparece. Em seguida examinar a tabela de frequˆencia

das letras que se deseja decifrar e correlacion´a-las (SINGH, 2001).

´E importante fazer uma correspondˆencia entre as letras e os s´ımbolos mais

frequentes. Entretanto, podemos observar que esse m´etodo utilizado para quebrar c´odigos

s´o funciona bem se o texto for longo, pois a existˆencia da facilidade de escrever um texto

curto na qual a contagem de frequˆencia seja totalmente diferente da m´edia, pode colocar

a utiliza¸c˜ao da metodologia em xeque.

Disco de Cifras

2.4 Disco de Cifras

16

Disco de cifras ´e um misturador de c´odigos que transforma a letra do texto

original em letra do texto cifrado, uma t´ecnica criptogr´aﬁca que faz uso de dois discos para

cifrar e decifrar mensagens. Seu inventor sugeriu que a disposi¸c˜ao do disco fosse alterada

durante uma mensagem, gerando uma cifra polialfab´etica, diﬁcultando ainda mais a sua

decodiﬁca¸c˜ao ao mudar o modo de mistura durante o processo de cifragem.

Sua concep¸c˜ao b´asica consiste de dois discos com diˆametros diferentes que s˜ao

montados de forma concˆentrica, conforme ilustra a Figura 2.2, onde as escalas com o

alfabeto s˜ao gravados e, ao movˆe-los em torna do eixo comum, relacionam-se entre si,

permitindo a mudan¸ca de cifras de uma forma pr´atica e f´acil.

Figura 2.2: Disco de Cifras.

17

3 INTRODUC¸ ˜AO `A TEORIA DOS N ´UMEROS

O estudo das propriedades dos n´umeros inteiros positivos ´e o objetivo central

da Teoria dos N´umeros. Apresentamos algumas propriedades elementares dos n´umeros

inteiros na qual ser˜ao necess´arias para entender o funcionamento do algoritmo RSA.

3.1 N´umeros inteiros

Neste t´opico ser˜ao abordadas algumas propriedades e caracter´ısticas dos n´umeros

inteiros que garantem a seguran¸ca do RSA no que diz respeito ao envio e recebimento de

informa¸c˜oes e na qual ter´a extrema necessidade para aplica¸c˜ao da criptograﬁa.

3.1.1 Divisor e M´ultiplo

Deﬁni¸c˜ao 3.1. Um n´umero inteiro b divide outro n´umero inteiro a se existe um terceiro

n´umero inteiro c tal que a = b · c

Podemos dizer que b ´e um divisor ou fator de a, ou tamb´em que a ´e m´ultiplo

de b . Todas essas formas de se expressar tem o mesmo signiﬁcado (COUTINHO, 2000).

Nas condi¸c˜oes da deﬁni¸c˜ao 3.1, se 1 < b < a, dizemos que b ´e um fator ou

divisor pr´oprio de a. De forma natural, podemos aﬁrmar que s´o temos dois divisores que

n˜ao s˜ao pr´oprios, 1 e o pr´oprio a. O n´umero c, descrito na deﬁni¸c˜ao ´e chamado de cofator

de b em a, ou seja, determinamos que um n´umero b divide um n´umero a efetuando a

divis˜ao e veriﬁcando se o resto ´e zero.

O cofator ´e o quociente da divis˜ao. Dois n´umeros inteiros quaisquer sempre

ter˜ao, pelo menos, o n´umero 1 como fator comum, ou seja, o n´umero 1 divide qualquer

n´umero inteiro. Se o n´umero 1 for o ´unico fator comum a dois n´umeros, diremos que n˜ao

existe fator pr´oprio comum, ou ainda, os dois n´umeros s˜ao primos entre si.

Coutinho (2015) cita propriedades dos m´ultiplos. Se a, b, c e d s˜ao n´umeros

inteiros, ent˜ao:

1. d divide 0;

Primo e Composto

18

2. Se d divide a e b, ent˜ao tamb´em divide a + b;

3. Se d divide a, ent˜ao divide a · c .

3.1.2 Primo e Composto

Deﬁni¸c˜ao 3.2. Um n´umero inteiro a (a > 1) ´e chamado de primo se possui somente dois

divisores inteiros positivos, a e 1. Se a > 1 n˜ao ´e primo dizemos que a ´e composto.

Proposi¸c˜ao 3.1. Se a for composto, o menor fator pr´oprio de a ´e menor ou igual a raiz

quadrada de a. Desta forma, buscando fatorar o n´umero a, se a for composto, algum

fator dever´a ser encontrado antes da busca ultrapassar

√

a .

3.1.3 Algoritmo

A origem da palavra algoritmo ´e de certa forma curiosa. No princ´ıpio a

palavra era escrita “algorismo” que vem da palavra ´arabe Al-khowarazmi, “o homem

de khowarazm”, pelo qual o matem´atico ´arabe Ibn Musa ﬁcou conhecido. Ele foi o
respons´avel por fazer chegar o sistema de numera¸c˜ao, usado na ´India, na Europa Medieval,

quando escreveu o livro Al-jabr wa’l muqabalah, no s´eculo IX. Por este motivo que

falamos em algarismos indo-ar´abicos e as palavras algorismo e algarismo s˜ao varia¸c˜oes da

mesma palavra que signiﬁcavam numerais indo-ar´abicos.

Observamos que a palavra algoritmo ´e muito antiga, mas que ganhou um novo

signiﬁcado por volta de 1800.

Coutinho (2000) aﬁrma que esse novo signiﬁcado, os matem´aticos chamam de

algoritmo qualquer m´etodo sistem´atico utilizado para fazer alguma coisa.

Atrav´es da Proposi¸c˜ao 3.1 podemos, ent˜ao, criar um algoritmo que descrever´a

suas etapas aﬁm de veriﬁcar se um n´umero ´e primo ou composto. Chamaremos: Algoritmo

ACHAR-FATOR.

Devemos ter uma entrada: um n´umero inteiro positivo a; e uma sa´ıda: um

fator pr´oprio de a ou a conclus˜ao de que a ´e primo.

Procedimento: tentar dividir por 2. Se for divis´ıvel pare, pois descobrimos que

2 ´e fator de a, se n˜ao, tente dividir por 3. Se for divis´ıvel pare, pois descobrimos que 3 ´e

Custo da Fatora¸c˜ao

19

fator de a, se n˜ao, tente dividir por 5. Continuar desta maneira at´e encontrar um n´umero

que divida a ou at´e que o candidato a divisor seja maior que

divisor for maior que

√

a pare, pois descobrimos que a ´e primo.

√

a. Se esse candidato a

Proposi¸c˜ao 3.2. O fator de um n´umero inteiro a > 1 encontrado pelo algoritmo ACHAR-

FATOR citado anteriormente ´e sempre um n´umero primo menor ou igual a raiz quadrada

de a .

3.1.4 Custo da Fatora¸c˜ao

Apesar da facilidade de entender e de utilizar o algoritmo ACHAR-FATOR, ele

´e muito ineﬁciente, mesmo quando usamos um supercomputador. H´a uma certa facilidade

de ilustrarmos se estimarmos o tempo que um computador levaria para achar um fator

de um n´umero grande usando o algoritmo ACHAR-FATOR.

Vale lembrar que, tendo um n´umero a por entrada, ACHAR-FATOR executa

na m´aquina

√

a tentativas de divis˜ao antes de encontrar um fator para a, sendo o pior

caso poss´ıvel ocorrendo quando executado exatamente

√

a tentativas de divis˜ao, o que

corresponde a dizer que a ´e primo.

´E neste pior caso que teremos que trabalhar para estimar o tempo de resposta

de um computador para retornar a resposta: a ´e primo.

Consideremos um n´umero primo p, de 100 ou mais algarismos. Isto ´e p ≥ 10100

e, portanto,

√

p ≥ 1050. Desta forma, precisaremos executar, pelo menos, 1050 divis˜oes

para garantir que o numero p ´e primo, utilizando o algoritmo ACHAR-FATOR. Para

transformar isso em tempo de c´alculo, precisamos ter uma ideia de quantas divis˜oes um

computador ´e capaz de executar em um segundo.

Vamos utilizar, para nosso exemplo, o supercomputador adquirido pela USP

(Universidade de S˜ao Paulo) que faz cerca de 20 trilh˜oes de c´alculos por segundo, de

acordo com reportagem feita pelo s´ıtio Plant˜aoNERD.com (PAIVA, 2012). Suponhamos

conseguir extrair cem por cento da capacidade desse supercomputador, ou seja, capaz de

executar 2 · 1013 divis˜oes por segundo. Ent˜ao precisar´ıamos de, pelo menos,

1050
2 · 1013 = 0, 5 · 1037 = 5 · 1036 segundos

para determinar que certo n´umero a, usando o algoritmo ACHAR-FATOR, ´e primo.

Fatorando um n´umero

20

Supondo que um ano tem 365 dias (para efeito de contas), cada dia tem 24

horas, cada hora tem 60 minutos e cada minuto tem 60 segundos, ent˜ao:

365 · 24 · 60 · 60 = 31536000 segundos,

isto ´e, 1 ano tem 31536000 segundos, ent˜ao:

5 · 1036
31536000

∼= 158548959918823000000000000000 anos

Calculando essa estimativa de tempo (em anos) que o supercomputador ad-

quirido pela USP leva para fatorar um n´umero relativamente grande (100 algarismos),

conclu´ımos que demoraria um pouco mais que 158,5 octilh˜oes de anos.

Podemos aﬁrmar que, ´e imposs´ıvel conﬁrmar que um n´umero de 100 ou mais

algarismos ´e primo usando este algoritmo ACHAR-FATOR. No entanto, n˜ao signiﬁca

que o algoritmo seja in´util, visto que vamos fatorar um n´umero inteiro que nada sabemos

sobre, h´a sempre possibilidade que tenha um fator primo pequeno (menor que um milh˜ao)

e para esses casos o algoritmo ACHAR-FATOR encontrar´a um fator rapidamente.

3.1.5 Fatorando um n´umero

Consideremos o n´umero inteiro 12105. Vamos aplicar o algoritmo ACHAR-

FATOR a este n´umero inteiro e achamos o fator 3,

assim

12105
3

= 4035,

12105 = 3 · 4035.

Os fatores encontrados pelo algoritmo ACHAR-FATOR sempre s˜ao primos, assim, 3 ´e
primo. ´E necess´ario aplicar o algoritmo ACHAR-FATOR ao cofator 4035 de 3 em 12105.

Aplicando ACHAR-FATOR a 4035, observamos que 3 tamb´em ´e fator deste n´umero.

Como

tem-se que

4035
3

= 1345,

12105 = 3 · 4035 = 3 · (3 · 1345) = 32 · 1345.

Aritm´etica Modular

21

Aplicando o algoritmo ACHAR-FATOR novamente, teremos achado o cofator de 1345, e

encontramos o fator 5, pois

de modo que

1345
5

= 269,

12105 = 32 · 1345 = 32 · (5 · 269).

No entanto, aplicando o algoritmo ACHAR-FATOR teremos

√

269 = 16, 4012194...,

ou seja, teremos que testar se 269 ´e divis´ıvel por n´umeros menores que 16 e pela Deﬁni¸c˜ao

3.2 veriﬁcamos que 269 n˜ao ´e divis´ıvel por nenhum n´umero menor que 16. Esses resultados

nos permitem observar que o n´umero 269 ´e primo.

Ent˜ao, podemos concluir que, usando o algoritmo ACHAR-FATOR a fatora¸c˜ao

do n´umero 12105 em potencias de n´umeros primos ´e:

12105 = 32 · 5 · 269.

3.2 Aritm´etica Modular

Deﬁni¸c˜ao 3.3. Se a e b s˜ao inteiros dizemos que a ´e congruente a b m´odulo n(n > 0) se

n|(a−b). Denotamos isto por a ≡ b(mod n). Caso contr´ario, dizemos que a ´e incongruente

a b m´odulo n.

Semelhante `as propriedades dos n´umeros inteiros, congruˆencia modular tamb´em

possui um rol de propriedades dessas. Considerando que n ´e um inteiro positivo.

1. Reﬂexiva, todo n´umero ´e congruente m´odulo n a si pr´oprio;

2. Sim´etrica, se a ≡ b(mod n) ent˜ao b ≡ a(mod n);

3. Transitiva, se a ≡ b(mod n) e b ≡ c(mod n), ent˜ao a ≡ c(mod n) .

Demonstra¸c˜ao. Para mostrar que a congruˆencia m´odulo n ´e reﬂexiva, devemos veriﬁcar

que a ≡ a(mod n). Mas, pela deﬁni¸c˜ao, isto ´e o mesmo que dizer que a − a = 0 ´e m´ultiplo

de n. Contudo, zero ´e m´ultiplo de qualquer inteiro n, uma vez que 0 · n = 0. Passemos `a

sim´etrica. Pela deﬁni¸c˜ao de congruˆencia m´odulo n, a ≡ b(mod n), ´e o mesmo que dizer

que a − b ´e m´ultiplo de n. Em outras palavras, se a ≡ b(mod n) ent˜ao existe algum inteiro

k tal que a − b = k · n.

Aritm´etica Modular

22

Multiplicando esta equa¸c˜ao por -1, obtemos: b − a = (−k) · n; isto ´e, b − a ´e

m´ultiplo de n, ou ainda, b ≡ a(mod n).

Para a propriedade transitiva, tomamos por hip´otese que: a ≡ b(mod n) e que

b ≡ c(mod n). Mas estas duas congruˆencias se traduzem, por deﬁni¸c˜ao, nas igualdades:

a − b = k1 · n e b − c = k2 · n, onde k1 e k2 s˜ao inteiros escolhidos de maneira adequada.

Somando estas duas ´ultimas equa¸c˜oes, (a − b) + (b − c) = k1 · n + k2 · n.

Cancelando o b `a esquerda e usando a distributividade da direita, obtemos:

a − c = (k1 + k2) · n, que ´e equivalente `a congruˆencia a ≡ c(mod n).

As trˆes propriedades que provamos correspondem `as propriedades dos m´ultiplos,

no entanto, podemos ir bem mais longe que isto. Digamos que a ´e um inteiro positivo.

Dividindo a por n temos: a = n · q + r, com r ∈ [0, n[.

Logo, a − r = n · q; que ´e equivalente a dizer que a ≡ r(mod n).

Veriﬁcamos com isto que todo inteiro positivo ´e congruente m´odulo n ao resto

de sua divis˜ao por n, que ´e um n´umero entre 0 e n. Podemos generalizar desta forma: se

a ≡ r(mod n) e 0 ≤ r < n, dizemos que r ´e o res´ıduo de m´odulo n.

Isto porque cada n´umero s´o pode ter um res´ıduo m´odulo n. De fato, se:

a ≡ r(mod n) com 0 ≤ r ≤ n − 1;

a ≡ r(cid:48)(mod n) com 0 ≤ r(cid:48) ≤ n − 1

ent˜ao, pelas propriedades sim´etrica e transitiva, r ≡ r(cid:48)(mod n). Digamos que r ≥ r(cid:48). Pela

deﬁni¸c˜ao da congruˆencia, isto signiﬁca que r − r(cid:48) ´e um m´ultiplo de n. Mas tanto r, quanto

r(cid:48) s˜ao menores que n, de modo que 0 ≤ r − r(cid:48) ≤ n. Isto signiﬁca que r − r(cid:48) s´o pode ser

m´ultiplo de n se o cofator correspondente for zero; o que nos d´a r = r(cid:48), mostrando que os

dois res´ıduos, r e r(cid:48) tˆem que ser iguais.

Aparentemente a ´unica coisa que ﬁzemos ao introduzir os res´ıduos foi inventar

um nome novo para o resto, mas n˜ao ´e bem assim. Note que o termo res´ıduo se aplica

a qualquer inteiro, positivo ou negativo, ao passo que o resto geralmente ´e usado quando

dividimos um inteiro positivo por n. O que ocorre, ent˜ao, se a for negativo? Para tornar

o argumento mais claro, conv´em come¸car com um exemplo.

Exemplo 3.1. Seja n = 6 e a = −55. Nosso objetivo ´e calcular o res´ıduo de −55 m´odulo

Algoritmo res´ıduo-mod-n

23

6; em outras palavras, queremos achar um inteiro 0 (cid:54) r < 6 tal que:

−55 ≡ r(mod 6).

Poder´ıamos proceder por tentativa, mas vamos tratar o problema de maneira mais sis-

tem´atica para podermos lidar mesmo com o caso em que o n for grande. Para isto,

dividimos 55 por 6, obtendo quociente 9 e resto 1, ou seja, 55 = 9 · 6 + 1. Multiplicando

tudo por -1, teremos −55 = (−9) · 6 − 1, de forma que −55 ≡ −1(mod 6). Observe que

-1 n˜ao ´e o res´ıduo de -55 m´odulo 6 porque -1 ´e negativo. Contudo, como 6 = 5 − (−1),

obtemos −1 ≡ 5(mod 6); e a propriedade transitiva da congruˆencia nos permite concluir

que −55 ≡ 5(mod 6). Portanto, -55 tem res´ıduo 5 m´odulo 6.

3.2.1 Algoritmo res´ıduo-mod-n

Para tratar o caso geral, podemos fazer um pequeno algoritmo seguindo as

etapas do Exemplo 3.1.

Primeiramente, estamos supondo que a ´e negativo, ent˜ao −a deve ser positivo.

Dividindo-o por n, −a = n · q + r e 0 ≤ r < n, onde q e r s˜ao o quociente e o resto da

divis˜ao respectivamente.

Multiplicando esta equa¸c˜ao por -1, obtemos a = n · (−q) − r e 0 ≤ r < n, isto

´e, a ≡ −r(mod n) e 0 ≤ r < n.

Se r = 0, ent˜ao a ≡ 0(mod n) e j´a achamos o res´ıduo. Se r (cid:54)= 0, ent˜ao

(n − r) − (−r) = n nos diz que −r ≡ n − r(mod n), de modo que a transitividade da

congruˆencia nos permite concluir que a ≡ n − r(mod n). Ainda precisamos nos certiﬁcar

que n − r ´e um res´ıduo, mas, para isto, basta veriﬁcar que est´a entre 0 e n − 1. Como

r ≥ 0 e r (cid:54)= 0, temos que r > 0. Logo n − r < n. Entretanto, r < n, e assim, conclu´ımos

que n − r > 0.

3.3 Inversos modulares

Nesta se¸c˜ao ser˜ao discutidos alguns t´opicos de suma importˆancia para enten-

dermos o funcionamento do RSA.

Deﬁnindo inverso modular

24

3.3.1 Deﬁnindo inverso modular

Vejamos a congruˆencia 2 · 3 ≡ −1(mod 7).

Utilizando a linguagem elementar dos n´umeros racionais, dizemos que -1 “di-

vidido” por 2 ´e igual a 3. Ao multiplicar a congruˆencia por -1 obtemos 2·(−3) ≡ 1(mod 7)

e tamb´em (−2) · 3 ≡ 1(mod 7).

Como −3 ≡ 4(mod 7) e −2 ≡ 5(mod 7), podemos concluir que

2 · 4 ≡ 1(mod 7) e 5 · 3 ≡ 1(mod 7).

Tamb´em, para este caso, dizemos que 1 dividido por 2 m´odulo 7 resulta em 4,

e 1 dividido por 3 resulta 5. Ocorrendo isto, dizemos que 2 e 4 s˜ao inversos m´odulo 7, e

o mesmo se d´a com os n´umeros 3 e 5.

Sistematicamente, dizemos que a e a(cid:48) s˜ao inversos m´odulo n se a·a(cid:48) ≡ 1(mod n).

Para este caso, dizemos que a(cid:48) ´e o inverso de a m´odulo n, ou tamb´em que a ´e

o inverso de a(cid:48) m´odulo n.

3.3.2 A existˆencia de inverso modular

Enumeramos, na Tabela 3.1, cada um dos res´ıduos diferentes poss´ıveis m´odulo

11, indicando o res´ıduo e seu respectivo inverso m´odulo 11. Notemos que zero n˜ao tem

inverso m´odulo n n˜ao importando qual valor n assuma, j´a que 0 · b ≡ 0(mod n) qualquer

que seja b ∈ Z. Com isso, n˜ao listamos o n´umero 0 entre os res´ıduos na Tabela 3.1.

Podemos utilizar mais que simples tentativa, porque se nos restringimos aos

inteiros entre 1 e n − 1, ent˜ao cada um destes n´umeros tem apenas um inverso neste

mesmo intervalo. Com efeito, se a(cid:48) e a(cid:48)(cid:48) s˜ao inversos de a m´odulo n, e est˜ao entre 1 e

n − 1, ent˜ao,

podemos concluir que,

a · a(cid:48) ≡ 1(mod n) e a · a(cid:48)(cid:48) ≡ 1(mod n),

a(cid:48)(cid:48) · (a · a(cid:48)) ≡ a(cid:48)(cid:48) · 1 ≡ a(cid:48)(cid:48)(mod n),

A existˆencia de inverso modular

25

Res´ıduo

Inverso M´odulo 11

1

2

3

4

5

6

7

8

9

1

6

4

3

9

2

8

7

5

e tamb´em que,

10

10

Tabela 3.1: Res´ıduo inverso modular 11.

(a(cid:48)(cid:48) · a) · a(cid:48) ≡ 1 · a(cid:48) ≡ a(cid:48)(mod n).

No entanto ﬁzemos apenas aplicar a propriedade associativa, n˜ao alterando o

resultado e, desta forma,

a(cid:48) ≡ a(cid:48)(cid:48)(mod n).

Ent˜ao signiﬁca que a subtra¸c˜ao a(cid:48) − a(cid:48)(cid:48) ´e divis´ıvel por n. S´o que, a(cid:48) e a(cid:48)(cid:48) s˜ao

maiores que zero e menores que n, de tal forma

−n < a(cid:48) − a(cid:48)(cid:48) < n.

Assim, a ´unica forma da subtra¸c˜ao a(cid:48) − a(cid:48)(cid:48) ser m´ultiplo de n ´e se for igual ao n´umero 0;

conclu´ımos que a(cid:48) = a(cid:48)(cid:48).

Essa conclus˜ao ajuda muito na hora de calcular a tabela. Quando calculamos,

observamos que 2 e 6 s˜ao inversos, um do outro, m´odulo 11, ent˜ao nem o n´umero 2 e

muito menos o n´umero 6 podem ser inversos de 3 m´odulo 11. Assim, procuramos pelo

res´ıduo do inverso de 3 apenas entre os inteiros 3, 4, 5, 7, 8, 9 e 10. Por isso, quanto mais

inversos determinamos, mais r´apido ﬁca determinar os que ainda faltam.

A inexistˆencia de inverso modular

26

3.3.3 A inexistˆencia de inverso modular

Propomos calcular uma outra tabela de inversos, desta vez calcularemos os in-

versos dos res´ıduos diferentes m´odulo 8. Sabendo que 1 ´e seu pr´oprio inverso, come¸caremos

do n´umero 2;

2 · 2 ≡ 4 (cid:54)≡ 1(mod 8)

2 · 3 ≡ 6 (cid:54)≡ 1(mod 8)

2 · 4 ≡ 0 (cid:54)≡ 1(mod 8)

2 · 5 ≡ 2 (cid:54)≡ 1(mod 8)

2 · 6 ≡ 4 (cid:54)≡ 1(mod 8)

2 · 7 ≡ 6 (cid:54)≡ 1(mod 8)

Ap´os efetuarmos os c´alculos veriﬁcamos que 2 n˜ao tem inverso m´odulo 8. Por

Coutinho (2014, p.85) sabemos que “todo inteiro ´e congruente m´odulo n ao seu res´ıduo”.

Modiﬁcaremos a frase para adaptar ao nosso exemplo: todo inteiro ´e congruente m´odulo

8 ao seu res´ıduo. Como devemos calcular se um n´umero ou se seu res´ıduo produz iguais

resultado m´odulo 8, n˜ao podendo haver nenhum n´umero inteiro que inverta 2, j´a que

tal n´umero inteiro n˜ao existe entre os n´umeros inteiros de 1 a 8. N˜ao sendo suﬁciente

apareceram resultados muito estranhos nos c´alculos feitos acima: embora saibamos agora

que 2 e 4 n˜ao sejam congruentes a 0 m´odulo 8, o produto deles dois ´e 8, e este ´e congruente

a 0 m´odulo 8. Fazendo uma alus˜ao com a multiplica¸c˜ao, ´e como se estiv´essemos dizendo

que a multiplica¸c˜ao de 2 n´umeros diferentes de 0 deu 0, o que ´e extremamente estranho.

Enumeramos todos os inversos m´odulo 8, apresentados na Tabela 3.2.

Observamos, na Tabela 3.2, que os n´umeros 2, 4 e 6 n˜ao tem inverso m´odulo

8.

A existˆencia de uma forte liga¸c˜ao entre n˜ao ter inverso m´odulo n e ser anulado

m´odulo n pelo produto com um res´ıduo n˜ao nulo. A prova que isso de fato ocorre ´e dada

por Hefez (2005).

Demonstra¸c˜ao. Supondo que n e 1 < a < n s˜ao inteiros positivos e que tˆem um fator

primo comum entre 1 e n, ou seja, 1 < p < n. Ent˜ao, podemos escrever: n = p · c e

a = p · e, onde c e e s˜ao os cofatores similares. Como 1 < p < n, tem-se c =

n
p

tamb´em

A inexistˆencia de inverso modular

27

Res´ıduo

Inverso M´odulo 8

1

2

3

4

5

6

7

1

-

3

-

5

-

7

Tabela 3.2: Res´ıduo inverso modular 8.

satisfaz 1 < c < n. Por outro lado, como 1 < a < n por hip´otese, temos que nem c, nem

a s˜ao congruentes a 0 m´odulo n. Contudo,

c · a ≡ c · p · e(mod n).

Por sua vez n = c · p, e desta forma,

c · p ≡ n ≡ 0(mod n);

na qual,

c · a ≡ c · p · e ≡ 0(mod n).

(3.1)

Mas, como usaremos essa informa¸c˜ao para veriﬁcar que a n˜ao tem inverso

m´odulo n? De fato que estes c´alculos exibem que a n˜ao pode ter inverso m´odulo n. Para

entender por que, procederemos por contradi¸c˜ao.

Suponha que a tivesse inverso a(cid:48) m´odulo n. Para isso, dever´ıamos ter,

a · a(cid:48) ≡ 1(mod n).

Multiplicando ambos os lados da congruˆencia por c, obteremos,

c · (a · a(cid:48)) ≡ c(mod n).

Associando os parˆenteses teremos,

28

(3.2)

Algoritmo Chinˆes do Resto

Entretanto, pela Equa¸c˜ao (3.1),

(c · a) · a(cid:48) ≡ c(mod n)

c · a ≡ 0(mod n);

de forma que

(c · a) · a(cid:48) ≡ 0 · a(cid:48) ≡ 0(mod n).

Comparando o resultado com a Equa¸c˜ao (3.2), obtemos,

c ≡ 0(mod n);

ou seja, n divide c. S´o que n˜ao ´e verdade, pois, vimos acima que, 1 < c < n. Obtendo,

desta forma, uma conclus˜ao absurda. Ocorreu isso porque ﬁzemos uma aﬁrma¸c˜ao falsa

ao supor que a tem inverso m´odulo n. Logo, a n˜ao tem inverso m´odulo n, como hav´ıamos

aﬁrmado antes. Em resumo, mostramos o que quer´ıamos.

3.4 Algoritmo Chinˆes do Resto

Para enunciar o Teorema Chinˆes do Resto, vamos inicialmente considerar o

seguinte exemplo para facilitar nosso entendimento.

Exemplo 3.2. Determinar o menor inteiro positivo que satisfaz a seguinte condi¸c˜ao:

deixar resto 1 quando dividido por 3 e resto 2 quando dividido por 5.

Observe que o Exemplo 3.2 ´e muito simples, o suﬁciente para que possamos

resolvˆe-lo sem precisar fazer contas. Entretanto, nas aplica¸c˜oes do RSA, vamos encontrar

exemplos parecidos, mas, com n´umeros muito maiores, que s´o ser´a poss´ıvel resolver pro-

cedendo de maneira met´odica, que ´e outra forma de dizer que resolvemos aplicando um

algoritmo. Enunciaremos um teorema que ser´a de grande valia mais adiante.

Teorema 3.4.1. Suponha que a tenha inverso m´odulo n. Se a · b ≡ a · c(mod n), para a,

b ∈ Z, ent˜ao b ≡ c(mod n).

Algoritmo Chinˆes do Resto

29

Vamos iniciar descrevendo a aplica¸c˜ao do algoritmo ao nosso exemplo.

Chamaremos de n o inteiro que procuramos. Podemos escrever as equa¸c˜oes

correspondentes `a divis˜ao de n por 3 e por 5 na seguinte forma:

n = 3q1 + 1

n = 5q2 + 2.

Usaremos simbologias diferentes (q1 e q2) para denotar os quocientes das di-

vis˜oes, e usando a mesma simbologia, automaticamente, implicaria na incorreta igualdade.

Veja que temos um sistema que apresenta trˆes vari´aveis (n, q1 e q2) e duas equa¸c˜oes. Como

queremos determinar uma solu¸c˜ao inteira torna isso um problema ainda mais complicado.

Contudo, as linhas desse sistema de equa¸c˜oes podem ser reescritas usando congruˆencia.

Ao fazer, obtemos:

n ≡ 1(mod 3),

n ≡ 2(mod 5).

O problema ´e achar uma forma de usar congruˆencias para determinar o n´umero

procurado usando apenas uma vari´avel. No entanto, quando temos um sistema de equa¸c˜oes,

tentamos isolar uma inc´ognita de uma equa¸c˜ao e substituir em outra equa¸c˜ao para achar

a resposta procurada. Mas, o problema apresenta duas congruˆencias que tˆem m´odulos

diferentes e, portanto, n˜ao podemos substitu´ı-las diretamente.

Vamos usar uma sa´ıda estrat´egica e h´ıbrida: substituiremos a equa¸c˜ao n =

5q2 + 2 n˜ao na equa¸c˜ao n = 3q1 + 1 mas, usaremos essa equa¸c˜ao para substituir na

congruˆencia n ≡ 1(mod 3). Fazendo a substitui¸c˜ao, tem-se:

5 ≡ 2(mod 3)

Acontece que 5q2+2 ≡ 1(mod 3), de forma que a congruˆencia pode ser reescrita

na forma

2q2 + 2 ≡ 1(mod 3).

Subtraindo 2 de ambos os membros da congruˆencia, obteremos:

2q2 ≡ −1(mod 3);

Algoritmo Chinˆes do Resto

30

sendo −1 ≡ 2(mod 3), tamb´em podemos escrever:

2q2 ≡ 2(mod 3).

Como 2 ´e invers´ıvel m´odulo 3, podemos cancel´a-lo na congruˆencia acima pelo Teorema

3.4.1, e obtemos:

q2 ≡ 1(mod 3),

ou seja, q2 deixa resto 1 na divis˜ao por 3, de modo que reescrevemos como:

q2 = 3q3 + 1,

sendo, q3 correspondente ao quociente da divis˜ao. Ent˜ao, agora temos, a partir das

equa¸c˜oes:

originais, obtemos uma nova equa¸c˜ao:

n = 3q1 + 1,

n = 5q2 + 2

q2 = 3q3 + 1,

que explicita q2, mesmo que tenhamos introduzido outra vari´avel q3, contudo essa ultima

equa¸c˜ao nos permite substituir o valor de q2 diretamente na linha 2 das duas equa¸c˜oes

originais. Fazendo

Tem-se que

n = 5q2 + 2 = 5(3q3 + 1) + 2.

n = 15q3 + 7.

Entretanto, se dividirmos 15q3 + 7 por 3, teremos 15 = 3 · 5, tal que:

15q3 + 7 = 3 · 5q3 + 7.

Como 7 ≥ 3 precisaremos escrever essa equa¸c˜ao de outra forma. Se 7 fosse

menor que 3, automaticamente seria o resto da divis˜ao. Ent˜ao:

Algoritmo Chinˆes do Resto

31

7 = 3 · 2 + 1

Substituindo as equa¸c˜oes obtidas e colocando o n´umero 3 em evidˆencia, temos:

15q3 + 7 = 3 · (5q3 + 2) + 1;

desta forma 15q3 +7 deixa resto 1 na divis˜ao por 3, como o que pretend´ıamos que ocorresse

com o n a ser determinado em nosso exemplo, para qualquer valor inteiro escolhido para

q3.

De forma mais direta, na divis˜ao por 5 teremos:

15q3 + 7 = 5 · 3q3 + 5 + 2 = 5(3q3 + 1) + 2;

na qual 5q3 +7 deixa resto 2 na divis˜ao por 5, resultando no que pedia o exemplo a solu¸c˜ao

como sendo n = 15q3 + 7.

No entanto, n˜ao obtivemos apenas uma solu¸c˜ao. O resultado nos leva a uma

fam´ılia de solu¸c˜oes, na qual, cada valor q3 inteiro que escolhermos, levar´a a uma solu¸c˜ao

distinta. Veja na Tabela 3.3 alguns valores para q3.

15q3 + 7

-53

-38

-23

-8

7

22

37

52

67

82

q3

-4

-3

-2

-1

0

1

2

3

4

5

Tabela 3.3: Solu¸c˜oes do exemplo.

A partir da f´ormula n = 15q3 + 7, obtemos qualquer poss´ıvel solu¸c˜ao deste

problema. Basta escolher adequadamente o valor de q3. Para veriﬁcar o menor inteiro n

positivo para as duas senten¸cas, podemos avaliar, de forma mais detalhada, a Tabela 3.3:

O Teorema Chinˆes do Resto

32

i) Se q3 < 0, ent˜ao n = 15q3 + 7 < 0;

ii) Se q3 > 0, ent˜ao n = 15q3 + 7 > 7;

de tal forma que o menor inteiro positivo procurado ´e n = 7.

3.4.1 O Teorema Chinˆes do Resto

As t´ecnicas utilizadas anteriormente para resolver sistemas de congruˆencias

s˜ao conhecidas como Algoritmo do Resto Chinˆes (SANTOS, 2006) ou Algoritmo Chinˆes

do Resto (COUTINHO, 2014). Recebeu esse nome, segundo Coutinho (2014, p.113-

114) “porque um dos primeiros lugares em que aparece ´e o livro Manual de aritm´etica do

mestre Sun, escrito entre 287 d.C. e 473 d.C.” encontrado na China. No entanto, Coutinho

(2014, p.114) tamb´em descreve que, “o mesmo resultado ´e mencionado na Aritm´etica de

Nicˆomaco de Gerasa, escrita por volta de 100 d.C.”.

Considere o seguinte sistema (1):

x0 ≡ a(mod m),

x0 ≡ b(mod n),

onde m e n s˜ao n´umeros inteiros positivos diferentes e vamos supor que o inteiro x0 ´e uma

solu¸c˜ao deste sistema de congruˆencia. Signiﬁca que x0 satisfaz as congruˆencias ao mesmo

tempo:

x0 ≡ a(mod m),

x0 ≡ b(mod n).

Sabendo que os m´odulos s˜ao distintos, s´o podemos substituir uma congruˆencia

na outra, se modiﬁcar uma delas em uma igualdade de n´umeros inteiros. Fazendo-o com

a linha 1 do sistema, veriﬁcamos que:

x0 = a + m · k

(3.3)

O Teorema Chinˆes do Resto

33

onde k ´e um n´umero inteiro qualquer, tal que:

a + m · k ≡ b(mod n),

ou tamb´em,

m · k ≡ (b − a)(mod n).

(3.4)

Vamos supor que m e n sejam primos entre si, ent˜ao m ´e invers´ıvel m´odulo

n. Digamos que m(cid:48) ´e o inverso de m m´odulo n. Multiplicando a Equa¸c˜ao (3.3) por m(cid:48),

teremos:

ou seja,

k ≡ m(cid:48)(b − a)(mod n).

k ≡ m(cid:48)(b − a) + n · t,

para algum n´umero inteiro t. Trocando a express˜ao para k na Equa¸c˜ao (3.3), teremos:

x0 = a + m(m(cid:48)(b − a) + n · t).

Ent˜ao, veriﬁcamos que se x0 ´e uma solu¸c˜ao do sistema (1), ent˜ao:

x0 = a + m(m(cid:48)(b − a) + n · t).

(3.5)

´E facilmente veriﬁcado que, atribuindo um valor inteiro qualquer a t, uma

express˜ao da forma a + m(m(cid:48)(b − a) + n · t) ´e obrigatoriamente solu¸c˜ao do sistema (1).

Basta ver que, a + m(m(cid:48)(b − a) + n · t) ´e congruente a a m´odulo m. Por outro lado,

a + m(m(cid:48)(b − a) + n · t) ≡ a + m · m(cid:48)(b − a)(mod n)

Como m · m(cid:48) ≡ 1(mod n), tem-se

a + m(m(cid:48)(b − a) + n · t) ≡ a + 1 · (b − a) ≡ b(mod n);

O Teorema Chinˆes do Resto

34

comprovando que a + m(m(cid:48)(b − a) + n · t) ´e uma solu¸c˜ao do sistema (1). O que ﬁzemos

est´a resumido no Teorema Chinˆes do Resto.

Santos enuncia o Teorema Chinˆes do Resto da seguinte forma:

Sejam m e n inteiros positivos primos entre si. Se a e b s˜ao inteiros
quaisquer, ent˜ao o sistema

x ≡ a(mod m),
x ≡ b(mod n).

sempre tem solu¸c˜ao e qualquer uma de suas solu¸c˜oes pode ser escrita na
forma

a + m(m(cid:48)(b − a) + n · t),

onde t ´e um inteiro qualquer e m(cid:48) ´e o inverso de m m´odulo n. (SANTOS,
2006, p.44).

Vamos generalizar o Teorema Chinˆes do Resto proposto por Santos apresen-

tando o Teorema 3.4.2 e uma aplica¸c˜ao dessa generaliza¸c˜ao no Exemplo 3.3:

Teorema 3.4.2. Sejam m1, m2, ..., mr, inteiros positivos primos entre si, dois a dois, e

sejam a1, a2, ..., ar; inteiros quaisquer. Ent˜ao, o sistema de congruˆencia:

X ≡ a1(mod m1)

X ≡ a2(mod m2)

... ... ...

X ≡ ar(mod mr)

admite uma solu¸c˜ao X. Al´em disso, as solu¸c˜oes s˜ao ´unicas m´odulo M = m1 · m2 · ... · mr

Exemplo 3.3. Determinar qual n´umero deixa resto 2, 3 e 2, quando dividido por 3, 5 e

7.

Inicialmente observamos que o problema ´e equivalente ao sistema:

X ≡ 2(mod 3)

X ≡ 3(mod 5)

X ≡ 2(mod 7)

No intuito de achar as solu¸c˜oes m´odulo M, multiplicaremos os m1, m2, ..., mr existentes.

35

Potˆencias

desta forma,

M = m1 · m2 · m3 = 3 · 5 · 7 = 105,

M1 =

M2 =

M3 =

M
m1
M
m2
M
m3

= 35

= 21

= 15.

Por outro lado as solu¸c˜oes das congruˆencias:

35Y ≡ 1(mod 3)

21Y ≡ 1(mod 5)

15Y ≡ 1(mod 7)

s˜ao respectivamente, y1 = 2, y2 = 1 e y3 = 1. Portanto, uma solu¸c˜ao m´odulo M = 105 ´e

dada por:

x = M1y1a1 + M2y2a2 + M3y3a3 = 233

Como 233 ≡ 23(mod 105), segue que 23 ´e uma solu¸c˜ao e qualquer outra solu¸c˜ao ´e do tipo

23 + 105t, t ∈ Z.

3.5 Potˆencias

Estamos caminhando para a parte ﬁnal sobre o que precisamos para apro-

priarmos do RSA de forma adequada. Embora trabalhado de forma elementar, vimos o

qu˜ao importante a matem´atica tem-se mostrado. Vamos enunciar algumas deﬁni¸c˜oes e o

Pequeno Teorema de Fermat para prosseguir.

3.5.1 Fun¸c˜oes Aritm´eticas

Santos (2006, p.69) deﬁne “fun¸c˜ao aritm´etica a fun¸c˜ao deﬁnida para todos os

inteiros positivos. A fun¸c˜ao φ de Euler ´e um exemplo de fun¸c˜ao aritm´etica”.

Tamb´em nos utilizamos da simbologia τ (n) para representar o n´umero de di-

visores positivos de n (SANTOS, 2006), em outras palavras, se n = pa1

1 pa2

2 pa3

3 · ... · par
r ,

ent˜ao:

Teorema de Fermat

36

τ (n) = (a1 + 1) (a2 + 1) (a3 + 1) · ... · (ar + 1).

Podemos utilizar uma aplica¸c˜ao r´apida e f´acil: 12 = 22 · 3, logo:

τ (12) = (2 + 1)(1 + 1) = 6.

A fun¸c˜ao φ de Euler ´e apresentada da seguinte forma: dado um n´umero inteiro

positivo n, essa fun¸c˜ao ´e deﬁnida como o n´umero de inteiros positivos n˜ao excedendo n

que s˜ao relativamente primos com ele pr´oprio, ou seja,

φ(pa) = pa − pa−1

Exempliﬁcando φ(27) = 33 − 33−1 = 33 − 32 = 27 − 9 = 18. Em um caso geral
2 pa3

r , teremos:

3 · ... · par

se n = pa1

1 pa2

φ(n) = n(1 − 1
p1

)(1 − 1
p2

)(1 − 1
p3

) · ... · (1 − 1
pr

).

3.5.2 Teorema de Fermat

Coutinho (2000) enuncia o Pequeno Teorema de Fermat da seguinte forma.

Se p ´e um n´umero primo e a ´e um n´umero inteiro que n˜ao ´e divis´ıvel por p, ent˜ao

ap−1 ≡ 1(mod p).

Iremos mostrar a veracidade do Teorema de Fermat que foi proposto por Euler,

por ser mais elementar. Enumerando poss´ıveis res´ıduos m´odulo p, que s˜ao

1, 2, 3, 4, ..., p − 1

e pegando cada res´ıduo desse, vamos multiplic´a-lo por a, teremos ent˜ao,

a · 1, a · 2, a · 3, a · 4, ..., a · (p − 1).

Suponhamos que r1 ´e o res´ıduo de a · 1, que r2 ´e o res´ıduo de a · 2 e assim

sucessivamente, at´e rp−1, que ter´a o res´ıduo, por generaliza¸c˜ao de suposi¸c˜ao a · (p − 1).

Iremos calcular esse produto

r1 · r2 · r3 · r4 · ... · rp−1.

Teorema de Fermat

37

m´odulo p de duas formas distintas.

Demonstra¸c˜ao. Levando em conta que

r1 ≡ a · 1(mod p),

r2 ≡ a · 2(mod p),

r3 ≡ a · 3(mod p),

...

...

...

...

rp−1 ≡ a · (p − 1)(mod p),

podemos concluir que

r1 · r2 · r3 · r4 · ... · rp−1 ≡ (a · 1) · (a · 2) · (a · 3) · (a · 4) · ... · (a · (p − 1))(mod p).

Contudo,

(a · 1) · (a · 2) · (a · 3) · (a · 4) · ... · (a · (p − 1)) = ap−1 · (1 · 2 · 3 · 4 · ... · (p − 1)).

de forma que

(r1 · r2 · r3 · r4 · ... · rp−1 ≡ ap−1 · (1 · 2 · 3 · 4 · ... · (p − 1))(mod p).

Demonstra¸c˜ao. Sabe-se que n˜ao podemos ter dois res´ıduos iguais dentre os res´ıduos

r1, r2, r3, r4, ..., rp−1.

Suponhamos por absurdo, que rk = rl, k e l inteiros entre 1 e p − 1 . Aplicando

a deﬁni¸c˜ao de res´ıduos, teremos

ou seja,

a · k ≡ rk ≡ rl ≡ a · l(mod p);

a · k ≡ a · l(mod p).

No entanto, como a n˜ao ´e divis´ıvel por p e este por sua vez ´e primo, eles n˜ao tˆem fator

pr´oprio comum. Mas isto implica que a ´e invers´ıvel m´odulo p tal que, podemos cancel´a-lo

na ´ultima congruˆencia, resultando

Teorema de Fermat

38

k ≡ l(mod p).

Mas k e l s˜ao n´umeros inteiros positivos, pela qual s˜ao menores que p, e s´o ser˜ao congru-

entes se forem iguais. Desta forma, se rk = rl, ent˜ao teremos k = l.

Isto nos mostra que os res´ıduos r1, r2, r3, r4, ..., rp−1 s˜ao, em n´umeros, p − 1

res´ıduos, todos diferentes de zero e todos distintos entre si. Entretanto s´o h´a p−1 res´ıduos

n˜ao nulos distintos m´odulo p, e esses s˜ao

1, 2, 3, 4, ..., p − 1,

o que deduzimos que a sequˆencia de n´umeros

r1 · r2 · r3 · r4 · ... · rp−1.

1, 2, 3, 4, ..., p − 1,

´e apenas uma mistura de

Um caso particular,

r1 · r2 · r3 · r4 · ... · rp−1 = 1 · 2 · 3 · 4 · ... · (p − 1).

Conclu´ımos, de uma forma gen´erica que, da primeira forma que efetuamos os

c´alculos, a multiplica¸c˜ao dos res´ıduos resulta em

r1 · r2 · r3 · r4 · ... · rp−1 ≡ ap−1 · (1 · 2 · 3 · 4 · ... · (p − 1))(mod p)

e da segunda forma, resulta em

r1 · r2 · r3 · r4 · ... · rp−1 = 1 · 2 · 3 · 4 · ... · (p − 1).

Portanto,

ap−1 · (1 · 2 · 3 · 4 · ... · (p − 1)) ≡ 1 · 2 · 3 · 4 · ... · (p − 1)(mod p).

Contudo, 1 · 2 · 3 · 4 · ... · (p − 1) ´e a multiplica¸c˜ao de invers´ıveis m´odulo p. Logo o n´umero

invers´ıvel m´odulo p, ´e o pr´oprio p. Ent˜ao podemos cancel´a-lo de ambos os membros da

congruˆencia, na qual resulta:

ap−1 ≡ 1(mod p).

Teorema de Fermat

39

O pr´oximo exemplo mostra uma aplica¸c˜ao do Pequeno Teorema de Fermat.

Exemplo 3.4. Calcular o resto da divis˜ao de 368 por 31.

Sabendo que:

330 ≡ 1(mod 31),

pelo Teorema de Fermat e tendo em vista que 68 = 2 · 30 + 8, teremos:

368 ≡ (330)2 · 38 ≡ 1 · 6561 ≡ 20(mod 31).

40

4 CRIPTOGRAFIA RSA

Reunindo os artif´ıcios e as t´ecnicas matem´aticas apresentadas at´e agora, po-

demos adentrar no mundo do RSA. O t´opico 4.1 descreve o algoritmo desenvolvido por

Ronald Rivest, Adi Shamir e Leonard Adleman, e, como se pode observar, levou o t´ıtulo
pelas iniciais dos sobrenomes de seus desenvolvedores. ´E extremamente necess´ario expli-

cit´a-lo para entender como funciona o procedimento e suas t´ecnicas.

4.1 Algoritmo RSA

O esquema desenvolvido por Rivest, Shamir e Adleman utiliza uma express˜ao

com exponenciais. O texto claro ´e criptografado em blocos, com cada bloco tendo um

valor bin´ario menor que algum n´umero n; ou seja, o tamanho do bloco precisa ser menor

ou igual a log2(n). Na pr´atica, o tamanho do bloco ´e de i bits, onde 2i < n ≤ 2i+l. A

criptograﬁa e a descriptograﬁa tˆem a seguinte forma, para algum bloco de texto claro M

e bloco de texto cifrado C:

C = M e mod n

M = C d mod n = (M e)d mod n = M ed mod n.

Tanto o emissor quanto o receptor precisam conhecer o valor de n. O emissor

conhece o valor de , e somente o receptor conhece o valor de d. Assim, esse ´e um algoritmo

de criptograﬁa de chave p´ublica com uma chave p´ublica P U = {e, n} e uma chave privada

P R = {d, n}. Para que esse algoritmo seja satisfat´orio para a criptograﬁa de chave

p´ublica, os seguintes requisitos precisam ser atendidos:

1. Ser poss´ıvel encontrar valores de e, d, n tais que M ed mod n = M para todo M < n.

2. Ser relativamente f´acil calcular M e mod n e C d mod n para todos os valores de

M < n.

3. Ser invi´avel determinar d dados e e n.

Por enquanto, focalizamos o primeiro requisito e consideremos as outras quest˜oes

mais adiante. Precisamos encontrar um relacionamento na forma

Pr´e-Codiﬁca¸c˜ao

41

M ed mod n = M

O relacionamento a seguir se mant´em se e e d forem inversos multiplicativos m´odulo φ(n),

onde φ(n) ´e a fun¸c˜ao de Euler. O relacionamento entre e e d pode ser expresso como

Isso equivale dizer

ed mod φ(n) = 1

ed ≡ 1mod φ(n)

d ≡ e−1 mod φ(n)

Ou seja, e e d s˜ao inversos multiplicativos mod φ(n). Observe que, de acordo

com as regras da aritm´etica modular, isso ´e verdadeiro somente se d (e, portanto, e) for

relativamente primo a φ(n). De modo equivalente, mdc(φ(n), d) = 1.

Agora, estamos prontos para formular o esquema RSA. Os ingredientes s˜ao os

seguintes:

p, q, dois n´umeros primos

(privados, escolhidos)

n = pq

(p´ublico, calculado)

e, com mdc(φ(n), e) = 1; 1 < e < φ(n)

(p´ublico, escolhido)

d ≡ e−1 (mod φ(n))

(privado calculado)

A chave privada consiste em {d, n} e a chave p´ublica consiste em {e, n} .

Suponha que o usu´ario A tenha publicado sua chave p´ublica e que o usu´ario B queira

enviar a mensagem M para A. Ent˜ao, B calcula C = Be mod n e transmite C. Ao receber

esse texto cifrado, o usu´ario A descriptografa calculando M = C d mod n.

4.2 Pr´e-Codiﬁca¸c˜ao

O que devemos fazer para encriptar uma mensagem no RSA ´e calcular sua

potˆencia m´odulo comparando a um expoente escolhido. No entanto, para ser vi´avel, o

texto deve ser um n´umero inteiro. Entretanto n˜ao ´e isto o que ocorre em geral: a grande

parte das mensagens ´e um texto. Ent˜ao, a primeira coisa que devemos fazer, se queremos

usar RSA, ´e descobrir um modo de converter o texto em uma sequˆencia de n´umeros

inteiros.

Pr´e-Codiﬁca¸c˜ao

42

Vamos supor, para deixar simples, que o texto de origem ´e uma mensagem,

de tal forma que, ela n˜ao cont´em n´umeros, apenas letras, e todas as suas letras s˜ao

mai´usculas. Por ﬁm, vamos supor, tamb´em que, no texto original tem apenas letras sem

acentos, formando as palavras, e seus espa¸cos entre as palavras. Vamos chamar esta etapa

de pr´e-codiﬁca¸c˜ao, para diferenciar do processo de codiﬁca¸c˜ao propriamente dito. Ent˜ao,

na pr´e-codiﬁca¸c˜ao transformaremos as letras do texto original, em n´umeros usando a

Tabela 4.1 para converter as letras em n´umeros.

Adotaremos que os espa¸cos entre as palavras ser˜ao substitu´ıdos por 99. Utili-

zaremos como exemplo a frase AMO O PITAGORAS e usando a Tabela 4.1 para converter

a frase em n´umeros teremos:

102224992499251829101624271028

A B C D E F G H I

J K L M

10

11

12

13

14

15

16

17

18

19

20

21

22

N O P Q R S T U V W X Y Z

23

24

25

26

27

28

29

30

31

32

33

34

35

Tabela 4.1: Conversor de letra em n´umero.

Previamente, vamos precisar de parˆametros para determinar o sistema RSA

que vamos usar. Dois primos distintos ser˜ao os parˆametros que denotaremos por p e q, de

forma que o resto na divis˜ao por 6 tem que ser 5. A escolha desse parˆametro ´e explicada

no pr´oximo t´opico.

Escolha n que satisfa¸ca n = p·q. E por ´ultimo vamos quebrar a frase convertida

de n´umero longo em blocos menores. Cada bloco tem que conter n´umeros menores que

n. Exempliﬁcando, escolhendo p = 17 e q = 23, ent˜ao n = 391. Aplicando a quebra do

n´umero longo em blocos menores teremos:

102 − 224 − 99 − 249 − 92 − 51 − 82 − 9 − 101 − 62 − 42 − 7 − 102 − 8

Devemos tomar alguns cuidados ao quebrar o n´umero longo em blocos menores para

n˜ao haver ambiguidade, por exemplo, se tomarmos o conversor come¸cando do n´umero 1

haveria problema, pois se tivermos a letra B (seu n´umero correspondente 2) e a letra A

juntas n˜ao saber´ıamos distinguir da letra V (de n´umero correspondente 21). Al´em disso,

Codiﬁcando e Decodiﬁcando

43

os blocos n˜ao devem come¸car por 0, pois seria um problema, tamb´em, distinguir o bloco

071 do bloco 71. Vale ressaltar que o texto num´erico n˜ao corresponde a uma unidade

lingu´ıstica e isso ´e bom, pois torna a an´alise de frequˆencia imposs´ıvel.

4.3 Codiﬁcando e Decodiﬁcando

Assim que encerrada a fase de pr´e-codiﬁca¸c˜ao, podemos iniciar a etapa de

codiﬁca¸c˜ao. Vamos precisar de n para codiﬁcar a mensagem. Chamaremos n de chave do

RSA e ela pode ser tornada p´ublica, ou seja, sem se preocupar em manter n em segredo,

pode-se enviar n a todos que queiram enviar uma mensagem. Stallings (2010) aﬁrma que

esse tipo de chave de codiﬁca¸c˜ao ´e conhecido como chave p´ublica.

Com os blocos pr´e-codiﬁcados, codiﬁcaremos bloco a bloco de forma separada.

A mensagem codiﬁcada aparecer´a na ordem em que os blocos forem codiﬁcados e essa

sequencia n˜ao pode ser modiﬁcada, pois ﬁcaria imposs´ıvel decodiﬁcar a mensagem original.

4.3.1 Codiﬁca¸c˜ao

Para codiﬁcar escolheremos um n´umero inteiro positivo e, de modo que o

mdc(n, e) = 1

e

1 < e < n, como destacado na Se¸c˜ao 4.1 no Algoritmo RSA.

Chamaremos C(b) de codiﬁcador de bloco e a f´ormula para calcul´a-lo ´e:

C(b) ≡ be(mod n).

Escolheremos e = 3 para nossa codiﬁca¸c˜ao de forma que, pegando bloco a

bloco e codiﬁcando-os.

C(102) ≡ 1023 ≡ 1022 · 102 ≡ 24276 ≡ 34(mod 391);

C(224) ≡ 2243 ≡ 2242 · 224 ≡ 128 · 224 ≡ 129(mod 391);

C(99) ≡ 993 ≡ 992 · 99 ≡ 29 · 99 ≡ 228(mod 391);

C(249) ≡ 2493 ≡ 2492 · 249 ≡ 223 · 249 ≡ 5(mod 391);

C(92) ≡ 923 ≡ 922 · 92 ≡ 253 · 92 ≡ 207(mod 391);

C(51) ≡ 513 ≡ 512 · 51 ≡ 255 · 51 ≡ 102(mod 391);

C(82) ≡ 823 ≡ 822 · 82 ≡ 77 · 82 ≡ 58(mod 391);

Decodiﬁcando

44

C(9) ≡ 93 ≡ 92 · 9 ≡ 81 · 9 ≡ 338(mod 391);

C(101) ≡ 1013 ≡ 1012 · 101 ≡ 35 · 101 ≡ 16(mod 391);

C(62) ≡ 623 ≡ 622 · 62 ≡ 325 · 62 ≡ 209(mod 391);

C(42) ≡ 423 ≡ 422 · 42 ≡ 200 · 42 ≡ 189(mod 391);

C(7) ≡ 73 ≡ 72 · 7 ≡ 49 · 7 ≡ 343(mod 391);

C(102) ≡ 1023 ≡ 1022 · 102 ≡ 238 · 102 ≡ 34(mod 391);

C(8) ≡ 83 ≡ 82 · 8 ≡ 64 · 8 ≡ 121(mod 391);

Ent˜ao temos a mensagem codiﬁcada, ap´os aplicar nosso codiﬁcador de bloco e

´e:

34 − 129 − 228 − 5 − 207 − 102 − 58 − 338 − 16 − 209 − 189 − 343 − 34 − 121

4.3.2 Decodiﬁcando

Para decodiﬁcar precisaremos da chave p´ublica e de um bloco codiﬁcado para

podermos reconstruir o bloco antes da codiﬁca¸c˜ao. Ent˜ao o que realmente precisamos

´e ter o n´umero n e ter o n´umero inverso d > 0 de 3 m´odulo (p − 1)(q − 1), ou seja,

3d ≡ 1(mod (p − 1)(q − 1)). A chave privada {d, n} precisa manter-se em segredo, caso

contr´ario, quem a tiver poder´a decodiﬁcar as mensagens enviadas para vocˆe.

Chamaremos o bloco codiﬁcado de D(a), onde a ´e o bloco codiﬁcado e a

f´ormula para decodiﬁc´a-lo ´e:

D(a) ≡ ad(mod n)

No t´opico 4.2 supomos que p e q deixam resto 5 na divis˜ao por 6, logo:

p ≡ 5(mod 6)

e

q ≡ 5(mod 6)

Desta forma,

e

(p − q)(q − 1) ≡ 4 · 4 ≡ 16 ≡ 4 ≡ −2(mod 6);

Decodiﬁcando

45

(p − q)(q − 1) ≡ 6 · k − 2,

para algum n´umero inteiro k positivo. Aplicando nossos conhecimentos do t´opico 3.3

descobrimos que o inverso de 3 m´odulo 6 · k − 2 ´e 4 · k − 1, assim, tomaremos

d = 4 · k − 1.

Como p = 17 e q = 23, temos que:

(p − 1)(q − 1) = (17 − 1)(23 − 1) = 16 · 22 = 352 = 6 · 58 + 4

na qual,

Logo, k = 59 e

(p − 1)(q − 1) = 6 · 59 − 2.

d = 4 · 59 − 1 = 235.

De posse do n´umero d = 235 podemos aplicar D(a) e usaremos a = 34, desta

forma teremos D(34) ≡ 34235(mod 391). Para resolvermos essa congruˆencia, recorrere-

mos aos t´opicos 3.4.1 (Teorema Chinˆes do Resto) e 3.5.2 (Teorema de Fermat) na qual

calcularemos 34235 m´odulo 17 e m´odulo 23, pois n = 391 = 17 · 23.






34 ≡ 0(mod 17)

34 ≡ 11(mod 23)

,

temos que 34235 ≡ 0235 ≡ 0(mod 17). Por outro lado, pelo Teorema de Fermat,

11235 ≡ (1122)101115 ≡ 1115(mod 23).

S´o que,

ent˜ao

11 ≡ −12 ≡ −4 · 3(mod 23)

11235 ≡ 1115 ≡ −415 · 315(mod 23);

46

Decodiﬁcando

Assim,

de modo que

411 ≡ 1(mod 23),

311 ≡ 1(mod 23),

415 ≡ 230 ≡ (211)2 · 28 ≡ 28 ≡ 3(mod 23),

315 ≡ 311 · 34 ≡ 34 ≡ 12(mod 23).

Desta forma conclu´ımos que

11235 ≡ −415 · 315 ≡ −3 · 12 ≡ 10(mod 23).

Portanto

corresponde a






34235 ≡ 0(mod 17)

34235 ≡ 10(mod 23)

,






x ≡ 0(mod 17)

x ≡ 10(mod 23)

.

Usaremos o Teorema Chinˆes do Resto para resolver esse sistema de congruˆencia. Da linha

2 do sistema obtemos, x = 10 + 23y. Substituindo na linha 1 obtemos,

10 + 23y ≡ 0(mod 17).

Desta forma 6y ≡ 7(mod 17). No entanto 6 possui inverso 3 m´odulo 17, de

madeira que y ≡ 3 · 7 ≡ 4(mod 17). Logo,

x = 10 + 23y = 10 + 23 · 4 = 102;

e j´a era esperado esse resultado, j´a que decodiﬁcamos 34, e este ´e correspondente a codi-

ﬁca¸c˜ao do bloco 102.

Seguran¸ca RSA

4.4 Seguran¸ca RSA

47

Vejamos ent˜ao porque funciona. Como j´a vimos, existe a fun¸c˜ao φ(n) que

calcula a quantidade de mdc entre dois n´umeros ser´a igual a 1 e tamb´em vimos que

φ(n) = φ(pq) = (p − 1)(q − 1). Outro fator se deve ao Teorema de Fermat, que Euler

generalizou, e aﬁrma que, se pegarmos a e n de maneira que o m´aximo divisor comum

seja igual a 1, ent˜ao aφ(n) quando dividimos por n possui resto da divis˜ao igual a 1, ou

seja:

aφ(n) ≡ 1 mod (n).

Escolhendo n, sendo n o produto de dois n´umeros primos p e q, aplicando o

Teorema de Fermat Euler teremos:

a(p−1)(q−1) ≡ 1 mod (n).

Fazendo algumas manipula¸c˜oes teremos a1+m(p−1)(q−1), pela qual, pegando esse n´umero e

dividindo por p · q, o resto dessa divis˜ao ´e igual a a, ou seja:

a1+m(p−1)(q−1) ≡ a mod (pq),

e esta ´e a chave do m´etodo RSA. Reunindo as informa¸c˜oes e inicialmente escolhemos o

n´umero e, de maneira que mdc(e, (p − 1)(q − 1)) = 1, tamb´em foi escolhido o n´umero d,

de maneira que e · d ≡ 1(mod (p − 1)(q − 1)) e foi feito os c´alculos fazendo ae ≡ b(mod n),

ou seja, bd = (ae)d = aed = a1+m(p−1)(q−1)≡a(mod n), e ´e justamente essa ultima linha que

garante que a codiﬁca¸c˜ao e a decodiﬁca¸c˜ao funciona.

48

5 APLICAC¸ ˜OES DE CRIPTOGRAFIA NA SALA

DE AULA

O objetivo desse cap´ıtulo ´e propor atividades em que alguns conte´udos abor-

dados neste texto sejam trabalhados em sala de aula com alunos do Ensino Fundamental

ou Ensino M´edio.

5.1 Atividade 1

Cifra de C´esar - Um dos primeiros sistemas de Criptograﬁa conhecido foi

elaborado pelo general J´ulio C´esar, no Imp´erio Romano. J´ulio C´esar substituiu cada letra

pela terceira letra que a segue no alfabeto, como ilustrado na Figura 5.1.

Figura 5.1: Sistema Criptogr´aﬁco de J´ulio C´esar.

Baseado nesse crit´erio:

a) Codiﬁque a frase: Eu gosto de Matem´atica;

b) Decifre a mensagem: OHJDO FRQVHJXL;

c) Em vez de caminhar trˆes letras para frente, podemos andar outro n´umero

de letras e teremos um novo m´etodo de cifrar mensagens. Esse n´umero ´e

chamado de chave ou senha do sistema criptogr´aﬁco, o qual, por motivos

´obvios, s´o deve ser conhecido por quem envia a mensagem e por quem a

recebe. Estabele¸ca agora o seu crit´erio de codiﬁca¸c˜ao avan¸cando mais do

que trˆes letras. Escreva uma palavra para a outra pessoa da sua dupla e

pe¸ca a ela para tentar decodiﬁcar sua mensagem. Se ela n˜ao conseguir,

conte o seu crit´erio e pe¸ca para ela tentar novamente.

Atividade 2

5.2 Atividade 2

49

Disco de Cifras - Podemos transformar letras em n´umeros, no processo de

substitui¸c˜ao de letras para criptografar uma mensagem. No quadro a seguir (Figura 5.2),

temos um exemplo de como podemos fazer essa associa¸c˜ao.

Figura 5.2: Sistema Criptogr´aﬁco associando letras a n´umeros.

Desse modo, a letra codiﬁcada ´e obtida da letra original, somando-se trˆes ao

n´umero correspondente. Mas, como vimos, podemos somar outros n´umeros. A partir

dessas informa¸c˜oes, resolva o problema a seguir, retirado de uma prova da Olimp´ıada

Brasileira de Matem´atica das Escolas P´ublicas - OBMEP1 2007, N´ıvel 2.

Um antigo m´etodo para codiﬁcar palavras consiste em escolher um

n´umero de 1 a 26, chamado chave do c´odigo, e girar o disco interno do aparelho

ilustrado na ﬁgura at´e que essa chave corresponda `a letra A. Depois disso, as

letras da palavra s˜ao substitu´ıdas pelos n´umeros correspondentes, separados

por tracinhos. Por exemplo, na Figura 5.3, a chave ´e 5 e a palavra P AI ´e

codiﬁcada como 20-5-13.

a) Usando a chave indicada na ﬁgura, descubra qual palavra foi codiﬁcada

como: 23-25-7-25-22-13;

b) Codiﬁque OBMEP usando a chave 20;

c) Chic´o codiﬁcou uma palavra de 4 letras com a chave 20, mas esqueceu-se

de colocar os tracinhos e escreveu 2620138. Ajude Chic´o colocando os

tracinhos que ele esqueceu e depois escreva a palavra que ele codiﬁcou;

d) Em uma outra chave, a soma dos n´umeros que representam as letras A,

B e C ´e 52. Qual ´e essa chave?

1Encontrado no endere¸co eletrˆonico: < http : //www.obmep.org.br/provas static/pf 2n2−2007.pdf >.

Acesso em 22 de fevereiro de 2017.

Atividade 3

50

Figura 5.3: Disco de cifra.

5.3 Atividade 3

Carreiras de Vigen`ere - Atribu´ıdo erroneamente ao francˆes Blase Vi-

gen`ere a Cifra de Vigen`ere ou Carreiras de Vigen`ere foi um marco hist´orico na segu-

ran¸ca de informa¸c˜oes pois acreditavam que a cifra fosse inquebr´avel por ser um sistema

criptogr´aﬁco polialfab´etico na qual utiliza-se palavras-chave.

Chic´o, ao estudar Vigen`ere, observou que Blase Vigen`ene aperfei¸coou uma

t´ecnica existente e ent˜ao decidiu criar as Carreiras de Chic´o ou Cifra de Chic´o (Figura

5.4) que consiste em substituir palavras-chave por deslocamento num´erico para cifrar uma

mensagem. A Tabela 5.1 exempliﬁca Chic´o cifrando a mensagem: ATACAR

mensagem original

A T A C A R

deslocamento

3

7

12

20

23

14

mensagem codiﬁcada D A M W X F

Tabela 5.1: Codiﬁca¸c˜ao de Chic´o.

Usando deslocamento 15 - 12 - 15 - 1 e suas repeti¸c˜oes:

Reﬂex˜oes sobre a Atividade 1

51

Figura 5.4: Carreiras de Chic´o.

a) Codiﬁque TECNOLOGIA;

b) Decodiﬁque SUVB CMD BH PGPVMH

c) ´E poss´ıvel decodiﬁcar uma mensagem utilizando as Carreiras de Chic´o

sem saber os deslocamentos utilizados?

5.4 Reﬂex˜oes sobre a Atividade 1

– Cifra de C´esar:

a) Codiﬁque a frase: Eu gosto de Matem´atica. HX JRV W R GH P DW HP DW LF D;

b) Decifre a mensagem OHJDO F RQV HJXL. LEGAL CONSEGUI;

c) Este item dessa atividade gera respostas pessoais dos alunos, dependendo da

senha que escolherem.

5.5 Reﬂex˜oes sobre a Atividade 2

– Disco de Cifras:

Reﬂex˜oes sobre a Atividade 3

52

a) A partir da ﬁgura do enunciado temos 23 = S, 25 = U , 7 = C, 22 = R e

13 = I. Logo, a palavra codiﬁcada como 23-25-7-25-22-13 ´e SU CU RI;

b) Para a chave 20 temos a ﬁgura abaixo, na qual vemos que O = 8, B = 21,

M = 6, E = 24 e P = 9.

Assim, a codiﬁca¸c˜ao de OBM EP ´e 8-21-6-24-9. Alternativamente, ao pas-

sar da chave 5 para a chave 20 devemos somar 15 aos n´umeros da ﬁgura do

enunciado, lembrando que se a soma for maior do que 26 devemos subtrair 26.

Assim, temos: em que OBM EP ´e codiﬁcada como 8-21-6-24-9;

c) Como n˜ao existe letra codiﬁcada como 0, um dos n´umeros associados a letras
na sequˆencia 2620138 ´e o 20. `A sua direita h´a trˆes d´ıgitos, mas como n˜ao h´a

letra codiﬁcada como 138 ou 38, os n´umeros associados a letras s˜ao o 13 e o

8.

Isto d´a um total de trˆes letras. Portanto, `a esquerda de 20 s´o podemos

admitir o 26. Logo, a codiﬁca¸c˜ao da palavra ´e 26-20-13-8, a qual, na chave 20,

corresponde a GAT O;

d) Quando somamos trˆes n´umeros consecutivos, obtemos um n´umero divis´ıvel por

3; por exemplo, 14 + 15 + 16 = 45. Ao somar os n´umeros que representam as

letras A, B e C nessa certa chave, obtemos 52, que n˜ao ´e um n´umero divis´ıvel

por 3. Isso mostra que os trˆes n´umeros n˜ao s˜ao consecutivos e isso somente ´e

poss´ıvel se um dos n´umeros for 26 e outro for 1. Como a soma ´e 52, o terceiro

n´umero ´e 52 − 27 = 25. A ´unica codiﬁca¸c˜ao de ABC, nesse caso, ´e 25-26-1, ou

seja, a chave ´e 25.

5.6 Reﬂex˜oes sobre a Atividade 3

– Carreiras de Vigen`ere:

a) IQRODXDHXM

b) DIGA NAO AS DROGAS

c) Sim. As Carreiras de Chic´o acompanham a metodologia das cifras polial-

fab´eticas e ao fazer an´alise de frequˆencia vai-se veriﬁcar um padr˜ao e quanto

maior a mensagem mais f´acil se torna a decodiﬁca¸c˜ao.

53

6 CONSIDERAC¸ ˜OES FINAIS

Este trabalho teve como objetivo compreender os conceitos matem´aticos

envolvidos que desencadearam na cria¸c˜ao da Criptograﬁa RSA, e segundo algumas

an´alises ´e predominantemente aplicado em compras pela internet, com cart˜oes de

pagamento e assinatura digital.

Primeiramente foi trabalhada uma vis˜ao hist´orica na qual a necessidade de manter

as informa¸c˜oes em sigilo era fator primordial e decisivo em batalhas. Veriﬁcamos

que a criptologia, no decorrer do tempo, passou por muitas muta¸c˜oes para obter a

seguran¸ca perfeita, no entanto, pesquisas bibliogr´aﬁcas apontaram a n˜ao existˆencia

dessa solu¸c˜ao ´ıntegra e ´otima.

Sabendo que n˜ao existem mecanismos totalmente seguros e visando a defesa de um

poss´ıvel ataque a essas trocas de informa¸c˜oes ´e necess´ario garantir um tempo h´abil

que essas informa¸c˜oes permanecer˜ao seguras.

Apresentar ao aluno a perspectiva de envio e recebimento de mensagem usando

materiais b´asicos como l´apis e papel dar-se-´a uma motiva¸c˜ao maior ao aprendizado

contextualizado, pois tem-se aprendizagem quando compreendemos conhecimento

te´orico aliada a visualiza¸c˜ao atrav´es da pr´atica, e ´e o que torna o processo mais

interessante.

A Teoria dos N´umeros foi e ´e o alicerce do algoritmo RSA. A criptograﬁa RSA

baseia-se na diﬁculdade de obter n´umeros primos como fatores de decomposi¸c˜ao de

um n´umero relativamente grande, e essa ´e a principal seguran¸ca deste modelo.

54

REFERˆENCIAS

COUTINHO, S. C. N´umeros inteiros e criptograﬁa RSA. S´erie de Computa¸c˜ao e Ma-
tem´atica n.2, IMPA e SBM, segunda edi¸c˜ao (revista e ampliada), 2000.

. Criptograﬁa. Programa de Inicia¸c˜ao Cient´ıﬁca da OBMEP. IMPA/OBMEP, 1 ed.

(d´ecima impress˜ao), Rio de Janeiro - RJ: IMPA, 2014.

. Criptograﬁa. Programa de Inicia¸c˜ao Cient´ıﬁca da OBMEP. IMPA/OBMEP

(www.obmep.org.br), 1 ed.
IMPA, 2015.

(d´ecima primeira impress˜ao), Rio de Janeiro - RJ:

FRANC¸ A, Milena Cristina. Rede de Computadores. Florian´opolis ? SC: Publica¸c˜oes do

IFSC, 2010.

HEFEZ, A. Elementos de Aritm´etica. Sociedade Brasileira de Matem´atica. 2005.

PAIVA, S. Plant˜aoNERD.com. Supercomputador faz 20 trilh˜oes de c´alculos por se-
gundo, 2012. Dispon´ıvel em: < http : //www.plantaonerd.com/blog/2012/03/15/
supercomputador − f az − 20 − trilhoes − de − calculos − por − segundo/ > Acesso
em: 20 de maio de 2016.

SANTOS, J. Pl´ınio de O. Introdu¸c˜ao `a Teoria dos N´umeros. 3 ed. (terceira impress˜ao).

Rio de Janeiro - RJ: IMPA, 2006.

SINGH, S. O livro dos c´odigos. S˜ao Paulo: Editora Record. 2001.

STALLINGS, W. Criptograﬁa e Seguran¸ca de Redes. Tradu¸c˜ao de Daniel Vieira. 4 Ed.

Editora Pearson, S˜ao Paulo - SP, 2010.

