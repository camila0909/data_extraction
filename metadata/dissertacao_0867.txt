UNIVERSIDADE ESTADUAL DO SUDOESTE DA BAHIA 

MESTRADO PROFISSIONAL EM MATEM√ÅTICA EM REDE 

NACIONAL ‚Äì PROFMAT 

ERLON ASSUN√á√ÉO WANDENKOLK ALVES 

CodeClass: o uso da tecnologia como recurso metodol√≥gico no 

ensino da criptografia  

Vit√≥ria da Conquista/BA 

2019 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
UNIVERSIDADE ESTADUAL DO SUDOESTE DA BAHIA 

MESTRADO PROFISSIONAL EM MATEM√ÅTICA EM REDE  

NACIONAL ‚Äì PROFMAT 

ERLON ASSUN√á√ÉO WANDENKOLK ALVES 

CodeClass: o uso da tecnologia como recurso metodol√≥gico no 

ensino da criptografia  

Disserta√ß√£o  apresentada  ao  Mestrado  Profissional  em 

Matem√°tica  em  Rede  Nacional  ‚Äì  PROFMAT,  oferecido 

pela  Universidade  Estadual  do  Sudoeste  da  Bahia  ‚Äì 

UESB, como requisito necess√°rio para obten√ß√£o do grau 

de  Mestre  em  Matem√°tica.  Orientadora:  Prof¬™.  Dr¬™ 

Alexsandra Oliveira Andrade. 

Vit√≥ria da Conquista/BA  

2019 

 
 
 
 
 
 
 
 
 
 
 
 
 
  A478c      Alves, Erlon Assun√ß√£o Wandenkolk.  

                       CodeClass: o uso da tecnologia como recurso metol√≥gico no ensino da 

criptografia. / Erlon Assun√ß√£o Wandenkolk Alves, 2019. 

                         91f. il.  
                         Orientador (a): Dra. Alexsandra Oliveira Andrade.  
                         Disserta√ß√£o (mestrado) ‚Äì Universidade Estadual do Sudoeste 
                    da Bahia, Mestrado Profissional em Matem√°tica em Rede Nacional ‚Äì  
                    PROFMAT, Vit√≥ria da Conquista - BA, 2019. 
                          Inclui refer√™ncias. 85 - 86. 

        1. Criptografia - Ensino. 2. CodeClass - Aplicativo. 3. Aritm√©tica.  4. 
N√∫meros primos. I. Andrade, Alexsandra Oliveira.   II. Universidade 
Estadual Sudoeste da Bahia, Mestrado Profissional em Matem√°tica em 
Rede Nacional ‚Äì PROFMAT, Vit√≥ria da Conquista, III. T. 

CDD: 510 

Cataloga√ß√£o na fonte: Juliana Teixeira de Assun√ß√£o- CRB 5/1890 
UESB ‚Äì Campus Vit√≥ria da Conquista ‚Äì BA  

 
 
 
 
 
 
 
 
       
         
                  
 
   
 
 
 
 
 
                                                                                                   
                                                                                                      
                                                                              
 
                                  
                                                                                                                                       
                                                                                 
                           
 
ERLON ASSUN√á√ÉO WANDENKOLK ALVES 

CodeClass: o uso da tecnologia como recurso metodol√≥gico no 

ensino da criptografia  

Disserta√ß√£o  apresentada  ao  Mestrado  Profissional  em 

Matem√°tica  em  Rede  Nacional  ‚Äì  PROFMAT,  oferecido 

pela  Universidade  Estadual  do  Sudoeste  da  Bahia  ‚Äì 

UESB, como requisito necess√°rio para obten√ß√£o do grau 

de Mestre em Matem√°tica.  

BANCA EXAMINADORA 

_____________________________________________ 

Professora Dr¬™.  Alexsandra Oliveira Andrade (Orientadora) 

Universidade Estadual do Sudoeste da Bahia ‚Äì UESB 

____________________________________________ 

Professor Dr. Flaulles Boone Bergamaschi 

Universidade Estadual do Sudoeste da Bahia ‚Äì UESB 

_______________ ___________________________ 

Professor Dr. Ronildo Pinheiro de Ara√∫jo Moura 

Universidade Federal do Rio Grande do Norte 

Vit√≥ria da Conquista/BA  

2019 

 
 
 
 
 
 
 
 
O segredo da felicidade √©  

   a felicidade do segredo. 

    (desconhecido)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     
 
     
 
 
 
DEDICAT√ìRIA 

trabalho  a 

todos 
Dedico  este 
aqueles  apaixonados  n√£o  s√≥  pela 
matem√°tica,  mas  sim  apaixonados 
tamb√©m  por  torn√°-la  ainda  mais 
apaixonante. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Finalmente, o momento de escrever os agradecimentos, este que prometi fazer 

somente  ao  conseguir  findar  este  trabalho.  Foram  tantos  colaboradores  diretos  e 

indiretos que esquecer o nome de alguns, n√£o ser√° dif√≠cil. 

Primeiramente  gostaria  de  agradecer  a  minha  esposa  Mylena  e  ao  meu 

pequeno Bento, por serem pacientes e compreensivos em todas as noites que me fiz 

ausente  durante  essa  trajet√≥ria.  Sei  que  n√£o  foi  f√°cil  para  n√≥s,  mas  finalmente 

superamos todos estes obst√°culos. 

Gostaria de agradecer aos meus pais pela compreens√£o e apoio nos momentos 

dif√≠ceis que enfrentamos, nas adversidades e tarefas que tiveram de ser abandonadas 

e  a  minha  irm√£  Sirlara  (Songs),  por  todo  carinho,  for√ßa  e  aux√≠lio  prontamente 

prestados. 

Em terceiro, quero agradecer a minha orientadora, Dr¬™ Alexsandra pelo apoio 

e palavras de tranquilidade, que sempre se prontificou ouvir e colaborar com as mais 

malucas ideias que tive durante essa jornada. 

Queria  agradecer  tamb√©m  aos  meus  colegas  do  PROFMAT,  que  tamb√©m 

lutaram junto comigo cada um atr√°s do seu pr√≥prio destino e sem nunca abandonar o 

pr√≥ximo:  Abizai,  Alan,  Ant√¥nio  Marcos,  Daniel,  Dimas,  Jocasta,  J√∫lio,  L√≠dia,  Liliane, 

Lupicino, Marcos, Paula, Rom√°rio. Todos voc√™s s√£o merecedores dessa  conquista; 

Em especial queria agradecer aos colegas Juli√£o pela nossa caminhada e conversas 

em  tantos  quil√¥metros  rodados,  uma  amizade  que  iniciou  no  PROFMAT  e  dever√° 

perdurar  por  muitos  anos.  L√≠dia,  pelo  companheirismo  de  sempre  e  Marc√£o  pelos 

experientes conselhos e pelo grande apoio quando eu e J√∫lio precisamos. 

Finalmente, gostaria de agradecer a dire√ß√£o, professores e colaboradores 

do  Col√©gio  Estadual Governador Luiz  Viana  Filho,  pelo apoio e  incentivo  durante a 

execu√ß√£o deste trabalho. 

O meu muito obrigado a todos voc√™s. 

 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1 Cifra de C√©sar ............................................................................................. 13 

Figura 2 Tela Inicial MIT App Inventor II .................................................................... 28 

Figura 3 Tela de Designer de Aplicativo do MIT App Inventor II ............................... 29 

Figura 4 Interface de Programa√ß√£o ........................................................................... 30 

Figura 5 Correspond√™ncia da Cifra de C√©sar ............................................................ 31 

Figura 6 Permuta√ß√£o segundo ùúé ............................................................................... 32 

Figura 7 Compara√ß√£o k=1 e k=3 ............................................................................... 35 

Figura 8 Produto de Primos de 1 a 50 ....................................................................... 38 

Figura 9 √çcone e Slogan do CodeClass ..................................................................... 46 

Figura 10 Tela Inicial do CodeClass .......................................................................... 47 

Figura 11 Interface Criptografia Linear ...................................................................... 48 

Figura 12 Exemplo de Preenchimento ...................................................................... 49 

Figura 13 Codifica√ß√£o e Gera√ß√£o das Chaves .......................................................... 50 

Figura 14 Tela de boas-vindas Criptografia RSA ...................................................... 51 

Figura 15 Gera√ß√£o das Chaves RSA ........................................................................ 52 

Figura 16 Codifica√ß√£o, Codifica√ß√£o sem assinatura e Codifica√ß√£o com Assinatura . 53 

Figura  17  Decodifica√ß√£o,  Decodifica√ß√£o  sem  Assinatura  e  Decodifica√ß√£o  com 
Assinatura .............................................................................................. 55 

Figura 18 Gerador de Primos .................................................................................... 56 

Figura 19 Correspond√™ncia Letra-N√∫mero ................................................................ 58 

Figura 20 Inversos Multiplicativos em ‚Ñ§26 ................................................................. 60 

 
Figura 21 Rel√≥gio de 26 horas .................................................................................. 61 

Figura 22 Sugest√µes de Chaves para Atividade ....................................................... 63 

Figura 23 Cart√£o da Parte II Criptografia Linear ........................................................ 69 

Figura 24 Resposta de um aluno √† Parte II ............................................................... 70 

Figura 25 Troca de mensagens utilizando Criptografia RSA. Parte IV ...................... 72 

Figura 26 Cart√£o falso, confeccionado pelo mediador. ............................................. 73 

Figura 27 E-mail falso ............................................................................................... 74 

Figura 28 Troca de mensagens entre E e R utilizando assinatura. ........................... 75 

Figura 29 Chaves do Autor E .................................................................................... 75 

Figura 30 Resultado apresentado na decodifica√ß√£o ................................................. 76 

Figura 31 Mensagem ap√≥s segunda tentativa de decodifica√ß√£o ............................... 77 

 
LISTA DE S√çMBOLOS 

‚Ñï  

‚Ñ§ 

‚Ñù 

‚àà 

‚â°  

Conjunto dos n√∫meros Naturais 

Conjunto dos n√∫meros Inteiros 

Conjunto dos N√∫meros Reais 

Pertence 

Congru√™ncia 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

A  criptografia  √©  raramente  trabalhada  na  educa√ß√£o  b√°sica,  pois  n√£o  consta 

diretamente  como  componente/conte√∫do  obrigat√≥rio  na  BNCC.  Tal  fato  apresenta 

ainda enquanto algo a ser trabalhado, pois √© um assunto extremamente importante, 

dado  o  contexto  de  que  vivemos  em  uma  era  digital  e  que  este  serve  de  porta  de 

entrada  para  diversos  outros  assuntos  que  comp√µe  a  grade  curricular  do  ensino 

m√©dio. Diante desta quest√£o, este trabalho tem como objetivo principal desenvolver 

um aplicativo que sirva como uma metodologia para o ensino da criptografia no ensino 

m√©dio. Este aplicativo desenvolvido √© intitulado de CodeClass e ser√° o protagonista 

numa proposta que visa popularizar o ensino da criptografia, por meio das tecnologias, 

podendo servir de porta de entrada para se trabalhar, al√©m deste assunto, diversos 

outros conte√∫dos na educa√ß√£o b√°sica.  Como resultados obtidos, foi realizado al√©m 

do  desenvolvimento  do  aplicativo,  uma  atividade  como  exemplo  neste  contexto 

educacional.  Assim,  foi  observado  que  o  uso  das  tecnologias  estimula  e  instiga  os 

alunos durante o processo de aprendizagem e que √© poss√≠vel utilizarmos a criptografia 

para abordar assuntos como fun√ß√µes e aritm√©tica b√°sica de uma maneira bem menos 

densa.  

Palavras-Chaves: Criptografia, RSA, CodeClass, N√∫meros Primos, Aritim√©tica

 
 
 
 
ABSTRACT 

Cryptography  is  seldom  taught  in  basic  education  since  the  Brazilian  curricular 

standards  (also  known  as  BNCC)  do  not  prescribe  cryptography  as  a  mandatory 

component. In this digital era, cryptography may serve as an introduction to several 

other subjects that make up the high school curriculum. Given the stated above, this 

paper aims to develop a application that provides a framework for teaching encryption 

in  high  school.  The  application  is  called  CodeClass  and  through  the  use  of  this 

technology  we  propose  to  popularize  the  teaching  of  cryptography  and  help  the 

teaching of various other contents of high school mathematics. Beyond the application 

development,  an activity  was  performed  as  an  example of  its  use  in  an  educational 

context. Thereby, we observed that the use of CodeClass motivates students during 

the  learning  process  and  that  cryptography  can  be  used  to  address  topics  such  as 

functions and basic arithmetic in a much less dense manner. 

Key-words: Encryption, RSA, CodeClass, Prime Numbers, Arithmetic. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUM√ÅRIO 

1. INTRODU√á√ÉO ................................................................................. 12 

2. REFER√äNCIAL TE√ìRICO ............................................................... 16 

2.1 Algoritmo da Divis√£o......................................................................................... 16 

2.2 Divisibilidade ..................................................................................................... 17 

2.3 MDC e o Algoritmo de Euclides ....................................................................... 18 

2.4 N√∫meros Primos ................................................................................................ 20 

2.5 Fun√ß√µes Aritm√©ticas a Fun√ß√£o ùùì de Euler ...................................................... 21 

2.6 Congru√™ncias .................................................................................................... 22 

2.7 Equa√ß√µes Diofantinas ....................................................................................... 24 

2.8 MIT App Inventor 2 ............................................................................................ 27 

2.1.1. A Interface do Sistema .............................................................................. 28 

2.2. Divis√£o e a Seguran√ßa de Redes: a Criptografia ........................................... 31 

3. CRIPTOGRAFIA .................................................................................... 32 

3.1. Sistema de Criptografia Linear ....................................................................... 32 

3.2. Trabalhando com Blocos ................................................................................. 33 

3.3. O Conceito de Chave P√∫blica .......................................................................... 36 

3.4. O RSA ................................................................................................................ 37 

3.4.1. Codifica√ß√£o letra-a-letra ............................................................................ 40 

3.4.2. Codifica√ß√£o por transposi√ß√£o de blocos .................................................... 41 

3.4.3. Decodifica√ß√£o ........................................................................................... 42 

3.4.4. Assinatura do RSA .................................................................................... 44 

4. O APLICATIVO CODECLASS E A CRIPTOGRAFIA ...................................... 45 

4.1. O aplicativo .................................................................................................. 45 

4.2. Interface ....................................................................................................... 46 

4.3. SUGEST√ÉO I ‚Äì Origem da Criptografia ....................................................... 57 

4.4. SUGEST√ÉO II ‚Äì Criptografia de Chave P√∫blica ........................................... 63 

4.5. Aplica√ß√£o do CodeClass .............................................................................. 66 

4.5.1. A Oficina ................................................................................................... 67 

5. RESULTADOS E DISCUSS√ïES ................................................................. 79 

 
 
 
1.1. Confec√ß√£o do CodeClass ......................................................................... 79 

1.2. Oficina .......................................................................................................... 80 

6. CONSIDERA√á√ïES FINAIS ...................................................................... 81 

REFER√äNCIAS .................................................................................... 83 

ANEXO A ............................................................................................. 85 

ANEXO B ............................................................................................. 89 

 
 
 
12 

1.   INTRODU√á√ÉO 

 O mundo mudou! O que antes era feito com um rel√≥gio despertador ou, em 

alguns casos, com o cocoricar de um galo, hoje √© feito pelo seu celular. As ruas que 

antes eram lentas e vagarosas, est√£o cada vez mais expressas e densas de ve√≠culos 

automotores. Se antes para obter not√≠cias era preciso esperar o hor√°rio do jornal no 

r√°dio, ou adquirir um impresso em uma banca, hoje enquanto estamos desatentos as 

not√≠cias chegam, e chegam, √†s vezes, antes mesmo de acontecer. 

Ainda  assim,  existem  coisas  no  mundo  que  n√£o  mudaram  e  uma  delas  √©  a 

necessidade  de  ocultar informa√ß√µes.  Esta  necessidade n√£o  aparece  com  a  difus√£o 

dos recursos tecnol√≥gicos, mas sim dos fatos mais corriqueiros que temos no dia a 

dia. Para exemplificar, imagine a situa√ß√£o de uma partida de xadrez acirrada, em que 

o advers√°rio n√£o consegue ler a sua mente para prever qual a sua estrat√©gia e tra√ßar, 

assim,  um  plano  de  defesa  ou  contra-ataque  antecipadamente.  Somente  ap√≥s  o 

movimento √© que voc√™ poder√° pensar no que pode ser feito. Em guerras ou batalhas 

por  poder,  o  princ√≠pio  que  rege  a  estrat√©gia  √©  o  mesmo.  Um  comandante  precisa 

informar √†  suas  tropas  qual rumo  tomar na  batalha  e  quais estrat√©gias  ir√£o  adotar. 

Por√©m, o inimigo tamb√©m quer saber qual a estrat√©gia ser√° usada para n√£o ser pego 

desprevenido e √© a partir dessa demanda que surge a necessidade de come√ßarmos 

a esconder certas informa√ß√µes.  

Como se j√° n√£o bastasse, com o advento da tecnologia, passamos todos a ficar 

conectados um ao outro, numa gigantesca rede chamada Internet. Nesta rede, cada 

computador do mundo est√°, literalmente, ligado um ao outro. Dentro deste contexto, 

torna-se inevit√°vel a utiliza√ß√£o de um meio que sirva para acobertar este tr√°fego, de 

modo  que  certas  informa√ß√µes  n√£o  sejam  interceptadas  por  destinat√°rios  n√£o 

autorizados.  Assim,  um  dos  meios  utilizados  para  prote√ß√£o  de  informa√ß√µes  √© 

conhecido  como  a  criptografia.  ‚ÄúA  criptografia  estuda  os  m√©todos  para  codificar  uma 

mensagem de modo que s√≥ seu destinat√°rio leg√≠timo consiga interpret√°-la.‚Äù [1]. 

Para contextualizarmos, um dos primeiros a utilizar um sistema de criptografia 

foi  J√∫lio  C√©sar  (100  a.C).  Na  Figura  1,  intitulado  Cifra  de  C√©sar,  √©  feita  uma 

substitui√ß√£o,  em  todo  texto,  de  cada  letra  por  uma  outra  que  √©  obtida  atrav√©s  da 

 
 
13 

permuta√ß√£o escolhida previamente. Na segunda linha, temos a imagem de cada letra 

da primeira linha ap√≥s a permuta√ß√£o. 

Figura 1 Cifra de C√©sar 

Fonte: O autor 

Observe que nessa situa√ß√£o, ao cifrarmos a palavra JULIO CESAR, obtemos 

MXOLR FHVDU.  

Este sistema, apesar de ser in√©dito e eficiente para a √©poca, √© bastante fr√°gil. 

Visto que se for observado certo padr√£o de repeti√ß√£o no texto, consegue-se facilmente 

quebrar o segredo deste c√≥digo. 

Antes dele, 404 a.C, existem registros de que: 

Lisandro de Esparta, recebeu um mensageiro ensanguentado e 
ferido, √∫nico sobrevivente de um grupo de cinco que partira da 
P√©rsia  numa  √°rdua  jornada.  O  mensageiro  lhe  entregou  seu 
cintur√£o,  que  Lisandro  enrolou  entorno  de  seu  citale  para 
descobrir  que  o  persa  Farnabazo  estava  planejando  atac√°-lo. 
Gra√ßas ao citale, Lisandro estava preparado para o ataque, e o 
repeliu. [2] 

Este  registo,  relata  sobre  o  primeiro  aparelho  criptogr√°fico  militar,  o  Citale 

Espartano. Este m√©todo se consiste em um bast√£o de madeira, em que se enrola uma 

fita  e  nela  escreve-se  a  mensagem  no  sentido  do  comprimento  do  bast√£o.  Ao 

desenrolar a fita, as letras ficar√£o em uma ordem um tanto quanto confusas e somente 

enrolando a mensagem em um bast√£o de mesmo di√¢metro ser√° poss√≠vel tornar leg√≠vel 

seu conte√∫do. 

Apesar  de  antiga,  mas  amplamente  utilizada  nesta  era  digital,  a  criptografia 

ainda n√£o √© trabalhada nas escolas como um conte√∫do em si e, menos ainda, como 

uma  aplica√ß√£o  pr√°tica  dos  conte√∫dos  abordados  principalmente  no  ensino  m√©dio. 

 
 
 
 
 
 
 
14 

Fazendo uma an√°lise das compet√™ncias e habilidades da cartilha Orienta√ß√µes Para o 

Ensino M√©dio √Årea: Matem√°tica [3]; produzida pela secret√°ria de Educa√ß√£o da Bahia. 

Observamos  que  muitos  dos  conte√∫dos  que  s√£o  sugeridos  no  EIXO  1  - 

LINGUAGEM,  ESTRUTURAS  E  ABSTRA√á√ïES  MATEM√ÅTICAS,  poderiam  ser 

trabalhados  de  uma  maneira  que  realmente  demonstrasse  a  real  relev√¢ncia  dos 

mesmos no cotidiano do estudante. 

Assim,  surge  a  ideia  de  elaborar  uma  proposta  que  apresentasse  o  tema 

Criptografia no contexto disciplinar estudado pelo aluno no seu ensino regular. Como 

em nossas pesquisas, n√£o encontramos ferramentas que trabalhassem este conte√∫do 

de uma maneira mais l√∫dica e que simulasse o que realmente acontece na troca de 

informa√ß√µes  pela  Internet,  decidimos  desenvolver  um  aplicativo  para  ser  utilizado 

justamente com este fim. 1 

Denominado de CodeClass, desenvolvemos um aplicativo, que nasceu com a 

ideia de apresentar aos estudantes como funcionam os sistemas de  criptografia na 

era  digital.  Nele,  al√©m  de  visualizar  a  real necessidade  das  evolu√ß√µes  do  ramo,  os 

usu√°rios poder√£o perceber o que as m√°quinas fazem para codificar e decodificar um 

texto, dando sentido √†s fun√ß√µes e aritm√©tica modular que s√£o aprendidas no decorrer 

das aulas regulares da educa√ß√£o b√°sica.  

Para usu√°rios mais avan√ßados, que muitas vezes venham a ser discentes ou 

formados em matem√°tica, este aplicativo poder√° ilustrar como alguns teoremas mais 

avan√ßados da aritm√©tica modular s√£o computacionalmente aplicados servindo a eles 

tamb√©m como um instrumento de contextualiza√ß√£o.  

Nosso  trabalho  foi  dividido  em  algumas  etapas  que  serviram  para  nortear  o 

nosso  desenvolvimento.  Incialmente,  no  Cap√≠tulo  1  foi  realizado  um  levantamento 

te√≥rico  do  que  √©  necess√°rio  para  o  entendimento  da  criptografia,  al√©m  de  diversas 

t√©cnicas  criptogr√°ficas,  para  que  pud√©ssemos  selecionar  aquelas  que  mais  se 

adequassem ao ensino b√°sico. 

O Cap√≠tulo 2, ir√° tratar de teoria matem√°tica para a compreens√£o da criptografia 

linear, RSA e o processo de codifica√ß√£o e decodifica√ß√£o de uma mensagem. 

1 Os m√©todos e t√©cnicas utilizadas para a cria√ß√£o do aplicativo vai ser melhor explicada no Cap√≠tulo 2. 

 
                                                           
15 

Para  tratar  da  criptografia  em  si,  escolhemos  dois  sistemas.  O  primeiro  √©  a 

criptografia linear, ele ser√° utilizado para servir de porta de entrada para os demais 

m√©todos,  pois pode  ser facilmente  explorada  manualmente,  sem a  necessidade de 

computadores ou calculadoras mais avan√ßadas. No Cap√≠tulo 3, iremos definir como 

este m√©todo se desenvolve.  

A segunda t√©cnica criptogr√°fica que decidimos implementar, foi o M√©todo RSA, 

que  tamb√©m  ser√°  apresentada  e  discutida  no  Cap√≠tulo  3.  A  saber,  o  RSA  √©  uma 

t√©cnica utilizada mundialmente na Internet e n√£o envolve algo que seja extremamente 

complexo de se explanar.  

Ambos  os  sistemas  foram  programados  para  ser  utilizado  no  aplicativo 

CodeClass,  que  foi  desenvolvido  neste  trabalho.  Este  aplicativo  foi  constru√≠do  por 

meio da plataforma gratuita de programa√ß√£o em bloco MIT App Inventor II para ser 

utilizado em sistemas Android. 

Ao  final,  ser√°  apresentado  ainda  no  Cap√≠tulo  3,  como  foi  realizada  a  oficina 

interativa que buscou, al√©m de testar as funcionalidades do aplicativo, apresentar os 

principais conceitos da criptografia e a necessidade da sua evolu√ß√£o. 

 Com isso, pudemos avaliar se a proposta seria realmente relevante para os 

estudantes  e,  assim,  podermos  ir  adaptando  tanto  o  CodeClass,  como  tamb√©m  as 

nossas sugest√µes, para serem cada vez mais efetivas no √¢mbito da educa√ß√£o b√°sica 

e que possam vir a fundamentar a continua√ß√£o deste trabalho sob outras perspectivas 

nas considera√ß√µes finais.   

. 

 
 
 
 
  
 
 
 
 
16 

2.   REFER√äNCIAL TE√ìRICO 

Para um  bom entendimento de  tudo  que  ser√°  exposto  neste trabalho, faz-se 

necess√°rio  a  compreens√£o  de  alguns  conceitos  que  v√£o  al√©m  da  Base  Nacional 

Comum Curricular (BNCC) [4]. Para tanto, este cap√≠tulo discutir√°: Algoritmo da divis√£o; 

Divisibilidade; MDC e o Algoritmo de Euclides, N√∫meros primos, Fun√ß√µes Aritm√©ticas 

a  Fun√ß√£o  œï  de  Euler, Congru√™ncias,  Equa√ß√µes  Diofantinas,  A  Interface  do  Sistema 
MIT App Inventor II. 

2.1 Algoritmo da Divis√£o 

Iremos apresentar agora, um dos algoritmos que mais encantam na Aritm√©tica 

dos Inteiros: o Algoritmo da divis√£o de Euclides. Este algoritmo que, segundo Santos, 

j√° configurava registros de sua apari√ß√£o no livro VII dos Elementos de Euclides, escrito 

por volta de 300a.C [5]. Iremos partir do princ√≠pio que o conhecimento das opera√ß√µes 

elementares, bem  como  suas principais propriedades e  resultados  do  conjunto  dos 

n√∫meros inteiros j√° s√£o de pr√©vio conhecimento de quem aprecia este trabalho.  

Teorema  1  (Algoritmo  da  Divis√£o).  Sejam  ùí∂ e ùëè,  com  ùí∂ > b  dois  n√∫meros 

inteiros com b ‚â† 0. Existem dois √∫nicos n√∫meros inteiros q e r  tais que 

ùëé = ùëè. ùëû + ùëü, com 0 ‚â§ ùëü < |ùëè|. 

Demonstra√ß√£o. Vamos considerar o conjunto 

ùëÜ  = {ùëé  ‚àí  ùëè. ùëû;  ùëû  ‚àà  ‚Ñ§}   ‚à©   (‚Ñï  ‚à™   {0}) 

Devemos mostrar, al√©m da exist√™ncia de ùëû ùëí ùëü, a unidade dos mesmos. De fato, 

temos  que  ùëé  > ùëè  implica  em  ‚àíùëè  >   ‚àíùëé.  Como ‚Ñï  √©  ilimitado,  existe  n ‚àà  ‚Ñï  tal  que 

ùëõ. (‚àíùëè) >   ‚àíùëé, portanto ùëÜ √© n√£o vazio e, al√©m disso,  ùëé ‚àí ùëõ. ùëè  > 0 o que mostra que ùëÜ 

√© limitado inferiormente pelo 0. Deste modo, o Princ√≠pio da Boa Ordena√ß√£o garante 

que ùëÜ tem um menor elemento que denotaremos por  ùëü. Tomemos ùëü = ùëé ‚àí ùëè. ùëû  ‚â• 0. 

Resta mostrar que ùëü < |ùëè|.  

Suponha   por  absurdo,  que    ùëü ‚â•  |ùëè|    ent√£o,   existe   ùë† ‚àà ‚Ñï  ‚à™ {0}   tal que  

 
 
 
 
 
17 

 ùëü = |ùëè| + ùë†  o que implica ùë† = ùëü ‚àí |ùëè| que √© uma contradi√ß√£o, visto que esta igualdade 

mostra que ùë†  ‚àà ùëÜ e ùë†  < ùëü que √© o menor elemento de ùëÜ. Absurdo. Portanto ùëü < |ùëè|.  

Para a unidade, suponhamos que existam tamb√©m, ùëûÀä e  ùëüÀä   pertencentes a ‚Ñ§ 

tais que     ùëé = ùëè. ùëû + ùëü = ùëè. ùëûÀä + ùëüÀä      onde 0  ‚â§ ùëü < |ùëè| e 0 ‚â§ ùëüÀä < |ùëè|.     Observe que  

‚àí|ùëè| < ‚àíùëü ‚â§ 0 e 0 ‚â§ ùëüÀä < |ùëè|, somando estas √∫ltimas desigualdades obtemos 

‚àí|ùëè| < ùëüÀä ‚àí ùëü  < |ùëè| 

|ùëüÀä ‚àí ùëü| < |ùëè| 

Por   outro   lado    ùëè. ùëû + ùëü = ùëè. ùëûÀä + ùëüÀä     implica     que    ùëè. (ùëû ‚àí ùëûÀä) = ùëüÀä ‚àí ùëü, da√≠ 

 |ùëè|. |ùëû ‚àí ùëûÀä| = |ùëüÀä ‚àí ùëü|. Unificando as express√µes, teremos 

|ùëè|. |ùëû ‚àí ùëûÀä| = |ùëüÀä ‚àí ùëü| < |ùëè| 

mas isto s√≥ faz sentido se ùëû = ùëûÀä e ùëü = ùëüÀä. O que prova a unidade de ùëû e ùëü.  

Apesar de nos chamar a aten√ß√£o o fato de ùëû e ùëü serem √∫nicos, este n√£o √© um 

algoritmo  muito  eficiente  para  fazermos  divis√µes.  Afinal,  ter√≠amos  que  testar  os 

quocientes um a um a fim de encontrar aquele que permitisse a sobra de um resto 

menor  que  |ùëè|.  Por√©m  √©  dele  que  surge  a  defini√ß√£o  de  congru√™ncia  que  ser√°  de 

extrema import√¢ncia em nossos estudos. 

‚àé 

2.2 Divisibilidade 

Defini√ß√£o 1. Sejam  ùëé e ùëè  inteiros, dizemos que  ùëé  divide ùëè,  denotando por  

 ùëé | ùëè, se existir um inteiro ùëê tal que ùëè = ùëé. ùëê. 

Se ùëé n√£o divide ùëè escrevemos ùëé  ‚à§ ùëè.  

Por exemplo, podemos dizer que 2 | 10, pois 10  =  2.5 e que 3  ‚à§  10 visto que 

3 n√£o √© um fator de 10. 

N√£o iremos citar aqui as propriedades que est√° opera√ß√£o possui, podendo ser 

consultada no livro do Pl√≠nio em [5]. 

 
 
 
 
 
 
 
 
18 

2.3 MDC e o Algoritmo de Euclides 

Uma das principais partes de um sistema criptogr√°fico √© determinar as chaves 

que codificam e decodificam uma mensagem. Para que entendamos um dos m√©todos 

que ser√£o apresentados no pr√≥ximo cap√≠tulo, precisamos compreender a forma como 

conseguimos determinar o MDC de um n√∫mero. Veremos nesta se√ß√£o que isso ser√° 

feito de maneira mais eficiente quando utilizando o Algoritmo de Euclides.  

Defini√ß√£o 2. O m√°ximo divisor comum de dois inteiros ùëé e ùëè (ùëé ou ùëè n√£o nulo), 

√© o maior n√∫mero inteiro que divide ùëé e ùëè. Denotaremos por ùëöùëëùëê(ùëé, ùëè) este inteiro. 

Teorema 2. Seja  ùëë  =  ùëöùëëùëê(ùëé, ùëè), ent√£o  existem  inteiros   ùëü e ùë†  tais  que  

 ùëë  =  ùëü. ùëé  +  ùë†. ùëè. 

Demonstra√ß√£o. Esta demonstra√ß√£o encontra-se no livro do Coutinho [1] p√°ginas 22 e 

23.  

Proposi√ß√£o 1. Se ùëê > 0 e ùëé e ùëè s√£o divis√≠veis por ùëê, ent√£o 

ùëöùëëùëê (

ùëé
ùëê

,

ùëè
ùëë

) =

1
ùëê

ùëöùëëùëê(ùëé, ùëè) 

Demonstra√ß√£o:  Por hip√≥tese,  como  a e  b  s√£o  divis√≠veis  por  c,  temos  que 

a

c

  e 

inteiros.  

b

c

  s√£o 

Para  provarmos  este  resultado,  iremos  utilizar  o  seguinte  resultado  que  consta 

demonstrado na p√°gina 6 do livro Introdu√ß√£o √† Teoria dos N√∫meros  [5], que diz: 

Para todo inteiro  ùë°, ùëöùëëùëê(ùë°ùëé, ùë°ùëè) = ùë°. ùëöùëëùëê(ùëé, ùëè) 

Assim, basta fazermos ‚Äúùëé‚Äù=

ùëé

ùëê

  e ‚Äúùëè‚Äù=

ùëè

ùëê

 e tomarmos ùë° =

1
. 

ùëê

‚àé 

 
 
 
 
 
 
 
 
  
 
 
19 

Teorema 3. Se ùëé e ùëè s√£o inteiros e ùëé = ùëû. ùëè + ùëü,  onde ùëû e ùëü s√£o inteiros, ent√£o 

ùëöùëëùëê(ùëé, ùëè) = ùëöùëëùëê(ùëè, ùëü). 

Demonstra√ß√£o.  Observe que todo divisor comum de ùëè e ùëü √© um divisor comum de ùëé.  

E, caso se isolarmos ùëé ‚àí ùëû. ùëè,  podemos observar que  todo  divisor  comum de  ùëé e ùëè 

√© tamb√©m divisor comum  de ùëü. Portando o conjunto dos divisores  comuns  de  ùëé e ùëè 

√©   igual   ao   conjunto   dos   divisores   comuns   de  ùëè   e  ùëü,   o   que   garante  

 ùëöùëëùëê(ùëé, ùëè) = ùëöùëëùëê(ùëè, ùëü).  

‚àé 

Agora  iremos  tratar  do  Algoritmo  de  Euclides  uma  importante  ferramenta 

quando necessitamos determinar o ùëÄùê∑ùê∂  de dois n√∫meros. Para que a demonstra√ß√£o 

n√£o  fique  t√£o  densa,  vamos  desenvolver  antes,  um  exemplo  num√©rico,  para  que  o 

leitor possa acompanhar as etapas da prova. 

       Queremos determinar o ùëöùëëùëê(1326,1001), para isso vamos utilizar o algoritmo da 

divis√£o para determinar o resto de 1326 por 1001, em seguida iremos dividir 1001 pelo 

resto encontrado na primeira itera√ß√£o e assim sucessivamente at√© obtermos resto 0. 

1326 = 1.1001 + 325 

1001 = 3.325 + 26 

325 = 12.26 + 13 

26 = 2.13 + 0 

A √∫ltima linha nos indica que ùëöùëëùëê(26,13) = 13, pois 13|26. Se utilizarmos o Teorema 

3, teremos ent√£o que  

ùëöùëëùëê(1326,1001) = ùëöùëëùëê(1001,325) = ùëöùëëùëê(325,26) = ùëöùëëùëê(26,13) = 13. 

Teorema  4  (O  Algoritmo  de  Euclides)  Sejam  ùëü0 = ùëé  e  ùëü1 = ùëè  inteiros  n√£o-
negativos com ùëè ‚â† 0. Se o algoritmo da divis√£o for aplicado sucessivamente para se 
obter 

ùëüùëó = ùëûùëó+1. ùëüùëó+1 + ùëüùëó+2,   0 ‚â§ ùëüùëó+2 < ùëüùëó+1 

Para ùëó = 0,1,2, ‚Ä¶ , ùëõ ‚àí 1 e ùëüùëõ+1 = 0 ent√£o ùëöùëëùëê(ùëé, ùëè) = ùëüùëõ, o √∫ltimo resto n√£o-nulo. 

Demonstra√ß√£o. Vamos aplicar o algoritmo da divis√£o, para dividir ùëü0 = ùëé  por ùëü1 = ùëè 

 
 
 
 
20 

ùëü0 = ùëû1. ùëü1 + ùëü2 

dividindo ùëü1 por ùëü2, e assim por diante quantas vezes foram necess√°rias, obtemos a 
sequ√™ncia de equa√ß√µes: 

ùëü0 = ùëû1. ùëü1 + ùëü2        0 < ùëü2 < ùëü1 

ùëü1 = ùëû2. ùëü2 + ùëü3        0 < ùëü3 < ùëü2 

ùëü0 = ùëû3. ùëü3 + ùëü4        0 < ùëü4 < ùëü3 

‚ãÆ 

ùëüùëõ‚àí2 = ùëûùëõ‚àí1. ùëüùëõ‚àí1 + ùëüùëõ          0 < ùëüùëõ < ùëüùëõ‚àí1 

ùëüùëõ‚àí1 = ùëûùëõ. ùëüùëõ + 0 

finalmente, aplicando o Teorema 3 nas equa√ß√µes acima conclu√≠mos que  

ùëüùëõ = ùëöùëëùëê(ùëüùëõ, ùëüùëõ‚àí1) = ùëöùëëùëê(ùëüùëõ‚àí1, ùëüùëõ‚àí2) = ‚ãØ = ùëöùëëùëê(ùëü1, ùëü2) = ùëöùëëùëê(ùëü0, ùëü1) = ùëöùëëùëê(ùëé, ùëè) 

‚àé 

2.4 N√∫meros Primos 

Defini√ß√£o  3.  Um  n√∫mero  inteiro  ùëõ > 1  √©  primo,  se  possui  somente  dois 

divisores positivos  ùëõ e 1. Se ùëõ > 1 n√£o √© primo, dizemos que ùëõ √© composto. 

O  teorema  a  seguir  foi  proposto  e  demonstrado  por  Gauss  em  1976.  Ele  √© 
fundamental para o funcionamento do Sistema RSA, bem como garanti que n√£o pode 
existir uma duplica√ß√£o de chaves neste sistema. 

Teorema 5 (Teorema Fundamental da Aritm√©tica). Todo inteiro maior do que 
1 pode ser representado de maneira √∫nica (a menos de ordem) como um produto de 
fatores primos. 

Demonstra√ß√£o: Se ùëõ  √© primo n√£o h√° nada a ser demonstrado. Suponhamos que  ùëõ 
seja um n√∫mero composto. Seja ùëù1 > 1 o menor dos divisores positivos de ùëõ. Observe 
que ùëù1 √© primo, pois caso contr√°rio existir√° um ùëùùëñ < ùëù1 tal que ùëùùëñ|ùëõ. Assim, podemos 
escrever ùëõ como sendo o produto de ùëù1. ùëõ1. 

Se ùëõ1 for primo, a prova est√° completa. Caso contr√°rio, tomamos ùëù2 como o 

menor o menor fator de ùëõ1. Assim, ùëù2 ser√° primo e podemos escrever ùëõ = ùëù1. ùëù2. ùëõ2. 

 
 
 
 
21 

Repetindo  esse  processo,  obtemos  uma  sequ√™ncia  finita  e  decrescente  de 
inteiros  positivos  ùëõ1, ùëõ2, ‚Ä¶ , ùëõùëü.  Como  os  primos  na  sequ√™ncia  ùëù1, ùëù2, ‚Ä¶ , ùëùùëò  n√£o  s√£o 
necessariamente distintos, ùëõ ser√° da forma 

ùëõ = ùëù1

ùõº1. ùëù2

ùõº2 ‚Ä¶ ùëùùëò

ùõºùëò 

Para  mostrarmos  que  essa  fatora√ß√£o  √©  √∫nica,  aplicamos  a  indu√ß√£o  sobre  ùëõ. 
Para  ùëõ = 2  √©  trivial  que  a  afirma√ß√£o  √©  verdadeira.  Suponha  que  ela  se  mantenha 
verdadeira para todos os inteiros maiores do que 1 e menores do que ùëõ. Mostremos 
que ela tamb√©m √© v√°lida para ùëõ.  

Suponha que ùëõ √© composto e tenha duas fatora√ß√µes, ou seja, 

ùëõ = ùëù1. ùëù2 ‚Ä¶ ùëùùë† = ùëû1. ùëû2 ‚Ä¶ ùëûùëü 

Iremos mostrar que ùëü = ùë† e que cada ùëùùëñ √© igual a algum ùëûùëñ. Como ùëù1 divide o produto 

ùëû1ùëû2 ‚Ä¶ ùëûùëü ent√£o ele deve dividir pelo menos um dos fatores ùëûùëó.  

Suponha sem perda de generalidade que ùëù1|ùëû1 e como ambos s√£o primos, podemos 

concluir que ùëù1 = ùëû1. Assim, 1 <

ùëõ
ùëù1

= ùëù2. ùëù3 ‚Ä¶ ùëùùë† = ùëû2. ùëû3 ‚Ä¶ ùëûùëü < ùëõ que por hip√≥tese de 

indu√ß√£o possui fatora√ß√£o √∫nica e, portanto ùëü = ùë† e, a menos de ordem, as fatora√ß√µes 

ùëù1. ùëù2 ‚Ä¶ ùëùùë† e ùëû1. ùëû2 ‚Ä¶ ùëûùëü s√£o iguais. 

‚àé 

2.5 Fun√ß√µes Aritm√©ticas a Fun√ß√£o ùùì de Euler 

Denominamos de fun√ß√£o aritm√©tica, uma fun√ß√£o definida para todos os inteiros 

positivos. No campo da Teoria dos N√∫meros, existem diversas fun√ß√µes aritm√©ticas, 

por√©m  nessa  se√ß√£o  trataremos  apenas  da  Fun√ß√£o  ùúô  de  Euler,  que  faz  parte  da 

mec√¢nica do algoritmo RSA que ser√° tratado no cap√≠tulo seguinte. 

Defini√ß√£o 4. Se ùëõ √© um inteiro positivo, a fun√ß√£o ùúô de Euler, denotada por ùúô(ùëõ), 

√© definida como sendo o n√∫mero de inteiros positivos menores ou iguais a ùëõ, que s√£o 

relativamente primos com ùëõ. 

Por exemplo, podemos verificar que ùúô(8) = 4, pois o conjunto dos n√∫meros ùë° 

de  1  a  8  tais  que  o  ùëöùëëùëê(8, ùë°) = 1  se  restringe  a  1,3,5,7,  ou  seja  possui  apenas  4 

elementos. 

 
 
 
22 

Uma observa√ß√£o interessante, √© que se ùëù for um n√∫mero primo tal que ùëù ‚â• 2 

ent√£o  ùúô(ùëù) = ùëù ‚àí 1,  afinal  nenhum  dos  n√∫meros  menores  que  ùëù  possui  um  divisor 

comum com ele.  

Teorema 6. A fun√ß√£o ùúô de Euler √© multiplicativa, isto √©, ùúô(ùëö. ùëõ) = ùúô(ùëö). ùúô(ùëõ) 

para ùëöùëëùëê(ùëö, ùëõ) = 1. 

Demonstra√ß√£o: Iremos omitir aqui a demonstra√ß√£o deste teorema, mas ela encontra-

se no livro do Abramo Hefez [6] pg. 199. 

Corol√°rio 1. Se ùëù e ùëû s√£o primos, ent√£o ùúô(ùëù. ùëû) = (ùëù ‚àí 1). (ùëû ‚àí 1) 

Demonstra√ß√£o: Pelo teorema anterior, como ùúô(ùëù. ùëû) = ùúô(ùëù). ùúô(ùëû) e do fato de 

ùëù e ùëû serem primos, temos que ùúô(ùëù) = ùëù ‚àí 1 e ùúô(ùëû) = ùëû ‚àí 1. 

2.6 Congru√™ncias 

‚àé 

Dizemos que dois n√∫meros ùëé e ùëè s√£o congruentes m√≥dulo ùëõ se os restos de 

sua divis√£o euclidiana por ùëõ s√£o iguais, escrevendo 

ùëé  ‚â°  ùëè ùëöùëúùëë ùëõ 

Como exemplo, podemos observar que 23  ‚â°  5 ùëöùëúùëë 18, pois sabemos que ao 

dividirmos  23  por  18  obtemos  quociente  1  e  resto  5.  Uma  outra  abordagem 

interessante para essa defini√ß√£o, √© dizermos que  ùëõ | (ùëé ‚àí ùëè)  ou equivalentemente  

ùëé ‚àí ùëè = ùëõ. ùëò para algum ùëò ‚àà ‚Ñ§.  

Alguns  resultados  a  respeito  das  opera√ß√µes  com  congru√™ncias  podem  ser 

encontrados  no  livro  do  Jos√©  Pl√≠nio  [5].  Nos  ateremos  aqui,  nos  teoremas  e 

proposi√ß√µes fundamentais para compreens√£o da criptografia. 

Proposi√ß√£o 4. Se ùëé, ùëè, ùëò e ùëõ s√£o inteiros com ùëò > 0 e ùëé ‚â° ùëè ùëöùëúùëë ùëõ, ent√£o 

ùëéùëò ‚â° ùëèùëò ùëöùëúùëë ùëõ.  

 Demonstra√ß√£o: Por hip√≥tese temos que ùëé ‚àí ùëè = ùëõ. ùëô, se utilizarmos a identidade 

ùëéùëò ‚àí ùëèùëò = (ùëé ‚àí ùëè). (ùëéùëò‚àí1 + ùëéùëò‚àí2ùëè + ùëéùëò‚àí3ùëè2 + ‚ãØ + ùëéùëèùëò‚àí2 + ùëèùëò‚àí1) 

e chamando ùëéùëò‚àí1 + ùëéùëò‚àí2ùëè + ùëéùëò‚àí3ùëè2 + ‚ãØ + ùëéùëèùëò‚àí2 + ùëèùëò‚àí1  de ùëö, teremos 

ùëéùëò ‚àí ùëèùëò = (ùëé ‚àí ùëè). ùëö = ùëõ. ùëô. ùëö = ùëõ. (ùëô. ùëö) 

o que implica em ùëéùëò ‚â° ùëèùëò ùëöùëúùëë ùëõ. 

 
 
23 

‚àé 

Teorema 6 (Pequeno Teorema de Fermat).   Se   ùëù   √©   primo,  ent√£o  

 ùëéùëù ‚â° ùëé ùëöùëúùëë ùëù, para todo inteiro ùëé. 

Demonstra√ß√£o:  Iremos  fazer  a  prova  deste  resultado  para  ùëé natural  utilizando  o 

princ√≠pio de indu√ß√£o em ùëé. 

Note que para ùëé = 1 o resultado √© trivial, visto que 1ùëù ‚â° 1 ùëöùëúùëë ùëù. 

Suponha que exista um ùëé ‚â• 1 tal que ùëéùëù ‚â° ùëé ùëöùëúùëë ùëù. Mostraremos a validez de 

proposi√ß√£o para ùëé + 1. 

Note que ao utilizarmos a expans√£o por Bin√¥mio de Newton, temos 

(ùëé + 1)ùëù = ùëéùëù + (

ùëù

ùëù ‚àí 1) ùëéùëù‚àí1 + ‚ãØ + (

ùëù
ùëñ

) ùëéùëñ + ‚ãØ + (

ùëù
1

) ùëé + 1                           (1) 

Aplicando congru√™ncias m√≥dulo ùëù em cada parcela observamos que a primeira 

delas, √© congruente a ùëé ùëöùëúùëë ùëù pela hip√≥tese de indu√ß√£o. As demais s√£o fatores de ùëù 

e, portanto, para 1 ‚â§ ùëñ ‚â§ ùëù ‚àí 1 teremos 

(

ùëù
ùëñ

) ‚â° 0 ùëöùëúùëë ùëù 

Logo, (ùëé + 1)ùëù ‚â° ùëéùëù + 1 ‚â° ùëé + 1 ùëöùëúùëë ùëù o que pelo princ√≠pio de indu√ß√£o, prova 

nosso teorema para o caso de ùëé natural. 

Note que se ùëé for um n√∫mero negativo, as congru√™ncias acima teriam o mesmo 

valor, o que torna o resultado indiferente para ùëé inteiro.  

‚àé 

Teorema 7 (Teorema de Euler). Se ùëö √© um inteiro positivo e ùëé um inteiro tal 

que ùëöùëëùëê(ùëé, ùëö) = 1, ent√£o 

ùëéùúô(ùëö) ‚â° 1 ùëöùëúùëë ùëö 

Demonstra√ß√£o: A demonstra√ß√£o deste teorema se encontra nas p√°ginas 49 e 

50 do livro do Martinez [7]. 

Teorema 8 (Teorema de Wilson): Se ùëù √© primo, ent√£o (ùëù ‚àí 1)! ‚â° ‚àí1 ùëöùëúùëë ùëù. 

Demonstra√ß√£o:   Inicialmente   observe   que   para   ùëù = 2,   temos    que 

(2 ‚àí 1)! = 1! = 1 ‚â° ‚àí1 ùëöùëúùëë 2  que √© v√°lido. Iremos afirmar, mas sem demonstrar, que 

a  congru√™ncia  ùëé. ùë• ‚â° 1 ùëöùëúùëë ùëù,  possui  uma  √∫nica  solu√ß√£o  para  todo  ùëé  no  conjunto 

 
 
 
24 

{1,2,3, . . . , ùëù ‚àí 1}. A prova deste resultado encontra-se demonstrado no livro do Jose 

Pl√≠nio de Oliveira Santos em [5] p√°ginas 37 e 38. 

Neste conjunto, note que somente  1 e ùëù ‚àí 1 s√£o eles mesmos o seu pr√≥prio 

inverso m√≥dulo ùëù. Restando ent√£o os n√∫meros 2,3,4, . . . , ùëù ‚àí 2; (ùëù ‚àí 3) ‚àín√∫meros, que 
podem  ser  agrupados  cada  um  com  seu  inverso  m√≥dulo  ùëù,  formando  ùëù‚àí3
2

congru√™ncias.  Por  exemplo,  digamos  que  2  e  (ùëù ‚àí ùëñ)  sejam  inversos  um  do  outro, 

podemos ent√£o formar a congru√™ncia 

2. (ùëù ‚àí ùëñ) ‚â° 1 ùëöùëúùëë ùëù 

Assim, ao multiplicarmos todas estas congru√™ncias, obteremos: 

2.3.4. ‚Ä¶ . (ùëù ‚àí 2) ‚â° 1 ùëöùëúùëë ùëù 

multiplicando esta √∫ltima por (ùëù ‚àí 1) teremos 

2.3.4. ‚Ä¶ . (ùëù ‚àí 2). (ùëù ‚àí 1) ‚â° ùëù ‚àí 1 ‚â° ‚àí1 ùëöùëúùëë ùëù 

como o lado esquerdo desta igualdade √© (ùëù ‚àí 1)!, temos ent√£o que  

o que prova o resultado. 

(ùëù ‚àí 1)! ‚â° 1 ùëöùëúùëë ùëù 

‚àé 

2.7 Equa√ß√µes Diofantinas 

Defini√ß√£o  5.  Uma  equa√ß√£o  da  ùëé. ùë• + ùëè. ùë¶ = ùëê,  onde  ùëé, ùëè e  ùëê  s√£o  inteiros  √© 

chamada Equa√ß√£o Diofantina Linear.  

Iremos analisar esta equa√ß√£o, pois para determinar o inverso de um n√∫mero ùëé 

m√≥dulo ùëõ, devemos determinar qual n√∫mero ùëè satisfaz a condi√ß√£o 

ùëé. ùëè ‚â° 1 ùëöùëúùëë ùëõ 

Ora, mas isto √© o mesmo que determinar ùëé. ùëè ‚àí 1 = ùëõ. ùëò e da√≠  

que √© uma Equa√ß√£o Diofantina com ùëê = 1. 

ùëé. ùëè + ùëõ. (‚àíùëò) = 1 

 
  
 
 
 
25 

Teorema 9.  Sejam ùëé  e  ùëè  inteiros  e ùëë = ùëöùëëùëê(ùëé, ùëè).  Se ùëë ‚à§ ùëê  ent√£o  a  equa√ß√£o 

ùëé. ùë• + ùëè. ùë¶ = ùëê n√£o possui nenhuma solu√ß√£o inteira. ùëÜùëí ùëë|ùëê ela possui infinitas solu√ß√µes 

e se ùë• = ùë•0 e ùë¶ = ùë¶0 √© uma solu√ß√£o particular, ent√£o todas as solu√ß√µes s√£o dadas por 

ùë• = ùë•0 +

ùë¶ = ùë¶0 ‚àí

ùëè
ùëë
ùëé
ùëë

. ùëò 

. ùëò 

onde ùëò √© um inteiro. 

Demonstra√ß√£o: Come√ßamos observando que se ùëë ‚à§ ùëê, a equa√ß√£o n√£o possui solu√ß√£o, 

afinal como ùëë √© um divisor comum de ùëé e ùëè, obviamente ele deveria dividir ùëê.  

Suponhamos que ùëë|ùëê pelo Teorema 2, temos que existem ùëö0 e ùëõ0 tais que  

      ùëé. ùëö0 + ùëè. ùëõ0 = ùëë                       

    (2). 

Da hip√≥tese ùëë|ùëê, existe um ùëò ‚àà ‚Ñ§, tal que ùëê = ùëë. ùëò. Multiplicando a equa√ß√£o (8) por ùëò 

obtemos    ùëé. (ùëö0. ùëò) + ùëè. (ùëõ0. ùëò) = ùëë. ùëò = ùëê,    o  que     nos    leva    a    conclus√£o    que   

ùë•0 = ùëö0. ùëò e ùë¶0 = ùëõ0. ùëò,   √© uma   solu√ß√£o   de   ùëé. ùë• + ùëè. ùë• = ùëê. 

Vamos verificar agora que o par (ùë•, ùë¶) em que: 

ùë• = ùë•0 +

ùë¶ = ùë¶0 ‚àí

ùëè
ùëë
ùëé
ùëë

. ùëò 

. ùëò 

s√£o tamb√©m solu√ß√µes da equa√ß√£o. 

De fato, temos: 

ùëé. ùë• + ùëè. ùë¶ = ùëé. (ùë•0 +

ùëè
ùëë

. ùëò) + ùëè. (ùë¶0 ‚àí

ùëé
ùëë

. ùëò) 

= ùëé. ùë•0 +

ùëé. ùëè
ùëë

. ùëò + ùëè. ùë¶0 ‚àí

ùëé. ùëè
ùëë

. ùëò 

que cancelando obtemos: 

= ùëé. ùë•0 + ùëè. ùë¶0 = ùëê. 

Dessa forma, conclu√≠mos que a partir de uma solu√ß√£o particular da Equa√ß√£o 

Diofantina, podemos gerar outras infinitas variando pois, somente o par√¢metro ùëò. 

Mostraremos agora que toda solu√ß√£o da equa√ß√£o ùëé. ùë• + ùëè. ùë¶ = ùëê √© da forma: 

ùë• = ùë•0 +

ùëè
ùëë

. ùëò 

 
 
 
 
26 

ùëé
ùëë
Suponha que os pares (ùë•, ùë¶) e  (ùë•0, ùë¶0) sejam solu√ß√µes da Equa√ß√£o Diofantina. 

ùë¶ = ùë¶0 ‚àí

. ùëò 

Assim,  

e, portanto,  

ùëé. ùë• + ùëè. ùë¶ ‚àí ùëé. ùë•0 ‚àí ùëè. ùë¶0 = ùëé. (ùë• ‚àí ùë•0) + ùëè. (ùë¶ ‚àí ùë¶0) = 0 

ùëé. (ùë• ‚àí ùë•0) = ùëè. (ùë¶0 ‚àí ùë¶) 

Como ùëöùëëùëê(ùëé, ùëè) = ùëë, temos pelo Corol√°rio 1 que ùëöùëëùëê (

ùëé

ùëë

,

ùëè

ùëë

) = 1. Portanto, dividindo 

os dois membros da √∫ltima igualdade por ùëë, teremos: 

ùëé

. (ùë• ‚àí ùë•0) =

ùëè

ùëë

. (ùë¶0 ‚àí ùë¶)                                            (3) 

|(ùë• ‚àí ùë•0) portanto existe ùëò ‚àà ‚Ñ§ tal que: ùë• ‚àí ùë•0 = ùëò.

ùëè

ùëë

, 

ùëë
) = 1, ùëè
ùëë

Todavia,  como  ùëöùëëùëê (

ùëé

ùëë

,

ùëè

ùëë

ou seja ùë• = ùë•0 + ùëò.

ùëè

ùëë

. 

Substituindo a solu√ß√£o encontrada na equa√ß√£o (9) teremos 

ùëé
ùëë

. (ùë•0 + ùëò.

ùëè
ùëë

‚àí ùë•0) =

ùëè
ùëë

. ùë¶ =

ùëè
ùëë

. ùë¶0 ‚àí

ùëè
ùëë

. ùë¶ 

. ùë¶0 ‚àí

ùëè
ùëë
ùëé. ùëè
ùëë2 . ùëò 

Como quer√≠amos demonstrar. 

ùë¶ = ùë¶0 ‚àí

ùëé
ùëë

. ùëò. 

‚àé 

Teorema 10 (Teorema Chin√™s do Resto).    Se      ùëöùëëùëê(ùëé1, ùëöùëñ) = 1, 

 ùëöùëëùëê(ùëöùëñ, ùëöùëó) = 1   para ùëñ ‚â† ùëó e ùëêùëñ inteiro, ent√£o o sistema 

ùëé1. ùë• ‚â° ùëê1 ùëöùëúùëë ùëö1
ùëé2. ùë• ‚â° ùëê2 ùëöùëúùëë ùëö2
ùëé3. ùë• ‚â° ùëê3 ùëöùëúùëë ùëö3
‚ãÆ
ùëéùëü. ùë• ‚â° ùëêùëü ùëöùëúùëë ùëöùëü

possui solu√ß√£o e a solu√ß√£o √© √∫nica m√≥dulo ùëö, onde ùëö = ùëö1. ùëö2 ‚Ä¶ . . ùëöùëü 

Demonstra√ß√£o:  Esta  demonstra√ß√£o  est√°  dispon√≠vel  no  livro  do  Martinez  [7]  nas 

p√°ginas 81 e 82. 

‚àé 

 
 
 
 
27 

2.8 MIT App Inventor 2 

Lan√ßado  em  15  de  dezembro  de  2010,  o  App  Inventor  for  Android  foi  um 

software web,  cuja proposta  era dar a  um usu√°rio  leigo  em  qualquer linguagem  de 

programa√ß√£o,  meios  para  que  o  mesmo  pudesse  desenvolver  um  aplicativo  para 

ambiente  Android.  Para  isso,  o  programador  utiliza  de  blocos  pr√©-definidos, 

encaix√°veis  que  sintetizam  de  maneira  pr√°tica  os  comandos  que  viriam  a  ser 

digitados.  A  interface  do  programa  permite  que  o  utilizador  usando  o  mouse  para 

arrastar e soltar os componentes, comandos e fun√ß√µes, encaixe blocos um no outros 

compondo o c√≥digo fonte do sistema que est√° sendo desenvolvido. 

Esta plataforma foi desenvolvida pela equipe App Inventor Team incorporada 

ao Google, e liderada por Hal Abelson e Mark Friedman. Posteriormente em parceria 

com  o  Massachusetts  Institute  of  Technology  (MIT),  foram  realizadas  melhorias  na 

interface e estabilidade do sistema em 6 de dezembro de 2013, uma nova vers√£o do 

software foi lan√ßada e batizada de MIT App Inventor 2. A atualiza√ß√£o o tornou bastante 

funcional e est√°vel, o que permitiu a cria√ß√£o de aplicativos bem mais completos do 

que  a  primeira  vers√£o  possibilitava.  Atualmente  √©  poss√≠vel  trabalhar  com  bases  de 

dados em nuvem, desenvolver jogos, sistemas de automa√ß√£o comercial, dentre outros 

programas que de certo modo admitem um elevado grau de complexidade.  

Claro  que  esta  proposta  de  programa√ß√£o  pode  limitar  um  pouco  as 

possibilidades de desenvolvimento, visto que seria imposs√≠vel disponibilizar todas as 

combina√ß√µes  de  blocos  poss√≠veis  para  o  usu√°rio,  o  que  na  programa√ß√£o 

convencional, com escrita manual do c√≥digo fonte, o usu√°rio tem a possibilidade de 

programar ao seu bel prazer, sem restri√ß√µes de cria√ß√£o. 

Em  2016,  o  Prof.  Dr.  Eduardo  Alves  do  Valle  Junior,  da  Faculdade  de 

Engenharia  El√©trica  e  de  Computa√ß√£o  da  Universidade  Estadual  de  Campinas 

(Unicamp),  finalizou  um  projeto  de  tradu√ß√£o  do  MIT  App  Inventor  2  para  a  L√≠ngua 

Portuguesa. Isto mobilizou o surgimento de alguns projetos voltados para o incentivo 

da  programa√ß√£o  na  educa√ß√£o  b√°sica,  como  o  Projeto  Computa√ß√£o  na  Escola:  ‚ÄúA 

Iniciativa Computa√ß√£o na Escola √© dedicada a aumentar o ensino de computa√ß√£o no 

 
 
28 

Ensino  Fundamental  e  M√©dio.  ‚ÄúNossa  vis√£o  √©  que  todos  os  alunos  em  todas  as 

escolas devem ter a oportunidade de aprender computa√ß√£o.‚Äù [8] 

O projeto acredita que a computa√ß√£o deve fazer parte do curr√≠culo no Ensino 

Fundamental e M√©dio assim como as demais disciplinas. No site do projeto dispon√≠vel 

em [9], h√° bastante material sobre outros projetos que o mesmo desenvolve, inclusive 

outras plataformas com a mesma finalidade do MIT App. 

2.1.1. A Interface do Sistema 

Para acessar o MIT App Inventor 2 √© necess√°rio acessar o link [10] e ‚Äúlogar‚Äù 

com  uma  ‚ÄúConta  Google‚Äù.  Esse  tipo  de  conta  √©  obrigat√≥ria  para  acessar  as 

funcionalidades de qualquer aparelho celular com o sistema operacional Android. Ao 

acessar a  plataforma,  o  usu√°rio  ir√°  se  deparar  com  uma  tela  de  gerenciamento  de 

projetos como a da Figura 2: 

Figura 2 Tela Inicial MIT App Inventor II 

Fonte: http://ai2.appinventor.mit.edu. Acessado em 08/10/2019 

Na  tela  de  boas  vindas  conforme  a  Figura  2,  o  usu√°rio  pode  gerenciar  seus 

projetos, criar, apagar, copiar, duplicar ou at√© mesmo acompanhar o desenvolvimento, 

quando feito em parceria com outros programadores. Caso n√£o haja nenhum projeto 

em andamento ou conclu√≠do, ser√° apresentada uma lista vazia e nesse caso o usu√°rio 

deve  iniciar  um  novo  projeto  do  zero,  seu  primeiro  projeto.  √â  importante  salvar  os 

projetos com nomes que sejam de f√°cil identifica√ß√£o e/ou a sua vers√£o, caso seja o 

caso. A plataforma n√£o permite a utiliza√ß√£o de caracteres especiais ou espa√ßos em 

 
 
29 

branco  no  nome  do  projeto.  Na  tela  inicial  tamb√©m  √©  poss√≠vel  ajustar  o  idioma  da 

plataforma e acessar o menu de ajuda. 

Ap√≥s criar um projeto e nome√°-lo, o usu√°rio ir√° acessar uma segunda tela, 

agora com todos os elementos necess√°rios para iniciar o processo de cria√ß√£o do 

aplicativo. 

Figura 3 Tela de Designer de Aplicativo do MIT App Inventor II 

1 

2 

3 

4 

Fonte: Imagem trabalhada pelo autor  

A 

tela  de  desenvolvimento,  possui  quatro 

regi√µes  com  diferentes 

funcionalidades.  A  primeira,  indicada  na  Figura  3,  com  o  n√∫mero  1,  √©  o  banco  de 

componentes que podem ser utilizados no App, nele o usu√°rio ter√° acesso a bot√µes, 

caixas  de  texto,  legendas,  caixas  para fotos,  base de dados,  c√¢mera,  entre  outros. 

Basicamente os componentes s√£o os meios pelos quais possibilitam a intera√ß√£o entre 

o  aplicativo  e  quem  o  utiliza.    Em  seguida,  vem  a  Zona  2,  que  o  local  onde  o 

programador pode ajustar os componentes na interface do aplicativo, dispondo-os da 

maneira como ser√° apresentada no projeto final. A Zona 3, √© uma listagem de todos 

os adere√ßos que comp√µe a tela do aplicativo. Isso auxilia na navega√ß√£o de quem est√° 

desenvolvendo um sistema que tenha in√∫meros componentes e, que muitas vezes h√° 

uma  combina√ß√£o  de  componentes,  um  dentro  do  outro.  Finalmente,  na  Zona  4,  √© 

poss√≠vel ajustar algumas configura√ß√µes dos componentes e da tela que est√° sendo 

desenvolvida como renomear um componente, ajustar cores, tamanho dentre outras 

 
 
 
30 

caracter√≠sticas. Na barra superior em verde, pode-se criar outras telas (Screens), pois 

geralmente os aplicativos s√£o formados por um conjunto de telas que interagem umas 

com as outras no decorrer da utiliza√ß√£o e acessar a interface de blocos que o espa√ßo 

onde realmente ocorrer√° a programa√ß√£o do app que est√° sendo desenvolvido.  

Ao  clicar  no  bot√£o  blocos,  o  desenvolvedor  ter√°  acesso  a  interface  ‚ÄúBlocos‚Äù 

onde poder√° realizar a combina√ß√£o dos blocos de c√≥digo a cada componente que √© 

adicionado na tela de designer, novos blocos surgem na tela de blocos, possibilitando 

uma vasta combina√ß√£o entre eles. 

Figura 4 Interface de Programa√ß√£o 

1 

2 

3 

Fonte: Imagem trabalhada pelo autor. 

Podemos dividir esta tela em tr√™s zonas distintas. Na primeira temos acesso 

aos  blocos:  comandos  de  controle,  fun√ß√µes,  conectivos  l√≥gicos  ou  matem√°ticos, 

defini√ß√£o e utiliza√ß√£o de vari√°veis tudo que √© necess√°rio para o implemento de c√≥digos 

como pode ser visto na Figura 4. A zona 2 √© feita a montagem, arrastando-se os blocos 

da Zona 1 os combinando e finalmente a Zona 3 serve para apagar algum c√≥digo, dar 

zoom  e  se  localizar,  pois  ao  encaixas  as  pe√ßas,  muitas  vezes  o  programa  acaba 

ficando  bem  extenso.  Na  mochila  no  canto  superior  direito,  √©  poss√≠vel  guardar 

algumas combina√ß√µes de blocos que foram utilizadas em um ou outro aplicativo e que 

possa ser reaproveitado em alguma outra tela, isso evita ter que ‚Äúreescrever‚Äù todo o 

processo. 

 
 
 
31 

2.2. Divis√£o e a Seguran√ßa de Redes: a Criptografia 

Para iniciarmos, vamos fazer uma an√°lise do sistema criptogr√°fico utilizado por 

J√∫lio  C√©sar,  o  qual  explanamos  na  Introdu√ß√£o  deste  trabalho.  Suponha  que  J√∫lio 

C√©sar assinasse todas as cartas, ent√£o a pessoa saberia ao final que a √∫ltima palavra 

seria seu nome e isto j√° bastaria para desvendar este tipo de permuta√ß√£o.  

√â poss√≠vel melhorar um pouco esta permuta√ß√£o causando algumas dificuldades 

para  desvendar  seu  segredo.  Para  isto  vamos  tomar  por  base  algumas  defini√ß√µes. 

Precisamos  primeiro  considerar  que  o  alfabeto  √©  ordenado  e  transform√°-lo  em 

n√∫meros.  Assim  poderemos  operar  com  os  mesmos,  utilizando  ferramentas 

matem√°ticas.  Considere  a  princ√≠pio  uma  correspond√™ncia  simples  em  que  ùê¥  =  1,

ùêµ  =  2, ùê∂  =  3, ... e, assim, por diante at√© atingirmos ùëç = 26 conforme a Figura 3.1.  

Para ilustrar, na Figura 5 √© apresentado como ser√° o nosso alfabeto, em que iremos 

construir todos os sistemas que ser√£o trabalhados a partir deste ponto. 

Figura 5 Correspond√™ncia da Cifra de C√©sar 

Fonte: O autor 

Feito isso, j√° podemos interpretar cada mensagem como um c√≥digo num√©rico.  

Por exemplo, a palavra CIDADE, seria o n√∫mero 3 9 4 1 4 5. 

A parte interessante de fazer essa atribui√ß√£o √© que cada letra do alfabeto pode 
ser visualizada como uma classe de equival√™ncia em ‚Ñ§26 onde  ùê¥ = 1ÃÖ, ùêµ = 2ÃÖ, ‚Ä¶ , ùëç =
26ÃÖÃÖÃÖÃÖ.  Desse  modo  podemos  representar  a  Cifra  de  C√©sar  pela  transforma√ß√£o  linear 
ùê∏(ùëãÃÖ) = ùëãÃÖ + 3ÃÖ  em  ‚Ñ§26  e,  assim,  ùê∏(ùê¥ÃÖ) = ùê∏(ùëãÃÖ) = 1ÃÖùê¥ + 3ÃÖ =   1ÃÖ + 3ÃÖ = 4ÃÖ = ùê∑  e,  de  modo 
sucessivo ùê∏(ùëçÃÖ) = 26ÃÖÃÖÃÖÃÖ + 3ÃÖ = 29ÃÖÃÖÃÖÃÖ = 3ÃÖ = ùê∂. 

Esse sistema, criado por J√∫lio C√©sar, nos servir√° de base para estudarmos uma 

infinidade  de  outros  sistemas  que  podem  ser  classificados  como  os  Sistemas  de 

Criptografia Linear ou Cifras de Transposi√ß√£o, o qual ser√° apresentado e discutido a 

seguir. 

 
 
 
 
 
 
 
 
 
32 

3.   CRIPTOGRAFIA 

Finalmente chegamos √† parte que delineamos este estudo, a criptografia. Neste 

cap√≠tulo ser√£o abordados alguns m√©todos criptogr√°ficos que surgiram no decorrer dos 

anos, bem como seu funcionamento, os pr√≥s e os contras.  

3.1. Sistema de Criptografia Linear 

Seja A um alfabeto ordenado com L letras. 

Defini√ß√£o  6.  Definimos  como  um  Sistema  de  Criptografia  Linear,  toda 

transforma√ß√£o       ùúé: ‚Ñ§L  ‚Üí ‚Ñ§L      definida    por  ùúé(ùëã) =  ùëé. ùëã  + b    onde    ùëé, ùëè ‚àà ‚Ñ§L     

e  ùëöùëëùëê(ùëé, ùêø)   =  1. Chamaremos tamb√©m ùëé e ùëè de ùëê‚Ñéùëéùë£ùëíùë† ùëëùëú ùë†ùëñùë†ùë°ùëíùëöùëé.  

Note  que  ùúé  √©  uma  bije√ß√£o,  pois  dado  ùëå  =  ùëé. ùëã  +  ùëè  em ‚Ñ§L  existe  ùëã =

ùëé‚àí1. (ùëå ‚àí ùëè),  visto  que  da  forma  que  ùëé  √©  tomado  ele  sempre  admitir√°  inverso 

multiplicativo no ‚Ñ§L. Portanto ùúé √© uma permuta√ß√£o. 

Deste modo, se considerarmos, por exemplo, a permuta√ß√£o 

ùúé(ùëã) = 17ÃÖÃÖÃÖÃÖ2. ùëã + 12ÃÖÃÖÃÖÃÖ 

teremos  o  seguinte  c√≥digo  representado  na  Figura  6,  que  mostra  os  resultados  de 

cada letra (alfabeto) quando aplicada a fun√ß√£o ùúé. 

Figura 6 Permuta√ß√£o segundo ùúé 

Fonte: O autor 

2 Usaremos a nota√ß√£o ùëéÃÖ apenas com o intuito de simplificar a nota√ß√£o de congru√™ncia por detr√°s das 
opera√ß√µes. Por exemplo, ao inv√©s de escrevermos que 27 ‚â° 1 ùëöùëúùëë 26 usaremos somente 1ÃÖ. A partir 
de agora, todas as nossas congru√™ncias ser√£o m√≥dulo 26. 

 
 
 
 
 
 
                                                           
33 

E assim, a palavra J√öLIO C√âSAR cifrada por essa permuta√ß√£o seria codificada 

como ZEHIG KSWCF. Apesar da sensa√ß√£o de que criamos uma verdadeira mistura 

nas correspond√™ncias, esse sistema possui uma falha, pois caso o invasor fa√ßa, por 

exemplo, uma an√°lise de frequ√™ncia da mensagem e descubra quais os caracteres 

mais aparecem, de  modo  a   ter  certeza  de  duas  informa√ß√µes,  como ùúé(ùëç) = ùêΩ   e  

 ùúé(ùê∏) = ùëà, ele poderia ent√£o decodificar a mensagem resolvendo o sistema. 

ùëé. 26ÃÖÃÖÃÖÃÖ + ùëè = 10ÃÖÃÖÃÖÃÖ
{
ùëé. 5ÃÖ + ùëè = 21ÃÖÃÖÃÖÃÖ

Como 26ÃÖÃÖÃÖÃÖ = 0ÃÖ,  este sistema se torna bem simples de resolver, pois ter√≠amos da 

primeira equa√ß√£o que ùëè = 10¬¥  e substituindo o resultado na segunda obter√≠amos  

ùëé. 5ÃÖ = 11ÃÖÃÖÃÖÃÖ 

Resolver  para  quais  valores  de  ùëé,  a  equa√ß√£o  ùëé. 5ÃÖ = 11ÃÖÃÖÃÖÃÖ  √©,  em  sua  ess√™ncia, 
encontrar um ùëé ‚àà ‚Ñ§26 de modo que quando dividirmos ùëé. 5ÃÖ  e 11ÃÖÃÖÃÖÃÖ por 26, obteremos o 
mesmo resto. Podemos ent√£o reescrever o problema como ùëé. 5ÃÖ ‚â° 11ÃÖÃÖÃÖÃÖ ùëöùëúùëë 26 que pode 

ser reescrito como ùëé. 5 ‚àí 11 = 26. ùëò obtendo assim a Equa√ß√£o Diofantina: 

ùëé. 5 + 26. ùëò = 11 

a  qual  resolvendo,  encontramos  ùëé = 23ÃÖÃÖÃÖÃÖ.  Deste  modo,  teremos  ent√£o  que  a 

fun√ß√£o  inversa  ùúé‚àí1(ùëã) = 23ÃÖÃÖÃÖÃÖ. ùëã + 10ÃÖÃÖÃÖÃÖ  ir√°  decodificar  a  mensagem.  V√™-se  ent√£o  que  o 

sistema pode ser bastante fr√°gil, pois conhecidas 2 permuta√ß√µes sempre poderemos 

descobrir as chaves ùëé e ùëè. 

3.2. Trabalhando com Blocos 

Como vimos anteriormente, codificar uma √∫nica letra torna um c√≥digo bastante 

vulner√°vel, visto que o estudo das frequ√™ncias faz com  que seja poss√≠vel identificar 

um padr√£o na mensagem codificada.  

Segundo Lemos, que pode ser visto em [11], uma forma de evitar ataques a um 

sistema de criptografia por meio de uma an√°lise de frequ√™ncia das letras √© trabalhar 

com as mensagens enviadas em blocos. A ideia √© substituir um bloco de ùëò letras, em 

que ùëò √© um natural, por outro bloco de ùëô de letras. Quando utilizamos o m√©todo Linear 

 
 
 
 
 
 
 
34 

na  subse√ß√£o  3.1, fizemos ùëò  =  1,  iremos agora  generalizar essa  ideia para  valores 

maiores.  

Dado um alfabeto A com L letras, podemos representar cada bloco de ùëò letras 

por  um  natural  ùëé na  base  L  tal  que  0  ‚â§  ùëé  <   ùêøùëò   .  De  fato,  se  tomarmos  o  bloco 

(ùëé1 ùëé2. . . ùëéùëò)ùêø teremos: 

(ùëé1ùëé2. . . ùëéùëò)ùêø   =   ùëé1.ùêøùëò‚àí1 + ùëé2. ùêøùëò‚àí2+. . . +ùëéùëò. ùêø0 

como ùëéùëñ pertence ao alfabeto ordenado tal que  ùê¥  =  0, . . . ùê¥ùêø   =  ùêø  ‚àí  1 temos 

que o menor bloco que possuiremos ser√° (00. . .0) (ùëò ‚àí ùëßùëíùëüùëúùë†) e o maior 

(ùêø  ‚àí  1ùêø  ‚àí  1 . . . ùêø  ‚àí  1) (ùëò ‚àí ùë£ùëíùëßùëíùë†) 

assim 

0. ùêøùëò‚àí1+. . . +0. ùêø0 ‚â§ (ùëé1ùëé2. . . ùëéùëò). ùêø < (ùêø ‚àí 1). ùêøùëò‚àí1+. . . +(ùêø ‚àí 1). ùêø0 

e,  claramente,  o  √∫ltimo  membro  da  desigualdade  pode  reescrito  como 

(ùêø ‚àí 1). (ùêøùëò‚àí1 + ùêøùëò‚àí2 + ‚ãØ + ùêø0) = ùêøùëò ‚àí 1 por se tratar de uma P.G finita. 

Em  outras  palavras,  ao  inv√©s  de  considerarmos  um  alfabeto  com  apenas  ùêø 

letras  estaremos  considerando  um  novo  alfabeto  com  ùêøùëò  ‚Äúletras‚Äù,  onde  cada  uma 

dessas ‚Äúletras‚Äù √© na verdade um bloco. 

k
Definindo  uma fun√ß√£o    ùúé:    ‚Ñ§L

  ‚Üí ‚Ñ§L

k  onde  ùúé(ùëã) = ùëé. ùëã + ùëè,  com  ùëé ‚àà ‚Ñ§ùêøùëò  e  ùëè ‚àà ‚Ñ§ 

teremos tamb√©m uma permuta√ß√£o bem definida, pois ùúé tamb√©m ser√° uma bije√ß√£o.  

Como  exemplo,  vamos  transmitir  uma  mensagem  em  blocos  de  tamanho         

ùëò = 3 a palavra MATEMATICA. Para dividirmos em blocos de tamanho exatamente 3, 

ser√°  preciso  completar  a  palavra  com  a  primeira  letra  do  alfabeto3  A,  teremos, 

portanto, MAT‚àíEMA‚àíTIC‚àíAAA, vamos utilizar a fun√ß√£o de permuta√ß√£o 

Deste modo 

ùúé(ùëã) =   5779

ÃÖÃÖÃÖÃÖÃÖÃÖÃÖ. ùëã  +  123ÃÖÃÖÃÖÃÖÃÖÃÖ4 

(MAT)27 = 12.272 + 0.271 + 19.270 = 8767 

3 Neste exemplo utilizaremos o alfabeto definido por Lemos [11], onde ùê¥ = 0, ùêµ = 1, . . . ùëç = 25, sem que 

haja  preju√≠zo  a  teoria.  No  trabalho  utilizamos  o  alfabeto  definido  inicialmente  apenas  para  facilitar  o 

processo de programa√ß√£o. 

4 Considere neste caso as congru√™ncias m√≥dulo 263 

 
 
                                                           
35 

(EMA)27 = 4.272 + 12.271 + 0.270 = 3240 

(T IC)27 = 19.272 + 8.271 + 2.270 = 14069 

(AAA)27 = 0.272 + 0.271 + 0.270 = 0 

aplicando ùúé em cada bloco num√©rico, teremos 

ùúé (8767)   =  50664616  =  574  

ùúé (3240)   =  18724083  =  5550  

ùúé (14069)   =  81304874  =  14084  

ùúé(0)   =  123  =  123 

finalmente, fazendo a correspond√™ncia, teremos que 

574  =   0.272   +  21.27  +  7  =   (ùê¥ùëâùêª)  

5550  =   7.272   +  16.27  +  15.27  =   (ùêªùëÑùëÉ) 

 14084  =   19.272   +  8.27  +  17  =   (ùëáùêºùëÖ) 

 123  =   0.272   +  4.27  +  15  =   (ùê¥ùê∏ùëÉ) 

Para que tenhamos uma ideia de qu√£o embaralhadas ficaram as letras, vamos 

comparar  a  mesma  palavra  com  o  primeiro  sistema,  quando  usamos  ùëò  = 1  e              

ùúé(ùëã) = 17.¬¥ ùëã + 12¬¥ , com o arranjamento por blocos de tamanho ùëò  =  3. 

Figura 7 Compara√ß√£o ùëò = 1 e ùëò = 3 

Fonte: O autor 

Observe  na  Figura  7  uma  melhora  significativa  apenas  com  a  mudan√ßa  do 

tamanho  do  bloco.  Ainda  segundo  Lemos  [11]  quanto  maior  o  bloco,  maior  a 

dificuldade em se quebrar o sistema por uma an√°lise de frequ√™ncias. Para ùëò  =  8 esta 

tarefa seria j√° muito complexa, se n√£o imposs√≠vel. 

 
 
 
36 

Usando este modelo de decodifica√ß√£o, o c√≥digo se torna mais eficiente, por√©m 

ainda continua com falhas operacionais grav√≠ssimas, que pode tornar sua utiliza√ß√£o 

na pr√°tica pouco eficiente.  

Para  que  o  receptor  leia  a  mensagem,  √©  preciso  ter  minimamente  o 

conhecimento  das  chaves  ùëé  e  ùëè  e,  em  algumas  situa√ß√µes,  o  tamanho  do  bloco 

utilizado. Eis que surge ent√£o a d√∫vida: Como enviar as chaves para o receptor da 

mensagem em seguran√ßa? Afinal, reflitamos, caso tenhamos um canal seguro para 

envio dessas chaves, por que n√£o enviar logo a mensagem por ele? Assim, partindo 

desta necessidade, nasce o conceito de chave p√∫blica, o qual iremos abordar a seguir. 

Idealizar um sistema criptogr√°fico em que n√£o seja necess√°rio enviar previamente as 

chaves para que o receptor decodifique a mensagem. 

3.3. O Conceito de Chave P√∫blica 

A ideia de criptografar com chave p√∫blica foi proposta de maneira te√≥rica em 

1976, por Diffie e Hellman [11]. O objetivo deste modelo era montar um sistema em 

que os usu√°rios pudessem trocar mensagens sem ter que, obrigatoriamente, efetuar 

a troca de chaves.  

Para ilustrar melhor, temos um exemplo: Suponha que Pedro e J√∫lia desejam 

trocar mensagens secretas, mas n√£o disp√µem de nenhum sistema criptogr√°fico. Pedro 

poderia colocar sua mensagem em um ba√∫ e colocar um cadeado que somente ele 

possu√≠sse a chave. Depois, esse ba√∫ seria enviado para J√∫lia, que n√£o iria conseguir 

abri-lo,  e  esta  colocaria  outro  cadeado  no  ba√∫,  que  somente  ela  possui  a  chave. 

Novamente esse ba√∫ voltaria a Pedro que removeria seu cadeado e enviaria o ba√∫ 

novamente  a  J√∫lia,  que  ao  final  o  receberia  somente  com  seu  cadeado,  e  assim, 

conseguiria,  depois  de  muitas  idas  e  vindas,  ter  acesso  √†  mensagem.  Claro  que 

estamos supondo que no meio de tantas viagens esse ba√∫ poderia ser arrombado ou 

extraviado, mas n√£o  compete  a n√≥s  decidir o  destino  do  ba√∫  e  sim  compreender a 

maneira simb√≥lica de fazer a criptografia acontecer. 

O  fato  de  n√£o  termos  que  enviar  a  chave  em  momento  algum  √©  o  que 

transforma os sistemas de chave p√∫blica ou Assim√©trica em algo muito vantajoso a 

 
 
 
 
 
37 

ser  utilizado.  Na  pr√°tica  esse  sistema  funciona  da  seguinte  forma.  Pedro  e  J√∫lia, 

possuem chaves de E e D de encripta√ß√£o e decripta√ß√£o de um mesmo sistema. Na 

pr√°tica essas chaves s√£o diferentes apenas nos n√∫meros que as comp√µem. Sejam Ep 

e Dp as chaves de Pedro e Ej e Dj as de J√∫lia. Assim, os usu√°rios J√∫lia e Pedro ir√£o 

esconder suas chaves de decodifica√ß√£o Dp e Dj e tornar√£o p√∫blicas suas chaves de 

encripta√ß√£o, Ep e Ej . Deste modo, para que Pedro envie uma mensagem M a J√∫lia, 

basta ele aplicar sobre esta mensagem o algoritmo de encripta√ß√£o de J√∫lia e, depois, 

o seu algoritmo de decripta√ß√£o assim, ele obteria Dp(Ej (M)) e esta mensagem seria 

enviada a J√∫lia que para conseguir ler bastaria aplicar Ep e depois Dj assim ter√≠amos 

da√≠, 

Ep (Dp(Ej (M))) = Ej (M) 

Dj (Ej (M)) = M 

Podemos montar um exemplo utilizando SCL que vimos na se√ß√£o anterior.  

Considere que Pedro e J√∫lia utilizam o sistema criptogr√°fico acima, em blocos 

de tamanho predefinido k onde Pedro utiliza a fun√ß√£o de permuta√ß√£o ùúé cuja inversa √© 

ùúé‚àí1 e J√∫lia utiliza a fun√ß√£o œÅ e œÅ-1 assim, eles podem tornar p√∫blicas as suas chaves 

de encripta√ß√£o ùúé e œÅ. Assim, para  Pedro  enviar  uma  mensagem  a J√∫lia,  ele  far√°  

œÅ(ùúé-1 (M)) e J√∫lia com sua chave privada conseguir√° identificar a mensagem de Pedro. 

Mas! Temos  neste  ponto,  um pequeno problema.  Se  supormos  a chave  p√∫blica de 

Pedro  ùúé(ùëã) =  ùê¥. ùëã  +  ùêµ, √© poss√≠vel encontrar facilmente a chave privada, pois dado 

ùëå  =  ùê¥. ùëã  +  ùêµ,  conseguimos  obter  a  inversa  de  ùúé  fazendo  ùëã  =   ùê¥‚àí1 . (ùëã  ‚àí  ùêµ),  ou 

seja, basta encontrar o inverso multiplicativo de ùê¥ em ‚Ñ§ùêøùëò . O que √© uma tarefa bem 
simples se usarmos o algoritmo de Euclides estendido. Assim, podemos concluir que, 

nem  todo  sistema  de  criptografia  √©  adequado  a  ser  utilizado  em  chaves  p√∫blicas. 

Precisamos ent√£o, de um sistema que n√£o seja poss√≠vel obter a chave privada atrav√©s 

da chave p√∫blica. 

3.4. O RSA 

Iremos tratar agora sobre a matem√°tica envolvida no Sistema RSA, que ser√° 

de tratado de maneira mais aplicada. Segundo Coutinho em [1] o RSA, foi proposto 

 
 
  
 
38 

em 1978 por Rivest, Shamir e Adleman, cujas iniciais dos nomes de seus respectivos 

criadores  batizaram  o  sistema.  √â  sabido  que  o  RSA  √©  largamente  utilizado  para 

garantir  a  seguran√ßa  da  troca  de  informa√ß√µes  entre  usu√°rios  na  internet.  Para  que 

possamos utilizar o seu algoritmo, faz-se necess√°rio primeiramente a defini√ß√£o de um 

alfabeto. Neste caso continuaremos a utilizar o mesmo alfabeto do SCL que vai de A 

a Z, que possui 26 letras, chamaremos esse n√∫mero de ùêø, por√©m isso nos obrigar√° a 

fazer  uma  certa  separa√ß√£o  no  envio  das  mensagens.  Em  alguns  casos  utiliza-se  o 

alfabeto  com  27  posi√ß√µes,  conta-se  de  A  a  Z  e  acrescenta-se  um  caractere  que 

representa o espa√ßo.  

Primeiramente,  devemos  escolher  dois  n√∫meros  primos  ùëù  e  ùëû  e  outros  dois 

n√∫meros inteiros ùëü e ùë†  de modo que eles se relacionem da seguinte forma: 

ùêøùëü < ùëù. ùëû < ùêøùë† 

pensar  numericamente  ajudar√°  a  facilitar  o  entendimento.  Tomaremos  no  decorrer 

deste texto, ùëü = 2 e ùë† = 3, teremos ent√£o que escolher ùëù e ùëû de modo que 

262 < ùëù. ùëû < 263 

729 < ùëù. ùëû < 19683 

Como n√£o iremos ter capacidade de fazer c√°lculos com n√∫meros grandes, pois 

tomaria muito tempo e talvez fosse necess√°rio um computador com um bom programa 

de computa√ß√£o alg√©brica para que voc√™ pudesse acompanhar, podemos procurar nos 

primos de 1 a 50, dois, que satisfa√ßam essa condi√ß√£o na Figura 8 

Figura 8 Produto de Primos de 1 a 50 

Fonte: O autor 

 
 
39 

Vamos escolher ùëù = 23 e ùëû = 41 e assim ùëù. ùëû = ùëõ = 943, temos quase todos os 

pr√©-requisitos para obten√ß√£o das chaves de Encripta√ß√£o e Decripta√ß√£o.  

Retomando  os  n√∫meros  que  hav√≠amos  definido  anteriormente,  temos  agora 

que montar as chaves de Codifica√ß√£o e Decodifica√ß√£o. Hav√≠amos escolhido  ùëü  =  2, 

ùë†  =  3, ùëõ  =  943 = 23.41. Para gerar a primeira chave, precisamos calcular o valor de 

‚àÖ(ùëõ) = (ùëù ‚àí 1). (ùëû ‚àí 1),  assim  ‚àÖ(943) = (23 ‚àí 1). (41 ‚àí 1) = 880.  Escolhemos  agora  o 

menor natural ùëí tal que ùëöùëëùëê(ùëí, 880) = 1, que no caso √© 3. 

Feito  isso,  acabamos  de  criar  a  nossa  chave  de  encripta√ß√£o/codifica√ß√£o  ou 

chave p√∫blica. No Sistema RSA √© indiferente a escolha da chave que ser√° p√∫blica ou 

privada, por√©m temos um apre√ßo por manter a primeira chave como a p√∫blica visto 

que o processo para determin√°-la √© mais simples do que o processo para obten√ß√£o 

da  chave  privada,  al√©m  de  que,  no  m√©todo  que  utilizamos,  √©  mais  dif√≠cil  acertar  a 

chave privada por tentativa do que a chave p√∫blica. Assim, nossa chave p√∫blica ser√° 

(ùëõ, ùëí), neste caso (943, 3). 

A chave privada, ser√°   obtida   procurando um   n√∫mero ùëë,   de   modo    que  

ùëë. ùëí ‚â° 1 ùëöùëúùëë ùúô(ùëõ) 

o que parece ser uma tarefa um pouco mais complexa. Devemos sempre procurar ùëë 

de tal maneira que ùëë < ùúô(ùëõ).  

Para nosso exemplo, iremos resolver a seguinte congru√™ncia 

ùëë. 3 ‚â° 1 ùëöùëúùëë 880 

que √© equivalente a determinar uma solu√ß√£o da Equa√ß√£o Diofantina 

ùëë. 3 + 880. ùëò = 1 

assim obtendo ùëë = 587, e, portanto, a chave privada (943,587). 

Voc√™ pode estar se preguntando sobre os n√∫meros ùëü e ùë† que definimos no in√≠cio 

desta  se√ß√£o.  O  m√©todo  RSA  pode  ser  utilizado  de  v√°rias  formas,  e  uma  delas  √©, 

inclusive, atrav√©s do sistema de blocos. No momento de criptografar uma mensagem, 

√©  poss√≠vel dividi-la  em  blocos  de  tamanho  ùëü,  criptograf√°-la  e  envi√°-la  em  blocos  de 

tamanho ùë†.  

Iremos tratar de algumas das formas que elas s√£o feitas. Por√©m, a proposta 

desse  trabalho,  ser√°  utilizar  o  m√©todo  mais  simples,  de  modo  que  seja  facilmente 

aplicado na sala de aula.  

 
 
40 

3.4.1. Codifica√ß√£o letra-a-letra 

Antes de iniciar a codifica√ß√£o, devemos fazer um processo de pr√©-codifica√ß√£o, 

onde  transformaremos  as  letras  em  n√∫meros  (de  acordo  o  alfabeto  definido).  Em 

seguida  o  autor da mensagem, de posse  da  chave p√∫blica  do  receptor ao  qual ele 

deseja enviar a mensagem, ir√° elevar cada bloco da mensagem (que representa cada 

letra)  por  ùëí,  e  encontrar  o  m√≥dulo  da  divis√£o  deste  resultado  por  ùëõ,  ou  seja,  se 

desejamos enviar a mensagem ùëé1ùëé2ùëé3 ‚Ä¶ ùëéùëõ devemos encontrar ùëè1ùëè2ùëè3 ‚Ä¶ ùëèùëõ onde 

ùëí ‚â° ùëè1ùëöùëúùëë ùëõ
ùëé1
ùëí ‚â° ùëè2ùëöùëúùëë ùëõ
ùëé2
‚ãÆ
ùëí ‚â° ùëèùëõùëöùëúùëë ùëõ
ùëéùëõ

a sequ√™ncia num√©rica ùëè1ùëè2 ‚Ä¶ ùëèùëõ ser√° nossa mensagem codificada. 

Vamos enviar a palavra C I D A D E que a hav√≠amos codificado como, 3 9 4 1 

4 5. Temos ent√£o que resolver as congru√™ncias: 

33 ‚â° ùëè1ùëöùëúùëë 943 ‚áí ùëè1 = 27
93 ‚â° ùëè2ùëöùëúùëë 943 ‚áí ùëè2 = 729
43 ‚â° ùëè3ùëöùëúùëë 943 ‚áí ùëè3 = 64
13 ‚â° ùëè4ùëöùëúùëë 943 ‚áí ùëè4 = 1
43 ‚â° ùëè5ùëöùëúùëë 943 ‚áí ùëè5 = 64
53 ‚â° ùëè6ùëöùëúùëë 943 ‚áí ùëè6 = 125

Parece que conseguimos, mas para uma an√°lise mais detalhada,  observa-se 

que temos alguns problemas na forma que fizemos a encripta√ß√£o. Observe que, letras 

repetidas obtiveram a mesma codifica√ß√£o. Al√©m disso, observe os resultados obtidos, 

eles  formam  simplesmente  o  cubo  do  n√∫mero  correspondente  a  letra.  Isso  se  d√° 

devido ao fato destas pot√™ncias serem menores do que 943, ou seja, o algoritmo s√≥ 

far√°  uma  mudan√ßa  mais  eficiente  se  as 

letras  envolvidas  obtiverem  um 

correspondente maior do que 10, isto √©, a partir do J. Al√©m disso, a letra A que √© igual 

a 1, sempre ser√° codificada como 1 ap√≥s a aplica√ß√£o do algoritmo, o que seria uma 

pista  e  tanto  para  decodificarmos  a  mensagem.  Como  resolvermos  isso?  Bom, 

existem  dois  modos,  um  que  seria  ao  inv√©s  de  codificar  letra  a  letra,  codificarmos 

blocos de duas letras ou mais, de acordo o nosso ùëü. Mas, para isto temos que tomar 

o cuidado de nenhum bloco ultrapassar o tamanho de ùëõ, com a nossa pre-codifica√ß√£o, 

o  maior bloco  de  duas  letras  seria  ùëåùëç  =  2526,  assim  precisar√≠amos  tomar um  ùëõ  um 

 
 
 
 
 
41 

pouco  maior  caso  necess√°rio,  se  quis√©ssemos  codificar  usando  blocos  de  3, 

aumentar√≠amos ainda mais o ùëõ. 

Outra sa√≠da caso quis√©ssemos manter a codifica√ß√£o letra a letra, seria modificar 

a correspond√™ncia do nosso alfabeto. Adotando por exemplo ùê¥ = 10, ùêµ = 11, e assim 

por diante at√© ùëç = 35. Assim, nosso algoritmo para o mesmo exemplo acima retornaria  
123 ‚â° ùëè1ùëöùëúùëë 943 ‚áí ùëè1 = 785
183 ‚â° ùëè2ùëöùëúùëë 943 ‚áí ùëè2 = 174
133 ‚â° ùëè3ùëöùëúùëë 943 ‚áí ùëè3 = 311
103 ‚â° ùëè4ùëöùëúùëë 943 ‚áí ùëè4 = 57
133 ‚â° ùëè5ùëöùëúùëë 943 ‚áí ùëè5 = 311
143 ‚â° ùëè6ùëöùëúùëë 943 ‚áí ùëè6 = 858

que √© um pouco melhor. 

Observe a codifica√ß√£o da palavra ùê∂ùêºùê∑ùê¥ùê∑ùê∏ utilizando um √∫nico bloco como letra. 

Para isso, tomamos novas chaves, p√∫blica e privadas, oriundas de ùëù = 773 e ùëû = 571 

ùê∂ùêºùê∑ùê¥ùê∑ùê∏ = 394145 

ùê∂‚Ñéùëéùë£ùëíùëÉ√∫ùëèùëôùëñùëêùëé = (ùëõ, ùëí) = (441383,7) 

ùê∂‚Ñéùëéùë£ùëíùëÉùëüùëñùë£ùëéùëëùëé = (ùëõ, ùëë) = (441383,62863) 

Assim, resolvendo a congru√™ncia 

E finalmente nossa mensagem a ser enviada ùëè1 = 318881 

3941457 ‚â° ùëè1ùëöùëúùëë 441383 

3.4.2. Codifica√ß√£o por transposi√ß√£o de blocos 

Para utilizar o sistema de codifica√ß√£o por transposi√ß√£o de blocos, precisamos 

decompor  a  mensagem  em  blocos  de  tamanho  ùëü, algumas  vezes,  a  depender  do 

tamanho  da  mensagem,  ser√°  necess√°rio  completar  o  √∫ltimo  bloco  com  uma  letra 

qualquer por exemplo ùê¥. Como escolhemos para o exemplo ùëü = 2, segue que a palavra 

cidade  seria  ent√£o  decomposta  como  ùê∂ùêº ‚àí ùê∑ùê¥ ‚àí ùê∑ùê∏.  N√£o  havendo,  portanto, 

necessidade de completarmos o √∫ltimo bloco. 

Feito 

isso,  devemos 

reescrever  os  blocos, 

fazendo  a  sua  correta 

correspond√™ncia num√©rica, assim, obtemos: 

ùê∂ùêº = 39; ùê∑ùê¥ = 41; ùê∑ùê∏ = 45 

 
 
 
 
 
 
 
42 

√â importante fixar aqui que o alfabeto utilizado faz a correspond√™ncia ùê¥ = 1, ùêµ =

2,  at√©  ùëç = 26 = 0,  portanto  utilizaremos  comumente  aqui  ùëç = 0.  Agora,  devemos 

escrever estes n√∫meros na base ùêø, obtendo: 

39 = 3.261 + 9.260 = 87 

41 = 4.261 + 1.260 = 105 

45 = 4.261 + 5.260 = 109 

codific√°-los utilizando nossa chave p√∫blica, 

873 ‚â° ùëè1ùëöùëúùëë 943 ‚áí ùëè1 = 289
1053 ‚â° ùëè2ùëöùëúùëë 943 ‚áí ùëè2 = 564
1093 ‚â° ùëè3ùëöùëúùëë 943 ‚áí ùëè3 = 290

Este  resultado  ainda  n√£o  ser√°  enviado,  pois  decidimos  que  seriam  enviados 

nesse processo, blocos de tamanho 3, assim, para finalizar, devemos colocar ùëè1, ùëè2 e 

ùëè3 na base 26 

Assim, 

289 = 2.262 + 8.261 + 9.260 = 1569 

564 = 5.262 + 6.261 + 4.260 = 3540 

290 = 2.262 + 9.261 + 0.260 = 1586 

3.4.3. Decodifica√ß√£o  

O  processo  de  decodifica√ß√£o  √©  an√°logo  a  codifica√ß√£o  neste  sistema,  por√©m 

utilizaremos esta parte para j√° justificarmos o porqu√™ do m√©todo RSA funciona. 

Teorema 10 (RSA). Seja ùëé ‚àà ‚Ñ§,  ent√£o ùëéùëëùëí ‚â° ùëé ùëöùëúùëë ùëõ. 

Demonstra√ß√£o:  Note  que  pela 

forma  como 

tomamos  ùëë  e  ùëí, 

temos  que                         

ùëë. ùëí ‚â° 1 ùëöùëúùëë ùúô(ùëõ). Ou seja, ùëë. ùëí = 1 + ùëò. ùúô(ùëõ). Podemos escrever, 

ùëéùëë.ùëí ‚â° ùëéùëë.ùëí ùëöùëúùëë ùëõ 

equivale a  

note que, manipulando mais ou pouco a equa√ß√£o acima temos, 

ùëéùëë.ùëí ‚â° ùëé1+ùëò.ùúô(ùëõ) ùëöùëúùëë ùëõ 

ùëéùëë.ùëí ‚â° (ùëéùúô(ùëõ))

ùëò

. ùëé1 ùëöùëúùëë ùëõ 

 
 
 
 
 
 
 
 
mas, o Teorema de Euler garante que 

e, portanto 

ùëéùúô(ùëõ) ‚â° 1 ùëöùëúùëë ùëõ 

ùëéùëë.ùëí ‚â° (1)ùëò. ùëé1 ‚â° ùëé ùëöùëúùëë ùëõ. 

43 

‚àé 

O Teorema 10, nos mostra que ao recebermos uma mensagem codificada pelo 

sistema  RSA  com  a  chave  p√∫blica  (ùëõ, ùëí),  para  decodific√°-la  basta  elevarmos  a 

mensagem a ùëë m√≥dulo ùëõ, que a mesma ser√° recuperada. 

Voltando ao exemplo da subse√ß√£o 3.4.1, e lembrando que nossa chave privada 

foi (943,587), temos ent√£o que resolver as congru√™ncias: 

27587 ‚â° ùëé1ùëöùëúùëë 943 ‚áí ùëé1 = 3
729587 ‚â° ùëé2 ùëöùëúùëë 943 ‚áí ùëé2 = 9
64587 ‚â° ùëè3ùëöùëúùëë 943 ‚áí ùëè3 = 4
1587 ‚â° ùëé4ùëöùëúùëë 943 ‚áí ùëé4 = 1
64587 ‚â° ùëé5ùëöùëúùëë 943 ‚áí ùëé5 = 4
125587 ‚â° ùëé6ùëöùëúùëë 943 ‚áí ùëé6 = 5

5 

Para  decodifica√ß√£o  das  mensagens  codificadas  em  blocos,  deve-se  seguir  o 

mesmo processo, por√©m as por transposi√ß√£o, deve-se tomar o cuidado de retornar os 

c√≥digos  enviados  para  a  base  anterior  antes  de  iniciarmos  o  processo  de 

decodifica√ß√£o. Assim ao recebermos a mensagem da subse√ß√£o 3..4.1, onde foi feita 

uma transposi√ß√£o de blocos, devemos proceder da seguinte forma: 

(1569)ùêø3 = 2.262 + 8.261 + 9.260 = (289)ùêø 
(3540)ùêø3 = 5.262 + 6.261 + 4.260 = (564)ùêø 
(1586)ùêø3 = 2.262 + 9.261 + 0.260 = (290)ùêø 

e em seguida aplicar a decodifica√ß√£o 

289587 ‚â° ùëé1ùëöùëúùëë 943 ‚áí ùëé1 = 87
564587 ‚â° ùëé2 ùëöùëúùëë 943 ‚áí ùëé2 = 105
290587 ‚â° ùëé3 ùëöùëúùëë 943 ‚áí ùëé3 = 109

5 Caso seja do interesse do leitor, √© poss√≠vel verificar os c√°lculos atrav√©s do aplicativo 

CodeClass, que ser√° abordado no pr√≥ximo cap√≠tulo. 

 
  
 
 
                                                           
 
44 

3.4.4. Assinatura do RSA 

Quando tratamos em 3.3 do Conceito de Chave p√∫blica, vimos como √© simples 
assinar  uma  mensagem  atrav√©s  dos  cadeados.  Por√©m,  na  pr√°tica,  para  que  isso 
aconte√ßa,  faz-se  necess√°rio  que  as  fun√ß√µes  que  codificam  e  decodificam  as 
mensagens se comportem como pares de fun√ß√µes onde uma se torna o inverso da 
outra e vice-versa. 

Para  que  isso  aconte√ßa  com  o  RSA,  √©  necess√°rio  seguirmos  alguns  passos 

durante a codifica√ß√£o e decodifica√ß√£o do sistema. 

Vamos supor que Pedro e J√∫lia desejem trocar mensagens. Cada um conhece 

suas chaves p√∫blicas e privadas e como funciona o sistema RSA. 

Sem perda de generalidade, suponha que as chaves p√∫blica e privada de Pedro 
sejam (ùëõùëÉ, ùëíùëÉ), (ùëõùëÉ, ùëëùëÉ). E as de J√∫lia sejam (ùëõùêΩ, ùëíùêΩ), (ùëõùêΩ, ùëëùêΩ). Considere tamb√©m ùëõùëÉ >
ùëõùêΩ. 

Pedro mandar√° a mensagem ùëé para J√∫lia da seguinte forma.  

Primeiramente ir√° determinar ùëè, onde ùëéùëíùêΩ ‚â° ùëè ùëöùëúùëë ùëõùêΩ  e em seguida ir√° calcular 

ùëê onde ùëèùëëùëÉ ‚â° ùëê ùëöùëúùëë ùëõùëÉ, enviando finalmente ùëê. 

Caso ùëõùêΩ > ùëõùëÉ ele dever√° inverter a ordem da opera√ß√£o anterior, realizando:  

Primeiramente ir√° determinar ùëè, onde ùëéùëëùëÉ ‚â° ùëè ùëöùëúùëë ùëõùëÉ  e em seguida ir√° calcular 

ùëê onde ùëèùëíùêΩ ‚â° ùëê ùëöùëúùëë ùëõùêΩ, enviando finalmente ùëê 

Para  a  decodifica√ß√£o,  deve-se  seguir  os  passos  na  ordem  inversa  de 

codifica√ß√£o, aplicando a congru√™ncia m√≥dulo maior ùëõ inicialmente. 

 
 
45 

4.   O APLICATIVO CODECLASS E A CRIPTOGRAFIA 

O aplicativo CodeClass foi desenvolvido com o intuito apresentar de maneira 

simples, os processos necess√°rios para a implementa√ß√£o de um complexo sistema 

de criptografia que √© comumente utilizado na internet, o RSA. Al√©m de possibilitar o 

desenvolvimento  de  atividades  voltadas  para  o  estudo  da  Aritm√©tica  Modular  nas 

aulas. 

Apesar  do  aplicativo  j√°  poder  ser  acessado,  acreditamos  que  ainda  s√£o 

necess√°rios  v√°rios  ajustes  e  melhorias,  que  busquem  aumentar  a  gama  de 

possibilidades quanto a sua utiliza√ß√£o. Al√©m disso, somente com o uso e colabora√ß√£o 

dos usu√°rios, ser√° poss√≠vel tornar o seu uso mais intuitivo e din√¢mico. O registro do 

mesmo j√° foi iniciado pela UESB no dia 19/09/2019.  

Para ter acesso ao aplicativo, basta acessar do seu celular o link dispon√≠vel em 

[12] onde consta a vers√£o mais recente do app. Ap√≥s acessar a pasta do drive, fa√ßa 

o  download  do  arquivo  CodeClass.apk  e  execute-o  em  seu  aparelho.  Como  o 

aplicativo  ainda  n√£o  se  encontra  dispon√≠vel  no  PlayStore,  muitas  vezes  ser√° 

necess√°ria uma autoriza√ß√£o manual do usu√°rio para prosseguir com a instala√ß√£o. 

4.1. O aplicativo 

O aplicativo CodeClass foi integralmente desenvolvido atrav√©s da plataforma 

gratuita,  MIT  App  Inventor  2.  O  seu  algoritmo  utiliza,  efetuando  as  devidas 

adapta√ß√µes,  toda  a  teoria  apresentada  neste  trabalho.  O  projeto  foi  iniciado  em 

meados de fevereiro, ap√≥s o levantamento te√≥rico ter sido completamente finalizado. 

Foi  necess√°ria  uma  completa  revis√£o  sobre  os  principais  algoritmos  da  Teoria  dos 

N√∫meros,  principalmente  para  a  tomada  decis√£o  quanto  as  etapas  l√≥gicas  que  o 

sistema iria realizar.  

A primeira fase do projeto, foi conseguir fazer com que o aplicativo interpretasse 

as letras do alfabeto como n√∫meros, para que pudesse ser feita a correla√ß√£o proposta 

 
 
 
 
46 

na Figura 5, para isso criamos no desenvolvimento do app uma lista, organizada por 

√≠ndices que possui 26 linhas.   

O  aplicativo  possui  tr√™s  fun√ß√µes  bem  definidos,  uma  para  se  trabalhar  a 

Criptografia Linear, a segunda trabalha a Criptografia RSA e um m√≥dulo gerador de 

n√∫meros primos. O primeiro destes, foi inserido por ser conceitualmente mais simples, 

e pode ser utilizado como base para compreens√£o da Criptografia RSA, al√©m de ser 

um  instrumento  que  servir√°  para  se  comparar  os  m√©todos,  entender    falhas  e 

conseguir discernir o porqu√™ de alguns sistemas n√£o serem adequados para o sistema 

de chave p√∫blica. 

O segundo bloco e foco deste projeto trata especificamente do RSA, e pode-se 

atribuir a ele diversos usos. Ele foi propositalmente subdividido em tr√™s partes gera√ß√£o 

das  chaves,  codifica√ß√£o e decodifica√ß√£o  afim de facilitar  o  trabalho  e  entendimento 

em cada uma das etapas. Sendo assim, ser√° poss√≠vel trabalhar todo o processo de 

maneira gradativa e independente. 

Finamente, foi colocado um m√≥dulo de n√∫meros primos, pois como estes s√£o 

a  base  do  sistema,  seria  sempre  necess√°rio  dar  uma  consultada  em  alguns. 

Acreditamos que deix√°-los ‚Äúa m√£o‚Äù pode servir para ganharmos tempo em algumas 

propostas. 

4.2. Interface 

Figura 9 √çcone e Slogan do CodeClass 

Fonte: O autor 

O aplicativo CodeClass cujo slogan pode ser visto na Figura 9, ainda encontra-

se em fase aperfei√ßoamento, por√©m j√° √© poss√≠vel acess√°-lo caso os usu√°rios queiram 

testar e at√© mesmo realizar sugest√µes e/ou cr√≠ticas para o projeto. O funcionamento 

 
 
 
 
47 

ainda  √©  um  pouco  arcaico,  devido  a  n√£o  ser  poss√≠vel  at√©  o  momento  automatizar 

alguns processos na inser√ß√£o dos dados. 

Ao  instalar  o  app,  o  usu√°rio  ir√°  se  deparar  com  uma  tela  inicial,  conforme  a 

Figura 10, que disponibiliza  acesso aos temas que poder√£o ser trabalhados. 

Figura 10 Tela Inicial do CodeClass 

Fonte: O Autor 

Nesta  tela,  √©  poss√≠vel  escolher  qual  tipo  de  criptografia  ser√°  trabalhada  de 

acordo a proposta que o professor deseja para aquela aula ou atividade, s√£o elas a 

Criptografia Linear, que apesar de ser completamente invi√°vel hoje, √© o passo inicial 

para entendermos a necessidade de evolu√ß√£o dos sistemas criptogr√°ficos. 

No  momento  o  bot√£o  sobre  encontra-se  em  fase  desenvolvimento,  n√£o 

havendo at√© o momento nenhuma funcionalidade para tal. Em breve ele ir√° apresentar 

informa√ß√µes  sobre  os  autores,  bem  como  a  forma  de  contato  para  algum  tipo  de 

suporte. 

Na  interface  descrita  na  Figura  4.3  √©  poss√≠vel  codificar  e  decodificar  uma 

mensagem  utilizando  o  Sistema  de  Criptografia  Linear.  Este  sistema  √©  uma 

reinterpreta√ß√£o da Cifra de C√©sar que foi citada no in√≠cio deste trabalho. Al√©m disso, 

sistemas mais avan√ßados com o utilizado na Enigma [2] tamb√©m se basearam num 

m√©todo similar a este para sua cria√ß√£o. 

 
 
48 

Figura 11 Interface Criptografia Linear 

Fonte: O autor 

Para  codificar  uma  mensagem,  o  autor  deve  escolher  inicialmente  dois 
par√¢metros  A  e  B,  que  comp√µes  a  fun√ß√£o  de  permuta√ß√£o  ùëì(ùëã) = ùê¥. ùëã + ùêµ,  como 
estamos utilizando o alfabeto tradicional, com as letras de A a Z (mai√∫sculas) e sem 
considerar  o  espa√ßo  em  branco,  consideramos  que  o  nosso  alfabeto  de  trabalho, 
consta de 26 caracteres. Para que haja inversos em ‚Ñ§26 faz-se ent√£o necess√°rio que 
a  escolha  de  ùê¥,  seja  de  forma  que  ùëöùëëùëê(ùê¥, 26) = 1,  caso  esta  condi√ß√£o  n√£o  seja 
satisfeita, o programa n√£o seguir√° com o processo. 

Escolhido  os  par√¢metros,  deve-se  digitar  nos  campos  da  janela  intitulada 
‚ÄúESCREVA  SUA  MENSAGEM‚Äù  os  caracteres  da  mensagem  que  se  deseja  enviar. 
Vale  ressaltar  que  s√≥  devem  ser  utilizados  caracteres  mai√∫sculos  do  alfabeto  e, 
sempre,  um  caractere  por  campo,  caso  contr√°rio  o  programa  ir√°  retornar  erros  e 
possivelmente ir√° finalizar sua execu√ß√£o. 

 
 
49 

Figura 12 Exemplo de Preenchimento 

Fonte: O autor 

Utilizamos a interface com o exemplo como pode ser visto na Figura 12, para 

ilustrar  o  preenchimento,  neste  caso  em  espec√≠fico  os  par√¢metros  utilizados  foram  

ùê¥ = 1 e ùêµ = 3 que representam a transposi√ß√£o inicial da Cifra de C√©sar, em seguida 

escrevemos a mensagem J U L I O C E S A R. Para codificar, basta finalmente clicar 

no  bot√£o  CRIPTOGRAFAR,  que  o  programa  ir√°  retornar  a  imagem  da  fun√ß√£o  de 

transposi√ß√£o definida. Caso seja de interesse do utilizador converter os n√∫meros em 

caracteres,  ir√°  ser  liberado  um  bot√£o  com  este  fim.  √â  importante  salientar  tamb√©m 

que, para que o receptor consiga ler a mensagem, √© necess√°rio ter acesso as chaves 

para leitura que tamb√©m s√£o geradas no momento da codifica√ß√£o. 

 
 
 
 
 
 
 
50 

Figura 13 Codifica√ß√£o e Gera√ß√£o das Chaves 

Fonte: O autor 

Finalizada  a  codifica√ß√£o  e  gera√ß√£o  das  chaves,  o  autor  poder√°  transmitir  a 

mensagem  para  o  receptor,  atrav√©s  do  bot√£o  compartilhar.  Vale  lembrar  que  √© 

importante  definir-se  tamb√©m  um  canal  seguro  para  envio  da  chave  de  leitura,  ou, 

caso contr√°rio o receptor n√£o ter√° condi√ß√µes de decodificar a mensagem como pode 

ser visto na Figura 13. 

A  decodifica√ß√£o  deve  ser  feita  da  mesma  forma  da  codifica√ß√£o.  Por√©m  na 

defini√ß√£o  dos  par√¢metros,  deve-se  colocar  os  valores  de  A  e  B  fornecidos  como 

‚ÄúCHAVE DE LEITURA‚Äù e em seguida, realizar as mesmas etapas da codifica√ß√£o. 

Na tela de boas vindas do Sistema de Criptografia RSA Figura 14, o utilizador  

tem  acesso  a  tr√™s  m√≥dulos  para  operar:  Gerar  Chaves,  Criptografar  Mensagem  e 

Decifrar  Mensagem.  Os  m√≥dulos  s√£o  completamente  independes,  n√£o  sendo 

necess√°rio alimentar um com informa√ß√µes para a utiliza√ß√£o dos demais. 

 
 
 
 
 
 
 
51 

Figura 14 Tela de boas-vindas Criptografia RSA 

Fonte: O autor 

A tela de gera√ß√£o das chaves, possui um funcionamento bem intuitivo. Basta 

que  o  utilizador,  escolha  dois  primos  distintos  e  pressione  o  bot√£o  verificar 

primalidade.  O  programa  ir√°  verificar  se  os  n√∫meros  s√£o  realmente  primos  e,  em 

seguida ir√° liberar o bot√£o para gera√ß√£o das chaves.  

Em testes realizados durante o desenvolvimento do aplicativo, verificamos que 

no momento a forma de execu√ß√£o do algoritmo torna invi√°vel a gera√ß√£o de chaves 

para  primos muito  grandes. Aconselhamos  trabalhar com n√∫meros  de  3  d√≠gitos,  no 

m√°ximo. √â poss√≠vel ainda assim gerar chaves para n√∫meros maiores, mas o tempo 

de espera pode  ser demasiadamente  grande, podendo  em alguns  casos finalizar a 

execu√ß√£o do programa no celular, por n√£o conseguir finalizar a tarefa. 

√â  importante  que,  ap√≥s  geradas  as  chaves,  o  usu√°rio  anote-as  em  um  local 

seguro, principalmente a sua chave privada. Caso seja uma din√¢mica ou oficina, ele 

pode divulgar as suas chaves p√∫blicas para outros usu√°rios, que poder√£o utiliz√°-las 

no decorrer do processo. Observe um exemplo na Figura 15. 

 
 
 
52 

Figura 15 Gera√ß√£o das Chaves RSA 

Fonte: O autor 

Ap√≥s  geradas  as  chaves  p√∫blica  e  privada,  podemos  iniciar  o  processo  de 

codifica√ß√£o. Para facilitar o entendimento e exemplificar o processo, iremos simular o 

envio de uma mensagem entre os usu√°rios Alice e Bob que possuem as chaves: 

Alice: P√∫blica (ùëõ, ùê∂ùëùùë¢ùëè)   =   (21509,5) Privada: (ùëõ, ùê∂ùëùùëüùëñùë£) =   (21509,16973) 

Bob: P√∫blica (ùëõ, ùê∂ùëùùë¢ùëè)   =   (20633,5) Privada: (ùëõ, ùê∂ùëùùëüùëñùë£) =   (20633,12089) 

Para  que  Bob  consiga  enviar  uma  mensagem  para  Alice,  ele  precisar  saber 

qual a chave p√∫blica de Alice. De posse dessa informa√ß√£o, ele deve preencher   na 

tela  de  Codifica√ß√£o,  nos  campos  ùëõ  e  ùê∂ùëùùë¢ùëè  as  chaves  p√∫blicas  do  usu√°rio  que  ir√° 

receber  a  mensagem,  neste  caso,  Alice.  Em  seguida  deve  escrever  nos  campos 

abaixo  a  sua mensagem,  sempre  respeitando um  caractere  por campo e utilizando 

sempre letras mai√∫sculas que pode ser vista na Figura 16. 

√â poss√≠vel enviar a mensagem assinada, ou n√£o. Tudo vai depender de como 

se est√° trabalhando o aplicativo e o dom√≠nimo de conte√∫do dos participantes. Para 

 
 
 
 
 
53 

assinar,  basta  que  o  autor  marque  o  campo  Assinar  mensagem  e  em  seguida 

preencher os  campos indicados  com  a  sua Chave  Privada.  Aten√ß√£o a assinatura √© 

sempre  realizada  com  a  chave  privada  do  autor.  Caso  haja  uma  invers√£o  destas 

chaves, ser√° imposs√≠vel para o receptor decodificar a informa√ß√£o recebida. 

Figura 16 Codifica√ß√£o, Codifica√ß√£o sem assinatura e Codifica√ß√£o com Assinatura 

Fonte: O autor 

Ap√≥s  ter  criptografado  a  mensagem,  a  mesma  pode  ser  enviada  atrav√©s  do 

bot√£o compartilhar ou transmitida por algum outro canal ao receptor. Vale ressaltar 

que n√£o √© poss√≠vel converter a mensagem codificada para o alfabeto, por n√£o se tratar 

de uma cifra de transposi√ß√£o. 

Finalmente na tela de decodifica√ß√£o, iremos realizar um processo semelhante 

ao  da  codifica√ß√£o.  Fez-se  necess√°rio  a  cria√ß√£o  de  uma  tela  a  parte  para  este 

processo,  devido  a  algumas  peculiaridades  no  processo  de  codifica√ß√£o  e 

decodifica√ß√£o. O principal deles, √© o fato de a entrada na codifica√ß√£o ser um caractere 

do  tipo  texto,  enquanto  a  sa√≠da  √©  um  caractere  num√©rico.  J√°  na  decodifica√ß√£o,  a 

 
 
 
 
 
54 

entrada do programa √© um caractere num√©rico e a sa√≠da ser√°  um caractere do tipo 

texto.  Portanto,  os  campos  de  entrada  nos  dois  processos  s√£o  distintos  e  assim 

optamos por realiz√°-los separados. 

Para decodificar a mensagem o receptor deve ir na tela decifrar mensagem e 

inserir  em  cada  campo  os  n√∫meros  que  foram  recebidos  e  na  ordem  recebida.  Foi 

tomado  o  cuidado  de deixar cada  bloco num√©rico  visivelmente  espa√ßado, de modo 

que n√£o haja sobreposi√ß√µes de blocos ou indefini√ß√µes das sequ√™ncias num√©ricas. 

Em seguida o receptor deve preencher os campos ùëõ e ùê∂ùëùùëüùëñùë£ com a sua chave 

privada  e  por fim  pressionar  o  bot√£o  DECODIFICAR  MENSAGEM.  Na  maioria  das 

vezes, a depender das chaves que foram utilizadas, voc√™ notar√° que os resultados 

foram  n√∫meros  menores  que  26.  Isso  indica  que  a  princ√≠pio  o  processo  parece  ter 

ocorrido da maneira correta. E assim, para finalizar o usu√°rio pode pressionar o bot√£o 

CONVERTER  PARA  TEXTO,  para  que  seja  traduzido  o  conte√∫do  para  caracteres 

alfab√©ticos conforme a Figura 17. 

Caso a mensagem tenha sido assinada, ele deve marcar o campo MENSAGEM 

ASSINADA  e  entrar  com  as  chaves  p√∫blicas  do  poss√≠vel  receptor.  Em  seguida 

pressionar  o  bot√£o  DECODIFICAR  MENSAGEM,  que  o  sistema  ir√°  proceder  da 

mesma forma que a decodifica√ß√£o sem assinatura. Se ocorrer tudo corretamente no 

processo  e  a  mensagem  conseguir  ter  sido  decifrada  com  sucesso,  ser√°  poss√≠vel 

converter os caracteres para as letras correspondentes do alfabeto, al√©m de termos a 

plena certeza sobre a autoria do conte√∫do. 

 
55 

Figura 17 Decodifica√ß√£o, sem Assinatura e com Assinatura 

Fonte: O autor 

O terceiro e ultimo m√≥dulo do aplicativo √© um gerador de n√∫meros primos, que 

optamos por deixar dispon√≠vel para fim meramente pr√°ticos de utiliza√ß√£o do programa. 

Utilizamos para a verifica√ß√£o da primalidade, nesta tela, o Teorema de Wilson 

a fim de ser mais simples de implement√°-lo na gera√ß√£o dos primos, que pode ser feita 

de maneira atrav√©s de um f√≥rmula de recurs√£o. Assim, nele ser√° poss√≠vel tanto testa 

se determinado n√∫mero √© primo, quanto tamb√©m gerar uma lista de primos, para que 

seja feita a escolha de algo de acordo o interesse do usu√°rio. 

Na tela que √© acessada pelo bot√£o GERADOR DE PRIMOS o usu√°rio tem as 

op√ß√µes de inciar a gera√ß√£o de uma lista ou testar a primalidade de algum n√∫mero de 

maneira  isolada.  Ap√≥s  precionar  o  bot√£o  GERAR  PRIMOS,  a  lista  ser√°  inciada  de 

maneira interrupta, at√© que seja solicitado a pausa do processo. Caso o interesse seja 

escolher um primo apenas, pode-se faz√™-lo desta forma. 

Se o interesse for em somente verificar se determinado n√∫mero √© primo, deve-

se  ent√£o  digit√°-lo  no  campo  espec√≠fico  e  precionar  o  bot√£o  VERIFICAR 

 
 
 
 
56 

PRIMALIDADE. O programa ir√° retornar o resultado como na Figura 18 e dar√° fim ao 

processo. 

Figura 18 Gerador de Primos 

Fonte: O autor 

 
 
 
 
 
 
 
 
 
 
 
 
 
57 

4.3. SUGEST√ÉO I ‚Äì Origem da Criptografia 

Dura√ß√£o: 200 minutos/ 4 aulas 

Objetivos:  Conhecer  a  origem  da  criptografia;  entender  o  funcionamento  dos 

primeiros  m√©todos  criptogr√°ficos;  compreender  a  sua 

import√¢ncia  para  o 

desenvolvimento da sociedade. 

S√©rie: A partir do 1¬∫Ano do Ensino M√©dio 

Um pouco de Hist√≥ria 

Todo  material  utilizado  nas  atividades,  inclusive  o  aplicativo,  se  encontra 

dispon√≠vel no link permanente, dispon√≠vel em [12]. 

Inicialmente,  a  proposta  √©  fazer  uma  breve  introdu√ß√£o  sobre  a  origem  da 

criptografia  e  da  Cifra  de  C√©sar.  Deve-se  verificar  se  os  alunos  compreenderam  o 

funcionamento da cifra de C√©sar e a import√¢ncia de se ocultar informa√ß√µes. 

Esta verifica√ß√£o pode ser feita solicitando aos alunos que respondam a Atividade 1. 

ATIVIDADE 1 

1)  Codifique seu nome utilizando a Cifra de C√©sar. 

2)  Decifre a frase MXOLR FHVDU.   

3)  Eu poderia, ao inv√©s de utilizar a correspond√™ncia de A para D, realizar alguma 

outra diferente? 

Usando o aplicativo 

Utilizando o aplicativo. 

Pe√ßa aos alunos que abram o aplicativo CodeClass. 

Em  seguida  clique  no  bot√£o  Criptografia  Linear,  na  tela  que  segue,  pe√ßa  que 

preencham as caixas A e B com os valores 1 e 3. Em seguida, pe√ßa-os que digitem a 

mensagem do exerc√≠cio 1 pressione o bot√£o criptografar e observem se o resultado √© 

o mesmo que eles obtiveram. 

 
 
58 

Na parte inferior do aplicativo, onde aparece: CHAVES PARA LEITURA constam as 

chaves para que o aluno consiga decifrar a mensagem. 

Pe√ßa-os  que  anotem  essas  chaves  ùê¥ = 1 e ùêµ = 23  e  agora  tentem  responder  o 

exerc√≠cio  2,  utilizando-as  para  decifrar  MXOLR  FHVDU.  √â  importante  que  eles 

entendam o funcionamento do mecanismo e n√£o tenham d√∫vidas quanto a forma de 

decifrar. 

Questione sobre a analogia entre a matem√°tica do aplicativo e a forma original que 

J√∫lio C√©sar criou.  

Para finalizar a atividade, pe√ßa aos alunos que escolham outros valores para A e B e 

observem o  que  acontece.   Observe  o  qu√£o  desordenado  podem ficar as  letras de 

acordo o A cresce. Ser√° que ainda assim existe um padr√£o?  

Entendendo o aplicativo 

Pr√©-requisito: Conhecimento de Fun√ß√µes, divis√£o inteira. 

Agora √© chegada a hora de entender o que o aplicativo est√° fazendo, para embaralhar 

as letras da mensagem. 

Para cada letra do alfabeto, vem atribu√≠do no aplicativo um n√∫mero como na Figura 

19. 

Figura 19 Correspond√™ncia Letra-N√∫mero 

Fonte: O autor 

e a fun√ß√£o que ir√° criar uma bagun√ßa nestes n√∫meros, no caso da Criptografia Linear, 

essa fun√ß√£o √©  

 
 
 
 
 
  
 
59 

Em que o usu√°rio ir√° definir os valores de A e B. 

ùëì(ùë•) = ùê¥. ùë• + ùêµ 

Para  exemplificar,  vamos  utilizar  os  par√¢metros  ùê¥ = 3  e  ùêµ = 2  para  facilitar 

nosso entendimento. Quando digitamos a palavra B O L A, o aplicativo faz a atribui√ß√£o 

num√©rica de acordo a tabela acima, enxergando na verdade os n√∫meros 2‚Äì 15‚Äì 12 ‚àí 1, 

feito isso e j√° de posse dos par√¢metros, ele vai calcular a imagem de cada um destes 

n√∫meros atrav√©s da fun√ß√£o ùëì obtendo assim,  

ùëì(2) = 3.2 + 2 = 8 

ùëì(15) = 3.15 + 2 = 47 

ùëì(12) = 3.12 + 2 = 38 

ùëì(1) = 3.1 + 2 = 5 

Para finalizar, o sistema buscar√° estes novos n√∫meros na tabela, e ir√° troc√°-

los novamente por letras. √â ai que surge o primeiro problema. Os n√∫meros 8 e 5 est√£o 

na tabela, s√£o respectivamente as letras H e E, Logo o aplicativo ir√° encontr√°-los, mas 

o  que  fazer com  n√∫meros  maiores  que  26 que  n√£o  est√£o na  tabela,  neste  caso  os 

n√∫meros 47 e 38. Muito simples, os n√∫meros maiores que 26, ele vai dividi-los por 26 

e observar o resto desta opera√ß√£o. Assim, ao dividirmos 47 por 26, obtemos quociente 

1 e resto 21. Portanto ele buscar√° 21 na tabela que √© a letra U. Da mesma forma ele 

o far√° com o 38 obtendo 12 letra L, e assim, a palavra B O L A, passou ent√£o a ser 

escrita como H U L E.  

Uma analogia muito interessante sobre a forma de verificar estes restos, √© comparar 

com um rel√≥gio, sabemos que os ponteiros de um rel√≥gio marcam de 1 a 12., mas 

ainda assim o dia vai de 0 √†s 24h. Assim, para sabermos que horas s√£o as 17h da 

tarde, o que fazemos √© dividir 17 por 12 e observar o resto, 5, por isso 17h, s√£o 5 da 

tarde. De maneira an√°loga, ao completarmos 24h, temos que √© a 0h do dia seguinte, 

visto que 24 divido por 12 deixa resto 0. 

Para  as  chaves,  o  algoritmo  se  torna  um  pouco  mais  complexo.  Como  pode  ser 

observado, o programa retornou que as CHAVES PARA LEITURA s√£o ùê¥ = 9 e ùêµ = 8 

isso quer dizer, que se escrever a mensagem H U L E e trocar os valores de A e B 

 
60 

para 9 e 8, ao apertar o bot√£o criptografar, voc√™ obter√° a palavra B O L A novamente. 

Mas como isso √© feito. 

Bom, sabemos que uma fun√ß√£o ùëì(ùë•) = ùê¥. ùë• + ùêµ, admite fun√ß√£o inversa 

ùëì‚àí1(ùë•) = ùê¥‚àí1.ùë• ‚àí ùê¥‚àí1. ùêµ se ùê¥ ‚â† 0 

assim, o que o programa faz √© descobrir quanto vale ùê¥‚àí1 ou seja o inverso de ùê¥. 

Nessas condi√ß√µes por n√£o trabalharmos com n√∫meros reais, o inverso de A, 

n√£o pode ser um n√∫mero decimal, por exemplo, aqui, 5‚àí1 que √© o mesmo que 1
5

= 0,20 

n√£o  √©  considerado  veremos  que  no  nosso  problema  5‚àí1 = 21.  Como  assim?  Eu 

explico, 5.21 = 105 ao dividirmos 105 por 26 obtemos resto 1 afinal 105 = 26.4 + 1. √â 

assim  que  determinamos  os  inversos  de  um  n√∫mero  no  conjunto  que  estamos 

trabalhando (ùëç26). A Figura 20 mostra os produtos de todos os n√∫meros de 1 a 26 de 

acordo a regra estabelecida. Em destaque est√£o aqueles que possuem inverso. 

Figura 20 Inversos Multiplicativos em ‚Ñ§26 

Fonte: O autor 

. 

1234567891011121314151617181920212223242526246810121416182022240246810121416182022240369121518212414710131619222525811141720230481216202426101418220481216202426101418220510152025491419243813182327121722161116210612182441016222814200612182441016222814200714212916234111825613201815223101724512190816246142241220210180816246142241220210180918110192112031221413225142361524716258170102041424818212226160102041424818212226160112271831425102161721324920516112238194150122410228206184162140122410228206184162140130130130130130130130130130130130130130142164186208221024120142164186208221024120154198231211652092413217621102514318722110166221221882414420100166221221882414420100178251672415623145221342112320112191011890181022012422146241680181022012422146241680191252417103221581201362518114231692211470201482221610424181260201482221610424181260211611612217127223181383241914942520151050221814106224201612840221814106224201612840232017141185225221916131074124211815129630242220181614121086420242220181614121086420252423222120191817161514131211109876543210260000000000000000000000000 
 
61 

Para n√∫meros maiores que 26, lembrem-se sempre de encontrar o resto dele 

por 26 e olhar na tabela. Repare que alguns n√∫meros n√£o possuem inverso, isto ocorre 

porque o MDC dele e 26 √© diferente de 1, por isso no app h√° uma notifica√ß√£o, onde o 

o MDC de A e 26 precisa ser 1. 

Finalmente,  j√°  sabemos  como foi  gerado  a Chave  para  Leitura A (vamos  denot√°-la 

aqui por  ùê¥ùê∑ chave para decifrar), seguindo no nosso exemplo,  em que escolhemos         

ùê¥ = 3,  provavelmente  ele  deve  ter te  retornado,  segundo  a  tabela,  uma  chave  para 

leitura ùê¥ùê∑ = 9. Para encontrar a Chave para Leitura ùêµùê∑, basta realizar a multiplica√ß√£o 
de ùê¥ùê∑. ùêµ visto que nossa fun√ß√£o inversa √© ùëì‚àí1(ùë•) = ùê¥‚àí1. ùë• ‚àí ùê¥‚àí1. ùêµ . Lembre-se       ùê¥‚àí1 =
ùê¥ùê∑. 

Assim,  ùê¥ùê∑. ùêµ = 9.2 = 18.  Caso  o  valor  tivesse  ultrapassado  26,  iriamos 

novamente procurar o resto dele por 26. Por√©m, observe que o segundo membro da 

fun√ß√£o inversa √© negativo, logo seria ‚àí18 o resultado correto, por√©m o programa deve 

ter lhe retornado 8. Isso ocorre devido ao fato de que os restos de uma divis√£o sempre 

s√£o positivos, assim, se pensarmos quanto falta para 18 chegar a 26, iriamos perceber 

que √© 8, exatamente o resto procurado. Pensemos de outra forma. Imagine o nosso 

rel√≥gio  que  marca  26  horas  de  uma  dia,  o  rel√≥gio  anda  no  sentido  hor√°rio.  Se 

pensarmos no menos como uma mudan√ßa de sentido (anti-hor√°rio), ent√£o o rel√≥gio 

andar -18h iria marcar 8h. Acompanhe na Figura 21:  

Figura 21 Rel√≥gio de 26 horas 

Fonte: O autor 

 
 
62 

Da√≠ surge, ent√£o, as chaves que ser√£o utilizadas para decifrar o c√≥digo. 

Tente  sugerir  aos  alunos  que  tentem  eles  mesmos  descobrir  as  Chaves  de 

Leitura, com o aux√≠lio da tabela e do rel√≥gio acima. 

Como exemplo, fa√ßamos para ùê¥ = 7 e ùêµ = 10. 

Como vimos, pela tabela o inverso de 7 √© 15. Assim, temos que ùê¥ùê∑ = 15. Para 

encontrarmos  ùêµùê∑  devemos  inicialmente  fazer  a  opera√ß√£o  ùê¥ùê∑. ùêµ  neste  caso  15.10, 

obtendo  150.  Olhando  para  o  resto  da  divis√£o  de  150  por  26,  temos  20,  pois              

150 = 5.26 + 20,  voltemos  ent√£o  20h  no  sentido  anti-hor√°rio  e  iremos  determinar        

ùêµùê∑ = 6. Portando ùê¥ùê∑ = 15 e ùêµùê∑ = 6. Confira com o aplicativo. 

Conclus√£o da Atividade 

Ao  t√©rmino  desta  atividade,  espera-se  que  os  alunos  tenham  entendido 

conceitos  introdut√≥rios  da  aritm√©tica  modular,  pode-se  utilizar  esta  atividade  como 

porta de entrada para o estudo de divisibilidade e congru√™ncia. 

Alguns  alunos  j√°  devem  ter  observado  e  talvez  at√©  clicado  no  bot√£o 

compartilhar,  que  existe  no  aplicativo.  Ele  funciona  simplesmente  para  enviar  a 

mensagem  que  foi  cifrada  via  algum  aplicativo  de  conversa√ß√£o.  Surge  a√≠  um 

questionamento  interessante,  digamos  que  voc√™  deseja  enviar  uma  mensagem  a 

algu√©m  em  uma  situa√ß√£o  um  pouco  turbulenta,  onde  ningu√©m  pode  ler  est√° 

mensagem. Voc√™ percebeu que ao compartilhar a mensagem, para que seu colega 

leia,  ele  precisar√°  da  chave  de  leitura?  Ou  seja,  ter√≠amos  que  ter  um  canal 

superseguro para enviar essa chave a ele. Mas hora se tiv√©ssemos esse canal, n√£o 

ter√≠amos necessidade de enviar a mensagem.  

Eis ent√£o que acabamos de perceber que o nosso sistema de criptografia, n√£o 

√©  t√£o  eficiente  quanto  esper√°vamos,  afinal  as  pessoas  envolvidas  nas  trocas  de 

mensagens, precisariam manter um certo contato em algum momento. 

Bom, √© a√≠ que surge uma nova forma de criptografar, um m√©todo que ir√° acabar 

com este problema A Criptografia de Chave P√∫blica.  

 
 
 
63 

4.4. SUGEST√ÉO II ‚Äì Criptografia de Chave P√∫blica 

Dura√ß√£o:100 minutos/ 2 aulas 

Objetivos:  Entender o  algoritmo de  Criptografia  de  Chave  P√∫blica.  Compreender o 

que √© uma assinatura digital e qual a sua import√¢ncia. 

S√©rie: A partir do 1¬∫Ano do Ensino M√©dio 

Pr√©-requisitos: N√£o h√° 

Mas o que seria chave p√∫blica? 

Nesta  atividade,  queremos  que  o  aluno  compreenda  o  conceito  de  chave 

p√∫blica, atrav√©s do aplicativo CodeClass. N√£o iremos avan√ßar nesta atividade sobre 

como funciona o aplicativo nem quais formas de faz√™-lo, simplesmente queremos que 

o aluno entenda a ess√™ncia do funcionamento da criptografia, onde os dois envolvidos 

na  comunica√ß√£o,  em  momento  algum  precisar√£o  de  um  canal  seguro  para  passar 

informa√ß√£o. 

ATIVIDADE 1 

Para  a  atividade,  precisamos  de  algumas  chaves  que  ser√£o  utilizadas  na 

din√¢mica. Como o foco sobre a gera√ß√£o das chaves ser√° dado na proposta seguinte, 

abaixo seguem alguns exemplos de chave que poder√£o ser utilizados. 

Figura 22 Sugest√µes de Chaves para Atividade 

CHAVE 1 

CHAVE 2 

CHAVE 3 

CHAVE 4 

CHAVE 5 

CHAVE 6 

(n,Publica) 

(33,3) 

(187,3) 

(209,7) 

(95,5) 

(1243,3) 

(649,3) 

(n,Privada) 

(33,7) 

(187,107) 

(209,103) 

(95,29) 

(1243,747) 

(649,387) 

CHAVE 7 

CHAVE 8 

CHAVE 9 

CHAVE10 

CHAVE 11 

CHAVE 12 

(n,Publica) 

(1003,3) 

(493,3) 

(1711,3) 

(319,3) 

(1067,7) 

(1649,5) 

(n,Privada) 

(1003,619) 

(493,299) 

(1711,1083) 

(319,187) 

(1067,823) 

(1649,1229) 

Fonte: O autor 

 
 
 
 
 
64 

√â interessante, talvez, deixar todas as chaves p√∫blicas expostas, para que um 

aluno saiba um a do outro. Como normalmente as turmas possuem mais de 20 alunos, 

talvez  seja  interessante  dividi-los  em  grandes  grupos,  pois  dois  alunos  n√£o  podem 

compartilhar uma mesma chave. No sistema √© poss√≠vel gerar quantas chaves forem 

necess√°rias.  Pe√ßa-os  que  guardem  com  cuidado  as  suas  chaves  privadas  e  n√£o 

mostrem ao colega. 

Inicialmente, os alunos foram divididos em trios. Primeiro precisamos que eles 

compreendam como funciona a encripta√ß√£o neste sistema e quem √© o emissor e o 

receptor da mensagem. Emissor quem escreve, receptor quem recebe. 

Pe√ßa aos alunos que abram o aplicativo CodeClass. Em seguida cliquem no 

bot√£o CRIPTOGRAFIA RSA depois CRIPTOGRAFAR MENSAGEM. 

Na nova tela, aparecem alguns campos que precisam ser preenchidos. Neles 

solicitam chaves p√∫blicas e privadas.  Nesse momento somente 2 alunos do trio ir√£o 

participar. Um aluno ir√° pegar a chave p√∫blica do colega para enviar uma mensagem 

a  ele.  Por  exemplo,  no  trio  de  Jo√£o,  Ana  e  Pedro,  digamos  que  eles  est√£o 

respectivamente com as Chaves 1, 2 e 3, da Figura 22. Jo√£o mandar√° uma mensagem 

a Ana, ent√£o logo ele deve preencher os campos Chave P√∫blica do Receptor ùëõ = 187 

e ùê∂ùëùùë¢ùëè = 3, que s√£o as chaves de p√∫blicas de Ana, que qualquer um pode ter acesso. 

Em seguida, ele deve escrever a mensagem nos 10 campos dispon√≠veis abaixo 

colocando  uma  letra, em  mai√∫sculo,  em  cada  campo.  Nesta  primeira  parte, n√£o h√° 

necessidade ainda de assinar, pois este n√£o √© o nosso foco por enquanto. Finalmente 

ao apertar o bot√£o CRIPTOGRAFAR ser√° gerada uma  sequ√™ncia num√©rica abaixo, 

que s√£o os n√∫meros que ser√£o enviados a Ana. 

√â importante que sejam respeitados os espa√ßamentos entre  os n√∫meros por 

exemplo,  no  nosso  caso  enviando  a  Ana  a  mensagem  O  L  A  Q  U  E  R  I  D  A,  os 

n√∫meros obtidos foram: 

9‚Äì 45‚Äì 1‚Äì 51 ‚àí 98‚Äì 125‚Äì 35‚Äì 168‚Äì 64‚Äì 1 

Esse espa√ßamento √© fundamental para que Ana consiga decifrar a mensagem. 

 
65 

Agora, Jo√£o deve anotar a mensagem num papel e enviar a Ana, caso prefira, 

ele  pode  escrever  o  nome  dele  no  campo  Autor  da  mensagem  e  compartilhar 

utilizando a fun√ß√£o do pr√≥prio aplicativo. Por√©m a ideia neste momento √© que Jo√£o 

entregue a mensagem a Pedro e que ele entregue a Ana, nesse meio tempo, Pedro 

deve  tentar  descobrir  qual  a  mensagem  que  foi  enviada  com  a  fun√ß√£o  DECIFRAR 

MENSAGEM. 

A fun√ß√£o de decifrar do aplicativo, √© parecida com a fun√ß√£o de cifrar. O receptor 

da mensagem, no caso Ana,  ir√° digitar a sequ√™ncia num√©rica recebida, cada bloco 

num√©rico em um campo como na foto abaixo. Em seguida digitar√° sua chave privada, 

neste caso, ùëõ = 187, ùê∂ùëùùëüùëñùë£ùëéùëëùëé = 107. Observe que as chaves privadas s√£o senhas e 

nunca devem ser expostas. Os n√∫meros ser√£o alterados, e para finalizar, basta que 

Ana  pressione  o  bot√£o  CONVERTER  PARA  TEXTO,  para  que  ela  possa  ter  a 

mensagem traduzida. 

√â  interessante  perceber  que  Pedro  pode  tentar  v√°rias  combina√ß√µes  para 

descobrir a mensagem, talvez por tentativa ele consiga, por√©m ele n√£o tem nem no√ß√£o 

de quantos caracteres tem a senha de Ana. Pode-se aproveitar o momento para fazer 

uma previs√£o de quantas tentativas ele iria precisar. 

Assinando uma mensagem 

Qual a raz√£o de se assinar uma mensagem? Esta resposta encontramos pelo 

simples  fato  de  reconhecermos  a  import√¢ncia  de  garantir  que  o  receptor  n√£o  seja 

enganado por um falso emissor. Suponhamos, com base na nossa proposta anterior: 

O que impede Pedro de escrever uma mensagem criptografada para Ana e assinar 

como se fosse Jo√£o? Por termos uma chave p√∫blica, na pr√°tica, qualquer pessoa teria 

o nosso endere√ßo e poderia nos enviar qualquer mensagem. Imagine um falso banco 

nos enviando falsos boletos, como eu saberia se √© realmente do meu banco, ou n√£o? 

Portanto, pe√ßa aos alunos que abram o aplicativo, cliquem em CRIPTOGRAFIA 

RSA  em  seguida  CRIPTOGRAFAR  MENSAGEM.  Pe√ßam  que  realizem  o  mesmo 

procedimento,  da  parte,  vamos  exemplificar.  Pe√ßa  que  Jo√£o  envie  a  mesma 

mensagem para Ana, do mesmo modo que procedeu anteriormente, mas agora antes 

de clicar em criptografar, ele deve marcar a caixa Assinar Mensagem. 

 
66 

Na sequ√™ncia, ir√° aparecer dois campos solicitando o valor de ùëõ e ùê∂ùëùùëüùëñùë£. Jo√£o 

deve  inserir  nestes  campos  a  sua  senha  de  leitura,  sua  chave  privada.  N√£o  h√° 

problema em o fazer, pois os campos s√£o do tipo senha preservando o segredo da 

mensagem.  

Ao  mesmo  tempo,  Pedro  tamb√©m  deve  escrever  uma  mensagem  a  Ana,  e 

assin√°-la.  Como  Pedro  n√£o  conhece  as  credenciais  privada  de  Jo√£o,  ele  ter√°  que 

utilizar as suas pr√≥prias chaves privadas, ou n√£o suar nenhuma. 

Agora,  tanto  Pedro,  quanto  Jo√£o  devem  transmitir  a  sua  mensagem  a  Ana. 

Caso  eles  queiram  saber  sobre a  sua  identidade,  talvez  torne  o  processo  at√©  mais 

interessante. Por exemplo, tanto Pedro quanto Jo√£o, preenchem o campo Autor como 

Jo√£o, assim, Ana n√£o saberia qual o verdadeiro Jo√£o. 

Quando  Ana  receber  as  mensagens,  ela  dever√°  ir  na  tela  para  DECIFRAR 

MENSAGEM,  l√°  ir√°  proceder  do  mesmo  modo  que  antes,  por√©m  dever√°  marcar  o 

campo, MENSAGEM ASSINADA e l√° colocar as credenciais p√∫blicas (Chave P√∫blica) 

de  Jo√£o.  Nesse  momento,  se  ela  fizer  o  mesmo  processo  de  leitura  com  as 

mensagens  de  Jo√£o  e  de  Pedro,  ela  somente  ir√°  conseguir  ler  a  mensagem  do 

verdadeiro Jo√£o. Provavelmente a outra nem ser√° executada pelo aplicativo, podendo 

inclusive gerar erros, ‚Äúbugando‚Äù ou at√© mesmo fechando a aplica√ß√£o, pois o programa 

n√£o conseguir√° interpretar as mensagens. 

4.5. Aplica√ß√£o do CodeClass 

No dia 01 de Outubro de 2019, foi realizada uma oficina no Col√©gio Estadual 

Governador  Luiz  Viana  Filho,  na  cidade  que  Guanambi-BA,  com  o  intuito  de 

apresentar o aplicativo CodeClass e algumas das propostas metodol√≥gicas que foram 

fundamentadas  e  sugeridas.  Nesta  oficina,  tivemos  13  colaboradores,  entre 

professores  e  estudantes.  Dentre  eles,  tr√™s  professores  da  √°rea  de  ci√™ncias  da 

natureza e matem√°tica e os demais, alunos do 1¬∫ Ano do Ensino M√©dio, sendo um da 

turma 1¬∫AM, um da turma 1¬∫BM e oito da turma 1¬∫DM, tidas regulares nesta institui√ß√£o 

no turno matutino. 

A oficina foi realizada no per√≠odo da tarde, com in√≠cio √†s 14 horas e t√©rmino √†s 

16  horas  e  40  minutos.  Como n√£o  havia  tempo h√°bil  dispon√≠vel para  realiza√ß√£o  de 

 
67 

todas  as  propostas  sugeridas  neste  trabalho,  foi  elaborada  uma  proposta  que 

agregasse  um  pouco  de  cada  um  dos  temas  sugeridos  e  que  focasse  mais  na 

utiliza√ß√£o do aplicativo e explana√ß√£o te√≥rica dos conceitos que regem a criptografia 

de  modo  pr√°tico.  Deste  modo,  podemos  realizar  um  teste  das  funcionalidades  do 

sistema e se o mesmo √© adequado para ser utilizado pelos estudantes. 

4.5.1. A Oficina 

Para  que  pud√©ssemos  avaliar  a  atividade,  foi  elaborado  um  question√°rio 

subdivido em seis partes, e que se encontra dispon√≠vel no Anexo A. Este question√°rio 

foi preenchido pelos participantes no decorrer da atividade. Cada parte √© precedida 

de  uma  proposta  diferente  relacionada  a  criptografia,  associada  ao  que  queremos 

avaliar naquele instrumento. 

A Parte I, trata dos conhecimentos pr√©vios que o participante possui sobre os 

conte√∫dos que ser√£o abordados e foram respondidas antes do in√≠cio da proposta.   

A Parte II do instrumento, trata do  funcionamento do Sistema de Criptografia 

Linear e  visa  observar se os participantes foram  capazes de  conseguir  utilizar este 

sistema  criptogr√°fico.  Por  meio  deste,  tamb√©m  conseguiremos  observar  poss√≠veis 

causas de insucesso se este for o caso. Na Parte III, objetivamos avaliar se o conceito 

de  chave  p√∫blica  foi  compreendido  pelos  participantes.  A  quarta  e  quinta  partes 

relacionam-se  com  a  criptografia  RSA,  bem  como  a  utiliza√ß√£o  da  assinatura  RSA. 

Caso  os  participantes  tenham  alguma  dificuldade  em  utilizar  o  sistema,  este 

instrumento tamb√©m servir√° de registro para poss√≠veis falhas. 

Finalmente  a  √∫ltima  parte  do  question√°rio,  a  Parte  VI,  possui  perguntas  que 

direcionam  a  coleta  de  informa√ß√µes  a  respeito  da  impress√£o  do  usu√°rio  quanto  a 

interface do sistema, o qual iremos investigar opini√£o do utilizador, bem como suas 

impress√µes quanto a usabilidade do CodeClass. 

Parte I 

A  primeira  parte  buscou  coletar  informa√ß√µes  quanto  ao  conhecimento  pr√©vio 

dos volunt√°rios. Foi observado que dos treze avaliados, todos desconheciam sobre a 

Cifra de C√©sar, apenas tr√™s em algum momento j√° ouviu falar sobre criptografia, mas 

questionados oralmente sobre onde eles podiam exemplificar aplica√ß√µes deste tema, 

 
68 

o geral n√£o soube. Um dos participantes alegou j√° conhecer superficialmente o tema, 

por ter iniciado um curso t√©cnico em Inform√°tica, mas n√£o deu continuidade. 

Uma  coisa  que  chamou  bastante  aten√ß√£o  neste  est√°gio  inicial,  foi  todos  os 

integrantes possu√≠rem aparelhos celulares, acessarem diariamente as redes sociais e 

at√© mesmo efetuarem transa√ß√µes financeiras no aparelho, mas mesmo assim nunca 

se questionaram sobre como √© tratada a seguran√ßa destes dados.  

Parte II 

O in√≠cio da oficina tratou da import√¢ncia da criptografia para nossa era digital, 

em decorr√™ncia da conscientiza√ß√£o da necessidade de escondermos informa√ß√µes e 

quem pode se beneficiar ou se prejudicar caso algo indevido seja exposto. 

Em seguida foi apresentada a Cifra de C√©sar e como C√©sar fazia para utiliz√°-

la  √†  sua  √©poca.  O  mais  interessante  foi  faz√™-los  perceber  como  a  matem√°tica  se 

relaciona com est√° cifra por meio de uma fun√ß√£o afim levando um n√∫mero em outro. 

Afinal, como a maioria dos alunos, eram do 1¬∫Ano Regular, o conte√∫do de fun√ß√µes √© 

amplamente  trabalhado  nesta  s√©rie  de  acordo  a  BNCC  [4].  Finalmente,  foi 

apresentado o passo a passo para se executar esta codifica√ß√£o no CodeClass. 

A atividade proposta foi cada um escolher dois par√¢metros, seja A, seja B, uma 

mensagem  de,  no  m√°ximo,  dez  caracteres  e  envi√°-la  ao  colega  mais  pr√≥ximo, 

juntamente  com  a  Chave  para  Leitura.  Por√©m,  essa  informa√ß√£o  n√£o  podia  ser 

entregue diretamente, devendo antes passar pelo mediador da oficina que tentaria de 

todas as formas ler as informa√ß√µes trocadas. A ideia era que eles percebessem que 

as mensagens n√£o estavam seguras visto que a senha para decodificar se encontrava 

no papel. 

Como forma de auxili√°-los e de facilitar o acompanhamento em caso de erro ou 

distor√ß√µes,  foram  utilizados  cart√µes  para  que  preenchessem  com  a  mensagem 

codificada e enviassem a um colega. 

 
 
69 

Figura 23 Cart√£o da Parte II Criptografia Linear 

Fonte: O autor 

Neste cart√£o, o autor da mensagem iria escrever uma mensagem codificada 

pelo aplicativo e envi√°-la para o receptor, juntamente com a chave para decodific√°-

la. Em seguida o receptor caso conseguisse decifrar a mensagem com o aplicativo 

deveria escrev√™-la na parte inferior destinada a isto. 

A Figura 23, foi um exemplo de mensagem que um dos participantes enviou. 

Nesta  etapa  todos  conseguiram  se  comunicar.  Um  dos  receptores  n√£o  conseguiu 

decodificar a mensagem  pois,  o autor colocou  as  chaves  de  leitura  invertidas,  mas 

verificado o problema, o mesmo teve √™xito na execu√ß√£o da atividade. 

Muito  alunos  perceberam  que  havia  algo  errado  em  ter  que  enviar  a  senha 

junto,  comentando  em  alguns  casos.  Dentre  algumas  falas,  foi  registrado,  em 

anota√ß√µes de campo a de um estudante: 

‚ÄúU√©, professor. Enviar essa senha t√° meio estranho‚Äù 
‚ÄúE se algu√©m roubar a senha no caminho?‚Äù 

 
 
 
 
70 

Figura 24 Resposta de um aluno √† Parte II 

Fonte: O autor 

A Figura 24 mostra a resposta de um dos participantes √† Parte II do 

question√°rio. 

Parte III 

Ap√≥s todos conseguirem terminar a atividade proposta, foi feita uma din√¢mica 

para  tentarmos  apresentar  o  conceito  de  chave  p√∫blica.  Na  din√¢mica,  dois  alunos 

foram escolhidos para trocar informa√ß√µes atrav√©s de uma caixa. Por√©m, essa caixa 

n√£o poderia ir sem um cadeado, pois no meio do caminho havia um terceiro aluno que 

tentaria  abri-la.  Assim,  eles  deveriam  bolar  uma  estrat√©gia  para  trocar  as  caixas, 

mantendo o conte√∫do em seguran√ßa.  

Os participantes, de maneira coletiva, tentaram bolar um plano para conseguir 

cumprir a atividade, mas sem √™xito. Houve ent√£o a necessidade da interfer√™ncia do 

mediador,  que  sugeriu  colocar  os  dois  cadeados  na  caixa.  Neste momento  um dos 

alunos conseguiu dar uma sugest√£o que completasse o desafio.  

 
 
 
 
71 

A  solu√ß√£o  deste  problema,  consistem  em  enviar  a  caixa  com  a  mensagem 

dentro, trancada com o primeiro cadeado. Ao receber a caixa, o receptor ir√° colocar o 

seu cadeado na caixa e envi√°-la de volta para o primeiro usu√°rio, que ir√° retirar o seu 

cadeado e novamente envi√°-la para o receptor. Que poder√° finalmente abrir o √∫ltimo 

cadeado e revelar o seu conte√∫do. 

Nos  question√°rios  percebemos  que  somente  um  dos  participantes  n√£o 

conseguiu  compreender  a  funcionamento  desta  estrat√©gia.  Marcando  que  seriam 

necess√°rias mais que tr√™s ‚Äúviagens da caixa‚Äù para o envio da informa√ß√£o. 

Parte IV 

O  objetivo  da  Parte  IV,  era  simular  um  sistema  de  troca  de  mensagens  pelo 

canal utilizando o sistema RSA. Primeiramente utilizamos o aplicativo para gerar as 

chaves  p√∫blicas e  privadas  de  cada  um dos  alunos presentes.  Estas  chaves foram 

inseridas  nos  question√°rios  para  que  ap√≥s  a  finaliza√ß√£o  da  atividade  pud√©ssemos 

testas. 

Verificamos que todas as chaves foram geradas com sucesso, por√©m um dos 

participantes  n√£o  conseguiu  utilizar  primos  maiores  que  17  para  gera√ß√£o  de  suas 

chaves.  O  aplicativo  era  finalizado  toda  vez  que  este  tentava  acrescentar n√∫meros 

maiores. Ainda n√£o conseguimos identificar o erro que aconteceu unicamente em um 

aparelho da marca Samsung modelo J5 Prime. 

Ap√≥s  cada  um  ter  gerado  as  suas  chaves,  todas  as  chaves  p√∫blicas  foram 

divulgadas no quadro, para facilitar o processo de envio. Em seguida foram solicitados 

a escrever a mensagem ao colega no cart√£o correspondente para que fosse enviada 

atrav√©s do Canal. Quando todos terminaram de redigir sua mensagem, o ministrante 

se passando pelo Canal, recolheu todos os cart√µes para entreg√°-los aos respectivos 

destinat√°rios  que  iriam  realizar  as  suas  respectivas  decodifica√ß√µes.  Na  Figura  25, 

segue um exemplo dos cart√µes enviados. 

 
72 

Figura 25 Troca de mensagens utilizando Criptografia RSA. Parte IV 

Fonte: O autor 

Nesta etapa todos os alunos conseguiram efetuar a leitura de suas mensagens 

de maneira correta, por√©m alguns n√£o a registraram no cart√£o, mantendo somente a 

decodifica√ß√£o no aparelho. 

Nesta etapa, foi inserida tamb√©m uma jogada surpresa por parte do ministrante. 

Sem  que  os  alunos  soubessem,  enquanto  os  autores  estavam  redigindo  as 

mensagens, foram confeccionados cart√µes falsos pelo mediador, que seriam trocados 

na hora da entrega da seguinte forma.: 

A  aluno A,  enviou  para  o  aluno  B  uma  certa  mensagem.  O  mediador  havia 

previamente  confeccionado  um  cart√£o  falso  do  aluno  A  para  o  B  e  efetuou  a 

substitui√ß√£o  do  cart√£o  verdadeiro  pelo  falso  no  momento  da  entrega.  Ap√≥s  a 

decodifica√ß√£o, eles foram surpreendidos pela mensagem da Figura 26. 

 
 
73 

Figura 26 Cart√£o falso, confeccionado pelo mediador. 

Fonte: O autor 

Os  participantes  come√ßaram  a  questionar  sobre  a  seguran√ßa  e  debatendo 

sobre o que poderia ter acontecido. Sozinhos chegaram a conclus√£o de que os cart√µes 

haviam sido alterados. Neste momento um aluno questionou: 

‚Äú Como eu vou ter certeza que foi o ‚Äúaluno A‚Äù que enviou a mensagem para mim? ‚Äù 

Aluno B 

Parte V 

A Parte V e a √∫ltima que envolve a utiliza√ß√£o do aplicativo, veio para responder 

o questionamento do aluno ao final da Parte IV. Como ter a certeza da autenticidade 

do remetente?  

Foram apresentados durante a atividade, exemplos de situa√ß√µes pr√°ticas onde 

necessitamos verificar quem de fato √© o remente, como nos casos dos e-mails. Foi 

apresentado o seguinte e-mail da Figura 27. 

 
 
 
74 

Figura 27 E-mail falso 

Fonte: O autor 

Ap√≥s a explana√ß√£o, os participantes perceberam como √© importante no meio 

digital garantir a veracidade de uma informa√ß√£o, afinal caso acredit√°ssemos que o e-

mail  era  de  fato  do  Banco  Bradesco,  poder√≠amos  colocar  a  integridade  do  nosso 

computador em risco pois, muito provavelmente este link levaria a algum Malware que 

infectasse nossa m√°quina. 

A  din√¢mica  desta  √∫ltima  parte,  consistia  em  realizar  a  codifica√ß√£o  de  uma 

mensagem, utilizando tamb√©m a fun√ß√£o de Assinatura do aplicativo CodeClass. Esta 

etapa exigia um cuido a mais dos alunos, pois qualquer erro de digita√ß√£o por parte do 

autor, iria inviabilizar o processo de decodifica√ß√£o.  

O processo n√£o ocorreu da maneira devida, pois o aplicativo apresentou um 

erro  na  decodifica√ß√£o,  que  os  alunos  n√£o  conseguirem  contornar  e  isto  acabou 

interferindo negativamente nesta etapa final. 

O  erro  apresentado  em  todos  os  aparelhos,  foi  identificado  como  sendo  na 

programa√ß√£o  do  sistema,  ap√≥s  uma  pequena  altera√ß√£o  que  havia  sido  feita  no 

aplicativo. A imagem da Figura 28, √© a codifica√ß√£o da mensagem T O M E C U I D A 

D, que o participante E enviou ao participante R, utilizando a fun√ß√£o assinatura. 

 
 
75 

Figura 28 Troca de mensagens entre E e R utilizando assinatura. 

Fonte: O autor 

Ap√≥s comparar os question√°rios, conseguimos identificar as chaves p√∫blicas 

e privadas de ambos participantes, para que pud√©ssemos simular o processo e 

entender a origem do erro. 

O participante E que √© autor da mensagem, possu√≠a Chave P√∫blica: ùëõ = 6901 

e ùê∂ùëùùë¢ùëè = 5 e Chave Privada: ùëõ = 6901 e ùê∂ùëùùëüùëñùë£ = 2693, como pode ser verificado na 

Figura 29. 

Figura 29 Chaves do Autor E 

 
 
 
76 

Fonte: O autor 

J√° o usu√°rio R, possu√≠a a Chave P√∫blicas e Privadas respectivamente ùëõ =

946, ùê∂ùëùùë¢ùëè = 3 e ùëõ = 943, ùê∂ùëùùëüùëñùë£ = 587. 

A codifica√ß√£o feita por E, foi correta, por√©m, na decodifica√ß√£o, quando R 

inseriu os dados no aplicativo juntamente com a sua Chave Privada e a Chave 

P√∫blica do autor, obteve o resultado como da Figura 30 

Figura 30 Resultado apresentado na decodifica√ß√£o 

Fonte: O autor 

Observe  que  os  n√∫meros  apresentados  deveriam  ser  menores  que  26,  para 

que fosse poss√≠vel converter a mensagem em texto. Conclu√≠mos ent√£o que o sistema 

n√£o codificou corretamente a mensagem. Por√©m caso pression√°ssemos novamente 

o  bot√£o  DECODIFICAR  MENSAGEM,  ir√≠amos  perceber  que  a  mensagem  seria 

decodificada corretamente. 

 
 
77 

Figura 31 Mensagem ap√≥s segunda tentativa de decodifica√ß√£o 

Fonte: O autor 

Por√©m  ainda  apresentado  erro,  pois  o  bot√£o  de  convers√£o  para  texto  n√£o 

apareceu, tornando necess√°ria uma convers√£o manual utilizando a correspond√™ncia 

da  Figura  5.  Com  isso,  a  etapa  proposta  n√£o  obteve  o  sucesso  esperado,  mas  foi 

explanado aos participantes sobre o problema e realizado um exemplo coletivamente 

de decodifica√ß√£o com assinatura. 

Parte VI 

Finalmente  a  √∫ltima  parte  do  question√°rio  tratava  sobre  as  percep√ß√µes  do 

participante  a  respeito  da  oficina  e  do  aplicativo.  Buscamos  coletar  informa√ß√µes  a 

respeito da din√¢mica da oficina, interface e usabilidade do CodeClass. 

Devido a finaliza√ß√£o da oficina prevista para as 16:30 e ter se estendido at√© √†s 

16:40, muitos alunos tiveram de sair apressadamente deixando parte da sexta parte 

incompleta. 

Dos  que  avaliaram  o  aplicativo,  pudemos  perceber  que  no  geral,  avaliaram 

positivamente  a  interface  e  boa  usabilidade.  Por√©m  o  ponto  que  mais  chamou  a 

aten√ß√£o, foi a  o erro  na  √∫ltima  tarefa.  O aplicativo  nesta  etapa  recebeu  notas  mais 

baixas na avalia√ß√£o.  

 
 
78 

De  um  modo  geral,  pudemos  perceber  que  os  participantes  avaliaram 

positivamente a atividade e a forma como estes conte√∫dos, que eram desconhecidos 

por  muitos,  foram  trabalhados.  Os  docentes  envolvidos  acharam  a  oficina  ‚Äúbem 

interativa e din√¢mica‚Äù.  

Julgaram tamb√©m que a oficina deveria ser dividida em mais se√ß√µes afim de 

diluir as informa√ß√µes passadas, dando tempo para: ‚Äúdigerir todas as informa√ß√µes‚Äù que 

se faziam presentes. 

 
 
 
79 

5.   RESULTADOS E DISCUSS√ïES  

Tentaremos  apresentar  agora  um  paralelo  de  todo  o  processo  que  foi 

desenvolvido  desde  o  in√≠cio  deste  projeto  at√©  o  momento,  apresentado  as  falhas  e 

acertos que obtivemos durante toda a execu√ß√£o do mesmo. 

1.1. Confec√ß√£o do CodeClass 

Durante o desenvolvimento do aplicativo, pudemos perceber a necessidade de 

compreender  processos  mais  avan√ßados  de  programa√ß√£o,  para  que  seja  poss√≠vel 

reduzir  o  tempo  de  execu√ß√£o  de  muitas  tarefas  que  o  CodeClass  executa. 

Acreditamos  que  o  aplicativo  ainda  √©  muito  primitivo  neste  ponto,  pois  faz-se 

necess√°rio ainda a execu√ß√£o de tarefas repetidas para obter certo resultado. 

Al√©m disso, gostar√≠amos de tornar a entrada de informa√ß√µes mais intuitiva, de 

modo que fosse mais f√°cil para o usu√°rio inserir os dados na plataforma. Imagine voc√™ 

simplesmente  poder  a  mensagem  em  um  √∫nico  campo  e  o  sistema  conseguir 

identificar cada caractere independente de ser mai√∫scula ou min√∫scula. Estas ser√£o 

provavelmente melhorias nas pr√≥ximas atualiza√ß√µes do aplicativo do CodeClass. 

Um outro  processo  que  identificamos falhas, foi  na  gera√ß√£o das  chaves.  Por 

mais que funcione, o tempo de execu√ß√£o aparenta ainda ser extenso. Visto que para 

n√∫meros relativamente pequenos a partir 600, n√£o conseguimos concluir a tarefa pela 

demora  na  execu√ß√£o.  Isto  se  d√°  pelo  fato  do  algoritmo  utilizado  na  resolu√ß√£o  da 

Equa√ß√£o  Diofantina,  necess√°ria  na  gera√ß√£o  das  chaves,  n√£o  ser  eficiente,  vide     

Anexo 2.  

Acreditamos  que  estes  processos  podem  ser  otimizados,  com  o  aux√≠lio  de 

algum  colaborador  na  √°rea  de  computa√ß√£o.  Sabemos  tamb√©m  da  limita√ß√£o  da 

plataforma  em  que  o  mesmo  foi  desenvolvido.  E  por  isso  ainda  √©  um  desafio 

conseguirmos encontrar meios de contornar certas demandas. 

Um resultado que j√° obtivemos em umas das atualiza√ß√µes feitas antes mesmo 

da  utiliza√ß√£o  do  aplicativo,  foi  a  altera√ß√£o  do  algoritmo  que  faz  a  verifica√ß√£o  dos 

primos. 

 
 
 
80 

Na tela de gera√ß√£o dos primos, utilizamos um algoritmo apresentado  em um 

v√≠deo  do projeto  Matem√°tica  com  Aplicativos,  que pode  ser acessado  em  [13],  que 

utiliza  o  Teorema  de  Wilson,  na  sua  confec√ß√£o.  Para  gera√ß√£o  dos  primos,  ele  se 

mostra bastante eficiente, visto que √© poss√≠vel armazenar o valor anterior na mem√≥ria 

e reutiliz√°-lo para determinar o pr√≥ximo primo. Por√©m quando tivemos que montar uma 

rotina para verificar a primalidade de certo n√∫mero, este algoritmo n√£o se mostrou t√£o 

eficiente quanto a for√ßa bruta (testar n√∫mero por n√∫mero at√© obtermos um divisor ou 

n√£o). Visto que este teste deve ser feito somente com os √≠mpares at√© a raiz do primo 

que desejamos verificar. 

1.2. Oficina 

Na oficina podemos perceber como a criptografia ainda √© pouco difundida nos 

meios p√∫blicos. Mais impressionantes ainda √© observar como a seguran√ßa na internet 

√©  pouco  discutida.  O n√∫mero de  ataques  cibern√©ticos  s√≥  tem  aumentado no  Brasil, 

chegando a dobrar em 2018 segundo reportagem do Canaltech dispon√≠vel em [15]. 

Ainda  assim,  percebemos  o  quanto  que  as  pessoas  pouco  sabem  ou  n√£o  se 

interessam  pelam  tema.  Quando  realiz√°vamos  a  divulga√ß√£o  da  oficina,  poucas 

pessoas apresentaram interesse no assunto. 

Durante  as  oficinas,  percebemos  que  um  ponto  que  foi  bastante  comentado 

pelos participantes foi a Criptografia Linear. Percebemos que eles gostaram bem mais 

desta do que da RSA. Talvez por ser mais simples de se entender os exemplos da 

Cifra  de  C√©sar  que  ilustra  bastante  o  tema.  Ela  foi  crucial  tamb√©m  para  poderem 

comparar o que difere a Linear da RSA quanto a ter a chave p√∫blica exposta.  

Encontramos ent√£o uma aplica√ß√£o para as Fun√ß√µes Afim, juntamente com a 

Aritm√©tica Modular, abordada normalmente em livros do Ensino M√©dio. Al√©m disso, o 

fato dos alunos poderem participar da atividade com o celular a todo momento em seu 

porte, os motivou a querer prestar mais aten√ß√£o na proposta. 

 
 
 
 
 
 
 
81 

6.   CONSIDERA√á√ïES FINAIS 

A  criptografia  busca  utilizar  diversos  m√©todos  n√£o  s√≥  matem√°ticos  para 

esconder informa√ß√µes, como foi o caso da Citale Espartana. Exatamente por isso, √© 

uma porta de entrada para tratar de diversos assuntos presentes no curr√≠culo n√£o s√≥ 

do ensino m√©dio, como tamb√©m fundamental. 

N√£o precisamos montar um sistema complexo, ou mesmo superseguro para se 

trabalhar criptografia dentro da sala de aula. O que precisamos √© encontrar formas de 

torn√°-la acess√≠vel e pr√°tica. Podemos criar diversas t√©cnicas de se criptografar uma 

mensagem utilizando muitos conte√∫dos da disciplina de matem√°tica, as tem√°ticas que 

abordamos  aqui  s√£o  apenas  uma  pontinha  de  um  leque  vasto  e  diversificado  de 

sistemas. 

Uma busca r√°pida pelo reposit√≥rio de disserta√ß√µes do PROFMAT, j√° √© poss√≠vel 

identificar quase 70 trabalhos que visam trazer aplica√ß√µes de criptografia no ensino 

m√©dio. Estes, buscam aplicar alguns conte√∫dos como matrizes, res√≠duos quadr√°ticos, 

recorr√™ncias e fun√ß√µes. Isso mostra que √© poss√≠vel trazer para sala de aula, fatos que 

sejam realmente relevantes para o aluno. √â poss√≠vel dar um sentindo e uma aplica√ß√£o 

pr√°tica ao emaranhado de n√∫meros e opera√ß√µes matem√°ticas. 

Al√©m  disso,  torna-se  poss√≠vel  despertar  um  senso  cr√≠tico  nos  alunos, 

instigando-os a discutir se √© poss√≠vel ‚Äúcriar‚Äù criptografias com uma fun√ß√£o afim, mas o 

porqu√™  de  n√£o  o  faz√™-la  com  a  fun√ß√£o  quadr√°tica.  Ser√°  que  podemos  modificar  a 

fun√ß√£o do segundo grau para que possamos utiliz√°-la? 

Alguns m√©todos ainda, s√£o muito menos falados, mas poder√≠amos ainda citar 

o Criptex supostamente elaborado por Leonardo da Vinci que Dan Brow apresenta em 

seu  livro  e  que  posteriormente  virou  filme  O  C√≥digo  da  Vinci  [16].  Um  cofre,  que 

necessita  de  uma  senha  para  revelar  seu  conte√∫do  e,  se  for√ßado  libera  uma 

subst√¢ncia em seu interior que destr√≥i a mensagem. √â a Geometria e a Engenharia 

juntas  para  esconder  segredos  e  aumentar  ainda  mais  a  gama  do  que  pode  ser 

trabalhado.  

Montamos  uma  proposta  que  ainda  tem  muito  a  amadurecer  e  ser 

aperfei√ßoada,  e  que  foi  bem  aceita  pelos  estudantes.  Acreditamos  ainda,  que  seja 

poss√≠vel  agu√ßar  ainda  mais  o  interesse,  se  al√©m  de  apresentarmos  o  sistema, 

 
 
82 

trabalharmos  tamb√©m  a  programa√ß√£o  por  traz  do  aplicativo.  As  oportunidades  s√£o 

in√∫meras, resta agora tornarmos a criptografia cada vez mais popular. 

 
REFER√äNCIAS  

[1]  COUTINHO  S.  C.  N√∫meros  Inteiros  e  Criptografia  RSA.  Rio  de  Janeiro: 

IMPA, 2011. (Cole√ß√£o Matem√°tica e Aplica√ß√µes) 

[2]  SINGH, S. O livro dos c√≥digos. Record, Rio de Janeiro. Tradu√ß√£o de Jorge 

Calife, 2001. 

[3]  BAHIA  SECRETARIA  DA  EDUCA√á√ÉO.  Orienta√ß√µes  curriculares  para  o 

ensino  m√©dio  √°rea:  matem√°tica  /  Secretaria  da  Educa√ß√£o.  ‚Äì  Salvador: 

Secretaria 

da 

Educa√ß√£o, 

2015. 

Dispon√≠vel 

em 

<http://escolas.educacao.ba.gov.br/sites/default/files/private/midiateca/docum

entos/2017/matematica.pdf>. Acessado dia 03/10/2019. 

[4]  BRASIL.  Base  Nacional  Comum  Curricular.  Bras√≠lia.  MEC/SEF,  2019. 

Dispon√≠vel 

em 

:  

http://basenacionalcomum.mec.gov.br/images/BNCC_EI_EF_110518_versaof

inal_site.pdf>  Acessado em: 03/10/2019 

[5]  SANTOS J. P. O. Introdu√ß√£o √† Teoria dos N√∫meros. -3 ed.- Rio de Janeiro: 

IMPA, 2018. 

[6]  HEFEZ, A. Aritm√©tica. Rio de Janeiro: SBM, 2016. 

[7]  MARTINEZ,  F.  B.  et  al.  Teoria  dos  N√∫meros:  um  passeio  com  primos  e 

outros n√∫meros familiares pelo mundo inteiro. Rio de Janeiro: IMPA, 2018. 

[8]  COMPUTA√á√ÉO  NA 

em 
<http://www.computacaonaescola.ufsc.br/?page_id=1656.>  Acessado  em 
13/08/2019).  

Somos.  Dispon√≠vel 

ESCOLA  Quem 

[9]  PROJETO COMPUTA√á√ÉO NA ESCOLA P√°gina do Projeto. Dispon√≠vel em: 

<http://www.computacaonaescola.ufsc.br/> .Acessado em 13/08/2019 . 

[10]  MIT  APP 

INVENTOR 

II  Acesso  a  Plataforma.  Dispon√≠vel  em: 

<http://ai2.appinventor.mit.edu/>  Acessado em : 19/09/2019.  

[11]  LEMOS  M.  Criptografia,  N√∫meros  Primos  e  Algoritmos.  Rio  de  Janeiro: 

IMPA, 2009. (Publica√ß√µes Matem√°ticas) 

[12]  ALVES  E.  A.  W.  Aplicativo  CodeClass  para  andriod.  CodeClass.apk  ‚Äì 

Dispon√≠vel 

em: 

<https://drive.google.com/open?id=1ZIGebePmMCXP6gXMrBTfBFWfoQGQX

a-j> ou Dispon√≠vel em: <https://is.gd/lniSDC> (encurtador de url). Acessado em: 

01/10/2019 

 
[13]  BARBOSA.  M.  A.  N√∫meros  Primos  -  Teorema  de  Wilson  -  MIT  App 

Inventor.  Dispon√≠vel  em:  https://www.youtube.com/watch?v=vyROeH5b7kg. 

Acessado em: 10/09/2019. 

[14]  BARBOSA.  M.  A.  Desenvolvendo  Aplicativos  Para  Dispositivos  M√≥veis 

Atrav√©s  Do  Mit  App  Inventor  2  Nas  Aulas  De  Matem√°tica.  2016.  144  f. 

Disserta√ß√£o (Mestrado em Matem√°tica) - PROFMAT, UESC, Bahia. 

[15]  WAKKA W. N√∫mero de ataques cibern√©ticos no Brasil quase que dobrou 

em  2018.  Dispon√≠vel  em:  <https://canaltech.com.br/seguranca/numero-de-

ataques-ciberneticos-no-brasil-quase-que-dobrou-em-2018-119600/> 

Acessado em: 30/09/2019 

[16]  BROW D., The Da Vinci code. First edition ed. New York: Doubleday, 2003. 

 
 
 
 
 
 
 
ANEXO A 

Criptografia e o CodeClass Uma Proposta Metodol√≥gica6 

Voc√™ √©: Estudante (    )     Professor (   ) 

Parte I ‚Äì Grau de Conhecimento 

1-  Voc√™ sabe o que √© criptografia? 

(  ) Sim 

(  ) N√£o 

2-  Caso  tenha  marcado  sim  na  Pergunta  1,  responda:  Voc√™  entende  a  import√¢ncia  da 

criptografia na nossa era digital? 
 (   ) Sim    

(  ) N√£o 

3-  J√° ouviu falar do termo Sistema de Chave P√∫blica? 

(   ) Sim    

(  ) N√£o 

4-  Voc√™ conhece a Cifra de C√©sar? 

(   ) Sim    

(  ) N√£o 

Parte II ‚Äì Criptografia Linear 

Escreva uma frase ou palavra de, no m√°ximo, 10 caracteres. Caso tenha menos letras, 

1- 
complete os espa√ßos vazios com a letra A. 

___   ___   ___   ___  ___  ___  ___   ___   ___   ___ 

2- Escolha dois n√∫meros para seus par√¢metros A e B. Cuidado, pois o par√¢metro A n√£o pode 

ser 1, nem par e nem m√∫ltiplo de 13. 

A = ___   

B = ___ 

3-  Utilizando o CodeClass, codifique a mensagem que voc√™ escolheu em na quest√£o 1. Em 

seguida, escreva-a no espa√ßo abaixo: 

___   ___   ___   ___   ___   ___   ___   ___   ___  ___ 

4-  Escreva as Chaves Para Leitura retornada pelo aplicativo no espa√ßo abaixo: 

5-  Envie a mensagem para seu parceiro (a) por meio do Canal. 

A = ___  B = ___ 

6  Atividade  elaborada  com  finalidade  de  pesquisa  na  √°rea  de  ensino  de  matem√°tica  vinculada  ao Programa  de 

Mestrado  Profissional  em  Matem√°tica  em  Rede  Nacional  (PROFMAT)  da  Universidade  Estadual  da  Bahia, 

campus Vit√≥ria da Conquista. 

 
 
 
 
 
 
 
 
 
 
                                                           
6-  Voc√™ percebeu alguma falha neste sistema? Se sim, cite-a: 

_______________________________________________________________________
_______________________________________________________________________
_______________________________________________________________________
__________________ 

Parte III ‚Äì Criptografia Chave P√∫blica 

1-  Voc√™ compreendeu o princ√≠pio de Codifica√ß√£o por Chave P√∫blica? 

(   ) Sim.    

(   ) Um pouco, ainda tenho algumas d√∫vidas.      (  ) N√£o Compreendi. 

2-  Quantas viagens a caixa teve que realizar para atingirmos o objetivo? 

(   ) 1  

(   ) 2    

(   ) 3 

(   ) 4+ 

3-  E quando tornamos a chave do cadeado p√∫blica, quantas viagens teve que realizar? 

(   ) 1  

(   ) 2    

(   ) 3 

(   ) 4+ 

Parte IV ‚Äì Criptografia RSA 

1-  Escolha dois n√∫meros primos P = ___  e Q = ___ menores que 400. 
2-  Gere as chaves p√∫blicas e privadas por meio do aplicativo CodeClass. 
3-  P√∫blica:  n=_________,Cpub________   Privada: n_________, Cpriv___________ 
4-  Torne P√∫blica a sua Chave (n,Cpub). 
5-  Escreva uma frase ou palavra de no m√°ximo 10 caracteres. Caso tenha menos letras, 

complete os espa√ßos vazios com a letra A. 

___   ___   ___   ___  ___  ___  ___   ___   ___   ___ 

1-  Codifique a mensagem utilizando a Chave P√∫blica do Destinat√°rio 

______   ______   ______   _______  ______  _______  _______   ______   _____ 

2-  Envie a mensagem para o receptor Por meio do Canal. 

3-  Voc√™ observou algum problema ou falha na seguran√ßa? 

(   ) Sim. Cite_______________ 

(   ) N√£o 

4-  Todos  receberam  suas  mensagens  corretamente?  Comente  se  voc√™  observou  alguma 

falha na seguran√ßa. 

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
__________________ 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Parte V ‚Äì Assinatura Digital 

1-  Escolha dois n√∫meros primos P = ___  e Q = ___ menores que 400. 
2-  Gere as chaves p√∫blica e privada atrav√©s do aplicativo CodeClass. 
3-  P√∫blica:  n=_________,Cpub________   Privada: n_________, Cpriv___________. 
4-  Torne P√∫blica a sua Chave (n,Cpub). 
5-  Escreva uma frase ou palavra de no m√°ximo 10 caracteres. Caso tenha menos letras, 

complete os espa√ßos vazios com a letra A. 

___   ___   ___   ___  ___  ___  ___   ___   ___   ___ 

6-  Digite a mensagem no campo adequado. Insira a Chave P√∫blica do Destinat√°rio, clique 
em Assinar Mensagem e Digite a sua Chave Privada (n,Cpriv). Codifique a mensagem: 

______   ______   ______   _______  ______  _______  _______   ______   _____ 

7-  Envie para o receptor por meio do Canal. 

8-  Deixe algum coment√°rio que chamou a sua aten√ß√£o neste procedimento. 

___________________________________________________________________________
___________________________________________________________________________
____________ 

Parte VI ‚Äì Sobre o Aplicativo 

1-  Voc√™  acredita  que  conseguiu  compreender  os  principais  conceitos  que  envolvem  a 

criptografia? 

(  ) Compreendi alguns conceitos     (   ) Compreendi a maioria dos conceitos

(  ) Compreendi todos os conceitos   (   ) N√£o compreendi muito bem 

2-  Das Partes II, III, IV, V da oficina, qual lhe chamou mais aten√ß√£o? E por qu√™? 

II (  )  

III (   )  

IV (   )  

V (   ) 

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
__________________ 

3-  Voc√™  sentiu  a  necessidade  de  compreender  como  s√£o  feitas  algumas  etapas  dos 

processos de codifica√ß√£o e decodifica√ß√£o? 

(   ) N√£o  

(   ) Sim. Qual? ________________________________ 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
4-  Para as perguntas abaixo, avalie de 1 a 5, onde 1 √© muito ruim e 5 excelente. 
5-  Quanto a interface do aplicativo ____. 
6-  Quanto a velocidade de processamento ___. 
7-  Quanto a forma como as telas est√£o dispostas ___. 
8-  Quanto a erros que apareceram durante a realiza√ß√£o das atividades ___. 

 
 
 
 
 
 
 
 
ANEXO B  

Parte do algoritmo de gera√ß√£o de chaves do Sistema RSA 

 
 
