UNIVERSIDADE ESTADUAL DO SUDOESTE DA BAHIA 

MESTRADO PROFISSIONAL EM MATEMÃTICA EM REDE 

NACIONAL â€“ PROFMAT 

ERLON ASSUNÃ‡ÃƒO WANDENKOLK ALVES 

CodeClass: o uso da tecnologia como recurso metodolÃ³gico no 

ensino da criptografia  

VitÃ³ria da Conquista/BA 

2019 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
UNIVERSIDADE ESTADUAL DO SUDOESTE DA BAHIA 

MESTRADO PROFISSIONAL EM MATEMÃTICA EM REDE  

NACIONAL â€“ PROFMAT 

ERLON ASSUNÃ‡ÃƒO WANDENKOLK ALVES 

CodeClass: o uso da tecnologia como recurso metodolÃ³gico no 

ensino da criptografia  

DissertaÃ§Ã£o  apresentada  ao  Mestrado  Profissional  em 

MatemÃ¡tica  em  Rede  Nacional  â€“  PROFMAT,  oferecido 

pela  Universidade  Estadual  do  Sudoeste  da  Bahia  â€“ 

UESB, como requisito necessÃ¡rio para obtenÃ§Ã£o do grau 

de  Mestre  em  MatemÃ¡tica.  Orientadora:  ProfÂª.  DrÂª 

Alexsandra Oliveira Andrade. 

VitÃ³ria da Conquista/BA  

2019 

 
 
 
 
 
 
 
 
 
 
 
 
 
  A478c      Alves, Erlon AssunÃ§Ã£o Wandenkolk.  

                       CodeClass: o uso da tecnologia como recurso metolÃ³gico no ensino da 

criptografia. / Erlon AssunÃ§Ã£o Wandenkolk Alves, 2019. 

                         91f. il.  
                         Orientador (a): Dra. Alexsandra Oliveira Andrade.  
                         DissertaÃ§Ã£o (mestrado) â€“ Universidade Estadual do Sudoeste 
                    da Bahia, Mestrado Profissional em MatemÃ¡tica em Rede Nacional â€“  
                    PROFMAT, VitÃ³ria da Conquista - BA, 2019. 
                          Inclui referÃªncias. 85 - 86. 

        1. Criptografia - Ensino. 2. CodeClass - Aplicativo. 3. AritmÃ©tica.  4. 
NÃºmeros primos. I. Andrade, Alexsandra Oliveira.   II. Universidade 
Estadual Sudoeste da Bahia, Mestrado Profissional em MatemÃ¡tica em 
Rede Nacional â€“ PROFMAT, VitÃ³ria da Conquista, III. T. 

CDD: 510 

CatalogaÃ§Ã£o na fonte: Juliana Teixeira de AssunÃ§Ã£o- CRB 5/1890 
UESB â€“ Campus VitÃ³ria da Conquista â€“ BA  

 
 
 
 
 
 
 
 
       
         
                  
 
   
 
 
 
 
 
                                                                                                   
                                                                                                      
                                                                              
 
                                  
                                                                                                                                       
                                                                                 
                           
 
ERLON ASSUNÃ‡ÃƒO WANDENKOLK ALVES 

CodeClass: o uso da tecnologia como recurso metodolÃ³gico no 

ensino da criptografia  

DissertaÃ§Ã£o  apresentada  ao  Mestrado  Profissional  em 

MatemÃ¡tica  em  Rede  Nacional  â€“  PROFMAT,  oferecido 

pela  Universidade  Estadual  do  Sudoeste  da  Bahia  â€“ 

UESB, como requisito necessÃ¡rio para obtenÃ§Ã£o do grau 

de Mestre em MatemÃ¡tica.  

BANCA EXAMINADORA 

_____________________________________________ 

Professora DrÂª.  Alexsandra Oliveira Andrade (Orientadora) 

Universidade Estadual do Sudoeste da Bahia â€“ UESB 

____________________________________________ 

Professor Dr. Flaulles Boone Bergamaschi 

Universidade Estadual do Sudoeste da Bahia â€“ UESB 

_______________ ___________________________ 

Professor Dr. Ronildo Pinheiro de AraÃºjo Moura 

Universidade Federal do Rio Grande do Norte 

VitÃ³ria da Conquista/BA  

2019 

 
 
 
 
 
 
 
 
O segredo da felicidade Ã©  

   a felicidade do segredo. 

    (desconhecido)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     
 
     
 
 
 
DEDICATÃ“RIA 

trabalho  a 

todos 
Dedico  este 
aqueles  apaixonados  nÃ£o  sÃ³  pela 
matemÃ¡tica,  mas  sim  apaixonados 
tambÃ©m  por  tornÃ¡-la  ainda  mais 
apaixonante. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Finalmente, o momento de escrever os agradecimentos, este que prometi fazer 

somente  ao  conseguir  findar  este  trabalho.  Foram  tantos  colaboradores  diretos  e 

indiretos que esquecer o nome de alguns, nÃ£o serÃ¡ difÃ­cil. 

Primeiramente  gostaria  de  agradecer  a  minha  esposa  Mylena  e  ao  meu 

pequeno Bento, por serem pacientes e compreensivos em todas as noites que me fiz 

ausente  durante  essa  trajetÃ³ria.  Sei  que  nÃ£o  foi  fÃ¡cil  para  nÃ³s,  mas  finalmente 

superamos todos estes obstÃ¡culos. 

Gostaria de agradecer aos meus pais pela compreensÃ£o e apoio nos momentos 

difÃ­ceis que enfrentamos, nas adversidades e tarefas que tiveram de ser abandonadas 

e  a  minha  irmÃ£  Sirlara  (Songs),  por  todo  carinho,  forÃ§a  e  auxÃ­lio  prontamente 

prestados. 

Em terceiro, quero agradecer a minha orientadora, DrÂª Alexsandra pelo apoio 

e palavras de tranquilidade, que sempre se prontificou ouvir e colaborar com as mais 

malucas ideias que tive durante essa jornada. 

Queria  agradecer  tambÃ©m  aos  meus  colegas  do  PROFMAT,  que  tambÃ©m 

lutaram junto comigo cada um atrÃ¡s do seu prÃ³prio destino e sem nunca abandonar o 

prÃ³ximo:  Abizai,  Alan,  AntÃ´nio  Marcos,  Daniel,  Dimas,  Jocasta,  JÃºlio,  LÃ­dia,  Liliane, 

Lupicino, Marcos, Paula, RomÃ¡rio. Todos vocÃªs sÃ£o merecedores dessa  conquista; 

Em especial queria agradecer aos colegas JuliÃ£o pela nossa caminhada e conversas 

em  tantos  quilÃ´metros  rodados,  uma  amizade  que  iniciou  no  PROFMAT  e  deverÃ¡ 

perdurar  por  muitos  anos.  LÃ­dia,  pelo  companheirismo  de  sempre  e  MarcÃ£o  pelos 

experientes conselhos e pelo grande apoio quando eu e JÃºlio precisamos. 

Finalmente, gostaria de agradecer a direÃ§Ã£o, professores e colaboradores 

do  ColÃ©gio  Estadual Governador Luiz  Viana  Filho,  pelo apoio e  incentivo  durante a 

execuÃ§Ã£o deste trabalho. 

O meu muito obrigado a todos vocÃªs. 

 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1 Cifra de CÃ©sar ............................................................................................. 13 

Figura 2 Tela Inicial MIT App Inventor II .................................................................... 28 

Figura 3 Tela de Designer de Aplicativo do MIT App Inventor II ............................... 29 

Figura 4 Interface de ProgramaÃ§Ã£o ........................................................................... 30 

Figura 5 CorrespondÃªncia da Cifra de CÃ©sar ............................................................ 31 

Figura 6 PermutaÃ§Ã£o segundo ğœ ............................................................................... 32 

Figura 7 ComparaÃ§Ã£o k=1 e k=3 ............................................................................... 35 

Figura 8 Produto de Primos de 1 a 50 ....................................................................... 38 

Figura 9 Ãcone e Slogan do CodeClass ..................................................................... 46 

Figura 10 Tela Inicial do CodeClass .......................................................................... 47 

Figura 11 Interface Criptografia Linear ...................................................................... 48 

Figura 12 Exemplo de Preenchimento ...................................................................... 49 

Figura 13 CodificaÃ§Ã£o e GeraÃ§Ã£o das Chaves .......................................................... 50 

Figura 14 Tela de boas-vindas Criptografia RSA ...................................................... 51 

Figura 15 GeraÃ§Ã£o das Chaves RSA ........................................................................ 52 

Figura 16 CodificaÃ§Ã£o, CodificaÃ§Ã£o sem assinatura e CodificaÃ§Ã£o com Assinatura . 53 

Figura  17  DecodificaÃ§Ã£o,  DecodificaÃ§Ã£o  sem  Assinatura  e  DecodificaÃ§Ã£o  com 
Assinatura .............................................................................................. 55 

Figura 18 Gerador de Primos .................................................................................... 56 

Figura 19 CorrespondÃªncia Letra-NÃºmero ................................................................ 58 

Figura 20 Inversos Multiplicativos em â„¤26 ................................................................. 60 

 
Figura 21 RelÃ³gio de 26 horas .................................................................................. 61 

Figura 22 SugestÃµes de Chaves para Atividade ....................................................... 63 

Figura 23 CartÃ£o da Parte II Criptografia Linear ........................................................ 69 

Figura 24 Resposta de um aluno Ã  Parte II ............................................................... 70 

Figura 25 Troca de mensagens utilizando Criptografia RSA. Parte IV ...................... 72 

Figura 26 CartÃ£o falso, confeccionado pelo mediador. ............................................. 73 

Figura 27 E-mail falso ............................................................................................... 74 

Figura 28 Troca de mensagens entre E e R utilizando assinatura. ........................... 75 

Figura 29 Chaves do Autor E .................................................................................... 75 

Figura 30 Resultado apresentado na decodificaÃ§Ã£o ................................................. 76 

Figura 31 Mensagem apÃ³s segunda tentativa de decodificaÃ§Ã£o ............................... 77 

 
LISTA DE SÃMBOLOS 

â„•  

â„¤ 

â„ 

âˆˆ 

â‰¡  

Conjunto dos nÃºmeros Naturais 

Conjunto dos nÃºmeros Inteiros 

Conjunto dos NÃºmeros Reais 

Pertence 

CongruÃªncia 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

A  criptografia  Ã©  raramente  trabalhada  na  educaÃ§Ã£o  bÃ¡sica,  pois  nÃ£o  consta 

diretamente  como  componente/conteÃºdo  obrigatÃ³rio  na  BNCC.  Tal  fato  apresenta 

ainda enquanto algo a ser trabalhado, pois Ã© um assunto extremamente importante, 

dado  o  contexto  de  que  vivemos  em  uma  era  digital  e  que  este  serve  de  porta  de 

entrada  para  diversos  outros  assuntos  que  compÃµe  a  grade  curricular  do  ensino 

mÃ©dio. Diante desta questÃ£o, este trabalho tem como objetivo principal desenvolver 

um aplicativo que sirva como uma metodologia para o ensino da criptografia no ensino 

mÃ©dio. Este aplicativo desenvolvido Ã© intitulado de CodeClass e serÃ¡ o protagonista 

numa proposta que visa popularizar o ensino da criptografia, por meio das tecnologias, 

podendo servir de porta de entrada para se trabalhar, alÃ©m deste assunto, diversos 

outros conteÃºdos na educaÃ§Ã£o bÃ¡sica.  Como resultados obtidos, foi realizado alÃ©m 

do  desenvolvimento  do  aplicativo,  uma  atividade  como  exemplo  neste  contexto 

educacional.  Assim,  foi  observado  que  o  uso  das  tecnologias  estimula  e  instiga  os 

alunos durante o processo de aprendizagem e que Ã© possÃ­vel utilizarmos a criptografia 

para abordar assuntos como funÃ§Ãµes e aritmÃ©tica bÃ¡sica de uma maneira bem menos 

densa.  

Palavras-Chaves: Criptografia, RSA, CodeClass, NÃºmeros Primos, AritimÃ©tica

 
 
 
 
ABSTRACT 

Cryptography  is  seldom  taught  in  basic  education  since  the  Brazilian  curricular 

standards  (also  known  as  BNCC)  do  not  prescribe  cryptography  as  a  mandatory 

component. In this digital era, cryptography may serve as an introduction to several 

other subjects that make up the high school curriculum. Given the stated above, this 

paper aims to develop a application that provides a framework for teaching encryption 

in  high  school.  The  application  is  called  CodeClass  and  through  the  use  of  this 

technology  we  propose  to  popularize  the  teaching  of  cryptography  and  help  the 

teaching of various other contents of high school mathematics. Beyond the application 

development,  an activity  was  performed  as  an  example of  its  use  in  an  educational 

context. Thereby, we observed that the use of CodeClass motivates students during 

the  learning  process  and  that  cryptography  can  be  used  to  address  topics  such  as 

functions and basic arithmetic in a much less dense manner. 

Key-words: Encryption, RSA, CodeClass, Prime Numbers, Arithmetic. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÃRIO 

1. INTRODUÃ‡ÃƒO ................................................................................. 12 

2. REFERÃŠNCIAL TEÃ“RICO ............................................................... 16 

2.1 Algoritmo da DivisÃ£o......................................................................................... 16 

2.2 Divisibilidade ..................................................................................................... 17 

2.3 MDC e o Algoritmo de Euclides ....................................................................... 18 

2.4 NÃºmeros Primos ................................................................................................ 20 

2.5 FunÃ§Ãµes AritmÃ©ticas a FunÃ§Ã£o ğ“ de Euler ...................................................... 21 

2.6 CongruÃªncias .................................................................................................... 22 

2.7 EquaÃ§Ãµes Diofantinas ....................................................................................... 24 

2.8 MIT App Inventor 2 ............................................................................................ 27 

2.1.1. A Interface do Sistema .............................................................................. 28 

2.2. DivisÃ£o e a SeguranÃ§a de Redes: a Criptografia ........................................... 31 

3. CRIPTOGRAFIA .................................................................................... 32 

3.1. Sistema de Criptografia Linear ....................................................................... 32 

3.2. Trabalhando com Blocos ................................................................................. 33 

3.3. O Conceito de Chave PÃºblica .......................................................................... 36 

3.4. O RSA ................................................................................................................ 37 

3.4.1. CodificaÃ§Ã£o letra-a-letra ............................................................................ 40 

3.4.2. CodificaÃ§Ã£o por transposiÃ§Ã£o de blocos .................................................... 41 

3.4.3. DecodificaÃ§Ã£o ........................................................................................... 42 

3.4.4. Assinatura do RSA .................................................................................... 44 

4. O APLICATIVO CODECLASS E A CRIPTOGRAFIA ...................................... 45 

4.1. O aplicativo .................................................................................................. 45 

4.2. Interface ....................................................................................................... 46 

4.3. SUGESTÃƒO I â€“ Origem da Criptografia ....................................................... 57 

4.4. SUGESTÃƒO II â€“ Criptografia de Chave PÃºblica ........................................... 63 

4.5. AplicaÃ§Ã£o do CodeClass .............................................................................. 66 

4.5.1. A Oficina ................................................................................................... 67 

5. RESULTADOS E DISCUSSÃ•ES ................................................................. 79 

 
 
 
1.1. ConfecÃ§Ã£o do CodeClass ......................................................................... 79 

1.2. Oficina .......................................................................................................... 80 

6. CONSIDERAÃ‡Ã•ES FINAIS ...................................................................... 81 

REFERÃŠNCIAS .................................................................................... 83 

ANEXO A ............................................................................................. 85 

ANEXO B ............................................................................................. 89 

 
 
 
12 

1.   INTRODUÃ‡ÃƒO 

 O mundo mudou! O que antes era feito com um relÃ³gio despertador ou, em 

alguns casos, com o cocoricar de um galo, hoje Ã© feito pelo seu celular. As ruas que 

antes eram lentas e vagarosas, estÃ£o cada vez mais expressas e densas de veÃ­culos 

automotores. Se antes para obter notÃ­cias era preciso esperar o horÃ¡rio do jornal no 

rÃ¡dio, ou adquirir um impresso em uma banca, hoje enquanto estamos desatentos as 

notÃ­cias chegam, e chegam, Ã s vezes, antes mesmo de acontecer. 

Ainda  assim,  existem  coisas  no  mundo  que  nÃ£o  mudaram  e  uma  delas  Ã©  a 

necessidade  de  ocultar informaÃ§Ãµes.  Esta  necessidade nÃ£o  aparece  com  a  difusÃ£o 

dos recursos tecnolÃ³gicos, mas sim dos fatos mais corriqueiros que temos no dia a 

dia. Para exemplificar, imagine a situaÃ§Ã£o de uma partida de xadrez acirrada, em que 

o adversÃ¡rio nÃ£o consegue ler a sua mente para prever qual a sua estratÃ©gia e traÃ§ar, 

assim,  um  plano  de  defesa  ou  contra-ataque  antecipadamente.  Somente  apÃ³s  o 

movimento Ã© que vocÃª poderÃ¡ pensar no que pode ser feito. Em guerras ou batalhas 

por  poder,  o  princÃ­pio  que  rege  a  estratÃ©gia  Ã©  o  mesmo.  Um  comandante  precisa 

informar Ã   suas  tropas  qual rumo  tomar na  batalha  e  quais estratÃ©gias  irÃ£o  adotar. 

PorÃ©m, o inimigo tambÃ©m quer saber qual a estratÃ©gia serÃ¡ usada para nÃ£o ser pego 

desprevenido e Ã© a partir dessa demanda que surge a necessidade de comeÃ§armos 

a esconder certas informaÃ§Ãµes.  

Como se jÃ¡ nÃ£o bastasse, com o advento da tecnologia, passamos todos a ficar 

conectados um ao outro, numa gigantesca rede chamada Internet. Nesta rede, cada 

computador do mundo estÃ¡, literalmente, ligado um ao outro. Dentro deste contexto, 

torna-se inevitÃ¡vel a utilizaÃ§Ã£o de um meio que sirva para acobertar este trÃ¡fego, de 

modo  que  certas  informaÃ§Ãµes  nÃ£o  sejam  interceptadas  por  destinatÃ¡rios  nÃ£o 

autorizados.  Assim,  um  dos  meios  utilizados  para  proteÃ§Ã£o  de  informaÃ§Ãµes  Ã© 

conhecido  como  a  criptografia.  â€œA  criptografia  estuda  os  mÃ©todos  para  codificar  uma 

mensagem de modo que sÃ³ seu destinatÃ¡rio legÃ­timo consiga interpretÃ¡-la.â€ [1]. 

Para contextualizarmos, um dos primeiros a utilizar um sistema de criptografia 

foi  JÃºlio  CÃ©sar  (100  a.C).  Na  Figura  1,  intitulado  Cifra  de  CÃ©sar,  Ã©  feita  uma 

substituiÃ§Ã£o,  em  todo  texto,  de  cada  letra  por  uma  outra  que  Ã©  obtida  atravÃ©s  da 

 
 
13 

permutaÃ§Ã£o escolhida previamente. Na segunda linha, temos a imagem de cada letra 

da primeira linha apÃ³s a permutaÃ§Ã£o. 

Figura 1 Cifra de CÃ©sar 

Fonte: O autor 

Observe que nessa situaÃ§Ã£o, ao cifrarmos a palavra JULIO CESAR, obtemos 

MXOLR FHVDU.  

Este sistema, apesar de ser inÃ©dito e eficiente para a Ã©poca, Ã© bastante frÃ¡gil. 

Visto que se for observado certo padrÃ£o de repetiÃ§Ã£o no texto, consegue-se facilmente 

quebrar o segredo deste cÃ³digo. 

Antes dele, 404 a.C, existem registros de que: 

Lisandro de Esparta, recebeu um mensageiro ensanguentado e 
ferido, Ãºnico sobrevivente de um grupo de cinco que partira da 
PÃ©rsia  numa  Ã¡rdua  jornada.  O  mensageiro  lhe  entregou  seu 
cinturÃ£o,  que  Lisandro  enrolou  entorno  de  seu  citale  para 
descobrir  que  o  persa  Farnabazo  estava  planejando  atacÃ¡-lo. 
GraÃ§as ao citale, Lisandro estava preparado para o ataque, e o 
repeliu. [2] 

Este  registo,  relata  sobre  o  primeiro  aparelho  criptogrÃ¡fico  militar,  o  Citale 

Espartano. Este mÃ©todo se consiste em um bastÃ£o de madeira, em que se enrola uma 

fita  e  nela  escreve-se  a  mensagem  no  sentido  do  comprimento  do  bastÃ£o.  Ao 

desenrolar a fita, as letras ficarÃ£o em uma ordem um tanto quanto confusas e somente 

enrolando a mensagem em um bastÃ£o de mesmo diÃ¢metro serÃ¡ possÃ­vel tornar legÃ­vel 

seu conteÃºdo. 

Apesar  de  antiga,  mas  amplamente  utilizada  nesta  era  digital,  a  criptografia 

ainda nÃ£o Ã© trabalhada nas escolas como um conteÃºdo em si e, menos ainda, como 

uma  aplicaÃ§Ã£o  prÃ¡tica  dos  conteÃºdos  abordados  principalmente  no  ensino  mÃ©dio. 

 
 
 
 
 
 
 
14 

Fazendo uma anÃ¡lise das competÃªncias e habilidades da cartilha OrientaÃ§Ãµes Para o 

Ensino MÃ©dio Ãrea: MatemÃ¡tica [3]; produzida pela secretÃ¡ria de EducaÃ§Ã£o da Bahia. 

Observamos  que  muitos  dos  conteÃºdos  que  sÃ£o  sugeridos  no  EIXO  1  - 

LINGUAGEM,  ESTRUTURAS  E  ABSTRAÃ‡Ã•ES  MATEMÃTICAS,  poderiam  ser 

trabalhados  de  uma  maneira  que  realmente  demonstrasse  a  real  relevÃ¢ncia  dos 

mesmos no cotidiano do estudante. 

Assim,  surge  a  ideia  de  elaborar  uma  proposta  que  apresentasse  o  tema 

Criptografia no contexto disciplinar estudado pelo aluno no seu ensino regular. Como 

em nossas pesquisas, nÃ£o encontramos ferramentas que trabalhassem este conteÃºdo 

de uma maneira mais lÃºdica e que simulasse o que realmente acontece na troca de 

informaÃ§Ãµes  pela  Internet,  decidimos  desenvolver  um  aplicativo  para  ser  utilizado 

justamente com este fim. 1 

Denominado de CodeClass, desenvolvemos um aplicativo, que nasceu com a 

ideia de apresentar aos estudantes como funcionam os sistemas de  criptografia na 

era  digital.  Nele,  alÃ©m  de  visualizar  a  real necessidade  das  evoluÃ§Ãµes  do  ramo,  os 

usuÃ¡rios poderÃ£o perceber o que as mÃ¡quinas fazem para codificar e decodificar um 

texto, dando sentido Ã s funÃ§Ãµes e aritmÃ©tica modular que sÃ£o aprendidas no decorrer 

das aulas regulares da educaÃ§Ã£o bÃ¡sica.  

Para usuÃ¡rios mais avanÃ§ados, que muitas vezes venham a ser discentes ou 

formados em matemÃ¡tica, este aplicativo poderÃ¡ ilustrar como alguns teoremas mais 

avanÃ§ados da aritmÃ©tica modular sÃ£o computacionalmente aplicados servindo a eles 

tambÃ©m como um instrumento de contextualizaÃ§Ã£o.  

Nosso  trabalho  foi  dividido  em  algumas  etapas  que  serviram  para  nortear  o 

nosso  desenvolvimento.  Incialmente,  no  CapÃ­tulo  1  foi  realizado  um  levantamento 

teÃ³rico  do  que  Ã©  necessÃ¡rio  para  o  entendimento  da  criptografia,  alÃ©m  de  diversas 

tÃ©cnicas  criptogrÃ¡ficas,  para  que  pudÃ©ssemos  selecionar  aquelas  que  mais  se 

adequassem ao ensino bÃ¡sico. 

O CapÃ­tulo 2, irÃ¡ tratar de teoria matemÃ¡tica para a compreensÃ£o da criptografia 

linear, RSA e o processo de codificaÃ§Ã£o e decodificaÃ§Ã£o de uma mensagem. 

1 Os mÃ©todos e tÃ©cnicas utilizadas para a criaÃ§Ã£o do aplicativo vai ser melhor explicada no CapÃ­tulo 2. 

 
                                                           
15 

Para  tratar  da  criptografia  em  si,  escolhemos  dois  sistemas.  O  primeiro  Ã©  a 

criptografia linear, ele serÃ¡ utilizado para servir de porta de entrada para os demais 

mÃ©todos,  pois pode  ser facilmente  explorada  manualmente,  sem a  necessidade de 

computadores ou calculadoras mais avanÃ§adas. No CapÃ­tulo 3, iremos definir como 

este mÃ©todo se desenvolve.  

A segunda tÃ©cnica criptogrÃ¡fica que decidimos implementar, foi o MÃ©todo RSA, 

que  tambÃ©m  serÃ¡  apresentada  e  discutida  no  CapÃ­tulo  3.  A  saber,  o  RSA  Ã©  uma 

tÃ©cnica utilizada mundialmente na Internet e nÃ£o envolve algo que seja extremamente 

complexo de se explanar.  

Ambos  os  sistemas  foram  programados  para  ser  utilizado  no  aplicativo 

CodeClass,  que  foi  desenvolvido  neste  trabalho.  Este  aplicativo  foi  construÃ­do  por 

meio da plataforma gratuita de programaÃ§Ã£o em bloco MIT App Inventor II para ser 

utilizado em sistemas Android. 

Ao  final,  serÃ¡  apresentado  ainda  no  CapÃ­tulo  3,  como  foi  realizada  a  oficina 

interativa que buscou, alÃ©m de testar as funcionalidades do aplicativo, apresentar os 

principais conceitos da criptografia e a necessidade da sua evoluÃ§Ã£o. 

 Com isso, pudemos avaliar se a proposta seria realmente relevante para os 

estudantes  e,  assim,  podermos  ir  adaptando  tanto  o  CodeClass,  como  tambÃ©m  as 

nossas sugestÃµes, para serem cada vez mais efetivas no Ã¢mbito da educaÃ§Ã£o bÃ¡sica 

e que possam vir a fundamentar a continuaÃ§Ã£o deste trabalho sob outras perspectivas 

nas consideraÃ§Ãµes finais.   

. 

 
 
 
 
  
 
 
 
 
16 

2.   REFERÃŠNCIAL TEÃ“RICO 

Para um  bom entendimento de  tudo  que  serÃ¡  exposto  neste trabalho, faz-se 

necessÃ¡rio  a  compreensÃ£o  de  alguns  conceitos  que  vÃ£o  alÃ©m  da  Base  Nacional 

Comum Curricular (BNCC) [4]. Para tanto, este capÃ­tulo discutirÃ¡: Algoritmo da divisÃ£o; 

Divisibilidade; MDC e o Algoritmo de Euclides, NÃºmeros primos, FunÃ§Ãµes AritmÃ©ticas 

a  FunÃ§Ã£o  Ï•  de  Euler, CongruÃªncias,  EquaÃ§Ãµes  Diofantinas,  A  Interface  do  Sistema 
MIT App Inventor II. 

2.1 Algoritmo da DivisÃ£o 

Iremos apresentar agora, um dos algoritmos que mais encantam na AritmÃ©tica 

dos Inteiros: o Algoritmo da divisÃ£o de Euclides. Este algoritmo que, segundo Santos, 

jÃ¡ configurava registros de sua apariÃ§Ã£o no livro VII dos Elementos de Euclides, escrito 

por volta de 300a.C [5]. Iremos partir do princÃ­pio que o conhecimento das operaÃ§Ãµes 

elementares, bem  como  suas principais propriedades e  resultados  do  conjunto  dos 

nÃºmeros inteiros jÃ¡ sÃ£o de prÃ©vio conhecimento de quem aprecia este trabalho.  

Teorema  1  (Algoritmo  da  DivisÃ£o).  Sejam  ğ’¶ e ğ‘,  com  ğ’¶ > b  dois  nÃºmeros 

inteiros com b â‰  0. Existem dois Ãºnicos nÃºmeros inteiros q e r  tais que 

ğ‘ = ğ‘. ğ‘ + ğ‘Ÿ, com 0 â‰¤ ğ‘Ÿ < |ğ‘|. 

DemonstraÃ§Ã£o. Vamos considerar o conjunto 

ğ‘†  = {ğ‘  âˆ’  ğ‘. ğ‘;  ğ‘  âˆˆ  â„¤}   âˆ©   (â„•  âˆª   {0}) 

Devemos mostrar, alÃ©m da existÃªncia de ğ‘ ğ‘’ ğ‘Ÿ, a unidade dos mesmos. De fato, 

temos  que  ğ‘  > ğ‘  implica  em  âˆ’ğ‘  >   âˆ’ğ‘.  Como â„•  Ã©  ilimitado,  existe  n âˆˆ  â„•  tal  que 

ğ‘›. (âˆ’ğ‘) >   âˆ’ğ‘, portanto ğ‘† Ã© nÃ£o vazio e, alÃ©m disso,  ğ‘ âˆ’ ğ‘›. ğ‘  > 0 o que mostra que ğ‘† 

Ã© limitado inferiormente pelo 0. Deste modo, o PrincÃ­pio da Boa OrdenaÃ§Ã£o garante 

que ğ‘† tem um menor elemento que denotaremos por  ğ‘Ÿ. Tomemos ğ‘Ÿ = ğ‘ âˆ’ ğ‘. ğ‘  â‰¥ 0. 

Resta mostrar que ğ‘Ÿ < |ğ‘|.  

Suponha   por  absurdo,  que    ğ‘Ÿ â‰¥  |ğ‘|    entÃ£o,   existe   ğ‘  âˆˆ â„•  âˆª {0}   tal que  

 
 
 
 
 
17 

 ğ‘Ÿ = |ğ‘| + ğ‘   o que implica ğ‘  = ğ‘Ÿ âˆ’ |ğ‘| que Ã© uma contradiÃ§Ã£o, visto que esta igualdade 

mostra que ğ‘   âˆˆ ğ‘† e ğ‘   < ğ‘Ÿ que Ã© o menor elemento de ğ‘†. Absurdo. Portanto ğ‘Ÿ < |ğ‘|.  

Para a unidade, suponhamos que existam tambÃ©m, ğ‘ËŠ e  ğ‘ŸËŠ   pertencentes a â„¤ 

tais que     ğ‘ = ğ‘. ğ‘ + ğ‘Ÿ = ğ‘. ğ‘ËŠ + ğ‘ŸËŠ      onde 0  â‰¤ ğ‘Ÿ < |ğ‘| e 0 â‰¤ ğ‘ŸËŠ < |ğ‘|.     Observe que  

âˆ’|ğ‘| < âˆ’ğ‘Ÿ â‰¤ 0 e 0 â‰¤ ğ‘ŸËŠ < |ğ‘|, somando estas Ãºltimas desigualdades obtemos 

âˆ’|ğ‘| < ğ‘ŸËŠ âˆ’ ğ‘Ÿ  < |ğ‘| 

|ğ‘ŸËŠ âˆ’ ğ‘Ÿ| < |ğ‘| 

Por   outro   lado    ğ‘. ğ‘ + ğ‘Ÿ = ğ‘. ğ‘ËŠ + ğ‘ŸËŠ     implica     que    ğ‘. (ğ‘ âˆ’ ğ‘ËŠ) = ğ‘ŸËŠ âˆ’ ğ‘Ÿ, daÃ­ 

 |ğ‘|. |ğ‘ âˆ’ ğ‘ËŠ| = |ğ‘ŸËŠ âˆ’ ğ‘Ÿ|. Unificando as expressÃµes, teremos 

|ğ‘|. |ğ‘ âˆ’ ğ‘ËŠ| = |ğ‘ŸËŠ âˆ’ ğ‘Ÿ| < |ğ‘| 

mas isto sÃ³ faz sentido se ğ‘ = ğ‘ËŠ e ğ‘Ÿ = ğ‘ŸËŠ. O que prova a unidade de ğ‘ e ğ‘Ÿ.  

Apesar de nos chamar a atenÃ§Ã£o o fato de ğ‘ e ğ‘Ÿ serem Ãºnicos, este nÃ£o Ã© um 

algoritmo  muito  eficiente  para  fazermos  divisÃµes.  Afinal,  terÃ­amos  que  testar  os 

quocientes um a um a fim de encontrar aquele que permitisse a sobra de um resto 

menor  que  |ğ‘|.  PorÃ©m  Ã©  dele  que  surge  a  definiÃ§Ã£o  de  congruÃªncia  que  serÃ¡  de 

extrema importÃ¢ncia em nossos estudos. 

âˆ 

2.2 Divisibilidade 

DefiniÃ§Ã£o 1. Sejam  ğ‘ e ğ‘  inteiros, dizemos que  ğ‘  divide ğ‘,  denotando por  

 ğ‘ | ğ‘, se existir um inteiro ğ‘ tal que ğ‘ = ğ‘. ğ‘. 

Se ğ‘ nÃ£o divide ğ‘ escrevemos ğ‘  âˆ¤ ğ‘.  

Por exemplo, podemos dizer que 2 | 10, pois 10  =  2.5 e que 3  âˆ¤  10 visto que 

3 nÃ£o Ã© um fator de 10. 

NÃ£o iremos citar aqui as propriedades que estÃ¡ operaÃ§Ã£o possui, podendo ser 

consultada no livro do PlÃ­nio em [5]. 

 
 
 
 
 
 
 
 
18 

2.3 MDC e o Algoritmo de Euclides 

Uma das principais partes de um sistema criptogrÃ¡fico Ã© determinar as chaves 

que codificam e decodificam uma mensagem. Para que entendamos um dos mÃ©todos 

que serÃ£o apresentados no prÃ³ximo capÃ­tulo, precisamos compreender a forma como 

conseguimos determinar o MDC de um nÃºmero. Veremos nesta seÃ§Ã£o que isso serÃ¡ 

feito de maneira mais eficiente quando utilizando o Algoritmo de Euclides.  

DefiniÃ§Ã£o 2. O mÃ¡ximo divisor comum de dois inteiros ğ‘ e ğ‘ (ğ‘ ou ğ‘ nÃ£o nulo), 

Ã© o maior nÃºmero inteiro que divide ğ‘ e ğ‘. Denotaremos por ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) este inteiro. 

Teorema 2. Seja  ğ‘‘  =  ğ‘šğ‘‘ğ‘(ğ‘, ğ‘), entÃ£o  existem  inteiros   ğ‘Ÿ e ğ‘   tais  que  

 ğ‘‘  =  ğ‘Ÿ. ğ‘  +  ğ‘ . ğ‘. 

DemonstraÃ§Ã£o. Esta demonstraÃ§Ã£o encontra-se no livro do Coutinho [1] pÃ¡ginas 22 e 

23.  

ProposiÃ§Ã£o 1. Se ğ‘ > 0 e ğ‘ e ğ‘ sÃ£o divisÃ­veis por ğ‘, entÃ£o 

ğ‘šğ‘‘ğ‘ (

ğ‘
ğ‘

,

ğ‘
ğ‘‘

) =

1
ğ‘

ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) 

DemonstraÃ§Ã£o:  Por hipÃ³tese,  como  a e  b  sÃ£o  divisÃ­veis  por  c,  temos  que 

a

c

  e 

inteiros.  

b

c

  sÃ£o 

Para  provarmos  este  resultado,  iremos  utilizar  o  seguinte  resultado  que  consta 

demonstrado na pÃ¡gina 6 do livro IntroduÃ§Ã£o Ã  Teoria dos NÃºmeros  [5], que diz: 

Para todo inteiro  ğ‘¡, ğ‘šğ‘‘ğ‘(ğ‘¡ğ‘, ğ‘¡ğ‘) = ğ‘¡. ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) 

Assim, basta fazermos â€œğ‘â€=

ğ‘

ğ‘

  e â€œğ‘â€=

ğ‘

ğ‘

 e tomarmos ğ‘¡ =

1
. 

ğ‘

âˆ 

 
 
 
 
 
 
 
 
  
 
 
19 

Teorema 3. Se ğ‘ e ğ‘ sÃ£o inteiros e ğ‘ = ğ‘. ğ‘ + ğ‘Ÿ,  onde ğ‘ e ğ‘Ÿ sÃ£o inteiros, entÃ£o 

ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) = ğ‘šğ‘‘ğ‘(ğ‘, ğ‘Ÿ). 

DemonstraÃ§Ã£o.  Observe que todo divisor comum de ğ‘ e ğ‘Ÿ Ã© um divisor comum de ğ‘.  

E, caso se isolarmos ğ‘ âˆ’ ğ‘. ğ‘,  podemos observar que  todo  divisor  comum de  ğ‘ e ğ‘ 

Ã© tambÃ©m divisor comum  de ğ‘Ÿ. Portando o conjunto dos divisores  comuns  de  ğ‘ e ğ‘ 

Ã©   igual   ao   conjunto   dos   divisores   comuns   de  ğ‘   e  ğ‘Ÿ,   o   que   garante  

 ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) = ğ‘šğ‘‘ğ‘(ğ‘, ğ‘Ÿ).  

âˆ 

Agora  iremos  tratar  do  Algoritmo  de  Euclides  uma  importante  ferramenta 

quando necessitamos determinar o ğ‘€ğ·ğ¶  de dois nÃºmeros. Para que a demonstraÃ§Ã£o 

nÃ£o  fique  tÃ£o  densa,  vamos  desenvolver  antes,  um  exemplo  numÃ©rico,  para  que  o 

leitor possa acompanhar as etapas da prova. 

       Queremos determinar o ğ‘šğ‘‘ğ‘(1326,1001), para isso vamos utilizar o algoritmo da 

divisÃ£o para determinar o resto de 1326 por 1001, em seguida iremos dividir 1001 pelo 

resto encontrado na primeira iteraÃ§Ã£o e assim sucessivamente atÃ© obtermos resto 0. 

1326 = 1.1001 + 325 

1001 = 3.325 + 26 

325 = 12.26 + 13 

26 = 2.13 + 0 

A Ãºltima linha nos indica que ğ‘šğ‘‘ğ‘(26,13) = 13, pois 13|26. Se utilizarmos o Teorema 

3, teremos entÃ£o que  

ğ‘šğ‘‘ğ‘(1326,1001) = ğ‘šğ‘‘ğ‘(1001,325) = ğ‘šğ‘‘ğ‘(325,26) = ğ‘šğ‘‘ğ‘(26,13) = 13. 

Teorema  4  (O  Algoritmo  de  Euclides)  Sejam  ğ‘Ÿ0 = ğ‘  e  ğ‘Ÿ1 = ğ‘  inteiros  nÃ£o-
negativos com ğ‘ â‰  0. Se o algoritmo da divisÃ£o for aplicado sucessivamente para se 
obter 

ğ‘Ÿğ‘— = ğ‘ğ‘—+1. ğ‘Ÿğ‘—+1 + ğ‘Ÿğ‘—+2,   0 â‰¤ ğ‘Ÿğ‘—+2 < ğ‘Ÿğ‘—+1 

Para ğ‘— = 0,1,2, â€¦ , ğ‘› âˆ’ 1 e ğ‘Ÿğ‘›+1 = 0 entÃ£o ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) = ğ‘Ÿğ‘›, o Ãºltimo resto nÃ£o-nulo. 

DemonstraÃ§Ã£o. Vamos aplicar o algoritmo da divisÃ£o, para dividir ğ‘Ÿ0 = ğ‘  por ğ‘Ÿ1 = ğ‘ 

 
 
 
 
20 

ğ‘Ÿ0 = ğ‘1. ğ‘Ÿ1 + ğ‘Ÿ2 

dividindo ğ‘Ÿ1 por ğ‘Ÿ2, e assim por diante quantas vezes foram necessÃ¡rias, obtemos a 
sequÃªncia de equaÃ§Ãµes: 

ğ‘Ÿ0 = ğ‘1. ğ‘Ÿ1 + ğ‘Ÿ2        0 < ğ‘Ÿ2 < ğ‘Ÿ1 

ğ‘Ÿ1 = ğ‘2. ğ‘Ÿ2 + ğ‘Ÿ3        0 < ğ‘Ÿ3 < ğ‘Ÿ2 

ğ‘Ÿ0 = ğ‘3. ğ‘Ÿ3 + ğ‘Ÿ4        0 < ğ‘Ÿ4 < ğ‘Ÿ3 

â‹® 

ğ‘Ÿğ‘›âˆ’2 = ğ‘ğ‘›âˆ’1. ğ‘Ÿğ‘›âˆ’1 + ğ‘Ÿğ‘›          0 < ğ‘Ÿğ‘› < ğ‘Ÿğ‘›âˆ’1 

ğ‘Ÿğ‘›âˆ’1 = ğ‘ğ‘›. ğ‘Ÿğ‘› + 0 

finalmente, aplicando o Teorema 3 nas equaÃ§Ãµes acima concluÃ­mos que  

ğ‘Ÿğ‘› = ğ‘šğ‘‘ğ‘(ğ‘Ÿğ‘›, ğ‘Ÿğ‘›âˆ’1) = ğ‘šğ‘‘ğ‘(ğ‘Ÿğ‘›âˆ’1, ğ‘Ÿğ‘›âˆ’2) = â‹¯ = ğ‘šğ‘‘ğ‘(ğ‘Ÿ1, ğ‘Ÿ2) = ğ‘šğ‘‘ğ‘(ğ‘Ÿ0, ğ‘Ÿ1) = ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) 

âˆ 

2.4 NÃºmeros Primos 

DefiniÃ§Ã£o  3.  Um  nÃºmero  inteiro  ğ‘› > 1  Ã©  primo,  se  possui  somente  dois 

divisores positivos  ğ‘› e 1. Se ğ‘› > 1 nÃ£o Ã© primo, dizemos que ğ‘› Ã© composto. 

O  teorema  a  seguir  foi  proposto  e  demonstrado  por  Gauss  em  1976.  Ele  Ã© 
fundamental para o funcionamento do Sistema RSA, bem como garanti que nÃ£o pode 
existir uma duplicaÃ§Ã£o de chaves neste sistema. 

Teorema 5 (Teorema Fundamental da AritmÃ©tica). Todo inteiro maior do que 
1 pode ser representado de maneira Ãºnica (a menos de ordem) como um produto de 
fatores primos. 

DemonstraÃ§Ã£o: Se ğ‘›  Ã© primo nÃ£o hÃ¡ nada a ser demonstrado. Suponhamos que  ğ‘› 
seja um nÃºmero composto. Seja ğ‘1 > 1 o menor dos divisores positivos de ğ‘›. Observe 
que ğ‘1 Ã© primo, pois caso contrÃ¡rio existirÃ¡ um ğ‘ğ‘– < ğ‘1 tal que ğ‘ğ‘–|ğ‘›. Assim, podemos 
escrever ğ‘› como sendo o produto de ğ‘1. ğ‘›1. 

Se ğ‘›1 for primo, a prova estÃ¡ completa. Caso contrÃ¡rio, tomamos ğ‘2 como o 

menor o menor fator de ğ‘›1. Assim, ğ‘2 serÃ¡ primo e podemos escrever ğ‘› = ğ‘1. ğ‘2. ğ‘›2. 

 
 
 
 
21 

Repetindo  esse  processo,  obtemos  uma  sequÃªncia  finita  e  decrescente  de 
inteiros  positivos  ğ‘›1, ğ‘›2, â€¦ , ğ‘›ğ‘Ÿ.  Como  os  primos  na  sequÃªncia  ğ‘1, ğ‘2, â€¦ , ğ‘ğ‘˜  nÃ£o  sÃ£o 
necessariamente distintos, ğ‘› serÃ¡ da forma 

ğ‘› = ğ‘1

ğ›¼1. ğ‘2

ğ›¼2 â€¦ ğ‘ğ‘˜

ğ›¼ğ‘˜ 

Para  mostrarmos  que  essa  fatoraÃ§Ã£o  Ã©  Ãºnica,  aplicamos  a  induÃ§Ã£o  sobre  ğ‘›. 
Para  ğ‘› = 2  Ã©  trivial  que  a  afirmaÃ§Ã£o  Ã©  verdadeira.  Suponha  que  ela  se  mantenha 
verdadeira para todos os inteiros maiores do que 1 e menores do que ğ‘›. Mostremos 
que ela tambÃ©m Ã© vÃ¡lida para ğ‘›.  

Suponha que ğ‘› Ã© composto e tenha duas fatoraÃ§Ãµes, ou seja, 

ğ‘› = ğ‘1. ğ‘2 â€¦ ğ‘ğ‘  = ğ‘1. ğ‘2 â€¦ ğ‘ğ‘Ÿ 

Iremos mostrar que ğ‘Ÿ = ğ‘  e que cada ğ‘ğ‘– Ã© igual a algum ğ‘ğ‘–. Como ğ‘1 divide o produto 

ğ‘1ğ‘2 â€¦ ğ‘ğ‘Ÿ entÃ£o ele deve dividir pelo menos um dos fatores ğ‘ğ‘—.  

Suponha sem perda de generalidade que ğ‘1|ğ‘1 e como ambos sÃ£o primos, podemos 

concluir que ğ‘1 = ğ‘1. Assim, 1 <

ğ‘›
ğ‘1

= ğ‘2. ğ‘3 â€¦ ğ‘ğ‘  = ğ‘2. ğ‘3 â€¦ ğ‘ğ‘Ÿ < ğ‘› que por hipÃ³tese de 

induÃ§Ã£o possui fatoraÃ§Ã£o Ãºnica e, portanto ğ‘Ÿ = ğ‘  e, a menos de ordem, as fatoraÃ§Ãµes 

ğ‘1. ğ‘2 â€¦ ğ‘ğ‘  e ğ‘1. ğ‘2 â€¦ ğ‘ğ‘Ÿ sÃ£o iguais. 

âˆ 

2.5 FunÃ§Ãµes AritmÃ©ticas a FunÃ§Ã£o ğ“ de Euler 

Denominamos de funÃ§Ã£o aritmÃ©tica, uma funÃ§Ã£o definida para todos os inteiros 

positivos. No campo da Teoria dos NÃºmeros, existem diversas funÃ§Ãµes aritmÃ©ticas, 

porÃ©m  nessa  seÃ§Ã£o  trataremos  apenas  da  FunÃ§Ã£o  ğœ™  de  Euler,  que  faz  parte  da 

mecÃ¢nica do algoritmo RSA que serÃ¡ tratado no capÃ­tulo seguinte. 

DefiniÃ§Ã£o 4. Se ğ‘› Ã© um inteiro positivo, a funÃ§Ã£o ğœ™ de Euler, denotada por ğœ™(ğ‘›), 

Ã© definida como sendo o nÃºmero de inteiros positivos menores ou iguais a ğ‘›, que sÃ£o 

relativamente primos com ğ‘›. 

Por exemplo, podemos verificar que ğœ™(8) = 4, pois o conjunto dos nÃºmeros ğ‘¡ 

de  1  a  8  tais  que  o  ğ‘šğ‘‘ğ‘(8, ğ‘¡) = 1  se  restringe  a  1,3,5,7,  ou  seja  possui  apenas  4 

elementos. 

 
 
 
22 

Uma observaÃ§Ã£o interessante, Ã© que se ğ‘ for um nÃºmero primo tal que ğ‘ â‰¥ 2 

entÃ£o  ğœ™(ğ‘) = ğ‘ âˆ’ 1,  afinal  nenhum  dos  nÃºmeros  menores  que  ğ‘  possui  um  divisor 

comum com ele.  

Teorema 6. A funÃ§Ã£o ğœ™ de Euler Ã© multiplicativa, isto Ã©, ğœ™(ğ‘š. ğ‘›) = ğœ™(ğ‘š). ğœ™(ğ‘›) 

para ğ‘šğ‘‘ğ‘(ğ‘š, ğ‘›) = 1. 

DemonstraÃ§Ã£o: Iremos omitir aqui a demonstraÃ§Ã£o deste teorema, mas ela encontra-

se no livro do Abramo Hefez [6] pg. 199. 

CorolÃ¡rio 1. Se ğ‘ e ğ‘ sÃ£o primos, entÃ£o ğœ™(ğ‘. ğ‘) = (ğ‘ âˆ’ 1). (ğ‘ âˆ’ 1) 

DemonstraÃ§Ã£o: Pelo teorema anterior, como ğœ™(ğ‘. ğ‘) = ğœ™(ğ‘). ğœ™(ğ‘) e do fato de 

ğ‘ e ğ‘ serem primos, temos que ğœ™(ğ‘) = ğ‘ âˆ’ 1 e ğœ™(ğ‘) = ğ‘ âˆ’ 1. 

2.6 CongruÃªncias 

âˆ 

Dizemos que dois nÃºmeros ğ‘ e ğ‘ sÃ£o congruentes mÃ³dulo ğ‘› se os restos de 

sua divisÃ£o euclidiana por ğ‘› sÃ£o iguais, escrevendo 

ğ‘  â‰¡  ğ‘ ğ‘šğ‘œğ‘‘ ğ‘› 

Como exemplo, podemos observar que 23  â‰¡  5 ğ‘šğ‘œğ‘‘ 18, pois sabemos que ao 

dividirmos  23  por  18  obtemos  quociente  1  e  resto  5.  Uma  outra  abordagem 

interessante para essa definiÃ§Ã£o, Ã© dizermos que  ğ‘› | (ğ‘ âˆ’ ğ‘)  ou equivalentemente  

ğ‘ âˆ’ ğ‘ = ğ‘›. ğ‘˜ para algum ğ‘˜ âˆˆ â„¤.  

Alguns  resultados  a  respeito  das  operaÃ§Ãµes  com  congruÃªncias  podem  ser 

encontrados  no  livro  do  JosÃ©  PlÃ­nio  [5].  Nos  ateremos  aqui,  nos  teoremas  e 

proposiÃ§Ãµes fundamentais para compreensÃ£o da criptografia. 

ProposiÃ§Ã£o 4. Se ğ‘, ğ‘, ğ‘˜ e ğ‘› sÃ£o inteiros com ğ‘˜ > 0 e ğ‘ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›, entÃ£o 

ğ‘ğ‘˜ â‰¡ ğ‘ğ‘˜ ğ‘šğ‘œğ‘‘ ğ‘›.  

 DemonstraÃ§Ã£o: Por hipÃ³tese temos que ğ‘ âˆ’ ğ‘ = ğ‘›. ğ‘™, se utilizarmos a identidade 

ğ‘ğ‘˜ âˆ’ ğ‘ğ‘˜ = (ğ‘ âˆ’ ğ‘). (ğ‘ğ‘˜âˆ’1 + ğ‘ğ‘˜âˆ’2ğ‘ + ğ‘ğ‘˜âˆ’3ğ‘2 + â‹¯ + ğ‘ğ‘ğ‘˜âˆ’2 + ğ‘ğ‘˜âˆ’1) 

e chamando ğ‘ğ‘˜âˆ’1 + ğ‘ğ‘˜âˆ’2ğ‘ + ğ‘ğ‘˜âˆ’3ğ‘2 + â‹¯ + ğ‘ğ‘ğ‘˜âˆ’2 + ğ‘ğ‘˜âˆ’1  de ğ‘š, teremos 

ğ‘ğ‘˜ âˆ’ ğ‘ğ‘˜ = (ğ‘ âˆ’ ğ‘). ğ‘š = ğ‘›. ğ‘™. ğ‘š = ğ‘›. (ğ‘™. ğ‘š) 

o que implica em ğ‘ğ‘˜ â‰¡ ğ‘ğ‘˜ ğ‘šğ‘œğ‘‘ ğ‘›. 

 
 
23 

âˆ 

Teorema 6 (Pequeno Teorema de Fermat).   Se   ğ‘   Ã©   primo,  entÃ£o  

 ğ‘ğ‘ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘, para todo inteiro ğ‘. 

DemonstraÃ§Ã£o:  Iremos  fazer  a  prova  deste  resultado  para  ğ‘ natural  utilizando  o 

princÃ­pio de induÃ§Ã£o em ğ‘. 

Note que para ğ‘ = 1 o resultado Ã© trivial, visto que 1ğ‘ â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘. 

Suponha que exista um ğ‘ â‰¥ 1 tal que ğ‘ğ‘ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘. Mostraremos a validez de 

proposiÃ§Ã£o para ğ‘ + 1. 

Note que ao utilizarmos a expansÃ£o por BinÃ´mio de Newton, temos 

(ğ‘ + 1)ğ‘ = ğ‘ğ‘ + (

ğ‘

ğ‘ âˆ’ 1) ğ‘ğ‘âˆ’1 + â‹¯ + (

ğ‘
ğ‘–

) ğ‘ğ‘– + â‹¯ + (

ğ‘
1

) ğ‘ + 1                           (1) 

Aplicando congruÃªncias mÃ³dulo ğ‘ em cada parcela observamos que a primeira 

delas, Ã© congruente a ğ‘ ğ‘šğ‘œğ‘‘ ğ‘ pela hipÃ³tese de induÃ§Ã£o. As demais sÃ£o fatores de ğ‘ 

e, portanto, para 1 â‰¤ ğ‘– â‰¤ ğ‘ âˆ’ 1 teremos 

(

ğ‘
ğ‘–

) â‰¡ 0 ğ‘šğ‘œğ‘‘ ğ‘ 

Logo, (ğ‘ + 1)ğ‘ â‰¡ ğ‘ğ‘ + 1 â‰¡ ğ‘ + 1 ğ‘šğ‘œğ‘‘ ğ‘ o que pelo princÃ­pio de induÃ§Ã£o, prova 

nosso teorema para o caso de ğ‘ natural. 

Note que se ğ‘ for um nÃºmero negativo, as congruÃªncias acima teriam o mesmo 

valor, o que torna o resultado indiferente para ğ‘ inteiro.  

âˆ 

Teorema 7 (Teorema de Euler). Se ğ‘š Ã© um inteiro positivo e ğ‘ um inteiro tal 

que ğ‘šğ‘‘ğ‘(ğ‘, ğ‘š) = 1, entÃ£o 

ğ‘ğœ™(ğ‘š) â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘š 

DemonstraÃ§Ã£o: A demonstraÃ§Ã£o deste teorema se encontra nas pÃ¡ginas 49 e 

50 do livro do Martinez [7]. 

Teorema 8 (Teorema de Wilson): Se ğ‘ Ã© primo, entÃ£o (ğ‘ âˆ’ 1)! â‰¡ âˆ’1 ğ‘šğ‘œğ‘‘ ğ‘. 

DemonstraÃ§Ã£o:   Inicialmente   observe   que   para   ğ‘ = 2,   temos    que 

(2 âˆ’ 1)! = 1! = 1 â‰¡ âˆ’1 ğ‘šğ‘œğ‘‘ 2  que Ã© vÃ¡lido. Iremos afirmar, mas sem demonstrar, que 

a  congruÃªncia  ğ‘. ğ‘¥ â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘,  possui  uma  Ãºnica  soluÃ§Ã£o  para  todo  ğ‘  no  conjunto 

 
 
 
24 

{1,2,3, . . . , ğ‘ âˆ’ 1}. A prova deste resultado encontra-se demonstrado no livro do Jose 

PlÃ­nio de Oliveira Santos em [5] pÃ¡ginas 37 e 38. 

Neste conjunto, note que somente  1 e ğ‘ âˆ’ 1 sÃ£o eles mesmos o seu prÃ³prio 

inverso mÃ³dulo ğ‘. Restando entÃ£o os nÃºmeros 2,3,4, . . . , ğ‘ âˆ’ 2; (ğ‘ âˆ’ 3) âˆ’nÃºmeros, que 
podem  ser  agrupados  cada  um  com  seu  inverso  mÃ³dulo  ğ‘,  formando  ğ‘âˆ’3
2

congruÃªncias.  Por  exemplo,  digamos  que  2  e  (ğ‘ âˆ’ ğ‘–)  sejam  inversos  um  do  outro, 

podemos entÃ£o formar a congruÃªncia 

2. (ğ‘ âˆ’ ğ‘–) â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘ 

Assim, ao multiplicarmos todas estas congruÃªncias, obteremos: 

2.3.4. â€¦ . (ğ‘ âˆ’ 2) â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘ 

multiplicando esta Ãºltima por (ğ‘ âˆ’ 1) teremos 

2.3.4. â€¦ . (ğ‘ âˆ’ 2). (ğ‘ âˆ’ 1) â‰¡ ğ‘ âˆ’ 1 â‰¡ âˆ’1 ğ‘šğ‘œğ‘‘ ğ‘ 

como o lado esquerdo desta igualdade Ã© (ğ‘ âˆ’ 1)!, temos entÃ£o que  

o que prova o resultado. 

(ğ‘ âˆ’ 1)! â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘ 

âˆ 

2.7 EquaÃ§Ãµes Diofantinas 

DefiniÃ§Ã£o  5.  Uma  equaÃ§Ã£o  da  ğ‘. ğ‘¥ + ğ‘. ğ‘¦ = ğ‘,  onde  ğ‘, ğ‘ e  ğ‘  sÃ£o  inteiros  Ã© 

chamada EquaÃ§Ã£o Diofantina Linear.  

Iremos analisar esta equaÃ§Ã£o, pois para determinar o inverso de um nÃºmero ğ‘ 

mÃ³dulo ğ‘›, devemos determinar qual nÃºmero ğ‘ satisfaz a condiÃ§Ã£o 

ğ‘. ğ‘ â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘› 

Ora, mas isto Ã© o mesmo que determinar ğ‘. ğ‘ âˆ’ 1 = ğ‘›. ğ‘˜ e daÃ­  

que Ã© uma EquaÃ§Ã£o Diofantina com ğ‘ = 1. 

ğ‘. ğ‘ + ğ‘›. (âˆ’ğ‘˜) = 1 

 
  
 
 
 
25 

Teorema 9.  Sejam ğ‘  e  ğ‘  inteiros  e ğ‘‘ = ğ‘šğ‘‘ğ‘(ğ‘, ğ‘).  Se ğ‘‘ âˆ¤ ğ‘  entÃ£o  a  equaÃ§Ã£o 

ğ‘. ğ‘¥ + ğ‘. ğ‘¦ = ğ‘ nÃ£o possui nenhuma soluÃ§Ã£o inteira. ğ‘†ğ‘’ ğ‘‘|ğ‘ ela possui infinitas soluÃ§Ãµes 

e se ğ‘¥ = ğ‘¥0 e ğ‘¦ = ğ‘¦0 Ã© uma soluÃ§Ã£o particular, entÃ£o todas as soluÃ§Ãµes sÃ£o dadas por 

ğ‘¥ = ğ‘¥0 +

ğ‘¦ = ğ‘¦0 âˆ’

ğ‘
ğ‘‘
ğ‘
ğ‘‘

. ğ‘˜ 

. ğ‘˜ 

onde ğ‘˜ Ã© um inteiro. 

DemonstraÃ§Ã£o: ComeÃ§amos observando que se ğ‘‘ âˆ¤ ğ‘, a equaÃ§Ã£o nÃ£o possui soluÃ§Ã£o, 

afinal como ğ‘‘ Ã© um divisor comum de ğ‘ e ğ‘, obviamente ele deveria dividir ğ‘.  

Suponhamos que ğ‘‘|ğ‘ pelo Teorema 2, temos que existem ğ‘š0 e ğ‘›0 tais que  

      ğ‘. ğ‘š0 + ğ‘. ğ‘›0 = ğ‘‘                       

    (2). 

Da hipÃ³tese ğ‘‘|ğ‘, existe um ğ‘˜ âˆˆ â„¤, tal que ğ‘ = ğ‘‘. ğ‘˜. Multiplicando a equaÃ§Ã£o (8) por ğ‘˜ 

obtemos    ğ‘. (ğ‘š0. ğ‘˜) + ğ‘. (ğ‘›0. ğ‘˜) = ğ‘‘. ğ‘˜ = ğ‘,    o  que     nos    leva    a    conclusÃ£o    que   

ğ‘¥0 = ğ‘š0. ğ‘˜ e ğ‘¦0 = ğ‘›0. ğ‘˜,   Ã© uma   soluÃ§Ã£o   de   ğ‘. ğ‘¥ + ğ‘. ğ‘¥ = ğ‘. 

Vamos verificar agora que o par (ğ‘¥, ğ‘¦) em que: 

ğ‘¥ = ğ‘¥0 +

ğ‘¦ = ğ‘¦0 âˆ’

ğ‘
ğ‘‘
ğ‘
ğ‘‘

. ğ‘˜ 

. ğ‘˜ 

sÃ£o tambÃ©m soluÃ§Ãµes da equaÃ§Ã£o. 

De fato, temos: 

ğ‘. ğ‘¥ + ğ‘. ğ‘¦ = ğ‘. (ğ‘¥0 +

ğ‘
ğ‘‘

. ğ‘˜) + ğ‘. (ğ‘¦0 âˆ’

ğ‘
ğ‘‘

. ğ‘˜) 

= ğ‘. ğ‘¥0 +

ğ‘. ğ‘
ğ‘‘

. ğ‘˜ + ğ‘. ğ‘¦0 âˆ’

ğ‘. ğ‘
ğ‘‘

. ğ‘˜ 

que cancelando obtemos: 

= ğ‘. ğ‘¥0 + ğ‘. ğ‘¦0 = ğ‘. 

Dessa forma, concluÃ­mos que a partir de uma soluÃ§Ã£o particular da EquaÃ§Ã£o 

Diofantina, podemos gerar outras infinitas variando pois, somente o parÃ¢metro ğ‘˜. 

Mostraremos agora que toda soluÃ§Ã£o da equaÃ§Ã£o ğ‘. ğ‘¥ + ğ‘. ğ‘¦ = ğ‘ Ã© da forma: 

ğ‘¥ = ğ‘¥0 +

ğ‘
ğ‘‘

. ğ‘˜ 

 
 
 
 
26 

ğ‘
ğ‘‘
Suponha que os pares (ğ‘¥, ğ‘¦) e  (ğ‘¥0, ğ‘¦0) sejam soluÃ§Ãµes da EquaÃ§Ã£o Diofantina. 

ğ‘¦ = ğ‘¦0 âˆ’

. ğ‘˜ 

Assim,  

e, portanto,  

ğ‘. ğ‘¥ + ğ‘. ğ‘¦ âˆ’ ğ‘. ğ‘¥0 âˆ’ ğ‘. ğ‘¦0 = ğ‘. (ğ‘¥ âˆ’ ğ‘¥0) + ğ‘. (ğ‘¦ âˆ’ ğ‘¦0) = 0 

ğ‘. (ğ‘¥ âˆ’ ğ‘¥0) = ğ‘. (ğ‘¦0 âˆ’ ğ‘¦) 

Como ğ‘šğ‘‘ğ‘(ğ‘, ğ‘) = ğ‘‘, temos pelo CorolÃ¡rio 1 que ğ‘šğ‘‘ğ‘ (

ğ‘

ğ‘‘

,

ğ‘

ğ‘‘

) = 1. Portanto, dividindo 

os dois membros da Ãºltima igualdade por ğ‘‘, teremos: 

ğ‘

. (ğ‘¥ âˆ’ ğ‘¥0) =

ğ‘

ğ‘‘

. (ğ‘¦0 âˆ’ ğ‘¦)                                            (3) 

|(ğ‘¥ âˆ’ ğ‘¥0) portanto existe ğ‘˜ âˆˆ â„¤ tal que: ğ‘¥ âˆ’ ğ‘¥0 = ğ‘˜.

ğ‘

ğ‘‘

, 

ğ‘‘
) = 1, ğ‘
ğ‘‘

Todavia,  como  ğ‘šğ‘‘ğ‘ (

ğ‘

ğ‘‘

,

ğ‘

ğ‘‘

ou seja ğ‘¥ = ğ‘¥0 + ğ‘˜.

ğ‘

ğ‘‘

. 

Substituindo a soluÃ§Ã£o encontrada na equaÃ§Ã£o (9) teremos 

ğ‘
ğ‘‘

. (ğ‘¥0 + ğ‘˜.

ğ‘
ğ‘‘

âˆ’ ğ‘¥0) =

ğ‘
ğ‘‘

. ğ‘¦ =

ğ‘
ğ‘‘

. ğ‘¦0 âˆ’

ğ‘
ğ‘‘

. ğ‘¦ 

. ğ‘¦0 âˆ’

ğ‘
ğ‘‘
ğ‘. ğ‘
ğ‘‘2 . ğ‘˜ 

Como querÃ­amos demonstrar. 

ğ‘¦ = ğ‘¦0 âˆ’

ğ‘
ğ‘‘

. ğ‘˜. 

âˆ 

Teorema 10 (Teorema ChinÃªs do Resto).    Se      ğ‘šğ‘‘ğ‘(ğ‘1, ğ‘šğ‘–) = 1, 

 ğ‘šğ‘‘ğ‘(ğ‘šğ‘–, ğ‘šğ‘—) = 1   para ğ‘– â‰  ğ‘— e ğ‘ğ‘– inteiro, entÃ£o o sistema 

ğ‘1. ğ‘¥ â‰¡ ğ‘1 ğ‘šğ‘œğ‘‘ ğ‘š1
ğ‘2. ğ‘¥ â‰¡ ğ‘2 ğ‘šğ‘œğ‘‘ ğ‘š2
ğ‘3. ğ‘¥ â‰¡ ğ‘3 ğ‘šğ‘œğ‘‘ ğ‘š3
â‹®
ğ‘ğ‘Ÿ. ğ‘¥ â‰¡ ğ‘ğ‘Ÿ ğ‘šğ‘œğ‘‘ ğ‘šğ‘Ÿ

possui soluÃ§Ã£o e a soluÃ§Ã£o Ã© Ãºnica mÃ³dulo ğ‘š, onde ğ‘š = ğ‘š1. ğ‘š2 â€¦ . . ğ‘šğ‘Ÿ 

DemonstraÃ§Ã£o:  Esta  demonstraÃ§Ã£o  estÃ¡  disponÃ­vel  no  livro  do  Martinez  [7]  nas 

pÃ¡ginas 81 e 82. 

âˆ 

 
 
 
 
27 

2.8 MIT App Inventor 2 

LanÃ§ado  em  15  de  dezembro  de  2010,  o  App  Inventor  for  Android  foi  um 

software web,  cuja proposta  era dar a  um usuÃ¡rio  leigo  em  qualquer linguagem  de 

programaÃ§Ã£o,  meios  para  que  o  mesmo  pudesse  desenvolver  um  aplicativo  para 

ambiente  Android.  Para  isso,  o  programador  utiliza  de  blocos  prÃ©-definidos, 

encaixÃ¡veis  que  sintetizam  de  maneira  prÃ¡tica  os  comandos  que  viriam  a  ser 

digitados.  A  interface  do  programa  permite  que  o  utilizador  usando  o  mouse  para 

arrastar e soltar os componentes, comandos e funÃ§Ãµes, encaixe blocos um no outros 

compondo o cÃ³digo fonte do sistema que estÃ¡ sendo desenvolvido. 

Esta plataforma foi desenvolvida pela equipe App Inventor Team incorporada 

ao Google, e liderada por Hal Abelson e Mark Friedman. Posteriormente em parceria 

com  o  Massachusetts  Institute  of  Technology  (MIT),  foram  realizadas  melhorias  na 

interface e estabilidade do sistema em 6 de dezembro de 2013, uma nova versÃ£o do 

software foi lanÃ§ada e batizada de MIT App Inventor 2. A atualizaÃ§Ã£o o tornou bastante 

funcional e estÃ¡vel, o que permitiu a criaÃ§Ã£o de aplicativos bem mais completos do 

que  a  primeira  versÃ£o  possibilitava.  Atualmente  Ã©  possÃ­vel  trabalhar  com  bases  de 

dados em nuvem, desenvolver jogos, sistemas de automaÃ§Ã£o comercial, dentre outros 

programas que de certo modo admitem um elevado grau de complexidade.  

Claro  que  esta  proposta  de  programaÃ§Ã£o  pode  limitar  um  pouco  as 

possibilidades de desenvolvimento, visto que seria impossÃ­vel disponibilizar todas as 

combinaÃ§Ãµes  de  blocos  possÃ­veis  para  o  usuÃ¡rio,  o  que  na  programaÃ§Ã£o 

convencional, com escrita manual do cÃ³digo fonte, o usuÃ¡rio tem a possibilidade de 

programar ao seu bel prazer, sem restriÃ§Ãµes de criaÃ§Ã£o. 

Em  2016,  o  Prof.  Dr.  Eduardo  Alves  do  Valle  Junior,  da  Faculdade  de 

Engenharia  ElÃ©trica  e  de  ComputaÃ§Ã£o  da  Universidade  Estadual  de  Campinas 

(Unicamp),  finalizou  um  projeto  de  traduÃ§Ã£o  do  MIT  App  Inventor  2  para  a  LÃ­ngua 

Portuguesa. Isto mobilizou o surgimento de alguns projetos voltados para o incentivo 

da  programaÃ§Ã£o  na  educaÃ§Ã£o  bÃ¡sica,  como  o  Projeto  ComputaÃ§Ã£o  na  Escola:  â€œA 

Iniciativa ComputaÃ§Ã£o na Escola Ã© dedicada a aumentar o ensino de computaÃ§Ã£o no 

 
 
28 

Ensino  Fundamental  e  MÃ©dio.  â€œNossa  visÃ£o  Ã©  que  todos  os  alunos  em  todas  as 

escolas devem ter a oportunidade de aprender computaÃ§Ã£o.â€ [8] 

O projeto acredita que a computaÃ§Ã£o deve fazer parte do currÃ­culo no Ensino 

Fundamental e MÃ©dio assim como as demais disciplinas. No site do projeto disponÃ­vel 

em [9], hÃ¡ bastante material sobre outros projetos que o mesmo desenvolve, inclusive 

outras plataformas com a mesma finalidade do MIT App. 

2.1.1. A Interface do Sistema 

Para acessar o MIT App Inventor 2 Ã© necessÃ¡rio acessar o link [10] e â€œlogarâ€ 

com  uma  â€œConta  Googleâ€.  Esse  tipo  de  conta  Ã©  obrigatÃ³ria  para  acessar  as 

funcionalidades de qualquer aparelho celular com o sistema operacional Android. Ao 

acessar a  plataforma,  o  usuÃ¡rio  irÃ¡  se  deparar  com  uma  tela  de  gerenciamento  de 

projetos como a da Figura 2: 

Figura 2 Tela Inicial MIT App Inventor II 

Fonte: http://ai2.appinventor.mit.edu. Acessado em 08/10/2019 

Na  tela  de  boas  vindas  conforme  a  Figura  2,  o  usuÃ¡rio  pode  gerenciar  seus 

projetos, criar, apagar, copiar, duplicar ou atÃ© mesmo acompanhar o desenvolvimento, 

quando feito em parceria com outros programadores. Caso nÃ£o haja nenhum projeto 

em andamento ou concluÃ­do, serÃ¡ apresentada uma lista vazia e nesse caso o usuÃ¡rio 

deve  iniciar  um  novo  projeto  do  zero,  seu  primeiro  projeto.  Ã‰  importante  salvar  os 

projetos com nomes que sejam de fÃ¡cil identificaÃ§Ã£o e/ou a sua versÃ£o, caso seja o 

caso. A plataforma nÃ£o permite a utilizaÃ§Ã£o de caracteres especiais ou espaÃ§os em 

 
 
29 

branco  no  nome  do  projeto.  Na  tela  inicial  tambÃ©m  Ã©  possÃ­vel  ajustar  o  idioma  da 

plataforma e acessar o menu de ajuda. 

ApÃ³s criar um projeto e nomeÃ¡-lo, o usuÃ¡rio irÃ¡ acessar uma segunda tela, 

agora com todos os elementos necessÃ¡rios para iniciar o processo de criaÃ§Ã£o do 

aplicativo. 

Figura 3 Tela de Designer de Aplicativo do MIT App Inventor II 

1 

2 

3 

4 

Fonte: Imagem trabalhada pelo autor  

A 

tela  de  desenvolvimento,  possui  quatro 

regiÃµes  com  diferentes 

funcionalidades.  A  primeira,  indicada  na  Figura  3,  com  o  nÃºmero  1,  Ã©  o  banco  de 

componentes que podem ser utilizados no App, nele o usuÃ¡rio terÃ¡ acesso a botÃµes, 

caixas  de  texto,  legendas,  caixas  para fotos,  base de dados,  cÃ¢mera,  entre  outros. 

Basicamente os componentes sÃ£o os meios pelos quais possibilitam a interaÃ§Ã£o entre 

o  aplicativo  e  quem  o  utiliza.    Em  seguida,  vem  a  Zona  2,  que  o  local  onde  o 

programador pode ajustar os componentes na interface do aplicativo, dispondo-os da 

maneira como serÃ¡ apresentada no projeto final. A Zona 3, Ã© uma listagem de todos 

os adereÃ§os que compÃµe a tela do aplicativo. Isso auxilia na navegaÃ§Ã£o de quem estÃ¡ 

desenvolvendo um sistema que tenha inÃºmeros componentes e, que muitas vezes hÃ¡ 

uma  combinaÃ§Ã£o  de  componentes,  um  dentro  do  outro.  Finalmente,  na  Zona  4,  Ã© 

possÃ­vel ajustar algumas configuraÃ§Ãµes dos componentes e da tela que estÃ¡ sendo 

desenvolvida como renomear um componente, ajustar cores, tamanho dentre outras 

 
 
 
30 

caracterÃ­sticas. Na barra superior em verde, pode-se criar outras telas (Screens), pois 

geralmente os aplicativos sÃ£o formados por um conjunto de telas que interagem umas 

com as outras no decorrer da utilizaÃ§Ã£o e acessar a interface de blocos que o espaÃ§o 

onde realmente ocorrerÃ¡ a programaÃ§Ã£o do app que estÃ¡ sendo desenvolvido.  

Ao  clicar  no  botÃ£o  blocos,  o  desenvolvedor  terÃ¡  acesso  a  interface  â€œBlocosâ€ 

onde poderÃ¡ realizar a combinaÃ§Ã£o dos blocos de cÃ³digo a cada componente que Ã© 

adicionado na tela de designer, novos blocos surgem na tela de blocos, possibilitando 

uma vasta combinaÃ§Ã£o entre eles. 

Figura 4 Interface de ProgramaÃ§Ã£o 

1 

2 

3 

Fonte: Imagem trabalhada pelo autor. 

Podemos dividir esta tela em trÃªs zonas distintas. Na primeira temos acesso 

aos  blocos:  comandos  de  controle,  funÃ§Ãµes,  conectivos  lÃ³gicos  ou  matemÃ¡ticos, 

definiÃ§Ã£o e utilizaÃ§Ã£o de variÃ¡veis tudo que Ã© necessÃ¡rio para o implemento de cÃ³digos 

como pode ser visto na Figura 4. A zona 2 Ã© feita a montagem, arrastando-se os blocos 

da Zona 1 os combinando e finalmente a Zona 3 serve para apagar algum cÃ³digo, dar 

zoom  e  se  localizar,  pois  ao  encaixas  as  peÃ§as,  muitas  vezes  o  programa  acaba 

ficando  bem  extenso.  Na  mochila  no  canto  superior  direito,  Ã©  possÃ­vel  guardar 

algumas combinaÃ§Ãµes de blocos que foram utilizadas em um ou outro aplicativo e que 

possa ser reaproveitado em alguma outra tela, isso evita ter que â€œreescreverâ€ todo o 

processo. 

 
 
 
31 

2.2. DivisÃ£o e a SeguranÃ§a de Redes: a Criptografia 

Para iniciarmos, vamos fazer uma anÃ¡lise do sistema criptogrÃ¡fico utilizado por 

JÃºlio  CÃ©sar,  o  qual  explanamos  na  IntroduÃ§Ã£o  deste  trabalho.  Suponha  que  JÃºlio 

CÃ©sar assinasse todas as cartas, entÃ£o a pessoa saberia ao final que a Ãºltima palavra 

seria seu nome e isto jÃ¡ bastaria para desvendar este tipo de permutaÃ§Ã£o.  

Ã‰ possÃ­vel melhorar um pouco esta permutaÃ§Ã£o causando algumas dificuldades 

para  desvendar  seu  segredo.  Para  isto  vamos  tomar  por  base  algumas  definiÃ§Ãµes. 

Precisamos  primeiro  considerar  que  o  alfabeto  Ã©  ordenado  e  transformÃ¡-lo  em 

nÃºmeros.  Assim  poderemos  operar  com  os  mesmos,  utilizando  ferramentas 

matemÃ¡ticas.  Considere  a  princÃ­pio  uma  correspondÃªncia  simples  em  que  ğ´  =  1,

ğµ  =  2, ğ¶  =  3, ... e, assim, por diante atÃ© atingirmos ğ‘ = 26 conforme a Figura 3.1.  

Para ilustrar, na Figura 5 Ã© apresentado como serÃ¡ o nosso alfabeto, em que iremos 

construir todos os sistemas que serÃ£o trabalhados a partir deste ponto. 

Figura 5 CorrespondÃªncia da Cifra de CÃ©sar 

Fonte: O autor 

Feito isso, jÃ¡ podemos interpretar cada mensagem como um cÃ³digo numÃ©rico.  

Por exemplo, a palavra CIDADE, seria o nÃºmero 3 9 4 1 4 5. 

A parte interessante de fazer essa atribuiÃ§Ã£o Ã© que cada letra do alfabeto pode 
ser visualizada como uma classe de equivalÃªncia em â„¤26 onde  ğ´ = 1Ì…, ğµ = 2Ì…, â€¦ , ğ‘ =
26Ì…Ì…Ì…Ì….  Desse  modo  podemos  representar  a  Cifra  de  CÃ©sar  pela  transformaÃ§Ã£o  linear 
ğ¸(ğ‘‹Ì…) = ğ‘‹Ì… + 3Ì…  em  â„¤26  e,  assim,  ğ¸(ğ´Ì…) = ğ¸(ğ‘‹Ì…) = 1Ì…ğ´ + 3Ì… =   1Ì… + 3Ì… = 4Ì… = ğ·  e,  de  modo 
sucessivo ğ¸(ğ‘Ì…) = 26Ì…Ì…Ì…Ì… + 3Ì… = 29Ì…Ì…Ì…Ì… = 3Ì… = ğ¶. 

Esse sistema, criado por JÃºlio CÃ©sar, nos servirÃ¡ de base para estudarmos uma 

infinidade  de  outros  sistemas  que  podem  ser  classificados  como  os  Sistemas  de 

Criptografia Linear ou Cifras de TransposiÃ§Ã£o, o qual serÃ¡ apresentado e discutido a 

seguir. 

 
 
 
 
 
 
 
 
 
32 

3.   CRIPTOGRAFIA 

Finalmente chegamos Ã  parte que delineamos este estudo, a criptografia. Neste 

capÃ­tulo serÃ£o abordados alguns mÃ©todos criptogrÃ¡ficos que surgiram no decorrer dos 

anos, bem como seu funcionamento, os prÃ³s e os contras.  

3.1. Sistema de Criptografia Linear 

Seja A um alfabeto ordenado com L letras. 

DefiniÃ§Ã£o  6.  Definimos  como  um  Sistema  de  Criptografia  Linear,  toda 

transformaÃ§Ã£o       ğœ: â„¤L  â†’ â„¤L      definida    por  ğœ(ğ‘‹) =  ğ‘. ğ‘‹  + b    onde    ğ‘, ğ‘ âˆˆ â„¤L     

e  ğ‘šğ‘‘ğ‘(ğ‘, ğ¿)   =  1. Chamaremos tambÃ©m ğ‘ e ğ‘ de ğ‘â„ğ‘ğ‘£ğ‘’ğ‘  ğ‘‘ğ‘œ ğ‘ ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘šğ‘.  

Note  que  ğœ  Ã©  uma  bijeÃ§Ã£o,  pois  dado  ğ‘Œ  =  ğ‘. ğ‘‹  +  ğ‘  em â„¤L  existe  ğ‘‹ =

ğ‘âˆ’1. (ğ‘Œ âˆ’ ğ‘),  visto  que  da  forma  que  ğ‘  Ã©  tomado  ele  sempre  admitirÃ¡  inverso 

multiplicativo no â„¤L. Portanto ğœ Ã© uma permutaÃ§Ã£o. 

Deste modo, se considerarmos, por exemplo, a permutaÃ§Ã£o 

ğœ(ğ‘‹) = 17Ì…Ì…Ì…Ì…2. ğ‘‹ + 12Ì…Ì…Ì…Ì… 

teremos  o  seguinte  cÃ³digo  representado  na  Figura  6,  que  mostra  os  resultados  de 

cada letra (alfabeto) quando aplicada a funÃ§Ã£o ğœ. 

Figura 6 PermutaÃ§Ã£o segundo ğœ 

Fonte: O autor 

2 Usaremos a notaÃ§Ã£o ğ‘Ì… apenas com o intuito de simplificar a notaÃ§Ã£o de congruÃªncia por detrÃ¡s das 
operaÃ§Ãµes. Por exemplo, ao invÃ©s de escrevermos que 27 â‰¡ 1 ğ‘šğ‘œğ‘‘ 26 usaremos somente 1Ì…. A partir 
de agora, todas as nossas congruÃªncias serÃ£o mÃ³dulo 26. 

 
 
 
 
 
 
                                                           
33 

E assim, a palavra JÃšLIO CÃ‰SAR cifrada por essa permutaÃ§Ã£o seria codificada 

como ZEHIG KSWCF. Apesar da sensaÃ§Ã£o de que criamos uma verdadeira mistura 

nas correspondÃªncias, esse sistema possui uma falha, pois caso o invasor faÃ§a, por 

exemplo, uma anÃ¡lise de frequÃªncia da mensagem e descubra quais os caracteres 

mais aparecem, de  modo  a   ter  certeza  de  duas  informaÃ§Ãµes,  como ğœ(ğ‘) = ğ½   e  

 ğœ(ğ¸) = ğ‘ˆ, ele poderia entÃ£o decodificar a mensagem resolvendo o sistema. 

ğ‘. 26Ì…Ì…Ì…Ì… + ğ‘ = 10Ì…Ì…Ì…Ì…
{
ğ‘. 5Ì… + ğ‘ = 21Ì…Ì…Ì…Ì…

Como 26Ì…Ì…Ì…Ì… = 0Ì…,  este sistema se torna bem simples de resolver, pois terÃ­amos da 

primeira equaÃ§Ã£o que ğ‘ = 10Â´  e substituindo o resultado na segunda obterÃ­amos  

ğ‘. 5Ì… = 11Ì…Ì…Ì…Ì… 

Resolver  para  quais  valores  de  ğ‘,  a  equaÃ§Ã£o  ğ‘. 5Ì… = 11Ì…Ì…Ì…Ì…  Ã©,  em  sua  essÃªncia, 
encontrar um ğ‘ âˆˆ â„¤26 de modo que quando dividirmos ğ‘. 5Ì…  e 11Ì…Ì…Ì…Ì… por 26, obteremos o 
mesmo resto. Podemos entÃ£o reescrever o problema como ğ‘. 5Ì… â‰¡ 11Ì…Ì…Ì…Ì… ğ‘šğ‘œğ‘‘ 26 que pode 

ser reescrito como ğ‘. 5 âˆ’ 11 = 26. ğ‘˜ obtendo assim a EquaÃ§Ã£o Diofantina: 

ğ‘. 5 + 26. ğ‘˜ = 11 

a  qual  resolvendo,  encontramos  ğ‘ = 23Ì…Ì…Ì…Ì….  Deste  modo,  teremos  entÃ£o  que  a 

funÃ§Ã£o  inversa  ğœâˆ’1(ğ‘‹) = 23Ì…Ì…Ì…Ì…. ğ‘‹ + 10Ì…Ì…Ì…Ì…  irÃ¡  decodificar  a  mensagem.  VÃª-se  entÃ£o  que  o 

sistema pode ser bastante frÃ¡gil, pois conhecidas 2 permutaÃ§Ãµes sempre poderemos 

descobrir as chaves ğ‘ e ğ‘. 

3.2. Trabalhando com Blocos 

Como vimos anteriormente, codificar uma Ãºnica letra torna um cÃ³digo bastante 

vulnerÃ¡vel, visto que o estudo das frequÃªncias faz com  que seja possÃ­vel identificar 

um padrÃ£o na mensagem codificada.  

Segundo Lemos, que pode ser visto em [11], uma forma de evitar ataques a um 

sistema de criptografia por meio de uma anÃ¡lise de frequÃªncia das letras Ã© trabalhar 

com as mensagens enviadas em blocos. A ideia Ã© substituir um bloco de ğ‘˜ letras, em 

que ğ‘˜ Ã© um natural, por outro bloco de ğ‘™ de letras. Quando utilizamos o mÃ©todo Linear 

 
 
 
 
 
 
 
34 

na  subseÃ§Ã£o  3.1, fizemos ğ‘˜  =  1,  iremos agora  generalizar essa  ideia para  valores 

maiores.  

Dado um alfabeto A com L letras, podemos representar cada bloco de ğ‘˜ letras 

por  um  natural  ğ‘ na  base  L  tal  que  0  â‰¤  ğ‘  <   ğ¿ğ‘˜   .  De  fato,  se  tomarmos  o  bloco 

(ğ‘1 ğ‘2. . . ğ‘ğ‘˜)ğ¿ teremos: 

(ğ‘1ğ‘2. . . ğ‘ğ‘˜)ğ¿   =   ğ‘1.ğ¿ğ‘˜âˆ’1 + ğ‘2. ğ¿ğ‘˜âˆ’2+. . . +ğ‘ğ‘˜. ğ¿0 

como ğ‘ğ‘– pertence ao alfabeto ordenado tal que  ğ´  =  0, . . . ğ´ğ¿   =  ğ¿  âˆ’  1 temos 

que o menor bloco que possuiremos serÃ¡ (00. . .0) (ğ‘˜ âˆ’ ğ‘§ğ‘’ğ‘Ÿğ‘œğ‘ ) e o maior 

(ğ¿  âˆ’  1ğ¿  âˆ’  1 . . . ğ¿  âˆ’  1) (ğ‘˜ âˆ’ ğ‘£ğ‘’ğ‘§ğ‘’ğ‘ ) 

assim 

0. ğ¿ğ‘˜âˆ’1+. . . +0. ğ¿0 â‰¤ (ğ‘1ğ‘2. . . ğ‘ğ‘˜). ğ¿ < (ğ¿ âˆ’ 1). ğ¿ğ‘˜âˆ’1+. . . +(ğ¿ âˆ’ 1). ğ¿0 

e,  claramente,  o  Ãºltimo  membro  da  desigualdade  pode  reescrito  como 

(ğ¿ âˆ’ 1). (ğ¿ğ‘˜âˆ’1 + ğ¿ğ‘˜âˆ’2 + â‹¯ + ğ¿0) = ğ¿ğ‘˜ âˆ’ 1 por se tratar de uma P.G finita. 

Em  outras  palavras,  ao  invÃ©s  de  considerarmos  um  alfabeto  com  apenas  ğ¿ 

letras  estaremos  considerando  um  novo  alfabeto  com  ğ¿ğ‘˜  â€œletrasâ€,  onde  cada  uma 

dessas â€œletrasâ€ Ã© na verdade um bloco. 

k
Definindo  uma funÃ§Ã£o    ğœ:    â„¤L

  â†’ â„¤L

k  onde  ğœ(ğ‘‹) = ğ‘. ğ‘‹ + ğ‘,  com  ğ‘ âˆˆ â„¤ğ¿ğ‘˜  e  ğ‘ âˆˆ â„¤ 

teremos tambÃ©m uma permutaÃ§Ã£o bem definida, pois ğœ tambÃ©m serÃ¡ uma bijeÃ§Ã£o.  

Como  exemplo,  vamos  transmitir  uma  mensagem  em  blocos  de  tamanho         

ğ‘˜ = 3 a palavra MATEMATICA. Para dividirmos em blocos de tamanho exatamente 3, 

serÃ¡  preciso  completar  a  palavra  com  a  primeira  letra  do  alfabeto3  A,  teremos, 

portanto, MATâˆ’EMAâˆ’TICâˆ’AAA, vamos utilizar a funÃ§Ã£o de permutaÃ§Ã£o 

Deste modo 

ğœ(ğ‘‹) =   5779

Ì…Ì…Ì…Ì…Ì…Ì…Ì…. ğ‘‹  +  123Ì…Ì…Ì…Ì…Ì…Ì…4 

(MAT)27 = 12.272 + 0.271 + 19.270 = 8767 

3 Neste exemplo utilizaremos o alfabeto definido por Lemos [11], onde ğ´ = 0, ğµ = 1, . . . ğ‘ = 25, sem que 

haja  prejuÃ­zo  a  teoria.  No  trabalho  utilizamos  o  alfabeto  definido  inicialmente  apenas  para  facilitar  o 

processo de programaÃ§Ã£o. 

4 Considere neste caso as congruÃªncias mÃ³dulo 263 

 
 
                                                           
35 

(EMA)27 = 4.272 + 12.271 + 0.270 = 3240 

(T IC)27 = 19.272 + 8.271 + 2.270 = 14069 

(AAA)27 = 0.272 + 0.271 + 0.270 = 0 

aplicando ğœ em cada bloco numÃ©rico, teremos 

ğœ (8767)   =  50664616  =  574  

ğœ (3240)   =  18724083  =  5550  

ğœ (14069)   =  81304874  =  14084  

ğœ(0)   =  123  =  123 

finalmente, fazendo a correspondÃªncia, teremos que 

574  =   0.272   +  21.27  +  7  =   (ğ´ğ‘‰ğ»)  

5550  =   7.272   +  16.27  +  15.27  =   (ğ»ğ‘„ğ‘ƒ) 

 14084  =   19.272   +  8.27  +  17  =   (ğ‘‡ğ¼ğ‘…) 

 123  =   0.272   +  4.27  +  15  =   (ğ´ğ¸ğ‘ƒ) 

Para que tenhamos uma ideia de quÃ£o embaralhadas ficaram as letras, vamos 

comparar  a  mesma  palavra  com  o  primeiro  sistema,  quando  usamos  ğ‘˜  = 1  e              

ğœ(ğ‘‹) = 17.Â´ ğ‘‹ + 12Â´ , com o arranjamento por blocos de tamanho ğ‘˜  =  3. 

Figura 7 ComparaÃ§Ã£o ğ‘˜ = 1 e ğ‘˜ = 3 

Fonte: O autor 

Observe  na  Figura  7  uma  melhora  significativa  apenas  com  a  mudanÃ§a  do 

tamanho  do  bloco.  Ainda  segundo  Lemos  [11]  quanto  maior  o  bloco,  maior  a 

dificuldade em se quebrar o sistema por uma anÃ¡lise de frequÃªncias. Para ğ‘˜  =  8 esta 

tarefa seria jÃ¡ muito complexa, se nÃ£o impossÃ­vel. 

 
 
 
36 

Usando este modelo de decodificaÃ§Ã£o, o cÃ³digo se torna mais eficiente, porÃ©m 

ainda continua com falhas operacionais gravÃ­ssimas, que pode tornar sua utilizaÃ§Ã£o 

na prÃ¡tica pouco eficiente.  

Para  que  o  receptor  leia  a  mensagem,  Ã©  preciso  ter  minimamente  o 

conhecimento  das  chaves  ğ‘  e  ğ‘  e,  em  algumas  situaÃ§Ãµes,  o  tamanho  do  bloco 

utilizado. Eis que surge entÃ£o a dÃºvida: Como enviar as chaves para o receptor da 

mensagem em seguranÃ§a? Afinal, reflitamos, caso tenhamos um canal seguro para 

envio dessas chaves, por que nÃ£o enviar logo a mensagem por ele? Assim, partindo 

desta necessidade, nasce o conceito de chave pÃºblica, o qual iremos abordar a seguir. 

Idealizar um sistema criptogrÃ¡fico em que nÃ£o seja necessÃ¡rio enviar previamente as 

chaves para que o receptor decodifique a mensagem. 

3.3. O Conceito de Chave PÃºblica 

A ideia de criptografar com chave pÃºblica foi proposta de maneira teÃ³rica em 

1976, por Diffie e Hellman [11]. O objetivo deste modelo era montar um sistema em 

que os usuÃ¡rios pudessem trocar mensagens sem ter que, obrigatoriamente, efetuar 

a troca de chaves.  

Para ilustrar melhor, temos um exemplo: Suponha que Pedro e JÃºlia desejam 

trocar mensagens secretas, mas nÃ£o dispÃµem de nenhum sistema criptogrÃ¡fico. Pedro 

poderia colocar sua mensagem em um baÃº e colocar um cadeado que somente ele 

possuÃ­sse a chave. Depois, esse baÃº seria enviado para JÃºlia, que nÃ£o iria conseguir 

abri-lo,  e  esta  colocaria  outro  cadeado  no  baÃº,  que  somente  ela  possui  a  chave. 

Novamente esse baÃº voltaria a Pedro que removeria seu cadeado e enviaria o baÃº 

novamente  a  JÃºlia,  que  ao  final  o  receberia  somente  com  seu  cadeado,  e  assim, 

conseguiria,  depois  de  muitas  idas  e  vindas,  ter  acesso  Ã   mensagem.  Claro  que 

estamos supondo que no meio de tantas viagens esse baÃº poderia ser arrombado ou 

extraviado, mas nÃ£o  compete  a nÃ³s  decidir o  destino  do  baÃº  e  sim  compreender a 

maneira simbÃ³lica de fazer a criptografia acontecer. 

O  fato  de  nÃ£o  termos  que  enviar  a  chave  em  momento  algum  Ã©  o  que 

transforma os sistemas de chave pÃºblica ou AssimÃ©trica em algo muito vantajoso a 

 
 
 
 
 
37 

ser  utilizado.  Na  prÃ¡tica  esse  sistema  funciona  da  seguinte  forma.  Pedro  e  JÃºlia, 

possuem chaves de E e D de encriptaÃ§Ã£o e decriptaÃ§Ã£o de um mesmo sistema. Na 

prÃ¡tica essas chaves sÃ£o diferentes apenas nos nÃºmeros que as compÃµem. Sejam Ep 

e Dp as chaves de Pedro e Ej e Dj as de JÃºlia. Assim, os usuÃ¡rios JÃºlia e Pedro irÃ£o 

esconder suas chaves de decodificaÃ§Ã£o Dp e Dj e tornarÃ£o pÃºblicas suas chaves de 

encriptaÃ§Ã£o, Ep e Ej . Deste modo, para que Pedro envie uma mensagem M a JÃºlia, 

basta ele aplicar sobre esta mensagem o algoritmo de encriptaÃ§Ã£o de JÃºlia e, depois, 

o seu algoritmo de decriptaÃ§Ã£o assim, ele obteria Dp(Ej (M)) e esta mensagem seria 

enviada a JÃºlia que para conseguir ler bastaria aplicar Ep e depois Dj assim terÃ­amos 

daÃ­, 

Ep (Dp(Ej (M))) = Ej (M) 

Dj (Ej (M)) = M 

Podemos montar um exemplo utilizando SCL que vimos na seÃ§Ã£o anterior.  

Considere que Pedro e JÃºlia utilizam o sistema criptogrÃ¡fico acima, em blocos 

de tamanho predefinido k onde Pedro utiliza a funÃ§Ã£o de permutaÃ§Ã£o ğœ cuja inversa Ã© 

ğœâˆ’1 e JÃºlia utiliza a funÃ§Ã£o Ï e Ï-1 assim, eles podem tornar pÃºblicas as suas chaves 

de encriptaÃ§Ã£o ğœ e Ï. Assim, para  Pedro  enviar  uma  mensagem  a JÃºlia,  ele  farÃ¡  

Ï(ğœ-1 (M)) e JÃºlia com sua chave privada conseguirÃ¡ identificar a mensagem de Pedro. 

Mas! Temos  neste  ponto,  um pequeno problema.  Se  supormos  a chave  pÃºblica de 

Pedro  ğœ(ğ‘‹) =  ğ´. ğ‘‹  +  ğµ, Ã© possÃ­vel encontrar facilmente a chave privada, pois dado 

ğ‘Œ  =  ğ´. ğ‘‹  +  ğµ,  conseguimos  obter  a  inversa  de  ğœ  fazendo  ğ‘‹  =   ğ´âˆ’1 . (ğ‘‹  âˆ’  ğµ),  ou 

seja, basta encontrar o inverso multiplicativo de ğ´ em â„¤ğ¿ğ‘˜ . O que Ã© uma tarefa bem 
simples se usarmos o algoritmo de Euclides estendido. Assim, podemos concluir que, 

nem  todo  sistema  de  criptografia  Ã©  adequado  a  ser  utilizado  em  chaves  pÃºblicas. 

Precisamos entÃ£o, de um sistema que nÃ£o seja possÃ­vel obter a chave privada atravÃ©s 

da chave pÃºblica. 

3.4. O RSA 

Iremos tratar agora sobre a matemÃ¡tica envolvida no Sistema RSA, que serÃ¡ 

de tratado de maneira mais aplicada. Segundo Coutinho em [1] o RSA, foi proposto 

 
 
  
 
38 

em 1978 por Rivest, Shamir e Adleman, cujas iniciais dos nomes de seus respectivos 

criadores  batizaram  o  sistema.  Ã‰  sabido  que  o  RSA  Ã©  largamente  utilizado  para 

garantir  a  seguranÃ§a  da  troca  de  informaÃ§Ãµes  entre  usuÃ¡rios  na  internet.  Para  que 

possamos utilizar o seu algoritmo, faz-se necessÃ¡rio primeiramente a definiÃ§Ã£o de um 

alfabeto. Neste caso continuaremos a utilizar o mesmo alfabeto do SCL que vai de A 

a Z, que possui 26 letras, chamaremos esse nÃºmero de ğ¿, porÃ©m isso nos obrigarÃ¡ a 

fazer  uma  certa  separaÃ§Ã£o  no  envio  das  mensagens.  Em  alguns  casos  utiliza-se  o 

alfabeto  com  27  posiÃ§Ãµes,  conta-se  de  A  a  Z  e  acrescenta-se  um  caractere  que 

representa o espaÃ§o.  

Primeiramente,  devemos  escolher  dois  nÃºmeros  primos  ğ‘  e  ğ‘  e  outros  dois 

nÃºmeros inteiros ğ‘Ÿ e ğ‘   de modo que eles se relacionem da seguinte forma: 

ğ¿ğ‘Ÿ < ğ‘. ğ‘ < ğ¿ğ‘  

pensar  numericamente  ajudarÃ¡  a  facilitar  o  entendimento.  Tomaremos  no  decorrer 

deste texto, ğ‘Ÿ = 2 e ğ‘  = 3, teremos entÃ£o que escolher ğ‘ e ğ‘ de modo que 

262 < ğ‘. ğ‘ < 263 

729 < ğ‘. ğ‘ < 19683 

Como nÃ£o iremos ter capacidade de fazer cÃ¡lculos com nÃºmeros grandes, pois 

tomaria muito tempo e talvez fosse necessÃ¡rio um computador com um bom programa 

de computaÃ§Ã£o algÃ©brica para que vocÃª pudesse acompanhar, podemos procurar nos 

primos de 1 a 50, dois, que satisfaÃ§am essa condiÃ§Ã£o na Figura 8 

Figura 8 Produto de Primos de 1 a 50 

Fonte: O autor 

 
 
39 

Vamos escolher ğ‘ = 23 e ğ‘ = 41 e assim ğ‘. ğ‘ = ğ‘› = 943, temos quase todos os 

prÃ©-requisitos para obtenÃ§Ã£o das chaves de EncriptaÃ§Ã£o e DecriptaÃ§Ã£o.  

Retomando  os  nÃºmeros  que  havÃ­amos  definido  anteriormente,  temos  agora 

que montar as chaves de CodificaÃ§Ã£o e DecodificaÃ§Ã£o. HavÃ­amos escolhido  ğ‘Ÿ  =  2, 

ğ‘   =  3, ğ‘›  =  943 = 23.41. Para gerar a primeira chave, precisamos calcular o valor de 

âˆ…(ğ‘›) = (ğ‘ âˆ’ 1). (ğ‘ âˆ’ 1),  assim  âˆ…(943) = (23 âˆ’ 1). (41 âˆ’ 1) = 880.  Escolhemos  agora  o 

menor natural ğ‘’ tal que ğ‘šğ‘‘ğ‘(ğ‘’, 880) = 1, que no caso Ã© 3. 

Feito  isso,  acabamos  de  criar  a  nossa  chave  de  encriptaÃ§Ã£o/codificaÃ§Ã£o  ou 

chave pÃºblica. No Sistema RSA Ã© indiferente a escolha da chave que serÃ¡ pÃºblica ou 

privada, porÃ©m temos um apreÃ§o por manter a primeira chave como a pÃºblica visto 

que o processo para determinÃ¡-la Ã© mais simples do que o processo para obtenÃ§Ã£o 

da  chave  privada,  alÃ©m  de  que,  no  mÃ©todo  que  utilizamos,  Ã©  mais  difÃ­cil  acertar  a 

chave privada por tentativa do que a chave pÃºblica. Assim, nossa chave pÃºblica serÃ¡ 

(ğ‘›, ğ‘’), neste caso (943, 3). 

A chave privada, serÃ¡   obtida   procurando um   nÃºmero ğ‘‘,   de   modo    que  

ğ‘‘. ğ‘’ â‰¡ 1 ğ‘šğ‘œğ‘‘ ğœ™(ğ‘›) 

o que parece ser uma tarefa um pouco mais complexa. Devemos sempre procurar ğ‘‘ 

de tal maneira que ğ‘‘ < ğœ™(ğ‘›).  

Para nosso exemplo, iremos resolver a seguinte congruÃªncia 

ğ‘‘. 3 â‰¡ 1 ğ‘šğ‘œğ‘‘ 880 

que Ã© equivalente a determinar uma soluÃ§Ã£o da EquaÃ§Ã£o Diofantina 

ğ‘‘. 3 + 880. ğ‘˜ = 1 

assim obtendo ğ‘‘ = 587, e, portanto, a chave privada (943,587). 

VocÃª pode estar se preguntando sobre os nÃºmeros ğ‘Ÿ e ğ‘  que definimos no inÃ­cio 

desta  seÃ§Ã£o.  O  mÃ©todo  RSA  pode  ser  utilizado  de  vÃ¡rias  formas,  e  uma  delas  Ã©, 

inclusive, atravÃ©s do sistema de blocos. No momento de criptografar uma mensagem, 

Ã©  possÃ­vel dividi-la  em  blocos  de  tamanho  ğ‘Ÿ,  criptografÃ¡-la  e  enviÃ¡-la  em  blocos  de 

tamanho ğ‘ .  

Iremos tratar de algumas das formas que elas sÃ£o feitas. PorÃ©m, a proposta 

desse  trabalho,  serÃ¡  utilizar  o  mÃ©todo  mais  simples,  de  modo  que  seja  facilmente 

aplicado na sala de aula.  

 
 
40 

3.4.1. CodificaÃ§Ã£o letra-a-letra 

Antes de iniciar a codificaÃ§Ã£o, devemos fazer um processo de prÃ©-codificaÃ§Ã£o, 

onde  transformaremos  as  letras  em  nÃºmeros  (de  acordo  o  alfabeto  definido).  Em 

seguida  o  autor da mensagem, de posse  da  chave pÃºblica  do  receptor ao  qual ele 

deseja enviar a mensagem, irÃ¡ elevar cada bloco da mensagem (que representa cada 

letra)  por  ğ‘’,  e  encontrar  o  mÃ³dulo  da  divisÃ£o  deste  resultado  por  ğ‘›,  ou  seja,  se 

desejamos enviar a mensagem ğ‘1ğ‘2ğ‘3 â€¦ ğ‘ğ‘› devemos encontrar ğ‘1ğ‘2ğ‘3 â€¦ ğ‘ğ‘› onde 

ğ‘’ â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ ğ‘›
ğ‘1
ğ‘’ â‰¡ ğ‘2ğ‘šğ‘œğ‘‘ ğ‘›
ğ‘2
â‹®
ğ‘’ â‰¡ ğ‘ğ‘›ğ‘šğ‘œğ‘‘ ğ‘›
ğ‘ğ‘›

a sequÃªncia numÃ©rica ğ‘1ğ‘2 â€¦ ğ‘ğ‘› serÃ¡ nossa mensagem codificada. 

Vamos enviar a palavra C I D A D E que a havÃ­amos codificado como, 3 9 4 1 

4 5. Temos entÃ£o que resolver as congruÃªncias: 

33 â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘1 = 27
93 â‰¡ ğ‘2ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘2 = 729
43 â‰¡ ğ‘3ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘3 = 64
13 â‰¡ ğ‘4ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘4 = 1
43 â‰¡ ğ‘5ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘5 = 64
53 â‰¡ ğ‘6ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘6 = 125

Parece que conseguimos, mas para uma anÃ¡lise mais detalhada,  observa-se 

que temos alguns problemas na forma que fizemos a encriptaÃ§Ã£o. Observe que, letras 

repetidas obtiveram a mesma codificaÃ§Ã£o. AlÃ©m disso, observe os resultados obtidos, 

eles  formam  simplesmente  o  cubo  do  nÃºmero  correspondente  a  letra.  Isso  se  dÃ¡ 

devido ao fato destas potÃªncias serem menores do que 943, ou seja, o algoritmo sÃ³ 

farÃ¡  uma  mudanÃ§a  mais  eficiente  se  as 

letras  envolvidas  obtiverem  um 

correspondente maior do que 10, isto Ã©, a partir do J. AlÃ©m disso, a letra A que Ã© igual 

a 1, sempre serÃ¡ codificada como 1 apÃ³s a aplicaÃ§Ã£o do algoritmo, o que seria uma 

pista  e  tanto  para  decodificarmos  a  mensagem.  Como  resolvermos  isso?  Bom, 

existem  dois  modos,  um  que  seria  ao  invÃ©s  de  codificar  letra  a  letra,  codificarmos 

blocos de duas letras ou mais, de acordo o nosso ğ‘Ÿ. Mas, para isto temos que tomar 

o cuidado de nenhum bloco ultrapassar o tamanho de ğ‘›, com a nossa pre-codificaÃ§Ã£o, 

o  maior bloco  de  duas  letras  seria  ğ‘Œğ‘  =  2526,  assim  precisarÃ­amos  tomar um  ğ‘›  um 

 
 
 
 
 
41 

pouco  maior  caso  necessÃ¡rio,  se  quisÃ©ssemos  codificar  usando  blocos  de  3, 

aumentarÃ­amos ainda mais o ğ‘›. 

Outra saÃ­da caso quisÃ©ssemos manter a codificaÃ§Ã£o letra a letra, seria modificar 

a correspondÃªncia do nosso alfabeto. Adotando por exemplo ğ´ = 10, ğµ = 11, e assim 

por diante atÃ© ğ‘ = 35. Assim, nosso algoritmo para o mesmo exemplo acima retornaria  
123 â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘1 = 785
183 â‰¡ ğ‘2ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘2 = 174
133 â‰¡ ğ‘3ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘3 = 311
103 â‰¡ ğ‘4ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘4 = 57
133 â‰¡ ğ‘5ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘5 = 311
143 â‰¡ ğ‘6ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘6 = 858

que Ã© um pouco melhor. 

Observe a codificaÃ§Ã£o da palavra ğ¶ğ¼ğ·ğ´ğ·ğ¸ utilizando um Ãºnico bloco como letra. 

Para isso, tomamos novas chaves, pÃºblica e privadas, oriundas de ğ‘ = 773 e ğ‘ = 571 

ğ¶ğ¼ğ·ğ´ğ·ğ¸ = 394145 

ğ¶â„ğ‘ğ‘£ğ‘’ğ‘ƒÃºğ‘ğ‘™ğ‘–ğ‘ğ‘ = (ğ‘›, ğ‘’) = (441383,7) 

ğ¶â„ğ‘ğ‘£ğ‘’ğ‘ƒğ‘Ÿğ‘–ğ‘£ğ‘ğ‘‘ğ‘ = (ğ‘›, ğ‘‘) = (441383,62863) 

Assim, resolvendo a congruÃªncia 

E finalmente nossa mensagem a ser enviada ğ‘1 = 318881 

3941457 â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ 441383 

3.4.2. CodificaÃ§Ã£o por transposiÃ§Ã£o de blocos 

Para utilizar o sistema de codificaÃ§Ã£o por transposiÃ§Ã£o de blocos, precisamos 

decompor  a  mensagem  em  blocos  de  tamanho  ğ‘Ÿ, algumas  vezes,  a  depender  do 

tamanho  da  mensagem,  serÃ¡  necessÃ¡rio  completar  o  Ãºltimo  bloco  com  uma  letra 

qualquer por exemplo ğ´. Como escolhemos para o exemplo ğ‘Ÿ = 2, segue que a palavra 

cidade  seria  entÃ£o  decomposta  como  ğ¶ğ¼ âˆ’ ğ·ğ´ âˆ’ ğ·ğ¸.  NÃ£o  havendo,  portanto, 

necessidade de completarmos o Ãºltimo bloco. 

Feito 

isso,  devemos 

reescrever  os  blocos, 

fazendo  a  sua  correta 

correspondÃªncia numÃ©rica, assim, obtemos: 

ğ¶ğ¼ = 39; ğ·ğ´ = 41; ğ·ğ¸ = 45 

 
 
 
 
 
 
 
42 

Ã‰ importante fixar aqui que o alfabeto utilizado faz a correspondÃªncia ğ´ = 1, ğµ =

2,  atÃ©  ğ‘ = 26 = 0,  portanto  utilizaremos  comumente  aqui  ğ‘ = 0.  Agora,  devemos 

escrever estes nÃºmeros na base ğ¿, obtendo: 

39 = 3.261 + 9.260 = 87 

41 = 4.261 + 1.260 = 105 

45 = 4.261 + 5.260 = 109 

codificÃ¡-los utilizando nossa chave pÃºblica, 

873 â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘1 = 289
1053 â‰¡ ğ‘2ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘2 = 564
1093 â‰¡ ğ‘3ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘3 = 290

Este  resultado  ainda  nÃ£o  serÃ¡  enviado,  pois  decidimos  que  seriam  enviados 

nesse processo, blocos de tamanho 3, assim, para finalizar, devemos colocar ğ‘1, ğ‘2 e 

ğ‘3 na base 26 

Assim, 

289 = 2.262 + 8.261 + 9.260 = 1569 

564 = 5.262 + 6.261 + 4.260 = 3540 

290 = 2.262 + 9.261 + 0.260 = 1586 

3.4.3. DecodificaÃ§Ã£o  

O  processo  de  decodificaÃ§Ã£o  Ã©  anÃ¡logo  a  codificaÃ§Ã£o  neste  sistema,  porÃ©m 

utilizaremos esta parte para jÃ¡ justificarmos o porquÃª do mÃ©todo RSA funciona. 

Teorema 10 (RSA). Seja ğ‘ âˆˆ â„¤,  entÃ£o ğ‘ğ‘‘ğ‘’ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›. 

DemonstraÃ§Ã£o:  Note  que  pela 

forma  como 

tomamos  ğ‘‘  e  ğ‘’, 

temos  que                         

ğ‘‘. ğ‘’ â‰¡ 1 ğ‘šğ‘œğ‘‘ ğœ™(ğ‘›). Ou seja, ğ‘‘. ğ‘’ = 1 + ğ‘˜. ğœ™(ğ‘›). Podemos escrever, 

ğ‘ğ‘‘.ğ‘’ â‰¡ ğ‘ğ‘‘.ğ‘’ ğ‘šğ‘œğ‘‘ ğ‘› 

equivale a  

note que, manipulando mais ou pouco a equaÃ§Ã£o acima temos, 

ğ‘ğ‘‘.ğ‘’ â‰¡ ğ‘1+ğ‘˜.ğœ™(ğ‘›) ğ‘šğ‘œğ‘‘ ğ‘› 

ğ‘ğ‘‘.ğ‘’ â‰¡ (ğ‘ğœ™(ğ‘›))

ğ‘˜

. ğ‘1 ğ‘šğ‘œğ‘‘ ğ‘› 

 
 
 
 
 
 
 
 
mas, o Teorema de Euler garante que 

e, portanto 

ğ‘ğœ™(ğ‘›) â‰¡ 1 ğ‘šğ‘œğ‘‘ ğ‘› 

ğ‘ğ‘‘.ğ‘’ â‰¡ (1)ğ‘˜. ğ‘1 â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›. 

43 

âˆ 

O Teorema 10, nos mostra que ao recebermos uma mensagem codificada pelo 

sistema  RSA  com  a  chave  pÃºblica  (ğ‘›, ğ‘’),  para  decodificÃ¡-la  basta  elevarmos  a 

mensagem a ğ‘‘ mÃ³dulo ğ‘›, que a mesma serÃ¡ recuperada. 

Voltando ao exemplo da subseÃ§Ã£o 3.4.1, e lembrando que nossa chave privada 

foi (943,587), temos entÃ£o que resolver as congruÃªncias: 

27587 â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘1 = 3
729587 â‰¡ ğ‘2 ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘2 = 9
64587 â‰¡ ğ‘3ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘3 = 4
1587 â‰¡ ğ‘4ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘4 = 1
64587 â‰¡ ğ‘5ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘5 = 4
125587 â‰¡ ğ‘6ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘6 = 5

5 

Para  decodificaÃ§Ã£o  das  mensagens  codificadas  em  blocos,  deve-se  seguir  o 

mesmo processo, porÃ©m as por transposiÃ§Ã£o, deve-se tomar o cuidado de retornar os 

cÃ³digos  enviados  para  a  base  anterior  antes  de  iniciarmos  o  processo  de 

decodificaÃ§Ã£o. Assim ao recebermos a mensagem da subseÃ§Ã£o 3..4.1, onde foi feita 

uma transposiÃ§Ã£o de blocos, devemos proceder da seguinte forma: 

(1569)ğ¿3 = 2.262 + 8.261 + 9.260 = (289)ğ¿ 
(3540)ğ¿3 = 5.262 + 6.261 + 4.260 = (564)ğ¿ 
(1586)ğ¿3 = 2.262 + 9.261 + 0.260 = (290)ğ¿ 

e em seguida aplicar a decodificaÃ§Ã£o 

289587 â‰¡ ğ‘1ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘1 = 87
564587 â‰¡ ğ‘2 ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘2 = 105
290587 â‰¡ ğ‘3 ğ‘šğ‘œğ‘‘ 943 â‡’ ğ‘3 = 109

5 Caso seja do interesse do leitor, Ã© possÃ­vel verificar os cÃ¡lculos atravÃ©s do aplicativo 

CodeClass, que serÃ¡ abordado no prÃ³ximo capÃ­tulo. 

 
  
 
 
                                                           
 
44 

3.4.4. Assinatura do RSA 

Quando tratamos em 3.3 do Conceito de Chave pÃºblica, vimos como Ã© simples 
assinar  uma  mensagem  atravÃ©s  dos  cadeados.  PorÃ©m,  na  prÃ¡tica,  para  que  isso 
aconteÃ§a,  faz-se  necessÃ¡rio  que  as  funÃ§Ãµes  que  codificam  e  decodificam  as 
mensagens se comportem como pares de funÃ§Ãµes onde uma se torna o inverso da 
outra e vice-versa. 

Para  que  isso  aconteÃ§a  com  o  RSA,  Ã©  necessÃ¡rio  seguirmos  alguns  passos 

durante a codificaÃ§Ã£o e decodificaÃ§Ã£o do sistema. 

Vamos supor que Pedro e JÃºlia desejem trocar mensagens. Cada um conhece 

suas chaves pÃºblicas e privadas e como funciona o sistema RSA. 

Sem perda de generalidade, suponha que as chaves pÃºblica e privada de Pedro 
sejam (ğ‘›ğ‘ƒ, ğ‘’ğ‘ƒ), (ğ‘›ğ‘ƒ, ğ‘‘ğ‘ƒ). E as de JÃºlia sejam (ğ‘›ğ½, ğ‘’ğ½), (ğ‘›ğ½, ğ‘‘ğ½). Considere tambÃ©m ğ‘›ğ‘ƒ >
ğ‘›ğ½. 

Pedro mandarÃ¡ a mensagem ğ‘ para JÃºlia da seguinte forma.  

Primeiramente irÃ¡ determinar ğ‘, onde ğ‘ğ‘’ğ½ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›ğ½  e em seguida irÃ¡ calcular 

ğ‘ onde ğ‘ğ‘‘ğ‘ƒ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›ğ‘ƒ, enviando finalmente ğ‘. 

Caso ğ‘›ğ½ > ğ‘›ğ‘ƒ ele deverÃ¡ inverter a ordem da operaÃ§Ã£o anterior, realizando:  

Primeiramente irÃ¡ determinar ğ‘, onde ğ‘ğ‘‘ğ‘ƒ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›ğ‘ƒ  e em seguida irÃ¡ calcular 

ğ‘ onde ğ‘ğ‘’ğ½ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘›ğ½, enviando finalmente ğ‘ 

Para  a  decodificaÃ§Ã£o,  deve-se  seguir  os  passos  na  ordem  inversa  de 

codificaÃ§Ã£o, aplicando a congruÃªncia mÃ³dulo maior ğ‘› inicialmente. 

 
 
45 

4.   O APLICATIVO CODECLASS E A CRIPTOGRAFIA 

O aplicativo CodeClass foi desenvolvido com o intuito apresentar de maneira 

simples, os processos necessÃ¡rios para a implementaÃ§Ã£o de um complexo sistema 

de criptografia que Ã© comumente utilizado na internet, o RSA. AlÃ©m de possibilitar o 

desenvolvimento  de  atividades  voltadas  para  o  estudo  da  AritmÃ©tica  Modular  nas 

aulas. 

Apesar  do  aplicativo  jÃ¡  poder  ser  acessado,  acreditamos  que  ainda  sÃ£o 

necessÃ¡rios  vÃ¡rios  ajustes  e  melhorias,  que  busquem  aumentar  a  gama  de 

possibilidades quanto a sua utilizaÃ§Ã£o. AlÃ©m disso, somente com o uso e colaboraÃ§Ã£o 

dos usuÃ¡rios, serÃ¡ possÃ­vel tornar o seu uso mais intuitivo e dinÃ¢mico. O registro do 

mesmo jÃ¡ foi iniciado pela UESB no dia 19/09/2019.  

Para ter acesso ao aplicativo, basta acessar do seu celular o link disponÃ­vel em 

[12] onde consta a versÃ£o mais recente do app. ApÃ³s acessar a pasta do drive, faÃ§a 

o  download  do  arquivo  CodeClass.apk  e  execute-o  em  seu  aparelho.  Como  o 

aplicativo  ainda  nÃ£o  se  encontra  disponÃ­vel  no  PlayStore,  muitas  vezes  serÃ¡ 

necessÃ¡ria uma autorizaÃ§Ã£o manual do usuÃ¡rio para prosseguir com a instalaÃ§Ã£o. 

4.1. O aplicativo 

O aplicativo CodeClass foi integralmente desenvolvido atravÃ©s da plataforma 

gratuita,  MIT  App  Inventor  2.  O  seu  algoritmo  utiliza,  efetuando  as  devidas 

adaptaÃ§Ãµes,  toda  a  teoria  apresentada  neste  trabalho.  O  projeto  foi  iniciado  em 

meados de fevereiro, apÃ³s o levantamento teÃ³rico ter sido completamente finalizado. 

Foi  necessÃ¡ria  uma  completa  revisÃ£o  sobre  os  principais  algoritmos  da  Teoria  dos 

NÃºmeros,  principalmente  para  a  tomada  decisÃ£o  quanto  as  etapas  lÃ³gicas  que  o 

sistema iria realizar.  

A primeira fase do projeto, foi conseguir fazer com que o aplicativo interpretasse 

as letras do alfabeto como nÃºmeros, para que pudesse ser feita a correlaÃ§Ã£o proposta 

 
 
 
 
46 

na Figura 5, para isso criamos no desenvolvimento do app uma lista, organizada por 

Ã­ndices que possui 26 linhas.   

O  aplicativo  possui  trÃªs  funÃ§Ãµes  bem  definidos,  uma  para  se  trabalhar  a 

Criptografia Linear, a segunda trabalha a Criptografia RSA e um mÃ³dulo gerador de 

nÃºmeros primos. O primeiro destes, foi inserido por ser conceitualmente mais simples, 

e pode ser utilizado como base para compreensÃ£o da Criptografia RSA, alÃ©m de ser 

um  instrumento  que  servirÃ¡  para  se  comparar  os  mÃ©todos,  entender    falhas  e 

conseguir discernir o porquÃª de alguns sistemas nÃ£o serem adequados para o sistema 

de chave pÃºblica. 

O segundo bloco e foco deste projeto trata especificamente do RSA, e pode-se 

atribuir a ele diversos usos. Ele foi propositalmente subdividido em trÃªs partes geraÃ§Ã£o 

das  chaves,  codificaÃ§Ã£o e decodificaÃ§Ã£o  afim de facilitar  o  trabalho  e  entendimento 

em cada uma das etapas. Sendo assim, serÃ¡ possÃ­vel trabalhar todo o processo de 

maneira gradativa e independente. 

Finamente, foi colocado um mÃ³dulo de nÃºmeros primos, pois como estes sÃ£o 

a  base  do  sistema,  seria  sempre  necessÃ¡rio  dar  uma  consultada  em  alguns. 

Acreditamos que deixÃ¡-los â€œa mÃ£oâ€ pode servir para ganharmos tempo em algumas 

propostas. 

4.2. Interface 

Figura 9 Ãcone e Slogan do CodeClass 

Fonte: O autor 

O aplicativo CodeClass cujo slogan pode ser visto na Figura 9, ainda encontra-

se em fase aperfeiÃ§oamento, porÃ©m jÃ¡ Ã© possÃ­vel acessÃ¡-lo caso os usuÃ¡rios queiram 

testar e atÃ© mesmo realizar sugestÃµes e/ou crÃ­ticas para o projeto. O funcionamento 

 
 
 
 
47 

ainda  Ã©  um  pouco  arcaico,  devido  a  nÃ£o  ser  possÃ­vel  atÃ©  o  momento  automatizar 

alguns processos na inserÃ§Ã£o dos dados. 

Ao  instalar  o  app,  o  usuÃ¡rio  irÃ¡  se  deparar  com  uma  tela  inicial,  conforme  a 

Figura 10, que disponibiliza  acesso aos temas que poderÃ£o ser trabalhados. 

Figura 10 Tela Inicial do CodeClass 

Fonte: O Autor 

Nesta  tela,  Ã©  possÃ­vel  escolher  qual  tipo  de  criptografia  serÃ¡  trabalhada  de 

acordo a proposta que o professor deseja para aquela aula ou atividade, sÃ£o elas a 

Criptografia Linear, que apesar de ser completamente inviÃ¡vel hoje, Ã© o passo inicial 

para entendermos a necessidade de evoluÃ§Ã£o dos sistemas criptogrÃ¡ficos. 

No  momento  o  botÃ£o  sobre  encontra-se  em  fase  desenvolvimento,  nÃ£o 

havendo atÃ© o momento nenhuma funcionalidade para tal. Em breve ele irÃ¡ apresentar 

informaÃ§Ãµes  sobre  os  autores,  bem  como  a  forma  de  contato  para  algum  tipo  de 

suporte. 

Na  interface  descrita  na  Figura  4.3  Ã©  possÃ­vel  codificar  e  decodificar  uma 

mensagem  utilizando  o  Sistema  de  Criptografia  Linear.  Este  sistema  Ã©  uma 

reinterpretaÃ§Ã£o da Cifra de CÃ©sar que foi citada no inÃ­cio deste trabalho. AlÃ©m disso, 

sistemas mais avanÃ§ados com o utilizado na Enigma [2] tambÃ©m se basearam num 

mÃ©todo similar a este para sua criaÃ§Ã£o. 

 
 
48 

Figura 11 Interface Criptografia Linear 

Fonte: O autor 

Para  codificar  uma  mensagem,  o  autor  deve  escolher  inicialmente  dois 
parÃ¢metros  A  e  B,  que  compÃµes  a  funÃ§Ã£o  de  permutaÃ§Ã£o  ğ‘“(ğ‘‹) = ğ´. ğ‘‹ + ğµ,  como 
estamos utilizando o alfabeto tradicional, com as letras de A a Z (maiÃºsculas) e sem 
considerar  o  espaÃ§o  em  branco,  consideramos  que  o  nosso  alfabeto  de  trabalho, 
consta de 26 caracteres. Para que haja inversos em â„¤26 faz-se entÃ£o necessÃ¡rio que 
a  escolha  de  ğ´,  seja  de  forma  que  ğ‘šğ‘‘ğ‘(ğ´, 26) = 1,  caso  esta  condiÃ§Ã£o  nÃ£o  seja 
satisfeita, o programa nÃ£o seguirÃ¡ com o processo. 

Escolhido  os  parÃ¢metros,  deve-se  digitar  nos  campos  da  janela  intitulada 
â€œESCREVA  SUA  MENSAGEMâ€  os  caracteres  da  mensagem  que  se  deseja  enviar. 
Vale  ressaltar  que  sÃ³  devem  ser  utilizados  caracteres  maiÃºsculos  do  alfabeto  e, 
sempre,  um  caractere  por  campo,  caso  contrÃ¡rio  o  programa  irÃ¡  retornar  erros  e 
possivelmente irÃ¡ finalizar sua execuÃ§Ã£o. 

 
 
49 

Figura 12 Exemplo de Preenchimento 

Fonte: O autor 

Utilizamos a interface com o exemplo como pode ser visto na Figura 12, para 

ilustrar  o  preenchimento,  neste  caso  em  especÃ­fico  os  parÃ¢metros  utilizados  foram  

ğ´ = 1 e ğµ = 3 que representam a transposiÃ§Ã£o inicial da Cifra de CÃ©sar, em seguida 

escrevemos a mensagem J U L I O C E S A R. Para codificar, basta finalmente clicar 

no  botÃ£o  CRIPTOGRAFAR,  que  o  programa  irÃ¡  retornar  a  imagem  da  funÃ§Ã£o  de 

transposiÃ§Ã£o definida. Caso seja de interesse do utilizador converter os nÃºmeros em 

caracteres,  irÃ¡  ser  liberado  um  botÃ£o  com  este  fim.  Ã‰  importante  salientar  tambÃ©m 

que, para que o receptor consiga ler a mensagem, Ã© necessÃ¡rio ter acesso as chaves 

para leitura que tambÃ©m sÃ£o geradas no momento da codificaÃ§Ã£o. 

 
 
 
 
 
 
 
50 

Figura 13 CodificaÃ§Ã£o e GeraÃ§Ã£o das Chaves 

Fonte: O autor 

Finalizada  a  codificaÃ§Ã£o  e  geraÃ§Ã£o  das  chaves,  o  autor  poderÃ¡  transmitir  a 

mensagem  para  o  receptor,  atravÃ©s  do  botÃ£o  compartilhar.  Vale  lembrar  que  Ã© 

importante  definir-se  tambÃ©m  um  canal  seguro  para  envio  da  chave  de  leitura,  ou, 

caso contrÃ¡rio o receptor nÃ£o terÃ¡ condiÃ§Ãµes de decodificar a mensagem como pode 

ser visto na Figura 13. 

A  decodificaÃ§Ã£o  deve  ser  feita  da  mesma  forma  da  codificaÃ§Ã£o.  PorÃ©m  na 

definiÃ§Ã£o  dos  parÃ¢metros,  deve-se  colocar  os  valores  de  A  e  B  fornecidos  como 

â€œCHAVE DE LEITURAâ€ e em seguida, realizar as mesmas etapas da codificaÃ§Ã£o. 

Na tela de boas vindas do Sistema de Criptografia RSA Figura 14, o utilizador  

tem  acesso  a  trÃªs  mÃ³dulos  para  operar:  Gerar  Chaves,  Criptografar  Mensagem  e 

Decifrar  Mensagem.  Os  mÃ³dulos  sÃ£o  completamente  independes,  nÃ£o  sendo 

necessÃ¡rio alimentar um com informaÃ§Ãµes para a utilizaÃ§Ã£o dos demais. 

 
 
 
 
 
 
 
51 

Figura 14 Tela de boas-vindas Criptografia RSA 

Fonte: O autor 

A tela de geraÃ§Ã£o das chaves, possui um funcionamento bem intuitivo. Basta 

que  o  utilizador,  escolha  dois  primos  distintos  e  pressione  o  botÃ£o  verificar 

primalidade.  O  programa  irÃ¡  verificar  se  os  nÃºmeros  sÃ£o  realmente  primos  e,  em 

seguida irÃ¡ liberar o botÃ£o para geraÃ§Ã£o das chaves.  

Em testes realizados durante o desenvolvimento do aplicativo, verificamos que 

no momento a forma de execuÃ§Ã£o do algoritmo torna inviÃ¡vel a geraÃ§Ã£o de chaves 

para  primos muito  grandes. Aconselhamos  trabalhar com nÃºmeros  de  3  dÃ­gitos,  no 

mÃ¡ximo. Ã‰ possÃ­vel ainda assim gerar chaves para nÃºmeros maiores, mas o tempo 

de espera pode  ser demasiadamente  grande, podendo  em alguns  casos finalizar a 

execuÃ§Ã£o do programa no celular, por nÃ£o conseguir finalizar a tarefa. 

Ã‰  importante  que,  apÃ³s  geradas  as  chaves,  o  usuÃ¡rio  anote-as  em  um  local 

seguro, principalmente a sua chave privada. Caso seja uma dinÃ¢mica ou oficina, ele 

pode divulgar as suas chaves pÃºblicas para outros usuÃ¡rios, que poderÃ£o utilizÃ¡-las 

no decorrer do processo. Observe um exemplo na Figura 15. 

 
 
 
52 

Figura 15 GeraÃ§Ã£o das Chaves RSA 

Fonte: O autor 

ApÃ³s  geradas  as  chaves  pÃºblica  e  privada,  podemos  iniciar  o  processo  de 

codificaÃ§Ã£o. Para facilitar o entendimento e exemplificar o processo, iremos simular o 

envio de uma mensagem entre os usuÃ¡rios Alice e Bob que possuem as chaves: 

Alice: PÃºblica (ğ‘›, ğ¶ğ‘ğ‘¢ğ‘)   =   (21509,5) Privada: (ğ‘›, ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£) =   (21509,16973) 

Bob: PÃºblica (ğ‘›, ğ¶ğ‘ğ‘¢ğ‘)   =   (20633,5) Privada: (ğ‘›, ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£) =   (20633,12089) 

Para  que  Bob  consiga  enviar  uma  mensagem  para  Alice,  ele  precisar  saber 

qual a chave pÃºblica de Alice. De posse dessa informaÃ§Ã£o, ele deve preencher   na 

tela  de  CodificaÃ§Ã£o,  nos  campos  ğ‘›  e  ğ¶ğ‘ğ‘¢ğ‘  as  chaves  pÃºblicas  do  usuÃ¡rio  que  irÃ¡ 

receber  a  mensagem,  neste  caso,  Alice.  Em  seguida  deve  escrever  nos  campos 

abaixo  a  sua mensagem,  sempre  respeitando um  caractere  por campo e utilizando 

sempre letras maiÃºsculas que pode ser vista na Figura 16. 

Ã‰ possÃ­vel enviar a mensagem assinada, ou nÃ£o. Tudo vai depender de como 

se estÃ¡ trabalhando o aplicativo e o domÃ­nimo de conteÃºdo dos participantes. Para 

 
 
 
 
 
53 

assinar,  basta  que  o  autor  marque  o  campo  Assinar  mensagem  e  em  seguida 

preencher os  campos indicados  com  a  sua Chave  Privada.  AtenÃ§Ã£o a assinatura Ã© 

sempre  realizada  com  a  chave  privada  do  autor.  Caso  haja  uma  inversÃ£o  destas 

chaves, serÃ¡ impossÃ­vel para o receptor decodificar a informaÃ§Ã£o recebida. 

Figura 16 CodificaÃ§Ã£o, CodificaÃ§Ã£o sem assinatura e CodificaÃ§Ã£o com Assinatura 

Fonte: O autor 

ApÃ³s  ter  criptografado  a  mensagem,  a  mesma  pode  ser  enviada  atravÃ©s  do 

botÃ£o compartilhar ou transmitida por algum outro canal ao receptor. Vale ressaltar 

que nÃ£o Ã© possÃ­vel converter a mensagem codificada para o alfabeto, por nÃ£o se tratar 

de uma cifra de transposiÃ§Ã£o. 

Finalmente na tela de decodificaÃ§Ã£o, iremos realizar um processo semelhante 

ao  da  codificaÃ§Ã£o.  Fez-se  necessÃ¡rio  a  criaÃ§Ã£o  de  uma  tela  a  parte  para  este 

processo,  devido  a  algumas  peculiaridades  no  processo  de  codificaÃ§Ã£o  e 

decodificaÃ§Ã£o. O principal deles, Ã© o fato de a entrada na codificaÃ§Ã£o ser um caractere 

do  tipo  texto,  enquanto  a  saÃ­da  Ã©  um  caractere  numÃ©rico.  JÃ¡  na  decodificaÃ§Ã£o,  a 

 
 
 
 
 
54 

entrada do programa Ã© um caractere numÃ©rico e a saÃ­da serÃ¡  um caractere do tipo 

texto.  Portanto,  os  campos  de  entrada  nos  dois  processos  sÃ£o  distintos  e  assim 

optamos por realizÃ¡-los separados. 

Para decodificar a mensagem o receptor deve ir na tela decifrar mensagem e 

inserir  em  cada  campo  os  nÃºmeros  que  foram  recebidos  e  na  ordem  recebida.  Foi 

tomado  o  cuidado  de deixar cada  bloco numÃ©rico  visivelmente  espaÃ§ado, de modo 

que nÃ£o haja sobreposiÃ§Ãµes de blocos ou indefiniÃ§Ãµes das sequÃªncias numÃ©ricas. 

Em seguida o receptor deve preencher os campos ğ‘› e ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£ com a sua chave 

privada  e  por fim  pressionar  o  botÃ£o  DECODIFICAR  MENSAGEM.  Na  maioria  das 

vezes, a depender das chaves que foram utilizadas, vocÃª notarÃ¡ que os resultados 

foram  nÃºmeros  menores  que  26.  Isso  indica  que  a  princÃ­pio  o  processo  parece  ter 

ocorrido da maneira correta. E assim, para finalizar o usuÃ¡rio pode pressionar o botÃ£o 

CONVERTER  PARA  TEXTO,  para  que  seja  traduzido  o  conteÃºdo  para  caracteres 

alfabÃ©ticos conforme a Figura 17. 

Caso a mensagem tenha sido assinada, ele deve marcar o campo MENSAGEM 

ASSINADA  e  entrar  com  as  chaves  pÃºblicas  do  possÃ­vel  receptor.  Em  seguida 

pressionar  o  botÃ£o  DECODIFICAR  MENSAGEM,  que  o  sistema  irÃ¡  proceder  da 

mesma forma que a decodificaÃ§Ã£o sem assinatura. Se ocorrer tudo corretamente no 

processo  e  a  mensagem  conseguir  ter  sido  decifrada  com  sucesso,  serÃ¡  possÃ­vel 

converter os caracteres para as letras correspondentes do alfabeto, alÃ©m de termos a 

plena certeza sobre a autoria do conteÃºdo. 

 
55 

Figura 17 DecodificaÃ§Ã£o, sem Assinatura e com Assinatura 

Fonte: O autor 

O terceiro e ultimo mÃ³dulo do aplicativo Ã© um gerador de nÃºmeros primos, que 

optamos por deixar disponÃ­vel para fim meramente prÃ¡ticos de utilizaÃ§Ã£o do programa. 

Utilizamos para a verificaÃ§Ã£o da primalidade, nesta tela, o Teorema de Wilson 

a fim de ser mais simples de implementÃ¡-lo na geraÃ§Ã£o dos primos, que pode ser feita 

de maneira atravÃ©s de um fÃ³rmula de recursÃ£o. Assim, nele serÃ¡ possÃ­vel tanto testa 

se determinado nÃºmero Ã© primo, quanto tambÃ©m gerar uma lista de primos, para que 

seja feita a escolha de algo de acordo o interesse do usuÃ¡rio. 

Na tela que Ã© acessada pelo botÃ£o GERADOR DE PRIMOS o usuÃ¡rio tem as 

opÃ§Ãµes de inciar a geraÃ§Ã£o de uma lista ou testar a primalidade de algum nÃºmero de 

maneira  isolada.  ApÃ³s  precionar  o  botÃ£o  GERAR  PRIMOS,  a  lista  serÃ¡  inciada  de 

maneira interrupta, atÃ© que seja solicitado a pausa do processo. Caso o interesse seja 

escolher um primo apenas, pode-se fazÃª-lo desta forma. 

Se o interesse for em somente verificar se determinado nÃºmero Ã© primo, deve-

se  entÃ£o  digitÃ¡-lo  no  campo  especÃ­fico  e  precionar  o  botÃ£o  VERIFICAR 

 
 
 
 
56 

PRIMALIDADE. O programa irÃ¡ retornar o resultado como na Figura 18 e darÃ¡ fim ao 

processo. 

Figura 18 Gerador de Primos 

Fonte: O autor 

 
 
 
 
 
 
 
 
 
 
 
 
 
57 

4.3. SUGESTÃƒO I â€“ Origem da Criptografia 

DuraÃ§Ã£o: 200 minutos/ 4 aulas 

Objetivos:  Conhecer  a  origem  da  criptografia;  entender  o  funcionamento  dos 

primeiros  mÃ©todos  criptogrÃ¡ficos;  compreender  a  sua 

importÃ¢ncia  para  o 

desenvolvimento da sociedade. 

SÃ©rie: A partir do 1ÂºAno do Ensino MÃ©dio 

Um pouco de HistÃ³ria 

Todo  material  utilizado  nas  atividades,  inclusive  o  aplicativo,  se  encontra 

disponÃ­vel no link permanente, disponÃ­vel em [12]. 

Inicialmente,  a  proposta  Ã©  fazer  uma  breve  introduÃ§Ã£o  sobre  a  origem  da 

criptografia  e  da  Cifra  de  CÃ©sar.  Deve-se  verificar  se  os  alunos  compreenderam  o 

funcionamento da cifra de CÃ©sar e a importÃ¢ncia de se ocultar informaÃ§Ãµes. 

Esta verificaÃ§Ã£o pode ser feita solicitando aos alunos que respondam a Atividade 1. 

ATIVIDADE 1 

1)  Codifique seu nome utilizando a Cifra de CÃ©sar. 

2)  Decifre a frase MXOLR FHVDU.   

3)  Eu poderia, ao invÃ©s de utilizar a correspondÃªncia de A para D, realizar alguma 

outra diferente? 

Usando o aplicativo 

Utilizando o aplicativo. 

PeÃ§a aos alunos que abram o aplicativo CodeClass. 

Em  seguida  clique  no  botÃ£o  Criptografia  Linear,  na  tela  que  segue,  peÃ§a  que 

preencham as caixas A e B com os valores 1 e 3. Em seguida, peÃ§a-os que digitem a 

mensagem do exercÃ­cio 1 pressione o botÃ£o criptografar e observem se o resultado Ã© 

o mesmo que eles obtiveram. 

 
 
58 

Na parte inferior do aplicativo, onde aparece: CHAVES PARA LEITURA constam as 

chaves para que o aluno consiga decifrar a mensagem. 

PeÃ§a-os  que  anotem  essas  chaves  ğ´ = 1 e ğµ = 23  e  agora  tentem  responder  o 

exercÃ­cio  2,  utilizando-as  para  decifrar  MXOLR  FHVDU.  Ã‰  importante  que  eles 

entendam o funcionamento do mecanismo e nÃ£o tenham dÃºvidas quanto a forma de 

decifrar. 

Questione sobre a analogia entre a matemÃ¡tica do aplicativo e a forma original que 

JÃºlio CÃ©sar criou.  

Para finalizar a atividade, peÃ§a aos alunos que escolham outros valores para A e B e 

observem o  que  acontece.   Observe  o  quÃ£o  desordenado  podem ficar as  letras de 

acordo o A cresce. SerÃ¡ que ainda assim existe um padrÃ£o?  

Entendendo o aplicativo 

PrÃ©-requisito: Conhecimento de FunÃ§Ãµes, divisÃ£o inteira. 

Agora Ã© chegada a hora de entender o que o aplicativo estÃ¡ fazendo, para embaralhar 

as letras da mensagem. 

Para cada letra do alfabeto, vem atribuÃ­do no aplicativo um nÃºmero como na Figura 

19. 

Figura 19 CorrespondÃªncia Letra-NÃºmero 

Fonte: O autor 

e a funÃ§Ã£o que irÃ¡ criar uma bagunÃ§a nestes nÃºmeros, no caso da Criptografia Linear, 

essa funÃ§Ã£o Ã©  

 
 
 
 
 
  
 
59 

Em que o usuÃ¡rio irÃ¡ definir os valores de A e B. 

ğ‘“(ğ‘¥) = ğ´. ğ‘¥ + ğµ 

Para  exemplificar,  vamos  utilizar  os  parÃ¢metros  ğ´ = 3  e  ğµ = 2  para  facilitar 

nosso entendimento. Quando digitamos a palavra B O L A, o aplicativo faz a atribuiÃ§Ã£o 

numÃ©rica de acordo a tabela acima, enxergando na verdade os nÃºmeros 2â€“ 15â€“ 12 âˆ’ 1, 

feito isso e jÃ¡ de posse dos parÃ¢metros, ele vai calcular a imagem de cada um destes 

nÃºmeros atravÃ©s da funÃ§Ã£o ğ‘“ obtendo assim,  

ğ‘“(2) = 3.2 + 2 = 8 

ğ‘“(15) = 3.15 + 2 = 47 

ğ‘“(12) = 3.12 + 2 = 38 

ğ‘“(1) = 3.1 + 2 = 5 

Para finalizar, o sistema buscarÃ¡ estes novos nÃºmeros na tabela, e irÃ¡ trocÃ¡-

los novamente por letras. Ã‰ ai que surge o primeiro problema. Os nÃºmeros 8 e 5 estÃ£o 

na tabela, sÃ£o respectivamente as letras H e E, Logo o aplicativo irÃ¡ encontrÃ¡-los, mas 

o  que  fazer com  nÃºmeros  maiores  que  26 que  nÃ£o  estÃ£o na  tabela,  neste  caso  os 

nÃºmeros 47 e 38. Muito simples, os nÃºmeros maiores que 26, ele vai dividi-los por 26 

e observar o resto desta operaÃ§Ã£o. Assim, ao dividirmos 47 por 26, obtemos quociente 

1 e resto 21. Portanto ele buscarÃ¡ 21 na tabela que Ã© a letra U. Da mesma forma ele 

o farÃ¡ com o 38 obtendo 12 letra L, e assim, a palavra B O L A, passou entÃ£o a ser 

escrita como H U L E.  

Uma analogia muito interessante sobre a forma de verificar estes restos, Ã© comparar 

com um relÃ³gio, sabemos que os ponteiros de um relÃ³gio marcam de 1 a 12., mas 

ainda assim o dia vai de 0 Ã s 24h. Assim, para sabermos que horas sÃ£o as 17h da 

tarde, o que fazemos Ã© dividir 17 por 12 e observar o resto, 5, por isso 17h, sÃ£o 5 da 

tarde. De maneira anÃ¡loga, ao completarmos 24h, temos que Ã© a 0h do dia seguinte, 

visto que 24 divido por 12 deixa resto 0. 

Para  as  chaves,  o  algoritmo  se  torna  um  pouco  mais  complexo.  Como  pode  ser 

observado, o programa retornou que as CHAVES PARA LEITURA sÃ£o ğ´ = 9 e ğµ = 8 

isso quer dizer, que se escrever a mensagem H U L E e trocar os valores de A e B 

 
60 

para 9 e 8, ao apertar o botÃ£o criptografar, vocÃª obterÃ¡ a palavra B O L A novamente. 

Mas como isso Ã© feito. 

Bom, sabemos que uma funÃ§Ã£o ğ‘“(ğ‘¥) = ğ´. ğ‘¥ + ğµ, admite funÃ§Ã£o inversa 

ğ‘“âˆ’1(ğ‘¥) = ğ´âˆ’1.ğ‘¥ âˆ’ ğ´âˆ’1. ğµ se ğ´ â‰  0 

assim, o que o programa faz Ã© descobrir quanto vale ğ´âˆ’1 ou seja o inverso de ğ´. 

Nessas condiÃ§Ãµes por nÃ£o trabalharmos com nÃºmeros reais, o inverso de A, 

nÃ£o pode ser um nÃºmero decimal, por exemplo, aqui, 5âˆ’1 que Ã© o mesmo que 1
5

= 0,20 

nÃ£o  Ã©  considerado  veremos  que  no  nosso  problema  5âˆ’1 = 21.  Como  assim?  Eu 

explico, 5.21 = 105 ao dividirmos 105 por 26 obtemos resto 1 afinal 105 = 26.4 + 1. Ã‰ 

assim  que  determinamos  os  inversos  de  um  nÃºmero  no  conjunto  que  estamos 

trabalhando (ğ‘26). A Figura 20 mostra os produtos de todos os nÃºmeros de 1 a 26 de 

acordo a regra estabelecida. Em destaque estÃ£o aqueles que possuem inverso. 

Figura 20 Inversos Multiplicativos em â„¤26 

Fonte: O autor 

. 

1234567891011121314151617181920212223242526246810121416182022240246810121416182022240369121518212414710131619222525811141720230481216202426101418220481216202426101418220510152025491419243813182327121722161116210612182441016222814200612182441016222814200714212916234111825613201815223101724512190816246142241220210180816246142241220210180918110192112031221413225142361524716258170102041424818212226160102041424818212226160112271831425102161721324920516112238194150122410228206184162140122410228206184162140130130130130130130130130130130130130130142164186208221024120142164186208221024120154198231211652092413217621102514318722110166221221882414420100166221221882414420100178251672415623145221342112320112191011890181022012422146241680181022012422146241680191252417103221581201362518114231692211470201482221610424181260201482221610424181260211611612217127223181383241914942520151050221814106224201612840221814106224201612840232017141185225221916131074124211815129630242220181614121086420242220181614121086420252423222120191817161514131211109876543210260000000000000000000000000 
 
61 

Para nÃºmeros maiores que 26, lembrem-se sempre de encontrar o resto dele 

por 26 e olhar na tabela. Repare que alguns nÃºmeros nÃ£o possuem inverso, isto ocorre 

porque o MDC dele e 26 Ã© diferente de 1, por isso no app hÃ¡ uma notificaÃ§Ã£o, onde o 

o MDC de A e 26 precisa ser 1. 

Finalmente,  jÃ¡  sabemos  como foi  gerado  a Chave  para  Leitura A (vamos  denotÃ¡-la 

aqui por  ğ´ğ· chave para decifrar), seguindo no nosso exemplo,  em que escolhemos         

ğ´ = 3,  provavelmente  ele  deve  ter te  retornado,  segundo  a  tabela,  uma  chave  para 

leitura ğ´ğ· = 9. Para encontrar a Chave para Leitura ğµğ·, basta realizar a multiplicaÃ§Ã£o 
de ğ´ğ·. ğµ visto que nossa funÃ§Ã£o inversa Ã© ğ‘“âˆ’1(ğ‘¥) = ğ´âˆ’1. ğ‘¥ âˆ’ ğ´âˆ’1. ğµ . Lembre-se       ğ´âˆ’1 =
ğ´ğ·. 

Assim,  ğ´ğ·. ğµ = 9.2 = 18.  Caso  o  valor  tivesse  ultrapassado  26,  iriamos 

novamente procurar o resto dele por 26. PorÃ©m, observe que o segundo membro da 

funÃ§Ã£o inversa Ã© negativo, logo seria âˆ’18 o resultado correto, porÃ©m o programa deve 

ter lhe retornado 8. Isso ocorre devido ao fato de que os restos de uma divisÃ£o sempre 

sÃ£o positivos, assim, se pensarmos quanto falta para 18 chegar a 26, iriamos perceber 

que Ã© 8, exatamente o resto procurado. Pensemos de outra forma. Imagine o nosso 

relÃ³gio  que  marca  26  horas  de  uma  dia,  o  relÃ³gio  anda  no  sentido  horÃ¡rio.  Se 

pensarmos no menos como uma mudanÃ§a de sentido (anti-horÃ¡rio), entÃ£o o relÃ³gio 

andar -18h iria marcar 8h. Acompanhe na Figura 21:  

Figura 21 RelÃ³gio de 26 horas 

Fonte: O autor 

 
 
62 

DaÃ­ surge, entÃ£o, as chaves que serÃ£o utilizadas para decifrar o cÃ³digo. 

Tente  sugerir  aos  alunos  que  tentem  eles  mesmos  descobrir  as  Chaves  de 

Leitura, com o auxÃ­lio da tabela e do relÃ³gio acima. 

Como exemplo, faÃ§amos para ğ´ = 7 e ğµ = 10. 

Como vimos, pela tabela o inverso de 7 Ã© 15. Assim, temos que ğ´ğ· = 15. Para 

encontrarmos  ğµğ·  devemos  inicialmente  fazer  a  operaÃ§Ã£o  ğ´ğ·. ğµ  neste  caso  15.10, 

obtendo  150.  Olhando  para  o  resto  da  divisÃ£o  de  150  por  26,  temos  20,  pois              

150 = 5.26 + 20,  voltemos  entÃ£o  20h  no  sentido  anti-horÃ¡rio  e  iremos  determinar        

ğµğ· = 6. Portando ğ´ğ· = 15 e ğµğ· = 6. Confira com o aplicativo. 

ConclusÃ£o da Atividade 

Ao  tÃ©rmino  desta  atividade,  espera-se  que  os  alunos  tenham  entendido 

conceitos  introdutÃ³rios  da  aritmÃ©tica  modular,  pode-se  utilizar  esta  atividade  como 

porta de entrada para o estudo de divisibilidade e congruÃªncia. 

Alguns  alunos  jÃ¡  devem  ter  observado  e  talvez  atÃ©  clicado  no  botÃ£o 

compartilhar,  que  existe  no  aplicativo.  Ele  funciona  simplesmente  para  enviar  a 

mensagem  que  foi  cifrada  via  algum  aplicativo  de  conversaÃ§Ã£o.  Surge  aÃ­  um 

questionamento  interessante,  digamos  que  vocÃª  deseja  enviar  uma  mensagem  a 

alguÃ©m  em  uma  situaÃ§Ã£o  um  pouco  turbulenta,  onde  ninguÃ©m  pode  ler  estÃ¡ 

mensagem. VocÃª percebeu que ao compartilhar a mensagem, para que seu colega 

leia,  ele  precisarÃ¡  da  chave  de  leitura?  Ou  seja,  terÃ­amos  que  ter  um  canal 

superseguro para enviar essa chave a ele. Mas hora se tivÃ©ssemos esse canal, nÃ£o 

terÃ­amos necessidade de enviar a mensagem.  

Eis entÃ£o que acabamos de perceber que o nosso sistema de criptografia, nÃ£o 

Ã©  tÃ£o  eficiente  quanto  esperÃ¡vamos,  afinal  as  pessoas  envolvidas  nas  trocas  de 

mensagens, precisariam manter um certo contato em algum momento. 

Bom, Ã© aÃ­ que surge uma nova forma de criptografar, um mÃ©todo que irÃ¡ acabar 

com este problema A Criptografia de Chave PÃºblica.  

 
 
 
63 

4.4. SUGESTÃƒO II â€“ Criptografia de Chave PÃºblica 

DuraÃ§Ã£o:100 minutos/ 2 aulas 

Objetivos:  Entender o  algoritmo de  Criptografia  de  Chave  PÃºblica.  Compreender o 

que Ã© uma assinatura digital e qual a sua importÃ¢ncia. 

SÃ©rie: A partir do 1ÂºAno do Ensino MÃ©dio 

PrÃ©-requisitos: NÃ£o hÃ¡ 

Mas o que seria chave pÃºblica? 

Nesta  atividade,  queremos  que  o  aluno  compreenda  o  conceito  de  chave 

pÃºblica, atravÃ©s do aplicativo CodeClass. NÃ£o iremos avanÃ§ar nesta atividade sobre 

como funciona o aplicativo nem quais formas de fazÃª-lo, simplesmente queremos que 

o aluno entenda a essÃªncia do funcionamento da criptografia, onde os dois envolvidos 

na  comunicaÃ§Ã£o,  em  momento  algum  precisarÃ£o  de  um  canal  seguro  para  passar 

informaÃ§Ã£o. 

ATIVIDADE 1 

Para  a  atividade,  precisamos  de  algumas  chaves  que  serÃ£o  utilizadas  na 

dinÃ¢mica. Como o foco sobre a geraÃ§Ã£o das chaves serÃ¡ dado na proposta seguinte, 

abaixo seguem alguns exemplos de chave que poderÃ£o ser utilizados. 

Figura 22 SugestÃµes de Chaves para Atividade 

CHAVE 1 

CHAVE 2 

CHAVE 3 

CHAVE 4 

CHAVE 5 

CHAVE 6 

(n,Publica) 

(33,3) 

(187,3) 

(209,7) 

(95,5) 

(1243,3) 

(649,3) 

(n,Privada) 

(33,7) 

(187,107) 

(209,103) 

(95,29) 

(1243,747) 

(649,387) 

CHAVE 7 

CHAVE 8 

CHAVE 9 

CHAVE10 

CHAVE 11 

CHAVE 12 

(n,Publica) 

(1003,3) 

(493,3) 

(1711,3) 

(319,3) 

(1067,7) 

(1649,5) 

(n,Privada) 

(1003,619) 

(493,299) 

(1711,1083) 

(319,187) 

(1067,823) 

(1649,1229) 

Fonte: O autor 

 
 
 
 
 
64 

Ã‰ interessante, talvez, deixar todas as chaves pÃºblicas expostas, para que um 

aluno saiba um a do outro. Como normalmente as turmas possuem mais de 20 alunos, 

talvez  seja  interessante  dividi-los  em  grandes  grupos,  pois  dois  alunos  nÃ£o  podem 

compartilhar uma mesma chave. No sistema Ã© possÃ­vel gerar quantas chaves forem 

necessÃ¡rias.  PeÃ§a-os  que  guardem  com  cuidado  as  suas  chaves  privadas  e  nÃ£o 

mostrem ao colega. 

Inicialmente, os alunos foram divididos em trios. Primeiro precisamos que eles 

compreendam como funciona a encriptaÃ§Ã£o neste sistema e quem Ã© o emissor e o 

receptor da mensagem. Emissor quem escreve, receptor quem recebe. 

PeÃ§a aos alunos que abram o aplicativo CodeClass. Em seguida cliquem no 

botÃ£o CRIPTOGRAFIA RSA depois CRIPTOGRAFAR MENSAGEM. 

Na nova tela, aparecem alguns campos que precisam ser preenchidos. Neles 

solicitam chaves pÃºblicas e privadas.  Nesse momento somente 2 alunos do trio irÃ£o 

participar. Um aluno irÃ¡ pegar a chave pÃºblica do colega para enviar uma mensagem 

a  ele.  Por  exemplo,  no  trio  de  JoÃ£o,  Ana  e  Pedro,  digamos  que  eles  estÃ£o 

respectivamente com as Chaves 1, 2 e 3, da Figura 22. JoÃ£o mandarÃ¡ uma mensagem 

a Ana, entÃ£o logo ele deve preencher os campos Chave PÃºblica do Receptor ğ‘› = 187 

e ğ¶ğ‘ğ‘¢ğ‘ = 3, que sÃ£o as chaves de pÃºblicas de Ana, que qualquer um pode ter acesso. 

Em seguida, ele deve escrever a mensagem nos 10 campos disponÃ­veis abaixo 

colocando  uma  letra, em  maiÃºsculo,  em  cada  campo.  Nesta  primeira  parte, nÃ£o hÃ¡ 

necessidade ainda de assinar, pois este nÃ£o Ã© o nosso foco por enquanto. Finalmente 

ao apertar o botÃ£o CRIPTOGRAFAR serÃ¡ gerada uma  sequÃªncia numÃ©rica abaixo, 

que sÃ£o os nÃºmeros que serÃ£o enviados a Ana. 

Ã‰ importante que sejam respeitados os espaÃ§amentos entre  os nÃºmeros por 

exemplo,  no  nosso  caso  enviando  a  Ana  a  mensagem  O  L  A  Q  U  E  R  I  D  A,  os 

nÃºmeros obtidos foram: 

9â€“ 45â€“ 1â€“ 51 âˆ’ 98â€“ 125â€“ 35â€“ 168â€“ 64â€“ 1 

Esse espaÃ§amento Ã© fundamental para que Ana consiga decifrar a mensagem. 

 
65 

Agora, JoÃ£o deve anotar a mensagem num papel e enviar a Ana, caso prefira, 

ele  pode  escrever  o  nome  dele  no  campo  Autor  da  mensagem  e  compartilhar 

utilizando a funÃ§Ã£o do prÃ³prio aplicativo. PorÃ©m a ideia neste momento Ã© que JoÃ£o 

entregue a mensagem a Pedro e que ele entregue a Ana, nesse meio tempo, Pedro 

deve  tentar  descobrir  qual  a  mensagem  que  foi  enviada  com  a  funÃ§Ã£o  DECIFRAR 

MENSAGEM. 

A funÃ§Ã£o de decifrar do aplicativo, Ã© parecida com a funÃ§Ã£o de cifrar. O receptor 

da mensagem, no caso Ana,  irÃ¡ digitar a sequÃªncia numÃ©rica recebida, cada bloco 

numÃ©rico em um campo como na foto abaixo. Em seguida digitarÃ¡ sua chave privada, 

neste caso, ğ‘› = 187, ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£ğ‘ğ‘‘ğ‘ = 107. Observe que as chaves privadas sÃ£o senhas e 

nunca devem ser expostas. Os nÃºmeros serÃ£o alterados, e para finalizar, basta que 

Ana  pressione  o  botÃ£o  CONVERTER  PARA  TEXTO,  para  que  ela  possa  ter  a 

mensagem traduzida. 

Ã‰  interessante  perceber  que  Pedro  pode  tentar  vÃ¡rias  combinaÃ§Ãµes  para 

descobrir a mensagem, talvez por tentativa ele consiga, porÃ©m ele nÃ£o tem nem noÃ§Ã£o 

de quantos caracteres tem a senha de Ana. Pode-se aproveitar o momento para fazer 

uma previsÃ£o de quantas tentativas ele iria precisar. 

Assinando uma mensagem 

Qual a razÃ£o de se assinar uma mensagem? Esta resposta encontramos pelo 

simples  fato  de  reconhecermos  a  importÃ¢ncia  de  garantir  que  o  receptor  nÃ£o  seja 

enganado por um falso emissor. Suponhamos, com base na nossa proposta anterior: 

O que impede Pedro de escrever uma mensagem criptografada para Ana e assinar 

como se fosse JoÃ£o? Por termos uma chave pÃºblica, na prÃ¡tica, qualquer pessoa teria 

o nosso endereÃ§o e poderia nos enviar qualquer mensagem. Imagine um falso banco 

nos enviando falsos boletos, como eu saberia se Ã© realmente do meu banco, ou nÃ£o? 

Portanto, peÃ§a aos alunos que abram o aplicativo, cliquem em CRIPTOGRAFIA 

RSA  em  seguida  CRIPTOGRAFAR  MENSAGEM.  PeÃ§am  que  realizem  o  mesmo 

procedimento,  da  parte,  vamos  exemplificar.  PeÃ§a  que  JoÃ£o  envie  a  mesma 

mensagem para Ana, do mesmo modo que procedeu anteriormente, mas agora antes 

de clicar em criptografar, ele deve marcar a caixa Assinar Mensagem. 

 
66 

Na sequÃªncia, irÃ¡ aparecer dois campos solicitando o valor de ğ‘› e ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£. JoÃ£o 

deve  inserir  nestes  campos  a  sua  senha  de  leitura,  sua  chave  privada.  NÃ£o  hÃ¡ 

problema em o fazer, pois os campos sÃ£o do tipo senha preservando o segredo da 

mensagem.  

Ao  mesmo  tempo,  Pedro  tambÃ©m  deve  escrever  uma  mensagem  a  Ana,  e 

assinÃ¡-la.  Como  Pedro  nÃ£o  conhece  as  credenciais  privada  de  JoÃ£o,  ele  terÃ¡  que 

utilizar as suas prÃ³prias chaves privadas, ou nÃ£o suar nenhuma. 

Agora,  tanto  Pedro,  quanto  JoÃ£o  devem  transmitir  a  sua  mensagem  a  Ana. 

Caso  eles  queiram  saber  sobre a  sua  identidade,  talvez  torne  o  processo  atÃ©  mais 

interessante. Por exemplo, tanto Pedro quanto JoÃ£o, preenchem o campo Autor como 

JoÃ£o, assim, Ana nÃ£o saberia qual o verdadeiro JoÃ£o. 

Quando  Ana  receber  as  mensagens,  ela  deverÃ¡  ir  na  tela  para  DECIFRAR 

MENSAGEM,  lÃ¡  irÃ¡  proceder  do  mesmo  modo  que  antes,  porÃ©m  deverÃ¡  marcar  o 

campo, MENSAGEM ASSINADA e lÃ¡ colocar as credenciais pÃºblicas (Chave PÃºblica) 

de  JoÃ£o.  Nesse  momento,  se  ela  fizer  o  mesmo  processo  de  leitura  com  as 

mensagens  de  JoÃ£o  e  de  Pedro,  ela  somente  irÃ¡  conseguir  ler  a  mensagem  do 

verdadeiro JoÃ£o. Provavelmente a outra nem serÃ¡ executada pelo aplicativo, podendo 

inclusive gerar erros, â€œbugandoâ€ ou atÃ© mesmo fechando a aplicaÃ§Ã£o, pois o programa 

nÃ£o conseguirÃ¡ interpretar as mensagens. 

4.5. AplicaÃ§Ã£o do CodeClass 

No dia 01 de Outubro de 2019, foi realizada uma oficina no ColÃ©gio Estadual 

Governador  Luiz  Viana  Filho,  na  cidade  que  Guanambi-BA,  com  o  intuito  de 

apresentar o aplicativo CodeClass e algumas das propostas metodolÃ³gicas que foram 

fundamentadas  e  sugeridas.  Nesta  oficina,  tivemos  13  colaboradores,  entre 

professores  e  estudantes.  Dentre  eles,  trÃªs  professores  da  Ã¡rea  de  ciÃªncias  da 

natureza e matemÃ¡tica e os demais, alunos do 1Âº Ano do Ensino MÃ©dio, sendo um da 

turma 1ÂºAM, um da turma 1ÂºBM e oito da turma 1ÂºDM, tidas regulares nesta instituiÃ§Ã£o 

no turno matutino. 

A oficina foi realizada no perÃ­odo da tarde, com inÃ­cio Ã s 14 horas e tÃ©rmino Ã s 

16  horas  e  40  minutos.  Como nÃ£o  havia  tempo hÃ¡bil  disponÃ­vel para  realizaÃ§Ã£o  de 

 
67 

todas  as  propostas  sugeridas  neste  trabalho,  foi  elaborada  uma  proposta  que 

agregasse  um  pouco  de  cada  um  dos  temas  sugeridos  e  que  focasse  mais  na 

utilizaÃ§Ã£o do aplicativo e explanaÃ§Ã£o teÃ³rica dos conceitos que regem a criptografia 

de  modo  prÃ¡tico.  Deste  modo,  podemos  realizar  um  teste  das  funcionalidades  do 

sistema e se o mesmo Ã© adequado para ser utilizado pelos estudantes. 

4.5.1. A Oficina 

Para  que  pudÃ©ssemos  avaliar  a  atividade,  foi  elaborado  um  questionÃ¡rio 

subdivido em seis partes, e que se encontra disponÃ­vel no Anexo A. Este questionÃ¡rio 

foi preenchido pelos participantes no decorrer da atividade. Cada parte Ã© precedida 

de  uma  proposta  diferente  relacionada  a  criptografia,  associada  ao  que  queremos 

avaliar naquele instrumento. 

A Parte I, trata dos conhecimentos prÃ©vios que o participante possui sobre os 

conteÃºdos que serÃ£o abordados e foram respondidas antes do inÃ­cio da proposta.   

A Parte II do instrumento, trata do  funcionamento do Sistema de Criptografia 

Linear e  visa  observar se os participantes foram  capazes de  conseguir  utilizar este 

sistema  criptogrÃ¡fico.  Por  meio  deste,  tambÃ©m  conseguiremos  observar  possÃ­veis 

causas de insucesso se este for o caso. Na Parte III, objetivamos avaliar se o conceito 

de  chave  pÃºblica  foi  compreendido  pelos  participantes.  A  quarta  e  quinta  partes 

relacionam-se  com  a  criptografia  RSA,  bem  como  a  utilizaÃ§Ã£o  da  assinatura  RSA. 

Caso  os  participantes  tenham  alguma  dificuldade  em  utilizar  o  sistema,  este 

instrumento tambÃ©m servirÃ¡ de registro para possÃ­veis falhas. 

Finalmente  a  Ãºltima  parte  do  questionÃ¡rio,  a  Parte  VI,  possui  perguntas  que 

direcionam  a  coleta  de  informaÃ§Ãµes  a  respeito  da  impressÃ£o  do  usuÃ¡rio  quanto  a 

interface do sistema, o qual iremos investigar opiniÃ£o do utilizador, bem como suas 

impressÃµes quanto a usabilidade do CodeClass. 

Parte I 

A  primeira  parte  buscou  coletar  informaÃ§Ãµes  quanto  ao  conhecimento  prÃ©vio 

dos voluntÃ¡rios. Foi observado que dos treze avaliados, todos desconheciam sobre a 

Cifra de CÃ©sar, apenas trÃªs em algum momento jÃ¡ ouviu falar sobre criptografia, mas 

questionados oralmente sobre onde eles podiam exemplificar aplicaÃ§Ãµes deste tema, 

 
68 

o geral nÃ£o soube. Um dos participantes alegou jÃ¡ conhecer superficialmente o tema, 

por ter iniciado um curso tÃ©cnico em InformÃ¡tica, mas nÃ£o deu continuidade. 

Uma  coisa  que  chamou  bastante  atenÃ§Ã£o  neste  estÃ¡gio  inicial,  foi  todos  os 

integrantes possuÃ­rem aparelhos celulares, acessarem diariamente as redes sociais e 

atÃ© mesmo efetuarem transaÃ§Ãµes financeiras no aparelho, mas mesmo assim nunca 

se questionaram sobre como Ã© tratada a seguranÃ§a destes dados.  

Parte II 

O inÃ­cio da oficina tratou da importÃ¢ncia da criptografia para nossa era digital, 

em decorrÃªncia da conscientizaÃ§Ã£o da necessidade de escondermos informaÃ§Ãµes e 

quem pode se beneficiar ou se prejudicar caso algo indevido seja exposto. 

Em seguida foi apresentada a Cifra de CÃ©sar e como CÃ©sar fazia para utilizÃ¡-

la  Ã   sua  Ã©poca.  O  mais  interessante  foi  fazÃª-los  perceber  como  a  matemÃ¡tica  se 

relaciona com estÃ¡ cifra por meio de uma funÃ§Ã£o afim levando um nÃºmero em outro. 

Afinal, como a maioria dos alunos, eram do 1ÂºAno Regular, o conteÃºdo de funÃ§Ãµes Ã© 

amplamente  trabalhado  nesta  sÃ©rie  de  acordo  a  BNCC  [4].  Finalmente,  foi 

apresentado o passo a passo para se executar esta codificaÃ§Ã£o no CodeClass. 

A atividade proposta foi cada um escolher dois parÃ¢metros, seja A, seja B, uma 

mensagem  de,  no  mÃ¡ximo,  dez  caracteres  e  enviÃ¡-la  ao  colega  mais  prÃ³ximo, 

juntamente  com  a  Chave  para  Leitura.  PorÃ©m,  essa  informaÃ§Ã£o  nÃ£o  podia  ser 

entregue diretamente, devendo antes passar pelo mediador da oficina que tentaria de 

todas as formas ler as informaÃ§Ãµes trocadas. A ideia era que eles percebessem que 

as mensagens nÃ£o estavam seguras visto que a senha para decodificar se encontrava 

no papel. 

Como forma de auxiliÃ¡-los e de facilitar o acompanhamento em caso de erro ou 

distorÃ§Ãµes,  foram  utilizados  cartÃµes  para  que  preenchessem  com  a  mensagem 

codificada e enviassem a um colega. 

 
 
69 

Figura 23 CartÃ£o da Parte II Criptografia Linear 

Fonte: O autor 

Neste cartÃ£o, o autor da mensagem iria escrever uma mensagem codificada 

pelo aplicativo e enviÃ¡-la para o receptor, juntamente com a chave para decodificÃ¡-

la. Em seguida o receptor caso conseguisse decifrar a mensagem com o aplicativo 

deveria escrevÃª-la na parte inferior destinada a isto. 

A Figura 23, foi um exemplo de mensagem que um dos participantes enviou. 

Nesta  etapa  todos  conseguiram  se  comunicar.  Um  dos  receptores  nÃ£o  conseguiu 

decodificar a mensagem  pois,  o autor colocou  as  chaves  de  leitura  invertidas,  mas 

verificado o problema, o mesmo teve Ãªxito na execuÃ§Ã£o da atividade. 

Muito  alunos  perceberam  que  havia  algo  errado  em  ter  que  enviar  a  senha 

junto,  comentando  em  alguns  casos.  Dentre  algumas  falas,  foi  registrado,  em 

anotaÃ§Ãµes de campo a de um estudante: 

â€œUÃ©, professor. Enviar essa senha tÃ¡ meio estranhoâ€ 
â€œE se alguÃ©m roubar a senha no caminho?â€ 

 
 
 
 
70 

Figura 24 Resposta de um aluno Ã  Parte II 

Fonte: O autor 

A Figura 24 mostra a resposta de um dos participantes Ã  Parte II do 

questionÃ¡rio. 

Parte III 

ApÃ³s todos conseguirem terminar a atividade proposta, foi feita uma dinÃ¢mica 

para  tentarmos  apresentar  o  conceito  de  chave  pÃºblica.  Na  dinÃ¢mica,  dois  alunos 

foram escolhidos para trocar informaÃ§Ãµes atravÃ©s de uma caixa. PorÃ©m, essa caixa 

nÃ£o poderia ir sem um cadeado, pois no meio do caminho havia um terceiro aluno que 

tentaria  abri-la.  Assim,  eles  deveriam  bolar  uma  estratÃ©gia  para  trocar  as  caixas, 

mantendo o conteÃºdo em seguranÃ§a.  

Os participantes, de maneira coletiva, tentaram bolar um plano para conseguir 

cumprir a atividade, mas sem Ãªxito. Houve entÃ£o a necessidade da interferÃªncia do 

mediador,  que  sugeriu  colocar  os  dois  cadeados  na  caixa.  Neste momento  um dos 

alunos conseguiu dar uma sugestÃ£o que completasse o desafio.  

 
 
 
 
71 

A  soluÃ§Ã£o  deste  problema,  consistem  em  enviar  a  caixa  com  a  mensagem 

dentro, trancada com o primeiro cadeado. Ao receber a caixa, o receptor irÃ¡ colocar o 

seu cadeado na caixa e enviÃ¡-la de volta para o primeiro usuÃ¡rio, que irÃ¡ retirar o seu 

cadeado e novamente enviÃ¡-la para o receptor. Que poderÃ¡ finalmente abrir o Ãºltimo 

cadeado e revelar o seu conteÃºdo. 

Nos  questionÃ¡rios  percebemos  que  somente  um  dos  participantes  nÃ£o 

conseguiu  compreender  a  funcionamento  desta  estratÃ©gia.  Marcando  que  seriam 

necessÃ¡rias mais que trÃªs â€œviagens da caixaâ€ para o envio da informaÃ§Ã£o. 

Parte IV 

O  objetivo  da  Parte  IV,  era  simular  um  sistema  de  troca  de  mensagens  pelo 

canal utilizando o sistema RSA. Primeiramente utilizamos o aplicativo para gerar as 

chaves  pÃºblicas e  privadas  de  cada  um dos  alunos presentes.  Estas  chaves foram 

inseridas  nos  questionÃ¡rios  para  que  apÃ³s  a  finalizaÃ§Ã£o  da  atividade  pudÃ©ssemos 

testas. 

Verificamos que todas as chaves foram geradas com sucesso, porÃ©m um dos 

participantes  nÃ£o  conseguiu  utilizar  primos  maiores  que  17  para  geraÃ§Ã£o  de  suas 

chaves.  O  aplicativo  era  finalizado  toda  vez  que  este  tentava  acrescentar nÃºmeros 

maiores. Ainda nÃ£o conseguimos identificar o erro que aconteceu unicamente em um 

aparelho da marca Samsung modelo J5 Prime. 

ApÃ³s  cada  um  ter  gerado  as  suas  chaves,  todas  as  chaves  pÃºblicas  foram 

divulgadas no quadro, para facilitar o processo de envio. Em seguida foram solicitados 

a escrever a mensagem ao colega no cartÃ£o correspondente para que fosse enviada 

atravÃ©s do Canal. Quando todos terminaram de redigir sua mensagem, o ministrante 

se passando pelo Canal, recolheu todos os cartÃµes para entregÃ¡-los aos respectivos 

destinatÃ¡rios  que  iriam  realizar  as  suas  respectivas  decodificaÃ§Ãµes.  Na  Figura  25, 

segue um exemplo dos cartÃµes enviados. 

 
72 

Figura 25 Troca de mensagens utilizando Criptografia RSA. Parte IV 

Fonte: O autor 

Nesta etapa todos os alunos conseguiram efetuar a leitura de suas mensagens 

de maneira correta, porÃ©m alguns nÃ£o a registraram no cartÃ£o, mantendo somente a 

decodificaÃ§Ã£o no aparelho. 

Nesta etapa, foi inserida tambÃ©m uma jogada surpresa por parte do ministrante. 

Sem  que  os  alunos  soubessem,  enquanto  os  autores  estavam  redigindo  as 

mensagens, foram confeccionados cartÃµes falsos pelo mediador, que seriam trocados 

na hora da entrega da seguinte forma.: 

A  aluno A,  enviou  para  o  aluno  B  uma  certa  mensagem.  O  mediador  havia 

previamente  confeccionado  um  cartÃ£o  falso  do  aluno  A  para  o  B  e  efetuou  a 

substituiÃ§Ã£o  do  cartÃ£o  verdadeiro  pelo  falso  no  momento  da  entrega.  ApÃ³s  a 

decodificaÃ§Ã£o, eles foram surpreendidos pela mensagem da Figura 26. 

 
 
73 

Figura 26 CartÃ£o falso, confeccionado pelo mediador. 

Fonte: O autor 

Os  participantes  comeÃ§aram  a  questionar  sobre  a  seguranÃ§a  e  debatendo 

sobre o que poderia ter acontecido. Sozinhos chegaram a conclusÃ£o de que os cartÃµes 

haviam sido alterados. Neste momento um aluno questionou: 

â€œ Como eu vou ter certeza que foi o â€œaluno Aâ€ que enviou a mensagem para mim? â€ 

Aluno B 

Parte V 

A Parte V e a Ãºltima que envolve a utilizaÃ§Ã£o do aplicativo, veio para responder 

o questionamento do aluno ao final da Parte IV. Como ter a certeza da autenticidade 

do remetente?  

Foram apresentados durante a atividade, exemplos de situaÃ§Ãµes prÃ¡ticas onde 

necessitamos verificar quem de fato Ã© o remente, como nos casos dos e-mails. Foi 

apresentado o seguinte e-mail da Figura 27. 

 
 
 
74 

Figura 27 E-mail falso 

Fonte: O autor 

ApÃ³s a explanaÃ§Ã£o, os participantes perceberam como Ã© importante no meio 

digital garantir a veracidade de uma informaÃ§Ã£o, afinal caso acreditÃ¡ssemos que o e-

mail  era  de  fato  do  Banco  Bradesco,  poderÃ­amos  colocar  a  integridade  do  nosso 

computador em risco pois, muito provavelmente este link levaria a algum Malware que 

infectasse nossa mÃ¡quina. 

A  dinÃ¢mica  desta  Ãºltima  parte,  consistia  em  realizar  a  codificaÃ§Ã£o  de  uma 

mensagem, utilizando tambÃ©m a funÃ§Ã£o de Assinatura do aplicativo CodeClass. Esta 

etapa exigia um cuido a mais dos alunos, pois qualquer erro de digitaÃ§Ã£o por parte do 

autor, iria inviabilizar o processo de decodificaÃ§Ã£o.  

O processo nÃ£o ocorreu da maneira devida, pois o aplicativo apresentou um 

erro  na  decodificaÃ§Ã£o,  que  os  alunos  nÃ£o  conseguirem  contornar  e  isto  acabou 

interferindo negativamente nesta etapa final. 

O  erro  apresentado  em  todos  os  aparelhos,  foi  identificado  como  sendo  na 

programaÃ§Ã£o  do  sistema,  apÃ³s  uma  pequena  alteraÃ§Ã£o  que  havia  sido  feita  no 

aplicativo. A imagem da Figura 28, Ã© a codificaÃ§Ã£o da mensagem T O M E C U I D A 

D, que o participante E enviou ao participante R, utilizando a funÃ§Ã£o assinatura. 

 
 
75 

Figura 28 Troca de mensagens entre E e R utilizando assinatura. 

Fonte: O autor 

ApÃ³s comparar os questionÃ¡rios, conseguimos identificar as chaves pÃºblicas 

e privadas de ambos participantes, para que pudÃ©ssemos simular o processo e 

entender a origem do erro. 

O participante E que Ã© autor da mensagem, possuÃ­a Chave PÃºblica: ğ‘› = 6901 

e ğ¶ğ‘ğ‘¢ğ‘ = 5 e Chave Privada: ğ‘› = 6901 e ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£ = 2693, como pode ser verificado na 

Figura 29. 

Figura 29 Chaves do Autor E 

 
 
 
76 

Fonte: O autor 

JÃ¡ o usuÃ¡rio R, possuÃ­a a Chave PÃºblicas e Privadas respectivamente ğ‘› =

946, ğ¶ğ‘ğ‘¢ğ‘ = 3 e ğ‘› = 943, ğ¶ğ‘ğ‘Ÿğ‘–ğ‘£ = 587. 

A codificaÃ§Ã£o feita por E, foi correta, porÃ©m, na decodificaÃ§Ã£o, quando R 

inseriu os dados no aplicativo juntamente com a sua Chave Privada e a Chave 

PÃºblica do autor, obteve o resultado como da Figura 30 

Figura 30 Resultado apresentado na decodificaÃ§Ã£o 

Fonte: O autor 

Observe  que  os  nÃºmeros  apresentados  deveriam  ser  menores  que  26,  para 

que fosse possÃ­vel converter a mensagem em texto. ConcluÃ­mos entÃ£o que o sistema 

nÃ£o codificou corretamente a mensagem. PorÃ©m caso pressionÃ¡ssemos novamente 

o  botÃ£o  DECODIFICAR  MENSAGEM,  irÃ­amos  perceber  que  a  mensagem  seria 

decodificada corretamente. 

 
 
77 

Figura 31 Mensagem apÃ³s segunda tentativa de decodificaÃ§Ã£o 

Fonte: O autor 

PorÃ©m  ainda  apresentado  erro,  pois  o  botÃ£o  de  conversÃ£o  para  texto  nÃ£o 

apareceu, tornando necessÃ¡ria uma conversÃ£o manual utilizando a correspondÃªncia 

da  Figura  5.  Com  isso,  a  etapa  proposta  nÃ£o  obteve  o  sucesso  esperado,  mas  foi 

explanado aos participantes sobre o problema e realizado um exemplo coletivamente 

de decodificaÃ§Ã£o com assinatura. 

Parte VI 

Finalmente  a  Ãºltima  parte  do  questionÃ¡rio  tratava  sobre  as  percepÃ§Ãµes  do 

participante  a  respeito  da  oficina  e  do  aplicativo.  Buscamos  coletar  informaÃ§Ãµes  a 

respeito da dinÃ¢mica da oficina, interface e usabilidade do CodeClass. 

Devido a finalizaÃ§Ã£o da oficina prevista para as 16:30 e ter se estendido atÃ© Ã s 

16:40, muitos alunos tiveram de sair apressadamente deixando parte da sexta parte 

incompleta. 

Dos  que  avaliaram  o  aplicativo,  pudemos  perceber  que  no  geral,  avaliaram 

positivamente  a  interface  e  boa  usabilidade.  PorÃ©m  o  ponto  que  mais  chamou  a 

atenÃ§Ã£o, foi a  o erro  na  Ãºltima  tarefa.  O aplicativo  nesta  etapa  recebeu  notas  mais 

baixas na avaliaÃ§Ã£o.  

 
 
78 

De  um  modo  geral,  pudemos  perceber  que  os  participantes  avaliaram 

positivamente a atividade e a forma como estes conteÃºdos, que eram desconhecidos 

por  muitos,  foram  trabalhados.  Os  docentes  envolvidos  acharam  a  oficina  â€œbem 

interativa e dinÃ¢micaâ€.  

Julgaram tambÃ©m que a oficina deveria ser dividida em mais seÃ§Ãµes afim de 

diluir as informaÃ§Ãµes passadas, dando tempo para: â€œdigerir todas as informaÃ§Ãµesâ€ que 

se faziam presentes. 

 
 
 
79 

5.   RESULTADOS E DISCUSSÃ•ES  

Tentaremos  apresentar  agora  um  paralelo  de  todo  o  processo  que  foi 

desenvolvido  desde  o  inÃ­cio  deste  projeto  atÃ©  o  momento,  apresentado  as  falhas  e 

acertos que obtivemos durante toda a execuÃ§Ã£o do mesmo. 

1.1. ConfecÃ§Ã£o do CodeClass 

Durante o desenvolvimento do aplicativo, pudemos perceber a necessidade de 

compreender  processos  mais  avanÃ§ados  de  programaÃ§Ã£o,  para  que  seja  possÃ­vel 

reduzir  o  tempo  de  execuÃ§Ã£o  de  muitas  tarefas  que  o  CodeClass  executa. 

Acreditamos  que  o  aplicativo  ainda  Ã©  muito  primitivo  neste  ponto,  pois  faz-se 

necessÃ¡rio ainda a execuÃ§Ã£o de tarefas repetidas para obter certo resultado. 

AlÃ©m disso, gostarÃ­amos de tornar a entrada de informaÃ§Ãµes mais intuitiva, de 

modo que fosse mais fÃ¡cil para o usuÃ¡rio inserir os dados na plataforma. Imagine vocÃª 

simplesmente  poder  a  mensagem  em  um  Ãºnico  campo  e  o  sistema  conseguir 

identificar cada caractere independente de ser maiÃºscula ou minÃºscula. Estas serÃ£o 

provavelmente melhorias nas prÃ³ximas atualizaÃ§Ãµes do aplicativo do CodeClass. 

Um outro  processo  que  identificamos falhas, foi  na  geraÃ§Ã£o das  chaves.  Por 

mais que funcione, o tempo de execuÃ§Ã£o aparenta ainda ser extenso. Visto que para 

nÃºmeros relativamente pequenos a partir 600, nÃ£o conseguimos concluir a tarefa pela 

demora  na  execuÃ§Ã£o.  Isto  se  dÃ¡  pelo  fato  do  algoritmo  utilizado  na  resoluÃ§Ã£o  da 

EquaÃ§Ã£o  Diofantina,  necessÃ¡ria  na  geraÃ§Ã£o  das  chaves,  nÃ£o  ser  eficiente,  vide     

Anexo 2.  

Acreditamos  que  estes  processos  podem  ser  otimizados,  com  o  auxÃ­lio  de 

algum  colaborador  na  Ã¡rea  de  computaÃ§Ã£o.  Sabemos  tambÃ©m  da  limitaÃ§Ã£o  da 

plataforma  em  que  o  mesmo  foi  desenvolvido.  E  por  isso  ainda  Ã©  um  desafio 

conseguirmos encontrar meios de contornar certas demandas. 

Um resultado que jÃ¡ obtivemos em umas das atualizaÃ§Ãµes feitas antes mesmo 

da  utilizaÃ§Ã£o  do  aplicativo,  foi  a  alteraÃ§Ã£o  do  algoritmo  que  faz  a  verificaÃ§Ã£o  dos 

primos. 

 
 
 
80 

Na tela de geraÃ§Ã£o dos primos, utilizamos um algoritmo apresentado  em um 

vÃ­deo  do projeto  MatemÃ¡tica  com  Aplicativos,  que pode  ser acessado  em  [13],  que 

utiliza  o  Teorema  de  Wilson,  na  sua  confecÃ§Ã£o.  Para  geraÃ§Ã£o  dos  primos,  ele  se 

mostra bastante eficiente, visto que Ã© possÃ­vel armazenar o valor anterior na memÃ³ria 

e reutilizÃ¡-lo para determinar o prÃ³ximo primo. PorÃ©m quando tivemos que montar uma 

rotina para verificar a primalidade de certo nÃºmero, este algoritmo nÃ£o se mostrou tÃ£o 

eficiente quanto a forÃ§a bruta (testar nÃºmero por nÃºmero atÃ© obtermos um divisor ou 

nÃ£o). Visto que este teste deve ser feito somente com os Ã­mpares atÃ© a raiz do primo 

que desejamos verificar. 

1.2. Oficina 

Na oficina podemos perceber como a criptografia ainda Ã© pouco difundida nos 

meios pÃºblicos. Mais impressionantes ainda Ã© observar como a seguranÃ§a na internet 

Ã©  pouco  discutida.  O nÃºmero de  ataques  cibernÃ©ticos  sÃ³  tem  aumentado no  Brasil, 

chegando a dobrar em 2018 segundo reportagem do Canaltech disponÃ­vel em [15]. 

Ainda  assim,  percebemos  o  quanto  que  as  pessoas  pouco  sabem  ou  nÃ£o  se 

interessam  pelam  tema.  Quando  realizÃ¡vamos  a  divulgaÃ§Ã£o  da  oficina,  poucas 

pessoas apresentaram interesse no assunto. 

Durante  as  oficinas,  percebemos  que  um  ponto  que  foi  bastante  comentado 

pelos participantes foi a Criptografia Linear. Percebemos que eles gostaram bem mais 

desta do que da RSA. Talvez por ser mais simples de se entender os exemplos da 

Cifra  de  CÃ©sar  que  ilustra  bastante  o  tema.  Ela  foi  crucial  tambÃ©m  para  poderem 

comparar o que difere a Linear da RSA quanto a ter a chave pÃºblica exposta.  

Encontramos entÃ£o uma aplicaÃ§Ã£o para as FunÃ§Ãµes Afim, juntamente com a 

AritmÃ©tica Modular, abordada normalmente em livros do Ensino MÃ©dio. AlÃ©m disso, o 

fato dos alunos poderem participar da atividade com o celular a todo momento em seu 

porte, os motivou a querer prestar mais atenÃ§Ã£o na proposta. 

 
 
 
 
 
 
 
81 

6.   CONSIDERAÃ‡Ã•ES FINAIS 

A  criptografia  busca  utilizar  diversos  mÃ©todos  nÃ£o  sÃ³  matemÃ¡ticos  para 

esconder informaÃ§Ãµes, como foi o caso da Citale Espartana. Exatamente por isso, Ã© 

uma porta de entrada para tratar de diversos assuntos presentes no currÃ­culo nÃ£o sÃ³ 

do ensino mÃ©dio, como tambÃ©m fundamental. 

NÃ£o precisamos montar um sistema complexo, ou mesmo superseguro para se 

trabalhar criptografia dentro da sala de aula. O que precisamos Ã© encontrar formas de 

tornÃ¡-la acessÃ­vel e prÃ¡tica. Podemos criar diversas tÃ©cnicas de se criptografar uma 

mensagem utilizando muitos conteÃºdos da disciplina de matemÃ¡tica, as temÃ¡ticas que 

abordamos  aqui  sÃ£o  apenas  uma  pontinha  de  um  leque  vasto  e  diversificado  de 

sistemas. 

Uma busca rÃ¡pida pelo repositÃ³rio de dissertaÃ§Ãµes do PROFMAT, jÃ¡ Ã© possÃ­vel 

identificar quase 70 trabalhos que visam trazer aplicaÃ§Ãµes de criptografia no ensino 

mÃ©dio. Estes, buscam aplicar alguns conteÃºdos como matrizes, resÃ­duos quadrÃ¡ticos, 

recorrÃªncias e funÃ§Ãµes. Isso mostra que Ã© possÃ­vel trazer para sala de aula, fatos que 

sejam realmente relevantes para o aluno. Ã‰ possÃ­vel dar um sentindo e uma aplicaÃ§Ã£o 

prÃ¡tica ao emaranhado de nÃºmeros e operaÃ§Ãµes matemÃ¡ticas. 

AlÃ©m  disso,  torna-se  possÃ­vel  despertar  um  senso  crÃ­tico  nos  alunos, 

instigando-os a discutir se Ã© possÃ­vel â€œcriarâ€ criptografias com uma funÃ§Ã£o afim, mas o 

porquÃª  de  nÃ£o  o  fazÃª-la  com  a  funÃ§Ã£o  quadrÃ¡tica.  SerÃ¡  que  podemos  modificar  a 

funÃ§Ã£o do segundo grau para que possamos utilizÃ¡-la? 

Alguns mÃ©todos ainda, sÃ£o muito menos falados, mas poderÃ­amos ainda citar 

o Criptex supostamente elaborado por Leonardo da Vinci que Dan Brow apresenta em 

seu  livro  e  que  posteriormente  virou  filme  O  CÃ³digo  da  Vinci  [16].  Um  cofre,  que 

necessita  de  uma  senha  para  revelar  seu  conteÃºdo  e,  se  forÃ§ado  libera  uma 

substÃ¢ncia em seu interior que destrÃ³i a mensagem. Ã‰ a Geometria e a Engenharia 

juntas  para  esconder  segredos  e  aumentar  ainda  mais  a  gama  do  que  pode  ser 

trabalhado.  

Montamos  uma  proposta  que  ainda  tem  muito  a  amadurecer  e  ser 

aperfeiÃ§oada,  e  que  foi  bem  aceita  pelos  estudantes.  Acreditamos  ainda,  que  seja 

possÃ­vel  aguÃ§ar  ainda  mais  o  interesse,  se  alÃ©m  de  apresentarmos  o  sistema, 

 
 
82 

trabalharmos  tambÃ©m  a  programaÃ§Ã£o  por  traz  do  aplicativo.  As  oportunidades  sÃ£o 

inÃºmeras, resta agora tornarmos a criptografia cada vez mais popular. 

 
REFERÃŠNCIAS  

[1]  COUTINHO  S.  C.  NÃºmeros  Inteiros  e  Criptografia  RSA.  Rio  de  Janeiro: 

IMPA, 2011. (ColeÃ§Ã£o MatemÃ¡tica e AplicaÃ§Ãµes) 

[2]  SINGH, S. O livro dos cÃ³digos. Record, Rio de Janeiro. TraduÃ§Ã£o de Jorge 

Calife, 2001. 

[3]  BAHIA  SECRETARIA  DA  EDUCAÃ‡ÃƒO.  OrientaÃ§Ãµes  curriculares  para  o 

ensino  mÃ©dio  Ã¡rea:  matemÃ¡tica  /  Secretaria  da  EducaÃ§Ã£o.  â€“  Salvador: 

Secretaria 

da 

EducaÃ§Ã£o, 

2015. 

DisponÃ­vel 

em 

<http://escolas.educacao.ba.gov.br/sites/default/files/private/midiateca/docum

entos/2017/matematica.pdf>. Acessado dia 03/10/2019. 

[4]  BRASIL.  Base  Nacional  Comum  Curricular.  BrasÃ­lia.  MEC/SEF,  2019. 

DisponÃ­vel 

em 

:  

http://basenacionalcomum.mec.gov.br/images/BNCC_EI_EF_110518_versaof

inal_site.pdf>  Acessado em: 03/10/2019 

[5]  SANTOS J. P. O. IntroduÃ§Ã£o Ã  Teoria dos NÃºmeros. -3 ed.- Rio de Janeiro: 

IMPA, 2018. 

[6]  HEFEZ, A. AritmÃ©tica. Rio de Janeiro: SBM, 2016. 

[7]  MARTINEZ,  F.  B.  et  al.  Teoria  dos  NÃºmeros:  um  passeio  com  primos  e 

outros nÃºmeros familiares pelo mundo inteiro. Rio de Janeiro: IMPA, 2018. 

[8]  COMPUTAÃ‡ÃƒO  NA 

em 
<http://www.computacaonaescola.ufsc.br/?page_id=1656.>  Acessado  em 
13/08/2019).  

Somos.  DisponÃ­vel 

ESCOLA  Quem 

[9]  PROJETO COMPUTAÃ‡ÃƒO NA ESCOLA PÃ¡gina do Projeto. DisponÃ­vel em: 

<http://www.computacaonaescola.ufsc.br/> .Acessado em 13/08/2019 . 

[10]  MIT  APP 

INVENTOR 

II  Acesso  a  Plataforma.  DisponÃ­vel  em: 

<http://ai2.appinventor.mit.edu/>  Acessado em : 19/09/2019.  

[11]  LEMOS  M.  Criptografia,  NÃºmeros  Primos  e  Algoritmos.  Rio  de  Janeiro: 

IMPA, 2009. (PublicaÃ§Ãµes MatemÃ¡ticas) 

[12]  ALVES  E.  A.  W.  Aplicativo  CodeClass  para  andriod.  CodeClass.apk  â€“ 

DisponÃ­vel 

em: 

<https://drive.google.com/open?id=1ZIGebePmMCXP6gXMrBTfBFWfoQGQX

a-j> ou DisponÃ­vel em: <https://is.gd/lniSDC> (encurtador de url). Acessado em: 

01/10/2019 

 
[13]  BARBOSA.  M.  A.  NÃºmeros  Primos  -  Teorema  de  Wilson  -  MIT  App 

Inventor.  DisponÃ­vel  em:  https://www.youtube.com/watch?v=vyROeH5b7kg. 

Acessado em: 10/09/2019. 

[14]  BARBOSA.  M.  A.  Desenvolvendo  Aplicativos  Para  Dispositivos  MÃ³veis 

AtravÃ©s  Do  Mit  App  Inventor  2  Nas  Aulas  De  MatemÃ¡tica.  2016.  144  f. 

DissertaÃ§Ã£o (Mestrado em MatemÃ¡tica) - PROFMAT, UESC, Bahia. 

[15]  WAKKA W. NÃºmero de ataques cibernÃ©ticos no Brasil quase que dobrou 

em  2018.  DisponÃ­vel  em:  <https://canaltech.com.br/seguranca/numero-de-

ataques-ciberneticos-no-brasil-quase-que-dobrou-em-2018-119600/> 

Acessado em: 30/09/2019 

[16]  BROW D., The Da Vinci code. First edition ed. New York: Doubleday, 2003. 

 
 
 
 
 
 
 
ANEXO A 

Criptografia e o CodeClass Uma Proposta MetodolÃ³gica6 

VocÃª Ã©: Estudante (    )     Professor (   ) 

Parte I â€“ Grau de Conhecimento 

1-  VocÃª sabe o que Ã© criptografia? 

(  ) Sim 

(  ) NÃ£o 

2-  Caso  tenha  marcado  sim  na  Pergunta  1,  responda:  VocÃª  entende  a  importÃ¢ncia  da 

criptografia na nossa era digital? 
 (   ) Sim    

(  ) NÃ£o 

3-  JÃ¡ ouviu falar do termo Sistema de Chave PÃºblica? 

(   ) Sim    

(  ) NÃ£o 

4-  VocÃª conhece a Cifra de CÃ©sar? 

(   ) Sim    

(  ) NÃ£o 

Parte II â€“ Criptografia Linear 

Escreva uma frase ou palavra de, no mÃ¡ximo, 10 caracteres. Caso tenha menos letras, 

1- 
complete os espaÃ§os vazios com a letra A. 

___   ___   ___   ___  ___  ___  ___   ___   ___   ___ 

2- Escolha dois nÃºmeros para seus parÃ¢metros A e B. Cuidado, pois o parÃ¢metro A nÃ£o pode 

ser 1, nem par e nem mÃºltiplo de 13. 

A = ___   

B = ___ 

3-  Utilizando o CodeClass, codifique a mensagem que vocÃª escolheu em na questÃ£o 1. Em 

seguida, escreva-a no espaÃ§o abaixo: 

___   ___   ___   ___   ___   ___   ___   ___   ___  ___ 

4-  Escreva as Chaves Para Leitura retornada pelo aplicativo no espaÃ§o abaixo: 

5-  Envie a mensagem para seu parceiro (a) por meio do Canal. 

A = ___  B = ___ 

6  Atividade  elaborada  com  finalidade  de  pesquisa  na  Ã¡rea  de  ensino  de  matemÃ¡tica  vinculada  ao Programa  de 

Mestrado  Profissional  em  MatemÃ¡tica  em  Rede  Nacional  (PROFMAT)  da  Universidade  Estadual  da  Bahia, 

campus VitÃ³ria da Conquista. 

 
 
 
 
 
 
 
 
 
 
                                                           
6-  VocÃª percebeu alguma falha neste sistema? Se sim, cite-a: 

_______________________________________________________________________
_______________________________________________________________________
_______________________________________________________________________
__________________ 

Parte III â€“ Criptografia Chave PÃºblica 

1-  VocÃª compreendeu o princÃ­pio de CodificaÃ§Ã£o por Chave PÃºblica? 

(   ) Sim.    

(   ) Um pouco, ainda tenho algumas dÃºvidas.      (  ) NÃ£o Compreendi. 

2-  Quantas viagens a caixa teve que realizar para atingirmos o objetivo? 

(   ) 1  

(   ) 2    

(   ) 3 

(   ) 4+ 

3-  E quando tornamos a chave do cadeado pÃºblica, quantas viagens teve que realizar? 

(   ) 1  

(   ) 2    

(   ) 3 

(   ) 4+ 

Parte IV â€“ Criptografia RSA 

1-  Escolha dois nÃºmeros primos P = ___  e Q = ___ menores que 400. 
2-  Gere as chaves pÃºblicas e privadas por meio do aplicativo CodeClass. 
3-  PÃºblica:  n=_________,Cpub________   Privada: n_________, Cpriv___________ 
4-  Torne PÃºblica a sua Chave (n,Cpub). 
5-  Escreva uma frase ou palavra de no mÃ¡ximo 10 caracteres. Caso tenha menos letras, 

complete os espaÃ§os vazios com a letra A. 

___   ___   ___   ___  ___  ___  ___   ___   ___   ___ 

1-  Codifique a mensagem utilizando a Chave PÃºblica do DestinatÃ¡rio 

______   ______   ______   _______  ______  _______  _______   ______   _____ 

2-  Envie a mensagem para o receptor Por meio do Canal. 

3-  VocÃª observou algum problema ou falha na seguranÃ§a? 

(   ) Sim. Cite_______________ 

(   ) NÃ£o 

4-  Todos  receberam  suas  mensagens  corretamente?  Comente  se  vocÃª  observou  alguma 

falha na seguranÃ§a. 

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
__________________ 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Parte V â€“ Assinatura Digital 

1-  Escolha dois nÃºmeros primos P = ___  e Q = ___ menores que 400. 
2-  Gere as chaves pÃºblica e privada atravÃ©s do aplicativo CodeClass. 
3-  PÃºblica:  n=_________,Cpub________   Privada: n_________, Cpriv___________. 
4-  Torne PÃºblica a sua Chave (n,Cpub). 
5-  Escreva uma frase ou palavra de no mÃ¡ximo 10 caracteres. Caso tenha menos letras, 

complete os espaÃ§os vazios com a letra A. 

___   ___   ___   ___  ___  ___  ___   ___   ___   ___ 

6-  Digite a mensagem no campo adequado. Insira a Chave PÃºblica do DestinatÃ¡rio, clique 
em Assinar Mensagem e Digite a sua Chave Privada (n,Cpriv). Codifique a mensagem: 

______   ______   ______   _______  ______  _______  _______   ______   _____ 

7-  Envie para o receptor por meio do Canal. 

8-  Deixe algum comentÃ¡rio que chamou a sua atenÃ§Ã£o neste procedimento. 

___________________________________________________________________________
___________________________________________________________________________
____________ 

Parte VI â€“ Sobre o Aplicativo 

1-  VocÃª  acredita  que  conseguiu  compreender  os  principais  conceitos  que  envolvem  a 

criptografia? 

(  ) Compreendi alguns conceitos     (   ) Compreendi a maioria dos conceitos

(  ) Compreendi todos os conceitos   (   ) NÃ£o compreendi muito bem 

2-  Das Partes II, III, IV, V da oficina, qual lhe chamou mais atenÃ§Ã£o? E por quÃª? 

II (  )  

III (   )  

IV (   )  

V (   ) 

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
__________________ 

3-  VocÃª  sentiu  a  necessidade  de  compreender  como  sÃ£o  feitas  algumas  etapas  dos 

processos de codificaÃ§Ã£o e decodificaÃ§Ã£o? 

(   ) NÃ£o  

(   ) Sim. Qual? ________________________________ 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
4-  Para as perguntas abaixo, avalie de 1 a 5, onde 1 Ã© muito ruim e 5 excelente. 
5-  Quanto a interface do aplicativo ____. 
6-  Quanto a velocidade de processamento ___. 
7-  Quanto a forma como as telas estÃ£o dispostas ___. 
8-  Quanto a erros que apareceram durante a realizaÃ§Ã£o das atividades ___. 

 
 
 
 
 
 
 
 
ANEXO B  

Parte do algoritmo de geraÃ§Ã£o de chaves do Sistema RSA 

 
 
