VIVIAN DA SILVEIRA MIRANDA

EXPLORANDO OS NÚMEROS PRIMOS E UMA DAS SUAS

APLICAÇÕES ATUAIS: A CRIPTOGRAFIA

2020

VIVIAN DA SILVEIRA MIRANDA

EXPLORANDO OS NÚMEROS PRIMOS E UMA DAS SUAS APLICAÇÕES ATUAIS:

A CRIPTOGRAFIA

Dissertação apresentada à Universidade Federal

de Lavras, como parte das exigências do

Programa de Pós-Graduação do Mestrado

Proﬁssional em Matemática em Rede Nacional

- PROFMAT - UFLA, para a obtenção do título

de Mestre.

Adriana Xavier Freitas

Orientadora

2020

Ficha catalográﬁca elaborada pelo Sistema de Geração de Ficha Catalográﬁca da Biblioteca

Universitária da UFLA, com dados informados pelo(a) próprio(a) autor(a).

Miranda, Vivian da Silveira

Explorando os números primos e uma das suas aplicações
atuais: a criptograﬁa / Vivian da Silveira Miranda. – Lavras :
UFLA, 2020.
90 p. :

Dissertação (mestrado proﬁssional)–Universidade Federal

de Lavras, 2020.

Orientadora: Adriana Xavier Freitas.
Bibliograﬁa.

1. Números primos. 2. Criptograﬁa. 3. Ensino médio. I.

Xavier, Adriana Freitas. II. Título.

Dedico esta monograﬁa ao meu marido e à minha mãe que estiveram ao meu lado me dando

apoio e me incentivando de forma paciente e carinhosa.

AGRADECIMENTOS

Agradeço, em primeiro lugar, a Deus por ter me capacitado, me dado determinação e, principa-

lemte, por ter me protegido durante todo o mestrado. Agradeço também aos meus colegas, que

não poderiam ser melhores! Sempre prontos a ajudar e incentivar. Em especial à Karina que foi

minha companheira de estrada e amiga para dividir os momentos bons e aﬂitos que passamos

nesse tempo. Aos meus professores que sempre procuraram a melhor forma de nos transmitir

um pouco do que sabem. E por último, agradeço à minha querida orientadora Adriana que me

guiou pelo melhor caminho para desenvolver esta dissertação, sempre com muito carinho nas

palavras e com explicações claras e concisas.

"A matemática é o alfabeto com o qual Deus escreveu o universo". Galileu Galilei

RESUMO

Os números primos são um grande mistério na Matemática, com grandes questionamentos e
curiosidades sobre eles. Será que existe um função que nos fornece todos os números primos?
Como saber se um determinado número é primo ou não? Qual a utilidade dos números primos?
Perguntas como essas nos motivou a escrever sobre esse tema pouco discutido na educação
básica e de tamanha importância, principalmente nos dias de hoje. Uma de suas aplicações,
que tem inﬂuência direta no nosso dia a dia, é na criptograﬁa. Quando fazemos uma transação
bancária, mandamos uma mensagem ou até mesmo escrevemos um bilhete em códigos, esta-
mos usando a criptograﬁa e consequentemente a Matemática. Esta dissertação aborda, em um
primeiro momento, conceitos sobre números primos, funções que os geram, testes de primali-
dades, primos especiais e alguns teoremas fundamentais sobre eles. Em seguida, são abordadas
as criptograﬁas RSA e ElGamal, sua codiﬁcação e decodiﬁcação bem como suas autenticida-
des. Também será apresentado o Protocolo Difﬁe-Hellman, um avanço na troca de chaves. Por
último são propostas atividades para despertar o interesse dos alunos dos anos ﬁnais do Ensino
Fundamental e do Ensino Médio e reforçar a importância da Matemática na vida de todos.

Palavras-chave: Números primos. Criptograﬁa. Ensino Médio.

ABSTRACT

Prime numbers are a great mystery in Mathematics with many questions and curiosities about
them. Is there a function which give us all prime numbers? How can one know wether a given
number is prime or not? How useful are prime numbers? Questions like those motivated us to
write about this topic which is not so much discussed in basic education and has huge relevance,
especially nowadays. One of its applications with direct inﬂuence in everyday life is encryption.
When we make a bank transaction, exchange a message or even when we write a note using
codes, we are using encryption and consequently Mathematics. In this dissertation we work,
ﬁrst, with concepts about prime numbers, generating functions, primality tests, special primes
and some fundamental theorems about them. Next, we present RSA and ElGamal encryption
systems, including their encoding, decryption and authenticity. We also present the Difﬁe-
Hellman Protocol, an advance in key exchange. Lastly, we suggest activities to arouse the
interest of students of basic education and to reinforce the importance of Mathematics in the
life of everybody.

Keywords: Prime number. Encryption. High school.

SUMÁRIO

1

2

INTRODUÇÃO .

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

NÚMEROS PRIMOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.0.1

Pequeno Teorema de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . .

2.1

2.1.1

2.1.2

2.1.3

2.2

2.2.1

2.2.2

2.3

2.3.1

2.3.2

2.3.3

2.3.4

2.4

2.4.1

2.4.2

FUNÇÕES QUE GERAM OS PRIMOS . . . . . . . . . . . . . . . . . . .

O polinômio de Euler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Outros polinômios .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Polinômio gerador de todos os números primos

. . . . . . . . . . . . . . .

DISTRIBUIÇÃO DE NÚMEROS PRIMOS . . . . . . . . . . . . . . . . .

Teorema dos números primos

. . . . . . . . . . . . . . . . . . . . . . . . .

Novo teorema sobre a distribuição dos números primos . . . . . . . . . . .

PRIMOS ESPECIAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Primos de Fermat .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Primos de Sophie Germain . . . . . . . . . . . . . . . . . . . . . . . . . . .

Primos de Mersenne

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Primos gêmeos .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

TESTE DE PRIMALIDADE . . . . . . . . . . . . . . . . . . . . . . . . . .

Custo de um algoritmo . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Testes determinísticos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.2.1 Crivo de Erastótenes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.2.2 Teorema de Wilson .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.2.3 Teste de Lucas .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.2.4 Teste Lucas-Lehmer .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.2.5

Fatoração de Fermat

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.2.6 AKS .

. .

. .

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.3

Testes não determinísticos

. . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.3.1 Teste de Leibniz .

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.3.2 Teste de Miller-Rabin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

PROBLEMAS EM ABERTO . . . . . . . . . . . . . . . . . . . . . . . . .

CRIPTOGRAFIAS .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Criptograﬁa RSA .

3.1.1

Pré-codiﬁcação .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.5

3

3.1

8

10

13

15

16

17

18

20

22

24

25

26

27

30

32

33

34

35

35

38

39

40

42

43

46

46

47

51

53

54

55

3.1.2

3.1.3

3.1.4

3.1.5

3.2

3.3

3.3.1

3.3.2

3.3.3

4

4.1

4.2

5

Codiﬁcação e decodiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . . . .

Autenticidade do método . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Segurança do RSA .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Assinaturas

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Protocolo Difﬁe-Hellman . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Criptograﬁa ElGmal

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

O Algoritmo de Criptograﬁa ElGamal

. . . . . . . . . . . . . . . . . . . .

Exemplo numérico .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Autenticidade do algoritmo . . . . . . . . . . . . . . . . . . . . . . . . . . .

ATIVIDADES .

Atividade 1 .

Atividade 2 .

.

.

.

.

CONCLUSÃO .

.

.

.

.

.

.

.

.

REFERÊNCIAS .

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

APENDICE A – CONGRUÊNCIAS . . . . . . . . . . . . . . . . . . . . .

APENDICE B – LOGARITMO DISCRETO . . . . . . . . . . . . . . . .

56

57

59

60

61

64

64

65

66

68

68

71

74

75

77

86

1 INTRODUÇÃO

8

Constantemente os professores são cobrados para que os conteúdos ministrados sejam

contextualizados e despertem o interesse em seus alunos. A Matemática apresenta uma van-

tagem, pois praticamente tudo que vamos fazer em nosso dia a dia, seja explicita ou implici-

tamente, envolve cálculos, raciocínio lógico, equações, proporções ou conceitos da geometria.

Até mesmo mandar uma mensagem, algo que parece não ter absolutamente nada a ver com

a Matemática, pode conter cálculos e propriedades matemáticas. Com certeza ao enviar uma

mensagem ou uma informação, você se deparou com a seguinte mensagem: “As mensagens e

as chamadas são protegidas com a criptograﬁa de ponta a ponta”. E é sobre essa segurança que

iremos trabalhar nessa dissertação. Estudaremos sobre a CRIPTOGRAFIA, ciência de trans-

formar, através de um processo conhecido como chave, uma informação de sua forma original

em outra ilegível aos que não tem acesso à essa chave. E a Matemática tem papel crucial

nessa transformação. A palavra criptograﬁa vem do grego e signiﬁca escrita secreta e segundo

(COUTINHO, 2009), criptograﬁa:

"É a arte dos “códigos secretos”, que todos já praticamos quando criança".

Os números primos também têm um grande destaque nessa dissertação. Ao ensinarmos

os números primos na educação básica, passamos ao aluno a falsa ideia de que esses números

servem apenas para fazermos o mínimo múltiplo comum e o máximo divisor comum. Mas,

ao estudarmos um pouco mais sobre esses incríveis números, percebemos o qual grandiosa é

sua aplicação e suas particularidades. Unir o ensino dos números primos com a aplicação na

criptograﬁa se torna extremamente interessante e o aluno passa a enxergar a utilidade de seu

aprendizado e esse passa a ter sentido.

Nossa dissertação tem por objetivo apresentar as Criptograﬁas de chaves assimétricas

RSA e ElGamal além dos conceitos matemáticos que as embasarão. Ela foi dividida em capítu-

los que se conectam e se complementam.

O primeiro capítulo trata-se deste texto introdutório com explicações do que será tratado

ao longo desta monograﬁa. No segundo capítulo nos dedicamos a falar sobre os Números pri-

mos, algumas deﬁnições e teoremas sobre sua importância e como todos os números naturais

podem se originar deles. Apresentamos também algumas funções que geram os primos, em-

basados em estudos de matemáticos que se dedicaram para encontrar e formular tais funções.

Em seguida, mostraremos como é a distribuição dos números primos, se a distância entre eles

é inﬁnita ou se há algum intervalo no qual sempre irá existir um número primo contido nele.

9

Apresentaremos alguns primos que são conhecidos como Primos especiais, primos que pos-

suem alguma característica especíﬁca. E para saber se um determinado número grande é primo,

estudaremos os Testes de primalidade.

Tudo que será explicado e mencionado no Capítulo 2 servirá de base para o Capítulo

3: Criptograﬁas. Nesse capítulo serão apresentados os algoritmos de codiﬁcação e decodiﬁca-

ção, exemplos práticos e suas respectivas autenticidades. Também apresentaremos o Protocolo

Difﬁe-Hellman, um dos grandes avanços na área da criptograﬁa, mais especiﬁcamente na troca

de chaves.

Para aplicar o que foi exposto nessa dissertação, temos o Capítulo 4: Atividades. Su-

gerimos duas atividades para serem desenvolvidas pelos professores com os alunos dos anos

ﬁnais do Ensino Fundamental ou Ensino Médio. Atividades que incentivam os alunos a praticar

a Matemática de forma prazerosa e descontraída, mas sem deixar de lado suas propriedades.

Por ﬁm, encerramos com as considerações ﬁnais deixando clara a importância de se

aprender Matemática e mostrando suas contribuições para temas tão atuais.

Esta dissertação também possui dois apêndices, um sobre Congruências e outro sobre

Logaritmo Discreto. Ambos apresentam teoremas e deﬁnições que servirão de base para o

capítulo sobre os números primos e para o capítulo sobre criptograﬁas.

10

2 NÚMEROS PRIMOS

Os números primos sempre foram e continuam sendo um dos grandes mistérios da Ma-

temática. Sua inﬁnidade e utilização ganham a atenção de muitos. A pergunta mais recorrente

sobre esses números acabou sendo respondida por Euclides ao provar que existem inﬁnitos

números primos. Mas ainda restava descobrir uma expressão viável para encontrar todos os

números primos ou, pelo menos, parte deles.

O fato é, os números primos nos auxiliam em várias questões matemáticas e sociais,

como por exemplo a criptograﬁa, tema central desta monograﬁa.

Trataremos, nesse capítulo, de algumas deﬁnições e propriedades dos números primos

que servirão como base para os próximos.

Deﬁnição 2.1 Um número natural maior do que 1 é chamado número primo se possuir como

divisores apenas o 1 e ele mesmo. Caso contrário, dizemos que o número é composto.

Podemos dizer que, um número natural n é primo se, ao escrevermos n da forma n = a.b,
com a, b ∈ N, temos apenas duas opções: a = 1 e b = n ou a = n e b = 1. No caso do número

natural n = a.b ser composto, temos que 1 < a < n e 1 < b < n.

Curiosidade: A palavra primos vem do latim PRIMUS que signiﬁca primeiro. Os

números primos recebem esse nome por não serem formados por outros números, serem os

“primeiros”. Os outros números que podem ser formados pelo produto de números primos, são

chamados de números compostos.

Notação: Usaremos a notação a|b para dizer que a divide b quando existir n ∈ Z tal que

b = a.n

Dados dois números primos p e q e um número inteiro qualquer a, temos que:

I) Se p|q, então p = q.

De fato, como p|q e sendo q um número primo, temos que p = 1 ou p = q. Sendo p

primo, temos que p > 1. Portanto, p = q.

II) Se p (cid:45) a, então mdc(p, a) = 1.

De fato, se mdc(p, a) = d, temos que d|p e d|a. Logo, d = p ou d = 1. Mas d (cid:54)= p, pois
p (cid:45) a, consequentemente, d = 1.

11

Proposição 2.2 Dois números inteiros a e b são primos entre si se, e somente se, existem intei-

ros m e n tais que ma + nb = 1.

A demonstração da proposição anterior pode ser encontra em (HEFEZ, 2016).

Teorema 2.3 Sejam a, b, c ∈ Z. Se a|bc e mdc(a, b) = 1, então a|c.

Demonstração: Se a|bc, existe y ∈ Z tal que bc = ay. Se mdc(a, b) = 1, pela proposição

anterior, temos que existem m, n ∈ Z tais que

ma + nb = 1.

Multiplicando ambos os membros da igualdade acima por c, temos:

mac + nbc = c.

mac + nay = c

a.(mc + ny) = c.

Mas bc = ay, então

Portanto, a|c.

(cid:4)

Lema 2.4 Sejam a, b, p ∈ Z, com p primo. Se p|ab, então p|a ou p|b.

Demonstração: Suponhamos que p|ab e, sem perda de generalidade, suponhamos que
p (cid:45) a. Então, basta provar que p | b. Se p (cid:45) a, então mdc(p, a) = 1. Assim, pelo Teorema 2.3,

p|b.

(cid:4)

Corolário 2.5 Se p, p1, ..., pn são números primos e, se p|p1...pn, então p = pi para algum

i = 1, .., n.

A demonstração do corolário anterior pode ser encontrada em (HEFEZ, 2016).

12

Teorema 2.6 Teorema fundamental da Aritmética

Todo número natural maior do que 1 ou é primo ou se escreve de modo único como um

produto de números primos.

Demonstração: Para esta demonstração usaremos a segunda forma do Princípio da

Indução Finita.

Se n = 2, o resultado é imediato. Suponhamos o resultado válido para todo número

natural menor do que n e vamos mostrar que vale para n. Para n primo, não há o que demonstrar.

Suponhamos então que n seja composto. Logo, existem números naturais n1 e n2 tais que

n = n1.n2, com 1 < n1 < n e 1 < n2 < n. Pela hipótese de indução, temos que existem números

primos p1, ..., pr e q1, ..., qs tais que n1 = p1...pr e n2 = q1...qs. Portanto n = p1...pr.q1...qs.

Agora, provaremos a unicidade da escrita. Suponhamos que tenhamos n = p1...pr =

q1...qs, onde os pi e os q j são números primos. Como p1|q1...qs, pelo Corolário 2.5, temos

que p1 = q j para algum j, que, após reordenamento de q1, ..., qs podemos supor que seja q1.

Portanto, p2...pr = q2...qs. Como p2...pr < n, a hipótese de indução acarreta que r = s e os pi

e os q j são iguais aos pares.

(cid:4)

Agrupando os fatores primos repetidos e ordenando os primos em ordem crescente no

Teorema 2.6, temos o seguinte enunciado:

Teorema 2.7 Dado um número inteiro n (cid:54)= −1, 0, 1, existem primos p1 < ... < pr e α1, ..., αr ∈
N univocamente determinados, tais que

n = ±(p1)α1...(pr)αr.

O próximo teorema é considerado uma das grandes conquistas da Matemática. Mostra-

remos duas demonstrações do próximo teorema, uma de Euclides outra de Euler.

Teorema 2.8 Existem inﬁnitos números primos.

Demonstração: Prova de Euclides Suponhamos, por absurdo, que exista apenas um

número ﬁnito de números primos p1, ..., pr. Considere o número natural

n = p1 p2...pr + 1.

13

Pelo Teorema 2.6, o número n é um número primo ou possui um fator primo p que,

portanto deve ser um dos p1, ..., pr e, consequentemente, divide o produto p1 p2...pr. Mas isso

implica que p divide 1, o que é absurdo. Portanto a sequência dos números primos é inﬁnita.

(cid:4)

Prova de Euler Suponhamos que a quantidade de números primos seja ﬁnita. São eles:

p1, p2, ..., pm. Considere ˜P deﬁnido pelo produto de m séries geométricas.

˜P =

(cid:32) ∞
∑
n=0

1
pn
1

(cid:33)

(cid:32) ∞
∑
n=0

·

1
pn
2

(cid:33)

· · ·

(cid:32) ∞
∑
n=0

1
pn
m

(cid:33)

.

As séries ∑∞

n=0

1
Pn
j

, com 1 ≤ j ≤ m, são convergentes com soma

∞
∑
n=0

1
pn
j

1

=

(cid:18)

1 −

1
p j

(cid:19) =

p j
p j − 1

.

Portanto:

˜P =

(cid:32) ∞
∑
n=0

1
pn
1

(cid:33)

(cid:32) ∞
∑
n=0

·

1
pn
2

(cid:33)

· · ·

(cid:33)

(cid:32) ∞
∑
n=0

1
pn
m

=

(cid:18) p1

(cid:19) (cid:18) p2

(cid:19)

p1 − 1

p2 − 1

...

(cid:18) pm

pm − 1

(cid:19)

.

Pelo teorema fundamental da aritmética (Teorema 2.6) todo inteiro positivo é represen-

tado unicamente como N = pn1

1 · pn2

2 · · · pnm

m . Logo

˜P =

∞
∑
n1,...,nm=0

1
pn1
1 · pn2
2 · · · pnm

m

=

∞
∑
N=1

1
N

= ∞

Chegando assim a uma contradição. Portanto, o conjunto dos números primos é inﬁnito.

(cid:4)

2.0.1 Pequeno Teorema de Fermat

Segundo (HEFEZ, 2016), o teorema que iremos apresentar já era de conhecimento dos

chineses há pelo menos 500 anos antes de Cristo, mas coube a Fermat, no século XVII, fazer

sua generalização. Apesar de receber o nome de “pequeno” é de grande importância, dentre

várias aplicações, para os testes de primalidade e para a criptograﬁa. Antes de enunciarmos o

Pequeno Teorema de Fermat, provaremo o seguinte lema:

Lema 2.9 Seja p um número primo. Os números

i < p, são todos divisíveis por p.

14



 = p





p

i

(p − 1)...(p − i + 1)
i!

, com 0 <

Demonstração: Para i = 1, o resultado segue de imediato. Suponhamos 0 < i < p.

Temos então que i!|p.(p − 1).(p − 2)...(p − i + 1). Mas como p é um número primo, temos que

mdc(i!, p) = 1. Assim, i!|(p − 1).(p − 2)...(p − i + 1). Provando assim que p divide







p

i

.

(cid:4)

Teorema 2.10 (Pequeno Teorema de Fermat) Dado um número primo p, tem-se que p divide

o número ap − a, para todo a ∈ Z.

Demonstração: Se p = 2, o resultado é óbvio já que a2 − a = a(a − 1) é par. Suponha-

mos p ímpar. Nesse caso, basta mostrar o resultado para a ≥ 0. Para a = 0, o resultado vale

pois p|0. Suponhamos o resultado válido para a, iremos prová-lo para a + 1. Pela fórmula do

Binômio de Newton,

(a + 1)p − (a + 1) = ap − a +


 ap−1 + ... +









p

1



 a.

p

p − 1

Pelo Lema 2.9 e pela hipótese de indução, o segundo membro da igualdade acima é

divisível por p, o resultado segue.

(cid:4)

Uma outra forma de enunciar o Pequeno Teorema de Fermat usando a notação de con-

gruência é:

Se p é um número primo e a ∈ Z, então

Mais ainda, se p (cid:45) a, então

ap ≡ a mod p.

ap−1 ≡ 1 mod p.

15

2.1 FUNÇÕES QUE GERAM OS PRIMOS

Quando pensamos em números naturais, conseguimos facilmente separá-los em pares

e ímpares. Se um número for da forma n = 2.m, com n e m naturais, ele será par; mas se for

da forma n = 2.m + 1, então será ímpar. Sendo assim, conseguimos uma fórmula para indicar

quando um número é par e quando ele é ímpar.

Será que com os números primos e compostos também conseguimos uma fórmula, uma

função para sabermos quando é um e quando é outro?

Podemos pensar em três tipos de funções, ou fórmulas, para determinar se um número é

primo ou composto. São elas:

i) f (n) = pn, n inteiro para todo n ≥ 1;

ii) f (n) é sempre um número primo e se n (cid:54)= m então f (n) (cid:54)= f (m);

iii) o conjunto de números primos é igual ao conjunto de valores positivos assumido pela

função.

Percebemos facilmente que a primeira condição é a mais ampla e a que mais nos chama

a atenção. Ela quer encontrar todos os primos em ordem. Já a segunda condição quer encontrar

um inﬁnidade de primos, mas não são todos e nem necessariamente em ordem. Por ﬁm, a

terceira condição quer encontrar uma função que descreva o conjunto dos números primos.

Exemplo 2.11 Um exemplo, não muito útil, da condição (i) é:

PN = 1 +

(cid:36)

(cid:115)
N

2N
∑
M=1

N
1 + π(M)

(cid:37)

,

sendo (cid:98)X(cid:99) a parte inteira de X e π(M) a quantidade de números primos menores do que ou

iguais ao x.

Obtida por Willians (1964) é uma fórmula muito extensa e acaba se tornando inútil.

Para termos uma ideia, se queremos encontrarmos o décimo primo, devemos contar quantos

primos existem até 1024:

P10 = 1 +

(cid:36)

(cid:115)
10

1024
∑
M=1

N
1 + π(M)

(cid:37)

= 29.

Exemplo 2.12 Um exemplo da condição (ii) pode ser dado por:

f (N) =

(cid:22)

222...w (cid:23)

,

16

sendo (cid:98)X(cid:99) a parte inteira de X.

(cid:22)

222...w (cid:23)

representa N etapas de expoentes e w = 1, 92827800... .

Obtida por Wright (1954), essa fórmula usa uma aproximação para w, o que gera erros

e acabamos obtendo números que não são primos. Tornando-a assim pouco útil.

Com relação à condição (iii), como iremos ver, não existe uma função polinomial com

uma única variável que gere todos os números primos, nem um algoritmo polinomial eﬁciente

que encontre os fatores de qualquer número natural composto. O que temos são algumas con-

jecturas e fórmulas que encontram uma parte dos primos. Veremos algumas delas com mais

detalhes nas seções seguintes.

Teorema 2.13 Se f (X) é um polinômio não-constante, com coeﬁcientes inteiros e uma variá-

vel, existem inﬁnitos inteiros n tais que | f (n)| não é primo.

Demonstração: Suponhamos que exista algum inteiro n0 ≥ 0 tal que | f (n0)| = p primo.

Sabendo que o polinômio não é constante, temos que

lim
n→∞

| f (n)| = ∞.

Então, existe n1 > n0 tal que, se n ≥ n1, então | f (n)| > p. Assim, para todo inteiro h tal

que n0 + ph ≥ n1, tem-se que f (n0 + ph) = f (n0)+ (múltiplo de p) = (múltiplo de p). Como

| f (n0 + ph)| > p, temos que | f (n0 + ph)| é um número composto.

(cid:4)

Pelo teorema anterior, vimos que um polinômio com coeﬁcientes inteiros e uma única

variável não fornece apenas números primos.

2.1.1 O polinômio de Euler

Veremos nesta seção um dos mais famosos polinômios geradores de primos, o Polinômio

de Euler, descoberto por Euler em 1772. O Polinômio de Euler dado pela função polinomial

17

P(n) = n2 − n + 41,

é um ótimo exemplo de função capaz de gerar uma grande sequência de números primos. Ao

analisarmos a função, conseguimos perceber facilmente que, se n for um múltiplo de 41, então

o número gerado não será primo, pois será múltiplo de 41 devido a sua forma.

Para n = 0, 1, 2, 3, ..., 39, todos seus valores são números primos. São eles, respectiva-

mente: 41, 43, 47, 53, 61, 71, 83, 97, 113, 131, 151, 173, 197, 223, 251, 281, 313, 347, 383,

421, 461, 503, 547, 593, 641, 691, 743, 797, 853, 911, 971, 1033, 1097, 1163, 1231, 1301,

1373, 1447, 1523 e 1601.

Curiosidade: Nesse polinômio de Euler, se tomarmos o polinômio P(n) = n2 + n + 41,

que se diferencia do P(n) apenas na mudança de sinal da variável de primeiro grau, com os

valores de n = 1, 2, 3, ..., 40 os primos encontrados são os mesmos.

2.1.2 Outros polinômios

Existem outros polinômios quadráticos que também produzem uma grande quantidade

de números primos. Veja em (RIBENBOIM, 2004). Alguns exemplos:

i) Polinômio de Legendre

Legendre observou que os polinômios da forma 2x2 + q, com q = 3, 5, 11 e 29 possuem a

maior quantidade de primos possíveis. Para outros valores de q a quantidade de número

primos encontrada é menor.

ii) Polinômio de A. Lévy

A. Lévy (1914) observou que 3x2 + 3x + 23 produz 22 primos.

iii) Polinômio de Pol e Speziali

Pol e Speziali (1951), encontraram 29 primos com o polinômio 6x2 + 6x + 31.

iv) Polinômio de R. Ruby

O polinômio quadrático f (x) = 36x2 − 810x + 2753, descoberto por R. Ruby (1990), é

atualmente o polinômio de uma variável que produz a maior quantidade de primos com

sucessivos valores iniciais tais que | f (k)| é primo, com k = 0, 1, 2..., 44.

18

v) Polinômio de Dress e Landreau

Dress e Landreau (2003) descobriram polinômios de grau superior, são eles:

f (x) = 66x3 + 83x2 − 13735x + 30139

sendo | f (x)| primo quando −26 < x < 19, obtendo 46 números primos; e

f (x) = 16x4 + 28x3 − 1685x2 − 2380x + 110647,

que gera 46 números primos para | f (x)| quando −2 < x < 22.

2.1.3 Polinômio gerador de todos os números primos

Na seção anterior, vimos que todos os polinômios com uma única variável geram apenas

uma parte dos números primos. Surgem então a seguinte questão: e se o polinômio tiver mais

de um variável?

Existe sim um polinômio que gere todos os números primos! Um polinômio com coeﬁ-

cientes inteiros, sendo que o conjunto de números primos coincide com o conjunto dos números

naturais assumidos por esse polinômio. O único detalhe é que um número primo pode aparecer

mais de uma vez.

Matijasevc (1971) descobriu um polinômio com grau 37 e 24 variáveis. Posteriormente,

ao fazer a tradução de sua descoberta para o inglês, esse polinômio foi aprimorado e contém 21

variáveis e grau 21.

Jones, Sato, Wada e Wiens (1976), descobriram um polinômio com grau 25 e 26 variá-

veis que encontram todos os número primos. É ele:

(k + 2){1 − [wz + h + j − q]2 − [(gk + 2g + k + 1)(h + j) + h − z]2

−[2n + p + q + z − e]2 − [16(k + 1)3(k + 2)(n + 1)2 + 1 − f 2]2

−[e3(e + 2)(a + 1)2 + 1 − o2]2 − [(a2 − 1)y2 + 1 − x2]2

−[16r2y4(a2 − 1) + 1 − u2]2 − [((a + u2(u2 − a))2 − 1)(n + 4dy)2

+1 − (x + cu)2]2 − [n + l + v − y]2 − [(a2 − 1)l2 + 1 − m2]2 − [ai + k + 1 − l − i]2

−[p + l(a − n − 1) + b(2an + 2a − n2 − 2n − 2) − m]2

−[q + y(a − p − 1) + s(2ap + 2a − p2 − 2p − 2) − x]2

−[z + pl(a − p) + t(2ap − p2 − 1) − pm]2}.

19

A demonstração pode ser encontrada em (RIBENBOIM, 2004).

Além desse polinômio que acabamos de ver, segundo Honsberger (1976) existe uma

função que gera os número primos. Antes de vermos tal função iremos enunciar o Teorema de

Wilson que será utilizado em sua demostração.

Teorema 2.14 Teorema de Wilson: Um número p é primo se, e somente se

(p − 1)! ≡ −1 mod p.

O Teorema de Wilson será demonstrado na seção de Testes de primalidade.

Proposição 2.15 Sejam x e y números naturais com y (cid:54)= 0 e a = x(y + 1) − (y! + 1), então

f (x, y) =

y − 1
2

(cid:2)|a2 − 1| − (a2 − 1)(cid:3) + 2

nos dá todos os números primos e somente estes.

Demonstração: Primeiro mostraremos que a função f (x, y) sempre será um número

primo e em seguida que ela fornece todos os números primos.

Note que a admite valores inteiros já que x e y são naturais, assim temos dois casos:

a2 ≥ 1 e a2 = 0.

i) Se a2 ≥ 1 temos que a2 − 1 ≥ 0, então |a2 − 1| = a2 − 1. Logo, f (x, y) = 2, que é um

número primo.

ii) Se a2 = 0, temos:

f (x, y) =

y − 1
2

[| − 1| − (−1)] + 2 = y + 1.

Como a2 = 0, então x(y + 1) − (y! + 1) = 0, ou seja, x(y + 1) = (y! + 1). Assim, (y +

1)|(y! + 1). Fazendo y = p − 1 temos o Teorema de Wilson:

p|(p − 1)! + 1.

Logo y + 1 é um número primo. Concluímos então que, para quaisquer valores naturais

de x e y a função f (x, y) será um número primo.

Como f (x, y) é primo para a = 0, temos x(y + 1) − (y! + 1) = 0. Assim, temos que

x =

y! + 1
y + 1

e, tomando y = p − 1, com p primo, teremos

o que nos dá

x =

(p − 1)! + 1
p

,

(cid:18)(p − 1)! + 1
p

f

(cid:19)

, p − 1

= p.

Portanto f (x, y) fornece todos os números primos.

20

(cid:4)

2.2 DISTRIBUIÇÃO DE NÚMEROS PRIMOS

Já sabemos que existem inﬁnitos números primos. Porém, não sabemos nada relativo a

sua distribuição dentro dos números naturais. Será que existe um intervalo no qual os números

primos estão mais concentrados? O objetivo desta seção é apresentar alguns resultados que

mostram como os números primos se distribuem e alguns resultados clássicos.

Usaremos como referência para esta seção (RIBENBOIM, 2004) e (COUTINHO, 2016).

Sabemos que qualquer inteiro na divisão por 6 deixa resto 0, 1, 2, 3, 4 ou 5. Como

queremos encontrar os números primos, os restos 0, 2 e 4 não nos convém pois tornariam o

número divisível por 2; o resto 3, tornaria o número divisível por 3. Portanto, se p for primo só

pode deixar resto 1 ou resto 5 quando dividido por 6. Isso nos leva a conjecturar que existem

inﬁnitos primos da forma 6N + 5.

Teorema 2.16 Existem inﬁnitos números primos da forma 6N + 5.

Demonstração: Suponhamos que

P = {5, p1, ..., ps},

seja um conjunto ﬁnito formado apenas por números primos da forma 6N + 5. Considere os

números

N = p1.p2 · · · ps

e 6N + 5.

21

Pelo teorema da fatoração única, podemos escrever 6N + 5 na forma

6N + 5 = qα1

1 · · · qαm
m ,

em que os qi são primos positivos e αi são inteiros positivos. Como 6N + 5 é ímpar, todos os

seus fatores têm que ser ímpares. Assim, os qi são ímpares e deixam resto 1 ou 5 na divisão por

6. Suponhamos que todos os qi deixem resto 1 na divisão por 6. Desta forma, teríamos que

Mas isso é impossível, pois

qα1
1 · · · qαm

m ≡ 1 mod 6.

qα1
1 · · · qαm

m ≡ 6N + 5 ≡ 5 mod 6

e 1 e 5 não são congruentes módulo 6.

O que nos leva a concluir que 6N + 5 tem pelo menos um fator primo que deixa resto 5

quando dividido por 6.

Como P, por hipótese, é o conjunto com todos os primos da forma 6N + 5, então 6N + 5

é divisível por algum elemento de P.

Primeiramente, temos que 5 não divide 6N + 5, pois se dividisse, teria que dividir tam-

bém

6N = (6N + 5) − 5 = 6N = 2 · 3 · p1 · · · ps

o que não acontece pelo fato de 5 não estar entre os primos dessa fatoração.

Por outro lado, se 6N + 5 fosse divisível por um dos primos que divide N, então (6N +

5) − 6N = 5, seria divisível pelo mesmo primo, o que também não é possível.

Mostrando assim que 6N + 5 não pode ser divisível por nenhum elemento de P, o que

nos leva a contradição.

Portanto, há uma quantidade inﬁnita de primos da forma 6n + 5.

(cid:4)

O que acabamos de provar foi um caso particular do Teorema de Dirichlet enunciado a

seguir

22

Teorema 2.17 Dados inteiros a e b primos entre si, então existe inﬁnitos primos da forma

an + b, com n natural.

Outro resultado clássico é o Postulado de Bertrand (1845): Seja n um inteiro positivo.

Então sempre existe um primo p tal que n ≤ p ≤ 2n.

As demonstrações do Teorema de Dirichlet e o Postulado de Bertrand podem ser encon-

tradas em (MARTINEZ; SALDANHA; TENGAN, 2011).

Esse postulado foi veriﬁcado por ele mesmo para todos os números até 2, 3 · 106.

2.2.1 Teorema dos números primos

Antes de prosseguir, deﬁniremos π(x) como sendo a quantidade de números primos tais

que 2 ≤ p ≤ x.

Apresentaremos agora algumas descobertas sobre a função π(x) em ordem cronológica.

Veja em (RIBENBOIM, 2004).

Euler

Como visto anteriormente, Euler demostrou que a soma dos inversos dos primos é di-

vergente, provando a inﬁnidade deles. Euler também observou que para todo número real σ > 1

a série

(cid:19)

(cid:18) 1
nσ

∞
∑
n=1

é convergente. Deﬁnindo assim, uma função ζ (σ ), conhecida como função zeta. A função zeta

expressa a fatoração de números inteiros como produto de números primos:

ζ (σ ) = ∏
p

1

1 −

1
pσ

, para σ > 1.

Legendre

Legendre (1808), utilizando o Crivo de Erastóstenes, provou que:

π(N) = π

√

N − 1 +∑ µ(d)

(cid:23)

,

(cid:22)N
d

o somatório é sobre todos os divisores d do produto de todos os primos p ≤

√

N e sendo

23

µ(d) a função de M ¨obius deﬁnida por:





µ(1) = 1;

µ(n) = (−1)r, se n f or o produto de r primos distintos;

µ(n) = 0, se o quadrado de um n ´umero primo divide n.

Como consequência desse resultado, Legendre mostrou que:

(cid:19)

(cid:18)π(x)
x

lim
n→∞

= 0.

Gauss

Com apenas 15 anos de idade, Gauss (1792) conjecturou que π(x) era assintoticamente

igual à função:

Tschebycheff

Li(x) =

(cid:90) x

2

dt
log t

.

Tschebycheff (1850) obteve grande avanço em determinar a magnitude de π(x) e mos-

trou que

se o limite existir.

Riemann

lim
x→∞

π(x)
x/log x

= 1,

Riemann, ao tentar obter uma melhor aproximação para π(x), começou a estudar a fun-

ção zeta e a estendeu para números complexos com partes reais maiores do que 1. A aproxima-

ção para a π(x) obtida por Riemann ﬁcou conhecida como Função de Riemann:

R(x) =

∞
∑
n=1

µ(n)
n

Li(x1/n),

Foi Riemann quem forneceu várias ferramentas para que se conseguisse provar o Teo-

rema dos Números Primos:

Teorema 2.18 (Teorema dos números primos) Seja π(x) a quantidade de números primos tais

que 2 ≤ p ≤ x. Temos que

lim
x→∞

π(x)
x/log x

= 1.

24

A demonstração desse teorema pode ser encontrada em (MARTINEZ; SALDANHA;

TENGAN, 2011)

2.2.2 Novo teorema sobre a distribuição dos números primos

Tivemos, recentemente, grandes avanços em relação à distância entre dois números pri-

mos. Os maiores responsáveis por esses avanços foram: Yitang Zhang e James Maynard.

Yitang Zhang

Yitang Zhang, nasceu em Xangai, China e desde muito novo já dava sinais de suas ha-

bilidades com a Matemática. Mesmo tendo sido forçado a parar de frenquentar uma escola,

devido a Revolução Cultural antiintelectual, Zhang nunca parou seus estudos e aos 23 anos in-

gressou na Universidade de Pequim, fez mestrado e aos 29 anos fez seu doutorado na Purdue

University em Lafayette, Indiana. Após seu doutorado, Zhang trabalhou por cerca de sete anos

com empregos temporários. Apenas aos 44 anos, Zhang conseguiu um emprego como profes-

sor de Matemática e dez anos depois, em 2009, começou estudar mais de perto a conjectura

dos primos gêmeos. O trabalho de Zhang foi tentar provar que os números primos não ﬁcam

inﬁnitamente distantes uns dos outros. Em 2013, Zhang mostrou que existem inﬁnitos pares

de primos que estão a menos de 70 milhões de unidades uns dos outros. Zhang acredita que

consegue reduzir esse valor. Veja em (LIN, 2015)

O método utilizado por ele tem base no trabalho de Goldston, Pintz e Yıldırım sobre as

lacunas entre primos consecutivos e o teorema de Bombieri-Vinogradov.

Teorema 2.19 Seja H = {h1, h2, ..., hk0} um conjunto admissível de inteiros não negativos com
k0 ≥ 3, 5 × 106. Existem inﬁnitos inteiros positivos n tais que a k0-tupla

{n + h1, n + h2, ..., n + hk0}

contém pelo menos dois primos. Consequentemente, temos:

lim inf
n→∞

(pn+1 − pn) < 7 × 107.

A demonstração desse teorema pode ser encontrado em (ZHANG, 2014)

25

James Maynard James Maynard, de apenas 26 anos, começava seus estudos sobre as

lacunas entre os números primos ao mesmo tempo que Yitang Zhang apresentava sua desco-

berta. Maynard deu sequência em seus estudos e poucos meses depois de Zhang conseguiu

provar, com uma abordagem completamente independente, que existem inﬁnitos pares de pri-

mos a uma distância menor do que 600 unidades. Maynard ainda foi além, sua abordagem se

aplicava para triplos, quádruplos e outras coleções maiores, mudando apenas o limite de cada

uma. Veja (KLARREICH, 2020).

Teorema 2.20 Seja pi o i-ésimo número primo, temos que

lim inf
n

(pn+1 − pn) < 600.

Para a demonstração desse teorema, Maynard utiliza apenas o teorema de Bombieri-Vinogradov.

Ver (MAYNARD, 2019).

2.3 PRIMOS ESPECIAIS

Mostraremos, nesta seção, alguns números primos especiais. São eles: primos de Fer-

mat, Mersenne, Sophie Germain e primos gêmeos.

Para as demonstrações de alguns resultados desses números primos devemos relembrar

algumas proposições sobre divisibilidade.

Proposição 2.21 Sejam a, b ∈ Z e n ∈ N. Temos que a − b divide an − bn.

Demonstração: A prova será feita por indução sobre n.

Para n = 1, a aﬁrmação é verdadeira, pois a − b divide a1 − b1 = a − b.

Suponhamos que a − b|an − bn. Assim,

an+1 − bn+1 = a.an − b.bn = a.an − b.an + b.an − b.bn = (a − b).an + (an − bn).b

Como a − b|a − b e, por hipótese, a − b|an − bn, temos que:

a − b|(a − b).an e a − b|(an − bn).b

Assim, a − b|an+1 − bn+1. Portanto, o resultado é valido para todo n ∈ N.

(cid:4)

26

Proposição 2.22 Sejam a, b ∈ Z e n ∈ N ∪ {0}. Temos que a + b divide a2n+1 + b2n+1.

Demonstração: Esta demonstração também será feita por indução em n.

Claramente, temos que a aﬁrmação é válida para n = 0, pois a + b divide a1 + b1 = a + b.

Suponhamos que a + b|a2n+1 + b2n+1. Assim

a2(n+1)+1 + b2(n+1)+1 = a2a2n+1 − b2a2n+1 + b2a2n+1 + b2b2n+1

= (a2 − b2)a2n+1 + b2(a2n+1 + b2n+1).

Como a + b divide a2 − b2 = (a + b).(a − b) e , por hipótese, a + b|a2n+1 + b2n+1, temos que

a + b|a2(n+1)+1 + b2(n+1)+1.

Portanto, o resultado é válido para todo n ∈ N ∪ 0.

(cid:4)

2.3.1 Primos de Fermat

Pierre de Fermat nasceu em 1601, na França, e morreu em 1665. Foi advogado e oﬁcial

do governo em Toulouse. Apesar de não ter a Matemática como sua principal atividade e não

ter tido interesse em publicar suas descobertas, Fermat é lembrado por seu legado incrível. Uma

de suas contribuições, da qual falaremos agora, ﬁcou conhecida como Números de Fermat.

Vejamos a seguinte proposição:

Proposição 2.23 Sejam a e n números naturais maiores do que 1. Se an + 1 é primo, então a é
par e n = 2m, com m ∈ N.

Demonstração: Suponhamos que an + 1 seja primo, com a, n > 1. Assim, temos que a

é par, pois caso contrário, an + 1 seria par maior que 2 contrariando o fato de ser primo. Se n
tivesse um divisor primo p diferente de 2, teríamos n = n1 p com n1 ∈ N. Pela Proposição 2.22,
an1 + 1 dividiria (an1)p + 1 = an + 1. Mas isso contraria o fato de an + 1 ser primo. Implicando
assim que n é da forma 2m.

(cid:4)

27

Os números conhecidos como números de Fermat são da forma

Fn = 22n

+ 1,

n = 0, 1, 2, ...

Os números de Fermat que são primos receberam o nome de Primos de Fermat.

Curiosidade: O maior número de Fermat para o qual se conhece um fator é F(23471) :
2223471 + 1; o fator é 5.223473 + 1. Esse também é o maior número de Fermat composto que se

sabe.

Outra grande contribuição de Fermat, denominada Último Teorema de Fermat, será vista

na próxima seção com os primos de Sophie German.

2.3.2 Primos de Sophie Germain

Sophie Germain, nasceu em Paris, França, no ano de 1776. Quando tinha 13 anos de

idade, teve início a Revolução Francesa, o que tornou necessário sua permanência em casa e

assim desencadeou seu interesse pelos estudos. Seu interesse pela Matemática surgiu após ler

sobre a história do assassinato de Arquimedes por um soldado. O assassinato ocorreu pelo fato

de Arquimedes estar mais preocupado com seus estudos em Geometria do que com o ataque.

Mas, como podemos imaginar, não foi fácil para Sophie German, uma mulher, estudar

assuntos cientíﬁcos mais aprofundados naquela época. Inicialmente, seus pais a proibiram de

estudar e as instituições não aceitavam mulheres. Sophie persistiu e obteve aceitação dos pais e

usou um pseudônimo masculino em seus trabalhos e comunicações com outros matemáticos.

Para conhecer mais sobre Sophie German, veja (WIKIPéDIA, 2020c).

Sophie Germain mostrou um caso particular do último teorema de Fermat que aﬁrmava:

xn + yn = zn , era válido apenas para n = 2,

sendo x, y, z ∈ Z e n ∈ N.

Sophie Germain provou que a aﬁrmação de Fermat estava correta para n = p, quando

p e 2p + 1 são números primos. Devido à essa prova, os números primos p tais que 2p + 1

também são primos, são conhecidos como primos de Sophie Germain. Como exemplos temos

o 3 e 7, 5 e 11 e vários outros.

Proposição 2.24 Se p e 2p + 1 são primos com p > 2, então não existem inteiros x, y, z com
mdc(x, y, z) = 1 e p (cid:45) xyz tais que xp + yp + zp = 0.

28

Demonstração: Demonstraremos esse resultado por contradição. Suponha que existam

x, y, e z com mdc(x, y, z) = 1 e p (cid:45) xyz tais que xp + yp + zp = 0.

Aﬁrmação 1: 2p + 1|xyz, caso contrário o pequeno teorema de Fermat implicaria que

x2p ≡ 1 mod(2p + 1). Logo x2p − 1 ≡ 0 mod(2p + 1). O que equivale a (xp − 1)(xp + 1) ≡

0 mod(2p+1). Como 2p+1 é primo, temos que xp ≡ 1 mod(2p+1) ou xp ≡ −1 mod(2p+1),

isto é, xp ≡ ±1 mod(2p + 1). Com raciocínio análogo ao caso anterior, concluímos que yp ≡

±1 mod(2p + 1) e zp ≡ ±1 mod(2p + 1). Independente de qual caso ocorra, temos que

xp + yp + zp ≡ ±1 ± 1 ± 1 (cid:54)≡ 0 mod(2p + 1),

o que é um absurdo. Portanto,2p + 1|xyz.

Do fato de p > 2 ser primo e xp + yp + zp = 0, temos

(−x)p = yp + zp

(−x)p = (y + z).(yp−1 − yp−2z + ... − yzp−2 + zp−1).

Aﬁrmação 2: os fatores do lado direito da igualdade (y + z) e (yp−1 − yp−2z + ... −

yzp−2 + zp−1) são primos entre si.

Suponha que q seja um primo que divide ambos os termos então q|x e

y + z ≡ 0 mod q

y ≡ −z mod q

(2.1)

e

yp−1 − yp−2z + ... − yzp−2 + zp−1 ≡ 0 mod q

usando a congruência 2.1, temos que

yp−1 − yp−2z + ... − yzp−2 + zp−1 ≡ pyp−1 mod q.

Como q|x e p (cid:45) xyz então p (cid:54)= q. Dos fatos que q|x , q|pyp−1 e p (cid:54)= q, segue que q|y.

Se isso ocorrer z ≡ −y ≡ 0 mod q. Desse modo, q|x, q|y e q|z, um absurdo. Pois

mdc(x, y, z) = 1.

Assim, pelo teorema da fatoração única em primos, existem inteiros a e d tais que

ap = y + z

d p = yp−1 − yp−2z + ... − yzp−2 + zp−1

29

(2.2)

(2.3)

Aplicando o raciocínio anterior para (−y)p = xp + zp e (−z)p = xp + yp, concluímos que

existem inteiros b, c, e e f , tais que

bp = x + z

ep = xp−1 − xp−2z + ... − xzp−2 + zp−1

cp = x + y

f p = xp−1 − xp−2y + ... − xyp−2 + yp−1

(2.4)

(2.5)

(2.6)

(2.7)

Como 2p + 1|xyz, podemos supor, sem perda de generalidade, que 2p + 1|x. Somando

as equações 2.4 e 2.6 obtemos

bp + cp = 2x + y + z

2x = bp + cp − (z + y)

Utilizando a equação 2.2, concluímos que

2x = bp + cp − ap

Do fato que p > 2, 2p + 1 é primo e 2p + 1|x, temos que 2p + 1|bp + cp − ap.

Utilizando a aﬁrmação 2 e os argumentos da demonstração da aﬁrmação 1, concluímos

que 2p + 1|abc.

Para terminar a demonstração dividiremo-na em dois casos.

30

Caso 1:

2p + 1|bp = x + z ou 2p + 1|cp = x + y. Do fato que 2p + 1|x e 2p + 1|xp + yp + zp = 0,

obtemos que 2p + 1|mdc(x, y, z) = 1, o que é um absurdo.

Caso 2:

2p + 1|ap Como 2p + 1|x e f p = xp−1 − xp−2y + ... − xyp−2 + yp−1, temos que f p ≡

yp−1 mod(2p + 1).

Sabemos que 2p + 1|ap e 2p + 1 é primo. Logo, 2p + 1|a. Desse último fato e da

aﬁrmação 2, concluímos que 2p + 1 (cid:45) d.

Já que 2p + 1|a e ap = y + z obtemos

y ≡ −z mod(2p + 1)

(2.8)

Da congruência 2.8 e da equação 2.3, concluímos

d p ≡ pyp−1 mod(2p + 1).

Assim, 2p + 1| f , caso contrário, teríamos

±p ≡ p f p ≡ pyp−1 ≡ d p ≡ ±1 mod(2p + 1),

o que é um absurdo.

Como 2p + 1| f e 2p + 1|x, da equação 2.7, concluímos que 2p + 1|y. Como y ≡

−z mod(2p + 1) segue que 2p + 1|z. Novamente 2p + 1|x, 2p + 1|y e 2p + 1|z, o que é im-

possível já que mdc(x, y, z) = 1.

(cid:4)

Curiosidade: o teorema de Fermat surgiu a partir do estudo do teorema de Pitágoras.

Fermat queria saber se para outras potências o teorema também estava correto. Infelizmente,

Fermat faleceu achando que o teorema era válido apenas para n = 2. Veja mais em (WIKIPé-

DIA, 2020b).

2.3.3 Primos de Mersenne

Marin Mersenne nasceu em uma família da classe trabalhadora, em 8 de setembro de

1588, na França. Aos dezesseis anos, Mersenne foi estudar na recém-criada Escola Jesuíta em

31

La Flèche, que havia sido criada como uma escola modelo para beneﬁciar todas as crianças,

independentemente da condição ﬁnanceira de seus pais. Ao contrário do desejo de seu pai,

que queira que Mersenne seguisse carreira na igreja, ele foi para Paris dar sequência em seus

estudos.

“Mersenne estava começando a perceber que, ao lado da religião, era a ciência que real-

mente o interessava. Matemática foi a área que estudou com maior profundidade, acreditando

que sem ela nenhuma ciência seria possível. Ele sempre teve uma abordagem ﬁlosóﬁca da ma-

temática e acreditava que a causa das ciências é a causa de Deus”. Veja (O’CONNOR,J.J. AND

ROBERTSON, E.F., 1996).

Curiosidade: Dentre seus muitos interesses, a música foi um deles. Passou um bom

tempo estudando sobre a velocidade e a acústica do som. Mersenne (1627) publicou uma obra

na qual falava das leis relativas à corda vibrante, dizendo que sua frequência é proporcional

à raiz quadrada da tensão e inversamente proporcional ao comprimento, ao diâmetro e à raiz

quadrada do peso especíﬁco da string, de forma que quando uma dessas condições for alterada,

todas as outras permaneçam as mesmas.

Mersenne é muito lembrado pelos famosos Números de Mersenne, aqueles que têm a

forma 2n − 1, para algum inteiro n. Sendo que os maiores primos conhecidos que se tenha relato
são todos da forma: Mn = 2n −1, para n = 43112609, 42643801, 37156667, 32582657, 30402457,

25964951, 24036583, 20996011, 134669717.

Inicialmente, acreditava-se que para todo p primo, os números de Mersenne fossem

primos. No entanto vários matemáticos como Hudalricus Regius (1536), Pietro Cataldi (1603),

Fermat (1640), Euler (1738), Lucas (1876) refutaram essa informação. Apenas em 1947 foi

feita uma lista com os números até 257 que tornam os números de Mersenne primos, são eles:

n = 2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107 e 127.

Desde 1951, são usados computadores para procurarem números primos grandes e os

valores de n para os quais Mn é primo são:

521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 232009,

44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221,

3021377, 6972593, 13466917, 20996011,24036583, 25964951, 30402457, 32582657,

37156667, 42643801 e 43112609.

32

Curiosidade: Os últimos dez números foram encontrados com a ajuda de computadores

pessoais. Hoje ainda é possível participar dessa busca através do site: www.mersenne.org .

Vimos que nem todos os números de Mersenne, Mn = 2n − 1, são primos. Agora, vere-

mos que os números de Mersenne só tem chance de serem primos quando n é primo.

Proposição 2.25 Sejam a e n números naturais maiores do que 1. Se an − 1 é primo, então

a = 2 e n é primo.

Demonstração: Admitiremos que an − 1 é um número primo, com a, n > 1.

Suponhamos, por absurdo, que a > 2. Assim, a Proposição 2.21 implica que a − 1 > 1

e (a − 1)|(an − 1). Absurdo, pois contraria o fato de an − 1 ser primo.

De forma análoga, podemos supor, por absurdo, que n não é primo. Temos que n = rs

com r, s > 1. Como 2r − 1 divide (2r)s − 1 = 2n − 1, novamente, a Proposição 2.21 implica que

an − 1 não é primo, absurdo. Logo, n é primo.

(cid:4)

Dado um número natural n qualquer é difícil determinar se n é primo ou não. Já para

os números de Mersenne, temos métodos muito eﬁcazes para dizer se esse número é primo ou

não. Por esse motivo, o maior número primo conhecido sempre é um de primo de Mersenne.

Na seção Teste de Primalidade apresentaremos um algoritmo que fatora primos de Mersenne

em tempo polinomial.

2.3.4 Primos gêmeos

Deﬁnição 2.26 Dois números primos p e q, com p > q, são chamados de números primos

gêmeos se p = q + 2.

Em outras palavras, o par de números primos da forma p e p + 2, são chamados primos

gêmeos.

Alguns exemplos de primos gêmeos são 3 e 5, 11 e 13, 149 e 151, 191 e 193, 239 e

241. Mas a medida que os números aumentam ﬁca mais difícil identiﬁcá-los. O maior par de

números gêmeos conhecido até o momento é:

2.003.663.613 × 2195.00 − 1, 2.003.663.613 × 2195.00 + 1.

33

Assim como havia a grande curiosidade de saber se existiam inﬁnitos números primos,

também há a curiosidade de saber se os primos gêmeos são inﬁnitos. Será que existem inﬁnitos

pares de números da forma (p, p + 2)?

Essa pergunta é uma famosa conjectura dos números primos gêmeos e será trabalhada

na seção Problemas em aberto.

Teorema 2.27 Sejam p e p + 2 primos gêmeos. Então,

∑
p,p+2primos

1
p

< ∞

Brun mostrou que ∑p,p+2primos

1
p

tante de Brun.

< ∞ converge para 1,9021605824283 , chamada cons-

B =

(cid:19)

(cid:18)1
3

+

1
5

+

(cid:19)

(cid:18)1
5

+

1
7

+

(cid:19)

(cid:18)1
7

+

1
9

+ ... +

(cid:19)

(cid:18) 1
p

+

1
p + 2

= 1, 9021605824283.

Devido ao fato da soma de seus inversos ser convergente, acredita-se que há um quan-

tidade ﬁnita de primos gêmeos. Ao contrário da soma dos inversos dos números primos que,

como vimos anteriormente na demonstração de Euler, diverge. Veja em (WIKIPéDIA, 2016).

2.4 TESTE DE PRIMALIDADE

Assim como ter funções que geram números primos é algo relevante e importante para a

Matemática, testar se um determinado número é primo também é. Os números primos são estu-

dados pelos matemáticos desde a antiguidade. Além da relevância na Matemática, os números

primos se mostraram de grande importância na Ciência da Computação nas últimas décadas.

Na criptograﬁa RSA, precisamos usar números primos grandes. Com isso, é importante termos

algoritmos que digam se um determinado número é primo ou não.

Veremos nesse capítulo alguns testes de primalidade, testes que aﬁrmam se um determi-

nado número inteiro é primo ou não. Esses testes são divididos em dois tipos: determinísticos e

não determinísticos. Como estamos interessados nos algoritmos do ponto de vista matemático

e computacional, comentaremos se ele é eﬁciente ou não, mas não aprofundaremos muito nos

cálculos para justiﬁcar a eﬁciência.

34

As deﬁnições e teoremas referentes à parte de congruência que serão apresentadas de

agora em diante podem ser encontradas no apêndice Congruências.

2.4.1 Custo de um algoritmo

O custo de um algoritmo é o tempo que se gasta para executá-lo. Para calcular o custo

dos algoritmos nessa dissertação levaremos em conta a quantidade de operações elementares

necessárias para executá-lo. Sempre que falamos em algoritmo, nossa intenção é implementá-

lo em um computador. Logo, assumiremos que os números estão escritos na base 2, ou seja, são

binários. Cada algarismo de um número nessa base é chamado de bit. Note que os possíveis

valores para um bit é 0 ou 1. Iremos analisar duas operações especíﬁcas: adição e multiplicação.

Adição

Sejam a = (ak−1, ..., a1, a0)2 e b = (bk−1, ..., b1, b0)2 as representações binárias dos in-

teiros a e b. Assim cada ai e cada bi é 0 ou 1 e

a = ak−12k−1 + ... + a12 + a0

e
b = bk−12k−1 + ... + b12 + b0.

Para efetuarmos a soma, procedemos da maneira usual, começando por a0 + b0. Essa

soma pode resultar em 0, 1 ou 2, sendo que, quando resultar em 2, devemos colocar o resultado

sendo 0 e acrescentar 1 na próxima soma. Esse 1 que é acrescentado chama-se reserva. A

próxima soma deve ser de a1 +b1 ou a1 +b1 +1, dependendo da reserva que tivermos. Devemos

proceder de forma análoga para as demais somas. Observe que, para cada reserva igual 1,

aumentamos uma operação de adição. Desta forma, não conseguimos prever quantas operações

faremos na adição, mas sabemos que o máximo de operações será 2k.

Multiplicação

Usando os mesmos a e b, precisamos primeiro multiplicar b por cada bit de a e em

seguida somar os resultados. Assim como na adição, na multiplicação também pode haver

reservas. Teremos então k produtos e no máximo k − 1 reservas, assim, o máximo de operações

seria 2k − 1. Portanto, para calcular o produto de b por cada bit a, teremos, no máximo, k.(2k −

1) operações. Resta agora somarmos esses produtos, ou seja, se

bai = (ci,k+1, ..., ci,1, ci,0)2

35

então podemos escrever a soma da seguinte maneira:

c0,k+1

. . .

c0,1 c0,0

c1,k+1

. . .
...
ck,0

c2,k+1
...
. . .

. . .

c2,1
...

ck,k+1

c1,1 c1,0

c2,0

Sabemos que número máximo de soma em cada grandeza é de 2k e, como temos k

grandezas, o custo dessas somas não excederá 2k2. Assim, a multiplicação terá k.(2k − 1) +

2k2 = 4k2 − k operações.

Segundo (COUTINHO, 2004), a prática corrente é se concentrar na maior potência de

k que aparece na expressão. Usaremos a notação O para determinar o custo de um algoritmo.
Sejam f e g duas funções cujo domínio é N ou R e o contradomínio é R. Dizemos que f (x) é

O(g(x)) se existirem constantes C1 e C2, tais que f (x) ≤ C1g(x) quando x > C2. Por exemplo,
seja f (x) um polinômio de grau n com coeﬁcientes reais. Então, f (x) é O(xn). Assim, a soma

de dois números de k bits tem custo O(k) e a multiplicação tem custo O(k2). Como um inteiro

positivo n tem, aproximadamente, log2 n bits, podemos calcular o custo da soma de dois inteiros
menores ou iguais a n como O(log2 n) e a multiplicação com custo O((log2 n)2).

Dizemos que um algoritmo é polinomial se o número de operações que ele executa
é O((log2 n)r), para algum r > 0. E o algoritmo é exponencial se o número de operações é
da ordem O(2log2 n) ou maior. Algoritmos polinomiais são considerados eﬁcientes, pois são

rápidos; já os exponenciais são lentos, sendo então considerados ineﬁcientes.

2.4.2 Testes determinísticos

O primeiro tipo de testes que estudaremos será o determinístico. São chamados assim

por se tratarem de testes cujo resultado nos diz se um número é primo ou composto com a

garantia de que a resposta está correta. A seguir, apresentaremos alguns deles.

2.4.2.1 Crivo de Erastótenes

Com certeza você já deve ter ouvido sobre o Crivo de Erastótenes. Esse foi o primeiro

método para encontrar números primos em um determinado intervalo e/ou veriﬁcar se um nú-

mero é primo ou composto.

Como o Crivo de Erastótenes funciona?

Vejamos um exemplo prático: se quisermos encontrar todos os números primos menores

do que 40 devemos, primeiramente, escrever todos os números de 2 a 40.

36

2
10
18
26
34

3
11
19
27
35

4
12
20
28
36

5
13
21
29
37

6
14
22
30
38

7
15
23
31
39

8
16
24
32
40

9
17
25
33

Em seguida, devemos eliminar todos os múltiplos de 2, exceto ele mesmo.

Tabela 2.1 – Eliminação dos múltiplos de 2

2

3
11
19
27
35

9
17
25
33

5
13
21
29
37

7
15
23
31
39

Agora, devemos eliminar os múltiplos de 3 e em seguida os múltiplos de 5.

Tabela 2.2 – Eliminação dos múltiplos de 3

2

3
11
19

35

17
25

5
13

29
37

7

23
31

Tabela 2.3 – Eliminação dos múltiplos de 5

2

3
11
19

17

7

23
31

5
13

29
37

Pela lógica, neste momento, eliminaríamos os múltiplos de 7, mas como podemos ver

nenhum dos números restantes é múltiplo de 7. O mesmo ocorre para os outros valores que

ainda estão na Tabela 2.3.

37

Portanto, os números que aparecem na Tabela 2.3 são considerados primos e os que

foram eliminados são considerados compostos.

E como proceder se quisermos determinar se um dado número é primo? Vejamos o

seguinte teorema:

Teorema 2.28 Se n não é primo, então n possui um fator primo menor ou igual a

√

n.

Demonstração: Seja n um número composto, tal que n = a.b, a, b ∈ N, com 1 < a ≤

b < n. Suponhamos por absurdo que

√
n

a >

e

b >

√

n.

Assim,

absurdo.

n = a.b >

√

√

n.

n = n,

Portanto, pelo menos um fator de n deve ser menor que

√

n. E pelo Teorema 2.6, esse

fator pode ser decomposto em um produto de números primos, todos menores ou iguais a

√

n.

(cid:4)

Pelo teorema anterior, concluímos que, para saber se um número n é primo, devemos

calcular o resto da divisão de n por cada número primo m com 2 ≤ m ≤

√

n. Se algum dos

restos for 0 então n é composto, caso contrário, n é primo. Vejamos alguns exemplos:

Exemplo 2.29 57 é um número primo?

Primeiramente, calculamos o maior inteiro menor que

√

57, ou seja, N <

√

57 = 7, 549....

Assim basta veriﬁcarmos se 57 é divisível pelos números primos menores ou iguais a 7. Facil-

mente, veriﬁcamos que 57 é divisível por 3. Portanto, 57 é um número composto.

Exemplo 2.30 149 é um número primo?

Devemos veriﬁcar se 149 é divisível por algum primo menor que

√

149, ou seja, se 149 é

divisível por 2, 3, 5, 7 ou 11. Simples divisões nos mostram que 149 não é divisível por nenhum

desses números primos. Portanto 149 é um número primo!

O Crivo de Erastótenes nos garante com certeza tanto se um número é primo quanto se

é composto. O inconveniente desse método é que, para um número grande, ele necessita que

38

muitas operações sejam executadas, apresentando um custo exponencial. Computacionalmente

falando, para um número com duzentos algarismos, teríamos que fazer em torno de 10100 di-

visões. Se considerarmos que, para realizar cada operação de divisão o computador leva um

segundo, o tempo para determinar se um número com 200 algarismo é primo poderia chegar a

ordem de 1092 anos. O que torna inviável o uso desse algoritmo.

2.4.2.2 Teorema de Wilson

Enunciaremos e demonstraremos um teorema que foi atribuído a Wilson (1741 - 1793),

mas que anteriormente também foi provado por Lagrange (1736 - 1813). Esse teorema, co-

nhecido como Teorema de Wilson, nos dá um critério de primalidade. Para números primos

pequenos, esse critério é muito útil. Infelizmente, para primos maiores, não é eﬁciente.

Proposição 2.31 Sejam a, m ∈ Z, com m > 1. A congruência aX ≡ 1 mod m possui solução
se, e somente se, (a, m) = 1. Além disso, se x0 ∈ Z é um solução, então x é uma solução da

congruência se, e somente se, x ≡ x0 mod m.

A demonstração dessa proposição pode ser encontrada em (HEFEZ, 2016), página 194.

Teorema 2.32 Um número p é primo se, e somente se, (p − 1)! ≡ −1 mod p.

Demonstração: (⇒) Para p = 2 e p = 3, o resultado segue de imediato. Suponhamos

p ≥ 5 primo. Para todo i ∈ {1, ..., p − 1}, segue da Proposição 8 do apêndice Congruências que

a congruência iX ≡ 1 mod p possui uma única solução módulo p. Assim, dado i ∈ {1, ..., p − 1},

existe um único j ∈ {1, ..., p − 1} tal que i j ≡ 1 mod p. Por outro lado, se i ∈ {1, ..., p − 1} é tal

que i2 ≡ 1 mod p, então p|i2 − 1, ou seja, p|i − 1 ou p|i + 1, o que só pode ocorrer se i = 1 ou

i = p − 1. Logo,

e, portanto,

2...(p − 2) ≡ 1 mod p,

1.2...(p − 2).(p − 1) ≡ p − 1 ≡ −1 mod p.

(⇐) Suponhamos que (p − 1)! ≡ −1 mod p, ou seja, p|((p − 1)! + 1). Queremos mostrar que

p é um número primo. Suponhamos que p = a.b, com a (cid:54)= p. Assim, a|((p − 1)! + 1). Como

a é um dos fatores de (p − 1)!, temos que a|(p − 1)! e consequentemente a|1, ou seja, a = 1.

Implicando assim que p é um número primo.

39

2.4.2.3 Teste de Lucas

Édouard Lucas, matemático francês, muito conhecido por suas recreações matemáticas,

como por exemplo a famosa Torre de Hanói, também contribuiu com muitos resultados da teoria

dos números. Uma de suas contribuições foi o teste de primalidade conhecido como Teste de Lu-

cas que nos aﬁrma com certeza se um número é primo. Saiba mais em: https://mathshistory.st-

andrews.ac.uk/Biographies/Lucas/

Além da congruência, ele utiliza a função φ (n) para determinar se n é um número primo.

O teste parte da ideia de que se φ (n) = n − 1, então n é primo. Essa ideia vem do fato que se

existem n − 1 números menores do que n cujo máximo divisor comum entre cada um desses

números com n é igual a 1, então n é primo.

Teste de Lucas: Seja n ∈ N um número ímpar e 2 ≤ b ≤ n − 1 um inteiro. Temos que n

será um número primo se

bn−1 ≡ 1 mod n

e

n−1
p

b

(cid:54)≡ 1 mod n

(2.9)

(2.10)

para todos fatores primos p de n − 1.

O Teste de Lucas não apresenta uma maneira de escolhermos a base b. Caso não obte-

nhamos um resultado satisfatório com a base escolhida, devemos mudá-la e repetir o teste.

Devemos estar atentos a aﬁrmação do teste. Ele nos diz que se as condições anteriores

forem satisfeitas, n é um número primo. No entanto, nada podemos aﬁrmar se as condições não

forem satisfeitas.

Exemplo 2.33 1031 é um número primo?

Primeiramente devemos escolher a base, b = 2. Em seguida, encontrarmos os fatores

primos de 1031 − 1 = 1030 = 2.5.103.

Restando apenas testar as congruências.

21030 ≡ 1 mod 1031

21030/2 (cid:54)≡ 1 mod 1031

21030/5 (cid:54)≡ 1 mod 1031

40

21030/103 (cid:54)≡ 1 mod 1031

A primeira congruência satisfaz a condição (2.9) e as outras três satisfazem a condição

(2.10).

Portanto, podemos aﬁrmar com certeza que 1031 é um número primo.

Exemplo 2.34 143 é um número primo?

Escolhendo a base, b = 2, vamos encontrar os fatores primos de 143 − 1 = 142 = 2.71.

Restando apenas testar as congruências.

2142 ≡ 114 mod 143

2142/2 (cid:54)≡ 1 mod 143

2142/71 (cid:54)≡ 1 mod 143

As duas últimas congruências satisfazem as condições do teste, mas a primeira, não.

Desta forma o teste ﬁca inconclusivo. Nossa única conclusão é que o número 143 pode ser

composto ou que escolhemos uma base que não foi satisfatória.

Ao analisarmos a congruência (2.10), percebemos que ela deve ser veriﬁcada para todos

os fatores primos de n − 1, em outras palavras, devemos fatorar n − 1. No último exemplo que

demos, é fácil fatorar 142, mas quando se trata de números grandes, essa fatoração se torna

inviável. E piora ainda mais se tivermos que trocar a base e refazer o teste.

2.4.2.4 Teste Lucas-Lehmer

Apresentaremos agora um teste que auxilia na descoberta dos primos de Mersenne, o

Teste de Lucas-Lehmer. Esse teste possui um algoritmo de fácil execução e custo polinomial e

graças a ele os maiores primos conhecidos são os de Mersenne. Este teste foi desenvolvido por

Lucas (1876) e posteriormente melhorado por Derrick Henry Lehmer (1930).

Teorema 2.35 (Teste de Lucas-Lehmer) Para todo número natural n, o número de Mersenne,
Mn = 2n − 1 é primo se, e somente se, Sn−2 ≡ 0 mod Mn, sendo Sn = S2

n−1 − 2 e S0 = 4.

Na seção sobre os primos de Mersenne, vimos que nem todos os números de Mersenne

são primos. Vejamos alguns exemplos usando o Teste de Lucas-Lehmer.

Exemplo 2.36 M5 = 31 é um número primo?

Devemos veriﬁcar se S3 ≡ 0 mod 31. Sabemos que S0 = 4, assim

41

S1 = 42 − 2 = 14,

S2 = 142 − 2 = 194 ≡ 8 mod 31;

S3 ≡ 82 − 2 = 64 ≡ 0 mod 31.

Portanto, pelo Teste de Lucas-Lehmer, o número de Mersenne, M5, é um número primo.

Exemplo 2.37 M11 = 2047 é um número primo?

Levando em consideração a Proposição 2.3.3, como 11 é um número primo, M11 é um

forte candidato a ser primo também. Precisamos veriﬁcar se S9 ≡ 0 mod 2047. Usando o

mesmo raciocínio do exemplo anterior e S0 = 4, temos:

S1 = 42 − 2 = 14,

S2 = 142 − 2 = 194;

S3 = 1942 − 2 ≡ 788 mod 2047.

S4 ≡ 7882 − 2 ≡ 701 mod 2047.

S5 ≡ 7012 − 2 ≡ 119 mod 2047.

S6 ≡ 1192 − 2 ≡ 1877 mod 2047.

S7 ≡ 18772 − 2 ≡ 240 mod 2047.

S8 ≡ 2402 − 2 ≡ 282 mod 2047.

S9 ≡ 2822 − 2 ≡ 1736 mod 2047.

Como a última congruência não satisfaz o Teste de Lucas-Lehmer, concluímos que M11

não é um número primo.

42

2.4.2.5 Fatoração de Fermat

Sabemos, pelo Teorema 2.6, que todo número composto pode ser fatorado, mas nem

sempre essa fatoração é simples e viável. Ela só é eﬁciente quando estamos trabalhando com

números pequenos. Veremos agora a Fatoração de Fermat, um algoritmo que, segundo (COU-

TINHO, 2009) é muito eﬁciente quando o número n tem um fator primo próximo de

√

n.

Todo número inteiro ímpar n pode ser escrito como a diferença do quadrado de dois

números, ou seja, n = 2k + 1 = (k + 1)2 − k2. Deste modo, o algoritmo consiste em achar

números inteiros positivos x e y tais que

n = x2 − y2 = (x + y).(x − y),

desta forma (x + y) e (x − y) são os fatores de n.

Mas como encontrar esses inteiros x e y?

Encontraremos o valor inicial de x, que será o maior inteiro menor que

√

n. Note que

√

n for um número inteiro, então teremos x =

√

n e y = 0. Sendo assim, n é um número

se

composto e a fatoração está feita. Caso contrário, devemos incrementar x de um em um e

calcular y =

x2 − n até que y seja um número inteiro ou x =

√

n + 1
2

. Se ocorrer o primeiro

caso, n é composto. Do contrário, n é primo. Vejamos agora dois exemplos para facilitar a

compreensão da Fatoração de Fermat.

Exemplo 2.38 259 é um número primo ou composto?

Primeiro veriﬁcamos se 259 é um quadrado perfeito. Como

√

259 é aproximadamente

16,09, concluímos 259 não é um quadrado perfeito. Temos que o valor de x é inicialmente igual

ao menor inteiro maior que

259, assim x = 17. Em seguida devemos calcular o valor de y.

√

Repetiremos esse passo até que y seja um número inteiro ou x =

n + 1
2

.

Veja a seguinte tabela:

x
17
19
20
21
22

y
5,47
10,09
11,87
13,49
15

Assim, 259 = (22 + 15) · (22 − 15) = 37 · 7. Portando 259 é um número composto.

Exemplo 2.39 41 é um número primo?

Inicialmente temos x = 6. Novamente, como

√

41 não é um número exato, devemos

adicionar 1 ao x e calcular o valor de y. Veja a tabela:

43

x
7
8
9
10
...
20
21

y
1,41
4,12
5,83
7,68
...
18,94
20

Logo, 41 = (21 + 20) · (21 − 20) = 41 · 1. Portanto, 41 é um número primo.

Observe que 41 é um número pequeno e mesmo assim precisamos de 15 passos para

efetuar a fatoração de Fermat.

Isso nos mostra que, apesar da fatoração sempre funcionar,

ela possui um custo exponencial. De acordo com o que vimos, a Fatoração de Fermat não

é eﬁciente. Porém, quando n possui dois fatores próximos, esse algoritmo é eﬁciente para

encontrá-los. Para descobrir porque o algoritmo funciona, veja capítulo 2, seção 5 de referência

(COUTINHO, 2004).

2.4.2.6 AKS

Veremos agora uma das grandes conquistas na parte de testes de primalidade, o Teste

AKS. Trata-se de um teste determinístico e ao mesmo tempo tem custo polinomial. Foi criado

e publicado por Manindra Agrawal, Neeraj Kayal e Nitin Saxena, cientistas indianos. Veja a

publicação em (AGRAWAL; KAYAL; SAXENA, 2004).

Assim como vários testes apresentados nessa dissertação, o Teste AKS também se baseia

no Pequeno Teorema de Fermat. Vejamos o fundamento matemático do AKS. Seja x uma

variável, a um inteiro e p um número primo. Pelo binômio de Newton temos que:

(x + a)p =

p
∑
j=0

(cid:18)p
j

(cid:19)

xp− ja j

mas, quando j é diferente de 1 e p, o coeﬁciente binomial (cid:0)p
j

(cid:1) é divisível por p, assim

(x + a)p ≡ xp + ap ≡ xp + a mod p

44

usando o Pequeno Teorema de Fermat para a última equivalência.

Reciprocamente, se

(x + a)N ≡ xN + a mod N

para todo a < N, então tomando a = 1, temos que N divide todos os coeﬁcientes binomiais (cid:0)N
j

(cid:1)

com 0 < j < N.

Suponhamos N composto e seja q um de seus fatores primos. Então

(cid:19)

(cid:18)N
q

=

N(N − 1)...(N − q + 1)
q(q − 1)...1

.

Nessa expressão temos que apenas N e q são divisíveis por q. Assim, se qk é a maior
(cid:1), o que é um absurdo. Portanto N é
(cid:1), logo N (cid:45) (cid:0)N
q

potência, de q, que divide N então qk (cid:45) (cid:0)N
q

primo.

Obtemos então, o seguinte critério de primalidade:

N é primo ⇔ (x + a)N ≡ xN + a (mod N), para todo a < N

⇔ (x + a)N ≡ xN + a (mod N), para algum a < N, com mdc(a, N) = 1.

Como podemos notar, este critério é ineﬁciente, pois devemos calcular todos os coeﬁci-

entes de (x + a)N e mostrar que os coeﬁcientes intermediários são divisíveis por N. No entanto,

se (x + a)N ≡ xN + a mod N, então eles deixam o mesmo resto módulo N quando divididos por

qualquer polinômio. Um caso particular seria pegar esse polinômio igual a xr − 1, assim

N é primo ⇒ (x + a)N ≡ xN + a (mod xr − 1, N), para todo a < N e r ∈ N.

O que os cientistas indianos mostraram foi que, para garantir que N seja primo, pre-

cisamos testar apenas se a congruência é válida para um valor especíﬁco de r, dependente

polinomialmente de log N, e alguns valores de a.

Deﬁnição 2.40 Se a, n ∈ Z com mdc(a, n) = 1, deﬁnimos a ordem de a módulo n como sendo o
menor l ∈ N∗ tal que al ≡ 1 mod n, denotamos l por ordna

Algoritmo AKS

O algoritmo AKS se divide em sete etapas:

1a etapa: Entrada N > 6.

2a etapa: Se N = ab, com b > 1, retorna COMPOSTO.

45

3a etapa: Encontrar o menor r tal que ordrN > 1
4a etapa: Se mdc(a, N) > 1 para algum primo a ≤ r, retorna COMPOSTO.

2(log2 N)2.

√

N < r, retorna PRIMO.

5a etapa: Se
6a etapa: Para a = 1 até (cid:98)(cid:112)φ (r)/2 log2 N(cid:99) faça
Se (x + a)N (cid:54)≡ xN + a (mod xr − 1, N), retorna COMPOSTO.

7o etapa: Retorna PRIMO.

Vejamos agora dois exemplo para o AKS.

Exemplo 2.41 213 é um número primo?

1a etapa: N = 213

2a etapa: 213 (cid:54)= ab.
3a etapa: Sendo l = ordr213, devemos encontrar o menor r tal que

213l ≡ 1 mod r, sendo l > 1

2(log2 213)2 ∼= 29, 96.

Temos que l = 31 e r = 3.

4a etapa: mdc(3, 213) = 3, retorna COMPOSTO.

Portanto, 213 é um número composto.

Exemplo 2.42 47 é um número primo?

1a etapa: N = 47.

2a etapa: 47 (cid:54)= ab.
3a etapa: Sendo l = ordr47, devemos encontrar o menor r tal que

47l ≡ 1 mod r, sendo l > 1

2(log2 47)2 ∼= 15, 43.

Temos que l = 18 e r = 5.

4a etapa: mdc(2, 47) = 1, mdc(3, 47) = 1 e mdc(5, 47) = 1.

√

47 ∼= 6, 8556 > 5, não podemos aﬁrmar nada.

5a etapa:
6a etapa: Primeiramente, devemos calcular (cid:98)(cid:112)φ (5)/2 log2 47(cid:99) = 7. Faça (x + a)47,
para todo 1 ≤ a ≤ 7, e veriﬁque se é congruente a (x47 + a) módulo (x5 − 1, 47). Temos que a

congruência é verdadeira para todo 1 ≤ a ≤ 7.

7a etapa: retorna PRIMO.

Portando, 47 é um número primo.

46

2.4.3 Testes não determinísticos

Veremos agora o segundo tipo de teste: não determinísticos. Segundo (COUTINHO,

2004), esses testes também nos diz se um determinado número é primo, mas dentro de uma

margem de erro. Vejamos alguns:

2.4.3.1 Teste de Leibniz

Leibniz, matemático alemão, foi quem deu o ponta pé inicial aos testes de primalidade.

Apesar de seu teste não estar totalmente correto, auxiliou para que muitos matemáticos tivessem

um ponto de partida e conseguissem aperfeiçoá-lo.

Leibniz tinha como base o Pequeno Teorema de Fermat. Ele acreditava que a recíproca

do teorema também era verdadeira, ou seja, se p|ap−1 − 1, sendo mdc(a, p) = 1, então p é

primo. Para facilitar os calculos, Leibiniz sempre utilizava a = 2.

Teste de Leibniz: Dado um número ímpar n ∈ N, se 2n−1 ≡ 1 mod n, então n é primo.

Leibniz não fez uma demonstração para essa sua suposição. Infelizmente, nem sempre

essa aﬁrmação está correta. O teste nos diz com certeza se um determinado número é com-

posto, mas quando o teste nos aﬁrma que n é primo, não é com certeza e sim com uma grande

possibilidade que seja.

Vejamos alguns exemplos:

Exemplo 2.43 131 é um número primo?

Usando o teste de Leibniz, temos que:

2130 ≡ 1 mod 131

Portanto, segundo o teste, 131 é um número primo.

Mas não podemos aﬁrmar, com certeza, que 131 é um número primo. Com o auxilio de

uma calculadora cientíﬁca conseguimos veriﬁcar que essa congruência está correta e que 131

realmente é um número primo.

Exemplo 2.44 561 é um número primo?

Usando o teste de Leibniz, encontramos a seguinte congruência:

2560 ≡ 1 mod 561

47

Portanto, segundo o teste, 561 é considerado um número primo.

Como 561 é um número pequeno, conseguimos fatorá-lo com facilidade e perceber que

561 = 3 · 11 · 17. Logo, 561 é um número composto.

Pelos exemplos anteriores conseguimos perceber que o Teste de Leibniz ora acerta, ora

erra. Vejamos mais um exemplo:

Exemplo 2.45 407 é um número primo?

Usando o teste de Leibniz, encontramos a seguinte congruência:

2406 ≡ 284 mod 407

Assim, como 2406 não é congruo a 1 mod 407, podemos aﬁrmar com certeza que 407 é

um número composto.

Vimos, com esse último exemplo, que a congruência não foi satisfeita, assim podemos

aﬁrmar com certeza que o número 407 é composto.

Curiosidade: Leibniz foi um grande contribuinte para o campo das calculadoras me-

cânicas. Foi ele quem adicionou a multiplicação, a divisão e a raiz quadrada na calculadora de

Pascal. Inventou uma Calculadora de Pisar, que usava uma engrenagem cilíndrica para pisar e

essa invenção acabou inﬂuenciando Thomas Arithmometer a criar a primeira calculadora me-

cânica produzida em grande escala. Leibniz também reﬁnou o sistema de números binários que

é a base de todos os computadores digitais. Veja em (WIKIPéDIA, 2020a).

2.4.3.2 Teste de Miller-Rabin

Gary L. Miller, atualmente, é professor de Ciência da Computação em Carnegie Mellon

University, nos Estados Unidos e ainda contribui muito com a área da computação. Michael

Rabin, conhecido por suas contribuições inovadoras na área da ciência da computação, traba-

lhou com criptograﬁa e números primos. Mas o que ressaltaremos aqui é a inﬂuência de ambos

no teste de primalidade conhecido como Teste Miller-Rabin.

Como dissemos anteriormente, o Teste de Leibniz serviu como base para que outros

matemáticos o aprimorassem e aumentassem sua precisão. Miller e Rabin foram dois deles.

O Teste de Miller-Rabin, possui algumas condições a serem veriﬁcadas. No entanto, se as

48

condições forem satisfeitas, há uma grande possibilidade do número ser primo, mas não uma

certeza.

Originalmente, o teste foi desenvolvido por Miller e era um teste determinístico. Porém,

esse teste era baseado na Hipótese de Riemann estendida que ainda não foi demonstrada. Foi

então que Rabin fez uma alteração no teste tornando-o não determinístico. Rabin demonstrou

que a probabilidade de erro a cada execução era de no máximo

1
4

, sendo que na média esse

número é bem menor.

Teorema 2.46 Seja n ∈ N um número ímpar e 1 < b < n − 1, um inteiro. Como n é ímpar temos

que n − 1 é um par. Portanto pode ser escrito como n − 1 = 2k · q, sendo k o maior expoente

possível do 2 e, consequentemente, q um número ímpar. Temos então que n é primo se algum

bq, b2q, b22q, ..., b2k−1q ≡ −1 mod n

ou
b2kq ≡ 1 mod n.

Demonstração: Considere as seguintes potências bq, b2q, b22q, ..., b2k−1q, b2kq. Se n é um
número primo, usando o Pequeno Teorema de Fermat temos que b2kq = bn−1 ≡ 1 mod n. Temos

então que pelo menos uma das potências de b é congruente a 1 módulo n. Seja s ≥ 1 o menor
expoente tal que b2sq ≡ 1 mod n, assim:

b2sq − 1 = (b2s−1q − 1) · (b2s−1q + 1).

Logo,

n|(b2s−1q − 1)

ou
n|(b2s−1q + 1)

Como s era o menor expoente que satisfazia a congruência, temos que (b2s−1q − 1) não

é divisível por n. Portanto n|(b2s−1q + 1), ou seja,

b2s−1q ≡ −1 mod n,

sendo 1 ≤ s − 1 ≤ k − 1.

(cid:4)

49

O desejo de muitos matemáticos é que a recíproca do terorema acima fosse verdadeira,

porque teríamos um teste determinístico eﬁciente. Porém, a recíproca não é verdadeira. Mas,

mesmo assim podemos usar a recíproca para obter um teste de probabilidade eﬁciente. Esse

novo teste não é determinístico e sim probabilístico.

Deﬁnição 2.47 Seja n ∈ N um número composto ímpar, com n − 1 = 2kq. Dizemos que n é um
pseudoprimo forte na base a se ou aq ≡ 1 mod n ou existe j(cid:48) < k com (aq)2 j(cid:48)

≡ −1 mod n.

Existem inﬁnitos pseudoprimos forte em qualquer base a > 1.

Deﬁnição 2.48 Seja A um conjunto ﬁnito. Denotamos a quantidade de elementos de A por #A.

Teorema 2.49 Seja

α(n) =

#{a| 0 < a < n, n um pseudoprimo f orte na base a}
φ (n)

.

Então, para todo número composto ímpar n > 9, temos que α(n) ≤

1
4

.

A demonstração desse teorema poder ser encontrada em (MARTINEZ; SALDANHA;

TENGAN, 2011).

Usando o teorema acima podemos desenvolver alguns testes de primalidade probabilís-

ticos, como o chamado de Teste de Miller-Rabin.

Teste de Miller-Rabin
Dado n ∈ N, com n ímpar e n > 9, tome t valores de a tais que 1 < a < n. Veriﬁque para

cada a se

aq, a2q, a22q, ..., a2k−1q (cid:54)≡ −1 mod n

e
a2kq (cid:54)≡ 1 mod n.

(cid:19)t

Se as condições acima forem veriﬁcadas a é composto. Caso contrário, com probabilidade
(cid:18)1
4

, temos que n é primo.

Vejamos agora dois exemplos para o Teste de Miller-Rabin.

Exemplo 2.50 241 é um número primo?

Sabemos que n = 241, então n − 1 = 240 = 24.15

Assim, k = 4, q = 15 e escolhendo b = 2 e t = 1 para facilitarmos as contas, temos as

seguintes congruências:

50

215 ≡ 233 mod n

22.15 ≡ 64 mod n

222.15 ≡ 240 ≡ −1 mod n

223.15 ≡ 1 mod n

224.15 ≡ 1 mod n

(2.11)

(2.12)

Pelas congruências 2.11 e 2.12, o Teste de Miller-Rabin nos diz que 241 é primo.

Como o teste de Miller-Rabin não é determinístico, não podemos aﬁrmar com certeza

que 241 é um número primo, mas sim que há uma grande chance de ser. Com o auxílio de uma

calculadora é fácil comprovar que 241 é realmente um número primo.

O próximo exemplo nos garante com certeza que o número testado é composto.

Exemplo 2.51 247 é um número primo?

Como n = 247, temos que n − 1 = 246 = 2.123

Assim, k = 1 e q = 123 e escolhendo a base b = 2 temos:

2123 ≡ 164 mod 247

22.123 ≡ 220 mod 247

Pelas congruências acima podemos aﬁrmar com certeza que 247 é um número com-

posto.

A escolha da base é importante para chegarmos a uma conclusão, por isso, ao testarmos

mais de uma base, conseguimos diminuir os possíveis erros. Alguns softwares usam 10 bases

diferentes para tentarem minimizar erros.

51

2.5 PROBLEMAS EM ABERTO

Apesar de serem estudados há muito tempo, ainda existem conjecturas sobre os números

primos que não foram demonstradas. Vejamos algumas delas:

Primos de Fermat

Como vimos na seção Primos especiais, sabemos que os Primos de Fermat, são números

da forma

que são primos.

Fn = 22n

+ 1,

n = 0, 1, 2, ...

Em uma de suas cartas, modo como discutia suas descobertas matemáticas, Fermat su-

gere que esses números são sempre primos. O que de fato acontece quando n = 0, 1, 2, 3, 4.

Posteriormente, Euler (1732) mostrou que para n = 5 o número de Fermat era composto, con-

trariando a hipótese de Fermat. Até os dias atuais, não se sabe da existência de outros números

de Fermat primos além dos cinco primeiros.

Primos gêmeos

Como vimos anteriormente, Primos gêmeos são primos da forma p e p+2. Sabemos que

todo número inteiro pode ser escrito como 6k, 6k − 1, 6k − 2, 6k + 1, 6k + 2, 6k + 3, sendo o

6k − 1 e 6k + 1 os únicos que podem ser primos. Além disso, a diferença entre eles é 2. Pelo
teorema de Dirichlet existem inﬁnitos primos da forma 6k − 1 e 6k + 1, k ∈ Z e cada par de

primos gêmeos pode ser escrito como (6k − 1, 6k + 1), exceto (3, 5). Podemos concluir, então,

que existem inﬁnitos primos gêmeos? Ou seja, existem inﬁnitos pares de números da forma

(p, p + 2)?

Essa pergunta é uma famosa conjectura dos números primos gêmeos e ainda está em

aberto e é um dos temas centrais da moderna teoria analítica dos números.

Infelizmente, mostrar que os primos gêmeos são da forma (6k − 1, 6k + 1) não garante

que todos os números da forma 6k − 1 ou 6k + 1 são primos, ou seja, a recíproca não é verda-

deira.

Com os trabalhos de Zhang e Maynard, vistos anteriormente, ﬁcamos cada vez mais

otimistas em encontrar uma demonstração para essa conjectura.

52

Primos de Sophie Germain

Com relação aos primos de Sophie Germain não se sabe se são inﬁnitos, mas também

nunca foi provado o contrário, desta forma, conjectura-se que existam inﬁnitos números primos

de Sophie Germain.

53

3 CRIPTOGRAFIAS

Uma das perguntas mais frequentes que todos os professores ouvem é: “Onde eu vou

usar isso?”. Um exemplo prático e que faz parte do cotidiano dos alunos é a criptograﬁa. E

poder mostrar que, graças a Matemática e os números primos, é possível ter uma codiﬁcação de

mensagem mais segura, faz despertar o interesse dos alunos por essa área.

Não podemos falar de criptograﬁa sem mencionar o Código de César ou Cifra de Cé-

sar, um dos códigos mais antigos e mais simples que consiste em trocar as letras do alfabeto

seguindo uma ordem bem determinada. O código recebe esse nome devido ao general Júlio Cé-

sar, do Império Romano, que o criou para se comunicar com seu exército sem que a mensagem

fosse descoberta por seus inimigos.

Segundo (COUTINHO, 2009), códigos desse tipo apresentam um grande problema: são

fáceis de “quebrar”, ou seja, rapidamente outra pessoa, que não seja o destinatário legítimo,

consegue descobrir o código usado e ler a mensagem original. Isso ocorre devido à frequência

média que cada letra aparece em uma frase ou texto. Na nossa língua as vogais são mais usadas

do que as consoantes e dentre as vogais a letra a é a mais usada, ﬁcando fácil identiﬁcar qual a

substituição utilizada.

Vejamos um exemplo do Código de César. Primeiramente devemos ter uma tabela de

conversão. No caso do general Júlio César, sua tabela consistia em trocar a letra A pela letra D,

a letra B pela E e assim sucessivamente (ver (HEFEZ, 2016)). Veja a tabela a seguir:

Tabela 3.1 – Tabela de conversão

Al f abeto A B C D E F G H I
D E F G H I
C ´odigo

K L M
K L M N O P

J

J

Al f abeto N O P Q R
Q R
C ´odigo

S

T U V W X Y

Z

S

T U V W X Y

Z
A B C

Assim, se quisermos codiﬁcar a mensagem original:

teremos a mensagem codiﬁcada:

NÃO SE RENDA

QDR VH UHQGD

54

Note que, para frases pequenas, não ﬁca tão evidente qual a frequência média de cada

letra. Segundo (COUTINHO, 2009), o método de decodiﬁcar a mensagem usando a frequência

média, só funciona se a mensagem for longa.

Com o avanço da tecnologia, códigos como o de César se tornaram mais fáceis de serem

quebrados e desta forma fez-se necessária a criação de códigos mais eﬁcazes.

Os códigos mais simples utilizam o que chamamos de criptograﬁa de chave simétrica,

cuja chave de codiﬁcação e de decodiﬁcação é a mesma. Já os códigos mais elaborados, aqueles

que são usados atualmente, utilizam a criptograﬁa de chave assimétrica, na qual as chaves de

codiﬁcação e decodiﬁcação são diferentes.

Veremos nesse capítulo a Criptograﬁa RSA, o Protocolo Difﬁe-Hellman e a Criptograﬁa

ElGamal.

3.1 Criptograﬁa RSA

Veremos agora um dos mais seguros métodos de criptograﬁa, a Criptograﬁa RSA, um

código inventado por R. L. Rivest, A Shamir e L. Adleman quando trabalhavam no Massachus-

sets Institute of Technology (M.I.T). Como podemos notar, RSA são as iniciais dos nomes dos

inventores desse código.

A criptograﬁa RSA consiste em um método de criptograﬁa de chave pública que para

ser implementado precisa de dois parâmetros básicos: dois números primos muito grandes e

distintos. Exatamente o que faz a segurança ser extremamente eﬁciente, pois é difícil fatorar

números primos muito grandes.

Curiosidade: Em certa ocasião, Rivest, após anos de estudo com seus amigos, ao pensar

sobre o problema das cifras assimétricas imaginou que a função de mão única poderia solucionar

esse problema e conseguiu formalizar sua descoberta em um artigo. Rivest assinou esse artigo

colocando seu nome e dos outros dois colaboradores em ordem alfabética: Adleman, Rivest e

Shamir. Por achar esse trabalho menos interessante do que os outros em que havia participado,

Adleman, sugeriu colocar seu nome por último. No entanto, o Sistema RSA se tornou uma das

cifras mais importantes da criptograﬁa moderna. Ver (SINGH, 2005).

Segundo (COUTINHO, 2016), a descrição da Criptograﬁa RSA consiste em, além de

mostrar os passos para codiﬁcar e decodiﬁcar uma mensagem, veriﬁcar a autenticidade do mé-

todo.

55

3.1.1 Pré-codiﬁcação

Primeiramente, para usarmos o método RSA, devemos converter a mensagem em nú-

meros. Para simpliﬁcar, vamos supor que a nossa mensagem é constituída apenas por palavras.

Para converter a mensagem em sequencia de números usaremos a seguinte tabela de conversão:

Tabela 3.2 – Tabela de conversão

A
10

B
11

C D E
14
13
12

F
15

G H
17
16

I
18

J
19

K
20

L M
22
21

N O P Q R
27
25
23

24

26

S
28

T
29

U V W X
33
30

31

32

Y
34

Z
35

Para representar o espaço entre as palavras, será usado o número 99. O uso de dois

algarismos para cada letra evita a ambiguidade. Por exemplo, se colocássemos a letra A sendo

1, a letra B sendo 2 e assim por diante, ao colocarmos o número 12 não saberíamos se a corres-

pondência seria AB ou L, que é a décima segunda letra do nosso alfabeto.

O próximo passo é determinarmos os números primos distintos, p e q, que usaremos

como parâmetros e que será de conhecimento apenas do receptor da mensagem. A partir desses

primos, determinaremos n, sendo n = p.q. Esse número n será de conhecimento público, o

que não afeta a segurança do método desde que escolhamos p e q grandes e distantes um do

outro, tornando a fatoração de n inviável. Segundo (COUTINHO, 2009), não basta p e q serem

grandes se |p − q| for pequeno, pois a fatoração de n se torna fácil se utilizarmos o algoritmo de

fatoração de Fermat.

O último passo consiste em separar o longo número, que encontraremos na conversão,

em blocos. Esses blocos não precisam ter todos a mesma quantidade de algarismos; devem,

apenas, ser números menores do que n e não começar com o número zero.

Exemplo 3.1 Seja p = 17 e q = 23, assim n = 391. Queremos converter a frase: Deus é ﬁel.

Deste modo, a frase é convertida no número

1314302899149915181421.

Separando esse número em blocos temos:

1 − 314 − 302 − 89 − 91 − 49 − 91 − 51 − 8 − 142 − 1.

56

3.1.2 Codiﬁcação e decodiﬁcação

Neste momento faremos a codiﬁcação da mensagem. Para isso, necessitamos do número

n e de um outro inteiro positivo e de tal forma que mdc(e, φ (n)) = 1. Como n = p.q, determinar

o valor de φ (n) é simples. Ao par (n, e) daremos o nome de chave de codiﬁcação do sistema

RSA, que será de conhecimento público. A frase "Deus é ﬁel" foi convertida em blocos, os

quais serão, cada um, codiﬁcados separadamente. A mensagem codiﬁcada será a sequência dos

blocos codiﬁcados, sem que esses sejam reunidos.

Como codiﬁcar um bloco?

Lembre-se que todos os blocos devem ser menores do que n. Se chamarmos o bloco a

ser codiﬁcado de b e o bloco codiﬁcado de C(b), para encontrarmos C(b) basta calcularmos o

resto da divisão de be por n.

Em outras palavras, C(b) é a forma reduzida de be módulo n, mas sempre trabalhando

com restos positivos.

C(b) ≡ be mod n.

Exemplo 3.2 No Exemplo 3.1, vamos codiﬁcar o terceiro bloco: 302.

Temos n = 391, assim φ (391) = φ (17.23) = (17 − 1).(23 − 1) = 352. Agora, devemos

escolher e. Para facilidade dos cálculos, escolheremos e = 3, sendo mdc(3, 352) = 1.

Todos esses valores são escolhidos e calculados pelo receptor. O emissor só terá conhe-

cimento do números n e e que serão necessários para que ele codiﬁque sua mensagem.

Temos então:

3023 ≡ (−89)3 ≡ −387 ≡ 4 mod 391.

Portanto, o bloco 302 é codiﬁcado como 4.

Codiﬁcando toda a mensagem teríamos a seguinte sequência:

1 − 155 − 4 − 387 − 114 − 349 − 114 − 102 − 121 − 386 − 1.

Decodiﬁcando a mensagem

Passemos agora para a decodiﬁcação da mensagem. Nesse momento necessitamos do

número n e do inverso multiplicativo de e em φ (n), que será denotado por d. Ao par (n, d)

daremos o nome de chave de decodiﬁcação, sendo essa de conhecimento exclusivo do receptor

da mensagem. Utilizando o algoritmo euclidiano estendido podemos encontrar d de maneira

fácil, veja (COUTINHO, 2009).

57

Seja C(b) um bloco da mensagem codiﬁcada e D(C(b)) o resultado da decodiﬁcação.

Para encontrarmos D(C(b)) basta calcularmos resto da divisão de C(b)d por n.

Em outras palavras, D(C(b)) é a forma reduzida de C(b)d módulo n.

D(C(b)) ≡ C(b)d mod n

Exemplo 3.3 Faremos a decodiﬁcação do terceiro bloco: 4. Usaremos d = 235 que foi encon-

trado pelo algoritmo euclidiano estendido.

Calculando D(4), referente ao terceiro bloco, temos:

4235 ≡ 302 mod 391

Ou seja, decodiﬁcando 4, temos o número 302. Portanto, decodiﬁcando o bloco 4,

voltamos ao bloco original.

Mas será que isso acontece para todos os blocos? Se sim, por que é válido?

3.1.3 Autenticidade do método

Precisamos mostrar que D(C(b)) = b. Temos que:

C(b) ≡ be mod n

D(C(b)) ≡ C(b)d mod n

e.d ≡ 1 mod φ (n)

(3.1)

(3.2)

(3.3)

Combinando as congruências (3.1) e (3.2) , temos:

D(C(b)) ≡ (be)d mod n

D(C(b)) ≡ be.d mod n

(3.4)

Queremos mostrar que

be.d ≡ b mod n.

58

Pela equação (3.3), existe um inteiro k tal que :

ed = kφ (n) + 1.

Usando a equação (3.4)

bkφ (n)+1 ≡ D(C(b)) mod n.

(3.5)

Dividiremos a demonstração em três casos.

Primeiro caso: p|b e q|b. Assim, p|b implica que

então

b ≡ 0 mod p

bed ≡ 0 mod p.

Como p é primo, temos que p|b.

De forma análoga, concluímos que, se q|b, então

bed ≡ 0 mod q.

Como q é primo, temos que q|b. Dos fatos que mdc(p, q) = 1 e p|b e q|b, concluímos que

n = pq|b. Logo

Portanto,

b ≡ 0 mod n.

bed ≡ 0 mod n.

Segundo caso: suponhamos agora que p e q não dividem b. Pelo Teorema de Fermat

temos que

bp−1 ≡ 1 mod p

e

bq−1 ≡ 1 mod q.

Implicando que

(bp−1)q−1 ≡ 1q−1 mod p,

(bq−1)p−1 ≡ 1p−1 mod q.

59

(3.6)

(3.7)

Das equações (3.6) e (3.7) e da Proposição 3 do apêndice Congruências, temos que

Assim,

O que equivale a

bφ (n) ≡ 1 mod pq.

(bφ (n))k.b ≡ b mod n.

b ≡ D(C(b)) mod n.

Terceiro caso: p|b e q (cid:45) b. Do fato que p|b, temos que

bed ≡ b mod p.

Como q não divide b, o pequeno teorema de Fermat implica que

bed ≡ b mod q.

Temos que mdc(p, q) = 1, p|bed − b e q|bed − b, então n = pq|bed − b. Então,

bed ≡ b mod n.

Provando assim, que o bloco b é igual ao bloco decodiﬁcado D(C(b)).

3.1.4 Segurança do RSA

Vimos que o RSA é um método de chave pública, o que poderia levantar questionamen-

tos sobre sua segurança. Sabemos que alguns valores, como n e e, são de conhecimento público

e d de conhecimento apenas do receptor legítimo da mensagem, assim o que devemos garantir

é que nenhuma pessoa consiga calcular d conhecendo apenas n e e.

60

Na prática só sabemos encontrar d se aplicarmos o algoritmo euclidiano estendido a

φ (n) e e. Mas só sabemos calcular φ (n) se conhecemos p e q, ou seja, se fatorarmos n. Se n for

grande sabemos que não existem algoritmos de fatoração eﬁcientes.

Segundo (COUTINHO, 2009), podemos supor que alguém tenha inventado um método

para calcular φ (n) a partir de n e e. Desta forma, teríamos conhecimento de n = p.q e φ (n) =

(p − 1).(q − 1). Queremos determinar p e q a partir disto. Sabemos que

φ (n) = (p − 1).(q − 1) = pq − (p + q) + 1 = n − (p + q) + 1,

Assim, temos que p + q = n − φ (n) + 1 é conhecido. No entanto,

(p + q)2 − 4n = p2 + q2 + 2pq − 4pq = (p − q)2

logo,

p − q =

(cid:113)

(p + q)2 − 4n

também é conhecido. Mas conhecendo p + q e p − q, conseguimos calcular p e q, ou seja,

fatoramos n. Portanto, não tem como descobrirmos φ (n) sem fatorarmos n.

Outra suposição seria inventar um algoritmo para calcular d diretamente. Sabemos que

ed ≡ 1 modφ (n), implicando no conhecimento de um múltiplo de φ (n). Novamente, teríamos a

fatoração de n. A demonstração de tal aﬁrmação pode ser encontrada em (RIVEST; SHAMIR;

ADLEMAN, 1978).

3.1.5 Assinaturas

Trabalhamos até agora com a segurança da Criptograﬁa RSA em impedir que terceiros

decodiﬁquem uma mensagem. Mas e se um terceiro se ﬁzer passar pelo emissor legítimo? O

que nos garante que a mensagem foi realmente enviada por uma determinada pessoa sendo que

a chave de codiﬁcação é de conhecimento público?

Agora, iremos tratar do problema de um “hacker” se passar pelo emissor legítimo e

enviar uma mensagem enganosa. Precisamos de um garantia de quem realmente é o emissor da

mensagem, precisamos que essa mensagem seja “assinada”.

Vejamos como isso ocorre. Suponhamos que uma empresa queria enviar uma mensagem

ao banco. Para isso, a empresa deve “assinar” essa mensagem para que o banco possa identiﬁcar

61

o emissor e conﬁar na mensagem que está recebendo. Sejam Ce e De as funções codiﬁcação e

decodiﬁcação de um empresa e Cb e Db as funções correspondentes do banco. As funções de

codiﬁcação, tanto da empresa quanto do banco, são de conhecimento público. O que seria de

costume, era a empresa usar Cb para decodiﬁcar um bloco a da mensagem e o banco usando

Db decodiﬁcaria a mensagem. Mas para garantir que foi realmente a empresa que enviou tal

mensagem, para assinar a mensagem, a empresa envia para o banco Cb(De(a)). Ou seja, a

empresa primeiro aplica a sua função de decodiﬁcação, que é apenas de seu conhecimento, e

depois codiﬁca o bloco da maneira usual. O banco ao receber o bloco aplica sua função Db e em

seguida aplica Ce, retornando assim a mensagem original. Isso é suﬁciente pois, se ao aplicar a

sequencia de funções CeDb a mensagem ﬁzer sentido signiﬁca que ela foi codiﬁcada usando as

funções CbDe, implicando que a mensagem foi enviada pela empresa devido ao fato de De ser

apenas de conhecimento da empresa. Segundo (COUTINHO, 2009), a probabilidade de uma

mensagem enviada por um hacker, sem ter utilizado a função De, fazer sentido é praticamente

zero.

Assim como há um constante avanço em aprimorar a segurança dos métodos de cripto-

graﬁa, também há um avanço nas técnicas de quebrar esses códigos. Segundo (COUTINHO,

2009), um consultor em assuntos de segurança, formado em biologia, descobriu um método

para encontrar a chave de decodiﬁcação do sistema RSA levando em conta apenas o tempo que

o sistema leva para conﬁrmar a assinatura. Percebemos, desta forma, que a segurança do RSA

não depende exclusivamente de algoritmos matemáticos.

3.2 Protocolo Difﬁe-Hellman

O maior desaﬁo da criptograﬁa era a troca de chaves entre correspondentes sem ser des-

coberta por terceiros. A comunidade dos criptologistas achavam que essa troca de chaves era

impossível acontecer sem o auxilio de um intermediador. Coube a Whitﬁeld Difﬁe e Martin

Hellman com contribuições de Ralph Merkle, através da congruência, mostrar que, não apenas

era possível, mas também era uma forma simples. Difﬁe e Hellman trabalharam na criptogra-

ﬁa de chave pública enquanto Merkle trabalhou, independentemente, na distribuição de chave

pública. Em 1976, Difﬁe e Hellman publicaram um artigo intitulado “New Directions in Cryp-

tography” na IEEE Transactions on Information Theory, e ﬁzeram referência ao trabalho de

Merkle. Em 2016, Difﬁe e Hellman receberam o prêmio Turing por esse trabalho.

Vejamos a seguir a ideia da dupla americana.

62

Maria e José precisam trocar uma chave secreta, mas possuem apenas um meio inseguro

para a troca. Então, eles escolhem dois números naturais m e a, sendo m primo e a um gerador
do grupo Z∗

m, e os tornam públicos. José escolhe outro número natural αJ e o mantém secreto.
Em seguida, calcula o único número βJ < m tal que aαJ ≡ βJ modm, e o envia para Maria.

De forma análoga, Maria escolhe um número natural αM, também secreto, e calcula o único
número βM < m tal que aαM ≡ βM mod m, e o envia para José. No próximo passo, José calcula
β αJ
M , obtendo

β αJ
M ≡ (aαM )αJ ≡ aαM.αJ ≡ α modm,

com α < m.

Por sua vez, Maria calcula β αM

J

, obtendo

β αM
J ≡ (aαJ )αM ≡ aαJ.αM ≡ α modm,

com α < m.

Fim do processo! Agora, Maria e José possuem a chave secreta α, que é de conheci-

mento apenas dos dois.

Exemplo 3.4 Suponhamos que Maria e José tenham escolhido os números naturais a = 30

e m = 239, de conhecimento de todos. José escolhe αJ = 5 e Maria escolhe αM = 3, sendo

que cada um conhece apenas seu número. Vamos descobrir qual a chave secreta que ambos

compartilharão.

José faz o seguinte cálculo para encontrar βJ:

303 ≡ 232 mod 239,

302 ≡ 183 mod 239,

305 = 303.302 ≡ 232.183 ≡ 153 mod 239.

Logo, βJ = 153.

Agora, Maria faz cálculos análogos para determinar βM:

303 = 27000 ≡ 232 mod 239.

Assim, βM = 232.

José envia o número 153 para Maria, que, por sua vez, envia o número 232 para ele.

63

Para determinar a chave secreta α, José tem que reduzir 2325 módulo 239.

2322 = 53824 ≡ 49 mod 239

2325 = 2322.2322.232 ≡ 49.49.232 ≡ 162 mod 239.

Portanto, α = 162 é a chave secreta!

Agora, Maria também deve reduzir 1533 módulo 239.

1532 = 23409 ≡ 226 mod 239

1533 = 1532.153 ≡ 226.153 ≡ 162 mod 239.

Exatamente o que esperávamos, α = 162.

Haveria um forma de um terceiro interceptar a mensagem e decifrá-la? Haveria como

um terceiro descobrir os valores αJ e αM que não foram divulgados?

Suponhamos que uma terceira pessoa esteja acompanhando a troca de mensagens e co-

nhece todos os valores públicos. Essa pessoa deverá resolver as seguintes congruências para

encontrar os valores que foram divulgados:

ou

30αJ ≡ 153 mod 239

30αM ≡ 232 mod 239.

Resolvendo uma das congruências acima, essa pessoa também terá acesso à chave se-

creta α.

No exemplo que demos, os valores adotados são considerados pequenos, o que os tor-

nam fáceis de serem descobertos. O aconselhável, para oferecer segurança, são números muito

maiores, sendo m próximo de 21000. O protocolo Difﬁe-Hellman é suscetível a ataques do tipo

“main in the middle attacks”, para mais detalhes veja (AHMED et al., 2012).

64

3.3 Criptograﬁa ElGmal

Taher ElGamal, nascido no Egito, vive atualmente na Califórnia e é mundialmente res-

peitado por suas contribuições com a criptograﬁa. É líder de segurança da informação e reco-

nhecido como o “pai” do SSL, protocolos criptográﬁcos que fornecem segurança de comunica-

ções em redes de computadores.

ElGamal criou um criptossistema que se baseia na diﬁculdade de calcular logaritmos

discretos em Z∗

p. Ver (ELGAMAL, 1985).

3.3.1 O Algoritmo de Criptograﬁa ElGamal

Este algoritmo trabalha com duas chaves, uma particular e outra pública. Chamaremos

os usuários de A e B.

Inicialmente, o usuário A cria uma chave particular e outra pública. Essa chave pública

servirá para que o usuário B criptografe uma mensagem m e a chave particular será usada pelo

usuário A para descriptografar m.

Como são criadas essas chaves?

1o) A escolhe um número primo, p.

2o) A escolhe g ∈ Z∗

p, com g, preferencialmente, sendo um gerador do grupo cíclico Z∗
p;

3o) A chave particular de A é um número k ∈ Z tal que 1 ≤ k ≤ p − 1;

4o) A calcula

r ≡ gk mod p.

(3.8)

Dessa forma, A cria uma chave pública (r, g, p).

Como o usuário B envia uma mensagem criptografada para A?

O usuário B usará a chave pública (r, g, p) juntamente com os seguintes passos:

1o) B escolhe um inteiro b, com 1 ≤ b ≤ p − 2 para ser sua chave particular e calcula

s ≡ gb mod p.

2o) Em seguida, para criptografar a mensagem m, B calcula:

γ ≡ m · rb mod p.

(3.9)

(3.10)

65

3o) A mensagem criptografada é representada pelo par (s, γ).

Como o usuário A irá descriptografar a mensagem m?

Quando A recebe o par (s, γ), segue os seguintes passos para descriptografar a mensa-

gem:

1o) A calcula, usando sua chave particular k:

2o) Em seguida, calcula:

y ≡ sp−1−k mod p.

m ≡ y · γ mod p.

(3.11)

(3.12)

Recuperando assim a mensagem m.

3.3.2 Exemplo numérico

Vamos mostrar como codiﬁcar e decodiﬁcar a palavra DEUS. Usaremos a Tabela 3.2

para a conversão das letras em números. Desta forma, a palavra DEUS é trocada pela sequência

numérica 13143028, ou seja, o emissor deve criptografar os números 13, 14, 30 e 28.

Criptografaremos o número 13, os outros são análogos.

Primeira etapa

O usuário A escolhe um primo p = 31, implicando que trabalharão com o grupo Z∗

31. Logo em

seguida escolhe um elemento desse grupo, g = 3 e também sua chave particular k = 25.

Em seguida calcula r:

r ≡ 325 ≡ 6 mod 31.

Criando dessa forma, uma chave pública que será enviada ao usuário B: (r, g, p) =

(6, 3, 31).

Segunda etapa

O usuário B recebe essa chave pública e escolhe um inteiro b = 16 e calcula s:

s ≡ 316 ≡ 8 mod 31.

66

A mensagem m = 13 criptografada calculando-se o γ:

γ ≡ 13.616 ≡ 13 mod 31.

Ficando assim, a mensagem criptografada, representada pelo par (8, 13).

Terceira Etapa

O usuário A recebe o par (8, 13) e calcula y:

y ≡ 831−1−25 ≡ 85 ≡ 1 mod 31.

Logo depois, usando sua chave particular k = 25, descriptografa a mensagem:

m ≡ 1.13 ≡ 13 mod 31.

Vimos então que a primeira letra da mensagem foi criptografa e descriptografada utili-

zando o algoritmo de ElGamal.

Nada impede que o usuário mande mais de uma letra por mensagem desde que m seja

estritamente menor do que p.

3.3.3 Autenticidade do algoritmo

Para provar a autenticidade do algoritmo de ElGamal, precisamos mostrar que a Equação

(3.12) é satisfeita. Da equação (3.11) temos que:

y ≡ sp−1−k mod p

y ≡ sp−1 · s−k mod p.

(3.13)

Pelo Pequeno Teorema de Fermat, 2.10, temos que:

sp−1 ≡ 1 mod p.

Assim, pela equação (3.9), podemos reescrever a equação (3.13) da seguinte forma:

y ≡ g−bk mod p.

(3.14)

67

Temos que calcular y · γ mod p. Das equações (3.10) e (3.14) temos:

y · γ ≡ m · rb · g−bk ≡ m · rb · r−b ≡ m mod p

Provando assim que, quando a mensagem é descriptografada, retorna à mensagem ori-

ginal.

4 ATIVIDADES

Apresentaremos algumas sugestões de atividades para serem feitas com os alunos do

68

Ensino Fundamental II e Médio.

√

2 é um número irracional

4.1

Uma boa forma de apresentar aos alunos do Ensino Fundamental II que existem outros

números além dos racionais é questioná-los sobre o valor de algumas raízes irracionais, por

exemplo,

2. Aconselhamos que seja usada a calculadora para esta atividade, isso estimula o

√

interesse dos alunos e não atrapalha o objetivo dessa atividade.

Primeiro passo

Questione-os entre quais raízes conhecidas

√

2 está. Como

√

2 é pequena, espera-se que

rapidamente eles respondam entre

Incentive-os a concluir que

e 4.

√

1 e

4.

√

√

2 deve ser um número entre 1 e 2, pois são as raízes de 1

√

1 <

√

2 <

√
4

√

2 < 2

1 <

Segundo passo

Peça aos alunos que acrescentem uma casa decimal ao número 1 e veriﬁquem se, ao

elevarem o novo número ao quadrado, ele será igual a 2.

Neste momento, indague-os sobre qual deve ser o primeiro número decimal. Como o

√

√

2 deve estar mais próxima de

1 do que de

número 2 está mais perto de 1 do que 4, assim
√

4, ou seja, mais perto de 1 do que de 2. Isso fará com que eles escolham os números 1, 2, 3,

4 ou, no máximo, 5 para serem a primeira casa decimal.

Ao fazerem os quadrados obterão:

x
x2

1,1
1,21

1,2
1,44

1,3
1,69

1,4
1,96

1,5
2,25

Com isso, veriﬁcarão que 1, 4 <

√

2 < 1, 5.

69

Terceiro passo

Neste momento, eles irão acrescentar a segunda casa decimal, seguindo a mesma lógica

que utilizaram para a primeira. Incentive-os a perceber que 2 está apenas a 4 centésimos de

distância do 1,96; enquanto 2,25 está a 25 centésimos. Assim, as tentativas serão: 1, 41; 1, 42 e

1, 43.

x
x2

1,41
1,9881

1,42
2,0164

1,43
2,0449

Pelos resultados obtidos, espera-se que eles concluam que:

(cid:112)

1, 9881 <

√

2 < (cid:112)

2, 0164

1, 41 <

√

2 < 1, 42.

Quarto passo

Novamente, peça que acrescentem a terceira casa decimal seguindo os critérios anterio-

res, esperando assim que as tentativas sejam: 1, 412; 1, 413; 1, 414 e 1, 415.

Obtendo:

x
x2

1,412
1,993744

1,413
1,996569

1,414
1,999396

1,415
2,002225

Desta forma, concluirão que 1, 414 <

√

2 < 1, 415.

Após esses cálculos e observarem que os valores se aproximam de 2, os alunos costu-

mam ﬁcar entusiasmados e estimulados a acrescentar mais uma casa.

Quinto passo

Para ﬁnalizar os cálculos, pedimos que acrescentem a quarta casa decimal. Espera-se

que as tentativas sejam: 1, 4141; 1, 4142; 1, 4143 e 1, 4144. Obtendo:

x
x2

1,4141
1,99967881

1,4142
1,99996164

1,4143
2,00024449

Concluindo que 1, 4142 <

√

2 < 1, 4143.

Neste momento, o professor pode escolher acrescentar a quinta casa decimal ou já passar

70

para a conclusão.

Conclusão

Após várias etapas, notamos que os números, ao serem elevados ao quadrado, se apro-

ximavam cada vez mais do número dois, mas nunca são exatamente ele. Para que não haja

dúvidas, peça para que os alunos façam 1,4142135623 ao quadrado e veriﬁquem que, mesmo

com dez casas decimais, não encontramos

2. Apesar de não ser uma demonstração esse pro-

√

cesso ilustra o fato de

2 ser irracional.

√

Após essa construção de raciocínio, o professor deverá apresentar a demonstração for-

mal para seus alunos:

Demonstração: Suponhamos que

√

2 seja um número racional. Assim,

√

2 =

p
q

, com p

e q números inteiros sem fatores em comum, ou seja, na forma irredutível. Elevando a igualdade

ao quadrado temos que:

2 =

p2
q2

p2 = 2 · q2

(4.1)

Assim, temos que p2 é um número par, consequentemente, p é par. Logo, podemos

escrever p = 2n, com n inteiro. Substituindo p = 2n na equação 4.1, temos:

(2n)2 = 2 · q2 ⇔ 4n2 = 2 · q2 ⇔ 2n2 = q2.

Novamente, temos que q2 é um número par, logo q também é. Mas se p e q são pares,

temos que

p
q

não está na forma irredutível, contradizendo a hipóteses inicial. Portanto

número irracional.

√

2 é um

DICA: Esta atividade também pode ser feita em um laboratório de Informática utili-

(cid:4)

zando o Excel. Esse software auxilia nos cálculos e, diferentemente da calculadora, consegue

fazer potências com mais casas decimais, facilitando a compreensão de que

casas decimais não periódicas.

√

2 possui inﬁnitas

71

4.2 Atividade 2

Propomos agora uma atividade envolvendo a criptograﬁas RSA: Caça ao tesouro.

A ideia desta atividade é fazer um mapa do tesouro criptografando os números que nele

aparecem. Nessa atividade, todos os grupos irão criptografar e descriptografar mensagens. A

separação da quantidade de grupos e alunos ﬁca a critério do professor.

Sugerimos que essa atividade seja realizada em quatro aulas: as duas primeiras para

explicar o conteúdo, a terceira para criptografar uma mensagem e a quarta para descriptografar

essa mensagem.

Suponhamos que haja 4 grupos, cada um desses grupos irá criptografar uma mensagem

para o grupo “seguinte“ e descriptografar a mensagem do grupo “anterior". Por isso, já em um

primeiro momento deve ﬁcar bem clara a ordem dos grupos para que não haja erro na troca de

informações. Veja a seguinte tabela:

Grupo Criptografa para Descriptografa de

I
II
III
IV

II
III
IV
I

IV
I
II
III

Vamos a um exemplo prático!

1a etapa: Pré-codiﬁcação

Pegaremos o Grupo I como exemplo, os demais são análogos. Primeiramente, o Grupo I

deve escolher os primos p e q para determinar n = p · q. Em seguida devem escolher um número

e de forma que mdc(e, φ (n)) = 1. O último passo é determinar o inverso multiplicativo, d, de e

mod φ (n). Lembrando que n e e serão de conhecimento público.

Para exempliﬁcar, escolhemos p = 13, q = 7 e e = 5. Assim, encontramos n = 91,

φ (91) = φ (13 · 7) = (13 − 1) · (7 − 1) = 72 e d = 29.

2a etapa: Codiﬁcação

O Grupo I torna público os números n e e para que o Grupo IV criptografe uma mensa-

gem. O Grupo IV tem a seguinte mensagem original:

"Siga 31 passos para o norte, gire 45o para a esquerda e siga na direção oeste 61 passos.

Neste momento, os alunos deverão criptografar os número que aparecem em seu mapa.

No nosso caso, devemos criptografar os números 31, 45 e 61:

72

315 ≡ 5 mod 91

455 ≡ 54 mod 91

615 ≡ 3 mod 91

Portanto, a mensagem criptografada que será entregue ao Grupo I é:

"Siga 5 passos para o norte, gire 54o para a esquerda e siga na direção oeste 3 passos".

3a etapa: Descriptografar

O Grupo I recebe a mensagem e utilizando o número d, descriptografa a mensagem.

529 = 510+10+9 = 510 · 510 · 59 ≡ 51 · 51 · 83 ≡ 31 mod 91

5429 = 5410+10+9 = 5410 · 5410 · 549 ≡ 23 · 23 · 83 ≡ 45 mod 91

329 = 310+10+9 = 310 · 310 · 39 ≡ 81 · 81 · 27 ≡ 61 mod 91

Note que separamos a congruência inicial em congruências menores. Como estamos

trabalhando com calculadora cientíﬁca, temos que nos atentar à quantidade de casas que ela

consegue trabalhar, então para que não haja erros, optamos por trabalhar com essas congruên-

cias. Para o cálculo dessas congruências foi usada a calculadora cientíﬁca online que pode ser

encontrada em: https://www.calculadoraonline.com.br/cientiﬁca .

Desta maneira, o Grupo I descobre que os verdadeiros valores são 31, 45 e 61. Retor-

nando à mensagem original.

Agora, basta seguir as instruções e encontrar o "tesouro"!

O grupo campeão será aquele que gastar menor tempo para criptografar e descriptografar

a mensagem. Basta somarmos o tempo gasto nas duas últimas aulas. Cabe ao professor, com

criatividade, escolher qual será o “tesouro“ que os alunos encontrarão.

Ao mesmo tempo que o Grupo I estará escolhendo as chaves para o Grupo IV, os outros

grupos estarão fazendo a mesmo coisa. Quando o Grupo IV tiver acesso aos valores n e e do

Grupo I, o Grupo I também estará tendo acesso aos valores de n e e que o Grupo II escolheu e

também terá que criptografar uma mensagem.

Sugestões:

• Escolher números primos pequenos.

73

• Ensinar aos alunos apenas como calcular φ (n).

• Ao invés de falar em inverso multiplicativo, explicar que para determinar o valor de d,

devemos encontrar um número que multiplicado por e deixa resto 1 na divisão por φ (n).

Esse inverso multiplicativo será encontrado por tentativa, mas explique que existe um

algoritmo para encontrar esse inverso.

74

5 CONCLUSÃO

Ao longo desta dissertação observamos que os números primos são importantes não só

para a Matemática, mas também para o nosso dia a dia. Com o aumento signiﬁcativo do uso

da tecnologia e da troca de informações pelos meios digitais fez-se necessária a criação de

métodos para transmitir essas informações de forma segura. E a criptograﬁa ajudou a tornar

isso possível.

Os números primos sempre foram alvo de muitos estudos, o que nos forneceu avan-

ços consideráveis em relação às suas propriedades e particularidades. Isso auxiliou muito no

desenvolvimento da criptograﬁa.

Com a criptograﬁa conseguimos exempliﬁcar a aplicação de vários conteúdos do Ensino

Fundamental e Médio, tais como: divisão euclidiana, máximo divisor comum, potenciação,

radiciação, propriedades transitiva, reﬂexiva, simétrica entre outras. O bom de ilustrar essas

aplicações é que ressaltamos para os alunos a importância da Matemática em seu cotidiano.

Estudamos duas criptograﬁas que se destacam atualmente: RSA e ElGamal. Ambas

baseadas na troca de chaves assimétricas. Estudos atuais mostraram que a Criptograﬁa ElGamal

é menos arriscada que a RSA, que apresentou falta de segurança em duas de cada mil chaves

coletadas. Ver (LENSTRA et al., 2012).

A criptograﬁa foi se desenvolvendo ao longo da história e percebemos que houve muitas

mudanças na forma de executá-la. O que começou apenas com uma troca na ordem das letras do

alfabeto se tornou algo soﬁsticado e com a presença de propriedades e conceitos matemáticos

mais reﬁnados. O conhecimento não é algo estático, está sempre em movimento, e a criptogra-

ﬁa está acompanhando esse movimento. Hoje, utilizamos os números primos na criptograﬁa

de informações e a segurança dos sistemas de criptograﬁa baseia-se em problemas matemáticos

que são difíceis de resolver nos computadores atuais. Mas vemos também um grande avanço

computacional, o que poderá acarretar em uma mudança na segurança desses métodos. Pes-

quisas vêm sendo desenvolvidas na busca de métodos alternativos que possam substituir os que

existem hoje. Estudos nos mostram que o próximo passo será a Criptograﬁa Quântica, que se

baseia nos princípios da mecânica quântica, não mais em números primos.

REFERÊNCIAS

75

AGRAWAL, M.; KAYAL, N.; SAXENA, N. Primes is in p. Annals of Mathematics, n. 2, p.
781–793, 2004. Disponível em: <https://www.cse.iitk.ac.in/users/manindra/algebra/primality_
v6.pdf>.

AHMED, M. et al. Difﬁe-hellman and its application in segurity protocols. International
Journal of Engineering Science and Innovative Technology (IJESIT), n. Volume 1, p.
69–73, nov 2012. Disponível em: <https://www.researchgate.net/publication/279725863>.

COUTINHO, S. C. Primalidade em Tempo Polinomial: uma introdução ao algoritmo
AKS. 1. ed. Rio de Janeiro: Unisersidade Federal do Rio de Janeiro, 2004.

COUTINHO, S. C. Números Inteiros e Criptograﬁa RSA. 2. ed. Rio de Janeiro: IMPA,
2009.

COUTINHO, S. C. Criptograﬁa. 1. ed. Rio de Janeiro: IMPA, 2016.

ELGAMAL, T. A public kay cryptosystem and a signatura scheme based on discrete
logarithms. IEEE Transactions on Information Theory, n. 31, p. 469–472, 1985. Disponível
em: <https://ieeexplore.ieee.org/document/1057074>. Acesso em: 04 nov. 2020.

HEFEZ, A. Aritmética. 2. ed. Rio de Janeiro: SBM, 2016.

KLARREICH, E. A number theorist who solves the hardest easy problems.
Quanta Magazine, 2020. Disponível em: <https://www.quantamagazine.org/
james-maynard-solves-the-hardest-easy-math-problems-20200701/>. Acesso em: 04
nov. 2020.

LENSTRA, A. et al. Ron was wrong, whit is right. Cryptology e Print Archive, n. 064, 2012.
Disponível em: <https://eprint.iacr.org/2012/064.pdf>. Acesso em: 04 nov. 2020.

LIN, T. After prime proof, an unlikely star rises. Quanta Magazine, 2015. Disponível em:
<https://www.quantamagazine.org/yitang-zhang-and-the-mystery-of-numbers-20150402>.
Acesso em: 04 nov. 2020.

MARTINEZ, F. B.; SALDANHA, N.; TENGAN, E. Teoria dos números. 2. ed. Rio de
Janeiro: IMPA, 2011.

MAYNARD, J. Small gaps between primes. 2019. Disponível em: <https://arxiv.org/pdf/1311.
4600.pdf>. Acesso em: 04 nov. 2020.

O’CONNOR,J.J. AND ROBERTSON, E.F. Marin Mersenne. [S.l.], 1996. Disponível em:
<https://mathshistory.st-andrews.ac.uk/Biographies/Mersenne/>. Acesso em: 04 nov. 2020.

RIBENBOIM, P. The Little Book of Bigger Primes. 2. ed. New York: Springer, 2004.

RIVEST, R.; SHAMIR, A.; ADLEMAN, L. A method for obtaining digital signatures and
public-key cryptosystems. Comm. ACM, n. 21, p. 120–126, 1978.

SINGH, S. O livro dos códigos. 5. ed. Rio de Janeiro: Record, 2005.

WIKIPéDIA. Constante de Brun — Wikipédia, a enciclopédia livre. 2016. [Online;
accessed 04-novembro-2020]. Disponível em: <https://pt.wikipedia.org/w/index.php?title=
Constante_de_Brun&oldid=47225932>.

76

WIKIPéDIA. Gottfried Wilhelm Leibniz — Wikipédia, a enciclopédia livre. 2020. [Online;
accessed 4-novembro-2020]. Disponível em: <https://pt.wikipedia.org/w/index.php?title=
Gottfried_Wilhelm_Leibniz&oldid=59976305>.

WIKIPéDIA. Último teorema de Fermat — Wikipédia, a enciclopédia livre. 2020. [Online;
accessed 20-outubro-2020]. Disponível em: <https://pt.wikipedia.org/w/index.php?title=
%C3%9Altimo_teorema_de_Fermat&oldid=59631994>.

WIKIPéDIA. Sophie Germain — Wikipédia, a enciclopédia livre. 2020. [Online; accessed
04-novembro-2020]. Disponível em: <https://pt.wikipedia.org/w/index.php?title=Sophie_
Germain&oldid=58371821>.

ZHANG, Y. Bounded gaps between primes. Annals of Mathematics, n. 179, p. 1121–
1174, 2014. Disponível em: <https://annals.math.princeton.edu/wp-content/uploads/
annals-v179-n3-p07-s.pdf>. Acesso em: 04 nov. 2020.

77

APÊNDICE A – CONGRUÊNCIAS

A congruência é uma das principais ferramentas usada na criptograﬁa, facilitando a des-

crição do processo de criptograﬁa RSA e de ElGamal. O que torna a congruência extremamente

útil é a sua relação com a divisão euclidiana. Apresentaremos agora alguns conceitos e teore-

mas que são de extrema importância para compreensão e utilização da congruência. Foi usado

como referência para a elaboração desse apêndice o livro da coleção PROFMAT de Aritmética,

no qual encontram-se as demonstrações aqui omitidas. Ver (HEFEZ, 2016).

Congruência

Seja m um número natural. Diremos que dois números inteiros a e b são congruentes

módulo m se os restos de sua divisão euclidiana por m são iguais. Escrevemos

a ≡ b mod m.

Por exemplo, 34 ≡ 29 mod5, pois o resto da divisão de 34 e 29 por 5 é 4, ou seja,

possuem o mesmo resto.

Quando a relação a ≡ b mod m for falsa, dizemos que a e b não são congruentes módulo

m e escrevemos a (cid:54)≡ b mod m.

Proposição 1 Seja m ∈ N. Para todos a, b, c ∈ Z, temos que

i) a ≡ a mod m;

ii) se a ≡ b mod m, então b ≡ a mod m;

iii) se a ≡ b mod m e b ≡ c mod m, então a ≡ c mod m.

Proposição 2 Suponha que a, b, m ∈ Z, com m > 1. Tem-se que a ≡ b mod m se, e

somente se, m|b − a.

Demonstração: Sejam a = mq + r, com 0 ≤ r < m e b = mt + s, com 0 ≤ s < m, as

divisões euclidianas respectivamente de a e b por m. Assim,

b − a = mt + s − mq − r = m(t − q) + (s − r).

Portanto, a ≡ b mod m se, e somente se, r = s, que é equivalente a dizer que m|b − a.

78

Temos ainda algumas propriedades adicionais:
Proposição 3 Sejam a, b ∈ Z e m, n, m1, m2, ...mr inteiros maiores que 1. Temos que:

i) se a ≡ b mod m e n|m então a ≡ b mod n;

ii) a ≡ b mod mi, para todo i = 1, 2, ..., r ⇔ a ≡ b mod [m1, m2, ..., mr];

Demonstração: i) Se a ≡ b mod m, então m|b − a. Como n|m, temos que n|b − a. Logo,

a ≡ b mod n.

ii) (⇒) Se a ≡ b mod mi, com i = 1, ..., r, então mi|b − a, para todo i. Desta forma,

temos que b − a é múltiplo de cada mi. Logo, [m1, ..., mr]|b − a, implicando que a ≡ b mod

mmc(m1, ..., mr). (⇐) Decorre do item i).

Da divisão euclidiana, temos que

O que equivale a dizer que

a = q.m + r com 0 ≤ r < m.

a ≡ r mod m.

Assim, todo inteiro positivo é congruente módulo m ao resto de sua divisão por m, que é um

número entre 0 e m − 1.

Se a ≡ r mod m e 0 ≤ r < m, dizemos que r é o resíduo de a módulo m.

No exemplo inicial, vimos que o resto da divisão de 34 por 5 é igual a 4, então, podemos

dizer que 34 ≡ 4 mod 5.

Proposição 4 Cada número tem apenas um resíduo módulo m.

Demonstração: De fato, se

a ≡ r mod m, com 0 ≤ r ≤ m − 1 e

a ≡ s mod m, com 0 ≤ s ≤ m − 1,

então, pela Proposição 1, temos que

r ≡ s mod m.

Sem perda de generalidade, seja r ≤ s. Pela Preposição 2 temos que m|s − r, mas r e s são

menores do que m, assim, 0 ≤ s − r < m. Implicando assim que s − r só pode ser múltiplo de m

se s − r = 0. Portanto os resíduos r e s são iguais.

79

A proposição a seguir mostra que a congruência, que é uma relação de equivalência, é

compatível com as operações de adição e multiplicação, tornando-a extremamente útil.

Proposição 5 Sejam a, b, c, d, m ∈ Z, com m > 1.

i) Se a ≡ b mod m e c ≡ d mod m, então a + c ≡ b + d mod m.

ii) Se a ≡ b mod m e c ≡ d mod m, então ac ≡ bd mod m.

Demonstração: Suponhamos que a ≡ b mod m e c ≡ d mod m. Assim, pela Proposição

2, temos que m|b − a e m|d − c.

i) Como m|b − a e m|d − c, temos que m|(b − a) + (d − c), ou seja, m|(b + d) − (a + c).

Portanto, a + c ≡ b + d mod m.

ii) Note que bd − ac = bd − ad + ad − ac = d(b − a) + a(d − c). Como m|b − a temos que

m|d(b − a). Da mesma forma, temos que m|a(d − c). Assim, m|d(b − a) + a(d − c), ou

seja m|bd − ac. Portanto, ac ≡ bd mod m.

Corolário 6 Sejam a, b, c, m ∈ Z, com m > 1. Temos que

a + c ≡ b + c mod m ⇔ a ≡ b mod m.

a.c ≡ b.c mod m ⇔ a ≡ b mod

m
(m, c)

.

Note que no item (ii) do corolário acima, se mdc(m, c) = 1, a ≡ b mod m.
Corolário 7 Para todo n ∈ N e a, b ∈ Z, se a ≡ b mod m, então tem-se que an ≡ bn mod

(i)

(ii)

m.

A demonstração pode ser feita por indução sobre n ou aplicando-se o segundo item da

proposição anterior.

Uma outra forma de enunciar o Pequeno Teorema de Fermat usando a notação de con-

80

gruência é:

Se p é um número primo e a ∈ Z, então

ap ≡ a mod p.

ap−1 ≡ 1 mod p.

Mais ainda, se p (cid:45) a, então

Teorema de Euler

O Teorema de Euler trata-se de uma generalização do Pequeno teorema de Fermat, visto

anteriormente.

Proposição 8 Sejam a, m ∈ Z, com m > 1. A congruência aX ≡ 1 mod m possui solução
se, e somente se, mdc(a, m) = 1. Além disso, se x0 ∈ Z é um solução, então x é uma solução da

congruência se, e somente se, x ≡ x0 mod m.

A demonstração dessa proposição pode ser encontrada em (HEFEZ, 2016), página 194.

Para enunciar e demonstrar o Teorema de Euler, precisamos entender o que é um sistema

completo de resíduo e um sistema reduzido de resíduo.

Vimos no início do capítulo que um resíduo é o resto da divisão de um inteiro positivo

por m, assim um sistema completo de resíduo módulo m é um conjunto de m inteiros que não

são dois a dois congruentes módulo m,

Exemplo 9 O sistema completo de resíduo módulo 5 é o conjunto R = {0, 1, 2, 3, 4}.

Podemos notar que os elementos do conjunto R podem ser trocados por outros que

deixem os mesmos restos. Como por exemplo {5, 6, 7, 8, 9}, ou ainda {12, 13, 14, 15, 16}. Per-

cebemos que qualquer conjunto formado por 5 inteiros consecutivos é um sistema completo de

resíduo módulo 5.

Generalizando, um conjunto de m inteiros consecutivos formam um sistema completo

de resíduos módulo m.

Um sistema reduzido de resíduos módulo m é o conjunto formado por todos os elementos

do sistema completo de resíduos que são primo com m.

81

Exemplo 10 Seja R = {0, 1, 2, ..., 19} um sistema completo de resíduos módulo 20.

Agora, para acharmos um sistema reduzido de resíduos, basta retirarmos os números que não

são primo com 20. Temos então que o conjunto R1 = {1, 3, 7, 9, 11, 13, 17, 19} é um sistema

reduzido de resíduos.

Deﬁnição 11 O número de elementos que um sistema reduzido de resíduos módulo m

possui, que será denotado por φ (m), é chamado função ﬁ de Euler.

Proposição 12 Seja r1, ..., rφ (m) um sistema reduzido de resíduos módulo m e seja a ∈ Z

tal que mdc(a, m) = 1. Então, ar1, ..., arφ (m) é um sistema reduzido de resíduos módulo m.

Demonstração: Seja a1, ..., am um sistema completo de resíduos módulo m do qual foi

retirado o sistema reduzido de resíduos r1, ..., rφ (m). Do fato de que mdc(a, m) = 1, tem-se que

mdc(ai, m) = 1 se, e somente se, mdc(aai, m) = 1, o resultado segue disso.

Agora, temos todos os pré-requisitos para enunciar e demonstrar o Teorema de Euler.
Teorema 13 Sejam a, m ∈ Z, com m > 1 e mdc(a, m) = 1. Então,

aφ (m) ≡ 1 mod m.

Demonstração: Seja {r1, r2, ..., rφ (m)} ⊂ {1, 2, 3, ..., m − 1} um sistema reduzido de re-

síduo. Pela Preposição 12, temos que {ar1, ar2, ..., arφ (m)} é outro sistema reduzido de resíduo.

Desta forma, temos que cada elemento de {ar1, ar2, ..., arφ (m)} é congruente a um, e apenas um,

elemento de {r1, r2, ..., rφ (m)}. Assim,

ar1.ar2. ... .arφ (m) ≡ r1.r2. ... .rφ (m) mod m,

ou seja,

aφ (m).(r1.r2. ... .rφ (m)) ≡ r1.r2. ... .rφ (m) mod m.

Como mdc(m, ri) = 1, pelo Corolário 6 item (ii) , temos que

aφ (m) ≡ 1 mod m.

82

Para usarmos o Teorema de Euler, precisamos calcular φ (m), o que muitas vezes é

algo extenso para se fazer usando o máximo divisor comum entre cada um dos restos com m.

Desta forma, a proposição a seguir nos auxiliará no cálculo de φ (m) para um número natural m

qualquer.

Proposição 14 Se p é um número primo e r um número natural então, tem-se que

φ (pr) = pr − pr−1 = pr−1.(p − 1).

Demonstração: Podemos perceber que do número 1 até pr temos pr números naturais.

Como vimos anteriormente, para encontrarmos os elementos do sistema reduzido de resíduos,

devemos retirar todos os números que não são primos com pr, ou seja, p, 2p, ..., pr−1 p, que são

ao todo pr−1 números. Portanto, φ (pr) = pr − pr−1.

Proposição 15 Sejam m, n ∈ N tais que mdc(m, n) = 1. Então

φ (m.n) = φ (m).φ (n).

Demonstração: Para m = 1 ou n = 1, o resultado segue de imediato. Suponhamos que

m > 1 e n > 1. Considere a seguinte tabela formada pelos números naturais de 1 a m.n:

1
n + 1
...
(m-1).n +1

2
n +2
...
(m-1).n +2

...
...
...
...

k
n +k
...

n
2n
...
(m-1).n +K ... m.n

...
...
...

Temos que mdc(t, m.n) = 1 se, e somente se, mdc(t, n) = mdc(t, m) = 1. Desta forma,

para calcular φ (m.n), devemos determinar quais inteiros na tabela são simultaneamente primos

com m e n.

Assim, se o primeiro elemento de uma coluna não for primo com n, então todos os

elementos da coluna não são primos com n. Portanto, os elementos primos com n estão neces-

sariamente nas colunas restantes que são em número φ (n), cujos elementos são primos com n,

como é fácil veriﬁcar.

83

Agora, veremos quais são os elementos primos com m em cada uma dessas colunas.

Como mdc(m, n) = 1, a sequência k, n + k, ..., (m − 1).n + k forma um sistema completo de

resíduos módulo m, pois tem m inteiros consecutivos. Assim, φ (m) desses elementos são primo

com m. Portanto, o número de elementos primos com m e n, ao mesmo tempo, é φ (m).φ (n).

Com as Proposições 14 e 15, podemos obter uma expressão para calcular φ (m) para

qualquer m ∈ N. Esse expressão é apresentada como o seguinte teorema:

Teorema 16 Seja m = p1

α1...pn

αn, com m> 1, a decomposição de m em fatores primos.

Então,

φ (m) = p1

α1−1...pn

αn−1.(p1 − 1)...(pn − 1).

A demonstração desse teorema segue direto das proposições citadas acima.

Exemplo 17 Calcular φ (20) pela expressão do teorema anterior.

Temos que

φ (20) = φ (22.5) = 21.50.(2 − 1).(5 − 1) = 2.1.1.4 = 8.

Exatamente como havíamos encontrado no Exemplo 10.

Inversos modulares

Observe as seguintes congruências.

3.5 ≡ 1 mod 7

4.7 ≡ 1 mod 9

Se utilizarmos a linguagem que usamos com os racionais, podemos dizer que 1 “divi-

dido“ por 3 módulo 7 tem como resultado o 5. O mesmo vale para a segunda congruência, 1

“dividido“ por 4 módulo 9, tem como resultado o número 7. Quando isso ocorre, dizemos que

3 e 5 são inversos módulo 7 e, no segundo caso, 4 e 7 são inversos módulo 9.

Sistematizando, a e a(cid:48) são inversos módulo n se

a.a(cid:48) ≡ 1 mod n.

84

Da mesma forma que a é inverso de a(cid:48), temos também que a(cid:48) é inverso de a.

Note que 0 não possui inverso para nenhum n, visto que 0.a ≡ 0 mod n, sendo a um

inteiro qualquer.

Será que, com exceção do 0, todo os números de 1 a n − 1 possuem inverso módulo n?

Abaixo encontramos os inverso dos números módulo 7 e os inversos módulo 10.

Inverso módulo 7
1
4
5
2
3
6

1
2
3
4
5
6

Tabela 1 – Tabela dos inversos módulo 7

Inverso módulo 10
1
-
7
-
-
-
3
-
9

1
2
3
4
5
6
7
8
9

Tabela 2 – Tabela dos inversos módulo 10

Os inversos nas tabelas foram determinados por tentativa. Ou seja, para acharmos o

inverso de 2 módulo 7, multiplicamos 2 pelos inteiros 2, 3 e 4, até que encontramos seu inverso,

o 4. O mesmo ﬁzemos com o 3, encontrando o 5. Para o número 4 e o 5 não foram necessárias

contas visto que eles já eram inversos do 2 e 3 respectivamente, desta forma o inverso do 4 é o

2 e o inverso do 5 é o 3. Faltando assim apenas o 6, cujo inverso é ele mesmo.

Note que os inversos também estão entre 1 e n−1, pois todo inteiro é congruente módulo

n ao seu resíduo. Note ainda que cada inteiro entre 1 e n−1 possui exatamente um inverso nesse

intervalo. A prova de tal aﬁrmação pode ser encontrada em (COUTINHO, 2016).

De forma análoga, ﬁzemos a tabela de inversos módulo 10. No entanto, veriﬁcamos que

alguns números não possuíam inversos.

85

O que nos retorna à pergunta inicial com uma reposta negativa e nos dá o seguinte

teorema:

Teorema 18 Dado a ∈ Z, temos que a possui inverso módulo m se, e somente se,

mdc(a, m) = 1.

A demonstração desse teorema segue direto da Proposição 8.

86

APÊNDICE B – LOGARITMO DISCRETO

Neste apêndice abordaremos alguns tópicos que serão necessários para compreensão da

Criptograﬁa ElGamal. Trabalharemos com Grupos e Logaritmos discretos.

Grupos

Um grupo é constituído por dois ingredientes básicos: um conjunto e uma operação

fechada deﬁnida neste conjunto. Digamos que o conjunto seja G e a operação seja ·. Por

operação fechada entendemos uma regra que a cada dois elementos a, b ∈ G associa um terceiro

elemento a · b que também está em G. Além do conjunto e da operação fechada, precisamos

que algumas condições sejam satisfeitas, como segue na deﬁnição:

Deﬁnição 1 Um conjunto G com uma operação

G × G → G

(a, b) (cid:26) a · b

é um grupo se as seguintes condições são satisfeitas:

i) A operação é associativa, isto é

a · (b · c) = (a · b) · c, para todo a, b, c ∈ G

ii) Existe um elemento neutro, isto é, existe e ∈ G tal que

a · e = e · a = a.

iii) Todo elemento possui um elemento inverso, isto é, para todo a ∈ G, existe b ∈ G tal que

a · b = b · a = e.

Vamos demonstrar agora que, tanto o elemento neutro, quando o elemento inverso, são

únicos.

Teorema 2 O elemento neutro é único.

Demonstração: Suponha que existam e, e(cid:48) ∈ G tais que ambos sejam elementos neutros

de G. Como e é um elemento neutro de G, temos que

e(cid:48) = e · e(cid:48).

87

Por outro lado, e(cid:48) também é elemento neutro de G, então

Assim,

e = e(cid:48) · e.

e = e(cid:48).

Portanto o elemento neutro é único.

Teorema 3 O elemento inverso de qualquer elemento de um grupo é único.

Demonstração: Suponhamos que existam b, c ∈ G tais que ambos são elementos in-

versos de a ∈ G. Usando as propriedades de grupo, temos:

b = e · b = (c · a) · b = c · (a · b) = c · e = c.

Portanto o elemento inverso de qualquer elemento de um grupo é único.

Exemplo 4

Sejam n > 1 um inteiro e ¯r = {kn + r |k ∈ Z, 0 ≤ r < n}. Considere o

conjunto

Zn = {1, 2, ..., n − 1},

e deﬁnindo a operação de adição sobre Zn como sendo

x + y = x + y = s,

sendo s o resto da divisão de x + y por n, temos que (Zn, +) é um grupo.

Exemplo 5 Seja n primo. Considerando o conjunto

Z∗

n = {1, 2, ..., n − 1}

e deﬁnindo a operação de multiplicação sobre Zn como sendo

x · y = x · y = s,

sendo s o resto da divisão de x · y por n, temos que (Zn, ·) é um grupo.

Deﬁnição 6 Seja G um conjunto munido com uma operação binária (a, b) (cid:26) a.b que

88

satisfaz as seguintes condições:

i) a · (b · c) = (a · b) · c, para todo a, b, c ∈ G

ii) Existe elemento neutro 1 ∈ G tal que

a · 1 = 1 · a = a.

iii) Todo elemento possui um elemento inverso, isto é, para todo a ∈ G, existe b ∈ G tal que

a · b = b · a = 1.

Então, dizemos que (G, .) é um grupo multiplicativo.

Subgrupos

Dado um grupo G, vamos estudar seus subconjuntos que com a operação herdada de G

também satisfazem as condições requeridas para ser um grupo. Esse subconjuntos são chama-

dos de subgrupo de G.

Deﬁnição 7 Seja (G, ·) um grupo. Um subconjunto não vazio H de G é um subgrupo

de G quando, com a operação de G, o conjunto H é um grupo, isto é, quando as seguinte

condições são satisfeitas:

i) h1 · h2 ∈ H, para todo h1, h2 ∈ H;

ii) h1 · (h2 · h3) = (h1 · h2) · h3, para todo h1, h2, h3 ∈ H;

iii) Existe e ∈ H tal que e · h = h · e = h, para todo h ∈ H;

iv) para cada h ∈ H existe h−1 ∈ H tal que h · h−1 = h−1 · h = e.

A primeira condição serve para que a operação (·) esteja bem deﬁnida em H, as demais

decorrem do fato de H ser grupo.

Deﬁnição 8 Dado a um elemento do grupo G, denotamos por < a > o conjunto de

todas as potências de a, ou seja,

< a > = {an : n ∈ Z},

sendo an = a.a. ... .a
(cid:125)
elemento neutro da operação do grupo.

, quando n > 0, an = a−1.a−1. ... .a−1
(cid:125)

(cid:123)(cid:122)
n vezes

(cid:123)(cid:122)
n vezes

(cid:124)

(cid:124)

89

, quando n < 0 e a0 = e, sendo e o

A deﬁnição acima faz com que < a > seja um subgrupo de G, algo que é facilmente

veriﬁcável.

Deﬁnição 9 O conjunto < a > é o subgrupo gerado por a. Chamamos a de gerador de

< a >.

Com isso, podemos deﬁnir grupos que podem ser gerados por um elemento.

Deﬁnição 10 Um grupo G é cíclico quando ele pode ser gerado por um elemento de G,

ou seja, existe g ∈ G tal que G =< g >.

O problema do Logaritmo Discreto

Começaremos relembrando a deﬁnição de logaritmo real. Dados dois números reais

positivos, a e b, com a > 0 e a (cid:54)= 1, devemos encontrar o único número real x, tal que

ax = b ⇔ loga b = x.

O logaritmo discreto possui uma deﬁnição análoga, porém necessitamos da congruência

módulo n.

Sejam (G, ·) um grupo multiplicativo e α, β ∈ G. Pretendemos encontrar um inteiro x

tal que

α x = β .

O inteiro x é denotado por logα β é chamado de logaritmo discreto de β .
p , p primo, e seja b um elemento não nulo de Z∗
Seja a um gerador de Z∗

p. O Problema

do Logaritmo Discreto consiste em encontrar um expoente x inteiro tal que,

ax ≡ b mod p.

Proposição 11 Se existir x ∈ Z tal que ax ≡ b mod p, então esta congruência possui

inﬁnitas soluções em Z.

Para evitar uma multiplicidade de soluções restringiremos o expoente x ao conjunto Zp
Proposição 12 Dado um inteiro ﬁxo a (cid:54)= 0, o problema do logaritmo discreto ax ≡
b mod p possui solução em Zp para qualquer b ∈ Zp com b (cid:54)≡ 0 mod p se, e somente se, a é
um gerador do grupo multiplicativo Z∗
p.

90

Demonstração: Considere que ax ≡ b mod p possui solução em Zp para todo inteiro
b. Ou seja, qualquer que seja b ∈ Zp, existe um x ∈ Zp tal que ax ≡ b mod p. Assim, a é gerador
de Z∗
p.

Agora, seja a um gerador de Z∗

p. Temos que cada elemento de Zp é congruente a alguma
potência de a. Portanto, para todo b ∈ Zp, existe x ∈ Zp tal que ax ≡ b mod p. Provando assim

que o problema do logaritmo discreto possui solução.

(cid:4)

Exemplo 13 Calcular x = log3 4 em Z5
Primeiro devemos veriﬁcar que 3 é um gerador do grupo multiplicativo Z∗

5. De fato,

pois todos os elementos de Z5

∗ são gerados por uma potência de 3:

30 = 1

31 = 3

32 = 4

33 = 2

34 = 1

Logo, pela proposição anterior, sabemos que o logaritmo possui solução. Temos que:

x = log3 4 ⇔ 3x ≡ 4 mod 5,

o que ocorre quando x = 2.

O exemplo dado é de fácil execução, porém, quando escolhemos convenientemente p e

a, principalmente p grande, a resolução torna-se mais difícil. Parte da segurança do Protocolo

Difﬁe-Hellman é baseada nesse fato.

