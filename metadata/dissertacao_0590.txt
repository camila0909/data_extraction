COLÉGIO PEDRO II

Pró-Reitoria de Pós-Graduação, Pesquisa, Extensão e Cultura
Mestrado Proﬁssional em Matemática em Rede Nacional

Leandro Jeferson Tôrres Ferreira

NÚMEROS
PRIMOS, CRIPTOGRAFIA RSA, PROBLEMAS DO MILÊNIO
E A SEGURANÇA DA INFORMAÇÃO

Rio de Janeiro

2020

Leandro Jeferson Tôrres Ferreira

NÚMEROS PRIMOS, CRIPTOGRAFIA RSA, PROBLEMAS DO MILÊNIO
E A SEGURANÇA DA INFORMAÇÃO

Dissertação de Mestrado apresentada ao
Programa de Mestrado Proﬁssional em
Matemática em Rede Nacional, vinculado
à Pró-Reitoria de Pós-Graduação, Pesquisa,
Extensão e Cultura do Colégio Pedro II, como
requisito parcial para obtenção do título de
Mestre em Matemática.

Orientadora: Drª. Luciana Santos da Silva Martino

Rio de Janeiro

2020

                                      COLÉGIO PEDRO II PRÓ-REITORIA DE PÓS-GRADUAÇÃO, PESQUISA, EXTENSÃO E CULTURA BIBLIOTECA PROFESSORA SILVIA BECHER CATALOGAÇÃO NA FONTE                    Ficha catalográfica elaborada pela Bibliotecária Simone Alves – CRB7 5692.   F383   Ferreira, Leandro Jeferson Tôrres       Números primos, criptografia RSA, problemas do milênio e a segurança da informação / Leandro Jeferson Tôrres Ferreira. – Rio de Janeiro, 2020.                  85 f.        Dissertação (Mestrado Profissional em Matemática em Rede Nacional) – Colégio Pedro II. Pró-Reitoria de Pós-Graduação, Pesquisa, Extensão e Cultura.   Orientador: Luciana Santos da Silva Martino.                                     1. Matemática – Estudo e ensino. 2. Números primos. 3. Criptografia.  4. Segurança da informação. I. Martino, Luciana Santos da Silva. II. Colégio Pedro II. III. Título.                                                                                                                                                                                                                    CDD 510                                                                                                                 Leandro Jeferson Tôrres Ferreira

NÚMEROS PRIMOS, CRIPTOGRAFIA RSA, PROBLEMAS DO MILÊNIO
E A SEGURANÇA DA INFORMAÇÃO

Dissertação de Mestrado apresentada ao
Programa de Mestrado Proﬁssional em
Matemática em Rede Nacional, vinculado
à Pró-Reitoria de Pós-Graduação, Pesquisa,
Extensão e Cultura do Colégio Pedro II, como
requisito parcial para obtenção do título de
Mestre em Matemática.

Aprovado em: ___/___/___.

Banca Examinadora:

Drª. Luciana Santos da Silva Martino
Colégio Pedro II

Drª. Maria de Lourdes Rocha de Assis Jean-
renaud
Colégio Pedro II

Drª. Cristiane Oliveira de Faria
Universidade do Estado do Rio de Janeiro

Rio de Janeiro
2020

Dedico, primeiramente, à Deus e à minha
linda família que tanto amo: Taís, Jacijane,
Laura e Felipe.

AGRADECIMENTOS

Agradeço primeiramente a Deus por mais esta conquista e por ser O Autor da

minha história.

Agradeço aos meus pais, Jacijane e Jessé (em memória), pelo incentivo que sempre
deram em minha jornada acadêmica e em toda a minha vida. Meus amores, muito obrigado.

À minha esposa, Taís, e à minha ﬁlha, Laura, a paciência e o amor que sempre me
dedicaram todos os dias, mesmo estando um pouco “ausente” devido aos meus estudos.
Amo vocês demais.

À minha professora orientadora, Luciana Martino, pela paciência e incentivo na

hora certa. Obrigado por sua dedicação.

Agradeço também aos colegas de minha turma.

Agradeço aos meus queridos professores do PROFMAT que me auxiliaram com
muito zelo e dedicação tornando essa jornada mais agradável. Em particular, agradeço
à professora Marilis Bahr Karam Venceslau, por todo auxílio, dedicação e carinho que
sempre demonstrou a mim e a meus colegas de curso.

O presente trabalho foi realizado com apoio da Coordenação de Aperfeiçoamento

de Pessoal de Nível Superior - Brasil (CAPES) - Código de Financiamento 001.

“Uma vez um matemático me falou que o verdadeiro prazer não está em achar a verdade,
mas em procurar por ela”.
(Leo Tolstoy)

RESUMO

FERREIRA, Leandro Jeferson Tôrres. Números primos, criptograﬁa RSA, problemas do
milênio e a segurança da informação. 2020. 85 f. Dissertação (Mestrado) – Colégio Pedro
II, Pró-Reitoria de Pós- Graduação, Pesquisa, Extensão e Cultura, Programa de Mestrado
Proﬁssional em Matemática em Rede Nacional, Rio de Janeiro, 2020.

Números Primos é um conceito fundamental dentro da Aritmética, porém, pouco explorado
no Ensino Básico. Muitas questões sobre estes números ainda encontram-se sem solução,
no entanto, estudos têm sido realizados na busca pelo conhecimento de conjecturas, como
a Hipótese de Riemann, um dos Problemas do Milênio, que apresenta relação direta com o
comportamento dos Números Primos e sua distribuição dentro dos Números Naturais. Uma
importante aplicação dos Números Primos é a Criptograﬁa RSA, considerada um método
seguro para troca de informações pela internet, incluindo transações bancárias, estratégias
militares e informações governamentais. Este estudo, inicialmente, aborda os conceitos
sobre os Números Inteiros e noções sobre Congruências Modulares que servem como base
teórica para os outros capítulos. Logo após são apresentados o conceito de Números Primos,
e também suas propriedades mais importantes e suas conjecturas em aberto. Em seguida,
é abordado o estudo sobre a Criptograﬁa, desde as técnicas mais primitivas até os estudos
mais recentes e a técnica da Criptograﬁa RSA e como sua base matemática a torna tão
segura. Por ﬁm, são apresentados dois Problemas do Milênio: A Hipótese de Riemann e
o Problema P = NP que, se demonstrados, inﬂuenciarão toda a segurança dos métodos
criptográﬁcos atuais e, consequentemente, a segurança das informações que transitam pela
rede mundial de computadores. Também são propostas atividades que têm, por ﬁnalidade,
estimular estudantes de 6º ao 9º anos do Ensino Fundamental e também do Ensino Médio
ao aprendizado dos Números Primos e suas aplicações.

Palavras-chave: Números Primos; Aritmética; Criptograﬁa RSA; Hipótese de Riemann;
Problemas do Milênio.

ABSTRACT

FERREIRA, Leandro Jeferson Tôrres. Números primos, criptograﬁa RSA, problemas do
milênio e a segurança da informação. 2020. 85 f. Dissertação (Mestrado) – Colégio Pedro
II, Pró-Reitoria de Pós- Graduação, Pesquisa, Extensão e Cultura, Programa de Mestrado
Proﬁssional em Matemática em Rede Nacional, Rio de Janeiro, 2020.

Prime Numbers is a fundamental concept within Arithmetic, however, little explored
in Basic Education. Many questions about these numbers are still unsolved, however,
studies have been carried out in the search for knowledge of conjectures, such as the
Riemann Hypothesis, one of the Millennium Problems, which is directly related to the
behavior of Prime Numbers and their distribution within Natural Numbers. An important
application of Prime Numbers is RSA Cryptography, considered a secure method for
exchanging information over the internet, including bank transactions, military strategies
and government information. This study initially addresses the concepts of Numbers
Integers and notions about Modular Congruences that serve as a theoretical basis for the
other chapters. Soon after, the concept of Prime numbers, as well as their most important
properties and their open conjectures. Then, the study on the Cryptography, from the
most primitive techniques to the most recent studies and the RSA Cryptography technique
and as its mathematical basis a makes it so safe. Finally, two Millennium Problems are
presented: The Riemann Hypothesis and the P = NP Problem which, if demonstrated,
inﬂuence the security of current cryptographic methods and, consequently, the security of
information world Wide Web. Activities are also proposed that aim to stimulate students
from the 6th to the 9th grade of Education Elementary and also from High School to the
learning of Prime Numbers and their applications.

Keywords: Prime numbers; Arithmetic; RSA encryption; Riemann Hypothesis; Millen-
nium Problems.

LISTA DE ILUSTRAÇÕES

Figura 1 – Reta Numérica em Z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
Figura 2 – Citale Espartano . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Figura 3 – Quadrado de Vigenère . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
Figura 4 – Máquina Enigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
Figura 5 – Ilustração do Código de Segurança - QR Code . . . . . . . . . . . . . . 64
Figura 6 – Gráﬁco do comportamento assintótico dominante da função f em relação

à p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

Figura 7 – Tempo de execução de algoritmos distintos em relação às suas classes

de complexidades . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

71
Figura 8 – Faces do Cubo de Vigenère
. . . . . . . . . . . . . . . . . . . . . . . . 76
Figura 9 – Face Frontal (verde) e Superior do Cubo de Vigenère . . . . . . . . . . 77
Figura 10 – Codiﬁcação da letra p . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
Figura 11 – Codiﬁcação da letra r
. . . . . . . . . . . . . . . . . . . . . . . . . . . 78
Figura 12 – Codiﬁcação da letra o . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
Figura 13 – Codiﬁcação da letra f . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
Figura 14 – Codiﬁcação da letra m . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
Figura 15 – Codiﬁcação da letra a . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
Figura 16 – Codiﬁcação da letra t . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
81
Figura 17 – Jogo completo com as 20 peças do Dominó de Goldbach . . . . . . . .
81
Figura 18 – Forma de jogo do Dominó de Goldbach . . . . . . . . . . . . . . . . . .

SUMÁRIO

INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12

NÚMEROS INTEIROS E CONGRUÊNCIAS . . . . . . . . . .
Números Inteiros - História e Deﬁnição . . . . . . . . . . . . . .
Propriedades da Adição e Multiplicação . . . . . . . . . . . . . . . . .
Outros resultados importantes . . . . . . . . . . . . . . . . . . . . . .
Divisibilidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Divisão Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Máximo Divisor Comum (MDC) . . . . . . . . . . . . . . . . . . . . .
Propriedades do MDC . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
Mínimo Múltiplo Comum (MMC)
Congruências
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Resolução de Congruências Lineares . . . . . . . . . . . . . . . . . . .

14
14

15
17
19

21
22
23
24
25

29

NÚMEROS PRIMOS . . . . . . . . . . . . . . . . . . . . . . . .
31
Números Primos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Pequeno Teorema de Fermat . . . . . . . . . . . . . . . . . . . . .
34
Pequeno Teorema de Fermat - Congruências
. . . . . . . . . . . . . .
Alguns resultados importantes sobre os Números Primos . . .
Teorema de Euclides . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Crivo de Eratóstenes
. . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Primos Gêmeos
Testes de Primalidade . . . . . . . . . . . . . . . . . . . . . . . . .
39
Teorema para caracterização de números primos
. . . . . . . . . . . .
39
Identidade de Sophie Germain . . . . . . . . . . . . . . . . . . . . . .
40
Teste de Primalidade de Fermat
. . . . . . . . . . . . . . . . . . . . .
Algoritmos de testes de primalidade . . . . . . . . . . . . . . . . . . .
41
Polinômio de Euler . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
42
Conjectura de Goldbach . . . . . . . . . . . . . . . . . . . . . . . .

35
36
38
39

35
35

CRIPTOGRAFIA E A SEGURANÇA DA INFORMAÇÃO:
DA ESTEGANOGRAFIA À CRIPTOGRAFIA RSA . . . . .
Exemplos de técnicas criptográﬁcas antigas

. . . . . . . . . . .
Citale espartano ou Bastão de Licurgo . . . . . . . . . . . . . . . . . .
Cifra de César . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Cifra de Vigenère

43
45

45
46
47

1

2
2.1

2.1.1
2.1.2
2.2

2.2.1
2.2.2
2.2.3
2.2.4
2.3

2.3.1

3
3.1
3.2

3.2.1
3.3

3.3.1
3.3.2
3.3.3
3.4

3.4.1
3.4.2
3.4.3
3.4.4
3.5
3.6

4

4.1

4.1.1
4.1.2
4.1.3

4.1.4
4.2

4.2.1
4.2.2
4.3

4.3.1
4.4

4.4.1
4.4.2
4.4.3
4.5

4.5.1
4.5.2

5
5.1

5.1.1
5.1.2
5.1.3
5.2

5.2.1
5.2.2
5.2.3
5.2.4
5.3

6
6.1

6.1.1
6.1.2
6.2

6.2.1
6.2.2
6.2.3

49
50

Enigma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
História da Criptograﬁa RSA . . . . . . . . . . . . . . . . . . . .
Algoritmo DHM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Rivest, Shamir e Adleman . . . . . . . . . . . . . . . . . . . . . . . .
Método de Criptograﬁa RSA . . . . . . . . . . . . . . . . . . . .
Análise Matemática do Método RSA . . . . . . . . . . . . . . . . . . .
Exemplo de codiﬁcação de uma mensagem . . . . . . . . . . . .
57
Pré-Codiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
Codiﬁcação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Decodiﬁcação
59
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Segurança do Método RSA e a Segurança da Informação . . . . 61
61
Segurança do Método RSA . . . . . . . . . . . . . . . . . . . . . . . .
62
Segurança da Informação no cotidiano . . . . . . . . . . . . . . . . . .

51
53
54

55
57

A HIPÓTESE DE RIEMANN E PROBLEMAS P VS NP . .
Hipótese de Riemann . . . . . . . . . . . . . . . . . . . . . . . . .
Bernoulli e Euler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conjectura de Gauss (Teorema dos Números Primos)
. . . . . . . . .
Bernhard Riemann . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Problemas P vs NP . . . . . . . . . . . . . . . . . . . . . . . . . .
Deﬁnições importantes
. . . . . . . . . . . . . . . . . . . . . . . . . .
Tempo Polinomial
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Problemas P e NP . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Problema do Milênio P = NP? . . . . . . . . . . . . . . . . . . . . . .
Os Problemas do Milênio e a Criptograﬁa RSA . . . . . . . . .

65
65

65
66
67
68

68
69
71
72
72

ATIVIDADES . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Detalhamento das atividades . . . . . . . . . . . . . . . . . . . . .
76
Cubo de Vigenère . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Dominó de Goldbach . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
Lista de Atividades . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
81
Atividade do Dominó de Goldbach . . . . . . . . . . . . . . . . . . . .
82
Atividade do Cubo de Vigenère . . . . . . . . . . . . . . . . . . . . . .
82
Avaliação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

74
75

7

CONCLUSÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

84

REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . .

85

1 INTRODUÇÃO

12

A Matemática é uma ciência muito rica em seu conteúdo e, principalmente, em suas
aplicações. No entanto, no Ensino Básico, não é incomum que um professor de Matemática
seja interpelado por um estudante sobre quais são as aplicações de um determinado
conceito em seu cotidiano ou qual a necessidade do aprendizado de determinado assunto
relacionado à Matemática. Estes casos são decorrentes de um currículo básico escolar
de Matemática sem conexão com a realidade do estudante e sem motivação para o
aprendizado. O indivíduo, em geral, procura aprender algo que seja importante, utilizável
ou mesmo curioso. Qualidades que não são mais reconhecidas pela maioria de nossos jovens
e adolescentes na Matemática.

Analisando este cenário de nosso Ensino Básico e reﬂetindo acerca de conteúdos
pouco explorados em nosso currículo escolar, destacamos os Números Primos. Neste caso
especíﬁco, na maior parte das vezes o conteúdo abordado ﬁca restrito à deﬁnição inicial
de Número Primo e à decomposição de números naturais em fatores primos. Não são
consideradas suas principais propriedades e curiosidades.

Sobre os Números Primos existem diversas conjecturas que poderiam estimular a
curiosidade de um estudante por seu estudo. Por outro lado, estes números servem de base
para diversas aplicações como a criptograﬁa moderna, e que fazem parte do cotidiano de
toda população mundial. Exemplo de tais aplicações se encontram na troca de e-mails,
transações bancárias e no sigilos de conversas por aplicativos de mensagens, entre outras.

Assim, temos como objetivo nesta pesquisa, estimular nosso aluno do Ensino Básico
ao estudo da Matemática por meio do conhecimento de propriedades, curiosidades e
aplicações dos Números Primos. Vale ainda ressaltar nesta pesquisa, a importância dos
Problemas do Milênio e como se relacionam com a criptograﬁa RSA e os Números Primos.

Esta pesquisa é composta por sete capítulos, dos quais o primeiro está desenvolvido
neste texto introdutório. No segundo capítulo, abordamos os conceitos e propriedades dos
Números Inteiros e Congruência Modular, assuntos estes que são a base para resultados
mais complexos sobre os Números Primos e sobre os cálculos da criptograﬁa RSA. O
terceiro capítulo é dedicado aos Números Primos: deﬁnição, principais propriedades e
conjecturas em aberto. No quarto capítulo é desenvolvido o tema sobre a criptograﬁa,
desde a técnica esteganográﬁca até a criptograﬁa RSA, e quais as implicações desta última
na segurança da informação. No quinto capítulo apresentamos a Hipótese de Riemann e o
problema P = N P , destacando sua relação com os Números Primos e sua importância
para a segurança da informação. Vale ressaltar que a leitura deste capítulo, em questão,
independe dos capítulos anteriores. No sexto capítulo, são listadas atividades que podem

ser implementadas em tempo apropriado com estudantes do Ensino Básico para estimular
o estudo e aprendizagem da Matemática. Foram elaborados dois produtos pedagógicos:
Cubo de Vigenère e Dominó de Goldbach para serem aplicados em sala de aula. No último
capítulo, são realizadas as considerações ﬁnais desta pesquisa.

13

2 NÚMEROS INTEIROS E CONGRUÊNCIAS

14

Este capítulo inicial visa a construir uma base teórica em que todo o trabalho
esteja sustentado. O conteúdo sobre Números Inteiros é a parte da Aritmética em que são
baseados os conceitos de Número Primo e de Congruência Modular, princípios matemáticos
da Criptograﬁa RSA, a ser melhor formulada nos próximos capítulos.

2.1 Números Inteiros - História e Deﬁnição

Os Números Inteiros e suas propriedades formam os pilares para o estudo da
Aritmética. Atualmente, o conceito de Número Inteiro se apoia em estudos que envolvem
estruturas algébricas como Grupos e Anéis, o que pode ser visto em (CIPRIANO, 2016).

No entanto, nem sempre o conceito geral sobre tais números foi considerado aceito
em termos formais. Na Antiguidade não há registros sobre o uso de números negativos pelos
povos egípcios, gregos ou babilônicos (EVES, 2004). O mais antigo relato foi encontrado
na China, entre o décimo e o segundo séculos de nossa Era, sendo utilizados na resolução
de alguns problemas cotidianos.

Ao longo da história, diversos matemáticos estudaram os números negativos isolada-
mente ou como parte de outros estudos. Porém, em sua grande maioria, estes matemáticos,
até o século XVII, consideravam os números negativos como “erros” ou raízes falsas de
certas equações, como o matemático francês René Descartes (1596 − 1650), na obra La
Géométrie, publicada em 1637.

A obra Tratado da Álgebra, do matemático Colin MacLaurin (1698−1746), publicada
postumamente em 1748, teve um papel fundamental ao considerar a importância dos
números negativos e dar os primeiros passos para um conceito matemático mais formal
sobre os Números Inteiros (BOYER, 2012).

O grande matemático Augustin-Louis Cauchy (1789 − 1857) estudou os números
negativos e se tornou o responsável pela deﬁnição de quantidades negativas que, segundo ele,
seriam grandezas que diminuem, representadas pelo sinal (-), a deﬁnição de Cauchy trazia
uma ambiguidade em relação aos números inteiros, quanto aos sentidos: operatórios (somar
ou diminuir) e predicativos (positivo ou negativo). Posteriormente, chegou à conclusão que
esta deﬁnição não era correta. Cauchy foi responsável por formalizar as quatro operações
básicas utilizando números positivos e negativos.

Outra notável contribuição foi apresentada por Richard Dedekind (1831 − 1916),
que estabeleceu uma relação de equivalência entre pares de números naturais, mostrando
a subtração como operação inversa da adição.

15

Deve-se à Hermann Hankel (1839 − 1873) a formulação de princípios e critérios que
nortearam a compreensão sobre os números inteiros, em sua publicação Teoria do Sistema
dos Números Complexos, de 1867 (EVES, 2004).

Outra deﬁnição importante foi a do número zero. Os indianos foram os primeiros a
considerarem o zero no seu sistema numérico posicional, entre os séculos III e IV de nossa
Era. O zero era chamado de sünya, que signiﬁca “vazio” (PADRÃO, 2008).

Finalmente, deﬁne-se o conjunto dos Números Inteiros, simbolizado pela letra Z (z
de zahlen, “número” em alemão), como sendo o conjunto dos números positivos e negativos
e o número zero:

Z = {..., −3, −2, −1, 0, 1, 2, 3, ...}

Geometricamente, cada número inteiro pode ser associado a um ponto da reta

numerada da Figura 1.

Figura 1 – Reta Numérica em Z

Fonte: O autor, 2020

Dentre os seus subconjuntos mais notáveis temos o conjunto dos Números Naturais

N = {1, 2, 3, 4, ...}.

2.1.1 Propriedades da Adição e Multiplicação

No conjunto dos Números Inteiros as operações de adição e multiplicação, entre
a e b, são deﬁnidas da seguinte forma: (a, b) 7−→ a + b ∈ Z e (a, b) 7−→ a · b = ab ∈ Z. A
seguir serão exibidos um conjunto de axiomas que caracterizam o conjunto dos Números
Inteiros (HEFEZ, 2016):

a. As operações de adição e multiplicação são bem deﬁnidas

∀a, b, a0, b0 ∈ Z, a = a0 e b = b0 ⇒ a + b = a0 + b0 e a · b = a0 · b0

b. Fechamento dos Números Inteiros em relação às operações de adição e multiplicação.

O conjunto dos Números Inteiros é fechado em relação às operações de adição e
multiplicação, isto é, ∀a, b ∈ Z, a + b ∈ Z e ab ∈ Z

c. Comutatividade

∀a, b ∈ Z, a + b = b + a e ab = ba

16

d. Associatividade

∀a, b, c ∈ Z, (a + b) + c = a + (b + c) e (a · b) · c = a · (b · c)

e. Elemento Neutro

∀a ∈ Z, a + 0 = a e a · 1 = a

f. Elemento Simétrico da adição

∀a ∈ Z, ∃b = −a tal que a + b = 0

g. Multiplicação distributiva em relação à adição

∀a, b, c ∈ Z, a · (b + c) = a · b + a · c

Essas primeiras propriedades caracterizam o conjunto dos Números Inteiros como

um anel comutativo com unidade.

Pela deﬁnição de número inteiro, Z = N ∪ {0} ∪ (−N), onde −N é o conjunto que

representa os elementos simétricos (ou opostos) em Z.

Outra deﬁnição importante é a de módulo de um número inteiro n (ou valor

absoluto):

|n| =






se n ≥ 0
n,
−n, se n < 0

Dois inteiros distintos que possuem o mesmo módulo são simétricos (ou opostos) entre si.

A seguir serão exibidas propriedades que se referem à ordenação dos Números

Inteiros:

h. Tricotomia.

Sejam a, b ∈ Z, uma e somente uma das aﬁrmações é veriﬁcada:

• a = b

• b − a ∈ N, isto é, a < b. Denomina-se a diferença entre b e a como b − a.
Consequentemente, deﬁne-se a subtração entre b e a, como a soma entre b e o
simétrico de a.

• −(b − a) = a − b ∈ N, isto é, b < a

i. Princípio da Boa Ordenação.

O princípio da Boa Ordenação em Z pode ser enunciado da seguinte forma:

Seja A um subconjunto não vazio de Z limitado inferiormente. Então A possui um
menor elemento.

17

O conjunto A ⊂ Z é limitado inferiormente se existe b ∈ Z tal que b ≤ x, ∀x ∈ A, ou
seja, b é cota inferior de A. Dizemos que a ∈ A é o menor elemento de A, se a ≤ x,
∀x ∈ A, sendo a a maior das cotas inferiores.

2.1.2 Outros resultados importantes

Serão exibidos, em seguida, outros resultados importantes que servirão como base

para o estudo das congruências.

Teorema 2.1.1. ∀a ∈ Z, a · 0 = 0

Demonstração. Utilizando as propriedades anteriores:

a · 0 = a · (0 + 0) = a · 0 + a · 0

Somando −(a · 0) aos dois membros da igualdade, teremos: −a · 0 + a · 0 =

−(a · 0) + (a · 0 + a · 0) =⇒ 0 = (−a · 0 + a · 0) + a · 0 =⇒ 0 = 0 + a · 0 =⇒ 0 = a · 0, ∀a ∈ Z

Teorema 2.1.2. ∀a, b, c ∈ Z, a = b ⇔ a + c = b + c

Demonstração. (⇒) a = b ⇒ a + c = b + c pois a operação de adição é bem deﬁnida em Z

(⇐) a + c = b + c, somando (−c) em ambos os membros da igualdade:

(a + c) + (−c) = (b + c) + (−c) =⇒ a + (c − c) = b + (c − c) =⇒ a + 0 = b + 0 =⇒

a = b

Teorema 2.1.3. ∀a, b, c ∈ Z, a < b e b < c ⇒ a < c

Demonstração. Seja a < b e b < c, temos que b − a ∈ N ⊂ Z e c − b ∈ N ⊂ Z

Logo, pela propriedade do fechamento:

(b−a)+(c−b) ∈ N ⊂ Z, logo b−a+c−b = b−b−a+c = c−a+0 = c−a ∈ N ⊂ Z

Portanto, a < c

Teorema 2.1.4. ∀a, b, c ∈ Z, a < b ⇔ a + c < b + c

Demonstração. (⇒) Se a < b =⇒ b − a ∈ N ⊂ Z

Logo, b − a = b − a + 0 = b − a + c − c = (b + c) − (a + c) ∈ N ⊂ Z

Portanto, a + c < b + c

(⇐) Supondo a + c < b + c, somando-se −c em ambos os membros da desigualdade

temos a < b

18

Teorema 2.1.5. ∀a, b ∈ Z, ∀c ∈ N, a < b ⇔ ac < bc

Demonstração. (⇒) Seja a < b =⇒ b − a ∈ N. Como N é fechado com relação à multipli-
cação, então (b − a) · c = bc − ac ∈ N. Logo, ac < bc.

(⇐) Reciprocamente, se ac < bc, com c ∈ N. Então, bc − ac > 0 =⇒ (b − a) · c > 0,

como c > 0, logo b − a > 0 =⇒ a < b.

Teorema 2.1.6. ∀a, b ∈ Z, ∀c ∈ Z − {0}, a = b ⇔ ac = bc

Demonstração. (⇒) Supondo a, b ∈ Z e c ∈ Z, a = b =⇒ ac = bc, a aﬁrmação é válida
pelo fato da operação de multiplicação ser bem deﬁnida em Z.

(⇐) Se ac = bc, então ac − bc = 0 =⇒ (a − b) · c = 0, como c 6= 0, então, a − b = 0.

Logo, a = b.

Teorema 2.1.7. Seja a, b ∈ Z, se ab = 0 então a = 0 ou b = 0

Demonstração. Supondo a 6= 0, então, como, por hipótese, ab = 0 e como, pelo Teo-
rema 2.1.1, dado a ∈ Z∗, a · 0 = 0. tem-se ab = 0 = a · 0, portanto, pelo Teorema 2.1.6,
b = 0.

O Teorema 2.1.7 implica no conjunto dos Números Inteiros ser um domínio de
integridade. As estruturas matemáticas que são domínio de integridade não apresentam
elementos denominados divisores de zero, ou seja, no caso dos inteiros, não existe nenhum
produto entre fatores inteiros, todos não nulos, que resulte em zero.

Outro resultado importante sobre Números Inteiros é o seguinte:

Teorema 2.1.8. Propriedade Arquimediana

Dados a, b ∈ Z, com b 6= 0, então existe n ∈ Z tal que a < nb.

Demonstração. Seja a ∈ Z, como a ≤ |a|. Sendo b 6= 0, então, |b| ≥ 1. Portanto,

a ≤ |a| < |a| + 1 ≤ |b| · (|a| + 1)

(2.1)

Se da desigualdade 2.1 tomarmos b positivo e n = (|a| + 1), ou ainda, se tomarmos b < 0 e
n = −(|a| + 1). Logo, tem-se:

a ≤ nb =⇒ a < nb

19

2.2 Divisibilidade

Deﬁnição 2.2.1. Deﬁne-se divisibilidade em Z, da seguinte forma:

Dados a, b ∈ Z diz-se que a | b se ∃c ∈ Z tal que b = c · a

a | b signiﬁca que a divide b ou que b é divisível por a, ou então, a é divisor de b. Portanto,
sua negação é a (cid:45) b, que signiﬁca que, para todo c em Z, ocorre que b 6= c · a.

Teorema 2.2.1. Sejam a, b, c ∈ Z, logo:

i. 1 | a, a | a e a | 0

ii. 0 | a ⇔ a = 0

iii. a | b ⇔ |a| | |b|

iv. a | b e b | c ⇒ a | c

Demonstração.

i. a = a · 1, então 1 | a

a = 1 · a, então a | a
0 = 0 · a, então a | 0

ii. (⇒) Se 0 | a, então ∃c ∈ Z, tal que a = c · 0 = 0

(⇐) Se a = 0, então a = 0 = c · 0, ∀c ∈ Z, então, a = c · 0, logo 0 | a

iii. (⇒) Se a | b, então ∃c ∈ Z tal que b = c · a ⇒ |b| = |c · a| = |c| · |a|, logo |a| | |b|

(⇐) Se |a| | |b|, então ∃c ∈ Z, tal que |b| = c · |a|. Portanto, temos alguns casos a
considerar:

a. Para a = 0

a = 0 ⇒ |b| = c · 0 = 0, logo a | b

b. Para a 6= 0 e b = 0, temos:

b = 0 ⇒ 0 = c · |a|, sendo c = 0, a | 0 ⇒ a | b

c. Para a e b 6= 0

• a > 0 e b > 0 ⇒ b = c · a ⇒ a | b

• a < 0 e b < 0 ⇒ −b = c · (−a) ⇒ (−b) · (−1) = c · (−a) · (−1) ⇒ b =

c · a ⇒ a | b

• a > 0 e b < 0 ⇒ −b = c · a ⇒ a | −b ⇒ a | b

• a < 0 e b > 0 ⇒ b = c · (−a) ⇒ −a | b ⇒ a | b

iv. Se a | b e b | c então ∃m, n ∈ Z tais que b = a · m e c = b · n. Portanto, c = b · n =

(a · m) · n. Pela propriedade associativa, c = a · (m · n), então, a | c.

20

Teorema 2.2.2. Se a, b, c, d ∈ Z, a | b e c | d ⇒ ac | bd

Demonstração. Se a | b e c | d então ∃m, n ∈ Z tais que b = am e d = cn. Portanto,
bd = (am) · (cn) = (ac) · (mn). Logo, ac | bd

Teorema 2.2.3. Se a, b, c ∈ Z, a | b ⇒ a | bc

Demonstração. Se a | b então ∃n ∈ Z tal que b = an, logo, bc = (an) · c = a · (nc), portanto,
a | bc

Teorema 2.2.4. Sejam a, b, c ∈ Z, tais que a | (b ± c). Então:

a | b ⇔ a | c

Demonstração. (⇒) Sejam a, b, c ∈ Z tais que a | (b + c) e a | b. Logo, ∃m, n ∈ Z tais que
b + c = am e b = an.

Portanto, b + c = an + c = am ⇒ c = am − an ⇒ c = a · (m − n) ⇒ a | c

(⇐) O raciocínio é análogo.

O resultado é demonstrado, de forma análoga, para a | (b − c).

Teorema 2.2.5. Se a, b, c ∈ Z são tais que a | b e a | c, então para todo x, y ∈ Z:

a | (xb + yc)

Demonstração. Se a | b e a | c, então ∃m, n ∈ Z tais que b = am e c = an. Logo,
xb + yc = x · (am) + y · (an) = a · (xm) + a · (yn) = a · (xm + yn) ⇒ a | xb + yc,
∀x, y ∈ Z

Teorema 2.2.6. Sejam a, b ∈ Z e n ∈ N, então a − b | an − bn

Demonstração. Usando Indução em n ∈ N: Para n = 1, têm-se que a aﬁrmação é válida,
pois a − b | a1 − b1. Suponha então que a − b | an − bn, para algum n ∈ N.
Assim, sendo an+1 − bn+1 = aan − ban + ban − bbn = (a − b) · an + b · (an − bn)

Como a − b | (a − b) · an e, pela hipótese de Indução a − b | an − bn, então,

a − b | an+1 − bn+1.

21

2.2.1 Divisão Euclidiana

A Divisão Euclidiana refere-se ao fato que nem sempre existirá c ∈ Z, tal que
a = b · c, ou seja, b pode não ser um divisor de a, o que signiﬁca que a divisão de a por
b 6= 0 não é inteira e deixa um resto r com r ∈ Z.

Teorema 2.2.7. Sejam a e b dois números inteiros com b 6= 0. Existem dois únicos
números inteiros q e r tais que:

a = bq + r, com 0 ≤ r < |b|

Demonstração. Consideremos o conjunto S como sendo a interseção

{x = a − by; y ∈ Z} \(N [{0}).

Primeiramente, provando a Existência:

Pela Propriedade Arquimediana (Teorema 2.1.8), ∃n ∈ Z tal que n · (−b) > −a,
logo a − nb > 0, então S não é vazio. Por outro lado, o conjunto S é limitado inferiormente
por 0 e portanto, pelo Princípio da Boa Ordenação, S possui um menor elemento r.

Supondo então r = a − bq com q ∈ Z, existe w ∈ N S{0} tal que r = |b| + w,
logo 0 (cid:54) w < r. Porém, isto contradiz o fato de ser r o menor elemento de S, pois
w = a − (q ± 1) · b ∈ S, com w < r.

Provando a Unicidade do quociente e do resto:

Supondo que dados a, b ∈ Z tem-se a = bq + r, com 0 (cid:54) r < |b| e a = bq0 + r0, com

0 (cid:54) r0 < |b|, r (cid:62) r0 e q (cid:62) q0. Têm-se:

a = bq + r ⇒ r = a − bq

a = bq0 + r0 ⇒ r0 = a − bq0

(2.2)

(2.3)

Subtraindo a Equação 2.3 da Equação 2.2:

r − r0 = b · (q0 − q)

Sendo r (cid:62) r0 então r − r0 (cid:62) 0. Como r < |b| e r0 < |b| tem-se que 0 (cid:54) r − r0 < |b|.

Logo 0 (cid:54) b · (q0 − q) < |b|.

Sendo b, q0 e q ∈ Z, então a desigualdade acima só se veriﬁca se q0 − q = 0 ⇒ q0 = q.

Logo, r − r0 = b · (q0 − q) = 0, portanto, r = r0.

22

Algumas observações podem ser feitas sobre o Teorema 2.2.7.

Primeiramente, é que para todo número inteiro n têm-se duas possibilidades: ou

este é par, ou é ímpar.

Caso n seja par, este será da forma 2q, com q ∈ N, quando sua divisão por 2 deixar
resto igual a zero. E será da forma n = 2q + 1, se na divisão de n por 2, este deixar resto
igual a 1.

Como na divisão de n por 2, os possíveis restos pertencem ao conjunto {0, 1},

pode-se garantir que todo inteiro ou será par ou ímpar.

Outra importante observação é que todo inteiro n pode ser escrito na forma
n = t · k + r, onde t ∈ N, t (cid:62) 2 e k, r ∈ Z, sendo 0 (cid:54) r < t. Por exemplo, todo n ∈ Z pode
ser escrito em uma, e somente uma das formas 4k, 4k + 1, 4k + 2 ou 4k + 3, quando t = 4.

2.2.2 Máximo Divisor Comum (MDC)

Dados a, b ∈ Z se d | a e d | b, com d ∈ Z, então d será considerado divisor comum

de a e b.

Deﬁnição 2.2.2. Para que d (cid:62) 0 seja o máximo divisor comum (mdc) de a e b é preciso
atender às seguintes propriedades:

i. d é um divisor comum de a e b;

ii. d é divisível por todo divisor comum de a e b, ou seja, se c ∈ Z é um divisor comum

de a e b, então c | d.

A notação que adotaremos para exibir o mdc entre a e b será d = (a, b).

Através da deﬁnição de mdc podemos listar algumas propriedades para a ∈ Z.

• (0, a) = |a|

• (1, a) = 1

• (a, a) = |a|

Mas ainda chega-se à conclusão que ∀b ∈ Z, têm-se que:

a | b ⇔ (a, b) = |a|

Demonstração. (⇒) Se a | b então |a| é um divisor comum de a e b e se c é um divisor
comum de a e b, então c | |a|, portanto, (a, b) = |a|

(⇐) Se (a, b) = |a|, segue, então que |a| | b, logo a | b

23

2.2.3 Propriedades do MDC

Teorema 2.2.8. Teorema de Bezóut

Sejam a, b ∈ Z, não ambos nulos, e d ∈ Z com d = (a, b). Então, existem x, y ∈ Z

tais que ax + by = d.

Demonstração. Sejam a, b ∈ Z, com b 6= 0, considere o conjunto I(a, b) = {ax + by; x, y ∈
Z}. Tome um inteiro positivo em I(a, b). Logo, |b| ∈ I(a, b). Seja d = ax0 + by0 o menor
inteiro positivo em I(a, b).

Dado n = ax1 + by1 ∈ I(a, b), sejam q e r ∈ Z tais que n = qd + r, com 0 (cid:54) r < d.
Têm-se, então que, n − qd = a · (x1 − qx0) + b · (y1 − qy0) = r ∈ I(a, b). Dessa forma, como
d é o menor inteiro positivo em I(a, b), então r = 0. Assim d | n, ∀n ∈ I(a, b).

Sendo a, b ∈ I(a, b), basta escolher (x, y) = (1, 0) e (x, y) = (0, 1), respectivamente,

temos que d | a e d | b. Logo, d (cid:54) (a, b).

Por outro lado, (a, b) divide a e b, de modo que, (a, b) divide d. Portanto, (a, b) (cid:54) d.

Consequentemente, d = (a, b).

Lema 2.2.9. Lema de Gauss

Sejam a, b, c ∈ Z. Se a | bc e (a, b) = 1, então a | c.

Demonstração. Se a | bc, então bc = at, t ∈ Z e, se (a, b) = 1, pelo Teorema 3.1.5,
∃m, n ∈ Z, tais que ma + nb = 1. Multiplicando por c, temos (ma) · c + (nb) · c = c ⇒
a · (mc) + n · (bc) = c ⇒ a · (mc) + n · (at) = c ⇒ a · (mc) + a · (nt) = c ⇒ a · (mc + nt) =
c ⇒ a | c.

Teorema 2.2.10. ∀a, b ∈ Z, não ambos nulos, e n ∈ N tem-se que

(na, nb) = n · (a, b)

Demonstração. Sejam k = (na, nb) e t = (a, b). Como t | a e t | b então nt | na e nt | nb,
portanto nt (cid:54) k, pois k = (na, nb).

Por outro lado, pelo Teorema 2.2.8, existem x e y inteiros tais que ax + by = t. Mul-
tiplicando essa igualdade por n, temos nax + nby = nt, logo k (cid:54) nt, pois é o menor número
que pode ser escrito como essa soma. Então, k = nt, concluindo que (na, nb) = n · (a, b).

24

Outra proposição importante é a seguinte:

Teorema 2.2.11. Sejam a, b ∈ N, com (a, b) = 1. Todo número c ∈ Z pode ser escrito de
modo único da seguinte forma:

c = ma + nb, com 0 (cid:54) m < b e n ∈ Z

Demonstração. Existência: Existem u, v ∈ Z tais que ua + vb = (a, b) = 1. Multiplicando
por c, tem-se:

auc + bvc = c

(2.4)

Pela Divisão Euclidiana, tem-se que ∃q, m ∈ Z com 0 (cid:54) m < b tais que uc = qb + m.

Substituindo esse valor de uc na Equação 2.4, obtêm-se:

a · (qb + m) + bvc = c =⇒ aqb + am + bvc = c =⇒ am + b · (qa + vc) = c

Logo,

c = ma + nb, com 0 (cid:54) m < b e n = qa + vc ∈ Z

Unicidade: Suponha que existam 0 (cid:54) m, m0 < b e que ma + nb = m0a + n0b =⇒

(m − m0) · a = (n0 − n) · b, com

|m − m0| < b

Por outro lado, por hipótese, b | (m − m0) · a, como (a, b) = 1, então,

b | m − m0

(2.5)

(2.6)

Portanto, da Equação 2.5 e Equação 2.6, tem-se que m = m0 e em tal caso,

n = n0.

2.2.4 Mínimo Múltiplo Comum (MMC)

Deﬁnição 2.2.3. Um inteiro é chamado múltiplo comum de a, b ∈ Z, se for múltiplo
simultaneamente de ambos.

Têm-se que m ∈ Z, m (cid:62) 0 é o mínimo múltiplo comum (MMC) de a e b, simbolizado

por m = [a, b], se:

i. m é múltiplo comum de a e b; e

ii. Se n é múltiplo comum de a e b, então m | n.

25

2.3 Congruências

Esta seção aborda a deﬁnição de um conceito matemático muito importante que é

o de congruências. Este relaciona-se à estrutura da Criptograﬁa RSA.

Deﬁnição 2.3.1. Dados a, b, m ∈ Z e m > 1, têm-se que a e b são congruentes módulo m,
se os restos das divisões de a e b por m forem iguais.

a ≡ b mod m

Exemplo.

i. 15 ≡ 3 mod 4, signiﬁca que 15 é congruente a 3 módulo 4, ou seja, 15 e 3

deixam o mesmo resto na divisão por 4.

ii. 8 6≡ 1 mod 5, signiﬁca que, 8 é incongruente a 1 módulo 5. Pois, 8 e 1 deixam restos

distintos quando divididos por 5.

Outra forma de deﬁnir a congruência entre dois inteiros módulo m é:

Teorema 2.3.1. Dado a, b, m ∈ Z, m > 1. Tem-se a ≡ b mod m se, e somente se,
m | b − a.

Demonstração. (⇒) Se a ≡ b mod m, então a = mk + r e b = mt + r. Logo, b − a =
(mt + r) − (mk + r) = m(t − k). Portanto, m | b − a.

(⇐) Sejam as divisões euclidianas de a e b por m:

a = mk1 + r1, com 0 ≤ r1 < m e b = mk2 + r2, com 0 ≤ r2 < m.

Como m | b − a, então m | (mk2 + r2) − (mk1 + r1), logo m | m(k2 − k1) + (r2 − r1),
tem-se que m | m(k2 −k1), portanto, para que m | m(k2 −k1)+(r2 −r1), então m | (r2 −r1).
No entanto, como r1 e r2 são estritamente menores que m, logo r2 − r1 = 0 ⇒ r1 = r2, ou
seja, a ≡ b mod m.

Decorrem da deﬁnição o seguinte teorema:

Teorema 2.3.2.

i. a ≡ a mod m, ∀a ∈ Z, m ∈ N.

Demonstração. m | 0 ⇒ m | a − a ⇒ a ≡ a mod m

ii. Se a ≡ b mod m, então b ≡ a mod m, ∀a, b ∈ Z, m ∈ N.

Demonstração. Se a ≡ b mod m ⇒ m | b − a ⇒ m | |a − b| ⇒ a ≡ b mod m.

iii. Se a ≡ b mod m e b ≡ c mod m, então a ≡ c mod m, ∀a, b, c ∈ Z, m ∈ N.

26

Demonstração. Se a ≡ b mod m e b ≡ c mod m, então m | b − a e m | c − b, portanto,
m | (b − a) + (c − b) ⇒ m | c − a, logo, a ≡ c mod m.

É importante notar que para todo inteiro a, da forma a = mq + r, q ∈ Z, m
e r números naturais, têm-se que a é congruente ao seu resto quando dividido por m.
Considerando R, o conjunto de números naturais dos m possíveis restos numa divisão
por m: R = {0, 1, 2, ..., m − 1} tem-se a ≡ r mod m, 0 ≤ r < m. Este conjunto R é
denominado de sistema completo de resíduos módulo m. Ao extrairmos desse conjunto R,
todos os elementos que não são primos com m, obtém-se o conjunto S, que é o conjunto
nomeado de sistema reduzido de resíduos módulo m. Este conjunto S obedece às seguintes
características:

• Dois a dois elementos de S são incongruentes módulo m.

• Todos os elementos de S são primos com m.

• Para cada número inteiro n, primo com m que tomarmos, sempre existirá um

elemento de S que será congruente a n módulo m.

Pode-se obter as demonstrações dos itens acima em Hefez (2016, p. 195).

Em relação ao número de elementos de S, pode-se deﬁnir a função ﬁ de Euler
φ : N −→ N, como a função que corresponde à quantidade de elementos de R que são
primos com m, ou seja, o número de elementos de S.

Portanto, a função φ é deﬁnida para m > 1 e, sendo φ(1) = 1. Logo, decorre das

deﬁnições acima, o seguinte resultado, segundo Hefez (2016, p. 195):

φ(m) ≤ m − 1, ∀m ≥ 2, valendo a igualdade quando m for primo.

O resultado a seguir relaciona o cálculo de φ(m) à sua decomposição em fatores

primos.

Teorema 2.3.3. Dados m > 1 e sua decomposição em fatores primos m = pα1
... · pαn

n . Então,

1 · pα2

2 · pα3
3 ·

φ(m) = pα1−1

1

· pα2−1
2

· pα3−1
3

· ... · pαn−1

n

· (p1 − 1) · (p2 − 1) · (p3 − 1) · ... · (pn − 1)

A prova do Teorema 2.3.3 pode ser vista em Lima (2013, p. 11).

O Teorema a seguir é um resultado importante sobre a Função de Euler.

27

Teorema 2.3.4. Teorema de Euler

Sejam m, a ∈ Z com m > 1 e (a, m) = 1. Então,

aφ(m) ≡ 1 mod m

Demonstração. Seja s1, s2, s3, ..., sφ(m) um sistema reduzido de resíduos módulo m. Por-
tanto, os elementos a · s1, a · s2, a · s3, a · s4, ..., a · sφ(m) também formam um sistema reduzido
de resíduos módulo m, pois:

a · s1, a · s2, a · s3, a · s4, ..., a · sφ(m) ≡ s1, s2, s3, ..., sφ(m)

(2.7)

Da Equação 2.7, tem-se

aφ(m) · s1, s2, s3, ..., sφ(m) ≡ s1, s2, s3, ..., sφ(m) mod m

(2.8)

Como (s1, s2, s3, ..., sφ(m), m) = 1, então, pelo Teorema 2.3.8, a Equação 2.8 tem

como resultado a congruência

aφ(m) ≡ 1 mod m

O Teorema de Euler é a generalização do Pequeno Teorema de Fermat. O Corolário

3.2.2.1 é o caso particular do Teorema de Euler, quando m for primo.

Em seguida, apresentamos alguns resultados importantes envolvendo congruências:

Teorema 2.3.5. Sejam a, b, c, d, m ∈ Z, m > 1. Se a ≡ b mod m e c ≡ d mod m, então
a + c ≡ b + d mod m.

Demonstração. Se a ≡ b mod m e c ≡ d mod m, então m | b − a e m | d − c, portanto,
m | (b − a) + (d − c) ⇒ m | (b + d) − (a + c) ⇒ a + c ≡ b + d mod m

Teorema 2.3.6. Sejam a, b, c, d, m ∈ Z, m > 1. Se a ≡ b mod m e c ≡ d mod m, então
ac ≡ bd mod m.

Demonstração. Se a ≡ b mod m e c ≡ d mod m, então m | b − a e m | d − c, portanto,
m | d(b − a) + a(d − c) ⇒ m | bd − ac ⇒ ac ≡ bd mod m

28

Corolário 2.3.6.1. Sejam a, b ∈ Z e n ∈ N, se a ≡ b mod m, então an ≡ bn mod m.

Demonstração. Usando Indução: Para n = 1, a aﬁrmação é válida, por hipótese.

Supondo a aﬁrmação válida para algum n > 1, temos que se a ≡ b mod m, então

an ≡ bn mod m.

Portanto, se a ≡ b mod m e an ≡ bn mod m, logo, pelo Teorema 2.3.6, an · a ≡

bn · b mod m ⇒ an+1 ≡ bn+1 mod m.

O Teorema 2.3.7 e o Teorema 2.3.8, referem-se às propriedades de cancelamento

em relação às operações de adição e multiplicação utilizando congruências.

Teorema 2.3.7. Sejam a, b, c, m ∈ Z, m > 1. Vale que a + c ≡ b + c mod m ⇔ a ≡
b mod m.

Demonstração. (⇒) a + c ≡ b + c mod m, então m | (b + c) − (a + c), logo, m | b − a ⇒
a ≡ b mod m.

(⇐) a ≡ b mod m e c ≡ c mod m, pelo Teorema 2.3.2, logo pelo Teorema 2.3.5,

a + c ≡ b + c mod m.

Teorema 2.3.8. Sejam a, b, c, m ∈ Z, m > 1. ac ≡ bc mod m ⇔ a ≡ b mod

(cid:16) m

(cid:17)

(c,m)

Demonstração. (⇒) ac ≡ bc mod m ⇒ m | bc − ac ⇒ m | (b − a)c ⇒ m

(c,m) | (b − a) ·

Como m

(c,m) e

c

(c,m) são números coprimos, então, m

(c,m) | b − a ⇒ a ≡ b mod

(⇐) a ≡ b mod
m | bc − ac ⇒ ac ≡ bc mod (m).

(c,m)

(cid:16) m

(cid:17)

⇒ m

(c,m) | b − a ⇒ m

(c,m) | (b − a) ·

c

(c,m) ⇒ m | (b − a)c ⇒

Em particular, sejam a, b, c, m ∈ Z, m > 1 e (c, m) = 1: ac ≡ bc mod m ⇔ a ≡

b mod m.

Teorema 2.3.9. Sejam a, b, m, n ∈ Z, m > 1, n > 1. Se a ≡ b mod m e n | m, então
a ≡ b mod n.

Demonstração. Se a ≡ b mod m, então m | b − a, logo b − a = mk, k ∈ Z. Portanto, como
n | m, tem-se m = nq, q ∈ Z, e assim, b − a = mk = (nq)k = n(qk) ⇒ n | b − a ⇒ a ≡
b mod n.

Teorema 2.3.10. Sejam a, b, m1, m2, ..., mr ∈ Z, com mi > 1, ∀i = 1, 2, ..., r.

a ≡ b mod mi ⇔ a ≡ b mod [m1, m2, ..., mr].

Demonstração. (⇒) Se a ≡ b mod mi, ∀i = 1, 2, ..., r, então mi | b−a, ∀i. Sendo assim, b−a
é um múltiplo de cada mi, portanto, [m1, m2, ..., mr] | b−a, logo a ≡ b mod [m1, m2, ..., mr].

(⇐) A recíproca é proveniente do Teorema 2.3.9.

c
(c,m) .
(cid:17)

.

(cid:16) m

(c,m)

29

2.3.1 Resolução de Congruências Lineares

Considerando as congruências da forma aX ≡ b mod m, onde a, b, m ∈ Z, m > 1,
denominadas congruências lineares, deseja-se identiﬁcar um critério para a veriﬁcação da
existência de soluções, ou seja, se existem x ∈ Z, tais que ax ≡ b mod m.

Sendo assim, eis uma proposição que apresenta tal critério:

Teorema 2.3.11. Sejam a, b, m ∈ Z, m > 1. Tem-se que aX ≡ b mod m possui solução
se, e somente se, (a, m) | b.

Demonstração. (⇒) Supondo que x seja a solução da congruência aX ≡ b mod m, ou seja,
∃y ∈ Z, tal que ax − b = my, tem-se que a equação aX − mY = b admite solução.

Como (a, m) | a e (a, m) | m, logo (a, m) | aX − mY , então (a, m) | b.

(⇐) Como por hipótese, (a, m) | b e como (a, m) | a, e então (a, m) | ax, tem-se

(a, m) | ax − b. Logo ∃t ∈ Z, tal que

ax − b = (a, m)t

Como (a, m) | m, então (a, m) | my, y ∈ Z. Sendo assim, seja

my = (a, m)q, q ∈ Z

(2.9)

(2.10)

Admitamos que exista uma única solução x0, y0 na qual t = q para a Equação 2.9
e Equação 2.10, então ax0 − b = (a, m)t = my0 portanto, m | ax0 − b e, consequentemente,
ax0 ≡ b mod m, com a, b, m ∈ Z, m > 1.

É notável que, se x0 é solução particular de aX ≡ b mod m, então x ≡ x0 mod m

é também uma solução e, portanto, gera todas as soluções também congruentes a esta.

Portanto, é necessário utilizar o Teorema 2.3.12 a seguir, para encontrar quais e

quantas são as soluções incongruentes duas a duas da congruência aX ≡ b mod m.

Teorema 2.3.12. Sejam a, b, m ∈ Z, m > 1 e (a, m) | b. Se x0 é solução da congruência
aX ≡ b mod m, então x0, x0 + m
d , onde d = (a, m), formam
uma coleção completa de soluções de aX ≡ b mod m, duas a duas incongruentes módulo
m.

d , ..., x0 + (d − 1) · m

d , x0 + 2 · m

Demonstração. Seja x0 uma solução da congruência aX ≡ b mod m. Nesse caso toda
solução x desta é congruente , módulo m, a x0 + i · m
d , para algum i, onde 0 ≤ i < d,
sendo d = (a, m). Logo, se ax ≡ ax0 mod m, então x ≡ x0 mod m. Sendo x − x0 ≡ t · m
d .
Portanto, ∃i, 0 ≤ i < d, tal que t = kd + i. Então, x = x0 + km + i · m
d mod m.
Têm-se que, x0 + i · m

d , 0 ≤ i < d, são soluções da congruência.

d ≡ x0 + i · m

30

Concluindo, essas soluções são incongruentes duas a duas, módulo m, pois se
d ≡ x0 + z · m

d mod m, com 0 ≤ y, z < d, então y = z.

x0 + y · m

Corolário 2.3.12.1. Se (a, m) = 1, então aX ≡ b mod m possui uma única solução
módulo m.

Este Corolário decorre diretamente do Teorema 2.3.12, no caso particular de
(a, m) = 1. Neste caso, esta solução única será chamada de inverso multiplicativo de a
módulo m.

Teorema 2.3.13. Dados a, m ∈ Z, com m > 1. A congruência aX ≡ 1 mod m possui
solução se, e somente se, (a, m) = 1.

Demonstração. Seja x0 uma solução da congruência aX ≡ 1 mod m. Esta congruência
possui solução se, e somente se, m | ax0 − 1. Portanto, existe y0 tal que ax0 − 1 = my0,
então, a congruência aX − mY = 1 possui solução inteira. Pelo Teorema 3.1.5, isso ocorre
se, e somente se, (a, m) = 1.

Exemplo. Resolução de uma congruência linear.

Seja a congruência 20X ≡ 4 mod 16 e d = (4, 20) = 4. Garantimos, portanto, a
existência de 4 soluções. Por rápida inspeção, encontra-se a solução x0 = 1. Utilizando o
Teorema 2.3.12, as soluções são:

• x0 = 1

• x0 + m

d = 1 + 16

4 = 5

• x0 + 2 · m

d = 1 + 2 · 16

4 = 9

• x0 + 3 · m

d = 1 + 3 · 16

4 = 13

Então, as soluções serão {1, 5, 9, 13}.

31

3 NÚMEROS PRIMOS

3.1 Números Primos

Segundo Coutinho (2014, p. 19 grifo do autor), “os gregos classiﬁcavam os números
em primeiros ou indecomponíveis e secundários ou compostos. Os números compostos são
secundários por serem formados a partir dos primos”. Ainda segundo Coutinho (2014, p. 19
grifo do autor), os romanos chamavam esses números de “primus” que, em latim, signiﬁca
primeiro. Logo, os números primos têm essa nomenclatura, pois, estes são considerados os
primeiros.

São números naturais que só possuem dois divisores naturais: 1 e o próprio número.
Como veremos adiante por meio do Teorema Fundamental da Aritmética, os números
primos formam todos os outros que não o são.

As propriedades dos números primos são fundamentais no estudo da Aritmética e
de outras áreas do conhecimento como Criptograﬁa, Ciência da Computação e Segurança
da Informação. No entanto, há muitos anos, algumas conjecturas importantes relacionadas
à esses números estão em aberto, como por exemplo, o padrão matemático responsável
por sua distribuição e regularidade no conjunto dos números naturais, o que será melhor
explorado nos próximos capítulos.

Exemplo. O número 5 é primo, pois apresenta como divisores positivos somente os números
1 e 5. O número 6 não é primo. Pois, apresenta os seguintes divisores positivos {1, 2, 3, 6}.
Todo número que não for primo é chamado composto.

Alguns resultados que decorrem da deﬁnição:

Sejam p e q primos, com n ∈ Z:

i. Se p | q, então p = q.

Demonstração. Como q é primo e p | q então p = 1 ou p = q, mas sendo p também
primo, tem-se, p = q.

ii. Se p (cid:45) n, então (p, n) = 1.

Demonstração. Seja d = (p, n), então d | p e d | n, logo d = p ou d = 1.

Como p (cid:45) n, então d (cid:45) p. Portanto d = 1.

32

Lema 3.1.1. Lema de Euclides

∀a, b, p ∈ Z, com p primo. Se p | ab, então p | a ou p | b.

Demonstração. Seja p primo e p | ab, e suponha que p (cid:45) a. Então (p, a) = 1. Pelo Lema de
Gauss, p | b.

Corolário 3.1.1.1. Se p, p1, p2, p3, ..., pn são números primos e p | p1 · p2 · ... · pn, então
p = pi para algum i = 1, 2, 3, ..., n.

Demonstração. Utilizando o Princípio de Indução: Sejam p, p1, p2, ..., pn, pn+1 números
primos.

Se p | p1, como p e p1 são primos, por hipótese, então p = p1.

Suponha que p | p1 · p2 · ... · pn, então p = pi, para algum i = 1, 2, ..., n.

Logo, se p | p1 · p2 · ... · pn, então p | p1 · p2 · ... · pn · pn+1 e, portanto, p = pi, para

algum i = 1, 2, 3, ..., n, n + 1.

O Teorema 3.1.2 fundamenta os números primos como as estruturas mais simples

que formam todos os números naturais. Eis o seu enunciado:

Teorema 3.1.2. Teorema Fundamental da Aritmética

Todo número natural maior do que 1 ou é primo ou se escreve de modo único (a

menos da ordem dos fatores) como um produto de números primos.

Demonstração. Pelo Princípio de Indução:

Se n = 2, temos válido o resultado, pois, 2 é primo.

Supondo que a aﬁrmação é válida para qualquer número natural menor que n,
então teremos que analisar e provar para n quando este for composto, pois se n é primo já
veriﬁca a aﬁrmação.

Se n é composto, logo ∃n1, n2 ∈ N, tais que n = n1n2, 1 < n1 < n e 1 < n2 < n.

Pela hipótese de indução, ∃p1, p2, ..., pr e q1, q2, ..., qs, tais que n1 = p1 · p2 · ... · pr e

n2 = q1 · q2 · ... · qs.

Portanto, n = p1 · p2 · ... · pr · q1 · q2 · ... · qs.

Unicidade da escrita: Suponhamos que n = p1 · p2 · ... · pr = q1 · q2 · ... · qs e que pi e
qj são números primos. Como p1 | q1 · q2 · ... · qs, pelo Corolário 3.1.1.1, temos que p1 = qj
para algum j, que supomos ser q1.

Logo, agora restam p2 · p3 · ... · pr = q2 · q3 · ... · qs.

33

Como p2 · p3 · ... · pr < n, pela hipótese de indução, têm-se que r = s e que todos pi

e qj são iguais aos pares.

Exemplo.

i. O número 13 é primo.

ii. O número 15 é composto, pois pode ser escrito na forma 15 = 3 · 5, onde 3 e 5 são

primos.

iii. O número 900 pode ser escrito na forma fatorada (produto) como 900 = 2·2·3·3·5·5 =

22 · 32 · 52.

O Exemplo iii nos conduz ao próximo resultado, cuja demonstração pode ser vista

em Hefez (2005, p. 84).

Teorema 3.1.3. Dado n ∈ Z − {−1, 0, 1}, existem primos p1 < p2 < ... < pr e
α1, α2, ..., αr ∈ N univocamente determinados, tais que:

n = ±pα1
1

· pα2
2

· ... · pαr
r

A seguir duas observações sobre o resultado anterior:

• Sejam n, m ∈ N e m > 1 e n > 1, em se tratando da decomposição em fatores primos,

teremos:

· pα2
2

n = pα1
1
expoentes α1, α2, ..., αr e β1, β2, ..., βr variando em N ∪ {0}.

r e m = pβ1

2 · ... · pβr

1 · pβ2

· ... · pαr

r , utilizando os primos p1, p2, ..., pr e os

• Com relação a n ∈ N, n > 1, escrito na forma n = pα1
1

· ... · pαr
perfeito se, e somente se, αi forem pares, para todos i = 1, 2, 3, ..., r.

· pα2
2

r , será quadrado

Teorema 3.1.4. Seja n ∈ N, n > 1, n = pα1
· ... · pαr
1
i = 1, 2, 3, ..., r. Se n0 | n e n0 > 0 (divisor positivo de n), então:

· pα2
2

r , sendo pi, primo, com

n0 = pβ1

1 · pβ2

2 · ... · pβr

r , 0 ≤ βi ≤ αi, para i = 1, 2, ..., r.

Demonstração. Seja n0 um divisor positivo de n e seja pβ a potência de um primo p que
ﬁgura na decomposição de n0 em fatores primos. Como pβ divide algum pαi
i , por ser primo
com os demais pαj

j , então, p = pi e 0 ≤ β ≤ αi.

34

Um resultado importante que relaciona o Teorema de Bezóut e os números conside-

rados primos entre si é:

Teorema 3.1.5. Dois números inteiros a e b são primos entre si (ou coprimos) se, e
somente se, existem números inteiros m e n tais que ma + nb = 1.

Demonstração. (⇒) Suponha que a e b são primos entre si. Logo, (a, b) = 1. Pelo Teo-
rema 2.2.8 ∃m, n ∈ Z tais que ma + nb = (a, b) = 1.

(⇐) Suponha que ∃m, n ∈ Z tais que ma + nb = 1. Se d = (a, b), temos que, pelo

Teorema 2.2.5, d | (ma + nb), o que implica que d | 1, e, portanto d = 1.

Outra ferramenta importante é o Teorema fornecido por Pierre de Fermat, conhe-
cido como Pequeno Teorema de Fermat que relaciona divisibilidade, números primos e
congruências.

3.2 Pequeno Teorema de Fermat

Pierre de Fermat, grande matemático francês que viveu entre 1601 e 1665, ofereceu

notável contribuição em diversas áreas da matemática.

Em 1640, Fermat enunciou uma proposição importantíssima no estudo de congruên-

cias, o Pequeno Teorema de Fermat.

Segundo Hefez (2016, p. 135), “500 anos antes de nossa Era, os chineses já sabiam
que se p é primo então p | 2p − 2”, e o trabalho de Fermat deu-se em generalizar esse
resultado.

Para provar o Pequeno Teorema de Fermat, utiliza-se o seguinte Lema:

Lema 3.2.1. Seja p, primo. Os números binomiais
0 < i < p, são todos divisíveis por p.

(cid:17)

(cid:16)p
i

=

p!

i!·(p−i)! , com i ∈ N, onde

Demonstração. Por Indução matemática:

i = 1, o resultado é válido.

Supondo 1 < i < p, então i! | p · (p − 1) · ... · (p − i + 1), como (i!, p) = 1, pelo Lema

de Euclides, i! | (p − 1) · ... · (p − i + 1), logo:

!

 p
i

= p · (p−1)·...·(p−i+1)

i!

35

Teorema 3.2.2. Pequeno Teorema de Fermat

Dado p, primo, tem-se p | ap − a, ∀a ∈ Z.

Demonstração. Se p = 2 a aﬁrmação é válida, pois a2 − a = a(a − 1) é par.

Supondo, então, p ímpar e a (cid:62) 0.

Pela Indução matemática em relação à a:

• a = 0, p | 0, logo é válida.

• Supondo válida a aﬁrmação válida para a, logo p | ap − a.

• Então, (a + 1)p − (a + 1) = ap − a +

!

 p
1

· ap−1 + ... +

  p

!

p − 1

· a

Logo, pela hipótese de indução e pelo Lema anterior, então, p | (a + 1)p − (a + 1),

∀a ∈ Z e p primo.

Do resultado acima, pode-se obter o Corolário 3.2.2.1 um novo enunciado para o

Pequeno Teorema de Fermat.

Corolário 3.2.2.1. Pequeno Teorema de Fermat

Se p é primo, a ∈ N e (p, a) = 1, então p | ap−1 − 1.

Demonstração. Como pelo Teorema 3.2.2, tem-se p | ap − a, para algum p primo. Então,
p | ap − a ⇒ p | a(ap−1 − 1), sendo (p, a) = 1, portanto p | ap−1 − 1.

3.2.1 Pequeno Teorema de Fermat - Congruências

Diante dos conceitos aqui expostos, segue uma reformulação do Pequeno Teorema

de Fermat (Teorema 3.2.2), com foco na notação de congruências.

Teorema 3.2.3. Pequeno Teorema de Fermat - Congruência

Se p é um número primo e a ∈ Z, então ap ≡ a mod p.

Em particular, se p (cid:45) a, então ap−1 ≡ 1 mod p.

3.3 Alguns resultados importantes sobre os Números Primos

3.3.1 Teorema de Euclides

Os números Primos sempre constituíram um grande mistério para os matemáticos.
Muitos estudiosos brilhantes, como Fermat, Euler, entre outros, aventuraram-se em conhecer
as principais características destes números.

36

Euclides foi um dos primeiros a estudar o comportamento dos primos quanto à sua

cardinalidade e demonstrou o seguinte resultado 300 anos antes de nossa Era:

Teorema 3.3.1. Teorema de Euclides

Existem inﬁnitos números primos.

Demonstração. Utilizando o método de redução ao absurdo. Supondo que existam k primos
(quantidade ﬁnita), sendo estes: p1, p2, p3, ..., pk.

Sejam n = p1 · p2 · ... · pk + 1 e q o menor divisor primo de n. Logicamente, q é
diferente de todos os primos pi, 1 ≤ i ≤ k, pois, como q | n, então q teria que dividir 1, logo,
impossível. Portanto, tem-se uma contradição na aﬁrmação que existem uma quantidade
ﬁnita de primos.

Este resultado traz à tona uma importante caracterização dos números primos
quanto à sua cardinalidade. Porém, outra questão notável é quanto a distribuição dos
primos dentro do conjunto dos naturais.

Ao longo dos tempos, diversas conjecturas foram alçadas, neste sentido, como o

Crivo de Eratóstenes, o Teorema dos números primos, entre outros.

3.3.2 Crivo de Eratóstenes

Segundo Oliveira; Fernández (2012, p. 127) “o Crivo de Eratóstenes é um algoritmo
que nos permite achar todos os números primos que são menores ou iguais que um natural
N dado”. O matemático grego Eratóstenes (285 - 194 antes da Era Comum) criou este
método utilizando uma tabela ordenada de inteiros positivos, iniciando no número 2 até o
número N , ou seja,

2, 3, 4, 5, 6, ..., N

Tabela 1 – Crivo de Eratóstenes

2
12
22
32
42
52
62
72
82
92

3
13
23
33
43
53
63
73
83
93

11
21
31
41
51
61
71
81
91

5
15
25
35
45
55
65
75
85
95

4
14
24
34
44
54
64
74
84
94
Fonte: O autor, 2020

7
17
27
37
47
57
67
77
87
97

6
16
26
36
46
56
66
76
86
96

8
18
28
38
48
58
68
78
88
98

9
19
29
39
49
59
69
79
89
99

10
20
30
40
50
60
70
80
90
100

37

Após criada a Tabela 1, serão determinados todos os primos menores que 100.

O procedimento em si é bem simples. Primeiramente, destaca-se o número 2, que é
o primeiro primo e único par e depois cancelam-se todos os múltiplos de 2 restantes, ou
seja, 4, 6, 8, ..., 98, 100. Em seguida, destaca-se o número 3 e cancelam-se todos os múltiplos
de 3 restantes: 9, 15, 21, ..., 93, 99. Este procedimento continua até um determinado número
k ∈ N (ver Teorema 3.3.2), onde pode-se concluir que todos os números compostos até 100
foram cancelados e os números destacados são todos os primos menores que 100, conforme
Tabela 2.

Tabela 2 – Crivo de Eratóstenes - tabela com os primos menores que 100

5

2

11

31
41

61
71

3
13
23

43
53

73
83

7
17

37
47

67

97

19
29

59

79
89

Fonte: O autor, 2020

Logo, os números primos entre 2 e 100, conforme a Tabela 2, são:

{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}.

Não é possível identiﬁcar um padrão, mesmo organizando primos em uma tabela.

Matemáticos têm realizado descobertas importantíssimas no campo da Aritmética,
porém, a distribuição dos primos dentro dos números naturais continua sendo uma questão
em aberto. No entanto, esta descoberta poderia acarretar diversas outras realizações
matemáticas mais signiﬁcativas, como por exemplo, a prova da Conjectura de Riemann e
outras conjecturas em aberto.

O teorema a seguir nos fornece resultados importantes sobre a caracterização da
primalidade de números inteiros e conceitualiza o inteiro positivo k < N abordado acima
como o número pelo qual devemos usar como limite na busca do conhecimento se um
determinado número é ou não primo.

38

Teorema 3.3.2. Seja n > 1 um número inteiro. Então:

a. O menor divisor de n, diferente de 1, é um número primo.

Demonstração. Seja um número natural k > 1, que é o menor divisor de n.

Suponhamos que k seja composto, então ∃m ∈ N, onde 1 < m < k, sendo m um
divisor de k, logo m | k e k | n, portanto, m | n, o que contradiz o fato de que k é o
menor divisor de n, ou seja, k é primo.

b. Se n é composto, este possui um menor divisor (diferente de 1), que é menor que ou

√

igual a

n.

Demonstração. Seja n um número composto e k > 1, o menor divisor de n. Portanto,
seja n = k · q, com q ≥ k dessa forma temos n = k · q ≥ k2 =⇒ n ≥ k2.

Logo,

√

n ≥ k.

Sendo assim, pode-se associar este último Teorema ao Crivo de Eratóstenes, onde
percebe-se que não é necessário, numa tabela que se inicia no número 2 até o 100,
100 = 10. Ou seja, no
veriﬁcarmos cada número e, sim, até um determinado k ≤
exemplo anterior, seria preciso veriﬁcar os primos até o número primo menor que 10, logo,
k = 7, alcançando, assim, todos os primos nesta tabela.

N =

√

√

Compreende-se que o método realizado por Eratóstenes seria eﬁcaz para números
pequenos, mas como a ideia central seria a de encontrar um procedimento que exprimisse
qualquer primo, por maior que este o seja, o Crivo de Eratóstenes não se qualiﬁca como
método mais eﬁciente.

Porém, existem outros métodos e relações que foram sendo analisadas para descobrir
a primalidade de um número n, como também sua localização entre os números naturais.

3.3.3 Primos Gêmeos

Segundo Viana (2018) esta nomenclatura foi utilizada pela primeira vez pelo

matemático alemão Paul Stäckel (1862 − 1919), em 1916.

Primos gêmeos são dois números primos ímpares e consecutivos, como os pares
(3, 5), (5, 7), (11, 13) e assim por diante, cuja diferença seja igual a 2. Ainda segundo Viana
(2018) é sabido que existem 27.412.679 primos gêmeos com 10 dígitos ou menos. Porém,
ainda não existe uma prova deﬁnitiva se a quantidade de números primos gêmeos é inﬁnita,
ou mesmo como se dá sua distribuição entre os próprios números primos. Ou seja, se existe
alguma relação matemática que deﬁna qual a distância entre pares de primos gêmeos entre
os números primos suﬁcientemente grandes.

39

Algumas informações importantes são conhecidas por meio do avanço tecnológico,
como o maior primo gêmeo que possui 388.342 dígitos. Este resultado foi calculado em
setembro de 2016 por Tom Greer, um voluntário norte-americano participante do projeto
PrimeGrid que investiga os maiores primos e conjecturas em aberto.

No entanto, o resultado enunciado por Euclides, conhecido como Conjectura dos
Primos Gêmeos, ainda não foi provado. Esta Conjectura aﬁrma que: “Existem inﬁnitos
p ∈ N primos tais que p + 2 também é primo”.

O matemático francês Alphonse de Polignac (1826 − 1863), conjecturou que para
cada número k, existem inﬁnitos pares de primos cuja diferença é igual a 2k. O caso k = 1
é a Conjectura dos Primos Gêmeos.

Em 2013, o matemático chinês Yitang Zhang, provou que para algum N menor
que 70 milhôes, existem inﬁnitos pares de primos cuja diferença é N . Daí o matemático
de origem chinesa Terence Tao começou a estudar a prova de Zhang a ﬁm de apresentar
um valor menor para N . Terence Tao em colaboração com Zhang, conseguiu em 2014,
demonstrar que o valor de N é menor que 246. A prova deﬁnitiva da Conjectura dos
Primos Gêmeos, quando N = 2, ainda encontra-se em aberto.

3.4 Testes de Primalidade

Muitos matemáticos têm procurado identiﬁcar padrões numéricos que reconheçam
números primos. Ainda hoje existem diversas conjecturas (ou hipóteses) em análise e sem
uma comprovação matemática. No entanto, algumas técnicas podem ser utilizadas para
caracterizar um número, principalmente, números muito grandes em primos ou compostos.

3.4.1 Teorema para caracterização de números primos

O Teorema 3.3.2 descreve que se n é um número inteiro composto, com n > 1, então
n. Segundo
este possui um menor divisor, diferente de 1, que é menor que ou igual a
Oliveira; Fernández (2012, p. 125): “Se n não possui divisores diferentes de 1, menores que
ou iguais a
n, então n é primo”. Assim, caracteriza-se, então se um inteiro maior que 1 é
primo através da quantidade de divisores menores que um determinado parâmetro que é
√

√

√

n.

Porém, este método ainda apresenta certa insatisfação quando n é um inteiro muito
n seria, portanto, um número ainda muito grande para identiﬁcar seus

√

grande, pois
divisores.

3.4.2 Identidade de Sophie Germain

Outro critério importante que pode ser utilizado para identiﬁcar se um número não é
primo é a identidade apresentada pela matemática francesa Sophie Germain (1776 − 1831).

40

Teorema 3.4.1. Identidade de Sophie Germain

Dados a, b ∈ R, têm-se que:

a4 + 4b4 = (a2 + 2b2 + 2ab) · (a2 + 2b2 − 2ab)

Demonstração. a4 + 4b4 = a4 + 4a2b2 + 4b4 − 4a2b2 = (a2 + 2b2)2 − 4a2b2 = (a2 + 2b2 +
2ab) · (a2 + 2b2 − 2ab)

É importante observar que esta identidade demonstra que todo número da forma
a4 + 4b4, com a, b ∈ R, pode ser escrito na forma de um produto, ou seja, é um número
composto. Outrossim, a utilização dessa relação é válida para a, b ∈ N, pois N ⊂ R.

Exemplo. O número 312 + 218 não é primo, pois, 312 + 218 = (33)4 + 22+16 = (33)4 + 4 · (24)4,
com a = 33 e b = 24, portanto, esse número é da forma a4 + 4b4. Logo, pela identidade de
Sophie Germain, é composto.

3.4.3 Teste de Primalidade de Fermat

Um teste de primalidade muito útil, assim como a Identidade de Sophie, não
determinístico, ou seja, que apenas exclui a possibilidade de um determinado número de
ser primo, caso não atenda à certa propriedade, é o teste realizado utilizando como base o
Pequeno Teorema de Fermat, analisado no início deste capítulo, que se

a ∈ Z e m ∈ N, com m > 1, então am ≡ a mod m, ou ainda, no caso em que a e m sejam
primos entre si, am−1 ≡ 1 mod m, para algum a ∈ N.

Têm-se que, todo número m que não atenda às condições acima, não será primo.

Por outro lado, esse resultado diz que existem inﬁnitos números que atendem
à condição do Teorema acima, mas não são primos, ou seja, existem inﬁnitos números
m onde (a, m) = 1 e a ∈ N, am−1 ≡ 1 mod m, porém m não é primo. Estes números
são chamados de pseudoprimos, ou então Números de Carmichael em homenagem ao
matemático americano Robert Carmichael (1879 − 1967).

Os números de Carmichael, segundo Figueiredo (2010, p. 91), são números compos-
tos (m ∈ Z∗
+) que satisfazem a congruência am−1 ≡ 1 mod m, para alguma base a ∈ Z e
(a, m) = 1. Por exemplo, o número 341 é pseudoprimo para a base 2, ou seja, este número
atende às condições que 2341−1 = 2340 ≡ 1 mod 341 e o mdc (2, 341) = 1, porém, 341 é
composto, pois 341 = 31 · 11. Logo, o teste de primalidade de Fermat não torna-se viável
para determinar se um número é realmente primo por causa dos números de Carmichael
(os pseudoprimos). Porém, pode fornecer a informação se um número não é primo.

41

3.4.4 Algoritmos de testes de primalidade

Atualmente, são utilizados diversos algoritmos que permitem determinar com certa

facilidade se um número suﬁcientemente grande é primo ou não.

Atualmente, o maior primo conhecido é 282.589.933 − 1, com 24.862.048 dígitos,
segundo o sítio eletrônico IMPA (Instituto de Matemática Pura e Aplicada), descoberto em
15 de janeiro de 2019, através da pesquisa nomeada de GIMPS (Great Internet Mersenne
Prime Search), sendo este o 51º primo de Mersenne (matemático francês que estudou os
primos da forma 2n − 1).

É relevante observar a importância dos algoritmos de pesquisa sobre números
primos e quão complexas tem sido as descobertas de novos primos cada vez maiores. Por
exemplo, o maior primo descoberto anterior à este, foi calculado em 2017. A partir do
início do uso do software GIMPS, por seu inventor Patrick Laroche, deu-se quase quatro
meses e algumas tentativas frustradas até a descoberta do então maior primo.

3.5 Polinômio de Euler

Outra questão ainda sem resposta é se existe algum polinômio que gere todos os
números primos. Sabe-se que alguns polinômios, chamados de polinômios geradores de
primos, permitem determinar uma certa quantidade de números primos como imagem de
n números pertencentes ao domínio dos inteiros positivos.

Um dos polinômios geradores de primos mais conhecido é o Polinômio de Euler:

P (n) = n2 − n + 41, com n ∈ N

Porém, nem todas as imagens de P são números primos. Segundo Fornari (2017, p.

4), analisando P (n), têm-se que:

• 1 ≤ n ≤ 40 =⇒ P (n) são todos números primos.

• P (41) = 1681 número composto.

• P (42) = 1763 número composto.

• P (43) = 1847 número primo.

• P (44) = 1933 número primo.

• P (45) = 2021 número composto.

P (n) gera 40 números primos como imagem de n ∈ N variando de 1 a 40. Mas, logo
em seguida, apresenta como imagens números compostos e ainda não é possível determinar

42

se a partir de um determinado número este polinômio irá gerar somente números primos
ou não. Ainda segundo Fornari (2017, p. 4) é notório que todas as imagens de múltiplos
de 41 serão compostos, pois, se k ∈ N e P (41k) = (41k)2 − (41k) + 41 =⇒ P (41k) =
41 · (41k2) − 41k + 41 =⇒ P (41k) = 41 · (41k2 − k + 1), logo 41 | P (41k), ∀k ∈ N.

3.6 Conjectura de Goldbach

Diversas conjecturas (ou hipóteses) sobre os números primos foram alçadas, mas
ainda se encontram sem solução. Muitas dessas conjecturas, caso comprovadas, poderiam
esclarecer dúvidas importantes acerca da distribuição dos números primos dentro dos
números naturais, como também fornecer padrões numéricos para identiﬁcar a primalidade
de números suﬁcientemente grandes e até serem utilizadas como base para a aceitação de
outros estudos ainda não demonstrados.

Uma importante hipótese, ainda em aberto, é a Conjectura de Goldbach, formulada
pelo matemático prussiano Christian Goldbach, em 1742. Segundo Alencar Filho (1981, p.
129), em carta ao matemático Leonhard Euler, Goldbach conjecturou que “todo inteiro
par maior que 5 pode ser escrito como a soma de 3 números primos”. Em resposta, Euler
aﬁrmou que tal conjectura, em caráter mais geral, seria equivalente à aﬁrmação que “todo
inteiro par maior que 2 pode ser escrito como a soma de 2 números primos”, conhecida
como Conjectura forte de Goldbach.

Apesar dos esforços empreendidos por muitos matemáticos ao longo dos anos, não
foi possível concluir a validade dessas aﬁrmações, mesmo tendo sido provada a hipótese
inicial para diversos números.

Já em 1923, segundo Perin (2017, p. 6) os matemáticos Godfrey Hardy e Jhon
E. Littlewood, propuseram uma nova versão para a hipótese de Goldbach em que “todo
número ímpar maior que 7 pode ser escrito como a soma de 3 números primos”. Estes
provaram essa conjectura para todo n ímpar maior que um determinado m natural, ou seja,
para naturais ímpares suﬁcientemente grandes. Outro matemático Ivan M. Vinagradov,
independentemente, chegou ao mesmo resultado daqueles. A versão de Hardy e Littlewood
é conhecida como Conjectura fraca de Goldbach, assim chamada, pois caso a conjectura
forte seja provada, esta automaticamente torna-se válida por ser uma consequência da
hipótese denominada forte.

Recentemente, segundo Hefez (2016, p. 134), em 2013, o matemático peruano
Harald Helfgott conseguiu demonstrar a versão de Vinagradov da Conjectura de Goldbach,
onde “reduziu-se para maior do que 5 a restrição de o número ser suﬁcientemente grande”.

4 CRIPTOGRAFIA E A SEGURANÇA DA INFORMAÇÃO: DA ESTE-

GANOGRAFIA À CRIPTOGRAFIA RSA

43

A preocupação com a segurança das informações (ou mensagens) trocadas sempre foi
prioridade entre pessoas, governos e, principalmente, lideranças militares. Durante o curso
histórico, muitas guerras foram vencidas através de informações recebidas por estrategistas
militares, ou até por meio de informantes inimigos. Porém, mensagens interceptadas por
exércitos inimigos podiam gerar consequências catastróﬁcas para a força militar que tentava
comunicar-se com suas tropas.

Assim, o medo de que suas mensagens fossem interceptadas, gerou a necessidade
de tornar o envio o mais secreto possível. Segundo Singh (2011, p. 21), Heródoto foi um
dos primeiros a retratar em seu livro As Histórias, técnicas para ocultar mensagens. Uma
das técnicas utilizadas, segundo Heródoto, na guerra entre gregos e persas, foi empregada
por “Histaeu que raspou a cabeça de um mensageiro e depois escreveu a mensagem em
seu couro cabeludo, esperando até seu cabelo crescer”.

Outras técnicas de ocultação de mensagens utilizadas durante a história foram o
uso da tinta invisível e do microponto pelos alemães durante a Segunda Guerra Mundial.
O primeiro microponto que foi utilizado pelos alemães e descoberto pelo FBI, em 1941,
tinha menos de 1 milímetro de diâmetro e foi colocado sobre um ponto ﬁnal de um texto
em uma carta, interceptada pelo governo americano, entre espiões alemães que operavam
na América Latina.

Esta técnica de ocultação da mensagem é conhecida como esteganograﬁa, palavra
composta pelas seguintes palavras gregas: steganos (coberto) e graphein (escrita). A técnica
da esteganograﬁa perdurou durante um longo período histórico, porém, sua grande falha
era a de que, quando descoberta, a mensagem que estava oculta, tornava-se legível ao
interceptador, perdendo toda a sua eﬁciência.

Ao mesmo tempo que as técnicas esteganográﬁcas eram utilizadas, desenvolviam-
se também técnicas que ocultavam as mensagens à olho nu, ou seja, mesmo visível ao
interceptador, as informações não eram legíveis a menos que fosse identiﬁcada a forma na
qual a mensagem havia sido “embaralhada”.

Esta técnica é conhecida como criptograﬁa e, segundo Singh (2011, p. 22 grifo do
autor), “é derivada da palavra grega kryptos, que signiﬁca oculto”. Ou seja, encriptar ou
codiﬁcar alguma mensagem é escrevê-la de forma que somente outra pessoa (o destinatário)
que conheça o algoritmo (ou a chave) seja capaz de desencriptá-la (ou decodiﬁcá-la)
evitando assim que mesmo que estas informações fossem interceptadas por outras pessoas,
não poderiam ser lidas sem uma chave de decodiﬁcação.

44

A criptologia é o estudo da criptograﬁa e de suas técnicas. Já a criptoanálise é o
ramo responsável por identiﬁcar as falhas e fraquezas de cada técnica encriptação para
“quebra” os códigos descobrindo a chave de desencriptação.

A criptograﬁa tem duas técnicas principais: a transposição e a substituição. A
técnica de criptograﬁa de transposição é baseada na troca das letras de uma mensagem
formando anagramas. Considerando uma palavra ou frase (mensagem) com n letras e pi
(quantidade de letras repetidas) de i letras distintas, têm-se, então,
p1!·p2!·...·pi! anagramas
distintos.

n!

Exemplo. A frase: “vamos atacar” possui 12!
mensagem. Por exemplo, MVASO ACARAT é um dos anagramas.

4! = 19.958.400 anagramas distintos desta

Já a criptograﬁa de substituição utiliza a troca das letras da mensagem pelas letras
de um código (codiﬁcação) ou cifra ou até pelas letras do alfabeto, em ordem distinta,
fazendo, assim, corresponder cada letra da mensagem com uma letra diferente do alfabeto.

Os termos cifra e código se confundem muitas vezes, mas pela deﬁnição de Singh
(2011, p. 47), código é utilizado quando substituem-se palavras ou frases e cifra, quando
são substituídas as letras.

As cifras monoalfabéticas apresentam o uso de apenas um sistema para encriptação.
Quando a cifra é polialfabética, signiﬁca que cada letra codiﬁcada da mensagem pode ter
sido gerada por uma regra distinta de substituição.

Observação. Serão utilizados ao longo deste trabalho de pesquisa sempre letras minúsculas
para letras da mensagem original e maiúsculas para a mensagem codiﬁcada.

a. Cifra monoalfabética de substituição:

Tabela 3 – Exemplo de Cifra de Substituição monoalfabética

Mensagem original

a

t

a

c

a

r

a

g

o

r

a

Mensagem criptografada B U B D B S

B H P S B

Fonte: O autor, 2020

Na mensagem criptografada (ver Tabela 3) utilizou-se apenas um alfabeto para
encriptar todas as letras da mensagem original. O algoritmo (ou a chave) utilizada é a
mesma para encriptar ou desencriptar e é notório que as letras da mensagem original
foram substituídas pelas letras subsequentes destas no alfabeto.

45

b. Cifra de substituição polialfabética:

Tabela 4 – Exemplo de Cifra de Substituição polialfabética

Mensagem original

b

a

t

e

r

e m

r

e

t

i

r

a

d

a

Mensagem criptografada D Z V D T

D O

Q G S K Q C C C

Fonte: O autor, 2020

Na encriptação desta mensagem (ver Tabela 4) foram utilizadas duas chaves. Uma
delas para as letras de ordem ímpar: 1ª letra, 3ª letra, 5ª letra, em diante, onde foram
substituídas, por letras que distavam duas casas à direita no alfabeto, ou seja, a por C;
b por D e assim sucessivamente. Já para encriptar as letras da mensagem original de
ordem par: 2ª letra, 4ª letra e etc., estas foram substituídas pelas letras que estavam
imediatamente à esquerda no alfabeto considerando como um ciclo, ou seja, a por Z; b
por A; c por B e assim em diante.

É importante observar que nos dois casos a mesma chave encriptadora é a mesma
desencriptadora. E que no item b (acima) a diﬁculdade de encontrar o padrão utilizado
na codiﬁcação (algoritmo) deve-se ao fato de serem utilizados um sistema de substituição
polialfabético.

Um criptosistema engloba todos esses fatores como algoritmo (chave), alfabeto e

mensagem original que são utilizados na codiﬁcação de uma mensagem.

A criptograﬁa tornou-se uma técnica mais interessante que a esteganograﬁa, devido
à rapidez para a troca de mensagens secretas e também sua momentânea conﬁabilidade no
caso de interceptação. No entanto, as técnicas criptográﬁcas, ao longo dos séculos, foram
sendo aprimoradas para garantir a segurança das informações transmitidas.

O principal agente de aprimoramento das cifras foi a necessidade de trocas de
informações rápidas e seguras entre governos e forças militares durante grandes conﬂitos,
onde estas informações estratégicas em posses de mãos inimigas custariam o sucesso da
guerra. Assim, esse agente impulsionou o crescimento dos estudos criptográﬁcos. Em
contrapartida, cresceu também os estudos para a quebra de cifras inimigas (criptoanálise).

4.1 Exemplos de técnicas criptográﬁcas antigas

4.1.1 Citale espartano ou Bastão de Licurgo

Datado do século cinco antes da Era Comum, o citale espartano era um bastão
de madeira no qual era enrolada uma tira de couro com letras em sequência que não
apresentavam sentido algum fora do bastão, porém, quando enrolada a tira no citale (ver

Figura 2) aparecia a mensagem original. O citale do emissor e do receptor deveriam possuir
o mesmo tamanho e diâmetro. Esta técnica é um exemplo de criptograﬁa de transposição.

46

Figura 2 – Citale Espartano

Fonte: Foundation, 2019

4.1.2 Cifra de César

A Cifra de César ou Cifra de deslocamento de César, foi utilizada pelo imperador
romano Júlio César, onde este utilizava a cifra de substituição monoalfabética, trocando
as letras da mensagem original por letras que distavam três casas no alfabeto utilizado,
ou seja, a por D; b por E, e assim, sucessivamente. É importante ressaltar que essa cifra
pode ser utilizada trocando as letras do alfabeto original por letra de uma a 25 casas de
distância dentro do alfabeto utilizado. Considerando, ainda, que pode-se permutar todas
as posições das letras do alfabeto chega-se a 26! = 403.291.461.126.605.635.584.000.000
rearranjos possíveis de cifras distintos.

Porém, a cifra de César apresentava diversas fraquezas. Uma delas é a associação
de cada letra da mensagem original a uma única do alfabeto cifrado, ou seja, cada letra do
alfabeto cifrado sempre pode ser associada a uma e somente uma da mensagem original,
tornando mais fácil a sua identiﬁcação.

Por volta do ano 750 de nossa Era os criptoanalistas árabes desenvolveram um
método de decifração conhecido como análise de frequência que basicamente, pode ser uti-
lizado em qualquer cifra de substituição monoalfabética. Esse método estuda a quantidade
de repetições de uma determinada letra na mensagem cifrada e suas posições possíveis
(por exemplo, diferenciando consoantes e vogais), como também a probabilidade do uso de
cada letra de acordo com a frequência de cada letra no idioma da mensagem. No caso da
Língua Portuguesa, as frequências são apresentadas na Tabela 5 a seguir:

Tabela 5 – Estatística da Frequência das letras em textos em Língua Portuguesa

47

Letra Frequência

Letra Frequência

A
B
C
D
E
F
G
H
I
J
K
L
M

14, 63%
1, 04%
3, 88%
4, 99%
12, 57%
1, 02%
1, 30%
1, 28%
6, 18%
0, 40%
0, 02%
2, 78%
4, 74%
Fonte: GTA-UFRJ, 2019

N
O
P
Q
R
S
T
U
V
W
X
Y
Z

5, 05%
10, 73%
2, 52%
1, 20%
6, 53%
7, 81%
4, 34%
4, 63%
1, 67%
0, 01%
0, 21%
0, 01%
0, 47%

Observe que a frequência da letra a na literatura brasileira é de 14, 63% sendo a

letra de maior frequência em textos de língua portuguesa.

Utilizando essa análise, se um texto, criptografado usando a cifra de substituição
monoalfabética, apresentar com maior frequência a letra T , então, existe uma grande
probabilidade, segundo a análise de frequência, dessa letra T representar a letra a da
mensagem original e assim por diante.

4.1.3 Cifra de Vigenère

A Cifra de Vigenère também conhecida como “Le Chiﬀre Indéchiﬀrable” ou “A
Cifra Indecifrável”, começou a ser estudada em meados do século XV pelo arquiteto italiano
Leon Battista Alberti (1404 − 1472), onde este concebeu a possibilidade da utilização de
mais de um alfabeto para cifrar letras distintas da mensagem original. Por exemplo, Alberti
estudou alternar a mudança entre alfabetos distintos, conforme exemplo da Tabela 6.

Tabela 6 – Tabela de Alternância entre alfabetos originais e cifrados

Alfabeto original A B C D E
Z
Alfabeto cifrado 1 O A Z F W .... B
..... Y
Alfabeto cifrado 2 C E G P S

....

Fonte: O autor, 2019

No entanto, o método foi retomado apenas no séc. XVI por Blaise Vigenère, um
diplomata francês. Vigenère utilizava o chamado Quadrado de Vigenère para cifrar as
mensagens, onde cada linha do alfabeto apresentava o início na letra seguinte do alfabeto,
como na Figura 3.

Figura 3 – Quadrado de Vigenère

48

Fonte: Crypto, 2019

Ou seja, essa cifra era imune ao ataque de análise de frequência, pois, cada letra
da mensagem original poderia aparecer como mais de uma letra diferente da mensagem
cifrada, por exemplo, se num texto cifrado, a letra que mais aparece for a letra M , isso
levará a um criptoanalista concluir que a letra M tem uma grande probabilidade de
ser a letra a (pela frequência na Língua Portuguesa). Mas, se a cifra utilizada for uma
cifra polialfabética, a letra M pode representar mais de uma letra distinta da mensagem
original.

A chave é utilizada para indicar a linha na qual a letra da mensagem original será
cifrada. No exemplo da Tabela 7, a chave corresponde à palavra dígito. Logo a letra a da
mensagem original corresponde à letra d da chave. Assim, a letra a será trocada pela letra
correspondente da linha considerada na Figura 3, que se inicia pela letra D e assim por
diante. A chave utilizada para cifrar uma mensagem através da cifra de Vigenère pode ser
uma palavra ou frase.

Tabela 7 – Exemplo de Mensagem cifrada com a Cifra de Vigenère

chave
mensagem original

d
a

i
t

g
a

i
q

t
u

o
d
e m

i
o

mensagem cifrada D B G Y N S P

W

Fonte: O Autor, 2020

g
c

I

i
a

t
s

o
t

d
e

i
l

g
o

I L H H T U

Pode-se observar que neste exemplo, a letra H aparece 2 vezes na mensagem cifrada.

49

Porém, a primeira letra H representa a letra t e a segunda, a letra e da mensagem original.

A Cifra de Vigenère foi utilizada em comunicações secretas por muito tempo, porém,

sua implementação era complexa por causa da cifragem pouco prática.

Essa cifra perdurou indecifrável até o século XIX, quando Charles Babbage (1791 −
1871), estudioso britânico, dedicado a resolver diversos problemas em áreas distintas,
começou a se dedicar à análise criptológica dessa cifra. Este observou que mesmo que
letras cifradas possam representar letras distintas da mensagem original, ainda assim,
poderiam ser analisadas as frequências nas quais as mesmas letras apareciam juntas e tentar
encontrar, desta forma, o tamanho da chave, demonstrando o momento em que a mesma
linha do alfabeto cifrado seria utilizado, gerando pistas da mensagem que fora cifrada.
Logo, uma chave curta e uma mensagem longa favoreceria a decifragem da mensagem.

4.1.4 Enigma

Depois de muitas tentativas de elaborar uma técnica eﬁciente de codiﬁcação por
linguistas e matemáticos por todo o mundo, em 1918 o engenheiro alemão Arthur Scherbius
projetou uma máquina de encriptação de mensagens chamada Enigma (ver Figura 4).
Esta máquina começou a ser utilizada para transmitir mensagens entre espiões alemães
antes da Segunda Guerra Mundial e, durante a guerra, tornou-se uma das ferramentas
estratégicas mais importantes do governo nazista.

A máquina Enigma apresentava um teclado e um letreiro luminoso, no qual após
teclada a letra da mensagem original, iluminava-se a letra correspondente da mensagem
cifrada. No entanto, seu funcionamento não era tão simples assim, já que dentro da Enigma
havia vários ﬁos elétricos, misturadores e discos que rotacionavam, de acordo com uma
ordem pré-determinada gerando cifras distintas.

Figura 4 – Máquina Enigma

Fonte: Goebel, 2019

A Enigma recebia, primeiramente, uma regulação primária, ou seja, a cada dia um
operador da Enigma mudava todas as conﬁgurações, como misturadores, ﬁos e rotores.

50

A máquina era composta por cinco rotores, mas só três eram usados a cada dia, cada
um desses rotores continha as 26 letras do alfabeto alemão e quando pressionada uma
letra da mensagem original no teclado os rotores giravam independentes uns dos outros
gerando, assim, 263 = 17.576 possibilidades de encriptação. Além dos rotores, a máquina
contava com misturadores das letras que aumentavam consideravelmente o número de
possibilidades de codiﬁcação. As conﬁgurações diárias eram previstas em um manual que
era utilizado tanto pelo emissor quanto pelo receptor da mensagem, que datilografava as
letras cifradas em uma máquina conﬁgurada igualmente à máquina usada para cifrar tal
mensagem. No painel luminoso acendiam as letras correspondentes à mensagem original.

Após muitos estudos realizados por organizações criadas pelos países aliados para
interceptar e desencriptar as mensagens trocadas pelos países inimigos, conseguiu-se
avanços na intenção de revelar as informações trocadas pelos militares alemães.

Em 1939, a Escola de Cifras e Códigos do Governo Britânico recrutou o matemático
britânico e professor de Cambridge Alan Turing, conhecido como o pai da computação,
para participar de uma unidade de criptoanalistas em Bletchley Park. Essa unidade, devido
principalmente ao trabalho de Turing, conseguiu depois de muitos esforços descobrir as
falhas no método de transmissão das cifras da Enigma Desta forma, conseguiram criar outra
máquina, chamada de Bomba Eletromecânica, que conseguia, a partir de interceptações
de mensagens cifradas pela Enigma, descrever as conﬁgurações que haviam sido realizadas
para aquele dia especíﬁco. Assim, com outra máquina Enigma de posse dos criptoanalistas
de Bletchley Park, esses conseguiam decifrar as mensagens interceptadas, conﬁgurando
esta máquina de acordo com as conﬁgurações diárias expostas pela máquina produzida
por Turing e seus colaboradores.

No livro de Singh (2011, p. 209) há uma referência a Sir Harry Hinsley que diz que:
“a guerra que terminou em 1945, só teria terminado em 1948”, ou seja, sem os quebradores
de códigos de Bletchley Park a guerra poderia ter durado mais 3 anos.

Mesmo após a guerra, as operações de Bletchley Park mantiveram-se em segredo
por vontade do governo britânico. No entanto, em 1974, após permissão do governo,
o capitão Winsterbothan, responsável pela distribuição das informações obtidas para
os países aliados, escreveu o livro The Secret Ultra, onde revelou toda a história dos
criptoanalistas de Bletchley Park e deu destaque ao trabalho realizado por Alan Turing
postumamente.

4.2 História da Criptograﬁa RSA

A criptograﬁa moderna passou por vários estágios durante a história. Deve-se
observar porém que a maior parte dos métodos criptográﬁcos utilizados até o ﬁnal da
Segunda Guerra tinham por base chaves simétricas. Neste caso, tanto a codiﬁcação quanto a

51

decodiﬁcação de uma determinada mensagem dependia de apenas uma chave e os métodos
de codiﬁcação e decodiﬁcação eram inversos. Ou seja, quem utilizasse uma chave para
codiﬁcar uma mensagem qualquer através de um processo de chave simétrica utilizaria
exatamente o processo inverso para decodiﬁcá-la. Como vimos anteriormente, por exemplo,
a Cifra de César utiliza um deslocamento das letras para uma determinada posição como a
para C, b para D e assim sucessivamente, deslocando três posições do alfabeto no sentido
do início para o ﬁm do mesmo. Na decodiﬁcação bastará então deslocar as mesmas três
posições sentido contrário, ou seja, do ﬁm para o início do alfabeto. Com o desenvolvimento
da criptoanálise, principalmente, durante a Segunda Guerra e a Guerra Fria, o método
criptográﬁco com chaves simétricas tornou-se mais simples de ser analisado e ter seu
método descoberto.

Outra importante questão a ser alçada em relação a esses métodos com chaves
simétricas é a troca de chaves. Um determinado indivíduo que quisesse utilizar algum
método criptográﬁco baseado em chave simétrica deveria informar ao destinatário qual a
chave que utilizou para codiﬁcar a mensagem a ﬁm de que este pudesse decodiﬁcá-la.

Com o advento da internet e a troca de informações por e-mail, por exemplo,
o processo de troca de chaves tornou-se cada vez mais inseguro, devido à facilidade
de interceptação. Por isso, um método de troca de chaves mais seguro e a forma de
implementação deste obteve cada vez mais importância.

4.2.1 Algoritmo DHM

Após a Segunda Guerra Mundial houve um avanço signiﬁcativo no estudo de
técnicas de codiﬁcação. Porém, com o advento da internet, tornou-se cada vez mais
necessária a utilização de chaves de codiﬁcação (ou decodiﬁcação) que pudessem ser
compartilhadas entre indivíduos que estivessem distantes, por e-mail, por exemplo. No
entanto, essa troca de chaves aumentava a probabilidade destas serem interceptadas por
algum indivíduo (hackers).

Logo, era crescente a necessidade de reinventar esse processo de troca de chaves de
forma que as informações que viessem a ser interceptadas não dessem condições de algum
indivíduo vir a decodiﬁcar uma mensagem codiﬁcada.

Entre 1974 e 1976, três criptógrafos norte-americanos: Whitﬁeld Diﬃe, Martin
Hellman e Ralph Merkle, conceberam a ideia de troca de chaves de forma inovadora.
Este conceito ﬁcou conhecido como Protocolo Diﬃe-Hellman-Merkle ou, simplesmente,
Algoritmo DHM, por causa das iniciais de seus inventores.

O Algoritmo DHM teve um papel importantíssimo no desenvolvimento de novas

teorias para a criptograﬁa, como por exemplo, o RSA.

52

Segundo Hefez (2016, p. 272), o funcionamento do Algoritmo DHM é o seguinte:

• Dois indivíduos: PEDRO e LUÍSA precisam trocar informações de forma segura.

Então, eles escolhem dois números naturais x e y e os tornam públicos.

• Em seguida, PEDRO escolhe um número natural αP que seja secreto e LUÍSA

também escolhe, secretamente, um número αL.

• Após a escolha de αP , PEDRO calcula o único número βP < Y , na qual

xαP ≡ βP mod y

e repassa βP para LUÍSA que, por sua vez, também calcula o único número βL < y,
na qual xαL ≡ βL mod y e repassa βL para PEDRO. Estes números βP e βL são os
únicos naturais menores que y que satisfazem a congruência xαi ≡ βi mod y, com
i = P ou L, ou seja, são os resíduos modulares (restos) da divisão de xαi por y.

• Por último, PEDRO e LUÍSA realizam, respectivamente, os cálculos:

βαP
L ≡ (xαL)αP ≡ xαLαP ≡ λ mod y, com λ < y

e

βαL
P ≡ (xαP )αL ≡ xαP αL ≡ λ mod y, com λ < y

Ou seja, os dois obtêm o mesmo resultado λ, sem divulgarem os números αP e αL,

que são as chaves secretas.

O Algoritmo DHM resolveu o problema da troca de chaves, possibilitando que dois
indivíduos utilizassem a mesma chave num sistema de criptograﬁa simétrica. Os métodos
de criptograﬁa de chave simétrica utiliza a mesma chave para codiﬁcar e decodiﬁcar
mensagens.

O conceito elaborado por Diﬃe e seus colaboradores foi considerado inovador, pois,
resolvera o problema de troca de chaves. Porém, este processo ainda precisava que houvesse
uma troca de informações entre indivíduos para que a mensagem pudesse ser encriptada,
o que poderia demandar tempo, além de relacionar a criptograﬁa da mensagem somente
entre dois indivíduos de cada vez.

Em 1975, Diﬃe publicou um resumo sobre o conceito de chaves assimétricas
que, diferentemente, dos métodos criptográﬁcos utilizados até então, apropriava-se de
duas chaves: uma Pública (que seria de livre acesso) e outra Privada (que somente o

53

destinatário teria acesso). Estas chaves apresentavam diferentes funções, uma (a pública)
seria para encriptação e a outra (privada) para desencriptação.

Com a concepção de chaves assimétricas, Diﬃe conseguiu viabilizar a troca de
mensagens criptografadas através do sistema de troca de chaves, por mais de dois indivíduos
ao mesmo tempo, pois, a chave pública de um indivíduo A pode estar acessível para diversos
outros indivíduos B, C, D e assim sucessivamente, que a utilizariam para encriptar a
mensagem e e enviá-la de volta a A que, por sua vez, utilizaria a sua chave privada
para desencriptar cada mensagem recebida. Nesse conceito de chaves assimétricas, os
métodos de encriptação e desencriptação são distintos, ou seja, precisa-se de uma função
ou conceito matemático que seja considerado de “mão única”, uma função em que o cálculo
de volta seja extremamente difícil. Embora Diﬃe tenha elaborado o conceito de chaves
assimétricas, este não conseguiu implementar uma função de “mão única” que viabilizasse
esse processo. Ou seja, a implementação do conceito elaborado por Diﬃe necessitava
de uma função matemática que quando fossem aplicados os dados para codiﬁcação se
obtivesse um resultado de forma fácil, porém, sua decodiﬁcação (ou sua operação inversa)
fosse extremamente difícil ou praticamente irreversível, em tempo razoável.

4.2.2 Rivest, Shamir e Adleman

Mesmo após o Algoritmo criado por Diﬃe, Hellman e Merkle, ainda permanecia a
diﬁculdade de implementar a técnica de chaves assimétricas, devido à falta de conhecimento
sobre qual a função mais apropriada para este ﬁm.

Mais tarde, em 1978, Ronald Rivest e Adi Shamir (ambos estudantes do curso
de Ciências da Computação) e Leonard Adleman (estudante de Matemática), todos do
Laboratório de Ciência da Computação do MIT (Massachusetts Institute of Techno-
logy), implementaram uma técnica criptográﬁca utilizando chaves assimétricas, através de
Congruências Modulares.

O conceito de Congruências Modulares tornou-se o mais apropriado para garantir
a segurança do método que ﬁcou conhecido como Criptograﬁa RSA, devido às iniciais
dos sobrenomes dos seus inventores.

Além disso, a segurança do método RSA deve-se, sobretudo, à utilização do produto
de dois primos p e q suﬁcientemente grandes como chave de criptograﬁa, sendo este produto
n = p · q de acesso público, porém, inviável a sua fatoração devido às características dos
números primos.

54

4.3 Método de Criptograﬁa RSA

O grande avanço da Criptograﬁa RSA em relação aos outros métodos mencionados
nesta pesquisa é a utilização de chaves assimétricas, ou seja, duas chaves que são aplicadas
de forma a realizarem técnicas distintas de codiﬁcação e decodiﬁcação.

O método RSA, em geral, é implementado por meio de programas computacionais
que, obviamente, utilizam a base binária como fundamento das representações simbólicas. O
sistema de códigos binários mais utilizado para o RSA é o ASCII (American Standard Code
for Information Interchange), onde cada sequência de 0 e 1 corresponde a um determinado
símbolo (ou caractere). Porém, para ﬁns de cálculo utilizaremos uma simbologia com
números na base decimal.

Segundo Coutinho (2014, p. 147) é necessária a utilização de uma tabela de pré-
codiﬁcação (ver Tabela 8), onde cada letra do alfabeto está associada a um número na
base 10, iniciando por 10 − A, 11 − B, até 35 − Z.

São utilizados números de dois algarismos, pois, se a tabela iniciasse pelo número
1, por exemplo, associado à letra A, poderíamos encontrar ambiguidades no momento da
conversão da mensagem criptografada para o alfabeto original. Por exemplo, se tivéssemos
a seguinte mensagem codiﬁcada 112915, utilizando a tabela a cima, teríamos ambiguidades
em relação à transcrição destes números para letra do alfabeto original, pois, não é
compreensível se tivermos 1 − 12 − 9 − 1 − 5 ou 11 − 29 − 15 entre outras possibilidades.

Tabela 8 – Tabela de Pré-Codiﬁcação

O
P
Q
R
S
T
U
V
W
X
Y
Z

10 A 24
11 B 25
12 C 26
13 D 27
14 E 28
15 F 29
16 G 30
17 H 31
32
I
18
19
33
J
20 K 34
21 L 35
22 M 99 ESPAÇO
23 N

Fonte: Coutinho, 2014

Finalmente, deve-se conceber o método de criptograﬁa RSA seguindo três etapas

55

bem deﬁnidas:

• Pré-Codiﬁcação

• Codiﬁcação

• Decodiﬁcação

4.3.1 Análise Matemática do Método RSA

Na etapa de Pré-Codiﬁcação a mensagem original é convertida em uma sequência

numérica. Esta é “quebrada” em blocos com m números naturais, onde 1 ≤ m < n.

O procedimento da escolha da quebra dos blocos deve respeitar o critério de cada
bloco ser menor que n e de que não se deve escolher m iniciando com algarismo zero, pois
no momento da decodiﬁcação pode haver perda de informações.

Para a codiﬁcação e decodiﬁcação, são determinados dois primos p e q distintos
e suﬁcientemente grandes. Segundo Bose (2008, p. 259), atualmente, com o avanço de
técnicas de fatoração e o uso de força bruta por meio de computadores cada vez mais
potentes, torna-se necessário o comprimento de uma chave pública não inferior a 1024 bits,
o que corresponde a 309 dígitos para utilizar em segurança de informações pessoais, chaves
com 2048 bits (ou 617 dígitos decimais) para sigilo de informações empresariais e 3072
bits, em diante, para chaves de chave para dados governamentais importantes. Em seguida,
obtemos dois importantes resultados que são os valores de n = p · q e φ(n) = (p − 1) · (q − 1).

Na codiﬁcação, escolhe-se o número e ∈ N, 1 < e < φ(n), tal que o mdc (e, φ(n)) = 1,
ou seja, os números e e φ(n) são primos entre si. Vale ressaltar que não existe e ∈ N
quando 1 < e < φ(4), ou seja, p = 2 e q = 2, ou ainda, quando 1 < e < φ(6), portanto,
com n = 2 · 3. Assim, temos a chave de codiﬁcação (chave pública) que é composta por
dois valores: e e n. Ambos valores são públicos, fornecidos pelo receptor e necessários para
que o emissor possa codiﬁcar a mensagem.

Para se determinar a chave de decodiﬁcação dk, precisa-se obter o número d ∈ N,
0 < d < φ(n), tal que e · d ≡ 1 mod φ(n), ou seja, o número d é o inverso múltiplo de
e módulo φ(n). Vale ressaltar que, pelo Teorema 2.3.13, como (e, φ(n)) = 1, então, o
valor de d sempre existe, como também é único pelo Corolário 2.3.12.1. Assim, a chave de
decodiﬁcação (chave privada) dk é composta por dois valores d e φ(n). Assim, o receptor,
que detém esses valores, poderá decodiﬁcar a mensagem recebida.

Segue, então, a codiﬁcação de cada bloco m:

ck(m) ≡ me mod n,

sendo ck(m) a codiﬁcação de cada bloco m pela chave de codiﬁcação ck.

56

Analisando a congruência acima pode-se inferir que ck(m), que é a codiﬁcação do

bloco m, é o resto da divisão de me por n. Logo, a decodiﬁcação de ck(m) será:

dk(ck(m)) ≡ (ck(m))d mod n,

onde dk(ck(m)) é a decodiﬁcação da mensagem codiﬁcada. É necessário observar que
dk(ck(m)) é o resto da divisão de (me)d = med por n.

Vale ressaltar que a demonstração seguirá, primeiramente, analisando a validade das
congruências dk(ck(m)) ≡ m mod p e dk(ck(m)) ≡ m mod q, o que implicará na validade
de dk(ck(m)) ≡ m mod n

Sendo ck(m) ≡ me mod n, queremos mostrar que dk(ck(m)) ≡ m mod n, ou seja,
que a codiﬁcação e a decodiﬁcação são operações inversas e que, conseguimos, ao decodiﬁcar
a codiﬁcação de cada bloco m, retornar à mensagem original. Mostraremos, inicialmente
que, dk(ck(m)) ≡ m mod p, com p primo.

Sendo d o inverso multiplicativo de e módulo φ(n), têm-se ed ≡ 1 mod φ(n), na

qual existe t ∈ N tal que ed = 1 + t · φ(n).

Considerando os seguintes casos:

• Se o mdc (m, p) = 1, utilizando o Pequeno Teorema de Fermat têm-se que mp−1 ≡
1 mod p e elevando ambos os membros da congruência ao expoente t(q − 1), obtemos
(mp−1)t(q−1) = mt(p−1)(q−1) ≡ 1 mod p. Assim, multiplicando ambos os membros por
m, têm-se m1+t(p−1)(q−1) ≡ m mod p. Como 1 + t(p − 1)(q − 1) = 1 + t · φ(n) = ed.
Logo, têm-se que dk(ck(m)) ≡ med = m1+t(p−1)(q−1) ≡ m mod p.

• Se o mdc (m, p) = p, então med = m1+t·φ(n) ≡ m mod p é verdadeira, pois, ambos os

lados são congruentes a zero módulo p.

Logo, dk(ck(m)) ≡ m mod p, para qualquer bloco m da mensagem original. De

modo análogo, têm-se que dk(ck(m)) ≡ (me)d = med ≡ m mod q, com q primo.

Como dk(ck(m)) ≡ m mod p e dk(ck(m)) ≡ m mod q implicam que p | [dk(ck(m))−
m] e q | [dk(ck(m)) − m], sendo p e q primos, tem-se que n = p · q | [dk(ck(m)) − m], ou
seja, dk(ck(m)) ≡ m mod n.

Em resumo, o receptor fornece os valores de e e de n = p · q de forma pública
para um possível emissor. Em seguida, o receptor calcula os valores de d e φ(n) que este
utilizará para decodiﬁcar a mensagem recebida do emissor.

57

4.4 Exemplo de codiﬁcação de uma mensagem

Considerando as três principais etapas do método RSA: Pré-Codiﬁcação, Co-
diﬁcação e Decodiﬁcação torna-se necessária a utilização de um exemplo prático de
codiﬁcação/decodiﬁcação de uma mensagem, chamada original.

4.4.1 Pré-Codiﬁcação

Codiﬁcaremos a seguinte mensagem: “ataquem hoje”. Será utilizada a Tabela 8,
com valores pré-deﬁnidos com dois algarismos cada, que correspondem às letras do alfabeto
e ao caractere espaço.

Na etapa de Pré-Codiﬁcação são necessários alguns cuidados para não haver perda
de informações na etapa de decodiﬁcação da mensagem, informação ambígua ou mesmo
comprometida. Alguns cuidados necessários:

• Utilização de números com dois algarismos iniciando no número 10 (representando
a letra a) até o número 35 (representa a letra z) e o número 99 que representa o
espaço entre duas palavras, para que não haja ambiguidades.

• Não iniciar nenhum bloco da mensagem com algarismo zero.

• Não dividir nenhum bloco da mensagem codiﬁcada de forma que, esse bloco, seja
maior que o produto entre os primos escolhidos, ou seja, cada bloco deve ser menor
que n = p · q.

Logo, a mensagem “ataquem hoje”, pré-codiﬁcada através da tabela 8 é:

102910263014229917241914

A sequência numérica acima é uma sequência pré-codiﬁcada. A quebra em blocos

desta sequência não é única, por exemplo:

102 − 910 − 26 − 301 − 42 − 2 − 99 − 17 − 241 − 9 − 14

ou ainda,

10 − 29 − 102 − 630 − 14 − 22 − 9 − 91 − 72 − 419 − 14

são exemplos de quebras da sequência pré-codiﬁcada em blocos.

Porém, a escolha de cada bloco m deve ser menor que n = p·q. Então, escolhendo-se

dois primos p = 13 e q = 17, têm-se n = 13 · 17 = 221.

Logo, pode-se escolher a seguinte quebra em blocos da sequência numérica que

representa a pré-codiﬁcação:

58

102 − 9 − 10 − 26 − 30 − 142 − 29 − 91 − 72 − 41 − 9 − 14

4.4.2 Codiﬁcação

Para codiﬁcar a sequência acima temos que codiﬁcar cada bloco m utilizando a
chave de codiﬁcação ck. Para isso, é necessário obter o valor de e, ou seja, encontrar o
resto da divisão de me por n. Portanto,

me ≡ ck(m) mod n.

Escolhamos a chave e ∈ N, sendo 1 < e < φ(n), com mdc (e, φ(n)) = 1. Como
φ(221) = (13 − 1) · (17 − 1) = 16 · 12 = 192 e sendo (e, 192) = (e, 26 · 3) = 1, o valor de e
não tem fatores 2 e 3. Logo, e pode ser 35 = 5 · 7 < 192.

Calculando cada bloco m de acordo com a congruência me ≡ ck(m) mod n, obtêm-

se ck(m) que é a codiﬁcação de cada bloco m:

• 10235 ≡ ck(102) mod 221 =⇒ 10235 = (1022)17 · 102 ≡ 1717 · 102 = (172)8 · 17 · 102 ≡
688 · 1734 = (682)4 · 1734 ≡ 2044 · 187 = (2042)2 · 187 ≡ 682 · 187 ≡ 204 · 187 =
38148 ≡ 136 mod 221. Ou seja, ck(102) = 136.

• 935 ≡ ck(9) mod 221 =⇒ 935 = (93)11 · 92 ≡ 6611 · 81 = (662)5 · 66 · 81 ≡ 1575 · 5346 =
(1572)2 · 157 · 5346 ≡ 1182 · 157 · 42 = 13924 · 6594 ≡ 1 · 185 ≡ 185 mod 221. Ou seja,
ck(9) = 185.

• 1035 ≡ ck(10) mod 221 =⇒ (105)7 ≡ 1087 = (1082)3 · 108 ≡ 1723 · 108 ≡ 144 · 108 =

15552 ≡ 82 mod 221. Ou seja, ck(10) = 82.

• 2635 ≡ ck(26) mod 221 =⇒ 2635 = (262)17 · 26 ≡ 1317 · 26 = (133)5 · 132 · 26 ≡
2085 · 4394 = (2082)2 · 208 · 4394 ≡ 1692 · 208 · 195 = 28561 · 40560 ≡ 52 · 117 =
6084 ≡ 117 mod 221. Ou seja, ck(26) = 117.

• 3035 ≡ ck(30) mod 221 =⇒ 3035 = (303)11 · 302 ≡ 3811 · 16 = (383)3 · 382 · 16 ≡
643 · 23104 ≡ 643 · 120 = 262144 · 120 ≡ 38 · 120 = 4560 ≡ 140 mod 221. Ou seja,
ck(30) = 140.

• 14235 ≡ ck(142) mod 221 =⇒ 14235 = (1422)17 · 142 ≡ 5317 · 142 = (533)5 · 532 · 142 ≡
1445 · 157 · 142 = (1442)2 · 144 · 22294 ≡ 1832 · 144 · 194 = 33489 · 27936 ≡ 118 · 90 =
10620 ≡ 12 mod 221. Ou seja, ck(142) = 12.

• 2935 ≡ ck(29) mod 221 =⇒ 2935 = (293)11 · 292 ≡ 7911 · 178 = (792)5 · 79 · 178 ≡
535 · 14062 ≡ (532)2 · 53 · 139 = 28092 · 7367 ≡ 1572 · 74 = 24649 · 74 = 1824026 ≡
113 mod 221. Ou seja, ck(29) = 113.

59

• 9135 ≡ ck(91) mod 221 =⇒ 9135 = (913)11 · 912 = 75357111 · 8281 ≡ 18211 · 104 =
(1822)5 · 182 · 104 = 331245 · 18928 ≡ (1952)2 · 195 · 143 = 380252 · 27885 ≡ 132 · 39 =
169 · 39 = 6591 ≡ 182 mod 221. Ou seja, ck(91) = 182.

• 7235 ≡ ck(72) mod 221 =⇒ 7235 = (723)11 · 722 = 37324811 · 5184 ≡ 20011 · 101 =
(2002)5 · 200 · 101 = 400005 · 20200 ≡ 2205 · 89 = (2202)2 · 220 · 89 = 484002 · 19580 ≡
12 · 132 ≡ 132 mod 221. Ou seja, ck(72) = 132.

• 4135 ≡ ck(41) mod 221 =⇒ 4135 = (413)11 · 412 = 6892111 · 1681 ≡ 19011 · 134 =
(1902)5 · 190 · 134 = 361005 · 25460 ≡ 775 · 45 = (772)2 · 77 · 45 = 59292 · 3465 ≡
1832 · 150 = 33489 · 150 ≡ 118 · 150 = 17700 ≡ 20 mod 221. Ou seja, ck(41) = 20.

• Este bloco é idêntico à outro bloco já codiﬁcado. Logo, ck(9) = 185.

• 1435 ≡ ck(14) mod 221 =⇒ 1435 = (143)11 · 142 = 274411 · 196 ≡ 9211 · 196 =
(922)5 · 92 · 196 = 84645 · 18032 ≡ 665 · 131 = (662)2 · 66 · 131 = 43562 · 8464 ≡
1572 · 27 = 24649 · 27 = 665523 ≡ 92 mod 221. Ou seja, ck(14) = 92.

Vale ressaltar que as etapas dos cálculos acima foram realizados considerando
as propriedades mencionadas nos capítulos anteriores, a ﬁm de manipular valores sem
a utilização de máquinas para calcular e sem excesso de tempo. Por exemplo, 1435 =
(143)11 · 142, pois foi observado que seria mais fácil para uma pessoa efetuar os cálculos
143 e 142 sem o auxílio de calculadoras e chegar a um valor de resto, quando divido pelo
valor de n = 221.

Logo, concluí-se que a codiﬁcação da mensagem original é:

136 − 185 − 82 − 117 − 140 − 12 − 113 − 182 − 132 − 20 − 185 − 92

A mensagem codiﬁcada acima é que será enviada ao destinatário. É importante
observar que, para que não haja perda de informações, deve-se manter a ordem dos blocos
codiﬁcados.

4.4.3 Decodiﬁcação

Em posse da mensagem codiﬁcada acima, o receptor decodiﬁcará a mensagem

utilizando a chave privada d, onde d é o inverso multiplicativo de e módulo φ(n),

e · d ≡ 1 mod φ(n),

onde d ∈ N e 0 < d < φ(n). Logo, calculando o valor de d, tem-se:

35d ≡ 1 mod φ(221) =⇒ 35d ≡ 1 mod 192 =⇒ 35 · 11 = 385 ≡ 1 mod 192. Então, d = 11.

60

O valor de d é encontrado utilizando o valor de φ(n). Em particular, este valor de
d = 11 foi encontrado utilizando tentativa e erro, porém existem outras técnicas como o
Algoritmo de Euclides. Conhecido o valor de d, tem-se a seguinte congruência que relaciona
o valor de d e n, sendo dk(ck(m)) o resto da divisão de cada bloco codiﬁcado med por n.
Então, a decodiﬁcação da sequência codiﬁcada é igual ao próprio bloco m original, ou seja,
dk(ck(m)) = m. Logo,

(me)d ≡ dk(ck(m)) mod n =⇒ (ck(m))d ≡ dk(ck(m)) ≡ m mod n

Calculando a decodiﬁcação de cada bloco da sequência codiﬁcada tem-se:

• (ck(m))d ≡ m mod n =⇒ 13611 = (1362)5 · 136 = 184965 · 136 ≡ 1535 · 136 =
(1534) · 153 · 136 = 547981281 · 20808 ≡ 68 · 34 = 2312 ≡ 102 mod 221. Ou seja,
dk(136) = 102.

• (ck(m))d ≡ m mod n =⇒ 18511 = (1852)5 · 185 = 342255 · 185 ≡ 1915 · 185 =

1914 · 191 · 185 ≡ 35 · 191 · 185 = 1236725 ≡ 9 mod 221. Ou seja, dk(185) = 9.

• (ck(m))d ≡ m mod n =⇒ 8211 = (822)5 · 82 = 67245 · 82 = (67242)2 · 6724 · 82 ≡
2172·551368 ≡ 2172·194 = 47089·194 = 9135266 ≡ 10 mod 221. Ou seja, dk(82) = 10.

• (ck(m))d ≡ m mod n =⇒ 11711 = (1172)5 · 117 = 136895 · 117 = (136892)2 · 13689 ·

117 ≡ 1692 · 1601613 ≡ 52 · 26 = 1352 ≡ 26 mod 221. Ou seja, dk(117) = 26.

• (ck(m))d ≡ m mod n =⇒ 14011 = (1402)5 · 140 = 196005 · 140 = (196002)2 · 19600 ·
140 = 3841600002 · 2744000 ≡ 1202 · 64 = 14400 · 64 = 921600 ≡ 30 mod 221. Ou
seja, dk(140) = 30.

• (ck(m))d ≡ m mod n =⇒ 1211 = (122)5 · 12 = 1445 · 12 = (1442)2 · 144 · 12 =
207362 · 1728 ≡ 1832 · 181 = 33489 · 181 = 6061509 ≡ 142 mod 221. Ou seja,
dk(12) = 142.

• (ck(m))d ≡ m mod n =⇒ 11311 = (1132)5 · 113 = 127695 · 113 ≡ 1725 · 113 =
(1722)2 · 172 · 113 = 295842 · 19436 ≡ 1912 · 209 = 36481 · 209 = 7624529 ≡ 29 mod 221.
Ou seja, dk(113) = 29.

• (ck(m))d ≡ m mod n =⇒ 18211 = (1822)5 · 182 = 331245 · 182 ≡ 1955 · 182 =
(1952)2 · 195 · 182 = 380252 · 35490 ≡ 132 · 130 = 21970 ≡ 91 mod 221. Ou seja,
dk(182) = 91.

• (ck(m))d ≡ m mod n =⇒ 13211 = (1322)5 · 132 = 174245 · 132 ≡ 1865 · 132 =
(1862)2 · 186 · 132 = 345962 · 24552 ≡ 1202 · 21 = 302400 ≡ 72 mod 221. Ou seja,
dk(132) = 72.

61

• (ck(m))d ≡ m mod n =⇒ 2011 = (202)5 · 20 = 4005 · 20 ≡ (4002)2 · 400 · 20 =

1600002 · 8000 ≡ 2172 · 44 = 2071916 ≡ 41 mod 221. Ou seja, dk(20) = 41.

• (ck(m))d ≡ m mod n =⇒ 18511 = (1852)5 · 185 = 342255 · 185 ≡ 1915 · 185 =

1914 · 191 · 185 ≡ 35 · 191 · 185 = 1236725 ≡ 9 mod 221. Ou seja, dk(185) = 9.

• (ck(m))d ≡ m mod n =⇒ 9211 = (922)5 · 92 = 84645 · 92 ≡ 665 · 92 = 663 · 662 · 92 =
287496 · 4356 · 92 ≡ 196 · 157 · 92 = 2831024 ≡ 14 mod 221. Ou seja, dk(92) = 14.

Observa-se que a decodiﬁcação de cada bloco ck(m), ou seja, cada bloco codiﬁcado
da mensagem original, é idêntico ao bloco m da mensagem original. Assim, d(ck(m)) = m,
o que veriﬁca a validade das chaves e método utilizados para encriptar mensagens.

4.5 Segurança do Método RSA e a Segurança da Informação

4.5.1 Segurança do Método RSA

Existem diversos métodos que são utilizados na segurança de dados da internet
e até de informações conﬁdenciais de países. Entre esses, o Método RSA é um dos mais
utilizados pela sua característica de ser implementado através de chaves assimétricas,
onde uma destas chaves é pública e outra é privada, possibilitando, assim, a rapidez na
comunicação.

Por outro lado, a sua ampla utilização se deve também à sua segurança, ou seja, à
capacidade de proteção das informações transmitidas ou armazenadas de forma considerada
invulnerável. Essa invulnerabilidade é baseada, principalmente, no tamanho de suas chaves,
ou seja, na quantidade de algarismos que os números p e q primos possuem. Quanto
maiores esses primos, previamente escolhidos, maior será o produto n entre eles que será a
chave pública.

Daí então surgem diversas indagações sobre a vulnerabilidade do conhecimento
de p e q primos através da divulgação de n. E é exatamente esse o segredo da segurança
deste método. Uma vez escolhidos p e q muito grandes com 100 ou mais algarismos cada,
tem-se uma chave n também muito grande (com muitos algarismos) e, por causa das
características dos números primos e da ineﬁciência de métodos de decomposição de inteiros
tão grandes torna-se improvável a sua descoberta.

Portanto, a segurança deste método de criptograﬁa consiste na utilização de primos
com muitos algarismos e na falta de eﬁciência de métodos (ou algoritmos) que consigam
decompor o produto desses primos pelo menos de forma razoavelmente rápida. Coutinho
(2014, p. 158) aﬁrma que só para testar se suas chaves eram realmente seguras o RSA
Laboratory, empresa que obtém os direitos de implementação do código RSA, apresentava,
de tempos em tempos, um código com chaves de tamanhos não tão grandes para saber se

62

algum indivíduo conseguiria decompor em tempo hábil os fatores primos. Em 2005, alguns
cientistas do Escritório Federal de Segurança da Informação da Alemanha (Bundesamt
für Informationssicherheit) conseguiram decompor o último destes códigos cuja chave
possuía 193 algarismos. Os cálculos foram feitos em nada menos que 5 meses, utilizando
80 computadores com alta velocidade. Ou seja, a rapidez da troca de informações com
a utilização de um produto de dois primos muito grande supera extremamente a sua
decodiﬁcação.

4.5.2 Segurança da Informação no cotidiano

Para Ferreira (2003, p. 162), a segurança da informação “protege a informação de
diversos tipos de ataques que surgem no ambiente organizacional, garante a continuidade
dos negócios, reduz as perdas e maximiza o retorno dos investimentos e das oportunidades”.

Em outra deﬁnição, Sêmola (2003, p. 43) diz que a segurança da informação é
“uma área do conhecimento dedicada à proteção de ativos da informação contra acessos
não autorizados, alterações indevidas ou sua indisponibilidade”.

O Método RSA é baseado em cálculos matemáticos, o que possibilita maior proteção
das informações. Desta forma, ﬁcam garantidos os princípios da segurança da informação
estabelecidos pela ABNT NBR ISO/IEC 27002:2013 (ver (ABNT, 2013)), correspondente
aos três primeiros princípios citados a seguir e ainda os princípios acrescentados por Sêmola
(2003, p. 11), que segundo Fernandes (2013, p. 20), são:

• Conﬁdencialidade - garante o acesso das informações à somente pessoas autoriza-

das.

• Disponibilidade - permite que as informações desejadas sejam acessadas a qualquer

momento.

• Integridade - garante a exatidão e inviolabilidade das informações.

• Legalidade - garante que as informações estejam de acordo com a lei vigente.

• Autenticidade - garante a veracidade das informações transmitidas e recebidas,

como também, a legitimidade dos usuários envolvidos.

A segurança da informação afeta-nos em diversas situações cotidianas e, por muitas
vezes, nem percebemos. Quando falamos em ﬁrewall, por exemplo, estamos citando um
programa de proteção de nossos dados em nosso computador, mas quando enviamos
esses dados pela rede precisamos também garantir que estes, se interceptados, não sejam
revelados. Assim, a necessidade da criptograﬁa se apresenta como proteção.

63

Citando um exemplo prático relacionado à proteção de dados pessoais enviados
pela rede, destaca-se o caso dos bloqueios realizados pela justiça brasileira ao aplicativo
de mensagens WhatsApp, considerado um dos mais utilizados no mundo para sua função,
entre os anos de 2015 e 2016, onde haviam quatro ordens judiciais que exigiam o acesso, por
parte da Polícia Federal, à contas suspeitas de serem utilizadas por criminosos. Na época,
as ações foram baseadas na Lei Nº 12.965 de 2014, conhecida como Marco Civil da internet,
disponível em Brasil (2014), onde são apregoados os princípios norteadores para expansão
da comunicação de rede no Brasil. No artigo 7º desta Lei é dito: “O acesso à internet é
essencial ao exercício da cidadania, e ao usuário são assegurados os seguintes direitos...”. No
mesmo artigo, no inciso III é dito: “inviolabilidade e sigilo de suas comunicações privadas
armazenadas, salvo por ordem judicial”.

Como resposta às solicitações da justiça, o WhatsApp informou que não conseguiria
repassar essas informações (conversas trocadas por meio de tais contas), pois nem o próprio
aplicativo teria acesso a elas, uma vez que são criptografadas de “ponta a ponta” (ou,
em inglês, “end-to-end”). Ou seja, a criptograﬁa utilizada não permite que a mensagem
trocada entre dois indivíduos, quando interceptada, seja legível, incluindo os servidores do
próprio WhatsApp.

O tipo de criptograﬁa utilizada é a assimétrica, chamada end-to-end encryption ou
E2EE, onde dois indivíduos A e B em uma conversa pelo WhatsApp possuem suas chaves
privadas e públicas, como na RSA.

Assim, quando A quer mandar uma mensagem para B, o aplicativo de A “busca”
a chave pública de B, através do servidor do aplicativo, e codiﬁca a mensagem que
é transmitida para B. A partir daí, o aplicativo de B, utiliza sua chave privada para
decodiﬁcar a mensagem recebida.

Assim, os responsáveis pelo WhatsApp alegaram que as informações solicitadas
pela Justiça estavam debaixo de muitas camadas de criptograﬁa e que não seria possível
fornecê-las.

O método para veriﬁcar se uma conversa entre dois indivíduos realmente está
criptografada é conferir se o código de segurança que aparece no aplicativo de ambos
são iguais ou também um dos indivíduos pode utilizar o seu aparelho para escanear o
código QR do outro aparelho (ver Figura 5) e, então aparecerá um sinal da cor verde, caso
esta conversa esteja segura. Por outro lado, a criptograﬁa de ponta a ponta só assegura a
conﬁdencialidade das informações quando são transmitidas. Ou seja, caso um hacker acesse
o celular de um indivíduo e este não possua um sistema de segurança em seu aparelho,
as informações do WhatsApp poderão ser acessadas. Por esta razão, o próprio aplicativo
recomenda ao usuário ativar a “veriﬁcação em duas etapas”, ou seja, de tempos em tempos
o aplicativo requer uma senha que o usuário cadastrou no aplicativo. Essa funcionalidade
também impede que uma pessoa que queira instalar o WhatsApp de outro indivíduo no

aparelho deste, sem o conhecimento daquele, tenha êxito, pois serão necessário, além do
código enviado ao aparelho, a senha cadastrada no aplicativo, evitando possíveis clonagens.

Figura 5 – Ilustração do Código de Segurança - QR Code

64

Fonte: Simões, 2019

O Ministro do STF Ricardo Lewandowski, em 2016, impetrou uma medida liminar

liberando o funcionamento do aplicativo. 1

1 Segundo

o

Globo,
<https://g1.globo.com/tecnologia/noticia/bloqueios-ao-whatsapp-no-brasil-chegam-ao-stf-
entenda.ghtml>, com acesso em 25 de janeiro de 2020.

com o

acordo

sítio

site

G1

do

da

de

eletrônico:

5 A HIPÓTESE DE RIEMANN E PROBLEMAS P VS NP

65

Em 1900, no ICM (International Congress of Mathematicians), em Paris, o mate-
mático David Hilbert listou 23 problemas que, segundo ele, ocupariam os matemáticos
durante o século XX. O problema de número oito foi a Hipótese de Riemann. De todos os
problemas listados por Hilbert, somente a conjectura feita por Bernhard Riemann não foi
ainda resolvida até a presente data.

Em 2000, o Clay Mathematics Institute (CMI), organização sem ﬁns lucrativos,
criada em 1998 pelo empresário Landon T. Clay, apresentou outra lista com 7 problemas
em aberto da matemática. A Hipótese de Riemann era o único problema que fazia parte
de ambas as listas. Essas questões em aberto foram chamadas de Problemas do Milênio.

Para incentivar a pesquisa matemática no mundo o Clay Mathematics Institute
(CMI), prometeu premiar com 1 milhão de dólares quem conseguisse resolver qualquer um
dos 7 problemas em aberto. Atualmente, somente a Conjectura de Poincaré foi resolvida
pelo matemático russo Grigori Perelman, em 2010, que recusou a premiação.

5.1 Hipótese de Riemann

A Hipótese de Riemann é uma conjectura relacionada ao cálculo da densidade dos
números primos por meio da determinação dos zeros da função zeta de Riemann dada pela
soma inﬁnita de potências de números complexos.

5.1.1 Bernoulli e Euler

Muitos matemáticos ao longo dos anos tiveram a curiosidade de estudar o conceito
de séries inﬁnitas. As séries são geradas pela soma dos termos de uma sequência. Algumas
séries causam estranheza, por isso, o tempo dedicado por alguns brilhantes matemáticos
em entender suas propriedades.

Muitos matemáticos já anunciaram ter resolvido a Hipótese de Riemann. Porém,

porém quando seus estudos passaram por análise foram encontrados erros.

As séries inﬁnitas podem convergir ou divergir. As séries convergentes são aquelas
cujas somas parciais dos termos de uma sequência inﬁnita vão se aproximando de um
determinado número. Ou seja, o limite das somas parciais tendem a um determinado
número. As séries que não são convergentes são denominadas divergentes, portanto, as
somas parciais não tendem a um número especíﬁco. Logo, quanto mais somam-se parcelas
a uma soma parcial mais este aumenta ou diminui inﬁnitamente.

Em 1689, o matemático Jacob Bernoulli (1655 − 1705) começou a estudar as séries

do tipo:

66

1 + 1

2n + 1

3n + 1

4n ..., para cada n ∈ N − {1}.

Já era conhecido desde 1650 que a série harmônica 1 + 1

2 + 1

3 + 1

4... é divergente, ou

seja, que essa soma cresce indeﬁnidamente.

Em 1735, o matemático suíço Leonhard Euler (1707 − 1783) começou a estudar a

função zeta ζ(n) = 1 + 1

2n + 1

3n + 1

4n ..., para n ∈ R.

Segundo Devlin (2004, p. 65), Euler provou que ζ(2) = π2

6 e logo depois chegou à

conclusão que a função ζ(n) = 1 + 1

2n + 1

3n + 1

4n ... era equivalente à

ζ(n) =

∞
Y

p

!

1
1 − p−n

=

(cid:18)

1
1 − 2−n

(cid:19)

(cid:18)

·

1
1 − 3−n

(cid:18)

(cid:19)

·

1
1 − 5−n

(cid:18)

(cid:19)

·

1
1 − 7−n

(cid:19)

...

com n ∈ R, n > 1 e p primo, conhecido como produto euleriano, indicando assim, a relação
entre a função ζ de Euler e a distribuição dos números primos e indicando como essas
séries poderiam ser escritas na forma de produto em que cada fator teria um número primo
p (PERUZZO, 2012).

5.1.2 Conjectura de Gauss (Teorema dos Números Primos)

O matemático alemão Johann Carl Friedrich Gauss (1777 − 1855), por volta dos
seus 15 ou 16 anos conjecturou sem exibir uma prova formal e utilizando tabelas de primos,
que a quantidade de primos de 1 até x, x ∈ R seria

π(x) ’ x
ln x

Anos depois, o matemático francês Adrien-Marie Legendre (1752−1833) fez diversas
descobertas importantes sobre números primos e, inclusive, realizou outra estimativa para
π(x) em sua obra Essai sur la théorie des nombres, que seria

π(x) ’

x
ln x−1,08366

Já em 1896, dois matemáticos Hadamard e de la Vallée Poussin, independentemente,

provaram que

limx→∞

π(x)
x
ln x

= 1

baseados nas ideias do matemático Riemann.

 
67

Esse teorema ﬁcou conhecido como Teorema dos Números Primos e mostra que a es-
= 1, para x real suﬁcientemente

ln x para π(x) é razoável, pois π(x)

x
ln x

timativa feita por Gauss π(x)
grande.

A Tabela 9 apresenta os valores de π(x) e a estimativa x

ln x, feita por Gauss:

Tabela 9 – Valores de π(x) e estimativa em relação a x
ln x

x
10
100
1000
10000
100000
1000000
10000000
100000000
1000000000
10000000000

π(x)
4
25
168
1229
9592
78498
664579
5761455
50847534
455052511
Fonte: Peruzzo, 2012

x
ln x
4, 34
21, 72
144, 76
1085, 74
8685, 83
72358, 9
620424, 37
5428881, 65
48255561, 45
434291670, 28

Mais tarde, Gauss formulou um conceito que trouxe um melhor reﬁnamento à
dt
ln t é

estimativa da quantidade de primos até um determinado x ∈ R, ou seja, L(x) = R x
2
uma aproximação mais razoável para π(x).

5.1.3 Bernhard Riemann

O matemático alemão Georg Friedrich Bernhard Riemann (1826 − 1866) apresentou
um artigo sobre a função zeta de Gauss em 1859, onde sua pretensão seria provar a
Conjectura de Gauss. Mesmo não obtendo êxito neste objetivo, Riemann formulou um
conceito importante que é conhecido como Função Zeta de Riemann.

Primeiramente, Riemann estudou a função ζ(n) de Gauss, para n ∈ R e estendeu

o conceito para s ∈ C, ou seja, a função zeta de Riemann é

ζ(s) = P∞

n=1

1
ns , para cada Re(s) > 1,

sendo Re(s) parte real de um número complexo s.

Riemann deﬁniu a função acima para números complexos maiores que 1 e observou
que os valores de s ∈ C para os quais ζ(s) = 0, ou seja, os chamados zeros triviais da
função zeta seriam todos da forma −2n, n ∈ N. Estes zeros seriam os inteiros pares
negativos: {−2, −4, −6, ...}.

68

Finalmente, Riemann notou que os zeros não triviais da função zeta estavam
entre os números complexos s, cuja parte real encontrava-se no intervalo entre 0 e 1. Daí
quando este conseguiu calcular alguns zeros não triviais de ζ(s) começou a obter valores
posicionados não aleatoriamente no plano complexo, mas sim “enﬁleirados” em relação aos
números complexos s, com parte real Re(s) = 1
2 + k · i,
sendo k ∈ R e i (unidade imaginária). Essa reta onde esses zeros de ζ(s) pareciam estar
concentrados foi chamada de reta crítica.

2, ou seja, os números da forma s = 1

Riemann conjecturou que então “todos os zeros não triviais da função ζ estão na
reta crítica”. Esta aﬁrmativa ﬁcou conhecida como Hipótese de Riemann e é o mais famoso
dos problemas em aberto (DEVLIN, 2004).

Esse comportamento não aleatório dos zeros não triviais da função zeta, se com-
provada, demonstra a relação entre a função zeta e a distribuição dos números primos.
Segundo Peruzzo (2012, p. 55) “A hipótese de Riemann é considerada o problema mais
profundo e fundamental da teoria dos números, e está intimamente ligada à distribuição
dos números primos”. Embora Riemann tenha iniciado seus estudos sobre a função zeta
com a intenção de concluir a Conjectura de Gauss, ele conseguiu estabelecer uma hipótese
que pode ter aplicações em diversas áreas. Em relação à densidade dos números primos,
pode-se concluir que a veracidade desta conjectura implicaria num padrão mais geral em
relação à sua distribuição:

Riemann mostrou que se todos os zeros complexos (não reais) da função
zeta tiverem parte real igual a 1/2, então o grau segundo o qual a função
densidade D(n) = φ(n)
ln(n) varia de uma maneira
n
aleatória, parecida com o modo como a proporção de caras que você
obtém quando joga uma moeda varia em torno de 1
2 . Isso signiﬁca que
ainda que você não possa prever de forma acurada quando é que o próximo
primo ocorrerá, o padrão global é extremamente regular. (DEVLIN, 2004,
p. 69)

difere da curva

1

Já em 1914, o matemático britânico Godfrey Hardy demonstrou que existem
2. Porém, não obteve

inﬁnitos zeros não triviais da função zeta na reta crítica Re(s) = 1
êxito na demonstração da Hipótese de Riemann.

5.2 Problemas P vs NP

5.2.1 Deﬁnições importantes

Assim como a Hipótese de Riemann, o Problema P = N P é considerado um dos
maiores problemas matemáticos do milênio. Porém, as aplicações deste problema abrangem
outras áreas, como a Ciência da Computação, por exemplo.

A Ciência da Computação, segundo Martins (2019, p. 4), é “a ciência que estuda as
técnicas, metodologias e instrumentos computacionais, visando automatizar os processos e
desenvolver soluções com o uso de processamento de dados”. A automatização de processos
sejam eles quais forem, precisa de formulação teórica, ou seja, uma lista do “passo a passo”

69

lógico que esse programa deve assumir. Passos lógicos são as operações que o computador
irá realizar para chegar em uma solução. Na Matemática também utilizam-se técnicas bem
deﬁnidas logicamente para se chegar a alguma conclusão (solução) formal. Chama-se à essa
sequência de passos lógicos de algoritmo. Um algoritmo computacional seriam os passos
lógicos que devem ser processados pelo computador para obter soluções que atendam às
condições de um determinado problema.

Um dos ramos mais importantes da Ciência Computacional é a Teoria da Comple-
xidade Computacional, onde é estudada a viabilidade de um determinado problema ou
conjunto de problemas serem resolvidos através de um determinado algoritmo. Ou seja,
segundo Oliveira (2010, p. 4), mede “os recursos necessários e suﬁcientes para solucionar
problemas algorítmicos concretos”.

O estudo da Complexidade Computacional visa relacionar a eﬁciência ou não de
determinados problemas em serem resolvidos utilizando-se algoritmos relacionados aos
mesmos em tempo razoável. Uma classe (conjunto) de problemas que os métodos compu-
tacionais empregados para solucioná-los não apresentam resultados eﬁcientes (rápidos) são
considerados não-determinísticos. Já aqueles que as técnicas computacionais implementa-
das (algoritmos) alcançam êxito em tempo razoável são denominados determinísticos (ou
eﬁcientes).

5.2.2 Tempo Polinomial

Segundo Oliveira (2010, p. 18), pesquisadores em Ciência da Computação descobri-
ram diversos problemas em que seus algoritmos demoravam muito tempo para resolvê-los,
tornando a busca por uma solução inviável.

Exemplo desse tipo de problema é o conhecido Problema do Caixeiro Viajante: um
comerciante deseja fazer um itinerário partindo de uma determinada cidade A, passando
por outras n − 1 outras cidades e retornando para a cidade A, tudo isso percorrendo a
menor distância total.

Aparentemente simples, este problema possui n! possibilidades de escolhas para os
possíveis trajetos, o que torna o trabalho de análise da menor distância muito demorado.
Daí a necessidade de descobrir métodos computacionais (caso existam) com maior eﬁciência,
ou seja, menor tempo de execução.

Deﬁnição 5.2.1. Seja f (x) uma função dominante assintoticamente em relação à função
p(x). Então existem duas constantes c e m reais positivas tais que

|p(x)| ≤ c · |f (x)|, ∀ x ≥ m

A deﬁnição restringe as funções p e f às suas imagens não negativas. O gráﬁco da
Figura 6 ilustra o comportamento assintótico dominante de f em relação à p, para todos

os valores do domínio maiores que m.

Figura 6 – Gráﬁco do comportamento assintótico dominante da função f em relação à p

70

Fonte: Fortes, 2013

A partir da noção acima, podemos deﬁnir a Notação assintótica ou Notação de
Bachmann-Landau O (O-Grande ou letra grega Ômicron) que descreve o comportamento
limitante ou assintótico de uma função em relação à outra. Dizemos que uma função p =
O(f (x)), ou seja, p está na ordem O de f , se f for uma função dominante assintoticamente
em relação à p.

Um exemplo prático seriam de duas funções f e g, onde f (x) = 3x2 + 6x + 5 e

g(x) = x2. Temos:

3x2 + 6x + 5 ≤ 3x2 + 6x2 + 5x2 = 14x2,

ou seja, f (x) ≤ 14 · g(x), ∀x ≥ 1 e portanto, f (x) = O(g(x)), ou ainda f (x) = O(x2).

Portanto, após a deﬁnição da notação assintótica (O), tem-se imediatamente a
deﬁnição de eﬁciência (tempo) de execução de um determinado algoritmo. Destacam-se,
duas classes de comportamento assintótico:

• f (x) = O(c · kx), com k > 1 e c constante de acordo com o problema: algoritmos com
essa função de complexidade são denominados algoritmos exponenciais em relação
ao tempo de execução.

• f (x) = O(p(x)) = O(c · xk), k (constante positiva) e c constante de acordo com o pro-
blema, sendo p(x) um polinômio em x: algoritmos com essa função de complexidade
são denominados algoritmos polinomiais em tempo de execução.

71

O algoritmo de um problema que possui função de complexidade igual a um
polinômio tem um tempo polinomial de execução, o é considerado mais eﬁciente, pois
proporciona um resultado (output) em tempo razoável. Já o algoritmo de um problema
que apresenta função de complexidade exponencial possui um tempo de execução inviável,
denominado tempo exponencial. A Figura 7 a seguir apresenta o tempo de execução de
diferentes algoritmos.

Figura 7 – Tempo de execução de algoritmos distintos em relação às suas classes de complexidades

Fonte: Devlin, 2004

Um problema é reconhecido como eﬁciente, ou seja, exibe menor tempo de execução
quando existe um comportamento assintótico em relação a uma função polinomial p(x),
onde x são os valores de entrada (input) suﬁcientemente grandes. Ou seja, existe uma
função f (x) que domina assintoticamente p(x), ∀x ≥ m, m constante.

5.2.3 Problemas P e NP

Pode-se, classiﬁcar alguns problemas computacionais como P (Problemas de tempo
polinomial determinístico). Como exemplo de problema pertencente à classe de problemas
P tem-se o de decidir se um inteiro é primo ou não.

Já os problemas cujos algoritmos possuem tempo de execução exponencial, mas
dada uma solução, possui decisão da veracidade ou não desta em tempo polinomial, são
classiﬁcados como problemas da classe N P , ou seja, problemas de tempo polinomial
não-determinístico. Como exemplo de problema pertencente à classe de problemas N P
tem-se o da fatoração de um inteiro dado.

Observando as duas classes deﬁnidas acima, pode-se inferir que P ⊆ N P , pois
todos os problemas que são resolvidos em tempo polinomial também possuem tempo
polinomial para veriﬁcação de uma solução dada.

72

5.2.4 Problema do Milênio P = NP?

Este é um dos Problemas do Milênio, formulado inicialmente por Stephen Cook e
Leonid Levin em 1971. O problema P = N P é o maior problema em aberto da Ciência da
Computação.

O problema, em questão, consiste em saber se P = N P , ou seja, se os problemas
de classe de complexidade N P também pertencem à classe P de complexidade. A questão
é se N P ⊆ P , ou seja, caso os problemas de classe N P pertençam à classe P , então a
conclusão seria a igualdade entre ambas as classes.

A dúvida consiste em saber se os problemas de classe N P também podem ser
resolvidos em tempo polinomial. Os problemas de classe N P possuem algoritmos que
executam a procura por uma solução em tempo exponencial. Assim, a descoberta da
veracidade do problema P = N P traria a conclusão que para todos os problemas de classe
N P existiria algum algoritmo que buscaria a solução em tempo polinomial. Desta forma,
até os mais difíceis problemas teriam solução rápida.

Já se for comprovada que a questão é falsa, ou seja, P 6= N P , então, será admitido
que existem problemas computacionais em que os algoritmos procuram soluções utilizando
“força bruta” em tempo exponencial.

Ainda existem problemas de classe N P que são considerados muito difíceis, os
denominados N P -completos, como o do Caixeiro Viajante. Esta classe possui uma im-
portante característica: caso algum problema desta classe puder ser resolvido em tempo
polinomial, então toda a classe N P também possui algum algoritmo que execute uma
solução em tempo polinomial, ou seja, P = N P . Vale ressaltar que os problemas de classe
N P -completos possuem a característica de que todos os outros problemas de classe N P
se reduzem a ele.

5.3 Os Problemas do Milênio e a Criptograﬁa RSA

A segurança da Criptograﬁa RSA, a princípio, consiste em dois problemas. A pri-
meira delas, identiﬁca o cálculo da fatoração de um inteiro n suﬁcientemente grande, como
algo muito difícil de ser realizado até por meio computacional. O problema de decompor n
em fatores primos, sendo n com mais de 1024 bits, é considerado de complexidade N P .
Logo, teoricamente, é mais fácil, tendo p e q primos, conferir se p · q = n (complexidade
polinomial). Porém, os algoritmos utilizados atualmente para a fatoração de n demorariam
um tempo demasiadamente grande para chegar na decomposição p · q a partir de n.

Em Coutinho (2014, p. 158), podemos encontrar um dos desaﬁos implementados
pelo RSA Laboratory. Neste desaﬁo público, o número inteiro possuía 193 algarismos e
sua fatoração foi ﬁnalizada em novembro de 2005, por F.Bahr, M. Boehm, J. Franke e T.
Kleinjung, após 5 meses e o uso de 80 computadores.

73

O problema refere-se à existência de alguma função que consiga representar um
padrão em relação aos números primos. De forma que, seja possível encontrar qualquer
número primo, maior que fosse, com rapidez. Vimos que muitos matemáticos tentaram
implementar polinômios geradores de primos e funções que pudessem caracterizá-los quanto
à sua distribuição dentro dos números naturais. Porém, algumas funções apresentavam
primos até um certo valor do domínio, mas também apresentavam números compostos.

Pode-se observar, no entanto, que as conjecturas alçadas nesta pesquisa como a
Hipótese de Riemann e o Problema P = N P tem relações diretas com esses problemas
mencionados acima. Em relação à Conjectura de Riemann, este aﬁrmou que as soluções não
triviais da função zeta de Riemann estão na reta crítica, ou seja, é um número complexo
2 + b · i, sendo b ∈ R e i número imaginário. Por outro lado, a função zeta de
da forma 1
Riemann pode ser relacionada aos números primos. Caso esta conjectura seja provada,
abrirá caminho para a descoberta de um padrão de distribuição dos números primos
dentro dos números naturais. Logo, a própria descoberta da veracidade da Conjectura de
Riemann, pode gerar mais técnicas matemáticas que implicariam num padrão geral sobre
os números primos, conforme Devlin (2004, p. 74).

Desta forma, o problema P = N P apresenta relevante importância pois sua
comprovação signiﬁcaria que qualquer problema NP também pertence à classe P . Ou
seja, para qualquer problema com algoritmos de resolução que precisam de um tempo
considerável ou mesmo impraticável para se chegar a um determinado resultado, existiria
algum algoritmo mais eﬁcaz que possuiria complexidade de tempo polinomial para gerar
uma solução.

Portanto, todos os problemas, até aqueles considerados mais difíceis, poderiam
ser solucionados. Bastaria apenas encontrar o algoritmo mais apropriado. A conclusão de
que P = N P impactaria consideravelmente o problema da segurança criptográﬁca, pois
revelaria que o problema da fatoração de inteiros muito grandes é solucionável em tempo
polinomial, sendo apenas necessária a utilização de novos algoritmos mais eﬁcientes.

A prova da Conjectura de Riemann e do problema P = N P traria uma nova
perspectiva em relação aos números primos e à decomposição de inteiros em fatores
primos. Ou seja, toda a base criptográﬁca, da mais atual a mais eﬁciente, que utiliza os
números primos como composições para suas chaves de segurança ﬁcaria exposta. Qualquer
indivíduo que estivesse em posse de tais conhecimentos e algoritmos computacionais
mais eﬁcientes poderia acessar informações consideradas seguras, como senhas bancárias,
informações pessoais e dados governamentais e até militares. Toda a noção e implementação
da criptograﬁa teria que ser repensada.

6 ATIVIDADES

74

As atividades a seguir são propostas para alunos do Ensino Básico (Ensino Fun-
damental II e Ensino Médio), tanto da rede pública quanto da privada. Temos, como
objetivo geral, estimular o estudo da matemática, ao disseminar o conhecimento e incitar
a curiosidade, tanto dos educandos como dos educadores, em relação aos números primos
e suas propriedades.

A Matemática é considerada uma disciplina de difícil compreensão por muitos. É
comum o questionamento, por parte dos educandos, acerca da utilidade de determinados
conceitos matemáticos. Com os números primos essa realidade não é diferente. Muitas
vezes, seu estudo se restringe a fatorar de números naturais pequenos e nem sequer são
abordadas as diversas aplicações cotidianas de suas propriedades, como a criptograﬁa
inclusa em nossas transações bancárias, por exemplo.

Jogos e curiosidades matemáticas podem ser utilizados pelo educador como estímulo
ao educando no processo de ensino e aprendizagem da Matemática. Exemplos práticos como
dominós de frações, jogos de perguntas e respostas baseados em conceitos matemáticos e
oﬁcinas sobre a montagem de cubos mágicos, são apenas alguns destes estímulos. Segundo
Grando (2000, p. 17):

As posturas, atitudes e emoções demonstradas pelas crianças, enquanto
se joga, são as mesmas desejadas na aquisição do conhecimento escolar.
Espera-se um aluno participativo, envolvido na atividade de ensino,
concentrado, atento, que elabore hipóteses sobre o que interage,que
estabeleça soluções alternativas e variadas, que se organize segundo
algumas normas e regras e, ﬁnalmente, que saiba comunicar o que pensa,
as estratégias de solução de seus problemas.

A criptograﬁa também pode desempenhar grande papel motivacional na aprendiza-
gem de Matemática. Embora não pertença ao currículo do Ensino Básico, o desenvolvimento
de técnicas criptográﬁcas, mesmo que primitivas, podem servir de estímulo para o educando
numa aula de Matemática. O conceito de criptograﬁa pode ser utilizado na resolução de
problemas matemáticos, como ressaltou Groenwald; Olgin (2011, p. 20): “metodologia de
resolução de problemas é indicada para o desenvolvimento de atividades didáticas com o
tema Criptograﬁa”.

Um problema matemático apresenta sempre um método de resolução dentro de
conceitos e fórmulas estabelecidas (na criptograﬁa, um algoritmo). Além disso, o educando
para resolver um problema precisa “decodiﬁcar” o enunciado e depois chegar à alguma
conclusão.

Ainda sobre resolver problemas matemáticos tem-se Polya (1978) que relata a
resolução das questões matemáticas através de quatro “passos” gerais, os quais podem ser

75

reformulados assim:

• Primeiramente, a leitura e interpretação do enunciado do problema.

• Seguindo, a compreensão de qual método seja mais eﬁcaz na resolução de uma

determinada questão.

• A seguir, a resolução em si, ou seja, a aplicação do método para a resolução.

• Depois de alcançar um resultado é importante que este seja veriﬁcado se condizente

com a resposta esperada para o problema em questão.

Nas atividades aqui propostas são apresentados um jogo de dominó matemático
inspirado na Conjectura de Goldbach e uma atividade com cubo mágico, sendo utilizando
para codiﬁcação e decodiﬁcação de mensagens, baseado no Quadrado de Vigenère. São
atividades lúdicas e divertidas que ressaltam o aprendizado da matemática, como também
a curiosidade sobre os números primos e a criptograﬁa.

6.1 Detalhamento das atividades

As atividades podem ser aplicadas aos estudantes do Ensino Básico, de acordo com

as seguintes propostas.

• Objetivos: Desenvolver o raciocínio lógico dos estudantes, bem como estimular o

interesse destes pela Matemática.

• Público-Alvo: Estudantes, das redes pública e privada, do Ensino Básico (Ensino

Fundamental II e Ensino médio).

• Metodologia: Primeiramente, serão ministradas 2 aulas (de 50 minutos cada) sobre
os números primos e suas principais propriedades e aplicações (criptograﬁa, por
exemplo), bem como sua relação com os Problemas do Milênio. Em seguida, serão
apresentadas as duas atividades, com tempo máximo de 50 minutos de duração para
realização, em grupo de 2 a 4 estudantes, escolhidos aleatoriamente. As atividades
são práticas e seguem um determinado roteiro.

• Avaliação: Durante o processo de realização das atividades os estudantes serão
avaliados constantemente quanto ao interesse pelos conteúdos propostos e quanto à
criatividade em solucionar os problemas apresentados.

76

6.1.1 Cubo de Vigenère

Após a apresentação do conteúdo sobre números primos e suas propriedades, os
estudantes estarão aptos a participar da atividade denominada de Cubo de Vigenère,
inspirada na versão bidimensional do Quadrado de Vigenère.

É utilizado um cubo de Rubik (ou cubo mágico), com dimensões 7x7x7 para
aproveitar as 28 faces dos cubos menores que ﬁcam no entorno de cada camada lateral
(7 · 4 = 28). Em cada face pequena é apresentada uma letra (de A a Z) ou um número (0
ou 1). A primeira camada superior do cubo apresenta o alfabeto minúsculo (representando
as letras da mensagem original). Já as outras camadas apresentam letras maiúsculas que
representam as letras da mensagem cifrada. No entanto, cada camada de cima para baixo,
tem o alfabeto deslocado uma casa para a esquerda, conforme a Figura 8. Ou seja, o Cubo
de Vigenère também é um sistema criptográﬁco polialfabético, necessitando de técnicas de
decodiﬁcação mais complexas. Porém, as atividades serão práticas e os estudantes poderão
utilizar o próprio cubo para codiﬁcar e decodiﬁcar a mensagem.

Figura 8 – Faces do Cubo de Vigenère

Fonte: O autor, 2020

O processo de codiﬁcação se desenvolve da seguinte forma: primeiramente, voltamos
a face verde onde é apresentado o início do alfabeto original para frente (face verde =
face frontal), conforme Figura 9. As faces vermelha, azul e laranja são as faces laterais.
Em seguida, escolhe-se, aleatoriamente, seis números naturais, que compõem a chave de
codiﬁcação/decodiﬁcação.

Figura 9 – Face Frontal (verde) e Superior do Cubo de Vigenère

77

Fonte: O autor, 2020

Por exemplo, para codiﬁcar a palavra profmat são escolhidos, aleatoriamente, os

números

4 - 10 - 1 - 2 - 3 - 8 (chave)

Cada número corresponde, respectivamente, às camadas de cima para baixo (exceto
a camada superior). Esse número representa a quantidade de vezes que aquela camada
será girada da esquerda para direita. Por exemplo, a 2ª camada de cima para baixo tem
como chave o número 4, ou seja, esta será movimentada horizontalmente 4 vezes e será
observado que a camada voltará ao seu estado inicial. A 3ª camada (de cima para baixo)
tem como chave o número 10, então será movida horizontalmente 10 vezes (esquerda para
direita), o que será o mesmo que mover a camada somente 2 vezes a partir do estágio
inicial, e assim, sucessivamente.

Um dos objetivos mais especíﬁcos é que o estudante perceba esta particularidade:
o número n natural escolhido não gerará n diferentes movimentos e sim, na verdade, r
movimentos distintos, sendo r o resto da divisão de n por 4, ou seja, r = {0, 1, 2, 3}, onde
zero representa o estágio inicial. Esta relação pode ser observada da seguinte forma:

4 ≡ 0 mod 4 e 10 ≡ 2 mod 4 e assim sucessivamente.

Vale ressaltar que foi tomado um sentido positivo, ou seja, da esquerda para direita
e, por esta razão, n positivo. No entanto, poderia ser usado n ∈ Z. Por exemplo, a chave
−1, corresponderia à uma volta de determinada camada no sentido da direita para a
esquerda. Pois,

3 ≡ −1 mod 4

Portanto, a chave 3 corresponde ao mesmo giro do que a chave −1.

Seguindo, tem-se cada letra da palavra profmat que corresponde ao alfabeto de
codiﬁcação de uma das camadas iniciando sempre de cima para baixo e no caso de palavras
com mais de 6 letras, a sétima letra retorna à primeira camada de codiﬁcação. Ou seja,

78

• p corresponde à segunda camada, chave 4.

• r corresponde à terceira camada, chave 10.

• o corresponde à quarta camada, chave 1.

• f corresponde à quinta camada, chave 2.

• m corresponde à sexta camada, chave 3.

• a corresponde à sétima camada, chave 8.

• t corresponde à segunda camada, chave 4.

Para codiﬁcar, o estudante se apropriará do cubo voltado para sua face frontal
(verde) e moverá cada camada o número de vezes que escolher de chave. Em seguida,
observará a letra p na primeira camada (que não foi movida) e qual letra (codiﬁcada) lhe
corresponde na camada pós movimento, ou seja, a letra Q, como vemos na Figura 10.

Figura 10 – Codiﬁcação da letra p

Fonte: O autor, 2020

Da mesma forma, a letra r pode ser codiﬁcada por F na terceira camada, conforme

Figura 11.

Figura 11 – Codiﬁcação da letra r

Fonte: O autor, 2020

Seguindo, a codiﬁcação da letra o, conforme Figura 12.

Figura 12 – Codiﬁcação da letra o

79

Fonte: O autor, 2020

Segue a codiﬁcação da letra f na letra X, de acordo com Figura 13.

Figura 13 – Codiﬁcação da letra f

Fonte: O autor, 2020

A codiﬁcação da letra m na letra Y , conforme Figura 14.

Figura 14 – Codiﬁcação da letra m

Fonte: O autor, 2020

A codiﬁcação da letra a na letra G, conforme Figura 15.

Figura 15 – Codiﬁcação da letra a

80

Fonte: O autor, 2020

Finalmente, a codiﬁcação da letra t na letra U , conforme Figura 16.

Figura 16 – Codiﬁcação da letra t

Fonte: O autor, 2020

Finalizado o processo de codiﬁcação, a mensagem codiﬁcada será

QF KXXGU

Esta mensagem que será repassada para outro estudante que será responsável por
sua decodiﬁcação utilizando o próprio cubo. Para isso, bastará praticar o processo inverso,
ou seja, procurar a letra Q na segunda camada e ver a qual letra do alfabeto original (na
primeira camada) esta corresponde (letra p), e assim, sucessivamente.

6.1.2 Dominó de Goldbach

A atividade a seguir, é baseada na Conjectura de Goldbach e nomeada de Dominó
de Goldbach. Este produto pedagógico matemático apresenta 20 peças, conforme Figura 17.
Em cada peça retangular tem-se duas partes, numa das quais é apresentado um número
para entre 4 e 42.

Figura 17 – Jogo completo com as 20 peças do Dominó de Goldbach

81

Fonte: O autor, 2020

Na outra parte, cada peça tem uma soma de dois números primos. As regras são,
praticamente, idênticas ao de um dominó comum, conforme jogada ilustrada pela Figura 18.
Cada grupo com 4 estudantes inicia o jogo com cinco peças. O estudante que jogar todas
as suas peças primeiro vence.

Figura 18 – Forma de jogo do Dominó de Goldbach

Fonte: O autor, 2020

6.2 Lista de Atividades

6.2.1 Atividade do Dominó de Goldbach

Cada grupo de quatro estudantes receberá um jogo de dominó com vinte peças

que devem ser divididas igualmente entre os participantes.

(A) O grupo deve jogar, no mínimo, uma partida.

82

(B) O grupo deverá relatar suas percepções em relação às peças do jogo. O que pode
ser observado em relação aos números de cada peça? E sobre os números que estão
sendo somados?

(C) Em grupo, elaborem esquemas (desenhos) de mais, no mínimo, cinco peças que

poderiam compor esse mesmo dominó.

(D) Na opinião, de cada membro do grupo por que não há nas peças números ímpares

(na parte do número isolado)?

6.2.2 Atividade do Cubo de Vigenère

Cada grupo de estudantes (de 2 a 4 em cada grupo) receberá um cubo com dimensões
7x7x7. Depois de explicado o modo de codiﬁcação e decodiﬁcação utilizando o cubo, cada
grupo deverá se dividir, em um primeiro momento, em codiﬁcadores e decodiﬁcadores. Os
codiﬁcadores escolherão uma chave de seis números aleatórios e uma palavra secreta para
ser codiﬁcada utilizando o cubo. Os decodiﬁcadores deverão decodiﬁcar a palavra secreta
utilizando, por sua vez, o cubo. Depois, uma segunda rodada é realizada, invertendo-se os
codiﬁcadores e decodiﬁcadores.

A seguir, deverão ser respondidos os seguintes questionamentos:

(A) Para cada membro do grupo, qual atividade foi mais difícil, codiﬁcar ou decodiﬁcar?

(B) A chave é composta por números aleatórios que, inclusive, podem ser muito grandes.
Como poderíamos descobrir a quantidade de movimentos necessários para cada
número da chave? Por exemplo, digamos que escolhemos o número 80. Será realmente
necessário movimentar a camada do cubo oitenta vezes? Por quê?

6.2.3 Avaliação

Os produtos pedagógicos criados acima (Dominó de Goldbach e Cubo de Vigenère)
foram elaborados no programa em 3D do Sketchup 2. Devido à falta de tempo hábil
para implementação desses produtos em sala de aula ressalto que, posteriormente a este
projeto de pesquisa, será realizada a implementação desses produtos, de forma física, para
aplicação pedagógica em sala de aula do Ensino Básico. A análise dos resultados efetivos
será publicada posteriormente em artigos.

Vale ressaltar, porém, que são esperados diversas respostas por parte dos estudantes
quanto às atividades propostas. Em relação à primeira atividade, é relevante que os alunos
observem a relação da soma de dois primos com o resultado par. Na segunda atividade
é importante que estes cheguem à conclusão que o número de voltas eﬁcientes de cada

2 Este programa apresenta versão gratuita e paga e pode ser baixado através do link:

<https://www.sketchup.com/pt-BR>.

camada é o resto da divisão do número de voltas (chave) por quatro (número de faces
laterais).

83

7 CONCLUSÃO

84

Esta pesquisa aborda o tema números primos de forma diferenciada, buscando
suas propriedades e aplicações, como na área da criptologia. O aprofundamento teórico
bem como suas aplicações demonstram a importância deste conceito matemático que, em
diversas situações, é ignorado no Ensino Básico.

Esse estudo e sua implementação na criptograﬁa RSA apresentam a utilização
destes em nosso cotidiano. Embora muitos estudantes não conheçam a criptograﬁa RSA, é
possível associá-la à segurança da informação: transações bancárias, informações comerciais
sigilosas, dados pessoais em rede e até informações governamentais.

Os Problemas do Milênio ressaltam a importância dos Números Primos e sua
relação com diversas áreas do conhecimento. Por outro lado, demonstram os esforços
contínuos a ﬁm de solucioná-los bem como os impactos, destes estudos, na segurança da
informação.

Por ﬁm, esta pesquisa relaciona o prazer que a curiosidade e a busca por uma
solução podem produzir não só nos brilhantes matemáticos que estudam os Números
Primos e suas aplicações, mas também em estudantes do Ensino Básico. As atividades
aqui propostas visam estimular estudantes a aprender através de jogos que despertem a
curiosidade sobre a Matemática.

REFERÊNCIAS

85

ALENCAR FILHO, E. D. Teoria Elementar dos Números. São Paulo: Nobel, 1981.

ASSOCIAÇÃO BRASILEIRA DE NORMAS TÉCNICAS. NBR ISO/IEC 27002: Tec-
nologia da informação - técnicas de segurança - código de prática para a gestão da segurança
da informação. [S.l.], 2013. 120 p.

BOSE, R. Information Theory, Coding and Cryptography. 2ª. ed. Nova Delhi
(Índia): The McGraw-Hill Companies, 2008.

BOYER, C. B. História da Matemática. 3ª. ed. São Paulo: Blucher, 2012.

BRASIL. LEI Nº 12.965, de 23 de abril de 2014. [S.l.], 2014. Disponível em: <http:
//www.planalto.gov.br/ccivil_03/_ato2011-2014/2014/lei/l12965.htm>.

CIPRIANO, V. M. B. S. A construção dos Números Inteiros e Racionais pelo
Método da Simetrização e Aplicações. Dissertação (Mestrado) — UFPI, Teresina,
ago. 2016.

COUTINHO, S. C. Números Inteiros e Criptograﬁa RSA. 2ª. ed. Rio de Janeiro:
IMPA, 2014.

CRYPTO, M. Quadrado de Vigenère. 2019. Wikipedia. Disponível em: <https://
commons.wikimedia.org/wiki/File:Vigen%C3%A8re_square_shading.svg>. Acesso em:
20 set 2019.

DEVLIN, K. Os Problemas do Milênio: sete grandes enigmas matemáticos do nosso
tempo. Rio de Janeiro: Editora Record, 2004.

EVES, H. Introdução à História da Matemática. Campinas: Editora Unicamp, 2004.

FERNANDES, N. O. C. Segurança da Informação. Cuiabá (MT), 2013.

FERREIRA, F. N. F. Segurança da Informação. Rio de Janeiro: Ciência Moderna,
2003.

FIGUEIREDO, L. M. Iniciação à Matemática: um curso com problemas e solu-
ções. Rio de Janeiro: UFF/CEP-EB, 2010. v. 2.

FORNARI, A. Polinômios Geradores de Números Primos. Campinas, 2017.

FORTES, R. Estrutura de Dados I - Análise de Dados. Ouro Preto (MG), 2013.

FOUNDATION, F. S. Figura Citale Espartano. 2019. Wikipedia. Disponí-
vel em: <https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Skytale.png/
199px-Skytale.png>. Acesso em: 29 set 2019.

GOEBEL, G. Máquina Enigma. 2019. Wikipedia. Disponível em: <https://commons.
wikimedia.org/wiki/File:Four-rotor-enigma.jpg>. Acesso em: 30 set 2019.

GRANDO, R. C. O Conhecimento Matemático e o Uso dos Jogos na Sala de
Aula. Dissertação (Mestrado) — Unicamp, Campinas, ago. 2000.

86

GROENWALD, C. L. O.; OLGIN, C. A. Criptograﬁa e o Currículo de Matemática
no Ensino Médio. [S.l.]: Revista de Educação Matemática, 2011.

GTA-UFRJ. Frequência das Letras em Textos em Língua Portuguesa. 2019.
GTA-UFRJ. Disponível em: <https://www.gta.ufrj.br/grad/06_2/alexandre/criptoanalise.
html>. Acesso em: 29 set 2019.

HEFEZ, A. Elementos de Aritmética. Rio de Janeiro: SBM, 2005.

HEFEZ, A. Aritmética. 2ª. ed. Rio de Janeiro: SBM, 2016.

LIMA, R. D. C. Criptograﬁa RSA e a Teoria dos Números. Dissertação (Mestrado)
— UFPB, João Pessoa, ago. 2013.

MARTINS, E. R. Fundamentos da Ciência da Computação. Ponta Grossa (PR):
Atena Editora, 2019.

OLIVEIRA, I. C. Complexidade Computacional e o Problema P vs NP. Campinas,
2010.

OLIVEIRA, K. I. M.; FERNÁNDEZ, A. J. C. Iniciação à Matemática: um curso
com problemas e soluções. 2ª. ed. Rio de Janeiro: SBM, 2012.

PADRÃO, D. L. A Origem do Zero. Dissertação (Mestrado) — PUC/SP, São Paulo,
ago. 2008.

PERIN, A. et al. Conjectura de Goldbach. Campinas, 2017.

PERUZZO, J. O Fascínio dos Números Primos. Irani (SC): Clube dos Autores, 2012.

POLYA, G. A Arte de Resolver Problemas. Rio de Janeiro: Editora Interciência,
1978.

SIMÕES, P.
PPLWARE.
conversas-whatsapp-seguras-dica/>. Acesso em: 28 nov 2019.

Ilustração do Código de Segurança - Código QR. 2019.
<https://pplware.sapo.pt/smartphones-tablets/
Disponível

em:

SINGH, S. O Livro dos Códigos (The Code Book). 9ª. ed. Rio de Janeiro: Record,
2011.

SÊMOLA, M. Gestão da Segurança da Informação: uma visão executiva. Rio de
Janeiro: Campus, 2003.

VIANA, M. Primos gêmeos constituem um dos mistérios mais intrigan-
tes da aritmética. 2018. SBM. Disponível em: <https://www.sbm.org.br/noticias/
primos-gemeos-constituem-um-dos-misterios-mais-intrigantes-da-aritmetica>. Acesso em:
27 jul 2019.

