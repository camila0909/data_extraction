UNIVERSIDADE FEDERAL DO CEARÁ 

CENTRO DE CIÊNCIAS 

DEPARTAMENTO DE MATEMÁTICA 

PROGRAMA DE PÓS-GRADUAÇÃO EM MATEMÁTICA EM REDE 
NACIONAL 

EDNEY FREITAS GREGÓRIO 

O DÉCIMO PROBLEMA DE HILBERT 

E UMA APLICAÇÃO 

FORTALEZA 

2018 

 
 
                                                       
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
EDNEY FREITAS GREGÓRIO 

O DÉCIMO PROBLEMA DE HILBERT 

E UMA APLICAÇÃO 

apresentada 

Dissertação 
ao 
Programa  de  Pós-graduação  em 
Matemática  em  Rede  Nacional, 
Universidade  Federal  do  Ceará, 
como requisito para a obtenção do 
título  de  Mestre  em  Matemática. 
Área  de  Concentração:  Ensino  de 
Matemática. 

Orientador:  Prof.  Dr.  Marcos 
Ferreira de  Melo. 

FORTALEZA 

2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Dados Internacionais de Catalogação na Publicação 

Universidade Federal do Ceará
Biblioteca Universitária
Gerada automaticamente pelo módulo Catalog, mediante os dados fornecidos pelo(a) autor(a)

G833d

Gregório, Edney Freitas.
    O décimo problema de Hilbert e uma aplicação / Edney Freitas Gregório. – 2018.
    60 f. 

     Dissertação (mestrado) – Universidade Federal do Ceará, Centro de Ciências, Programa de Pós-Graduação
em Matemática, Fortaleza, 2018.
     Orientação: Prof. Dr. Marcos Ferreira de Melo.

    1. Equações diofantinas. 2. Funções recursivas. I. Título.
                                                                                                                                                  CDD 510

EDNEY FREITAS GREGÓRIO 

O DÉCIMO PROBLEMA DE HILBERT 
E UMA APLICAÇÃO 

apresentada 

ao 
Dissertação 
Programa  de  Pós-graduação  em 
Matemática  em  Rede  Nacional, 
Universidade  Federal  do  Ceará, 
como requisito para a obtenção do 
título  de  Mestre  em  Matemática. 
Área  de  Concentração:  Ensino  de 
Matemática. 

Orientador:  Prof.  Dr.  Marcos 
Ferreira de  Melo. 

Aprovada em: 11/06/2018 

                                                 BANCA EXAMINADORA 

Prof. Dr. Marcos Ferreira de Melo (orientador) 
Universidade Federal do Ceará (UFC) 

Prof. Dr. Marcelo Ferreira de Melo  
Universidade Federal do Ceará (UFC) 

Prof. Dr. Ângelo Papa Neto  
Instituto Federal de Educação, Ciência e Tecnologia do Ceará (IFCE) 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                                                          A todos os colegas do PROFMAT, 

                                                                                      pelo companheirismo durante o curso. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

     A Deus em primeiro lugar, por me abençoar com a vida. A minha familia que me ajudou 

do começo ao fim, minha querida esposa, amigos e  professores. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

Este  trabalho  trata  do  Décimo  Problema  de  Hilbert,  cujo  enunciado  é:  Dada  uma  equação 

diofantina com coeficientes inteiros em um número qualquer de variáveis, é possivel elaborar 

um processo que decida, atráves de um número finito de operações, se a equação tem soluções 

inteiras. O objetivo é demonstrar que não é possivel elaborar tal processo, isto é, mostrar que 

o  Décimo  Problema  de  Hilbert  é  insolúvel.  Este  trabalho  inicia-se  com  um  estudo  sobre 

Equações  Diofantinas,  Conjuntos  Diofantinos  e  Funções  Diofantinas,  analisando  suas 

propriedades,  seguindo-se  uma  prova  do  Teorema  da  Sequência  dos  Números.  Um  papel 

central  nesse estudo é desempenhado pelas Equações de Pell, utilizadas com a  finalidade de 

mostrar que a função exponencial é diofantina. Este resultado, juntamente com o conceito de 

função  recursiva,  permite  mostrar  que  a  função  ser  recursiva  é  equivalente  a  ser  diofantina. 

Finalmente,  provamos  o  Teorema  de  Universalidade  que  é  utilizado  na  demonstração  do 

teorema  principal  que  afirma  a  insolubilidade  do  Décimo  Problema  de  Hilbert  e  no  ultimo 

capitulo  é  dada  uma  aplicação  desse  resultado  para  a  demonstração  do  Teorema  de 

Incompletude de Gödel. 

Palavras-chave: Equações Diofantinas.   Funções Recursivas.   Função Exponencial. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ABSTRACT 

This  work  discusses  the  Hilbert's  Tenth  Problem,  whose  statement  is:  Given  a  Diophantine 

equation with any  number of unknown quantities  and with  integer coefficients, it is possible 

to devise a process according to which it can be determined by a finite number of operations, 

whether the equation is solvable in rational integers.  The goal is to prove that it is impossible 

to  develop  such  a  process,  ie,  to  show  that  the  Hibert’s  Tenth  Problem  is  unsolvable.  This 

work  starts  with  a  study  of  Diophantine  Equations,  Diophantine  Sets  and  Diophantine 

Functions, with an analysis of their properties, followed by a proof of the Number Sequence 

Theorem. An important role, in this study, is played by the Pell equations,  which are used to 

show  that  the  exponential  function  is  diophantine.  This  result,  together  with  the  concept  of 

recursive function, allows us to show that there is an equivalence between recursive functions 

and  Diophantine  functions.  Finally  we  prove  the  universality  theorem  which  is  used  in  the 

proof of the main theorem which asserts the insolubility of Hilbert’s Tenth Problem and not 

last  chapter  and  given  application  of  result  for  a  demonstration  of  Gödel's  Incompletude 

Theorem. 

Key words: Diophantine Equations.   Recursive Functions.   Exponential Function. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÁRIO 

1 

2 

  INTRODUÇÃO................................................................................................     9 

  EQUAÇÕES DIOFANTINAS........................................................................     11 

2.1   Sistemas de equações diofantinas...................................................................     11 

2.2   Soluções nos números naturais.......................................................................    12 

2.3   Conjuntos diofantinos......................................................................................    13 

3      O 10º PROBLEMA DE HILBERT É INSOLÚVEL....................................    21 

3.1   A função exponencial é diofantina..................................................................    21 

3.2   A linguagem dos predicados diofantinos........................................................    38 

3.3   Novos conjuntos diofantinos............................................................................    43 

3.4   Conceito de algoritmo e modelos de computabilidade..................................    49 

3.5   Funções  recursivas...........................................................................................    50 

3.6   O conjunto diofantino universal......................................................................    54 

4      UMA APLICAÇÃO PARA O 10º PROBLEMA DE HILBERT.................     59 

4.1   Teorema de incompletude de Godel................................................................    59 

5      CONCLUSÃO...................................................................................................    60                                      

REFERÊNCIAS................................................................................................    61 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
9 

1  INTRODUÇÃO 

           No ano de 1900, o matemático David Hilbert divulgou um documento contendo vinte e 

três  problemas  que  deixaram  o  século  XIX  para  serem  resolvidos  no  século  XX.  O  décimo 

problema trata-se de equações diofantinas e seu enunciado é : Dada uma equação diofantina 

com  coeficientes  inteiros  em  um  número  qualquer  de  variáveis,  é  possível  elaborar  um 

processo  que  decida,  através  de  um  número  finito  de  operações,se  a  equação  tem  solução 

inteira.  Hoje  entendemos  o  termo  “elaborar  um  processo”  no  sentido  de  encontrar  um 

algoritmo. Mas, quando os problemas de Hilbert foram propostos, não havia nenhuma noção 

rigorosa para o conceito de algoritmo, e isso era um obstáculo para a solução desse problema. 

           A  primeira  grande  contribuição  foi  dada  em  1931  por  Kurt  Godel  ,  além  de  outros 

lógicos como Alonzo Church  e Alan Turing , que contribuiram na formulação rigorosa para a 

noção  de  computabilidade.  Isso  possibilitou  o  estabelecimento  do  que  seria  um  algoritmo 

insóluvel,  isto  é,  a  impossibilidade  de  existir  um  algoritmo  com  determinadas  propriedades. 

Assim,  os  primeiros  exemplos  de  algoritmos  insolúveis  foram  encontrados  inicialmente  na 

lógica matemática para surgirem posteriomente em outros ramos da matemática. 

           A  teoria  da  computabilidade  forneceu  diversas  ferramentas  para  enfrentar  o  Décimo 

Problema  de  Hibert.  Na  década  de  1950,  surgiram  vários  artigos  relacionados  ao  problema, 

alguns deles escritos por Martin Davis e Hilary Putnam . 

           A matemática Julia Robinson contribuiu fortemente na demonstração de que a função 

exponencial  é  diofantina  .  Mas,  a  peça  chave  na  solução  definitiva  do  problema  foi  o 

matemático Yuri Matiyasevich que, apesar de não ter sido o primeiro a investigar o problema, 

soube habilmente  juntar as peças deste grande quebra-cabeças e resolver, no ano de 1970, o 

Décimo Problema de Hilbert. 

          A  dissertação  começa  tratando  das  equações  diofantinas  com  alguns  exemplos  e 

propriedades. Os resultados nesta seção são: o Teorema das Funções de Emparelhamento e o 

Teorema da Sequência de Números. Em seguida vem 25 lemas sobre equações de Pell com a 

finalidade  de  provar  que  a  função  exponencial  é  diofantina.  Como  consequência  desse  fato 

obtemos  novas  funções  diofantinas  e  novos  conjuntos  diofantinos.  Na  parte  final  da 

dissertação  definimos  função  recursiva  e  provamos  que  uma  função  ser  recursiva  é 

equivalente  a  ser  diofantina.  Após  isso,  demonstramos    o  Teorema  da  Universalidade  e 

concluimos a dissertação com o Teorema que afirma a insolubilidade do Décimo Problema de 

Hilbert e usamos  esse resultado para provar o Teorema de Incompletude de Gödel. 

 
 
 
 
 
10 

          Nessa dissertação vamos denotar o conjunto dos números naturais por ℕ = {0,1,2,3, … } 

e o conjunto dos números inteiros positivos por ℕ∗ = {1,2,3, … }. Além disso, será necessário 

utilizar  o  Teorema  de  Lagrange,  que  afirma  que  todo  número  natural  possui  representação 

como  soma  de  quatro  quadrados  e  tambem  usaremos  o  teorema  chinês  sobre  restos.  As 

demonstrações desses teoremas se encontram na referência bibliográfica (Introdução a Teoria 

dos números. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     
11 

2  EQUAÇÕES DIOFANTINAS 

      O objetivo principal desse capítulo é introduzir dois conceitos, o de conjunto Diofantino e 

o  de  função  Diofantina  bem  como  suas  propriedades  e  exemplos  que  elucidarão  estes 

conceitos. 

      Uma equação Diofantina é uma equação da forma: 

𝐷(𝑥1, … , 𝑥𝑚) = 0                                                                                                                       

Onde 𝐷 é um polinômio com coeficientes inteiros. Esta equação também pode ser escrita da 

seguinte forma: 

𝐷𝐿(𝑥1, … , 𝑥𝑚) = 𝐷𝑅(𝑥1, … , 𝑥𝑚)                                                                                             

Onde 𝐷𝐿 e 𝐷𝑅 são polinômios com coeficientes inteiros positivos. Para obter tal forma basta 

transpor para o lado direito os termos com coeficientes negativos.  

2.1  Sistema de equações diofantinas  

Lema 1.1. um sistema constituido de 𝑘 equações Diofantinas 

{

𝐷1(𝑥1, … , 𝑥𝑚) = 0
…
𝐷𝑘(𝑥1, … , 𝑥𝑚) = 0

Tem como solução os inteiros 𝑥1, … , 𝑥𝑚 se, e somente se, a equação Diofantina 

𝑘

𝐸(𝑥1, … , 𝑥𝑚) = ∑ 𝐷𝑖

2(𝑥1, … , 𝑥𝑚)

=  0                                                                               

𝑖=1

tem a mesma solução. 

Demonstração. 

      Primeiramente, suponha que o sistema é satisfeito, ou seja ,  𝐷𝑖(𝑥1, … , 𝑥𝑚) = 0 para 1 ≤

𝑖 ≤ 𝑘 daí 𝐷𝑖

2(𝑥1, … , 𝑥𝑚) = 0  para 1 ≤ 𝑖 ≤ 𝑘 , e então  ∑ 𝐷𝑖

𝑘
𝑖=1

2(𝑥1, … , 𝑥𝑚)

= 0. 

2(𝑥1, … , 𝑥𝑚) ≥ 0 para 1 ≤ 𝑖 ≤ 𝑘 , 
      Reciprocamente, se  ∑ 𝐷𝑖
segue que 𝐷𝑖(𝑥1, … , 𝑥𝑚) = 0  para 1 ≤ 𝑖 ≤ 𝑘. Portanto um sistema de equações Diofantinas 

= 0 , como 𝐷𝑖

2(𝑥1, … , 𝑥𝑚)

𝑘
𝑖=1

pode ser reduzido a uma única equação Diofantina.    ∎           

      A 

transformação 

inversa 

também 

é 

possivel, 

isto 

é 

, 

transformar 

a 

equação  𝐷(𝑥1, … , 𝑥𝑚) = 0 em um sistema 
𝐷1(𝑥1, … , 𝑥𝑚, 𝑦1, … , 𝑦𝑛) = 0
…
𝐷𝑘(𝑥1, … , 𝑥𝑚, 𝑦1, … , 𝑦𝑛) = 0

{

Onde 𝑦1, … , 𝑦𝑛 são novas variáveis no sistema. 

 
 
 
 
                                                                                                                  
 
 
                                                                                                 
12 

Um  possível  motivo  para  transformar  uma  equação  Diofantina  em  um  sistema  pode 

ser a obtenção de um sistema constituído de equações de grau menor. É interessante perceber 

que qualquer equação Diofantina pode ser transformada num sistema de equações constituído 

de equações de dois tipos: 

𝐈)    𝛂 = 𝛃 + 𝛄                      𝐈𝐈)      𝛂 = 𝛃𝛄                                            

Onde  α, β e γ são números particulares ou dependem das variáveis 𝑥1, … , 𝑥𝑚, 𝑦1, … , 𝑦𝑛. 

Exemplo 1.1 : Considere a seguinte equação Diofantina que envolve três variáveis (x, y, z) , 

   D(x, y, z) =   4x3y − 2x2z3 −  3y2x + 5z = 0      transpondo  os  termos  negativos  obtemos 

  4x3y + 5z =  2x2z3 +  3y2x .  Agora 

introduziremos 

15 

novas 

variáveis 

𝑝1, … , 𝑝4, 𝑞1, 𝑟1, … 𝑟5, 𝑠1, . . , 𝑠3, 𝑡1, 𝑢1  ( 𝑝4𝑝3𝑝2𝑝1 ,     𝑟5𝑟4𝑟3𝑟2𝑟1 , 𝑠3𝑠2𝑠1 ≠ 0)  e  obtemos  o 
sistema equivalente: 

𝑝1 = 4𝑥 ,         𝑝2 = 𝑝1𝑥 ,     𝑝3 = 𝑝2𝑥 ,        𝑝4 = 𝑝3𝑦; 
𝑞1 = 5𝑧;
𝑟1 = 2𝑥 ,     𝑟2 = 𝑟1𝑥 ,       𝑟3 = 𝑟2𝑧 ,          𝑟4 = 𝑟3𝑧,      𝑟5 = 𝑟4𝑧;
𝑠1 = 3𝑦 ,         𝑠2 = 𝑠1𝑦 ,            𝑠3 = 𝑠2𝑥 ;
𝑡1 = 𝑝4 + 𝑞1 ,   𝑢1 = 𝑟5 + 𝑠3 ,       𝑡1 = 𝑢1.

{

Veja que  𝑝4 = 4x3y,    𝑞1 = 5z,   𝑟5 = 2x2z3 , 𝑠3  = 3y2x. 

Finalmente,  utilizando  o  Lema  1.1,  obtemos  uma  equação  de  grau  4 

independentemente do grau da equação inicial. Então para resolver o 10º problema de Hilbert 

será suficiente decidir se uma equação de grau 4 tem ou não solução. 

2.2  Soluções nos números naturais  

Em  seu  10°  problema,  Hilbert  falou  sobre  as  soluções  nos  inteiros.  Algumas  vezes 

uma  solução  nos  inteiros  é  evidente.  Por  exemplo  ,  a  equação    (x + 1)3 + (y + 1)3 =

(z + 1)3    tem  infinitas  soluções  da  forma     x = z  e y = −1.  Por outro  lado,  a obtenção  de 

soluções  não-negativas    𝑥 , 𝑦   e  𝑧 para  tal  equação    não  é  trivial.  Desse  modo,  para  uma 

equação  Diofantina  particular  ,  o  problema  de  dicidir  se  esta  tem  uma  solução  inteira  e  o 

problema de decidir se esta tem uma solução inteira não-negativa são em geral dois problemas 

distintos. 

 
 
 
 
 
 
 
 
 
 
                                             
 
 
                               
 
 
 
Lema  1.2.  A    equação  Diofantina  𝐷(𝑥1, … , 𝑥𝑛) = 0  tem  uma  solução  nos  naturais   se,  e 
somente se, o sistema   

13 

𝐷(𝑥1, … , 𝑥𝑛) = 0
2 + 𝑦1,3
2 + 𝑦1,2
...
2 + 𝑦𝑛,3
2 + 𝑦𝑛,2

2
2 + 𝑦1,4

2
2 + 𝑦𝑛,4

𝑥1 = 𝑦1,1

𝑥𝑛 = 𝑦𝑛,1

{

tem uma solução nos inteiros. 

Demonstração. 

Considere  (𝑥1, … , 𝑥𝑛)  uma  solução  nos  naturais  da  equação  𝐷(𝑥1, … , 𝑥𝑛) = 0.  Pelo 
teorema  de  Lagrange  todo  natural  pode  ser  escrito  como  soma  de  quatro  quadrados 

portanto,podemos expressar cada 𝑥𝑖 com 

 1 ≤ 𝑖 ≤ 𝑛  como soma de quatro quadrados, dando uma solução ao sistema. Reciprocamente, 

qualquer solução do sistema em números inteiros inclui a solução  (𝑥1, … , 𝑥𝑛) em naturais da 
equação 𝐷(𝑥1, … , 𝑥𝑛) = 0.     

∎ 

Pelo  Lema  1.1  podemos 

reduzir  o 

sistema 

a  uma  única 

equação 

𝐸(𝑥1, … , 𝑥𝑛, 𝑦1,1, … , 𝑦𝑛,4) = 0  do resultado acima ela tem solução  inteira  se , e somente se 

𝐷(𝑥1, … , 𝑥𝑛) = 0 tem solução natural , onde as equações  𝐷 e 𝐸 são diferentes. 

Desse  modo,  foi  mostrado  que  o  problema  de  decisão  de  determinar  a  existência  ou 

não-existência de soluções  não-negativas é reduzido ao problema de determinar a existência  

ou não-existência de soluções inteiras. Assim , para provar que o Décimo Problema de Hilbert 

é  insolúvel  na  sua  forma  original  é  suficiente  mostrar  que o  mesmo  é  insolúvel  nos  inteiros 

não-negativos. 

2.3 Conjunto diofantino 

Definição 1.1: Seja 𝑀  ⊆ (ℕ∗)𝑛. O Conjunto 𝑀 será chamado de conjunto Diofantino quando 

existir  um  polinômio  𝐷(𝑎1, … , 𝑎𝑛 ,𝑥1, … , 𝑥𝑚)  a  coeficientes  inteiros  tal  que  (𝑎1, … , 𝑎𝑛) ∈ 

𝑀 ⟺ ∃ 𝑥1, … , 𝑥𝑚 ∈ ℕ∗  tais  que  𝐷(𝑎1, … , 𝑎𝑛 ,𝑥1, … , 𝑥𝑚)  =  0  .  O  número  𝑛  é  chamado  de 

dimensão de 𝑀. 

Exemplo  1.2.  O  conjunto  𝐶  dos  números  compostos  positivos  é  Diofantino.  Observe  que, 

𝑥  ∈ 𝐶 ⟺   ∃𝑦, 𝑧  ∈ ℕ∗ tais que 𝑥 = (𝑦 + 1)(𝑧 + 1). 

 
 
 
 
 
 
 
                                                                      
 
 
 
 
 
 
14 

Demonstração. 

Seja    𝑥  ∈ 𝐶 .  Então  existem  1 < 𝑎, 𝑏 < 𝑥 tais  que  𝑥 = 𝑎𝑏.  Como  𝑎 , 𝑏 > 1,   existem 

𝑦, 𝑧  ∈ ℕ∗ tais que 𝑎 = 𝑦 + 1 e 𝑏 = 𝑧 + 1.  Logo, 𝑥 = (𝑦 + 1)(𝑧 + 1).  

Reciprocamente, 

suponha  que  ∃𝑦, 𝑧  ∈ ℕ∗ 

tais  que  𝑥 = (𝑦 + 1)(𝑧 + 1)   e             

   (𝑦 + 1) , (𝑧 + 1) > 1  segue que 𝑥 é composto. Portanto, 𝑥 ∈ 𝐶. Veja que a dimensão de 𝐶 é 

𝑛 = 1  e 𝑥 ∈ 𝐶 ⟺ (∃ 𝑦, 𝑧 ∈ ℕ∗)[ 𝐷(𝑥, 𝑦, 𝑧) = 𝑥 − (𝑦 + 1)(𝑧 + 1)].   ∎ 

Vejamos  agora,  que  a  união  e  a  interseção  de  dois  conjuntos  Diofantinos  de  mesma 

dimensão são também conjuntos Diofantinos. 

Proposição 1.1: Considere os conjuntos Diofantinos   𝑀1   𝑒     𝑀2  de mesma dimensão então 

  𝑀1 ∪ 𝑀2 também é um conjunto diofantino. 
Demontração.  

Por  hipótese    𝑀1 = {(𝑎1, … , 𝑎𝑛)   ∈ (ℕ∗)𝑛: ∃𝑥1, … , 𝑥𝑚 ∈ ℕ∗ ⎸𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) = 0}   
e 

𝑀2 = {(𝑎1, … , 𝑎𝑛)   ∈ (ℕ∗)𝑛: ∃𝑦1, … , 𝑦𝑡 ∈ ℕ∗⎸ 𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0}.  

Devemos mostrar que ,  

(𝑎1, … , 𝑎𝑛) ∈ 𝑀1 ∪ 𝑀2 ⟺ ∃𝑧1, 𝑧2, … , 𝑧𝑚+𝑡 ∈ ℕ∗ ⎸[𝐷(𝑎1, … , 𝑎𝑛 ,𝑧1, 𝑧2, … , 𝑧𝑚+𝑡) = 0].  

Para  isso definimos , 𝐷(𝑎1, … , 𝑎𝑛 ,𝑧1, 𝑧2, … , 𝑧𝑚+𝑡) =

𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚)𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0  e  𝑥1 = 𝑧1 , … 𝑥𝑚 = 𝑧𝑚  e  𝑦1 =

𝑧𝑚+1 , … 𝑦𝑡 = 𝑧𝑚+𝑡 . 

 Seja (𝑎1, … , 𝑎𝑛) ∈   𝑀1 ∪ 𝑀2. Se (𝑎1, … , 𝑎𝑛) ∈   𝑀1,  então ,    ∃ 𝑥1, … , 𝑥𝑚 ∈ ℕ∗  tal  que 
𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) = 0  daí  𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚)𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0,  Para 
quaisquer  𝑦1, … , 𝑦𝑡 ∈ ℕ∗.  Se  (𝑎1, … , 𝑎𝑛) ∈   𝑀2 , então  ,  existem    𝑦1, … , 𝑦𝑡 ∈ ℕ∗  tais  que 
Logo,  𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚)𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) =
𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0. 
0 , Para quaisquer 𝑥1, … , 𝑥𝑚 ∈ ℕ∗.  

 
 
 
 
 
 
 
 
 
 
 
 
 
Reciprocamente  ,  suponha  que  ∃𝑥1, … , 𝑥𝑚, 𝑦1, … , 𝑦𝑡 ∈ ℕ∗  tais  que  o  produto    seja  zero,  ou 
seja  , 𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚)𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0.Caso    𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) =

0 

então, 

(𝑎1, … , 𝑎𝑛) ∈   𝑀1, 

logo, 

(𝑎1, … , 𝑎𝑛) ∈   𝑀1 ∪ 𝑀2. 

Agora, 

Caso 

𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0, então (𝑎1, … , 𝑎𝑛) ∈   𝑀2. Logo, (𝑎1, … , 𝑎𝑛) ∈   𝑀1 ∪ 𝑀2.  ∎ 

15 

Proposição 1.2: Considere os conjuntos Diofantinos   𝑀1   𝑒     𝑀2  de mesma dimensão então 

  𝑀1 ∩ 𝑀2 também é um conjunto diofantino. 

Demonstração. 
Por hipótese,  𝑀1 = {(𝑎1, … , 𝑎𝑛)   ∈ (ℕ∗)𝑛: ∃𝑥1, … , 𝑥𝑚 ∈ ℕ∗⎸ 𝐷1(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) = 0} e 
𝑀2 = {(𝑎1, … , 𝑎𝑛)   ∈ (ℕ∗)𝑛: ∃𝑦1, … , 𝑦𝑡 ∈ ℕ∗⎸ 𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0}.   

Devemos mostrar que  

(𝑎1, … , 𝑎𝑛) ∈ 𝑀1 ∩   𝑀2 ⟺ ∃𝑧1, 𝑧2, … , 𝑧𝑚+𝑡 ∈ ℕ∗ ⎸[𝐷(𝑎1, … , 𝑎𝑛 ,𝑧1, 𝑧2, … , 𝑧𝑚+𝑡) = 0].  

Para isso definimos   

𝐷(𝑎1, … , 𝑎𝑛 ,𝑧1, 𝑧2, … , 𝑧𝑚+𝑡) = 𝐷1

2(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) + 𝐷2

2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0 

onde , 

𝑥1 = 𝑧1 , … 𝑥𝑚 = 𝑧𝑚  e  𝑦1 = 𝑧𝑚+1 , … 𝑦𝑡 = 𝑧𝑚+𝑡 . 

Seja (𝑎1, … , 𝑎𝑛) ∈   𝑀1 ∩   𝑀2, então ∃𝑥1, . . , 𝑥𝑚, 𝑦1, . . , 𝑦𝑡 ∈ ℕ∗ ⎸𝐷1(𝑎1, . . , 𝑎𝑛, 𝑥1, . . , 𝑥𝑚) = 0 e 

𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0. Portanto, 𝐷1

2(𝑎1, … , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) +

 𝐷2

2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0. 

Reciprocamente, suponha que ∃𝑥1, … , 𝑥𝑚, 𝑦1, … , 𝑦𝑡 ∈ ℕ∗ tais que   

2(𝑎1, . . , 𝑎𝑛, 𝑥1, . . , 𝑥𝑚) + 𝐷2

𝐷1
𝐷2(𝑎1, … , 𝑎𝑛, 𝑦1, … , 𝑦𝑡) = 0. Logo, (𝑎1, … , 𝑎𝑛) ∈   𝑀1  𝑒  (𝑎1, … , 𝑎𝑛) ∈   𝑀2 ,  ou seja , 
(𝑎1, … , 𝑎𝑛) ∈   𝑀1 ∩  𝑀2.  ∎ 

2(𝑎1, . . , 𝑎𝑛, 𝑦1, . . , 𝑦𝑡) = 0. Então, 𝐷1(𝑎1, . . , 𝑎𝑛, 𝑥1, … , 𝑥𝑚) = 0 e 

Vejamos alguns exemplos de conjuntos Diofantinos: 

Exemplo 1.3.  O conjunto 𝐸 dos números positivos que não são potências de 2 é Diofantino 

com dimensão 1, pois, 

𝑥 ∈ 𝐸 ⟺ (∃ 𝑦, 𝑧  ∈ ℕ∗)[𝑥 = 𝑦(2𝑧 + 1)]. 

 
 
 
 
 
 
 
 
 
 
 
Exemplo 1.4.  O conjunto 𝐷 = {(𝑥, 𝑦) ∈ (ℕ∗)2: 𝑥 < 𝑦}  é Diofantino com dimensão 2, pois 

(𝑥, 𝑦) ∈ 𝐷  ⟺ (∃𝑧  ∈ ℕ∗) [ 𝑥 + 𝑧 = 𝑦]. 

16 

Exemplo 1.5.  (Relação de Ordem) O conjunto 𝑁 = {(𝑥, 𝑦)   ∈ (ℕ∗)2: 𝑥 ≤ 𝑦} é Diofantino 

com dimensão 2, pois  

(𝑥, 𝑦) ∈ 𝑁  ⟺ (∃𝑧  ∈ ℕ∗)[ 𝑥 + 𝑧 − 1 = 𝑦]. 

Exemplo 1.6. (Relação de Divisibilidade)  O conjunto 𝑬 = {(𝑥, 𝑦)   ∈ (ℕ∗)2: 𝑥  ⎸𝑦} é 

Diofantino com dimensão 2, pois   

(𝑥, 𝑦) ∈ 𝑬 ⟺ (∃𝑧  ∈ ℕ∗)[  𝑦 = 𝑧𝑥]. 

Exemplo 1.7. (Relação de Interseção)   O conjunto 𝑌 = {(𝑥, 𝑦, 𝑧)   ∈ (ℕ∗)3: 𝑥  ⎸𝑦  e  𝑥 < 𝑧 } 

é Diofantino com dimensão 3. 

 Demonstração. 

Como  𝑥  ⎸𝑦  ⟺ (∃𝑎  ∈ ℕ∗) [𝑦 = 𝑎𝑥]  e  𝑥 < 𝑧  ⟺ (∃𝑏  ∈ ℕ∗)[𝑧 = 𝑥 + 𝑏] , Podemos 

ver    𝑌  como  a  união  de  dois  conjuntos  𝑌1 ∩ 𝑌2 = 𝑌  onde  𝑌1 = {(𝑥, 𝑦, 𝑧)   ∈ (ℕ∗)3: 𝑥  ⎸𝑦}  e 
𝑌1 = {(𝑥, 𝑦, 𝑧)   ∈ (ℕ∗)3 ⎸ 𝑥 < 𝑦}   

pela 

propriedade 

(1.2) 

, 

(𝑥, 𝑦, 𝑧) ∈ 𝑌 ⟺ (∃𝑎, 𝑏 ∈ (ℕ∗)2) [(𝑦 − 𝑎𝑥  )2 +

 (𝑧 − 𝑥 − 𝑏  )2 = 0], ou seja, 𝑌 é diofantino.  

∎ 

Exemplo  1.8.  (Relação  de  Congruência)      Sejam  𝑎, 𝑏 , 𝑐 ∈ ℕ∗  definimos  a  relação  de 

congruência sobre ℕ∗ como: 

Mas isso é equivalente a : 

𝑎 ≡ 𝑏 (𝑚𝑜𝑑 𝑐) ⇔ 𝑐 ⎸𝑎 − 𝑏   

𝑎 ≡ 𝑏 (𝑚𝑜𝑑 𝑐) ⇔ ∃ 𝑥  ∈ ℕ∗  tal que  𝑎 = 𝑏 + 𝑐𝑥   

Pela propriedade 1.1 temos que : 

𝑎 ≡ 𝑏 (𝑚𝑜𝑑 𝑐) ⇔ ∃ 𝑥  ∈ ℕ∗  tal que  𝑎 − 𝑏 − 𝑐𝑥 = 0. 

Assim pela definição 1.1 ,  a relação de congruência é diofantina. 

∎ 

1.4  Função diofantina 

Definição 1.2: Seja 𝑓: (ℕ∗)𝑛 ⟶ ℕ∗. Chamamos de gráfico de 𝑓 o conjunto 

 graf(𝑓) = {(𝑎1, … , 𝑎𝑛, 𝑏) ∈ (ℕ∗)𝑛+1 ⎸𝑏 = 𝑓(𝑎1, … , 𝑎𝑛)}. 

Definição 1.3. (Função Diofantina): Seja  𝑓: (ℕ∗)𝑛 ⟶ ℕ∗. Dizemos que 𝑓 é uma função 

diofantina quando graf(𝑓) é um conjunto diofantino. 

 
 
 
 
 
 
 
Exemplo 1.9.  Considere a função 𝑇: ℕ∗ ⟶ ℕ∗ definida por ,   

 𝑇(𝑛) = 1 + 2 + ⋯ + 𝑛 = 𝑛(𝑛+1)

2

  ,  observe  que  𝑇  é  uma  função  Diofantina,  de  fato,  como  

graf(𝑇) = {(𝑛, 𝑚) ∈ (ℕ∗)2  ⎸𝑚 = 𝑇(𝑛)}      então  (𝑛, 𝑚) ∈  graf(𝑇) ⟺ 𝑚 = 𝑛(𝑛+1)

2

⟺ 2𝑚 =

𝑛(𝑛 + 1). Logo, graf(𝑇) é um conjunto Diofantino e, portanto, 𝑇 é uma função Diofantina. 

17 

Lema  1.3.  Seja  a  função  𝑇: ℕ ⟶ ℕ  definida  por      𝑇(𝑛) = 𝑛(𝑛+1)

2

  .  Então  𝑇(𝑧) é  crescente,  

𝑇(𝑧) ≥ 𝑧 e para cada  𝑧  ∈ ℕ∗ , existe um único inteiro  𝑛 ≥ 0 , tal que 𝑇(𝑛) < 𝑧 ≤ 𝑇(𝑛 + 1).  

Demonstração. 

Como  𝑇(𝑧 + 1) −  𝑇(𝑧) = 𝑧 + 1 > 0 , segue  que  𝑇(𝑧)  é  crescente.  Seja   𝑧    ∈ ℕ∗ 

,como 𝑧  ≥ 1 , temos que  𝑧+1
2

≥ 1 , então 𝑧(𝑧+1)

2

≥ 𝑧 , e portanto, 𝑇(𝑧) ≥ 𝑧.  

Agora  ,  defina  o  conjunto  𝑆𝑧 = { 𝑛 ∈ ℕ ∶  𝑇(𝑛) ≥ 𝑧 }.    Veja  que  𝑆𝑧 ≠ 𝜙,  pois  𝑧  

∈   𝑆𝑧

. Alem disso, 𝑆𝑧 ⊂ ℕ∗ , pois 0 ∉ 𝑆𝑧 . Pelo princípio da boa ordem, existe um único 𝑚 ∈
𝑆𝑧  tal  que  𝑚 = 𝑚𝑖𝑛𝑆𝑧  ,  e  consequentemente,  existe  um  único  𝑛 = 𝑚 − 1  ∈  ℕ.  Como  𝑛 <
𝑚 = 𝑚𝑖𝑛𝑆𝑧  temos  que  𝑛 ∉ 𝑆𝑧 .  Logo  ,  𝑇(𝑛) < 𝑧  ,  e  como  𝑚 ∈ 𝑆𝑧  ,  temos  que  𝑧 ≤ 𝑇(𝑚). 
Portanto , 𝑇(𝑛) < 𝑧 ≤ 𝑇(𝑛 + 1).    

∎ 

Teorema  1.1  (Teorema  das  Funções  de  Emparelhamento)  Existem  funções    Diofantinas 

𝑃(𝑥, 𝑦), 𝐿(𝑧), 𝑅(𝑧) tais que : 

𝟏) Para todo  𝑥, 𝑦, 𝑧 ∈ ℕ∗   𝐿(𝑃(𝑥, 𝑦)) = 𝑥  ,   𝑅(𝑃(𝑥, 𝑦)) = 𝑦   e  𝑃(𝐿(𝑧), 𝑅(𝑧)) = 𝑧 

𝟐) 𝐿(𝑧) ≤ 𝑧,   𝑅(𝑧) ≤ 𝑧.   

Demonstração. 

Pelo Lema (1.3) a função 𝑇 é crescente e para cada  𝑧  ∈ ℕ∗ , existe um único inteiro 

𝑛 ≥ 0  , tal  que  𝑇(𝑛) < 𝑧 ≤  𝑇(𝑛 + 1) =  𝑇(𝑛) + 𝑛 + 1. Como  𝑇(𝑛) < 𝑧 temos  então  que  𝑦

∶= 𝑧 − 𝑇(𝑛) > 0  ,  logo  𝑦 ∈ ℕ∗.Por  outro  lado,    𝑧 ≤  𝑇(𝑛 + 1) = 𝑇(𝑛) + 𝑛 + 1 ⇒   𝑦 +

𝑇(𝑛) ≤ 𝑇(𝑛) + 𝑛 + 1 ⇒ 𝑦 ≤ 𝑛 + 1 ⇒ 𝑛 + 1 − 𝑦 ≥ 0  ⇒ 𝑛 + 2 − 𝑦 > 0 ⇒  

Note que 𝑥 e 𝑦 são únicos e dependem de 𝑧. Podemos então definir as funções 

𝑥 ∶= 𝑛 + 2 − 𝑦 ∈ ℕ∗. 

𝐿: ℕ∗ ⟶ ℕ∗, com  𝐿(𝑧) = 𝑥 ;
{
𝑅: ℕ∗ ⟶ ℕ∗, com  𝑅(𝑧) = 𝑦 ; 

        Como  𝑧 = 𝑇(𝑛) + 𝑦  e  𝑛 = 𝑥 + 𝑦 − 2  definimos  𝑃: (ℕ∗)2 ⟶ ℕ∗, como               

𝑃(𝑥, 𝑦) = 𝑇(𝑥 + 𝑦 − 2) + 𝑦 note que 𝑃(𝑥, 𝑦) = 𝑧.  

 
 
 
 
 
 
 
 
Prova de  𝟏) 

 Para todos os números   𝑥, 𝑦, 𝑧  ∈ ℕ∗  𝐿(𝑃(𝑥, 𝑦)) = 𝑥  , 𝑅(𝑃(𝑥, 𝑦)) =

𝑦 , 𝑃(𝐿(𝑧), 𝑅(𝑧)) = 𝑧  de fato pois, 𝐿(𝑃(𝑥, 𝑦)) ≝ 𝐿(𝑧) ≝ 𝑥   , 𝑅(𝑃(𝑥, 𝑦)) ≝ 𝑅(𝑧) ≝ 𝑦  e  

18 

𝑃(𝐿(𝑧), 𝑅(𝑧)) ≝ 𝑃(𝑥, 𝑦) ≝ 𝑧.  

Prova de  𝟐) 

Provemos  agora  que  𝐿(𝑧) ≤ 𝑧  𝑒  𝑅(𝑧) ≤ 𝑧  de  fato,  como  𝑧 = 𝑇(𝑛) + 𝑦 ⇒ 𝑧 ≥ 𝑦 ⇒

𝑧 ≥ 𝑅(𝑧). Para o que falta usamos o lema (1.3) já que  𝑧 ≥ 𝑇(𝑥 + 𝑦 − 2) + 1 ≥ 𝑇(𝑥 − 1) +

1 ≥ (𝑥 − 1) + 1 = 𝑥. Logo  𝑧 ≥ 𝑥,  ou seja , 𝑧 ≥ 𝐿(𝑧).  

𝑳, 𝑹 𝒆 𝑷 são Diofantinas 

 Note que 𝐿(𝑧), 𝑅(𝑧) e 𝑃(𝑥, 𝑦) são funções diofantinas uma vez que : 

𝑧 = 𝑃(𝑥, 𝑦) ⟺           2𝑧 = (𝑥 + 𝑦 − 2)(𝑥 + 𝑦 − 1) + 2𝑦 
𝑥 =  𝐿(𝑧)     ⟺ (∃𝑦)[2𝑧 = (𝑥 + 𝑦 − 2)(𝑥 + 𝑦 − 1) + 2𝑦
𝑦 =  𝑅(𝑧)    ⟺   (∃𝑥)[2𝑧 = (𝑥 + 𝑦 − 2)(𝑥 + 𝑦 − 1) + 2𝑦

A  função  𝑃(𝑥, 𝑦)  estabelece  uma  bijeção  entre  conjunto  dos  pares  ordenados  formados  por 

inteiros  positivos  e  o  conjunto  dos  números  inteiros  positivos.  E  para  cada  inteiro 𝑧  ,  o  par 

ordenado que esta associado a 𝑧 por 𝑃(𝑥, 𝑦) é (𝐿(𝑧), 𝑅(𝑧))  

∎.  

Outra função Diofantina que  nos será  muito útil  esta relacionada ao Teorema Chinês 

sobre restos. Defina a função 𝑆(𝑖, 𝑢) = 𝑤 onde 𝑤 é o único inteiro positivo para o qual  𝑤 ≡

𝐿(𝑢)(𝑚𝑜𝑑 1 + 𝑖. 𝑅(𝑢))  e 𝑤 < 1 + 𝑖𝑅(𝑢).  Aqui  , 𝑤  é o resto  da  divisão  euclidiana  de  𝐿(𝑢) 

por 1 + 𝑖𝑅(𝑢). 

Teorema 1.2 (Teorema da Sequência de Números) Existe uma função Diofantina 𝑆(𝑖, 𝑢) tal 

que : 

𝟏) 𝑆(𝑖, 𝑢) ≤ 𝑢  , e 
𝟐)  Para  cada  sequência   𝑎1, … , 𝑎𝑛   ∈  ℕ∗ ,    existe  um  número  inteiro  𝑢  tal  que  𝑆(𝑖, 𝑢) = 𝑎𝑖 
para 1 ≤ 𝑖 ≤ 𝑛. 

Demonstração. 

𝑺 é Diofantina 

Definimos  a  função  𝑆: (ℕ∗)2 ⟶ ℕ∗,  da  seguinte  forma  :    𝑆(𝑖, 𝑢) = 𝑤,  onde  𝑤  é  o 

único inteiro positivo para o qual   𝑤 ≡ 𝐿(𝑢)(𝑚𝑜𝑑 1 + 𝑖𝑅(𝑢) ),   0 < 𝑤 < 1 + 𝑖𝑅(𝑢) , sendo 

𝑢 = 𝑃(𝑥, 𝑦) tal que 𝑥 = 𝐿(𝑢) e 𝑦 = 𝑅(𝑢). Mostremos agora que 𝑆(𝑖, 𝑢) é diofantina.  

 
 
 
 
 
 
 
Veja  que  𝑤 = 𝑆(𝑖, 𝑢) ⇔ ∃𝑧  ∈ ℕ∗ tal  que  𝐿(𝑢) = (𝑧 − 1)(1 + 𝑖𝑅(𝑢)) + 𝑤  e            

19 

0 < 𝑤 < 1 + 𝑖𝑅(𝑢) ⟺ 

⟺ ∃𝑥, 𝑦, 𝑧, 𝑣  ∈ ℕ∗ tais que      {

que       

2𝑢 = (𝑥 + 𝑦 − 2)(𝑥 + 𝑦 − 1) + 2𝑦,
𝑥 = 𝑤 + (𝑧 − 1)(1 + 𝑖𝑦),
𝑖𝑦 =  𝑤 + 𝑣 − 1.

⟺ ∃𝑥, 𝑦, 𝑧, 𝑣  ∈ ℕ∗ tais 

2
(2𝑢 − (𝑥 + 𝑦 − 2)(𝑥 + 𝑦 − 1) − 2𝑦)2 + (𝑥 − 𝑤 − (𝑧 − 1)(1 + 𝑖𝑦))

+

(1 + 𝑖𝑦 −  𝑤 − 𝑣)2 = 0.  

Então  usando  a  Lema  1.1  (somando  os  quadrados  das  três  equações)  prova-se  que 

𝑆(𝑖, 𝑢) é Diofantino, note que a terceira equação do sistema   (𝑖𝑦 =  𝑤 + 𝑣 − 1) vem do fato 

que 0 < 𝑤 < 1 + 𝑖𝑅(𝑢) ⇔ 0 < 1 + 𝑖𝑦 − 𝑤 ≝ 𝑣 ∈ ℕ∗.  

Prova de  𝟏) 

Provemos agora que 𝑆(𝑖, 𝑢) ≤ 𝑢. De fato , como  𝐿(𝑢) = (𝑧 − 1)(1 + 𝑖𝑅(𝑢)) + 𝑤 ⇒

𝐿(𝑢) ≥ 𝑤 ⇒ 𝐿(𝑢) ≥ 𝑆(𝑖, 𝑢) mas pelo Teorema (1.1) , 𝐿(𝑢) ≤ 𝑢 . Logo ,  𝑆(𝑖, 𝑢) ≤ 𝑢.  

Prova de  𝟐) 

Finalmente,  sejam  𝑎1, … , 𝑎𝑛   ∈ ℕ∗ uma  sequência  de  números.  Escolha  𝑦 ∈ ℕ∗  como 
sendo  algum  número  maior  que  cada  𝑎1, … , 𝑎𝑛  e  divisível  por  1,2, … , 𝑛.  Então  os  números 

1 + 𝑦, 1 + 2𝑦, … ,1 + 𝑛𝑦 são relativamente primos entre si.  

De  fato,  seja  𝑑 ∈  ℕ∗  onde    𝑑 ⎸1 + 𝑖𝑦 , e   𝑑 ⎸1 + 𝑗𝑦 , com  𝑖 < 𝑗,  então  𝑑 ⎸[𝑗(1 +

𝑖𝑦) − 𝑖(1 + 𝑗𝑦)] , isto é, 𝑑 ⎸𝑗 − 𝑖  de modo que 𝑑 ≤ 𝑗 − 𝑖 ≤ 𝑛  daí  𝑑 ⎸𝑦 .  

De 𝑑 ⎸𝑦 e 𝑑 ⎸1 + 𝑖𝑦 temos 𝑑 = 1 .Sendo assim , podemos aplicar o Teorema Chinês 

sobre restos para obtermos um número 𝑥 tal que: 

𝑥 ≡   𝑎1     (𝑚𝑜𝑑 1 + 𝑦)
𝑥 ≡   𝑎2     (𝑚𝑜𝑑 1 + 2𝑦)
… … … … … .
… … … … … .
𝑥 ≡   𝑎𝑛     (𝑚𝑜𝑑 1 + 𝑛𝑦)

{

Logo para  𝑖 = 1,2, … , 𝑛 teremos 𝑎𝑖 ≡ 𝐿(𝑢)(𝑚𝑜𝑑 1 + 𝑖. 𝑅(𝑢)) e 𝑎𝑖 < 𝑦 = 𝑅(𝑢) < 1 +

𝑖𝑅(𝑢). Mas por definição da função 𝑆(𝑖, 𝑢) segue que 𝑎𝑖 =  𝑆(𝑖, 𝑢).       ∎       

      Uma impressionante caracterização dos conjuntos Diofantinos de inteiros positivos é dado 

pelo: 

Teorema 1.3 Um conjunto 𝑆 de inteiros positivos é Diofantino com dimensão 1 se e somente 

se existe um polinômio 𝑃 tal que 𝑆 é precisamente o conjunto dos inteiros positivos na 

imagem da função definida por 𝑃. 

 
 
 
 
 
 
 
 
20 

Demonstração. 

Primeiramente, suponha que 𝑆 é Diofantino, logo, existe um polinômio 𝑄 tal que: 

𝑥  ∈ 𝑆 ⟺ (∃𝑥1, … , 𝑥𝑚 ∈ ℕ∗)[𝑄(𝑥, 𝑥1, … , 𝑥𝑚) = 0]. 

Seja  𝑃(𝑥, 𝑥1, … , 𝑥𝑚) = 𝑥. [1 − 𝑄2(𝑥, 𝑥1, … , 𝑥𝑚)].  Se  𝑥  ∈ 𝑆,  escolha  𝑥1, … , 𝑥𝑚  tais 
que  𝑄(𝑥, 𝑥1, … , 𝑥𝑚) = 0,  logo  𝑃(𝑥, 𝑥1, … , 𝑥𝑚) = 𝑥,  o  que  mostra  que  𝑥  esta  no  conjunto 

imagem da função definida por 𝑃. 

Por outro lado, seja  𝑧 = 𝑃(𝑥, 𝑥1, … , 𝑥𝑚), 𝑧 > 0. Como 𝑧 = 𝑥. [1 − 𝑄2(𝑥, 𝑥1, … , 𝑥𝑚)] e 
𝑄2(𝑥, 𝑥1, … , 𝑥𝑚) = 0  pois 

1 − 𝑄2(𝑥, 𝑥1, … , 𝑥𝑚) > 0,  

segue 

logo 

que 

𝑥 > 0, 

𝑄 (𝑥, 𝑥1, … , 𝑥𝑚) ∈ ℤ  , ou seja, 𝑄(𝑥, 𝑥1, … , 𝑥𝑚) = 0. Portanto 𝑧 = 𝑥 e 𝑄(𝑧, 𝑥1, … , 𝑥𝑚) = 0 o 

que mostra que 𝑧  ∈ 𝑆. 

 Reciprocamente, seja 𝑆 o conjunto dos inteiros positivos na imagem da função 

definida por 𝑃. Logo, 

𝑥  ∈ 𝑆 ⟺ (∃𝑥1, … , 𝑥𝑚 ∈ ℕ∗)[𝑃(𝑥1, … , 𝑥𝑚) = 𝑥]. 

Defina  𝑅(𝑥, 𝑥1, … , 𝑥𝑚) = 𝑥 − 𝑃(𝑥1, … , 𝑥𝑚).  Então ,  𝑥  ∈ 𝑆 ⟺ (∃𝑥1, … , 𝑥𝑚 ∈
ℕ∗)[𝑅(𝑥, 𝑥1, … , 𝑥𝑚) = 0],  Logo o conjunto 𝑆 é Diofantino. 

∎ 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
3    O 10º PROBLEMA DE HILBERT É INSOLÚVEL 

21 

3.1  A função exponencial é diofantina 

     O objetivo desta seção é mostrar que a função exponecial ℎ(𝑛, 𝑘) = 𝑛𝑘 é Diofantina. Isto é 

necessário  pois  esta  função  servirá  de  base  para  mostrarmos  que outras  funções  importantes 

também  são  Diofantinas.  Para  isso  serão  necessários  25  lemas,  os  quais  enunciaremos  e 

provaremos  a  seguir.  Nestes  lemas  utilizaremos  fortemente  a  Equação  de  Pell,  a  Teoria  de 

Congruências e o Princípio de Indução Finita. 

Definição 2.1 A equação diofantina 𝑥2 − 𝑑𝑦2 = 𝑁 ,   onde 𝑑 e 𝑁 são inteiros é chamado de 

equação de PELL. A equação de Pell é de grande importância na teoria dos números devido 

ao fato de que muitas equações diofantinas podem ser transformadas em uma equação de Pell 

, ou que dependa de alguma forma dela.  

Exemplo 2.1 : Encontre todas as soluções inteiras da equação geral do segundo grau: 

𝑎𝑥2 + 𝑏𝑥𝑦 + 𝑐𝑦2 + 𝑑𝑥 + 𝑒𝑦 + 𝑓 = 0 , 

Onde  𝑎 , 𝑏, 𝑐, 𝑑, 𝑒, 𝑓  são  inteiros.  O  procedimento  é o  seguinte  :  Agrupamos  os termos  desta 

maneira  ,  𝑎𝑥2 + (𝑏𝑦 + 𝑑)𝑥 + (𝑐𝑦2 + 𝑒𝑦 + 𝑓) = 0.  Logo  a  equação  inicial  pode  ser  vista 

como uma simples equação do segundo grau com descriminante,  

∆1= (𝑏𝑦 + 𝑑)2 − 4𝑎(𝑐𝑦2 + 𝑒𝑦 + 𝑓) = (𝑏2 − 4𝑎𝑐)𝑦2 + (2𝑏𝑑 − 4𝑎𝑒)𝑦 + 𝑑2 − 4𝑎𝑓 , 
descriminante deve ser um quadrado perfeito , chamaremos então             ∆1= 𝑧2. Definindo ,   

esse 

𝑝 = 𝑏2 − 4𝑎𝑐 ,       𝑞 = 2𝑏𝑑 − 4𝑎𝑒 ,

𝑟 = 𝑑2 − 4𝑎𝑓 

Logo teremos ,   𝑝𝑦2 + 𝑞𝑦 + 𝑟 − 𝑧2 = 0 ,  que de novo é uma equação do segundo grau com 

descriminante ∆2= 𝑞2 − 4𝑝(𝑟 − 𝑧2)  , novamente  esse descriminante deve ser um quadrado 
perfeito , chamaremos então  ∆2= 𝑤2.  Daí ,   

𝑞2 − 4𝑝(𝑟 − 𝑧2) = 𝑤2 ⟺ 𝑤2 − 4𝑝𝑧2 = 𝑞2 − 4𝑝𝑟. 

Que é uma equaçãode PELL , com 𝑞2 − 4𝑝𝑟 = 𝑁. Logo , se conhecemos as soluções inteiras 

dessa  equação  ,  obtemos  imediatamente  as  soluções  inteiras  da  equação  geral  do  segundo 

grau. Nessa dissertação trabalharemos com o caso especial (ou particular)  𝑥2 − 𝑑𝑦2 = 1. 

A Equação Especial de Pell é dada por 𝑥2 − 𝑑𝑦2 = 1 , com 𝑥, 𝑦 ∈ ℤ, onde  𝑑 ∶= 𝑎2 − 1, 𝑎 >

1.  𝑑 ∈ ℕ∗. Observe  que  (𝑥, 𝑦) = (1,0)  e  (𝑥, 𝑦) = (𝑎, 1)  são  soluções  triviais  da  equação  de 

Pell,  além  disso    se  (𝑥, 𝑦)  é  uma  solução  então  (−𝑥, 𝑦) , (𝑥, −𝑦) e  (−𝑥, −𝑦)  também  são 

soluções. Note que se 𝑑 = 𝑘2 para algum valor de  𝑘 , então a equação especial acima so tem 

a solução trivial (𝑥, 𝑦) = (1,0). 

 
 
 
 
22 

Demonstração : 

Se 𝑑 = 𝑘2 para algum valor de  𝑘 , então usando fatoração   (𝑥 + 𝑘𝑦)(𝑥 − 𝑘𝑦) = 1 ,  logo 

𝑥 + 𝑘𝑦 = ±1 ou 𝑥 − 𝑘𝑦 = ±1 , pois o produto de inteiros é igual a um se e só se ambos são 

iguais a 1 ou −1. Assim temos os  sistemas : 

{

𝑥 + 𝑘𝑦 = −1
𝑥 − 𝑘𝑦 = −1

      𝑜𝑢    {

𝑥 + 𝑘𝑦 = 1
𝑥 − 𝑘𝑦 = 1

Resolvendo temos que a única solução é (𝑥, 𝑦) = (±1,0). De agora em diante consideraremos 

𝑑 como sendo um número que não é quadrado perfeito , ou seja , √𝑑 ∉ ℚ . 

Definição 2.2  𝑥𝑛(𝑎) e 𝑦𝑛(𝑎) para 𝑛 ∈ ℕ, 𝑎 > 1, são definidas por 𝑥𝑛(𝑎) + 𝑦𝑛(𝑎)√𝑑 =

𝑛
(𝑎 + √𝑑)

. Quando o contexto permitir , a dependência em relação a 𝑎 não será explicitada e 

escreverei apenas 𝑥𝑛 e 𝑦𝑛. 

Exemplo 2.2 :  𝑥1(𝑎) = 𝑎  𝑒  𝑦1(𝑎) = 1  ,     𝑥0(𝑎) = 1  𝑒  𝑦0(𝑎) = 0 

0
 𝑥0(𝑎) + 𝑦0(𝑎)√𝑑 = (𝑎 + √𝑑)

= 1 , o que implica que  𝑥0(𝑎) = 1  𝑒  𝑦0(𝑎) = 0 

1
𝑥1(𝑎) + 𝑦1(𝑎)√𝑑 = (𝑎 + √𝑑)

= 𝑎 + √𝑑, o que implica que  𝑥1(𝑎) = 𝑎  𝑒  𝑦1(𝑎) = 1 

Exemplo 2.3  :  𝑏 > 𝑎 ⟺ 𝑥𝑘(𝑏) > 𝑥𝑘(𝑎) .Usando binômio de Newton temos   𝑥𝑘(𝑎) +

𝑘
𝑦𝑘(𝑎)√𝑑 = (𝑎 + √𝑑)

𝑘
𝑥𝑘(𝑎) = ∑
𝑗=0
𝑗 𝑝𝑎𝑟

(𝑘
𝑗)

𝑎𝑘−𝑗𝑑

𝑗
2

𝑘
      𝑦𝑘(𝑎) = ∑

𝑗=1
𝑗 í𝑚𝑝𝑎𝑟

{

𝑎𝑘−𝑗𝑑

𝑗−1
2  

(𝑘
𝑗)

   . Logo se  𝑏 > 𝑎 ⟺ 𝑏𝑘−𝑗 > 𝑎𝑘−𝑗 ⟺ 𝑥𝑘(𝑏) > 𝑥𝑘(𝑎). 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
23 

Lema 2.1 Não existem inteiros  𝑥, 𝑦, que satisfaçam a Equação de Pell para os quais            

1 < 𝑥 + 𝑦√𝑑 < 𝑎 + √𝑑. 

Lema 2.2 Sejam 𝑥, 𝑦 e 𝑥′, 𝑦′ inteiros, que satisfaçam a Equação de Pell. Definindo           

 𝑥′′ = 𝑥𝑥′ + 𝑦𝑦′𝑑    e   𝑦′′ = 𝑥′𝑦 + 𝑦′𝑥. Então 𝑥′′ e 𝑦′′ satisfazem a Equação de Pell. 

Lema 2.3 𝑥𝑛 e 𝑦𝑛 satisfazem a Equação de Pell. 

Lema 2.4 Sejam 𝑥, 𝑦 soluções não negativas da Equação de Pell. Então para algum             

𝑛 ∈  ℕ , 𝑥 = 𝑥𝑛 e 𝑦 = 𝑦𝑛. 

Lema 2.5 𝑥𝑚±𝑛 = 𝑥𝑚𝑥𝑛 ± 𝑑𝑦𝑚𝑦𝑛 e 𝑦𝑚±𝑛 = 𝑦𝑚𝑥𝑛 ± 𝑥𝑚𝑦𝑛. 

Lema 2.6 𝑦𝑚±1 = 𝑎𝑦𝑚 ± 𝑥𝑚 𝑒 𝑥𝑚±1 = 𝑎𝑥𝑚 ± 𝑑𝑦𝑚. 

Lema 2.7 (𝑥𝑛, 𝑦𝑛) = 1. 

Lema 2.8 𝑦𝑛 ⎸𝑦𝑛𝑘.   𝑛 ∈ ℕ∗ 

Lema 2.9 𝑦𝑛 ⎸𝑦𝑡 se, e somente se, 𝑛 ⎸𝑡.    𝑛 ∈ ℕ∗ 

Lema 2.10  𝑦𝑛𝑘 ≡ 𝑘𝑥𝑛

𝑘−1𝑦𝑛 (mod 𝑦𝑛

3),    ∀ 𝑘  ∈   ℕ∗ , 𝑘 ≥ 1. 

Lema 2.11 𝑦𝑛

2 ⎸𝑦𝑛 .𝑦𝑛 .     𝑛 ∈ ℕ∗ 

Lema 2.12 𝑦𝑛

2 ⎸𝑦𝑡 então 𝑦𝑛 ⎸𝑡 .    𝑛 ∈ ℕ∗ 

Lema 2.13 𝑥𝑛+1 = 2𝑎𝑥𝑛 − 𝑥𝑛−1 e 𝑦𝑛+1 = 2𝑎𝑦𝑛 − 𝑦𝑛−1. 

Lema 2.14 𝑦𝑛(𝑎) ≡ 𝑛  (mod 𝑎 − 1). 
Lema 2.15 Se 𝑎 ≡ 𝑏 (mod 𝑐),  então ∀ 𝑛  ∈  ℕ,    𝑥𝑛(𝑎) ≡ 𝑥𝑛(𝑏)  (mod 𝑐) e                 
𝑦𝑛(𝑎) ≡   𝑦𝑛(𝑏)  (mod 𝑐). 

Lema 2.16 Quando 𝑛 é par, 𝑦𝑛 é par e quando 𝑛 é ímpar, 𝑦𝑛 é ímpar. 
Lema 2.17  𝑥𝑛(𝑎) − 𝑦𝑛(𝑎)(𝑎 − 𝑦) ≡ 𝑦𝑛  (mod 2𝑎𝑦 − 𝑦2 − 1). 

Lema 2.18 ∀ 𝑛 ∈  ℕ, 𝑦𝑛+1 > 𝑦𝑛 ≥ 𝑛. 
Lema 2.19  ∀ 𝑛 ∈  ℕ, 𝑎𝑛 ≤ 𝑥𝑛(𝑎) < 𝑥𝑛+1(𝑎) e 𝑥𝑛(𝑎) ≤ (2𝑎)𝑛. 
Lema 2.20 𝑥2𝑛±𝑗 ≡ −𝑥𝑗 (mod 𝑥𝑛). 

Lema 2.21 𝑥4𝑛±𝑗 ≡ 𝑥𝑗 (mod 𝑥𝑛). 

Lema 2.22  Seja  𝑥𝑖 ≡ 𝑥𝑗 (mod 𝑥𝑛),    𝑖 ≤ 𝑗 ≤ 2𝑛,   𝑛 > 0. Então 𝑖 = 𝑗, exceto se                          

𝑎 = 2  , 𝑛 = 1 , 𝑖 = 0  𝑒  𝑗 = 2. 

Lema 2.23 Seja 𝑥𝑖 ≡ 𝑥𝑗  (mod 𝑥𝑛), 0 < 𝑛,   0 < 𝑖 ≤ 𝑛,   0 ≤ 𝑗 < 4𝑛 , então                               

𝑗 = 𝑖 𝑜𝑢 𝑗 = 4𝑛 − 𝑖. 

Lema 2.24 Seja 0 < 𝑖 ≤ 𝑛  e  𝑥𝑖 ≡ 𝑥𝑗   (mod  𝑥𝑛) então 𝑗 ≡ ±𝑖  (mod 4𝑛). 

Lema 2.25  Se 𝑎 > 𝑦𝑘  então    2𝑎𝑦 − 𝑦2 − 1 > 𝑦𝑘 

 
 
 
 
24 

Lema 2.1  Não existem inteiros  𝑥, 𝑦, que satisfaçam a Equação de Pell e a inequação 

Demonstração. 

1 < 𝑥 + 𝑦√𝑑 < 𝑎 + √𝑑. 

Suponha que  𝑥, 𝑦  satisfazem  𝑥2 − 𝑑𝑦2 = 1  e  1 < 𝑥 + 𝑦√𝑑 < 𝑎 + √𝑑.  Como , 

1 = (𝑎 + √𝑑)(𝑎 − √𝑑) = (𝑥 + 𝑦√𝑑)(𝑥 − 𝑦√𝑑) 

essa igualdade e a inequação implicam que   1 > 𝑥 − 𝑦√𝑑 > 𝑎 − √𝑑. Daí , 

{

1 > 𝑥 − 𝑦√𝑑 > 𝑎 − √𝑑
𝑒
1 < 𝑥 + 𝑦√𝑑 < 𝑎 + √𝑑

⟹ {

−1 < −𝑥 + 𝑦√𝑑 < −𝑎 + √𝑑
𝑒
1 < 𝑥 + 𝑦√𝑑 < 𝑎 + √𝑑

⟹  0 < 2𝑦√𝑑 < 2√𝑑 ⟹ 0

< 𝑦 < 1. 

Por fim chegamos em uma contradição portanto o Lema 2.1 está provado. 

∎ 

Lema 2.2 Sejam 𝑥, 𝑦 e 𝑥′, 𝑦′ inteiros, que satisfaçam a Equação de Pell. Definindo                      

𝑥′′ = 𝑥𝑥′ + 𝑦𝑦′𝑑   e  𝑦′′ = 𝑥′𝑦 + 𝑦′𝑥 . Então 𝑥′′ e 𝑦′′ satisfazem a Equação de Pell. 

Demonstração. 

Pela definição temos que 

{

𝑥′′ + 𝑦′′√𝑑 = (𝑥 + 𝑦√𝑑)(𝑥′ + 𝑦′√𝑑)
𝑥′′ − 𝑦′′√𝑑 = (𝑥 − 𝑦√𝑑)(𝑥′ − 𝑦′√𝑑)

⟹ (𝑥′′)2 − 𝑑(𝑦′′)2 = (𝑥′′ + 𝑦′′√𝑑)(𝑥′′ − 𝑦′′√𝑑) 

= (𝑥 + 𝑦√𝑑)(𝑥 − 𝑦√𝑑)(𝑥′ − 𝑦′√𝑑)(𝑥′ + 𝑦′√𝑑) = (𝑥2 − 𝑑𝑦2)(𝑥 ′2 − 𝑑𝑦′2) = 1.    

  ∎ 

Lema 2.3 𝑥𝑛 e 𝑦𝑛 satisfazem a Equação de Pell. 

Demonstração.  Para 𝑛 = 1 o lema é verdadeiro. De fato,     𝑥1(𝑎) + 𝑦1(𝑎)√𝑑 =

1
(𝑎 + √𝑑)

= 𝑎 + √𝑑, o que implica que  𝑥1(𝑎) = 𝑎  𝑒  𝑦1(𝑎) = 1, é a solução trivial da 

Equação de Pell. Suponha que o lema seja verdadeiro para 𝑛 − 1 ,  ou seja,  𝑥𝑛−1(𝑎)  e 
 𝑦𝑛−1(𝑎) também satisfazem a equação. Logo 

𝑛
𝑥𝑛(𝑎) + 𝑦𝑛(𝑎)√𝑑 = (𝑎 + √𝑑)

= (𝑎 + √𝑑)(𝑎 + √𝑑)

𝑛−1

= (𝑥1 + 𝑦1√𝑑)(𝑥𝑛−1 + 𝑦𝑛−1√𝑑) 

Utilizando o Lema 2.2 e a hipótese de indução, temos que 𝑥𝑛(𝑎) e 𝑦𝑛(𝑎) satisfazem a 

equação.   ∎ 

 
 
 
 
Lema 2.4 Sejam 𝑥, 𝑦 ∈ ℕ soluções da Equação de Pell. Então para algum 𝑛 ∈   ℕ∗ temos , 𝑥 =

25 

𝑥𝑛 e 𝑦 = 𝑦𝑛. 

Demonstração. 

𝑛
     Inicialmente note que 𝑥 + 𝑦√𝑑 ≥ 1. Por outro lado, a medida que  𝑛  aumenta   (𝑎 + √𝑑)

𝑛
tende ao infinito. Portanto existe um 𝑛 ≥ 0, tal que (𝑎 + √𝑑)

≤ 𝑥 + 𝑦√𝑑 < (𝑎 + √𝑑)𝑛+1 se 

𝑛
ocorre  a  igualdade  (𝑎 + √𝑑)

= 𝑥 + 𝑦√𝑑  o  resultado  esta  provado,  caso  contrario            

𝑥𝑛 + 𝑦𝑛√𝑑 < 𝑥 + 𝑦√𝑑 < (𝑥𝑛 + 𝑦𝑛√𝑑)(𝑎 + √𝑑)  como  (𝑥𝑛 + 𝑦𝑛√𝑑)(𝑥𝑛 − 𝑦𝑛√𝑑) = 1  (ver 

Lema 2.3), então o número 𝑥𝑛 − 𝑦𝑛√𝑑 > 0 pois  𝑥𝑛 + 𝑦𝑛√𝑑 > 0 . Daí:  

(𝑥𝑛 − 𝑦𝑛√𝑑)(𝑥𝑛 + 𝑦𝑛√𝑑) < (𝑥𝑛 − 𝑦𝑛√𝑑)(𝑥 + 𝑦√𝑑)

< (𝑥𝑛 − 𝑦𝑛√𝑑)(𝑥𝑛 + 𝑦𝑛√𝑑)(𝑎 + √𝑑). 

Logo,  

1< (𝑥𝑛 − 𝑦𝑛√𝑑)(𝑥 + 𝑦√𝑑) <  𝑎 + √𝑑   ⇒
𝐿 2.2

  ∃𝑥′′, 𝑦′′ ∈  ℤ  ⎸ 1 < 𝑥′′ + 𝑦′′√𝑑 <  𝑎 + √𝑑 

. 

𝑛
Mas  isto contradiz o lema 2.1. Logo , devemos ter (𝑎 + √𝑑)

= 𝑥 + 𝑦√𝑑  , ou seja,  ∃ 𝑛 ∈

 ℕ  ⎸𝑥 = 𝑥𝑛 e 𝑦 = 𝑦𝑛.    ∎ 

Lema 2.5  𝑥𝑚±𝑛 = 𝑥𝑚𝑥𝑛 ± 𝑑𝑦𝑚𝑦𝑛 e 𝑦𝑚±𝑛 = 𝑦𝑚𝑥𝑛 ± 𝑥𝑚𝑦𝑛. 

Demonstração.  𝑥𝑚+𝑛 + 𝑦𝑚+𝑛√𝑑 ≝ (𝑎 + √𝑑)𝑚+𝑛 = (𝑥𝑚 + 𝑦𝑚√𝑑)(𝑥𝑛 + 𝑦𝑛√𝑑) =

(𝑥𝑚𝑥𝑛 + 𝑑𝑦𝑚𝑦𝑛) + (𝑦𝑚𝑥𝑛 + 𝑥𝑚𝑦𝑛)√𝑑. 

Portanto,      {

    𝑥𝑚+𝑛 = 𝑥𝑚𝑥𝑛 + 𝑑𝑦𝑚𝑦𝑛
𝑒
  𝑦𝑚+𝑛 = 𝑦𝑚𝑥𝑛 + 𝑥𝑚𝑦𝑛.

De forma análoga, temos que (𝑥𝑚−𝑛 + 𝑦𝑚−𝑛√𝑑)(𝑥𝑛 + 𝑦𝑛√𝑑) = 𝑥𝑚 + 𝑦𝑚√𝑑, e 

multiplicando por  𝑥𝑛 − 𝑦𝑛√𝑑 de ambos os lados, obtemos: 

𝑥𝑚−𝑛 + 𝑦𝑚−𝑛√𝑑 = (𝑥𝑚 + 𝑦𝑚√𝑑)(𝑥𝑛 − 𝑦𝑛√𝑑) = (𝑥𝑚𝑥𝑛 − 𝑑𝑦𝑚𝑦𝑛) + (𝑦𝑚𝑥𝑛 − 𝑥𝑚𝑦𝑛)√𝑑. 

Portanto, 

{

𝑥𝑚−𝑛 = 𝑥𝑚𝑥𝑛 − 𝑑𝑦𝑚𝑦𝑛
𝑒
   𝑦𝑚−𝑛 = 𝑦𝑚𝑥𝑛 − 𝑥𝑚𝑦𝑛.     

     ∎ 

 
 
 
 
 
 
Lema 2.6   𝑦𝑚±1 = 𝑎𝑦𝑚 ± 𝑥𝑚  𝑒  𝑥𝑚±1 = 𝑎𝑥𝑚 ± 𝑑𝑦𝑚. 

Demonstração. 

Faça  𝑛 = 1  no Lema 2.5 e lembre que  𝑥1 = 𝑎  e  𝑦1 = 1. Uma consequência desse Lema é 

que  𝑦𝑚+1 > 𝑦𝑚  de fato pois  𝑦𝑚+1 = 𝑎𝑦𝑚 + 𝑥𝑚 ≥ 𝑎𝑦𝑚 > 𝑦𝑚.  Portanto segue por indução 

26 

que   𝑛 > 𝑟 ⟺ 𝑦𝑛 > 𝑦𝑟    

∎ 

Lema 2.7 (𝑥𝑛, 𝑦𝑛) = 1. 

Demonstração. 

Seja 𝐷 ∈  ℕ∗ tal que 𝐷 ⎸𝑥𝑛  e  𝐷 ⎸𝑦𝑛 , então 𝐷 ⎸𝑥𝑛

2 − 𝑑𝑦𝑛

2 ⟹ 𝐷 ⎸1 ⟹ 𝐷 = 1    

∎ 
Lema 2.8  𝑦𝑛 ⎸𝑦𝑛𝑘.   𝑛 ∈  ℕ∗ 

Demonstração. 

Vamos utilizar indução sobre 𝑘  . O lema é verdadeiro para 𝑘 = 1 , já que, 𝑦𝑛 ⎸𝑦𝑛. .Suponha 

que  seja  verdadeiro  para  𝑘 = 𝑚,  ou  seja,  𝑦𝑛 ⎸𝑦𝑛𝑚.  Do  Lema  2.5 

temos  que                 

𝑦𝑛(𝑚+1) = 𝑦𝑚𝑛+𝑛 =   𝑦𝑚𝑛𝑥𝑛 + 𝑥𝑛𝑚𝑦𝑛. Como  𝑦𝑛 ⎸𝑥𝑚𝑛 𝑦𝑛  e  pela  hipótese  de 

indução 

𝑦𝑛 ⎸𝑦𝑛𝑚𝑥𝑛 ⟹ 𝑦𝑛  ⎸(𝑦𝑚𝑛𝑥𝑛 + 𝑥𝑚𝑛 𝑦𝑛) ⟹ 𝑦𝑛 ⎸𝑦𝑛(𝑚+1).  Portanto  o  lema  é  válido  para    𝑘 =

𝑚 + 1, o que conclui a prova por indução.     

∎ 
Lema 2.9 𝑦𝑛 ⎸𝑦𝑡 ⟺ 𝑛 ⎸𝑡.     𝑛 ∈  ℕ∗ 

Demonstração. 

Inicialmente, 

suponha  que  𝑦𝑛 ⎸𝑦𝑡  mas  que  𝑛 ∤ 𝑡.  Então  podemos 

escrever                             

𝑡 = 𝑛𝑞 + 𝑟, 0 < 𝑟 < 𝑛.  Então 𝑦𝑡 = 𝑦𝑛𝑞+𝑟 e pelo Lema 2.5 temos que,  𝑦𝑡 = 𝑦𝑛𝑞𝑥𝑟 + 𝑥𝑛𝑞𝑦𝑟. 

Do  Lema  2.8    𝑦𝑛 ⎸𝑦𝑛𝑞  e  por  hipótese  𝑦𝑛 ⎸𝑦𝑡,        como  𝑥𝑛𝑞𝑦𝑟 = 𝑦𝑡 − 𝑥𝑛𝑞𝑦𝑟  segue  que 

𝑦𝑛 ⎸𝑥𝑛𝑞 𝑦𝑟.  

Provemos  agora  que  (𝑦𝑛, 𝑥𝑛𝑞) = 1,   se 𝑑 ⎸𝑦𝑛  e 𝑑 ⎸𝑥𝑛𝑞 ,  pelo  Lema  2.8 , 𝑑 ⎸𝑦𝑛𝑞  e  do  Lema 

2.7  temos  que  (𝑥𝑛𝑞, 𝑦𝑛𝑞) = 1  ,  segue  que  𝑑 ⎸1,  ou  seja,  𝑑 = 1.  Portanto  𝑦𝑛 ⎸𝑦𝑟,  e  daí          

𝑦𝑛 ≤  𝑦𝑟. Por outro lado como 𝑛 > 𝑟, pela consequência do Lema 2.6 teriamos 𝑦𝑛 >  𝑦𝑟 , ou 

seja , 𝑦𝑛 ≤  𝑦𝑟 e 𝑦𝑛 >  𝑦𝑟 que é uma contradição. Portanto 𝑟 = 0 ⟹ 𝑡 = 𝑛𝑞 ⟹  𝑛 ⎸𝑡 . 

 Reciprocamente, se 𝑛 ⎸𝑡 ⟹ 𝑡 = 𝑛𝑘, pelo Lema 2.8  𝑦𝑛 ⎸𝑦𝑛𝑘,  ou seja,  𝑦𝑛 ⎸𝑦𝑡.  

∎ 

 
 
 
 
 
27 

Lema 2.10  𝑦𝑛𝑘 ≡ 𝑘𝑥𝑛

𝑘−1𝑦𝑛 (mod 𝑦𝑛

3),    ∀ 𝑘  ∈   ℕ∗. 

 Demonstração. 

  Por definição 𝑥𝑛𝑘 + 𝑦𝑛𝑘√𝑑 = (𝑎 + √𝑑)𝑛𝑘 = (𝑥𝑛 + 𝑦𝑛√𝑑)𝑘 e pela fórmula do Binômio de 
Newton: 

𝑘
(𝑥𝑛 + 𝑦𝑛√𝑑)

𝑘

= ∑ (
𝑗=0

𝑘
𝑗

)

𝑥𝑛

𝑘−𝑗𝑦𝑛

𝑗𝑑

𝑗
2

= (

𝑘
0

) 𝑥𝑛

𝑘 + (

𝑘
1

) 𝑥𝑛

𝑘−1𝑦𝑛𝑑

1
2 + (

𝑘
2

Desta igualdade concluimos que , 

) 𝑥𝑛

𝑘−2𝑦𝑛

2𝑑 + ⋯ + (

) 𝑦𝑛

𝑘𝑑

𝑘
2

 . 

𝑘
𝑘

𝑘

𝑦𝑛𝑘√𝑑 = ∑ (

𝑗=0
𝑗 𝑖𝑚𝑝𝑎𝑟

𝑘
𝑗

𝑘

⟹ 𝑦𝑛𝑘 = ∑ (

𝑗=0
𝑗 𝑖𝑚𝑝𝑎𝑟

)

𝑗𝑑
𝑘−𝑗𝑦𝑛
𝑥𝑛

𝑗
2 = 𝑘𝑥𝑛

𝑘−1𝑦𝑛√𝑑 + √𝑑 ∑ (

𝑘

)

𝑗𝑑
𝑘−𝑗𝑦𝑛
𝑥𝑛

𝑗−1
2   ⟹   

𝑘
𝑗

𝑘
𝑗

)

𝑗𝑑
𝑘−𝑗𝑦𝑛
𝑥𝑛

𝑗
2 = 𝑘𝑥𝑛

𝑘−1𝑦𝑛 + ∑ (

)

𝑗𝑑
𝑘−𝑗𝑦𝑛
𝑥𝑛

𝑗−1
2   

𝑘
𝑗

𝑗=3
𝑗 𝑖𝑚𝑝𝑎𝑟

𝑘

𝑗=3
𝑗 𝑖𝑚𝑝𝑎𝑟

Para  𝑗 ≥ 3,  os  termos  desta  expansão  são  todos  congruentes  a  zero  (mod  𝑦𝑛

3). Então      

  𝑦𝑛𝑘 ≡ 𝑘𝑥𝑛

𝑘−1𝑦𝑛 (mod 𝑦𝑛

3). 

∎ 

Lema 2.11   𝑦𝑛

2 ⎸𝑦𝑛 . 𝑦𝑛  .     𝑛 ∈  ℕ∗ 

Demonstração. Utilizando 𝑘 = 𝑦𝑛 no Lema 2.10 obtemos 𝑦𝑛 .𝑦𝑛 ≡ 𝑦𝑛
congruência temos que ∃𝑡 ∈ ℤ  tal que  𝑦𝑛 .𝑦𝑛 = (𝑦𝑛)3𝑡 + 𝑦𝑛
2 ⎸𝑦𝑛 .𝑦𝑛  .   ∎ 
onde concluímos que 𝑦𝑛

2𝑥𝑛
𝑦𝑛−1 = 𝑦𝑛

2𝑥𝑛

𝑦𝑛−1(mod 𝑦𝑛

3) e desta 

2(𝑦𝑛𝑡 + 𝑥𝑛

𝑦𝑛−1), de 

Lema 2.12   𝑦𝑛

2 ⎸𝑦𝑡 ⇒ 𝑦𝑛 ⎸𝑡.     𝑛 ∈  ℕ∗ 

Demonstração. 

     Como 𝑦𝑛

2 ⎸𝑦𝑡, segue que  𝑦𝑛 ⎸𝑦𝑡 e pelo Lema 2.9, 𝑛 ⎸𝑡. Seja 𝑡 = 𝑛𝑘. Do Lema 2.10 temos 
2 ⎸(𝑦𝑛)3 concluímos que 
2 ⎸𝑦𝑛𝑘 e 𝑦𝑛
𝑘−1.  Mas  pelo  Lema  2.7,   (𝑥𝑛, 𝑦𝑛) = 1. Então 𝑦𝑛 ⎸𝑘,  e  como 

𝑘−1𝑦𝑛 = 𝑦𝑛𝑘 − 𝑢(𝑦𝑛)3 e como 𝑦𝑛

que, ∃𝑢 ∈ ℤ  tal que  𝑘𝑥𝑛
2 ⎸𝑘𝑥𝑛
𝑦𝑛
𝑡 = 𝑛𝑘, segue que 𝑦𝑛 ⎸𝑡.     ∎ 

𝑘−1𝑦𝑛, ou  ainda,  𝑦𝑛 ⎸𝑘𝑥𝑛

 
 
 
28 

Lema 2.13  𝑥𝑛+1 = 2𝑎𝑥𝑛 − 𝑥𝑛−1 e 𝑦𝑛+1 = 2𝑎𝑦𝑛 − 𝑦𝑛−1. 

Demonstração. 

𝑥𝑛+1 = 𝑎𝑥𝑛 + 𝑑𝑦𝑛   𝑒   𝑦𝑛+1 = 𝑎𝑦𝑛 + 𝑥𝑛,

Do Lema 2.6 temos:   {

𝑥𝑛−1 = 𝑎𝑥𝑛 − 𝑑𝑦𝑛   𝑒   𝑦𝑛−1 = 𝑎𝑦𝑛 − 𝑥𝑛,

⟹  {

𝑥𝑛+1 + 𝑥𝑛−1 = 2𝑎𝑥𝑛 
𝑒
 𝑦𝑛+1 + 𝑦𝑛−1 = 2𝑎𝑦𝑛

e  então  ,   𝑥𝑛+1 = 2𝑎𝑥𝑛 − 𝑥𝑛−1  e  𝑦𝑛+1 = 2𝑎𝑦𝑛 − 𝑦𝑛−1.  Estas  equações  mais  as 

condições iniciais 𝑥0 = 1, 𝑥1 = 𝑎 , 𝑦0 = 0  e 𝑦1 = 1 determinam todos os valores de 𝑥𝑛 e 𝑦𝑛. 

 ∎ 

Lema 2.14 𝑦𝑛(𝑎) ≡ 𝑛  (mod 𝑎 − 1). 

Demonstração. 

     Para 𝑛 = 0 𝑒 𝑛 = 1 a congruência é trivialmente satisfeita já que 𝑦0(𝑎) = 0  𝑒 𝑦1(𝑎) = 1. 

Vamos  supor  que  o 

lema  é  verdadeiro  para  𝑘 ≤ 𝑛 

.  Devemos  mostrar  que               

  𝑦𝑛+1(𝑎) ≡ 𝑛 + 1  (mod 𝑎 − 1). Da hipótese de indução temos ,  

𝑦𝑛(𝑎) ≡ 𝑛 (mod 𝑎 − 1)  
𝑒
 𝑦𝑛−1(𝑎) ≡ 𝑛 − 1   (mod 𝑎 − 1).

{

Como  𝑎 ≡ 1 (mod  𝑎 − 1),  segue  das  propriedades  de  conguência  que  2𝑎𝑦𝑛(𝑎) ≡ 2𝑛  (mod 

𝑎 − 1) , daí  

2𝑎𝑦𝑛(𝑎) ≡ 2𝑛  (mod 𝑎 − 1)  
𝑒
−𝑦𝑛−1(𝑎) ≡ −(𝑛 − 1)  (mod 𝑎 − 1)

{

𝐿2.13
Logo ,   𝑦𝑛+1(𝑎) ≡

2𝑎𝑦𝑛(𝑎) − 𝑦𝑛−1(𝑎) ≡ 2𝑛 − (𝑛 − 1) ≡ 𝑛 + 1  (mod 𝑎 − 1)  . ∎ 

Lema 

2.15  Se  𝑎 ≡ 𝑏 

(mod 

𝑐), então  ∀ 𝑛 ∈  ℕ , 𝑥𝑛(𝑎) ≡ 𝑥𝑛(𝑏)  (mod 

𝑐) 

e                      

𝑦𝑛(𝑎) ≡   𝑦𝑛(𝑏)  (mod 𝑐). 

Demonstração. 

Vamos provar que 𝑥𝑛(𝑎) ≡ 𝑥𝑛(𝑏)  (mod 𝑐). Para 𝑛 = 0 e 𝑛 = 1  a congruência é trivialmente 
satisfeita  já  que  𝑥0(𝑎) = 𝑥0(𝑏) = 1 , 𝑦0(𝑎) = 𝑦0(𝑏) = 0, 𝑥1(𝑎) = 𝑎 , 𝑥1(𝑏) = 𝑏,   𝑦1(𝑎) =
𝑦1(𝑏) = 1.  Vamos  supor  que  o  lema  é  verdadeiro  para  𝑘 ≤ 𝑛.    Em  particular,  𝑥𝑛(𝑎) ≡
𝑥𝑛(𝑏)  (mod 𝑐) e 𝑥𝑛−1(𝑎) ≡ 𝑥𝑛−1(𝑏)  (mod 𝑐). Daí, 

 
 
 
 
 
 
  
 
  
 
 
{

𝑥𝑛(𝑎) ≡ 𝑥𝑛(𝑏) (mod 𝑐)
𝑒
 𝑥𝑛−1(𝑎) ≡ 𝑥𝑛−1(𝑏)  (mod 𝑐).

⟹  {

 2𝑎𝑥𝑛(𝑎) ≡ 2𝑎𝑥𝑛(𝑏)  (mod 𝑐)  
𝑒
−𝑥𝑛−1(𝑎) ≡ −𝑥𝑛−1(𝑏)  (mod 𝑐).

29 

𝐿 2.13
⟹ 2𝑎𝑥𝑛(𝑎) − 𝑥𝑛−1(𝑎) ≡ 2𝑎𝑥𝑛(𝑏) − 𝑥𝑛−1(𝑏)  (mod 𝑐)  ⇒

𝑥𝑛+1(𝑎) ≡ 𝑥𝑛+1(𝑏)  (mod 𝑐)    

A prova de que 𝑦𝑛(𝑎) ≡ 𝑦𝑛(𝑏)  (mod 𝑐) é feita de forma inteiramente análoga.  

∎ 

Lema 2.16 Quando 𝑛 é par, 𝑦𝑛 é par e quando 𝑛 é ímpar, 𝑦𝑛 é ímpar. 

Demonstração. 

Do Lema 2.13  𝑦𝑚+1 ≡ 2𝑎𝑦𝑚 − 𝑦𝑚−1 ≡ 𝑦𝑚−1 (mod 2) ⟹ 𝑦𝑚+1 ≡ 𝑦𝑚−1 (mod 2) daí 

temos dois casos 

 0 = 𝑦0 ≡ 𝑦2   ≡   𝑦4 ≡ ⋯   ≡ 𝑦𝑛  (mod 2). Logo 𝑦𝑛 é par quando 𝑛 é par. 

1 = 𝑦1 ≡ 𝑦3   ≡    𝑦5 ≡ ⋯   ≡ 𝑦𝑛  (mod 2). Logo 𝑦𝑛 é ímpar, quando 𝑛 é ímpar.    

∎ 
Lema 2.17  𝑥𝑛(𝑎) − 𝑦𝑛(𝑎)(𝑎 − 𝑦) ≡ 𝑦𝑛  (mod 2𝑎𝑦 − 𝑦2 − 1). 
Demonstração. 

Para 𝑛 = 0 e  𝑛 = 1  a congruência é satisfeita. 

𝑥0 − 𝑦0(𝑎 − 𝑦) = 1 = 𝑦0      e      𝑥1 − 𝑦1(𝑎 − 𝑦) = 𝑎 − 1(𝑎 − 𝑦) = 𝑦 = 𝑦1. 
Devemos  mostrar  que   𝑥𝑛+1(𝑎) − 𝑦𝑛+1(𝑎)(𝑎 − 𝑦) ≡ 𝑦𝑛+1  (mod  2𝑎𝑦 − 𝑦2 − 1) para  isso 

suponha que o lema seja verdadeiro para 𝑘 ≤ 𝑛.  temos que:  

𝐿 2.13
𝑥𝑛+1(𝑎) − 𝑦𝑛+1(𝑎)(𝑎 − 𝑦) =

(2𝑎𝑥𝑛 − 𝑥𝑛−1) − (2𝑎𝑦𝑛 − 𝑦𝑛−1)(𝑎 − 𝑦) = 

= 2𝑎[𝑥𝑛 − 𝑦𝑛(𝑎 − 𝑦)] − [𝑥𝑛−1 − 𝑦𝑛−1(𝑎 − 𝑦)] 

Mas pela hipótese de indução, 

𝑥𝑛 − 𝑦𝑛(𝑎 − 𝑦) ≡ 𝑦𝑛 (mod 2𝑎𝑦 − 𝑦2 − 1)   
{
𝑒
 −[𝑥𝑛−1 − 𝑦𝑛−1(𝑎 − 𝑦)] ≡ −𝑦𝑛−1 (mod 2𝑎𝑦 − 𝑦2 − 1)

Então, 

 𝑥𝑛+1(𝑎) − 𝑦𝑛+1(𝑎)(𝑎 − 𝑦) ≡ 2𝑎𝑦𝑛 − 𝑦𝑛−1 ≡ 𝑦𝑛−1(2𝑎𝑦 − 1) ≡ 𝑦𝑛−1. 𝑦2 ≡ 𝑦𝑛+1 
(mod 2𝑎𝑦 − 𝑦2 − 1)  o que conclui  a prova.  Perceba que na última  igualdade  foi usado que 

2𝑎𝑦 − 1 ≡ 𝑦 (mod 2𝑎𝑦 − 𝑦2 − 1).    

∎   

 
 
 
  
 
 
 
 
 
 
 
Lema 2.18   ∀ 𝑛 ∈   ℕ ,  𝑦𝑛+1 > 𝑦𝑛 ≥ 𝑛. 
Demonstração. 

Pela  consequência  do    Lema  2.6,  𝑦𝑛+1 > 𝑦𝑛.  Resta  provar  que  𝑦𝑛 ≥ 𝑛.  Se  𝑛 = 0,  o 

lema é verdadeiro, pois 𝑦0 = 0 ≥ 0. Suponha que o lema seja verdadeiro para 𝑛, ou seja, 𝑦𝑛 ≥

𝑛. Sabemos que 𝑦𝑛+1 > 𝑦𝑛 ⟹ 𝑦𝑛+1 ≥ 𝑦𝑛 + 1, e pela hipótese de indução            𝑦𝑛+1 ≥ 𝑛 +

30 

1, o que conclui a prova.     

∎ 

Lema 2.19  ∀ 𝑛 ∈   ℕ , 𝑎𝑛 ≤ 𝑥𝑛(𝑎) < 𝑥𝑛+1(𝑎)   e   𝑥𝑛(𝑎) ≤ (2𝑎)𝑛. 
Demonstração. 
       Primeiro  Provemos  que    𝑎𝑛 ≤ 𝑥𝑛(𝑎) < 𝑥𝑛+1(𝑎).  Para  𝑛 = 0,  as  desigualdades  se 
verificam, pois 𝑥0 = 1 e 𝑥1 = 𝑎 > 1 = 𝑎0  portanto  , 𝑎0 ≤ 𝑥0 < 𝑥1  suponha o lema válido 
para  𝑛. Devemos provar que 𝑎𝑛+1 ≤ 𝑥𝑛+1(𝑎) < 𝑥𝑛+2(𝑎). De fato , pois 

𝐿2.6
𝑥𝑛+2 =

𝐿2.6
𝑎𝑥𝑛+1 + 𝑑𝑦𝑛+1 ≥ 𝑎𝑥𝑛+1 > 𝑥𝑛+1 =

𝑎𝑥𝑛 + 𝑑𝑦𝑛 ≥ 𝑎𝑥𝑛 ≥

𝑖𝑛𝑑𝑢çã𝑜

𝑎𝑛+1 

⟹ 𝑎𝑛+1 ≤ 𝑥𝑛+1(𝑎) < 𝑥𝑛+2(𝑎).  
       Provemos agora tambem por indução que 𝑥𝑛(𝑎) ≤ (2𝑎)𝑛. Para 𝑛 = 0  a desigualdade é 

2𝑎𝑥𝑛 − 𝑥𝑛−1 ≤ 2𝑎𝑥𝑛 ≤

𝑖𝑛𝑑𝑢çã𝑜

(2𝑎)𝑛+1 ⟹

𝐿2.13
verdadeira  já  que  𝑥0 ≤ (2𝑎)0    ,  como  𝑥𝑛+1 =
𝑥𝑛+1(𝑎) ≤ (2𝑎)𝑛+1.    
∎ 

Lema 2.20   𝑥2𝑛±𝑗 ≡ −𝑥𝑗 (mod 𝑥𝑛). 

Demonstração. 

Pelas fórmulas de adição do Lema 2.5  e  lembrando que  𝑑𝑦𝑛

2 = 𝑥𝑛

2 − 1 temos : 

𝑥2𝑛±𝑗 ≡ 𝑥𝑛+(𝑛±𝑗) ≡ 𝑥𝑛𝑥𝑛±𝑗 + 𝑑𝑦𝑛𝑦𝑛±𝑗 ≡ 𝑥𝑛(𝑥𝑛𝑥𝑗 ± 𝑑𝑦𝑛𝑦𝑗) + 𝑑𝑦𝑛(𝑦𝑛𝑥𝑗 ± 𝑥𝑛𝑦𝑗) 
2𝑥𝑗 ≡ (𝑥𝑛

2 − 1)𝑥𝑗 ≡ −𝑥𝑗  (mod 𝑥𝑛).     

≡ 𝑑𝑦𝑛

∎ 

Lema 2.21  𝑥4𝑛±𝑗 ≡ 𝑥𝑗 (mod 𝑥𝑛). 

Demonstração. 

Pelo Lema 2.20.   𝑥4𝑛±𝑗 ≡ 𝑥2𝑛+(2𝑛±𝑗) ≡ −𝑥2𝑛±𝑗 ≡ −(−𝑥𝑗) ≡ 𝑥𝑗  (mod 𝑥𝑛).    

∎ 

 
 
 
 
 
 
 
 
31 

Lema 2.22  Seja  

𝑥𝑖 ≡ 𝑥𝑗      (mod 𝑥𝑛),    𝑖 ≤ 𝑗 ≤ 2𝑛  , 𝑛 > 0. 

Então 𝑖 = 𝑗, exceto se 𝑎 = 2  , 𝑛 = 1  , 𝑖 = 0  𝑒  𝑗 = 2. 

Demonstração. 
𝒙𝒏  ímpar : Suponha que 𝑥𝑛 é ímpar e seja 𝑞 =  𝑥𝑛−1

2

. Então os números 

−𝑞, −𝑞 + 1, −𝑞 + 2, … , −1,0,1, … , 𝑞 − 1, 𝑞 

Formam um sistema completo de restos módulos 𝑥𝑛. 

      Pelo 
Lema 
𝑥𝑛 = 𝑎𝑥𝑛−1 + 𝑑𝑦𝑛−1 ⟹ 𝑥𝑛−1 ≤ 𝑥𝑛

2.19, 

≤ 𝑥𝑛
2

, assim 𝑥𝑛−1 ≤ 𝑞 .  

𝑎

1 = 𝑥0 < 𝑥1 < ⋯ < 𝑥𝑛−1. Usando 

o 

Lema 

2.6                                     

      Se  𝑥𝑛−1 = 𝑞 ⟹ 2𝑥𝑛−1 = 𝑥𝑛 − 1 ⟹ 2𝑥𝑛−1 + 1 = 𝑥𝑛 ⟹ 𝑑𝑦𝑛−1 = 1 ⟹ 𝑑 = 1  absurdo 

já  que  𝑑 > 1  .  Se  𝑥𝑛−1 < 𝑞      pelo    Lema  2.20  os  números  𝑥𝑛+1, 𝑥𝑛+2, … , 𝑥2𝑛−1, 𝑥2𝑛  são 

congruentes módulo 𝑥𝑛 a respectivamente    a    −𝑥𝑛−1, −𝑥𝑛−2, … , −𝑥1, −𝑥0.  Deste modo os 

números  𝑥0, 𝑥1, … , 𝑥2𝑛  são  mutuamente  incongruentes  módulos  𝑥𝑛  o  que  prova  o  resultado. 

Note que 𝑥𝑛 ≡ 0  (mod 𝑥𝑛).    

𝒙𝒏  par : Suponha que 𝑥𝑛 é par e seja 𝑞 = 𝑥𝑛

2

sistema completo de restos módulo 𝑥𝑛 

. Neste caso, os números abaixo formam um 

−𝑞 + 1, −𝑞 + 2, … , −1,0,1, … , 𝑞 − 1, 𝑞 

Como acima 𝑥𝑛−1 ≤ 𝑞. Assim, o resultado segue como acima, exceto se  𝑥𝑛−1 = 𝑞 = 𝑥𝑛

2

,  de 

modo que pelo Lema 2.13, 𝑥𝑛+1 ≡ −𝑞 (mod 𝑥𝑛) e se 𝑖 = 𝑛 − 1 e 𝑗 = 𝑛 + 1 nosso resultado 

seria falso já que                 

  𝑥𝑛+1 ≡ −𝑞 ≡ 𝑞 ≡ 𝑥𝑛−1(mod 𝑥𝑛) ⇒    𝑥𝑛+1 ≡ 𝑥𝑛−1(mod 𝑥𝑛) 

mas   𝑛 − 1  ≠ 𝑛 + 1.  Novamente  do  Lema  2.6, 𝑥𝑛 = 𝑎𝑥𝑛−1 + 𝑑𝑦𝑛−1,    e  desse  modo  𝑥𝑛 =

2𝑥𝑛−1 implica 𝑎 = 2  e 𝑦𝑛−1 = 0  já que  𝑑 > 0 , isto é, 𝑛 = 1. Assim,o resultado pode falhar 

somente quando 𝑎 = 2  , 𝑛 = 1  , 𝑖 = 0  𝑒 𝑗 = 2.    

∎ 

Repare que  𝑥𝑖 ≡ 𝑥𝑗   (mod 𝑥𝑛)    ⟺    𝑥𝑗 ≡ 𝑥𝑖  (mod 𝑥𝑛)  Assim,o resultado pode falhar  

quando 𝑎 = 2, 𝑛 = 1, 𝑖 = 2  𝑒 𝑗 = 0.     

 
 
 
 
 
 
 
 
 
32 

Lema 2.23  Seja 𝑥𝑖 ≡ 𝑥𝑗  (mod 𝑥𝑛),    0 < 𝑖 ≤ 𝑛,    0 ≤ 𝑗 < 4𝑛, então 𝑗 = 𝑖 𝑜𝑢 𝑗 = 4𝑛 − 𝑖. 

Demonstração. 

Primeiro  suponha  que    𝑗 ≤ 2𝑛.  Então  pelo  Lema  2.22,   𝑗 = 𝑖,  exceto  se  o  caso 

excepcional  ocorrer.Como  𝑖 > 0,  então  isto  só  pode  acontecer  se    𝑗 = 0 , 𝑎 = 2 , 𝑛 = 1  e  

𝑖 = 2   que é uma contradição já que por hipótese 𝑖 ≤ 𝑛.  

Por outro lado, seja 𝑗 > 2𝑛 e considerando 𝑗′ = 4𝑛 − 𝑗, temos 0 < 𝑗′ < 2𝑛. Do Lema 

2.21,𝑥𝑗′ ≡ 𝑥𝑗     (mod  𝑥𝑛)   mas 
𝑥𝑗′ ≡ 𝑥𝑖     (mod  𝑥𝑛) . Novamente 𝑗′ = 𝑖, exceto se o caso excepcional do Lema 2.22 ocorrer, 
mas isto esta fora de questão já que , 𝑖 e 𝑗′ > 0.   

  𝑥𝑖 ≡ 𝑥𝑗  (mod  𝑥𝑛) segue 

hipótese 

por 

que                          

∎ 

Lema 2.24 Seja 0 < 𝑖 ≤ 𝑛  e  𝑥𝑖 ≡ 𝑥𝑗   (mod  𝑥𝑛) então 𝑗 ≡ ±𝑖  (mod 4𝑛). 

Demonstração. 

      Escrevendo 𝑗 = 4𝑛𝑞 + 𝑗′, 0 ≤ 𝑗′ < 4𝑛.  Note agora que  

 4𝑛𝑘 +   𝑗′ = 4𝑛 + 4𝑛(𝑘 − 1) + 𝑗′  , 1 ≤ 𝑘 ≤ 𝑞    ⟹   𝑥𝑗 ≡ 𝑥4𝑛(𝑞−1)+𝑗′ ≡ ⋯ ≡

𝑥4𝑛(1−1)+𝑗′     (mod   𝑥𝑛
𝐿2.8

)   ⟹   𝑥𝑗 ≡ 𝑥𝑗′     (mod  𝑥𝑛) ⟹ 𝑥𝑖 ≡

𝐻𝑖𝑝ó𝑡𝑒𝑠𝑒

𝑥𝑗 ≡ 𝑥𝑗′     (mod  𝑥𝑛). E 

pelo Lema 2.23, 𝑖 = 𝑗′ ou 𝑖 = 4𝑛 − 𝑗′.Se 𝑖 = 4𝑛 − 𝑗′, como 𝑗 = 4𝑛𝑞 + 𝑗′ ⟹ 𝑖 + 𝑗 ≡

4𝑛(𝑞 + 1) ≡ 0  (𝑚𝑜𝑑 4𝑛) ⟹ 𝑗 ≡ −𝑖    (mod 4𝑛).Se 𝑖 = 𝑗′, como 𝑗 = 4𝑛𝑞 + 𝑗′ ⟹ 𝑗 − 𝑖 ≡

4𝑛𝑞 ≡ 0  (𝑚𝑜𝑑 4𝑛) ⟹ 𝑗 ≡ 𝑖    (mod 4𝑛). 

∎ 

Lema 2.25  Se 𝑎 > 𝑦𝑘  então    2𝑎𝑦 − 𝑦2 − 1 > 𝑦𝑘 

Demonstração. 

Defina  𝑔: ℝ ⟶ ℝ  , 𝑔(𝑦) = 2𝑎𝑦 − 𝑦2 − 1.  Então  𝑔(1) = 2𝑎 − 2 ≥ 𝑎, pois  𝑎 ≥ 2. 

Derivando 𝑔(𝑦) temos 𝑔′(𝑦) = 2𝑎 − 2𝑦, Para 1≤ 𝑦 < 𝑎 ,  𝑔′(𝑦) = 2𝑎 − 2𝑦 > 0, ou seja, a 

função  𝑔(𝑦)  é  crescente  nesse  intervalo  e  consequentimente   𝑔(𝑦) ≥ 𝑎  no  intervalo  ,  como 

por hipótese 𝑎 > 𝑦𝑘  portanto ,  

𝑔(𝑦) > 𝑦𝑘 ⟹ 2𝑎𝑦 − 𝑦2 − 1 ≥ 𝑎 > 𝑦𝑘.    

∎ 

 
 
 
 
 
 
 
 
 
      Estes lemas serão necessarios para provarmos os dois resultados seguintes. Considere o 

seguinte sistema de equações Diofantinas. 

33 

I. 

II. 

III. 

IV. 

𝑥2 − (𝑎2 − 1)𝑦2 = 1 

𝑢2 − (𝑎2 − 1)𝑣2 = 1 

𝑠2 − (𝑏2 − 1)𝑡2 = 1 

𝑣 = 𝑟𝑦2, 

V. 

𝑏 = 1 + 4𝑝𝑦 = 𝑎 + 𝑞𝑢, 

VI. 

𝑠 = 𝑥 + 𝑐𝑢, 

VII. 

𝑡 = 𝑘 + 4(𝑑 − 1)𝑦, 

VIII. 

𝑦 = 𝑘 + 𝑒 − 1. 

Vale o seguinte resultado: 

Teorema 2.1 Dados 𝑎, 𝑥, 𝑘, (𝑎 > 1), o sistema de (I)-(VIII) tem  solução em  ℕ∗ nos 

argumentos restantes 𝑦, 𝑢, 𝑣, 𝑠, 𝑡, 𝑏, 𝑟, 𝑝, 𝑞, 𝑐, 𝑑, 𝑒  se e somente se 𝑥 = 𝑥𝑘(𝑎). 

Demonstração. 

Primeiramente consideremos dadas as soluções de (I)-(VIII).De (V), 𝑏 > 𝑎 > 1. Pelo Lema 

2.4 concluímos a partir de (I), (II) e (III) que existem 𝑖, 𝑗, 𝑛 > 0 tais que: 

𝑥 = 𝑥𝑖(𝑎),

𝑦 = 𝑦𝑖(𝑎),

𝑢 = 𝑥𝑛(𝑎),

𝑣 = 𝑦𝑛(𝑎),

𝑠 = 𝑥𝑗(𝑏),

𝑡 = 𝑦𝑗(𝑏) 

Perceba que  𝑖, 𝑗  ou  𝑛 não pode ser nulo. 

1)   𝒃 ≡ 𝒂   (mod 𝒙𝒏(𝒂))  e    𝒙𝒊(𝒂) ≡ 𝒙𝒋(𝒃)  (𝐦𝐨𝐝 𝒙𝒏(𝒂))    

As equações (V) e (VI) produzem respectivamente essas congruências. 

2)  𝒙𝒋(𝒃) ≡ 𝒙𝒋(𝒂)   (𝐦𝐨𝐝 𝒙𝒏(𝒂)). 

𝐿2.15
Como 𝑏 ≡ 𝑎   (mod 𝑥𝑛(𝑎))   ⇒

𝑥𝑗(𝑏) ≡ 𝑥𝑗(𝑎)   (mod 𝑥𝑛(𝑎)).  

3)  𝒙𝒊(𝒂) ≡ 𝒙𝒋(𝒂)   (𝐦𝐨𝐝 𝒙𝒏(𝒂)). 

Usando 1) e 2) temos  𝑥𝑖(𝑎) ≡ 𝑥𝑗(𝑏) ≡ 𝑥𝑗(𝑎)   (mod 𝑥𝑛(𝑎)) ⟹ 𝑥𝑖(𝑎) ≡

𝑥𝑗(𝑎)   (mod 𝑥𝑛(𝑎)).  

 
 
 
 
 
 
 
 
 
 
 
4)  𝒋 ≡ ±𝒊  (mod 𝟒𝒏) 

𝐿2.6
Usando (IV) temos que  𝑣 > 𝑦 ⟹   𝑦𝑛(𝑎) > 𝑦𝑖(𝑎) ⇒

𝑛 > 𝑖 > 0 .  

𝐿2.24
       𝑥𝑖(𝑎) ≡ 𝑥𝑗(𝑎)   (mod 𝑥𝑛(𝑎)) ⇒

𝑗 ≡ ±𝑖  (mod 4𝑛)  

34 

5)  𝒋 ≡ ±𝒊  (mod 𝟒𝒚𝒊(𝒂)) 
Da equação (IV) deduz-se que (𝑦𝑖(𝑎))2 ⎸𝑦𝑛(𝑎) e do Lema 2.12  𝑦𝑖(𝑎) ⎸𝑛 , daí (4) implica 

que  𝑗 ≡ ±𝑖  (mod 4𝑦𝑖(𝑎)). 

6)  𝒚𝒋(𝒃) ≡ 𝒋  (mod 𝟒𝒚𝒊(𝒂)) 

Da equação (V)   𝑏 − 1 = 4𝑝𝑦  e  do Lema 2.14   𝑦𝑗(𝑏) ≡ 𝑗  (mod 𝑏 − 1) ⟹   𝑦𝑗(𝑏) ≡

𝑗  (mod 4𝑝𝑦 )   ⟹ 𝑦𝑗(𝑏) ≡ 𝑗  (mod 4𝑦 ) ⟹ 𝑦𝑗(𝑏) ≡ 𝑗  (mod 4𝑦𝑖(𝑎)). 

7)  𝒚𝒋(𝒃) ≡ 𝒌  (mod 𝟒𝒚𝒊(𝒂)). 

Segue diretamente de (VII). 

8)   𝒌 ≡ ±𝒊  (mod 𝟒𝒚𝒊(𝒂)). 

Segue diretamente da relação de transitividade entre  5), 6) e 7) 

9)  𝒌 = 𝒊 

A equação (VIII) produz 𝑘 ≤ 𝑦𝑖(𝑎) e o Lema 2.18   𝑖 ≤ 𝑦𝑖(𝑎), ou seja, −2𝑦𝑖(𝑎) < 𝑘 ±
𝑖 ≤ 2𝑦𝑖(𝑎), mas 4𝑦𝑖(𝑎) ⎸𝑘 ± 𝑖 ,  daí 𝑘 ± 𝑖 = 0. como 𝑘 + 𝑖 > 0,  temos 𝑘 − 𝑖 = 0 ,  isto é 
, 𝑘 = 𝑖  assim 𝑥 = 𝑥𝑖(𝑎) = 𝑥𝑘(𝑎). 

      Reciprocamente, seja 𝑥 = 𝑥𝑘(𝑎) devemos mostrar que o sistema de (I)-(VIII) tem  

solução  nos argumentos restantes  𝑦, 𝑢, 𝑣, 𝑠, 𝑡, 𝑏, 𝑟, 𝑝, 𝑞, 𝑐, 𝑑, 𝑒.  

1)  Como 𝑥 = 𝑥𝑘(𝑎)  então  𝑦 = 𝑦𝑘(𝑎) satisfaz (I). 

2)  Considere 𝑚 = 2𝑘𝑦𝑘(𝑎) e seja 𝑢 = 𝑥𝑚(𝑎) e 𝑣 = 𝑦𝑚(𝑎). Então (II) é satisfeita. 

3)  Pelo Lema 2.11 , 𝑦𝑘
2 ⎸𝑦𝑚, isto é, 𝑦𝑘
𝑦𝑘

2 ⎸𝑦𝑘 .𝑦𝑘 ,  mas 𝑘. 𝑦𝑘  ⎸𝑚,  pelo Lema 2.9, 𝑦𝑘.𝑦𝑘  ⎸𝑦𝑚.  Portanto 

2 ⎸𝑣.com isto podemos escolher  𝑟 satisfazendo (IV). 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
35 

4)  Além disso, como 𝑚 é par, pelo Lema 2.16, 𝑣 é par e como 𝑢 e 𝑣 satisfazem (II) segue 

que 𝑢 é ímpar. Pelo Lema 2.7, (𝑢, 𝑣) = 1. Provemos agora que  (𝑢, 4𝑦) = 1, de fato, 

seja 𝑝 um número primo que divide 𝑢 e 4𝑦 então 𝑝 ⎸𝑦 pois 𝑢 é ímpar, e como 𝑘 ⎸𝑚 

pelo Lema 2.9.  𝑦𝑘 ⎸𝑦𝑚 , isto é ,  𝑦 ⎸𝑣 , logo 𝑝 ⎸𝑣 e como (𝑢, 𝑣) = 1 segue que 𝑝 ⎸1, 

uma contradição. 

Pelo Teorema do Resto Chinês podemos encontrar 𝑏0 tal que:  {

𝑏0 ≡ 1  (𝑚𝑜𝑑 4𝑦) 
𝑒
𝑏0 ≡ 𝑎  (𝑚𝑜𝑑  𝑢),

Como 4𝑗𝑦𝑢 ≡ 0  (mod  4𝑦)  e 4𝑗𝑦𝑢 ≡ 0  (mod  𝑢),   então  𝑏0 + 4𝑗𝑦𝑢 também  satisfaz 

as congruências, e podemos encontrar 𝑏, 𝑝, 𝑞 satisfazendo a equação (V). 

5)  A equação (III) é satisfeita, definindo, 𝑠 = 𝑥𝑘(𝑏) e  𝑡 = 𝑦𝑘(𝑏). Perceba que  𝑠 > 𝑥. 

pois, 

𝑏 > 𝑎

𝐸𝑥𝑒𝑚𝑝𝑙𝑜 2.3
⇒

𝑥𝑘(𝑏) > 𝑥𝑘(𝑎) ⇒ 𝑠 > 𝑥. 

6)  Provemos  agora  que  𝑠 ≡ 𝑥  (mod  𝑢). De  fato 

,  da  equação  (V)  temos  que                 

𝑏 ≡ 𝑎  (𝑚𝑜𝑑  𝑢),  agora usando o Lema 2.15 temos  𝑥𝑘(𝑏) ≡ 𝑥𝑘(𝑎)(𝑚𝑜𝑑  𝑢).  Assim 

𝑐 , pode ser escolhido de forma a satisfazer (VI). 

7)  Pelo  Lema  2.18, 

  𝑦𝑘(𝑏) ≥ 𝑘,  ou 

seja, 

𝑡 ≥ 𝑘 

e  pelo  Lema  2.14,                                    

𝑡 =  𝑦𝑘(𝑏) ≡ 𝑘   (mod 𝑏 − 1) e assim, usando (V) temos que 4𝑦 ⎸(𝑏 − 1)  daí ,  𝑡 ≡

𝑘  (mod 4𝑦). Podemos então escolher 𝑑 satisfazendo a equação (VII). 

8)  Ainda pelo Lema 2.18 , 𝑦 ≥ 𝑘, então (VIII) pode ser satisfeito tomando                  

𝑒 = 𝑦 − 𝑘 + 1.    

∎ 

O Teorema 2.1 implica que o conjunto 

𝑀 = {(𝑎, 𝑥, 𝑘) ⎸𝑥 = 𝑥𝑘(𝑎)} 

é Diofantino, basta utilizar o Lema 1.1 para reduzir o sistema de equações Diofantinas (I)-

(VIII) a uma só equação. 

Colorário 2.1 A função 𝑔(𝑧, 𝑘) = 𝑥𝑘(𝑧 + 1) é Diofantina. 

      Incluindo  ao  sistema  (I)-(VIII)  a  equação  𝑎 = 𝑧 + 1  (*)Pelo  teorema  2.1,  o  sistema 

(*),(I)-(VIII)  tem  solução  se,  𝑥 = 𝑥𝑘(𝑎) = 𝑔(𝑧, 𝑘).Desse  modo,  pode-se  mostrar  que  𝑔  é 

Diofantina utilizando a maneira usual de somar os quadrados dos nove polinômios.      ∎ 

 
 
 
 
 
 
 
 
36 

Agora acrescente ao sistema (I)-(VIII) as seguintes equações: 

(IX) (𝑥 − 𝑦(𝑎 − 𝑛) − 𝑚)2 = (𝑓 − 1)2(2𝑎𝑛 − 𝑛2 − 1)2, 

(X)  𝑚 + 𝑔 = 2𝑎𝑛 − 𝑛2 − 1, 

(XI) 𝑤 = 𝑛 + ℎ = 𝑘 + 𝑙, 

(XII) 𝑎2 − (𝑤2 − 1)(𝑤 − 1)2𝑧2 = 1. 

Com isto podemos provar o seguinte Lema. 

Lema 2.26  𝑚 = 𝑛𝑘   ⟺  as equações (I)-(XII) tem uma  solução em ℕ∗ nos argumentos 

restantes. 

Demonstração. 

Suponha que (I)-(XII) é satisfeito. 

1)  𝑤 > 1 e 𝑎 > 1. 

Por (XI), 𝑤 > 1. Assim (𝑤 − 1)𝑧 > 0 , e por (XII), 𝑎 > 1. 

2)  ∃𝑘 ∈ ℕ ⎸ 𝑥 = 𝑥𝑘(𝑎) e 𝑦 = 𝑦𝑘(𝑎) 

Basta aplicar o Teorema 2.1. 

3)  𝑥𝑘 − 𝑦𝑘(𝑎 − 𝑛) ≡ 𝑚   (mod 2𝑎𝑛 − 𝑛2 − 1)   e                                                         

𝑥𝑘 − 𝑦𝑘(𝑎 − 𝑛) ≡ 𝑛𝑘   (mod 2𝑎𝑛 − 𝑛2 − 1) 

Basta extrair as raízes quadradas em (IX) e usar o Lema 2.17 respectivamente. 

4)  𝑚 ≡ 𝑛𝑘(mod 2𝑎𝑛 − 𝑛2 − 1)    e    𝑛, 𝑘 < 𝑤. 

Aplicando  transitividade em   3)  e usando a  equação (XI) respectivamente. 

5)  ∃𝑗 ∈ ℕ ⎸ 𝑎 = 𝑥𝑗(𝑤) , (𝑤 − 1)𝑧 = 𝑦𝑗(𝑤)   e     𝑦𝑗(𝑤) ≡ 𝑗  (mod 𝑤 − 1) 

Segue diretamente do Lema 2.4 aplicado em XII e do Lema 2.14 respectivamente 

6)  𝑗 ≡ 0  (mod 𝑤 − 1) 

De  5)  temos  (𝑤 − 1)𝑧 = 𝑦𝑗(𝑤)  ou  seja  𝑦𝑗(𝑤) ≡ 0  (mod  𝑤 − 1).  Mas  𝑦𝑗(𝑤) ≡

𝑗  (mod 𝑤 − 1) ,Logo por transitividade   𝑗 ≡ 𝑦𝑗(𝑤) ≡ 0  (mod 𝑤 − 1).    

7)  𝑤 − 1 ≤ 𝑗    e    𝑎 ≥ 𝑤𝑗 

De 6) 𝑤 − 1 ⎸𝑗  e 𝑗 ≠ 0 , segue que 𝑤 − 1 ≤ 𝑗. Para segunda afirmação basta usar o 

Lema 2.19 lembrando que 𝑥𝑗(𝑤) = 𝑎. 

8)  𝑎 > 𝑛𝑘   

Lembrando  que  𝑛, 𝑘 < 𝑤  , 

 𝑎 ≥ 𝑤𝑗 

  e 

  𝑤 − 1 ≤ 𝑗 .   Obtemos  que                             

𝑎 ≥ 𝑤𝑗 ≥ 𝑤𝑤−1 > 𝑛𝑤−1 ≥ 𝑛𝑘 

 
 
 
 
 
 
 
37 

9)  𝑚 < 2𝑎𝑛 − 𝑛2 − 1    e    𝑛𝑘 < 2𝑎𝑛 − 𝑛2 − 1. 

Basta usar a equação (X) e aplicar o Lema 2.25 em 8)  respectivamente. 

10) 𝑚 = 𝑛𝑘 

Segue diretamente da combinação entre  4)  e  9).  

      Reciprocamente, suponha que 𝑚 = 𝑛𝑘. Devemos encontrar soluções para o sistema (I)-

(XII). 

1)  Escolha algum 𝑤 tal que 𝑤 > 𝑘, 𝑛 .Seja 𝑎 = 𝑥𝑤−1(𝑤) tal que 𝑎 > 1. Pelo Lema 2.14, 

𝑦𝑤−1(𝑤) ≡ 𝑤 − 1 ≡ 0  (mod 𝑤 − 1) 

Assim , ∃𝑧 ∈ ℕ∗ tal que  

Tomando  

𝑦𝑤−1(𝑤) = 𝑧(𝑤 − 1). 

𝑥𝑤−1(𝑤) = 𝑎
𝑒
{
   𝑦𝑤−1(𝑤) = 𝑧(𝑤 − 1)

Temos que (XII) é satisfeita. 

2)  Definindo ℎ = 𝑤 − 𝑛 e 𝑙 = 𝑤 − 𝑘 , temos que a equação (XI) é satisfeita. 

3)  Provemos agora que 𝑎 > 𝑛𝑘,  como 𝑤 > 𝑘, 𝑛  e  𝑥𝑤−1(𝑤) = 𝑎 . Daí                    

𝐿2.19
𝑎 ≥

𝑤𝑤−1 > 𝑛𝑤−1 ≥ 𝑛𝑘  

e novamente pelo Lema 2.25,  𝑚 = 𝑛𝑘 < 2𝑎𝑛 − 𝑛2 − 1.  

Daí , ∃𝑔 ∈ ℕ∗ tal que 

𝑚 + 𝑔 = 2𝑎𝑛 − 𝑛2 − 1. 

Assim, (X) é satisfeita. 

4)  Definindo 𝑥 = 𝑥𝑘(𝑎) e 𝑦 = 𝑦𝑘(𝑎). O Lema 2.17 nos permite definir 𝑓 ∈ ℕ∗ tal que: 

𝑥 − 𝑦(𝑎 − 𝑛) − 𝑚 = ±(𝑓 − 1)(2𝑎𝑛 − 𝑛2 − 1) 

De forma que (IX) é satisfeita. 

5)  Finalmente, o sistema (I)-(VIII) pode ser satisfeito pelo Teorema 2.1. 

∎ 

      Pelo  Lema  2.26, temos  que  o  conjunto    𝑁 = {(𝑚, 𝑛, 𝑘) ∈ (ℕ∗)3 ⎸𝑚 = 𝑛𝑘}.é  Diofantino. 

Basta utilizar o Lema 1.1 para reduzir o sistema  de equações Diofantinas (I)-(XII) a uma só 

equação. E esta conclusão implica diretamente no resultado mais importante desta seção que 

enunciamos no próximo teorema. 

Teorema 2.2 A função exponencial  ℎ ∶   (ℕ∗)2 ⟶ ℕ∗ , ℎ(𝑛, 𝑘) = 𝑛𝑘 é Diofantina 

 
 
 
 
 
38 

3.2  A linguagem dos predicados diofantinos 

      Agora que provamos que a função exponecial é Diofantina, podemos mostrar que muitas 

outras funções e conjuntos também são.  

Exemplo 2.4. A função ℎ ∶   (ℕ∗)3 ⟶ ℕ∗ , ℎ(𝑢, 𝑣, 𝑤) = 𝑢𝑣𝑤

 é diofantina. 

De fato, 𝑦 = 𝑢𝑣𝑤

  ⟺ (∃ 𝑧 ∈ ℕ∗)(𝑦 = 𝑢𝑧   ∧  𝑧 = 𝑣𝑤), 

Onde “∧” é o simbolo lógico para "e". Usando o Teorema 2.2, existe um polinômio 𝑃 tal que: 

𝑦 = 𝑢𝑧   ⟺ (∃ 𝑟1, … , 𝑟𝑛 ∈ ℕ∗)[𝑃(𝑦, 𝑢, 𝑧, 𝑟1, … , 𝑟𝑛) = 0], 

𝑧 = 𝑣𝑤   ⟺ (∃ 𝑠1, … , 𝑠𝑛 ∈ ℕ∗)[𝑃(𝑧, 𝑣, 𝑤, 𝑠1, … , 𝑠𝑛) = 0]. 

Então,  𝑦 = 𝑢𝑣𝑤

  ⟺ (∃ 𝑟1, … , 𝑟𝑛, 𝑠1, … , 𝑠𝑛)[𝑃2(𝑦, 𝑢, 𝑧, 𝑟1, … , 𝑟𝑛) + 𝑃2(𝑧, 𝑣, 𝑤, 𝑠1, … , 𝑠𝑛) = 0]. 

∎ 

      Este procedimento é perfeitamente generalizável e isso já sabemos das proposições 1.1 e 

1.2 vistas no capítulo 1. Expressões que já são conhecidas por gerar conjuntos Diofantinos 

podem ser combinadas livremente utilizando os operadores lógicos “∧” e “∨”, a expressão 

resultante será novamente um conjunto Diofantino. Estas expressões são chamadas de 

predicados Diofantinos. 

Nesta linguagem é permitido o uso dos símbolos lógicos “∨” para “𝑜𝑢”, assim 

(∃ 𝑟1, … , 𝑟𝑛 ∈ ℕ∗)[𝑃1 = 0]    ∨   (∃ 𝑠1, … , 𝑠𝑚 ∈ ℕ∗)[𝑃2 = 0]
⟺ (∃ 𝑟1, … , 𝑟𝑛, 𝑠1, … , 𝑠𝑚 ∈ ℕ∗)[𝑃1. 𝑃2 = 0]. 

(∃ 𝑟1, … , 𝑟𝑛 ∈ ℕ∗)[𝑃1 = 0]  ∧   (∃ 𝑠1, … , 𝑠𝑚 ∈ ℕ∗)[𝑃2 = 0]
1 + 𝑃2

⟺ (∃ 𝑟1, … , 𝑟𝑛, 𝑠1, … , 𝑠𝑚 ∈ ℕ∗)[𝑃2

2 = 0]. 

Três importantes funções Diofantinas são dadas pelo : 

Teorema 2.3 As seguintes funções são Diofantinas: 

𝑓(𝑛, 𝑘) = (

𝑛
𝑘
𝑔(𝑛) = 𝑛!

) 

𝑦

ℎ(𝑎, 𝑏, 𝑦) = ∏(𝑎 + 𝑏𝑘)

{

𝑘=1

Na prova deste teorema a notação  [𝛼] , onde 𝛼 é um número real, será usada para denotar o 

único inteiro tal que: 

[𝛼] ≤ 𝛼 < [𝛼] + 1. 

 
 
 
 
 
 
 
 
 
 
 
 Lema 2.27  Para  0 < 𝑘 ≤ 𝑛,    𝑢 > 2𝑛   temos que  

(𝑢 + 1)𝑛
[
𝑢𝑘

𝑛

𝑛
𝑖

] = ∑ (
𝑖=𝑘

) 𝑢𝑖−𝑘

. 

Demonstração. 

(𝑢 + 1)𝑛 = ∑ (

𝑛
𝑖=0

𝑛
𝑖

) 𝑢𝑖

 ⟹

(𝑢+1)𝑛

𝑢𝑘 = ∑ (

𝑛
𝑖=0

𝑛
𝑖

) 𝑢𝑖−𝑘 = 𝑆 + 𝑅

,  Onde 𝑆 = ∑ (

𝑛
𝑖=𝑘

𝑛
𝑖

39 

) 𝑢𝑖−𝑘

  e  

𝑅 = ∑

𝑘−1
𝑖=0

𝑛
(
𝑖

) 𝑢𝑖−𝑘

.  Como 𝑢𝑖−𝑘 ∈ ℕ∗  para  𝑘 ≤ 𝑖 ≤ 𝑛 então  𝑆  é um inteiro e para 

           0 ≤ 𝑖 ≤ 𝑘 − 1 , −𝑘 ≤ 𝑖 − 𝑘 ≤ −1 ,   logo 𝑢𝑖−𝑘 ≤ 𝑢−1 assim , 

𝑘−1

𝑅 ≤ 𝑢−1 ∑ (

𝑖=0

𝑛
𝑖

) < 𝑢−1

𝑛

∑ (
𝑖=0

𝑛
𝑖

) = 𝑢−1

. (1 + 1)𝑛 =

2𝑛
𝑢

< 1. 

Assim,  𝑆 ≤

(𝑢+1)𝑛

𝑢𝑘 < 𝑆 + 1, O que prova o resultado. 

∎ 

Lema 2.28 Para 0 < 𝑘 ≤ 𝑛,     𝑢 > 2𝑛   temos que. 

[(𝑢+1)𝑛
𝑢𝑘

] ≡ (

𝑛
𝑘

)   (mod 𝑢). 

Demonstração. 
Pelo Lema 2.27 , temos que  [(𝑢+1)𝑛

𝑢𝑘

(

𝑛
𝑛

𝑛
) 𝑢𝑛−𝑘 ≡ (
𝑘

) (mod 𝑢). ∎ 

𝑛
] = ∑ (
𝑖=𝑘

𝑛
𝑖

) 𝑢𝑖−𝑘 = (

𝑛
𝑘

) 𝑢0 + (

𝑛
𝑘 + 1

) 𝑢1 + ⋯ +

Lema 2.29  𝑓 ∶   (ℕ∗)2 ⟶ ℕ∗, 𝑓(𝑛, 𝑘) = (

𝑛
𝑘

)  é  Diofantina. 

Demonstração. 

Como  

0 < (

𝑛
𝑘

𝑛

) ≤ ∑ (

𝑖=0

𝑛
𝑖

) = 2𝑛

< 𝑢, 

Do Lema 2.28  [(𝑢+1)𝑛

𝑢𝑘
único inteiro positivo congruente a [(𝑢+1)𝑛

𝑛
𝑘

𝑢𝑘

] ≡ (

)   (mod 𝑢) e sabemos que 0 < (

𝑛
𝑘

) < 𝑢 . Portanto (

𝑛
𝑘

) é o 

]   (mod 𝑢) e menor que 𝑢. Desse modo, 

𝑧 = (

𝑛
𝑘

) ⟺ (∃ 𝑢, 𝑣, 𝑤 ∈ ℕ∗)(𝑣 = 2𝑛   ∧  𝑢 > 𝑣  ∧  𝑤 = [(𝑢+1)𝑛

𝑢𝑘

]  ∧  𝑧 ≡ 𝑤  (mod 𝑢) 

 ∧  𝑧 < 𝑢). 

Para ver que (

𝑛
𝑘

) é Diofantina, é suficiente notar que cada expressão acima separada por “∧” é 

um predicado Diofantino. 

 
 
 
1)   𝑣 = 2𝑛 é claramente Diofantino pelo Teorema 2.2. 

2)  A inequação 𝑢 > 𝑣  é claramente Diofantina pelo exemplo 1.4. 

3)  A congruência  𝑧 ≡ 𝑤   (𝑚𝑜𝑑 𝑢) é Diofantina pelo exemplo 1.8. 
4)  𝑤 = [(𝑢+1)𝑛

] ⟺ (∃ 𝑥, 𝑦, 𝑡) (𝑡 = 𝑢 + 1  ∧  𝑥 = 𝑡𝑛   ∧   𝑦 = 𝑢𝑘   ∧  𝑤 ≤ 𝑥
𝑦

𝑢𝑘

40 

< 𝑤 + 1), 

E 

∎ 

𝑤 ≤

𝑥
𝑦

< 𝑤 + 1 ⟺ 𝑤𝑦 ≤ 𝑥 < (𝑤 + 1)𝑦. 

Lema 2.30  Se 𝑟 > (2𝑥)𝑥+1, então 𝑥! = [ 𝑟𝑥
(𝑟
𝑥)

]. 

Demonstração. 

Para 𝑥 = 0  ,  o  resultado é imediato pois 1! = [ 𝑟0
𝑟
0)

(

] , consideremos agora  𝑥 > 0  então, é 

verdade que  

𝒓𝒙
(𝒓
𝒙)

< 𝑥!

𝟏
𝒙
𝒓

(𝟏−

𝒙   pois , 
)

𝑟𝑥
𝑟
𝑥

(

)

= 𝑟𝑥.

𝑥! (𝑟 − 𝑥)!
𝑟!

= 𝑟𝑥.

𝑥!. (𝑟 − 𝑥)!
𝑟. (𝑟 − 1) … (𝑟 − 𝑥 + 1)(𝑟 − 𝑥)!

=

𝑟𝑥. 𝑥!
𝑟. (𝑟 − 1) … (𝑟 − 𝑥 + 1)

= 𝑥! (

(1 − 0
𝑟

1
) (1 − 1
𝑟

) … (1 −

) < 𝑥!

(𝑥−1)

𝑟

)

1
(1 − 𝑥
𝑟

)

𝑥 

𝟏
𝟏 − 𝒙
𝒓

< 1 +

𝟐𝒙
𝒓

Por hipótese , 𝑟 > (2𝑥)𝑥+1 ⟹   𝑥
𝑟

< 1

2.(2𝑥)𝑥 < 1

2

.  Logo ,  

= 1 + 𝑥
𝑟

+ (𝑥
𝑟

)

2

+ ⋯ = 1 + 𝑥
𝑟

(1 + 𝑥
𝑟

+ (𝑥
𝑟

)

2

+ ⋯ ) < 1 + 𝑥
𝑟

(1 + 1
2

+ (1
)
2

2

+ ⋯ ) = 1 +

1

1− 

𝑥
𝑟

2𝑥

𝑟

.  

(𝟏 +

(1 +

𝒙

𝟐𝒙
𝒓

)

𝑥

2𝑥
𝑟

)

< 1 +

𝟐𝒙
𝒓

. 𝟐𝒙  

𝑥

= ∑ (
𝑗=0

𝑥
𝑗 ) (

2𝑥
𝑟

𝑗

)

< 1 +

2𝑥
𝑟

𝑥

∑ (
𝑗=1

𝑥
𝑗 ) < 1 +

2𝑥
𝑟

. 2𝑥. 

 
 
 
 
 
 
<  𝑥! +

(𝟐𝒙)𝒙+𝟏
𝒓

< 𝑥!

1
(1 − 𝑥
𝑟

)

𝑥 < 𝑥! (1 +

𝑥

)

< 𝑥! (1 +

2𝑥
𝑟

2𝑥
𝑟

. 2𝑥) = 𝑥! +

2𝑥+1𝑥
𝑟

. 𝑥! ≤ 𝑥! +

(2𝑥)𝑥+1
𝑟

. 

41 

𝒓𝒙
𝒓
𝒙

(

)

𝑟𝑥
𝑟
𝑥

(

)

Pois  𝑥 . 𝑥!   ≤ 𝑥 𝑥+1. 

< 𝑥! + 1 

𝒓𝒙
𝒓
𝒙

(

)

 Por hipótese    

(2𝑥)𝑥+1
𝑟

< 1 ,  Portanto    𝑟𝑥
(𝑟
𝑥)

≤ 𝑥! +

(2𝑥)𝑥+1
𝑟

< 𝑥! + 1.  

𝒙! ≤

𝒓𝒙
𝒓
𝒙

(

)

Como 

𝑟𝑥
𝑟.(𝑟−1)…(𝑟−𝑥+1)

≥ 1,  teremos  

𝑟𝑥.𝑥!
𝑟.(𝑟−1)…(𝑟−𝑥+1)

≥ 𝑥! ⇒ 𝑟𝑥
(𝑟
𝑥)

≥ 𝑥! , segue que 

𝑥! ≤

𝑟𝑥
𝑟
(
𝑥

)

< 𝑥! + 1. 

O que conclui a prova do lema. 

∎ 

Lema 2.31  𝑔 ∶   ℕ∗ ⟶ ℕ∗, 𝑔(𝑛) = 𝑛!   é  uma função Diofantina. 

Demonstração. 

Basta mostrar que  

𝑚 = 𝑛! ⟺   {

∃ 𝑟, 𝑠, 𝑡, 𝑢, 𝑣 ∈ ℕ∗ ⎸𝑠 = 2𝑛 + 1  ∧  𝑡 = 𝑛 + 1
∧   𝑟 = 𝑠𝑡  ∧   𝑢 = 𝑟𝑛   ∧

∧  𝑣 = (

)  ∧  𝑚𝑣 ≤ 𝑢 < (𝑚 + 1)𝑣.

𝑟
𝑛

De fato, suponha que 𝑚 = 𝑛! .  

 Defina  𝑠 = 2𝑛 + 1 , 𝑡 = 𝑛 + 1 , 𝑟 = 𝑠𝑡 , 𝑢 = 𝑟𝑛  e  𝑣 = (

𝑟
𝑛

) . Como 𝑚, 𝑛 > 0,temos que 

𝑠, 𝑡, 𝑟, 𝑢, 𝑣 > 0. Observe que 

e  pelo Lema 2.30 , 

𝑟 = 𝑠𝑡 = (2𝑛 + 1)𝑛+1 > (2𝑛)𝑛+1, 

 
 
 
 
 
 
 
 
 
 
 
42 

ou seja, 

logo, 

𝑚 = 𝑛! = [𝑟𝑛/ (

𝑟
𝑛

)] , 

𝑚 ≤

𝑢
𝑣

< 𝑚 + 1 , 

𝑚𝑣 ≤ 𝑢 < (𝑚 + 1)𝑣. 

Reciprocamente, suponha que ∃ 𝑟, 𝑠, 𝑡, 𝑢, 𝑣 ∈ ℕ∗ tais que , 𝑠 = 2𝑛 + 1 e 𝑡 = 𝑛 + 1 e 𝑟 = 𝑠𝑡 e 

𝑢 = 𝑟𝑛 e  𝑣 = (

𝑟
𝑛

) e 𝑚𝑣 ≤ 𝑢 < (𝑚 + 1)𝑣.  

Como 𝑚𝑣 ≤ 𝑢 < (𝑚 + 1)𝑣  ⟹   [𝑢
𝑣

] = 𝑚  ⟹   [𝑟𝑛/ (

𝑟
𝑛

)] = 𝑚 ,  Note que  𝑟 = 𝑠𝑡 =

(2𝑛 + 1)𝑛+1 > (2𝑛)𝑛+1, daí  novamente pelo Lema 2.30 , 

𝑛! = [𝑟𝑛/ (

𝑟
𝑛

)] ⟹  𝑚 = 𝑛! 

∎ 

Lema 2.32 Seja 𝑏𝑞 ≡ 𝑎  (mod 𝑚). Então,   

𝑦

∏(𝑎 + 𝑏𝑘)
𝑘=1

≡ 𝑏𝑦 ⋅ 𝑦! (

𝑞 + 𝑦
𝑦

) (𝑚𝑜𝑑 𝑚) 

Demonstração. 

𝑏𝑦 ⋅ 𝑦! (

𝑞 + 𝑦
𝑦

) =

𝑏𝑦 ⋅ 𝑦! ⋅ (𝑞 + 𝑦)!
𝑦! ⋅ 𝑞!

=

𝑏𝑦 ⋅ (𝑞 + 𝑦)!
𝑞!

=

𝑏𝑦 ⋅ (𝑞 + 𝑦) ⋅ (𝑞 + 𝑦 − 1) ⋅⋅⋅ (𝑞 + 1) ⋅ 𝑞!
𝑞!

= 𝑏𝑦 ⋅ (𝑞 + 𝑦) ⋅ (𝑞 + 𝑦 − 1) ⋅⋅⋅ (𝑞 + 1)

= (𝑏𝑞 + 𝑦𝑏) ⋅ (𝑏𝑞 + (𝑦 − 1)𝑏) ⋅⋅⋅ (𝑏𝑞 + 𝑏). 

Mas por hipótese  𝑏𝑞 ≡ 𝑎  (𝑚𝑜𝑑 𝑚) , segue que: 

(𝑏𝑞 + 𝑦𝑏) ⋅ (𝑏𝑞 + (𝑦 − 1)𝑏) ⋅⋅⋅ (𝑏𝑞 + 𝑏) ≡ (𝑎 + 𝑦𝑏) ⋅ (𝑎 + (𝑦 − 1)𝑏) ⋅⋅⋅ (𝑎 + 𝑏)

𝑦

≡ ∏(𝑎 + 𝑏𝑘)

   (𝑚𝑜𝑑 𝑚). 

𝑘=1

E isto prova o resultado. 

∎ 

 
 
 
 
 
 
 
 
Lema 2.33 ℎ(𝑎, 𝑏, 𝑦) = ∏ (𝑎 + 𝑏𝑘)

𝑦
𝑘=1

 é uma função Diofantina. 

43 

Demonstração. 

      No  Lema  2.32,  faça  𝑚 = 𝑏(𝑎 + 𝑏𝑦)𝑦 + 1.  Então  (𝑚, 𝑏) = 1  e 𝑚 >  ∏ (𝑎 + 𝑏𝑘) > 0

𝑦
𝑘=1

. 

Logo,  a  congruência  𝑏𝑋 ≡ 𝑎 (𝑚𝑜𝑑 𝑚)  possui  uma  única  solução  𝑋 = 𝑞 tal  que  0 ≤ 𝑞 < 𝑚 

daí  𝑏𝑞 ≡ 𝑎 (𝑚𝑜𝑑 𝑚).Do  Lema  2.32  ∏ (𝑎 + 𝑏𝑘)

  é  o  único  número  menor  que  𝑚  que  é 

𝑦
𝑘=1

congruente módulo 𝑚 a 𝑏𝑦𝑦! (

𝑞 + 𝑦
𝑦

) , isto é, 

𝑦

𝑧 = ∏(𝑎 + 𝑏𝑘) ⟺ (∃𝑚, 𝑝, 𝑞, 𝑟, 𝑠, 𝑡, 𝑢, 𝑣, 𝑤, 𝑥 ∈ ℕ∗)

𝑘=1

{𝑟 = 𝑎 + 𝑏𝑦    ∧   𝑠 = 𝑟y   ∧   𝑚 = 𝑏𝑠 + 1   ∧  𝑏𝑞 = 𝑎 + 𝑚𝑡    ∧   𝑢 = 𝑏𝑦   ∧  𝑣 = 𝑦!    ∧  𝑧

< 𝑚  

 ∧    𝑤 = 𝑞 + 𝑦   ∧  𝑥 = (

𝑤
𝑦 )     ∧   𝑧 + 𝑚𝑝 = 𝑢𝑣𝑥} 

      Como  a  função  exponencial,  combinatorial  e  fatorial  são  diofantinas  segue  que  ℎ  é  uma 

função diofantina.A afirmação do Teorema 2.3 está provada pelos Lemas  2.29,  2.31  e  2.33. 

∎ 

3.3  Novos conjuntos diofantinos 

      Com este lema 2.33 , combinado com os próximos Lemas 2.34 e 2.35 poderemos mostrar 

que é diofantino o seguinte conjunto: 

𝑆 = {(𝑦, 𝑥1, … , 𝑥𝑛) ∈ (ℕ∗)𝑛+1: ∀𝑧 ∈ ℕ∗ com 𝑧 ≤ 𝑦 , ∃ 𝑦1 …,𝑦𝑚   ∈
ℕ∗  ⎸𝑃(𝑦, 𝑧, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0}. 

       Onde 𝑃 é um polinômio qualquer. Este conjunto 𝑆 ser diofantino será fundamental para 

provar o Teorema da Universalidade e o Teorema que caracteriza as funções diofantinas. 

Lema 2.34 

∀𝑘 ∈ ℕ∗com 𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈ ℕ∗ ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0  

⇕ 
∃𝑢 ∈ ℕ∗ ⎸∀𝑘 ∈ ℕ∗com  𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈ ℕ∗ com 𝑦𝑖 ≤ 𝑢, 𝑖 =
1, … , 𝑚   ⎸ 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0  

 
 
 
  
 
 
 
 
 
 
Demonstração. 

44 

Por hipótese, para cada 𝑘 ∈ {1,2, … , 𝑦}, ∃𝑦1
(𝑘), … , 𝑦𝑚

𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘)) = 0. 

(𝑘), … , 𝑦𝑚

(𝑘) ∈ ℕ∗ para os quais  

Tomando 𝑢 como sendo o máximo destes números , isto é. 

𝑢 = max{ 𝑦𝑖

(𝑘)⎸ 1 ≤ 𝑖 ≤ 𝑚  ; 1 ≤ 𝑘 ≤ 𝑦}. 

Segue que, 

∃𝑢 ∈ ℕ∗ ⎸∀𝑘 ∈ ℕ∗com  𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈ ℕ∗ com 𝑦𝑖 ≤ 𝑢, 𝑖 =
1, … , 𝑚   ⎸ 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0  

A recíproca é trivial. 

∎ 

Lema 2.35 Seja 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) um polinômio com as propriedades: 

(1) 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) > 𝑢, 

(2) 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) > 𝑦, 

(3) 𝑘 ≤ 𝑦 𝑒 𝑦1, … , 𝑦𝑚 ≤ 𝑢   ⟹   ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚 ) ⎸ ≤ 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛). 

Então, 

 ∀𝑘 ∈ ℕ∗com 𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈ ℕ∗ ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0  

⇕ 

∃ 𝑐, 𝑡, 𝑎1, … , 𝑎𝑚 ∈ ℕ∗ ⎸ 1 + 𝑐𝑡 = ∏ (1 + 𝑘𝑡)
𝑡 = 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛)!

𝑦
𝑘=1

(∗)

𝑢
1 + 𝑐𝑡  ⎸ ∏(𝑎𝑖 − 𝑗)
𝑗=1

,

1 ≤ 𝑖 ≤ 𝑚 

{

 𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡ 0  (𝑚𝑜𝑑 1 + 𝑐𝑡).

Demonstração. 

Provemos  que  ∀𝑘 ∈ ℕ∗com  𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈ ℕ∗ ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0 
,supondo a validade de (1), (2), (3) e  (*).  Para cada  𝑘 = 1,2, … , 𝑦,  seja 𝑝𝑘 um fator primo 
(𝑘)  (𝑚𝑜𝑑 𝑝𝑘)   onde  

(𝑘) o resto da divisão de 𝑎𝑖 por 𝑝𝑘 , ou seja, 𝑎𝑖 ≡ 𝑦𝑖

de 1 + 𝑘𝑡 . Seja 𝑦𝑖
(1 ≤ 𝑘 ≤ 𝑦  ;  1 ≤ 𝑖 ≤ 𝑚). Disto segue que para cada 𝑘, 𝑖: 

𝒂)    1 ≤ 𝑦𝑖

(𝑘) ≤ 𝑢,

{

  𝒃)    𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) = 0

 
 
 
 
  
 
  
 
 
 
 
 
 
Demonstração de (a)  

      Note 

que 

por 

definição 

𝑢
1 + 𝑐𝑡   ⎸ ∏ (𝑎𝑖 − 𝑗)
𝑗=1

,  por  transitividade,  𝑝𝑘 ⎸ ∏ (𝑎𝑖 − 𝑗)

.  Assim,  como    𝑝𝑘  é  primo,       

𝑝𝑘 ⎸1 + 𝑘𝑡, 
𝑢
𝑗=1

45 

por 

hipótese (∗)   1 + 𝑘𝑡 ⎸1 + 𝑐𝑡  e                                      

𝑝𝑘  ⎸𝑎𝑖 − 𝑗  para  algum  𝑗 ∈ {1,2, … , 𝑢}, ou  seja,  𝑗 ≡ 𝑎𝑖  (𝑚𝑜𝑑 𝑝𝑘).Daí  também  por 

transitividade , 𝑗 ≡ 𝑦𝑖

(𝑘)  (𝑚𝑜𝑑 𝑝𝑘). 

      Uma vez que 𝑡 = 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛)! isso implica que 𝑝𝑘 > 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) , suponha o 

contrário  então  isso  implicaria  que  𝑝𝑘 ≤ 𝑄(𝑦, 𝑢,  𝑥1, … , 𝑥𝑛) ⟹   𝑝𝑘 ⎸𝑡  ,  mas  por  definição  

𝑝𝑘 ⎸1 + 𝑘𝑡 , portanto 𝑝𝑘 ⎸1 , absurdo. Daí todo divisor primo de  1 + 𝑘𝑡 deve ser  maior que 

𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛).  

       De (1), 𝑝𝑘 > 𝑢. Portanto, 𝑗 ≤ 𝑢 < 𝑝𝑘. Uma vez que 𝑦𝑖
(𝑘) < 𝑝𝑘. Assim. 𝑦𝑖

temos também que 𝑦𝑖

(𝑘), 𝑗 são ambos menores que 𝑝𝑘 ,positivos e 

(𝑘) é o resto da divisão de 𝑎𝑖 por 𝑝𝑘 

congruentes a 𝑝𝑘 então  𝑦𝑖

(𝑘) = 𝑗  e como 1 ≤ 𝑗 ≤ 𝑢 segue que 1 ≤ 𝑦𝑖

(𝑘) ≤ 𝑢. 

Demonstração de (b)  

      Primeiro provemos que 𝑘 ≡ 𝑐 (𝑚𝑜𝑑 𝑝𝑘) para isso lembre que 𝑝𝑘 ⎸1 + 𝑘𝑡  e  𝑝𝑘 ⎸1 + 𝑐𝑡  , 
então𝑝𝑘 ⎸𝑘(1 + 𝑐𝑡) −  𝑐(1 + 𝑘𝑡) ⟹  𝑝𝑘 ⎸𝑘 − 𝑐   ⟹  𝑘 ≡ 𝑐 (𝑚𝑜𝑑 𝑝𝑘).Por definição já 

sabemos que  𝑎𝑖 ≡ 𝑦𝑖

(𝑘)  (𝑚𝑜𝑑 𝑝𝑘) , 1 ≤ 𝑖 ≤ 𝑚. 

E por hipótese (*), 

    𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) ≡  𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡ 0  (𝑚𝑜𝑑 1 + 𝑐𝑡). 

Como, 𝑝𝑘 ⎸(1 + 𝑐𝑡) temos , 

𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) ≡  𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡ 0  (𝑚𝑜𝑑 𝑝𝑘). 

Assim, 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) é múltiplo de 𝑝𝑘 e , por (3) , temos que  

⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘))  ⎸ ≤ 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) < 𝑝𝑘. 

Portanto, 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) = 0. Isto prova (b) e completa a primeira parte da 

demonstração.  

 
 
 
 
 
 
 
 
 
 
      Reciprocamente, supondo válida que  ∀𝑘 ∈ ℕ∗com 𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈
ℕ∗ ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0 e também a validade de (1),(2) e (3) . Verifiquemos a 
validade de (*). 

46 

I) 

Supondo  que, 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) = 0, para cada 1 ≤ 𝑘 ≤ 𝑦, onde 

cada 𝑦𝑗

(𝑘) ≤ 𝑢. Nós fixamos 𝒕 ∶= 𝑸(𝒚, 𝒖, 𝒙𝟏, … , 𝒙𝒏)!. 

II) 

𝑦
Note que ∏ (1 + 𝑘𝑡)
𝑘=1

≡ 1  (𝑚𝑜𝑑 𝑡), então existe 𝑐 ∈ ℕ∗  tal que  𝟏 + 𝒄𝒕 =

∏ (𝟏 + 𝒌𝒕).

𝒚
𝒌=𝟏

III)  Agora, para 1 ≤ 𝑘 < 𝑙 ≤ 𝑦, devemos ter  (1 + 𝑘𝑡, 1 + 𝑙𝑡) = 1 . De fato suponha 

que exista um primo 𝑝 tal que 𝑝 ⎸1 + 𝑘𝑡  e  𝑝 ⎸1 + 𝑙𝑡, então 𝑝 ⎸(𝑙 − 𝑘)𝑡  daí como 

𝑝 é primo temos dois casos: 

      Se 𝑝 ⎸(𝑙 − 𝑘) teríamos que 𝑝 ≤ 𝑙 − 𝑘 < 𝑦  e por (2) temos 𝑝 < 𝑦 < 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) ⟹

𝑝 ⎸𝑄(𝑦, 𝑢,  𝑥1, … , 𝑥𝑛)  ! ⟹  𝑝 ⎸𝑡 ⟹  𝑝 ⎸1  ,contradição.    Se  𝑝 ⎸𝑡 ⟹  𝑝 ⎸1 temos  um  absurdo. 
Portanto,  (1 + 𝑘𝑡, 1 + 𝑙𝑡) = 1. Desse  modo  os  números  1 + 𝑘𝑡,  com  1 ≤ 𝑘 ≤ 𝑦  são  primos 

entre si, e o Teorema Chinês do Resto pode ser aplicado para produzir, para cada 𝑖,  1 ≤ 𝑖 ≤

𝑚, um número 𝑎𝑖  tal que 

𝑎𝑖 ≡ 𝑦𝑖

(𝑘)    (𝑚𝑜𝑑 1 + 𝑘𝑡),

1 ≤ 𝑘 ≤ 𝑦 

      Provemos agora que  𝑘 ≡ 𝑐  (𝑚𝑜𝑑 1 + 𝑘𝑡).  Como 1 + 𝑘𝑡 ⎸1 + 𝑐𝑡 , temos que                               

1 + 𝑘𝑡  ⎸𝑘(1 + 𝑐𝑡) −  𝑐(1 + 𝑘𝑡) ,ou seja , 1 + 𝑘𝑡 ⎸𝑘 − 𝑐. Assim, para cada 1 ≤ 𝑘 ≤ 𝑦  , 

temos que 𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡  𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘))   (𝑚𝑜𝑑 1 + 𝑘𝑡) 

.Como por hipótese 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1

(𝑘), … , 𝑦𝑚

(𝑘)) = 0 , temos que 

𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡  0  (𝑚𝑜𝑑 1 + 𝑘𝑡) 

Uma vez que os números 1 + 𝑘𝑡 são primos entre si e cada um divide 

𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚), fazendo seu produto,obtemos: 

𝑷(𝒚, 𝒄, 𝒙𝟏, … , 𝒙𝒏, 𝒂𝟏, … , 𝒂𝒎) ≡ 𝟎  (𝒎𝒐𝒅 𝟏 + 𝒄𝒕). 

Pois, 

 
 
 
 
 
 
 
 
 
 
𝑦

1 + 𝑐𝑡 = ∏(1 + 𝑘𝑡)
𝑘=1

 ⎸ 𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) 

47 

IV) 

Lembrando que , 

Isto é, 

e como 1 ≤ 𝑦𝑖

(𝑘) ≤ 𝑢, 

𝑎𝑖 ≡ 𝑦𝑖

(𝑘)    (𝑚𝑜𝑑 1 + 𝑘𝑡), 

1 + 𝑘𝑡 ⎸𝑎𝑖 − 𝑦𝑖

(𝑘) 

𝑢
 1 + 𝑘𝑡 ⎸ ∏(𝑎𝑖 − 𝑗).
𝑗 = 1

E novamente, como os números 1 + 𝑘𝑡 são respectivamente primos entre si,                          

𝒖
𝟏 + 𝒄𝒕 ⎸ ∏ (𝒂𝒊 − 𝒋).
𝒋 = 𝟏

∎ 

Teorema 2.4 

      Se 𝑃 é um polinômio a coeficientes inteiros, então são diofantinos os seguintes conjuntos: 

𝑅 = {(𝑦, 𝑥1, … , 𝑥𝑛) ∈ (ℕ∗)𝑛+1: ∃𝑘 ∈ ℕ∗ com 𝑘 ≤ 𝑦 , ∃ 𝑦1 … , 𝑦𝑚   ∈ ℕ∗  ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0}.
{

𝑆 = {(𝑦, 𝑥1, … , 𝑥𝑛) ∈ (ℕ∗)𝑛+1: ∀𝑘 ∈ ℕ∗ com 𝑘 ≤ 𝑦 , ∃ 𝑦1 … , 𝑦𝑚   ∈ ℕ∗  ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0}.

Demonstração. 

𝑹 é um conjunto diofantino 

      Como (𝑦, 𝑥1, … , 𝑥𝑛) ∈ 𝑅 ⇔ ∃ 𝑘, 𝑦1 … , 𝑦𝑚 ∈ ℕ∗ ⎸𝑘 ≤ 𝑦  e  𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) =
0. Segue que 𝑅 é um conjunto diofantino. 

𝑺 é um conjunto diofantino 

      Agora é fácil completar a prova do Teorema 2.4 usando os Lemas 2,34  e 2.35.Primeiro 

encontre um polinômio 𝑄 satisfazendo (1), (2), (3) no Lema 2,35 

𝑁
Para isso , escreva: 𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = ∑
𝑟=1
forma: 

𝑡𝑟,

 onde cada  𝑡𝑟 tem a seguinte 

𝑡𝑟 = 𝑐𝑟𝑦𝑎𝑘𝑏𝑥1

𝑞1𝑥2

𝑞2 … 𝑥𝑛

𝑞𝑛𝑦1

𝑠1𝑦2

𝑠𝑚 
𝑠2 … 𝑦𝑚

Para cada 𝑐𝑟 positivo ou negativo. 
Seja 𝑢𝑟 = ⎸𝑐𝑟⎸𝑦𝑎+𝑏𝑥1
Lembrando que 

𝑞2 … 𝑥𝑛

𝑞1𝑥2

𝑞𝑛𝑢𝑠1+𝑠2+⋯+𝑠𝑚   e  𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛) = 𝑢 + 𝑦 + ∑

𝑁
𝑟=1

𝑢𝑟.

𝑢 = max{ 𝑦𝑖

(𝑘)⎸ 1 ≤ 𝑖 ≤ 𝑚  ; 1 ≤ 𝑘 ≤ 𝑦}. 

Então (1) , (2) e (3) do Lema 2.35 é trivialmente satisfeito. Desse modo, 

 
 
 
 
 
 
 
 
 ∀𝑘 ∈ ℕ∗ com 𝑘 ≤ 𝑦, ∃ 𝑦1 …,𝑦𝑚   ∈ ℕ∗ ⎸𝑃(𝑦, 𝑘, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0  

48 

É equivalente a, 

∃ 𝑐, 𝑡, 𝑎1, … , 𝑎𝑚 ∈ ℕ∗ ⎸ 1 + 𝑐𝑡 = ∏ (1 + 𝑘𝑡) ,
𝑡 = 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛)!  ,

𝑦
𝑘=1

𝑢
1 + 𝑐𝑡  ⎸ ∏(𝑎𝑖 − 𝑗)
𝑗=1

,

1 ≤ 𝑖 ≤ 𝑚 

{

 𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡ 0  (𝑚𝑜𝑑 1 + 𝑐𝑡).

Que por sua vez, é equivalente a  

∃ 𝑢, 𝑐, 𝑡, 𝑎1, … , 𝑎𝑚, 𝑒, 𝑓, 𝑔1, … , 𝑔𝑚, ℎ1, … , ℎ𝑛, 𝑙 ∈ ℕ∗   ⎸

𝑒 = 1 + 𝑐𝑡    ∧    𝑒 = ∏ (1 + 𝑘𝑡)   ∧  𝑓 = 𝑄(𝑦, 𝑢, 𝑥1, … , 𝑥𝑛)

𝑦
𝑘=1

𝑡 = 𝑓!     ∧    𝑔𝑖 = 𝑎𝑖 − 𝑢 − 1,

1 ≤ 𝑖 ≤ 𝑚

𝑢

 ℎ𝑖 = ∏(𝑔𝑖 + 𝑗)     ∧    𝑒 ⎸ℎ𝑖 

𝑗=1

{

   𝑙 =  𝑃(𝑦, 𝑐, 𝑥1, … , 𝑥𝑛, 𝑎1, … , 𝑎𝑚) ≡ 0  (𝑚𝑜𝑑 1 + 𝑐𝑡)    ∧  𝑒 ⎸𝑙 .

Note que ,   

𝑢
∏(𝑎𝑖 − 𝑗)
𝑗=1

𝑢

= ∏(𝑎𝑖 − 𝑢 − 1 + 𝑗)

. 

𝑗=1

Como cada uma dessas expressões acima são diofantinas a combinação delas utilizando o 

operador “∧” e “∃” também será, portanto o conjunto 

𝑆 = {(𝑦, 𝑥1, … , 𝑥𝑛) ∈ (ℕ∗)𝑛+1: ∀𝑧 ∈ ℕ∗ com 𝑧 ≤ 𝑦  𝑒  ∃ 𝑦1 … , 𝑦𝑚  

∈ ℕ∗  ⎸𝑃(𝑦, 𝑧, 𝑥1, … , 𝑥𝑛, 𝑦1, … , 𝑦𝑚) = 0} 

É diofantino. 

∎ 

Lembre que já provamos no teorema 2.3 que as funções  ℎ(𝑎, 𝑏, 𝑦) = ∏ (𝑎 + 𝑏𝑘) 

𝑦
𝑘=1

,

𝑔(𝑛) = 𝑛!  

e  𝑓(𝑛, 𝑘) = (

𝑛
𝑘

) são diofantinas. 

 
 
 
 
 
 
  
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
3.4  Conceito de algoritmo e modelos de computabilidade 

49 

      Um algoritmo é um método cuja execução consiste na aplicação, passo a passo , de certas 

regras especificas a priori. Estas regras devem determinar o resultado final completamente. As 

operações  básicas  da  aritmética  ;  somar  ,  multiplicar    e  dividir  são  procedimentos 

algorítmicos. Um algoritmo conhecido é o algoritmo de Euclides para determinar o máximo 

divisor  comum  de  dois  inteiros  não  negativos.  Necessitamos  definir  as  funções  calculáveis, 

existem os seguintes modelos de computabilidade : 

1)  Godel – Herbrabd - Kleene (1936) : Funções recursivas gerais definidas por meio de 

uma equação de Cálculo. 

2)  Church (1936) : Funciones   𝜆 − definidas. 

3)  Godel - Kleene (1936) : Funções   𝜇 −recursivas  e funções recursivas parciais. 

4)  Turing (1936 ) : Funções calculáveis definidas por máquinas finitas conhecidas como 

máquinas de Turing. 

5)  Post (1943) : Funções definidas por sistemas de deduções canônica. 

6)  Markov (1951) : Funções obtidas por certo algoritmo sobre um alfabeto finito. 

7)   Shepherdson -  Sturgis (1963) : Máquinas ilimitadas de registro. 

      Todos os modelos anteriores de Computabilidade são equivalentes e determinam a classe 

das  funções  calculáveis  denotada  por    ℭ  .  Nesse  trabalho  usaremos  o  modelo  de 

computabilidade 3. 

      A Classe de Funções recursivas surge ao tornar mais preciso o conceito intuitivo de uma 

função  calculável.  Algumas  Funções  Iniciais  ,  que  podem  ser  consideradas  imediatamente 

calculáveis , são chamadas de recursivas , e certas regras (Recursão Primitiva , Composição e 

Minimização)    são  especificadas  por  meio  das  quais  novas  funções  recursivas  podem  ser 

geradas a partir de funções que já sabemos ser recursivas. As regras são tais que , para cada 

nova  função  recursiva  ,  é  possível  indicar  de  uma  só  vez  um  algoritmo  para  calcular  os 

valores da função , se tais algoritmos estiverem disponíveis para as funções recursivas dadas. 

Definição 2.3 :  Uma  função 𝑓 ∶ ℕ𝑛 ⟶ ℕ  é computável  (ou calculável)  se para um    𝑥 ∈

𝑑𝑜𝑚 (𝑓).  Pudermos encontrar um algoritmo tal que o valor de 𝑦 = 𝑓(𝑥). 

 
 
 
 
 
 
 
 
 
Exemplo  2.5  Seja   𝑓 ∶ ℕ2 ⟶ ℕ , 𝑓(𝑥, 𝑦) = 𝑚𝑑𝑐(𝑥, 𝑦).  Esta  função  pode  ser  calculada  pelo 

método de Euclides.    

Exemplo  2.6  Seja  𝑓 ∶ ℕ ⟶ ℕ ,   𝑓(𝑥) = {

1 ,              𝑥 é 𝑝𝑟𝑖𝑚𝑜
2 ,   𝑥  𝑛ã𝑜 é  𝑝𝑟𝑖𝑚𝑜

        Esta  função  pode  ser 

50 

calculada pelo Crivo de Eratóstenes. 

3.5  Funções recursivas  

Para definir função recursiva considere a função 𝑆(𝑖, 𝑢) definida no Teorema 1.2. 

Definição : Funções Recursivas são aquelas que podem ser obtidas a partir das funções 

recursivas iniciais 

     𝑐1(𝑥) = 1 ;                                    (𝑰𝒅𝒆𝒏𝒕𝒊𝒅𝒂𝒅𝒆)
       𝑆(𝑥) = 𝑥 + 1 ;                                          (𝑺𝒖𝒄𝒆𝒔𝒔𝒐𝒓) 
𝑛(𝑥1, … , 𝑥𝑛) = 𝑥𝑖 ,   1 ≤ 𝑖 ≤ 𝑛 ;                           (𝑷𝒓𝒐𝒋𝒆çã𝒐)  

           𝑈𝑖

{

𝑆(𝑖, 𝑢).                 (𝑻𝒆𝒐𝒓𝒆𝒎𝒂 𝟏. 𝟐)              

      Aplicando  interativamente  três  operações  básicas:  Composição,  Recursão  Primitiva  e 

Minimização definida abaixo podemos  obter uma função ℎ também recursiva. 

Composição:  

Define a função ℎ que satisfaz a equação: 

ℎ(𝑥1, … , 𝑥𝑛) = 𝑓(𝑔1(𝑥1, … , 𝑥𝑛), … , 𝑔𝑚(𝑥1, … , 𝑥𝑛)), 

a partir das funções recursivas 𝑔1, … , 𝑔𝑚 e 𝑓(𝑡1, … , 𝑡𝑚) dadas. 

Recursão Primitiva: Define a função ℎ(𝑥1, … , 𝑥𝑛, 𝑧) que satisfaz as equações: 

ℎ(𝑥1, … , 𝑥𝑛, 1) = 𝑓(𝑥1, … , 𝑥𝑛), 
ℎ(𝑥1, … , 𝑥𝑛, 𝑡 + 1) = 𝑔(𝑡, ℎ(𝑥1, … , 𝑥𝑛, 𝑡), 𝑥1, … , 𝑥𝑛), 

a  partir  das  funções  𝑓, 𝑔  dadas.  Quando  𝑛 = 0 , 𝑓  torna-se  uma  constante  e  ℎ  é  obtida 

diretamente  de  𝑔.  Note  que  a  sequência  de  fibonacci    pode  ser  escrita  como  uma  função 

recursiva. 

Minimização: Define a função ℎ que satisfaz a equação: 

ℎ(𝑥1, … , 𝑥𝑛) = min

y

[𝑓(𝑥1, … , 𝑥𝑛, 𝑦) = 𝑔(𝑥1, … , 𝑥𝑛, 𝑦)], 

A partir das funções 𝑓, 𝑔 dadas e assumindo que 𝑓, 𝑔 são tais que para cada  𝑥1, … , 𝑥𝑛 existe 

pelo menos um 𝑦 satisfazendo a equação 

Ou seja, ℎ está definida para toda n-upla (𝑥1, … , 𝑥𝑛). 

𝑓(𝑥1, … , 𝑥𝑛, 𝑦) = 𝑔(𝑥1, … , 𝑥𝑛, 𝑦), 

 
 
 
 
 
   
 
 
 
 
 
51 

Abaixo temos uma lista de algumas funções recursivas. 

Proposição 2.1: A função  ℎ(𝑥, 𝑦) = 𝑥 + 𝑦 é recursiva. 

Demonstração. 

Defina 𝑔(𝑢, 𝑣, 𝑤) = 𝑣 + 1 e 𝑓(𝑥) = 𝑥 + 1. Note que 𝑔 e 𝑓 são recursivas pois podem ser 

obtidas a partir das funções recursivas iniciais,  𝑔(𝑢, 𝑣, 𝑤) = 𝑆(𝑈2

3(𝑢, 𝑣, 𝑤)) = 𝑆(𝑣)  e 

𝑓(𝑥) = 𝑆(𝑥) = 𝑥 + 1. Agora considere a função ℎ(𝑥, 𝑦) definida por ,  

   {

ℎ(𝑥, 1) = 𝑓(𝑥)
 ℎ(𝑥, 𝑡 + 1) = 𝑔(𝑡, ℎ(𝑥, 𝑡), 𝑥).

Portanto, segue por indução que  ℎ(𝑥, 𝑡) = 𝑥 + 𝑡 e por recursão primitiva, ℎ é recursiva. 

∎ 

Proposição 2.2: A função  ℎ(𝑥, 𝑦) = 𝑥𝑦 é recursiva. 

Demonstração. 

      Defina  𝑓(𝑥) = 𝑥    e    𝑔(𝑢, 𝑣, 𝑤) = 𝑣 + 𝑤  .  Note  que  𝑔  e  𝑓  são  recursivas,  pois           

𝑓(𝑥) = 𝑈1

1(𝑥)   e  𝑔(𝑢, 𝑣, 𝑤) = 𝒔(𝑈2

3(𝑢, 𝑣, 𝑤), 𝑈3

3(𝑢, 𝑣, 𝑤)). Onde 𝒔 é a função soma que já 

sabemos  que  é  recursiva,  veja  que  𝑔  é  recursiva  por  composição.Agora,  considere  a  função 

ℎ(𝑥, 𝑡) definida por, 

   {

ℎ(𝑥, 1) = 𝑓(𝑥)
 ℎ(𝑥, 𝑡 + 1) = 𝑔(𝑡, ℎ(𝑥, 𝑡), 𝑥).

Logo, por indução ℎ(𝑥, 𝑡) = 𝑥𝑡 e por recursão primitiva, ℎ é recursiva. 

∎ 
Proposição 2.3: Para cada 𝑘 ∈ ℕ∗, a função constante 𝑐𝑘(𝑥) = 𝑘 é recursiva. 
Demonstração. 

Para 𝑘 = 1 vale o resultado. Suponha que 𝑐𝑘(𝑥) = 𝑘 é recursiva, então  𝑐𝑘+1(𝑥) é recursiva 
por composição   pois,  

𝑐𝑘+1(𝑥) = 𝑘 + 1 = 𝑐𝑘(𝑥) + 𝑐1(𝑥) = 𝒔(𝑐𝑘(𝑥), 𝑐1(𝑥)). 

∎ 

Observe  que  todos  os  polinômios  𝑃(𝑥1, … , 𝑥𝑛) com  coeficientes  inteiros  positivos  são 
recursivos. Basta expressar essas funções por uma iteração finita de adição e multiplicação de 

variáveis e 𝑐(𝑥).Por exemplo: 

2𝑥2𝑦 + 3𝑥𝑧3 + 5 = 𝑐2(𝑥) ⋅ 𝑥 ⋅ 𝑥 ⋅ 𝑦 + 𝑐3(𝑥) ⋅ 𝑥 ⋅ 𝑧 ⋅ 𝑧 ⋅ 𝑧 + 𝑐5(𝑥). 

Teorema 2.5  Uma função é recursiva se e só se é computável . 

      A demonstração desse resultado pode ser visto com detalhes na referência bibliográfica 

[Computability Theory , veja as páginas 61 e 69].    

 
 
 
 
 
 
Agora enunciaremos um dos resultados centrais deste trabalho: 

52 

Teorema 2.6  Uma função é Diofantina se, e somente se, é recursiva. 

Demonstração.Seja 𝑓 uma função diofantina , 𝑦 = 𝑓(𝑥1, … , 𝑥𝑛) ⟺ ∃𝑡1, … , 𝑡𝑚 ∈
ℕ∗ ⎸ 𝑃(𝑥1, … , 𝑥𝑛, 𝑦, 𝑡1, … , 𝑡𝑚) = 𝑄(𝑥1, … , 𝑥𝑛, 𝑦, 𝑡1, … , 𝑡𝑚) onde 𝑃 e 𝑄 são polinômios com 
coeficientes inteiros e positivos. Então pelo Teorema da Seqüência de Números, 

 ∃𝑢 ∈ ℕ∗  ⎸ 𝑆(1, 𝑢) = 𝑦  e  𝑆(𝑖 + 1, 𝑢) = 𝑡𝑖  , 1 ≤ 𝑖 ≤ 𝑚 , Assim ,  

𝑃(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢), … , 𝑆(𝑚 + 1, 𝑢)) = 𝑄(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢), … , 𝑆(𝑚 + 1, 𝑢)). 

Logo, o conjunto 

𝐴 = {𝑢 ∈ ℕ∗ ⎸  𝑃(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢), … , 𝑆(𝑚 + 1, 𝑢)) = 𝑄(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢), … , 𝑆(𝑚 + 1, 𝑢)} 
é  não vazio. Pelo princípio da Boa Ordem , existe 𝑢0 = 𝑚𝑖𝑛𝐴. Daí ,  

𝑃(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢0), … , 𝑆(𝑚 + 1, 𝑢0)) = 𝑄(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢0), … , 𝑆(𝑚 + 1, 𝑢0)). 

Onde  𝑆(𝑖 + 1, 𝑢0) = 𝑡𝑖  , 1 ≤ 𝑖 ≤ 𝑚, temos que 

𝑃(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢0), 𝑡1, … , 𝑡𝑚) = 𝑄(𝑥1, … , 𝑥𝑛, 𝑆(1, 𝑢0), 𝑡1, … , 𝑡𝑚). 

Portanto , 

𝑓(𝑥1, … , 𝑥𝑛) = 𝑆(1, 𝑢0) = 𝑆(1, 𝑚𝑖𝑛𝐴). 

       Assim , por composição , 𝑃 e 𝑄 são recursivas já que são polinômios com coeficientes 

inteiros e positivos , por minimalidade , 𝑚𝑖𝑛𝐴 é recursiva e , novamente por composição , 𝑓 é 

recursiva. 

        Reciprocamente, como 𝑐(𝑥), 𝑆(𝑥), 𝑈𝑖
mostrar que as funções diofantinas são fechadas para as operações de composição, recursão 

𝑛(𝑥1, … , 𝑥𝑛)  e  𝑆(𝑖, 𝑢) são diofantinas ,basta 

primitiva e minimização, já que no Teorema 1.2 mostramos que 𝑆(𝑖, 𝑢) é Diofantina e as 

funções recursivas iniciais são trivialmente Diofantinas. Faremos isto a seguir: 

Composição: 

Se ℎ(𝑥1, … , 𝑥𝑛) = 𝑓(𝑔1(𝑥1, … , 𝑥𝑛), … , 𝑔𝑚(𝑥1, … , 𝑥𝑛)), onde 𝑓, 𝑔1, … , 𝑔𝑚 são Diofantinas 
então ℎ também é , pois , 𝑦 = ℎ(𝑥1, … , 𝑥𝑛) ⟺   ∃𝑡1, … , 𝑡𝑚 ∈ ℕ∗: 𝑡𝑖 = 𝑔𝑖(𝑥1, … , 𝑥𝑛), 1 ≤ 𝑖 ≤
𝑚  e  𝑦 = 𝑓(𝑡1, … , 𝑡𝑚). 

𝑡1 = 𝑔1(𝑥1, … , 𝑥𝑛)
…
…
𝑡𝑚 = 𝑔𝑚(𝑥1, … , 𝑥𝑛)
𝑦 = 𝑓(𝑡1, … , 𝑡𝑚)

{

      Pelo Lema 1.1  podemos reduzir o sistema em uma única equação 

𝐸(𝑥1, . . , 𝑥𝑛, 𝑦, 𝑡1, . . , 𝑡𝑚) = 0. 

 
 
 
 
 
 
 
 
 
 
Recursão primitiva: 

Se  

ℎ(𝑥1, … , 𝑥𝑛, 1) =  𝑓(𝑥1, … , 𝑥𝑛) 

ℎ(𝑥1, … , 𝑥𝑛, 𝑡 + 1) = 𝑔(𝑡, ℎ(𝑥1, … , 𝑥𝑛, 𝑡), 𝑥1, … , 𝑥𝑛), 

53 

      Onde  𝑓, 𝑔  são  Diofantinas,  então ℎ  também  é,  pois,  usando o  Teorema  da  Sequência  de 

Números para codificar os números    𝑆(1, 𝑢) = ℎ(𝑥1, … , 𝑥𝑛, 1) , … ,  𝑆(𝑧, 𝑢) = ℎ(𝑥1, … , 𝑥𝑛, 𝑧) 
temos que , 

𝑦 = ℎ(𝑥1, … , 𝑥𝑛, 𝑧) ⟺  

∃𝑢 , 𝑣  ∈ ℕ∗  ⎸  [  𝑣 = 𝑆(1, 𝑢)  e  𝑣 = 𝑓(𝑥1, … , 𝑥𝑛)] ,
    𝑒   [ ∀𝑡 ∈ ℕ∗, 1 ≤ 𝑡 ≤ 𝑧  temos 𝑡 = 𝑧 ] 𝑜𝑢 𝑡 < 𝑧 e nesse caso
 [ ∃𝑣′ ∈ ℕ∗ ⎸𝑣′ = 𝑆(𝑡 + 1, 𝑢)  𝑒  𝑣′ = 𝑔(𝑡, 𝑆(𝑡, 𝑢), 𝑥1, … , 𝑥𝑛))]
𝑒  [𝑦 = 𝑆(𝑧, 𝑢)]

{

      Do teorema  1.2  temos  que    𝑆(𝑖, 𝑢)  é  diofantino  alem  disso  os operadores  ∧  𝑒 ∨    geram 

conjuntos  diofantinos  , os  quantificadores  ∃ 𝑒 ∀ também    geram.    Esse  último  quantificador 

gera conjuntos diofantinos  por causa do Teorema 2.4, assim  ℎ é Diofantina. 

Minimização: 

Se  

ℎ(𝑥1, … , 𝑥𝑛) = min

[ 𝑓(𝑥1, … , 𝑥𝑛, 𝑦) = 𝑔(𝑥1, … , 𝑥𝑛, 𝑦)], onde 𝑓, 𝑔 são Diofantinas, então ℎ 

y

também é, pois, 

𝑦 = ℎ(𝑥1, … , 𝑥𝑛, 𝑧) ⟺  

∎ 

∃𝑧 ∈ ℕ∗ ⎸ [ 𝑧 =  𝑓(𝑥1, … , 𝑥𝑛, 𝑦) 𝑒 𝑧 =  𝑔(𝑥1, … , 𝑥𝑛, 𝑦)] ,
    𝑒   [ ∀𝑡 ∈ ℕ∗, 1 ≤ 𝑡 ≤ 𝑦 temos 𝑡 = 𝑦 ] 𝑜𝑢 𝑡 < 𝑦 e nesse caso 
 [ ∃𝑢 , 𝑣 ∈ ℕ∗ ⎸  𝑢 = 𝑓(𝑥1, … , 𝑥𝑛, 𝑡) 𝑒 𝑣 =  𝑔(𝑥1, … , 𝑥𝑛, 𝑡) 
𝑒  [(𝑢 < 𝑣 𝑜𝑢 𝑣 < 𝑢).

{

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
54 

3.6  O conjunto diofantino universal 

      Seja  𝑆 o  conjunto  de todos os  polinômios  a  coeficientes  inteiros  e  positivos.  Fixado  um 

alfabeto infinito de variáveis 𝑥0, 𝑥1, 𝑥2, … e considerando o número 1, as operações de adição 

e multiplicação sucessivas e também  as funções de emparelhamento descritas no teorema 1.1 

, temos que  a função  𝑃: ℕ∗ → 𝑆 ,    𝑃𝑥 = 𝑃𝑥(𝑥0, 𝑥1, … , 𝑥𝑛) definida por. 

{  

𝑃1 = 1,
𝑃3𝑖−1 = 𝑥𝑖−1 ,
𝑃3𝑖 = 𝑃𝐿(𝑖)   + 𝑃𝑅(𝑖) ,   
  𝑃3𝑖+1 = 𝑃𝐿(𝑖) ⋅ 𝑃𝑅(𝑖)  .

      É  sobrejetora,  isto  é,  a  função  𝑃  gera  todos  os  polinômios  de  𝑆.  Escrevendo                     

𝑃𝑖 = 𝑃𝑖(𝑥0, 𝑥1, … , 𝑥𝑛), onde 𝑛 é grande o suficiente para que todas as variáveis que ocorram 

em 𝑃𝑖 estejam incluídas (É claro que 𝑃𝑖 geralmente não depende de todas as variáveis). 

Finalmente, seja 

𝐷𝑛 = {𝑥0   ∈ ℕ∗: ∃𝑥1, … , 𝑥𝑛 ∈ ℕ∗ ⎸ 𝑃𝐿(𝑛)(𝑥0, 𝑥1, … , 𝑥𝑛) = 𝑃𝑅(𝑛)(𝑥0, 𝑥1, … , 𝑥𝑛)}. 

      Observe que  𝑃𝐿(𝑛) e 𝑃𝑅(𝑛) não envolvem todas as variáveis 𝑥0, 𝑥1, … , 𝑥𝑛, mas claramente 

não podem envolver qualquer outra (Lembre-se que 0 < 𝐿(𝑛), 𝑅(𝑛) ≤ 𝑛). Pela forma como a 

sequência  𝑃𝑖 foi construída, vê-se que a sequência de conjuntos 𝐷1, 𝐷2, 𝐷3, … inclui todos os 

conjuntos Diofantinos de números inteiros positivos. 

Proposição 2.4. A família  𝐷 = {𝐷1 , 𝐷2, 𝐷3, … } contem todos os conjuntos diofantinos de 

números inteiros positivos. 

Demonstração. 

      Seja 𝐴 ⊆ ℕ∗ um conjunto diofantino. Então, por definição existe um polinômio 𝐷 com 

coeficientes inteiros tal que , 

𝐴 = {𝑥0   ∈ ℕ∗ ∶   ∃𝑥1, … , 𝑥𝑛 ∈ ℕ∗  ⎸ 𝐷(𝑥0, 𝑥1, … , 𝑥𝑛) = 0   } 
      Podemos  escrever  𝐷 = 𝑓 − 𝑔  ,  onde  𝑓  e  𝑔  são  polinômios  com  coeficientes  inteiros  e 

positivos.  Como 

a 

função  𝑃  definida 

anteriormente 

é 

sobrejetora, 

existem                           

𝑥 , 𝑦  ∈ ℕ∗ ⎸  𝑃𝑥 = 𝑓  e   𝑃𝑦 = 𝑔.    Como  (𝑥 , 𝑦) ∈  ℕ∗ 𝑥  ℕ∗,  existe  𝑛  ∈ ℕ∗ ⎸𝑥 = 𝐿(𝑛)  e  𝑦 =

𝑅(𝑛).  Logo,  𝐷 = 𝑓 − 𝑔 =  𝑃𝑥 −  𝑃𝑦 =  𝑃𝐿(𝑛) −  𝑃𝑅(𝑛) .Portanto ,  𝐴 = 𝐷𝑛 

∎ 

 
 
 
 
 
 
 
 
 
55 

Teorema 2.6 (Teorema da Universalidade) 

O conjunto 𝑈 = {(𝑛, 𝑥) ∈ (ℕ∗)2 ⎸𝑥 ∈ 𝐷𝑛} é Diofantino. 

Demonstração. 

Basta mostrar que 

∃𝑢 ∈ ℕ∗ ⎸ 𝑆(1, 𝑢) = 1  𝑒  𝑆(2, 𝑢) = 𝑥 
𝑒
∀𝑖 ∈ {1, … , 𝑛}  𝑡𝑒𝑚𝑜𝑠  𝑆(3𝑖, 𝑢) = 𝑆(𝐿(𝑖), 𝑢) + 𝑆(𝑅(𝑖), 𝑢) 
𝑒  
𝑆(3𝑖 + 1, 𝑢) = 𝑆(𝐿(𝑖), 𝑢) ∙ 𝑆(𝑅(𝑖), 𝑢)
 𝑒 
𝑆(𝐿(𝑛), 𝑢) = 𝑆(𝑅(𝑛), 𝑢).

𝑥 ∈ 𝐷𝑛 ⟺

{

Seja 𝑥 ∈ 𝐷𝑛 para 𝑥 e 𝑛 dados. Então , por definição ∃𝑡1, … , 𝑡𝑛 ∈ ℕ∗ tais que: 

𝑃𝐿(𝑛)(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑃𝑅(𝑛)(𝑥, 𝑡1, … , 𝑡𝑛). 
Pelo Teorema da Sequência de Números, ∃𝑢 ∈ ℕ∗ tal que 𝑆(𝑗, 𝑢) = 𝑃𝑗(𝑥, 𝑡1, … , 𝑡𝑛) onde  1 ≤

𝑗 ≤ 3𝑛 + 2.   

Então em particular  𝑆(1, 𝑢) = 𝑃1(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑃1 = 1  e 𝑆(2, 𝑢) = 𝑃2(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑥0 =
𝑥, ou seja, 𝑺(𝟏, 𝒖) = 𝟏  e  𝑺(𝟐, 𝒖) = 𝒙 para 𝑖 ∈ {1, … , 𝑛}  temos que 

𝑆(3𝑖, 𝑢) = 𝑃3𝑖(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑃𝐿(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛) + 𝑃𝑅(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛)

= 𝑺(𝑳(𝒊), 𝒖) + 𝑺(𝑹(𝒊), 𝒖), 

𝑆(3𝑖 + 1, 𝑢) = 𝑃3𝑖+1(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑃𝐿(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛). 𝑃𝑅(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛)

= 𝑺(𝑳(𝒊), 𝒖) ∙ 𝑺(𝑹(𝒊), 𝒖) , 

Como 𝑥 ∈ 𝐷𝑛 , sabemos que  

Ou seja,  

𝑃𝐿(𝑛)(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑃𝑅(𝑛)(𝑥, 𝑡1, … , 𝑡𝑛). 

𝑺(𝑳(𝒏), 𝒖) = 𝑺(𝑹(𝒏), 𝒖). 

Reciprocamente, seja o lado direito verdadeiro para 𝑥 e 𝑛 dados. Seja 𝑡𝑗′ = 𝑆(3𝑗′ + 2, 𝑢) para 
1 ≤ 𝑗′ ≤ 𝑛. Então 

𝑡1 = 𝑆(5, 𝑢), 𝑡2 = 𝑆(8, 𝑢), … , 𝑡𝑛 = 𝑆(3𝑛 + 2, 𝑢) 
Vejamos por indução que  𝑆(𝑗, 𝑢) = 𝑃𝑗(𝑥, 𝑡1, … , 𝑡𝑛) onde  1 ≤ 𝑗 ≤ 3𝑛 + 2. Para 𝑗 = 1, temos 

que  

 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
56 

Agora, suponha válido para valores até 𝑗 − 1, e vamos mostrar que vale para 𝑗.  

𝑆(1, 𝑢) = 𝑃1(𝑥, 𝑡1, … , 𝑡𝑛) = 1   

Se 𝒋 = 𝟑𝒊 − 𝟏   

Então, 𝑆(3𝑖 − 1, 𝑢) = 𝑆(3(𝑖 − 1) + 2, 𝑢) = 𝑡𝑖−1 = 𝑃3𝑖−1(𝑥, 𝑡1, … , 𝑡𝑛). Lembre que 𝑡𝑗′ =
𝑆(3𝑗′ + 2, 𝑢) e note que 1 ≤ 𝑖 − 1 ≤ 𝑛. 

Se 𝒋 = 𝟑𝒊  

𝐻𝑖𝑝
Então , 𝑆(3𝑖, 𝑢) =

𝐼𝑛𝑑
𝑆(𝐿(𝑖), 𝑢) + 𝑆(𝑅(𝑖), 𝑢) =

𝑃𝐿(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛) + 𝑃𝑅(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛) =

𝑃3𝑖(𝑥, 𝑡1, … , 𝑡𝑛). 

Se 𝒋 = 𝟑𝒊 − 𝟏 

𝐻𝑖𝑝
  Entã , 𝑆(3𝑖 + 1, 𝑢) =

𝐼𝑛𝑑
𝑆(𝐿(𝑖), 𝑢) ∙ 𝑆(𝑅(𝑖), 𝑢) =

𝑃𝐿(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛). 𝑃𝑅(𝑖)(𝑥, 𝑡1, … , 𝑡𝑛) =

𝑃3𝑖+1(𝑥, 𝑡1, … , 𝑡𝑛). 

Portanto  𝑆(𝑗, 𝑢) = 𝑃𝑗(𝑥, 𝑡1, … , 𝑡𝑛) onde  1 ≤ 𝑗 ≤ 3𝑛 + 2. Como 𝑆(𝐿(𝑛), 𝑢) = 𝑆(𝑅(𝑛), 𝑢) , 

segue que 

Logo , 𝑥 ∈ 𝐷𝑛 

∎ 

𝑃𝐿(𝑛)(𝑥, 𝑡1, … , 𝑡𝑛) = 𝑃𝑅(𝑛)(𝑥, 𝑡1, … , 𝑡𝑛). 

      Uma  vez  que  𝐷1, 𝐷2, 𝐷3, …  dão  uma  enumeração  de  todos  os  conjuntos  Diofantinos  de 

inteiros  positivos,  é  fácil  construir  um  conjunto  diferente  de  todos  eles  e,  portanto  não 

Diofantino. Basta definir: 

𝑉 = {𝑛 ∈ ℕ∗  ⎸𝑛 ∉ 𝐷𝑛}. 

Teorema 2.7 O conjunto  𝑉 = {𝑛 ∈ ℕ∗  ⎸𝑛 ∉ 𝐷𝑛}  não é Diofantino. 
Demonstração. 

      Esta é uma aplicação do método de diagonalização de Cantor. Suponha que V é 

Diofantino , então existe 𝑘 ∈ ℕ∗ ⎸𝑉 = 𝐷𝑘 , como 𝑉 = 𝐷𝑘 temos , 𝑘 ∈ 𝑉 ⇔  𝑘 ∈   𝐷𝑘  e da 
definição de  𝑉 temos 𝑘 ∈ 𝑉 ⇔  𝑘 ∉   𝐷𝑘, absurdo. 

   {

𝑘 ∈ 𝑉 ⇔  𝑘 ∈   𝐷𝑘
𝑒
 𝑘 ∈ 𝑉 ⇔  𝑘 ∉   𝐷𝑘.

 
 
 
 
  
 
 
 
 
 
57 

∎ 

Teorema 2.8  A função 𝑔(𝑛, 𝑥) definida por: 

 𝑔(𝑛, 𝑥) =   {  

1  ,
2  ,

𝑠𝑒 𝑥 ∉ 𝐷𝑛
𝑠𝑒 𝑥 ∈ 𝐷𝑛 

não é recursiva. 

Demonstração. 

Se 𝑔 fosse recursiva, então 𝑔 seria diofantina, isto é, 

𝑦 = 𝑔(𝑛, 𝑥) ⟺ ∃𝑦1, … , 𝑦𝑚 ∈ ℕ∗ ⎸𝑃(𝑛, 𝑥, 𝑦, 𝑦1, … , 𝑦𝑚) = 0. 

Mas disto segue que: 

𝑉 = {𝑥 ∈ ℕ∗  ⎸𝑥 ∉ 𝐷𝑥} = {𝑥 ∈ ℕ∗  ⎸𝑔(𝑥, 𝑥) = 1}

= {𝑥 ∈ ℕ∗ : ∃𝑦1, … , 𝑦𝑚 ∈ ℕ∗ ⎸𝑃(𝑥, 𝑥, 1, 𝑦1, … , 𝑦𝑚) = 0}, 

Logo, 𝑉 é diofantina , absurdo. 

 ∎ 

Teorema 2.9  O Décimo problema de Hilbert é insolúvel nos inteiros positivos. 

Demonstração. 
Pelo Teorema  da  Universalidade  ,  sabemos  que  o  conjunto  𝑈 = {(𝑛, 𝑥) ∈ (ℕ∗ )2 ⎸𝑥 ∈ 𝐷𝑛}  é 
Diofantino , isto é, 

𝑥 ∈ 𝐷𝑛 ⟺ ∃𝑧1, … , 𝑧𝑘   ∈ ℕ∗  ⎸ 𝑃(𝑛, 𝑥, 𝑧1, … , 𝑧𝑘) = 0. 
      Suponha  por  absurdo  que  o  Décimo  problema  de  Hilbert  seja  solúvel  nos  inteiros 

positivos,ou  seja  ,  suponha  que  exista  um  algoritmo  para  testar  se  uma  equação  diofantina 

possui  soluções  inteiras  positivas.  Então  para 𝑥  e 𝑛  dados,  este  algoritmo  poderia  ser  usado 

para testar se a equação 

𝑃(𝑛, 𝑥, 𝑧1, … , 𝑧𝑘) = 0 

      Tem solução, isto é, se 𝑥 ∈ 𝐷𝑛 ou não. Desse modo o algoritmo calcula a função 𝑔(𝑛, 𝑥). 
Uma vez que as funções recursivas são apenas aquelas para as quais existe um algoritmo de 

computação,  𝑔(𝑛, 𝑥)  seria  recursiva,  ou  melhor  ,  se  existe  um  algoritmo  para  determinar 

𝑔(𝑛, 𝑥)  ,  para  cada  𝑛  e  cada  𝑥  inteiros  positivos  ,  então  𝑔 é  recursiva,  mas  isto  contraria  o 

Teorema 2.8. Logo o Décimo Problema de Hilbert é insolúvel nos inteiros positivos. 

∎ 

 
 
 
 
 
 
 
 
 
58 

Teorema 2.10  O Décimo problema de Hilbert é insolúvel nos naturais. 

Demonstração. 

      Seja 𝑃(𝑥1, … , 𝑥𝑚) = 0 uma equação diofantina. Defina o polinômio 

𝑄(𝑦1, … , 𝑦𝑚) = 𝑃(𝑦1 + 1, … , 𝑦𝑚 + 1). 
      Suponha  por  absurdo  que  o  décimo  problema  de  Hilbert  é  solúvel  nos  naturais.  Então 

,existe um algoritmo que testa se   ∃𝑦1, … , 𝑦𝑚 ∈ ℕ ⎸𝑄(𝑦1, … , 𝑦𝑚) = 0. Escrevendo 𝑥𝑖 = 𝑦𝑖 +
1 ,  onde  1 ≤ 𝑖 ≤ 𝑚  ,  esse  algoritmo  testa  se     ∃𝑥1, … , 𝑥𝑚 ∈ ℕ∗ ⎸𝑃(𝑥1, … , 𝑥𝑚) = 0.  Logo  o 
décimo problema de Hilbert é solúvel nos inteiros positivos, absurdo. 

∎ 

Teorema 2.11 O Décimo problema de Hilbert é insolúvel  

Demonstração. 

Seja 𝑃(𝑥1, … , 𝑥𝑚) = 0 uma equação diofantina. Pela proposição 1.1 sabemos que  o sistema 

𝑥1 = 𝑦1,1

2
2 + 𝑦1,4

𝑃(𝑥1, … , 𝑥𝑚) = 0
2 + 𝑦1,3
2 + 𝑦1,2
...
2 + 𝑦𝑚,3
2 + 𝑦𝑚,2

𝑥𝑚 = 𝑦𝑚,1

{

2 + 𝑦𝑚,4

2

      Pode ser simplificado na equação,  𝐸(𝑥1, … , 𝑥𝑚, 𝑦1,1, … , 𝑦𝑚,4) = 0. Suponha por absurdo 

que  o  décimo  problema  de  Hilbert  seja  solúvel,  logo,  existe  um  algoritmo  que  testa  se  a 

equação, 𝐸(𝑥1, … , 𝑥𝑚, 𝑦1,1, … , 𝑦𝑚,4) = 0 possui solução inteira. Pelo Lema 1.2, isso equivale 

a dizer que esse algoritmo testa se, 𝑃(𝑥1, … , 𝑥𝑚) = 0 possui solução nos naturais. Portanto, o 
décimo problema de Hilbert é solúvel nos naturais, absurdo. 

∎ 

      Note que este resultado não dá informações sobre a existência de soluções para qualquer 

equação  Diofantina  específica,  limita-se  a  garantir  que  não  existe  um  algoritmo  único  para 

testar  todas  as  classes  de  equações  Diofantinas.  Isto  não  quer  dizer  que,  dada  uma  equação 

diofantina em particular, não possamos achar um  método para tentar descobrir se ela possui 

ou não soluções inteiras. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
59 

4  UMA APLICAÇÃO PARA O 10º  PROBLEMA DE HILBERT 

      Uma  implicação  muito  importante  dessa  solução  negativa  do  décimo  problema  de 

HILBERT é o teorema de incompletude de GÖDEL demonstrado em 1931. 

4.1  Teorema de incompletude de Godel 

Teorema 3.1. Não existe um sistema axiomático consistente do qual se pode deduzir todas as 

verdades da aritmética. 

Demonstração. 

      Suponhamos  que  existe  um  sistema  Γ  consistente  que  deduz  todas  as  verdades  da 

aritmética. A notação Γ ⊢ ψ indica que a fórmula da aritmética  ψ  se deduz de Γ. O conceito 

de  dedução  formal  é  um  processo  algorítmico,  no  sentido  de  que,  dada  uma  sucessão  de 

fórmulas, é possível deduzir se é ou não é uma dedução correta. É então possível fornecer um 

algoritmo que liste todas as deduções corretas. Agora, dada uma equação diofantina  

𝑃(𝑥) = 0,  ela  pode  ser  escrita  na  forma  𝑃1(𝑥) = 𝑃2(𝑥)  onde  ´´𝑃1(𝑥) = 𝑃2(𝑥)``  pertence  a 
linguagem da aritmética. Consideremos a fórmula 

ψ ∶ ∃𝑥 [𝑃1(𝑥) = 𝑃2(𝑥)]. 

      Este fórmula deve ser verdadeira ou falsa. Se ψ é verdadeira , Γ ⊢ ψ por hipótese. Se ψ é 

falsa então ¬ψ é verdadeira, assim  Γ ⊢ ¬ψ. Como Γ é consistente , Γ não pode deduzir a ψ  e 

¬ψ . O algoritmo a seguir resolveria o décimo problema de HILBERT.  

      Liste  todas  as  deduções  corretas  e  examine  a  última  fórmula,  pare  o  processo  quando 

aparecer  ψ  ou  ¬ψ.  O  processo  termina  pois  alguma  das  duas    fórmulas  é  dedutível  ,  deve 

haver uma dedução que termina em ψ  ou ¬ψ . Se é ψ a que aparece, a equação 𝑃(𝑥) = 0  é 

solúvel.  Se  é  ¬ψ,  a  equação  não  é  solúvel  .  Assim  temos  encontrado  um  algoritmo  que 

soluciona o décimo problema de HILBERT!! , isso contradiz o teorema 2.11. Por conseguinte 

não existe um tal sistema Γ.  

      Então    se  existe  um  sistema  consistente  que  deduz  Todas  as  verdades  da  aritmética  ele 

conseguiria dizer se dada uma equação diofantina  ela tem ou não tem solução nos inteiros , 

mas  isso significaria que o Décimo problema de Hilbert é solúvel  nos  inteiros , portanto um 

absurdo já que sabemos que o décimo problema não é solúvel e portanto não existe tal sistema 

axiomático consistente.  

 
 
 
 
 
 
 
 
 
60 

5   CONCLUSÃO 

      É  Importante  perceber  que  a  insolubilidade  do  10º  problema  de  Hilbert  não  dá 

informações  sobre  a  existência  de  soluções  para  qualquer  equação  Diofantina  específica, 

limita-se a garantir que não existe um algoritmo único para testar todas as classes de equações 

Diofantinas.  Isto  não  quer  dizer  que,  dada  uma  equação  diofantina  em  particular,  não 

possamos achar um método para tentar descobrir se ela possui ou não soluções inteiras. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
61 

REFERÊNCIA 

CHURCH, A.  An unsolvable problem of elementary number theory. American Journal of 
Mathematics, v. 58, p. 345-363, out. 1936. 

COOK, S. Computability theory. [s.l.] : University of Toronto, 2008. Disponível em:  
http://www.cs.toronto.edu/~toni/Courses/438/Mynotes/page54. pdf Acesso em 19 jun 2018. 

DAVIS, M. Arithmetical problems and recursively enumerable predicates. Journal of 
Symbolic Logic, v. 18, p. 33-41, jan. 1953. 

DAVIS, M. Hilbert’s tenth problem is unsolvable. The American Mathematical Monthly, v. 
80, p. 233-269, nov. 1973. 

PUTNAM, H. Reduction of Hilbert tenth problem. Journal of Symbolic Logic, v. 23, p. 183-
187, fev. 1958. 

GODEL, K. Uber formal unentscheidbare satze der principia mathematica und verwandter 
systeme. Monatshefte fur  Mathematik und Physik, v. 38, p. 173-198, out. 1931. 

MATIYASEVICH, Y. Hilbert’s tenth problem.  Cambridge, Mass. : Mit Press, 1993. 

ROBINSON, J. Existential definability in arithmetic. Transactions of the American 
Mathematical Society, v. 72, p. 437-449, nov. 1952. 

SANTOS, J. Introdução à teoria dos números. Rio de Janeiro : IMPA, 2010. Coleção 
Matemática Universitária. 

TURING, A. On computable number with an application to the Entscheidungs problem. 
Proceedings of the London Mathematical Society, v. 42, p. 230-265, fev. 1936. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
