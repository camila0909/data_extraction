Universidade Federal da Bahia - UFBA
Instituto de Matematica - IM
Sociedade Brasileira de Matematica - SBM

Mestrado Profissional em Matem√°tica em Rede Nacional - PROFMAT

Disserta√ß√£o de Mestrado

Uso de Programa√ß√£o no ensino das
Transforma√ß√µes Geom√©tricas no Plano

Jos√© Ben√≠cio dos Anjos Fran√ßa

Salvador - Bahia

Mar√ßo de 2016

Uso de Programa√ß√£o no ensino das
Transforma√ß√µes Geom√©tricas no Plano

Jos√© Ben√≠cio dos Anjos Fran√ßa

Disserta√ß√£o

de

Mestrado

apresentada

√† Comiss√£o Acad√™mica

Institucional

do

PROFMAT-UFBA como requisito parcial para

obten√ß√£o do t√≠tulo de Mestre em Matem√°tica.

Orientador: Prof. Dr. Vin√≠cius Moreira Mello.

SALVADOR - BAHIA

MAR√áO DE 2016

SISTEMA DE BIBLIOTECAS DA UFBA

Fran√ßa, Jos√© Ben√≠cio dos Anjos

Uso de programa√ß√£o no ensino das transforma√ß√µes geom√©tricas no plano /

Jos√© Ben√≠cio dos Anjos Fran√ßa. ‚Äì 2016.

179f.: il.

Inclui ap√™ndices.

Orientador: Prof. Dr. Vin√≠cius Moreira Mello.

Disserta√ß√£o (mestrado) ‚Äì Universidade Federal da Bahia, Instituto de

Matem√°tica, Salvador, 2016.

1. Constru√ß√µes Geom√©tricas. 2. Linguagem de Programa√ß√£o (Computadores).

3. Processing (Linguagem de programa√ß√£o de computadores). I. Mello, Vin√≠cius

Moreira. II. Universidade Federal da Bahia. Instituto de Matem√°tica. III. T√≠tulo.

CDU - 516

CDU - 514

√Ä minha fam√≠lia

Agradecimentos

A Deus

Ele que ilumina e rege a minha vida, fortalecendo a cada encal√ßo que a vida oferece,

mostrando que mesmo nas dificuldades existe a beleza da vida. Neste dia n√£o quero pedir

nada, apenas agradecer por tudo que j√° pedi e me foi consagrado. Com sua gra√ßa e ben√ß√£o

continuarei a trilhar os caminhos em busca da evolu√ß√£o plena.

A fam√≠lia

Fonte de vida e energia, onde encontro o para√≠so da harmonia e tranquilidade

para reestruturar-me cada vez mais, pois com o amor familiar s√≥ temos a nos fortalecer

mesmo diante das dificuldades. Em especial a minha m√£e Maria da Concei√ß√£o e irm√£

Patr√≠cia por sempre me apoiar mesmo vendo as dificuldades da profiss√£o e o tempo para

conseguir estudar, e a meu irm√£o Renato por me ajudar com linguagem de programa√ß√£o

nos momentos de dificuldade e d√∫vidas.

√Ä UFBA e aos professores colaboradores

A todos os que integram a Universidade Federal da Bahia, em especial aos pro-

fessores que colaboraram, e tiveram compreens√£o da necessidade deste curso, e de qu√£o

seria importante para meu crescimento profissional e pessoal. E ao professor Vin√≠cius

Moreira Mello pela indica√ß√£o da linguagem de programa√ß√£o Processing.JS, mesmo depois

de testarmos a linguagem Blockly da Google sem muito sucesso com os materiais de apoio

e instru√ß√£o.

Ao quarteto fant√°stico

CAPES, SBM, PROFMAT e a UFBA, pela implanta√ß√£o do curso e estrutura√ß√£o

do mesmo. Ao mesmo tempo pela disponibiliza√ß√£o de materiais e livros a pre√ßos acess√≠veis

com alta qualidade, pois sua aquisi√ß√£o foi fundamental e imprescind√≠vel para o sucesso

profissional e acad√™mico.

A Eliane Santos Alves

Pela nossa rela√ß√£o de cumplicidade, amor, carinho, preocupa√ß√£o e sinceridade. E

por ter me compreendido nos momentos finais do mestrado onde precisei me debru√ßar

sobre o computador para aprender a programar antes de ensinar o que √© programar.

Aos colegas do curso

Cada um possui uma import√¢ncia no decorrer do curso, pois cada ser tem sua

especificidade, e compete a todos n√≥s admirarmos na observa√ß√£o e respeitarmos acima de

qualquer diferen√ßa. Alguns encontravam-se mais afastados, outros mais pr√≥ximos, mesmo

assim todos contribu√≠ram para esta rica conviv√™ncia em grupo durante o curso. Aos mais

pr√≥ximos espero ter sido presente nas solicita√ß√µes, assim como foram para mim, e os

momentos que vivenciamos juntos seja em grupos de estudos ou para discontra√ß√£o como

o jogo de boliche ou os almo√ßos ser√£o sempre inesquec√≠veis. E quero aqui deixar registrado

aos colegas de equipe da disciplina Recursos Computacionais no ensino de Matem√°tica ‚Äì

MA36 ‚Äì o apoio e o desprendimento pela escolha do tema para minha defesa de mestrado,

s√£o eles: Sidn√©ia, Marconi, Rubens e Vit√≥rio.

Aos Amigos e colegas de trabalho

Todos possui uma import√¢ncia em cada fase de nossas vidas, mas quero deixar

aqui registrado o apoio que os colegas de trabalho da Escola Municipal Am√©lia Rodrigues

prestaram juntamente com a dire√ß√£o, Andrea Tavares, no percurso deste mestrado, em

especial, minha amiga Nadjara que sempre apoiou minhas perip√©cias matem√°ticas com

algumas contribui√ß√µes particulares para aperfei√ßoa-la em apresenta√ß√µes e/ou ministrando

aulas.

‚ÄúNada perece no Universo; tudo

quanto nele acontece n√£o passa de

meras transforma√ß√µes".

Pit√°goras

Resumo

Este trabalho apresenta uma s√≠ntese hist√≥rica do processo de implanta√ß√£o do uso

de computadores na educa√ß√£o, explicitando o surgimento das linguagens de programa√ß√£o

com sua evolu√ß√£o e contribui√ß√£o para a mesma, e um conjunto de atividades explorat√≥ria

para serem trabalhadas na sala de inform√°tica como recurso did√°tico para uma aprendi-

zagem significativa a respeito das Transforma√ß√µes Geom√©tricas no Plano atrav√©s do uso
da linguagem de programa√ß√£o Processing nas turmas do 9o ano do Ensino Fundamental

II da Unidade Escolar Am√©lia Rodrigues, Monte Gordo-Cama√ßari/BA. Com o Processing

√© poss√≠vel propor e realizar atividades l√∫dicas que promovam uma aprendizagem atra-

v√©s do ensino de programa√ß√£o de computadores que consiste basicamente em instruir o

computador a realizar uma determinada atividade. Essa linguagem possibilita um pri-

meiro contato com os princ√≠pios da computa√ß√£o para a gera√ß√£o de aplicativos e jogos,

viabilizando com isso um futuro profissional para os interessados em dar continuidade na

aprendizagem que se inicia a partir do curso de programa√ß√£o no site da Khan Academy.

Palavras chave: Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica;

Processing.JS.

Abstract

This paper presents a historical overview of the implementation of the use of com-

puters in education process, explaining the emergence of programming languages with

their development and contribution to it, and a set of exploratory activities to be worked

in the computer room as a resource of teaching for a significant learning about the Ge-

ometric Transformations in the plane by using Processing programming language in the

9th year of the Secondary School of Unit Amelia Rodrigues, Monte Gordo-Cama√ßari/BA.

With Processing is possible to propose and carry out recreational activities that promote

learning through computer programming education consisting primarily to instruct the

computer to perform a particular activity. That language will allow a first contact with

the principles of computing to generate applications and games, allowing thereby a pro-

fessional future for those interested in learning that starts from the programming course

at the Khan Academy website.

Key words: Programming Language; Geometric Transformation; Proces-

sing.JS.

Lista de Figuras

1

2

Correntes de ensino-aprendizagem usando o computador

. . . . . . . .

p. 26

Segmentos de reta para o algoritmo de Euclides

. . . . . . . . . . . . .

p. 33

3 MDC de Euclides no ret√£ngulo . . . . . . . . . . . . . . . . . . . . . . .

p. 33

4

5

6

7

8

9

Comando para exibi√ß√£o de mensagens e elipse . . . . . . . . . . . . . .

p. 43

IDE e aplica√ß√£o da elipse animada . . . . . . . . . . . . . . . . . . . . .

p. 46

Sistema de Coordenadas Cartesianas e no Processing

. . . . . . . . . .

p. 47

Constru√ß√µes no Modo B√°sico e Modo Cont√≠nuo . . . . . . . . . . . . . .

p. 49

Declara√ß√µes de vari√°veis

. . . . . . . . . . . . . . . . . . . . . . . . . .

p. 51

Diagrama de uma estrutura if-else . . . . . . . . . . . . . . . . . . . . .

p. 52

10 Constru√ß√£o condicional com if-else . . . . . . . . . . . . . . . . . . . . .

p. 52

11 Diagrama e Constru√ß√£o com a estrutura switch();

. . . . . . . . . . . .

p. 53

12 Operadores condicionais

. . . . . . . . . . . . . . . . . . . . . . . . . .

p. 54

13 Operadores L√≥gicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 55

14 Diagrama de Fluxo com repeti√ß√£o simples

. . . . . . . . . . . . . . . .

p. 55

15 Desenhando formas com o comando while

. . . . . . . . . . . . . . . .

p. 56

16 Desenhando formas com o comando do {} while( ) . . . . . . . . . . . .

p. 57

17 Desenhando formas com o comando for . . . . . . . . . . . . . . . . . .

p. 58

18 Anima√ß√µes na estrutura for associado a vetores . . . . . . . . . . . . . .

p. 62

19

Imagem em tons de cinza usando uma matriz

. . . . . . . . . . . . . .

p. 63

20 Constru√ß√£o do tabuleiro para o Jogo da Velha . . . . . . . . . . . . . .

p. 64

21 Constru√ß√£o com fun√ß√£o de regresso . . . . . . . . . . . . . . . . . . . .

p. 65

22 Detalhe da DRP de Escher . . . . . . . . . . . . . . . . . . . . . . . . .

p. 67

23 Transla√ß√£o do ponto ùëÄ segundo o vetor ‚Éóùë£ . . . . . . . . . . . . . . . .

p. 71

24 Transla√ß√£o do ponto ùëÄ segundo o segmento ùëÉ ùëÑ . . . . . . . . . . . . .

p. 72

25 Composi√ß√£o de transla√ß√£o do ponto ùêæ em ùêæ ‚Ä≤‚Ä≤

. . . . . . . . . . . . . .

p. 73

26 Reflex√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 74

27 Reflex√£o no plano cartesiano . . . . . . . . . . . . . . . . . . . . . . . .

p. 74

28 Reflex√£o em rela√ß√£o a um ponto e uma reta ùëü qualquer . . . . . . . . .

p. 75

29 Rota√ß√£o do ponto ùëã com centro em ùëÇ e amplitude ùõº . . . . . . . . . .

p. 79

30 Rota√ß√£o do ponto ùëã e amplitude ùõº com centro na origem e no ponto C

p. 80

31 Homotetia de redu√ß√£o (0 < |ùëò| < 1) e amplia√ß√£o |ùëò| > 1 . . . . . . . . .

p. 83

32 Dilata√ß√£o horizontal e vertical

. . . . . . . . . . . . . . . . . . . . . . .

p. 84

33 Fotografia de uma estrada . . . . . . . . . . . . . . . . . . . . . . . . .

p. 86

34 Constru√ß√£o de tri√¢ngulos ret√¢ngulos com efeito de transla√ß√£o . . . . . .

p. 88

35 C√≥digo de Transla√ß√£o com a fun√ß√£o ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë• e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë• . . . . .

p. 89

36 Constru√ß√£o de tri√¢ngulos com efeito de simetria . . . . . . . . . . . . .

p. 90

37 Constru√ß√£o de tri√¢ngulos com efeito de rota√ß√£o

. . . . . . . . . . . . .

p. 91

38 Fluxograma com esquema de uma rota√ß√£o no Processing . . . . . . . .

p. 91

39 Constru√ß√£o de quadrados com efeito de amplia√ß√£o e redu√ß√£o . . . . . .

p. 92

40 Constru√ß√£o de c√≠rculos com dilata√ß√£o horizontal e vertical . . . . . . . .

p. 93

41 Applet 2: Boneco geom√©trico . . . . . . . . . . . . . . . . . . . . . . . .

p. 98

42 Applet 3: Transla√ß√£o prim√°ria . . . . . . . . . . . . . . . . . . . . . . . p. 101

43 Applet 4: Transla√ß√£o do caf√© da manh√£ . . . . . . . . . . . . . . . . . . p. 104

44 Constru√ß√£o do cen√°rio casa com √°rvores e c√©u ensolarado . . . . . . . . p. 108

45 Complementa√ß√£o do cen√°rio com bonecos no ambiente

. . . . . . . . . p. 111

46 Applet 5: Cen√°rio com anima√ß√£o da tartaruga no lago

. . . . . . . . . p. 114

47 Medidas de √¢ngulos em graus e em radianos

. . . . . . . . . . . . . . . p. 116

48 Rota√ß√£o do ret√¢ngulo de 50 por 70 pixels na malha quadriculada . . . . p. 118

49 Applet 6: Rota√ß√£o-Transla√ß√£o e Transla√ß√£o-Rota√ß√£o no ret√¢ngulo de 50

por 70 pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 120

50 Applet 7: Giro de quadrados com cores oscilantes . . . . . . . . . . . . p. 122

51 Applet 7.1: Catavento quadrangular em oscila√ß√£o de cores

. . . . . . . p. 123

52 Applet 8: Constru√ß√£o dos elementos da mandala . . . . . . . . . . . . . p. 126

53 Applet 8.1: Mandala em duas perspectivas centrais

. . . . . . . . . . . p. 126

54 Operadores l√≥gicos ‚Äúe‚Äù, ‚Äúou‚Äù e ‚Äúnega√ß√£o‚Äù . . . . . . . . . . . . . . . . . . p. 129

55 Applet 9: Controle de movimento com rota√ß√£o . . . . . . . . . . . . . . p. 133

56 Escudo para montagem . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 136

57 Applet 10: Simetria em rela√ß√£o ao eixos e a origem . . . . . . . . . . . p. 139

58 Estrutura para o mosaico . . . . . . . . . . . . . . . . . . . . . . . . . . p. 141

59 Mosaico completo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 143

60 Applet 11: Caleidosc√≥pio do mosaico interativo

. . . . . . . . . . . . . p. 146

61 Minions do Filme Meu Malvado Favorito . . . . . . . . . . . . . . . . . p. 148

62 Applet 12: Exerc√≠to de 2 Minions . . . . . . . . . . . . . . . . . . . . . p. 150

63 Tri√¢ngulo de Sierpinski . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 152

64 Molde do Tri√¢ngulo de Sierpinski

. . . . . . . . . . . . . . . . . . . . . p. 154

65 Applet 13: Constru√ß√£o do Tri√¢ngulo de Sierpinski

. . . . . . . . . . . . p. 155

66 Applet 13.1: Tri√¢ngulo de Sierpinski no Processing

. . . . . . . . . . . p. 157

67 Applet 14: Dilata√ß√£o e contra√ß√£o irregular

. . . . . . . . . . . . . . . . p. 159

68 Transforma√ß√£o com dois pontos de fuga . . . . . . . . . . . . . . . . . . p. 172

Lista de Tabelas

1

2

3

4

5

6

7

8

Tabela com os comandos textFont e ellipse . . . . . . . . . . . . . . . .

p. 43

N√≠veis de complexibilidade da programa√ß√£o Processing

. . . . . . . . .

p. 48

Comandos classificados por modalidade de constru√ß√£o . . . . . . . . . .

p. 48

Constru√ß√µes Iniciais no Modo B√°sico e Modo Cont√≠nuo . . . . . . . . .

p. 49

Tipos de dados para vari√°veis

. . . . . . . . . . . . . . . . . . . . . . .

p. 51

Tabela de exemplos dos operadores l√≥gicos . . . . . . . . . . . . . . . .

p. 54

Quadro comparativo entre as estruturas de repeti√ß√£o . . . . . . . . . .

p. 59

Comando for associado a vetores

. . . . . . . . . . . . . . . . . . . . .

p. 61

9 Matriz bidimensional

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 62

Lista de Abreviaturas e S√≠mbolos

API

Application Programming Interface

BASIC

Beginners All-purpose Symbolic Instruction Code

CAI

Computer Aided Instruction

CAPRE

Comiss√£o Coordenadora das Atividades de Processamento Eletr√¥nico

CNPq

Conselho Nacional de Desenvolvimento Cient√≠fico e Tecnol√≥gico

COBOL

COmmon Business Oriented Language

CODASYL

Conference on Data Systems Languages

DIGIBR√ÅS

Empresa Digital Brasileira

DRP

EAO

Divis√£o Regular do Plano

Enseignemente Assist√© par Ordinateur

Fortran

IBM Mathematical FORmula TRANslation System

IBM

IME

LISP

International Business Machines

Instituto de Matem√°tica e Estat√≠stica

LISt Processor

MATLAB

MATrix LABoratory

MDC

MEC

MIT

M√°ximo Divisor Comum

Minist√©rio da Educa√ß√£o e Cultura

Massachussets Institute of Tecnology

PCN+

Orienta√ß√µes Complementares dos Par√¢metros Curriculares Nacionais do

Ensino M√©dio

PCN-EF

Par√¢metros Curriculares Nacionais do Ensino Fundamental

PCN-EM

Par√¢metros Curriculares Nacionais do Ensino M√©dio

PDE

Processing Development Environment

PROINFO

Programa Nacional de Tecnologia Educacional

PRONINFE

Programa Nacional de Inform√°tica na Educa√ß√£o

rad

SEI

TGP

TIC

UCA

Radiano unidade de medida do √¢ngulo plano no Sistema Internacional

Secret√°ria Especial de Inform√°tica

Transforma√ß√µes Geom√©tricas no Plano

Tecnologia de Comunica√ß√£o e Informa√ß√£o

Um Computador por Aluno

UFBA

Universidade Federal da Bahia

UFRGS

Universidade Federal do Rio Grande do Sul

UFRJ

Universidade Federal do Rio de Janeiro

UFSCAR

Universidade Federal de S√£o Carlos

UNICAMP

Universidade Estadual de Campinas

USP

Universidade de S√£o Paulo

Sum√°rio

Introdu√ß√£o

1 Hist√≥ria da Programa√ß√£o no Ensino de Matem√°tica

p. 18

p. 23

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o . . . . . . . . . . . . . . . . . . .

p. 25

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o . . . . . . . . . . . . . . . . .

p. 31

1.2.1 Pr√©-hist√≥ria da Linguagem de Programa√ß√£o

. . . . . . . . . . .

p. 31

1.2.2 Primeiras Linguagens de Programa√ß√£o . . . . . . . . . . . . . .

p. 36

1.2.2.1

Linguagens de Baixo N√≠vel . . . . . . . . . . . . . . . .

p. 39

1.2.2.2

Linguagens N√£o-Estruturadas . . . . . . . . . . . . . .

p. 39

1.2.2.3

Linguagens Procedurais

. . . . . . . . . . . . . . . . .

p. 40

1.2.2.4

Linguagens Funcionais . . . . . . . . . . . . . . . . . .

p. 40

1.2.2.5

Linguagens Orientadas a Objeto . . . . . . . . . . . .

p. 41

1.2.2.6

Linguagens Espec√≠ficas a Aplica√ß√µes

. . . . . . . . . .

p. 41

1.2.2.7

Linguagens Visuais . . . . . . . . . . . . . . . . . . . .

p. 41

1.3 Hist√≥ria do Processing

. . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 42

2 Descri√ß√£o da Linguagem Processing

p. 45

2.1 Comandos B√°sicos e Menu . . . . . . . . . . . . . . . . . . . . . . . . .

p. 46

2.2 Vari√°veis e Tipos de dados . . . . . . . . . . . . . . . . . . . . . . . . .

p. 50

2.3 Estrutura condicional e operadores l√≥gicos

. . . . . . . . . . . . . . . .

p. 51

2.4 Estrutura de Repeti√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 54

2.5 Vari√°veis Complexas

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 59

2.6 Fun√ß√µes ou M√©todos

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 62

3 Transforma√ß√£o Geom√©trica no Plano

p. 66

3.1 An√°lise matem√°tica das transforma√ß√µes geom√©tricas . . . . . . . . . . .

p. 69

3.2 Transforma√ß√µes Isom√©tricas

. . . . . . . . . . . . . . . . . . . . . . . .

p. 71

3.2.1 Transla√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 71

3.2.2 Reflex√£o (ou Simetria) em rela√ß√£o a uma reta . . . . . . . . . .

p. 73

3.2.3 Rota√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 79

3.3 Transforma√ß√µes Isom√≥rficas

. . . . . . . . . . . . . . . . . . . . . . . .

p. 82

3.3.1 Homotetia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 82

3.4 Transforma√ß√µes Anam√≥rficas . . . . . . . . . . . . . . . . . . . . . . . .

p. 83

3.4.1 Dilata√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 84

4 Transforma√ß√µes Geom√©tricas em Processing

p. 85

4.1 Transforma√ß√µes isom√©tricas no Processing

. . . . . . . . . . . . . . . .

p. 87

4.2 Transforma√ß√µes isom√≥rficas no Processing . . . . . . . . . . . . . . . . .

p. 92

4.3 Transforma√ß√µes anam√≥rficas no Processing . . . . . . . . . . . . . . . .

p. 93

5 Atividades Propostas

p. 95

5.1 Explorando o aplicativo

. . . . . . . . . . . . . . . . . . . . . . . . . .

p. 96

5.2

Isometria de Transla√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . .

p. 99

5.2.1 Conhecendo a transla√ß√£o . . . . . . . . . . . . . . . . . . . . . . p. 100

5.2.2 Aprimorando a transla√ß√£o . . . . . . . . . . . . . . . . . . . . . p. 101

5.2.3 Macro constru√ß√£o com a transla√ß√£o . . . . . . . . . . . . . . . . p. 104

5.3

Isometria de rota√ß√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . p. 115

5.3.1 Conhecendo a rota√ß√£o . . . . . . . . . . . . . . . . . . . . . . . p. 115

5.3.2 Aprimorando a rota√ß√£o . . . . . . . . . . . . . . . . . . . . . . . p. 122

5.3.3 Anima√ß√£o com efeito de rota√ß√£o . . . . . . . . . . . . . . . . . . p. 127

5.4

Isometria de reflex√£o ou simetria

. . . . . . . . . . . . . . . . . . . . . p. 134

5.4.1 Conhecendo a simetria . . . . . . . . . . . . . . . . . . . . . . . p. 135

5.4.2 Aprimorando a simetria . . . . . . . . . . . . . . . . . . . . . . p. 139

5.5 Transforma√ß√£o de homotetia . . . . . . . . . . . . . . . . . . . . . . . . p. 146

5.5.1 Conhecendo a homotetia . . . . . . . . . . . . . . . . . . . . . . p. 147

5.5.2 Aprimorando a homotetia . . . . . . . . . . . . . . . . . . . . . p. 151

5.6 Transforma√ß√£o de dilata√ß√£o/contra√ß√£o irregular

. . . . . . . . . . . . . p. 157

6 Considera√ß√µes Finais

Refer√™ncias Bibliogr√°ficas

Ap√™ndice A -- Transforma√ß√µes Lineares

Ap√™ndice B -- Transforma√ß√µes Projetivas

p. 160

p. 162

p. 166

p. 169

B.1 Transforma√ß√£o Projetiva Plana . . . . . . . . . . . . . . . . . . . . . . p. 169

Ap√™ndice C -- Mosaico para caleidosc√≥pio

p. 174

18

Introdu√ß√£o

Os livros did√°ticos de matem√°tica utilizados no Ensino Fundamental, anos finais, e

no Ensino M√©dio limitam-se na sua maioria ao estudo das rela√ß√µes de congru√™ncia e seme-

lhan√ßa de tri√¢ngulos sem correlacionar com as transforma√ß√µes geom√©tricas no plano (TGP)

e os efeitos que tais transforma√ß√µes geram na an√°lise do comportamento das fun√ß√µes. Essa

realidade √© refor√ßada pelos docentes ao ensinarem geometria plana e o comportamento

das fun√ß√µes descontextualizado com as transforma√ß√µes geom√©tricas, a saber: transla√ß√£o,

reflex√£o e rota√ß√£o chamadas de transforma√ß√µes isom√©tricas e as homotetias.

Ambicionamos que, se a abordagem do comportamento gr√°fico de fun√ß√µes inici-

asse por meio da observa√ß√£o de diferentes padr√µes e movimentos no plano atrav√©s das

transforma√ß√µes geom√©tricas, o aluno poderia chegar √†s generaliza√ß√µes matem√°ticas neces-

s√°rias com maior apropria√ß√£o do conte√∫do estudado, e consequentemente, proporciona ao

discente o desenvolvimento de capacidades como preconiza os Par√¢metros Curriculares

Nacionais do Ensino Fundamental ‚Äì PCN-EF [1].

O ensino de Matem√°tica deve garantir o desenvolvimento de capacidades
como: observa√ß√£o, estabelecimento de rela√ß√µes, comunica√ß√£o (diferentes
linguagens), argumenta√ß√£o e valida√ß√£o de processos e o est√≠mulo √†s for-
mas de racioc√≠nio como intui√ß√£o, indu√ß√£o, dedu√ß√£o, analogia e estimativa
[1, p. 56].

Esses padr√µes existentes no comportamento geom√©trico e de fun√ß√µes est√£o presentes

em diversos campos de atua√ß√£o aos quais os alunos posteriormente podem ingressar, como

na engenharia, na arquitetura e na arte. Vivemos em um universo repleto de padr√µes onde

a Matem√°tica representa uma das ci√™ncias respons√°veis pela cria√ß√£o de teorias que revelam

os segredos da natureza, mostrando variados padr√µes que revelam o comportamento de

uma fun√ß√£o. Diante do exposto, Lima [2] ressalta que o ensino de Matem√°tica deve

abranger tr√™s componentes essenciais, a conceitua√ß√£o, a manipula√ß√£o e a aplica√ß√£o, sendo

imprescind√≠vel a presen√ßa de cada um deles, de forma dosada, para o sucesso de qualquer

curso. Esta dosagem √© importante para que n√£o volte a acontecer como nas d√©cadas de

60 e 70 onde o excesso de conceitua√ß√£o sem focar nos detalhes usuais direcionaram para

um ensino sem objetivos concretos.

Neste sentido, o docente possui o papel de apresentar o mundo dos padr√µes para

Introdu√ß√£o

19

o discente com o intuito de despertar a admira√ß√£o por uma matem√°tica observ√°vel e

aparentemente agrad√°vel de estudar ao ponto de se aprofundar nos conceitos e reconhecer

que a matem√°tica n√£o √© uma ci√™ncia alheia √† realidade. Para Devlin [3] o mundo dos

padr√µes √© o real objeto de estudo dos matem√°ticos contempor√¢neos.

O que o matem√°tico faz √© examinar ‚Äúpadr√µes‚Äù abstratos, padr√µes num√©ri-
cos, padr√µes de forma, padr√µes de movimento, padr√µes de comporta-
mento, etc. Esses padr√µes tanto podem ser reais como imagin√°rios, vi-
suais ou mentais, est√°ticos ou assumindo um interesse pouco mais recre-
ativo. Podem surgir a partir do mundo √† nossa volta, das profundezas
do espa√ßo e do tempo, ou das atividades mais ocultas da mente humana
[3, p. 9].

Nos processos de generaliza√ß√£o de um certo padr√£o √© comum sermos conduzidos

√† apresentar resultados equivocados, no entanto, √© neste ponto que busca-se atrav√©s da

matem√°tica, aperfei√ßoar-se no reconhecimento desses padr√µes em diferentes formas, como

na resolu√ß√£o de problemas que precisam de observa√ß√£o, sele√ß√£o de dados, representa√ß√£o

geom√©trica, alg√©brica ou aritm√©tica, interpreta√ß√£o e generaliza√ß√£o. Este √© o princ√≠pio que

direciona as pessoas no desenvolvimento do pensar matem√°tico e consequentemente em

qualquer outra forma de pensar [4].

O processo de resolu√ß√£o de problemas √© uma excepcional estrat√©gia de aprendiza-

gem, tendo em vista que o aluno √© oportunizado a observar livremente os dados, organiz√°-

los, represent√°-los e propor solu√ß√µes. Esta liberdade de pensamento contribui para o des-

pertar cognitivo como aponta os PCN+ (Orienta√ß√µes Complementares dos Par√¢metros

Curriculares Nacionais do Ensino M√©dio):

A resolu√ß√£o de problemas √© pe√ßa central para o ensino de matem√°tica,
pois o pensar e o fazer se mobilizam e se desenvolvem quando o indiv√≠duo
est√° engajado ativamente no enfrentamento de desafios. Esta compet√™n-
cia n√£o se desenvolve quando propomos apenas exerc√≠cios de aplica√ß√£o
de conceitos e t√©cnicas matem√°ticas, pois, neste caso, o que est√° em
a√ß√£o √© uma simples transposi√ß√£o anal√≥gica: o aluno busca na mem√≥ria
um exerc√≠cio semelhante e desenvolve passos an√°logos aos daquela situ-
a√ß√£o, o que n√£o garante que seja capaz de usar seus conhecimentos em
situa√ß√µes diferentes ou mais complexas[5, p. 112].

Entretanto, na sala de aula existe muita repeti√ß√£o de algoritmos sem significa-

√ß√£o para o aluno acompanhado de conte√∫dos estanques pr√©-selecionados pelo professor,

quando a matriz curricular n√£o pode ser cumprida na integra. Onde este professor em

muitas situa√ß√µes n√£o possui dom√≠nio de conte√∫do e nem seguran√ßa no ato de ensinar, e

isso contribui para a extin√ß√£o do ensino da geometria no Ensino Fundamental al√©m de

colaborar com a amplia√ß√£o do deficit de aprendizagem que √© irrecuper√°vel para o discente.

Introdu√ß√£o

20

Neste processo de aprendizagem existe um exagero alg√©brico no Ensino Fundamental que

estende-se ao Ensino M√©dio ao ponto de conjecturar as fun√ß√µes de forma puramente alg√©-

brica e isoladas.

A fragmenta√ß√£o do ensino de matem√°tica em fun√ß√£o do ac√∫mulo de conte√∫dos

desconexos contribui para uma forma√ß√£o acad√™mica de pessoas incapazes de aplicar os

mais diversos conceitos matem√°ticos no dia-a-dia, nem fazer correla√ß√µes com outros blocos

das diversas √°reas do conhecimento.

Fundamenta-se ainda a escolha do tema pela import√¢ncia em que os casos de sime-

tria auxiliam na elabora√ß√£o do pensamento matem√°tico e possibilidade de correlacionar

com outras √°reas como evidencia os PCN-EF na escolha de conte√∫dos:

Deve destacar-se tamb√©m nesse trabalho a import√¢ncia das transforma-
√ß√µes geom√©tricas (isometricas, homotetias), de modo que permita o de-
senvolvimento de habilidades de percep√ß√£o, por exemplo, das condi√ß√µes
para que duas figuras sejam congruentes ou semelhantes [1, p. 51].

Salienta-se ainda que, segundo Stormowski [6], as transforma√ß√µes geom√©tricas apa-

recem nos Par√¢metros Curriculares Nacionais do Ensino M√©dio (PCN-EM) apenas como

uma forma de complementar o estudo geom√©trico e particularmente o estudo dos n√∫meros

complexos. Tanto Stormowski [6] como Cerqueira [7] concordam com a exist√™ncia de uma

diferen√ßa na abordagem deste assunto por parte dos documentos que tratam do ensino

fundamental e m√©dio. Para Cerqueira [7] a abordagem dos conte√∫dos √© mais espec√≠fica

por n√£o abordar os conceitos de forma geral e aberta como encontramos nos PCN-EF.

Diante do exposto o presente trabalho prop√µe-se em apresentar o estudo das trans-

forma√ß√µes geom√©tricas atrav√©s do uso da linguagem de programa√ß√£o como suporte para

uma aprendizagem significativa baseada na experimenta√ß√£o e manipula√ß√£o de dados. A

partir do curso de programa√ß√£o oferecido pela Khan Academy, ap√≥s o curso os discentes

realizaram uma s√©rie de atividades desenvolvidas diretamente no Processing.JS tomando

por base o conhecimento adquirido e as orienta√ß√µes constantes no roteiro de estudo. Os

alunos piloto do projeto s√£o todos oriundos de uma comunidade de baixa renda da regi√£o
de Monte Gordo/Cama√ßari-BA e encontram-se no 9o ano do Ensino Fundamental II da
pr√≥pria Unidade Escolar1 que disponibilizar√° o Laborat√≥rio de Inform√°tica para os encon-

tros orientados e execu√ß√£o das atividades. A princ√≠pio o Laborat√≥rio ser√° utilizado com

o intuito de matricularem os discentes no portal da Khan Academy enquanto iniciam as

primeiras aulas de programa√ß√£o direcionada de forma cronol√≥gica para fundamentar toda

1Escola Municipal Am√©lia Rodrigues situada na Rua S√£o Bento

Introdu√ß√£o

21

a teoria de algoritmo, sintaxe entre outros elementos imprescind√≠veis para uma aprendi-

zagem formativa e significativa nesse ramo da ci√™ncia. Contudo, como o professor pode

acompanhar a evolu√ß√£o de seus discentes atrav√©s de um portal de aprendizagem t√£o am-

plo?

A esse respeito o pr√≥prio sistema da Khan Academy foi projetado para favorecer

uma aprendizagem √† dist√¢ncia sem perder de vista o car√°ter presencial, ou seja, √© poss√≠vel

inscrever os alunos em diversos cursos e ainda assim acompanhar a evolu√ß√£o de cada um

deles atrav√©s do c√≥digo liberado para o cadastro de turmas que funciona basicamente em

duas modalidades: Na primeira, o pr√≥prio professor convida os alunos a participarem do

curso enviando um email onde eles s√≥ precisam confirmar a participa√ß√£o e; Na segunda

op√ß√£o, o professor disponibiliza um c√≥digo que os pr√≥prios alunos podem adicionar assim

que se inscreverem no portal com uma conta de email ativa da google ou facebook. De

posse da assinatura do portal e com o sistema inicializado o curso proporciona aos envol-

vidos uma aprendizagem de programar desenhos, anima√ß√µes e jogos usando JavaScript e

Processing.JS. Para os alunos motivados √© poss√≠vel finalizar o curso aperfei√ßoando com a

cria√ß√£o de p√°ginas Web com linguagem HTML e CSS. O intuito dos alunos participarem

desse curso visa as constru√ß√µes de imagens transformadas no plano como proposta de

atividade utilizando o programa Processing.

No entanto, para o andamento desse curso o aluno dever√° ter conhecimentos pr√©vios

sobre:

‚àô Geometria Plana ‚Äì Pol√≠gonos regulares e simetrias;

‚àô Rela√ß√µes Bin√°rias;

‚àô No√ß√µes de Fun√ß√£o;

‚àô Conhecimentos b√°sicos de computa√ß√£o: Word, Excel e Internet.

Al√©m dos requisitos pedag√≥gicos tradicionais, o aluno precisar√° de um computador
com Processing.JS 2 instalado e com acesso a Internet para realizar o curso na Khan

Academy. Esse software √© de dom√≠nio p√∫blico e de f√°cil uso. Trata-se de uma linguagem

que possibilitar√° ao aluno um primeiro contato com a programa√ß√£o, percebendo assim, a

import√¢ncia das transforma√ß√µes geom√©tricas bem como de outros temas da Matem√°tica

para criar programas.

Em fun√ß√£o disso, o trabalho encontra-se subdivido em 6 cap√≠tulos.

2A vers√£o mais recente est√° dispon√≠vel para download em https://github.com/processing/processing/releases

Introdu√ß√£o

22

No Cap√≠tulo 1, apresentamos o percurso hist√≥rico da inser√ß√£o da computa√ß√£o no

ensino da matem√°tica, com √™nfase para a evolu√ß√£o das linguagens de programa√ß√£o e as

contribui√ß√µes que tal recurso oferece para a disciplina. Al√©m da hist√≥ria do Processing e

sua aplicabilidade na matem√°tica.

No Cap√≠tulo 2, divulgamos uma descri√ß√£o da linguagem utilizada no Processing

com os principais comandos e efeitos gr√°ficos.

No Cap√≠tulo 3, abordamos as Transforma√ß√µes Geom√©tricas do Plano Cartesiano,

assim como sua representa√ß√£o matricial e sua rela√ß√£o com o produto de matrizes.

No Cap√≠tulo 4, expomos uma rela√ß√£o entre as TGP com a linguagem de progra-

ma√ß√£o Processing, objetivando a compreens√£o gr√°fica oferecidas por tais transforma√ß√µes.

No Cap√≠tulo 5, difundimos nossas propostas de atividades com roteiro que criem

uma rela√ß√£o entre as transforma√ß√µes geom√©tricas descritas no Cap√≠tulo 3 com a linguagem

de programa√ß√£o descrita no Cap√≠tulo 2 e Cap√≠tulo 4. Tais atividades s√£o imprescind√≠veis

por possibilitar a visualiza√ß√£o e o entendimento das transforma√ß√µes de forma din√¢mica e

ao mesmo tempo criativa.

No Cap√≠tulo 6, faremos as considera√ß√µes finais do trabalho com as respetivas con-

clus√µes de forma a contribuir para o desenvolvimento deste segmento da Matem√°tica.

Para finalizar‚Äû ap√≥s as refer√™ncias bibliogr√°ficas apresentaremos nos ap√™ndices as

Transforma√ß√µes Lineares e Transforma√ß√µes Projetivas, em especial, a Projetiva Plana

imprescind√≠vel para demonstrar como as transforma√ß√µes geom√©tricas e a programa√ß√£o

em computa√ß√£o se interligam, isto √©, como a matem√°tica √© utilizada nas linguagens de

programa√ß√£o no que se refere ao estudo das TGPs.

23

1 Hist√≥ria da Programa√ß√£o no

Ensino de Matem√°tica

O uso do computador como recurso pedag√≥gico em sala de aula nos √∫ltimos anos

passou a ser uma necessidade na forma√ß√£o do indiv√≠duo para o mercado de trabalho

de tal forma que a discuss√£o sobre as vantagens ou desvantagens da utiliza√ß√£o dessa

Tecnologia de Comunica√ß√£o e Informa√ß√£o (TIC) ficou restrito a d√©cada de 90 e in√≠cio dos

anos 2000 [8, 9, 10, 11]. Ao inv√©s disso, discuti-se hoje como usar esse recurso para auxiliar

didaticamente na promo√ß√£o da aprendizagem eficiente [12].

De acordo com Valente [10], a inclus√£o do computador na educa√ß√£o brasileira

sempre esteve atrelada historicamente ao fato dessa provocar mudan√ßas pedag√≥gicas, ob-

jetivando com isso uma educa√ß√£o centrada no ensino, na transmiss√£o da informa√ß√£o, para

resultar numa educa√ß√£o centrada no aluno, onde o mesmo pudesse aprender por interm√©-

dio das atividades via computador.

A intera√ß√£o do aluno com o meio em que vive √© facilmente constatada com a

inser√ß√£o das tecnologias no ensino de Matem√°tica. Para Sordo Juanena [13] devemos fixar

os olhares no estudo das interrela√ß√µes entre o aspecto tecnol√≥gico, educativo e matem√°tico.

Esse autor [13] defende ainda tr√™s caracter√≠sticas primordiais do ponto de vista

did√°tico ao se utilizar o computador como ferramenta em sala de aula. S√£o elas:

1. A aten√ß√£o dos alunos volta-se para o significado dos dados e an√°lise dos resultados.

2. Permite aos alunos prognosticar ordens diversas do tipo (desenhos, c√°lculos, deci-

s√µes, etc.) com muito mais rapidez.

3. Intera√ß√£o com os alunos que pode intervir em determinados momentos para prestar

informa√ß√µes ou novas tarefas com base em resultados obtidos, tornando-se desta

forma uma poderosa ferramenta de explora√ß√£o e investiga√ß√£o.

Outro ponto importante que consta nos PCN-EM [14] relacionado ao ensino da

CAP√çTULO 1. HIST√ìRIA DA PROGRAMA√á√ÉO NO ENSINO DE MATEM√ÅTICA24

matem√°tica enfatiza a necessidade da organiza√ß√£o curricular com o intuito de favorecer o

desenvolvimento das compet√™ncias e habilidades desejadas aos alunos do ensino b√°sico.

Esse impacto da tecnologia, cujo instrumento mais relevante √© hoje o
computador, exigir√° do ensino de Matem√°tica um redirecionamento sob
uma perspectiva curricular que favore√ßa o desenvolvimento de habilida-
des e procedimentos com os quais o indiv√≠duo possa se reconhecer e se
orientar nesse mundo do conhecimento em constante movimento. Para
isso, habilidades como selecionar informa√ß√µes, analisar as informa√ß√µes
obtidas e, a partir disso, tomar decis√µes exigir√£o linguagem, procedi-
mentos e formas de pensar matem√°ticos que devem ser desenvolvidos
ao longo do Ensino M√©dio, bem como a capacidade de avaliar limites,
possibilidades e adequa√ß√£o das tecnologias em diferentes situa√ß√µes [14,
p. 41].

Borba [15, p. 285] tamb√©m evidencia:

A introdu√ß√£o das novas tecnologias ‚Äì computadores, calculadoras gr√°fi-
cas e interfaces que se modificam a cada dia ‚Äì tem levantado diversas
quest√µes. Dentre elas destaco as preocupa√ß√µes relativas √†s mudan√ßas
curriculares, √†s novas din√¢micas da sala de aula, ao ‚Äúnovo‚Äù papel do
professor e ao papel do computador nesta sala de aula.

Dessa an√°lise dos PCN-EM e Borba evidenciamos a import√¢ncia do recurso com-

putacional para o desenvolvimento de uma linguagem a ser desenvolvida n√£o somente

no Ensino M√©dio, acreditamos que o incremento dessa linguagem √© plaus√≠vel a partir do
6o ano do Ensino Fundamental com atividades direcionadas com focos distintos daqueles

denotados no Ensino M√©dio. A linguagem de programa√ß√£o √© uma dessas linguagens ad-

miss√≠veis no Ensino Fundamental II e consiste basicamente em ‚ÄúEnsinar‚Äù o computador a

executar um determinado servi√ßo e para isso, o programador precisa utilizar uma sequ√™n-

cia l√≥gica a partir da linguagem formal e precisa, onde o papel do professor √© fundamental

de forma a mediar todo o processo. Com isso, o aluno passa a realizar uma s√©rie de

atividades que s√£o fundamentais para a aquisi√ß√£o de novos conhecimentos [9].

Nesse sentido, um professor mediador √© aquele que trabalhar em constante ‚Äúzona

de risco‚Äù. E ao sair de sua ‚Äúzona de conforto‚Äù e instigar o aluno √† investiga√ß√£o, o professor
esta favorecendo uma aprendizagem ativa, cr√≠tica opondo-se a aprendizagem passiva 1

[16].

1Na aprendizagem ativa o aluno √© o principal construtor do processo de ensino. Nesse processo de
aprendizagem o professor n√£o ensina diretamente, a sua fun√ß√£o consta em criar ferramentas e construir em
conjunto com os alunos um ambiente favor√°vel √† aprendizagem. Assim, √© poss√≠vel criar estrat√©gias criati-
vas que tenham significado para o aluno e ajudem-no a decidir como e o que vai integrar, diferentemente
da aprendizagem passiva, onde a responsabilidade reincide exclusivamente sobre o docente.

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

25

Os recursos que a linguagem de programa√ß√£o podem oferecer para o processo de

aprendizagem esta entrela√ßada com o pr√≥prio percurso hist√≥rico da computa√ß√£o e as con-

tribui√ß√µes que diversos matem√°ticos forneceram ao longo dos s√©culos desde o surgimento

dos primeiros computadores el√©tricos. Para evidenciar o quanto a linguagem de progra-

ma√ß√£o e a matem√°tica est√£o interligadas vamos subdividir esse cap√≠tulo em t√≥picos que

passaram pela hist√≥ria da computa√ß√£o na educa√ß√£o, a evolu√ß√£o da linguagem de pro-

grama√ß√£o at√© chegar √† hist√≥ria do Processing aplicado principalmente no contexto da

Matem√°tica.

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

A hist√≥ria do computador remonta ao per√≠odo em que o homem come√ßou a sentir

necessidade de contar as coisas, da√≠ surgiu o nome computador do latim computare. A

partir do processo de enumera√ß√£o das coisas surgiu tamb√©m a prem√™ncia dos c√°lculos para

agilizar suas tarefas e, a primeira m√°quina a executar esse processo foi o √°baco chin√™s que

existe a pelo menos quatro mil anos e at√© hoje √© utilizado em diversos pa√≠ses.

No entanto, somente no meado da d√©cada de 30 que surgiu o primeiro computador

el√©trico em plena Segunda Guerra Mundial. Sua principal fun√ß√£o era realizar c√°lculos

complexos num curto espa√ßo de tempo e com a m√°xima precis√£o com o intuito de construir

poderosas armas ou decifrar os c√≥digos secretos do inimigo.

Ap√≥s a guerra, tal recurso deixou de ser uma exclusividade do ex√©rcito e passou a

ser utilizado tanto nos neg√≥cios, como nas pesquisas industriais e universit√°rias. Mas, a

utiliza√ß√£o do computador na educa√ß√£o s√≥ iniciou-se juntamente com o in√≠cio da comerci-

aliza√ß√£o dos primeiros computadores com capacidade de programa√ß√£o e armazenamento

de informa√ß√£o nos anos 50, mesmo sem a exist√™ncia de softwares apropriados [10, 11, 17].

No entanto, a incorpora√ß√£o dos computadores nas escolas efetivamente ocorreu nas

d√©cadas de 70 e 80, tanto nos Estados Unidos como nos demais pa√≠ses, intensificando-se

com o surgimento dos microcomputadores na √∫ltima d√©cada mencionada.

Nos Estados Unidos, em meados dos anos 70, existiam duas correntes de pensa-

mento a respeito do uso do computador na educa√ß√£o: Uma foi desenvolvida por Patrick

Suppes, o mentor dos programas de exerc√≠cio CAI (Computer Aided Instruction) que

consistia basicamente em programas dotados de gr√°ficos din√¢micos onde o computador

atuava como m√°quina de ensinar sob uma perspectiva de instru√ß√£o conhecida como instru-

cionismo. O computador fazia perguntas e o aluno apresentava as respostas que julgavam

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

26

corretas.

E a outra corrente defendia o uso do computador como uma maneira de provocar

mudan√ßas na educa√ß√£o, sob uma perspectiva construcionista. A teoria construcionista

desenvolvida por Seymour Papert foi baseada na teoria de Piaget e algumas ideias de

Intelig√™ncia Artificial que se evidenciou simultaneamente com a linguagem de programa√ß√£o
LOGO2 criada pelo pr√≥prio Seymour Papert. Para esse matem√°tico sul-africano o termo

construcionismo apresentado em Valente [9, p. 40] serve para ‚Äúmostrar um outro n√≠vel de

constru√ß√£o do conhecimento: a constru√ß√£o do conhecimento que acontece quando o aluno

elabora um objeto de seu interesse, como uma obra de arte, um relato de experi√™ncia ou um

programa de computador‚Äù. Com isso constatamos um diferenciador entre a perspectiva

instrucionista e a construcionista.

Figura 1: Correntes de ensino-aprendizagem usando o computador

A Figura 1 apresenta um comparativo entre as duas linhas de ensino-aprendizagem

‚Äì instrucionismo e construcionismo ‚Äì onde a presen√ßa do computador, do aluno, de um

professor e de um software √© constante em ambos os casos. No entanto, a dire√ß√£o do ensino,

o tipo de software utilizado, a postura a ser adotada pelo docente e a caracteriza√ß√£o

do discente dentro do processo diferencia essas linhas de ensino-aprendizagem. Para o

instrucionismo, o computador j√° vem pr√©-programado para ensinar o aluno (o espectador

do processo) atrav√©s de um software na modalidade CAI. J√°, no construcionismo de Papert

existe uma invers√£o, ou seja, √© o disc√≠pulo que passa a ensinar ao computador a cumprir

uma determinada tarefa a partir de uma postura ativa do mesmo. Isso √© alcan√ßado atrav√©s

de um software, que em nosso estudo √© o Processing. Nota-se ainda que em ambos os casos,

2Logo √© uma linguagem de programa√ß√£o voltada para o ambiente educacional que foi desenvolvido na
d√©cada de 60 no MIT (Massachussets Institute of Tecnology), em Cambridge, Massachussets, Estados
Unidos. Este software potencializa os docentes a trabalharem com os conte√∫dos de todas as √°reas do
conhecimento e n√≠veis de escolaridade com o objetivo de retirar o aluno da passividade diante de um
computador [18, 19].

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

27

a figura do professor mediador √© fundamental para o processo de aprendizagem.

Constatou-se que os princ√≠pios de Seymour Papert foram bastante difundidos e

defendidos por diversos pa√≠ses durante os anos 80 e in√≠cio dos anos 90 como sendo o

caminho para uma transforma√ß√£o absoluta na escola a partir da pr√≥pria linguagem LOGO.

Entretanto, tal transforma√ß√£o n√£o ocorreu na concep√ß√£o de Valente [10] em fun√ß√£o dos

diversos fatores, tais como a qualifica√ß√£o ineficaz dos professores.

O processo de incorpora√ß√£o dos computadores na educa√ß√£o, nos Estados Unidos,

aconteceu de forma descentralizada e sem a interfer√™ncia das a√ß√µes governamentais at√©

fazer parte do curr√≠culo a partir de 2000. No entanto, em outros pa√≠ses, como a Fran√ßa,

Portugal e Brasil, a inser√ß√£o desse recurso na educa√ß√£o aconteceu com a participa√ß√£o

do sistema p√∫blico que se articulou com as universidades para avaliar de que forma a

integra√ß√£o dessa TIC aconteceria em todos os n√≠veis do ensino [17].

A Fran√ßa foi o primeiro pa√≠s ocidental que preocupou-se imediatamente com a

forma√ß√£o de professores na incorpora√ß√£o da inform√°tica na educa√ß√£o al√©m de estabele-

cer o p√∫blico-alvo, materiais, software, meios de distribui√ß√£o, instala√ß√£o e manuten√ß√£o

dos equipamentos nas escolas, por considerar imperativo para uma inser√ß√£o plena desse

recurso educacional implantado na d√©cada de 70. At√©, ent√£o, os softwares utilizados

caracterizavam-se como EAO (Enseignemente Assist√© par Ordinateur), equivalente ao

CAI americano. Tais softwares eram programados com base na teoria comportamenta-

lista e no condicionamento instrumental (est√≠mulo-resposta). Contudo, na d√©cada seguinte

passaram a utilizar a linguagem de programa√ß√£o e metodologia LOGO nos seus estudos

com base nas ideias de Seymour Papert, o que se contrap√≥s √†s bases conceituais do EAO

[10, 11, 20, 19].

Desde 1985, a Fran√ßa preestabeleceu no seu plano nacional Informatique pour
Tous 3 a disciplina de inform√°tica de car√°ter obrigat√≥rio e com orienta√ß√£o para o aluno

ser ativo durante o processo de ensino-aprendizagem. E com o intuito de prevalecer esse

princ√≠pio a sua reformula√ß√£o em 2006 manteve esse ideal [17].

Apesar dos in√∫meros projetos de inform√°tica na educa√ß√£o, a Fran√ßa, de acordo com

Valente [10] n√£o conseguiu obter √™xito e nem provocar mudan√ßas no sentido de romper o

h√°bito milenar da educa√ß√£o do falar/ditar dos professores. Para L√©vy [21, p. 5] uma das

causas do insucesso esta no seguinte fato: ‚ÄúO governo escolheu material da pior qualidade,

perpetuamente defeituoso, fracamente interativo, pouco adequado aos usos pedag√≥gicos‚Äù.

J√°, Portugal iniciou o uso pedag√≥gico do computador atrav√©s do Projeto para a

3‚ÄúInform√°tica para Todos‚Äù

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

28

Introdu√ß√£o das Novas Tecnologias no Sistema Educativo mais conhecido como Relat√≥rio
CARMONA que culminou com a implementa√ß√£o do projeto MINERVA4, lan√ßado em 1985,

com o objetivo de introduzir a inform√°tica no ensino n√£o superior de forma racionalizada

para valorizar ativamente o sistema educacional em todas as inst√¢ncias e que permitisse

uma din√¢mica constante de avalia√ß√µes e atualiza√ß√µes de solu√ß√µes. A principal meta do

projeto estava em preparar as escolas ao mesmo tempo que favorecia com a forma√ß√£o

continuada de orientadores e professores para o uso da inform√°tica no ensino. A partir

desse projeto foram desenvolvidos centros de pesquisa e forma√ß√£o de profissionais na √°rea

que contribuem para a inser√ß√£o da computa√ß√£o no ensino das escolas de Portugal [17, 19].

A partir da amplia√ß√£o do projeto Minerva, em 1996, foi criado o Programa N√ìNIO

‚Äì S√©culo XXI ‚Äì Programa de Tecnologias da Informa√ß√£o e da Comunica√ß√£o na Educa√ß√£o,

cujo nome foi em homenagem ao pr√≥prio inventor desse instrumento de medida de alta

precis√£o, o matem√°tico, ge√≥grafo e pedagogo portugu√™s Pedro Nunes (1502-1578). Com o

intuito de implementar esse Programa foram criados uma rede de Centros de Compet√™ncia

distribu√≠dos pelo pa√≠s em institui√ß√µes de ensino superior e em outras organiza√ß√µes educa-

cionais para apoiar, orientar, acompanhar e avaliar os projetos das escolas nas dimens√µes

t√©cnica, te√≥rico-pr√°tica e organizacional, onde possu√≠am indica√ß√£o das escolas ao propor

seus projetos ao Minist√©rio da Educa√ß√£o [17]. Para Almeida [17] e Lemos Junior [19], um

dos pontos de atua√ß√£o dos Centros de Compet√™ncia (o da Universidade do Minho) que

mais se destacaram dentro do Programa N√ìNIO foram o empenho e a dedica√ß√£o dos pro-

fessores e, o interesse e entusiasmo dos alunos confirmando com isso que a integra√ß√£o das

TIC‚Äôs no ensino assumiu o papel de catalisadora de mudan√ßas na implementa√ß√£o de novas

alternativas √† educa√ß√£o e √† pr√°tica pedag√≥gica dos professores perfeitamente envolvidos

no projeto e, especificamente, na mudan√ßa de atitude dos alunos ao incorporar as TIC no

processo de aprendizagem e constru√ß√£o de conhecimentos, tanto na aula formal como nas

situa√ß√µes de estudo individual e no desenvolvimento de seus trabalhos.

Portugal promoveu ainda em 2007 o Plano Tecnol√≥gico da Educa√ß√£o que represen-

tava uma proposta do governo para garantir o acesso ao computador port√°til e √† Internet

banda larga orientada a professores do ensino b√°sico e secund√°rio, atual ensino fundamen-

tal e m√©dio, com o objetivo de auxiliar os professores no uso individualizado e profissional

das TIC‚Äôs.

Os primeiros passos para a inser√ß√£o da tecnologia digital no sistema educacional

brasileiro aconteceu durante a d√©cada de 70 de forma similar ao ocorrido em Portugal

e na Fran√ßa. Com o intuito de construir uma ind√∫stria pr√≥pria, o governo brasileiro

4Meios Inform√°ticos na Educa√ß√£o: Racionalizar, Valorizar, Atualizar

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

29

criou a Comiss√£o Coordenadora das Atividades de Processamento Eletr√¥nico (CAPRE),

a Empresa Digital Brasileira (DIGIBR√ÅS) e tamb√©m a Secret√°ria Especial de Inform√°tica

(SEI), que nasceu como org√£o executivo do Conselho de Seguran√ßa Nacional da Presid√™n-

cia da Rep√∫blica que at√© ent√£o era a ditadura militar [20]. Segundo Almeida [17] e Valente

[10], foram realizados diversos semin√°rios nacionais por decis√£o do governo federal e com

a participa√ß√£o da comunidade cient√≠fica da √©poca. Dessa forma, as pol√≠ticas de imple-

menta√ß√£o e desenvolvimento da inform√°tica na educa√ß√£o deixou de ser produto apenas

das decis√µes governamentais como ocorria na Fran√ßa e nem reflexo imediato do mercado

como aconteceu nos Estados Unidos, ou seja, as delibera√ß√µes e as propostas passaram a

serem frutos de discuss√µes e propostas feitas pela comunidade de t√©cnicos e pesquisadores

da √°rea baseada nas pr√≥prias pesquisas concretizadas entre as universidades e escolas da

rede p√∫blica. Com isso, a fun√ß√£o do MEC passou a ser, desde ent√£o, a de acompanhar,

viabilizar e implementar tais decis√µes.

A primeira institui√ß√£o de ensino superior a utilizar o computador na educa√ß√£o foi

a Universidade Federal do Rio de Janeiro (UFRJ), no in√≠cio da d√©cada de 70, com o

intuito de realizar simula√ß√µes de rea√ß√µes qu√≠micas em cursos de p√≥s-gradua√ß√£o de Qu√≠-

mica. J√° em 1976 um grupo de pesquisadores da UNICAMP (Universidade Estadual de

Campinas) resolveu visitar o Mit Media Lab, cujo retorno viabilizou a cria√ß√£o do grupo

interdisciplinar formado por especialistas nas √°reas de computa√ß√£o, lingu√≠stica e psicolo-

gia educacional que alavancou as primeiras investiga√ß√µes sobre o uso do computador na

educa√ß√£o com a linguagem LOGO impulsionando o movimento [20, 17]. A UNICAMP

ainda foi respons√°vel pela introdu√ß√£o da linguagem de programa√ß√£o BASIC no sistema

educacional [19].

O MEC e a SEI juntamente com o Conselho Nacional de Desenvolvimento Cient√≠-

fico e Tecnol√≥gico (CNPq) realizaram o ‚ÄúI Semin√°rio Nacional de Inform√°tica na Educa-

√ß√£o‚Äù, em Bras√≠lia no ano de 1981, com o intuito de discutir a conveni√™ncia ou n√£o de se

utilizar o computador como instrumento auxiliar no processo ensino-aprendizagem. No

ano seguinte, a Universidade Federal da Bahia (UFBA) tra√ßou uma linha pol√≠tica para

implementar a inform√°tica na educa√ß√£o. Desses semin√°rios surgiu o projeto EDUCOM,

em 1983, implantado no √¢mbito da SEI com uma proposta de trabalho interdisciplinar

destinado a cria√ß√£o de centros-piloto nas universidades brasileiras como instrumentos re-

levantes para a informatiza√ß√£o da sociedade, objetivando a capacita√ß√£o nacional e uma

futura pol√≠tica setorial, compete aqui informar que as universidades brasileiras pioneiras

nesse processo foram a UFRJ, a UNICAMP e a UFRGS (Universidade Federal do Rio

Grande do Sul)[20, 22].

1.1 Hist√≥ria da Computa√ß√£o na Educa√ß√£o

30

Para viabilizar o projeto EDUCOM foram estabelecidas as seguintes propostas, de

acordo com Gon√ßalves [20, p. 13]:

‚àö

‚àö

‚àö

‚àö

Sensibilizar e capacitar professores de 1o grau, interessados em uma
pr√°tica pedag√≥gica atrav√©s do uso de computadores;

Facilitar a divulga√ß√£o de pesquisas e trabalhos realizados junto √†s
comunidades de ensino de 2o e 3o graus [. . .];

Divulgar t√©cnicas e software educacionais necess√°rios ao desenvol-
vimento de programas de ensino [. . .] para escolas, universidades e
empresas interessadas;

Estimular o desenvolvimento de teses, trabalhos e est√°gios na √°rea;

Valente [10] afirma ainda que o papel do computador na educa√ß√£o √© o de provocar

as mudan√ßas pedag√≥gicas necess√°rias, inv√©s de ‚Äúautomatizar o ensino‚Äù ou mesmo preparar

o aluno para ser capaz de trabalhar com a inform√°tica. Dessa forma, o grande desafio

estava na mudan√ßa da abordagem educacional, ou seja, transformar a educa√ß√£o centrada

no aluno, na transforma√ß√£o da informa√ß√£o em uma educa√ß√£o onde o aluno possa realizar

atividades por interm√©dio do computador e, consequentemente, aprender.

Para cumprir as propostas de uso pedag√≥gico do computador nas escolas, o MEC

criou o projeto FORMAR, em 1987, coordenado pela UNICAMP. Tal projeto contava com

a participa√ß√£o dos pesquisadores e especialistas dos demais centros-piloto integrantes do

projeto EDUCOM e o principal objetivo do programa estava no desenvolvimento de cursos

de especializa√ß√£o na √°rea de inform√°tica educativa para atuarem nos sistemas p√∫blicos de

educa√ß√£o e assim se tornarem multiplicadores na forma√ß√£o de outros docentes em suas

institui√ß√µes de origem ao finalizar o curso. Contudo, apesar dos cursos contarem com os

aplicativos CAI, linguagem de programa√ß√£o LOGO e outros programas b√°sicos, o projeto

FORMAR n√£o teve muitos avan√ßos no sentido de incorporar o computador nas atividades

de sala de aula.

O MEC resolveu implementar, em 1989, o projeto PRONINFE (Programa Nacional

de Inform√°tica na Educa√ß√£o) fundamentado nas ideias de Seymour Papert, ou seja, na

teoria construcionista e em Paulo Freire com a pr√°tica da pedagogia cr√≠tico-reflexiva. A

principal finalidade desse projeto consistia no desenvolvimento da Inform√°tica Educativa

no Brasil, atrav√©s de projetos e atividades amparados em fundamenta√ß√£o pedag√≥gica

s√≥lida e atualizada. Tal programa tornou-se o principal referencial das a√ß√µes atualmente

planejadas pelo MEC que perdurou mais de uma d√©cada at√© o surgimento do Programa

Nacional de Tecnologia Educacional (PROINFO), em 1997, com maior abrang√™ncia a n√≠vel
nacional. No entanto, tal nomenclatura, PROINFO, s√≥ foi adotada atrav√©s do Decreto no

6.300, de 12 de dezembro de 2007 para atender a finalidade de incorporar o uso de todas as

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

31

m√≠dias tecnol√≥gicas de informa√ß√£o e comunica√ß√£o nas redes p√∫blicas de educa√ß√£o b√°sica;

melhorar a qualidade do processo de ensino e aprendizagem; proporcionar uma educa√ß√£o

voltada para o desenvolvimento cient√≠fico e tecnol√≥gico, e educar para uma cidadania

global em uma sociedade tecnologicamente desenvolvida.

Salienta-se que tais mudan√ßas pedag√≥gicas foram o objetivo de todas as a√ß√µes dos

projetos de inform√°tica na educa√ß√£o. Todavia, os resultados obtidos n√£o foram suficientes

para sensibilizar ou alterar o sistema educacional como um todo at√© o presente momento.

Mesmo fornecendo computadores port√°teis aos alunos da rede p√∫blica de ensino e o ofe-

recimento de cursos para a forma√ß√£o de professores mediante projetos escolares atrav√©s

do projeto Um Computador por Aluno (UCA), o uso de tablets, distribui√ß√£o dos equipa-

mentos tecnol√≥gicos nas escolas, recursos multim√≠dia e digitais como a√ß√£o do PROINFO.

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

√â not√≥rio que cada civiliza√ß√£o ao longo da hist√≥ria possu√≠a um tipo de linguagem

diferente, assim como, cada pa√≠s tem seu idioma que lhes permitem comunicar-se entre

si. Com o computador n√£o seria diferente, foi desenvolvido uma linguagem espec√≠fica que

programa os computadores para executarem uma determinada ordem, geralmente atrav√©s

de algoritmos. No entanto, a pr√≥pria hist√≥ria nos revela que o povo da babil√¥nia j√° possu√≠a

uma linguagem natural para escrever seus algoritmos e estes descreviam situa√ß√µes da vida

cotidiana sem recorrer ao uso de vari√°veis. Desta forma, falar na evolu√ß√£o da linguagem

de programa√ß√£o √© analisar as contribui√ß√µes do per√≠odo da pr√©-hist√≥ria das linguagens, as

primeiras linguagens e os paradigmas da programa√ß√£o com suas principais linguagens.

1.2.1 Pr√©-hist√≥ria da Linguagem de Programa√ß√£o

A hist√≥ria nos revela que Euclides de Alexandria (330‚Äì227 a.C.) se destacou n√£o

s√≥ por sua obra ‚Äúos Elementos‚Äù, esse matem√°tico estruturou de forma sistem√°tica o saber

geom√©trico, implementando as ideias sobre axiomatiza√ß√£o, de Arist√≥teles, para uma ci-

√™ncia exata [23]. Dentre as contribui√ß√µes encontradas nessa obra encontra-se o algoritmo

para calcular o MDC (M√°ximo Divisor Comum), ou simplesmente, algoritmo de Euclides

que apareceu no livro VII com uma interpreta√ß√£o geom√©trica definida pela determina√ß√£o

da maior medida comum entre dois segmentos de reta [24]. De acordo com esta ideia

de Euclides o aluno n√£o precisaria recorrer a decomposi√ß√£o em fatores primos, utilizando

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

32

a interpreta√ß√£o geom√©trica do MDC do algoritmo de Euclides como segue no seu livro,
conseguir√≠amos introduzir inclusive de forma pr√°tica este conte√∫do nas turmas de 6o ano

do ensino fundamental.

Proposi√ß√£o 1.1 (MDC de Euclides). Sendo dados dois n√∫meros n√£o primos entre si,

achar a maior medida comum deles [24, p. 271].

De acordo com esta proposi√ß√£o, dados dois segmentos AB e CD representando

dois n√∫meros n√£o primos entre si, respectivamente, e diferentes de zero, existe um terceiro

segmento EF que cabe um n√∫mero inteiro de vezes nos outros dois segmentos, isto √©, o

segmento EF mensura os segmentos AB e CD, conforme podemos observar na Figura 2.

Um exemplo pr√°tico que expl√≠cita a ideia do algoritmo de Euclides pode ser obtido

determinando o MDC entre 345 e 253. Como 253 n√£o divide 345, ent√£o determinamos a

diferen√ßa entre o maior n√∫mero e o menor, e se o resultado n√£o dividir o menor, ent√£o

repetimos o procedimento at√© obtermos um resto que divida todos os restos antecedentes

e os n√∫meros 253 e 345. Sendo assim, temos:

345 ‚àí 253 = 92 =‚áí 253 ‚àí 92 = 161 =‚áí 161 ‚àí 92 = 69 =‚áí 92 ‚àí 69 = 23

Como o n√∫mero 23 divide os restos 69, 92 e 161 e, os n√∫meros 253 e 345, ent√£o o

n√∫mero 23 √© o mdc entre 345 e 253. Tal concep√ß√£o √© encontrada segundo Oliveira [25],

no livro Hist√≥ria da Matem√°tica, de Carl Boyer, na p√°gina 84, quando faz refer√™ncia ao

livro Elementos de Euclides e √© apresentado da seguinte forma:

Dados dois n√∫meros diferentes, subtrai-se o menor ùëé do maior ùëè repeti-
damente at√© que se obtenha um resto ùëü1 menor do que o menor n√∫mero;
ent√£o subtrai-se repetidamente esse resto ùëü1 de ùëé at√© resultar um resto
ùëü2 menor do que ùëü1 ent√£o subtrai-se repetidamente ùëü2 de ùëü1 e assim por
diante, finalmente, o processo leva a um resto ùëüùëõ que mede ùëüùëõ‚àí1, por-
tanto todos os restos precedentes, bem como ùëé e ùëè; esse n√∫mero ùëüùëõ ser√°
o m√°ximo divisor comum de ùëé e ùëè.

Existe tamb√©m outra forma de exemplificar geometricamente esta situa√ß√£o que

√© construindo um ret√¢ngulo de medidas 345 e 253 (Figura 3). O objetivo √© dividir o

ret√¢ngulo em quadrados iguais, com o maior lado poss√≠vel, conforme a figura mostra.

Para isso, dividi-se as medidas do lado maior pelo lado menor, a parte inteira determina

o n√∫mero de quadrados com lado igual ao menor. A medida restante √© utilizada em nova

divis√£o do menor lado com o residual anterior para obter novos quadrados e, assim por

diante, quando a divis√£o em quadrados for exata, isto √©, n√£o sobrar nenhum ret√¢ngulo,

ent√£o a dimens√£o do menor quadrado ser√° o MDC entre 345 e 253, que ainda √© 23.

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

33

Figura 2: Segmentos de reta para o algoritmo
de Euclides

Figura 3: MDC de Euclides no ret√£ngulo

Atrav√©s da programa√ß√£o o aluno poder√° desenvolver um aplicativo que execute

estes procedimentos √™nuplas vezes at√© obter o MDC. Sem falar que tal concep√ß√£o impul-

sionou muitos avan√ßos na pr√≥pria linguagem de programa√ß√£o.

Salienta-se ainda que Abu Ja‚Äôfar Muhammad Ibn Musa Al‚ÄôKhwarizmi (780‚Äì850),

matem√°tico e astr√¥nomo persa, trouxe grandes avan√ßos para a matem√°tica e para a pro-

grama√ß√£o de computadores com a descoberta do sistema de numera√ß√£o decimal e seus dez

s√≠mbolos intitulados atualmente como algarismos indo-ar√°bicos que acabou por influenciar

fortemente a matem√°tica na Europa Medieval.

Muitos outros matem√°ticos influenciaram ao longo da hist√≥ria, no entanto, foi

atrav√©s da L√≥gica Moderna iniciada no s√©culo XVII com o fil√≥sofo e matem√°tico alem√£o

Gottfried Wilhelm Leibniz (1646‚Äì1716) que influenciou, mesmo ap√≥s 200 anos, v√°rios

ramos da L√≥gica Matem√°tica Moderna e outras √°reas relacionadas, como a Cibern√©tica

desenvolvida por Norbert Wiener. Com o ambicioso programa para a L√≥gica, Leibniz

influenciou seus contempor√¢neos e sucessores, que visava criar uma linguagem universal

baseada em um alfabeto do pensamento ou characteristica universalis, uma esp√©cie de c√°l-

culo universal para o racioc√≠nio. Na concep√ß√£o desse matem√°tico, tal linguagem universal
deveria ser como a √Ålgebra ou como uma vers√£o dos ideogramas chineses5 [23].

Apesar dos suscet√≠veis erros que a calculadora de Leibniz possu√≠a, sua inven√ß√£o foi

de fundamental import√¢ncia para a hist√≥ria da programa√ß√£o por introduzir o conceito de

operacionalizar as multiplica√ß√µes e divis√µes atrav√©s das adi√ß√µes e subtra√ß√µes sucessivas,

ou seja, sua m√°quina era capaz de realizar as 4 opera√ß√µes b√°sicas.

Os ideais de Leibniz a respeito das m√°quinas para liberar o homem das tarefas re-

petitivas e de simples execu√ß√£o foi quase implantada pelo matem√°tico e astr√¥nomo ingl√™s

5Os ideogramas chineses s√£o uma cole√ß√£o de sinais b√°sicos que padronizassem no√ß√µes simples n√£o

anal√≠ticas.

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

34

Charles Babbage (1792‚Äì1871), apreciado exclusivamente como um dos grandes desbrava-

dores da era dos computadores. Esse matem√°tico projetou, em 1822, um mecanismo feito

de madeira e lat√£o que alteraria a hist√≥ria por elaborar um dispositivo mec√¢nico capaz de

executar uma s√©rie de c√°lculos, no entanto, sua constru√ß√£o n√£o foi efetivada por limita√ß√µes

tecnol√≥gicas da √©poca.

Ressalta-se que o Analitical Engine, a M√°quina Anal√≠tica ‚Äì denomina√ß√£o da in-

ven√ß√£o de Charles Babbage ‚Äì aproximava conceitualmente do atual computador. E por

considerar de fundamental import√¢ncia a impress√£o dos resultados, Charles ponderou que

os resultados finais e os intermedi√°rios fossem impressos com o intuito de evitar erros,

sendo necess√°rio para isso dispositivos de entrada e sa√≠da. Segundo Fonseca [23], a en-

trada de dados na m√°quina seria feito por tr√™s tipos de cart√µes, s√£o eles:

‚Äúcart√µes de

n√∫meros‚Äù respons√°vel por apresentar os n√∫meros das constantes de um problema; ‚Äúcar-

t√µes diretivos‚Äù para controlar a movimenta√ß√£o dos n√∫meros na m√°quina; e os ‚Äúcart√µes

de opera√ß√£o‚Äù para comandar a realiza√ß√£o das opera√ß√µes tais como adi√ß√µes, subtra√ß√µes e

outras. Contudo, o mais impressionante na sua m√°quina estava nas duas inova√ß√µes que

trariam um grande impacto, tais inova√ß√µes contou com a participa√ß√£o de Ada Augusta
Byron6, condessa de Lovelace. A primeira inova√ß√£o estava no conceito de ‚Äútransfer√™ncia

de controle‚Äù que permitiria √† m√°quina comparar quantidades e, a depender dos resulta-

dos da compara√ß√£o, poderia desviar para outra instru√ß√£o ou sequ√™ncia de instru√ß√µes. A

outra caracter√≠stica constava na possibilidade dos resultados calculados alterarem outros

n√∫meros e instru√ß√µes colocadas na m√°quina, viabilizando com isso que o ‚Äúcomputador‚Äù

modificasse seu pr√≥prio sistema.

A inspira√ß√£o de Babbage adv√©m do franc√™s Joseph-Mariae Jacquard (1752‚Äì1824)

que introduziu o conceito de armazenamento de informa√ß√µes em placas perfuradas, para

controlar uma m√°quina de tecelagem com o intuito de substituir o trabalho humano. O

funcionamento dessa m√°quina de tecelagem atrav√©s dos cart√µes perfurados determinava

como a fiandeira deveria executar seu tra√ßado, passando a linha por cima ou por baixo,

quando repetir o processo, entre outros modelos de tra√ßados. Dessa forma, a M√°quina

Anal√≠tica de Babbage poderia ser considerada como uma adapta√ß√£o do tear de Jacquard,

j√° que a mesma processava padr√µes alg√©bricos da mesma maneira que o tear processava

padr√µes de desenhos.

6Filha do famoso poeta Lord Byron e educada pelo matem√°tico logicista ingl√™s Augustus De Morgan.
Ao ser apresentada a Babbage durante a primeira demonstra√ß√£o da M√°quina de Diferen√ßas percebeu o
potencial alcance das novas inven√ß√µes e passou a contribuir ativamente em seus trabalhos e por causa disso
√© considerada a primeira efetiva programadora de computadores, mesmo um s√©culo antes da exist√™ncia
do mesmo.

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

35

Em 1935, finalmente o computador passou por uma revolu√ß√£o, quando Alan Mathi-

son Turing (1912‚Äì1954) tomou conhecimento do Entscheidungsproblem de Hilbert durante

um curso ministrado pelo ent√£o matem√°tico Max Neumann. Naquele momento Turing

ainda era estudante do King‚Äôs College, em Cambridge, e os resultados de G√∂del e do pro-

blema da decis√£o motivaram-no inicialmente para a caracteriza√ß√£o de quais fun√ß√µes s√£o
capazes de serem computadas7. A esse conjunto de esfor√ßos originou-se a fundamenta√ß√£o

te√≥rica da chamada ‚ÄúCi√™ncia da Computa√ß√£o‚Äù.

Turing definiu que os c√°lculos mentais consistem em opera√ß√µes para transformar

n√∫meros em uma s√©rie de estados intermedi√°rios que progridem de um para o outro de

acordo com um conjunto limitado de regras, at√© que a resposta seja encontrada. Dessa

forma, Turing concluiu que as regras matem√°ticas exigem defini√ß√µes mais r√≠gidas do que

as discuss√µes no campo da metaf√≠sica sobre a mente humana e, a partir da√≠ concentrou-se

nesses estados objetivando utilizar para comandar as opera√ß√µes da m√°quina. Por causa

de suas ideias, o governo ingl√™s, em 1940, convocou-o para decifrar as mensagens codifi-

cadas pelo inimigo, a Alemanha, atrav√©s de sua atua√ß√£o na Escola de Cifras e C√≥digos.

Quando a Segunda Guerra Mundial terminou sua contribui√ß√£o tinha ajudado a construir

um computador, o Colossus, uma m√°quina completamente eletr√≤nica com 1.500 v√°lvulas

que moviam-se muito mais r√°pido do que a m√°quina Enigma da Alemanha [23].

O interesse de Turing pela programa√ß√£o das opera√ß√µes de um computador ‚Äì cha-

mada atualmente de codifica√ß√£o ‚Äì contribuiu para a cria√ß√£o de linguagens de programa√ß√£o

avan√ßadas para o hardware do per√≠odo. Para Turing, as m√°quinas poderiam modificar

suas pr√≥prias opera√ß√µes a partir da elabora√ß√£o de tabelas de instru√ß√µes que convertem

automaticamente a escrita decimal em d√≠gitos bin√°rios para serem lidos pelas m√°quinas

inicialmente constru√≠das nas ideias da √°lgebra booleana. Na concep√ß√£o desse matem√°tico,

os futuros programadores trabalhariam com linguagens consideradas atualmente como de

alto n√≠vel. Nas palavras do pr√≥prio Turing apresentada por Rheingold em Fonseca [23]:

As tabelas de instru√ß√µes dever√£o ser feitas por matem√°ticos com expe-
ri√™ncia em computadores e certa habilidade em resolver problemas de
solu√ß√£o mais dif√≠cil. Haver√° bastante trabalho deste tipo a ser feito, se
todo os processos conhecidos tiverem de ser convertidos na forma de ta-
belas de instru√ß√µes em determinado momento. Esta tarefa seguir√° para-
lelamente √† constru√ß√£o da m√°quina, para evitar demoras entre o t√©rmino
desta e a produ√ß√£o de resultados. Poder√£o ocorrer atrasos, devido a vir-
tuais obst√°culos desconhecidos, at√© o ponto em que seja melhor deixar

7Os matem√°ticos da √©poca buscavam um novo tipo de c√°lculo l√≥gico que viabilizasse entre outras
coisas, colocar em uma base matem√°tica segura o conceito heur√≠stico do que seja proceder a um c√¥mputo.
Tal resultado era importante para a matem√°tica por determinar se √© poss√≠vel haver um procedimento
efetivo para se solucionar os problemas de uma determinada classe bem definida[23].

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

36

os obst√°culos l√° do que gastar tempo em projetar algo sem problemas
(quantas d√©cadas estas coisas levar√£o?). Este processo de elabora√ß√£o de
tabelas de instru√ß√µes ser√° fascinante.

Compete neste trecho validar a import√¢ncia da √°lgebra booleana desenvolvida pelo

matem√°tico ingl√™s George Boole (1815‚Äì1864), o fundador da L√≥gica Simb√≥lica. Boole con-

seguiu desenvolver o primeiro sistema formal para o racioc√≠nio l√≥gico aplicando-o inclusive

em diversos situa√ß√µes do c√°lculo formal e opera√ß√µes com regras formais sem considerar

as no√ß√µes primitivas. A sua contribui√ß√£o foi marcante para a hist√≥ria da computa√ß√£o,

tanto que sem ele, o caminho que interligou a L√≥gica √† Matem√°tica demoraria muito a ser

constru√≠do. No que tange √† Computa√ß√£o, a M√°quina Anal√≠tica de Babbage seria apenas

uma tentativa inspiradora, enquanto, sua √°lgebra booleana foi fundamental para que a

tecnologia computacional chegasse com facilidade at√© a velocidade da eletr√¥nica [23].

Na computa√ß√£o, seu ideal de um sistema matem√°tico fundamentado apenas em

duas quantidades, o ‚ÄòUniverso‚Äô e o ‚ÄòNada‚Äô, indicados por ‚Äò1‚Äô e ‚Äò0‚Äô, respectivamente, con-

duziu sua inven√ß√£o do sistema de dois estados para a quantifica√ß√£o l√≥gica que viabilizou

a constru√ß√£o do primeiro computador, uma vez que seus construtores entenderam que

o sistema com apenas dois valores seriam suficientes para compor os mecanismos para

perfazer os c√°lculos. No entanto, somente ap√≥s o desenvolvimento de quantificadores,

introduzidos por Charles Sanders Peirce (1839‚Äì1914), que a l√≥gica booleana parou de

se limitar ao racioc√≠nio proposicional e passou a ter uma l√≥gica formal aplicada ao ra-

cioc√≠nio matem√°tico geral. A partir da implementa√ß√£o da L√≥gica √† Matem√°tica e dos

avan√ßos tecnol√≥gicos impulsionados pelas descobertas da √©poca muitas outras linguagens

de programa√ß√£o surgiram, juntamente com a evolu√ß√£o do computador.

1.2.2 Primeiras Linguagens de Programa√ß√£o

Os primeiros computadores mec√¢nicos e eletromec√¢nicos que surgiram a partir da

d√©cada de 1930 estavam fundamentados na estrutura imaginada por Babbage que j√° po-

deria ser viabilizada pela tecnologia da √©poca. Al√©m desses computadores, muitos outros

projetos de computadores eletr√¥nicos concretizados posteriormente sofreram influ√™ncias

dessas primeiras m√°quinas. Contudo, foi Konrad Zuse (1910‚Äì1995) que desenvolveu a pri-

meira m√°quina de c√°lculo controlada automaticamente. Na vis√£o desse engenheiro civil,

um dos aspectos mais onerosos ao se realizar longos c√°lculos com dispositivos mec√¢nicos

constava em guardar resultados intermedi√°rios para depois utiliz√°-los nos lugares dese-

jados para os passos seguintes. De acordo com o pensamento de Zuse, em 1934, uma

calculadora autom√°tica s√≥ necessita de tr√™s unidades b√°sicas, s√£o elas: uma controladora,

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

37

uma mem√≥ria e um dispositivo de c√°lculo para a aritm√©tica. A partir desse pensamento

desenvolveu o Z1, em 1936, um computador constru√≠do inteiramente com pe√ßas mec√¢nicas

e uma fita de pel√≠cula cinematogr√°fica para as instru√ß√µes controlarem a m√°quina.

Depois do computador Z1, Zuse chegou a desenvolver os computadores Z2, Z3 e

Z4. No entanto, assim que salvou o Z4 de um bombardeio e mudou-se para a pequena vila

Hintesrtein nos Alpes, Zuse percebeu que n√£o existia uma nota√ß√£o formal para a descri√ß√£o

de algoritmos e come√ßou a desenvolver uma linguagem chamada de Plankalk√ºl (program

calculus). Essa linguagem consistia numa extens√£o do c√°lculo proposional e de predicado

de Hilbert. Na vis√£o de Zuse, o Plankalk√ºl tinha como miss√£o fornecer uma descri√ß√£o

formal pura de qualquer procedimento computacional. Contudo, tal linguaguem de pro-

grama√ß√£o n√£o perdurou muito por n√£o apresentar uma sintaxe amig√°vel para expressar

programas em um formato leg√≠vel e facilmente edit√°vel apesar de possuir conceitos funda-

mentais para a programa√ß√£o: tipos de dados, estrutura de dados hier√°rquicos, atribui√ß√£o,

itera√ß√£o, entre outros.

Salienta-se que depois do Teorema de G√∂del e do projeto de Hilbert foi poss√≠vel

caracterizar o termo efetivamente comput√°vel atrav√©s da m√°quina de Turing. Ou seja,

foi poss√≠vel tornar claro o que vem a ser um procedimento efetivo e um problema compu-

t√°vel. Para Fonseca [23], um procedimento efetivo √© uma sequ√™ncia finita de instru√ß√µes

que podem ser executadas por um agente computacional, seja ele humano ou n√£o. Tais

propriedades apresentadas s√£o:

I. A descri√ß√£o deve ser finita;

II. Parte de um certo n√∫mero de dados, pertencente a conjuntos espec√≠ficos de objetos,

e espera-se que produza um certo n√∫mero de resultados que mantenham rela√ß√£o

espec√≠fica com os dados;

III. Sup√µe-se que exista um agente computacional (humano, eletr√¥nico, mec√¢nico, entre

outros) que execute as instru√ß√µes do procedimento;

IV. Cada instru√ß√£o deve ser bem definida;

V. As instru√ß√µes devem ser t√£o simples que poderiam ser executadas por algu√©m usando

l√°pis e papel, em um espa√ßo de tempo finito.

A esse procedimento efetivo d√°-se o nome de algoritmo. Ou seja, o algoritmo8

√© uma sequ√™ncia finita de passos para resolver um determinado problema. Cada des-

8Instru√ß√µes no campo de entrada do programa

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

38

cri√ß√£o finita do algoritmo √© realizada por uma determinada linguagem, essa linguagem

algor√≠tmica pertence a um subconjunto n√£o amb√≠guo de uma linguagem natural, como o

Franc√™s, o Ingl√™s ou Chin√™s, ou uma linguagem artificial constru√≠da para tal fim, como as
linguagens de programa√ß√£o9. A forma ou formato desses procedimentos efetivos em uma

linguagem algor√≠tmica qualquer √© espec√≠fica de um conjunto de regras conhecido como

regras de sintaxe, cujas propriedades foram enumeradas anteriormente.

Essa sintaxe corresponde a escrita correta e o relacionamento entre os s√≠mbolos e

frases apresentadas nesses programas. Para alguns autores, segundo Fonseca [23], essas

regras se dividem em concreta e abstrata. Sendo que a concreta abarca: o reconhecimento

de textos (sequ√™ncias de caracteres) coerentemente escritos de acordo com as especifica√ß√µes

da linguagem e; a coloca√ß√£o dos textos, de forma n√£o imprecisa, no interior das frases

que concebe o programa. Enquanto, a sintaxe abstrata molda as estruturas de frases

do programa. Consequentemente, a sintaxe define √† forma dos programas executarem,

de modo que as express√µes, os comandos e as declara√ß√µes possam ser sobrepostos para

compor um programa. Dessa forma, a linguagem de programa√ß√£o passa a ter uma nota√ß√£o

formal para a descri√ß√£o de um algoritmo, sem as ambiguidades e as variabilidades de

uma linguagem natural, que viabilize o rigor nas defini√ß√µes e demonstra√ß√µes sobre os
procedimentos. Al√©m desses itens, a linguagem de programa√ß√£o precisa ser universal10 e
possuir uma sem√¢ntica11.

Diversos autores apresentam a linguagem de programa√ß√£o dividida de diferentes

formas para classifica-las ao longo da hist√≥ria conhecidas como paradigmas de programa-

√ß√£o. Dentre elas evidencia-se a divis√£o dentro da seguinte taxonomia apresentada por

Gudwin [26]:

‚ãÜ Linguagens de Baixo N√≠vel

‚ãÜ Linguagens N√£o-Estruturadas

‚ãÜ Linguagens Procedurais

‚ãÜ Linguagens Funcionais

9Assembly, Fortran, Lisp, Algol, Cobol, Basic, Logo, Pascal, Forth, C, Smalltalk, SQL, Ada, C++,

Perl, Java, Python, Ruby, JavaScript, PHP, Delphi, C#, VB.NET, entre outros ao longo da hist√≥ria.

10A linguagem √© universal quando qualquer problema cuja solu√ß√£o possa ser encontrada atrav√©s de um

computador, ou seja, √© qualquer linguagem que possa ser definida por uma fun√ß√£o recursiva

11A sem√¢ntica depende exclusivamente do efeito que se deseja causar quando o programa for executado
por uma agente computacional, eletr√¥nico ou n√£o, isto √©, √© um conjunto de regras que determinam a
ordem na qual as opera√ß√µes do programa ir√£o ser executadas, quais ser√£o executadas primeiro e quando
se encerrar√£o.

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

39

‚ãÜ Linguagens Orientadas a Objeto

‚ãÜ Linguagens Espec√≠ficas a Aplica√ß√µes

‚ãÜ Linguagens Visuais

As linguagens de programa√ß√£o induzem os alunos a pensarem no que est√° sendo

proposto pelo computador e assim, resulte numa intera√ß√£o entre o computador e o aluno.

No entanto, para o sucesso desse processo √© preciso basicamente quatro ingredientes apre-

sentado por Valente [9], s√£o eles: o computador, o software educativo, o professor ca-

pacitado para usar o computador como meio educacional e o aluno. Ao mesmo tempo,

Valente [10] afirma:

As linguagens de programa√ß√£o t√™m mais recursos, enquanto os outros
software como os tutoriais, as multim√≠dias j√° prontas, os processadores de
texto, n√£o t√™m capacidade para executar o que o aprendiz est√° pensando
e, portanto, n√£o fornecem um feedback que seja √∫til para ele compreender
o que faz.

Dessa forma, o uso de computadores e das linguagens de programa√ß√£o auxilia o

aprendente a construir o conhecimento e a compreender o que faz, constituindo assim

uma verdadeira revolu√ß√£o no processo de aprendizagem. Portanto, conhecer os tipos de

linguagens e suas caracter√≠sticas √© de fundamental import√¢ncia para um docente antes de

iniciar um programa direcionado √† aprendizagem de seus alunos com alguma linguagem

de programa√ß√£o, em fun√ß√£o disso, descreveremos brevemente cada uma delas com as

principais linguagens de programa√ß√£o.

1.2.2.1 Linguagens de Baixo N√≠vel

S√£o linguagens cujas instru√ß√µes se aproximam diretamente da linguagem de m√°-

quina que √© enviado ao processador para executar uma tarefa. Nesse sentido, existem

diversas linguagens de baixo n√≠vel para cada processador diferente e o conjunto de lingua-

gens desse tipo √© conhecido de forma geral como ‚ÄúLinguagem Assembly ‚Äù [26].

1.2.2.2 Linguagens N√£o-Estruturadas

As linguagens n√£o-estruturadas s√£o mais aprimoradas do que as linguagens de

baixo n√≠vel, uma vez que seus comandos n√£o encontram-se vinculados ao processador e

sistema utilizados, viabilizando com isso sua utiliza√ß√£o em diversas plataformas. Com

esta evolu√ß√£o, sua sem√¢ntica passou a ser mais gen√©rica, consentindo ao programador

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

40

executar opera√ß√µes mais sofisticadas que s√£o emuladas por sequ√™ncia de instru√ß√µes mais

simples em linguagem de m√°quina. No entanto, apesar de representar um grande salto

qualitativo quando comparado com as linguagens de baixo n√≠vel, tal linguagem tornou-se

paulatinamente obsoleta com o surgimento das linguagens procedurais, as funcionais e

as orientadas a objetos [26]. Nesse tipo de linguagem destaca-se as linguagens COBOL

(COmmon Business Oriented Language) e BASIC (Beginners All-purpose Symbolic Ins-

truction Code).

1.2.2.3 Linguagens Procedurais

S√£o linguagens de alto n√≠vel conhecidas por serem um sub-tipo das linguagens ‚Äúes-

truturadas‚Äù, j√° que, essas linguagens se op√µe as n√£o-estruturadas por apresentar estruturas

de controle que permitem, entre outras coisas, o teste de condi√ß√µes (if-then-else), controle

de repeti√ß√£o de blocos de c√≥digo (for, while, do), fazem a sele√ß√£o de alternativas (switch,

case) e dividem o c√≥digo do programa em m√≥dulos intitulados tamb√©m de fun√ß√µes ou

procedimentos [26]. As linguagens procedurais s√£o caracterizadas pela exist√™ncia de uma

sequ√™ncia de chamada de procedimentos definida atrav√©s de seus algoritmos. Esse grupo

de linguagens √© representada pelos programas em C, Pascal, Fortran, Algol e Forth,

entretanto, algumas linguagens mais sofisticadas foram desenvolvidas para corrigir defi-

ci√™ncias e explorar novos contextos onde C, Pascal e Fortran apresentaram-se de forma

ineficiente, s√£o elas: Ada, Modula-2 e Modula-3.

1.2.2.4 Linguagens Funcionais

As linguagens ditas funcionais diferem das linguagens procedurais por evidenciar

uma programa√ß√£o funcional onde a √™nfase est√° na avalia√ß√£o de express√µes ao inv√©s da

execu√ß√£o de comandos. As express√µes nessas linguagens s√£o formadas utilizando-se fun-

√ß√µes para combinar valores bin√°rios. Dentre as linguagens funcionais mais conhecidas

encontram-se a LISP (LISt Processor) e a Prolog, todavia, a linguagem Scheme √©

frequentemente mencionada por ser uma variante simplificada da LISP. Al√©m dessas lin-

guagens funcionais existem na lituratura outras, tais como: Aspect, Caml, Clean, Erlang,

FP, Gofer, Haskell, Hope, Hugs, Id, IFP, J, Miranda, ML, NESL, OPAL e Sisal [26].

Embora esses recursos existentes contribu√≠ssem significativamente para o avan√ßo

cient√≠fico e tecnol√≥gico da √©poca, ainda existia a necessidade de se obter uma linguagem

que explorasse ao m√°ximo o potencial das novas tecnologias rec√©m inventadas, al√©m da

pr√≥pria crise de software no final da d√©cada de 60 que necessitava de uma linguagem mais

1.2 Evolu√ß√£o da Linguagem de Programa√ß√£o

41

confi√°vel para resolver sistemas complexos e com baixo custo na produ√ß√£o e manuten√ß√£o

caso houvesse necessidade. Diante desse contexto que surgiu √†s linguagens orientadas a

objeto que abordaremos a seguir.

1.2.2.5 Linguagens Orientadas a Objeto

A partir da necessidade de se organizar o processo de programa√ß√£o de uma lingua-

gem que surgiu a programa√ß√£o orientada a objetos que por si s√≥ √© uma t√©cnica. Antes

do surgimento dessa linguagem, os paradigmas da engenharia de software derivavam os

m√≥dulos basicamente da funcionalidade de um sistema, tais m√≥dulos correspondiam essen-

cialmente aos m√≥dulos procedimentais que eram alimentados por dados e geravam novos

dados na opera√ß√£o. Com a chegada do paradigma de orienta√ß√£o a objeto essa concep-

√ß√£o foi modificada, idealizando os objetos como m√≥dulos que se comunicam por meio de

mensagens, encapsulando ao mesmo tempo dados e fun√ß√µes, por meio de um mecanismo

conhecido como tipo de dados abstratos [26].

Dentre as linguagens de programa√ß√£o orientada a objetos a primeira que se tem

not√≠cia foi o Simula, desenvolvida em 1967. Em seguida, veio o Smalltalk, em 1970.

Atualmente, existe uma diversidade de linguagens orientadas a objeto, abrangendo desde

linguagens de prop√≥sito geral, at√© linguangens para multim√≠dia e programa√ß√£o em l√≥gica

como aponta Gudwin [26], onde destacam-se as seguintes linguagens: Simula, Smalltalk,

C++, Objective-C, Java, Eiffel, Python e Ruby

1.2.2.6 Linguagens Espec√≠ficas a Aplica√ß√µes

As linguagens espec√≠ficas foram desenvolvidas para atenderem algumas necessida-

des da √©poca, dentre elas destacam-se √†s linguagens para bancos de dados, Simula√ß√£o,

Scripts e Formata√ß√£o de textos. Dentre essas linguagens espec√≠ficas destacamos o MA-

TLAB (MATrix LABoratory) que √© a linguagem de simula√ß√£o com maior destaque nas

aplica√ß√µes cient√≠ficas.

1.2.2.7 Linguagens Visuais

As linguagens de programa√ß√£o visual, segundo Gudwin [26], prov√©m do princ√≠pio

de que os gr√°ficos s√£o mais intelig√≠veis do que os textos. Dessa forma, a cria√ß√£o de um

programa por meio de diagramas e outros recursos gr√°ficos tendem a tornar a pr√≥pria

programa√ß√£o ainda mais f√°cil, possibilitando que os usu√°rios sem muitas habilidades em

1.3 Hist√≥ria do Processing

42

programa√ß√£o gerem seus pr√≥prios programas.

Nessa concep√ß√£o, uma representa√ß√£o gr√°fica de um programa tenciona a ser uma

descri√ß√£o de alto n√≠vel para o funcionamento do programa e esse tipo de representa√ß√£o

normalmente limita bastante a flexibilidade dos programas que podem ser desenvolvidos,

no entanto, permite a r√°pida elabora√ß√£o de programas com mais facilidade num escopo

limitado de op√ß√µes. Sendo assim, as aplica√ß√µes principais para a programa√ß√£o visual se

limitam a um campo bem espec√≠fico evitando prop√≥sitos gerais.

Dentro dessa √≥tica, as linguagens de programa√ß√£o visual podem ser subdividas em:

‚ãÜ Ferramentas de Programa√ß√£o Visual exemplificada pelos Toolkits.

‚ãÜ Linguagens de Programa√ß√£o Visual H√≠brida representada pelas linguagens Delphi,

Visual Basic e Visual C++.

‚ãÜ Linguagem de Programa√ß√£o Visual Pura representada pela programa√ß√£o Khoros,

Simulink e Processing .

Sendo que essa √∫ltima linguagem, √© gratuita e de c√≥digo aberto desenvolvida para

artes eletr√≥nicas e projetos visuais cujo foco primordial volta-se para o ensino de no√ß√µes

b√°sicas de programa√ß√£o de computador em contexto visual. Por este motivo, a linguagem

de programa√ß√£o Processing foi escolhida como nosso objeto de estudo que abordaremos

com mais detalhes a partir da pr√≥xima sec√ß√£o.

1.3 Hist√≥ria do Processing

O ambiente Processing √© derivado da linguagem Java e foi projetado inicialmente,

em 2001, por Casey Reas e Ben Fry, ambos ex-membros do Grupo de Computa√ß√£o do

MIT Media Lab. Por ser uma linguagem de programa√ß√£o utilizada em contexto visual,

muitos usu√°rios s√£o primordialmente artistas, estudantes e pesquisadores e, por possuir

uma facilidade na instala√ß√£o, uso e aprendizagem agregada √† produtividade de programas

que utilizem intera√ß√µes complexas, faz com que Processing seja ideal para a prototipa√ß√£o

r√°pida de ideias e como caderno de esbo√ßos em software.

Outro ponto importante do Processing em rela√ß√£o as outras linguagens consta no

fato da sua IDE incluir um sketchbook como alternativa para organizar projetos sem ado-

tar o mesmo padr√£o da maioria das IDEs e seus programas chamados de Sketches s√£o uma

subclasse do Java Papplet que √© uma classe implementada da maioria das funcionalidades

1.3 Hist√≥ria do Processing

43

da Processing. Al√©m disso, todo o c√≥digo do sketch √© traduzido para o Java ao ser com-

pilado. Atualmente, o Processing possui uma enorme comunidade de usu√°rios criativos

em virtude da gratuitidade e por rodar na maioria dos sistemas operacionais, al√©m da

possibilidade de gerar gr√°ficos em 2D, em 3D, de processar m√≠dias digitais audiovisuais,

gera√ß√£o de arquivos PDF, exibi√ß√£o de imagens SVG, qualquer biblioteca existente para a

linguagem Java, e, ainda integrar com outros ambientes ou interfaces como o Arduino e

Kinect.

Com o Processing, o programador n√£o precisa possuir dom√≠nio da sintaxe de pro-

grama√ß√£o para iniciar sua aprendizagem e com poucos comandos √© poss√≠vel escrever um

aplicativo que geralmente em outras linguagens s√£o necess√°rias diversas linhas de instru-

√ß√µes que exige um dom√≠nio da sintaxe. Para um aluno exibir uma simples mensagem de

‚ÄúBom dia, Pessoal!!!‚Äù com o desenho de uma elipse na mesma tela √© necess√°rio escrever

apenas as seguintes declara√ß√µes da tabela 1 que resulta na constru√ß√£o da Figura 4.

Tabela 1: Tabela com os comandos textFont e ellipse

Instru√ß√µes
Tamanho da tela
Plano de fundo
Carrega vari√°vel fonte
Escolhe o tipo de fonte
Ativa a fonte e o seu tamanho
Escreve a mensagem na tela
Constr√≥i uma elipse

Comandos
ùë†ùëñùëßùëí(300, 250);
ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(0);
ùëÉ ùêπ ùëúùëõùë° ùëì ùëúùëõùë°ùëí;
ùëì ùëúùëõùë°ùëí = ùëôùëúùëéùëëùêπ ùëúùëõùë°(‚ÄùùëÄ ùëúùëõùëúùë°ùë¶ùëùùëíùê∂ùëúùëüùë†ùëñùë£ùëé ‚àí 50.ùë£ùëôùë§‚Äù);
ùë°ùëíùë•ùë°ùêπ ùëúùëõùë°(ùëì ùëúùëõùë°ùëí, 38);
ùë°ùëíùë•ùë°(‚Äùùêµùëúùëö ùê∑ùëñùëé, ùëÉ ùëíùë†ùë†ùëúùëéùëô!!!‚Äù, 20, 50);
ùëíùëôùëôùëñùëùùë†ùëí(150, 150, 160, 120);

Figura 4: Comando para exibi√ß√£o de mensagens e elipse

Esse aspecto did√°tico do Processing n√£o inviabiliza sua aplica√ß√£o em programas

reais que exijam alto desempenho em processamento gr√°fico e/ou que exijam portabili-

dade para diversas plataformas de software. Em fun√ß√£o disso, √© considerada uma √≥tima

ferramenta para n√£o-programadores ou iniciantes em programa√ß√£o por apresentar uma

1.3 Hist√≥ria do Processing

44

sintaxe simplificada e uma satisfa√ß√£o imediata com um retorno visual como apresenta-

mos nas Figuras 4. Com isso, reafirmamos a import√¢ncia dessa linguagem para inserir

os alunos do Ensino Fundamental e M√©dio no contexto das linguagens de programa√ß√£o

para iniciarmos a descri√ß√£o da pr√≥pria janela (IDE) e comandos do Processing no pr√≥ximo

cap√≠tulo.

Com os avan√ßos tecnol√≥gicos ainda foi poss√≠vel incrementar essa linguagem no

sistema de Javascript com o intuito de implementar os trabalhos usando os padr√µes web

e sem nenhum plugin a partir das contribui√ß√µes de John Resig. Dessa forma, surgiu o

Processing que √© um projeto irm√£o daquele criado inicialmente por Ben Fry e Casey Reas

mantendo a potencialidade do programa original, ou seja, ainda √© poss√≠vel visualizar seus

dados, uma arte digital, anima√ß√µes interativas, gr√°ficos educativos, jogos, entre outros. A

proposta do Processing √© elevar o n√≠vel de compreens√£o e visualiza√ß√£o das artes eletr√≥nicas

com a permissividade do c√≥digo de processamento ser executado por qualquer navegador

compat√≠vel com HTML5, incluindo as vers√µes atuais do Firefox, Safari, Chrome, Opera e

Internet Explorer.

As vers√µes de Processing j√° conseguem incorporar esta funcionalidade ao instalar

um aplicativo em JavaScript pelo pr√≥prio programa e assim, viabilizar uma constru√ß√£o

tanto em Processing como em Processing.JS.

Em detrimento disso, as constru√ß√µes em Processing ainda ser√° realizada no Pro-

cessing e para os alunos que n√£o possuem acesso ao computador ou notebook em suas

resid√™ncias para exercitar e desenvolver algumas atividades ainda √© poss√≠vel utilizar um

aplicativo desenvolvido para Android, o APDE ou o An Editor for Processing, gratuitos e

com a mesma interatividade daquele encontrado no computador sem os recursos da barra

de menus. No caso, dos alunos desejarem divulgar suas constru√ß√µes na internet, √© poss√≠vel
criar uma conta no OpenProcessing 12 para copiar seus c√≥digos ou digita-los diretamente

nessa vers√£o online do Processing.JS.

12No endere√ßo eletr√¥nico: http://www.openprocessing.org

45

2 Descri√ß√£o da Linguagem

Processing

A utiliza√ß√£o do recurso computacional em Matem√°tica para explorar diversos te-

mas matem√°ticos fundamentando a teoria com a pr√°tica tem-se tornado imprescind√≠vel

para novas descobertas e conjeturas viabilizando uma aprendizagem significativa e con-

textualizada. Nossa proposta √© utilizar a linguagem de programa√ß√£o para fortalecer e

desenvolver os conceitos de transforma√ß√£o geom√©trica no plano como forma de aborda-

gem em problemas que apresentam padr√µes de deslocamento de figuras planas, tais como

a an√°lise gr√°fica de fun√ß√µes, entre outras aplica√ß√µes.

Usaremos a linguagem de programa√ß√£o Processing compilado para JavaScript que

est√° dispon√≠vel gratuitamente no endere√ßo https://github.com/processing/processing/releases

para as plataformas Windows, Linux e Mac OS.

Como suporte de estudo, usaremos como tutorial os seguintes materiais:

‚ãÜ V√≠deo de Introdu√ß√£o a Linguagem de Programa√ß√£o Processing do Professor Cl√°udio

Lu√≠s Vieira Oliveira apresentado na Semana de Tecnologia 2014 (FATEC Jundia√≠),

dispon√≠vel no youtube https://www.youtube.com/watch?v=pSHRk0B9SwI.

‚ãÜ O curso de Programa√ß√£o oferecido no site da Khan Academy.

‚ãÜ O material do Workshop Processing, desenvolvido pelo Professor Cla√∫dio Esperan√ßa,

dispon√≠vel no endere√ßo http://www.lcg.ufrj.br/Members/esperanc/workshopvis.

‚ãÜ Os v√≠deos de Introdu√ß√£o a Programa√ß√£o com Jogos em Processing, desenvolvido pelo

grupo Sputnik Learning Space, dispon√≠vel no endere√ßo https://www.youtube.com/

channel/UCRltB7VDN-2oLilZBXT8rMg.

‚ãÜ O livro Processing: a programming handbook for visual designers and artists do

pr√≥prio autor, Ben Fry e Casey Reas [27], da linguagem Processing com tradu√ß√£o

nossa para aplicar nas constru√ß√µes.

2.1 Comandos B√°sicos e Menu

46

Esse cap√≠tulo n√£o possui a men√ß√£o de ser utilizado como um curso de Processing, no

entanto, objetiva-se apresentar as principais ferramentas b√°sicas para iniciar uma produ-

√ß√£o nessa linguagem para viabilizar a import√¢ncia de recorrer a tal recurso para o ensino

das TGP. Sua linguagem potencializa a visualiza√ß√£o e manipula√ß√£o dos objetos geom√©tri-

cos ao mesmo tempo que insere os alunos no √¢mbito da programa√ß√£o, possibilitando uma

forma√ß√£o profissional para os interessados em dar continuidade no programa.

2.1 Comandos B√°sicos e Menu

Essa linguagem de programa√ß√£o possui uma IDE tradicional com menus, uma

barra de ferramentas, um editor de textos com abas, pain√©is para mensagens e para sa√≠da

textual como segue na Figura 5(a), e na vers√£o atualizada j√° existe um item espec√≠fico

para JavaScript. A documenta√ß√£o dos arquivos gerados pelo aplicativo √© chamado de

PDE (Processing Development Environment) e os programas constru√≠dos nessa linguagem

s√£o chamados de sketches, como na Figura 5(b), e podem ser compostos de diversos

arquivos de c√≥digo e outros recursos como imagens, fontes, bibliotecas, etc. Cada sketches

√© guardado em um subdiret√≥rio de uma pasta intitulada de sketbook.

(a) Tela de Comandos

(b) Tela de exibi√ß√£o

Figura 5: IDE e aplica√ß√£o da elipse animada

Na barra de ferramentas s√£o exibidos seis comandos b√°sicos para o processamento,

a depender da vers√£o: Start server, Stop server, New, Open, Save, Export for Web.

‚ãÜ Start server: Executa o c√≥digo (compila o c√≥digo, abre a janela de exibi√ß√£o e

2.1 Comandos B√°sicos e Menu

47

executa o programa dentro);

‚ãÜ Stop server: Encerra um programa em execu√ß√£o, mas n√£o fecha a janela de exibi-

√ß√£o;

‚ãÜ New: Cria um novo desenho (projeto);

‚ãÜ Open: Selecionar e carregar um esbo√ßo pr√©-existente;

‚ãÜ Save: Salva o desenho atual em seu local atual;

‚ãÜ Export for Web: Exporta o desenho atual para o sketchbook como um Applet Java

incorporado em um arquivo HTML. O diret√≥rio que cont√©m os arquivos √© aberto. Ao

clicar no arquivo index.html o programa carrega o software no navegador padr√£o.

Al√©m dessa barra de ferramenta existe na barra do menu seis comandos adicionais:

Arquivo, Editar, Sketch, Debug, Ferramentas e Ajuda.

As coordenadas cartesianas na maioria das linguagens de programa√ß√£o incluindo

o Processing, possuem sua origem no canto superior esquerdo da janela, onde as coorde-

nadas do eixo ùë• aumentam para a direita e as coordenadas do eixo ùë¶ aumentam a partir

do topo. Ressalva-se ainda que cada coordenada mapeia diretamente a posi√ß√£o do objeto

em pixels. Por exemplo, se o seu programa possui 300 por 240 pixels de largura e altura,

respectivamente, ent√£o a coordenada (0, 0) √© o pixel superior esquerdo, enquanto a co-

ordenada (300, 240) est√° no canto inferior direito, onde a √∫ltima coordenada vis√≠vel no

canto inferior direito da tela est√° na posi√ß√£o (299, 239), ver Figura 6.

Figura 6: Sistema de Coordenadas Cartesianas e no Processing

2.1 Comandos B√°sicos e Menu

48

O Processing ainda permite simular desenho em tr√™s dimens√µes que n√£o ser√° abor-

dado nesse estudo. De acordo com Amado [28], essa linguagem permite que o usu√°rio

programe em tr√™s n√≠veis de complexidade: o modo b√°sico, o modo cont√≠nuo e o modo

de Java. No entanto, o mesmo aconselha iniciar a programa√ß√£o no modo b√°sico com o

intuito de incrementar o conhecimento sobre coordenadas, vari√°veis e loops antes de se

aventurar nos modos cont√≠nuos e Java. Diante desse exposto, Amado descreve cada n√≠vel

conforme mostra a tabela 2.

Tabela 2: Caract√©risticas do grau de complexibilidade da programa√ß√£o Processing

Modo B√°sico

Esse modo √© utilizado para desenhar objetos simples no ecr√£ e implementar os fundamentos
da programa√ß√£o. As linhas simples de c√≥digo t√™m uma representa√ß√£o direta na tela.

Modo Cont√≠nuo Esse modo fornece estrutura ao programa e permite desenhar de forma cont√≠nua, atualizar

Java

e introduzir interatividade mais complexa.
Esse modo √© o mais flex√≠vel, permitindo que os programas Java sejam escritos comple-
tamente dentro do ambiente Processing. Escrevendo no modo Java remove as limita√ß√µes
das bibliotecas de processamento e d√° acesso √† linguagem de programa√ß√£o Java completo.

Dentro das constru√ß√µes existem alguns comandos que s√£o inerentes ao grupo do

Modo B√°sico e outras do Modo Cont√≠nuo como revela a tabela 3 que apresenta o comando

com sua descri√ß√£o.

Tabela 3: Descri√ß√£o de alguns comandos inerentes aos Modos B√°sico e Cont√≠nuo da pro-
grama√ß√£o Processing

Comandos
size();
background();
fill();
stroke();
strokeWeight();
smooth();

Modos

B√°sico

Cont√≠nuo

frameRate();

frameCount();

loop();
noLoop();
redraw();

point(ùë•, ùë¶);
line(ùë•1, ùë¶1, ùë•2, ùë¶2);
rect(ùë•, ùë¶, ùë§, ‚Ñé);
ellipse(ùë•, ùë¶, ùë§, ‚Ñé);
triangle(ùë•1, ùë¶1, ùë•2, ùë¶2, ùë•3, ùë¶3)
quad(ùë•1, ùë¶1, ùë•2, ùë¶2, ùë•3, ùë¶3, ùë•4, ùë¶4); Desenha quadril√°tero.
bezier(ùë•1, ùë¶1, ùë•2, ùë¶2, ùë•3, ùë¶3, ùë•4, ùë¶4); Curvas B√©zier c√∫bicas.
println();
setup();
draw();

Descri√ß√µes
Define a resolu√ß√£o da janela (‚ÄúTamanho‚Äù).
Define a cor do fundo e limpa a tela.
Escolhe a cor usada para preenchimento das formas.
Espec√≠fica a cor de tra√ßado de linhas.
Determina a largura do tra√ßado em pixels.
Espec√≠fica a t√©cnica de antiserrilhamento que deve ser utilizada para suavizar
o tra√ßo.
Marca pontos.
Desenha segmento de reta.
Desenha ret√¢ngulo.
Desenha elipse.
Desenha tri√¢ngulo.

Envia texto para √°rea de console do Processing e pula uma linha.
Fun√ß√£o chamada quando inicia a execu√ß√£o do programa.
Fun√ß√£o chamada imediatamente ap√≥s a execu√ß√£o do setup, loop de repeti√ß√£o
para o desenho de forma cont√≠nua.
Valor aproximado de taxa de atualiza√ß√£o m√°xima de frames na execu√ß√£o do
programa em modo cont√≠nuo.
No modo cont√≠nuo, √© um n√∫mero inteiro que cont√©m o n√∫mero de frames mos-
trados desde o in√≠cio da execu√ß√£o do programa. Cada chamada ao m√©todo
draw incrementa este valor.
Executa a fun√ß√£o void draw(); uma √∫nica vez.
Impede o void draw(); de executar em loop;
Redesenha as formas quando chamado em outros eventos fora da draw.

A seguir apresentaremos uma constru√ß√£o considerando o Modo B√°sico e o Modo

2.1 Comandos B√°sicos e Menu

49

Cont√≠nuo de acordo com os c√≥digos de comando constantes na tabela 4. O resultado dessa

constru√ß√£o no Modo B√°sico e no Modo Cont√≠nuo encontra-se presente nas imagens das

Figuras 7(a) e 7(b), respectivamente.

Tabela 4: Comando das constru√ß√µes iniciais no Modo B√°sico e no Modo Cont√≠nuo

Modo B√°sico
size(200,250);
background(255);
fill(255,204,0);
stroke(0);
strokeWeight(10);
smooth();
rect(20, 50, 100, 150);
strokeWeight(5);
fill(200,0,200);
ellipse(160, 190, 50, 90);
Modo Cont√≠nuo
int ùë•0 = 10; //Chamada da vari√°vel ùë•0
int ùë¶0 = 80; //Chamada da vari√°vel ùë¶0
void setup(); {
size(200,200);
stroke(255);
strokeWeight(6);
smooth();
}
void draw();{
background(0);
for (int ùëñ = 0; ùëñ < 5; ùëñ + +){
int ùë• = ùë•0 + ùëñ * 10;
line(ùë•, ùë¶0, ùë• + 20, ùë¶0 ‚àí 40);
}
ùë•0+ = 1;
if (ùë•0 >= 200) ùë•0 = 0;
}

Coment√°rios
//Tamanho da tela 200 por 250 pixels de largura e altura
//Cor de fundo da tela 255 = branca
//Preenchimento da forma amarelo
//Cor de tra√ßado 0 = preta
//Largura do tra√ßado
//Arestas mais suaves
//Ret√¢ngulo de coordenadas (20,50) com largura 100, comprimento 150
//Largura do tra√ßado
//Preenchimento da forma rosa
//Elipse de centro (160,190) com largura 50, comprimento 90
Coment√°rios

//Fun√ß√£o chamada quando inicia a execu√ß√£o do programa.
// Tamanho da tela
//Cor de tra√ßado branca
//Largura do tra√ßado
//Arestas mais suaves
//Encerrar o comando void setup()
//Inicia o comando de repeti√ß√£o.
//Fundo da tela preto

//Encerrar o comando for
//Move desenho para a direita

//Encerrar o comando void draw()

(a) Objetos no Modo B√°-
sico

(b) Segmentos animados no Modo Cont√≠nuo

Figura 7: Constru√ß√µes no Modo B√°sico e Modo Cont√≠nuo

De acordo com Amado [28] o livro de Semiologia e cria√ß√£o Gr√°fica de Bertin com

aplica√ß√£o √† constru√ß√£o de programas apresenta a parametriza√ß√£o do problema bem como a

2.2 Vari√°veis e Tipos de dados

50

cria√ß√£o de um conjunto de instru√ß√µes a serem seguidas por quem ir√° executar o programa.

Deste ponto de vista, o autor supracitado apresenta um conjunto de 7 par√¢metros que

condicionam ou comp√µe todo tipo de cria√ß√µes gr√°ficas, s√£o eles:

1 Posi√ß√£o;

3 Valor;

5 Cor;

7 Forma;

2 Tamanho;

4 Textura;

6 Orienta√ß√£o;

No entanto, os meios digitais incrementam pelo menos mais 7 par√¢metros que s√£o

listados por Amado [28] como:

1 Movimento;

3 Adi√ß√£o(aumento);

5 Espectro;

7 Muta√ß√£o;

2 Crescimento;

4 Moir√©;

6 Rota√ß√£o;

2.2 Vari√°veis e Tipos de dados

Para Amado [28], a mem√≥ria √© um importante conceito em algoritmia, pois esta

permite armazenar resultados intermedi√°rios do algoritmo, e a esses elementos de mem√≥ria

utilizados num algoritmo que designamos por vari√°veis. As vari√°veis s√£o as ‚Äúgavetas‚Äù ou

‚Äúcontentores‚Äù onde ser√£o guardados todos os tipos de elementos para serem reutilizados

pelo programa em outra ocasi√£o. Para cada vari√°vel existe um identificador que nomeia

para ser localizado na mem√≥ria do computador, tal identifica√ß√£o precisa ser cont√≠nua e n√£o

pode come√ßar por n√∫meros. Sendo assim, √© preciso informar ao programa qual ‚Äúgaveta‚Äù

de um certo tipo de dados ser√° utilizado declarando sua vari√°vel que diferentemente do

Flash ou PHP, o Processing necessita de uma certa indica√ß√£o do tipo de dados que a

vari√°vel vai armazenar - n√∫meros inteiros, reais, texto, entre outros.

As vari√°veis s√£o declaradas de acordo com seu tipo, dentre elas destacam-se os tipos

primitivos int, float e String. A tabela 5 apresenta a caracter√≠stica b√°sica de algumas

vari√°veis que podem ser visualizadas na constru√ß√£o das Figuras 8(a), no Modo B√°sico, e

8(b), no Modo Cont√≠nuo.

Os dados ainda podem ser classificados como tipos complexos que s√£o tipos com-

postos formados por v√°rios elementos simples como aponta Amado [28]:

‚àô Vector ou Array, em ingl√™s, √© uma lista de elementos do mesmo tipo que podem

ser ativados via um √≠ndice;

‚àô Matriz √© um vector multi-dimensional;

2.3 Estrutura condicional e operadores l√≥gicos

51

Tabela 5: Declara√ß√µes dos tipos de vari√°veis

Keyword

Descri√ß√£o

byte
short
int
long

Byte
Inteiro curto
Inteiro
Inteiro longo

float

V√≠rgula flutuante

Tamanho/Gama
N√∫meros Inteiros
8-bit (‚àí128 a 127)
16-bit (‚àí32768 a 32767)
32-bit (‚àí2147483648 a 2147483647)
64-bit (‚àí9223372036854775808 a ...807)
N√∫meros Reais
32-bit IEEE 754 (1.401298...707ùëí45 a 3.402823...860ùëí+38

(a) Modo B√°sico

(b) Modo Cont√≠nuo

Figura 8: Declara√ß√µes de vari√°veis

‚àô Estrutura √© a agrega√ß√£o de v√°rios tipos de dados;

2.3 Estrutura condicional e operadores l√≥gicos

As a√ß√µes ou decis√µes tomadas em fun√ß√£o de determinadas condi√ß√µes s√£o uma parte

importante nas nossas vidas. Na programa√ß√£o n√£o √© diferente, √© preciso tomar decis√µes

e executar a√ß√µes condicionalmente, e a esse processo chamamos de Controle de Fluxo. O

controle de fluxo do programa √© devido essencialmente a duas estruturas: if e switch.

A forma mais elementar de uma estrutura condicional encontra-se na estrutura

if-else. Essa estrutura consiste basicamente se sim - fazemos uma a√ß√£o A - se n√£o -

fazemos uma a√ß√£o B, conforme ilustra o fluxograma da Figura 9(a). No entanto, essa

estrutura pode gerar ramifica√ß√µes bastante complexas a depender do n√∫mero de condi√ß√µes

a serem verificadas ou ainda do n√∫mero de ramifica√ß√µes de cada condi√ß√£o ou sub-condi√ß√µes

conforme o fluxograma da Figura 9(b).

2.3 Estrutura condicional e operadores l√≥gicos

52

(a) Estrutura if-else simples

(b) Estrutura if-else ramificado

Figura 9: Diagrama de uma estrutura if-else

Um exemplo de constru√ß√£o utilizando a condicional if-else esta na constru√ß√£o de

segmentos obedecendo a seguinte condi√ß√£o: Se ‚Äúi‚Äù divide por 20 sem resto, ent√£o desenhar

a primeira linha maior, do contr√°rio, desenhar a segunda linha menor e o resultado disso √©

a imagem da Figura 10(b) a partir do comando 10(a). Entretanto, se houver tr√™s ou mais

condi√ß√µes a verificar √© recomendado usar a estrutura switch conforme mostra o fluxograma

da Figura 11(a) constata na constru√ß√£o da Figura 11(b)

(a) Comando

(b) Imagem condicionada

Figura 10: Constru√ß√£o condicional com if-else

Quanto ao requisito operadores, √© poss√≠vel subdividir em tr√™s categorias:

‚àô Operadores aritm√©ticos: +, ‚àí, ‚ãÜ, /;

‚àô Operadores condicionais: >, <, >=, <=, <>;

‚àô Operadores l√≥gicos: e, ou, nega√ß√£o.

Sendo que os operadores condicionais s√≥ podem ser usados nas estruturas condi-

cionais, tendo em vista que o resultado produzido por essa verifica√ß√£o ser sempre uma

2.3 Estrutura condicional e operadores l√≥gicos

53

(a) Diagrama de Fluxo

Figura 11: Diagrama e Constru√ß√£o com a estrutura switch();

(b) Constru√ß√£o

vari√°vel do tipo boolean - verdadeiro ou falso - o que viabiliza ou n√£o a verifica√ß√£o da

condi√ß√£o. Ressalta-se ainda que os operadores condicionais divergem dos operadores de

atribui√ß√£o, como na express√£o ùëé = 10 que √© distinto de ùëé == 10, uma vez que o primeiro

atribui o valor 10 √† vari√°vel e o segundo verifica se ùëé tem um valor num√©rico inteiro de

10 (resultando assim em verdadeiro ou falso). A seguir listamos os principais operadores

condicionais do programa.

== Igual a;

>= Maior ou igual a;

> Maior que;

< Menor que;

<= Menor ou igual a;

! = Diferente ou nega√ß√£o (not).

A Figura 12 foi constru√≠da para validar se um n√∫mero inteiro ùëé √© maior ou igual

do que um inteiro ùëè. No entanto, o resultado foi apresentado de duas formas nessa

figura: A primeira delas aparece no console do programa atrav√©s do comando println; e a

segunda aparece numa janela de exibi√ß√£o com a mesma mensagem de valida√ß√£o ao utilizar

o comando text associado a escolha de um tipo de fonte e seu tamanho.

2.4 Estrutura de Repeti√ß√£o

54

(b) Texto condicionado

(a) Comando condicional

Figura 12: Operadores condicionais

Com rela√ß√£o aos operadores l√≥gicos que s√≥ operam sobre dados l√≥gicos, podemos

inferir que s√£o como elementos de conjun√ß√£o sint√°tica que viabilizam a execu√ß√£o de condi-

√ß√µes complexas, tipo: Se n√£o chover e fizer calor, ent√£o vamos √† praia. A verifica√ß√£o dessa

condi√ß√£o √© concretizada por um operador l√≥gico que serve para interligar os elementos,

s√£o eles com seus respectivos s√≠mbolos:

&& e;

‚Äñ ou;

! n√£o.

A tabela 6 apresenta um exemplo com os valores l√≥gicos para cada um dos opera-

dores l√≥gicos listados acima.

Tabela 6: Tabela de exemplos dos operadores l√≥gicos

‚Äñ - (‚Äúou‚Äù)
B
A
Falso
Falso
Verdade Verdade
Falso
Verdade Falso
Verdade
Verdade Verdade Verdade

A ‚Äñ B
Falso

&& - (‚Äúe‚Äù)
A && B
B
Falso
Falso
Verdade Falso
Falso

A
Falso
Falso
Verdade Falso
Verdade Verdade Verdade

! - (‚Äún√£o‚Äù)

A
Falso
Verdade Falso

! A
Verdade

Um exemplo de uma aplica√ß√£o utilizando os operadores l√≥gicos no Processing pode

ser percebida pela Figura 13 que mostra o resultado e a linha de comandos nessa lingua-

gem.

2.4 Estrutura de Repeti√ß√£o

Os c√≥digos dependentes de uma condi√ß√£o l√≥gica n√£o s√£o a √∫nica forma de estabele-

cer o crit√©rio para que uma determinada opera√ß√£o seja satisfeita. Nesses casos, utiliza-se

2.4 Estrutura de Repeti√ß√£o

55

Figura 13: Operadores L√≥gicos

frequentemente no desenvolvimento de programas de computador uma estrutura de repe-

ti√ß√£o de comandos atuantes em um conjunto de opera√ß√µes sobre v√°rios dados diferentes,

ou at√© a condi√ß√£o inicial a ser concretizada, ou seja, uma programa√ß√£o com repeti√ß√£o

simples consiste em estabelecer basicamente uma condi√ß√£o que se verdadeiro executa um

comando e retorna ao ponto inicial para ser avaliado se cont√≠nua a executar a a√ß√£o ou

se caso o resultado seja falso parar o programa, como na Figura 14. As estruturas de

repeti√ß√£o podem ser subdividas de quatro formas, distinguindo-se pelo local no qual a

condi√ß√£o √© tratada:

Figura 14: Diagrama de Fluxo com repeti√ß√£o simples

‚ãÜ Estrutura de Repeti√ß√£o com teste no in√≠cio

Essa estrutura repete um fluxo de execu√ß√£o enquanto uma certa condi√ß√£o esteja

sendo satisfeita, de acordo com o c√≥digo:

2.4 Estrutura de Repeti√ß√£o

56

while (condi√ß√£o)
{ primeiro comando a ser executado;
segundo comando a ser executado;
...
comando n a ser executado }

Compete ressaltar que a condi√ß√£o while (enquanto em portugu√™s) possui uma

express√£o l√≥gica do mesmo tipo e forma das utilizadas em estruturas if ... else. E se

a express√£o tiver valor inicialmente falso, os comandos embutidos dentro do bloco while

nunca ser√£o executados, no entanto, se a condi√ß√£o for permanentemente verdadeira, o

bloco continuar√° em execu√ß√£o indefinidamente e programa ficar√° em execu√ß√£o cont√≠nua,

levando ao que popularmente se chama de ‚Äútravamento da m√°quina‚Äù. O que n√£o √© desej√°vel

em um programa, por isso, deve-se prestar aten√ß√£o na condi√ß√£o l√≥gica do comando while.

A Figura 15(a) ilustra um exemplo de utiliza√ß√£o da estrutura de repeti√ß√£o while

para desenhar um conjunto de formas geom√©tricas como mostra a Figura 15(b).

(a) Comando while

(b) Imagem while

Figura 15: Desenhando formas com o comando while

‚ãÜ Estrutura de Repeti√ß√£o com teste no final

Nessa estrutura, um fluxo de execu√ß√£o ser√° repetido ao menos uma vez e cada vez

que terminar a execu√ß√£o de um dos fluxos, o teste condicional √© feito para verificar se o

fluxo √© executado novamente. Sua linha de comando √© executado pela descri√ß√£o:

do
{ primeiro comando a ser executado;
segundo comando a ser executado;
...
comando n a ser executado
} while (condi√ß√£o)

Ilustramos o comando do {} while( ) com os comandos da Figura 16(a) para

desenhar um conjunto de formas geom√©tricas como mostra a Figura 16(b).

2.4 Estrutura de Repeti√ß√£o

57

(a) Comando do {} while( )

(b) Imagem do {}
while( )

Figura 16: Desenhando formas com o comando do {} while( )

Dessa forma, todas as condi√ß√µes s√£o testadas pelo menos uma vez, mesmo que o

primeiro comando seja falso.

‚ãÜ Estrutura de Repeti√ß√£o com vari√°vel de controle

Nos casos que √© dif√≠cil determinar quantas vezes um bloco ser√° executado, recomenda-

se utilizar os comandos while e do while uma vez que sua operacionaliza√ß√£o se repetir√°

diversas vezes at√© a condi√ß√£o ser satisfeita. J√°, nos casos onde o n√∫mero de vezes que um

bloco √© executado √© conhecido, o comando mais indicado √© o for (para, em portugu√™s) por

permitir a execu√ß√£o de um bloco limitando-se em uma quantidade de vezes conforme a

estrutura abaixo:

for (inicializa√ß√£o; condi√ß√£o; incremento) {
comando 1
...
comando n
}

A estrutura do comando for tem um funcionamento diferenciado em rela√ß√£o aos

comandos anteriores. Visto que o comando de inicializa√ß√£o √© o primeiro a ser iniciado. Em

seguida, o ciclo de repeti√ß√µes se inicia validando a condi√ß√£o l√≥gica e, enquanto a mesma for

verdadeira, os comandos dentro do for s√£o executados, seguidos do comando na posi√ß√£o

incremento. Salienta-se ainda que as estruturas while e for s√£o equivalentes, quanto √†

capacidade de express√£o em um programa. No entanto, o formato do for permite expressar

de maneira mais clara alguns tipos de constru√ß√µes. A equival√™ncia dessa estrutura com a

while se d√° pela descri√ß√£o abaixo:

A Figura 17(a) mostra o comando de uma programa√ß√£o na estrutura for que produz

como resultado a imagem da Figura 17(b). Se alterarmos o elemento da vari√°vel do

2.4 Estrutura de Repeti√ß√£o

58

while (condi√ß√£o) {
comando 1
...
comando n
incremento
}

comprimento e da largura da elipse, 4‚ãÜùëñ‚àí300, 300‚àí3‚ãÜùëñ por 4‚ãÜùëñ‚àí290, 500‚àí3‚ãÜùëñ, o resultado

visual √© totalmente diferente.

(a) Comando for

(b) Imagem for

Figura 17: Desenhando formas com o comando for

‚ãÜ Estrutura de Repeti√ß√£o com teste no meio

Em alguns casos, a estrutura de repeti√ß√£o no in√≠cio ou no final de um bloco s√£o

dif√≠ceis de serem executadas com condi√ß√µes complexas. E em fun√ß√£o disso, a estrutura de

repeti√ß√£o com teste no meio que utiliza-se do comando break passar a ser √∫til para inter-

romper a repeti√ß√£o a qualquer momento da execu√ß√£o. Ao interromper um determinado

fluxo, o sistema desvia a execu√ß√£o do programa para imediatamente ap√≥s aquele fluxo.

Em sua estrutura de repeti√ß√£o, a linguagem segue a descri√ß√£o:

while (true) { // Ou outra condi√ß√£o
primeiro comando a ser executado
segundo comando a ser executado
if (condi√ß√£o)
break
terceiro comando a ser executado
n comando a ser executado
}

A intera√ß√£o de um la√ßo √© interrompida pelo comando continue, fazendo com que

a execu√ß√£o do la√ßo seja desviada para o in√≠cio deste. Se o comando continue √© chamado

dentro de um ‚Äúfor‚Äù, o controle passa a ser executado dentro do comando incremento. A

tabela 7 resume a compara√ß√£o entre as estruturas de repeti√ß√£o apresentadas nesse t√≥pico.

2.5 Vari√°veis Complexas

59

Tabela 7: Quadro comparativo das estruturas de repeti√ß√£o

Estrutura
while

do while

for

Quando √© testada a condi√ß√£o Quantidade de execu√ß√µes

in√≠cio

fim

in√≠cio

0 ou mais

1 ou mais

0 ou mais

Teste no meio

Qualquer lugar

Depende se utiliza while, do
while ou for

Efeito do comando continue
Passa para a pr√≥xima itera√ß√£o, ou
seja, testa a condi√ß√£o;
Passa para a pr√≥xima intera√ß√£o,
isto √©, testa a condi√ß√£o;
Faz o incremento e depois testa a
condi√ß√£o;
Depende se utiliza while, do while
ou for.

2.5 Vari√°veis Complexas

As vari√°veis ou gavetas que utilizamos at√© agora permitiram o armazenamento de

apenas um valor de cada vez. No entanto, para a constru√ß√£o de aplicativos aprimorados √©

necess√°rio o conhecimento de uma nova vari√°vel que viabilize o armazenamento de diversos

valores simultaneamente, a essa vari√°vel d√°-se o nome de vetores ou arrays que s√£o um

tipo espec√≠fico de vari√°vel din√¢mica, como se fosse uma lista ou gaveta com in√∫meras

subdivis√µes.

Esse recurso viabiliza a armazenagem de um conjunto de dados de mesma natureza

em uma √∫nica vari√°vel. Com isso, nossos programas podem executar diversos movimentos

utilizando uma √∫nica vari√°vel a depender de qual fun√ß√£o de manipula√ß√£o de um vetor

estejamos ativando. As fun√ß√µes de um vetor podem ser ativadas com as seguintes fun√ß√µes

com seu respectivo efeito gr√°fico.

‚àô append Aumenta o tamanho do vetor acrescentando-se um elemento ao final deste;

‚àô arrayCopy Copia um vetor ou parte dele em outro;

‚àô concat Concatena (junta) dois vetores;

‚àô expand Aumenta um vetor para o dobro de seu tamanho ou para um tamanho

especificado;

‚àô reverse Inverte um vetor;

‚àô shorten Elimina o √∫ltimo elemento de um vetor;

‚àô sort Ordena um vetor;

‚àô splice Coloca um vetor ou elemento dentro de um outro;

‚àô subset Retorna um vetor de elementos de dentro de um vetor j√° existente.

2.5 Vari√°veis Complexas

60

As declara√ß√µes de uma vari√°vel do tipo vetor podem ser elucidadas da mesma

maneira que qualquer outro tipo de dado. A diferen√ßa consta apenas ap√≥s o nome do tipo

de dado, ou seja, ao final do tipo de vari√°vel deve-se colocar um sinal de abertura e de

fechamento de colchetes ([ e ]). Nesse sentido, qualquer dos seguintes c√≥digos declaram

vetores:

i. int[] posi√ß√£o;

ii. float[] tamanho;

iii. color[] cor;

iv. string[] nome;

Entretanto, o vetor n√£o pode ser utilizado com apenas a declara√ß√£o de sua vari√°vel,

para seu funcionamento √© imprescind√≠vel informar quantas posi√ß√µes o vetor disponibiliza

e a partir disso a mem√≥ria do computador √© separada para cada posi√ß√£o do vetor que √©

chamado com a palavra chave new.

A declara√ß√£o desse vetor com o n√∫mero de posi√ß√µes do mesmo pode ser escrito de

duas formas como segue:

int[] posicao;
posicao = new int[5];

color[] cor = new color[10];

De acordo com os c√≥digos supracitados, o vetor posi√ß√£o √© criado com 5 posi√ß√µes

em duas linhas, enquanto, o vetor cor √© criado com 10 posi√ß√µes.

A atribui√ß√£o de valores dentro de uma vari√°vel vetor, assim como o n√∫mero de

posi√ß√µes que o mesmo ocupa pode ser declarada de duas formas, como segue no c√≥digo,

onde a primeira coluna refere-se a atribui√ß√£o de valores nomeando o vetor e a posi√ß√£o

desejada entre colchetes ([ e ]) seguida pelo sinal de igualdade (=), ao passo que na

segunda coluna, a cria√ß√£o do vetor com o operador new √© substitu√≠do por uma lista

separada por v√≠rgulas e delimitada por chaves.

int[] dado = new int[3];
dado[0] = 5;
dado[1] = 3;
dado[2] = 2;

int[] dado = {3, 1, 2};

Nas situa√ß√µes onde o programador tenta acessar uma posi√ß√£o fora da lista criada

conduz um erro de execu√ß√£o que p√°ra o programa com a exibi√ß√£o da mensagem ArrayIn-

dexOutOfBoundsException. Normalmente esta situa√ß√£o acontece com programadores

2.5 Vari√°veis Complexas

61

iniciantes que tentam subscrever uma vari√°vel no n√≠vel superior, sem prestar aten√ß√£o que

toda vari√°vel de um vetor come√ßa sempre na posi√ß√£o zero.

Usualmente a estrutura for √© associada para percorrer vetores e sua inicializa√ß√£o

se d√° com o valor zero, limitando-se at√© o tamanho do vetor. A intera√ß√£o nesse caso √©

feita item a item. Com isso, a estrutura for associada a vetores segue como no c√≥digo da

tabela 8 que gera a constru√ß√£o da Figura 18.

Tabela 8: Comando for associado a vetores com constru√ß√£o din√¢mica

Linha Comando
1

ùëì ùëôùëúùëéùë°[ ] ùë•, ùë¶; // Armazena a posi√ß√£o do
objeto
ùëêùëúùëôùëúùëü[ ] ùëê; // Cor do objeto
ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù(){
ùë†ùëñùëßùëí(300, 300); // Configura√ß√£o da tela

ùë• = ùëõùëíùë§ ùëì ùëôùëúùëéùë°[20];
ùë¶ = ùëõùëíùë§ ùëì ùëôùëúùëéùë°[20];
ùëê = ùëõùëíùë§ ùëêùëúùëôùëúùëü[20];
/‚ãÜ O comando new criando 20 posi√ß√µes
para armazenar a posi√ß√£o e a cor do objeto
‚ãÜ/
ùëì ùëúùëü(ùëñùëõùë° ùëñ = 0; ùëñ < ùë•.ùëôùëíùëõùëîùë°‚Ñé; ùëñ + +){

ùë•[ùëñ] = ùëüùëéùëõùëëùëúùëö(10, ùë§ùëñùëëùë°‚Ñé ‚àí 10);

ùë¶[ùëñ] = ùëüùëéùëõùëëùëúùëö(10, ‚Ñéùëíùëñùëî‚Ñéùë° ‚àí 10);

//Coloca o objeto na tela em posi√ß√£o ale-
at√≥ria
ùëê[ùëñ] = ùëêùëúùëôùëúùëü(ùëüùëéùëõùëëùëúùëö(256), ùëüùëéùëõùëëùëúùëö(256),
ùëüùëéùëõùëëùëúùëö(256)); //Sorteia a cor do objeto
} }
ùë£ùëúùëñùëë ùëëùëüùëéùë§(){
ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255); //Limpa a tela
ùëì ùëúùëü(ùëñùëõùë° ùëñ = 0; ùëñ < ùë•.ùëôùëíùëõùëîùë°‚Ñé; ùëñ + +){

ùëñùëì (ùë•[ùëñ] < ùëöùëúùë¢ùë†ùëíùëã){ //Se o objeto estiver
√† esquerda do mouse
ùë•[ùëñ] = ùë•[ùëñ] ‚àí 1; //V√° para a esquerda

Linha Comando
20

} else {

21
22
23

24
25
26
27

28

29

30

31

32

33
34
35
36

37

38

ùë•[ùëñ] = ùë•[ùëñ] + 1; //V√° para a direita
}
ùëñùëì (ùë¶[ùëñ] < ùëöùëúùë¢ùë†ùëíùëå ){//Se o objeto estiver
acima do mouse
ùë¶[ùëñ] = ùë¶[ùëñ] ‚àí 1; //V√° para cima
} ùëíùëôùë†ùëí {
ùë¶[ùëñ] = ùë¶[ùëñ] + 1; //V√° para baixo
}

ùëñùëì (ùë•[ùëñ] < 0 || ùë¶[ùëñ] < 0 || ùë•[ùëñ] > ùë§ùëñùëëùë°‚Ñé ||
ùë¶[ùëñ] > ‚Ñéùëíùëñùëî‚Ñéùë°){ //Se o objeto saiu da tela
ùë•[ùëñ] = ùëüùëéùëõùëëùëúùëö(10, ùë§ùëñùëëùë°‚Ñé ‚àí 10); //Sorteia
a posi√ß√£o em x
ùë¶[ùëñ] = ùëüùëéùëõùëëùëúùëö(10, ‚Ñéùëíùëñùëî‚Ñéùë° ‚àí 10); //Sorteia
a posi√ß√£o em y
}

// Desenha o objeto

ùëì ùëñùëôùëô(ùëê[ùëñ]); //Cor do objeto
ùëíùëôùëôùëñùëùùë†ùëí(ùë•[ùëñ], ùë¶[ùëñ], 10, 10); //Desenha elipse
ùëüùëíùëêùë°(ùë¶[ùëñ], ùë•[ùëñ], 6, 6); //Desenha ret√¢ngulo
ùëéùëüùëê(ùë•[ùëñ] ‚àí 5, ùë¶[ùëñ] ‚àí 5, 15, 15, 0, ùëÉ ùêº +
ùëÑùëà ùê¥ùëÖùëá ùê∏ùëÖ_ùëÉ ùêº, ùëÉ ùêºùê∏); //Desenha arco
}

}

2
3
4

5
6
7
8

9

10

11

12

13

14
15
16
17

18

19

Nesse c√≥digo, salienta-se que a vari√°vel ‚Äúùëñ++‚Äù dispon√≠vel nas linhas 9 e 17 da tabela

8 tem o mesmo resultado que o comando ‚Äúùëñ = ùëñ + 1‚Äù, e em fun√ß√£o disso, cada itera√ß√£o

acaba acessando uma posi√ß√£o diferente do vetor. Outro recurso incrementado refere-se ao

c√≥digo mouseX, linha 18, que viabiliza uma anima√ß√£o que muda o sentido do movimento

a medida que o mouse se aproxima de um determinado ponto da tela.

A aplica√ß√£o em vetor, notoriamente, √© uma extens√£o de uma vari√°vel simples que

pode ainda ser estendida para uma estrutura bidimensional chamada de matrizes. De

2.6 Fun√ß√µes ou M√©todos

62

Figura 18: Anima√ß√µes na estrutura for associado a vetores

fato, se um vetor √© interpretado como uma linha de uma tabela do Excel, a matriz

pode abranger uma tabela inteira. No caso de uma matriz bidimensional, seus valores

s√£o acessados atrav√©s de dois valores de √≠ndice e s√£o √∫teis para armazenar imagens. A

imagem da Figura 19(a) foi constru√≠da usando uma matriz bidimensional para desenhar

uma imagem em tons de cinza de acordo com os c√≥digos incrementados na tabela 9.

Tabela 9: C√≥digo da Imagem em tons de cinza usando uma matriz bidimensional

Linha Comando
1
2
3
4
5
6
7
8
9
10

// Matriz bidimensional
ùë†ùëñùëßùëí(300, 300);
background(255);
int colunas = width;
int linhas= height;
//Declara√ß√£o da matriz bidimensional
int[][] matriz = new int[colunas][linhas];
//Inicializar valores da matriz 2D;
for (ùëñùëõùë° ùëñ = 0; ùëñ < ùëêùëúùëôùë¢ùëõùëéùë†; ùëñ + +) {
for (ùëñùëõùë° ùëó = 0; ùëó < ùëôùëñùëõ‚Ñéùëéùë†; ùëó + +) {

Linha Comando
11
12
13
14
15
16
17
18
19
20

ùëöùëéùë°ùëüùëñùëß[ùëñ][ùëó] = ùëñùëõùë°(ùëüùëéùëõùëëùëúùëö(255));
}
}
//Desenhar pontos
for (ùëñùëõùë° ùëñ = 0; ùëñ < ùëêùëúùëôùë¢ùëõùëéùë†; ùëñ + +) {
for (ùëñùëõùë° ùëó = 0; ùëó < ùëôùëñùëõ‚Ñéùëéùë†; ùëó + +) {
stroke(ùëöùëéùë°ùëüùëñùëß[ùëñ][ùëó]);
point(i, j);
}
}

Ao substituirmos o comando ùëùùëúùëñùëõùë°(ùëñ, ùëó); da linha de comando 18, por ùëùùëúùëñùëõùë°(ùë§ùëñùëëùë°‚Ñé/3 +

2‚ãÜùëñ/3 ‚àí 50, ‚Ñéùëíùëñùëî‚Ñéùë°/3 + 2‚ãÜùëó/3 ‚àí 50); a nova imagem constru√≠da passar a possuir o dimen-

sionamento da tela de tons cinzas reduzida como podemos constatar na 19(b). Com isso,

obtemos uma matriz com menos elementos que s√≥ s√£o exibidos na tela do console se in-

clu√≠mos o comando ‚Äúprintln (‚Äúùëöùëéùë°ùëüùëñùëß[ùëñ][ùëó] = ùëñùëõùë°(ùëüùëéùëõùëëùëúùëö(255));‚Äù);‚Äù antes de finalizar o

programa.

2.6 Fun√ß√µes ou M√©todos

Em programa√ß√£o a palavra fun√ß√£o e m√©todo possuem o mesmo significado como

afirma Amado [28]. Onde s√£o mantidos como pequenos programas que tomam determina-

2.6 Fun√ß√µes ou M√©todos

63

(a) Tela fechada com pontos

(b) Tela parcialmente fechada
com pontos

Figura 19: Imagem em tons de cinza usando uma matriz

dos valores de entrada e produzem um resultado. No entanto, o autor supracitado afirma

que a prov√°vel distin√ß√£o encontra-se no fato de usarmos uma fun√ß√£o quando estamos nos
referindo a uma instru√ß√£o conhecida pela linguagem (API1) tal como ellipse(), ou fill().

J√°, se desejarmos construir uma casa estruturada (porta, janela, telhado, entre outros

itens) estamos a executar um m√©todo ou conjunto de instru√ß√µes para o efeito. Por este

motivo, Amado caracteriza tudo como m√©todos, visto que o programa s√≥ executa uma

fun√ß√£o, seja ela um rect() ou desenhar uma casa, quando esta tem que estar descrita de

alguma forma.

Salienta-se ainda que algumas fun√ß√µes matem√°ticas j√° est√£o embutidas para o

√¢mbito dessa linguagem, s√£o elas:

‚àô sin, cos, tan, atan

‚àô sqrt, log, exp, abs

Para as fun√ß√µes que n√£o est√£o definidas nessa linguagem como um pacote de ferra-

mentas, √© poss√≠vel incrementar com novas estruturas utilizando par√¢metros que s√£o valores

passados ao m√©todo quando este √© chamado mediante a instru√ß√£o seguinte estabelecida

de forma geral, onde seus significados s√£o:

tipo nome (tipo1 param1, tipo2 param2, ¬∑ ¬∑ ¬∑ , tipoN paramN) {
comando;
¬∑ ¬∑ ¬∑
comando;
}

1A API √© uma Interface de Programa√ß√£o de Aplicativos, isto √©, um conjunto de rotinas e padr√µes esta-
belecidos por um software para a utiliza√ß√£o das suas funcionalidades por aplicativos que n√£o pretendem
envolver-se nos detalhes da implementa√ß√£o do software, mas apenas usar seus servi√ßos.

2.6 Fun√ß√µes ou M√©todos

64

1. tipo √© o tipo do valor de retorno (int, float, entre outros);

2. nome √© o nome pelo qual a fun√ß√£o ser√° conhecida;

3. tipo1 param1 s√£o o tipo e o nome do primeiro par√¢metro.

Nos casos onde o m√©todo computa algo mas n√£o retorna nada, pode-se usar a

palavra void como tipo, como podemos constatar no comando da Figura 20(a) que

proporciona a imagem de um tabuleiro est√°tico do jogo da velha, ver imagem 20(b).

(b) Jogo da Velha est√°tico

(a) Comando Jogo da Velha

Figura 20: Constru√ß√£o do tabuleiro para o Jogo da Velha

Se houver necessidade de retornar algum valor, deve-se prioritariamente incluir em

algum ponto da defini√ß√£o um comando da forma return valor que viabilizar√° a reutiliza√ß√£o

do comando utilizando uma quantidade de c√≥digos de programa√ß√£o reduzido. A exemplo

desse recurso temos a aplica√ß√£o da Figura 21(b) constru√≠da com o comando 21(a).

2.6 Fun√ß√µes ou M√©todos

65

(a) Comando com fun√ß√£o return

(b) Anima√ß√£o com fun-
√ß√£o return

Figura 21: Constru√ß√£o com fun√ß√£o de regresso

Al√©m dos recursos apresentados, o Processing possui diversas aplica√ß√µes que viabili-

zam a constru√ß√£o de jogos com poucos recursos ou dom√≠nio da linguagem via √†s aplica√ß√µes

que podem ser desenvolvidas a partir dos comandos de transforma√ß√£o no plano. Contudo,

antes de realizar tal aplica√ß√£o √© de fundamental import√¢ncia analisar como imagens planas

s√£o deslocadas e para isso apresentaremos a transforma√ß√£o geom√©trica de forma concei-

tual viabilizando a interpreta√ß√£o da linguagem de programa√ß√£o para o deslocamento de

imagens no plano.

66

3 Transforma√ß√£o Geom√©trica no

Plano

As transforma√ß√µes geom√©tricas est√£o presentes historicamente na constitui√ß√£o da

maioria dos seres vivos atrav√©s da utiliza√ß√£o das simetrias, rota√ß√µes, transla√ß√µes e ho-

motetias (amplia√ß√µes e redu√ß√µes) para copiar os elementos apresentados pela natureza e

reproduzidos em cer√¢micas, tecidos e cestas em uma pr√°tica ancestral.

Nesse sentido, os avan√ßos no estudo da geometria impulsionados pelos eg√≠pcios,

babil√¥nios, hindus, chineses e principalmente pelos gregos com a publica√ß√£o do livro ‚ÄúOs

Elementos‚Äù de Euclides[24] que, em fun√ß√£o do desenvolvimento do modelo axiom√°tico,

trouxe uma enorme contribui√ß√£o para o ensino da geometria e o comportamento das

fun√ß√µes atrav√©s das transforma√ß√µes geom√©tricas.

Dentre as obras dos tempos modernos destacam-se as contribui√ß√µes do artista

holand√™s Maurits Cornelis Escher por utilizar as transforma√ß√µes geom√©tricas em seus

trabalhos. No entanto, como afirma Medeiros e Lopes [29, 30], apesar de sua obra estar

repleta de conceitos matem√°ticos e todos os seus trabalhos possu√≠rem um forte conte√∫do

dessa ci√™ncia, o mesmo era absolutamente leigo no assunto.

Conta-se at√© que H.M.S. Coxeter, um dos papas da geometria moderna,
entusiasmado com os desenhos do artista, convidou-o a participar de uma
de suas aulas. Vexame total, Para decep√ß√£o do catedr√°tico. Escher n√£o
sabia do que ele estava falando, mesmo quando discorria sobre teorias
que o artista aplicava intuitivamente em suas gravuras [30, p. 5].

Esse artista dedicou seus trabalhos com isometrias decorativas a partir de suas

visitas ao pal√°cio mourisco de Allambra, em Granada ‚Äì Espanha que foi constru√≠do pelos

√°rabes no s√©culo XIII. Apesar de n√£o possuir o conhecimento sobre o assunto, Escher

copiou obsessivamente os ornamentos das paredes do respectivo pal√°cio e, acabou por

descobrir os movimentos utilizados nos ornamentos: as isometrias, isto √©, a transla√ß√£o, a

rota√ß√£o, a reflex√£o, a transla√ß√£o refletida e suas combina√ß√µes. E atrav√©s da experimenta√ß√£o

conseguiu chegar aos dezessete grupos existentes das combina√ß√µes isom√©tricas que tornam

CAP√çTULO 3. TRANSFORMA√á√ÉO GEOM√âTRICA NO PLANO

67

a figura invariante [29].

Na concep√ß√£o do Professor de geometria do Instituto de Matem√°tica e Estat√≠stica

(IME) da Universidade de S√£o Paulo (USP), S√©rgio Alves, que utiliza os desenhos desse

artista holand√™s em suas aulas,

√© not√°vel que Escher, sem qualquer conhecimento pr√©vio de matem√°tica,
tenha descoberto essas possibilidades. Quanto aos quatro movimentos,
s√£o os √∫nicos poss√≠veis de serem aplicados sobre um padr√£o plano de
modo que o resultado obtido seja exatamente a figura original. Em
termos matem√°ticos, s√£o as √∫nicas isometrias do plano. O estudo desses
movimentos √© chamado de Geometria das Transforma√ß√µes e suas leis
governam a constru√ß√£o de desenhos peri√≥dicos [30, p. 5].

O holand√™s Escher chamou seus trabalhos de Divis√£o Regular do Plano (DRP)
como fundamenta Medeiros [29] e algumas de suas artes s√£o mostradas nas figuras1 22(a),

22(b).

(a) Butterfly (No. 70)

(b) Lizard/Fish/Bat (No. 85)

Figura 22: Detalhe da DRP de Escher

No entanto, voltando a analisar as contribui√ß√µes de Euclides, encontramos vinte e

tr√™s defini√ß√µes, cinco postulados e nove no√ß√µes para demonstrar toda a geometria conhe-

cida como geometria euclidiana ou geometria cl√°ssica no Livro I de ‚ÄúOs Elementos‚Äù. Os

cinco postulados est√£o listados a seguir:

1o Fique postulado tra√ßar uma reta a partir de todo ponto at√© todo

ponto.

2o Tamb√©m prolongar uma reta limitada, continuamente, sobre uma

reta.

1Imagens de Escher obtidas no site http://www.mcescher.com/gallery/ink/

CAP√çTULO 3. TRANSFORMA√á√ÉO GEOM√âTRICA NO PLANO

68

3o E, com todo centro e dist√¢ncia, descrever um c√≠rculo.
4o E serem iguais entre si todos os √¢ngulos retos.
5o E, caso uma reta, caindo sobre duas retas, fa√ßa os √¢ngulos interiores
e do mesmo lado menores do que dois retos, sendo prolongadas as
duas retas, ilimitadamente encontrarem-se no lado no qual est√£o os
menores do que dois retos [24, p. 98].

A diferencia√ß√£o entre os postulados e as no√ß√µes comuns constante no Livro I de

Euclides versa sobre a exclusividade dos postulados para √† geometria, a medida que as

no√ß√µes comuns s√£o afirma√ß√µes de validade geral. A exemplo disso, temos a primeira das

no√ß√µes comuns de Euclides [24, p. 99] ao afirmar que ‚Äúas coisas iguais √† mesma coisa s√£o

tamb√©m iguais entre si‚Äù.

Diversas contribui√ß√µes foram atreladas ao longo da hist√≥ria, no entanto, somente

com Sophus Lie (1842‚Äì1899) e F√©lix Klein (1849‚Äì1925) que criaram a no√ß√£o de grupos

de transforma√ß√µes e invariante correspondentes fundamentada na teoria de grupos, que

resolveram o problema de identifica√ß√£o da estrutura do conjunto de transforma√ß√µes como

sinaliza Medeiros [29].

De acordo com Fainguelernt [31, p. 72], ‚ÄúKlein, em 1870, revolucionou o enfoque

da geometria, ao afirmar que devemos entender o seu contexto como o estudo das propri-

edades invariantes das figuras face √†s transforma√ß√µes de um grupo‚Äù. E, em 1872, Klein

afirmou que o conceito de transforma√ß√£o desempenha um papel coordenador e simpli-

ficador no estudo da Geometria, possibilitando uma abordagem intuitiva e informal da

mesma atrav√©s das transforma√ß√µes.

F√©lix Klein foi um professor da Universidade de Erlangen (1872‚Äì1875) e posteri-

ormente em Leipzig (1880‚Äì1886) e em Gottingen (1886‚Äì1913). Para Klein [32], a rela√ß√£o

entre um grupo de transforma√ß√µes e uma geometria √© que a define, chamando esse grupo

de transforma√ß√µes de grupo principal para essa geometria. Nas palavras do autor supraci-

tado [32, p. 7] as ‚Äúpropriedades geom√©tricas n√£o se alteram pelas transforma√ß√µes do grupo

principal. Podemos tamb√©m afirmar de modo inverso: as propriedades geom√©tricas s√£o

caracterizadas pela sua invari√¢ncia com respeito √†s transforma√ß√µes do grupo principal‚Äù.

Outra import√¢ncia para o ensino das TGP consta no fato da maioria dos aplicativos

de computa√ß√£o gr√°fica permitir a manipula√ß√£o de uma imagem de v√°rias maneiras, tais

como a mudan√ßa de suas propor√ß√µes, rota√ß√µes ou cilhamentos como aponta Concei√ß√£o [33].

Al√©m de uma t√©cnica b√°sica da distor√ß√£o de uma imagem pelo movimento dos v√©rtices de

um ret√¢ngulo que a cont√©m.

Entretanto, Concei√ß√£o [33] afirma que a deforma√ß√£o consiste em distorcer v√°rias

3.1 An√°lise matem√°tica das transforma√ß√µes geom√©tricas

69

partes da imagem de maneiras distintas e por isso, √© um procedimento mais complicado.

Em fun√ß√£o disso, a deforma√ß√£o de duas imagens por procedimentos complementares com
a fus√£o das deforma√ß√µes obtidas resulta num morfismo2 das duas imagens.

Segundo o autor mencionado, a principal aplica√ß√£o das deforma√ß√µes e morfismos

est√° na produ√ß√£o de efeitos especiais no cinema, na televis√£o e na propaganda. Al√©m

das diversas aplica√ß√µes cient√≠ficas e tecnol√≥gicas para essas t√©cnicas como na assist√™ncia

√† cirurgia pl√°stica e de reconstru√ß√£o, na investiga√ß√£o de varia√ß√µes do projeto de um pro-

duto e o ‚Äúenvelhecimento‚Äù de fotografias de pessoas desaparecidas ou suspeitos da pol√≠cia.

A seguir, apresentamos uma breve an√°lise matem√°tica das transforma√ß√µes geom√©tricas,

evidenciando sua dimens√£o geom√©trica e alg√©brica.

3.1 An√°lise matem√°tica das transforma√ß√µes geom√©tri-

cas

Uma Transforma√ß√£o Geom√©trica no Plano √© uma fun√ß√£o que associa a cada ponto

do plano um outro ponto tamb√©m do plano atrav√©s de certas regras. Dessa forma, os

movimentos que originam a mudan√ßa de posi√ß√£o dos pontos podem, ou n√£o, manter a

forma e o tamanho da figura a ser transformada. Segundo Wagner [34, p. 70] ‚ÄúUma

transforma√ß√£o ùëá no plano Œ† √© uma fun√ß√£o ùëá : Œ† ‚Üí Œ† que associa a cada ponto ùê¥ do
plano um outro ponto ùê¥‚Ä≤ = ùëá (ùê¥) do plano chamado imagem de ùê¥ por ùëá ‚Äù.

Matematicamente, dizemos que uma transforma√ß√£o √© bijetiva se, e somente se, uma

transforma√ß√£o no plano Œ† for injetiva, e isso acontece quando possui pontos distintos do

plano com imagens distintas, isto √©, se ùëÉ Ã∏= ùëÑ, ent√£o ùëá (ùëÉ ) Ã∏= ùëá (ùëÑ). E se a transforma√ß√£o
for tamb√©m sobrejetiva no mesmo plano Œ†, nesse caso, possui para todo ponto ùê¥‚Ä≤ pelo
menos uma imagem para o ponto ùê¥, ou seja, para todo ponto ùê¥‚Ä≤ existe ùê¥ tal que ùëá (ùê¥) =
ùê¥‚Ä≤. Portanto, essa transforma√ß√£o √© bijetiva, isto √©, ‚àÄùê¥‚Ä≤ ‚àà Œ†, ‚àÉ|ùê¥ ‚àà Œ†; ùëá (ùê¥) = ùê¥‚Ä≤. Nesse

contexto, utilizaremos somente as transforma√ß√µes bijetivas.

As transforma√ß√µes que ser√£o tratadas aqui ser√£o sempre bije√ß√µes de um conjunto
ùëÄ ‚äÇ R em outro conjunto ùëÅ ‚äÇ R. Onde ùëÄ e ùëÅ s√£o reconhecidas como ‚Äúfiguras geom√©tri-

cas‚Äù no mundo f√≠sico. Como o conceito de Geometria trazido por Klein est√° intimamente

ligado √† Teoria de Grupos √© recomend√°vel que os professores que n√£o estejam habituados

2Um morfismo definido por Concei√ß√£o [33, p. 49] ‚Äúpode ser descrito como uma combina√ß√£o de defor-
ma√ß√µes de duas imagens distintas, associando caracter√≠sticas correspondentes das duas imagens. Uma
das duas imagens √© escolhida como imagem inicial e a outra como a imagem final‚Äù. E √© usado para gerar
um efeito de anima√ß√£o ou de transi√ß√£o de imagens.

3.1 An√°lise matem√°tica das transforma√ß√µes geom√©tricas

70

com a no√ß√£o de grupo, que busquem em bons livros3 de √Ålgebra para um aprofundamento

mais detalhado.

A defini√ß√£o de um grupo necessita de um conjunto de objetos, como os n√∫meros

inteiros, e de uma opera√ß√£o que possa ser realizada com eles, como a soma, de tal forma

que esta opera√ß√£o cumpra certos requisitos de um grupo:

1. A opera√ß√£o precisa ser fechada para o conjunto utilizado. Nesse sentido, a soma de

dois n√∫meros inteiros √© sempre um n√∫mero inteiro;

2. A opera√ß√£o precisa ser associativa. Nesse sentido, temos que a soma √© obviamente

associativa;

3. A opera√ß√£o precisa possuir elemento neutro. Nesse caso, o elemento zero faz este

papel, visto que 0 + ùë° = ùë° + 0, ‚àÄùë° ‚àà Z;

4. A opera√ß√£o precisa possuir um elemento inverso para qualquer elemento do conjunto
dado. Para esta situa√ß√£o o inverso de ùë° √© o ‚àíùë°, uma vez que ‚àíùë°+ùë° = ùë°+(‚àíùë°), ‚àÄùë° ‚àà Z.

Em fun√ß√£o dos Grupos de Transforma√ß√µes, o nosso ‚Äúconjunto de objetos‚Äù conter√°

as transforma√ß√µes sobre figuras do plano Œ† e a ‚Äúopera√ß√£o‚Äù que utilizaremos ser√° a opera-

√ß√£o de composi√ß√£o. Nesse sentido, faz-se necess√°rio uma breve revis√£o de Transforma√ß√µes

Lineares (ver Ap√™ndice A) para associar com as transforma√ß√µes geom√©tricas operaciona-

lizadas na forma matricial, como associaremos com a linguagem de programa√ß√£o. No

entanto, isso n√£o inviabiliza o ensino das TGP nos anos finais do Ensino Fundamental,

ao contr√°rio, revela uma possibilidade de se abordar matrizes de forma contextualizada

no Ensino M√©dio.

Como a pesquisa estar√° sempre abordando transforma√ß√µes (e movimentos), haver√°

sempre uma figura que √© transformada em outra de acordo com o contexto da explica√ß√£o.

Nesse ponto, apresentaremos as transforma√ß√µes geom√©tricas de acordo com as rela√ß√µes

estabelecidas entre as figuras iniciais e finais, isto √©, quando √© isom√©trica, isom√≥rfica ou

anam√≥rfica.

3Recomenda-se o livro de √Ålgebra Moderna de Domingues e Iezzi ([35], cap√≠tulo 4)

3.2 Transforma√ß√µes Isom√©tricas

71

3.2 Transforma√ß√µes Isom√©tricas

As primeiras TGP chamadas de isom√©tricas s√£o as transforma√ß√µes que preservam

dist√¢ncias. Nesse sentido, definimos uma transforma√ß√£o isom√©trica T quando

ùëë[ùëá (ùëÄ ), ùëá (ùëÅ )] = ùëë(ùëÄ, ùëÅ )

para quaisquer pontos ùëÄ e ùëÅ do plano Œ†. De acordo com Wagner [34, p. 71], qualquer

transforma√ß√£o isom√©trica possui as seguintes regras:

a) a imagem de uma reta por uma isometria √© uma reta.

b) uma isometria preserva paralelismo.

c) uma isometria preserva √¢ngulos.

Consequentemente, a isometria constitui um grupo de transforma√ß√µes geom√©tricas

que auxiliam a geometria euclidiana, tendo em vista a possibilidade de avaliar quando

duas figuras s√£o congruentes ao analisar se o movimento preserva a forma e o tamanho da

figura original, mudando apenas sua posi√ß√£o no plano. Por esse motivo, as transforma√ß√µes

isom√©tricas s√£o denominadas de movimentos r√≠gidos do plano por modificar apenas a

posi√ß√£o da figura inicial e s√£o subdivididas em Transla√ß√£o, Reflex√£o e Rota√ß√£o.

3.2.1 Transla√ß√£o

Nas palavras de Souza [36, p. 19], ‚Äútransladar uma figura √© o mesmo que mov√™-la

no plano sem rotacion√°-la‚Äù, isso significa, que a transla√ß√£o √© uma TGP que leva cada

ponto do plano a um novo ponto segundo uma trajet√≥ria representada por um segmento

de reta de tamanho fixo e que faz um √¢ngulo fixo em rela√ß√£o ao plano horizontal. Logo,

seguindo a ideia de Wagner [34], uma transla√ß√£o √© uma transforma√ß√£o no plano Œ† onde

a fun√ß√£o bijetora ùëá : Œ† ‚Üí Œ† preserva dist√¢ncias associando a cada ponto ùëÄ do plano Œ†,
o ponto ùëá (ùëÄ ) = ùëÄ ‚Ä≤ = ùëÄ + ‚àí‚Üíùë£ , onde ‚àí‚Üíùë£ √© um segmento de reta orientado de medida,
dire√ß√£o e sentido fixo (Figura 23).

Figura 23: Transla√ß√£o do ponto ùëÄ segundo o vetor ‚Éóùë£

3.2 Transforma√ß√µes Isom√©tricas

72

Algebricamente, se considerarmos dois pontos ùëÉ e ùëÑ distintos, de coordenadas

(ùë•1, ùë¶1) e (ùë•2, ùë¶2), respectivamente, pela defini√ß√£o anterior, conforme a Figura 24 mostra,
para que o ponto ùëÄ ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤) seja o transladado do ponto ùëÄ = (ùë•, ùë¶) segundo o vetor

‚àí‚Üí
ùëÉ ùëÑ, os tri√¢ngulos ùëÉ ùëÑùëÖ e ùëÄ ùëÄ ‚Ä≤ùëÇ devem ser congruentes, da√≠:

determinado por

e

ùëö(ùëÉ ùëÖ) = ùë•2 ‚àí ùë•1 = ùëö(ùëÄ ùëÇ)

ùëö(ùëÖùëÑ) = ùë¶2 ‚àí ùë¶1 = ùëö(ùëÇùëÄ ‚Ä≤)

logo, a express√£o do ponto transladado √© dada por:

(ùë•‚Ä≤, ùë¶‚Ä≤) = ùëá (ùë•, ùë¶) = (ùë• + ùë•2 ‚àí ùë•1, ùë¶ + ùë¶2 ‚àí ùë¶1)

(3.1)

Figura 24: Transla√ß√£o do ponto ùëÄ segundo o segmento ùëÉ ùëÑ

Exemplo 3.1. Se o ponto ùëÉ = (2, 5) e o ponto ùëÑ = (3, 9), a transla√ß√£o segundo o

segmento orientado

‚àí‚Üí
ùëÉ ùëÑ, de acordo com a express√£o 3.1, ser√° dada por:

ùëá (ùë•, ùë¶) = (ùë• + 3 ‚àí 2, ùë¶ + 9 ‚àí 5) = (ùë• + 1, ùë¶ + 4)

onde o segmento orientado

‚àí‚Üí
ùëÉ ùëÑ possui coordenadas vetoriais (3 ‚àí 2, 9 ‚àí 5) = (1, 4). Dessa

forma, a equa√ß√£o de transla√ß√£o de ponto a ponto no plano ser√° dada por:

ùëá (ùë•, ùë¶) = (ùë• + ùëé, ùë¶ + ùëè)

(3.2)

onde

‚àí‚Üí
ùëÉ ùëÑ = ‚àí‚Üíùë£ = (ùëé, ùëè), com ùëé e ùëè pertencente a R.

Por outro lado, pode-se concluir que se ùëé = 0, temos uma transla√ß√£o vertical e, se

ùëè = 0, a transla√ß√£o ser√° horizontal. Nesse sentido ainda, √© poss√≠vel inferir que a transfor-

ma√ß√£o desloca os pontos horizontalmente uma dist√¢ncia indicada por ùëé e verticalmente

uma dist√¢ncia indicada por ùëè. Por esse motivo, a equa√ß√£o de transla√ß√£o 3.2 pode ser

3.2 Transforma√ß√µes Isom√©tricas

73

escrita na forma matricial:

ùëá (ùë•, ùë¶) =

[Ô∏É

]Ô∏É

¬∑

1 0

0 1

]Ô∏É

[Ô∏É

ùë•

ùë¶

+ ‚àí‚Üíùë£ , ùëúùëõùëëùëí ‚àí‚Üíùë£ =

[Ô∏É

]Ô∏É

ùëé

ùëè

Al√©m disso, as transla√ß√µes possuem as seguintes propriedades.

i A transla√ß√£o √© um movimento r√≠gido por preservar dist√¢ncias;

ii A composi√ß√£o de duas transla√ß√µes √© uma transla√ß√£o. Se todo ponto ùêæ de uma figura
plana Œ¶ √© transladado de um vetor ‚àí‚Üíùë£ 1 transformando ùêæ em ùêæ ‚Ä≤ e, posteriormente, de
um vetor ‚àí‚Üíùë£ 2 que transforma ùêæ ‚Ä≤ em ùêæ ‚Ä≤‚Ä≤, com isso, a transforma√ß√£o resultante levar√°
ùêæ em ùêæ ‚Ä≤‚Ä≤ pelo vetor ‚àí‚Üíùë£ 1 + ‚àí‚Üíùë£ 2. Ao prosseguir com esse paralelismo entre transla√ß√µes
e vetores validaremos que a composi√ß√£o de transla√ß√µes √© comutativa, isto √©, se ùëá‚àí‚Üíùë£ 1
translada Œ¶ na dire√ß√£o de ‚àí‚Üíùë£ 1 e ùëá‚àí‚Üíùë£ 2 na dire√ß√£o de ‚àí‚Üíùë£ 2, ent√£o ùëá‚àí‚Üíùë£ 1(ùëá‚àí‚Üíùë£ 2(Œ¶)) =
ùëá‚àí‚Üíùë£ 2(ùëá‚àí‚Üíùë£ 1(Œ¶)) = ùëá‚àí‚Üíùë£ 1+‚àí‚Üíùë£ 2(Œ¶) (Figura 25).

iii Uma transla√ß√£o admite sempre uma invers√£o. Para toda transla√ß√£o ùëá‚àí‚Üíùë£ √© sempre

poss√≠vel determinar uma transla√ß√£o ùëá ‚àí1

‚àí‚Üíùë£ = ùëá‚àí‚àí‚Üíùë£ tal que ùëá‚àí‚Üíùë£ (ùëá‚àí‚àí‚Üíùë£ (Œ¶)) = ùëá‚àí‚àí‚Üíùë£ (ùëá‚àí‚Üíùë£ (Œ¶)) =

Œ¶.

Figura 25: Composi√ß√£o de transla√ß√£o do ponto ùêæ em ùêæ ‚Ä≤‚Ä≤

3.2.2 Reflex√£o (ou Simetria) em rela√ß√£o a uma reta

Dentre os movimentos r√≠gidos, a reflex√£o ou simetria √© a transforma√ß√£o mais di-

fundida no Brasil em detrimento do ensino da √≥ptica geom√©trica. Sabe-se ainda que as

reflex√µes podem se dar em rela√ß√£o a um ponto ou a uma reta. E por isso, √© definida

a partir de uma reta ùëü do plano Œ†, onde a reflex√£o em torno da reta ùëü √© uma fun√ß√£o
ùëÜùëü : Œ† ‚Üí Œ†, tal que ùëÜùëü(ùêµ) = ùêµ para todo ùêµ ‚àà ùëü e, para ùëã /‚àà ùëü, ùëÜùëü(ùëã) = ùëã ‚Ä≤ √© tal que a
mediatriz do segmento ùëãùëã ‚Ä≤ √© a reta ùëü (Ver Figura 26).

3.2 Transforma√ß√µes Isom√©tricas

74

Figura 26: Reflex√£o

Considerando um sistema de coordenadas cartesianas no plano Œ† no qual um dos

eixos, abscissas ou ordenadas, coincida com a reta ùëü, ent√£o a cada ponto ùëã = (ùë•, ùë¶),
tem-se ùëÜùëü(ùëã) = (ùë•‚Ä≤, ùë¶‚Ä≤) = ùëã ‚Ä≤, onde ùëã ‚Ä≤ = (ùë•, ‚àíùë¶) ou ùëã ‚Ä≤ = (‚àíùë•, ùë¶), respectivamente, ver
Figura 27(a).

De modo geral, a rela√ß√£o entre as coordenadas do ponto ùëã com sua imagem re-
fletida, ùëã ‚Ä≤, na reta ùëü √© dada pelo sistema, conforme mostra as Figuras 27(a) e 27(b):

(a) Reflex√£o em rela√ß√£o aos eixos cartesi-
anos

(b) Reflex√£o em rela√ß√£o a 1a e 2a bissetriz

Figura 27: Reflex√£o no plano cartesiano

1. Reflex√£o em rela√ß√£o ao eixo das abscissas

‚éß
‚é®

ùë•‚Ä≤ = ùë•

‚é©

ùë¶‚Ä≤ = ‚àíùë¶

2. Reflex√£o em rela√ß√£o ao eixo das ordenadas

‚éß
‚é®

ùë•‚Ä≤ = ‚àíùë•

‚é©

ùë¶‚Ä≤ = ùë¶

3. Reflex√£o em rela√ß√£o a reta ùë¶ = ùë•, primeira bissetriz

‚éß
‚é®

ùë•‚Ä≤ = ùë¶

‚é©

ùë¶‚Ä≤ = ùë•

4. Reflex√£o em rela√ß√£o a reta ùë¶ = ‚àíùë•, segunda bissetriz

‚éß
‚é®

ùë•‚Ä≤ = ‚àíùë¶

‚é©

ùë¶‚Ä≤ = ‚àíùë•

3.2 Transforma√ß√µes Isom√©tricas

75

Outra reflex√£o importante √© em rela√ß√£o a um ponto fixo do plano. Sendo assim,
seja ùëã ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤) a imagem refletida do ponto ùëã = (ùë•, ùë¶) em rela√ß√£o ao ponto ùëÉ = (ùë•0, ùë¶0).
Como os pontos ùëã, ùëã ‚Ä≤ e ùëÉ s√£o colineares, ver Figura 28(a), tal que

ùëë(ùëã ‚Ä≤, ùëÉ ) = ùëë(ùëã, ùëÉ )

(3.3)

a express√£o correspondente a essa reflex√£o obtida a partir de (3.3) e com base na Figura

28(a), resume-se em:

(ùë•‚Ä≤, ùë¶‚Ä≤) = (ùë•0, ùë¶0) + (ùë•0 ‚àí ùë•, ùë¶0 ‚àí ùë¶) = (2ùë•0 ‚àí ùë•, 2ùë¶0 ‚àí ùë¶)

Logicamente, a lei de transforma√ß√£o ùëÜùëü : Œ† ‚Üí Œ† ser√° dada por:

ùëÜùëü(ùë•, ùë¶) = (ùë•‚Ä≤, ùë¶‚Ä≤) = (2ùë•0 ‚àí ùë•, 2ùë¶0 ‚àí ùë¶)

(3.4)

(a) Reflex√£o em rela√ß√£o a um ponto ùëã qualquer

(b) Reflex√£o em rela√ß√£o a uma reta ùëü qualquer

Figura 28: Reflex√£o em rela√ß√£o a um ponto e uma reta ùëü qualquer

Exemplo 3.2. A reflex√£o de um ponto qualquer ùëã = (ùë•, ùë¶) em rela√ß√£o √† origem do

sistema cartesiano (0, 0) fica assim determinada com base na equa√ß√£o (3.4):

ùëÜùëü(ùë•, ùë¶) = (ùë•‚Ä≤, ùë¶‚Ä≤) = (2 ¬∑ 0 ‚àí ùë•, 2 ¬∑ 0 ‚àí ùë¶) = (‚àíùë•, ‚àíùë¶)

No entanto, a reflex√£o de qualquer ponto ùëã do plano Œ† em rela√ß√£o a uma reta ùëü
do pr√≥prio plano, determina um ponto ùëã ‚Ä≤ que se mant√©m perpendicular a reta ùëü tal que

ùëë(ùëã, ùëü) = ùëë(ùëã ‚Ä≤, ùëü)

Nesse sentido, considere as coordenadas do ponto ùëã = (ùë•0, ùë¶0) e do seu sim√©trico
ùëã ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤) em rela√ß√£o a uma reta ùëü que faz um √¢ngulo ùõº com o eixo das abscissas no

3.2 Transforma√ß√µes Isom√©tricas

76

sentido anti-hor√°rio, conforme mostra a Figura 28(b). Como a equa√ß√£o cartesiana da reta

ùëü √© dada por:

onde ùëé = ùë°ùëî(ùõº) e ùëè = ùëê

ùëêùëúùë†(ùõº), para todo ùëê ‚àà R. Da√≠,

ùë¶ = ùëéùë• + ùëè,

ùëêùëúùë†(ùõº) ¬∑ ùë¶ ‚àí ùë†ùëíùëõ(ùõº) ¬∑ ùë• = ùëê

(3.5)

De modo an√°logo, a reta que une os pontos ùëã e ùëã ‚Ä≤ e, √© perpendicular a reta ùëü √© determi-

nada pela express√£o:

ùë¶ = ùë°ùëî(90o + ùõº) ¬∑ ùë• + ùêπ = ‚àíùëêùëúùë°ùëî(ùõº)ùë• + ùêπ,

onde ùêπ = ùëêùëúùë°ùëî(ùõº)ùë•0 + ùë¶0. Consequentemente,

ùëêùëúùë†(ùõº) ¬∑ ùë• + ùë†ùëíùëõ(ùõº) ¬∑ ùë¶ = ùëêùëúùë†(ùõº) ¬∑ ùë•0 + ùë†ùëíùëõ(ùõº) ¬∑ ùë¶0

(3.6)

Do fato da reta ùëü ser mediatriz do segmento ùëãùëã ‚Ä≤, tem-se o ponto ùëÄ = (ùëö, ùëõ)

(Figura 28(b)) como ponto m√©dio do referido segmento cujas coordenadas:

(ùëö, ùëõ) =

(Ô∏Ç ùë•0 + ùë•‚Ä≤
2

,

ùë¶0 + ùë¶‚Ä≤
2

)Ô∏Ç

(3.7)

s√£o a solu√ß√£o das equa√ß√µes (3.5) e (3.6). E isso implica no sistema,

‚éß
‚é®

‚é©

ùëêùëúùë†(ùõº) ¬∑ ùëõ ‚àí ùë†ùëíùëõ(ùõº) ¬∑ ùëö = ùëê

ùë†ùëíùëõ(ùõº) ¬∑ ùëõ + ùëêùëúùë†(ùõº) ¬∑ ùëö = ùëêùëúùë†(ùõº) ¬∑ ùë•0 + ùë†ùëíùëõ(ùõº) ¬∑ ùë¶0

Cuja solu√ß√£o √©:

(ùëö, ùëõ) = (Ô∏Äùëêùëúùë†2(ùõº)ùë•0 + ùëêùëúùë†(ùõº)ùë†ùëíùëõ(ùõº)ùë¶0 ‚àí ùë†ùëíùëõ(ùõº)ùëê, ùë†ùëíùëõ2(ùõº)ùë¶0 + ùëêùëúùë†(ùõº)ùë†ùëíùëõ(ùõº)ùë•0 + ùëêùëúùë†(ùõº)ùëê)Ô∏Ä

(Ô∏Ç

ùëêùëúùë†2(ùõº)ùë•0 +

=

ùë†ùëíùëõ(2ùõº)
2

ùë¶0 ‚àí ùë†ùëíùëõ(ùõº)ùëê, ùë†ùëíùëõ2(ùõº)ùë¶0 +

ùë†ùëíùëõ(2ùõº)
2

)Ô∏Ç

ùë•0 + ùëêùëúùë†(ùõº)ùëê

(3.8)

A partir da compara√ß√£o das igualdades constantes em (3.7) e (3.8) √© poss√≠vel esta-

belecer a express√£o alg√©brica do ponto sim√©trico ùëã ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤), isto √©:

(ùë•‚Ä≤, ùë¶‚Ä≤) = ùëÜùëü(ùë•0, ùë¶0) = (2ùëö ‚àí ùë•0, 2ùëõ ‚àí ùë¶0)
= (Ô∏Ä2ùëêùëúùë†2(ùõº)ùë•0 + ùë†ùëíùëõ(2ùõº)ùë¶0 ‚àí 2ùëêùë†ùëíùëõ(ùõº) ‚àí ùë•0, ùë†ùëíùëõ(2ùõº)ùë•0 + 2ùë†ùëíùëõ2(ùõº)ùë¶0 + 2ùëêùëúùë†(ùõº)ùëê ‚àí ùë¶0
= (Ô∏Ä[Ô∏Ä2ùëêùëúùë†2(ùõº) ‚àí 1]Ô∏Ä ùë•0 + ùë†ùëíùëõ(2ùõº)ùë¶0 ‚àí 2ùë†ùëíùëõ(ùõº)ùëê, ùë†ùëíùëõ(2ùõº)ùë•0 + [Ô∏Ä2ùë†ùëíùëõ2(ùõº) ‚àí 1]Ô∏Ä ùë¶0 + 2ùëêùëúùë†(ùõº)ùëê)Ô∏Ä

)Ô∏Ä

3.2 Transforma√ß√µes Isom√©tricas

77

= (ùëêùëúùë†(2ùõº)ùë•0 + ùë†ùëíùëõ(2ùõº)ùë¶0 ‚àí 2ùë†ùëíùëõ(ùõº)ùëê, ùë†ùëíùëõ(2ùõº)ùë•0 ‚àí ùëêùëúùë†(2ùõº)ùë¶0 + 2ùëêùëúùë†(ùõº)ùëê)

(3.9)

Por outro lado, sabe-se que a constante ùëê em (3.9), definida anteriormente na

equa√ß√£o da reta ùëü, corresponde a:

ùëè =

ùëê
ùëêùëúùë†(ùõº)

‚áî ùëê = ùëèùëêùëúùë†(ùõº)

(3.10)

Dessa forma, substitu√≠mos a express√£o (3.10) em (3.9) para determinar as coordenadas
alg√©bricas do ponto sim√©trico de ùëã, isto √©, as coordenadas de ùëã ‚Ä≤:

ùëÜùëü(ùë•, ùë¶) = (ùëêùëúùë†(2ùõº)ùë•0 + ùë†ùëíùëõ(2ùõº)ùë¶0 ‚àí ùë†ùëíùëõ(2ùõº)ùëè, ùë†ùëíùëõ(2ùõº)ùë•0 ‚àí ùëêùëúùë†(2ùõº)ùë¶0 + 2ùëêùëúùë†2(ùõº)ùëè) (3.11)

Exemplo 3.3. Obtenha o ponto sim√©trico de (2, 7) em rela√ß√£o a reta ùëü : ùë¶ =

‚àö

3ùë• + 2

com base na lei de simetria (3.11).

Solu√ß√£o:

‚àö

Note na equa√ß√£o da reta ùëü que seu coeficiente angular e linear s√£o ùëé =
‚àö

respectivamente. Como ùëé = ùë°ùëî(ùõº) =

3, ent√£o ùõº = ùúã

3 e ùëè = 2,
3 . Com isso, basta aplicar os dados

na express√£o alg√©brica (3.11) para obter o ponto sim√©trico de (2, 7), isto √©:

ùëÜùëü(2, 7) =

(Ô∏Å

2ùëêùëúùë†

(Ô∏Å

(Ô∏É

=

‚àí1 +

2

)Ô∏Å

ùúã
3
‚àö
3
5

2

(Ô∏Å

ùúã
2
3
)Ô∏É
3

+ 7ùë†ùëíùëõ

‚àö

,

9
2

+

)Ô∏Å

‚àí 2ùë†ùëíùëõ

)Ô∏Å

(Ô∏Å

2

ùúã
3

, 2ùë†ùëíùëõ

)Ô∏Å

(Ô∏Å

2

ùúã
3

‚àí 7ùëêùëúùë†

)Ô∏Å

(Ô∏Å

2

ùúã
3

+ 4ùëêùëúùë†2 (Ô∏Åùúã
3

)Ô∏Å)Ô∏Å

√â not√≥rio que sem a demonstra√ß√£o detalhada da lei de simetria para o caso de

qualquer reta ùëü do plano que os alunos do nono ano do ensino fundamental conseguir√°

aplicar o conhecimento, uma vez que o ensino da trigonometria j√° faz parte da matriz

curricular dessa seria√ß√£o. No entanto, nessa situa√ß√£o, em especial, a abordagem torna-

se mais completa quando aplicada no segundo ano do ensino m√©dio, onde o ensino da

trigonometria costuma ser mais detalhado.

Desse fato, visualizamos que nem todo o ensino de reflex√£o se faz sentido dentro

do ensino fundamental por necessitar de um conhecimento mais aprofundado da Matem√°-

tica, seja por meio do ensino da trigonometria ou por meio do ensino de matrizes como

apresentaremos a seguir.

As reflex√µes em rela√ß√£o aos eixos coordenados (ùëÇùë• e ùëÇùë¶), a origem do sistema e em

rela√ß√£o a primeira e a segunda bissetrizes podem ser representadas por uma transforma√ß√£o

3.2 Transforma√ß√µes Isom√©tricas

78

com representa√ß√£o matricial como podemos ver no esquema a seguir.

1. Simetria em rela√ß√£o ao eixo ùëÇùë• e a matriz de transforma√ß√£o ùëá =

ùëá (ùë•, ùë¶) =

[Ô∏É

1

0

]Ô∏É

[Ô∏É

]Ô∏É

ùë•

ùë¶

=

[Ô∏É

ùë•

]Ô∏É

‚àíùë¶

¬∑

0 ‚àí1

2. Simetria em rela√ß√£o ao eixo ùëÇùë¶ e a matriz de transforma√ß√£o ùëá =

ùëá (ùë•, ùë¶) =

[Ô∏É

‚àí1 0

0

1

]Ô∏É

[Ô∏É

¬∑

]Ô∏É

ùë•

ùë¶

=

[Ô∏É

]Ô∏É

‚àíùë•

ùë¶

[Ô∏É

1

]Ô∏É

0

0 ‚àí1

;

[Ô∏É

‚àí1 0

0

1

]Ô∏É

;

3. Simetria em rela√ß√£o a origem e a matriz de transforma√ß√£o ùëá =

ùëá (ùë•, ùë¶) =

[Ô∏É

‚àí1

]Ô∏É

0

0 ‚àí1

]Ô∏É

[Ô∏É

ùë•

ùë¶

¬∑

[Ô∏É

]Ô∏É

‚àíùë•

‚àíùë¶

=

[Ô∏É

‚àí1

0

]Ô∏É
;

0 ‚àí1

4. Simetria em rela√ß√£o a primeira bissetriz e a matriz de transforma√ß√£o ùëá =

[Ô∏É

]Ô∏É
;

0 1

1 0

ùëá (ùë•, ùë¶) =

[Ô∏É

0 1

1 0

]Ô∏É

[Ô∏É

¬∑

ùë•

ùë¶

]Ô∏É

[Ô∏É

=

]Ô∏É

ùë¶

ùë•

5. Simetria em rela√ß√£o a segunda bissetriz e a matriz de transforma√ß√£o ùëá =

[Ô∏É

]Ô∏É

0 ‚àí1

‚àí1

0

.

ùëá (ùë•, ùë¶) =

[Ô∏É

]Ô∏É

0 ‚àí1

‚àí1

0

[Ô∏É

‚àíùë¶

]Ô∏É

‚àíùë•

[Ô∏É

]Ô∏É

ùë¶

ùë•

=

¬∑

Uma observa√ß√£o importante ainda em rela√ß√£o as reflex√µes com base no pensamento

de Medeiros [29], refere-se as reflex√µes em rela√ß√£o aos pontos fora da origem que na vis√£o

da autora √© uma combina√ß√£o de uma simetria com transla√ß√µes, isto √©, basta transladarmos

o centro de simetria para a origem e a partir da√≠ realizarmos a simetria proposta em rela√ß√£o

a nova origem e, finalmente transladamos o centro de simetria para sua origem inicial. J√°,

as reflex√µes em rela√ß√£o a uma reta qualquer √© vista pela autora como uma combina√ß√£o da

simetria em rela√ß√£o ao eixo ùëÇùë• e uma rota√ß√£o.

Nesse sentido, √© importante destacar o pensamento de Souza [36, p.35] ao afirmar

que:

3.2 Transforma√ß√µes Isom√©tricas

79

A reflex√£o pode ser vista como um movimento r√≠gido realizado no espa√ßo,
retirando a figura da folha de papel e fazendo-a rotacionar com rela√ß√£o
ao eixo que utilizamos como ‚Äúespelho‚Äù at√© que ela novamente encontre o
papel, no outro semiplano.

Com base nesse pensamento, se faz necess√°rio definir a rota√ß√£o no plano e como

se efetua uma rota√ß√£o segundo a √≥tica da Matem√°tica.

3.2.3 Rota√ß√£o

Considere um ponto, ùëÇ, fixo no plano Œ† e um √¢ngulo de rota√ß√£o ùõº (convencionamos

tradicionalmente o sentido anti-hor√°rio como positivo) com v√©rtice em ùëÇ. Dizemos que a

rota√ß√£o de centro ùëÇ e amplitude ùõº √© uma transforma√ß√£o no plano Œ†, onde a transforma√ß√£o

ùëÖùõº : Œ† ‚Üí Œ† preserva dist√¢ncias e associa cada ponto ùëã do plano, com ùëã Ã∏= ùëÇ, o ponto
ùëã ‚Ä≤ = ùëÖùõº(ùëã) de forma que se tenha ùëã ‚Ä≤ como imagem de ùëã e os segmentos ùëÇùëã e ùëÇùëã ‚Ä≤ de
mesma medida e ùõº = ùëã ÃÇÔ∏ÄùëÇùëã ‚Ä≤ com o sentido de ùëã para ùëã ‚Ä≤ [34] (Ver Figura 29).

Figura 29: Rota√ß√£o do ponto ùëã com centro em ùëÇ e amplitude ùõº

Para todo ùëù inteiro, as rota√ß√µes de amplitudes ùõº + ùëù ¬∑ 360o s√£o id√™nticas. Nas
situa√ß√µes para 0o ‚â§ ùõº ‚â§ 360o, a rota√ß√£o de amplitude ‚àíùõº √© igual √† rota√ß√£o de amplitude
360o ‚àí ùõº.

Considere o plano cartesiano com ùëã = (ùë•, ùë¶) definido, a rota√ß√£o de centro definido

inicialmente em ùëÇ = (0, 0) e amplitude ùõº que transforma ùëã no ponto ùëã ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤).

No estudo dessa transforma√ß√£o suas coordenadas se apresentam melhor definidas

na forma polar, isto √©, as coordenadas do ponto ùëã em rela√ß√£o a origem do plano cartesiano

√© expressa por (ùë•, ùë¶) = (ùëüùëêùëúùë†(ùõΩ), ùëüùë†ùëíùëõ(ùõΩ)) em que ùëü representa a dist√¢ncia da origem ao

ponto ùëã e ùõΩ a amplitude do eixo ùë• ao segmento ùëÇùë•.

Para os discentes do 9o Ano do Ensino Fundamental, em especial, essa abordagem

torna-se vi√°vel pelas raz√µes trigonom√©tricas considerando o tri√¢ngulo ret√¢ngulo ùëÇùëãùêæ,

onde ùêæ √© o p√© da perpendicular baixada do ponto ùëã ao eixo ùëÇùë• (ver Figura 30(a)).

3.2 Transforma√ß√µes Isom√©tricas

80

1. Rota√ß√£o em torno da Origem: Dado o ponto ùëã = (ùëüùëêùëúùë†(ùõΩ), ùëüùë†ùëíùëõ(ùõΩ)) em que o

segmento ùëÇùëã = ùëü faz um √¢ngulo ùõΩ em rela√ß√£o ao eixo ùëÇùë•, conforme a Figura 30(a).

Sendo ùëã ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤) a imagem de ùëã pela rota√ß√£o de amplitude ùõº em rela√ß√£o ao centro na

origem apresentar√° suas coordenadas dada por:

(ùë•‚Ä≤, ùë¶‚Ä≤) = ùëÖùõº(ùë•, ùë¶) = (ùëüùëêùëúùë†(ùõº + ùõΩ), ùëüùë†ùëíùëõ(ùõº + ùõΩ))

= (ùëü(ùëêùëúùë†ùõºùëêùëúùë†ùõΩ ‚àí ùë†ùëíùëõùõºùë†ùëíùëõùõΩ), ùëü(ùë†ùëíùëõùõºùëêùëúùë†ùõΩ + ùë†ùëíùëõùõΩùëêùëúùë†ùõº))

= (ùë•ùëêùëúùë†ùõº ‚àí ùë¶ùë†ùëíùëõùõº, ùë•ùë†ùëíùëõùõº + ùë¶ùëêùëúùë†ùõº)

(3.12)

2. Rota√ß√£o em torno de um ponto C: As rota√ß√µes fora da origem √© determinada

com uma rota√ß√£o supondo uma nova origem cartesiana, para depois fazer uma

transla√ß√£o. Nesse sentido, vamos considerar o centro de rota√ß√£o ùê∂ = (ùë•0, ùë¶0) como

origem de um sistema cartesiano transladado ùë•0 unidades na abcissa e ùë¶0 unidades

na ordenada, ver Figura 30(b).

(a) Rota√ß√£o em torno da origem ùëÇ

(b) Rota√ß√£o em torno do ponto ùê∂ fora da ori-
gem

Figura 30: Rota√ß√£o do ponto ùëã e amplitude ùõº com centro na origem e no ponto C

Dessa forma, considere que o ponto ùëã = (ùë• ‚àí ùë•0, ùë¶ ‚àí ùë¶0) em rela√ß√£o a nova origem

ùê∂ como mostra a Figura 30(b), com isso a lei de transforma√ß√£o (3.12) assume a forma:

(ùë•‚Ä≤, ùë¶‚Ä≤) = ùëÖùõº(ùë•, ùë¶) = ([ùë• ‚àí ùë•0]ùëêùëúùë†ùõº ‚àí [ùë¶ ‚àí ùë¶0]ùë†ùëíùëõùõº, [ùë• ‚àí ùë•0]ùë†ùëíùëõùõº + [ùë¶ ‚àí ùë¶0]ùëêùëúùë†ùõº)

(3.13)

Contudo, as coordenadas do ponto ùëã ‚Ä≤ conforme (3.13) considera o ponto ùê∂ como origem

do sistema cartesiano transladado. Para escrever as coordenadas desse ponto em rela√ß√£o

√† origem ùëÇ adicionamos as coordenadas do ponto ùê∂, obtendo assim a express√£o alg√©brica

que representa a rota√ß√£o do ponto ùëã segundo uma amplitude ùõº com centro em ùê∂ =

3.2 Transforma√ß√µes Isom√©tricas

81

(ùë•0, ùë¶0), conforme mostra a Figura 30(b).

ùëÖùõº(ùë•, ùë¶) = (ùë•0 + [ùë• ‚àí ùë•0]ùëêùëúùë†ùõº ‚àí [ùë¶ ‚àí ùë¶0]ùë†ùëíùëõùõº, ùë¶0 + [ùë• ‚àí ùë•0]ùë†ùëíùëõùõº + [ùë¶ ‚àí ùë¶0]ùëêùëúùë†ùõº)

(3.14)

Exemplo 3.4. Considere o centro de rota√ß√£o ùê∂ = (2, 3) e um ponto qualquer do plano
ùë•ùëÇùë¶, isto √©, ùëã = (ùë•, ùë¶) tal que ùëã ‚Ä≤ seja a imagem rotacionada do ponto ùëã segundo
um √¢ngulo de 90o. Com base nessa informa√ß√£o, √© poss√≠vel inferir que a express√£o que

determinar o lugar geom√©trico de todas as poss√≠veis imagens do ponto ùëã √© dada por:

Solu√ß√£o:

Com base na lei de rota√ß√£o (3.14) e nos dados do exemplo, a express√£o ser√° dada por:

ùëÖùõº(ùë•, ùë¶) = (2 + [ùë• ‚àí 2]ùëêùëúùë†(90o) ‚àí [ùë¶ ‚àí 3]ùë†ùëíùëõ(90o), 3 + [ùë• ‚àí 2]ùë†ùëíùëõ(90o) + [ùë¶ ‚àí 3]ùëêùëúùë†(90o))

= (2 ‚àí ùë¶ + 3, 3 + ùë• ‚àí 2)

= (5 ‚àí ùë¶, 1 + ùë•)

Portanto, podemos definir que a transforma√ß√£o de rota√ß√£o

ùëÖùõº(ùë•, ùë¶) = (ùë•ùëêùëúùë†ùõº ‚àí ùë¶ùë†ùëíùëõùõº, ùë•ùë†ùëíùëõùõº + ùë¶ùëêùëúùë†ùõº)

√© associada na forma matricial por:

ùëÖùõº(ùë•, ùë¶) =

[Ô∏É

ùëêùëúùë†ùõº ‚àíùë†ùëíùëõùõº

ùë†ùëíùëõùõº

ùëêùëúùë†ùõº

]Ô∏É

[Ô∏É

=

]Ô∏É

[Ô∏É

¬∑

ùë•

ùë¶

ùë•ùëêùëúùë†ùõº ‚àí ùë¶ùë†ùëíùëõùõº

ùë¶ùë†ùëíùëõùõº + ùë¶ùëêùëúùë†ùõº

]Ô∏É

[Ô∏É

=

]Ô∏É

ùë•‚Ä≤
ùë¶‚Ä≤

Salienta-se que a matriz de transforma√ß√£o da rota√ß√£o possui o determinante uni-

t√°rio, e isso implica que a transforma√ß√£o √© isom√©trica, isto √©, preserva dist√¢ncias, √¢ngulos

e √°reas.

‚Éí
‚Éí
‚Éí
‚Éí
‚Éí

ùëêùëúùë†ùõº ‚àíùë†ùëíùëõùõº

ùë†ùëíùëõùõº

ùëêùëúùë†ùõº

‚Éí
‚Éí
‚Éí
‚Éí
‚Éí

= ùëêùëúùë†2ùõº ‚àí (‚àíùë†ùëíùëõ2ùõº) = ùëêùëúùë†2ùõº + ùë†ùëíùëõ2ùõº = 1

Nesse ponto ainda √© poss√≠vel definir que uma reflex√£o em rela√ß√£o a origem √© exa-

tamente igual √† uma rota√ß√£o de 180o centrada em ùëÇ.

Como podemos confirmar, as transforma√ß√µes isom√©tricas mant√©m preservadas tanto

a dist√¢ncia, como os √¢ngulos e as √°reas, e isso, n√£o √© mantido nas demais transforma√ß√µes

isom√≥rficas e anam√≥rficas.

3.3 Transforma√ß√µes Isom√≥rficas

82

3.3 Transforma√ß√µes Isom√≥rficas

As transforma√ß√µes isom√≥rficas na concep√ß√£o de Lira [37] s√£o as transforma√ß√µes de

semelhan√ßa e homotetia, e possuem a propriedade de modificar o tamanho mantendo a

forma da figura inicial com a mesma amplitude entre segmentos correspondentes.

3.3.1 Homotetia

A homotetia com centro ùëÇ no plano Œ† e uma raz√£o ùëò Ã∏= 0 √© a transforma√ß√£o

ùêªùëÇ,ùëò : Œ† ‚Üí Œ† que a cada ponto ùëã ‚àà Œ† associa o ponto ùëã ‚Ä≤ = ùêªùëÇ,ùëò(ùëã), tal que

‚àí‚àí‚Üí
ùëÇùëã ‚Ä≤ = ùëò ¬∑

‚àí‚àí‚Üí
ùëÇùëã

Com base nessa informa√ß√£o, considere ùëã = (ùë•, ùë¶) e sua imagem ùëã ‚Ä≤ = (ùë•‚Ä≤, ùë¶‚Ä≤)

no sistema de coordenadas cartesianas do plano Œ† com uma figura Œ¶ do mesmo plano,

dizemos que a homotetia que associa a cada ponto ùëã de Œ¶ √© dada por:

ou ainda, pelo sistema:

ùêªùëÇ,ùëò(ùë•, ùë¶) = (ùëò ¬∑ ùë•, ùëò ¬∑ ùë¶) = ùëã ‚Ä≤

‚éß
‚é®

ùë•‚Ä≤ = ùëò ¬∑ ùë•

‚é©

ùë¶‚Ä≤ = ùëò ¬∑ ùë¶

Como ùëò √© um n√∫mero real diferente de zero, as figuras semelhantes a Œ¶ ser√£o

uma homotetia direta da figura inicial se ùëò > 0 e inversa nos casos em que ùëò < 0. E

nas situa√ß√µes em que ùëò = 1 ou ùëò = ‚àí1 dizemos que a homotetia √© uma transforma√ß√£o

identidade (congruente) ou uma transforma√ß√£o sim√©trica em rela√ß√£o ao ponto de origem
ùëÇ (ou rota√ß√£o de 180o em torno de ùëÇ), respectivamente.

Ressalta-se ainda que:

‚àô Se 0 < |ùëò| < 1, as figuras Œ¶‚Ä≤ resultantes dessa transforma√ß√£o ser√£o reduzidas em

rela√ß√£o √† original (Œ¶), no mesmo sentido de Œ¶ se ùëò > 0 e sentido invertido se ùëò < 0,

ver Figura 31(a).

‚àô Se |ùëò| > 1, as figuras Œ¶‚Ä≤ ser√£o resultantes de uma amplia√ß√£o da figura Œ¶ de mesmo

sentido para ùëò > 0 e sentido invertido para ùëò < 0, ver Figura 31(b).

Dessa forma, conclu√≠mos que a homotetia √© uma transforma√ß√£o que preserva apenas

os √¢ngulos construindo imagens semelhantes de raz√£o ùëò Ã∏= 0. E por esse motivo a lei de

3.4 Transforma√ß√µes Anam√≥rficas

83

(a) Homotetia de redu√ß√£o

(b) Homotetia de amplia√ß√£o

Figura 31: Homotetia de redu√ß√£o (0 < |ùëò| < 1) e amplia√ß√£o |ùëò| > 1

transforma√ß√£o

ùêªùëÇ,ùëò(ùë•, ùë¶) = (ùëò ¬∑ ùë•, ùëò ¬∑ ùë¶) = (ùë•‚Ä≤, ùë¶‚Ä≤)

√© associada a matriz de transforma√ß√£o

ùêªùëÇ,ùëò(ùë•, ùë¶) =

[Ô∏É

ùëò 0

0 ùëò

]Ô∏É

[Ô∏É

¬∑

]Ô∏É

ùë•

ùë¶

=

[Ô∏É

]Ô∏É

ùëòùë•

ùëòùë¶

]Ô∏É

[Ô∏É

ùë•‚Ä≤
ùë¶‚Ä≤

=

√â not√≥rio que o determinante associado a matriz de transforma√ß√£o √© dado por ùëò2, e isso,

justifica o fato de n√£o preservar dist√¢ncias e a √°rea como acontece com as transforma√ß√µes

isom√©tricas.

3.4 Transforma√ß√µes Anam√≥rficas

As transforma√ß√µes que deformam (ampliam ou reduzem) as figuras no sentido

horizontal em propor√ß√£o diferente do sentido vertical n√£o podem ser consideradas homo-

tetias como aponta Stormowski[6] e alguns autores classificam essa transforma√ß√£o como

anam√≥rfica [37].

Podemos afirmar ent√£o que essa transforma√ß√£o quando aplicada a uma figura Œ¶

do plano Œ†, modifica sua posi√ß√£o, tamanho e a pr√≥pria forma original da figura. Por esse
motivo, as fun√ß√µes ùê¥ : Œ† ‚Üí Œ†‚Ä≤ onde para cada ùëã ‚àà Œ† , tem-se ùê¥(ùëã) = ùëã ‚Ä≤ de forma que ùëã ‚Ä≤

n√£o conserva as caracter√≠sticas da figura original. Dentre as transforma√ß√µes anam√≥rficas

destacaremos a dilata√ß√£o, sendo que existe ainda a contra√ß√£o vertical e horizontal e o

cisalhamento.

3.4 Transforma√ß√µes Anam√≥rficas

84

3.4.1 Dilata√ß√£o

A dilata√ß√£o √© uma transforma√ß√£o que gera deforma√ß√£o na dire√ß√£o do eixo ùëÇùë•

de acordo com um fator ùëò1, e na dire√ß√£o do eixo ùëÇùë¶ pelo fator ùëò2. Dessa forma, as
coordenadas do ponto ùëã ‚Ä≤ obtida a partir de ùëã √© expressa por:

‚éß
‚é®

ùë•‚Ä≤ = ùëò1 ¬∑ ùë•

‚é©

ùë¶‚Ä≤ = ùëò2 ¬∑ ùë¶

Salienta-se que se ùëò1 > ùëò2, a dilata√ß√£o ser√° na horizontal, ver Figura 32(a). Do

contr√°rio, a dilata√ß√£o ser√° na vertical, ver Figura 32(b).

(a) Dilata√ß√£o horizontal com ùëò1 > ùëò2

(b) Dilata√ß√£o vertical com ùëò1 < ùëò2

Figura 32: Dilata√ß√£o horizontal e vertical

Para essa transforma√ß√£o a matriz de transforma√ß√£o associada apresenta a seguinte

lei:

ùê¥(ùë•, ùë¶) =

[Ô∏É

ùëò1

0

]Ô∏É

¬∑

0

ùëò2

]Ô∏É

[Ô∏É

ùë•

ùë¶

=

[Ô∏É

ùëò1ùë•

ùëò1ùë¶

]Ô∏É

[Ô∏É

=

]Ô∏É

ùë•‚Ä≤
ùë¶‚Ä≤

Dessa an√°lise, conclu√≠mos as abordagens das transforma√ß√µes geom√©tricas quanto

ao quesito matem√°tico e passaremos a apresentar uma abordagem integradora das trans-

forma√ß√µes com a linguagem de programa√ß√£o Processing.

85

4 Transforma√ß√µes Geom√©tricas em

Processing

As transforma√ß√µes geom√©tricas se relacionam com a computa√ß√£o gr√°fica segundo

dois aspectos apontados por Velho [38]:

‚àô Mudan√ßa de Coordenadas feita atrav√©s de uma transforma√ß√£o do espa√ßo Œ† e √©

utilizado para obter a devida formula√ß√£o anal√≠tica do problema e;

‚àô Deforma√ß√£o de objetos do espa√ßo Œ†, tais deforma√ß√µes se dividem em duas

classes:

As deforma√ß√µes r√≠gidas conhecidas por mudar a posi√ß√£o dos objetos no pr√≥prio

espa√ßo sem alterar suas rela√ß√µes m√©tricas e s√£o chamadas tamb√©m de isometrias ou

movimentos r√≠gidos (sec√ß√£o 3.2) e;

As deforma√ß√µes n√£o-r√≠gidas que caracterizam-se por alterar as rela√ß√µes m√©tricas dos

objetos e s√£o conhecidas como transforma√ß√µes isom√≥rficas (sec√ß√£o 3.3) e anam√≥rficas

(sec√ß√£o 3.4).

No entanto, a abordagem dessas transforma√ß√µes n√£o revelou-se suficiente para com-

preender como se comporta a geometria na √≥tica da computa√ß√£o gr√°fica. Segundo Velho

[38, p. 21], definir ‚Äúo modelo adequado de geometria √© importante para colocar e resolver

corretamente os problemas tanto do ponto de vista conceitual quanto de implementa√ß√£o‚Äù.

Em fun√ß√£o disso, o referido autor discute em seu livro de Fundamentos da Computa√ß√£o

Gr√°fica qual deve ser a geometria adotada na computa√ß√£o gr√°fica apresentando o con-

ceito de Geometria Axiom√°tico de Euclides, a Geometria Anal√≠tica de Ren√© Descartes e

o conceito de grupo de transforma√ß√£o introduzido por Felix Klein.

Esse autor recorre a alguns conceitos da √Ålgebra Linear, tais como Transforma-
√ß√µes Lineares (Ap√™ndice A) e Transforma√ß√µes Ortogonais 1 para definir que a isometria

possui uma caracteriza√ß√£o euclidiana resultante de uma transforma√ß√£o linear ortogonal.

1Para mais detalhes consulte Velho [38, p. 27, 28].

CAP√çTULO 4. TRANSFORMA√á√ïES GEOM√âTRICAS EM PROCESSING

86

Com isso, foi poss√≠vel mostrar que a transla√ß√£o n√£o √© uma transforma√ß√£o linear, por n√£o

preservar as opera√ß√µes do espa√ßo e nem faz parte da √°lgebra de transforma√ß√µes do espa√ßo

euclidiano, visto que a transforma√ß√£o √© uma isometria, sem necessariamente ser Linear

se, e somente se;

ùëá (ùë¢) = ùêø(ùë¢) + ùë£ùëú

onde ùêø √© uma transforma√ß√£o linear ortogonal e ùë£ùëú um vetor fixo.

Diante do exposto, conclu√≠mos que a Geometria Euclidiana n√£o √© a mais indi-

cada para a computa√ß√£o gr√°fica. Entretanto, a implementa√ß√£o da Geometria Afim e da
Transforma√ß√£o Afim2 apresenta-se como uma excelente escolha por incluir nas transfor-

ma√ß√µes afins, os movimentos r√≠gidos da Geometria Euclidiana, al√©m de ser representado

por matrizes que vislumbram uma estrutura computacional simples.

Contudo, somente com √† Geometria Projetiva que foi poss√≠vel resolver o problema

no processo de visualiza√ß√£o de uma transforma√ß√£o fotogr√°fica por n√£o preservar retas

paralelas em uma estrada quando analisamos uma fotografia.

(a)

(b)

Figura 33: Fotografia de uma estrada

A Geometria Projetiva do ponto de vista de Velho [38] √© uma extens√£o natural da

Geometria Afim que por sua vez estende o campo de atua√ß√£o da Geometria Euclidiana.

E a partir do conceito de visualiza√ß√£o, esse autor define o espa√ßo projetivo como sendo

uma proje√ß√£o c√¥nica e isso justifica o fato das retas paralelas da estrada (Figura 33(b)) se

encontrarem em um ponto localizado no horizonte para onde convergem os lados paralelos,

visto que no espa√ßo projetivo n√£o existem retas paralelas.

A necessidade de definir qual a geometria adotada pela computa√ß√£o gr√°fica encontra-

se no fato de definir uma forma √∫nica para representar a transla√ß√£o que √© a soma de vetores,

a rota√ß√£o e a escala (simetria) que √© a multiplica√ß√£o de um vetor por uma matriz.

A solu√ß√£o para representa-las de forma √∫nica encontra-se nas coordenadas homo-

g√™neas das transforma√ß√µes projetivas (Ap√™ndice B) e como cada transforma√ß√£o possui sua

2Ver Velho [38, p. 28‚Äì 35]

4.1 Transforma√ß√µes isom√©tricas no Processing

87

propriedade caracter√≠stica, podemos concluir que as matrizes para as transforma√ß√µes em

coordenadas homog√™neas s√£o dadas por:

ùëá (ùë•, ùë¶) =

‚é°

‚é¢
‚é¢
‚é£

1 0 ùë°ùë•

0 1 ùë°ùë¶

0 0

1

‚é§

‚é•
‚é•
‚é¶

, ùê∏(ùë•, ùë¶) =

‚é°

‚é¢
‚é¢
‚é£

ùëÜùë•

0

0

0 ùëÜùë¶ 0

0

0

1

‚é§

‚é•
‚é•
‚é¶

ùëí ùëÖ(ùë•, ùë¶) =

‚é°

‚é¢
‚é¢
‚é£

ùëêùëúùë†(ùõº) ‚àíùë†ùëíùëõ(ùõº) 0

ùë†ùëíùëõ(ùõº)

ùëêùëúùë†(ùõº)

0

0

0

1
(4.1)

‚é§

‚é•
‚é•
‚é¶

Onde as transforma√ß√µes ùëá , ùê∏ e ùëÖ s√£o respectivamente, transla√ß√£o, escala3 e rota-

√ß√£o.

No caso das simetrias em rela√ß√£o a primeira e a segunda bissetriz, respectivamente,

a matriz de transforma√ß√£o ùê∏ ser√° dada por

ùê∏(ùë•, ùë¶) =

‚é°

‚é¢
‚é¢
‚é£

‚é§

‚é•
‚é•
‚é¶

0 1 0

1 0 0

0 0 1

ùëí ùê∏(ùë•, ùë¶) =

‚é°

‚é¢
‚é¢
‚é£

0 ‚àí1 0

‚àí1

0

0

0

0

1

‚é§

‚é•
‚é•
‚é¶

Observa-se com isso, qual a geometria adotada na Computa√ß√£o Gr√°fica e como

esse sistema construi as TGP na tela. Da√≠, passamos a apresentar as ferramentas do

Processing, respons√°veis por tais efeitos de design gr√°fico.

4.1 Transforma√ß√µes isom√©tricas no Processing

Conforme apresentamos na sec√ß√£o 3.2, as transforma√ß√µes isom√©tricas s√£o: Transla-

√ß√£o, Simetria e Rota√ß√£o. Diante disso, vamos apresentar como o Processing executa cada

uma dessas transforma√ß√µes e o comando necess√°rio para tal efeito gr√°fico.

Come√ßaremos pela transla√ß√£o cuja fun√ß√£o √© ativa pelo termo translate (). Essa

fun√ß√£o move a origem da figura do canto superior esquerdo da tela para outro ponto. Seu

deslocamento gr√°fico consiste em descolar seus par√¢metros ùë• e ùë¶, nessa ordem.

Dessa forma, sua fun√ß√£o √© chamada com a sintaxe ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùë•, ùë¶) que adiciona

os valores dos par√¢metros ùë• e ùë¶ a quaisquer formas desenhadas ap√≥s a execu√ß√£o da fun√ß√£o.

A transla√ß√£o viabiliza a constru√ß√£o de figuras no estilo das obras de Escher, como mostra

a Figura 34(b) constru√≠da com o c√≥digo da transla√ß√£o de um tri√¢ngulo ret√¢ngulo com um

dos pontos na origem, ver Figura 34(a).

3Escala s√£o as transforma√ß√µes de reflex√µes, assim como as homotetias, dilata√ß√µes entre outros efeitos

anam√≥rficos para a computa√ß√£o gr√°fica.

4.1 Transforma√ß√µes isom√©tricas no Processing

88

(b) Transla√ß√£o de tri√¢ngulo

(a) Comando com fun√ß√£o ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùë•, ùë¶)

Figura 34: Constru√ß√£o de tri√¢ngulos ret√¢ngulos com efeito de transla√ß√£o

Nota-se que o c√≥digo de transla√ß√£o oscila deslocando a √∫ltima imagem constru√≠da

para uma nova posi√ß√£o. Nesse sentido, o programa oferece uma ferramenta intitulada

de ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë• que s√£o incorporada nas transforma√ß√µes para ampliar

seu alcance. A ferramenta ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë• funciona basicamente salvando o atual sistema

de coordenadas para a pilha matricial enquanto a fun√ß√£o ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë• restaura o sistema

antes de deslocar as coordenadas como podemos perceber na Figura 35.

Se analisarmos o c√≥digo de transla√ß√£o da Figura 35, √© poss√≠vel constatar que o

comando ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(80, 0); √© o mesmo para todos os tri√¢ngulos na mesma linha modificando

apenas quando transladamos o tri√¢ngulo inicialmente de preto para a segunda linha da

imagem, para voltar ao mesmo comando de transla√ß√£o anterior, conforme mostra a Figura

34(b).

A fun√ß√£o de Simetria √© ativada no Processing pela sintaxe ùë†ùëêùëéùëôùëí(ùë•, ùë¶) que reflete

a figura em rela√ß√£o aos eixos ùë• e ùë¶, quando a origem dos mesmo √© deslocada para o meio

da tela ao associar os valores 1 ou ‚àí1 para os par√¢metros dos eixos.

Sendo assim, para construir uma imagem sim√©trica no Processing precisamos ini-

cialmente de uma figura, preferencialmente, relacionada com o centro da tela que pode

ser obtida com uma transla√ß√£o para enfim executar a simetria ora em rela√ß√£o ao eixo

das abscissas, ora em rela√ß√£o aos eixos das ordenadas, ou ainda em rela√ß√£o a origem do

4.1 Transforma√ß√µes isom√©tricas no Processing

89

Figura 35: C√≥digo de Transla√ß√£o com a fun√ß√£o ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë• e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•

sistema cartesiano deslocado.

Com base nessa informa√ß√£o, consideremos o eixo ùë•‚Ä≤ùëÇ‚Ä≤ùë¶‚Ä≤ com origem deslocada

para o centro da tela (150, 150) e um tri√¢ngulo no quarto quadrante (cor ‚Äúroxa‚Äù). Para
transladar esse tri√¢ngulo em torno dos novos eixos, ùë•‚Ä≤ e ùë¶‚Ä≤, e em torno da nova origem ùëÇ‚Ä≤

utilizamos a linha de comando como mostra na Figura 36(a) para obtermos o efeito de

uma imagem similar a um escudo medieval, ver Figura 36(b).

Ao executar os comandos relacionados da Figura 36(a) constatamos que a ordem de

lan√ßamento dos comandos interfere diretamente nas imagens sim√©tricas proporcionada e a

justificativa √© facilmente obtida no pr√≥prio programa ao lan√ßar o comando ùëùùëüùëñùëõùë°ùëÄ ùëéùë°ùëüùëñùë•();

que imprime no console do aplicativo a matriz de transforma√ß√£o associada a simetria

transladada. Para cada simetria existe um produto na matriz de transforma√ß√£o associada

utilizando o contexto de composi√ß√£o de transforma√ß√µes.

Para evitar esse efeito podemos inserir os comandos de simetria, com o preenchi-

mento e as formas geom√©tricas entre cada ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() como aparece

abaixo, referenciando a simetria esperada diretamente no comando ùë†ùëêùëéùëôùëí.

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(‚àí1, 1); //cor ‚Äúazul‚Äù

ùë†ùëêùëéùëôùëí(1, ‚àí1); //cor ‚Äúverde‚Äù

ùëì ùëñùëôùëô(140, 150, 250);

ùëì ùëñùëôùëô(40, 150, 90);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 150, 80, 120, 80, 0);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 150, 80, 120, 80, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

4.1 Transforma√ß√µes isom√©tricas no Processing

90

(b) Simetria de tri√¢ngulo

(a) Comando da fun√ß√£o ùë†ùëêùëéùëôùëí(ùë•, ùë¶) com ùë•, ùë¶ ‚àà
{‚àí1, 1}

Figura 36: Constru√ß√£o de tri√¢ngulos com efeito de simetria

Para as transforma√ß√µes de rota√ß√£o no plano o programa utiliza a sintaxe rotate(ùúÉ),

onde ùúÉ √© o √¢ngulo dado em radianos e o sentido positivo da rota√ß√£o √© o hor√°rio, j√° o anti-

hor√°rio na linguagem de programa√ß√£o √© o sentido negativo. Nesse sentido, para o aluno

compreender os efeitos da rota√ß√£o ser√° necess√°rio algumas no√ß√µes de convers√£o de √¢ngulo

de grau para radianos e vice-versa. Al√©m disso, para visualizar a rota√ß√£o √© necess√°rio que

a imagem esteja prioritariamente na proximidade do centro da tela atrav√©s do recurso de

transla√ß√£o para centralizar a constru√ß√£o.

roxa, e as rota√ß√µes de amplitude 3ùúã

Sendo assim, considere um tri√¢ngulo deslocado para a nova origem (150, 150), cor
2 radianos. Com os comandos ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e
ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•(), o sistema armazena os c√≥digos, ver Figura 37(a), e executa no sentido in-

2 , ùúã, ùúã

verso da composi√ß√£o das transforma√ß√µes, isto √©, da √∫ltima linha do comando ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•()

at√© a √∫ltima entrada no ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•(), o resultado destes comandos gera uma imagem

similar ao cata-vento de papel, ver Figura 37(b).

Cada nova rota√ß√£o executa um produto na matriz homog√™nea da transforma√ß√£o

deslocando a √∫ltima pe√ßa rotacionada. As transforma√ß√µes sucessivas nesta linguagem

interagem-se na ordem inversa para a constru√ß√£o como mostra o fluxograma. [38(b)], as

constru√ß√µes com o comando pushMatrix(); e popMatrix(); executa a √∫ltima constru√ß√£o

4.1 Transforma√ß√µes isom√©tricas no Processing

91

(b) Rota√ß√£o de tri√¢ngulo

(a) Comando com fun√ß√£o ùëüùëúùë°ùëéùë°ùëí(ùúÉ) com 0 ‚â§ ùúÉ ‚â§ 2ùúã

Figura 37: Constru√ß√£o de tri√¢ngulos com efeito de rota√ß√£o

como se estivesse a remover uma pe√ßa da torre de h√°noi.

(a) Fluxograma dos c√≥digos no Processing

(b) Fluxograma na ordem de constru√ß√£o

Figura 38: Fluxograma com esquema de uma rota√ß√£o no Processing

A inclus√£o dos comandos de preenchimento e formas geom√©tricas entre ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•()

e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() evitar√° o efeito do produto entre as matrizes como acontece com a simetria

anterior, entretanto, ser√° necess√°rio redefinir uma nova ordem para as amplitudes.

4.2 Transforma√ß√µes isom√≥rficas no Processing

92

4.2 Transforma√ß√µes isom√≥rficas no Processing

Conforme apresentamos na sec√ß√£o 3.3, a homotetia √© uma transforma√ß√£o isom√≥r-

fica. E, vamos apresentar como o Processing executa esta transforma√ß√£o com o comando
ùë†ùëêùëéùëôùëí(ùëò, ùëò); com ùëò ‚àà R+.

Em fun√ß√£o da limita√ß√£o visual da linguagem apenas no quadrante positivo do

sistema, ou seja, no sistema global da tela, a constante ùëò est√° definida para todo n√∫mero

real positivo. Neste sentido, toda a constru√ß√£o de amplia√ß√£o ser√° dada por ùëò > 1 e

a redu√ß√£o por 0 < ùëò < 1. Salienta-se ainda que m√∫ltiplas homotetias s√£o obtida pelo

produto das matrizes de transforma√ß√£o associadas a este efeito visual.

(b) Homotetia no quadrado

(a) Homotetia com fatores ùëò = {0, 25; 2; 4}

Figura 39: Constru√ß√£o de quadrados com efeito de amplia√ß√£o e redu√ß√£o

Desta forma, considere o c√≥digo 39(a) da Figura 39(b). A transforma√ß√£o foi cons-

tru√≠da utilizando constantes ùëò = {0, 25; 2; 4}, no entanto, suas imagens possuem, res-

pectivamente, raz√µes {0, 25; 0, 5; 2} em fun√ß√£o do produto das matrizes de transforma√ß√£o

associadas a cada etapa da constru√ß√£o. Por este motivo, compete aqui salientar a impor-

4.3 Transforma√ß√µes anam√≥rficas no Processing

93

t√¢ncia na ordem dos dados a serem ‚Äúalimentados‚Äù na linguagem para o aplicativo funcionar

dentro dos conformes desejados e na forma de implementar as fun√ß√µes ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() para evitar o efeito de produtos matriciais.

Com a combina√ß√£o de uma transla√ß√£o na homotetia, o ponto de origem desta

transforma√ß√£o seria deslocada para as coordenadas da transla√ß√£o desejada e, consequen-

temente, toda a constru√ß√£o ser√° transladada mantendo as devidas propor√ß√µes.

4.3 Transforma√ß√µes anam√≥rficas no Processing

Para finalizar a apresenta√ß√£o das ferramentas da linguagem Processing para o

estudo das transforma√ß√µes planas, iremos utilizar a fun√ß√£o ùë†ùëêùëéùëôùëí(ùëò1, ùëò2) para construir

dilata√ß√µes no sentido horizontal e vertical considerando sempre ùëò1 Ã∏= ùëò2. Neste sentido,

a dilata√ß√£o provocar√° uma distor√ß√£o na imagem no sentido horizontal, quando ùëò1 > ùëò2,

e no caso, de ùëò1 < ùëò2, a distor√ß√£o da dilata√ß√£o ser√° vertical, como podemos perceber no

c√≥digo 40(a) e na imagem 40(b).

(b) dilata√ß√£o do c√≠rculo

(a) dilata√ß√£o horizontal e vertical

Figura 40: Constru√ß√£o de c√≠rculos com dilata√ß√£o horizontal e vertical

Com o conhecimento matem√°tico sobre as TGPs e com a linguagem de progra-

ma√ß√£o Processing sintetiza este conhecimento, iremos abordar um conjunto de atividades

para serem executadas pelos discentes do nono Ano da Unidade Escolar Am√©lia Rodrigues,

no referido laborat√≥rio de inform√°tica Unidade Escolar.

Em fun√ß√£o da limita√ß√£o did√°tica dos alunos para compreenderem com dom√≠nio

4.3 Transforma√ß√µes anam√≥rficas no Processing

94

as principais opera√ß√µes matem√°ticas envolvendo a TGP, abordaremos a tem√°tica utili-

zando a pr√≥pria linguagem e os efeitos que tais transforma√ß√µes executam na proje√ß√£o de

imagens. Desta forma, objetivamos uma aprendizagem pr√°tica visando a manipula√ß√£o

em detrimento da teoria pela teoria, isto √©, os envolvidos no programa reconheceram as

transforma√ß√µes atrav√©s de seus efeitos visuais e assim poder√£o classificar o efeito gr√°fico

sem utilizar a conceitua√ß√£o matem√°tica, principalmente no que discerne a utiliza√ß√£o de

matrizes e transforma√ß√µes lineares.

95

5 Atividades Propostas

Neste cap√≠tulo, apresentaremos uma sequ√™ncia de atividades did√°ticas referentes

√† constru√ß√£o do conceito das TGPs. Para a elabora√ß√£o das atividades, utilizaremos a

linguagem processing com base nas informa√ß√µes constante nos cap√≠tulos 2 e 4 suprimindo

ao m√°ximo a linguagem matem√°tica do cap√≠tulo 3, em fun√ß√£o da pr√≥pria limita√ß√£o did√°tica

dos envolvidos, sem perder de vista sua interpreta√ß√£o geom√©trica que √© o foco desta

pesquisa. Sendo assim, as atividades que propomos √© viabilizada pela mobiliza√ß√£o das

formas do pensamento matem√°tico que s√£o, nas palavras de Lage [39, p.6]:

[...] modos de pensar que contribuem para desenvolver as capacidades
de raciocinar, testar, experimentar, procurar rela√ß√µes, descobrir, comu-
nicar e nas atividades investigativas, que incentivam a curiosidade, o
interesse e a perserveran√ßa dos alunos por meio da cultura da explora√ß√£o
e investiga√ß√£o matem√°tica.

Dentre os h√°bitos de pensamento matem√°tico, a autora mencionada sinaliza cinco

h√°bitos primordiais fundamentando-se em Cuoco, Goldengerb e Mark (1994), Davis e

Hersh (1995), que devemos despertar nos estudantes:

1. Reconhecer padr√µes ou invariantes escondidos em uma situa√ß√£o matem√°tica. Neste

sentido, qualquer conte√∫do pode ser explorado.

2. Fazer experi√™ncias e explora√ß√µes. A busca por padr√µes e invariantes motiva os alunos

e a explora√ß√£o juntamente com a descoberta assumem um papel fundamental em

sua aprendizagem.

3. Visualiza√ß√£o. Este h√°bito visa √† capacidade de criar, manipular e ‚Äúler‚Äù imagens

mentais de aspectos comuns da realidade.

4. Pensar, desmontar ideias, ser inventor. Neste quesito o aluno √© capaz de examinar

um sistema j√° existente e fazer as devidas altera√ß√µes em algum aspecto.

5.1 Explorando o aplicativo

96

5. Fazer conjecturas sobre as situa√ß√µes matem√°ticas propostas. Neste ponto, o aluno √©

capaz de supor que algo √© verdadeiro com base nas evid√™ncias preexistentes e ent√£o

investigar acerca da sua veracidade.

Com o intuito de proporcionar uma modifica√ß√£o nos h√°bitos de pensamento mate-

m√°tico, vamos implementar uma segu√™ncia did√°tica consistente na explora√ß√£o das TGPs

apresentadas neste material, com o objetivo de gerar imagens est√°ticas e din√¢micas (ani-

ma√ß√µes). Al√©m de construir algumas telas de obra de arte digital a partir de processos

iterativos com o uso da linguagem de programa√ß√£o Processing.

5.1 Explorando o aplicativo

Neste bloco de atividades figuram aquelas de primeiro contato dos alunos com a

linguagem de programa√ß√£o em estudo, e a import√¢ncia de seguir uma ordem no fluxograma

da constru√ß√£o para n√£o modificar a aplica√ß√£o objetivada. A proposta dessas atividades

consiste em oportunizar os alunos a familiarizar-se com as ferramentas dispon√≠veis no

software.

Objetivo

Levar o aluno a perceber a import√¢ncia de um fluxograma na cria√ß√£o de aplica√ß√µes

utilizando linguagem de programa√ß√£o e mobilizar algumas formas gerais de pensamento

matem√°tico como: aprender a fazer experi√™ncias e explora√ß√µes, incentivar a interpreta√ß√£o

e a visualiza√ß√£o nas investiga√ß√µes matem√°ticas.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Plano Cartesiano

Subs√≠dio Te√≥rico

O Plano Cartesiano foi criado pelo fil√≥sofo, f√≠sico e matem√°tico franc√™s Ren√© Des-

cartes que durante a Idade Moderna era conhecido por seu nome latino Renatus Cartesius.

Sua cria√ß√£o foi projetada com o intuito de localizar pontos num determinado espa√ßo e gra-

√ßas a sua fa√ßanha matem√°tica, a geometria anal√≠tica teve seu marco hist√≥rico.

Para localizar pontos no contexto da linguagem de programa√ß√£o, consideremos

duas semirretas com origem no ponto ùëÇ, no canto superior do ecr√£, onde os sentidos

horizontal para direita e vertical para baixo como representam o eixo das abscissas (eixo

0ùë•) e o eixo das ordenadas (eixo ùëÇùë¶), respectivamente.

5.1 Explorando o aplicativo

97

Metodologia

Aula expositiva experimental com participa√ß√£o dos alunos; E explora√ß√£o da lin-

guagem de programa√ß√£o Processing com os estudantes agrupados em duplas ou trios, a

depender da rela√ß√£o quantidade de alunos e computadores dispon√≠vel no laborat√≥rio de

inform√°tica.

Material

Papel, l√°pis ou caneta e computador com o Processing instalado.

Procedimento

Configure a dimens√£o e o plano de fundo da tela, logo em seguida, construa ele-

mentos geom√©tricos, tais como:

linhas, quadril√°teros, tri√¢ngulos, c√≠rculos, entre outros,

adicionando uma espessura ao contorno e o preenchimento das figuras, conforme consta

nos c√≥digos da Parte I e organize os dados informados na Parte II dessa atividade para

reproduzir a imagem apresentada.

Parte I

a) Abra um arquivo no Processing e grave como: Applet 1 nome da dupla ou trio.

b) Configura√ß√£o da √°rea de trabalho do aplicativo.

size(largura, altura); //Defina dois valores para resolu√ß√£o da tela (‚ÄúTamanho‚Äù).

background(ùëò); //Defina um valor entre [0, 255] para a cor do plano de fundo.

c) Constru√ß√£o de formas geom√©tricas b√°sicas.

line(ùë•1, ùë¶1, ùë•2, ùë¶2); //Defina os valores das coordenadas iniciais e finais da linha.

triangle(ùë•1, ùë¶1, ùë•2, ùë¶2, ùë•3, ùë¶3); //Defina os valores dos v√©rtices do tri√¢ngulo.

point(ùë•, ùë¶); //Desenhe pontos variando suas coordenadas.

rect(ùë•, ùë¶, comprimento, altura); //Desenhe um ret√¢ngulo.

ellipse(ùë•, ùë¶, comprimento, altura); //Desenhe uma elipse.

Observe que a constru√ß√£o do ret√¢ngulo e da elipse apresenta a mesma sequ√™ncia de

dados, onde os dois primeiros par√¢metros definem a posi√ß√£o nas coordenadas ùë• e ùë¶

e os dois √∫ltimos definem o comprimento e a altura da figura.

d) Configura√ß√£o das cores e contorno.

fill(R, G, B); //Pinte as formas constru√≠das atribuindo valores entre [0, 255] para

determinar os tons de R‚Äìvermelho, G‚Äìverde e B‚Äìazul.

stroke(R, G, B); //Altere a cor dos contornos da mesma forma que atribuiu o

5.1 Explorando o aplicativo

98

preenchimento das mesmas.

strokeWeight(ùëõ); //Escolha uma espessura para os contornos ou cada contorno das

formas.

e) Execute o Applet est√°tico a cada passagem de um item para o outro e observe as

modifica√ß√µes na aplica√ß√£o dos comandos. Organize os dados do item ‚Äúd‚Äù entre cada

forma geom√©trica do item ‚Äúc‚Äù modificando seu preenchimento, contorno e espessura

de forma a evidenciar graficamente cada elemento.

Parte II

Objetivo

Al√©m dos objetivos anteriores, ressalta-se os seguintes objetivos. Conhecer o sis-

tema de coordenadas no contexto da linguagem de programa√ß√£o e identificar a ordem de

constru√ß√£o dos elementos gr√°ficos.

Material

Papel, l√°pis ou caneta e computador com o Processing instalado.

Procedimento

Inicialmente, utilize uma folha quadriculada para representar as constru√ß√µes do

item c, dessa atividade, antes de iniciar a constru√ß√£o no programa para determinar qual

a melhor forma de organizar os dados com o intuito de gerar a imagem fornecida pelo

docente e ao final determinar a espessura e cor do preenchimento constante no item d.

Configure a tela e o plano de fundo conforme solicitado e organize os dados para

reproduzir a mesma imagem da Figura 41.

Figura 41: Applet 2: Boneco geom√©trico

a) Abra um novo arquivo e grave-o como: Applet 2 nome da dupla ou trio.

5.2 Isometria de Transla√ß√£o

99

b) Configura√ß√£o da tela.

size(300, 300);

background(255);

c) Dados das figuras planas do Applet boneco geom√©trico.

rect(20, 60, 100, 20);
triangle(30, 60, 70, 30, 110, 60);
ellipse(50, 100, 5, 5);
ellipse(50, 100, 15, 15);
rect(45, 130, 50, 120);
line(95, 150, 120, 200);
ellipse(120, 200, 30, 10);

ellipse(70, 250, 100, 20);
ellipse(70, 100, 80, 80);
ellipse(70, 250, 80, 10);
ellipse(90, 100, 15, 15);
line(45, 100, 20, 200);
ellipse(20, 200, 30, 10);

d) Dados das cores e espessura do contorno do Applet boneco geom√©trico.

fill(200, 162, 200); ‚Äì Lil√°s
fill(144, 238, 144); ‚Äì Verde claro
fill(50, 205, 50); ‚Äì Verde lima
strokeWeight(2);
fill(127, 255, 212); ‚Äì √Ågua-marinha
fill(255, 0, 127); ‚Äì Rosa brilhante
strokeWeight(5);

fill(255, 140, 0); ‚Äì Laranja escruo
stroke(250, 128, 114); ‚Äì Salm√£o
fill(0); ‚Äì Preto
fill(0, 206, 209); ‚Äì Turquesa escura
stroke(10); ‚Äì Preto
fill(255, 150, 0);
strokeWeight(1);

Avalia√ß√£o

Avaliar se todas as equipes conseguiram desenvolver as atividades e, se necess√°-

rio, retomar as constru√ß√µes para avaliar os poss√≠veis entraves encontrados na constru√ß√£o

das imagens. Al√©m de avaliar a transposi√ß√£o dos dados da malha quadriculada para a

linguagem de programa√ß√£o.

5.2 Isometria de Transla√ß√£o

Esta sec√ß√£o das atividades propostas concentrar√° a transforma√ß√£o de isometria cuja

caracter√≠stica fundamental encontra-se no deslocamento dos objetos, a chamada isometria

de transla√ß√£o. Dessa forma, esperamos que os alunos possam reconhecer e identificar suas

caracter√≠sticas, e peculiaridades com o apoio do professor que poder√° trazer exemplos

diversos da transforma√ß√£o em quest√£o antes de iniciar a linguagem de programa√ß√£o para

os alunos fazerem suas conjecturas iniciais.

Com isso, podemos inferir que o objetivo central dessa sec√ß√£o fundamenta-se em

apresentar algumas isometrias de transla√ß√£o aos alunos, de modo que identifiquem pecu-

liaridades, caracter√≠sticas e regularidades nas constru√ß√µes via linguagem de programa√ß√£o.

5.2 Isometria de Transla√ß√£o

100

5.2.1 Conhecendo a transla√ß√£o

Objetivo

Construir o conceito de transla√ß√£o de uma figura bidimensional e fazer com que

os alunos percebam o movimento da imagem na tela do ‚ÄúApplet‚Äù como um deslocamento

de acordo com uma dire√ß√£o, sentido e dist√¢ncia, conforme a manipula√ß√£o de um vetor

expresso no c√≥digo da transforma√ß√£o.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Transla√ß√£o

Subs√≠dio Te√≥rico

Transladar √© mover o objeto no plano sem rotacionar, ou ainda, transladar con-

siste em deslocar a figura em ùëé unidades na dire√ß√£o horizontal e ùëè unidades na dire√ß√£o

vertical. Em linguagem de programa√ß√£o, este recurso √© necess√°rio para mover a origem

do canto superior esquerdo da tela para outro local, a depender de seus dois par√¢metros

mencionados e esses par√¢metros s√£o adicionados a qualquer desenhada ap√≥s a fun√ß√£o ser

executada.

Metodologia

Aula expositiva com realiza√ß√£o do Applet; E explora√ß√£o do c√≥digo de transla√ß√£o

com os estudantes agrupados em duplas ou trios.

Material

Computador com o Processing instalado.

Procedimento

Configure a dimens√£o e o plano de fundo da tela, logo em seguida, execute os

c√≥digos de transla√ß√£o observando os efeitos no deslocamento das figuras.

a) Abra um arquivo no Processing e grave como: Applet 3 nome da dupla ou trio.

b) Digite os seguintes c√≥digos de configura√ß√£o do programa.

ùë†ùëñùëßùëí(500, 200);

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(241, 250, 0); //Plano de fundo no padr√£o (ùëÖ, ùê∫, ùêµ).

c) Constru√ß√£o do tri√¢ngulo equil√°tero interno ao quadrado.

ùëì ùëñùëôùëô(200, 100, 200);//Defini√ß√£o da cor do quadrado.

5.2 Isometria de Transla√ß√£o

101

ùëüùëíùëêùë°(0, 20, 150, 150); //Quadrado de lado 150 pixels iniciando do ponto (0, 20).

ùëì ùëñùëôùëô(10, 250, 255); //Defini√ß√£o da cor do tri√¢ngulo.

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 170, 150, 170, 75, 40); //Tri√¢ngulo equil√°tero de lado 150 pixels.

d) Translade toda a constru√ß√£o (tri√¢ngulo e quadrado) para a posi√ß√£o (160, 20) con-

forme a instru√ß√£o.

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(160, 20); //Desloca 160 pixels √† direita e 20 para baixo.

ùëì ùëñùëôùëô(200, 100, 200);

ùëüùëíùëêùë°(0, 20, 150, 150);

ùëì ùëñùëôùëô(10, 250, 255);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 170, 150, 170, 75, 40);

e) Ao acrescentar o deslocamento translate(160, ‚àí20), quem ser√° deslizada, a figura

original ou a √∫ltima imagem deslocada? Para descobrir acrescente o comando

translate(160, ‚àí20) e repita o c√≥digo de constru√ß√£o do quadrado e do ret√¢ngulo

mantendo a mesma ordem e procedimento.

Avalia√ß√£o

Avaliar se o aluno compreende como a transla√ß√£o √© executada e se consegue distin-

guir qual imagem foi deslocada a cada acr√©scimo do c√≥digo da programa√ß√£o em quest√£o

para obter a imagem da Figura 42. E assim, identificar a import√¢ncia do acr√©scimo da

fun√ß√£o de pilhagem de matrizes nas constru√ß√µes envolvendo transforma√ß√µes geom√©tricas

que abordaremos na pr√≥xima atividade.

Figura 42: Applet 3: Transla√ß√£o prim√°ria

5.2.2 Aprimorando a transla√ß√£o

Objetivo

Aprofundar o conhecimento de transla√ß√£o atrav√©s da utiliza√ß√£o das fun√ß√µes push-

Matrix() e popMatrix() e automatizar processos mais elaborados de uma transforma√ß√£o

de transla√ß√£o.

5.2 Isometria de Transla√ß√£o

Conte√∫do Program√°tico

102

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Transla√ß√£o

Subs√≠dio Te√≥rico

No Applet 3 podemos perceber como as aplica√ß√µes acumulam suas matrizes de

transforma√ß√£o e para evitar este efeito ‚Äúcumulativo‚Äù utilizamos os c√≥digos ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•()

e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•(). Enquanto, a fun√ß√£o ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() registra o estado atual de todas as

transforma√ß√µes, a fun√ß√£o ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() retorna ao estado anterior √† fun√ß√£o ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•().

Na pr√°tica, essas fun√ß√µes associam cada matriz da transforma√ß√£o como uma folha

de papel com a lista atual de transforma√ß√µes (transla√ß√£o, rota√ß√£o, escala) escrito na

superf√≠cie. Para salvar a matriz de transforma√ß√£o atual para uso posterior basta adicionar

uma nova folha de papel na parte superior da pilha e copiar as informa√ß√µes da folha

anterior com as altera√ß√µes desejadas, preservando assim as informa√ß√µes da folha abaixo.

Quando desejar retornar a matriz anterior basta remover o topo da folha para revelar as

transforma√ß√µes guardadas.

Nesse sentido, salienta-se que cada pushMatrix() √© associado a uma popMatrix() e

uma fun√ß√£o n√£o pode ser utilizada sem a presen√ßa da outra. E no caso de n√£o necessitar

mais da pilha de transforma√ß√£o √© poss√≠vel desfazer utilizando a fun√ß√£o resetMatrix() que

limpa todas as fun√ß√µes de transforma√ß√µes at√© ent√£o definidas restabelecendo a matriz

identidade da transforma√ß√£o.

Metodologia

Aula expositiva com realiza√ß√£o do Applet; E compete aos estudantes construir o

Applet experimentando os efeitos gr√°ficos em sintonia com a teoria da transforma√ß√£o para

enriquecer as possibilidades nas constru√ß√µes de novos aplicativos.

Material

Computador com o Processing instalado.

Procedimento

Para construir um prato com um omelete e uma torrada para o caf√© da manh√£

podemos utilizar basicamente as fun√ß√µes rect e ellipse. No entanto, para servir v√°rios

pratos id√™nticos podemos transladar toda a constru√ß√£o para novas coordenadas facilmente

utilizando a fun√ß√£o translate(ùëé,ùëè) combinada com as fun√ß√µes de pilhagem de matrizes

(pushMatrix() e popMatrix()).

5.2 Isometria de Transla√ß√£o

103

Com o intuito de preparar um caf√© da manh√£ execute o sistema de c√≥digos da

atividade.

a) Abra um novo arquivo e grave-o como: Applet 4 nome da dupla ou trio.

b) Configura√ß√£o da tela.

size(500, 500);

background(144, 255, 244); //Plano de fundo azul claro

c) Dados do Applet caf√© da manh√£.

//Prato branco

5 ùëüùëíùëêùë°(10, 70, 70, 10);

9 ùëì ùëñùëôùëô(255, 255, 0);

1 ùëì ùëñùëôùëô(240, 250, 255);

6 ùëüùëíùëêùë°(60, 60, 20, 30);

10 ùëíùëôùëôùëñùëùùë†ùëí(120, 70, 30, 30);

2 ùëíùëôùëôùëñùëùùë†ùëí(120, 120, 220, 220);

//Clara do ovo

//Torrada

3 ùëíùëôùëôùëñùëùùë†ùëí(120, 120, 200, 200);

7 ùëì ùëñùëôùëô(255);

11 ùëì ùëñùëôùëô(247, 113, 60);

//Colher

8 ùëíùëôùëôùëñùëùùë†ùëí(120, 70, 100, 50);

12 ùëüùëíùëêùë°(150, 100, 50, 70);

4 ùëì ùëñùëôùëô(201, 201, 201);

//Gema do ovo

13 ùëüùëíùëêùë°(160, 110, 30, 50);

d) Transla√ß√£o com a fun√ß√£o pusMatrix() e popMatrix() de acordo com os dados do

Applet.

1ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

6 ùëì ùëñùëôùëô(201, 201, 201);

11 ùëì ùëñùëôùëô(255, 255, 0);

2ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(250, 0);

7 ùëüùëíùëêùë°(10, 70, 70, 10);

12 ùëíùëôùëôùëñùëùùë†ùëí(120, 70, 30, 30);

//Prato branco

8 ùëüùëíùëêùë°(60, 60, 20, 30);

//Torrada

3 ùëì ùëñùëôùëô(240, 250, 255);

//Clara do ovo

13 ùëì ùëñùëôùëô(247, 113, 60);

4 ùëíùëôùëôùëñùëùùë†ùëí(120, 120, 220, 220);

9 ùëì ùëñùëôùëô(255);

14 ùëüùëíùëêùë°(150, 100, 50, 70);

5 ùëíùëôùëôùëñùëùùë†ùëí(120, 120, 200, 200);

10 ùëíùëôùëôùëñùëùùë†ùëí(120, 70, 100, 50);

15 ùëüùëíùëêùë°(160, 110, 30, 50);

//Colher

//Gema do ovo

16ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

e) Execute uma nova transla√ß√£o com o comando ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() deslo-

cando a constru√ß√£o com a fun√ß√£o ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 250). Ao inv√©s de digitar os c√≥digos

iniciais novamente, selecione, copie e cole.

f) Repita o procedimento anterior usando agora o translate(250, 250) para servir o

quarto prato do caf√© da manh√£.

Avalia√ß√£o

Avaliar se todos conseguiram compreender a import√¢ncia de se utilizar as fun√ß√µes

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() para automatizar a mudan√ßa de coordenadas dos entes

5.2 Isometria de Transla√ß√£o

104

constru√≠dos, atrav√©s do ‚ÄúApplet‚Äù desta atividade. Apesar do √°rduo trabalho em se digitar

o c√≥digo repetidas vezes at√© culminar na imagem da Figura 43. Com isso, os alunos cons-

tatar√£o a import√¢ncia de criar sub-rotinas para evitar a repeti√ß√£o dos c√≥digos enumeras

vezes e viabilizar uma constru√ß√£o mais sofisticada, a exemplo das pr√≥ximas atividades.

Figura 43: Applet 4: Transla√ß√£o do caf√© da manh√£

5.2.3 Macro constru√ß√£o com a transla√ß√£o

Objetivo

Reduzir o n√∫mero de c√≥digos duplicados no programa para reutiliz√°-lo sem grandes

altera√ß√µes em outros programas e decompor problemas grandes em pequenas partes para

melhorar a interpreta√ß√£o visual do respectivo programa.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Transla√ß√£o

Subs√≠dio Te√≥rico

No contexto da programa√ß√£o, a cria√ß√£o de sub-rotinas que s√£o fun√ß√µes, proce-

dimentos ou mesmo subprogramas, consiste em uma por√ß√£o de c√≥digo que resolve um

problema muito espec√≠fico, parte de um problema maior para a aplica√ß√£o maior. Notori-

amente, o conceito de fun√ß√£o difere da no√ß√£o de procedimento em algumas linguagens, j√°

que devolve um valor, se bem que esta distin√ß√£o n√£o √© sequer existente nessa linguagem;

por exemplo, em Processing, a implementa√ß√£o de um procedimento √© uma fun√ß√£o do tipo

void.

Dentre as vantagens da utiliza√ß√£o de sub-rotinas durante a programa√ß√£o listamos:

5.2 Isometria de Transla√ß√£o

105

‚ãÜ A redu√ß√£o de c√≥digo duplicado num programa;

‚ãÜ A possibilidade de reutilizar o mesmo c√≥digo sem grandes altera√ß√µes em outros

programas;

‚ãÜ A decomposi√ß√£o de problemas grandes em pequenas partes;

‚ãÜ Melhorar a interpreta√ß√£o visual de um programa;

‚ãÜ Esconder ou regular uma parte de um programa, mantendo o restante do c√≥digo

alheio √†s quest√µes internas resolvidas dentro dessa fun√ß√£o.

Dentro dessa √≥tica, Velho [38, p. 279] pondera:

A composi√ß√£o de diversos objetos gr√°ficos na forma√ß√£o de modelos mais
complexos √© de fundamental import√¢ncia para determinados tipos de
aplica√ß√£o, como por exemplo, a anima√ß√£o de pessoas e animais, e tamb√©m
na √°rea de rob√≥tica. Por outro lado, a decomposi√ß√£o de objetos em partes
mais simples que se relacionam de forma hier√°rquica √© uma estrat√©gia
bastante utilizada na solu√ß√£o de problemas, dentro do esp√≠rito de dividir
para conquistar.

Na concep√ß√£o de Velho [38], uma hierarquia √© um grafo onde os v√©rtices s√£o objetos

gr√°ficos. Sendo que um conjunto de pares de objetos constituem as arestas formadoras de

uma rela√ß√£o de v√≠nculo hier√°rquico de dois objetos sobre a mesma aresta. Nesse √¢mbito,

os objetos s√£o classificados de acordo com sua hierarquia em: Objetos compostos quando

n√£o existe movimento relativo entre os diversos sub-objetos, ou ainda, os v√≠nculos s√£o

r√≠gidos e isso √© muito √∫til para descrever cen√°rios com muitos elementos, como √© o caso

dessa atividade. E objetos articulados quando os v√≠nculos n√£o s√£o r√≠gidos, ou seja, s√£o

objetos constitu√≠dos de partes r√≠gidas conectadas por articula√ß√µes ou juntas que formam

um v√≠nculo entre as partes permitindo a movimenta√ß√£o relativa entre elas, como √© o caso

do corpo humano, dos r√¥bos, entre outros.

Metodologia

Aula expositiva com realiza√ß√£o do Applet; E por ser um Applet bastante iterativo,

repleto de implementa√ß√µes para a constru√ß√£o do cen√°rio, foi sugerida a constru√ß√£o de

sub-rotinas para atuar de forma l√∫dica e pr√°tica na manipula√ß√£o e experimenta√ß√£o da

linguagem mais complexa.

Material

Papel, l√°pis ou caneta e computador com o Processing instalado.

5.2 Isometria de Transla√ß√£o

106

Procedimento

A constru√ß√£o de um cen√°rio formado por √°rvores, uma casa, duas pessoas, um

lago, uma tartaruga nadando e um c√©u ensolarado requer um controle aprimorado do uso

da linguagem de programa√ß√£o. Em fun√ß√£o disso, a computa√ß√£o gr√°fica desenvolveu uma

estrat√©gia para facilitar a confec√ß√£o de jogos eletr√¥nicos, entre outros. Esse objetivo na

programa√ß√£o √© alcan√ßado com a cria√ß√£o de fun√ß√µes para controlar cada objeto do cen√°rio

e a partir dessa fun√ß√£o, preferencialmente com suas coordenadas na origem do sistema, √©

poss√≠vel criar v√°rios aplicativos com ou sem anima√ß√µes preservando o objeto.

Com o intuito de construir o cen√°rio mencionado no par√°grafo anterior, subdividi-

remos a atividade em quest√£o em quatro etapas para facilitar a compreens√£o e dom√≠nio

dos novos elementos acrescentados na programa√ß√£o.

Parte I

Configura√ß√£o inicial do cen√°rio, dimensionando a tela e programando o ambiente

c√©u e terra atrav√©s do comando void setup e void draw. Esses comandos s√£o muito utiliza-

dos nos processos de anima√ß√£o e cria√ß√£o de jogos, por isso, sua import√¢ncia na execu√ß√£o

da atividade para incrementar novas possibilidades de aprendizagem para constru√ß√µes

din√¢micas.

a) Abra um novo arquivo e grave-o como: Applet 5 nome da dupla ou trio.

b) Configura√ß√£o da tela com a fun√ß√£o void.

1 ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù(){

5 ùëì ùëñùëôùëô(135, 206, 250); //Cor do ambiente c√©u

2 ùë†ùëñùëßùëí(400, 400); //Configura√ß√£o da tela.

6 ùëüùëíùëêùë°(0, 0, 400, 250); //Dimens√£o do c√©u.

3 ùëì ùëñùëôùëô(50, 205, 50); //Cor do ambiente terra

7 }

4 ùëüùëíùëêùë°(0, 250, 400, 150);

//Dimens√£o

da

8 ùë£ùëúùëñùëë ùëëùëüùëéùë§() {

terra.

Parte II

9 }

Com o mesmo arquivo, vamos incrementar o programa com a constru√ß√£o dos pri-

meiros objetos para o cen√°rio, ou seja, vamos estruturar os objetos √°rvores e o objeto

c√©u (sol e nuvens), conforme mostra a Figura 44(a). E para finalizar essa parte, vamos

programar o ambiente casa particionando seus detalhes (paredes, telhado, janela e porta)

em fun√ß√µes distintas para o programa sintetizar como consta na Figura 44(b)

5.2 Isometria de Transla√ß√£o

107

a) Abra uma ‚ÄúNova Aba‚Äù e nomeei o ambiente onde montaremos os objetos de ‚Äúcenario‚Äù.

Para abrir uma ‚ÄúNova Aba‚Äù clique na seta abaixo da barra de ferramentas e selecione

‚ÄúNova Aba‚Äù.

b) Na aba ‚Äúcenario‚Äù, construa com a fun√ß√£o void os objetos mencionados, de acordo

com a ordem preestabelecida.

1 ùë£ùëúùëñùëë ùëéùëüùë£ùëúùëüùëí1(){//Fun√ß√£o √°rvore 1.

14 ùë°ùëüùëñùëéùëõùëîùëôùëí(100, 0, 85, 15, 115, 15);//Galhos.

2 ùëì ùëñùëôùëô(0, 255, 0);//cor verde.

15 ùëì ùëñùëôùëô(129, 69, 14);

3 ùë†ùë°ùëüùëúùëòùëí(144, 238, 144);

16 ùëüùëíùëêùë°(95, 55, 10, 20);//Tronco.

3 ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 50,-60, 110, 60, 110);//Galhos.

17 }

4 ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 20,-50, 70, 50, 70);//Galhos.

18 ùë£ùëúùëñùëë ùëêùëíùë¢(){ //Fun√ß√£o c√©u(sol e nuvens).

5 ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0,-30, 30, 30, 30);//Galhos.

19 ùëì ùëñùëôùëô(255, 255, 0);//Cor amarela (sol).

6 ùëì ùëñùëôùëô(129, 69, 14);

20 ùëíùëôùëôùëñùëùùë†ùëí(‚àí20, ‚àí20, 40, 40);//sol.

7 ùëüùëíùëêùë°(‚àí10, 110, 20, 40);//Tronco.

21 ùëì ùëñùëôùëô(255, 250, 250);//Cor

branca

(nu-

8 }

vens).

9 ùë£ùëúùëñùëë ùëéùëüùë£ùëúùëüùëí2() {//Fun√ß√£o √°rvore 2.

22 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 100, 40); //nuvem.

10 ùëì ùëñùëôùëô(0, 255, 0);//cor verde

23 ùëíùëôùëôùëñùëùùë†ùëí(‚àí50, ‚àí10, 80, 40);//nuvem.

11 ùë†ùë°ùëüùëúùëòùëí(144, 238, 144);

24 }

12 ùë°ùëüùëñùëéùëõùëîùëôùëí(100, 25, 70, 55, 130, 55);//Galhos.

13 ùë°ùëüùëñùëéùëõùëîùëôùëí(100, 10, 75, 35, 125, 35);//Galhos.

c) Ao executar o programa n√£o aparecer√° os objetos rec√©m criados, para visualiza-los √©

necess√°rio acrescentar a fun√ß√£o arvore1, arvore2 e ceu dentro do comando void draw

na aba principal. Em outras palavras, abra a aba principal designada de ‚ÄúApplet 5‚Äù

e no interior do comando draw digite os c√≥digos abaixo deslocando os objetos para

suas respectivas posi√ß√µes, preservando a ordem dos dados.

1 ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

2 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

8 ùëéùëüùë£ùëúùëüùëí1();

9 ùëéùëüùë£ùëúùëüùëí2();

15 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

16 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(90, 50);

3 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(15, 210);

10 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

17 ùëõùëúùëÜùë°ùëüùëúùëòùëí();

4 ùëéùëüùë£ùëúùëüùëí2();

11 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

18 ùëêùëíùë¢();

5 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

12 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(270, 200);

19 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

6 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

13 ùëéùëüùë£ùëúùëüùëí2();

20 }

7 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(70, 200);

14 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

Vamos pensar Nessa constru√ß√£o existe alguma rela√ß√£o entre o dimensionamento

da √°rvore 1 para a √°rvore 2? Se existir, qual a raz√£o entre √°rvore 1 e a √°rvore 2?

5.2 Isometria de Transla√ß√£o

108

(Dica: Comece analisando as coordenadas dos galhos da √°rvore 1 para a √°rvore 2,

para depois analisar o tamanho do tronco das √°rvores, na mesma ordem)

(a) Cen√°rio √°rvore e c√©u ensolarado

(b) Cen√°rio com a casa

Figura 44: Constru√ß√£o do cen√°rio casa com √°rvores e c√©u ensolarado

√ß√£o de propor√ß√£o existente entre as √°rvores cujo fator mensurado foi de 1

Com rela√ß√£o ao questionamento anterior, espera-se que os alunos percebam a rela-
2. Nesse sentido,
ainda √© plaus√≠vel instig√°-los quanto a viabilidade de escrever as coordenadas da √°rvore 1,

menor, da mesma forma que a √°rvore 2, maior, utilizando para isso uma redu√ß√£o de escala

conforme abordaremos no bloco de transforma√ß√µes da sec√ß√£o 5.5.

Ap√≥s a implementa√ß√£o das √°rvores, dos elementos sol e nuvem no c√©u, s√≥ faltar√°

programar a constru√ß√£o da casa particionando seus detalhes em fun√ß√µes conforme fora

relatado anteriormente. Para isso, voltaremos a aba ‚Äúcenario‚Äù para programar as fun√ß√µes

de parti√ß√£o da casa.

d) Na aba ‚Äúcenario‚Äù implementaremos a constru√ß√£o da casa a partir das fun√ß√µes telhado,

paredes, porta e janela, conforme a ordem de lan√ßamento dos dados constante na

listagem.

1 ùë£ùëúùëñùëë ùë°ùëíùëô‚Ñéùëéùëëùëú(){

2 ùëì ùëñùëôùëô(255, 36, 0);

9 ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

10 ùë£ùëíùëüùë°ùëíùë•(‚àí50, 30);

3 ùëûùë¢ùëéùëë(-50, 30,-10,-10, 30,-30, 0, 0);

11 ùë£ùëíùëüùë°ùëíùë•(‚àí50, 90);

4 ùëûùë¢ùëéùëë(0, 0, 30,-30, 90,-10, 50, 30);

12 ùë£ùëíùëüùë°ùëíùë•(50, 90);

5 }

6 ùë£ùëúùëñùëë ùëùùëéùëüùëíùëëùëíùë†(){

7 //parede da frente

8 ùëì ùëñùëôùëô(150, 100, 100);

13 ùë£ùëíùëüùë°ùëíùë•(50, 30);

14 ùë£ùëíùëüùë°ùëíùë•(0, 0);

15 ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

16//parede lateral

5.2 Isometria de Transla√ß√£o

109

17 ùëûùë¢ùëéùëë(50, 30, 50, 90, 90, 50, 90, ‚àí10);

25 ùë£ùëúùëñùëë ùëóùëéùëõùëíùëôùëé(){

18 }

19 ùë£ùëúùëñùëë ùëùùëúùëüùë°ùëé(){

20 ùëì ùëñùëôùëô(200, 100, 0);

21 ùëüùëíùëêùë°(0, 0, 20, 40);

22 ùëì ùëñùëôùëô(0);

26 ùëì ùëñùëôùëô(250, 240, 240);

27 ùëüùëíùëêùë°(0, 0, 10, 10);

28 ùëüùëíùëêùë°(10, 0, 10, 10);

30 ùëüùëíùëêùë°(0, 10, 10, 10);

31 ùëüùëíùëêùë°(10, 10, 10, 10);

23 ùëíùëôùëôùëñùëùùë†ùëí(16, 22, 5, 5);

32 }

24 }

e) Para a constru√ß√£o ser visualizada no aplicativo devemos posicionar as fun√ß√µes da

parti√ß√£o casa em suas devidas coordenadas dentro do comando draw da aba ‚ÄúApplet

5‚Äù, conforme fizemos no item c da atividade. Entretanto, daremos continuidade a

partir de onde finalizamos na programa√ß√£o do ambiente √°rvores e elementos do c√©u.

ùë£ùëúùëñùëë ùëëùëüùëéùë§(){¬∑ ¬∑ ¬∑

6 ùëùùëéùëüùëíùëëùëíùë†();

12 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

1 //casa

7 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

13 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(260, 250);

2 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

8 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

14 ùëóùëéùëõùëíùëôùëé();

3 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(250, 200);

9 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(220, 250);

15 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

4 ùë†ùë°ùëüùëúùëòùëí(0);

5 ùë°ùëíùëô‚Ñéùëéùëëùëú();

10 ùëùùëúùëüùë°ùëé();

11 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

}

Para essa atividade utilizamos novos c√≥digos, a saber: quad( ¬∑ ¬∑ ¬∑ ), utilizado para

construir qualquer quadril√°tero dados seus v√©rtices, como fizemos na fun√ß√£o telhado, e

beginShape(); vertex( ¬∑ ¬∑ ¬∑ ); ¬∑ ¬∑ ¬∑ ; endShape(CLOSE); que serve para construir qualquer

poligonal, principalmente as que possuem mais de 4 v√©rtices. O que garante o fechamento

dessa poligonal √© a palavra ‚ÄúCLOSE‚Äù encontrada no endShape, se remover essa express√£o

do c√≥digo que construiu a frente da casa, esta perder√° uma linha poligonal que voltar√°

a se fechar somente repetindo o c√≥digo do primeiro v√©rtice (vertex) antes de encerrar o

c√≥digo endShape, ou reescrevendo a express√£o ‚ÄúCLOSE‚Äù novamente.

Ap√≥s programar a constru√ß√£o da casa, das √°rvores e do sol ensolarado, a nossa

atividade s√≥ precisa agora da imagem de pessoas e um lago com a tartaruga nadando

conforme sugerido no in√≠cio da atividade. Para isso, abordaremos na pr√≥xima etapa a

constru√ß√£o da figura de dois bonecos com sua vestimenta posicionado atr√°s da √°rvore

maior e no outro extremo da tela para dar uma no√ß√£o de profundidade.

Parte III

Nessa atividade construiremos a figura do boneco particionando na mesma lingua-

5.2 Isometria de Transla√ß√£o

110

gem as partes do corpo. No entanto, em anima√ß√µes e constru√ß√£o de jogos costuma-se

chamar uma fun√ß√£o para cada parte do corpo e assim fazer movimentos independentes de

forma mais sofisticada partindo de elementos escritos na origem do sistema. Como nosso

boneco ficar√° est√°tico e j√° apresentamos muitas fun√ß√µes at√© o momento, manteremos nossa

constru√ß√£o em uma √∫nica fun√ß√£o com sua vestimenta em outra fun√ß√£o.

Dessa forma, vamos iniciar a constru√ß√£o da fun√ß√£o boneco e da fun√ß√£o roupa

seguindo o mesmo princ√≠pio das etapas anteriores. Para avaliar o grau de aprendizagem

at√© o momento, omitiremos aonde os c√≥digos devem ser inseridos e como fazer a imagem

do boneco aparecer atr√°s da √°rvore2, maior, como podemos ver na Figura 45.

a) Constru√ß√£o da fun√ß√£o boneco;

1 ùë£ùëúùëñùëë ùëèùëúùëõùëíùëêùëú(){

11 ùëíùëôùëôùëñùëùùë†ùëí(‚àí6, ‚àí6, 4, 4);//olho direito

2 ùëüùëíùëêùë°(‚àí5, 15, 10, 40); //coluna

12 ùëíùëôùëôùëñùëùùë†ùëí(6, ‚àí6, 4, 4);//olho esquerdo

3 ùëûùë¢ùëéùëë(‚àí5, 55, 0, 55, ‚àí10, 85, ‚àí15, 85);

13 ùëì ùëñùëôùëô(240, 240, 240);

//perna direita

14 ùëíùëôùëôùëñùëùùë†ùëí(0, 7, 20, 5);//boca sorrindo

4 ùëûùë¢ùëéùëë(5, 55, 0, 55, 10, 85, 15, 85);//perna es-

15 //√≥culos

querda

16 ùëì ùëñùëôùëô(0, 0, 0, 100);//lente transl√∫cida

5 ùëûùë¢ùëéùëë(‚àí5, 20, ‚àí5, 25, ‚àí20, 45, ‚àí25, 45);

17 ùëüùëíùëêùë°(‚àí10, ‚àí10, 8, 8);//direito

//bra√ßo direito

18 ùëüùëíùëêùë°(2, ‚àí10, 8, 8);//esquerdo

6 ùëûùë¢ùëéùëë(5, 20, 5, 25, 20, 45, 25, 45);

//bra√ßo

19 ùëì ùëñùëôùëô(0);//arma√ß√£o preta

esquerdo

7 //rosto

20 ùëüùëíùëêùë°(‚àí2, ‚àí7, 4, 2);//central

21 ùëüùëíùëêùë°(‚àí20, ‚àí7, 9, 2);//direita

8 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 35, 35);//cabe√ßa

22 ùëüùëíùëêùë°(10, ‚àí7, 9, 2);//esquerda

9 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 3, 8);//nariz

23 }

10 ùëì ùëñùëôùëô(135, 206, 250);//cor azul

b) Constru√ß√£o da fun√ß√£o roupa;

1 ùë£ùëúùëñùëë ùëüùëúùë¢ùëùùëé(){

2 //camisa

6 //bermuda

7 ùëûùë¢ùëéùëë(‚àí5, 55, 0, 55, ‚àí4, 70, ‚àí12, 70);

3 ùëüùëíùëêùë°(‚àí5, 20, 10, 40);//coluna

//perna direita

4 ùëûùë¢ùëéùëë(‚àí5, 20, ‚àí5, 25, ‚àí15, 40, ‚àí24, 40);

8 ùëûùë¢ùëéùëë(5, 55, 0, 55, 4, 70, 12, 70); //perna es-

//bra√ßo direito

querda

5 ùëûùë¢ùëéùëë(5, 20, 5, 25, 15, 40, 24, 40);

//bra√ßo

9 }

esquerdo

5.2 Isometria de Transla√ß√£o

111

c) Visualiza√ß√£o do boneco com sua vestimenta na tela gr√°fica;

Boneco atr√°s da √°rvore

1 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

2 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(40, 245);

3 ùë†ùë°ùëüùëúùëòùëí(0);

Boneco depois do lago

1 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

2 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(350, 300);

3 ùë†ùë°ùëüùëúùëòùëí(0);

4 ùëì ùëñùëôùëô(255, 160, 122);//Salm√£o claro na pele

4 ùëì ùëñùëôùëô(255, 160, 122);//Salm√£o claro na pele

5 ùëèùëúùëõùëíùëêùëú();

6 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

7 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

8 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(40, 245);

9 ùë†ùë°ùëüùëúùëòùëí(0);

5 ùëèùëúùëõùëíùëêùëú();

6 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

7 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

8 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(350, 300);

9 ùë†ùë°ùëüùëúùëòùëí(0);

10 ùëì ùëñùëôùëô(100, 50, 255);//azul

10 ùëì ùëñùëôùëô(100, 50, 255);//azul

11 ùëüùëúùë¢ùëùùëé();

12 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

11 ùëüùëúùë¢ùëùùëé();

12 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

Figura 45: Complementa√ß√£o do cen√°rio com bonecos no ambiente

Com a aprendizagem das atividades anteriores, espera-se que o discente consiga notoria-

mente descobrir a posi√ß√£o do c√≥digo do Boneco atr√°s da √°rvore sem dificuldades. E essa

anima√ß√£o viabiliza ainda alguns questionamentos para os discentes, dentre eles destaca-

mos:

Como √© poss√≠vel visualizar os olhos do boneco mesmo utilizando √≥culos? Podemos

remover parte da arma√ß√£o sem apagar nenhum c√≥digo? Qual a cor dos olhos do boneco?

Para todos esses questionamentos, os alunos precisam rever a linguagem e idealizar

seu objetivo antes de executar algum comando. No caso da visualiza√ß√£o dos olhos mesmo

utilizando os √≥culos, a resposta encontra-se na cor da lente, note que o comando fill

apresenta um quarto valor que determina na escala de [0, 255] o tom de transpar√™ncia da

5.2 Isometria de Transla√ß√£o

112

cor selecionada, isto √©, quanto mais pr√≥ximo de zero, mais transparente fica essa cor, no

sentido contr√°rio, mais escurece a cor preestabelecida.

No segundo questionamento talvez o professor tenha que intervir com algumas

dicas para os alunos prestarem aten√ß√£o nos coment√°rios da pr√≥pria linguagem, algo do

tipo, ‚Äúna hora que aparece o nome da cor ou nome das partes do boneco algu√©m visualiza

esses nomes na tela ou acontece algum erro durante a execu√ß√£o da linguagem‚Äù. Em √∫ltimo

caso o docente chamar√° a aten√ß√£o para as ‚Äúduas barras‚Äù e isso possibilitar√° a investiga√ß√£o

e experimenta√ß√£o por parte dos envolvidos com dificuldade de assimilar algo n√£o usual

at√© ent√£o.

Existe ainda a possibilidade de suprimir uma gama de c√≥digos sem utilizar as barras

duplas em cada linha a ser omitida, nesse ponto a figura do professor mediador ser√° crucial

por apresentar algo novo na linguagem muito utilizado na programa√ß√£o quando n√£o se

deseja revelar toda uma constru√ß√£o de imediato ou n√£o se necessita de algum elemento

espec√≠fico sem deletar a informa√ß√£o. Esse recurso √© um coment√°rio que pode omitir v√°rias

linhas ao mesmo tempo quando colocado os s√≠mbolos corretos entre os c√≥digos a serem

postergado, assim o docente poder√° explicar a diferen√ßa entre cada uma das formas de se

inserir um coment√°rio como podemos perceber:

// Coment√°rio de linha simples.

/* Inicializa o coment√°rio de v√°rias linhas

continua coment√°rio

*/ Finaliza o coment√°rio

A partir dessa explana√ß√£o os alunos poder√£o responder ao terceiro questionamento

com maior presteza otimizando tempo e recursos para alcan√ßar um objetivo, e isso viabiliza

seu poder de decis√£o cotidiana.

Para finalizar essa atividade, construiremos um lago onde uma tartaruga ir√° nadar

constantemente da esquerda para a direita. Por essa a primeira anima√ß√£o din√¢mica,

deixamos essa etapa para o final por considerar um recurso estimulante para os discentes

j√° pensarem na possibilidade de aperfei√ßoarem o conhecimento em programa√ß√£o para a

cria√ß√£o de jogos e anima√ß√µes mais sofisticadas.

Parte IV

Para construir um lago ser√° necess√°rio apenas um c√≥digo da ellipse, mas, para

construir uma tartaruga necessitaremos de v√°rios comandos da ellipse como mostra a

sequ√™ncia de c√≥digos da fun√ß√£o tartaruga nadando no lago.

5.2 Isometria de Transla√ß√£o

113

a) Programa√ß√£o do lago e da tartaruga animada;

1 ùë£ùëúùëñùëë ùë°ùëéùëüùë°ùëéùëüùë¢ùëîùëé(){

10 ùëíùëôùëôùëñùëùùë†ùëí(‚àí53 + ùëé, 13, 10, 10);

2 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 200, 90); //lago

11 ùëíùëôùëôùëñùëùùë†ùëí(‚àí53 + ùëé, ‚àí13, 10, 10);

3 ùëì ùëñùëôùëô(183, 115, 51); //cor do casco

12 ùëíùëôùëôùëñùëùùë†ùëí(‚àí45 + ùëé, 0, 15, 15);//cabe√ßa

4 ùëíùëôùëôùëñùëùùë†ùëí(‚àí70 + ùëé, 0, 50, 20); //casco

13 //olho

5 ùëì ùëñùëôùëô(154, 205, 50); //cor do corpo

14 ùëì ùëñùëôùëô(255);//parte branca

6 //pernas traseiras

15 ùëíùëôùëôùëñùëùùë†ùëí(‚àí43 + ùëé, ‚àí2, 7, 5);

7 ùëíùëôùëôùëñùëùùë†ùëí(‚àí87 + ùëé, ‚àí13, 10, 10);

16 ùëì ùëñùëôùëô(0); //parte preta

8 ùëíùëôùëôùëñùëùùë†ùëí(‚àí87 + ùëé, 13, 10, 10);

17 ùëíùëôùëôùëñùëùùë†ùëí(‚àí42 + ùëé, ‚àí2, 2, 2);

9 //pernas dianteiras

18 }

b) Visualiza√ß√£o da tartaruga em movimento.

1 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

2 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(200, 350);

3 ùëì ùëñùëôùëô(0, 200, 255);

4 ùëé = (ùëé + 0.5)%139;

5 ùë°ùëéùëüùë°ùëéùëüùë¢ùëîùëé();

6 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

Quando os alunos digitarem o c√≥digo para gerarem o movimento da tartaruga em

fun√ß√£o da vari√°vel a, o programa exibir√° uma mensagem de erro no seu rodap√© com a
seguinte express√£o em ingl√™s ‚ÄúThe variable ‚Äòa‚Äô does not exist 1‚Äù, de fato, n√£o definimos para

quais valores esse termo a existe. Nesse sentido, a figura do professor volta a ser crucial

para apresentar e diferenciar as nota√ß√µes de vari√°vel em programa√ß√£o que se restringe a

dois tipos nesse trabalho, int e float.

A vari√°vel int √© utilizada no contexto dos n√∫meros inteiros, enquanto a vari√°vel

float √© empregada no campo dos n√∫meros reais. Diante desse conhecimento, o docente

solicitar√° que os alunos acrescente o comando int a = 0 no in√≠cio da aba ‚ÄúApplet 5‚Äù ou

fora da fun√ß√£o setup, antes de iniciar a fun√ß√£o void draw.

Se os alunos j√° tiverem escrito o c√≥digo de visualiza√ß√£o da fun√ß√£o tartaruga ir√°
aparecer outra mensagem de erro em ingl√™s ‚ÄúCannot convert from float to int2‚Äù. Antes

dos discentes alteram conforme o programa sugestiona, questionem aos alunos o porque

do programa fazer essa indaga√ß√£o.

Aos atenciosos, talvez este questionamento seja desnecess√°rio. Entretanto, o obje-

tivo das atividades esta al√©m de instrumentalizar-los no uso da linguagem de programa√ß√£o.

1A vari√°vel ‚Äòa‚Äô n√£o existe, tradu√ß√£o nossa
2N√£o pode converter de float para int, tradu√ß√£o nossa

5.2 Isometria de Transla√ß√£o

114

Objetiva-se nos discentes uma atitude investigativa com foco na experimenta√ß√£o e di√°logo.

Por este motivo, tal questionamento √© fundamental para que percebam que apesar do c√≥-

digo utilizado refira-se aos n√∫meros inteiros, na atribui√ß√£o ao valor de ‚Äúa‚Äù foi estabelecido

um incremento n√£o inteiro e por este motivo a pr√≥pria linguagem nos chama a aten√ß√£o

para substituir a vari√°vel lan√ßada por float.

Apesar de chegarem a essa conclus√£o, antes que os alunos mudem o contexto da

vari√°vel, de inteiro para real, solicitem aos discentes uma altera√ß√£o no incremento para um

n√∫mero inteiro, tipo: ùëé = (ùëé + 1)%139, depois continuem a aumentar esse acrescimento.

A grande pergunta a ser fazer com esta oscila√ß√£o no incremento √©: Qual o efeito gr√°fico

que o acr√©scimo inteiro provoca no movimento da tartaruga? A prov√°vel resposta ser√°

na velocidade do movimento da tartaruga. Diante disso, vem o questionamento quanto

ao acr√©scimo mais ideal para o movimento de uma tartaruga, se na escala dos n√∫meros

inteiros ou dos n√∫meros reais.

Por este motivo, vamos mudar o contexto da vari√°vel ‚Äúa‚Äù para os n√∫meros reais,

isto √©, trocaremos o comando int a = 0 por float a = 0. E para o acr√©scimo podemos

solicitar aos alunos que testem valores menores do que 1 e mantenham aquele que julgarem

mais fidedigno ao movimento da tartaruga.

Com isso, finalizamos essa atividade com uma anima√ß√£o para o movimento da

tartaruga, conforme mostra o jogo de imagens das Figuras 46(a) e 46(b). Salienta-se

ainda que tais imagens s√£o apenas representa√ß√µes do deslocamento da tartaruga, uma vez

que o recurso impresso limita a visualiza√ß√£o de imagens em movimento, por esse motivo,

utilizar recursos tecnol√≥gicos no processo de ensino aprendizagem viabiliza um conjunto

de possibilidades ilimitadas quando comparado ao material did√°tico.

(a) Tartaruga no in√≠cio do movimento

(b) Tartaruga em movimenta√ß√£o

Figura 46: Applet 5: Cen√°rio com anima√ß√£o da tartaruga no lago

5.3 Isometria de rota√ß√£o

115

Avalia√ß√£o

Com essa atividade esperamos que os alunos desenvolvam a habilidade de construir

fun√ß√µes para controlar os elementos gr√°ficos e assim manipulem muitas partes do cen√°rio

com a menor quantidade de c√≥digos.

5.3 Isometria de rota√ß√£o

A rota√ß√£o √© uma transforma√ß√£o geom√©trica que preserva as caracter√≠sticas de uma

isometria de tal forma que o objeto sofre apenas um giro em torno de ponto fixo no plano.

Dessa forma, esperamos que os alunos caracterizem os objetos como isom√©tricos segundo

um determinado √¢ngulo de rota√ß√£o em rela√ß√£o ao objeto original e para atingir esse feito,

contaremos com o papel mediador do professor durante o processo de programa√ß√£o e

exemplifica√ß√£o de constru√ß√µes existentes realizadas utilizando esse princ√≠pio geom√©trico.

Para fundamentar o processo de aprendizagem dessa isometria utilizaremos cons-

tru√ß√µes b√°sicas e elaboradas via linguagem de programa√ß√£o, no entanto, utilizaremos

material concreto como ponto de partida no intuito de viabilizar a combina√ß√£o da trans-

la√ß√£o com a rota√ß√£o no efeitos gr√°ficos que ser√£o produzidos em parceria com os discentes.

Tal parceria e ponto de partida √© crucial para as atividades elaboradas e o entendimento

das propriedades caracter√≠sticas da rota√ß√£o.

5.3.1 Conhecendo a rota√ß√£o

Objetivo

Construir o conceito de rota√ß√£o de uma figura bidimensional e fazer com que os

alunos percebam a rota√ß√£o da imagem na tela do ‚ÄúApplet‚Äù como um giro segundo um

√¢ngulo em torno de um ponto fixo. Al√©m de identificar a import√¢ncia da transla√ß√£o

no processo de uma rota√ß√£o em computa√ß√£o gr√°fica, principalmente, de sua ordem de

execu√ß√£o.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Rota√ß√£o e Transla√ß√£o;

Plano Cartesiano.

Subs√≠dio Te√≥rico

Rotacionar √© rodar o objeto no plano, em outras palavras, rotacionar uma figura

5.3 Isometria de rota√ß√£o

116

consiste em girar o objeto em torno de um ponto fixo segundo uma amplitude medida em

radianos ou graus, onde a forma e o tamanho do objeto √© preservada.

Na computa√ß√£o gr√°fica, em especial no Processing, a rota√ß√£o √© uma fun√ß√£o que faz

girar todo o sistema de coordenadas em torno de sua origem quando o comando rotate(rad)

√© acionado na constru√ß√£o. Onde o par√¢metro rad √© o √¢ngulo medido em radianos quando

giramos o objeto no sentido hor√°rio.

Na Matem√°tica, a unidade padr√£o para medir √¢ngulos √© o radiano. Entretanto,

costumamos ensinar trigonometria com os √¢ngulos medidos em graus tanto a n√≠vel de

Ensino Fundamental como no Ensino M√©dio. Em fun√ß√£o disso, vamos escrever a rota√ß√£o

segundo essa unidade de medida, o grau, acionando o c√≥digo rotate (radians(grau)); Onde

a express√£o radians(grau) ser√° a convers√£o autom√°tica da medida do √¢ngulo em graus para

radianos.

Mesmo n√£o sendo necess√°rio o dom√≠nio das unidades do √¢ngulo em radiano, √©

importante que os alunos conhe√ßam pelo menos o sistema de convers√£o de uma unidade

para a outra e para isso podemos partir de uma circunfer√™ncia de raio ùëü qualquer com

centro na origem do plano cartesiano. Como o c√≠rculo √© dividido em quatro quadrantes
nesse plano e uma volta completa mede 360o, ent√£o conforme mostra a Figura 47, os

√¢ngulos em graus e radianos s√£o denotados por sua correspond√™ncia na regra de tr√™s

simples:

(a) √Çngulos medidos em graus

(b) √Çngulos medidos em radianos

Figura 47: Medidas de √¢ngulos em graus e em radianos

Graus
360o
180o

ùõº

Radianos

2ùúã

ùúã

ùõΩ

5.3 Isometria de rota√ß√£o

117

Pela regra de tr√™s simples, os alunos podem converter a unidade de grau para

radianos ou radianos para graus no momento que julgarem oportuno aplicando a convers√£o

direta como segue:

ùõº = 180oùõΩ

ùúã

ùõΩ = ùõºùúã
180o

Combina√ß√£o das transforma√ß√µes de rota√ß√£o e transla√ß√£o

A fun√ß√£o de rota√ß√£o gera um efeito visual interessante. No entanto, utilizando

somente esse recurso na programa√ß√£o acometeremos um erro no quesito visual, visto que,

a rota√ß√£o gira todo o sistema de coordenadas em torno da origem, n√£o importando qual

o objeto desenhado na tela. Para evitar esse problema utilizaremos a transla√ß√£o para

alterar a origem antes de rotacionar a constru√ß√£o e assim, toda e qualquer constru√ß√£o

permanecer√° visualmente na tela.

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù e manipula√ß√£o do plano cartesiano;

Explora√ß√£o do c√≥digo de rota√ß√£o com os estudantes agrupados em duplas ou trio; E

compete aos estudantes construir o Applet experimentando os efeitos gr√°ficos em sintonia

com a teoria da transforma√ß√£o para enriquecer as possibilidades nas constru√ß√µes de novos

aplicativos.

Material

Malha quadriculada, l√°pis ou caneta e computador com o Processing instalado.

Procedimento

Considere um ret√¢ngulo de dimens√µes 50 por 70 pixels iniciada na coordenada

(0, 0). Fixando-se um alfinete na origem do sistema e girando toda a malha quadriculada
no sentido hor√°rio, com o aux√≠lio do transferidor, fa√ßa o ret√¢ngulo girar 90o em rela√ß√£o as

coordenadas iniciais, como mostra a Figura 48(a).

Mantendo-se uma malha quadriculada em branco, fixa abaixo da inicial, os alunos

constataram que a rota√ß√£o do ret√¢ngulo saiu totalmente do sistema da malha, em com-

puta√ß√£o isso significa que a constru√ß√£o n√£o esta vis√≠vel na tela. Para evitar esse efeito

visual utilizamos uma transla√ß√£o depois da rota√ß√£o, deslocando o novo ret√¢ngulo em 70

unidades para a direita e 0 unidades para baixo, em rela√ß√£o ao ‚Äúnovo‚Äù sistema, e com isso,

a constru√ß√£o volta a aparecer totalmente sob a malha quadriculada fixada ressurgindo na

tela como aparece na Figura 48(b).

5.3 Isometria de rota√ß√£o

118

(a) Rota√ß√£o do plano em 90o

(b) Transla√ß√£o do plano com giro de 90o

Figura 48: Rota√ß√£o do ret√¢ngulo de 50 por 70 pixels na malha quadriculada

Contudo, se executarmos o mesmo deslocamento no Processing n√£o obteremos a

mesma imagem obtida de forma manual. O motivo encontra-se no fato do novo sistema
obtido ap√≥s o giro de 90o ser equivalente ao eixo ‚àíùë¶ùëÇùë•, em outras palavras, o novo eixo

horizontal √© o ‚àíùë¶ e o eixo vertical √© o ùë•. Com isso, na programa√ß√£o devemos lan√ßar a

seguinte informa√ß√£o em rela√ß√£o ao sistema de eixos ‚Äòoriginal‚Äù, ùë•ùëÇùë¶, deslocamos 0 unidades

para a direita e ‚àí70 unidades para baixo. Para exemplificar isso, construiremos essa

mesma atividade no Processsing salientando que essa situa√ß√£o seria totalmente diferente

se o √¢ngulo de giro fosse distinto do √¢ngulo reto, ou ainda, para qualquer outro √¢ngulo
diferente dos m√∫ltiplos de 90o a rela√ß√£o entre os ‚Äúnovos‚Äù eixos e os ‚Äúoriginais‚Äù n√£o seria

facilmente obtida e isso dificulta a visibilidade do objeto programado.

Essa atividade mostrar√° na pr√°tica a import√¢ncia no deslocamento da origem do

sistema para um ponto no interior da tela, em alguns casos costumamos utilizar o centro da

tela como ‚Äúnova‚Äù origem, e s√≥ assim executarmos o giro do √¢ngulo estipulado. O intuito de

manter essa ordem tanto em programa√ß√£o como ‚Äúmanualmente‚Äù versa sobre a facilidade

de realizarmos a rota√ß√£o sem nos preocuparmos com a coordenada de origem.

Isso, √©

muito empregado no estudo da C√¥nicas em Geometria Anal√≠tica, para ser mais preciso,

a ordem de execu√ß√£o √© a mesma diferindo apenas no fato de deslocarmos as c√¥nicas com

centro fora da origem para um ‚Äúnovo‚Äù eixo cuja origem coincida com o centro da c√¥nica

para obtermos a rota√ß√£o da mesma como aparece nos livros de Geometria Anal√≠tica de

n√≠vel superior, a exemplo, o livro de Geometria Anal√≠tica da Cole√ß√£o PROFMAT [40].

Nesse intuito, al√©m da referida constru√ß√£o, montaremos um jogo de imagens do

quadrado de lado 50 pixels girando em torno do mesmo ponto fixo, no centro da tela,

atrav√©s da fun√ß√£o void para n√£o precisarmos repetir sempre o mesmo c√≥digo modificando

apenas a cor de cada quadrado.

5.3 Isometria de rota√ß√£o

119

Para alcan√ßar nosso objetivo, vamos lan√ßar os c√≥digos do ret√¢ngulo de 50 por 70

pixels e do quadrado de 50 pixels de lado em ‚ÄúApplets‚Äù distintos e avaliar o efeito da

rota√ß√£o no Processing seguindo ordens diversas na execu√ß√£o da transla√ß√£o.

Parte I

Visualiza√ß√£o do ret√¢ngulo de 50 por 70 pixels na origem seguida da rota√ß√£o de 90o

em torno dessa origem, e por fim, um deslocamento de 0 unidades para direita e ‚àí70

unidades para baixo.

a) Abra um arquivo no Processing e salve como: Applet 6 nome da dupla ou trio.

b) Construa o ret√¢ngulo de 50 por 70 pixels centrado na origem do ‚ÄúApplet‚Äù de tamanho

150 por 150 pixels com plano de fundo branco. N√£o esque√ßa de definir uma cor (fill )

para o ret√¢ngulo;

c) Aplique o comando rotate(radians(90)); e, em seguida, repita o c√≥digo do ret√¢ngulo

modificando apenas sua cor. Ao final, execute o programa e observe as imagens
obtidas. O novo ret√¢ngulo com giro de 90o apareceu na tela?

d) Como a rota√ß√£o n√£o desenha o ret√¢ngulo dentro da tela, vamos transladar, agora,

o eixo em 0 unidades para a direita e ‚àí70 unidades para baixo. Para isso, utilize

a fun√ß√£o translate seguida do c√≥digo do ret√¢ngulo com uma nova cor. Execute

novamente o programa e visualize como o ret√¢ngulo aparece na tela. O ret√¢ngulo

continua na mesma posi√ß√£o do inicial? O efeito visual proporcionado pode se igualar

ao da atividade realizada em malha quadriculada?

e) Como desafio, coloque toda a constru√ß√£o a partir do comando rotate(radians(90));

em coment√°rio utilizando o artif√≠cio /* ¬∑ ¬∑ ¬∑ */ e;

f) Refa√ßa a constru√ß√£o iniciando com a mesma transla√ß√£o adaptando suas coordenadas

de forma que o ret√¢ngulo deslocado apare√ßa na tela com uma cor distinta;

g) Depois de transladar o ret√¢ngulo, vamos girar o ret√¢ngulo em 90o da mesma forma

que fizemos antes, repetindo para isso as coordenadas do ret√¢ngulo com uma nova

cor logo em seguida ao comando rotate(radians(90));

h) Comparando o primeiro resultado com esse, existe alguma diferen√ßa visual? E

quanto aos c√≥digos, existe alguma distin√ß√£o? Se houver, qual foi a principal modi-

fica√ß√£o necess√°ria?

5.3 Isometria de rota√ß√£o

120

Com essa atividade os alunos viabiliza√ß√£o a import√¢ncia de executar uma transla√ß√£o antes

de iniciar a pr√≥pria rota√ß√£o como meio facilitador, ao ponto de alcan√ßar o mesmo objetivo

com um grau menor de dificuldade como consta nas Figuras 49(a) e 49(b). Salienta-se

ainda que se a transla√ß√£o fosse para o centro da tela a constru√ß√£o exigiria um grau de

dificuldade ainda menor. Dessa forma, o docente pode sugerir que os alunos mudem a

rota√ß√£o para o centro da tela e avaliem o quanto esse recurso torna a atividade vers√°til.

(a) Rota√ß√£o seguida da
transla√ß√£o do ret√¢ngulo

(b) Transla√ß√£o seguida
da rota√ß√£o do ret√¢ngulo

Figura 49: Applet 6: Rota√ß√£o-Transla√ß√£o e Transla√ß√£o-Rota√ß√£o no ret√¢ngulo de 50 por
70 pixels

Parte II

De posse do conhecimento de rota√ß√£o e a import√¢ncia em executar uma transla√ß√£o

antes de ativar o giro do plano, vamos construir diversos quadrados de 50 pixels de lado
com giros constantes de 30o ao redor do mesmo ponto de origem deslocada. Para deixar a

constru√ß√£o mais din√¢mica, utilizaremos o recurso de mudan√ßa de cor constante para dar

um efeito visual diversificado em conjunto com a fun√ß√£o void.

a) Abra um novo arquivo e salve como: Applet 7 nome da dupla ou trio.

b) Vamos construir o cen√°rio para a fun√ß√£o void com aplica√ß√£o para n√∫meros inteiros

na mudan√ßa de cores dos quadrados.

1 int a=0 ; //Vari√°vel inteira para as cores.

5 background(255);//Fundo branco.

2 void setup() {

6 }

3 size (200, 200);//Tamanho da tela.

7 void draw() {

4 smooth();//Suaviza o tra√ßado.

8 }

c) Construa o quadrado vermelho de 50 pixels de lado com deslocamento de 100 por

100 unidades a partir da origem que servir√° de base para nossa constru√ß√£o, como

mostra a Figura 50(a). Para alcan√ßar esse objetivo utilize os comandos ùëüùëíùëêùë°(¬∑ ¬∑ ¬∑ );

5.3 Isometria de rota√ß√£o

121

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(¬∑ ¬∑ ¬∑ ); e ùëì ùëñùëôùëô(¬∑ ¬∑ ¬∑ ); em qualquer tom de vermelho na fun√ß√£o void draw ().

N√£o esque√ßa de organizar os dados para manter o quadrado a partir do ponto de

coordenadas (100, 100).

d) Abra uma aba e nomeia de ‚Äúquadrado‚Äù. Nessa aba vamos construir duas fun√ß√µes
quadrados e cores programadas com um giro de 30o, onde a fun√ß√£o cor depender√° do

par√¢metro ‚Äúa‚Äù. Siga os comandos para construir esses quadrados e cores animadas.

1 void quadrado1() {

9 rect(0, 0, 50, 50); //Quadrado 2.

2 rotate(radians(30)); //Giro de 30o.

10 }

3 cor(1); //Cor animada.

11 void cor(1) {

4 rect(0, 0, 50, 50); //Quadrado 1.

12 fill(255‚àíùëé, 255‚àí2 ‚ãÜ ùëé, 5 ‚ãÜ ùëé+1);

5 }

6 void quadrado2() {

13 }

14 void cor(2) {

7 rotate(radians(30)); //Giro de 30o.

15 fill(100+ùëé, 255‚àí2 ‚ãÜ ùëé, 5 ‚ãÜ ùëé‚àí200);

8 cor2 (); //Cor animada.

16 }

Observe que a fun√ß√£o void quando utilizado para controlar a cor de preenchimento

cria a possibilidade de manuseia-la em outras fun√ß√µes. Diante disso, qual o benef√≠cio

pr√°tico viabilizado por esse procedimento? Ao executar uma separa√ß√£o do objeto de seu

preenchimento podemos manipular as cores de forma independente e assim diferenciar

durante a programa√ß√£o ao mesmo tempo que reaproveitar em objetos diversos.

e) Para reproduzir a Figura 50(b), volte a aba ‚Äúapplet 7‚Äù e digite o nome da fun√ß√£o qua-

drado1(); e quadrado2(); alternadamente depois do comando do quadrado vermelho

na fun√ß√£o void draw de modo que a constru√ß√£o complete uma volta encaixando o

primeiro quadrado girado com o √∫ltimo.

f) Note que a constru√ß√£o apresenta uma cor constante e nosso objetivo √© deixa-la

oscilante a partir do par√¢metro ‚Äúa‚Äù. Para manter esse intuito, acrescente o comando

ùëé = (ùëé+1)%ùë§ùëñùëëùë°‚Ñé; ao final do jogo de dados das fun√ß√µes quadrados antes de encerrar

a fun√ß√£o void draw.

Com isso, nossa atividade se encerrar. No entanto, √© poss√≠vel incrementar a ativi-

dade adicionando um c√≠rculo e dois tri√¢ngulos sim√©tricos no centro da constru√ß√£o de forma
que o tri√¢ngulo gire 360o, continuamente. Para isso, √© s√≥ construir os elementos necess√°-

rios na aba ‚Äúquadrado‚Äù e depois ampliar os c√≥digos da aba ‚Äúapplet 7‚Äù com os respectivos

dados na ordem.

5.3 Isometria de rota√ß√£o

122

(a) Quadrado vermelho

(b) Rota√ß√£o do jogo de quadrados

Figura 50: Applet 7: Giro de quadrados com cores oscilantes

Na aba ‚Äúquadrado‚Äù

Na aba ‚Äúquadrado‚Äù

1 void centro() {

2 fill(255,200,0); //Cor amarela

3 ellipse(0, 0, 30, 30); //C√≠rculo no centro

4 strokeWeight(2);
5 rotate(b); //Para rota√ß√£o de 360o

6 cor1();

7 triangle(0, 0, 15, 0, 0, 15);

8 rotate(radians(180));

9 cor2();

10 triangle(0, 0, 15, 0, 0, 15); }

Na aba ‚Äúapplet 7‚Äù

Na aba ‚Äúapplet 7‚Äù

1 int a = 0;

5 void draw() {

2 float b = 0; //Para rota√ß√£o dos tri√¢ngulos

6 ¬∑ ¬∑ ¬∑

3 void setup () {

4 ¬∑ ¬∑ ¬∑ }

7 centro ( );

8 b += 0.01; }

Aos alunos que complementarem a atividade √© vi√°vel utilizar uma malha quadri-

culada para construir o c√≠rculo e explorar a possibilidade de construir dois tri√¢ngulos com

um dos pontos na borda do c√≠rculo e os demais no interior do mesmo de forma a se as-

semelhar com um losango. Com isso, os alunos explorar√£o a linguagem em conjunto com

uma estrat√©gia para solucionar um problema eminente ao n√≠vel de seu conhecimento. O

resultado do incremento da atividade e essa √∫ltima varia√ß√£o desafiadora produz como re-

sultado as Figuras 51(a) e 51(b), sendo que a √∫ltima √© considerada um poss√≠vel resultado

tendo em vista a liberdade de escolha das coordenadas dos tri√¢ngulos.

5.3.2 Aprimorando a rota√ß√£o

Objetivo

Aprimorar a fun√ß√£o de rota√ß√£o atrav√©s do condicionador if-else para teste de valor

l√≥gico, verdade e falsidade no processo de constru√ß√£o de ‚Äúmandalas‚Äù. E Automatizar as

5.3 Isometria de rota√ß√£o

123

(a) Tri√¢ngulo em giro

(b) Los√¢ngulo em giro

Figura 51: Applet 7.1: Catavento quadrangular em oscila√ß√£o de cores

aplica√ß√µes com elementos repetidos em coordenadas distintas para melhorar a linguagem

durante a programa√ß√£o.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Rota√ß√£o; No√ß√µes de l√≥-

gica.

Subs√≠dio Te√≥rico

O desenvolvimento dessa atividade est√° atrelada a uma no√ß√£o r√°pida de l√≥gica,

principalmente, no que discerne a opera√ß√£o de verdade e falsidade. Na programa√ß√£o existe

alguns comandos utilizados para analisar os operadores l√≥gicos atrav√©s dos conectivos ‚Äúe‚Äù,

‚Äúou‚Äù e ‚Äúnega√ß√£o‚Äù. No entanto, tal an√°lise n√£o faz parte do enfoque dessa atividade, mas na

pr√≥xima atividade abordaremos com mais detalhes, no momento foquemos nossa aten√ß√£o

ao fato da informa√ß√£o verdadeira executar uma opera√ß√£o e o contr√°rio, a informa√ß√£o falsa

executar√° outra opera√ß√£o.

Para esse tipo de an√°lise vamos utilizar o recurso da fun√ß√£o if-else. Essa estrutura

atua em conjunto com o comando for que executa uma repeti√ß√£o no comando at√© que uma

condi√ß√£o seja satisfeita, isto √©, o comando for √© uma estrutura de repeti√ß√£o empregado

quando se conhece o n√∫mero de vezes que o bloco da constru√ß√£o √© executado. Sua estrutura

fundamenta-se √© um valor inteiro ou real associado a uma condi√ß√£o com incremento na

fun√ß√£o e, a parti da√≠, iniciamos os comandos para o argumento verdadeiro seguida da

informa√ß√£o falsa, como segue no esquema abaixo:

for (valor inicial; condi√ß√£o; incremento na fun√ß√£o){

if (afirma√ß√£o) {

comando se for verdadeiro;

} else{

comando se for falso;

}

5.3 Isometria de rota√ß√£o

124

A esse tipo de argumenta√ß√£o √© poss√≠vel inserir outras condi√ß√µes caso a primeira

informa√ß√£o n√£o seja verdadeira, com isso √© poss√≠vel criar ramifica√ß√µes no comando if-else

at√© atingir todos os objetivos. No entendimento de Ben Fry e Casey Reas [27, p. 53],

the conditionals allow a program to behave differently depending on the values of their
variables3. Para cada afirma√ß√£o deve haver uma express√£o que resolve para verdade ou

falso e quando a express√£o √© verdadeira o c√≥digo entre as chaves √© executado, do contr√°rio

passa para a pr√≥xima afirma√ß√£o. Os autores supracitados [27, p. 66] enumeram ainda

como o comando for √© executado a cada nova intera√ß√£o como segue na sequ√™ncia com

tradu√ß√£o nossa:

1. A declara√ß√£o do valor inicial √© executado;

2. A afirma√ß√£o √© avaliada como verdade (true) ou falso (false);

3. Se a afirma√ß√£o for verdadeira, v√° para a etapa 4. Se a afirma√ß√£o for falsa, pule para

a etapa 6;

4. Execute as instru√ß√µes dentro do comando se verdadeiro;

5. Execute a instru√ß√£o de incremento da fun√ß√£o e passe para a etapa 2;

6. Saia da estrutura e continue a execu√ß√£o do programa.

Durante a aplica√ß√£o ser√° poss√≠vel testar as informa√ß√µes anteriores e seus efeitos

visuais na constru√ß√£o de mandalas.

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù; Explora√ß√£o do c√≥digo de repeti√ß√£o

for com teste l√≥gico de verdade ou falso com os estudantes agrupados em duplas ou trio;

E explorar os efeitos visuais na retirada do preenchimento dos objetos para construir

mandalas.

Material

Computador com o Processing instalado.

Procedimento

Para construir imagens no estilo de mandalas facilmente vamos utilizar o recurso

de repeti√ß√£o de comandos seguindo uma l√≥gica para verdade e outra para falsidade. Como

3as estruturas condicionais permitem que um programa se comporte de forma diferente, dependendo

dos valores de suas vari√°veis (Tradu√ß√£o nossa).

5.3 Isometria de rota√ß√£o

125

essa √© nossa primeira atividade no seguimento, iremos mostrar como utilizar esse recurso

com detalhes para futuras constru√ß√µes ou remodela√ß√£o das j√° realizadas com o intuito de

enxugar o c√≥digo ao m√°ximo e otimizar a constru√ß√£o.

Vamos come√ßar preparando o cen√°rio para a constru√ß√£o das mandalas e depois

lan√ßar os dados dos objetos para gerar o visual gr√°fico necess√°rio do nosso objetivo.

a) Abra um arquivo e salve como: Applet 8 nome da dupla ou trio.

b) Configura√ß√£o inicial do cen√°rio da mandala.

1 size(300, 300);

3 translate(150, 150); //Nova origem da

2 background(255); //Fundo branco.

constru√ß√£o.

c) Estrutura for com comando rotate.

1 for (int ùëñ= 1; ùëñ < width; ùëñ + +) {

uma unidade a cada novo giro at√© atingir o

2 rotate(radians(11.25)‚ãÜùëñ);

valor da largura (width) da tela.

3 //Constru√ß√£o inicia para ùëñ=1 e aumenta

4 ¬∑ ¬∑ ¬∑ }

d) Incrementando o teste l√≥gico no comando for para avaliar o efeito visual.

4 if (ùëñ%3==0) {

5 fill(250, 200, 150);

6 stroke(200, 0, 200);

7 strokeWeight(3);

12 strokeWeight(2);

13 rect(0, 0, 100, 100);

14 } else {

15 fill(200, 200, 0);

8 triangle(0, 0, 100, 0, 0, 100);

16 stroke(0, 0, 0);

9 } else if (ùëñ%2==0) {

10 fill(100, 100, 100);

11 stroke(0, 200, 150);

17 strokeWeight(2);

18 ellipse(0, 0, 100, 30);

19 }

e) Execute a constru√ß√£o e observe como fica o empilhamento dos objetos conforme

mostra a Figura 52(a). Se omitirmos o preenchimento dos objetos colocando uma

barra dupla nos comandos fill obteremos a Figura 52(b).

A fun√ß√£o if desenha o tri√¢ngulo se ùëñ dividir por 3 sem resto. Se n√£o dividir executa

os c√≥digos depois de else, para desenhar o quadrado de 100 pixels de lado, o valor de ùëñ

dividir√° exatamente por 2 e, se houver resto ainda desenha uma elipse como comando

final.

5.3 Isometria de rota√ß√£o

126

(a) Sobreposi√ß√£o de objetos colori-
dos

(b) Objetos sobrepostos

Figura 52: Applet 8: Constru√ß√£o dos elementos da mandala

f) No entanto, nossa constru√ß√£o ainda n√£o apresenta uma caracter√≠stica de uma man-

dala, para isso acrescente na configura√ß√£o inicial antes da fun√ß√£o translate o comando

noFill();. Esse comando remove o preenchimento das constru√ß√µes permitindo so-

brepor as linhas visualmente como podemos ver atrav√©s da Figura 53(a).

g) O que acontece com a mandala se acrescentarmos logo ap√≥s a cor do plano de fun√ß√£o

o comando rectMode(CENTER);. Teste esse comando e observe seu efeito.

(a) Mandala expandida

(b) Mandala compactada

Figura 53: Applet 8.1: Mandala em duas perspectivas centrais

O comando rectMode combinado com o modo CENTER afeta como os ret√¢ngulos

s√£o desenhados conforme mostra a Figura 53(b), esse modo faz com que o primeiro e o

segundo par√¢metro do ret√¢ngulo seja o centro da constru√ß√£o para uma largura e altura

estabelecida, para os alunos perceberem a diferen√ßa solicitem que ocultem o comando

noFill e execute o programa. Depois oculte o comando rectMode(CENTER) e questionem

qual a diferen√ßa visual da constru√ß√£o. Assim poder√° explicar como esse comando funciona

na integra.

5.3 Isometria de rota√ß√£o

127

Avalia√ß√£o

Avaliar se todos conseguiram construir suas mandalas nos dois formatos solicitados.

Com essa atividade o mediador poder√° solicitar uma nova constru√ß√£o mudando a posi√ß√£o

dos objetos ou inserindo novos objetos geom√©tricos. Com isso, vai ser poss√≠vel reavaliar o

dom√≠nio da nova ferramenta e sua potencialidade de ensino preparando-os para aplica√ß√µes

mais complexas.

5.3.3 Anima√ß√£o com efeito de rota√ß√£o

Objetivo

Ampliar o dom√≠nio do recurso da fun√ß√£o de rota√ß√£o com a constru√ß√£o de uma

anima√ß√£o din√¢mica e interativa nas suas cores.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Rota√ß√£o.

Subs√≠dio Te√≥rico

Para a constru√ß√£o dessa anima√ß√£o os alunos utilizaram todos os conhecimentos

j√° apresentados nas aplica√ß√µes anteriores com o acr√©scimo de uma nova fun√ß√£o chamada

keyPressed(), onde cada vez que uma tecla √© pressionada o c√≥digo dentro da fun√ß√£o Key-

Pressed √© executado uma vez. Essa fun√ß√£o √© associada a vari√°vel boolean que possui

apenas dois valores l√≥gicos, verdade ou falso, al√©m disso, existe a possibilidade de com-

binar com a condicional if ativando seus c√≥digos somente quando pressionar uma tecla

ou mesmo parando seus c√≥digos ao pressionar alguma tecla a depender da atribui√ß√£o na

vari√°vel boolean.

O roteiro da atividade e execu√ß√£o da anima√ß√£o visa uma manipula√ß√£o pr√°tica

de um sistema de rota√ß√£o a partir do esquema na malha quadriculada. O sucesso do

processo depende da estrutura√ß√£o do fluxograma antes da programa√ß√£o para viabilizar

uma otimiza√ß√£o na linguagem utilizada.

Al√©m dessa nova vari√°vel o aluno precisar√° da no√ß√£o de l√≥gica com rela√ß√£o ao

operador l√≥gico ‚Äúou‚Äù, entretanto, abordaremos os outros valores l√≥gicos com o intuito de

diferenciar-los primordialmente no contexto da programa√ß√£o. Nesse intuito, o professor

mediador poder√° utilizar atividades textuais utilizando esses conectivos para exemplificar

a veracidade da informa√ß√£o. Como o nosso p√∫blico se resume aos alunos do nono ano do

Ensino Fundamental, vamos elucidar essas opera√ß√µes l√≥gicas explanando quando a rela√ß√£o

5.3 Isometria de rota√ß√£o

128

entre duas senten√ßas assume valor l√≥gico verdade e do contr√°rio assume valor l√≥gico falso.

Como as opera√ß√µes l√≥gicas s√£o visualizadas geralmente no primeiro ano do Ensino

M√©dio, n√£o vamos entrar em detalhes com a tabela verdade. Em suma, os discentes

necessitam apenas reconhecer quando duas senten√ßas assumem valor l√≥gico verdade ou

falso a depender do conectivo l√≥gico empregado. Por esse motivo, a presen√ßa do professor

mediador em conjunto com um banco de afirma√ß√µes textuais e matem√°ticas podem ajudar

os alunos analisarem quando uma informa√ß√£o √© ver√≠dica ou n√£o.

De acordo com o emprego da l√≥gica em conson√¢ncia com a linguagem de progra-

ma√ß√£o podemos resumir cada operador l√≥gico e seu emprego computacional como segue:

1. Operador l√≥gico ‚Äúe‚Äù s√≥ assume o valor l√≥gico verdade quando todas as informa√ß√µes

s√£o verdadeiras. Em programa√ß√£o, esse operador l√≥gico √© representado pelo s√≠mbolo

‚Äú&&‚Äù.

Exemplo 5.1. Dado o ret√¢ngulo nas coordenadas ùëüùëíùëêùë°(ùë• + 10, ùë• + 20, 60, 40); Construa

todos os ret√¢ngulos para ùë• > 20 e ùë• < 50, onde ùë• √© um n√∫mero inteiro n√£o negativo.

2. J√° o operador l√≥gico ‚Äúou‚Äù s√≥ assume valor l√≥gico verdade quando pelo menos uma

das afirma√ß√µes √© verdadeira. Na programa√ß√£o, o s√≠mbolo representativo √© o ‚Äú||‚Äù.

Exemplo 5.2. Dada a elipse nas coordenadas ùëíùëôùëôùëñùëùùë†ùëí(ùëé + 50, 30 + ùëé, ùëé + 30, ùëé + 30);

Construa todos as elipses quando ùëé < 40 ou ùëé > 60 para ùëé pertencente ao conjunto dos

n√∫meros inteiros n√£o negativos.

3. O operador l√≥gico da ‚Äúnega√ß√£o‚Äù, nega todas as afirma√ß√µes anteriores. Em progra-

ma√ß√£o, essa nega√ß√£o √© ativada pelo s√≠mbolo ‚Äú!‚Äù.

Exemplo 5.3. Para todo ùëê n√£o maior que 50, construa os tri√¢ngulos nas coordenadas

ùë°ùëüùëñùëéùëõùëîùëôùëí(ùëê + 20, 50, ùëê + 60, 10, 150, 200) Onde ùëê pertence ao conjunto dos n√∫meros inteiros

n√£o negativos.

Todos esses exemplos podem ser explorados em sala de aula atrav√©s de uma malha

quadriculada para visualizar se os alunos compreendem o significado pr√°tico de cada

conectivo no contexto da matem√°tica com √™nfase para a constru√ß√£o de objetos geom√©tricos.

Uma vez compreendido no papel o processo de sua constru√ß√£o passa-se a planejar como

inserir essa constru√ß√£o atrav√©s de uma linguagem de programa√ß√£o de forma a se obter o

mesmo efeito visual. Nesse ponto, sugerimos a aplica√ß√£o dos exemplos na programa√ß√£o

atrav√©s dos c√≥digos que sugestionaremos a seguir.

5.3 Isometria de rota√ß√£o

129

1. Configure a tela no tamanho necess√°rio para a constru√ß√£o com um plano de fundo

branco, sem preenchimento (noFill ) e uma cor para a linha do contorno (stroke)

com a espessura de 1.5 (strokeWeight);

2. Utilize o comando for para inserir o tipo de vari√°vel, a condi√ß√£o pode ser o valor da

tela e seu incremento unit√°rio;

3. Para cada constru√ß√£o l√≥gica utilize no c√≥digo if a restri√ß√£o para enfim escrever as

fun√ß√µes solicitadas.

Para demonstrar como proceder nessa exemplifica√ß√£o com os alunos via linguagem

de programa√ß√£o, vamos lan√ßar os c√≥digos referente aos exemplos 5.1, 5.2 e 5.3 com as

respectivas Figuras 54(a), 54(b) e 54(c), nessa ordem. Salienta-se que a visualiza√ß√£o

isolada de cada uma delas se dar perante a inclus√£o de parte do c√≥digo como coment√°rio.

1 //Configura√ß√£o b√°sica do programa

14 for (ùëñùëõùë° ùëé = 0; ùëé < 300; ùëé = ùëé + 3){

2 setup(300, 300);

3 background(255);

4 noFill(); //sem preenchimento.

5 stroke(30, 57, 67);

6 strokeWeight(1.5);

15 if(ùëé < 40 || ùëé > 60){

16 ellipse(ùëé + 50, 30 + ùëé, ùëé + 30, ùëé + 30);

17 }

18 }

19 //Teste do valor l√≥gico ‚Äúnega√ß√£o‚Äù.

7 //Teste do valor l√≥gico ‚Äúe‚Äù.

20 for(ùëñùëõùë° ùëê = 0; ùëê < 300; ùëê = ùëê + 2){

8 for (ùëñùëõùë° ùë• = 0; ùë• < 300; ùë• = ùë• + 2){

21 boolean ùëë = ùëê > 50; //ùëë = verdade

9 if (ùë• > 20 && ùë• < 50){

22 if(!ùëë){ //!ùëë = falso

10 rect(ùë• + 10, ùë• + 20, 60, 40);

23 triangle(ùëê + 20, 50, ùëê + 60, 10, 150, 200);

11 }

12 }

13 //Teste do valor l√≥gico ‚Äúou‚Äù.

24 }

25 }

(a) Exemplo 1

(b) Exemplo 2

(c) Exemplo 3

Figura 54: Operadores l√≥gicos ‚Äúe‚Äù, ‚Äúou‚Äù e ‚Äúnega√ß√£o‚Äù

5.3 Isometria de rota√ß√£o

130

Note no c√≥digo das aplica√ß√µes l√≥gicas que o incremento amplia a constru√ß√£o em

duas ou tr√™s unidades e a esse efeito dar-se o espa√ßamento entre as linhas das figuras,

no caso do incremento unit√°rio n√£o haveria espa√ßamento suficiente para visualizar a in-

terrup√ß√£o na constru√ß√£o do exemplo 2, e ao construir a nega√ß√£o foi necess√°rio construir

uma vari√°vel booleana com a declara√ß√£o indesejada para s√≥ assim negar essa nova vari√°vel

atrav√©s da l√≥gica computacional, isto √©, utilizando o s√≠mbolo ‚Äú!‚Äù.

Atrav√©s de todas essas ferramentas podemos construir nosso ‚ÄúApplet 9‚Äù com a

funcionalidade em futuras programa√ß√µes elaboradas utilizando o mesmo princ√≠pio b√°sico.

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù e manipula√ß√£o do plano cartesiano;

Explora√ß√£o do c√≥digo dos operadores l√≥gicos em conjunto com os estudantes agrupados

em duplas ou trio; E compete aos estudantes construir o esquema estrutural na malha

quadriculada para converter em linguagem de programa√ß√£o e assim, aprimorar o applet

atrav√©s da rota√ß√£o deslocada para o centro da tela.

Material

Malha quadriculada, l√°pis ou caneta, compasso e computador com o Processing

instalado.

Procedimento

Vamos construir duas barras verticais com uma bola em cada uma, se movendo,

e com essas barras apoiadas a partir do seu centro na terceira barra faz todo o conjunto

girar completamente at√© uma tecla ser acionada para ativar e desativar o movimento.

Para elucidar esse objetivo √© necess√°rio intercalar a programa√ß√£o com o planejamento na

malha quadriculada de forma a garantir o sucesso do ‚ÄúApplet‚Äù. A sensa√ß√£o de movimento

ser√° proporcionado pelas vari√°veis reais controlando os √¢ngulos dos giros e uma vari√°vel

inteira para gerenciar o movimento da bola, sendo que essa atividade √© uma adapta√ß√£o do
v√≠deo tutorial do Professor Doutor Michael Kipp4 que objetivava ensinar o gerenciamento

das fun√ß√µes pushMatrix e popMatrix.

Com isso, vamos lan√ßar m√£o dos dados da constru√ß√£o no Processing alternando

com a simula√ß√£o na malha quadriculada a medida que julgarmos necess√°rio.

a) Abra um arquivo e salve como: ‚ÄúApplet 9 nome da dupla ou trio.

4Para maiores informa√ß√µes sobre o curso do Processing desse professor, alem√£o, da Universidade de

Augsburg acesse o site http://processing.michaelkipp.de/.

5.3 Isometria de rota√ß√£o

131

b) Configure a fun√ß√£o void setup da seguinte forma;

1 void setup() {

2 size(300, 300);

4 fill(0);

5 rectMode(CENTER); //Para centralizar

3 noStroke(); //Sem serrilhamento no tra√ßo

6 }

c) Os primeiros itens da fun√ß√£o void draw ser√° configurar o plano de fundo e construir

o ret√¢ngulo que servir√° de suporte para os verticais.

Para isso, use uma malha quadriculada e projete o ret√¢ngulo com as dimens√µes de

200 por 15 pixels na origem. Como nossa constru√ß√£o ter√° o efeito de giro, ent√£o desloque

o ret√¢ngulo para o centro da malha quadriculada. Diante disso, podemos incrementar os
c√≥digos da etapa no programa e visualizar o primeiro giro de 360o.

1 void draw() {

4 rotate(ùëé); //Para o giro de 360o.

2 background(200); //Fundo cinza.

5 rect(0, 0, 200, 15);

3 translate(150, 150); //Centro do Applet.

6 }

Note que o programa informa que ùëé vari√°vel n√£o existe, solicite que os alunos

criem essa vari√°vel no campo dos n√∫meros reais (float) antes da fun√ß√£o setup e execute

o programa. Nessa hora a barra n√£o faz nenhum movimento por n√£o especificar como

ser√° o incremento dessa vari√°vel ùëé a cada execu√ß√£o do c√≥digo, da√≠, adicione o comando

ùëé + = 0.01 antes de fechar a chave da fun√ß√£o draw e volte a executar o primeiro giro.

d) Na malha quadriculada desenhe um novo ret√¢ngulo na origem com dimens√µes 10

por 80 pixels, observe que essa ser√° nossas barras verticais e devemos posicionar-las

nas extremidades na barra de suporte.

Para isso, solicitem aos discentes que determinem inicialmente a posi√ß√£o da barra

√† direita (barra 1), ou seja, qual o deslocamento necess√°rio dessa vez para alcan√ßar o obje-

tivo, deixe os alunos testarem seus dados no programa dentro da fun√ß√£o draw adicionando

os c√≥digos entre pushMatrix e popMatrix para visualizar se est√£o corretos.

Provavelmente, essa barra sair√° deslocada da barra suporte em fun√ß√£o do primeiro

deslocamento j√° ter mudado a origem em 150 pixels. Nesse ponto, a interfer√™ncia do pro-

fessor viabilizar√° essa observa√ß√£o para que os mesmos corrijam os dados sendo necess√°rio,

a depender do n√≠vel de cada aluno, apenas chamar a aten√ß√£o para a primeira constru-

√ß√£o. Uma vez corrigido os dados lan√ßados se equipararam aos seguintes implementado na

fun√ß√£o draw.

5.3 Isometria de rota√ß√£o

132

void draw() {

¬∑ ¬∑ ¬∑

rotate(ùëè); //Novo giro de 360o.

rect(0, 0, 10, 80);

translate(100, 0); //Centro barra1 (250, 150).

¬∑ ¬∑ ¬∑ }

Solicite que repita o procedimento da vari√°vel ùëé para criar essa nova vari√°vel ùëè com

o mesmo aumento no incremento, sendo este √∫ltimo anotado ap√≥s o incremento ùëé.

e) Descubra qual o deslocamento para a barra vertical √† esquerda (barra 2) a partir

da conclus√£o da barra anterior e adapte os c√≥digos anteriores para essa nova barra

que ficar√° com os seguintes c√≥digos adicionado logo ap√≥s a √∫ltima barra.

void draw() {

¬∑ ¬∑ ¬∑

rotate(ùëê); //Novo giro de 360o.

rect(0, 0, 10, 80);

translate(‚àí100,0); //Centro barra2 (50,150)

¬∑ ¬∑ ¬∑ }

f) Para finalizar a atividade falta colocar uma bola em movimento em cada barra

vertical e s√≥ conquistaremos essa etapa depois de planejar na malha quadriculada

as coordenadas da referida bola.

Solicitem aos alunos para construir um c√≠rculo, nossa bola, de raio 10 pixels apoiado na

barra 1 com seu centro sobre o segmento que parte do centro dessa barra paralelo ao

lado menor. Ao deslocar a barra 1, deslocamos a origem do sistema mantendo seu centro

na origem, em fun√ß√£o disso, considere o centro da barra 1 como o centro do sistema

para determinar as coordenadas da bola. A prov√°vel coordenada encontrada se seguida a

orienta√ß√£o ter√° a seguinte caracter√≠stica na programa√ß√£o ùëíùëôùëôùëñùëùùë†ùëí(15, 0, 20, 20);.

Para movimentar a bola na vertical, vamos trocar a coordenada do eixo ùë¶ por uma

vari√°vel ‚Äúùëèùëúùëôùëé‚Äù e lan√ßar esse c√≥digo juntamente com a cria√ß√£o dessa vari√°vel inteira no

programa. Como essa bola refere-se ao movimento da barra vertical podemos lan√ßar seu

c√≥digo tanto na barra 1 como na barra 2. Assim, o c√≥digo do programa ficar√° com esse

acr√©scimo logo ap√≥s cada barra, mas s√≥ ter√° movimenta√ß√£o se incluirmos o incremento

ùëèùëúùëôùëé + = 1;.

void draw() {

¬∑ ¬∑ ¬∑

ellipse(15, ùëèùëúùëôùëé, 20, 20);//bola 1

translate(‚àí100, 0); //Centro barra 2 (50,150).

translate(100, 0); //Centro barra 1 (250, 150).

rotate(ùëê); //Novo giro de 360o.

rotate(ùëè); //Novo giro de 360o.

rect(0, 0, 10, 80);

rect(0, 0, 10, 80);

ellipse(15, ùëèùëúùëôùëé, 20, 20);//bola 2

5.3 Isometria de rota√ß√£o

133

¬∑ ¬∑ ¬∑

ùëé + = 0.01;

ùëè + = 0.01;

ùëê + = 0.01;

ùëèùëúùëôùëé + = 1;

}

Note que a bola n√£o executa o seu movimento somente sobre as barras e para corri-

gir isso precisamos de uma nova vari√°vel para controlar o movimento da bola condicionando-

a a mover-se somente sobre as barras. Nesse quesito recorremos aos operadores l√≥gicos,

especificamente, ao operador l√≥gico ‚Äúou‚Äù para restringir o movimento al√©m da barra.

Da√≠, incluiremos os seguintes c√≥digos no seu lugar espec√≠fico.

ùëì ùëôùëúùëéùë° ùëé = 0;

¬∑ ¬∑ ¬∑

ùëñùëõùë° ùëèùëúùëôùëé = 0;

ùëñùëõùë° ùëöùëúùë£ùëíùëüùëèùëúùëôùëé = 1;

¬∑ ¬∑ ¬∑

ùëê + = 0.01;

ùëèùëúùëôùëé + = ùëöùëúùë£ùëíùëüùëèùëúùëôùëé;

ùëñùëì (ùëèùëúùëôùëé > 40 || ùëèùëúùëôùëé < ‚àí40){

ùëöùëúùë£ùëíùëüùëèùëúùëôùëé = ‚àíùëöùëúùë£ùëíùëüùëèùëúùëôùëé;

}

}

Com isso, as bolas se mover√£o ininterruptamente dentro do intervalo da altura do

ret√¢ngulo, ou seja, quando a bola atingir os limites do ret√¢ngulo o c√≥digo ùëöùëúùë£ùëíùëüùëèùëúùëôùëé =

‚àíùëöùëúùë£ùëíùëüùëèùëúùëôùëé; far√° suas coordenadas retrocederem o movimento da bola. Mas, a bola 2

encontra-se na regi√£o interna em rela√ß√£o a barra suporte, para mudar isso, basta mudar a

coordenada do eixo ùë• de 15 para ‚àí15 resultando na Figura 55. Para instalar um controle

que pare o movimento ao pressionar qualquer tecla √© s√≥ acrescentar uma nova fun√ß√£o

chamada void keyPressed ao final da linguagem com sua vari√°vel de controle.

ùë£ùëúùëñùëë ùêæùëíùë¶ùëÉ ùëüùëíùë†ùë†ùëíùëë(){

ùëóùëúùëîùëéùëü =!ùëóùëúùëîùëéùëü; }

(a) Posi√ß√£o 1

(b) Posi√ß√£o 2

(c) Posi√ß√£o 3

Figura 55: Applet 9: Controle de movimento com rota√ß√£o

5.4 Isometria de reflex√£o ou simetria

134

No entanto, √© preciso atribuir um valor l√≥gico na vari√°vel booleana, isto √©, acres-

centar no in√≠cio da programa√ß√£o o c√≥digo ùëèùëúùëúùëôùëíùëéùëõ ùëóùëúùëîùëéùëü = ùëì ùëéùëôùë†ùëí;. Mesmo assim, n√£o √©

poss√≠vel parar o movimento com nenhuma tecla sem antes configurar os valores da fun√ß√£o

ùëóùëúùëîùëéùëü, para isso, precisamos criar uma condi√ß√£o, ùëñùëì , controladora de todos os incrementos.

Da√≠, basta incluir os incrementos no comando ùëñùëì como segue:

ùëñùëì (ùëóùëúùëîùëéùëü){

ùëé + = 0.01;

ùëè + = 0.01;

ùëê + = 0.01;

ùëèùëúùëôùëé + = ùëöùëúùë£ùëíùëüùëèùëúùëôùëé;

ùëñùëì (ùëèùëúùëôùëé > 40 || ùëèùëúùëôùëé < ‚àí40){

ùëöùëúùë£ùëíùëüùëèùëúùëôùëé = ‚àíùëöùëúùë£ùëíùëüùëèùëúùëôùëé;

}

}

}

N√£o podemos esquecer de fechar todas as chaves, do contr√°rio o programa ir√°

acusar um erro na linguagem e inviabilizar√° sua aplica√ß√£o.

Avalia√ß√£o

Com essa atividade espera-se que os alunos desenvolvam uma intera√ß√£o com os

operadores l√≥gicos juntamente com a fun√ß√£o de controle de movimento al√©m de ampliar

seu dom√≠nio no planejamento dos fluxogramas importante para o desenvolvimento de

aplicativos b√°sicos e avan√ßados.

5.4 Isometria de reflex√£o ou simetria

A reflex√£o ou simetria √© uma transforma√ß√£o geom√©trica que preserva as caracter√≠s-

ticas de uma isometria de tal forma que o objeto sofre uma ‚Äúrota√ß√£o em rela√ß√£o ao eixo

espelhado‚Äù como se fosse retirado da folha de papel e transportado para o outro semi-

plano da folha como aponta o pensamento de Souza [36]. Dessa forma, esperamos que os

alunos caracterizem os objetos como isom√©tricos segundo uma reflex√£o em rela√ß√£o ao es-

pelhamento dos eixos coordenados. Nesse sentido, a figura do professor mediador durante

a etapa de execu√ß√£o √© de fundamental import√¢ncia, ainda mais sabendo que o mesmo

recurso computacional √© utilizado para ampliar ou reduzir os objetos possibilitando ainda

a dilata√ß√£o ou compress√£o de apenas um dos eixos.

Para fundamentar o processo de aprendizagem dessa isometria vamos combinar

com outras transforma√ß√µes em constru√ß√µes b√°sicas e avan√ßadas via programa√ß√£o diversi-

ficando com material concreto para elaborar os projetos na companhia dos discentes.

5.4 Isometria de reflex√£o ou simetria

135

5.4.1 Conhecendo a simetria

Objetivo

Construir o conceito de simetria ou reflex√£o de uma figura bidimensional e fa-

zer com que os alunos notem a simetria como um ‚Äúespelhamento‚Äù do objeto em outro

semiplano da tela, isto √©, em torno dos eixos coordenados deslocados e da nova origem.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Simetria e Transla√ß√£o.

Subs√≠dio Te√≥rico

A simetria √© uma transforma√ß√£o que necessariamente precisa estar combinada com

a transla√ß√£o dos eixos coordenados pelo mesmo motivo que demonstramos na rota√ß√£o.

Sendo assim, todas simetrias implementadas na atividade encontra-se com seus eixos

deslocados para o centro da tela, como referencial visual.

Para essa atividade vamos utilizar os elementos de outras atividades implemen-

tando o recurso de inserir texto na tela para diferenciar a figura original das refletidas em

rela√ß√£o aos eixos e a pr√≥pria origem deslocada (centro da tela).

Uma fonte deve ser convertida inicialmente para o formato VLW antes do Proces-

sing exibir o texto no display. Para converter uma fonte, selecione a op√ß√£o ‚ÄúCriar Fonte‚Äù

no menu Ferramentas e na janela que se abrir com os nomes das fontes instaladas no

computador plaus√≠vel de convers√£o, selecione uma dessas fontes e clique em ‚ÄúOK‚Äù. A fonte

√© gerada e copiada para a pasta de dados do Sketch atual. Para confirmar se a fonte foi

instalada, clique no menu Sketch e selecione ‚ÄúVer Pasta de Sketch‚Äù.

Na caixa de di√°logo ‚ÄúCriar Fonte‚Äù √© poss√≠vel alterar o tamanho da fonte e selecionar

se ser√° smooth (suave), al√©m da possibilidade de exportar ‚ÄúAll Characters‚Äù (todos os

caracteres) da fonte. Outra vantagem desse mecanismo est√° no fato da possibilidade de

alterar o nome da fonte antes de criar a mesma.

Uma vez que a fonte j√° exista, a exibi√ß√£o de letras ou textos na tela depender√°

de algumas etapas. Antes dessa fonte ser usada, precisamos carregar-la no programa e

definir com nossa fonte atual. Para isso, utilizamos um tipo de dados √∫nico do Processing

chamado ‚ÄúPFont‚Äù para armazenar seus dados. Da√≠, para construir uma mensagem textual

lan√ßamos os seguintes c√≥digos:

ùëÉ ùêπ ùëúùëõùë° ùëì ùëúùëõùë°ùëí; //Declara√ß√£o da vari√°vel.

5.4 Isometria de reflex√£o ou simetria

136

ùëì ùëúùëõùë°ùëí = ùëôùëúùëéùëëùêπ ùëúùëõùë°(‚Äúùëõùëúùëöùëí ùëëùëé ùëì ùëúùëõùë°ùëí ‚àí ùë°ùëéùëöùëéùëõ‚Ñéùëú.ùë£ùëôùë§‚Äù); //Carrega a fonte.

ùë°ùëíùë•ùë°ùêπ ùëúùëõùë°(ùëì ùëúùëõùë°ùëí); Define a fonte do texto atual.

ùë°ùëíùë•ùë°(‚Äúùëöùëíùëõùë†ùëéùëîùëíùëö‚Äù, ùë•, ùë¶); //Escreva a mensagem na coordenada (x,y).

√â poss√≠vel ainda alterar o tamanho da fonte sem criar uma nova fonte incluindo o

tamanho desejado dentro do c√≥digo ùë°ùëíùë•ùë°ùêπ ùëúùëõùë°(ùëì ùëúùëõùë°ùëí, ùëõùëúùë£ùëúùë°ùëéùëöùëéùëõ‚Ñéùëú).

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù a partir da montagem da estrutura

na malha quadriculada para montagem do fluxograma; Explora√ß√£o do c√≥digo de simetria

com os estudantes agrupados em duplas ou trio; E compete aos estudantes construir o

Applet experimentando os efeitos gr√°ficos em sintonia com a teoria da transforma√ß√£o para

enriquecer as possibilidades nas constru√ß√µes de novos aplicativos.

Material

Malha quadriculada, l√°pis ou caneta, compasso e computador com o Processing

instalado.

Procedimento

Nessa atividade vamos construir um escudo composto de v√°rios c√≠rculos, quadrados

e um tri√¢ngulo conforme mostra a Figura 56 e projeta-los em semiplanos distintos tanto em

rela√ß√£o aos eixos coordenados como em rela√ß√£o a origem do deslocamento. Para facilitar

a visualiza√ß√£o vamos construir usando linhas dois sistemas de eixos passando pelo centro

da tela para ser nossos eixos coordenados com centro em (150, 150).

Figura 56: Escudo para montagem

Dessa forma, o primeiro passo da atividade consiste basicamente em programar a

tela e construir o escudo como aparece na Figura 56. Diante disso, lan√ßamos os seguintes

c√≥digos no programa:

a) Configura√ß√£o do Applet;

5.4 Isometria de reflex√£o ou simetria

137

1 ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù( ) {

2 ùë†ùëñùëßùëí(300, 300);

3 ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

9 ùëÉ ùêπ ùëúùëõùë° ùëì ùëúùëõùë°ùëí;

10 ùëì ùëúùëõùë°ùëí = ùëôùëúùëéùëëùêπ ùëúùëõùë°(‚Äúùêµùëíùëõùëñùëêùëñùëú ‚àí 40.ùë£ùëôùë§‚Äù);

11 ùë°ùëíùë•ùë°ùêπ ùëúùëõùë°(ùëì ùëúùëõùë°ùëí, 38);

4 ùëì ùëúùëü(ùëñùëõùë° ùëñ = 0; ùëñ <= 300; ùëñ = ùëñ + 150){

12 }

5 ùë†ùë°ùëüùëúùëòùëíùëä ùëíùëñùëî‚Ñéùë°(2);

13 ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

6 ùëôùëñùëõùëí(0, 150, ùëñ + 150, 150);

14 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(150, 150);

7 ùëôùëñùëõùëí(150, 0, 150, ùëñ + 150);

15 ùë†ùë°ùëüùëúùëòùëíùëä ùëíùëñùëî‚Ñéùë°(1);

8 }

16 ¬∑ ¬∑ ¬∑ }

b) Para construir o escudo, abra uma nova ‚ÄúAba‚Äù e nomeia de escudo. Nessa aba

configure o escudo particionando-a em subfun√ß√µes;

1 ùë£ùëúùëñùëë ùëèùëüùëéùë†ùëéùëú( ){

2 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(50, 50);

//Desloca 30 pixels da origem

14 ùëì ùëñùëôùëô(255, 215, 0);//Cor amarela

//Desloca da origem 50 por 50 pixels

15 ùë°ùëüùëñùëéùëõùëîùëôùëí(20, 0, 40, 30, 0, 30);

3 ùëì ùëñùëôùëô(255, 0, 0);//cor vermelha

16 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 20);

4 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 60, 60);

5 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí30, ‚àí30);

//Desloca mais 20 pixels

17 ùëì ùëñùëôùëô(252, 15, 192);//Cor rosa choque

//Volta 30 pixels para a origem

18 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 20, 20);

6 ùëì ùëñùëôùëô(237, 145, 33);//Cor salm√£o

19 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí10, ‚àí10);

7 ùëûùë¢ùëéùëë(30, 0, 60, 30, 30, 60, 0, 30);

//Volta 10 pixels

8 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 30);

20 ùëì ùëñùëôùëô(124, 252, 0);//Cor verde lima

//Desloca 30 pixels da origem

21 ùëûùë¢ùëéùëë(10, 0, 20, 10, 10, 20, 0, 10);

9 ùëì ùëñùëôùëô(0, 0, 255);//Cor azul

22 }23 ùë£ùëúùëñùëë ùëíùë†ùëêùë¢ùëëùëú(){24 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

10 ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 40, 40);

11 }

12 ùë£ùëúùëñùëë ùë†ùëñùëöùëèùëúùëôùëú(){

13 ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 30);

25 ùëèùëüùëéùë†ùëéùëú();

26 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

27 ùë†ùëñùëöùëèùëúùëôùëú();

28 }

c) Uma vez programado a fun√ß√£o escudo podemos executar toda a simetria em rela√ß√£o

a cada um dos eixos cartesianos e a origem do plano transladado, em 150 pixels, na

aba ‚ÄúApplet‚Äù;

13 ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

15 ¬∑ ¬∑ ¬∑

16 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

18 ùëì ùëñùëôùëô(0);

19 ùë°ùëíùë•ùë°(‚Äùùê∏ùë†ùëêùë¢ùëëùëú‚Äù, ‚àí30, 65);

20 ùë°ùëíùë•ùë°(‚ÄùùëÇùëüùëñùëîùëñùëõùëéùëô‚Äù, ‚àí30, 90);

17 ùëíùë†ùëêùë¢ùëëùëú();//Escudo original.

21 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

5.4 Isometria de reflex√£o ou simetria

138

22 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•(); 23 ùë†ùëêùëéùëôùëí(‚àí1, 1);

29 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Simetria em rela√ß√£o ao eixo x deslocado.

30 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

24 ùëíùë†ùëêùë¢ùëëùëú();

25 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

26 ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

27 ùë†ùëêùëéùëôùëí(1, ‚àí1);

31 ùë†ùëêùëéùëôùëí(‚àí1, ‚àí1);

//Simetria em rela√ß√£o a origem deslocada.

32 ùëíùë†ùëêùë¢ùëëùëú();

33 ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Simetria em rela√ß√£o ao eixo y deslocado.

34 }

28 ùëíùë†ùëêùë¢ùëëùëú();

O professor mediador pode intercalar essa constru√ß√£o com o uso da malha quadri-

culada solicitando para os alunos constru√≠rem cada um dos elementos do escudo isolada-

mente na malha quadriculada e depois montar cada uma das fun√ß√µes, brasao e simbolo,

com tr√™s objetos apenas, encaixando o menor sobre o maior, sendo um quadrado entre

dois c√≠rculos para o brasao, e um c√≠rculo entre um tri√¢ngulo e um quadrado para a outra

fun√ß√£o. Nesse ponto, os alunos devem determinar quanto cada um deslocar√° para a pri-

meira constru√ß√£o, o c√≠rculo maior, aparecer centrada na coordenada (50, 50). E por fim,

como montar a fun√ß√£o escudo combinando estas duas fun√ß√µes.

Quando o escudo j√° estiver montado o mediador j√° pode sugestionar a reflex√£o em

rela√ß√£o aos eixos coordenados e a origem, de forma intercalada para n√£o sobrecarregar

os discentes ao mesmo tempo. Nessa fase, √© poss√≠vel ensinar o ‚Äúespelhamento‚Äù utilizando

o artif√≠cio da dobradura, isto √©, dobrando a malha em rela√ß√£o a um dos eixos de forma

a sobrepor a constru√ß√£o no outro semiplano da malha, como se houvesse uma ‚Äúrota√ß√£o‚Äù
do objeto em 180o com rela√ß√£o ao eixo deslocado. Ap√≥s essa sobreposi√ß√£o e marca√ß√£o

da nova posi√ß√£o de cada objeto refletido seria f√°cil determinar o tipo de comando para a

simetria observando qual dos eixos foi refletido, isso √©, teve sua coordenada invertida.

De posse dessa informa√ß√£o visual √© poss√≠vel planejar como as coordenadas 1 e ‚àí1

ser√° empregada na fun√ß√£o ùë†ùëêùëéùëôùëí(ùë•, ùë¶) de acordo com a simetria, ou valor invertido do eixo

como podemos perceber em cada reflex√£o da figura 57.

Avalia√ß√£o

Com essa atividade espera-se que os discentes tenham se familiarizados com a

fun√ß√£o ùë†ùëêùëéùëôùëí para obter simetrias e na composi√ß√£o das equipes tenham compreendido

qual o efeito visual de uma reflex√£o muito encontrado em faixas de ambul√¢ncia em cima

do capo do carro, entre outros meios que exploram esse recurso visual.

5.4 Isometria de reflex√£o ou simetria

139

(a) Simetria em rela√ß√£o
ao eixo ùë•

(b) Simetria em rela√ß√£o
ao eixo ùë¶

(c) Simetria em rela√ß√£o a
origem

Figura 57: Applet 10: Simetria em rela√ß√£o ao eixos e a origem

5.4.2 Aprimorando a simetria

Objetivo

Aprimorar o conceito de simetria na constru√ß√£o de um caleidosc√≥pio a partir de

uma pe√ßa de dimens√£o 150 por 150 pixels constru√≠do a partir dos c√≥digos fornecidos pelo

docente com utiliza√ß√£o das TGP.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Simetria , Transla√ß√£o e

Rota√ß√£o.

Subs√≠dio Te√≥rico

A simetria √© uma transforma√ß√£o facilmente encontrada na natureza, por exemplo,

nos flocos de neve, nas estrelas do mar, nos ouri√ßos, nas borboletas, em alguns p√°ssaros,

entre tantos outros meios. Sua ideia remete-se ao equil√≠brio proporcional, ao padr√£o com

regularidade, a harmonia com beleza e a uma ordem na sua perfei√ß√£o.

Dessa forma, como definir a simetria no contexto das formas geom√©tricas planas e

nas formas da natureza? Sabe-se que uma figura geom√©trica plana √© dita sim√©trica se for

poss√≠vel dividi-la por uma reta, de forma que as duas partes obtidas possam se sobrepor

por dobragem. Al√©m disso, seu conceito est√° associado √†s opera√ß√µes de reflex√£o, reflex√£o

deslizante, rota√ß√£o e transla√ß√£o.

Em nossa atividade anterior basicamente utilizamos o conceito de simetria de re-

flex√£o ou axial, obtido quando o objeto √© refletido em rela√ß√£o a um eixo como se fosse um

espelho, e simetria de rota√ß√£o, quando o objeto gira em torno de um ponto. No entanto,

a simetria n√£o se resume apenas no espelhamento ou na rota√ß√£o, a exemplo da simetria

de transla√ß√£o que √© dada em fun√ß√£o do deslizamento do objeto sobre uma reta mantendo

5.4 Isometria de reflex√£o ou simetria

140

o mesmo inalterado com apenas dois elementos caracterizadores, s√£o eles: o comprimento

da transla√ß√£o ou per√≠odo e a repeti√ß√£o da forma. Salienta-se ainda que essa propriedade √©

necess√°ria para compor mosaicos, faixas de ornamentos e est√£o muito presentes nas obras

de Escher.

Outra forma de simetria √© a reflex√£o deslizante que consiste numa opera√ß√£o com-

binada da reflex√£o com a transla√ß√£o paralela ao plano de reflex√£o, ou seja, o objeto √©

refletido no outro semiplano seguido de um deslocamento paralelo ao eixo de simetria.

Com isso, podemos potencializar o ensino dessa transforma√ß√£o geom√©trica construindo

diversas aplica√ß√µes explorando cada um dessas formas de simetria. Contudo, nosso ob-

jetivo √© construir um caleidosc√≥pio a partir do fragmento de uma figura fornecida nos

c√≥digos divulgados pelo docente que ser√° completada com as transforma√ß√µes de simetria

e, em seguida, girada continuamente de acordo com um √¢ngulo ùëé de crescimento constante.

Para a constru√ß√£o dessa atividade precisamos definir o caleidosc√≥pio com o intuito

de compreender as passagens em cada trecho da atividade objetivando o efeito visual que

tal aparelho proporciona. A palavra caleidosc√≥pio origina de tr√™s palavras gregas: kalos

= belo/beleza + eidos = figura/forma + esc√≥pios = vejo, e segundo a revista Univerci√™n-
cia5, o caleidosc√≥pio ‚Äú√© um instrumento √≥tico com pequenos espelhos na extremidade que

refletem, m√∫ltipla e simetricamente, pequenos objetos, como vidros, formando imagens

art√≠sticas muito belas e divertidas‚Äù e ao movimentar o tubo, os pequenos vidros se movem

modificando a imagem dinamicamente mantendo a simetria regida pelo posicionamento

dos espelhos e das leis da reflex√£o na f√≠sica. Sabe-se ainda que existe diversas vers√µes de

caleidosc√≥pio que preserva o princ√≠pio b√°sico regido pela simetria de reflex√£o que faz parte

do intuito dessa atividade.

Nesse tipo de atividade √© poss√≠vel produzir sua pr√≥pria imagem ou utilizar imagens

obtidas na Internet para mostrar a import√¢ncia da simetria de reflex√£o, a exemplo da

borboleta que pode ser obtida a partir da metade de seu corpo, entre outras formas. No

entanto, para inserir uma figura no Processing √© necess√°rio importar-las para o ‚ÄúSketch‚Äù

antes de iniciar a pr√≥pria aplica√ß√£o com a imagem. Esse tipo de atividade ser√° explorado

nas transforma√ß√µes de homotetia com viabilidade para ser explorado nas transforma√ß√µes

sim√©tricas.

Na constru√ß√£o do caleidosc√≥pio vamos inserir um comando para deixar o preenchi-

mento das formas oscilante para dar a impress√£o do olho piscando entre outras formas
constru√≠das. O comando ùëüùëéùëõùëëùëúùëö(‚Äúùë£ùëéùëôùëúùëü‚Ä≤‚Ä≤) sorteia um n√∫mero no intervalo do ‚Äúvalor‚Äù de-

5Revista Univerci√™ncia da UFSCAR com publica√ß√£o em jan/abr de 2002 dispon√≠vel para consulta no

endere√ßo http://www.ufscar.br/ univerci/n_1_a1/assunto_editorial.pdf

5.4 Isometria de reflex√£o ou simetria

141

terminado de forma aleat√≥ria para deixar a anima√ß√£o com efeito de movimento de forma

simplificada.

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù a partir de uma imagem na malha

quadriculada fornecida pelo docente para construir as pe√ßas e o sistema de cores para

confec√ß√£o de um mosaico atrav√©s das simetrias de reflex√£o e reflex√£o deslizante para mon-

tar um caleidosc√≥pio com a rota√ß√£o do mosaico. Compete aos estudantes traduzir as

imagens em c√≥digos para execut√°-los no ‚ÄúApplet‚Äù observando seus dados para posterior-

mente constru√≠rem seu pr√≥prio mosaico.

Material

Malha quadriculada, l√°pis ou caneta e computador com o Processing instalado.

Procedimento

Nessa atividade vamos fornecer um pequeno mosaico, Figura 58, na malha qua-

driculada para servir de base para os alunos buscarem os c√≥digos de cada figura plana

considerando sempre um ponto como origem para visualizar o dom√≠nio dos alunos em

transladar cada origem para formar o mosaico padr√£o al√©m de utilizar a simetria de al-

guns elementos que se repetem em pontos distintos da malha.

Figura 58: Estrutura para o mosaico

Em fun√ß√£o de alguns elementos apresentarem coordenadas com um grau de com-

plexibilidade maior, em especial as formas circulares, vamos determinar suas coordenadas

locais para o aluno especificar apenas suas coordenadas globais na constru√ß√£o. Al√©m

5.4 Isometria de reflex√£o ou simetria

142

disso, todos os pontos est√£o distantes na propor√ß√£o de 10 pixels de um para o outro, os

que n√£o constam nessa distancia encontram-se a 5 pixels para facilitar suas localiza√ß√µes

locais para formar a coordenada global.

Para orientar o docente vamos apresentar a constru√ß√£o do mosaico inteiro com os

c√≥digos seguindo uma orienta√ß√£o que pode coincidir com a dos discentes. Para facilitar

a escolha das cores, vamos divulgar uma listagem de c√≥digos para os alunos preencherem

as figuras planas constante na malha quadriculada, na forma de fun√ß√£o.

Diante disso, vamos iniciar a aplica√ß√£o configurando a tela principal e uma aba

para as fun√ß√µes cores dispon√≠veis.

a) Configura√ß√£o do Applet;

ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù(){

ùë†ùëñùëßùëí(700, 700);

ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

ùë†ùë°ùëüùëúùëòùëíùëä ùëíùëñùëî‚Ñéùë° (1.5);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùë§ùëñùëëùë°‚Ñé/2, ‚Ñéùëíùëñùëî‚Ñéùë°/2);

}

}

b) Constru√ß√£o das fun√ß√µes cores na aba ‚Äúcor‚Äù:

ùë£ùëúùëñùëë ùëùùëüùëéùë°ùëé() {

ùë£ùëúùëñùëë ùëêùëéùë†ùë°ùëéùëõ‚Ñéùëú() {

ùë£ùëúùëñùëë ùëùùëíùëüùë¢() {

ùëì ùëñùëôùëô(192, 192, 192); }

ùëì ùëñùëôùëô(165, 42, 42); }

ùëì ùëñùëôùëô(205, 133, 63); }

ùë£ùëúùëñùëë ùëéùëßùëêùëíùë¢() {

ùë£ùëúùëñùëë ùëêùëéùëüùëöùëíùë†ùëñùëö() {

ùë£ùëúùëñùëë ùëéùëöùëéùëüùëíùëôùëú() {

ùëì ùëñùëôùëô(135, 206, 250); }

ùëì ùëñùëôùëô(220, 20, 60); }

ùëì ùëñùëôùëô(255, 255, 0); }

ùë£ùëúùëñùëë ùëüùëúùë†ùëéùëèùëüùëñùëô() {

ùë£ùëúùëñùëë ùëéùëßùë£ùëñùëú() {

ùë£ùëúùëñùëë ùë£ùëíùëüùëöùëíùëô‚Ñéùëú() {

ùëì ùëñùëôùëô(255, 0, 127); }

ùëì ùëñùëôùëô(138, 43, 226); }

ùëì ùëñùëôùëô(255, 0, 0); }

ùë£ùëúùëñùëë ùë†ùëéùëôùëöùëéùëú() {

ùë£ùëúùëñùëë ùë°ùë¢ùëüùëûùë¢ùëíùë†ùëé() {

ùë£ùëúùëñùëë ùë£ùëíùëüùëêùëôùëéùëüùëú() {

ùëì ùëñùëôùëô(255, 160, 122); }

ùëì ùëñùëôùëô(64, 224, 208); }

ùëì ùëñùëôùëô(135, 206, 250); }

ùë£ùëúùëñùëë ùëúùë¢ùëüùëú() {

ùë£ùëúùëñùëë ùë£ùëíùëüùëëùëí() {

ùë£ùëúùëñùëë ùëíùë†ùëöùëíùëüùëéùëôùëëùëé() {

ùëì ùëñùëôùëô(255, 215, 0); }

ùëì ùëñùëôùëô(0, 255, 127); }

ùëì ùëñùëôùëô(80, 200, 120); }

ùë£ùëúùëñùëë ùëóùëéùëöùëèùëú() {

ùë£ùëúùëñùëë ùëôùëñùëöùëé() {

ùë£ùëúùëñùëë ùëêùëñùëõùëßùëéùëì ùëúùë†ùëêùëú() {

ùëì ùëñùëôùëô(255, 69, 0); }

ùëì ùëñùëôùëô(191, 255, 0); }

ùëì ùëñùëôùëô(105, 105, 105, 200); }

Coordenadas dos elementos considerados complexos para se obter de forma indi-

vidual analisando somente a malha quadriculada.

c) C√≥digos das formas circulares e das linhas do bigode do gato, com suas cores e linhas

animadas com a fun√ß√£o ùëüùëéùëõùëëùëúùëö(256) que atribui valores aleat√≥rios do intervalo de

5.4 Isometria de reflex√£o ou simetria

143

[0, 255] para pigmentar a constru√ß√£o com cores oscilando de entre os tons de preto

a branco:

//Olho do peixe

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 10, 5);

ùë†ùë°ùëüùëúùëòùëí(ùëüùëéùëõùëëùëúùëö(256));

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

ùëôùëñùëõùëí(0, 0, 8, 8);

ùë†ùëêùëéùëôùëí(0, 0, 5, 5);

//Olho do gato

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 5, 5);

//Bigode direito

ùëôùëñùëõùëí(0, 5, 8, 13);

ùëõùëúùëÜùë°ùëüùëúùëòùëí();

Nessa atividade vamos favorecer a criatividade dos discentes na constru√ß√£o dos

c√≥digos das pe√ßas desse mosaico, mantendo as cores que desejarem de acordo com a

tabela de cores que disponibilizaremos para a implementa√ß√£o. No entanto, o mediador

precisar√° de um poss√≠vel resultado para consulta no caso de d√∫vidas que encontra-se no

Ap√™ndice C.

Como nosso objetivo final √© construir o mosaico da Figura 59 para criarmos a ideia

de movimento com a fun√ß√£o de rota√ß√£o e assim dar mobilidade a nosso caleidosc√≥pio, os

discentes v√£o precisar construir uma fun√ß√£o que gerencie todas as pe√ßas de forma √∫nica

para facilitar no ‚Äúespelhamento‚Äù. Nesse ponto, os alunos v√£o precisar combinar as transla-

√ß√µes de forma a encaixar as pe√ßas como consta no modelo da malha quadriculada (Figura

58), isto √©, em uma nova aba chamada ‚Äúmosaico‚Äù vamos construir a fun√ß√£o ùë£ùëúùëñùëë ùëöùëúùë†ùëéùëñùëêùëú()

para recriar a imagem da malha quadriculada no Processing.

Figura 59: Mosaico completo

5.4 Isometria de reflex√£o ou simetria

144

A partir da pr√≥pria malha quadriculada √© poss√≠vel determinar qual a transla√ß√£o

necess√°ria para deslocar cada figura com o intuito de encaixar as pe√ßas e por esse motivo

vamos deixar os c√≥digos no Ap√™ndice C juntamente com os c√≥digos das pe√ßas, sugerimos

que o docente intermediei o in√≠cio dessa fun√ß√£o sugestionando a chamada de algumas

fun√ß√µes da aba ‚Äúpe√ßas‚Äù como segue abaixo, n√£o esque√ßa de mencionar que as fun√ß√µes

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•() e ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•() auxiliam toda essa constru√ß√£o.

d) Princ√≠pio da constru√ß√£o da fun√ß√£o ‚Äúmosaico‚Äù:

ùë£ùëúùëñùëë ùëöùëúùë†ùëéùëñùëêùëú(){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 20);

ùë¶();

ùëì ùëñùëôùëô(189, 143, 143);

ùëùùëíùëõùë°();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí30, 30);

ùëüùëíùëêùë°(0, 0, 150, 150);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, ‚àí20);

ùëì ùëúùëüùëöùëé2();

ùë°ùëüùëíùë£ùëú();

ùëùùëö();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 10);

¬∑ ¬∑ ¬∑ }

Note que no in√≠cio da constru√ß√£o surgiu um ret√¢ngulo com as dimens√µes da malha

quadriculada cuja fun√ß√£o √© preencher os espa√ßos ausentes de figura plana com a mesma

cor para reduzir um pouco o n√∫mero de c√≥digos utilizados no processo. Com a estrutura

do mosaico pronta √© s√≥ ativar a fun√ß√£o ùëöùëúùë†ùëéùëñùëêùëú(); na fun√ß√£o ùë£ùëúùëñùëë ùëëùëüùëéùë§() para visualizar

se todas as figuras planas encontram-se nas suas respectivas posi√ß√µes e se ser√° necess√°rio

algum ajuste no c√≥digo antes de avan√ßarmos no nosso objetivo.

De posse desses ajustes vamos passar para o ‚Äúespelhamento‚Äù do mosaico nos eixos

e na origem para construir nossa pe√ßa principal. Para isso, vamos construir uma √∫ltima

aba, ‚Äútela‚Äù, para controlar a reprodu√ß√£o dos mosaicos sim√©tricos fundamentais para nossa

aplica√ß√£o final. Em fun√ß√£o da atividade anterior, esperamos que os alunos consigam de

forma independente programar essas simetrias combinando as transla√ß√µes com as respec-

tivas simetrias em rela√ß√£o aos eixos. Para orientar-los disponibilizaremos os c√≥digos dessa

simetria juntamente com os c√≥digos anteriores no Ap√™ndice C, e assim, o docente poder√°

auxiliar em qualquer d√∫vida pertinente as passagem com dificuldade.

Nesta aba ‚Äútela‚Äù construa a fun√ß√£o ùë£ùëúùëñùëë ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú() para implementar uma cons-

tru√ß√£o de simetria que funcionar√° como pe√ßa central do nosso mosaico 59. Uma vez com

a fun√ß√£o constru√≠da √© poss√≠vel visualiza-la substituindo a fun√ß√£o ùëöùëúùë†ùëéùëñùëêùëú() pela fun√ß√£o

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú e verificar se completou um quadrado com quatro figuras sim√©tricas entre si.

Para os alunos vislumbrarem nosso produto final que √© um caleidosc√≥pio em mo-

vimento solicite aos mesmos para adicionar o comando ùëüùëúùë°ùëéùë°ùëí(ùëé); no in√≠cio da fun√ß√£o

ùë£ùëúùëñùëë ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú e no final da fun√ß√£o o incremento ùëé = ùëé + 0.001; Salienta-se que o

5.4 Isometria de reflex√£o ou simetria

145

tipo de vari√°vel tem que ser ùëì ùëôùëúùëéùë° para n√∫meros reais e programado antes da fun√ß√£o

ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù() com a inscri√ß√£o ùëì ùëôùëúùëéùë° ùëé = 0.

Finalmente chegamos na √∫ltima parte da programa√ß√£o e antes de iniciar-la solicite

aos discentes para ocultarem o comando ùëüùëúùë°ùëéùë°ùëí(ùëé) para deixar a constru√ß√£o est√°tica e

assim analisar os efeitos dos passos seguintes.

Nessa parte, vamos refletir a fun√ß√£o ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú() no entorno da parte central.

Salienta-se que poder√≠amos obter o mesmo efeito refletindo a fun√ß√£o ùëöùëúùë†ùëéùëñùëêùëú(), no en-

tanto, ser√° necess√°rio muito mais c√≥digos para alcan√ßar o mesmo objetivo e utilizar a

fun√ß√£o ùë†ùëêùëéùëôùëí para refletir a fun√ß√£o ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú em combina√ß√£o com a transla√ß√£o n√£o cau-

sar√° nenhum efeito visual diferente daquele em que a fun√ß√£o ùë†ùëêùëéùëôùëí n√£o for embutido. O

motivo para tal aus√™ncia de altera√ß√£o de imagem encontra-se no fato dessa ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú

funcionar como o efeito visual das asas das borboletas, isto √©, essa fun√ß√£o foi obtida de

uma reflex√£o e a reflex√£o da reflex√£o √© a pr√≥pria figura deslocada para uma nova posi√ß√£o.

Por este motivo para economizar no n√∫mero de c√≥digos na constru√ß√£o do nosso mo-

saico, como aparece na Figura 59, vamos implementar a fun√ß√£o ùë£ùëúùëñùëë ùëëùëüùëéùë§ com a fun√ß√£o

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú deslocando sua origem para as origens externas da parte central considerando

sempre um distanciamento de 300 pixels entre cada nova origem em fun√ß√£o da ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú

possuir o dobro do tamanho da Figura 58. Apesar do n√∫mero de deslocamentos para com-

pletar o mosaico seja relativamente pequeno (8 transla√ß√µes) vamos abordar seus c√≥digos

no Ap√™ndice C por apresentar em m√©dia 45 linhas de comandos. Entretanto, o docente

poder√° intermediar o in√≠cio da constru√ß√£o estimulando a descoberta de cada nova origem

para os deslocamentos considerando a origem inicial no centro da tela.

Para proporcionar o movimento do nosso caleidosc√≥pio vamos implementar com

a fun√ß√£o ùëüùëúùë°ùëéùë°ùëí(ùëè) logo ap√≥s a fun√ß√£o ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí dentro da aplica√ß√£o ùëëùëüùëéùë§ e no final da

mesma seu incremento ùëè = ùëè + 0.004. N√£o esque√ßam de criar essa vari√°vel no campo dos

n√∫meros reais. Para ilustrar o resultado final de nosso caleidosc√≥pio observe o jogo de

imagens da Figura 60.

Avalia√ß√£o

A produ√ß√£o de um caleidosc√≥pio proporciona um jogo de imagens em movimento

com varia√ß√µes que permitem uma explora√ß√£o visual diferente a cada novo jogo de movi-

mento ou visualizar regularidades quando a imagem iniciar um movimento de repeti√ß√£o

na sequ√™ncia de imagens. Al√©m disso, esperamos ainda que os alunos consigam manipular

os dados para obter o produto final e assim fazer suas conjecturas quanto ao n√≠vel de

aprendizagem da linguagem at√© o presente momento.

5.5 Transforma√ß√£o de homotetia

146

(a) Rota√ß√£o hor√°ria da tela

(b) Rota√ß√£o hor√°ria da tela e do mosaico

Figura 60: Applet 11: Caleidosc√≥pio do mosaico interativo

A explora√ß√£o da linguagem de forma quase independente por parte dos alunos

viabiliza um desenvolvimento cognitivo favor√°vel para o desenvolvimento de suas pr√≥prias

aplica√ß√µes caracterizando a figura do professor como um mediador para impulsionar nos

entraves e formalizar suas pr√≥prias conquistas.

5.5 Transforma√ß√£o de homotetia

A homotetia √© uma transforma√ß√£o geom√©trica que preserva a forma e as amplitudes

dos segmentos, ou seja, √© uma transforma√ß√£o que modifica apenas de forma proporcional

as medidas de seus segmentos. Em fun√ß√£o disso, podemos dizer que a homotetia √© uma
transforma√ß√£o de amplia√ß√£o ou redu√ß√£o da imagem segundo uma constante ùëò ‚àà R, tal

que |ùëò| > 1 ou 0 < |ùëò| < 1. Com isso, esperamos que os alunos caracterizem os objetos

segundo uma rela√ß√£o de semelhan√ßa por uma homotetia preestabelecida no princ√≠pio da

constru√ß√£o.

Para fundamentar o processo de aprendizagem da homotetia, vamos combinar-la

com outras transforma√ß√µes em constru√ß√µes b√°sicas e avan√ßadas via programa√ß√£o diversi-

ficando com material concreto para elaborar os projetos na companhia dos discentes.

5.5 Transforma√ß√£o de homotetia

147

5.5.1 Conhecendo a homotetia

Objetivo

Construir o conceito de homotetia, ou seja, o conceito de amplia√ß√£o e redu√ß√£o de

figuras bidimensionais, e fazer com que os alunos notem a homotetia como uma rela√ß√£o

de semelhan√ßa entre as figuras planas e suas potencialidades na programa√ß√£o.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Homotetia e Transla√ß√£o.

Subs√≠dio Te√≥rico

A homotetia √© uma transforma√ß√£o que preserva as caracter√≠sticas principais, como

a forma e os √¢ngulos, alterando apenas o tamanho da figura e consequentemente sua √°rea

de forma proporcional. Essa rela√ß√£o √© facilmente explicada atrav√©s da deriva√ß√£o grega da

palavra homotetia, onde hom√≥s = igual e thet√≥s = colocado, isto √©, as figuras homot√©ticas

s√£o colocadas a uma dist√¢ncia igual a ‚Äúalgo‚Äù, geralmente um ponto. Umas das m√°quinas

que integram esse princ√≠pio em seu funcionamento s√£o as copiadoras que fazem amplia√ß√µes

ou redu√ß√µes.

Diferentemente das isometrias, as homotetias positivas n√£o necessitam de uma

transla√ß√£o da origem para serem executadas. No entanto, no caso das homotetias inversas,

negativas, a transla√ß√£o √© imprescind√≠vel para visualizarmos na tela da aplica√ß√£o.

Para implementar a primeira atividade de homotetia, vamos importar uma figura

extra√≠da da internet e construir diversas imagens homot√©ticas a essa. A incorpora√ß√£o da

imagem √© feita atrav√©s das seguintes linhas de comando.

ùëÉ ùêºùëöùëéùëîùëí ùë°; //Vari√°vel para chamada da imagem.

ùë° = ùëôùëúùëéùëëùêºùëöùëéùëîùëí(‚Äúùëõùëúùëöùëíùëëùëéùëñùëöùëéùëîùëíùëö.ùëíùë•ùë°ùëíùëõùë†ùëú‚Äù); //Arquivo com a imagem em .ùëóùëùùëî e .ùëùùëõùëî.

ùëñùëöùëéùëîùëí(ùë°, ùë•, ùë¶); //Chamada da imagem na coordenada (ùë•, ùë¶).

No entanto, √© necess√°rio adicionar esta imagem no ficheiro do ‚Äúsketch‚Äù, mais pre-

cisamente numa pasta chamada ‚Äúdata‚Äù onde consta o arquivo salvo. Para fazer isso,

inicialmente com um arquivo j√° salvo √© s√≥ abrir o menu ‚Äúsketch‚Äù e selecionar a op√ß√£o

‚Äúadicionar ficheiro‚Äù. Quando uma nova janela se abrir √© s√≥ procurar a pasta onde dei-

xou a imagem a ser incorporada no aplicativo e selecionar para adiciona-la e assim ser

reconhecido pelo programa ao executar as linhas de comando anteriores.

Com as ferramentas necess√°rias √© s√≥ iniciar a implementa√ß√£o e produzir uma tela

5.5 Transforma√ß√£o de homotetia

148

rica de imagens em diversas propor√ß√µes para produzir obras de artes visuais utilizando

somente as transforma√ß√µes de homotetia e transla√ß√£o.

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù a partir da imagem fornecida em ar-

quivo pelo docente mediador para montagem da tela com figuras homot√©ticas; Explora√ß√£o

do c√≥digo de homotetia com os estudantes agrupados em duplas ou trio para culminar

com a constru√ß√£o do Applet e seus efeitos gr√°ficos em concord√¢ncia com a teoria da

transforma√ß√£o para ampliar as possibilidades das constru√ß√µes e dos aplicativos.

Material

L√°pis ou caneta e computador com o Processing instalado.

Procedimento

Nessa atividade vamos construir um jogo de imagens dos Minions, mais especifi-

camente, dos Minios Dave e Stuart conforme mostra a Figura 61 em diversas escalas de

proporcionalidade. Para facilitar o preenchimento da tela de 850 por 650 pixels vamos

utilizar uma dilata√ß√£o de 50% no Minios Dave seguida de redu√ß√µes de 50% ou mais para

dar a impress√£o de encolhimento. Ao mesmo tempo que incorporamos o Minios Stuart na

aplica√ß√£o utilizando uma homotetia de redu√ß√£o invertida em diversas posi√ß√µes conforme

mostra a Figura 62.

(a) Minion Dave

(b) Minion Stuart

Figura 61: Minions do Filme Meu Malvado Favorito

Entretanto, para alcan√ßar o objetivo dessa atividade inicialmente devemos carregar

as configura√ß√µes b√°sicas do programa para importar as imagens dos Minions supracitados

diretamente para o applet, conforme consta nos comandos:

a) Configura√ß√£o do Applet para carregamento de imagens;

5.5 Transforma√ß√£o de homotetia

149

//Vari√°vel das imagens

ùëò

=

ùëôùëúùëéùëëùêºùëöùëéùëîùëí(‚ÄùùëÄ ùëñùëõùëñùëúùëõùê∑ùëéùë£ùëí.ùëóùëùùëî‚Äù);

ùëÉ ùêºùëöùëéùëîùëíùëò, ùë°;

ùë†ùëñùëßùëí(850, 650);

//Imagem do Minion Stuart

ùë° = ùëôùëúùëéùëëùêºùëöùëéùëîùëí(‚ÄùùëÄ ùëñùëõùëñùëúùëõùëÜùë°ùë¢ùëéùëüùë°.ùëóùëùùëî‚Äù);

//Imagem do Minion Dave

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

Para o applet reconhecer as figuras dos Minions devemos importar estas imagens

para o seu ‚Äúsketch‚Äù, mas, antes devemos salvar a aplica√ß√£o com o nome: Applet 12

nome da dupla ou trio. Com o arquivo salvo √© s√≥ localizar a aba ‚ÄúAdicionar Ficheiro‚Äù

localizada na barra de ferramentas sketch e na nova janela √© s√≥ buscar onde o professor

mediador salvou o arquivo dos Minions para mandar abrir, importar, diretamente no

nosso applet.

Com o arquivo anexado em nossa aplica√ß√£o √© s√≥ lan√ßar os c√≥digos dispondo cada

um dos personagens na tela segundo uma escala de medida determinada no pr√≥prio c√≥digo.

b) Posicionamento do Minion Dave com amplia√ß√£o de 50% e redu√ß√£o de mesma pro-

por√ß√£o, al√©m de outras redu√ß√µes desse personagem;

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(400, 0);//Posi√ß√£o (400, 0)

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(385, 0); //Posi√ß√£o (385, 0)

ùë†ùëêùëéùëôùëí(1.5); //Dave ampliado 50%

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëñùëöùëéùëîùëí(ùëò, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(0.35); //Dave em redu√ß√£o 65%

ùëñùëöùëéùëîùëí(ùëò, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(105, 0); //Posi√ß√£o (105, 0)

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëñùëöùëéùëîùëí(ùëò, 0, 0); //Dave tamanho normal

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 200); //Posi√ß√£o (395, 200)

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(0.27); //Dave em redu√ß√£o 75%

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•(); //Posi√ß√£o (0, 0)

ùë†ùëêùëéùëôùëí(0.5); //Dave reduzido 50%

ùëñùëöùëéùëîùëí(ùëò, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëñùëöùëéùëîùëí(ùëò, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

c) Disposi√ß√£o do Minion Stuart em redu√ß√£o invertida a partir de 60% e do Minion

Dave em redu√ß√£o invertida de 75%;

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(‚àí0.3); //Stuart em redu√ß√£o 70%

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(115, 315); //Posi√ß√£o (115, 315)

ùëñùëöùëéùëîùëí(ùë°, 0, 0);

5.5 Transforma√ß√£o de homotetia

150

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëñùëöùëéùëîùëí(ùë°, 0, 0); ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(195, 525); //Posi√ß√£o (195, 525)

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(70, ‚àí5); //Posi√ß√£o (220, 645)

ùë†ùëêùëéùëôùëí(‚àí0.5); //Stuart em redu√ß√£o 50%

ùë†ùëêùëéùëôùëí(‚àí0.2); //Stuart em redu√ß√£o 80%

ùëñùëöùëéùëîùëí(ùë°, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëñùëöùëéùëîùëí(ùë°, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(415, 635); //Posi√ß√£o (415, 635)

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(330, 0); //Posi√ß√£o (480, 650)

ùë†ùëêùëéùëôùëí(‚àí0.6); //Stuart em redu√ß√£o 40%

ùë†ùëêùëéùëôùëí(‚àí0.3); //Stuart em redu√ß√£o 70%

ùëñùëöùëéùëîùëí(ùë°, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëñùëöùëéùëîùëí(ùë°, 0, 0);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(150, 650); //Posi√ß√£o (150, 650)

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(345, ‚àí120); //Posi√ß√£o (495, 530)

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(‚àí0.25); //Dave em redu√ß√£o 75%

ùë†ùëêùëéùëôùëí(‚àí0.33); //Stuart em redu√ß√£o 67%

ùëñùëöùëéùëîùëí(ùëò, 0, 0);

Figura 62: Applet 12: Exerc√≠to de 2 Minions

A figura do professor mediador nessa atividade visa explorar o recurso da homo-

tetia, no entanto, os alunos podem ficar livres para executar a atividade e produzir telas

distintas uma da outra. Nesse caso, o mediador poder√° intervir para as constru√ß√µes n√£o

se sobreporem ao mesmo tempo estabelecer novos desafios com o intuito de preencher ao

m√°ximo os espa√ßos vazios, sugestionando inclusive a utiliza√ß√£o de rota√ß√£o de eixos para

aumentar o n√∫mero de Minions nos pontos inexistentes.

5.5 Transforma√ß√£o de homotetia

151

Avalia√ß√£o

Ao concluir o processo de constru√ß√£o da tela repleta de Minions, espera-se que

os alunos notem como esta transforma√ß√£o geom√©trica contribui para a redu√ß√£o de c√≥di-

gos, principalmente, quando desejamos construir a mesma imagem em diversos escalas.

Al√©m disso, a atividade proporciona uma nova habilidade que inclui a inclus√£o de figuras

extra√≠das de qualquer meio digital nos formatos jpeg e png.

5.5.2 Aprimorando a homotetia

Objetivo

Aprimorar o dom√≠nio da transforma√ß√£o de homotetia no processo de constru√ß√£o

do Tri√¢ngulo de Sierpinski e automatizar tal constru√ß√£o com a implementa√ß√£o do c√≥digo

preservando o princ√≠pio de implementa√ß√£o do mesmo.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Homotetia.

Subs√≠dio Te√≥rico

O matem√°tico polon√™s, Waclav Sierpinski (1882-1969), descobriu um padr√£o re-

cursivo na divis√£o de um tri√¢ngulo equil√°tero em quatro tri√¢ngulos semelhantes, onde

um destes encontra-se invertido em rela√ß√£o ao original e √© retirado do tri√¢ngulo inicial

sobrando apenas os outros tr√™s. A recursividade da constru√ß√£o esta no fato de repetir o

mesmo procedimento em cada um dos tr√™s novos tri√¢ngulos com a orienta√ß√£o original de

forma sucessiva.

Esse tri√¢ngulo intitulado de Tri√¢ngulo de Sierpinski (ver Figura 63) √© considerado

uma das formas elementares da geometria fractal por apresentar algumas propriedades

como apresenta Santos, Silva e Rossy [41], tais como: possuir tantos pontos como o

conjunto dos n√∫meros reais; possuir √°rea igual a zero; ser auto-semelhante, ou seja, as

partes das figuras s√£o c√≥pias reduzidas de toda a figura; e n√£o perder sua defini√ß√£o inicial

√† medida que √© ampliado.

No entanto, antes de visualizarmos como proceder para a constru√ß√£o desse fractal,

faz-se necess√°rio definir o que √© um fractal que teve sua no√ß√£o inicial estabelecida pelo

matem√°tico franc√™s, Benoit Mandelbrot, e para defini-lo utilizamos as palavras de Sallum

[42, p.1]:

Um fractal √© uma figura que pode ser quebrada em pequenos peda√ßos,

5.5 Transforma√ß√£o de homotetia

152

sendo cada um desses peda√ßos uma reprodu√ß√£o do todo. N√£o podemos
ver um fractal porque √© uma figura limite, mas as etapas de sua constru-
√ß√£o podem dar uma ideia da figura toda. Seu nome se deve ao fato de
que a dimens√£o de um fractal n√£o √© um n√∫mero inteiro.

Figura 63: Tri√¢ngulo de Sierpinski

Com base na defini√ß√£o podemos apresentar a no√ß√£o de como √© feito o Tri√¢ngulo de

Sierpinski e uma das maneiras de se obter esse tri√¢ngulo √© atrav√©s do seguinte algoritmo

divulgada por Santos, Silva e Rossy [41, p.4]:

1. Comece com um tri√¢ngulo equil√°tero em um plano. O tri√¢ngulo de Sierpinski can√¥-

nico utilizava um tri√¢ngulo equil√°tero com a base paralela ao eixo horizontal, mas

qualquer tri√¢ngulo pode ser usado;

2. Encolha o tri√¢ngulo pela metade (cada lado deve ter metade do tamanho original),

fa√ßa tr√™s c√≥pias e posicione cada tri√¢ngulo de maneira que encoste nos outros dois

em um canto;

3. Repita o passo 2 para cada figura obtida, indefinidamente (ver a partir da terceira

figura);

Pereira [43, p. 38] tamb√©m apresenta em sua disserta√ß√£o sobre Fractais Circulares

como se obter esse tri√¢ngulo e nas palavras do pr√≥prio autor:

Para a constru√ß√£o do tri√¢ngulo de Sierpinski constru√≠mos um tri√¢ngulo
equil√°tero e inscrevemos outro tri√¢ngulo com v√©rtices no ponto m√©dio
de cada um de seus lados. Retirando-se esse tri√¢ngulo, temos 3 novos
tri√¢ngulos de mesmo tamanho. Em cada novo tri√¢ngulo inscreve-se ou-
tro tri√¢ngulo com v√©rtice no ponto m√©dio de cada uma de seus lados.
Retirando-se o tri√¢ngulo inscrito, temos 9 novos tri√¢ngulos de emsmo ta-
manho. Repetindo se esse processo indefinidamente nos novos tri√¢ngulos
formados obter-se-√° o fractal denominado Tri√¢ngulo de Sierpinski, cuja
√°rea cada vez se torna menor.

5.5 Transforma√ß√£o de homotetia

153

O fractal propriamente dito s√≥ √© obtido ao repetir o algoritmo infinitas vezes, no

entanto, √† medida que o n√∫mero de intera√ß√µes aumenta, a imagem obtida tende a se tornar

cada vez mais parecida com o fractal de Sierpinski.

Para implementar esse fractal de forma automatizada vamos construir uma nova

fun√ß√£o ùë£ùëúùëñùëë com controle das coordenadas do tri√¢ngulo equil√°tero para obter sempre

novos tri√¢ngulos pela metade do anterior e assim obtermos todo o fractal do Tri√¢ngulo de

Sierpinski.

Metodologia

Aula expositiva com constru√ß√£o do Tri√¢ngulo de Sierpinski na malha quadriculada

para obter um fragmento do fractal e construir no ‚ÄúApplet‚Äù. Ap√≥s a constru√ß√£o inicial,

buscar automatizar a constru√ß√£o de todo o fractal com o m√≠nimo de c√≥digos no processo.

Material

L√°pis, Caneta, Compasso, Malha quadriculada e Computador com o Processing

instalado.

Procedimento

Para construir a no√ß√£o do Tri√¢ngulo de Sierpinski depois de fazer o molde na malha

quadriculada utilizaremos a redu√ß√£o de escala combinada com uma simetria em rela√ß√£o

ao eixo dos ùë¶ e a transla√ß√£o para posicionar os tri√¢ngulos em suas devidas coordenadas.
Ao final apresentaremos o c√≥digo obtido na p√°gina do OpenProcessing6 para constru√ß√£o

do fractal do Tri√¢ngulo de Sierpinski.

Vamos come√ßar preparando o applet para o lan√ßamento dos c√≥digos.

a) Abra um arquivo e salve como: Applet 13 nome da dupla ou trio.

b) Configura√ß√£o inicial para o tri√¢ngulo equil√°tero.

ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù(){

ùë†ùëñùëßùëí(350, 300);

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

}

ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 290);

//Posi√ß√£o do tri√¢ngulo inicial

ùëöùëúùëôùëëùëí(); }

A fun√ß√£o ‚Äúùëöùëúùëôùëëùëí()‚Äù no referido c√≥digo acima servir√° de guia para constru√ß√£o mais

imediata das miniaturas considerando o primeiro passo da aplica√ß√£o j√° satisfeita (Reduzir

6Dispon√≠vel para consulta no endere√ßo http://www.openprocessing.org/sketch/17026.

5.5 Transforma√ß√£o de homotetia

154

o tri√¢ngulo equil√°tero a sua metade e distribuir tr√™s c√≥pias id√™nticas dessa redu√ß√£o nos

cantos do tri√¢ngulo original). Para construir essa fun√ß√£o ‚Äúùëöùëúùëôùëëùëí()‚Äù basta aplicarmos os

seguintes c√≥digos para produzir a Figura 64.

c) Implanta√ß√£o do c√≥digo da fun√ß√£o ‚Äúùëöùëúùëôùëëùëí()‚Äù.

ùë£ùëúùëñùëë ùëöùëúùëôùëëùëí(){

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(0.5);

ùë°ùëüùëñùëéùëõùëîùë¢ùëôùëú();

ùëì ùëñùëôùëô(255, 200, 0); //Cor amarela

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëñùëéùëõùëîùë¢ùëôùëú(); //Tri√¢ngulo Inicial

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(75, ‚àí130); //Tri√¢ngulo superior

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(0.5);

ùë°ùëüùëñùëéùëõùëîùë¢ùëôùëú();

ùë†ùëêùëéùëôùëí(0.5); //Redu√ß√£o 50%

ùëüùëíùë†ùëíùë°ùëÄ ùëéùë°ùëüùëñùë•(); //Limpa as Transforma√ß√µes

ùëì ùëñùëôùëô(0, 200, 255); //Cor azul

}

ùë°ùëüùëñùëéùëõùëîùë¢ùëôùëú(); //Tri√¢ngulo direito

ùë£ùëúùëñùëë ùë°ùëüùëñùëéùëõùëîùë¢ùëôùëú(){ //Tri√¢ngulo inicial

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(1, ‚àí1);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 300, 0, 150, 150 * ùë†ùëûùëüùë°(3));

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(150, 0); //Tri√¢ngulo esquerdo

}

O resultado dessa codifica√ß√£o servir√° para agilizar o processo de constru√ß√£o do

Tri√¢ngulo de Sierpinski na tentativa de automatizar todo o processo. A pr√≥xima etapa √©
reproduzir esse ‚Äúmolde‚Äù de forma reduzida seguindo a propor√ß√£o de 50%
2ùëõ‚àí1 , onde ùëõ representa
o n√∫mero de redu√ß√µes da figura inicial distribu√≠das nos tr√™s cantos onde aparece o tri√¢ngulo

azul da Figura 64.

(a) Tri√¢ngulo equil√°tero

(b) Molde Sierpinski

Figura 64: Molde do Tri√¢ngulo de Sierpinski

O pr√≥ximo passo √© replicar esse molde para construir as demais partes do Tri√¢ngulo

de Sierpinski aplicando os devidos deslocamentos com sua respectiva redu√ß√£o conforme

podemos notar nos pr√≥ximos c√≥digos at√© resultar na Figura 65.

5.5 Transforma√ß√£o de homotetia

155

(a) Montagem do Tri√¢ngulo

(b) Tri√¢ngulo em constru√ß√£o

Figura 65: Applet 13: Constru√ß√£o do Tri√¢ngulo de Sierpinski

d) C√≥digos para amplia√ß√£o da quantidade de moldes do Tri√¢ngulo de Sierpinski inseri-

dos na fun√ß√£o ùë£ùëúùëñùëëùëëùëüùëéùë§():

ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

ùëöùëúùëôùëëùëí();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùëë, 290);

ùë†ùëêùëéùëôùëí(0.25/ùëê);

1 ùëì ùëúùëü(ùëñùëõùë° ùëó = 30; ùëó <= 300; ùëó = ùëó + 150){

ùëöùëúùëôùëëùëí(); } }

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùëó, 290);

ùë†ùëêùëéùëôùëí(0.5/ùëñ);

ùëöùëúùëôùëëùëí();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùëó, 290);

ùë†ùëêùëéùëôùëí(0.25/ùëñ);

ùëöùëúùëôùëëùëí(); } }

4 ùëì ùëúùëü(ùëñùëõùë° ùëí = 1; ùëí < 5; ùëí = 2 * ùëí){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(105, 160);

ùë†ùëêùëéùëôùëí(0.5/ùëí);

ùëöùëúùëôùëëùëí();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(105, 160);

ùë†ùëêùëéùëôùëí(0.25/ùëí);

2 ùëì ùëúùëü(ùëñùëõùë° ùëé = 1; ùëé < 5; ùëé = 2 * ùëé){

ùëöùëúùëôùëëùëí();

ùëì ùëúùëü(ùëñùëõùë° ùëè = 30; ùëè <= 300; ùëè = ùëè + 150){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(142, 95);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(75 + ùëè, 290);

ùë†ùëêùëéùëôùëí(0.25/ùëé);

ùëöùëúùëôùëëùëí();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùëè, 290);

ùë†ùëêùëéùëôùëí(0.25/ùëé);

ùëöùëúùëôùëëùëí(); } }

ùë†ùëêùëéùëôùëí(0.25/ùëí);

ùëöùëúùëôùëëùëí(); } }

5 ùëì ùëúùëü(ùëñùëõùë° ùëî = 1; ùëî < 5; ùëî = 2 * ùëî){

ùëì ùëúùëü(ùëñùëõùë° ‚Ñé = 30; ‚Ñé < 100; ‚Ñé = ‚Ñé + 150){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(150 + ‚Ñé, 160);

ùë†ùëêùëéùëôùëí(0.25/ùëî);

3 ùëì ùëúùëü(ùëñùëõùë° ùëê = 1; ùëê < 5; ùëê = 2 * ùëê){

ùëöùëúùëôùëëùëí();

ùëì ùëúùëü(ùëñùëõùë° ùëë = 30; ùëë <= 300; ùëë = ùëë + 150){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚Ñé + 75, 160);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(75/2 + ùëë, 224);

ùë†ùëêùëéùëôùëí(0.25/ùëê);

ùëöùëúùëôùëëùëí();

ùë†ùëêùëéùëôùëí(0.25/ùëî);

ùëöùëúùëôùëëùëí(); } }

}

Notem que mesmo utilizando express√µes no processo de constru√ß√£o do Tri√¢ngulo

de Sierpinski, n√£o conseguimos construir toda a imagem desse tri√¢ngulo. Para isso, preci-

5.5 Transforma√ß√£o de homotetia

156

sar√≠amos melhorar nossa express√£o ou continuar o processo de constru√ß√£o j√° iniciado, isto

√©, sintetizamos essa express√£o para construir o m√°ximo de moldes ou condicionaremos de

forma ilimitada a extens√£o do c√≥digo j√° utilizado.

Em fun√ß√£o disso, vamos construir um outro aplicativo para esse Tri√¢ngulo uti-

lizando a linguagem retirada do site da OpenProcessing.org como foi mencionado no

procedimento da atividade.

a) Abra um novo arquivo e salve-o como Applet 13.1 nome da dupla ou trio.

b) Adicione os seguintes c√≥digos para visualizar o resultado do Tri√¢ngulo de Sierpinski

de forma integral.

ùë£ùëúùëñùëë ùë†ùëíùë°ùë¢ùëù(){

ùë†ùëñùëßùëí(800, 800);

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

ùë†ùëöùëúùëúùë°‚Ñé();

ùëõùëúùëÜùë°ùëüùëúùëòùëí();

ùëêùëúùëôùëúùëüùëÄ ùëúùëëùëí(ùëÖùê∫ùêµ, 5, 100, 100);

ùë°ùëüùëñùëéùëõùëîùëôùëíùëÜùëñùëíùëü(0, 700, 400, 0, 800, 700, 7);

}

//Fun√ß√£o do Tri√¢ngulo de Sierpinski.

ùë£ùëúùëñùëë ùë°ùëüùëñùëéùëõùëîùëôùëíùëÜùëñùëíùëü(ùëì ùëôùëúùëéùë° ùë•1, ùëì ùëôùëúùëéùë° ùë¶1, ùëì ùëôùëúùëéùë° ùë•2, ùëì ùëôùëúùëéùë° ùë¶2, ùëì ùëôùëúùëéùë° ùë•3, ùëì ùëôùëúùëéùë° ùë¶3, ùëñùëõùë° ùëõ){

//‚Äòn‚Äô √© o n√∫mero da intera√ß√£o.

ùëì ùëôùëúùëéùë° ‚Ñé3 = (ùë•3 + ùë•1)/2;

ùëñùëì (ùëõ > 0){

ùëì ùëñùëôùëô(0, 128/ùëõ, 128);

ùëì ùëôùëúùëéùë° ùë§3 = (ùë¶3 + ùë¶1)/2;

//Trace os tri√¢ngulos com as novas coorde-

ùë°ùëüùëñùëéùëõùëîùëôùëí(ùë•1, ùë¶1, ùë•2, ùë¶2, ùë•3, ùë¶3);

nadas.

//Calcule os pontos m√©dios de todos seg-

ùë°ùëüùëñùëéùëõùëîùëôùëíùëÜùëñùëíùëü(ùë•1, ùë¶1, ‚Ñé1, ùë§1, ‚Ñé3, ùë§3, ùëõ ‚àí 1);

mentos.

ùëì ùëôùëúùëéùë° ‚Ñé1 = (ùë•1 + ùë•2)/2;

ùëì ùëôùëúùëéùë° ùë§1 = (ùë¶1 + ùë¶2)/2;

ùëì ùëôùëúùëéùë° ‚Ñé2 = (ùë•2 + ùë•3)/2;

ùëì ùëôùëúùëéùë° ùë§2 = (ùë¶2 + ùë¶3)/2;

ùë°ùëüùëñùëéùëõùëîùëôùëíùëÜùëñùëíùëü(‚Ñé1, ùë§1, ùë•2, ùë¶2, ‚Ñé2, ùë§2, ùëõ ‚àí 1);

ùë°ùëüùëñùëéùëõùëîùëôùëíùëÜùëñùëíùëü(‚Ñé3, ùë§3, ‚Ñé2, ùë§2, ùë•3, ùë¶3, ùëõ ‚àí 1);

}

}

Como podemos constatar nos c√≥digos para o Tri√¢ngulo de Sierpinski, o algoritmo

de programa√ß√£o utilizado est√£o bem reduzidos e nessa aplica√ß√£o n√£o foi utilizado nenhuma

aplica√ß√£o direta das transforma√ß√µes geom√©tricas. Por este motivo, n√£o iniciamos a ati-

vidade aplicando tais c√≥digos que resultam no Tri√¢ngulo completo de Sierpinski como

mostra a Figura 66.

5.6 Transforma√ß√£o de dilata√ß√£o/contra√ß√£o irregular

157

Figura 66: Applet 13.1: Tri√¢ngulo de Sierpinski no Processing

Avalia√ß√£o

Avaliar o dom√≠nio do conceito de homotetia e manuseio de express√µes para otimi-

zar o processo da constru√ß√£o de figuras entre outros itens. Com essa atividade ainda √©

poss√≠vel avaliar o fluxograma da constru√ß√£o para otimizar o processo ao mesmo tempo

que potencializa a descoberta dos fractais.

5.6 Transforma√ß√£o de dilata√ß√£o/contra√ß√£o irregular

Quando ampliamos ou encolhemos uma figura em ambos sentidos ao mesmo tempo

(vertical e horizontal) estamos empregando o conceito de homotetia de fator ùëò. No entanto

√© poss√≠vel dilatar ou comprimir a mesma figura em apenas um dos sentidos ou com fatores

distintos, nesses casos dizemos que a figura transformada sofreu uma dilata√ß√£o/contra√ß√£o

irregular.

O processo de dilata√ß√£o ou contra√ß√£o de figuras quando aplicado por raz√µes distin-

tas para o sentido horizontal e vertical n√£o s√£o classificadas como homotetias [6], existem

ainda autores [37] que denominam essa transforma√ß√£o de anam√≥rfica.

Para apresentar estes conceitos vamos construir um ambiente utilizando partes dos

elementos de outros Applet‚Äôs com o intuito de dilata-los e contra√≠-los.

5.6 Transforma√ß√£o de dilata√ß√£o/contra√ß√£o irregular

158

Objetivo

Construir o conceito de dilata√ß√£o/contra√ß√£o irregular e as potencialidades dessa

transforma√ß√£o para gera√ß√£o de movimentos e anima√ß√µes gr√°ficas.

Conte√∫do Program√°tico

Linguagem de Programa√ß√£o; Transforma√ß√£o Geom√©trica - Dilata√ß√£o/Contra√ß√£o

irregular, Transla√ß√£o.

Subs√≠dio Te√≥rico

Dilatar ou contrair uma figura quando realizado em ambos os sentidos gera uma

imagem proporcional a original, no entanto, a dilata√ß√£o/contra√ß√£o pode ser empregada

em rela√ß√£o a um dos eixos ou em ambos com fatores distintos. As imagens de dilata√ß√£o

no sentido vertical esticam a figura dando uma impress√£o de emagrecimento da mesma,

j√° no sentido horizontal proporcionam uma sensa√ß√£o de alargamento da figura. No caso

da contra√ß√£o, o efeito encurta na horizontal e achata na vertical.

Metodologia

Aula expositiva com constru√ß√£o do ‚ÄúApplet‚Äù a partir dos c√≥digos de outras aplica-

√ß√µes (Applet‚Äôs 2, 5 e 12) para proporcionar a sensa√ß√£o de dilata√ß√£o e contra√ß√£o de forma

desproporcional nos sentidos horizontais e verticais.

Material

computador com o Processing instalado.

Procedimento

A atividade prop√µe reaproveitar os c√≥digos de fun√ß√µes constru√≠das em outros ap-

plet‚Äôs para otimizar a atividade e proporcionar uma an√°lise dos efeitos de dilata√ß√£o e

contra√ß√£o desproporcional. O efeito gerado nessa atividade pode ser comparado com um

labirinto de espelhos onde temos variados tipos de lentes esf√©ricas.

Ao finalizar o lan√ßamento dos dados, o resultado ser√° a Figura 67 composta por

diversas dilata√ß√µes e contra√ß√µes desproporcionais constru√≠das com os seguintes c√≥digos:

Inicialmente capturamos os c√≥digos do boneco geom√©trico (Applet 2) e constru√≠mos

uma aba ‚Äúboneco geometrico‚Äù para a fun√ß√£o ùë£ùëúùëñùëë ùëèùëúùëõùëíùëêùëú() na aplica√ß√£o do novo Applet

14.

a) Configura√ß√£o do Applet para carregamento de imagens;

5.6 Transforma√ß√£o de dilata√ß√£o/contra√ß√£o irregular

159

Figura 67: Applet 14: Dilata√ß√£o e contra√ß√£o irregular

//Vari√°vel das imagens

ùëò

=

ùëôùëúùëéùëëùêºùëöùëéùëîùëí(‚ÄùùëÄ ùëñùëõùëñùëúùëõùê∑ùëéùë£ùëí.ùëóùëùùëî‚Äù);

ùëÉ ùêºùëöùëéùëîùëíùëò, ùë°;

ùë†ùëñùëßùëí(850, 650);

//Imagem do Minion Stuart

ùë° = ùëôùëúùëéùëëùêºùëöùëéùëîùëí(‚ÄùùëÄ ùëñùëõùëñùëúùëõùëÜùë°ùë¢ùëéùëüùë°.ùëóùëùùëî‚Äù);

//Imagem do Minion Dave

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

A figura do professor mediador nessa atividade visa explorar o recurso da homo-

tetia, no entanto, os alunos podem ficar livres para executar a atividade e produzir telas

distintas uma da outra. Nesse caso, o mediador poder√° intervir para as constru√ß√µes n√£o

se sobreporem ao mesmo tempo estabelecer novos desafios com o intuito de preencher ao

m√°ximo os espa√ßos vazios, sugestionando inclusive a utiliza√ß√£o de rota√ß√£o de eixos para

aumentar o n√∫mero de Minions nos pontos inexistentes.

Avalia√ß√£o

Ao concluir o processo de constru√ß√£o da tela repleta de Minions, espera-se que

os alunos notem como esta transforma√ß√£o geom√©trica contribui para a redu√ß√£o de c√≥di-

gos, principalmente, quando desejamos construir a mesma imagem em diversos escalas.

Al√©m disso, a atividade proporciona uma nova habilidade que inclui a inclus√£o de figuras

extra√≠das de qualquer meio digital nos formatos jpeg e png.

160

6 Considera√ß√µes Finais

Constatou-se neste trabalho que a implementa√ß√£o de uma linguagem de progra-

ma√ß√£o n√£o √© s√≥ interessante como vi√°vel para inserir os alunos no processo de constru√ß√£o

da pr√≥pria aprendizagem tendo em vista que os mesmos ser√£o protagonistas na constru-

√ß√£o do seu conhecimento segundo a teoria construcionista. Salienta-se neste sentido a

import√¢ncia em definir qual a melhor linguagem para favorecer um dom√≠nio m√≠nimo em

programa√ß√£o com o intuito de otimizar o processo de constru√ß√£o da pr√≥pria Matem√°tica

objetiva no emprego deste recurso tecnol√≥gico.

Ap√≥s muitas pesquisas e an√°lise das linguagens de programa√ß√£o, constatamos que a

linguagem de programa√ß√£o Processing √© a que melhor satisfaz nosso objetivo para inser√ß√£o

no processo pedag√≥gico. Dentre os motivos desta escolha podemos listar o fato de ser

uma linguagem gratuita, com vers√µes para Windows, Linux, Mac OS e o pr√≥prio sistema

Android para Smartphones, al√©m de ser uma linguagem de f√°cil programa√ß√£o pensada para

Designers Visuais, Artes Eletr√¥nicas e n√£o-programadores com a inten√ß√£o de se inserir no

universo da Programa√ß√£o.

O trabalho apresentou um percurso hist√≥rico da computa√ß√£o na educa√ß√£o visando

analisar a evolu√ß√£o das linguagens e sua contribui√ß√£o matem√°tica. Ap√≥s conhecer como

surgiu os variados tipos de linguagens focamos em nossa linguagem de estudo, Processing,

para enfim apresentarmos as TGPs e como podemos interagir via Programa√ß√£o. As pos-

sibilidades de aprendizagem ultrapassam as barreiras da pr√≥pria tecnologia, uma vez que

a maioria das constru√ß√µes fora pensada para ser trabalhada na malha quadriculada com

o intuito de planejar e otimizar o algoritmo empregado na linguagem.

Al√©m disso, as atividades seguiram uma orienta√ß√£o pedag√≥gica abordando seus

objetivos, materiais empregados, conte√∫dos visualizados, um suporte te√≥rico e ainda um

procedimento metodol√≥gico com a sequ√™ncia de constru√ß√£o evolutiva, isto √©, a medida que

os alunos s√£o convidados a participar do programa, os mesmos s√£o estimulados a novas

descobertas ao tempo que demonstram o dom√≠nio/conhecimento adquirido a cada nova

etapa. Em fun√ß√£o disso, algumas de nossas atividades discutem com os discentes a cerca de

CAP√çTULO 6. CONSIDERA√á√ïES FINAIS

161

algumas passagens sugestionando inclusive o motivo da escolha de determinado elemento

em detrimento de outrem, j√° que a proposta visa o trabalho em equipe, a valoriza√ß√£o de

ideias e sua organiza√ß√£o, e o incentivo a constru√ß√£o tendo como base o desenho em uma

malha quadriculada.

Dentre as dificuldades para participa√ß√£o no Curso de Programa√ß√£o no Khan Aca-

demy e aprendizagem da linguagem para posterior implementa√ß√£o das atividades pro-

postas na Unidade Escolar, podemos elucidar os problemas de configura√ß√£o do sistema

de rede Wifi e uma rede de cabeametno insuficiente para todos os 12 computadores em

funcionamento em fun√ß√£o da vers√£o do Linux Educacional e suporte t√©cnico por parte da

Prefeitura para solucionar estes empecilhos.

O processo de constru√ß√£o das atividades buscou conceituar e interpretar as Trans-

forma√ß√µes Geom√©tricas atrav√©s da manipula√ß√£o de dados e deslocamento din√¢mico dos

construtos de forma a contribuir para uma aprendizagem l√∫dica com potencialidade para

a descoberta de novas compet√™ncias e habilidades ao mesmo tempo que revela aos en-

volvidos uma Matem√°tica aplic√°vel com viabilidade de avan√ßarem tanto nos conceitos

matem√°ticos como na programa√ß√£o para constru√ß√£o de jogos eletr√¥nicos quando atingir

um n√≠vel de dom√≠nio das ferramentas computacionais.

Por isso esperamos que o trabalho sirva como fonte de consulta para os professores

de Matem√°tica em ambos os n√≠veis de ensino, Fundamental e M√©dio, de forma a contribuir

para a minimiza√ß√£o das dificuldades dos alunos em compreender como se comportam os

objetos em movimenta√ß√£o preservando algumas de suas caracter√≠sticas, e isso, potencializa

tamb√©m o estudo de fun√ß√µes quando referenciamos o posicionamento de seus gr√°ficos

como um dos objetos geom√©tricos em estudo. Salienta-se ainda que n√£o objetivamos

substituir nenhum conte√∫do matem√°tico, ao contr√°rio, a implementa√ß√£o dessa tecnologia

visa refor√ßar a aprendizagem matem√°tica com manipula√ß√£o de dados em conjunto com o

recurso visual e investiga√ß√£o matem√°tica para atingir nossos objetivos.

162

Refer√™ncias Bibliogr√°ficas

[1] BRASIL. Par√¢metros Curriculares Nacionais: Matem√°tica. Bras√≠lia: Minist√©rio da

Educa√ß√£o/Secret√°ria de Educa√ß√£o Fundamental, 1998.

[2] LIMA, E. L. Conceitua√ß√£o, manipula√ß√£o e aplica√ß√£o: os tr√™s componentes do ensino

de matem√°tica. Revista do Professor de Matem√°tica ‚Äì SBM, n. 41, p. 1‚Äì6, 1999.

[3] DEVLIN, K. Matem√°tica - a ci√™ncia dos padr√µes. Porto: Porto Editora, 2002.

[4] CANGUSS√ö, E. S. O Ensino de Sequ√™ncias de Recorr√™ncias na Educa√ß√£o B√°sica
com o aux√≠lio de Linguaguem de Programa√ß√£o. Disserta (Mestrado Profissional em
Matem√°tica) ‚Äî Universidade Federal do Maranh√£o - UFMA, S√£o Lu√≠s, 2013.

[5] BRASIL. PCN+ Ensino M√©dio: Orienta√ß√µes Educacionais Complementares aos
Par√¢metros Curriculares Nacionais. Ci√™ncias da Natureza, Matem√°tica e suas
Tecnologias. Bras√≠lia: Minist√©rio da Educa√ß√£o/Secret√°ria de Educa√ß√£o M√©dia e Tec-
nol√≥gica, 2002.

[6] STORMOWSKI, V. Estudando matrizes a partir de transforma√ß√µes geom√©tricas. Dis-
serta (Mestrado Profissional em Ensino de Matem√°tica) ‚Äî Universidade Federal do
Rio Grande do Sul - UFRGS, Porto Alegre, 2008.

[7] CERQUEIRA, A. P. F. de. Isometrias: an√°lise de documentos curriculares e uma
proposta de situa√ß√£o de aprendizagem para o ensino m√©dio. Disserta (Mestrado Profis-
sional em Ensino de Matem√°tica) ‚Äî Pontif√≠cia Universidade Cat√≥lica de S√£o Paulo -
PUC-SP, S√£o Paulo, 2008.

[8] VALENTE, J. A. O uso inteligente do computador na educa√ß√£o. P√°tio - Revista
Pedag√≥gica, Editora Artes M√©dicas Sul, n. 1, p. 19‚Äì21, 1 1997. Dispon√≠vel em:
http://www.educacaopublica.rj.gov.br/biblioteca/educacao/0024.html. Acesso em 02 ago
2014.

[9] VALENTE, J. A. Computadores e conhecimento: Repensando a educa√ß√£o. In:

.
2a. ed. Campinas, SP: UNICAMP/NIED, 1998. cap. 1 e 2, p. 1 a 53. Dispon√≠vel em:
http://www.nied.unicamp.br/?q=system/files/Computadores%20e%20Conhecimento.
pdf. Acesso em 02 ago 2014.

[10] VALENTE,

In:
na
. Campinas, SP: OEA-NIED/UNICAMP, 1999. cap. 1. Dispon√≠vel em:

J. A. O computador

conhecimento.

sociedade

do

http://www.nied.unicamp.br/oea/pub/livro1/cap1.zip. Acesso em 02 ago 2014.

[11] FRAN√áA, J. B. dos A. Novas tecnologias no ensino da matem√°tica: Forma√ß√£o
inicial de professores. Artigo de P√≥s-Gradua√ß√£o em Doc√™ncia do Ensino Supe-
rior pela Associa√ß√£o Bahiana de Educa√ß√£o e Cultura ‚Äì ABEC. Dispon√≠vel em:

Refer√™ncias Bibliogr√°ficas

163

https://drive.google.com/file/d/0ByHgpHWSevqEOUpBOWM5Qmo0TDg/view?pli=1.
2009.

[12] GIRALDO, V.; CAETANO, P. A. S.; MATTOS, F. R. P. Recursos Computacionais
no Ensino de Matem√°tica. 1a. ed. Rio de Janeiro: SBM, 2012. (Cole√ß√£o PROFMAT).

[13] SORDO JUANENA, J. M. Estudio de una estrategia did√°ctica basada en las
nuevas tecnolog√≠as para la ense√±anza de la geometr√≠a din√°mica. Tese (Facultad de
Educaci√≥n) ‚Äî Universidad Complutense de Madrid, Madrid, 2005. Dispon√≠vel em
http://biblioteca.ucm.es/tesis/edu/ucm-t28911.pdf. Acesso em 10 dez 2014.

[14] BRASIL. Par√¢metros Curriculares Nacionais: Ensino M√©dio. Bras√≠lia: Minist√©rio da

Educa√ß√£o/Secret√°ria de Educa√ß√£o M√©dia e Tecnol√≥gica, 1999.

[15] BORBA, M. de C. Tecnologias inform√°ticas na educa√ß√£o matem√°tica e reorganiza√ß√£o
de pensamento. In: BICUDO, M. A. V. (Ed.). Pesquisa em Educa√ß√£o Matem√°tica:
concep√ß√µes e perspectivas. S√£o Paulo: UNESP, 1999. p. 285‚Äì295.

[16] REIS,
o

L. R. M.
fracasso

Estrat√©gias

de

zir
http://proerdpmdf.files.wordpress.com/2010/07/aprendizagem-ativa1.pdf.
em 10 jan 2015.

escolar:

Papel

do

aprendizagem ativa
psicopedagogo.

para
Dispon√≠vel

redu-
em
Acesso

trilhados

[17] ALMEIDA, M. E. B.
atuais
cap.

cami-
UNESP,
nhos
em
99
2008. v.
http://www.periodicos.rc.biblioteca.unesp.br/index.php/bolema/article/viewFile/1723/
1497. Acesso em 10 dez 2014.

. Rio Claro:
129. BOLEMA. Dispon√≠vel

de. Tecnologias
desafios.
p.
4,

educa√ß√£o:

dos

aos

29,

21,

In:

na

n.

a

[18] POCRIFKA, D. H.; SANTOS, T. W. Linguagem logo e a constru√ß√£o do co-
nhecimento. In: PUCPR. IX Congresso Nacional de educa√ß√£o e III Encontro Sul
Brasileiros de Psicopedagogia. Curitiba: PUCPR, 2009. p. 2469 a 2479. Dispo-
n√≠vel em http://www.pucpr.br/eventos/educere/educere2009/anais/pdf/2980_1303.pdf.
Acesso em 12 dez 2014.

[19] LEMOS JUNIOR, J. A. S. Estudo de Fun√ß√µes Afins e Quadr√°ticas com o aux√≠lio
do Computador. Disserta (Mestrado Profissional em Matem√°tica em Rede Nacional -
PROFMAT) ‚Äî Universidade Federal de Campina Grande - UFCG, Campina Grande,
Jul 2013.

[20] GON√áALVES, M. B.; LENTZ, C. R.; PEREIRA, R. Matem√°tica e Inform√°tica.
Florian√≥polis: Laborat√≥rio de Ensino √† Dist√¢ncia, 2001. (Programa de Forma√ß√£o Con-
tinuada √† Dist√¢ncia).

[21] L√âVY, P. As Tecnologias da Intelig√™ncia: o futuro do pensamento na era da

inform√°tica. 13a. ed. S√£o Paulo: Editora 34, 2004.

[22] MORAES, M. C. Inform√°tica educativa no brasil: Uma hist√≥ria vivida, algumas li√ß√µes
aprendidas. Revista de Inform√°tica na Educa√ß√£o, v. 1, n. 1, p. 19‚Äì44, Abril 1997. Dis-
pon√≠vel em: http://www.br-ie.org/pub/index.php/rbie/article/view/2320/2082. Acesso
em 12 dez 2014.

Refer√™ncias Bibliogr√°ficas

164

[23] FONSECA FILHO, C. Hist√≥ria

do
Pensamento e da Tecnologia. Porto Alegre: EDIPUCRS, 2007. Dispon√≠vel em:
http://www.pucrs.br/edipucrs/online/historiadacomputacao.pdf. Acesso em 05 ago
2014.

O Caminho

computa√ß√£o:

da

[24] EUCLIDES. Os elementos/ Euclides. S√£o Paulo: UNESP, 2009. Tradu√ß√£o e introdu-

√ß√£o de Ireneu Bicudo.

[25] OLIVEIRA, Z. C. de. Uma interpreta√ß√£o geom√©trica do MDC. Revista do Professor

de Matem√°tica ‚Äì SBM, n. 29, p. 24‚Äì26, 1995.

[26] GUDWIN, R. R. Linguagens de programa√ß√£o ‚Äì mini e microcomputadores: Soft-
ware. UNICAMP, 1997. Notas de aula para disciplina EA877. Dispon√≠vel em
ftp://ftp.dca.fee.unicamp.br/pub/docs/ea877/lingpro.pdf. Acessado em 10 jan 2015.

[27] REAS, C.; FRY, B. Processing: a programming handbook for visual designers and
artists. Foreword by John Maeda. Cambridge, Massachusetts EUA: MIT Press books,
2007.

[28] AMADO, P. Introdu√ß√£o √† Programa√ß√£o Gr√°fica (Usando Processing. Porto, Por-
tugal: FBAUP - Faculdade de Belas Artes, 2007. Dispon√≠vel em http://repositorio-
aberto.up.pt/handle/10216/1848. Acesso em 10 dez 2014.

[29] MEDEIROS, L. G. F. de. DANDO MOVIMENTO √Ä FORMA: as transforma√ß√µes
geom√©tricas no plano na forma√ß√£o continuada a dist√¢ncia de professores de matem√°tica.
Disserta (Disserta√ß√£o de Mestrado Profissional em Educa√ß√£o Matem√°tica) ‚Äî Uni-
versidade Severino Sombra, USS, Brasil, Vassouras, Abr 2012. Dispon√≠vel em:
http://www.uss.br/arquivos/posgraduacao/strictosensu/educacaoMatematica/disserta
coes/2012/Dissertacao_LICIA_GIESTA_FERREIRA_DE_MEDEIROS.pdf. Acesso
em 05 dez 2014.

[30] LOPES, C.

F.

Escher:

Licen√ßa,

d√°
http://www.uff.br/dalicenca/images/stories/jornais/jornal40novo.pdf.
15 dez 2014.

Ano XIV,

2009. Dispon√≠vel
Acesso

n.

O g√™nio
40,

p.

da
8, mai

arte matem√°tica.

Jornal
em:
em

[31] FAINGUELERNT, E. K. Educa√ß√£o Matem√°tica: Representa√ß√£o e Constru√ß√£o em

Geometria. Porto Alegre: Artes M√©dicas Sul, 1999.

[32] KLEIN, F. O Programa Erlangen de F√©lix Klein. S√£o Paulo: Intituto de F√≠sica/USP,
1984. Dispon√≠vel em: http://publica-sbi.if.usp.br/PDFs/pd499. Acesso em: 05 jan 2015.

[33] CONCEI√á√ÉO, M. R. F. Transforma√ß√µes no Plano: Uma aplica√ß√£o do Estudo de
Matrizes com o Uso de Planilhas Eletr√¥nicas. Disserta (Mestrado Profissional em Ma-
tem√°tica em Rede Nacional - PROFMAT) ‚Äî Universidade Federal do Rio Grande ‚Äì
FURG, Rio Grande, mar 2013.

[34] WAGNER, E. Constru√ß√µes geom√©tricas. In:

. 6a. ed. Rio de Janeiro: Sociedade
Brasileira de Matem√°tica-SBM, 1994. v. 1, cap. Transforma√ß√µes Geom√©tricas, p. 70‚Äì90.

[35] DOMINGUES, H. H.; IEZZI, G. √Ålgebra Moderna. 4. ed. S√£o Paulo: Atual, 2003.

Refer√™ncias Bibliogr√°ficas

165

[36] SOUZA, D. M. de. Uso de Transforma√ß√µes Geom√©tricas na Revigora√ß√£o do Ensino de
Geometria Plana. Disserta (Mestrado Profissional em Matem√°tica em Rede Nacional
- PROFMAT) ‚Äî Instituto Nacional de Matem√°tica Pura e Aplicada ‚Äì IMPA, Rio de
Janeiro, 2014.

[37] LIRA, A. C. de B. A matem√°tica dos espelhos: Proposta para o ensino-aprendizagem
de matrizes utilizando transforma√ß√µes geom√©tricas. Disserta (Especializa√ß√£o em Edu-
ca√ß√£o Matem√°tica para Professores do Ensino M√©dio) ‚Äî Universidade Estadual da
Para√≠ba - UEPB, Campina Grande, 2011.

[38] GOMES, J.; VELHO, L. Fundamentos da Computa√ß√£o Gr√°fica. 1a. ed. Rio de Ja-

neiro: IMPA, 2008. (S√©rie de Computa√ß√£o e Matem√°tica).

[39] LAGE, M. A. Mobiliza√ß√£o das formas de pensamento matem√°tico no estudo de
transforma√ß√µes geom√©tricas no plano. Disserta (Mestrado em Ensino de Matem√°tica)
‚Äî Pontif√≠cia Universidade Cat√≥lica de Minas Gerais - PUC MINAS, Belo Horizonte,
2008.

[40] DELGADO, J.; FRENSEL, K.; CRISSAFF, L. Geometria Anal√≠tica. Rio de Janeiro:

SBM, 2013. (Cole√ß√£o PROFMAT).

[41] SANTOS, E. R. M. dos; SILVA, J. do Socorro Costa da; ROSSY, N. da cunha. Uti-
lizando a geometria fractal na introdu√ß√£o do conceito de pot√™ncia para uma turma
do projovem urbano. In: SBEM. X Encontro Nacional de Educa√ß√£o Matem√°tica:
Educa√ß√£o Matem√°tica, Cultura e Diversidade. Salvador-BA, 2010. Dispon√≠vel em:
http://www.lematec.net/CDS/ENEM10/artigos/RE/T17_RE1694.pdf. Acesso em: 10
jan 2016.

[42] SALLUM √âlvia M. Fractais no ensino m√©dio. Revista do Professor de Matem√°tica,

n. 57, p. 1‚Äì8, 2o quadrimestre 2005.

[43] PEREIRA, A. S. Fractais circulares: algumas considera√ß√µes e atividades. Disserta
(Mestrado Profissional em Matem√°tica - PROFMAT) ‚Äî Universidade Estadual de
Londrina, Londrina, 2013.

[44] FRAN√áA, J. B. dos A. et al. (Ed.). Transforma√ß√µes de Fun√ß√µes: fun√ß√£o afim, fun√ß√£o
quadr√°tica e fun√ß√£o exponecial. Salvador: UFBA, 2014. Trabalho da Disciplina MA36
do PROFMAT.

[45] VALE, I. et al. Os padr√µes no ensino e aprendizagem √Ålgebra. In: ISABEL VALE,
TERESA PIMENTEL, ANA BARBOSA AND L. FONSECA AND L. SANTOS AND
P. CANAVARRO. N√∫meros e √Ålgebra. Lisboa: SEM-SPCE, 2007. p. 193 a 211. Dispo-
n√≠vel em: http://www.rdpc.uevora.pt/bitstream/10174/1416/1/PadrAcesso em: 20 out
2015.

[46] LIMA, E. L. √Ålgebra Linear. 8. ed. Rio de Janeiro: IMPA, 2011.

[47] BOLDRINI, J. L. √Ålgebra Linear. 3. ed. S√£o Paulo: Harbra Ltda, 1986.

[48] HEFEZ, A.; FERNANDEZ, C. de S. Introdu√ß√£o √† √Ålgebra Linear. Rio de Janeiro:

SBM, 2012. (Cole√ß√£o PROFMAT).

166

AP√äNDICE A -- Transforma√ß√µes Lineares

As fun√ß√µes cujos dom√≠nios e contradom√≠nios s√£o espa√ßos vetoriais e que preservam

as opera√ß√µes de adi√ß√£o de vetores e de multiplica√ß√£o de um vetor por um escalar s√£o as

fun√ß√µes objetivadas pela √Ålgebra Linear. Essa fun√ß√£o √© definida da seguinte forma:

Defini√ß√£o A.1 (Transforma√ß√£o Linear). Sejam ùëâ e ùëä espa√ßos vetoriais1. Uma transfor-

ma√ß√£o linear de ùëâ em ùëä √© uma aplica√ß√£o (fun√ß√£o) ùëá : ùëâ ‚Üí ùëä que possui as seguintes

propriedades:

(i) ùëá (ùë£1 + ùë£2) = ùëá (ùë£1) + ùëá (ùë£2), para quaisquer ùë£1 e ùë£2 em ùëâ ;

(ii) ùëá (ùõºùë£) = ùõºùëá (ùë£), para quaisquer ùë£ em ùëâ e ùõº em R.

As propriedades (i) e (ii) s√£o equivalentes √† seguinte propriedade:

ùëá (ùë£1 + ùõºùë£2) = ùëá (ùë£1) + ùõºùëá (ùë£2),

para quaisquer ùë£1 e ùë£2 em ùëâ e para qualquer ùõº em R.

Exemplo A.1. Sejam ùëâ = R e ùëä = R e ùëá : R ‚Üí R definida por ùëá (ùëö) = ùëòùëö, ùëò ‚àà R.
Dados ùë¢, ùë£ ‚àà R, ùõº ‚àà R, temos:

ùëá (ùë¢ + ùõºùë£) = ùëò(ùë¢ + ùõºùë£) = ùëòùë¢ + ùëòùõºùë£ = ùëòùë¢ + ùõº(ùëòùë£) = ùëá (ùë¢) + ùõºùëá (ùë£),

segue que ùëá √© uma transforma√ß√£o linear.

De fato, toda a transforma√ß√£o linear de R em R s√≥ pode ser deste tipo.

1O leitor interessado poder√° encontrar as defini√ß√µes de espa√ßo vetorial, subespa√ßos vetoriais e bases

em livros de √Ålgebra Linear dos quais recomendo [46], [47] e [48]

APENDICE AP√äNDICE A -- TRANSFORMA√á√ïES LINEARES.

167

Exemplo A.2. As transforma√ß√µes lineares ùëá : R2 ‚Üí R2, definidas por:

1 ùëá (ùë•, ùë¶) = (2ùë•, 2ùë¶) s√£o ‚Äúesticamentos‚Äù na imagem da aplica√ß√£o;

2 ùëá (ùë•, ùë¶) = (‚àíùë¶, ùë•) √© uma rota√ß√£o de 90o no sentido anti-hor√°rio;

3 ùëá (ùë•, ùë¶) = (ùë¶, ùë•) √© uma reflex√£o (espelhamento) com rela√ß√£o √† reta ùë¶ = ùë•;

4 ùëá (ùë•, ùë¶) = (ùë•, 0) √© uma proje√ß√£o ortogonal no eixo ùëÇùë•;

Teorema A.1. A toda matriz ùëö √ó ùëõ est√° associada uma transforma√ß√£o linear de Rùëõ em
Rùëö e a toda transforma√ß√£o linear de Rùëõ em Rùëö est√° associada uma matriz ùëö √ó ùëõ.

Demonstra√ß√£o:
Sejam ùëâ = Rùëõ e ùëä = Rùëö e ùê¥ a matriz ùëö √ó ùëõ. Definimos

ùëÄùê¥ : Rùëõ ‚Üí Rùëö por ùë£ ‚Ü¶‚Üí ùê¥ ¬∑ ùë£

onde ùë£ =

‚é§

, assim: ùëÄùê¥(ùë£) = ùê¥ ¬∑

‚é•
‚é•
‚é¶

‚é°

‚é¢
‚é¢
‚é£

ùë•1
...
ùë•ùëõ

‚é°

‚é¢
‚é¢
‚é£

ùë•1
...
ùë•ùëõ

‚é§

‚é•
‚é•
‚é¶

=

‚é§

‚é•
‚é•
‚é¶

‚é°

‚é¢
‚é¢
‚é£

ùë¶1
...
ùë¶ùëõ

das propriedades de opera√ß√µes com matrizes:

ùëÄùê¥(ùë¢ + ùõºùë£) = ùê¥(ùë¢ + ùõºùë£) = ùê¥ùë¢ + ùê¥ùõºùë£ = ùê¥ùë¢ + ùõºùê¥ùë£ = ùëÄùê¥(ùë¢) + ùõºùëÄùê¥(ùë£), e portanto ùëÄùê¥

√© uma transforma√ß√£o linear.

Por outro lado, dada uma transforma√ß√£o linear, associamos uma matriz da seguinte

forma:

Seja ùëá : ùëâ ‚Üí ùëä uma transforma√ß√£o linear, em que ùëëùëñùëö(ùëâ ) = ùëõ e ùëëùëñùëö(ùëä ) = ùëö.

Sejam ùõº = (ùë£1, ¬∑ ¬∑ ¬∑ , ùë£ùëõ) e ùõΩ = (ùë§1, ¬∑ ¬∑ ¬∑ , ùë§ùëö) bases de ùëâ e ùëä , respectivamente. Como ùõΩ √©

uma base de ùëä , podemos determinar de modo √∫nico n√∫meros reais ùëéùëñùëó, com 1 ‚â§ ùëñ ‚â§ ùëõ e

1 ‚â§ ùëó ‚â§ ùëö, tais que

ùëá (ùë£ùëñ) = ùëé1ùëñùë§1 + ¬∑ ¬∑ ¬∑ + ùëéùëóùëñùë§ùëó + ¬∑ ¬∑ ¬∑ + ùëéùëöùëñùë§ùëö.

(A.1)

Tomemos agora ùë£ em ùëâ . Temos que ùë£ = ùëò1ùë£1 + ¬∑ ¬∑ ¬∑ + ùëòùëõùë£ùëõ, em que ùëòùëñ ‚àà R para

1 ‚â§ ùëñ ‚â§ ùëõ. Pela linearidade de ùëá e por (A.1), segue que

ùëá (ùë£) = ùëò1ùëá (ùë£1) + ¬∑ ¬∑ ¬∑ + ùëòùëõùëá (ùë£ùëõ)

= ùëò1(ùëé11ùë§1 + ¬∑ ¬∑ ¬∑ + ùëéùëö1ùë§ùëö) + ¬∑ ¬∑ ¬∑ + ùëòùëõ(ùëé1ùëõùë§1 + ¬∑ ¬∑ ¬∑ + ùëéùëöùëõùë§ùëö)

= (ùëé11ùëò1 + ¬∑ ¬∑ ¬∑ + ùëé1ùëõùëòùëõ)ùë§1 + ¬∑ ¬∑ ¬∑ + (ùëéùëö1ùëò1 + ¬∑ ¬∑ ¬∑ + ùëéùëöùëõùëòùëõ)ùë§ùëö.

APENDICE AP√äNDICE A -- TRANSFORMA√á√ïES LINEARES.

168

Logo,

[ùëá (ùë£)]ùõΩ =

=

Onde definimos

‚é°

‚é¢
‚é¢
‚é£

‚é°

‚é¢
‚é¢
‚é£

‚é§

‚é•
‚é•
‚é¶

ùëé11ùëò1 + ¬∑ ¬∑ ¬∑ + ùëé1ùëõùëòùëõ
...
ùëéùëö1ùëò1 + ¬∑ ¬∑ ¬∑ + ùëéùëöùëõùëòùëõ
‚é°

‚é§

ùëé11 + ¬∑ ¬∑ ¬∑ + ùëé1ùëõ
...
ùëéùëö1 + ¬∑ ¬∑ ¬∑ + ùëéùëöùëõ

‚é•
‚é•
‚é¶

‚é¢
‚é¢
‚é£

‚é§

‚é•
‚é•
‚é¶

ùëò1
...
ùëòùëõ

= [ùëá (ùë£)]ùõº

ùõΩ ¬∑ [ùë£]ùõº

(A.2)

[ùëá ]ùõº

ùõΩ =

‚é°

‚é¢
‚é¢
‚é£

ùëé11
...
ùëéùëö1

¬∑ ¬∑ ¬∑

¬∑ ¬∑ ¬∑

‚é§

‚é•
‚é•
‚é¶

ùëé1ùëõ
...
ùëéùëöùëõ

. A matriz [ùëá ]ùõº

ùõΩ, que representa ùëá em rela√ß√£o √†s bases ùõº e ùõΩ, √© chamada matriz de ùëá nas

bases ùõº e ùëèùëíùë°ùëé. Por (A.2), obtemos a express√£o

[ùëá ]ùõΩ = [ùëá ]ùõº

ùõΩ ¬∑ [ùë£]ùõº para todo ùë£ em ùëâ .

Fica assim estabelecida a bije√ß√£o entre transforma√ß√µes lineares e matrizes.

Considere [ùëá ]ùõº

ùõΩ =

]Ô∏É

[Ô∏É

2 0

0 2

como uma aplica√ß√£o ùëÄùê¥ : R2 ‚Üí R2 em rela√ß√£o a base

can√¥nica do R2. Sendo assim, aplicando a equa√ß√£o (A.2) para um vetor ùë£ = (ùë•, ùë¶) ‚àà R2,

temos:

[ùëá ]ùõΩ = [ùëá ]ùõº

ùõΩ ¬∑ [ùë£]ùõº =

[Ô∏É

2 0

0 2

]Ô∏É

[Ô∏É

¬∑

ùë•

ùë¶

]Ô∏É

[Ô∏É

=

]Ô∏É

2ùë•

2ùë¶

Note que esta √© a aplica√ß√£o linear que representa o ‚Äúesticamento‚Äù listada no exemplo (A.2).

169

AP√äNDICE B -- Transforma√ß√µes Projetivas

Considere o modelo afim do espa√ßo projetivo n-dimensional, RPùëõ, onde os pontos
projetivos s√£o retas passando pela origem de Rùëõ+1 ‚àí {0}. Uma transforma√ß√£o projetiva

transforma pontos do espa√ßo projetivo, logo, T deve transformar uma reta pela origem de
Rùëõ+1 noutra reta que tamb√©m passa pela origem, segundo a √≥tica euclidiana. Portanto,
ùëá √© uma transforma√ß√£o linear invert√≠vel ùëá : Rùëõ+1 ‚Üí Rùëõ+1, do espa√ßo euclidiano Rùëõ+1.

Dessa forma, conclu√≠mos que uma transforma√ß√£o projetiva de RPùëõ preserva os

elementos lineares do espa√ßo projetivo e al√©m disso √© representado por uma matriz de

ordem ùëõ + 1.

√â not√≥rio que se ùëá : RPùëõ ‚Üí RPùëõ √© uma transforma√ß√£o projetiva e ùúÜ ‚àà R, ùúÜ Ã∏= 0,

ent√£o pela linearidade de ùëá , temos:

(ùúÜùëá )ùëÉ = ùëá (ùúÜùëÉ ) = ùëá (ùëÉ )

Da√≠, uma transforma√ß√£o projetiva fica definida a menos de um produto por um

escalar n√£o nulo [38].

B.1 Transforma√ß√£o Projetiva Plana

A transforma√ß√£o projetiva ùëá : RP2 ‚Üí RP2 do plano projetivo √© dada por uma
transforma√ß√£o linear invert√≠vel ùëá : R3 ‚Üí R3. Por isso, representamos na forma de uma

matriz ùëÄ de ordem 3 invert√≠vel. Para compreender como essa matriz atua no plano

projetivo, vamos dividi-la em 4 blocos.

Seja

ùëÄ =

‚éõ

‚éú
‚éú
‚éù

ùëé

ùëê

ùëè

ùëë

ùëì1 ùëì2

‚éû

‚éü
‚éü
‚é†

ùë°ùë•

ùë°ùë¶

ùëò

(Ô∏É

=

)Ô∏É

,

ùê¥ ùëá

ùêπ ùêª

B.1 Transforma√ß√£o Projetiva Plana

170

onde

ùê¥ =

(Ô∏É

ùëé ùëè

)Ô∏É

ùëê ùëë

, ùêπ =

(Ô∏Å

ùëì1 ùëì2

)Ô∏Å

, ùëá =

)Ô∏É

(Ô∏É

ùë°ùë•

ùë°ùë¶

ùëí ùêª =

)Ô∏Å

(Ô∏Å

ùëò

(B.1)

Sabe-se que a matriz

ùê¥ =

(Ô∏É

ùëé ùëè

)Ô∏É

ùëê ùëë

em (B.1) √© uma matriz de transforma√ß√£o geom√©trica em cada caso apresentado nas trans-

forma√ß√µes isom√©tricas (sec√ß√£o 3.2), isom√≥rfica (sec√ß√£o 3.3) e anam√≥rfica (sec√ß√£o 3.4). Com

isso, vamos analisar o comportamento dos blocos ùêπ , ùëá e ùêª constante em (B.1).

Supondo que

ùêπ =

(Ô∏Å

0 0

)Ô∏Å

, ùëá =

(Ô∏É

)Ô∏É
0

0

ùëí ùêª =

(Ô∏Å

)Ô∏Å
1

,

a matriz da transforma√ß√£o projetiva (B.1) ser√° dada por:

‚éõ

‚éú
‚éú
‚éù

ùëé ùëè 0

ùëê ùëë 0

0 0 1

‚éû

‚éü
‚éü
‚é†

Nesse caso, aplicando a transforma√ß√£o a um ponto do infinito (ùë•, ùë¶, 0) ou a um ponto afim

(ùë•, ùë¶, 1) do plano projetivo, suas imagens ser√£o dadas, respectivamente, por:

‚éõ

‚éú
‚éú
‚éù

ùëé ùëè 0

ùëê ùëë 0

0 0 1

‚éû

‚éü
‚éü
‚é†

¬∑

‚éõ

‚éú
‚éú
‚éù

‚éû

‚éü
‚éü
‚é†

ùë•

ùë¶

0

‚éõ

‚éú
‚éú
‚éù

=

ùëéùë• + ùëèùë¶

ùëêùë• + ùëëùë¶

0

‚éû

‚éü
‚éü
‚é†

ùëí

‚éõ

‚éú
‚éú
‚éù

ùëé ùëè 0

ùëê ùëë 0

0 0 1

‚éû

‚éü
‚éü
‚é†

¬∑

‚éû

‚éü
‚éü
‚é†

‚éõ

‚éú
‚éú
‚éù

ùë•

ùë¶

1

‚éõ

‚éú
‚éú
‚éù

=

ùëéùë• + ùëèùë¶

ùëêùë• + ùëëùë¶

1

‚éû

‚éü
‚éü
‚é†

Onde o ponto resultante √© um ponto do infinito e um ponto afim, nesta ordem.

Salienta-se que em ambos os casos as coordenadas afins dos pontos transformados

s√£o dadas por:

(Ô∏É

ùëé ùëè

)Ô∏É

(Ô∏É

¬∑

)Ô∏É

ùë•

ùë¶

=

(Ô∏É

ùëéùë• + ùëèùë¶

ùëêùë• + ùëëùë¶

)Ô∏É

.

ùëê ùëë

Fundamentando que o bloco ùê¥ √© a matriz de uma transforma√ß√£o linear no espa√ßo

euclidiano aplicado ao espa√ßo projetivo. Portanto, o grupo das transforma√ß√µes projetivas

do plano cont√©m, naturalmente, o grupo das transforma√ß√µes lineares do plano euclidiano,

em especial, o grupo dos movimentos r√≠gidos da Geometria Euclidiana Plana.

B.1 Transforma√ß√£o Projetiva Plana

171

Da an√°lise das transforma√ß√µes afins √© not√≥rio que a matriz

‚éõ

‚éú
‚éú
‚éù

ùëé ùëè

ùë°ùë•

ùëê ùëë ùë°ùë¶

0 0

1

‚éû

‚éü
‚éü
‚é†

representa uma transforma√ß√£o linear do plano seguida de uma transla√ß√£o, facilmente

confirmada na seguinte situa√ß√£o onde:

ùê¥ =

(Ô∏É

1 0

)Ô∏É

0 1

, ùêπ =

(Ô∏Å

)Ô∏Å

,

0 0

ùëí ùêª =

(Ô∏Å

)Ô∏Å
1

Da√≠;

‚éõ

1 0 ùë°ùë•

0 1 ùë°ùë¶

‚éú
‚éú
‚éù

‚éû

‚éõ

‚éû

‚éõ

‚éü
‚éü
‚é†

¬∑

‚éú
‚éú
‚éù

‚éü
‚éü
‚é†

=

‚éú
‚éú
‚éù

ùë•

ùë¶

ùë• + ùë°ùë•

ùë¶ + ùë°ùë¶

‚éû

‚éü
‚éü
‚é†

1

0 0

1
Portanto, essa aplica√ß√£o resulta de uma transla√ß√£o de um vetor ‚àí‚Üíùë£ = (ùë°ùë•, ùë°ùë¶). Por outro
lado, o elemento ùëò, que constitui o bloco ùêª da matriz, corresponde a uma homotetia do
plano afim de fator 1
ùëò , ùëò Ã∏= 0. Logicamente comprovado, visto que:

1

‚éõ

‚éú
‚éú
‚éù

1 0 0

0 1 0

0 0 ùëò

‚éû

‚éü
‚éü
‚é†

¬∑

‚éõ

‚éú
‚éú
‚éù

‚éû

‚éü
‚éü
‚é†

ùë•

ùë¶

1

=

‚éõ

‚éú
‚éú
‚éù

‚éû

‚éü
‚éü
‚é†

ùë•

ùë¶

ùëò

=

‚éû

‚éü
‚éü
‚é†

‚éõ

‚éú
‚éú
‚éù

ùë•
ùëò
ùë¶
ùëò
1

Com base nos dados apresentados, as transforma√ß√µes projetivas preservam os pontos

afins e os pontos ideais. Ou seja, segundo as palavras de Velho [38, p.42]:

‚ÄúO grupo

das transforma√ß√µes projetivas cont√©m o grupo das transforma√ß√µes afins (e portanto os

movimentos r√≠gidos da geometria Euclidiana)‚Äù.

Nota-se que falta apenas o bloco ùêπ da matriz ùëÄ em (B.1) a ser identificado.

Para isso, tomemos o bloco ùê¥ como sendo a matriz identidade, o bloco ùëá nulo e ùëò = 1.

Aplicando a transforma√ß√£o no ponto afim (ùë•, ùë¶, 1), obtemos:

‚éõ

‚éú
‚éú
‚éù

1

0

0

1

0

0

ùëì1 ùëì2 1

‚éû

‚éü
‚éü
‚é†

‚éû

‚éü
‚éü
‚é†

‚éõ

ùë•

¬∑

‚éú
‚éú
‚éù

ùë¶

1

=

‚éõ

‚éú
‚éú
‚éù

ùë•

ùë¶

‚éû

‚éü
‚éü
‚é†

ùëì1ùë• + ùëì2ùë¶ + 1

Se ùëì1 Ã∏= 0 ou ùëì2 Ã∏= 0, a equa√ß√£o ùëì1ùë• + ùëì2ùë¶ + 1 = 0 possuir√° uma infinidade de solu√ß√µes.

Isso revela que os pontos afins (ùë•, ùë¶, 1) ser√£o transformados em pontos do infinito (ùë•, ùë¶, 0)

do plano projetivo.

B.1 Transforma√ß√£o Projetiva Plana

172

No entanto, se a aplica√ß√£o da transforma√ß√£o for em um ponto ideal (ùë•, ùë¶, 0), tere-

mos:

‚éõ

‚éú
‚éú
‚éù

1

0

0

1

0

0

ùëì1 ùëì2 1

‚éû

‚éü
‚éü
‚é†

¬∑

‚éõ

‚éú
‚éú
‚éù

‚éû

‚éü
‚éü
‚é†

ùë•

ùë¶

0

‚éõ

‚éú
‚éú
‚éù

=

ùë•

ùë¶

ùëì1ùë• + ùëì2ùë¶

‚éû

‚éü
‚éü
‚é†

Com isso, conclu√≠mos que se ùëì1ùë• + ùëì2ùë¶ Ã∏= 0, ent√£o os pontos do infinito do plano

projetivo s√£o transformados em pontos do plano afim. Nessas situa√ß√µes dizemos que um

ponto ideal foi transformado em um ponto ùëÉ0 do plano afim e a fam√≠lia de retas paralelas

que interceptam nesse ponto ideal, s√£o transformados em uma fam√≠lia de retas incidentes

no ponto ùëÉ0 e esse ponto ùëÉ0 √© chamado de ponto de fuga da transforma√ß√£o.

A exist√™ncia dos pontos de fuga √© controlada pelos elementos ùëì1 e ùëì2, na matriz ùëÄ

da transforma√ß√£o projetiva. Onde ùëì1 Ã∏= 0 e ùëì2 = 0 √© o ponto de fuga em rela√ß√£o ao eixo

ùëÇùë•, do contr√°rio, se ùëì1 = 0 e ùëì2 Ã∏= 0, o ponto de fuga ser√° em rela√ß√£o ao eixo ùëÇùë¶.

Figura 68: Transforma√ß√£o com dois pontos de fuga

Nota-se que uma transforma√ß√£o projetiva ùëá : RP2 ‚Üí RP2 definida em coordenadas

homog√™neas pela matriz

‚éõ

‚éú
‚éú
‚éù

ùëé

ùëê

ùëè

ùëë

ùë°ùë•

ùë°ùë¶

ùëì1 ùëì2 ùëò

‚éû

‚éü
‚éü
‚é†

Associa um ponto euclidiano (ùë•, ùë¶) do plano a uma imagem ùëß = (ùë•, ùë¶, 1) para

escrever a transforma√ß√£o na forma de produto, isto √©:

ùëá (ùë•, ùë¶, 1) =

‚éõ

‚éú
‚éú
‚éù

ùëé

ùëê

ùëè

ùëë

ùë°ùë•

ùë°ùë¶

ùëì1 ùëì2 ùëò

‚éû

‚éü
‚éü
‚é†

‚éõ

‚éú
‚éú
‚éù

¬∑

‚éû

‚éü
‚éü
‚é†

ùë•

ùë¶

1

Salienta-se nesse ponto que as transforma√ß√µes geom√©tricas abordadas no trabalho

n√£o enfatiza a exist√™ncia de pontos de fugas, adotaremos o bloco ùêπ em (B.1)sempre na

forma nula. Al√©m disso, o bloco ùê¥ ser√° apresentado de acordo com o tipo de transforma√ß√£o

geom√©trica, enquanto o bloco ùëá s√≥ possuir√° valor diferente de zero nas situa√ß√µes em que

B.1 Transforma√ß√£o Projetiva Plana

173

haja transla√ß√£o somente ou em composi√ß√£o com outra transforma√ß√£o. E nos casos em que

haja uma homotetia a constante ùëò ter√° valor diferente de 1. Nesse sentido, a transforma√ß√£o

anterior pode ser escrita da seguinte forma:

ùëá (ùë•, ùë¶, 1) =

‚éõ

‚éú
‚éú
‚éù

ùëé ùëè

ùë°ùë•

ùëê ùëë ùë°ùë¶

0 0 ùëò

‚éû

‚éü
‚éü
‚é†

‚éõ

‚éú
‚éú
‚éù

¬∑

‚éû

‚éü
‚éü
‚é†

ùë•

ùë¶

1

= (ùëéùë• + ùëèùë¶ + ùë°ùë•, ùëêùë• + ùëëùë¶ + ùë°ùë¶, ùëò)

Se ùëò Ã∏= 0, √© poss√≠vel dividir (ùëéùë• + ùëèùë¶ + ùë°ùë•, ùëêùë• + ùëëùë¶ + ùë°ùë¶, ùëò) por ùëò, e assim obter o

mesmo ponto escrito na forma

ùëá (ùë•, ùë¶) = ùëá (ùë•, ùë¶, 1) =

(Ô∏Ç ùëéùë• + ùëèùë¶ + ùë°ùë•
ùëò

,

ùëêùë• + ùëëùë¶ + ùë°ùë¶
ùëò

)Ô∏Ç

(B.2)

A equa√ß√£o (B.2) expressa uma transforma√ß√£o projetiva em coordenadas euclidianas

de R2.

174

AP√äNDICE C -- Mosaico para caleidosc√≥pio

O Mosaico da atividade da sec√ß√£o 5.4.2 foi pensada de forma a oportunizar os

alunos na constru√ß√£o dos c√≥digos de cada figura plana. Para auxiliar o docente vamos

disponibilizar o c√≥digo de cada figura para construir o mosaico b√°sico para nosso calei-

dosc√≥pio com movimento cont√≠nuo.

a) Constru√ß√£o das figuras como fun√ß√µes na aba ‚Äúpe√ßas‚Äù:

1 ùë£ùëúùëñùëë ùë°ùëüùëíùë£ùëú(){

ùëôùëñùëöùëé();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(0, 30);

ùë£ùëíùëüùë°ùëíùë•(10, 40);

ùë£ùëíùëüùë°ùëíùë•(20, 30);

ùë£ùëíùëüùë°ùëíùë•(10, 20);

ùë£ùëíùëüùë°ùëíùë•(20, 10);

ùë£ùëíùëüùë°ùëíùë•(30, 20);

ùë£ùëíùëüùë°ùëíùë•(40, 10);

ùë£ùëíùëüùë°ùëíùë•(30, 0);

ùë£ùëíùëüùë°ùëíùë•(30, 0);

ùë£ùëíùëüùë°ùëíùë•(30, 10);

ùë£ùëíùëüùë°ùëíùë•(0, 10);

ùë£ùëíùëüùë°ùëíùë•(70, 10);

ùë£ùëíùëüùë°ùëíùë•(60, 0);

ùë£ùëíùëüùë°ùëíùë•(40, 20);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë£ùëíùëüùë°ùëíùë•(20, 0);

}

3 ùë£ùëúùëñùëë ùëùùëö(){

ùë£ùëíùëüùëöùëíùëô‚Ñéùëú();

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

}

ùëûùë¢ùëéùëë(0, 0, 10, 10, 30, 10, 40, 0);

4 ùë£ùëúùëñùëë ùë¶(){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 10);

ùë£ùëíùëüùëëùëí();

ùëéùëßùë£ùëñùëú();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë£ùëíùëüùë°ùëíùë•(10, 0);

}

2 ùë£ùëúùëñùëë ùëùùëíùëõùë°(){

ùëéùëßùëêùëíùë¢();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(10, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(20, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(20, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(40, 0);

ùë£ùëíùëüùë°ùëíùë•(50, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(60, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(70, 0);

ùë£ùëíùëüùë°ùëíùë•(80, 0);

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(10, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(30, 10);

ùë£ùëíùëüùë°ùëíùë•(50, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(60, 0);

ùë£ùëíùëüùë°ùëíùë•(30, 30);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(0, 10);

APENDICE AP√äNDICE C -- MOSAICO PARA CALEIDOSC√ìPIO.

175

ùë£ùëíùëüùë°ùëíùë•(20, 30);

ùë£ùëíùëüùë°ùëíùë•(20, 40);

ùë£ùëíùëüùë°ùëíùë•(30, 50);

ùë£ùëíùëüùë°ùëíùë•(30, 30);

ùë£ùëíùëüùë°ùëíùë•(0, 20);

ùë£ùëíùëüùë°ùëíùë•(10, 30);

ùë£ùëíùëüùë°ùëíùë•(10, 40);

ùë£ùëíùëüùë°ùëíùë•(20, 40);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 0);

ùë†ùëêùëéùëôùëí(‚àí1, 1);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

}

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë£ùëíùëüùë°ùëíùë•(30, 50);

8 ùë£ùëúùëñùëë ùëîùëéùë°ùëú(){

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 30);

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(0, 20);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùë£ùëíùëüùë°ùëíùë•(10, 0);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí20);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí30);

ùë£ùëíùëüùë°ùëíùë•(40, 50);

ùë£ùëíùëüùë°ùëíùë•(50, 40);

ùë£ùëíùëüùë°ùëíùë•(40, 30);

ùë£ùëíùëüùë°ùëíùë•(60, 10);

ùë£ùëíùëüùë°ùëíùë•(60, 0);

ùë£ùëíùëüùë°ùëíùë•(30, 0);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(20, ‚àí20);

//rosto

ùëúùë¢ùëüùëú();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(0, 30);

ùë£ùëíùëüùë°ùëíùë•(20, 50);

ùë£ùëíùëüùë°ùëíùë•(40, 30);

ùë£ùëíùëüùë°ùëíùë•(40, 0);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë£ùëíùëüùë°ùëíùë•(10, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí10);

}

5 ùë£ùëúùëñùëë ùëé(){

ùëùùëíùëüùë¢();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùë£ùëíùëüùë°ùëíùë•(20, 10);

ùë£ùëíùëüùë°ùëíùë•(10, 20);

ùë£ùëíùëüùë°ùëíùë•(10, 30);

ùë£ùëíùëüùë°ùëíùë•(20, 40);

ùë£ùëíùëüùë°ùëíùë•(30, 30);

ùë£ùëíùëüùë°ùëíùë•(40, 40);

ùë£ùëíùëüùë°ùëíùë•(40, 0);

ùë£ùëíùëüùë°ùëíùë•(20, 0);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùë£ùëíùëüùë°ùëíùë•(20, 0);

ùë£ùëíùëüùë°ùëíùë•(10, ‚àí10);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë£ùëíùëüùëëùëí();

ùë†ùëéùëôùëöùëéùëú();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 20);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

//orelha esquerda

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 20);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(5, 0);

ùë†ùëêùëéùëôùëí(1, ‚àí1);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 5, ‚àí5);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

//orelha direita

}

7 ùë£ùëúùëñùëë ùëùùëíùëñùë•ùëí(){

ùë£ùëíùëüùëöùëíùëô‚Ñéùëú();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 0);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 5, ‚àí5);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëûùë¢ùëéùëë(0, 0, 20, ‚àí20, 40, 0, 20, 20);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 0);

//olho esquerdo

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 20);

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(0, 256));

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 10);

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 5, 5); //ùëúùëô‚Ñéùëú

ùëì ùëñùëôùëô(255);

ùëûùë¢ùëéùëë(0, 0, 0, 10, 10, 0, 10, ‚àí10);

ùëôùëñùëõùëí(10, ‚àí20, 10, ‚àí10);

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 10, 5);

}

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 30);

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

6 ùë£ùëúùëñùëë ùëì ùëúùëüùëöùëé1(){

ùë†ùëêùëéùëôùëí(1, ‚àí1);

//caudas

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 5, 5);

//olho direito

ùë†ùëéùëôùëöùëéùëú();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 0);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

ùëì ùëñùëôùëô(255);

APENDICE AP√äNDICE C -- MOSAICO PARA CALEIDOSC√ìPIO.

176

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 10, 5);

ùë£ùëíùëüùë°ùëíùë•(10, 40);

ùëì ùëñùëôùëô(255);

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

ùë£ùëíùëüùë°ùëíùë•(30, 40);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, ‚àí10);

ùëíùëôùëôùëñùëùùë†ùëí(0, 0, 5, 5);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

//nariz

ùë£ùëíùëüùë°ùëíùë•(30, 50);

ùë£ùëíùëüùë°ùëíùë•(40, 50);

ùë£ùëíùëüùë°ùëíùë•(40, 0);

ùë£ùëíùëüùë°ùëíùë•(20, 20);

ùëéùëüùëê(0, 0, 10, 10, 0, ùëÉ ùêº);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 0);

ùëéùëüùëê(0, 0, 10, 10, 0, ùëÉ ùêº);

}

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(15, 20);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

9 ùë£ùëúùëñùëë ùëì ùëúùëüùëöùëé2(){

ùë†ùëéùëôùëöùëéùëú();

//patas

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 5, 5);

ùëéùëöùëéùëüùëíùëôùëú();

//boca

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 30);

ùëêùëéùëüùëöùëíùë†ùëñùëö();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 17);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, ‚àí10, 20, 0);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùë†ùëêùëéùëôùëí(1, ‚àí1);

ùëóùëéùëöùëèùëú();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 0);

ùë£ùëíùëüùë°ùëíùë•(0, 20);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, ‚àí10, 20, 0);

ùë£ùëíùëüùë°ùëíùë•(20, 40);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 5, 5);

}

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

//pelo esquerdo

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(7, 20);

ùë£ùëúùëñùëë ùëêùëéùëüùëüùëú(){

ùëéùëßùëêùëíùë¢();

ùëüùëúùë°ùëéùë°ùëí(ùëÉ ùêº/2);

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(40, 20);

ùë£ùëíùëüùë°ùëíùë•(40, 10);

ùë£ùëíùëüùë°ùëíùë•(30, 0);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(20, ‚àí20);

ùë†ùë°ùëüùëúùëòùëí(ùëüùëéùëõùëëùëúùëö(256));

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùëôùëñùëõùëí(0, 0, 8, 8);

ùëôùëñùëõùëí(0, 5, 8, 13);

//pelo direito

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(25, 0);

ùë†ùëêùëéùëôùëí(‚àí1, 1);

ùëôùëñùëõùëí(0, 0, 8, 8);

ùëôùëñùëõùëí(0, 5, 8, 13);

ùëõùëúùëÜùë°ùëüùëúùëòùëí();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùë°ùëüùëúùëòùëí(0);

//corpo do gato

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 30);

ùëùùëüùëéùë°ùëé();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(0, 50);

ùë£ùëíùëüùë°ùëíùë•(10, 50);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùë£ùëíùëüùë°ùëíùë•(20, 10);

ùë£ùëíùëüùë°ùëíùë•(30, 20);

ùë£ùëíùëüùë°ùëíùë•(40, 20);

ùë£ùëíùëüùë°ùëíùë•(50, 10);

ùë£ùëíùëüùë°ùëíùë•(60, 10);

ùë£ùëíùëüùë°ùëíùë•(70, 0);

ùëéùëßùë£ùëñùëú();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 0);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 10);

ùëéùëöùëéùëüùëíùëôùëú();

ùëüùëíùëêùë°(0, 0, 10, 10);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí10, 10);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùëéùëßùë£ùëñùëú();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 10);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

ùëì ùëñùëôùëô(ùëüùëéùëõùëëùëúùëö(256));

}

ùëíùëôùëôùëñùëùùë†ùëí(7, 3, 5, 5);

10 ùë£ùëúùëñùëë ùëì ùëúùëüùëöùëé3(){

ùëêùëñùëõùëßùëéùëì ùëúùë†ùëêùëú();

ùëôùëñùëöùëé();

ùëûùë¢ùëéùëë(0, 0, 15, 0, 15, 10, 10, 10);

ùë†ùëêùëéùëôùëí(1, ‚àí1);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 0);

ùë†ùëêùëéùëôùëí(‚àí1, 1);

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùëûùë¢ùëéùëë(0, 0, 15, 0, 15, 10, 10, 10);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

//rodas

ùë£ùëíùëüùë°ùëíùë•(10, 20);

APENDICE AP√äNDICE C -- MOSAICO PARA CALEIDOSC√ìPIO.

177

ùë£ùëíùëüùë°ùëíùë•(20, 20);

ùë£ùëíùëüùë°ùëíùë•(30, 30);

ùë£ùëíùëüùë°ùëíùë•(40, 30);

ùë£ùëíùëüùë°ùëíùë•(50, 20);

ùë£ùëíùëüùë°ùëíùë•(60, 30);

ùë£ùëíùëüùë°ùëíùë•(50, 40);

ùë£ùëíùëüùë°ùëíùë•(70, 40);

ùë£ùëíùëüùë°ùëíùë•(40, 70);

ùë£ùëíùëüùë°ùëíùë•(20, 50);

ùë£ùëíùëüùë°ùëíùë•(30, 40);

ùë£ùëíùëüùë°ùëíùë•(20, 30);

ùë£ùëíùëüùë°ùëíùë•(10, 40);

ùë£ùëíùëüùë°ùëíùë•(0, 30);

ùë£ùëíùëüùë°ùëíùë•(30, 10);

ùë£ùëíùëüùë°ùëíùë•(20, 20);

ùë£ùëíùëüùë°ùëíùë•(40, 40);

ùë£ùëíùëüùë°ùëíùë•(40, 70);

ùë£ùëíùëüùë°ùëíùë•(10, 70);

ùë£ùëíùëüùë°ùëíùë•(10, 50);

ùë£ùëíùëüùë°ùëíùë•(0, 50);

ùë£ùëíùëüùë°ùëíùë•(0, 30);

ùë£ùëíùëüùë°ùëíùë•(10, 20);

ùë£ùëíùëüùë°ùëíùë•(0, 20);

ùëûùë¢ùëéùëë(0, 0, 0, 10, 20, 30, 20, 20);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(40, 0);

ùë†ùëêùëéùëôùëí(‚àí1, 1);

ùëûùë¢ùëéùëë(0, 0, 0, 10, 20, 30, 20, 20);

}

13 ùë£ùëúùëñùëë ùëëùëíùëõùë°(){

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(10, 0);

ùë£ùëíùëüùë°ùëíùë•(15, ‚àí5);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùë£ùëíùëüùë°ùëíùë•(20, 0);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 40);

ùëùùëíùëüùë¢();

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí10);

ùë£ùëíùëüùë°ùëíùë•(30, ‚àí30);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

ùëûùë¢ùëéùëë(0, 0, 10, ‚àí10, 20, 0, 10, 10);

ùë£ùëíùëüùë°ùëíùë•(50, ‚àí30);

}

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 20);

11 ùë£ùëúùëñùëë ùëì ùëúùëüùëöùëé4(){

ùë†ùëêùëéùëôùëí(1, ‚àí1);

ùëúùë¢ùëüùëú();

ùë£ùëíùëüùë°ùëíùë•(50, 0);

ùë£ùëíùëüùë°ùëíùë•(30, 10);

ùë£ùëíùëüùë°ùëíùë•(20, 10);

ùëóùëéùëöùëèùëú();

ùëèùëíùëîùëñùëõùëÜ‚Ñéùëéùëùùëí();

ùë£ùëíùëüùë°ùëíùë•(0, 0);

ùë£ùëíùëüùë°ùëíùë•(10, 10);

ùë£ùëíùëüùë°ùëíùë•(20, 0);

ùë°ùëüùëñùëéùëõùëîùëôùëí(0, 0, 10, 0, 10, 10);

ùëíùëõùëëùëÜ‚Ñéùëéùëùùëí(ùê∂ùêøùëÇùëÜùê∏);

}

12 ùë£ùëúùëñùëë ùëêùë¢ùëèùëú(){

}

ùëûùë¢ùëéùëë(0, 0, 20, ‚àí20, 40, 0, 20, 20);

b) Constru√ß√£o da fun√ß√£o ‚Äúmosaico‚Äù na respectiva aba:

1 ùë£ùëúùëñùëë ùëöùëúùë†ùëéùëñùëêùëú(){

ùëì ùëúùëüùëöùëé2();

ùëì ùëúùëüùëöùëé4();

ùëì ùëñùëôùëô(189, 143, 143);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(20, 10);

ùëüùëíùëêùë°(0, 0, 150, 150);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëêùë¢ùëèùëú();

ùë°ùëüùëíùë£ùëú();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(110, 0);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí30, 0);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëé();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(30, 20);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùëíùëõùë°();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùëùùëíùëõùë°();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, ‚àí20);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 30);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(40, 60);

ùëùùëö();

ùëì ùëúùëüùëöùëé1();

ùëùùëíùëñùë•ùëí();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(10, 10);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí30, 20);

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë¶();

ùëì ùëúùëüùëöùëé3();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí30, 30);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 30);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(110, 40);

APENDICE AP√äNDICE C -- MOSAICO PARA CALEIDOSC√ìPIO.

178

ùëêùëéùëüùëüùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(110, 40);

ùëëùëíùëõùë°();

ùëîùëéùë°ùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí40, 40);

}

c) Constru√ß√£o da fun√ß√£o ùë£ùëúùëñùëë ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú na aba ‚Äútela‚Äù:

ùë£ùëúùëñùëë ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú(){

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

gem (350,350);

ùëüùëúùë°ùëéùë°ùëí(ùëé);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(‚àí1);

//Mosaico principal

//Simetria no eixo 0ùë¶;

ùëöùëúùë†ùëéùëñùëêùëú();

ùëöùëúùë†ùëéùëñùëêùëú();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(1, ‚àí1);

ùëöùëúùë†ùëéùëñùëêùëú();

//Simetria no eixo 0ùë•;

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùë†ùëêùëéùëôùëí(‚àí1, 1);

ùëöùëúùë†ùëéùëñùëêùëú();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

//Simetria em rela√ß√£o √† ori-

}

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Incremento para rota√ß√£o

do conjunto.

ùëé = ùëé + 0.001;

d) Constru√ß√£o do caleidosc√≥pio com implementa√ß√£o da fun√ß√£o ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú no interior

da fun√ß√£o ùë£ùëúùëñùëë ùëëùëüùëéùë§:

ùë£ùëúùëñùëë ùëëùëüùëéùë§(){

ùëèùëéùëêùëòùëîùëüùëúùë¢ùëõùëë(255);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Origem no centro da tela (350, 350);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(ùë§ùëñùëëùë°‚Ñé/2, ‚Ñéùëíùëñùëî‚Ñéùë°/2);

//Origem no ponto (350 ‚àí 300, 350 + 300);

ùëüùëúùë°ùëéùë°ùëí(ùëè);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí300, 300);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Origem no ponto (350 + 300, 350);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(300, 0);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

//Origem no ponto (350 + 300, 350 ‚àí 300);

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(300, ‚àí300);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Origem no ponto (350 ‚àí 300, 350);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí300, 0);

//Origem no ponto (350, 350 + 300);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, 300);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Origem no ponto (350 + 350, 350 + 350);

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(300, 300);

//Origem no ponto (350, 350 ‚àí 300);

APENDICE AP√äNDICE C -- MOSAICO PARA CALEIDOSC√ìPIO.

179

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(0, ‚àí300);

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

ùëùùë¢ùë†‚ÑéùëÄ ùëéùë°ùëüùëñùë•();

ùë°ùëíùëôùëéùëöùëúùë†ùëéùëñùëêùëú();

ùëùùëúùëùùëÄ ùëéùë°ùëüùëñùë•();

//Incremento para rota√ß√£o da tela do mo-

saico;

//Origem no ponto (350 ‚àí 300, 350 ‚àí 300);

ùëè = ùëè + 0.004;

ùë°ùëüùëéùëõùë†ùëôùëéùë°ùëí(‚àí300, ‚àí300);

}

Com isso, o mosaico que servir√° de suporte para nosso caleidosc√≥pio est√° completo

e pronto para iniciar seus movimentos.

