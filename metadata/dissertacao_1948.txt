Universidade Federal de Mato Grosso
Instituto de Ciˆencias Exatas e da Terra

Departamento de Matem´atica

Projeto e Constru¸c˜ao de um prot´otipo para plotagem

de gr´aﬁcos 2D utilizando a plataforma Arduino

Ludimila Gon¸calves Pereira

Mestrado Proﬁssional em Matem´atica: PROFMAT/SBM

Orientador: Prof. Dr. Adilson Antˆonio Berlatto

Barra do Gar¸cas - MT

julho de 2018

Projeto e constru¸c˜ao de um prot´otipo para plotagem
de gr´aﬁcos 2D utilizando a plataforma Arduino

Este exemplar corresponde `a reda¸c˜ao ﬁnal da dis-
serta¸c˜ao, devidamente corrigida e defendida por
Ludimila Gon¸calves Pereira e aprovada pela co-
miss˜ao julgadora.

Barra do Gar¸cas, 25 de julho de 2018.

Prof. Dr. Adilson Antˆonio Berlatto
Orientador

Banca examinadora:

Prof. Dr. Adilson Antˆonio Berlatto
Prof. Dr. Juan Elmer Villanueva Zevallos
Prof. Dr. Paulo C´esar Cavalcante de Oliveira

Disserta¸c˜ao apresentada ao curso de Mestrado
Proﬁssional em Matem´atica – PROFMAT, da Uni-
versidade Federal de Mato Grosso, como requisito
parcial para obten¸c˜ao do t´ıtulo de Mestre em
Matem´atica.

ii

Dados Internacionais de Catalogação na Fonte.  Ficha catalográfica elaborada automaticamente de acordo com os dados fornecidos pelo(a)autor(a). Permitida a reprodução parcial ou total, desde que citada a fonte.P436p    Pereira, Ludimila Gonçalves.Projeto e construção de um protótipo  para plotagem de gráficos2D utilizando a plataforma Arduino / Ludimila Gonçalves Pereira. --2018x, 59 f. : il. color. ; 30 cm.Orientador: Adilson Antônio Berlatto.Dissertação (mestrado profissional) - Universidade Federal deMato Grosso, Instituto de Ciências Exatas e da Terra, Programa dePós-Graduação em Matemática, Cuiabá, 2018.Inclui bibliografia.1. Ensino de Matemática. 2. Protótipo. 3. Ensino de funções. I.Título.iii

Resumo

Este trabalho trata da combina¸c˜ao multidisciplinar de uma ferramenta tecnol´ogica mo-

derna, acess´ıvel e de baixo custo com a matem´atica ensinada no ensino m´edio. Ele abor-

dar´a o projeto e manufatura¸c˜ao de um prot´otipo para plotagem, visualiza¸c˜ao e an´alise

de fun¸c˜oes em 2 dimens˜oes, desenvolvido com a utiliza¸c˜ao de componentes eletrˆonicos e a

plataforma Arduino. A proposta ´e capacitar e incentivar os educadores `a utilizar tal fer-

ramenta como suporte ao ensino da disciplina, incentivando os alunos `as ´areas correlatas

do prot´otipo e tamb´em colaborando para visualiza¸c˜ao de conceitos matem´aticos abstratos

e consequentemente contribuindo para o seu aprendizado.

Palavras chave: Ensino de matem´atica, prot´otipo, ensino de fun¸c˜oes.

iv

Abstract

This paper presents a multidisciplinary combination of a modern, accessible and low cost

technological tool with the math taught in high school. He will approach the design and

manufacture of a prototype to plotting, visualization and analysis of 2-D functions, deve-

loped using electronic components and Arduino. The proposal is to train and encourage

educators to use the tool like a support in the teach process, encouraging students to learn

about the correlate areas of the prototype and also collaborating their to visualization

abstract mathematical concepts.

Keywords: Mathematics teaching, prototype, functions teaching.

v

Sum´ario

Resumo

Abstract

Lista de ﬁguras

Lista de tabelas

Introdu¸c˜ao

1 Fun¸c˜oes, seus gr´aﬁcos e sua rela¸c˜ao com o c´alculo num´erico

1.1 Fun¸c˜oes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 Produto cartesiano . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.3 O Plano num´erico R2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

iv

v

ix

x

1

6

7

7

8

1.4 Fun¸c˜ao aﬁm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.5 Fun¸c˜ao polinomial

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

1.5.1 Trinˆomio de segundo grau (polinˆomio de grau 2) . . . . . . . . . . . 11

1.6 Fun¸c˜ao exponencial e logar´ıtmica . . . . . . . . . . . . . . . . . . . . . . . 13

1.7 C´alculo num´erico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

1.8 M´etodo de Newton-Raphson . . . . . . . . . . . . . . . . . . . . . . . . . . 16

1.8.1 Algoritmo do M´etodo de Newton-Raphson . . . . . . . . . . . . . . 18

1.9 M´etodo da Bissec¸c˜ao . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

1.9.1 Algoritmo do M´etodo da Bissec¸c˜ao . . . . . . . . . . . . . . . . . . 22

1.10 Considera¸c˜oes ﬁnais do cap´ıtulo . . . . . . . . . . . . . . . . . . . . . . . . 23

2 Arduino, componentes eletroeletrˆonicos e o prot´otipo

25

2.1 Arduino . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

vi

2.2 Componentes eletroeletrˆonicos . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.2.1 LEDs

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.2.2 Resistor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.2.3 LCD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

2.3 Prot´otipo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

2.4 Considera¸c˜oes ﬁnais do cap´ıtulo . . . . . . . . . . . . . . . . . . . . . . . . 36

3 Utilizando o prot´otipo

37

3.1 Prot´otipo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

3.2 Proposta de atividades para sala de aula . . . . . . . . . . . . . . . . . . . 39

4 Maxima

42

4.1 Considera¸c˜oes ﬁnais do cap´ıtulo . . . . . . . . . . . . . . . . . . . . . . . . 45

Considera¸c˜oes ﬁnais

Apˆendice: C´odigo do programa do prot´otipo

47

52

vii

Lista de Figuras

1.1 Ponto P do sistema de eixos OXY .

. . . . . . . . . . . . . . . . . . . . . .

9

1.2 Gr´aﬁco da fun¸c˜ao g, tal que g(x) = 2x + 3. . . . . . . . . . . . . . . . . . . 10

1.3 Gr´aﬁco de uma fun¸c˜ao quadr´atica. Com F indicando o foco, B o v´ertice e

o eixo “0X”a reta diretriz d.

. . . . . . . . . . . . . . . . . . . . . . . . . . 12

1.4 Gr´aﬁco da fun¸c˜ao f , tal que f (x) = x2 − 3x − 4. . . . . . . . . . . . . . . . 13

1.5 Curvas caracter´ısticas da fun¸c˜ao exponencial. . . . . . . . . . . . . . . . . . 13

1.6 Curvas caracter´ısticas da fun¸c˜ao logar´ıtmica. . . . . . . . . . . . . . . . . . 14

1.7 Gr´aﬁcos das fun¸c˜oes f e g, tal que f (x) = 3x e g(x) = log3x.

. . . . . . . . 15

1.8

Interpreta¸c˜ao geom´etrica do m´etodo de Newton-Raphson. . . . . . . . . . . 17

1.9 Gr´aﬁco das itera¸c˜oes realizadas para a fun¸c˜ao f , com as respectivas retas

tangentes em cada ponto da itera¸c˜ao e ponto de interse¸c˜ao entre elas (retas

tangentes) e a fun¸c˜ao f .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

1.10 M´etodo da Bissec¸c˜ao. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

1.11 Gr´aﬁco das itera¸c˜oes realizadas para a fun¸c˜ao f , com as respectivas apro-

xima¸c˜oes.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

2.1 Projetos constru´ıdos com Arduino.

. . . . . . . . . . . . . . . . . . . . . . 26

2.2 Placa do Arduino UNO.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

2.3 Tela do Arduino IDE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.4 S´ımbolo do LED, com 1 representando o anodo e 2 o catodo. . . . . . . . . 29

2.5 LED vermelho.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.6 S´ımbolo do resistor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.7 Resistor de ﬁlme pl´astico.

. . . . . . . . . . . . . . . . . . . . . . . . . . . 30

2.8 C´odigo de Cores. Fonte: AudioGroup (2017).

. . . . . . . . . . . . . . . . 30

2.9 Display LED 16x2.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

2.10 Push-button de 2 terminais.

. . . . . . . . . . . . . . . . . . . . . . . . . . 31

viii

2.11 Circuito de um das 12 teclas utilizadas no teclado. . . . . . . . . . . . . . . 32

2.12 Componentes do prot´otipo.

. . . . . . . . . . . . . . . . . . . . . . . . . . 32

2.13 Conex˜oes da matriz de LEDs.

. . . . . . . . . . . . . . . . . . . . . . . . . 33

2.14 Vis˜ao superior do painel manufaturado com todos os LEDs acesos. . . . . . 34

2.15 Circuito do teclado e liga¸c˜ao com o Arduino. . . . . . . . . . . . . . . . . . 35

2.16 Conex˜oes el´etricos necess´arias entre o LCD e o Arduino Mega.

. . . . . . . 35

2.17 Prot´otipo constru´ıdo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

3.1 Tra¸cado da fun¸c˜ao f , tal que f (x) = −x.

. . . . . . . . . . . . . . . . . . . 38

3.2 Tra¸cado da fun¸c˜ao f , tal que f (x) = x − 2. . . . . . . . . . . . . . . . . . . 39

3.3 Tra¸cado da fun¸c˜ao f , tal que f (x) = 4.

. . . . . . . . . . . . . . . . . . . . 39

4.1 M´etodo de Newton-Raphson para a fun¸c˜ao g, tal que g(x) = x3 − 5. . . . . 43

log(x)
x

4.2 M´etodo de Newton-Raphson para a fun¸c˜ao g, tal que g(x) =

+ 2x. . 43

4.3 M´etodo da Bissec¸c˜ao para a fun¸c˜ao f , tal que f (x) = x3 − 5. . . . . . . . . 44

4.4 M´etodo da Bissec¸c˜ao para a fun¸c˜ao g, tal que g(x) =

log(x)
x

+ 2x.

. . . . . 44

4.5 Exibe comando de plotagem de gr´aﬁco 2D e janela com o gr´aﬁco da fun¸c˜ao

f , tal que f (x) = x3 − 5.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

4.6 Exibe comando de plotagem de gr´aﬁco 2D e janela com o gr´aﬁco da fun¸c˜ao

g, tal que g(x) =

log(x)
x

+ 2x.

. . . . . . . . . . . . . . . . . . . . . . . . . 45

ix

Lista de Tabelas

1.1 Resultado do c´alculo das vari´aveis e fun¸c˜oes relacionadas ao M´etodo de

Newton-Raphson para encontrar zero da fun¸c˜ao f , tal que f (x) = x3 − 5.

. 17

1.2

Intervalos e aproxima¸c˜oes para as itera¸c˜oes do M´etodo da Bissec¸c˜ao para

encontrar zero da fun¸c˜ao f , tal que f (x) = x3 − 5. . . . . . . . . . . . . . . 21

x

Introdu¸c˜ao

As fun¸c˜oes matem´aticas est˜ao presentes em v´arios ramos das atividades huma-

nas, desde atividades rotineiras at´e estudos mais complexos em diversas ´areas do conhe-

cimento, como na f´ısica, qu´ımica, biologia, economia, etc. A disponibilidade de recursos

tecnol´ogicos e as transforma¸c˜oes nos padr˜oes de engajamento social e interativo dos ado-

lescentes est˜ao exigindo que as estrat´egias de ensino se modernizem, levando em conta o

desenvolvimento tecnol´ogico e o interesse individual atual, de forma que o estudo se torne

interessante e possa desenvolver habilidades multidisciplinares concomitantemente, como

eletrˆonica, programa¸c˜ao e a pr´opria matem´atica.

A Legisla¸c˜ao Educacional Brasileira, como forma de desenvolvimento cognitivo

aos alunos, inclui o uso das tecnologias na Lei de Diretrizes e Bases, n” 9394/96, e nos

Parˆametros Curriculares Nacionais, 2002, como forma de capacit´a-los para aquisi¸c˜ao e

o desenvolvimento de novas competˆencias, para que ele seja capaz de responder a novos

ritmos e processos, exigˆencias da vida social e proﬁssional moderna.

Nesse sentido, alguns estudiosos da educa¸c˜ao, exibem em seus trabalhos a fun¸c˜ao

do professor nesse processo. Segundo Bettega (2010), a tecnologia deve servir para enri-

quecer o ambiente educacional, propiciando a constru¸c˜ao de conhecimentos por meio de

uma atua¸c˜ao ativa, cr´ıtica e criativa por parte de alunos e professores. J´a Golbert (2002),

defende a ideia de que cabe ao professor ajudar os estudantes a adquirir as ferramentas

culturais que lhes possibilitem reﬂetir sobre suas pr´oprias intui¸c˜oes e experiˆencias e comu-

nic´a-las, articulando suas ideias, construindo compreens˜oes mais ricas. Isto signiﬁca que ´e

da competˆencia do professor encontrar os meios de transpor a distˆancia entre a linguagem

usual dos alunos e as disciplinas do ensino cl´assico.

Existem v´arios estudos que relaciona a utiliza¸c˜ao da computa¸c˜ao, eletrˆonica e

rob´otica educacional como ferramenta e meio de aprendizagem para todos os n´ıveis de

1

ensino. Rodarte (2014) traz em sua disserta¸c˜ao, as percep¸c˜oes que obteve com a uti-

liza¸c˜ao da rob´otica no ensino fundamental, mais especiﬁcamente no ensino de ˆangulos e

geometria plana, no 7” ano do Ensino Fundamental. Rodrigues (2015), em seu trabalho,

apresenta tamb´em os resultados obtidos com a utiliza¸c˜ao da plataforma LEGOﬁ numa

atividade desenvolvida para o ensino fundamental. Almeida (2017) exibe em seu trabalho

a plataforma Arduino e alguns exemplos pr´aticos de projetos que podem ser utilizados no

ensino da matem´atica.

Diante dessa realidade, idealizou-se um projeto de desenvolvimento de um prot´otipo

para utiliza¸c˜ao no ensino da matem´atica na educa¸c˜ao b´asica, mais especiﬁcamente para

o estudo de fun¸c˜oes. A pesquisa inclui o projeto e constru¸c˜ao de uma estrutura para

plotagem de gr´aﬁcos, ou seja, visualiza¸c˜ao de um gr´aﬁco, por meio de um painel formado

por LEDs, o qual se tem o controle pontual do acendimento de cada LED, que representa

um valor deﬁnido em rela¸c˜ao aos dois eixos cartesianos, ou seja, cada LED representar´a

uma coordenada no gr´aﬁco.

Al´em do painel de LEDs, o prot´otipo ´e formado tamb´em por uma IHM (Interface

Homem-M´aquina), ferramenta que possibilitar´a que o usu´ario insira a fun¸c˜ao desejada

num teclado, e em seguida poder´a visualizar o tra¸cado da fun¸c˜ao no painel e algumas

informa¸c˜oes sobre ela em um pequeno display.

O documento ´e instrutivo para constru¸c˜ao e programa¸c˜ao do prot´otipo, que pode

ser desenvolvido por alunos e/ou professores para montagem, exibi¸c˜ao e utiliza¸c˜ao em sala

de aula, bem como para participa¸c˜ao em feiras tecnol´ogicas.

O desenvolvimento de ferramentas tecnol´ogicas para o ensino al´em de auxiliar

o aprendizado do aluno, possibilita `a eles a participa¸c˜ao em eventos nacionais e/ou in-

ternacionais como a Campus Party, que ´e o principal evento de internet e tecnologia

do pa´ıs. Ela ocorre no Brasil desde 2008 e ´e respons´avel por divulgar as tecnologias

mais avan¸cadas, assim como suas aplica¸c˜oes nos campos da Educa¸c˜ao, da Economia, do

Trabalho e da Cultura Digital. Ao longo do evento s˜ao realizadas palestras, debates, com-

peti¸c˜oes e oﬁcinas que permitem que os frequentadores consigam interagir, compartilhar

conhecimento, produzir novidades e acompanhar as principais tendˆencias da atualidade

(Campus Party, 2018, ver).

Ou ainda capacitam tamb´em os alunos a participarem da FEBRACE (Feira Bra-

sileira de Ciˆencias e Engenharia), um movimento nacional de est´ımulo ao jovem cientista,

2

que ocorre no Brasil desde 2003, com intuito de estimular uma cultura investigativa, de

criatividade, inova¸c˜ao e empreendedorismo na Educa¸c˜ao B´asica brasileira, por meio da

indu¸c˜ao `a realiza¸c˜ao de projetos e mostras cient´ıﬁcas e tecnol´ogicas nas escolas. Podem

submeter projetos para a FEBRACE estudantes que estejam cursando o 8(cid:176) ou 9(cid:176) Ano do

Ensino Fundamental, Ensino M´edio ou o Ensino T´ecnico (FEBRACE, 2018, ver).

Al´em de medalhas e trof´eus para os melhores ﬁnalistas de cada categoria, os

estudantes tamb´em podem receber equipamentos, certiﬁcados de diversas organiza¸c˜oes

em v´arias ´areas cient´ıﬁcas e algumas empresas, e demais prˆemios concedidos com apoio

de parcerias com a iniciativa privada.

A FEBRACE concede medalhas e trof´eu para os destaques nas seguintes cate-

gorias: Ciˆencias Agr´arias, Ciˆencias Biol´ogicas, Ciˆencias da Sa´ude, Ciˆencias Exatas e da

Terra, Ciˆencias Humanas, Ciˆencias Sociais Aplicadas, Engenharia. Tamb´em recebem des-

taque os melhores ﬁnalistas em Vota¸c˜ao Popular, Destaque em Criatividade, Destaque em

Inova¸c˜ao, Destaque em Relevˆancia Social, Destaque em Rigor Cient´ıﬁco e Destaque em

Empreendedorismo. A premia¸c˜ao da FEBRACE tamb´em concede o credenciamento para

participa¸c˜ao como ﬁnalista em outras feiras.

A rob´otica educacional permite tamb´em a participa¸c˜ao na OBR (Olimp´ıada Bra-

sileira de Rob´otica), que tem duas modalidades independentes: te´orica e pr´atica, e destina-

se a todos os estudantes de qualquer escola, p´ublica ou privada, do ensino fundamental,

m´edio ou t´ecnico em todo o territ´orio nacional (OBR, 2018, ver).

A OBR tem o objetivo de estimular os jovens `as carreiras cient´ıﬁco-tecnol´ogicas,

identiﬁcar jovens talentosos e promover debates e atualiza¸c˜oes no processo de ensino-

aprendizagem brasileiro. Ela ocorre desde 2006 e atualmente ´e considerado o maior evento

de rob´otica da Am´erica Latina e classiﬁca equipes para a RoboCup, maior evento de

rob´otica do mundo.

O evento procura adequar-se tanto ao p´ublico que nunca viu rob´otica quanto ao

p´ublico de escolas que j´a tˆem contato com a rob´otica educacional. As atividades acontecem

atrav´es de competi¸c˜oes pr´aticas (com robˆos) e provas te´oricas em todo o Brasil. A prova

te´orica n˜ao exige do aluno o conhecimento espec´ıﬁco de rob´otica. Na primeira fase, as

provas s˜ao feitas na escola de cada estudante inscrito e as quest˜oes v˜ao envolver problemas

pr´aticos do dia a dia a partir da rob´otica. J´a a pr´atica traz um desaﬁo: equipes de at´e

quatro alunos ter˜ao que construir um robˆo totalmente autˆonomo, ou seja, sem controle

3

remoto, e que seja capaz de navegar por um terreno acidentado, localizar v´ıtimas e resgat´a-

las. Os inscritos nessa modalidade ter˜ao que participar de eventos regionais e, de acordo

com sua pontua¸c˜ao, se classiﬁcar˜ao `as etapas estaduais e `a ﬁnal nacional.

H´a tamb´em eventos internacionais que os alunos poder˜ao competir como a LARC

(Competi¸c˜ao Latino Americana de Robˆos), IEEE (Competi¸c˜ao Latino Americana de

Rob´otica), WRE (Workshop de Rob´otica na Educa¸c˜ao), WRO (World Robot Olympiad ),

RoboCup, entre outros eventos e feiras locais, estaduais e internacionais de rob´otica e/ou

ensino.

Alguns exemplos de participa¸c˜ao e premia¸c˜ao nesses eventos s˜ao listados a seguir:

– o trabalho “A rob´otica educacional como intersec¸c˜ao entre as disciplinas t´ecnicas

do curso de inform´atica”que ﬁcou em 3” lugar geral na Febrace 2015 (IFRN, 2015,

ver).

– O Certiﬁcado de Excelˆencia recebido por alunos do PRONATEC, no Jap˜ao, em 2015,

devido ao trabalho de rob´otica apresentado no pa´ıs sobre o servi¸co de tratamento

m´edico infantil (Brasil, 2015, ver).

– Medalha de ouro conquistada pelo estudante de 10 anos na “K*Bot World Cham-

pionship”, realizada nos EUA em 2017 (Porto, 2017, ver).

As oportunidades de exposi¸c˜ao, competi¸c˜ao e compartilhamento de informa¸c˜oes

s˜ao diversas, j´a existem diversos eventos consolidados em todo o mundo, o incentivo `a

participa¸c˜ao ´e de fundamental importˆancia para o desenvolvimento do esp´ırito de pesqui-

sador dos alunos ainda no ensino b´asico, para que eles se sintam motivados `a participarem

dos eventos e produzirem materiais e conte´udos que contribuam para o seu aprendizado

e crescimento da ciˆencia no pa´ıs.

Posto isso, o objetivo desse documento ´e a capacita¸c˜ao e o incentivo de professores

e/ou alunos para o desenvolvimento e utiliza¸c˜ao de ferramentas tecnol´ogicas no ensino, seja

ela replica¸c˜ao desse prot´otipo ou desenvolvimento de outros mais amplos ou diferenciados,

contribuindo para o ensino da matem´atica e tamb´em contribuindo para a participa¸c˜ao em

eventos, feiras, mostras e competi¸c˜oes tecnol´ogicas.

Al´em do detalhamento do prot´otipo, este trabalho d´a um ponta-p´e inicial para o

desenvolvimento de prot´otipos para estudo de fun¸c˜oes mais complexas: s˜ao mostrados os

principais m´etodos num´ericos para c´alculo de ra´ız(es) de fun¸c˜oes n˜ao lineares e tamb´em

4

seus algoritmos. Foram desenvolvidos os c´odigos dos m´etodos estudados no software Ma-

xima, no qual se pode observar e calcular ra´ızes de fun¸c˜oes e o tra¸cado de seus respectivos

gr´aﬁcos.

Num trabalho mais amplo, tais m´etodos poder˜ao ser aliados `a plataforma Arduino

para desenvolvimento de um prot´otipo que comporte mais “pixels”, ou seja, tenha mais

LEDs, e possa exibir com uma resolu¸c˜ao maior os variados tipos de curvas e que tamb´em

resolva os mais variados tipos de fun¸c˜oes.

Para exposi¸c˜ao da proposta desse trabalho, ele foi dividido em introdu¸c˜ao, trˆes

cap´ıtulos e considera¸c˜oes. No primeiro cap´ıtulo dessa disserta¸c˜ao ser´a apresentada fun¸c˜oes

e caracter´ısticas dos seus respectivos gr´aﬁcos; trar´a tamb´em os m´etodos num´ericos uti-

lizados para encontrar zero(s) de fun¸c˜oes, m´etodos que podem ser implementados para

estudos de fun¸c˜oes n˜ao lineares. J´a no segundo cap´ıtulo ser´a apresentada a plataforma Ar-

duino e suas especiﬁcidades, os componentes eletrˆonicos utilizados e seu funcionamento,

e tamb´em ser´a detalhada a manufatura¸c˜ao e programa¸c˜ao do prot´otipo. No terceiro

cap´ıtulo ser˜ao exibidos os resultados obtidos com a utiliza¸c˜ao do prot´otipo e no quarto

cap´ıtulo os resultados obtidos com a utiliza¸c˜ao de m´etodos num´ericos para estudo estudo

de fun¸c˜oes no software Maxima; por ﬁm as considera¸c˜oes ﬁnais do presente trabalho.

5

Cap´ıtulo 1

Fun¸c˜oes, seus gr´aﬁcos e sua rela¸c˜ao

com o c´alculo num´erico

O conceito de fun¸c˜ao est´a relacionado `a ideia de associa¸c˜ao de um elemento a ou-

tro, segundo uma regra espec´ıﬁca. Assim, por exemplo, podemos considerar o tamanho de

uma popula¸c˜ao variando em fun¸c˜ao do tempo, ou associado ao tempo e a sua localiza¸c˜ao,

ou a qualquer outro fator que interﬁra na popula¸c˜ao em estudo; o pre¸co de um produto

pode estar associado apenas ao seu custo de produ¸c˜ao, ou ao seu custo e demanda, ou

ainda, ao seu custo, `a demanda e outros fatores; e assim por diante.

J´a o gr´aﬁco de uma fun¸c˜ao real descreve uma curva no plano, a qual representa

o seu comportamento e facilita muito o seu entendimento. Ele nos d´a uma imagem

proveitosa da “hist´oria de vida”de uma fun¸c˜ao. Uma vez que a coordenada y de qualquer

ponto (x, y) sobre o gr´aﬁco ´e y = f (x), por exemplo, se os valores de f (x) s˜ao n˜ao

negativos para todo x no dom´ınio de f , podemos entender o valor de f (x) como a altura

do ponto no gr´aﬁco acima de x. O gr´aﬁco de f nos permite visualizar o dom´ınio sobre
o eixo x e a imagem sobre o eixo y. ´E, portanto, uma ferramenta b´asica no estudo de

c´alculo e outras disciplinas da matem´atica.

C´alculo n´umerico ´e a disciplina, tradicionalmente vista no ensino superior, que

estuda as t´ecnicas para a solu¸c˜ao aproximada de problemas matem´aticos. Estas t´ecnicas

s˜ao de natureza anal´ıtica e computacional.

Devido, principalmente, ao aumento cont´ınuo da capacidade e velocidade de pro-

cessamento das m´aquinas, o desenvolvimento de m´etodos n´umericos tornou a simula¸c˜ao

computacional de problemas matem´aticos uma pr´atica usual nas mais diversas ´areas ci-

6

ent´ıﬁcas e tecnol´ogicas.

S˜ao utilizados para resolver problemas espec´ıﬁcos como, por exemplo: resolver

equa¸c˜oes alg´ebricas, resolver sistemas de equa¸c˜oes lineares, interpolar e ajustar pontos,

calcular derivadas e integrais, resolver equa¸c˜oes diferenciais ordin´arias, etc.

Neste trabalho, ser´a apresentado o M´etodo de Newton-Raphson e de Bissec¸c˜ao,

para encontrar ra´ız(es) de fun¸c˜oes n˜ao lineares, complementando assim o estudo de fun¸c˜oes

e de seus gr´aﬁcos.

Foram utilizados como referenciais bibliogr´aﬁcos para escrita desse cap´ıtulo os

seguintes autores: Lima (2013), Guidorizzi (2013) e Stewart (2013).

1.1 Fun¸c˜oes

Segundo Guidorizzi (2013), uma fun¸c˜ao f ´e uma terna (A, B, a (cid:55)→ b), em que A

e B s˜ao dois conjuntos e a (cid:55)→ b uma regra que nos permite associar a cada elemento a de

A, um ´unico b de B. O conjunto A ´e o dom´ınio de f e indica-se por Df , assim A = Df .

O conjunto B ´e o contradom´ınio de f . O ´unico b de B associado ao elemento a de A ´e

indicado por f (a); dizemos que f (a) ´e o valor que f assume em a ou que f (a) ´e o valor

que f associa a a. A imagem de f ´e o conjunto de todos os valores poss´ıveis de f (x)

quando x varia por todo o dom´ınio.

Segundo Stewart (2013), podemos representar uma fun¸c˜ao de quatro maneiras

diferentes: por uma equa¸c˜ao, por uma tabela, por um gr´aﬁco ou mesmo por meio de

palavras. Sendo que a equa¸c˜ao matem´atica e o gr´aﬁco s˜ao as formas mais utilizadas no

estudo matem´atico.

1.2 Produto cartesiano

Um par ordenado p = (x, y) ´e formado por um objeto x, chamado a primeira

coordenada de p e um objeto y, chamado a segunda coordenada de p. Dois pares ordenados

p = (x, y) e q = (u, v) ser˜ao chamados iguais quando x = u e y = v, isto ´e, quando tiverem

a mesma primeira coordenada e a mesma segunda coordenada. O produto cartesiano X×Y

de dois conjuntos X e Y ´e o conjunto X × Y formado por todos os pares ordenados (x, y)

7

cuja primeira coordenada x pertence a X e cuja segunda coordenada y pertence a Y .

Simbolicamente:

X × Y = {(x, y); x ∈ X, y ∈ Y }.

Segundo Lima (2013), se X = {x1, . . . , xm} e Y = {y1, . . . , yp} s˜ao conjuntos

ﬁnitos com m e p elementos respectivamente, ent˜ao o produto cartesiano X × Y ´e ﬁnito e

possui mp elementos. Noutras palavras n(X × Y ) = n(X).n(Y ), com n(X) representando

o n´umero de elementos pertencentes a X e n(Y ) o n´umero de elementos pertencentes a

Y . A melhor maneira de enxergar isto ´e pensar no produto cartesiano X × Y como um

quadrado retangular

(x1, y1)(x1, y2) . . . (x1, yp)

(x2, y1)(x2, y2) . . . (x2, yp)
...
(xm, y1)(xm, y2) . . . (xm, yp).

com p colunas, cada uma das quais possui m elementos.

O produto cartesiano X ×Y acha-se intimamente ligado `a ideia de rela¸c˜ao bin´aria.

Uma rela¸c˜ao (bin´aria) R entre elementos do conjunto X e elementos do conjunto Y ´e uma

condi¸c˜ao ou um conjunto de condi¸c˜oes que permitem determinar, dados x ∈ X e y ∈ Y ,

se x est´a ou n˜ao relacionado com y segundo R. No caso aﬁrmativo, escreve-se xRy.

Um caso particularmente importante no estudo de fun¸c˜oes ´e a rela¸c˜ao funcional.

Ela ocorre quando se tem uma fun¸c˜ao f : X → Y . Diz-se ent˜ao que o elemento x ∈ X

est´a relacionado com o elemento y ∈ Y quando y = f (x). Neste caso, n˜ao se costuma

escrever xf y como se faria numa outra rela¸c˜ao qualquer. P˜oe-se apenas y = f (x).

O gr´aﬁco de uma rela¸c˜ao R entre dois conjuntos X e Y ´e o subconjunto G(R)

do produto cartesiano X × Y formado pelos pares (x, y) tais que xRy. Assim, G(R) =

{(x, y) ∈ X × Y ; xRy}.

1.3 O Plano num´erico R2

Um dos exemplos mais importantes de produto cartesiano ´e o R2 = R × R. Os

elementos (x, y) de R2 s˜ao os pares ordenados de n´umeros reais. Eles surgem como as

coordenadas cartesianas de um ponto P do plano Π (x = abcissa, y = ordenada) quando

8

se ﬁxa nesse plano um par de eixos ortogonais OX e OY , que se intersectam no ponto O,

chamado a origem do sistema de coordenadas.

Dado o ponto P ∈ Π, a abcissa de P ´e o n´umero x, coordenada do p´e da

perpendicular baixada de P sobre o eixo OX, enquanto a ordenada de P ´e a coordenada

y do p´e da perpendicular baixada de P sobre o eixo OY . Diz ent˜ao que (x, y) ´e o par de

coordenadas do ponto P relativamente ao sistema de eixos OXY . A Figura 1.1 ilustra

graﬁcamente o ponto P .

Figura 1.1: Ponto P do sistema de eixos OXY .

Os eixos OX e OY dividem o plano em quatro regi˜oes, chamadas de quadrantes,

que s˜ao numeradas no sentido anti-hor´ario e come¸ca pela regi˜ao do espa¸co com x ≥ 0

e y ≥ 0. Dessa forma, temos que o primeiro quadrante ´e formado pelos pontos cujas

coordenadas apresentam x ≥ 0 e y ≥ 0; o segundo quadrante x ≤ 0 e y ≥ 0; o terceiro

quadrante x ≤ 0 e y ≤ 0 e o quarto quadrante x ≥ 0 e y ≤ 0.

A fun¸c˜ao f : Π → R2, que associa a cada ponto P do plano Π seu par de coor-

denadas f (P ) = (x, y) relativamente ao sistema de eixos OXY , ´e uma correspondˆencia

biun´ıvoca. Ela permite traduzir conceitos e propriedades geom´etricas para uma linguagem

alg´ebrica e, reciprocamente, interpretar geometricamente rela¸c˜oes entre n´umeros reais.

Podemos ent˜ao dizer que R2 ´e o modelo aritm´etico do plano Π enquanto Π ´e o modelo

geom´etrico de R2.

9

1.4 Fun¸c˜ao aﬁm

Uma fun¸c˜ao f : R → R chama-se aﬁm quando existem constantes a, b ∈ R tais

que f (x) = ax+b para todo x ∈ R. O gr´aﬁco da fun¸c˜ao aﬁm com dom´ınio e contradom´ınio

em R ´e uma reta com taxa de varia¸c˜ao igual a a e que intercepta os eixos cordenados X

e Y nos pontos

, 0

e (0, b), respectivamente.

(cid:19)

(cid:18) −b
a

Quando b = 0, a fun¸c˜ao ´e chamada linear e ´e o modelo matem´atico para os

problemas de proporcionalidade. Uma proporcionalidade ´e uma fun¸c˜ao f : R → R tal

que, para quaisquer n´umeros reais c,x tem-se f (cx) = cf (x) (proporcionalidade direta)

ou f (cx) =

, se c (cid:54)= 0 (proporcionalidade inversa).

f (x)
c

J´a quando a = 0, a fun¸c˜ao ´e chamada de fun¸c˜ao constante, da´ı, a fun¸c˜ao f : R →

R ´e tal que, para qualquer real b, x tem-se f (x) = b.

´E poss´ıvel ainda determinar se uma fun¸c˜ao ´e aﬁm, sem que os coeﬁcientes a e b

sejam fornecidos explicitamente. Nesse caso, obt´em-se b como o valor que a fun¸c˜ao dada

assume quando x = 0. O n´umero b = f (0) `as vezes se chama o valor inicial da fun¸c˜ao f .

Quanto ao coeﬁciente a, ele pode ser determinado a partir do conhecimento dos valores

f (x1) e f (x2) que a fun¸c˜ao f assume em dois pontos distintos e arbitr´arios x1 e x2.

no ponto

Vamos analisar a fun¸c˜ao g(x) = 2x + 3. Temos que a fun¸c˜ao intercepta o eixo X
(cid:18) −3
2

e o eixo Y no ponto (0, 3). O que nos fornece o gr´aﬁco mostrado na

, 0

(cid:19)

Figura 1.2.

Figura 1.2: Gr´aﬁco da fun¸c˜ao g, tal que g(x) = 2x + 3.

10

1.5 Fun¸c˜ao polinomial

Uma fun¸c˜ao p : R → R ´e chamada de polinomial quando s˜ao dados n´umeros reais

a0, a1, . . . , an tais que, para todo x ∈ R , temos

p(x) = anxn + an−1xn−1 + . . . + a1x + a0.

Se an (cid:54)= 0, dizemos que p tem grau n.

Segundo Stewart (2013), os polinˆomios s˜ao usados comumente para modelar

v´arias quantidades que ocorrem em ciˆencias sociais e naturais. Um exemplo ´e a uti-

liza¸c˜ao, por parte dos economistas, de polinˆomio para representar o custo na produ¸c˜ao de

x unidades de um produto.

Os m´etodos que se usam atualmente para determinar uma raiz do polinˆomio p

localizada no intervalo [a, b] quando se sabe que p(a) e p(b) tˆem sinais opostos baseiam-se

em algoritmos aproximativos, os quais instruem, passo a passo, como proceder para obter

uma sequˆencia de n´umeros x1, x2, . . . , xn tais que os valores p(x1), p(x2), . . . , p(xn) est˜ao

cada vez mais pr´oximos de zero.

1.5.1 Trinˆomio de segundo grau (polinˆomio de grau 2)

Uma fun¸c˜ao f : R → R, de n´umeros reais a, b, c, com a (cid:54)= 0, tais que f (x) =

ax2 + bx + c para todo x ∈ R ´e o trinˆomio de segundo grau, tamb´em chamado de fun¸c˜ao

quadr´atica, ou somente polinˆomio de grau dois. O gr´aﬁco de uma fun¸c˜ao quadr´atica ´e

uma par´abola que abre-se para cima se a > 0 e para baixo quando a < 0.

Dados um ponto F e uma reta d que n˜ao o cont´em, a par´abola de foco F e diretriz

d ´e conjunto de pontos do plano que distam igualmente de F e de d. A reta perpendicular

`a diretriz, baixada a partir do foco, chama-se o eixo da par´abola. O ponto da par´abola

mais pr´oximo da diretriz chama-se o v´ertice dessa par´abola. Ele ´e o ponto m´edio do

segmento cujas extremidades s˜ao o foco e a interse¸c˜ao do eixo com a diretriz. A Figura

1.3 ilustra graﬁcamente a fun¸c˜ao quadr´atica e os parˆametros supramencionados.

11

Figura 1.3: Gr´aﬁco de uma fun¸c˜ao quadr´atica. Com F indicando o foco, B o v´ertice e o
eixo “0X”a reta diretriz d.

Temos que o ponto do gr´aﬁco de f (x) = ax2 + bx + c mais pr´oximo da diretriz ´e

aquele de abcissa

−b
2a

m´aximo quando a < 0. Ainda quando x =

que constitui o gr´aﬁco de f .

. Nesse ponto, f atinge seu valor m´ınimo quando a > 0 e seu valor

−b
2a

, o ponto (x, f (x)) ´e o v´ertice da par´abola

O gr´aﬁco da fun¸c˜ao quadr´atica ´e um elemento de grande importˆancia para en-

tender o comportamento dessa fun¸c˜ao. As abcissas x1, x2 dos pontos onde esse gr´aﬁco

intersecta o eixo 0X s˜ao as ra´ızes do trinˆomio.

O ponto m´edio do segmento [x1, x2] ´e a abcissa do v´ertice da par´abola. Se o

gr´aﬁco est´a inteiramente acima, ou inteiramente abaixo do eixo 0X, a equa¸c˜ao n˜ao possui

ra´ızes. Se o gr´aﬁco apenas tangencia o eixo 0X, a equa¸c˜ao tem uma raiz ´unica. Se

x1 < x < x2 ent˜ao f (x) tem sinal contr´ario ao sinal de a; se x < x1 ou x > x2, f (x) tem

o mesmo sinal de a.

Vamos analisar a fun¸c˜ao f , tal que f (x) = x2 − 3x − 4. Como a > 0, a par´abola

apresentar´a sua concavidade voltada para cima, e a fun¸c˜ao apresenta ra´ızes iguais a −1 e 4.

Temos ainda que seu valor m´ınimo ´e x =

3
2

, o v´ertice da par´abola ´e o ponto (1, 5; −6, 25),

e temos tamb´em que sua fun¸c˜ao cortar´a o eixo Y no ponto (0, −4). A Figura 1.4 ilustra

o gr´aﬁco dessa fun¸c˜ao.

12

Figura 1.4: Gr´aﬁco da fun¸c˜ao f , tal que f (x) = x2 − 3x − 4.

1.6 Fun¸c˜ao exponencial e logar´ıtmica

Seja a um n´umero real positivo e a (cid:54)= 1. A fun¸c˜ao f : R → R+, dada por

f (x) = ax, ´e chamada de fun¸c˜ao exponencial de base a.

Os gr´aﬁcos dessa fun¸c˜ao apresentam os tra¸cados apresentados na Figura 1.5.

(a) para a > 1

(b) para 1 < a < 0

Figura 1.5: Curvas caracter´ısticas da fun¸c˜ao exponencial.

A fun¸c˜ao exponencial mais comum em aplica¸c˜oes ´e a fun¸c˜ao exponencial de base

a = e, onde e ´e a constante de Euler. A fun¸c˜ao, nesse caso, ´e chamada de fun¸c˜ao expo-

nencial natural ou, simplesmente fun¸c˜ao exponencial. Ela tamb´em pode ser representada

na nota¸c˜ao

13

f (x) = ex.

A fun¸c˜ao exponencial de base a, deﬁnida anteriormente, admite uma fun¸c˜ao in-

versa g chamada de fun¸c˜ao logar´ıtmica na base a. Portanto, g : R+ → R. A regra de

associa¸c˜ao desta fun¸c˜ao ´e representada como g(x) = logax.

Como as fun¸c˜oes exponencial e logar´ıtmica (ambas de base a) s˜ao inversas uma

da outra, segue pela deﬁni¸c˜ao de fun¸c˜ao inversa que

alogax = x, para todo x ∈ R+

e
loga(ax) = x, para todo x ∈ R.

Sendo assim, tomando x = 0 e x = 1, obteremos loga1 = 0 e logaa = 1.

Seu gr´aﬁco ´e a reﬂex˜ao do gr´aﬁco de y = ax em torno da reta y = x. As suas

curvas caracter´ısticas s˜ao mostradas na Figura 1.6.

(a) para a > 1

(b) para 1 < a < 0

Figura 1.6: Curvas caracter´ısticas da fun¸c˜ao logar´ıtmica.

A fun¸c˜ao inversa da exponencial natural ´e o logaritmo natural, ele pode ser re-

presentado da seguinte forma

logex = lnx.

Em particular, se ﬁzermos x = 1, obteremos lne = 1.

Vamos analisar a fun¸c˜ao exponencial f , tal que f (x) = 3x e a fun¸c˜ao logar´ıtmica

g, tal que g(x) = log3x. Temos que g ´e a inversa da fun¸c˜ao f , portanto, temos que seu

14

tra¸cado ´e a reﬂex˜ao do gr´aﬁco de f em torno da reta y = x. A Figura 1.7 ilustra o gr´aﬁco

de ambas as fun¸c˜oes.

Figura 1.7: Gr´aﬁcos das fun¸c˜oes f e g, tal que f (x) = 3x e g(x) = log3x.

1.7 C´alculo num´erico

Os m´etodos num´ericos quando implementados numa l´ogica computacional se mos-

tram eﬁcientes no c´alculo das raizes devido `a velocidade de opera¸c˜ao das m´aquinas, con-

seguindo realizar v´arias itera¸c˜oes num curto intervalo de tempo. Com isso, conseguimos

obter ra´ız(es) aproximadas de fun¸c˜oes n˜ao lineares com erros muito pequenos.

Quando a fun¸c˜ao ´e polinomial, de primeiro grau, o problema de encontrar zeros

dessa fun¸c˜ao se reduz a encontrar as ra´ızes da equa¸c˜ao f (x) = ax + b = 0. Tradicio-

nalmente, nesses casos, os estudantes aprendem a manipular algebricamente a equa¸c˜ao,

utilizando o algoritmo de isolar a inc´ognita. Da´ı obtemos que o zero da fun¸c˜ao ser´a:

x =

−b
a

,

desde que a (cid:54)= 0.

J´a para as fun¸c˜oes polinomiais de segundo grau, um dos m´etodos ´e a utiliza¸c˜ao

da chamada “F´ormula de Bhaskara”. Se f : R → R ´e tal que f (x) = ax2 + bx + c, com

a (cid:54)= 0, ent˜ao os zeros da fun¸c˜ao ser˜ao:

−b ±

x =

√

b2 − 4ac
2a

,

15

desde que b2 − 4ac ≥ 0.

Para as demais fun¸c˜oes n˜ao lineares, encontrar as suas ra´ızes se torna mais com-

plexo. Nesse sentido, os m´etodos n´umericos oferecem recursos com os quais podemos nos

aproximar da solu¸c˜ao desejada.

1.8 M´etodo de Newton-Raphson

A ﬁm de tornar o entendimento do m´etodo simples, at´e mesmo para o Ensino

B´asico, esse trabalho se ateve somente ao entendimento gr´aﬁco do m´etodo. Para isso, o

M´etodo de Newton-Raphson, trabalha de forma iterativa, na busca do ponto de interse¸c˜ao

entre o gr´aﬁco de uma fun¸c˜ao f : R → R e a reta das abscissas (y = 0).

Antes de apresentar o m´etodo propriamente dito, precisamos conhecer o conceito

de derivada de uma fun¸c˜ao. A derivada est´a intimamente relacionado `a taxa de varia¸c˜ao

instantˆanea de uma fun¸c˜ao. Se uma fun¸c˜ao f ´e deﬁnida em um intervalo aberto contendo

x0, ent˜ao a derivada de f em x0 denotada por f (cid:48)(x0), ´e dada por

f (cid:48)(x0) = lim∆→0

f (x0 + ∆x) − f (x0)
∆x

.

se esse limite existir, com ∆x representando uma pequena varia¸c˜ao em x, pr´oximo de x0.

A ideia geral do m´etodo ´e produzir, a partir de uma aproxima¸c˜ao inicial conhecida

(x0) e uma precis˜ao (cid:15), uma sequˆencia de valores que convirja para a solu¸c˜ao do problema.

Temos que a equa¸c˜ao da reta tangente ao gr´aﬁco da fun¸c˜ao f no ponto (x0,f (x0)),

tem o coeﬁciente angular igual a f (cid:48)(x0), e ´e dada por:

y − f (x0) = f (cid:48)(x0).(x − x0)

Sabendo que essa reta passa por (x1, 0), temos que

0 − f (x0) = f (cid:48)(x0).(x1 − x0).

Portanto,

De modo geral, temos

x1 = x0 −

f (x0)
f (cid:48)(x0)

.

xi+1 = xi −

f (xi)
f (cid:48)(xi)

.

16

Ou seja, dada aproxima¸c˜ao xi, a pr´oxima aproxima¸c˜ao xi+1 ´e o ponto de interse¸c˜ao

entre o eixo das abscissas (y = 0) e a reta tangente (y) ao gr´aﬁco da fun¸c˜ao f no ponto

x = xi.

As itera¸c˜oes ocorrer˜ao at´e que | xi+1 − xi |< (cid:15) , ou seja, at´e f (xi) se aproxime de

y = 0 o quanto se desejar. A Figura 1.8 mostra a interpreta¸c˜ao geom´etrica do m´etodo.

Figura 1.8: Interpreta¸c˜ao geom´etrica do m´etodo de Newton-Raphson.

Vamos utilizar o m´etodo para encontrar as ra´ızes da fun¸c˜ao f : R → R, tal que

f (x) = x3 − 5, com precis˜ao de (cid:15) = 10−3 e utilizando o valor inicial de x0 = 1.

Calculou-se cada ponto (xi, f (xi)), o coeﬁciente angular da reta tangente (f (cid:48)(x))

em cada ponto xi e em seguida a reta tangente, determinando assim, sucessivamente, a

aproxima¸c˜ao xi+1, at´e obtermos o mais pr´oximo que se desejar f (xi) de y = 0, ou seja,

| xi+1 − xi |< (cid:15).

A Tabela 1.1 mostra os resultados obtidos para a fun¸c˜ao f e a Figura 1.9 exibe

o Gr´aﬁco das Itera¸c˜oes, com as fun¸c˜oes e pontos de interesses destacados.

Tabela 1.1: Resultado do c´alculo das vari´aveis e fun¸c˜oes relacionadas ao M´etodo de
Newton-Raphson para encontrar zero da fun¸c˜ao f , tal que f (x) = x3 − 5.

i

0
1
2
3
4
5

(xi, f (xi))

f (cid:48)(xi) = 3x2
i

y − f (xi) = f (cid:48)(xi).(x − xi) xi+1 = xi −

(1;-4)
(2,3333;7,7032)
(1,8617;1,4525)
(1,7220;0,1062)
(1,7101;0,0011)
(1,7100;0,0002)

3
16,3329
10,3978
8,8958
8,7733
8,7723

y0 = 3x − 7
y1 = 16, 3329x − 30, 4064
y2 = 10, 3978x − 17, 9051
y3 = 8, 8958x − 15, 2124
y4 = 8, 7733x − 14, 9922
y5 = 8, 7723x − 15, 0008

f (xi)
f (cid:48)(xi)
2,3333
1,8617
1,7220
1,7101
1,7100
1,7100

17

Figura 1.9: Gr´aﬁco das itera¸c˜oes realizadas para a fun¸c˜ao f , com as respectivas retas
tangentes em cada ponto da itera¸c˜ao e ponto de interse¸c˜ao entre elas (retas tangentes) e
a fun¸c˜ao f .

Como | x5 − x4 |= 0, 0001 < (cid:15), a itera¸c˜ao para e temos que x ∼= x5 = 1, 7100.

1.8.1 Algoritmo do M´etodo de Newton-Raphson

O algoritmo do m´etodo de Newton-Raphson, para encontrar zero(s) de fun¸c˜oes,

ser´a da seguinte forma: primeiro ser´a fornecido a fun¸c˜ao f , uma aproxima¸c˜ao inicial

“x0”; a precis˜ao “(cid:15)”; e n´umero m´aximo de itera¸c˜oes “nmax”e o programa fornecer´a como

sa´ıda uma solu¸c˜ao aproximada ou uma mensagem de erro. A l´ogica de programa¸c˜ao para

implementa¸c˜ao do m´etodo segue o passo-a-passo abaixo:

Passo 1: declare

x, (aproxima¸c˜ao inicial para a raiz)

x0, (aproxima¸c˜ao para a raiz, a cada itera¸c˜ao)

(cid:15), (precis˜ao requerida)

i (contador de itera¸c˜oes)

nmax (n´umero m´aximo de itera¸c˜oes)

Passo 2: declare

f , (fun¸c˜ao que se quer achar a raiz)

18

d, (derivada da fun¸c˜ao f)

Passo 3: Fa¸ca i = 1;

Passo 4: Repita x = x0 −

f (xi)
f (cid:48)(xi)

;

Passo 5: Se | x − x0 |< (cid:15) ou i = nmax → ent˜ao

interrompa

ﬁm se

Passo 6: i ← i + 1;

Passo 7: x0 ← x;

ﬁm repita

Passo 8: se i > nmax, ent˜ao

escreva ”Convergˆencia n˜ao obtida”

Passo 9: sen˜ao

escreva x, f (x)

ﬁm se

pare

1.9 M´etodo da Bissec¸c˜ao

O m´etodo da bissec¸c˜ao explora o Teorema do Valor Intermedi´ario, segundo o

qual: “Seja uma fun¸c˜ao f cont´ınua no intervalor fechado [a, b], se y0 ´e um valor entre f (a)

e f (b), ent˜ao existe pelo menos um x0 ∈ [a, b], tal que f (x0) = y0.”

Sendo assim, a ideia para aproximar o zero de f (x) ´e tomar como primeira apro-

xima¸c˜ao o ponto m´edio do intervalo [a, b], isto ´e:

x0 =

a + b
2

.

Pode ocorrer de f (x0) = 0 e, nesse caso, o zero de f (x) ´e x∗ = x0. Caso contr´ario,
se f (a).f (x0) < 0, ent˜ao x∗ ∈ (a, x0). Nesse caso, tomamos como segunda aproxima¸c˜ao

do zero de f (x) o ponto m´edio do intervalo [a, x0], isto ´e, x1 =

se f (x0).f (b) < 0, ent˜ao, aproxima¸c˜ao desejada ´e x1 =

b + x0
2

intervalo [x0, b].

a + x0
2

. No outro caso,

, que ´e o ponto m´edio do

O m´etodo ocorrer´a de forma iterativa, a partir de um intervalo inicial dado [a, b]

e uma precis˜ao (cid:15). A cada itera¸c˜ao se determinar´a a aproxima¸c˜ao xi que ´e ponto m´edio

do intervalo, a partir da qual permitir´a que seja avaliado e determinado o intervalo da

19

itera¸c˜ao subsequente, no qual se tenha uma raiz da fun¸c˜ao, at´e que obtenha-se f (xi)

pr´oximo de y = 0 quanto se desejar, ou seja, | xi+1 − xi |< (cid:15). A Figura 1.10 ilustra o

funcionamento do m´etodo.

Figura 1.10: M´etodo da Bissec¸c˜ao.

Vamos utilizar o m´etodo tamb´em para encontrar as ra´ızes da fun¸c˜ao f , tal que

f (x) = x3 − 5, com precis˜ao de (cid:15) = 10−2. Consideraremos o intervalo inicial I0 = [1, 2].

Da´ı obtemos:

x0 =

a + b
2

=

1 + 2
2

= 1, 5.

Como f (1, 5) = −1, 625 < 0, f (1) = −4 < 0 e f (2) = 3 > 0. Ent˜ao o novo

intervalo I1 = [1, 5; 2], da´ı:

x1 =

1, 5 + 2
2

= 1, 75.

Como f (1, 75) = 0, 3594 > 0, f (1, 5) = −1, 625 < 0 e f (2) = 3 > 0. Ent˜ao o

novo intervalo I2 = [1, 5; 1, 75], da´ı:

x2 =

1, 5 + 1, 75
2

= 1, 625.

Como f (1, 625) = −0, 7090 < 0, f (1, 5) = −1, 625 < 0 e f (1, 75) = 0, 3594 > 0.

Ent˜ao o novo intervalo I3 = [1, 625; 1, 75], da´ı:

x3 =

1, 625 + 1, 75
2

= 1, 6875.

Como f (1, 6875) = −0, 1946 < 0, f (1, 625) = −0, 7090 < 0 e f (1, 75) = 0, 3594 >

0. Ent˜ao o novo intervalo I4 = [1, 6875; 1, 75], da´ı:

20

x4 =

1, 75 + 1, 6875
2

= 1, 7188.

Como f (1, 7188) = 0, 0778 > 0, f (1, 6875) = −0, 1946 < 0 e f (1, 75) = 0, 3594 >

0. Ent˜ao o novo intervalo I5 = [1, 6875; 1, 7188], da´ı:

x5 =

1, 6875 + 1, 7188
2

= 1, 7032.

Como f (1, 7032) = −0, 0592 < 0, e f (1, 7188) = 0, 0778 > 0. Ent˜ao o novo

intervalo I6 = [1, 7032; 1, 7188], da´ı:

x6 =

1, 7032 + 1, 7188
2

= 1, 7110.

Como | x6 − x5 |= 0, 0078 < (cid:15), a itera¸c˜ao para e temos que x ∼= x6 = 1, 7110.

A Tabela 1.2 e o gr´aﬁco da Figura 1.11 concatena os c´alculos das aproxima¸c˜oes e sua

visualiza¸c˜ao gr´aﬁca.

Tabela 1.2: Intervalos e aproxima¸c˜oes para as itera¸c˜oes do M´etodo da Bissec¸c˜ao para
encontrar zero da fun¸c˜ao f , tal que f (x) = x3 − 5.
i
0
1
2
3
4
5
6

xi
Ii
A=1,5
I0 = [1; 2]
B=1,75
I1 = [1, 5; 2]
C=1,625
I2 = [1, 5; 1, 75]
D=1,6875
I3 = [1, 625; 1, 75]
E=1,7188
I4 = [1, 6875; 1, 75]
I5 = [1, 6875; 1, 7188] F=1,7032
I6 = [1, 7032; 1, 7188] G=1,7110

21

Figura 1.11: Gr´aﬁco das itera¸c˜oes realizadas para a fun¸c˜ao f , com as respectivas apro-
xima¸c˜oes.

1.9.1 Algoritmo do M´etodo da Bissec¸c˜ao

Seja f cont´ınua em [a, b] e tal que f (a) e f (b) tenham sinais opostos, o algoritmo

do m´etodo da bissec¸c˜ao para encontrar zeros de fun¸c˜ao ter´a como entrada a fun¸c˜ao “f ”,

extremidades “a”e “b”, precis˜ao “(cid:15)”e n´umero m´aximo de itera¸c˜oes “nmax”. J´a a sua

sa´ıda ser´a a solu¸c˜ao aproximada ou mensagem de erro. O passo-a-passo da l´ogica de

programa¸c˜ao ´e descrito a seguir:

Passo 1: declare

a, b, (limites inferior e superior do intervalo)

xm, (valor m´edio entre a e b)

(cid:15), (precis˜ao requerida)

i (contador de itera¸c˜oes)

nmax (n´umero m´aximo de itera¸c˜oes)

Passo 2: declare

f (x) (fun¸c˜ao que se quer achar raiz)

leia a, b, (cid:15)

se f (a).f (b) = 0 ent˜ao

Passo 3: escreva Valores de a e b inv´alidos

22

interrompa

ﬁm se

i ← 1

Passo 4: repita

xm ←

b + a
2

Passo 5: se | b − a |< (cid:15) ou i > nmax ent˜ao

interrompa

ﬁm se

Passo 6: se f (xm).f (b) < 0 ent˜ao

a ← xm

Passo 7: sen˜ao

b ← xm

ﬁm se

Passo 8: i ← i + 1

ﬁm repita

se i > nmax ent˜ao

escreva Convergˆencia n˜ao obtida

sen˜ao

escreva xm, f (xm)

ﬁm se

para

1.10 Considera¸c˜oes ﬁnais do cap´ıtulo

As fun¸c˜oes s˜ao utilizadas para modelar matematicamente v´arios problemas do

dia-a-dia e quest˜oes cient´ıﬁcas, portanto, o conhecimento de seu gr´aﬁco ´e de extrema

importˆancia para estudo de seu comportamento.

Os m´etodos num´ericos quando implementados numa l´ogica computacional, se

mostram eﬁcientes no c´alculo das raizes devido `a velocidade de opera¸c˜ao das m´aquinas,

conseguindo realizar v´arias itera¸c˜oes num curto intervalo de tempo. Com isso, consegui-

mos obter raiz(es) aproximada(s) de fun¸c˜oes n˜ao lineares com erros muito pequenos.

Observamos que dos m´etodos num´ericos supramencionados, o da Bissec¸c˜ao con-

23

vergiu mais lentamente que o de Newton-Raphson, ou seja, para encontrar uma raiz com

o mesmo erro nos dois m´etodos, ter´ıamos que realizar mais itera¸c˜oes utilizando da Bis-

sec¸c˜ao. No entanto, o m´etodo da Bissec¸c˜ao ´e mais simples, j´a que n˜ao ´e necess´ario o

c´alculo da derivada fun¸c˜ao, somente ´e feito uma m´edia aritm´etica simples.

Mas isso depende de condi¸c˜oes iniciais ideais:

– Para o M´etodo de Newton-Raphson: depende da escolha de uma boa aproxima¸c˜ao

inicial x0 e que a primeira derivada da fun¸c˜ao seja diferente de zero, ou seja, f (cid:48)(xi) (cid:54)=

0;

– Para o M´etodo da Bissec¸c˜ao: depende se a fun¸c˜ao ´e cont´ınua no intervalo inicial

escolhido [a, b], e que exista uma raiz da fun¸c˜ao nele, ou seja, f (a).f (b) < 0.

Apesar das peculiaridades dos dois m´etodos, eles apresentam f´acil visualiza¸c˜ao

gr´aﬁca, o que pode facilitar o seu entendimento por alunos, inclusive do Ensino M´edio.

24

Cap´ıtulo 2

Arduino, componentes

eletroeletrˆonicos e o prot´otipo

Neste cap´ıtulo, ser´a abordado a plataforma utilizada (Arduino), a qual apresenta

um microcontrolador embarcado com n´ucleo de processador, mem´oria e perif´ericos de

entrada e sa´ıda num ´unico circuito integrado. Esse pequeno computador pode ser utilizado

para controle e leitura de sensores e tamb´em controle e ativa¸c˜ao de atuadores, como

motores, rel´es, sinalizadores, etc.

Devido seu baixo custo e facilidade de programa¸c˜ao tem sido utilizado por pro-

jetistas, estudantes e curiosos da ´area para desenvolvimento de produtos e dispositivos

automatizados nos mais diversos ramos, como por exemplo, I) automa¸c˜ao residencial: con-

trole de cortinas, portas, eletrodom´esticos, port˜oes, comedouros de animais de estima¸c˜ao,

etc; II) controle de lavouras: umidade do solo, irriga¸c˜ao, supervis˜ao a´erea com drones,

etc; III) desenvolvimento de robˆos: seguidores de linha, competi¸c˜oes de luta, competi¸c˜oes

de futebol, etc; IV) prot´otipos autˆonomos diversos: cubo de LEDs com efeitos em seu

acendimento, jaqueta de LEDs para ciclistas, ﬁleira de LEDs com t´ecnica de POV (Per-

sistent of Vision) que fornece como resultado um display esf´erico, como um globo girante,

ou circular, como um rel´ogio e seus ponteiros.

Temos v´arios exemplos de projetos utilizando Arduino. Um deles trata-se de um

Seguidor Solar, que ´e um dispositivo para ser utilizado como suporte para placas solares,

que a partir da compara¸c˜ao da leitura de sensores de luminosidade, h´a ativa¸c˜ao de motores

que permitem `a estrutra que se movimente de acordo com a movimenta¸c˜ao do Sol, com

isso h´a um aumento na gera¸c˜ao de energia se comparado ao modelo utilizado, que s˜ao as

25

placas ﬁxas nos telhados.

Outro exemplo ´e o cubo de LEDs, de 8x8x8, desenvolvido a partir da interliga¸c˜ao

de 512 LEDs formando um cubo, o qual se tem o controle pontual de cada um deles, per-

mitindo a programa¸c˜ao de v´arios efeitos: como efeito chuva, acendimento de cada camada

por vez, acendimento de cada linha por vez, acendimento de todos, escrita tridimensional

de letras, etc. A Figura 2.1 exibe ambos projetos.

(a) Seguidor Solar.

(b) Cubo de LEDs.

Figura 2.1: Projetos constru´ıdos com Arduino.

Neste cap´ıtulo ainda ser´a abordado o funcionamento e especiﬁca¸c˜oes dos com-

ponentes eletroeletrˆonicos utilizados no projeto e as conex˜oes necess´arias entre eles para

manufataru¸c˜ao do prot´otipo, escopo desse trabalho.

2.1 Arduino

Para o controle, supervis˜ao e ativa¸c˜ao dos perif´ericos ser´a utilizado o Arduino,

que ´e uma plataforma de prototipagem eletrˆonica de hardware livre e de placa ´unica,

projetada com um microcontrolador Atmel AVR com suporte de E/S(Entrada/Sa´ıda)

embutido, uma linguagem de programa¸c˜ao padr˜ao, a qual ´e essencialmente C/C + +.

(Arduino, 2017,ver).

A plataforma ´e uma ferramenta acess´ıvel, de baixo custo, ﬂex´ıvel e f´acil de se

usar por proﬁssionais e amadores. Pode ser usada para o desenvolvimento de objetos

interativos independentes, ou ainda para ser conectado a um computador hospedeiro.

26

Uma t´ıpica placa Arduino ´e composta por um controlador, algumas E/S digitais

e anal´ogicas, al´em de uma interface serial ou USB, para interligar-se ao hospedeiro, que

´e usado para program´a-la e interag´ı-la em tempo real. Usando-se extens˜oes chamadas de

Shields, ´e poss´ıvel ainda conect´a-las `a rede, `a outros Arduinos e dispositivos m´oveis, por

v´arios protocolos de comunica¸c˜ao (Bluetooth, Internet, RF (r´adio frequˆencia), Xbee, etc).

A Figura 2.2 mostra uma das placas oﬁciais do Arduino: o Arduino UNO. No

entanto, existe v´arios outros modelos, como por exemplo, o Arduino Mega que ´e uma

placa que conta com mais E/S que o UNO, o Arduino Nano que apresenta dimens˜oes

mais compactas, etc.

Figura 2.2: Placa do Arduino UNO.

A maior vantagem dessa plataforma de desenvolvimento sobre as demais ´e a

facilidade de sua utiliza¸c˜ao, pois, pessoas que n˜ao s˜ao da ´area t´ecnica podem aprender o

b´asico e criar seus pr´oprios projetos em um intervalo de tempo relativamente curto.

Al´em do hardware, h´a o Arduino IDE (Ambiente de Desenvolvimento Integrado)

que ´e uma aplica¸c˜ao multiplataforma escrita em Java e esquematizado para introduzir

a programa¸c˜ao aos seus utilizadores, sejam eles proﬁssionais ou tamb´em pessoas n˜ao

familiarizadas com o desenvolvimento de software. Ela inclui um editor de c´odigo com

recursos de realce de sintaxe, parˆenteses correspondentes e identiﬁca¸c˜ao autom´atica, sendo

capaz de compilar e carregar programas para a placa com um ´unico clique.

Tendo uma biblioteca chamada Wiring, ele possui a capacidade de programar em

C/C + +. Isto permite criar com facilidade muitas opera¸c˜oes de entrada e sa´ıda, tendo

que deﬁnir apenas duas fun¸c˜oes no pedido para fazer um programa funcional:

– setup() Inserida no in´ıcio, na qual pode ser usada para inicializar conﬁgura¸c˜ao, e

27

– loop() Chamada para repetir um bloco de comandos ou esperar at´e que seja desli-

gada.

O Arduino IDE e as duas fun¸c˜oes b´asicas supramencionadas s˜ao mostradas na

Figura 2.3.

Figura 2.3: Tela do Arduino IDE.

2.2 Componentes eletroeletrˆonicos

Na constru¸c˜ao do prot´otipo foram utilizados alguns componentes eletroeletrˆonicos,

como LEDs, resistores, LCD (tela de cristal l´ıquido) e constru´ıdo um teclado n´umerico

com bot˜oes de contato. O funcionamento e as liga¸c˜oes el´etricas necess´arias de cada com-

ponente, ser˜ao descritos nos subcap´ıtulos a seguir.

2.2.1 LEDs

Os LEDs s˜ao diodos emissores de luz, componentes do tipo bipolar, ou seja,

que apresentam dois terminais, sendo que um ´e chamado de anodo e o outro de catodo.

Dependendo da forma como ele ´e polarizado, ele permite ou n˜ao a passagem de corrente,

e consequente emiss˜ao de luz. Na Figura 2.4 ´e poss´ıvel observar o s´ımbolo el´etrico do

LED e a identiﬁca¸c˜ao de seus terminais.

28

Figura 2.4: S´ımbolo do LED, com 1 representando o anodo e 2 o catodo.

Atualmente os LEDs dispon´ıveis no mercado s˜ao os redondos de 3mm e de 5mm,

quadrado de 8x8 mm e o tipo “piranha”. Foram utilizados LEDs do tipo redondo de 5

mm, a Figura 2.5 mostra um deles, o de cor vermelha.

Figura 2.5: LED vermelho.

Em termos pr´aticos, para o LED ser ativado deve-se ter uma corrente circulando

em seus terminais no sentido anodo → catodo, o que implica numa diferen¸ca de potencial

positiva entre os terminais anodo e catodo.

2.2.2 Resistor

A propriedade f´ısica de um componente ou dispositivo de se opor `a passagem de

corrente el´etrica ´e chamada de resistˆencia e ´e representada pelo s´ımbolo R.

A unidade de resistˆencia ´e chamada de ohm e ´e representada pelo s´ımbolo Ω;

1Ω = 1V /A.

Um componente que possui uma resistˆencia R ´e chamado de resistor. Um resistor

´e representado pelo s´ımbolo de dois terminais que aparece na Figura 2.6.

Figura 2.6: S´ımbolo do resistor.

29

Existem quatro tipos b´asicos de resistores: resistores de caborno, resistores de

ﬁlme de carbono, resistores de ﬁlme de metal e resistores de ﬁo. A Figura 2.7 mostra um

resistor de ﬁlme pl´astico (tipo que foi utilizado no prot´otipo), com suas faixas coloridas,

que representam um c´odigo de cores.

Figura 2.7: Resistor de ﬁlme pl´astico.

O C´odigo de Cores ´e um sistema criado para identiﬁcar a resistˆencia e a tolerˆancia

dos resistores, ele ´e mostrado na Figura 2.8. Os resistores comerciais podem ter valores

entre 1 ohm e 10 megaohm.

Figura 2.8: C´odigo de Cores. Fonte: AudioGroup (2017).

2.2.3 LCD

Tela de cristal l´ıquido, acrˆonimo de LCD (em inglˆes liquid crystal display), ´e

um painel ﬁno usado para exibir informa¸c˜oes por via eletrˆonica, como texto, imagens e

v´ıdeos. Um LCD consiste de um l´ıquido polarizador da luz, eletricamente controlado, que

se encontra comprimido dentro de celas entre duas lˆaminas transparentes polarizadoras.

Os eixos polarizadores das duas lˆaminas est˜ao alinhados perpendicularmente entre si.

Cada cela ´e provida de contatos el´etricos que permitem que um campo el´etrico possa ser

aplicado ao l´ıquido no interior.

Os m´odulos LCD s˜ao especiﬁcados principalmente por sua capacidade gr´aﬁca de

comunica¸c˜ao, ou seja, o n´umero de caracteres por linha e o n´umero de linhas. Alguns

30

valores t´ıpicos para essas especiﬁca¸c˜oes s˜ao:

– N´umero de caracteres: 8, 12, 16, 20, 24 e 40.

– N´umero de linhas: 1, 2 e 4.

O display utilizado apresenta um m´odulo I2C integrado para simpliﬁcar suas

liga¸c˜oes com o Arduino. A Figura 2.9 mostra um display LCD de 16 colunas x 2 linhas.

Figura 2.9: Display LED 16x2.

O M´odulo LCD I 2C ou I2C ´e ideal para ser utilizado em projetos envolvendo

LCDs, podendo estar presente em projetos com Arduino ou outros microcontroladores

que tenham suporte ao protocolo I 2C onde h´a diversos dispositivos (n˜ao necessariamente

LCDs) que comunicar˜ao entre si com apenas duas linhas de dados.

O protocolo I 2C foi desenvolvido para conectar diversos dispositivos (perif´ericos)

utilizando apenas as duas linhas de dados SDA (Serial Data) e SCL (Serial Clock ). A

ideia principal ´e deﬁnir um endere¸co hexadecimal para cada dispositivo e no momento de

comunica¸c˜ao somente o dispositivo solicitado responder´a.

2.2.3.1 Teclado de Push-Button

Foi manufaturado um teclado matricial de 11 linhas x 1 coluna, identiﬁcados

pelos numerais de “0”a “9”e “=”, utilizando teclas t´acteis de 2 pinos de contatos do tipo

normalmente aberto (NA), chamados de push-buttons. Esse interruptor ﬁca normalmente

aberto (desligado), mas se vocˆe pressionar e segurar o bot˜ao, o interruptor fecha (liga).

Ao soltar o bot˜ao, o interruptor abre novamente. A Figura 2.10 mostra o componente.

Figura 2.10: Push-button de 2 terminais.

31

A Figura 2.11 mostra a liga¸c˜ao el´etrica de cada tecla, com “Arduino”tratando-se

da porta do Arduino que ser´a respons´avel pela leitura do sinal el´etrico da tecla conectada

a ela, “GND”´e o Terra, “5V”´e a tens˜ao de alimenta¸c˜ao do circuito e “R”corresponde ao

resistor de resistˆencia 10kΩ.

Figura 2.11: Circuito de um das 12 teclas utilizadas no teclado.

2.3 Prot´otipo

O prot´otipo trata-se de um equipamento composto por um painel de LEDs e uma

IHM composta de um LCD 16x2 e um teclado num´erico de “0”a “9”e uma tecla de “=”,

microcontrolados pela plataforma Arduino. O Arduino ser´a respons´avel por realizar a

leitura do teclado e controlar o acendimento do painel de LEDs e do display. A Figura

2.12 exibe os componentes do prot´otipo.

Figura 2.12: Componentes do prot´otipo.

O microcontrolador escolhido foi o Arduino Mega, j´a que, para controle individual

de cada LED, sem utilizar nenhuma t´ecnica de multiplexagem, seriam necess´arios pelo

menos 121 sa´ıdas. Com o Mega e a t´ecnica utilizada, para controle de todos os LEDs

ser˜ao necess´arios 22 sa´ıdas, fora as portas que seriam demandas para o controle da IHM,

32

justiﬁcando assim a sua escolha, j´a que ´e um modelo que apresenta uma quantidade

superior em rela¸c˜ao aos demais modelos dispon´ıveis.

O painel manufaturado ´e uma matriz formada por 11 linhas e 11 colunas, totali-

zando 121 LEDs. Sendo que a linha e a coluna central, de n´umero 6, representam os eixos

cartesianos e seus LEDs s˜ao de cor vermelha, diferente dos demais que s˜ao de cor verde.

Nele, os LEDs de uma mesma coluna apresentam seus anodos interligados entre

si, que dali se interliga `a um resistor limitador de corrente de 220Ω e por ﬁm `a uma das

portas digitais do microcontrolador. J´a os LEDs de uma mesma linha, apresentam seus

catodos interligados entre si e `a uma das portas digitais do microcontrolador. Nas Figuras

2.13 e 2.14 ´e poss´ıvel visualizar as conex˜oes el´etricas entre os LEDs e o Painel de LEDs

j´a montado.

Figura 2.13: Conex˜oes da matriz de LEDs.

33

Figura 2.14: Vis˜ao superior do painel manufaturado com todos os LEDs acesos.

A ativa¸c˜ao de cada LED, que representa um par ordenado, ocorrer´a da seguinte

forma: de acordo com a fun¸c˜ao inserida, o programa desenvolvido encontrar´a os LEDs

(coordenada) que dever˜ao ser acesos para formar o tra¸cado da fun¸c˜ao. Para ativar um

LED espec´ıﬁco o microcontrolador dever´a mandar dois sinais simultˆaneos de forma a se

estabelecer uma diferen¸ca de potencial entre os terminais do componente e assim permitir

a circula¸c˜ao de corrente e seu acendimento.

Por exemplo, para acender o LED da quinta coluna e da terceira linha, o programa

dever´a mandar um sinal alto (5V) para a porta do microcontrolador a qual a quinta

coluna est´a conectada e um sinal baixo (0V) para a porta do microcontrolador a qual est´a

conectada a terceira linha.

A IHM desenvolvida ´e parte da estrutura que permite que o usu´ario interaja

com o painel, ou seja, ´e nela que ele inserir´a a fun¸c˜ao que deseja visualizar, com aux´ılio

de um teclado num´erico que est´a conectado ao microcontrolador, poder´a ser inserido os

coeﬁcientes da equa¸c˜ao; e ´e por onde tamb´em, poder´a se visualizar, em um visor LCD de

16 linhas x 2 colunas, a pr´opria fun¸c˜ao e o valor do seu zero.

A Figura 2.15 exibe as liga¸c˜oes el´etricas do circuito completo do teclado. Nele

podemos ver os 12 bot˜oes, os conectores que ser˜ao utilizados para conect´a-la ao Arduino

e `a alimenta¸c˜ao.

34

Figura 2.15: Circuito do teclado e liga¸c˜ao com o Arduino.

O circuito funcionar´a da seguinte forma: como trata-se de uma tecla NA, a leitura

que o Arduino far´a do circuito ser´a 0V, caso pressionado, o circuito ser´a fechado, e ele

passar´a a ler 5V, comparando essa diferen¸ca leitura, o controlador saber´a quando cada

bot˜ao foi pressionado, e assim poderar atuar de forma correta.

A Figura 2.16 indica as conex˜oes necess´arias do LCD 16x2 (com m´odulo I2C

integrado) que ser´a utilizado no prot´otipo.

Figura 2.16: Conex˜oes el´etricos necess´arias entre o LCD e o Arduino Mega.

Por ﬁm, foi constru´ıda uma caixa de placas de compensando de madeira com as

dimens˜oes: 15 cm de comprimento x 15 cm de largura x 11 cm de altura. Em sua regi˜ao

35

superior foi ﬁxado o painel de LEDs, o LCD e o teclado n´umerico; e manufaturado, em

material pl´astico, uma placa para recobri-la, deixando assim, exposto somente a parte de

intera¸c˜ao com o usu´ario.

Na regi˜ao frontal foi colocado um bot˜ao, de dois estados (ON /OFF), para

abrir/fechar o circuito da alimenta¸c˜ao, e consequentemente ligar/desligar o prot´otipo.

As conex˜oes el´etricas, o microcontrolador e sua bateria foram acondicionados em seu in-

terior para uma visualiza¸c˜ao mais atrativa do prot´otipo. A Figura 2.17 mostra o prot´otipo

constru´ıdo.

(a) Vis˜ao superior.

(b) Vis˜ao traseira.

Figura 2.17: Prot´otipo constru´ıdo.

2.4 Considera¸c˜oes ﬁnais do cap´ıtulo

Para constru¸c˜ao do prot´otipo foram utilizados componentes eletrˆonicos de f´acil

manipula¸c˜ao e f´aceis de serem encontrados em lojas de eletrˆonica. O dimensionamento

dos componentes foram realizados de acordo com a alimenta¸c˜ao que ser´a utilizada para

eles (5V), podendo variar caso seja utilizada uma fonte de alimenta¸c˜ao diferente para

placas perif´ericas (placa de LEDs e teclado). Foi utilizado para alimentar o Arduino uma

bateria de 9V, ´e recomendado utilizar uma fonte de tens˜ao de 7V a 12V.

No cap´ıtulo 3 ser´a abordado alguns exemplos de estudo de fun¸c˜oes, os quais

poder˜ao ser utilizado o prot´otipo como apoio ao ensino em sala de aula.

36

Cap´ıtulo 3

Utilizando o prot´otipo

Este cap´ıtulo trar´a os resultados obtidos utilizando o prot´otipo constru´ıdo para

aplica¸c˜oes com a fun¸c˜ao aﬁm e, tamb´em, ser´a apresentada uma proposta de atividade que

poder´a ser utilizada em sala de aula pelos alunos utilizando o equipamento desenvolvido.

3.1 Prot´otipo

O prot´otipo desenvolvido ´e para plotagem exclusiva de fun¸c˜oes aﬁns, do tipo

f (x) = ax + b, com a, b e x ∈ Z. Devido a quantidade limitada de LEDs por quadrante,

as demais fun¸c˜oes ﬁcariam com suas curvas desconﬁguradas, al´em disso, o prot´otipo ´e

limitado a −5 ≤ x ≤ 5 e a −5 ≤ f (x) ≤ 5, com isso cada LED representa uma coordenada

(x, y) com x, y ∈ Z.

Ao ser iniciado, o prot´otipo pedir´a, via LCD, que seja inserida os coeﬁcientes a e

b da fun¸c˜ao f (x) = ax + b e em seguida pedir´a ainda que seja informado se s˜ao positivos

ou negativos.

A escala do programa, que ser´a utilizada para o c´alculo da imagem da fun¸c˜ao,

ser´a de 1 : 1, partindo disso ´e calculado a imagem da fun¸c˜ao f para −5 ≤ x ≤ 5.

Al´em de calcular os pares ordenados das fun¸c˜oes inseridas, o programa ir´a de-

terminar, tamb´em, a raiz da fun¸c˜ao, por meio da l´ogica desenvolvida, que basicamente

trata-se de encontrar o valor de x para y = 0.

Ap´os ser informado os coeﬁcientes da fun¸c˜ao e o programa realizar o c´alculo dos

pares ordenados e de seu zero, o microcontrolador ir´a ativar os LEDs correspondentes aos

pares ordenados que comp˜oe o tra¸cado da fun¸c˜ao pedida. Al´em disso, ir´a fazer com que

37

seja exibido no LCD a fun¸c˜ao fornecida pelo usu´ario e tamb´em o valor do zero calculado.

Tais informa¸c˜oes ir˜ao ser mostradas at´e que qualquer uma das teclas seja acionada e

o programa reinicie pedindo novamente os coeﬁcientes da nova fun¸c˜ao requerida pelo

usu´ario.

Vamos analisar como o programa ir´a trabalhar caso fosse inserida a fun¸c˜ao f ,

tal que f (x) = −x. Temos que para x = −5 → f (x) = 5, ent˜ao, para acender o LED

correspondente ao par ordenado (−5, 5), o programa dever´a mandar um sinal alto (5V)

para a porta do microcontrolador a qual a primeira coluna est´a conectada e um sinal

baixo (0V) para a porta do microcontrolador a qual est´a conectada a primeira linha. O

programa proceder´a da mesma forma para todos os pares ordenados, para que assim,

seja obtido o tra¸cado da fun¸c˜ao. A Figura 3.1 exibe como ﬁcar´a o tra¸cado da fun¸c˜ao f

supramencionada.

Figura 3.1: Tra¸cado da fun¸c˜ao f , tal que f (x) = −x.

Vamos analisar tamb´em a fun¸c˜ao f , tal que f (x) = x − 2. Temos que para x =

−5 → f (x) = −7, como o painel de LEDs n˜ao comporta o valor da imagem encontrado,

o programa n˜ao acender´a nenhum LED verde na primeira coluna, isso ocorrer´a sempre

que x → −5 > f (x) > 5. Ou seja, s´o haver´a acendimento de coordenadas, LEDs, de

acordo com as limita¸c˜oes f´ısicas do painel. A Figura 3.2 exibe como ﬁcar´a o tra¸cado dessa

fun¸c˜ao.

38

Figura 3.2: Tra¸cado da fun¸c˜ao f , tal que f (x) = x − 2.

Vamos analisar tamb´em a fun¸c˜ao constante f , tal que f (x) = 4. Temos que para

todo x → f (x) = 4, ent˜ao o painel acender´a todos os LEDs da segunda linha e os LEDs

correspondentes ao eixo X0Y . A Figura 3.3 exibe como ﬁcar´a o tra¸cado dessa fun¸c˜ao.

Figura 3.3: Tra¸cado da fun¸c˜ao f , tal que f (x) = 4.

3.2 Proposta de atividades para sala de aula

Para utiliza¸c˜ao do Prot´otipo, como apoio `as aulas, com intuito de estudo de

fun¸c˜oes e visualiza¸c˜ao do seu respectivo gr´aﬁco, ´e proposto as atividades a seguir para

serem resolvidas e plotadas para sua veriﬁca¸c˜ao:

39

1. Foi realizado o lan¸camento de um m´ıssel a partir de um submarino, cuja

trajet´oria ´e vertical (sentido fundo do mar → c´eu) e deﬁnida pela reta y = 2x − 4, com

x tratando-se do tempo em segundos e y da altura (em km) em rela¸c˜ao ao fundo mar.

Determine: a) coordenada do lan¸camento.

O lan¸camento ocorrer´a com x = 0, o que nos fornecer´a y = 2.0 − 4 = −4.

Portanto, a coordenada do lan¸camento ´e (0, −4).

b) instante em que o m´ıssel cruza a linha do oceano.

O m´ıssel ir´a cruzar a linha do oceano quando y = 0, como isso substituindo na

equa¸c˜ao, obtemos 0 = 2x − 4 → x = 2. Portanto, o m´ıssel cruzar´a a linha do oceano 2

segundos ap´os seu lan¸camento.

c) determine a altura que ele estar´a, em rela¸c˜ao a superf´ıcie, 3 segundos ap´os o

lan¸camento.

Temos que x = 3, da´ı obtemos que y = 2.3 − 4 = 2. Portanto, o m´ıssel estar´a a

2 km da superf´ıcie.

d) determine a altura que ele estar´a, em rela¸c˜ao ao ponto de lan¸camento, ap´os 4

segundos.

Temos que x = 4; da´ı, obtemos que y = 2.4 − 4 = 4. Como o m´ıssel foi lan¸cado a

uma profundidade de 4 km, e como, ap´os 4 segundos, ele se encontra a 4 km da superf´ıcie,

temos ent˜ao que ele estar´a a 8 km do ponto em que foi lan¸cado.

2. Um entregador de uma pizzaria cobra por entrega realizada. O valor de cada

entrega ´e proporcional a distˆancia da entrega at´e a pizzaria. Para realizar uma entrega,

numa residˆencia que se localizava a 3 km da pizzaria ele cobrou 6 reais. Determine:

a) a fun¸c˜ao matem´atica que representa o valor cobrado por ele (em reais) em

fun¸c˜ao da distˆancia (em km) do local `a pizzaria.

Como o valor cobrado ´e proporcional a distˆancia, ent˜ao teremos uma fun¸c˜ao do

tipo f (x) = ax, com x representando a distˆancia percorrida.

Como ele recebeu 6 reais por um deslocamento de 3 km, teremos: 6 = a.3 → a = 2.

Da´ı, obtemos a fun¸c˜ao f (x) = 2x.

40

b) Numa entrega ele faturou 14 reais, determine a distˆancia do local at´e a pizzaria.

Sabendo que ele faturou 14 reais, e que a fun¸c˜ao matem´atica ´e a encontrada em

a), temos que 14 = 2.x → x = 7. Portanto, a distˆancia percorrida foi de 7 km.

3. Num parque de divers˜ao, o valor da entrada ´e 2 reais e o custo para utiliza¸c˜ao

de cada brinquedo ´e de 1 real. Determine:

a) a fun¸c˜ao matem´atica que representa o valor gasto (em reais) em fun¸c˜ao do

n´umero de brinquedos utilizados.

Como o valor a ser pagado ´e composto por uma parcela ﬁxa de 2 reais mais a

quantidade de brinquedos vezes o seu custo (1 real), a fun¸c˜ao que representa o gasto ´e

dado por: f (x) = x + 2, com x representando o n´umero de brinquedos utilizados.

b) o valor gasto por uma crian¸ca que utilizou 7 brinquedos.

Como foram utilizados 7 brinquedos, temos que x = 7; da´ı, obtemos que o gasto

ser´a de f (7) = 7 + 2 = 9 reais.

c) Jo˜ao levou 10 reais, determine o n´umero m´aximo de brinquedos que ele poder´a

utilizar.

Como f (x) = 10, temos que x + 2 = 10 → x = 8. Portanto, o n´umero m´aximo

de brinquedos que ele poder´a utilizar ser´a 8.

41

Cap´ıtulo 4

Maxima

O Maxima ´e um Sistema de Computa¸c˜ao Alg´ebrica (CAS), de software livre,

podendo ser baixado, copiado e redistribu´ıdo livremente. Ele permite efetuar c´alculos

num´ericos e simb´olicos, plotar gr´aﬁcos em duas e trˆes dimens˜oes e elaborar implementa¸c˜oes

computacionais eﬁcientes e precisas, mostrando-se uma ferramenta importante para es-

tudo das fun¸c˜oes, para encontrar zero(s) e tamb´em para plotagem de gr´aﬁcos.

A utiliza¸c˜ao do software matem´atico ´e uma alternativa `a constru¸c˜ao de um dispo-

sitivo para uma vis˜ao tecnol´ogica do estudo da teoria matem´atica e tamb´em uma inicia¸c˜ao

para o desenvolvimento de equipamentos mais robustos, utilizando os m´etodos n´umericos

aqui estudados ou outros de acordo com o foco do trabalho.

No software Maxima foi desenvolvido um c´odigo do m´etodo de Newton-Raphson

e outro c´odigo para o m´etodo da Bissec¸c˜ao para encontrar zero(s) de fun¸c˜oes.

Primeiro vamos analisar o c´odigo do m´etodo de Newton-Raphson para a fun¸c˜ao

g, tal que g(x) = x3 − 5. Inicialmente foi criado o m´etodo “newton”, ao qual ´e fornecida a

fun¸c˜ao “f ”, aproxima¸c˜ao inicial “x”e a precis˜ao desejada “erro”. O “newton”foi deﬁnido

como um bloco, no qual obteremos a derivada da fun¸c˜ao “df ”, o valor assumido pela

fun¸c˜ao e por sua derivada a cada itera¸c˜ao ”f (x)“ e “y”, respectivamente; e ser´a calculado

o valor de cada aproxima¸c˜ao: “x −

f (x)
y

”. Isso ocorrer´a at´e que o m´odulo do valor da

fun¸c˜ao para aproxima¸c˜ao calculada seja menor que o “erro”informado.

A Figura 4.1 mostra (em azul) o c´odigo desenvolvido e o valor obtido (em preto)

de cada aproxima¸c˜ao.

42

Figura 4.1: M´etodo de Newton-Raphson para a fun¸c˜ao g, tal que g(x) = x3 − 5.

Agora vamos utilizar o c´odigo desenvolvido do m´etodo de Newton-Raphson para a

fun¸c˜ao g, tal que g(x) =

log(x)
x

+2x. A Figura 4.2 mostra (em azul) o c´odigo desenvolvido

e o valor obtido (em preto) de cada aproxima¸c˜ao.

Figura 4.2: M´etodo de Newton-Raphson para a fun¸c˜ao g, tal que g(x) =

log(x)
x

+ 2x.

Agora vamos analisar o c´odigo do m´etodo da Bissec¸c˜ao para a fun¸c˜ao f , tal que

f (x) = x3 − 5. Inicialmente foi criada um m´etodo “bissec”, ao qual ´e fornecida a fun¸c˜ao

f , o intervalor inicial “a”e “b”, n´umero m´aximo de itera¸c˜oes “n”e a precis˜ao desejada

“erro”. O “bissec”foi deﬁnido como um bloco, no qual obteremos xm =

a + b
2

, fazendo

x0 = a e x1 = b. Foi criado, tamb´em, no c´odigo, um la¸co do tipo while, que avaliar´a

se o n´umero de itera¸c˜oes realizadas ´e menor do que o n´umero m´aximo fornecido “n”e se

| x1 − x0 |> ”erro”.

43

Enquanto as duas condi¸c˜oes forem verdadeiras o loop ﬁcar´a contando o n´umero

de itera¸c˜oes realizadas a partir do contador “int”, que a cada itera¸c˜ao somar´a 1 ao valor

anterior e tamb´em ir´a avaliar se f (xm).f (x0) < 0, caso positivo far´a com que x1 = xm e

calcular´a “xm”, caso negativo far´a x0 = xm e calcular´a “xm”. A Figura 4.3 mostra (em

azul) o c´odigo desenvolvido e o valor obtido (em preto) para “xm”a cada itera¸c˜ao.

Figura 4.3: M´etodo da Bissec¸c˜ao para a fun¸c˜ao f , tal que f (x) = x3 − 5.

Utilizaremos o c´odigo desenvolvido do m´etodo da Bissec¸c˜ao para a fun¸c˜ao g, tal

que g(x) =

log(x)
x

+ 2x . A Figura 4.4 mostra (em azul) o c´odigo desenvolvido e o valor

obtido (em preto) para f (pn) a cada itera¸c˜ao.

Figura 4.4: M´etodo da Bissec¸c˜ao para a fun¸c˜ao g, tal que g(x) =

log(x)
x

+ 2x.

44

As Figura 4.5 e 4.6 exibem os gr´aﬁcos das fun¸c˜oes estudadas anteriormente por

meio dos m´etodos n´umericos mostrados, obtido no programa M´axima.

Figura 4.5: Exibe comando de plotagem de gr´aﬁco 2D e janela com o gr´aﬁco da fun¸c˜ao
f , tal que f (x) = x3 − 5.

Figura 4.6: Exibe comando de plotagem de gr´aﬁco 2D e janela com o gr´aﬁco da fun¸c˜ao

g, tal que g(x) =

log(x)
x

+ 2x.

4.1 Considera¸c˜oes ﬁnais do cap´ıtulo

O software Maxima apesar de pouco conhecido ´e uma boa alternativa `a outros

softwares de dom´ınio, os quais necessitam de licen¸ca para o seu uso. Nele pudemos inserir

linhas de comando para programa¸c˜ao dos m´etodos estudados e obter as aproxima¸c˜oes

desejadas, bem como o gr´aﬁco das fun¸c˜oes estudadas, podendo veriﬁcar assim que os

45

zeros encontrados nos m´etodos num´ericos s˜ao de fato os pontos que cortam o eixo das

abcissas, como se era esperado.

O software serviu de ferramenta para veriﬁca¸c˜ao de alguns dos m´etodos que

podem ser utilizados para estudos de fun¸c˜oes de maneira computacional, e que, aliado `a

rob´otica poder´a servir de base para constru¸c˜ao de outras ferramentas para o ensino de

fun¸c˜oes mais complexas, bem como outros assuntos da matem´atica e de outras disciplinas.

O uso de tais m´etodos no software ´e um “pontap´e inicial”para sua utiliza¸c˜ao em

outras plataformas e um incentivo `a utiliza¸c˜ao de tecnologia no ensino.

46

Considera¸c˜oes ﬁnais

A plataforma Arduino por ter uma grande comunidade mundial de utilizadores e

ser amparada por f´oruns, blogs, diversos sites com tutoriais e bibliotecas compartilhadas

com c´odigos prontos para uso, facilita bastante o primeiro contato com o microcontrolador

para toda a comunidade das diversas ´areas de ensino.

A constru¸c˜ao e programa¸c˜ao do prot´otipo pode ser desenvolvida somente pelos

educadores e utilizada como ferramenta de ensino, ou at´e mesmo envolver os alunos em

todas etapas, propiciando a eles contato com programa¸c˜ao, eletrˆonica, c´alculo num´erico

e as fun¸c˜oes matem´aticas em si.

Incentivando-os tamb´em `a participa¸c˜ao em eventos

tecnol´ogicos, e ao envolvimento com projetos e pesquisas.

O desenvolvimento de um trabalho pr´atico, como a manufatura¸c˜ao de um prot´otipo,

apresenta diﬁculdades intr´ınsecas, como o aperfei¸coamento da estrutura at´e obten¸c˜ao de

uma vers˜ao funcional e apresent´avel, sendo necess´ario substitui¸c˜ao de componentes, de

soldas, de ﬁa¸c˜ao, teste da programa¸c˜ao in´umeras vezes, at´e obten¸c˜ao de um c´odigo que

funcione de maneira satisfat´oria para a arquitetura utilizada, etc.

Como LEDs s˜ao componentes sens´ıveis `a temperatura, no processo de soldagem,

foi necess´aria a substitui¸c˜ao de alguns deles e, tamb´em, que fosse refeita algumas soldagens

devido `a mau contato ou rompimento. No desenvolvimento do teclado, foram desenvol-

vidos 3 modelos diferentes, reaproveitando teclas de calculadoras, mudando a disposi¸c˜ao

(horizontal e vertical) delas, at´e se obter teclas que se adaptassem melhor ao tamanho da

estrutura e tamb´em aos push-buttons.

O prot´otipo desenvolvido ´e um incentivo para pesquisas multidisciplinares entre

a matem´atica, eletrˆonica e programa¸c˜ao, o prot´otipo pode ser ampliado n˜ao s´o em di-

mens˜oes f´ısicas (quantidades de LEDs), mas tamb´em quanto `a sua aplica¸c˜ao, utilizando

os m´etodos n´umericos apresentados para plotagem de fun¸c˜oes n˜ao lineares, como as po-

linomiais, logar´ıtmicas e exponenciais e tamb´em em outras assuntos da matem´atica. O

47

software Maxima possibitou a exibi¸c˜ao do funcionamento de tais m´etodos, servindo como

base para sua aplica¸c˜ao em outras plataformas microcontroladas ou n˜ao.

Aliando o ensino da matem´atica `a uma ferramenta tecnol´ogica, al´em de facilitar

a visualiza¸c˜ao de conceitos matem´aticos abstratos, desperta o interesse do aluno, j´a que

passar´a a lidar com um elemento novo no usual padr˜ao de ensino da matem´atica, que tem

uma abordagem muita mais te´orica do que pr´atica.

Para trabalhos futuros ´e poss´ıvel replicar o prot´otipo com outros microcontrola-

dores, ou em dimens˜oes maiores, ou at´e mesmo utilizar microncontroladores, eletrˆonica e

a rob´otica para desenvolvimento de outras ferramentas de ensino.

48

Referˆencias Bibliogr´aﬁcas

Comiss˜ao Organizadora. Campus Party. Dispon´ıvel em: <http://brasil.campus-

party.org/>.

Comiss˜ao Organizadora. FEBRACE. Dispon´ıvel em: <http://febrace.org.br/>.

Comiss˜ao Organizadora. Olimp´ıada Brasileira

de Rob´otica. Dispon´ıvel

em:

<http://www.obr.org.br/>.

IFRN. Projeto de rob´otica conquista 3” lugar geral na Febrace 2015. Dispon´ıvel

em:

<http://portal.ifrn.edu.br/campus/reitoria/noticias/com-projeto-de-robotica-

alunos-do-campus-pau-dos-ferros-garantem-3o-lugar-geral-na-febrace-2015>.

Acesso

em: abril de 2018.

Brasil. Minist´erio da Educa¸c˜ao. Estudantes brasileiros ganham certiﬁcado de ex-

celˆencia no Jap˜ao. Dispon´ıvel em: <http://portal.mec.gov.br/ultimas-noticias/209-

564834057/32851-estudantes-brasileiros-ganham-certiﬁcado-de-excelencia-no-japao>.

Acesso em: abril de 2018.

Porto,

A.

Brasileiro

campe˜ao mundial

de

rob´otica. Dispon´ıvel

em:

<https://www.metrojornal.com.br/foco/2017/07/27/brasileiro-e-campeao-mundial-

de-robotica.html>. Acesso em: maio de 2018.

Arduino Group. Getting Started with Arduino and Genuino products. Dispon´ıvel

em: <https://www.arduino.cc/en/Guide/HomePage>. Acesso em: setembro de 2017.

49

AudioGroup.

C´odigo

de

Cores

de

Resistores.

Dispon´ıvel

em:

<http://encurtador.com.br/cuEGR>. Acesso em: outubro de 2017.

Golbert, C. S. Novos rumos na aprendizagem de matem´atica. Porto Alegre: Me-

dia¸c˜ao, 2002.

Bettega, M. H. S. Educa¸c˜ao continuada na era digital. 2 ed. S˜ao Paulo: Cortez,

2010.

Rodrigues, W.

S. Atividades

com rob´otica

educacional

para

as

au-

las

de matem´atica

do

6”

ao

9” Ano

do Ensino Fundamental:

liza¸c˜ao

da metodologia

LEGOﬁ Zoom Education.

Dispon´ıvel

uti-

em:

<https://repositorio.unesp.br/bitstream/handle/11449/127594/000844410.pdf>.

Acesso em: em maio de 2018.

Rodarte, A. P. M. A Rob´otica como aux´ılio `a aprendizagem da matem´atica:

percep¸c˜oes

de

uma

professora

do

ensino

fundamental

p´ublico. Dispon´ıvel

em:<https://encurtador.com.br/aCPUV>. Acesso em: abril de 2018.

Almeida, D. S. Uso da plataforma arduino para o ensino e aprendizado de matem´atica.

Dispon´ıvel em: <http://webartigos.com/artigos/uso-da-plataforma-arduino-para-o-

ensino-e-aprendizado-de-matematica/150524>. Acesso em: de outubro de 2017.

Guidorizzi, H. L. Um Curso de C´alculo. Rio de Janeiro: LTC, 2013.

Stewart, J. C´alculo. Rio de Janeiro: Thomson, 2013.

Lima, E. L. N´umeros e Fun¸c˜oes Reais. Cole¸c˜ao Profmat. Porto Alegre: SBM,

2013.

Brasil. Minist´erio da Educa¸c˜ao. Secretaria de Educa¸c˜ao M´edia e Tecnol´ogica.

Parˆametros Curriculares Nacionais: Ensino M´edio. Bras´ılia, 2000.

50

Brasil. Minist´erio da Educa¸c˜ao. Secretaria de Educa¸c˜ao M´edia e Tecnol´ogica.

Parˆametros Curriculares Nacionais: Matem´atica. Bras´ılia, 1997.

Hohenwarter, M. GeoGebra Graphing Calculator, version 6.0. Calculadora Gr´aﬁca.

Dispon´ıvel em: <https://www.geogebra.org/download>. Acesso em: janeiro de 2018.

MIT.

Maxima,

version

5.41.0.

CAS

Software.

Dispon´ıvel

em:

<http://maxima.sourceforge.net/download.html>. Acesso em: abril de 2018.

Interaction Design Lab Potsdam. Fritzing, version 0.9.3b. CAD Software. Dispon´ıvel

em: <http://fritzing.org/download/ >. Acesso em: dezembro de 2017.

51

Apˆendice: C´odigo do programa do

prot´otipo

include < W ire.h > include < LiquidCrystalI2C.h > //T ECLADOintbot1 =

23; intbot2 = 25; intbot3 = 27; intbot4 = 29; intbot5 = 31; intbot6 = 33; intbot7 =

35; intbot8 = 37; intbot9 = 39; intbot0 = 41; intbotX = 43;

int b1 = 0; int b2 = 0; int b3 = 0; int b4 = 0; int b5 = 0; int b6 = 0; int b7 =

0; int b8 = 0; int b9 = 0; int b0 = 0; int bX = 0;

// PORTAS DAS COLUNAS DO PAINEL int coluna1 = 2; int coluna2 = 3; int

coluna3 = 4; int coluna4 = 5; int coluna5 = 6; int coluna6 = 7; int coluna7 = 8; int

coluna8 = 9; int coluna9 = 10; int coluna10 = 11; int coluna11 = 12;

//PORTAS DAS LINHAS DO PAINEL int linha1 = 22; int linha2 = 24; int

linha3 = 26; int linha4 = 28; int linha5 = 30; int linha6 = 32; int linha7 = 34; int linha8

= 36; int linha9 = 38; int linha10 = 40; int linha11 = 42;

LiquidCrystalI2Clcd(0x3F, 2, 1, 0, 4, 5, 6, 7, 3, P OSIT IV E); //P ORT ASDOLCD

int a = 0; int b = 0; int c = 0; int d = 0;

void setup() pinMode(bot1, INPUT); pinMode(bot2, INPUT); pinMode(bot3,

INPUT); pinMode(bot4, INPUT); pinMode(bot5, INPUT); pinMode(bot6, INPUT); pin-

Mode(bot7, INPUT); pinMode(bot8, INPUT); pinMode(bot9, INPUT); pinMode(bot0,

INPUT); pinMode(botX, INPUT);

pinMode(coluna1, OUTPUT); pinMode(coluna2, OUTPUT); pinMode(coluna3,

OUTPUT); pinMode(coluna4, OUTPUT); pinMode(coluna5, OUTPUT); pinMode(coluna6,

OUTPUT); pinMode(coluna7, OUTPUT); pinMode(coluna8, OUTPUT); pinMode(coluna9,

OUTPUT); pinMode(coluna10, OUTPUT); pinMode(coluna11, OUTPUT);

pinMode(linha1, OUTPUT); pinMode(linha2, OUTPUT); pinMode(linha3, OUT-

PUT); pinMode(linha4, OUTPUT); pinMode(linha5, OUTPUT); pinMode(linha6, OUT-

52

PUT); pinMode(linha7, OUTPUT); pinMode(linha8, OUTPUT); pinMode(linha9, OUT-

PUT); pinMode(linha10, OUTPUT); pinMode(linha11, OUTPUT); Serial.begin(9600);

lcd.begin(16, 2); lcd.setBacklight(HIGH);

void loop()

leituraTeclado();

lcd.clear(); lcd.setCursor(0, 0); lcd.print(”Painel de Leds:”); lcd.setCursor(0, 1);

lcd.print(”Coeﬁciente a?”);

while (bX == 0) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(0, 0, 0, 0, 0, 0, 0, 0,

0, 0, 0); //desliga todos coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1,

1, 1); //acende eixo x coluna(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1,

1);

leituraTeclado();

if (b1 == HIGH) c = 1; else if (b2 == HIGH) c = 2; else if (b3 == HIGH) c

= 3; else if (b4 == HIGH) c = 4; else if (b5 == HIGH) c = 5; else if (b6 == HIGH)

c = 6; else if (b7 == HIGH) c = 7; else if (b8 == HIGH) c = 8; else if (b9 == HIGH)

c = 9; else if (b0 == HIGH) c = 0;

leituraTeclado();

b1 = 0; b2 = 0; b3 = 0; b4 = 0; b5 = 0; b6 = 0; b7 = 0; b8 = 0; b9 = 0; b0 =

0; bX = 0; delay(200);

lcd.clear(); lcd.setCursor(0, 0); lcd.print(”Painel de Leds:”); lcd.setCursor(0, 1);

lcd.print(”1.a+ e 2.a-”); while (bX == 0)

leituraTeclado(); if (b1 == HIGH) a = c; else if (b2 == HIGH) a = ((-1) *

c);

leituraTeclado(); b1 = 0; b2 = 0; b3 = 0; b4 = 0; b5 = 0; b6 = 0; b7 = 0; b8 = 0;

b9 = 0; b0 = 0; bX = 0; delay(200); lcd.clear(); lcd.setCursor(0, 0); lcd.print(”Painel de

Leds:”); lcd.setCursor(0, 1); lcd.print(”Coeﬁciente b?”); while (bX == 0)

leituraTeclado();

if (b1 == HIGH) d = 1; else if (b2 == HIGH) d = 2; else if (b3 == HIGH)

d = 3; else if (b4 == HIGH) d = 4; else if (b5 == HIGH) d = 5; else if (b6 ==

HIGH) d = 6; else if (b7 == HIGH) d = 7; else if (b8 == HIGH) d = 8; else if (b9

== HIGH) d = 9; else if (b0 == HIGH) d = 0;

leituraTeclado();

b1 = 0; b2 = 0; b3 = 0; b4 = 0; b5 = 0; b6 = 0; b7 = 0; b8 = 0; b9 = 0; b0 =

0; bX = 0; delay(200);

lcd.clear(); lcd.setCursor(0, 0); lcd.print(”Painel de Leds:”); lcd.setCursor(0, 1);

53

lcd.print(”1.b+ e 2.b-”); while (bX == 0)

leituraTeclado(); if (b1 == HIGH) b = d; else if (b2 == HIGH) b = ((-1) *

d);

leituraTeclado();

b1 = 0; b2 = 0; b3 = 0; b4 = 0; b5 = 0; b6 = 0; b7 = 0; b8 = 0; b9 = 0; b0 =

0; bX = 0; delay(200);

lcd.clear(); lcd.setCursor(0, 0); lcd.print(”f(x)=”); lcd.print(a); lcd.print(”x+(”);

lcd.print(b); lcd.print(”)”);

//CALCULO DA RAIZ ﬂoat raiz = -(b / a);

lcd.setCursor(0, 1);

lcd.print(”Raiz: ”);

lcd.print(raiz); //CALCULO PARES

ORDENADOS

int y0 = b;

int yn1 = ((a * (-1)) + b); int yn2 = ((a * (-2)) + b); int yn3 = ((a * (-3)) + b);

int yn4 = ((a * (-4)) + b); int yn5 = ((a * (-5)) + b);

int y1 = ((a * 1) + b); int y2 = ((a * 2) + b); int y3 = ((a * 3) + b); int y4 =

((a * 4) + b); int y5 = ((a * 5) + b);

Serial.println(yn1); Serial.println(yn5);

while (b1 == 0 b2 == 0 b3 == 0 b4 == 0 b5 == 0 b6 == 0 b7 == 0 b8

== 0 b9 == 0 b0 == 0 bX == 0) if (y5 == (-5)) coluna(1, 0, 0, 0, 0, 0, 0, 0, 0, 0,

0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0); else if (y5 == (-4)) coluna(1, 0, 0, 0, 0, 0, 0, 0, 0,

0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1); else if (y5 == (-3)) coluna(1, 0, 0, 0, 0, 0, 0, 0,

0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1); else if (y5 == (-2)) coluna(1, 0, 0, 0, 0, 0, 0,

0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1); else if (y5 == (-1)) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1); else if (y5 == 0) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1); else if (y5 == 1) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1); else if (y5 == 2) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1); else if (y5 == 3) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); else if (y5 == 4) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1); else if (y5 == 5) coluna(1, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0); linha(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); else coluna(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);

coluna(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (y4 == (-5)) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1,

54

1, 0); else if (y4 == (-4)) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 0, 1); else if (y4 == (-3)) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1,

1, 0, 1, 1); else if (y4 == (-2)) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 0, 1, 1, 1); else if (y4 == (-1)) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

1, 0, 1, 1, 1, 1); else if (y4 == 0) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

0, 1, 1, 1, 1, 1); else if (y4 == 1) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 0,

1, 1, 1, 1, 1, 1); else if (y4 == 2) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 0, 1,

1, 1, 1, 1, 1, 1); else if (y4 == 3) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 0, 1, 1,

1, 1, 1, 1, 1, 1); else if (y4 == 4) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 0, 1, 1, 1,

1, 1, 1, 1, 1, 1); else if (y4 == 5) coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(0, 1, 1, 1, 1,

1, 1, 1, 1, 1, 1); else coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

1); coluna(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (y3 == (-5)) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1,

1, 0); else if (y3 == (-4)) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 0, 1); else if (y3 == (-3)) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1,

1, 0, 1, 1); else if (y3 == (-2)) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 0, 1, 1, 1); else if (y3 == (-1)) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

1, 0, 1, 1, 1, 1); else if (y3 == 0) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

0, 1, 1, 1, 1, 1); else if (y3 == 1) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 0,

1, 1, 1, 1, 1, 1); else if (y3 == 2) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 0, 1,

1, 1, 1, 1, 1, 1); else if (y3 == 3) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 0, 1, 1,

1, 1, 1, 1, 1, 1); else if (y3 == 4) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 0, 1, 1, 1,

1, 1, 1, 1, 1, 1); else if (y3 == 5) coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(0, 1, 1, 1, 1,

1, 1, 1, 1, 1, 1); else coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

1); coluna(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (y2 == (-5)) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1,

1, 0); else if (y2 == (-4)) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 0, 1); else if (y2 == (-3)) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1,

1, 0, 1, 1); else if (y2 == (-2)) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 0, 1, 1, 1); else if (y2 == (-1)) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

1, 0, 1, 1, 1, 1); else if (y2 == 0) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

0, 1, 1, 1, 1, 1); else if (y2 == 1) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 0,

55

1, 1, 1, 1, 1, 1); else if (y2 == 2) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 0, 1,

1, 1, 1, 1, 1, 1); else if (y2 == 3) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 0, 1, 1,

1, 1, 1, 1, 1, 1); else if (y2 == 4) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 0, 1, 1, 1,

1, 1, 1, 1, 1, 1); else if (y2 == 5) coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(0, 1, 1, 1, 1,

1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

1); coluna(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (y1 == (-5)) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1,

1, 0); else if (y1 == (-4)) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 0, 1); else if (y1 == (-3)) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1,

1, 0, 1, 1); else if (y1 == (-2)) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 0, 1, 1, 1); else if (y1 == (-1)) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

1, 0, 1, 1, 1, 1); else if (y1 == 0) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

0, 1, 1, 1, 1, 1); else if (y1 == 1) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 0,

1, 1, 1, 1, 1, 1); else if (y1 == 2) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 0, 1,

1, 1, 1, 1, 1, 1); else if (y1 == 3) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 0, 1, 1,

1, 1, 1, 1, 1, 1); else if (y1 == 4) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 0, 1, 1, 1,

1, 1, 1, 1, 1, 1); else if (y1 == 5) coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(0, 1, 1, 1, 1,

1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

1); coluna(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (y0 == (-5)) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1,

1, 0); else if (y0 == (-4)) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 0, 1); else if (y0 == (-3)) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1,

1, 0, 1, 1); else if (y0 == (-2)) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 0, 1, 1, 1); else if (y0 == (-1)) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

1, 0, 1, 1, 1, 1); else if (y0 == 0) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1,

0, 1, 1, 1, 1, 1); else if (y0 == 1) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 0,

1, 1, 1, 1, 1, 1); else if (y0 == 2) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 0, 1,

1, 1, 1, 1, 1, 1); else if (y0 == 3) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 0, 1, 1,

1, 1, 1, 1, 1, 1); else if (y0 == 4) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 0, 1, 1, 1,

1, 1, 1, 1, 1, 1); else if (y0 == 5) coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(0, 1, 1, 1, 1,

1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

1); coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

56

if (yn1 == (-5)) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 1, 0); else if (yn1 == (-4)) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 1, 1, 0, 1); else if (yn1 == (-3)) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0); linha(1, 1, 1, 1,

1, 1, 1, 1, 0, 1, 1); else if (yn1 == (-2)) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0); linha(1,

1, 1, 1, 1, 1, 1, 0, 1, 1, 1); else if (yn1 == (-1)) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0);

linha(1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1); else if (yn1 == 0) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0,

0); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1); else if (yn1 == 1) coluna(0, 0, 0, 0, 0, 0, 1, 0, 0,

0, 0); linha(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1); else if (yn1 == 2) coluna(0, 0, 0, 0, 0, 0, 1, 0,

0, 0, 0); linha(1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1); else if (yn1 == 3) coluna(0, 0, 0, 0, 0, 0, 1,

0, 0, 0, 0); linha(1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn1 == 4) coluna(0, 0, 0, 0, 0, 0,

1, 0, 0, 0, 0); linha(1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn1 == 5) coluna(0, 0, 0, 0, 0,

0, 1, 0, 0, 0, 0); linha(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0,

0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); coluna(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0); linha(1, 1, 1,

1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (yn2 == (-5)) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 1, 0); else if (yn2 == (-4)) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 1, 1, 0, 1); else if (yn2 == (-3)) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0); linha(1, 1, 1, 1,

1, 1, 1, 1, 0, 1, 1); else if (yn2 == (-2)) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0); linha(1,

1, 1, 1, 1, 1, 1, 0, 1, 1, 1); else if (yn2 == (-1)) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0);

linha(1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1); else if (yn2 == 0) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0,

0); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1); else if (yn2 == 1) coluna(0, 0, 0, 0, 0, 0, 0, 1, 0,

0, 0); linha(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1); else if (yn2 == 2) coluna(0, 0, 0, 0, 0, 0, 0, 1,

0, 0, 0); linha(1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1); else if (yn2 == 3) coluna(0, 0, 0, 0, 0, 0, 0,

1, 0, 0, 0); linha(1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn2 == 4) coluna(0, 0, 0, 0, 0, 0,

0, 1, 0, 0, 0); linha(1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn2 == 5) coluna(0, 0, 0, 0, 0,

0, 0, 1, 0, 0, 0); linha(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0,

0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); coluna(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0); linha(1, 1, 1,

1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (yn3 == (-5)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 1, 0); else if (yn3 == (-4)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0); linha(1, 1, 1, 1, 1, 1,

1, 1, 1, 0, 1); else if (yn3 == (-3)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0); linha(1, 1, 1, 1,

1, 1, 1, 1, 0, 1, 1); else if (yn3 == (-2)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0); linha(1,

57

1, 1, 1, 1, 1, 1, 0, 1, 1, 1); else if (yn3 == (-1)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0);

linha(1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1); else if (yn3 == 0) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0,

0); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1); else if (yn3 == 1) coluna(0, 0, 0, 0, 0, 0, 0, 0, 1,

0, 0); linha(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1); else if (yn3 == 2) coluna(0, 0, 0, 0, 0, 0, 0, 0,

1, 0, 0); linha(1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1); else if (yn3 == 3) coluna(0, 0, 0, 0, 0, 0, 0,

0, 1, 0, 0); linha(1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn3 == 4) coluna(0, 0, 0, 0, 0, 0,

0, 0, 1, 0, 0); linha(1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn3 == 5) coluna(0, 0, 0, 0, 0,

0, 0, 0, 1, 0, 0); linha(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0,

0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);

coluna(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (yn4 == (-5)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 1, 0); else if (yn4 == (-4)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0); linha(1, 1, 1, 1, 1, 1,

1, 1, 1, 0, 1); else if (yn4 == (-3)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0); linha(1, 1, 1, 1,

1, 1, 1, 1, 0, 1, 1); else if (yn4 == (-2)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0); linha(1,

1, 1, 1, 1, 1, 1, 0, 1, 1, 1); else if (yn4 == (-1)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0);

linha(1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1); else if (yn4 == 0) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1,

0); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1); else if (yn4 == 1) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0,

1, 0); linha(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1); else if (yn4 == 2) coluna(0, 0, 0, 0, 0, 0, 0, 0,

0, 1, 0); linha(1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1); else if (yn4 == 3) coluna(0, 0, 0, 0, 0, 0, 0,

0, 0, 1, 0); linha(1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn4 == 4) coluna(0, 0, 0, 0, 0, 0,

0, 0, 0, 1, 0); linha(1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn4 == 5) coluna(0, 0, 0, 0, 0,

0, 0, 0, 0, 1, 0); linha(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1,

0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0); linha(1, 1, 1,

1, 1, 1, 1, 1, 1, 1, 1); delay(2);

if (yn5 == (-5)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1); linha(1, 1, 1, 1, 1, 1, 1, 1,

1, 1, 0); else if (yn5 == (-4)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1); linha(1, 1, 1, 1, 1, 1,

1, 1, 1, 0, 1); else if (yn5 == (-3)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1); linha(1, 1, 1, 1,

1, 1, 1, 1, 0, 1, 1); else if (yn5 == (-2)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1); linha(1,

1, 1, 1, 1, 1, 1, 0, 1, 1, 1); else if (yn5 == (-1)) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);

linha(1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1); else if (yn5 == 0) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

1); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1); else if (yn5 == 1) coluna(0, 0, 0, 0, 0, 0, 0, 0, 0,

0, 1); linha(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1); else if (yn5 == 2) coluna(0, 0, 0, 0, 0, 0, 0, 0,

58

0, 0, 1); linha(1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1); else if (yn5 == 3) coluna(0, 0, 0, 0, 0, 0, 0,

0, 0, 0, 1); linha(1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn5 == 4) coluna(0, 0, 0, 0, 0, 0,

0, 0, 0, 0, 1); linha(1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1); else if (yn5 == 5) coluna(0, 0, 0, 0, 0,

0, 0, 0, 0, 0, 1); linha(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); else coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

1); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1); linha(1, 1, 1,

1, 1, 1, 1, 1, 1, 1, 1); delay(2);

coluna(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0); linha(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); delay(2);

//desliga todos coluna(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); linha(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);

//acende eixo x coluna(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); linha(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1);

delay(2); leituraTeclado();

void coluna (int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int

k) digitalWrite(coluna1, a); digitalWrite(coluna2, b); digitalWrite(coluna3, c); digital-

Write(coluna4, d); digitalWrite(coluna5, e); digitalWrite(coluna6, f); digitalWrite(coluna7,

g); digitalWrite(coluna8, h); digitalWrite(coluna9, i); digitalWrite(coluna10, j); digital-

Write(coluna11, k);

void linha (int l, int m, int n, int o, int p, int q, int r, int s, int t, int u,

int v) digitalWrite(linha1, l); digitalWrite(linha2, m); digitalWrite(linha3, n); digital-

Write(linha4, o); digitalWrite(linha5, p); digitalWrite(linha6, q); digitalWrite(linha7, r);

digitalWrite(linha8, s); digitalWrite(linha9, t); digitalWrite(linha10, u); digitalWrite(linha11,

v);

//LEITURA DO TECLADO void leituraTeclado() b1 = digitalRead(bot1); b2

= digitalRead(bot2); b3 = digitalRead(bot3); b4 = digitalRead(bot4); b5 = digital-

Read(bot5); b6 = digitalRead(bot6); b7 = digitalRead(bot7); b8 = digitalRead(bot8);

b9 = digitalRead(bot9); b0 = digitalRead(bot0); bX = digitalRead(botX);

59

