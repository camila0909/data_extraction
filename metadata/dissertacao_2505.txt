Congruências modulares e aplicações no ensino básico

Janayna Mara Rezende Barbosa

Dissertação de Mestrado do Programa de Mestrado Proﬁssional em
Matemática em Rede Nacional (PROFMAT)

UNIVERSIDADE DE SÃO PAULOInstituto de Ciências Matemáticas e de ComputaçãoSERVIÇO DE PÓS-GRADUAÇÃO DO ICMC-USP

Data de Depósito:

Assinatura: ______________________

Janayna Mara Rezende Barbosa

Congruências modulares e aplicações no ensino básico

Dissertação apresentada ao Instituto de Ciências
Matemáticas e de Computação – ICMC-USP,
como parte dos requisitos para obtenção do título
de Mestra em Ciências – Mestrado Proﬁssional em
Matemática em Rede Nacional. VERSÃO REVISADA

Área de Concentração: Mestrado Proﬁssional em
Matemática em Rede Nacional

Orientadora: Profa. Dra. Katia Andreia Gonçalves
de Azevedo

USP – São Carlos
Novembro de 2017

Ficha catalográfica elaborada pela Biblioteca Prof. Achille Bassi e Seção Técnica de Informática, ICMC/USP, com os dados fornecidos pelo(a) autor(a)R467cRezende Barbosa, Janayna Mara   Congruências modulares e aplicações no ensinobásico / Janayna Mara Rezende Barbosa; orientadoraKatia Andreia Gonçalves Azevedo. -- São Carlos, 2017.   112 p.   Dissertação (Mestrado - Programa de Pós-Graduaçãoem Mestrado Profissional em Matemática em RedeNacional) -- Instituto de Ciências Matemáticas e deComputação, Universidade de São Paulo, 2017.   1. Teoria dos Números. 2. Congruências. 3. Códigode barras. I. Azevedo, Katia Andreia Gonçalves,orient. II. Título. Janayna Mara Rezende Barbosa

Modular congruence and applications in basic education

Master dissertation submitted to the Institute of
Mathematics and Computer Sciences – ICMC-USP, in
partial fulﬁllment of the requirements for the degree of
Mathematics Professional Master’s Program. FINAL
VERSION

Concentration Area: Professional Master Degree
Program in Mathematics in National Network

Advisor: Profa.
de Azevedo

Dra.

Katia Andreia Gonçalves

USP – São Carlos
November 2017

Aos meus pais que sempre me incentivaram a estudar e a lutar pelos meus sonhos.

AGRADECIMENTOS

Agradeço em primeiro lugar a Deus, por essa oportunidade e por me dar forças nos

momentos em que mais precisei.

Aos meus pais, que não mediram esforços para facilitar que eu chegasse até aqui, pelo

amor e por todas as orações que ﬁzeram.

Às minhas ﬁlhas, Maria Clara e Maria Luísa, que compreenderam a minha ausência em

vários momentos para realizar esse trabalho.

Ao meu irmão, Junior, pelo companheirismo durante essa caminhada.

À minha professora e orientadora, Prof. Dra. Katia Andrea Gonçalves de Azevedo, por
toda dedicação e paciência, por ter acreditado no meu potencial, incentivando a seguir em frente
sempre.

A todos os professores do Profmat, polo de Ribeirão Preto, pelo empenho e atenção

destinados aos alunos e por toda preocupação em garantir um curso de boa qualidade.

Ao programa Profmat, pela oportunidade de crescimento proﬁssional.

À Capes, pelo incentivo e ﬁnanciamento do curso.

A todos os colegas de turma, pelas trocas de conhecimento que ﬁzemos, principalmente
à Priscila e ao Talles, por serem também companheiros das idas e vindas ao curso e ao amigo
Rafael a quem agradeço imensamente todo o apoio para a digitação deste trabalho.

Enﬁm, agradeço a todos que contribuíram de alguma forma, para que esse objetivo fosse

alcançado.

“Fiz a escalada da montanha da vida,
removendo pedras e plantando ﬂores”
(Cora Coralina)

RESUMO

BARBOSA, J. M. Congruências modulares e aplicações no ensino básico. 2017. 112
p. Dissertação (Mestrado em Ciências – Mestrado Proﬁssional em Matemática em Rede
Nacional) – Instituto de Ciências Matemáticas e de Computação, Universidade de São Paulo,
São Carlos – SP, 2017.

O presente trabalho inicia-se com uma breve história sobre a evolução da Teoria dos Números,
destacando os estudiosos que tiveram grande importância para o reconhecimento dessa parte
da Matemática. Logo após, é feita uma fundamentação teórica dos principais tópicos da
Teoria dos Números, ressaltando alguns teoremas e apresentando exemplos de aplicações
em várias áreas da Matemática. É apresentado um estudo a respeito dos diversos sistemas
de codiﬁcação que fazem o uso do dígito veriﬁcador, com o objetivo de motivar o aluno
a entender um pouco sobre o conceito de aritmética modular, de maneira fácil, rápida e
simples. Para ﬁnalizar são apresentados relatos de atividades realizadas com alunos do
ensino básico, envolvendo códigos de barras, visando ressaltar a importância de entender a
aplicabilidade das congruências nos dias de hoje.

Palavras-chave: Teoria dos números, Congruências e Códigos de barras.

ABSTRACT

BARBOSA, J. M. Modular congruence and applications in basic education. 2017. 112
p. Dissertação (Mestrado em Ciências – Mestrado Proﬁssional em Matemática em Rede
Nacional) – Instituto de Ciências Matemáticas e de Computação, Universidade de São Paulo,
São Carlos – SP, 2017.

His work starts by describing a brief history on the development of Numbers Theory, high-
lighting the ones who had great importance for the recognition of this part of Mathematics.
Next, a theoretical framework of the main topics of Numbers Theory is made, emphasizing
some theorems and presenting examples of applications in several areas of Mathematics.
A survey is done about several coding systems that use check digit, in order to motivate
the student to understand the concept of modular arithmetic, in an easy, fast and simple
way. Finally, we present reports of activities carried out with students of basic education,
involving bar codes, in order to highlight the importance of understanding the applicability
of congruences nowadays.

Keywords: Theory of Numbers, Congruences and Barcodes.

LISTA DE ILUSTRAÇÕES

Figura 1 – Engrenagens.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

39

.

80
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 2 – Woodland e Silver .
80
. . . . . . . . . . . . . . . . . . . .
Figura 3 – Modelo do Primeiro Código de Barras.
81
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 4 – George J. Laurer.
81
. . . . . . . . . . . . . . . . . . . . .
Figura 5 – Exemplo de códigos de barras UPC.
82
Figura 6 – Exemplo de códigos de barras EAN-13.
. . . . . . . . . . . . . . . . . . .
85
Figura 7 – Código de Barras de um macarrão instantâneo. . . . . . . . . . . . . . . . .
86
Figura 8 – Estrutura do Código de Barras.
. . . . . . . . . . . . . . . . . . . . . . . .
88
Figura 9 – Código de Barras de um Medicamento. . . . . . . . . . . . . . . . . . . . .
89
. . . . . . . . . . . . . . . . .
Figura 10 – Código de Barras de um Leite Condensado.
95
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 11 – QR Code (a). .
.
.
98
Figura 12 – Partes que compõem o número do Cartão de Crédito.
. . . . . . . . . . . .
99
Figura 13 – Número de um Cartão de Crédito. . . . . . . . . . . . . . . . . . . . . . . .
Figura 14 – Cartão ﬁctício da Internet. . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
Figura 15 – Alunos na sala de vídeo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
. . . . . . . . . . . . . 104
Figura 16 – Imagem de um QR code com atividade Matemática.
Figura 17 – QR codes criados pelos alunos.
. . . . . . . . . . . . . . . . . . . . . . . . 105
Figura 18 – Alunos expondo embalagem e a estrutura de um código de barras (a). . . . . 106
Figura 19 – Alunos expondo embalagem e a estrutura de um código de barras (b). . . . . 106
Figura 20 – Alunos expondo embalagem e a estrutura de um código de barras (c). . . . . 107
. . . . . . . . . . . . . . 109
Figura 21 – Alunos determinando o dígito veriﬁcador do CPF.

.

LISTA DE TABELAS

Tabela 1 – Crivo de Eratóstenes.
Tabela 2 – Soma em Z6. .
.
Tabela 3 – Multiplicação em Z6.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

56
75
75

82
. . . . . . . . . . . . . . . . . . . . . . . . . .
Tabela 4 – Cor e espessura das listras.
83
. . . . . . . . . . . . . . . . . . . . . . . .
Tabela 5 – Codiﬁcação para código UPC.
84
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Tabela 6 – Codiﬁcação EAN-13.
84
Tabela 7 – Codiﬁcação do lado esquerdo do código EAN-13.
. . . . . . . . . . . . . .
94
Tabela 8 – Capacidade de armazenamento de um QR Code. . . . . . . . . . . . . . . .
Tabela 9 – Dígito da federação. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
Tabela 10 – Dígito da federação. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

SUMÁRIO

1 Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2 Um pouco da História da Teoria dos Números

. . . . . . . . . . . . . . . . 23

3 Principais Conceitos e Teoremas

. . . . . . . . . . . . . . . . . . . . . . . . 27

.

.

.

.

.

.

3.1 Princípio da Boa Ordenação . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Divisibilidade .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.1 Divisão Euclidiana . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.2 Paridade .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.3 Máximo Divisor Comum . . . . . . . . . . . . . . . . . . . . . . . .
3.2.4 Mínimo Múltiplo Comum . . . . . . . . . . . . . . . . . . . . . . .
3.2.5 Equações Diofantinas . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.6 Pequeno Teorema de Fermat e Números Especiais . . . . . . . .
3.2.7 Teorema Fundamental da Aritmética . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.1 Classes Residuais . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.3 Congruências

.

.

.

.

27
33
37
38
39
47
48
51
54
58
71

4 Sistemas de Codificação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.1 Estudo de Alguns Sistemas de Codificação . . . . . . . . . . . . . . . . .
79
4.1.1 Códigos de Barras . . . . . . . . . . . . . . . . . . . . . . . . . . .
79
4.1.2 Estrutura do Código de Barras . . . . . . . . . . . . . . . . . . . .
82
4.1.3 Erros detectáveis e Erros não detectáveis . . . . . . . . . . . . .
87
4.1.4 QR Code .
94
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.5 Outros Códigos Numéricos . . . . . . . . . . . . . . . . . . . . . .
96
4.1.6 Relação entre pesos e módulo . . . . . . . . . . . . . . . . . . . . 100
4.2 Aplicação em sala de aula . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

.

.

REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

21

CAPÍTULO

1

INTRODUÇÃO

A Teoria dos Números é um ramo da Matemática que estuda as propriedades dos números
em geral. Ela é dividida em vários campos, sendo um deles dedicado ao estudo das propriedades
dos números inteiros.

Uma das ferramentas importantes da Teoria dos Números é a congruência modular, que

envolve o estudo de congruências no conjunto dos números inteiros.

A principal motivação para escolha do tema Congruências Modulares e Aplicações no
Ensino Básico para esse trabalho, foi que, fazendo o uso das novas tecnologias, juntamente
com conceitos aplicáveis dessa parte da Matemática, podemos compreender melhor o mundo de
informações que nos cerca.

O professor de Matemática, com o objetivo de proporcionar aos alunos o desenvolvimento
de competências e habilidades que garantam a formação do cidadão, frente a um novo perﬁl de
proﬁssional, pode fazer o uso em sala de aula de atividades diversas, e neste trabalho propomos
aplicações de congruências modulares.

Uma destas aplicações é relativa aos sistemas de codiﬁcações, ressaltando os códigos
de barras. Estes são usados pelo mundo todo para a identiﬁcação de produtos, facilitando a
organização e contagem de estoques, além de agilizar o processo de entrada e saída dos produtos.

Além disso, em diversos campos da Matemática, temos problemas que podem ter a sua

resolução facilitada se usarmos os teoremas e propriedades da Teoria dos Números.

O objetivo deste trabalho é ainda mostrar como conceitos da Teoria dos Números estão
presentes no nosso dia-a-dia e o quanto é importante a aplicação de seus conceitos para resolução
de problemas diversos.

No capítulo II é feito um levantamento do contexto histórico da evolução dos estudos
relacionados à Teoria dos Números, tentando ressaltar os grandes matemáticos que contribuíram
de alguma forma para o reconhecimento e estudo dessa parte da Matemática.

22

Capítulo 1. Introdução

No capítulo III é apresentada uma fundamentação teórica, com estudos dos principais

teoremas e conceitos que serão usados ao longo do trabalho e nas aplicações.

No capítulo IV, primeiramente, é contada um pouco da história dos códigos de barras.
A seguir, é feito um estudo sobre sua estrutura e a obtenção do dígito veriﬁcador. É mostrado
também como é possível ou não detectar um erro ao se digitar os algarismos de um código
de barras. Além do código de barras, o trabalho também faz o estudo de outros sistemas de
codiﬁcações que fazem o uso do dígito veriﬁcador. É apresentado relato de atividades que foram
trabalhadas com alunos do 9oano do ensino básico, relativo ao tema, em uma escola pública do
estado de Minas Gerais.

É esperado que, a partir desse trabalho muitos outros possam surgir para completá-lo e
enriquecê-lo com outras aplicações de congruências modulares que possam ser adequadamente
utilizadas nas aulas ministradas por professores de Matemática na educação básica, procu-
rando sempre motivar os alunos e desenvolver competências e habilidades necessárias para sua
formação e atuação na sociedade em que vivemos.

23

CAPÍTULO

2

UM POUCO DA HISTÓRIA DA TEORIA DOS
NÚMEROS

A forma de compreender e representar os números, respondendo a uma necessidade do

homem de representar quantidades, foram evoluindo ao longo da história.

Embora os números inteiros positivos compõem o sistema matemático mais simples,
o estudo de suas propriedades exerce grande fascínio na mente humana desde a antiguidade,
desaﬁando inúmeros estudiosos através de seus conceitos e propriedades que vão além de
qualquer simplicidade.

Os sumérios, por volta de 2500 a.C., já possuíam um calendário e faziam o uso da base

sexagesimal. Já desenvolviam algum tipo de aritmética no estudo da astronomia.

No Antigo Egito encontra-se o Papiro de Rhind ou Papiro de Ahmes. Esse documento
egípcio é datado de 1650 a.C., onde um escriba de nome Ahmes detalha a solução de 85
problemas de aritmética, frações, cálculo de áreas, volumes e progressões. É um dos documentos
antigos mais famosos que descreve registros onde é possível perceber como a Matemática era
praticada naquela época.

A Teoria dos Números é um ramo da Matemática que se preocupa com as propriedades
dos números inteiros e com os problemas que surgiram naturalmente do estudo dos números
inteiros. A Teoria dos Números também já foi chamada de Aritmética Superior. Esse termo caiu
em desuso.

A primeira abordagem cientíﬁca da Teoria dos Números é atribuída aos gregos, por
volta de 450 a.C. Pitágoras e seus seguidores, chamados de pitagóricos, foram os primeiros a
classiﬁcar os números em pares, ímpares e primos.

Entre os problemas da Teoria dos Números abordados pelos gregos antigos, podemos
citar o cálculo do máximo divisor comum de dois números, a determinação dos números primos

24

Capítulo 2. Um pouco da História da Teoria dos Números

menores que um inteiro dado e a demonstração de que há uma inﬁnidade de números primos.

Podemos citar também Euclides de Alexandria (330-275 a.C.). Ele, a pedido do imperador
Ptolomeu I, organizou a obra “Os Elementos”, composta de 13 livros. Destes, os livros VII, VIII
e IX são dedicados à Teoria dos Números onde encontramos conceitos numéricos expressos em
linguagem geométrica. Outro matemático de destaque é Diofanto de Alexandria, (nascido entre
201 e 214 e falecido entre 284 e 298). Sua obra Arithmetica, escrita por volta de 250 d.C., trata
principalmente da solução de equações indeterminadas com coeﬁcientes inteiros.

Embora a Matemática tenha sido continuadamente estudada por outros autores gregos e
posteriormente, por árabes, indianos e europeus, a parte da Teoria dos Números ﬁcou esquecida
até o início do século XVII.

Em 1612, Bachet (1581-1638), outro grande matemático de destaque na Teoria dos
Números, publicou o texto original em grego de Diofanto incluindo uma tradução latina. Entre
1621 e 1632 o francês Pierre de Fermat (1601-1665), adquiriu a cópia do livro de Bachet, fazendo
um estudo e anotando nas margens as ideias que lhe ocorriam. Essas anotações posteriormente
serviram de base para importantes resultados.

Naquela época, a Matemática era exercida como proﬁssão por poucas pessoas. A comu-
nicação entre os estudiosos era precária e se dava através de cartas e por pessoas que serviam de
difusores das novas ideias. Uma das pessoas que se destacou nesse papel foi Marin Mersenne
(1588-1648). Ele mantinha correspondência com alguns dos maiores matemáticos da época,
como Descartes, Pascal e Fermat.

Nessa época, existia a República das Letras, que era uma espécie de sociedade informal de
estudiosos, professores, bibliotecários, jornalistas, inventores, historiadores e artistas. Mersenne
comunicava as novidades matemáticas que chegavam ao seu conhecimento à essa República.

Depois da morte de Pierre de Fermat, em 1665, coube a Samuel Fermat, seu ﬁlho, coletar
e publicar a obra de seu pai. Dessas anotações, a parte de maior destaque foi o Último Teorema
de Fermat.

O sucessor de Fermat foi o suiço Leonhard Euler (1707-1783). Euler publicou uma
imensa obra Matemática, contribuindo para quase todas as áreas da Matemática pura e aplicada
existentes no século XVIII. Este esteve ligado a academias cientíﬁcas na Alemanha e na Rússia,
que eram instituições de pesquisas que passaram a publicar atas com as contribuições cientíﬁcas
de seus membros.

Christian Goldbach (1690-1764) era um professor da Academia das Ciências de São
Petesburgo. Goldbach escreveu vários documentos relacionados a teorias matemáticas e ﬁcou
conhecido pela conjectura de Goldbach e foi contemporâneo de Euler.

Em 1729, em uma de suas correspondências a Euler, Goldbach mencionou o seguinte
questionamento: “ Você conhece a observação de Fermat de que todos os números da forma

25

22n

+ 1 são primos?”.

Euler não demonstrou muito interesse e só em 1730, começou ﬁnalmente a ler a obra
de Fermat. Nos anos seguintes, este provou grande parte dos resultados enunciados por Fermat,
resolvendo inclusive a questão proposta por Goldbach.

Euler foi responsável pela popularização da Teoria dos Números, mas o estudo de forma
sistematizada, ou seja, de forma metodológica, visando a elaboração do conhecimento, iniciou-se
somente com a obra Disquisitiones Arithmeticae, do alemão Carl Friedrich Gauss (1777-1855),
publicada em 1801.

Gauss foi um matemático, astrônomo e físico alemão que contribuiu muito em diversas
áreas da ciência, dentre elas a Teoria dos Números, Estatística, Análise Matemática, Astronomia
e Óptica. Alguns se referem a ele como “Príncipe da Matemática”. Ele considerava a Matemática
como rainha das ciências.

A Teoria dos Números, desde então, busca descobrir relações que diferentes tipos de

números podem estabelecer.

27

CAPÍTULO

3

PRINCIPAIS CONCEITOS E TEOREMAS

Neste capítulo, apresentamos alguns resultados importantes para o entendimento e

desenvolvimento do trabalho.

3.1 Princípio da Boa Ordenação

Adotaremos aqui o Princípio da Boa Ordenação, que é uma propriedade do conjunto dos

Números Inteiros, como axioma e, como consequência deste, o Princípio de Indução Finita.

Alguns livros, como por exemplo em [9], adota o Princípio de Indução Finita como
axioma e deste enuncia o Princípio da Boa Ordenação. Já em [8], é adotado o Princípio da Boa
Ordenação e deste obtém-se o Princípio de Indução Finita como faremos aqui. Começamos,
primeiramente, com uma deﬁnição.

Deﬁnição 1. Dizemos que um subconjunto S de Z é limitado inferiormente, se existir c ∈ Z tal
que c ≤ x para todo x ∈ S. Dizemos que a ∈ S é um menor elemento de S, se a ≤ x para todo
x ∈ S.

Note que um menor elemento de S, se existir, é único, pois se a e a′ são menores

elementos de S, temos a ≤ a′ e a′ ≤ a, o que acarreta a = a′.

Os conjuntos Z e −N não são limitados inferiormente e nem possuem um menor ele-

mento. Já N é limitado inferiormente e possui 1 como menor elemento.

Princípio da Boa Ordenação: Se S é um subconjunto não vazio de Z e limitado inferi-

ormente, então S possui um menor elemento.

Este axioma diferencia os números inteiros dos racionais e reais. Note que, o intervalo
(0, 1), tanto em Q quanto em R é limitado inferiormente, mas não possui um menor elemento.

28

Capítulo 3. Principais Conceitos e Teoremas

A seguir, serão listadas algumas propriedades dos números inteiros que podem ser

demonstradas com o uso do Princípio da Boa Ordenação.

Proposição 1. Não existe nenhum número inteiro n tal que 0 < n < 1.

Demonstração. Suponha por absurdo que exista n com essa propriedade. Logo, o conjunto
S = {x ∈ Z; 0 < x < 1} é não vazio, além de ser limitado inferiormente. Portanto, S possui
um menor elemento a com 0 < a < 1. Multiplicando esta última desigualdade por a, obtemos
0 < a2 < a < 1. Logo a2 ∈ S e a2 < a, uma contradição. Portanto, S = /0.

Corolário 1. Dado um número inteiro n qualquer, não existe nenhum número inteiro m tal que
n < m < n + 1.

Demonstração. Suponha, por absurdo, que exista um número inteiro m satisfazendo as desigual-
dades n < m < n + 1, logo 0 < m − n < 1, o que contradiz a Proposição 1.

Deﬁnição 2. Dizemos que um subconjunto T de Z é limitado superiormente, se existir d ∈ Z tal
que d ≥ x para todo x ∈ T . Dizemos que um elemento b ∈ Z é o maior elemento de T , se b ≥ x
para todo x ∈ T .

É imediato veriﬁcar que o maior elemento de um conjunto, se existir, é único.

Uma das mais importantes consequências do Princípio da Boa Ordenação é o Princípio

de Indução Finita.

Teorema 3.1. Sejam S um subconjunto de Z e a ∈ Z tais que

(i) a ∈ S

(ii) S é fechado com respeito à operação de "somar 1"a seus elementos, ou seja, ∀n, n ∈

S ⇒ n + 1 ∈ S.

Então, {x ∈ Z; x ≥ a} ⊂ S.

Demonstração. Ponhamos S′ = {x ∈ Z; x ≥ a} e suponhamos por absurdo que S′ ̸⊂ S, logo
S′∖S ̸= /0. Como esse conjunto é limitado inferiormente por a, existe um menor elemento c em
S′∖S. Pelo fato de c ∈ S′ e c /∈ S, temos que c > a. Portanto c − 1 ∈ S′ e c − 1 ∈ S. Pela hipótese
sobre S, temos que c = (c − 1) + 1 ∈ S. Como c ∈ S′, obtemos uma contradição com o fato de
c ∈ S′∖S.

A proposição demonstrada acima aplica-se para veriﬁcar a validade geral de fórmulas ou
propriedades que envolvem números inteiros. E é conhecida como um dos Axiomas de Giuseppe
Peano (1858-1932).

Segue-se do Princípio de Indução Finita, o seguinte instrumento para provar teoremas.

3.1. Princípio da Boa Ordenação

29

Uma sentença Matemática aberta em n, são expressões que quando n é substituído por

um número inteiro ela se torna uma sentença verdadeira ou falsa.

Teorema 3.2. Seja a ∈ Z e seja p(n) uma sentença aberta em n. Suponha que

(i) p(a) é verdadeiro,

(ii) ∀n ≥ a, p(n) é verdadeiro ⇒ p(n + 1) é verdadeiro.

Então, p(n) é verdadeiro para todo n ≥ a.

Demonstração. Seja V = {n ∈ Z; p(n)} verdadeiro, ou seja, V é o subconjunto dos elementos
de Z para os quais p(n) é verdadeiro.

Como por (i) a ∈ V e por (ii)

∀n, n ∈ V ⇒ n + 1 ∈ V

segue-se do Princípio de Indução Finita que {x ∈ Z; x ≥ a} ⊂ V .

A comparação entre o Princípio de Indução Finita e um jogo de dominós ajuda na
compreensão deste (Ver [5]). Consideremos um jogo de dominós, já enﬁleirados. Empurrando
o primeiro, veremos eles caírem continuadamente. Ao empurrarmos o primeiro vemos este
empurrar o segundo, este empurrar o terceiro, e assim por diante.

Para o estudo em questão substituíremos os dominós por uma sequência inﬁnita de

proposições deﬁnidas pelos inteiros.

Admita que seja possível provar que

(A) A proposição inicial seja verdadeira;

(B) Sendo uma proposição, diferente da proposição inicial, verdadeira, isso implica que

a proposição próxima também seja verdadeira.

Assim, todas as proposições da sequência ﬁcam provadas como verdadeiras.

A parte (A) é chamada de Base da Indução ou passo básico e a parte (B) é o passo

indutivo.

Para fazer o uso do método de indução devemos:

∙ Não considerarmos a proposição como fato isolado, mas como uma sequência inﬁnita de

proposições semelhantes;

∙ Provar a primeira proposição da sequência, chamada de base da indução ou passo básico;

30

Capítulo 3. Principais Conceitos e Teoremas

∙ Deduzimos a segunda proposição da primeira, a terceira da segunda, e assim por diante.

Esse é o passo indutivo.

A partir disso, podemos chegar a qualquer das proposições da sequência, partindo da base
de indução. Assim todas elas serão aceitas como verdadeiras.

Através de alguns exemplos veremos como usar o Princípio de Indução Finita para provar

alguns resultados.

Exemplo 3.1. Queremos determinar uma fórmula para a soma dos n primeiros números naturais.
Conta a história que o matemático alemão Carl Friedrich Gauss (1777-1885), quando ainda
garoto, estava em sua sala de aula, e o professor para aquietar a turma, mandou os alunos
calcularem a soma de todos os números naturais de 1 a 100. Para sua surpresa, pouco tempo
depois, o menino deu a resposta 5050, aparentemente sem cálculos. Indagado como tinha
descoberto tão rapidamente o resultado, Gauss então com nove anos de idade, descreveu um
método que posteriormente foi sistematizado da seguinte forma:

Sendo Sn = 1 + 2 + ... + n, o objetivo é encontrar uma fórmula fechada para Sn.

Somando a igualdade acima, membro a membro, com ela mesma, só que a segunda com

as parcelas em ordem invertida, temos que:

Sn = 1 + 2 + ... + (n − 1) + (n − 2) + n

Sn = n + (n − 1) + (n − 2) + ... + 2 + 1

obtendo

2Sn = (n + 1) + (n + 1) + ... + (n + 1) = n(n + 1)

Com isso temos que Sn =

n(n + 1)
2

.

É necessário ser crítico em relação à fórmula encontrada. Ela parece já satisfazer o
problema proposto. Mas, é preciso saber se a fórmula é válida para todo n. Para isso, usamos o
Princípio de Indução Finita:

Considerando a sentença Sn sobre os naturais e n0 = 1 temos

1o) Para a base de indução, sendo n0 = 1:

S(1) =

1.(1 + 1)
2

=

1.2
2

=

2
2

= 1.

3.1. Princípio da Boa Ordenação

31

Portanto, para n0 = 1, Sn0 é verdadeira.
2o) Considerando como hipótese de indução que Sn seja verdadeira e provaremos para

Sn+1:

Sn = 1 + 2 + 3 + ... + n =

n(n + 1)
2

Sn+1 = 1 + 2 + 3 + ... + n + (n + 1) =

n(n + 1)
2

+ n + 1

Sn+1 =

n(n + 1) + 2(n + 1)
2

Sn+1 =

n2 + n + 2n + 2
2

=

n2 + 3n + 2
2

Sn+1 =

(n + 1)(n + 2)
2

Sn+1 =

(n + 1)[(n + 1) + 1]
2

.

Isto torna a proposição válida para todo n ∈ N.

O Princípio de Indução Finita é usado para estabelecer verdades matemáticas, válidas
para subconjuntos de Z. Não é o caso de mostrar que uma sentença aberta vale para um grande
número de casos, mas mostrar que determinada sentença aberta é verdadeira para todo número
inteiro maior ou igual do que um a, tal que a ∈ Z.

O Princípio de Indução Finita admite uma variante, chamada de Princípio da Indução

Completa, ou Segunda Forma do Princípio de Indução.

Teorema 3.3. Seja p(n) uma sentença aberta tal que

(i) p(a) é verdadeiro,

(ii) ∀n, p(a) e p(a + 1) e ...e p(n) é verdadeiro ⇒ p(n + 1) é verdadeiro.

Então, p(n) é verdadeiro para todo n ≥ a.

Demonstração. Considere o conjunto V = {n ∈ a + N; p(n)verdadeiro}. Queremos provar que
o conjunto W = (a + N)∖V é vazio. Suponha, por absurdo, que vale o contrário. Logo, pelo
Princípio da Boa Ordenação, W teria um menor elemento k, e, como sabemos de (i) que
a /∈ W , segue-se que existe n tal que k = a + n > a. Portanto, a, a + 1, ..., k − 1 /∈ W ; logo
a, a + 1, ..., k − 1 ∈ V . Por (ii) conclui-se que k = k − 1 + 1 = (a + n − 1) + 1 ∈ V , o que contradiz
o fato de k ∈ W .

32

Capítulo 3. Principais Conceitos e Teoremas

Na prática, para provar uma propriedade utilizando a segunda forma de indução, devemos
provar que n0 ∈ T , sendo T um subconjunto de Z, e a seguir, dado um n qualquer, maior do
que n0, admitir que n e todos os números entre n0 e n, inclusive, estão em T e provar que n + 1
também pertence a T .

Problema 1 (Propriedades da sequência de Fibonacci)

Leonardo Fibonacci, como era conhecido, nasceu em 1170 e morreu em 1240. Foi
um grande matemático da Europa Cristã Medieval. Ele representou papel importante, fazendo
contribuições relevantes.

Foi Fibonacci quem descobriu a sequência (1, 1, 2, 3, 5, 8, ...). Nessa sequência cada

termo, a partir do terceiro, equivale à soma dos dois termos imediatamente anteriores.

Determine o próximo número na sequência 1, 1, 2, 3, 5, 8, 13, ... e prove que o seu termo

de posição n é sempre menor que (7/4)n.

Solução:

Como dito anteriormente, cada termo, a partir do terceiro, é a soma dos dois termos

imediatamente anteriores

2 = 1 + 1
3 = 2 + 1
5 = 3 + 2, e assim por diante.

Pode-se concluir então que o próximo termo da sequência proposta no problema é 21,

pois 8 + 13 = 21.

Essa sequência pode ser deﬁnida da seguinte maneira recursiva

(cid:40)

F1 = F2 = 1
Fn+1 = Fn−1 + Fn, ∀n ≥ 2, n ∈ N

Utilizando a segunda forma do Princípio da Indução Finita, ou forma completa, podemos

provar que ∀n ∈ N, Fn < (7/4)n.

Para n = 1 e n = 2, a proposição é verdadeira, pois

F1 = F2 = 1 < (7/4)1 = 7/4.

Seja n ≥ 2 um natural e vamos supor que para todo natural m com 1 ≤ m ≤ n, vale que

Fm < (7/4)m. Vamos mostrar que Fn+1 < (7/4)n+1:

Fn+1 = Fn−1 + Fn < (7/4)n−1 + (7/4)n = (7/4)n.(7/4)−1 + (7/4)n

3.2. Divisibilidade

33

= (7/4)n.(4/7) + (7/4)n

= (7/4)n.( 4

7 + 1)

= (7/4)n. 11
7

Como (7/4)n. 11

7 < (7/4)n.7/4 = (7/4)n+1, então, Fn+1 < (7/4)n+1.

Logo, a proposição está demonstrada.

3.2 Divisibilidade

Vejamos agora o importante conceito de divisibilidade.

Deﬁnição 3. Sejam a, b ∈ Z. Diz-se que a divide b, escrevendo a|b, quando existir q ∈ Z, tal
que b = qa. Quando a|b, diremos também que a é um divisor ou um fator de b, ou ainda, que b é
múltiplo de a ou que b é divisível por a.

Caso a não divida b, escreve-se a (cid:45) b e lê-se a não divide b.

Exemplo 3.2. Sabe-se que 3|27, pois 27 = 3.9.

Teorema 3.4. Sejam a, b, c e d números inteiros quaisquer. Então as seguintes proposições são
verdadeiras

(1) 1|a, a|a e a|0;

(2) Se a|b e b|c, então a|c;

(3) Se a|b e c|d, então (ac)|(bd);

(4) Se a|b e a|c, então a|(b + c);

(5) Se a|b então para todo m ∈ Z, tem-se que a|(mb);

(6) Se a|b e a|c, então para todo m, n ∈ Z, tem-se que a|(mb + nc);

(7) a|b ⇔ a| − b ⇔ −a|b ⇔ −a| − b;

(8) Se a|b e b ̸= 0, então |a| ≤ |b|;

(9) Se b|a e a|b, então a = ±b;

(10) Se a|1, então a = ±1.

Demonstração. (1) Tem-se que, 1|a, pois a = 1.a; a|a pois a = 1.a; e a|0 pois 0 = 0.a.

(2) Se a|b e b|c, então existem números inteiros q1 e q2, tais que b = q1.a e c = q2.b.

Substituindo o valor de b na segunda obtemos c = (q1q2).a. Logo, a|c.

34

Capítulo 3. Principais Conceitos e Teoremas

(3) Se a|b e c|d, então existem números inteiros q1 e q2 tais que b = q1a e d = q2c.

Multiplicando a primeira pela segunda temos que bd = (q1q2)ac. Logo, ac|bd.

(4) Se a|b e a|c, então existem números inteiros tais que b = q1a e c = q2a. Somando as
duas equações membro a membro temos que b + c = q1a + q2a = (q1 + q2)a. Logo, a|(b + c).

(5) Se a|b então existe um número q, tal que b = qa. Multiplicando a equação anterior

por m, tem-se que mb = (qm)a, logo, para todo m, tem-se que a|mb.

(6) Se a|b e a|c, então existem números inteiros q1 e q2, tais que b = q1a e c = q2a.
Multiplicando a primeira e a segunda equação por m e n, inteiros, respectivamente, tem-se que,
mb = mq1a e nc = nq2a. Somando-as membro a membro, obtêm-se que mb + nc = q1ma +
q2na = (q1m + q2n)a, logo a|(mb + nc).

(7) a|b então b = qa, q ∈ Z. Multiplicando ambos os lados por (−1) obtêm-se que
(−b) = (−q)a, (−q) ∈ Z ou ainda que (−b) = q(−a), q ∈ Z. Partindo de b = qa, q ∈ Z, podemos
escrever que b = (−q)(−a), (−q) ∈ Z, e seguem as equivalências.

(8) Se a|b com b ̸= 0, então existe um número inteiro q ̸= 0 tal que b = qa, logo,

|b| = |qa| = |q|.|a| ≥ |a|.

(9) Suponha que b|a e a|b. Se a = 0 ou b = 0, tem-se a = b = 0. No caso de a, b ̸= 0,

tem-se pelo item (8) que |a| ≤ |b| e |b| ≤ |a|. Logo |a| = |b|, ou seja, a = ±b.

(10) Se a|1 pelo item (1), sabe-se que 1|a para todo a inteiro. Logo, pelo item anterior

tem-se que a = ±1.

Teorema 3.5. Sejam a, b e c ∈ Z, tais que a|(b + c). Então a|b ⇔ a|c.

Demonstração. Suponha a|(b + c). Então existe um número inteiro q, tal que b + c = qa.

Suponha ainda que a|b. Então existe q1 tal que b = aq1. De b +c = qa e b = aq1 podemos
escrever que aq1 + c = aq. Disso, tem-se que c = a(q − q1) ∈ Z. Então a|c. A demonstração de
a|c ⇒ a|b é análoga.

Exemplo 3.3. Prove que se n é ímpar, então 8 divide n2 − 1.

Como n é ímpar, podemos escrever que n = 2k + 1, para algum k ∈ Z. Com isso temos

que

n2 − 1 = (2k + 1)2 − 1 = 4k2 + 4k + 1 − 1 = 4k(k + 1).

Como k e k + 1 são números consecutivos, um deles é par. E um número par multiplicado

por 4 será sempre um múltiplo de 8. Portanto, n2 − 1 é múltiplo de 8, para todo n ímpar.

3.2. Divisibilidade

35

Teorema 3.6. Sejam a, b, n ∈ N, com a > b > 0. Temos que a − b divide an − bn.

Demonstração. Vamos provar por indução sobre n.

É óbvio a aﬁrmação para n = 1, pois a − b divide a1 − b1 = a − b. Suponhamos, agora,

que a − b|an − bn e provemos que a − b|an+1 − bn+1. Então, podemos escrever que

an+1 − bn+1 = ana − bnb = ana − ban + ban − bnb = an(a − b) + b(an − bn).

Como a − b|a − b e por hipótese a − b|an − bn, pelo item 6 do Teorema 3.4, podemos

aﬁrmar que a − b|an+1 − bn+1, para todo n ∈ N.

Teorema 3.7. Sejam a, b, n ∈ N, com a + b ̸= 0. Então temos que a + b divide a2n+1 + b2n+1.

Demonstração. Esse resultado também será provado por indução.

Para n = 1, temos que a2n+1 + b2n+1 = a3 + b3.

Como a3 + b3 pode ser escrito na forma (a + b)(a2 − ab + b2) então a + b|a3 + b3.

Suponhamos, agora, que a+b|a2n+1 +b2n+1 e provemos que a+b|a2(n+1)+1 +b2(n+1)+1.

Temos que

a2(n+1)+1 + b2(n+1)+1 = a2a2n+1 − b2a2n+1 + b2a2n+1 + b2b2n+1 = (a2 − b2)a2n+1 +

b2(a2n+1 + b2n+1).

Como a + b|a2 − b2, pois a2 − b2 = (a − b)(a + b) e, por hipótese a + b|a2n+1 + b2n+1,

podemos aﬁrmar que para todo n ∈ N, a + b|a2(n+1)+1 + b2(n+1)+1.

Teorema 3.8. Sejam a, b, n ∈ N, com a ≥ b > 0. Temos que a + b divide a2n − b2n.

Demonstração. Novamente, usando indução sobre n provaremos a aﬁrmação acima.

Para n = 1, temos que a + b|a2 − b2, pois a2 − b2 = (a − b)(a + b).

Como hipótese de indução consideremos que a + b|a2n − b2n e provemos que a +

b|a2(n+1) − b2(n+1).

Podemos escrever que

a2(n+1) − b2(n+1) = a2a2n − b2a2n + b2a2n − b2b2n = (a2 − b2)a2n + b2(a2n − b2n).

Como a + b|a2 − b2 e, por hipótese a + b|a2n − b2n, decorre das igualdades acima que

a + b|a2(n+1) + b2(n+1), estabelecendo assim o resultado para todo n ∈ N.

A seguir, temos exemplos de aplicação dos teoremas anteriores.

Exemplo 3.4. Mostre que para todo n ∈ N,

36

Capítulo 3. Principais Conceitos e Teoremas

8|32n − 1.

A expressão 32n − 1 pode ser escrita da seguinte forma

Como 8 é 9 − 1, então

(32)n − 1n = 9n − 1n.

9 − 1|9n − 1n

pelo Teorema 3.6.

A potência 1n, para todo n ∈ N, será sempre 1. Então,

9 − 1|9n − 1

8|9n − 1

8|(32)n − 1

8|32n − 1 para todo n ∈ N.

Exemplo 3.5. Demonstre que 13|270 + 370.

Podemos reescrever 270 + 370 como (22)35 + (32)35 = 435 + 935.

Como 13 é igual a 4 + 9, temos que

4 + 9|435 + 935.

Pelo Teorema 3.7 sabemos que a + b|a2n+1 + b2n+1. Note que 35 é da forma 2n + 1 =

2.17 + 1. E considerando a = 4 e b = 9, podemos aﬁrmar que 13|270 + 370.

Exemplo 3.6. Prove que 53|74n − 24n, para todo n ∈ N.

A expressão 74n − 24n pode ser reescrita na forma (72)2n − (22)2n = 492n − 42n. Como

53 é 49 + 4, a aﬁrmação dada pode ser reescrita como

49 + 4|492n − 42n.

Pelo Teorema 3.8, temos que a + b|a2n − b2n. Considerando a = 49 e b = 4, então

podemos aﬁrmar que 53|74n − 24n, para todo n ∈ N.

3.2. Divisibilidade

37

3.2.1 Divisão Euclidiana

Mesmo que um número natural a não divida o número b, podemos efetuar essa divisão

obtendo um quociente “q” e um resto r, sendo estes únicos.

Teorema 3.9. Sejam a e b dois números naturais com 0 < a ≤ b. Existem dois únicos números
naturais q e r tais que

b = aq + r, com 0 ≤ r < a.

Demonstração. Suponha que b > a e considere os números, pertencentes a N,

b, b − a, b − 2a,...,b − na,...

Pela Propriedade da Boa Ordem, o conjunto S formado pelos elementos acima tem um

menor elemento r = b − qa.

Vamos provar que r < a.

Se a|b então r = 0 e nada temos a provar.

Se, por outro lado, a (cid:45) b, então r ̸= 0, e portanto, basta mostrar que não ocorre r ≥ a.

De fato, se isso ocorresse, existiria um número natural c < r tal que r = c + a.

Consequentemente, sendo r = c + a = b − qa, teríamos c = b − qa − a ⇒ c = b − (q +

1)a ∈ S, com c < r contradizendo o fato de r ser o menor elemento de S.

Portanto, temos que b = aq + r com r < a, o que prova a existência de q e r.

Para provarmos a unicidade, observe que, dados dois elementos distintos de S, a diferença

entre o maior e o menor desses elementos, sendo um múltiplo de a, é pelo menos a.

Logo, se r = b − aq e r′ = b − aq′, com r < r′ < a, teríamos r′ − r ≥ a, o que acarretaria

r′ ≥ r + a ≥ a, absurdo. Portanto, r = r′.

Disso segue-se que b − aq = b − aq′, o que implica que aq = aq′ e, portanto, q = q′.

Exemplo 3.7. Mostre que o resto da divisão de 10n por 9 é sempre 1, qualquer que seja o número
natural n.

Por indução, para n = 0, temos que

100 = 9.0 + 1.

Portanto, o resultado vale.

Suponha agora, que o resultado seja válido para um dado n, isto é 10n = 9q + 1 e

provemos para n + 1.

38

Capítulo 3. Principais Conceitos e Teoremas

Considere a igualdade

10n+1 = 10.10n = (9 + 1).10n = 9.10n + 10n = 9.10n + 9q + 1 = 9(10n + q) + 1.

Com isso, prova-se que o resultado vale para n + 1 e portanto, vale para todo n ∈ N.

3.2.2 Paridade

A ideia de paridade é uma poderosa ferramenta na resolução de problemas matemáticos

envolvendo números inteiros.

Deﬁnição 4. Denominamos números pares aos inteiros ..., −6, −4, −2, 0, 2, 4, ..., ou seja, todos
os inteiros da forma 2q, para q ∈ Z. E denominamos números ímpares aos inteiros ..., −3, −1, 1, 3,
5, ..., ou seja, todos os inteiros da forma 2q + 1, para q ∈ Z.

Dizemos que dois números inteiros têm a mesma paridade quando, e só quando, ou

ambos forem pares, ou ambos forem ímpares.

Teorema 3.10. A soma de dois números pares é par.

Demonstração. De fato, dois números pares podem ser escritos na forma 2q e 2q′ cuja soma é
2q + 2q′ = 2(q + q′). Logo, a soma de dois pares é par.

Teorema 3.11. A soma de dois números ímpares é par.

Demonstração. Representando os dois números ímpares nas formas 2q + 1 e 2q′ + 1, temos que
(2q + 1) + (2q′ + 1) = 2(q + q′) + 2. Logo, a soma de dois números ímpares é par.

Teorema 3.12. A soma de um número par com um número ímpar é ímpar.

Demonstração. Seja o número par representado por 2q e o número ímpar representado por
2q′ + 1. Para a soma destes termos temos 2q + 2q′ + 1 = 2(q + q′) + 1. Logo, a soma de um
número par com um número ímpar é ímpar.

Teorema 3.13. O produto de dois números pares é par.

Demonstração. Consideremos os números pares na forma 2q e 2q′. Efetuando o produto temos
que 2q.2q′ = 2(2qq′). Logo, o produto de dois números pares é múltiplo de 4 e portanto, é
par.

Teorema 3.14. O produto de um número par por um número ímpar é par.

Demonstração. Considere um número par na forma 2q e o número ímpar na forma 2q′ + 1,
efetuando o produto, obtemos 2q.(2q′ + 1) = 2(2qq′ + q). Logo, o produto de um número par
por um número ímpar é par.

3.2. Divisibilidade

39

Teorema 3.15. O produto de dois números ímpares é ímpar.

Demonstração. Sendo um dos números ímpares na forma 2q + 1 e o outro na forma 2q′ + 1
e efetuando o produto obtemos (2q + 1)(2q′ + 1) = 4qq′ + 2q + 2q′ + 1 = 2(2qq′ + q + q′) + 1.
Logo, o produto de dois números ímpares é ímpar.

Vejamos a seguir alguns exemplos de uso da paridade na resolução de exercícios.

Em [4], página 5, encontramos o seguinte enunciado:

Exemplo 3.8. Onze engrenagens estão colocadas em um plano, arrumadas em uma cadeia como
ilustrado na ﬁgura a seguir. Todas as engrenagens podem rodar simultaneamente?

Figura 1: Engrenagens.

Suponha que o sentido de rotação da primeira seja horário. Então a segunda tem que
girar no sentido contrário, ou seja, anti-horário, a terceira no sentido horário novamente, a quarta
no sentido anti-horário. Mas, então, a primeira e a décima primeira engrenagem tem que girar no
mesmo sentido, o que é uma contradição. Portanto a resposta é não.

Exemplo 3.9. Pergunta-se: O resultado de 2010 x 11200 + 2119 é par ou ímpar?

Para sabermos a paridade desse número não precisamos efetuar as contas indicadas.
Basta pensarmos que, como 20 é par, multiplicando por ele mesmo 10 vezes, resultará um
número também par, como 11 é ímpar, multiplicado por ele mesmo 200 vezes, resultará em um
número ímpar, o mesmo ocorre com 21, que é ímpar, e ao ser multiplicado por ele mesmo 19
vezes, também resultará em um número ímpar. Agora basta pensarmos nas seguintes operações:
(par x ímpar + ímpar) e veremos que o resultado será ímpar.

3.2.3 Máximo Divisor Comum

Segundo a deﬁnição de divisibilidade, ao observar o fato de que se um número inteiro a
é divisor de um inteiro b, então −a também divide b. Assim, podemos determinar o conjunto
dos divisores inteiros de um número inteiro b, representado por D(b).

40

Capítulo 3. Principais Conceitos e Teoremas

Exemplo 3.10. a) D(6) = {±1, ±2, ±3, ±6}.

b) D(15) = {±1, ±3, ±5, ±15}.

c) D(40) = {±1, ±2, ±4, ±5, ±8, ±10, ±20, ±40}.

d) D(48) = {±1, ±2, ±3, ±4, ±6, ±8, ±12, ±16, ±24, ±48}.

Observando os conjuntos dos divisores de 40 e de 48, veriﬁca-se que estes apresentam

números comuns, que são: {±1, ±2, ±4, ±8}. Este fato motiva a seguinte deﬁnição:

Deﬁnição 5. Sejam a, b ∈ Z dois números, sendo pelo menos um deles diferente de zero. O
máximo divisor comum entre a e b, denotado por mdc(a, b), é o número natural d, d > 0, que é
divisor comum de a e b e possui as propriedades a seguir:

a) d|a e d|b.

b) Se algum c ∈ N dividir simultaneamente, a e b, então temos que c|d.

No exemplo apresentado anteriormente, temos mdc(40, 48) = 8.

Observação:

a) mdc(a, 1) = 1;

b) mdc(a, 0) = |a|, com a ̸= 0;

c) Se a é divisor de b, então mdc(a, b) = a;

d) Se mdc(a, b) = 1, então a e b são denominados primos entre si ou coprimos.

Exemplo 3.11. a) mdc(1894, 1) = 1;

b) mdc(17, 0) = 17;

c) mdc(28, 14) = 14, pois 14 é divisor de 28;

d) mdc(13, 14) = 1, então 13 e 14 são primos entre si ou coprimos.

Teorema 3.16. Um número d é divisor comum de a e de b, não ambos nulos, se e somente se,
ele é um divisor comum de a e de b − a.

Demonstração. Se d|a e d|b então existem q1 e q2, tais que a = dq1 e b = dq2. Subtraindo a
segunda da primeira obtemos b − a = d(q2 − q1). Logo, d|(b − a).

Reciprocamente, se d|a e d|b − a então existem q3 e q4, tais que a = dq3 e b − a = dq4.

Somando a primeira com a segunda obtemos a + b − a = b = d(q3 + q4). Logo, d|b.

Exemplo 3.12. Pelo Teorema anterior, temos que 6 é um divisor comum de 42 e 30, pois 6|42,
6|12 e 6|42 − 30.

3.2. Divisibilidade

41

Para provar a existência do máximo divisor comum, Euclides utilizou-se basicamente do

lema abaixo.

Lema 1. (Lema de Euclides) Sejam a, b, n ∈ N, com a < na < b. Se existe mdc(a, b − na),
então existe mdc(a, b) e

mdc(a, b) = mdc(a, b − na).

Demonstração. Seja d = mdc(a, b − na). Como d|a e d|(b − na), pelo Teorema 3.16, segue que
d divide b = b − na + na. Logo, d é um divisor comum de a e b. Suponha agora que c seja um
divisor comum de a e b. Logo, c é um divisor comum de a e b − na e, portanto, c|d. Isso prova
que d = mdc(a, b).

Usando a mesma técnica na demonstração do Lema de Euclides, pode-se provar que,

para todos a, b, n ∈ N

ou que, se na > b, então

mdc(a, b) = mdc(a, b + na)

mdc(a, b) = mdc(a, na − b).

O Lema de Euclides é efetivo para calcular mdc e será fundamental para estabelecermos
o algoritmo de Euclides, que permite, com eﬁciência, calcular o mdc de dois números naturais
quaisquer.

Pelo Lema de Euclides podemos encontrar o mdc(42, 30) da seguinte maneira:

como 12 = 42 − 1.30, então mdc(42, 30) = mdc(30, 12). Como 6 = 30 − 2.12, então

mdc(30, 12) = mdc(12, 6). Como 0 = 12 − 2.6, então mdc(12, 6) = mdc(6, 0) = 6.

Logo, mdc(42, 30) = 6.

Uma outra aplicação do Lema de Euclides enunciado anteriormente pode ser apresentado

no problema a seguir.

Exemplo 3.13. Determine os valores de a e n para os quais a + 1 divide a2n + 1.

Note inicialmente que

a + 1|a2n + 1 ⇔ mdc(a + 1, a2n + 1) = a + 1.

Como a2n + 1 = (a2n − 1) + 2 e como visto em divisibilidade, Teorema 3.8, que a +

1|a2n − 1, assim podemos escrever que, para todo n, temos

42

Capítulo 3. Principais Conceitos e Teoremas

a + 1 = mdc(a + 1, a2n + 1) = mdc(a + 1, (a2n − 1) + 2) = mdc(a + 1, 2).

Portanto, a + 1|a2n + 1, para algum n ∈ N, se e somente se, a + 1 = mdc(a + 1, 2), o que

ocorre se, e somente se a = 0 ou a = 1.

Exemplo 3.14. Dona Maria, costureira do bairro, dispõe de duas ﬁtas de tamanhos diferentes.
Com as mãos, ela mediu as ﬁtas: a primeira de 24 palmos e a segunda de 32 palmos. Ela pretende
cortar as duas ﬁtas de modo a obter pedaços do mesmo tamanho e que seja o maior possível.
Quanto medirá cada ﬁta?

Como 8 = 32−1.24, então mdc(32, 24) = mdc(24, 8). Como 0 = 24−3.8, então mdc(24,

8) = mdc(8, 0) = 8.

Portanto, cada pedaço deverá medir 8 palmos para que Dona Maria obtenha todos do
mesmo tamanho e de maior medida possível. Como 24 : 8 = 3 e 32 : 8 = 4, ela conseguirá obter
7 pedaços.

Observe que dados a, b ∈ Z, se existir o mdc(a, b) de a e b, então

mdc(a, b) = mdc(−a, b) = mdc(a, −b) = mdc(−a, −b).

Assim, para efeito do cálculo do mdc de dois números, podemos sempre supô-los não

negativos.

Apresentaremos agora a prova construtiva da existência do mdc dada por Euclides
(Ver [6]). Esse método, que recebeu o nome de algoritmo de Euclides, é muito usado na área
computacional e pouco foi aperfeiçoado em mais de dois milênios.

Como os restos formam uma sequência estritamente decrescente, o algoritmo eventual-

mente termina quando atingimos o resto 0.

Dados a, b ∈ N, podemos supor a ≤ b. Se a = 1 ou a = b, ou ainda a|b sabe-se que

mdc(a, b) = a.

Suponha então, que 1 < a < b e que a (cid:45) b. Logo, pelo algoritmo geral da divisão podemos

escrever

b = aq1 + r1, com r1 < a.

Assim, temos duas possibilidades:

1o) r1|a.

Pelo Lema de Euclides, teríamos que r1 = mdc(a, r1) = mdc(a, b − q1a) = mdc(a, b),

terminando assim o algoritmo.

3.2. Divisibilidade

2o) r1 (cid:45) a

43

Nesse caso, podemos efetuar a divisão de a por r1, obtendo

a = r1.q2 + r2, com r2 < r1.

Com isso temos duas possibilidades novamente

a) r2|r1.

Neste caso, novamente pelo Lema de Euclides, temos

r2 = mdc(r1, r2) = mdc(r1, a − q2r1) = mdc(r1, a) = mdc(b − q1a, a) = mdc(b, a) =

mdc(a, b).

Terminando assim o algoritmo.

b) r2 (cid:45) r1.

Ao efetuarmos a divisão de r1 por r2, obtemos

r1 = r2q3 + r3, com r3 < r2.

Se esse processo continuasse indeﬁnidamente, teríamos uma sequência de números
naturais a > r1 > r2 > ... que não possui menor elemento, o que não é possível pelo Princípio da
Boa Ordem que nos garante que o conjunto dos números naturais, possui um menor elemento.
Logo, para algum n, temos que rn|rn−1, e assim mdc(a, b) = rn.

Com isso mostramos a existência do mdc(a, b).

Vamos mostrar agora a unicidade. Para isso, admitamos que mdc(a, b) = d e mdc(a, b) =
d′. Assim, tanto d como d′ são divisores comuns de a e b. Então, d|d′ e d′|d e como d e d′ são
ambos positivos segue que d = d′, provando assim a unicidade do mdc(a, b).

O algoritmo acima pode ser sintetizado e realizado na prática, através das divisões

sucessivas, utilizando o que é conhecido pelos alunos como "jogo da velha ampliado".

Inicialmente, efetuamos a divisão b = aq1 + r1 e colocamos os números envolvidos no

seguinte diagrama

q1
a

b
r1

A seguir, continuamos efetuando a divisão a = r1q2 + r2 e colocamos os números

envolvidos no diagrama

44

Capítulo 3. Principais Conceitos e Teoremas

q2
r1

q1
a
r2

b
r1

Ao prosseguirmos enquanto for possível, teremos

q1
a
r2

q2
r1
r3

b
r1

q3
r2

...

...

qn−1
rn−2
rn

qn
rn−1
0

qn+1
rn = mdc(a, b)

Podemos ilustrar o algoritmo de Euclides com o seguinte exemplo:

Dona Marta, costureira do bairro, dispõe de duas peças de tecidos de tamanhos diferentes.
A primeira peça tem 372 cm e a segunda 162 cm. Ela pretende cortar os dois tecidos de modo a
obter pedaços iguais e que sejam do maior comprimento possível. Quanto medirá cada pedaço
do tecido?

Pelo diagrama apresentado anteriormente podemos escrever que

2

372

162

48

18

3

48

12

2

18

6

1

12

0

2

6

Pelo método do diagrama ﬁca fácil perceber que o mdc dos dois números em questão é
o último resto não nulo do processo das divisões sucessivas. Portanto, cada pedaço do tecido
deverá ter 6 cm.

No exemplo acima, podemos perceber que o Algoritmo de Euclides nos fornece

Portanto,

6 = 18 − 1.12
12 = 48 − 2.18
18 = 162 − 3.48
48 = 372 − 2.162.

6 = 18 − 1.12
= 18 − 1.(48 − 2.18)
= 3.18 − 48
= 3(162 − 3.48) − 48
= 3.162 − 10.48

3.2. Divisibilidade

45

= 3.162 − 10(372 − 2.162)
= 23.162 − 10.372.

Temos então que

mdc(372, 162) = 6 = 23.162 − 10.372.

Através das divisões sucessivas do Algoritmo de Euclides conseguimos escrever 6 como

a diferença entre um múltiplo de 162 e um múltiplo de 372.

Essa é uma propriedade do mdc que será demonstrada a seguir, que é chamada relação
de Bézout. É uma ferramenta que pode ser usada para encontrar o mdc entre dois números
através de uma combinação linear destes. O resultado foi provado pela primeira vez por Claude-
Gaspard Bachet de Méziriac (1581-1638) e algum tempo depois generalizado por Etienne Bézout
(1730-1783).

Proposição 2. (Relação de Bézout) Sejam a, b ∈ Z ambos não nulos e seja d = mdc(a, b).
Então existem x1, y1 ∈ Z tais que

ax1 + by1 = d.

Demonstração. O caso a = 0 ou b = 0 é trivial, pois mdc(0, a) = a e mdc(0, b) = b. Nos outros
casos, considere o conjunto S, composto de todas as combinações lineares de a e b,

S = {ax + by, x, y ∈ Z, e ax + by > 0}.

Considere a ̸= 0. Então, a ∈ S, pois a = a.1 + b.0 > 0 se a > 0 e −a pertence a S, pois

−a = a(−1) + b.0 > 0 se a < 0. Logo, S ̸= /0.

Seja a = 0. Se b > 0, então a.0 + b.1 > 0 e se b < 0, então a.0 + b(−1) > 0. Logo, S ̸= /0.

Pelo princípio da Boa Ordem, existe um d ∈ S minimal.

Como d ∈ S, temos d > 0 e existem x1 e y1 ∈ Z tais que d = ax1 + by1.

Aﬁrmamos que d é o mdc(a, b).

Dividindo a por d, então ∃ q, r ∈ Z tais que a = dq + r e 0 ≤ r < d. Assim, r = a − qd =

a − q(ax1 + by1) = a − aqx1 − bqy1 = a(1 − qx1) + b(−qy1).

Se fosse r > 0, poderíamos concluir que r ∈ S, o que claramente é um absurdo já que

r < d e d é o elemento mínimo de S.

Logo, r = 0 e a = qd, o que signiﬁca que d|a.

Da mesma forma mostra-se que d|b.

46

Capítulo 3. Principais Conceitos e Teoremas

Como d|a e d|b, logo d é divisor comum de a e b.

Seja c ∈ N tal que c|a e c|b. Pelo Teorema 3.4 (6) concluímos que c|ax1 + by1 e c|d.

Logo, d = mdc(a, b).

A proposição demonstrada acima nos fornece o mdc de dois números, como combinação
linear destes, mas não é construtiva como o Algoritmo de Euclides, que nos fornece um meio
prático para achar o mdc de dois números.

Proposição 3. Sejam a, b ∈ Z, não ambos nulos e seja d = mdc(a, b). Então,

{ax + by|x, y ∈ Z} = {dz|z ∈ Z}.

Em palavras: As combinações lineares inteiras de a e b são exatamente os múltiplos do

mdc(a, b).

Demonstração. Abreviemos T = {ax + by|x, y ∈ Z} e R = {dz|z ∈ Z}. Pela Relação de Bézout,
existem x1, y1 ∈ Z com d = ax1 + by1. Para todo z ∈ Z segue dz = a(x1z) + b(y1z) ∈ T . Logo,
R ⊆ T . Como d|(ax + by) para qualquer ax + by ∈ T , segue também T ⊆ R. Logo, T = R.

Com a Relação de Bézout e o fato de que dados dois números naturais a e b serem ditos
primos entre si, ou coprimos, se mdc(a, b) = 1, ou seja, se o único divisor comum de ambos é 1,
podemos estabelecer o seguinte corolário.

Corolário 2. Dois números a, b ∈ Z não ambos nulos, são primos entre si, se e somente se
existem x1, y1 ∈ Z tais que

ax1 + by1 = 1.

Este resultado estabelece relações entre as estruturas aditivas e multiplicativas dos

números naturais, permitindo provar a proposição a seguir.

Proposição 4. Sejam a, b e c números naturais. Se a|b.c e mdc(a, b) = 1 então a|c.

Demonstração. Se a|b.c, então existe l ∈ N tal que bc = al. Se mdc(a, b) = 1, então pelo
corolário anterior, temos que existem m, n ∈ N tais que

na + mb = 1.

Multiplicando por c ambos os lados da igualdade acima, temos que

c = nac + cmb.

3.2. Divisibilidade

47

Substituindo bc por al nesta última igualdade, temos que

c = nac + mal = a(nc + ml)

e portanto, a|c.

Proposição 5. Sejam a, b ∈ Z, ambos não nulos e d = mdc(a, b). Então,

mdc

(cid:19)

(cid:18) a
d

,

b
d

= 1.

(Observamos que

a
d

e

b
d

são números inteiros).

Demonstração. De ax + by = d para certos x, y ∈ Z, segue que
concluímos a aﬁrmação.

a
d

x +

b
d

y = 1. Pelo Corolário 2

3.2.4 Mínimo Múltiplo Comum

Deﬁnição 6. Sejam a, b ∈ Z dois números ambos não nulos. O mínimo múltiplo comum entre a
e b é o número natural m = mmc(a, b) deﬁnido pelas propriedades

a) a|m e b|m (isto é, m é múltiplo comum de a e b).

b) Se a|c e b|c para algum c ∈ N, então temos também m|c.

Se c é um mínimo múltiplo comum de a e b, então pela Deﬁnição 5, item b, temos que
m|c e, portanto, m ≤ c, o que nos diz que o mínimo múltiplo comum, se existir, é único e é o
menor dos múltiplos de a e b.

Vale lembrar que o número a.b é sempre um múltiplo comum de a e b.

A proposição enunciada a seguir, conecta o mdc e o mmc de dois números inteiros e

pode ser utilizada, juntamente com o Algoritmo de Euclides, para o cálculo de mmc.

Proposição 6. Sejam a e b dois números inteiros. Então mdc(a, b).mmc(a, b) = a.b.

Demonstração. Se a = 0 ou b = 0, a igualdade acima é trivialmente satisfeita. É também fácil
veriﬁcar que a igualdade é veriﬁcada para a e b se, e somente se, ela é veriﬁcada para ±a e ±b.
Então, sem perda de generalidade, podemos supor a, b ∈ N.

Consideremos m =

Podemos escrever m = a

.

ab
mdc(a, b)
b
mdc(a, b)

= b

a
mdc(a, b)

.

Assim, a|m e b|m. Portanto m é um múltiplo comum de a e b.

Seja c um múltiplo comum de a e b; logo, c = na = n′b. Segue que

48

Capítulo 3. Principais Conceitos e Teoremas

n

a
mdc(a, b)

= n′

b
mdc(a, b)

.

Pela Proposição 5, mdc

(cid:18)

(cid:19)

= 1.

b
mdc(a, b)

,

a
mdc(a, b)
a
mdc(a, b)

divide n′, e, portanto, m =

a
mdc(a, b)

b divide

Pela Proposição 4, temos que

n′b, que é igual a c.

Segue um exemplo de aplicação de mmc.

Exemplo 3.15. Seja n ∈ N e n ̸= 0. Calcule mmc(n2 + 1, n + 1).

n2 + 1 = (n + 1)(n − 1) + 2. Logo, mdc(n2 + 1, n + 1) = mdc(n + 1, n2 + 1) = mdc(n +
1, (n + 1)(n − 1) + 2) e pelo Lema de Euclides, mdc(n + 1, (n + 1)(n − 1) + 2) = mdc(n + 1, 2).

Se n é par, n + 1 é ímpar e mdc(n + 1, 2) = 1 e daí,

mmc(n2 + 1, n + 1).mdc(n2 + 1, n + 1) = (n2 + 1)(n + 1) ⇒ mmc(n2 + 1, n + 1) = (n2 +

1)(n + 1).

Se n é ímpar, n + 1 é par e mdc(n + 1, 2) = 2 e daí,

mmc(n2 + 1, n + 1).mdc(n2 + 1, n + 1) = (n2 + 1)(n + 1) ⇒ mmc(n2 + 1, n + 1) =

(n2 + 1)(n + 1)
2

.

3.2.5 Equações Diofantinas

Nesta seção deﬁniremos as equações diofantinas lineares, estudaremos a condição para
que existam soluções de uma equação diofantina linear e mostraremos como resolver equações
deste tipo aplicando mdc, através do Algoritmo de Euclides.

Uma equação diofantina é linear se ela tiver a forma

a1x1 + a2x2 + ... + anxn = c,

onde as incógnitas são x1, x2, ..., xn ∈ Z.

Tais equações são chamadas equações diofantinas lineares em homenagem a Diofanto de

Alexandria (aproximadamente 300 d.C.).

Diofanto foi um matemático e ﬁlósofo grego e é considerado o maior algebrista grego,
verdadeiro precursor da moderna teoria dos números e considerado por alguns como pai da
álgebra, devido à sua inovação com notações, e por ser o primeiro a usar símbolos na resolução de
problemas algébricos. Mostrou interesse por uma grande variedade de equações indeterminadas
que admitem inﬁnitas soluções.

3.2. Divisibilidade

49

Nesse trabalho, faremos o estudo em particular das equações diofantinas lineares do tipo

ax + by = c com a, b, c ∈ Z.

A resolução de muitos problemas de aritmética depende da resolução desses tipos de
equação, onde a, b e c são números inteiros dados e x e y são incógnitas a serem determinadas
em Z.

Nem sempre estas equações possuem soluções. É portanto necessário estabelecer condi-

ções para que tais equações possuam soluções e, caso tenham, como determiná-las.

Para isso estabeleceremos duas proposições a seguir.

Proposição 7. Sejam a, b, c ∈ Z e a e b não ambos nulos e d = mdc(a, b). A equação diofantina

ax + by = c

admite pelo menos uma solução x, y ∈ Z se, e somente se, d|c.

Demonstração. Como d|a e d|b temos também que d|c para qualquer possível solução (x, y) ∈
Z × Z, de ax + by = c. Logo, d|c é uma condição necessária para que haja a solução de ax + by =
c.

Reciprocamente, seja d|c, digamos dl = c para algum l ∈ Z. Pelo Teorema de Bézout
sabemos que existem x1 e y1 ∈ Z com d = ax1 + by1. Segue c = a(lx1) + b(ly1) e vemos que
(lx1, ly1) é uma solução particular de ax + by = c.

Usando a mesma notação da proposição anterior, temos

Proposição 8. Suponha d|c e seja (x0, y0) uma solução particular de ax + by = c. Então a solução
geral, isto é, o conjunto de todas as soluções de ax + by = c é dada por

(cid:40)

x = x0 + b
d t
y = y0 − a
d t

com t ∈ Z

Demonstração. Seja (x0, y0) uma solução particular e t ∈ Z. Provamos primeiro que qualquer
par de números

(cid:40)

x = x0 + b
d t
y = y0 − a
d t

satisfaz a equação também.

50

Capítulo 3. Principais Conceitos e Teoremas

De fato, ax + by = a (cid:0)x0 + b

d t(cid:1) + b (cid:0)y0 − a

d t(cid:1) = ax0 + b

d at + by0 − b

d at = ax0 + by0 = c.

Reciprocamente, seja (x, y) uma solução qualquer de ax + by = c. Temos então ax0 +

by0 = c = ax + by e daí

a(x − x0) = b(y0 − y).

Existem r, s ∈ Z tais que a = rd e b = ds e vale mdc(r, s) = mdc( a

d , b

d ) = 1.

Segue que dr(x − x0) = ds(y0 − y) e daí

r(x − x0) = s(y0 − y),

pois d ̸= 0.

Podemos supor a ̸= 0. Concluímos r|s(y0 − y) e daí r|y0 − y pois mdc(r, s) = 1.
Logo, existe t ∈ Z tal que rt = y0 − y de onde vem y = y0 − rt = y0 − a

d t.

Segue que r(x − x0) = s(y0 − y) = srt e então x − x0 = st, pois r ̸= 0. Isto dá x = x0 + st =

x0 + b

d t.

Logo, temos

para algum t ∈ Z, como aﬁrmado.

(cid:40)

x = x0 + b
d t
y = y0 − a
d t

Exemplo 3.16. Analisar se existem soluções inteiras da equação

12x + 5y = 7

Nota-se que o mdc(12, 5) = 1 e 1|7. Portanto, essa equação diofantina linear admite

solução.

Pelo algoritmo de Euclides podemos escrever 1 como combinação linear de 12 e 5

1 = 5 − 2.2 = 5 − 2(12 − 2.5) = 5 − 2.12 + 4.5 = 5.5 − 2.12 = 12(−2) + 5(5) = 1.

Multiplicando ambos os lados por 7, obtemos

12(−14) + 5(35) = 7.

Concluímos então que (−14, 35) é uma solução particular de 12x + 5y = 7. Dessa forma,

as soluções desta equação são dadas por

x = −14 + 5t, y = 35 − 12t, com t ∈ Z.

3.2. Divisibilidade

51

3.2.6 Pequeno Teorema de Fermat e Números Especiais

Faremos o estudo dos números primos, que desempenham papel importante dentro da
teoria dos números e de toda a Matemática. A estes números estão associados problemas cujas
soluções têm resistido as tentativas de várias gerações de matemáticos, como visto em [14].

Deﬁnição 7. Um número p ∈ N é denominado primo, se p > 1 e seus únicos divisores são p e 1.
Indicamos por P = {p ∈ N|p é primo} o conjunto de todos os números primos.

Podemos dizer que

p ∈ P ⇔ (∀a, b ∈ N : p = ab ⇒ a = p e b = 1 ou a = 1 e b = p).

Um número n > 1 é dito composto se ele não é primo. Assim, n é composto, se existem

r, s ∈ N, 1 < s ≤ r < n com n = rs.

Por exemplo, 2, 3, 5, 7, 11 e 13 são números primos, enquanto 4, 6, 8, 9, 10 e 12 são

compostos.

Com o Lema de Euclides podemos estabelecer a seguinte propriedade fundamental dos

números primos.

Proposição 9. Sejam a, b, p ∈ N, com p primo. Se p|ab, então p|a ou p|b.

Demonstração. Suponhamos p|ab e p (cid:45) a. Agora se p (cid:45) a, então mdc(p, a) = 1 e portanto, pela
Proposição 4, segue que p|b.

Observamos que com esta proposição os números primos ﬁcam caracterizados totalmente,

pois se n = rs é composto (1 < s ≤ r < n), podemos ter n|rs. Porém n (cid:45) r e n (cid:45) s.

Por exemplo, se 7|ab, sabemos que um dos fatores a ou b (ou ambos) é múltiplo de 7.

Mas, temos que 4|36 = 2.18, porém nem 4 (cid:45) 2 e nem 4 (cid:45) 18.

Desde aproximadamente, 500 anos antes de Cristo, os chineses já sabiam que se p é um
número primo, então p|2p − 2. Pierre de Fermat, no século XVII, generalizou este resultado,
através de um pequeno, mas notável teorema.

Para demonstrar o Pequeno Teorema de Fermat faremos o uso do lema a seguir.

Primeiramente se p e i são dois números naturais, nesse caso com 0 < i < p, chama-se

número binomial de classe i ao número (cid:0)p
i

(cid:1) dado por

(cid:19)

(cid:18)p
i

=

p!
i!(p − i)!

=

p(p − 1)(p − 2)...(p − i + 1)(p − i)!
i!(p − i)!

=

p(p − 1)...(p − i + 1)
i!

.

Lema 2. Seja p um número primo. Os números (cid:0)p
i

(cid:1), onde 0 < i < p, são todos divisíveis por p.

52

Capítulo 3. Principais Conceitos e Teoremas

Demonstração. O resultado vale trivialmente para i = 1, pois (cid:0)p
(cid:1) = p e p|p. Podemos, então,
1
supor 1 < i < p. Neste caso i!|p(p − 1)...(p − i + 1). Como (i!, p) = 1, decorre que i!|(p −
1)...(p − i + 1), e o resultado se segue, pois como visto anteriormente:

(cid:19)

(cid:18)p
i

=

p(p − 1)...(p − i + 1)
i!

.

Teorema 3.17. (Pequeno Teorema de Fermat) Dado um número primo p, tem-se que p divide
o número ap − a, para todo a ∈ N.

Demonstração. Vamos provar o resultado por indução sobre a. O resultado vale para a = 1, pois
p|0. Supondo o resultado válido para a, iremos provar para a + 1. Pela fórmula do Binômio de
Newton,

(a + 1)p − (a + 1) = ap − a + (cid:0)p
1

(cid:1)ap−1 + ... + (cid:0) p
p−1

(cid:1)a.

Pelo lema anterior e pela hipótese de indução, o segundo membro da igualdade acima é

divisível por p.

Como consequência do Pequeno Teorema de Fermat, podemos escrever o seguinte

corolário.

Corolário 3. Se p é um número primo e se a é um número natural não divisível por p, então p
divide ap−1 − 1.

Demonstração. Como, pelo Pequeno Teorema de Fermat, p|a(ap−1 − 1) e como (a, p) = 1,
segue, imediatamente, que p divide ap−1 − 1.

O interessante é observar que o Pequeno Teorema de Fermat nos serve como um teste de

não primalidade.

Dado m ∈ N, com m > 1, se existir algum a ∈ N, com mdc(a, m) = 1, e m (cid:45) am−1 − 1,

então m não é primo.

Porém, é interessante salientar que se um número, m > 1, atender a condição de m|am−1 −

1, esse número não é necessariamente primo. Isso pode ser visto no exemplo abaixo.

Exemplo 3.17. Seja a ∈ N tal que mdc(a, 3) = mdc(a, 11) = mdc(a, 17) = 1. Isso é equivalente
a mdc(a, 561) = 1, pois 3.11.17 = 561.

Por outro lado,

mdc(a280, 3) = mdc(a56, 11) = mdc(a35, 17) = 1.

3.2. Divisibilidade

53

Pelo Pequeno Teorema de Fermat, 3 divide (a280)2 −1 = a560 −1, 11 divide (a56)10 −1 =
a560 − 1 e 17 divide (a35)16 − 1 = a560 − 1. Daí segue que 561 divide a560 − 1, para todo a tal
que mdc(a, 561) = 1, sem que 561 seja primo.

Apresentaremos agora algumas propriedades de alguns números primos.

Primos de Fermat e de Mersenne

Nessa parte será feito o estudo de alguns números primos, como números de Fermat em
homenagem a Pierre de Fermat (1601-1665), que após Euclides e Eratóstenes, foi considerado o
primeiro matemático a contribuir para o desenvolvimento da Teoria dos Números.

Proposição 10. Sejam a e n números naturais maiores do que 1. Se an + 1 é primo, então a é
par e n = 2m, com m ∈ N.

Demonstração. Suponhamos que an + 1 seja primo, onde a > 1 e n > 1. Logo, a tem que ser
par, pois, caso contrário, an + 1 seria par e maior do que dois, o que contraria o fato de ser primo.

Se n tivesse um divisor primo p, diferente de 2, teríamos n = n′ p com n′ ∈ N, e n′ ̸= 0.
Portanto, pelo Teorema 3.7, an′

+ 1 dividiria (an′)p + 1 = an + 1, contradizendo o fato

desse último número ser primo. Isto implica que n é da forma 2m.

Os números de Fermat são os números da forma Fn = 22n

+ 1, n = 0, 1, ....

Em 1640, Fermat aﬁrmou que acreditava que todos os números dessa forma eram primos,

baseando-se no fato de que F0 = 3, F1 = 5, F2 = 17, F3 = 257, F4 = 65537 são primos.

Mas em 1732, Leonard Euler, provou que F5 = 225 + 1 = 641 x 6700417, portanto um
número composto. Até hoje, não se sabe se existem outros números de Fermat além dos cinco
primeiros, que são chamados de primos de Fermat.

Proposição 11. Sejam a e n números naturais maiores do que 1. Se an − 1 é primo, então a = 2
e n é primo.

Demonstração. Suponhamos que an − 1 seja primo, com a > 1 e n > 1. Suponhamos, por
absurdo, que a > 2. Logo a − 1 > 1 e a − 1|an − 1 pelo Teorema 3.6 e, portanto, an − 1 não é
primo, assim temos uma contradição. Consequentemente a = 2.

Por outro lado, suponhamos, por absurdo, que n não é primo. Temos que n = rs com
r > 1 e s > 1. Como 2r − 1 divide (2r)s − 1 = 2n − 1, novamente considerando o Teorema 3.6,
contradiz o fato de 2n − 1 ser primo. Portanto, n é primo.

Os números de Mersenne são os números da forma Mp = 2p − 1, onde p é um número

Capítulo 3. Principais Conceitos e Teoremas

54

primo.

Para p pertencente ao intervalo 2 ≤ p ≤ 5000 os números de Mersenne que são pri-
mos são chamados de primos de Mersenne e correspondem aos seguintes valores de p :
2, 3, 5, 7, 13, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 3217, 4253 e 4423.

Em Janeiro de 2016, o pesquisador estadunidense Curtis conseguiu calcular o maior
número primo de Mersenne até o momento. Este número é formado por mais de 22 milhões
de dígitos, e é da forma 274207281 − 1. Vale lembrar que esse tipo de sequência numérica é um
componente importante para os sistemas de encriptação usados em computadores (Ver [15]).

3.2.7 Teorema Fundamental da Aritmética

Teorema 3.18. (Teorema Fundamental da Aritmética) Todo número 1 < n ∈ N ou é primo
ou se escreve como produto de números primos, de forma única (a menos da ordem dos fatores).

Demonstração. Usando a segunda forma do Princípio de Indução, podemos escrever que

1o) Se n = 2, o resultado é óbvio.

2o) Suponhamos o resultado válido para todo número natural menor do que n e vamos
provar que vale para n. Se o número n é primo, nada temos a demonstrar. Suponhamos, então, n
composto.

Logo, existem números naturais n1 e n2 tais que n = n1.n2, com 1 < n1 < n e 1 < n2 < n.
Pela hipótese de indução, temos que existem números primos p1, ..., pr e q1, ..., qs tais que
n1 = p1...pr e n2 = q1...qs. Portanto, n = p1...prq1...qs.

Para provar a unicidade da escrita suponhamos, agora que, n = p1...pr = q1...qs, onde
os pi e q j são números primos. Como p1|q1...qs, concluímos, aplicando-se repetidas vezes a
Proposição 9, que p1 tem que dividir alguns dos fatores q1, q2, ..., qs. Logo existe k(1 ≤ k ≤ s)
com p1|qk. Como p1 e qk são primos, temos p1 = qk ≥ q1. Da mesma forma, q1|pl para algum
l(1 ≤ l ≤ r) e segue q1 = pl ≥ p1. Assim, p1 = q1. Agora, de p1.p2...pr = q1.q2...qs segue que

p2...pr = q2....qs.

Portanto, por indução, concluímos r −1 = s−1, isto é, r = s e p2 = q2, p3 = q3,...,pr =

qr que junto com p1 = q1 ﬁca provado o que queríamos demonstrar.

Agrupando no Teorema Fundamental da Aritmética, os fatores primos repetidos, se
necessário, e ordenando os números primos em ordem crescente podemos enunciar o seguinte
teorema.

3.2. Divisibilidade

55

Teorema 3.19. Para todo número 1 < n ∈ N existem únicos primos distintos p1, p2, ..., pr (os
quais podemos supor em ordem natural p1 < ... < pr) e únicos números a1, a2, ..., ar ∈ N de tal
maneira que

n = pa1

1 .pa2

2 ...par

r =

r
∏
k=1

pak
k .

O produto

r
∏
k=1

pak
k chama-se decomposição primária de n.

É interessante notar que um número natural n > 1, escrito na forma n = pa1

1 ...par

r é um

quadrado perfeito, se, e somente se, cada expoente ai é par.

Ao estudarmos os números primos, nos vem a ideia se o conjunto formado pelos números
primos é ﬁnito ou não. Essa duvida foi respondida por Euclides de Alexandria em 300 a.C. no
livro IX dos Elementos. Ele provou usando redução ao absurdo, pela primeira vez em Matemática,
sendo esta prova considerada uma das pérolas em Matemática.

Teorema 3.20. Existem inﬁnitos números primos.

Demonstração. Suponhamos que os números primos formassem um conjunto ﬁnito, repre-
sentado por P = {p1, p2, ..., pr}. Consideremos um número natural n = p1.p2....pr + 1. Pelo
Teorema Fundamental da Aritmética, este n > 1 é divisível por algum primo q. Pela suposição,
q = pk para algum k ∈ {1, 2, ..., r} e, consequentemente, esse q divide o produto p1 p2...pr. Mas,
isto implica também que q divide 1, o que é um absurdo. Logo, nenhum conjunto ﬁnito pode
conter todos os primos.

Ao saber da inﬁnitude dos números primos, nos perguntamos, se é possível obter uma

lista que contenha números primos até uma dada ordem.

Será apresentado a seguir, um dos métodos mais antigos para obter uma tabela de
números primos, chamado de Crivo de Eratóstenes, devido ao matemático grego Eratóstenes,
que viveu por volta de 230 anos antes de Cristo. Esse método, descrito em [13] e [16], permite
determinar todos os números primos até a ordem que se desejar, mas não é muito eﬁciente para
ordens elevadas.

Para se obter os números primos até uma certa ordem n, escreva os números de 2 até n

em uma tabela.

O primeiro desses números, o 2, é primo. Risque todos os demais múltiplos de 2 na

tabela, pois não são primos.

56

Capítulo 3. Principais Conceitos e Teoremas

O próximo número não riscado é o 3, que também é primo. Risque todos os múltiplos de

3 na tabela, pois esses não são primos.

O seguinte número não riscado é o 5 que é um número primo. Risque os demais múltiplos

de 5 na tabela.

Seguindo, temos que o próximo número não riscado é o 7, que também é primo. Risque

os demais múltiplos de 7 na tabela.

Note que o procedimento segue da mesma maneira enquanto dado um número primo p,

p2 ≤ n. Isso se deve a uma consequência dada pelo próprio Eratóstenes.

Faremos como exemplo o resultado para n = 150. Para esse caso, o procedimento termina
quando chegarmos no número primo 11, visto que para o próximo primo 13, quando elevado ao
quadrado resulta em 169 que é maior que 150.

2
12
22
32
42
52
62
72
82
92
102
112
122
132
142

3
13
23
33
43
53
63
73
83
93
103
113
123
133
143

4
14
24
34
44
54
64
74
84
94
104
114
124
134
144

5
15
25
35
45
55
65
75
85
95
105
115
125
135
145

6
16
26
36
46
56
66
76
86
96
106
116
126
136
146

8
7
18
17
28
27
38
37
48
47
58
57
68
67
78
77
88
87
97
98
107 108
118 119
117
127 128 129
137 138
148
147

10
9
20
19
30
29
40
39
50
49
60
59
70
69
80
79
90
89
99
100
109 110
120
130
139 140
149 150

11
21
31
41
51
61
71
81
91
101
111
121
131
141

Tabela 1: Crivo de Eratóstenes.

Ao término desse procedimento, os números não riscados são todos primos menores ou

iguais a n.

Lema 3. Se um número natural n > 1 não é divisível por nenhum número primo p tal que p2 ≤ n,
então ele é primo.

Demonstração. Suponhamos, por absurdo, que n não seja divisível por nenhum número primo p
tal que p2 ≤ n e que não seja primo. Seja q o menor número primo que divide n; então, n = qn1,
com q ≤ n1. Segue daí que q2 ≤ qn1 = n. Logo, n é divisível por um número primo q tal que
q2 ≤ n, absurdo.

3.2. Divisibilidade

57

Note que o Lema acima descrito também nos fornece um teste de primalidade, pois, para
veriﬁcar se um certo número n é primo, basta veriﬁcar que não é divisível por nenhum primo p
que não supere

√

n.

Exemplo 3.18. Para mostrar que o número 221 é composto basta testar se ele é múltiplo de algum
dos números primos p = 2, 3, 5, 7, 11 e 13 já que o próximo primo 17 é tal que 172 = 289 > 221.

Fazendo esse procedimento obtemos que 221 é divisível por 13 (221 = 13 x 17), portanto

não é primo.

A distribuição dos números primos dentro dos naturais ainda é algo desconhecido e está

ligada a muitos problemas em estudos.

Pela tabela acima, nota-se que existem pares de números primos que diferem de duas uni-
dades. Podemos listar alguns deles: (3, 5), (5, 7), (11, 13) , (17, 19), (29, 31), (41, 43), (59, 61),
(71, 73) entre outros.

Esses pares de primos consecutivos são chamados de primos gêmeos e eles diferem de 2

unidades.

Deﬁnição 8. Um par de números (p, p + 2) é denominado um gêmeo de primos se ambos, p e
p + 2 são primos.

É interessante citar que até o presente momento os matemáticos ainda não sabem dizer

se os pares de primos gêmeos formam um conjunto ﬁnito ou inﬁnito.

Um outro problema matemático, ainda em aberto, é a conjectura de Goldbach (lembrando

que o termo Conjectura, em uma linguagem mais coloquial signiﬁca palpite, chute).

O matemático prussiano Christian Goldbach, numa certa carta de 7 de junho de 1742
endereçada a Leonard Euler, um dos maiores matemáticos, propôs que se provasse que todo
número natural maior do que 5 pode ser escrito como soma de três números primos:

Por exemplo: 6 = 2 + 2 + 2, 7 = 3 + 2 + 2, 8 = 3 + 3 + 2, 9 = 5 + 2 + 2, 10 = 5 + 3 + 2,

e assim por diante.

Euler, por sua vez, respondeu que acreditava na conjectura, mas que prová-la era equiva-

lente a mostrar que todo número par maior ou igual a 4 era soma de dois números primos.

Por exemplo: 4 = 2 + 2, 6 = 3 + 3, 8 = 5 + 3, 10 = 3 + 7 etc.

Em 1937, o matemático russo Ivan Vinogradov, demonstrou o difícil teorema que garante
que todo número natural ímpar, suﬁcientemente grande, pode ser escrito como soma de, no
máximo, três números primos.

Muitos problemas ainda por resolver estão relacionados com a distribuição dos números

primos dentro da sequência dos números naturais.

58

Capítulo 3. Principais Conceitos e Teoremas

3.3 Congruências

Realizaremos agora um estudo da aritmética com os restos da divisão euclidiana por um

número dado.

Deﬁnição 9. Seja n ∈ N, com n ̸= 0, um número ﬁxo. Dois números a, b ∈ Z chamam-se
congruentes módulo n, se os restos de sua divisão euclidiana por n são iguais. Quando os inteiros
a e b são congruentes módulo n, escreve-se:

a ≡ b (mod n).

Proposição 12. Suponha que a, b ∈ N são tais que b ≥ a. Tem-se que a ≡ b (mod n) se, e
somente se, n|b − a.

Demonstração. Sejam a = nq + r, com r < n e b = nq′ + r′, com r′ < n as divisões euclidianas
de a e b por n, respectivamente. Logo,

(cid:40)

b − a =

n(q′ − q) + (r′ − r), se r′ ≥ r
n(q′ − q) − (r − r′), se r ≥ r′

Portanto, a ≡ b (mod n) se, e somente se r = r′, o que em vista da igualdade acima, é

equivalente a dizer que n|b − a, já que |r − r′| < n.

Por exemplo, 22 ≡ 7 (mod 5), pois os restos da divisão de 22 e de 7 por 5 são iguais a 2.

Quando a e b não possuírem o mesmo resto na divisão por n, dizemos que a relação

a ≡ b (mod n) é falsa. Nesse caso, escrevemos a ̸≡ b (mod n).

Como o resto da divisão de um número natural qualquer por 1 é sempre zero, temos que

a ≡ b (mod 1), para quaisquer a, b ∈ N. Portanto, consideremos sempre n > 1.

Todo número inteiro é congruente módulo n ao seu resto pela divisão euclidiana por n, e
portanto, é congruente módulo n a um dos números 0, 1, ..., n − 1. E dentre esses números, dois
deles não são congruentes módulo n entre si.

Chamaremos de sistema completo de resíduos módulo n a todo conjunto de números
inteiros cujos restos pela divisão por n são os números 0, 1, ..., n − 1, em qualquer ordem e sem
repetições.

Exemplo 3.19. Para n = 7, temos que {0, 1, 2, 3, 4, 5, 6} é o conjunto dos menores restos não-
negativos módulo 7. E que {−23, 15, 70, −47, 83, −4, 36} é um sistema completo de resíduos
módulo 7, pois −23 ≡ 5, 15 ≡ 1, 70 ≡ 0, −47 ≡ 2, 83 ≡ 6, −4 ≡ 3, 36 ≡ 4 (mod 7).

Portanto, um sistema de resíduos completo módulo n possui n elementos.

O que tornam as congruências tão úteis em problemas de divisibilidade e compatível com
as operações de adição e multiplicação nos inteiros é o fato de ser uma relação de equivalência.

3.3. Congruências

59

Como visto em [11] podemos estabelecer as seguintes propriedades.

Teorema 3.21. (Propriedades Fundamentais das Congruências). Seja n ∈ N, a, b, c, d ∈ Z.
Temos:

1) (Reﬂexividade): a ≡ a (mod n).

Demonstração. a ≡ a (mod n) pois n|a − a = 0.

2) (Simetria): Se a ≡ b (mod n), então b ≡ a (mod n).

Demonstração. Se n|a − b, então n| − (a − b) ⇔ n|b − a.

3) (Transitividade): Se a ≡ b (mod n) e b ≡ c (mod n), então a ≡ c (mod n).

Demonstração. Se n|a − b e n|b − c, então n|(a − b) + (b − c) ⇔ n|a − c.

4) (Compatibilidade com a soma e diferença): Pode-se somar e subtrair membro a

membro

(cid:40)

a ≡ b (mod n)
c ≡ d (mod n)

(cid:40)

⇒

a + c ≡ b + d (mod n)
a − c ≡ b − d (mod n)

Demonstração. Se n|a − b e n|c − d, então n|(a − b) + (c − d).

Como (a − b) + (c − d) pode ser escrito da forma (a + c) + (−b − d) = (a + c) − (b + d),

então n|(a + c) − (b + d). O outro caso é análogo.

Como consequência disso, temos que se a ≡ b (mod n), então ka ≡ kb (mod n) para todo

k ∈ Z.

5) (Compatibilidade para o produto): Pode-se multiplicar membro a membro em uma

congruência

(cid:40)

a ≡ b (mod n)
c ≡ d (mod n)

⇒ ac ≡ bd (mod n)

Demonstração. n|(a − b) − (c − d) ⇔ n|(a − b) + (−c + d) ⇔ n|(a − c) + (d − b) ⇔ n|(a − c) −
(b − d) e n|(a − b)c + (c − d)b ⇔ n|ac − bd.

Em particular, se a ≡ b (mod n), então ak ≡ bk (mod n) para todo k ∈ N.

6) (Cancelamento): Se mdc(c, n) = 1, então

ac ≡ bc (mod n) ⇔ a ≡ b (mod n).

60

Capítulo 3. Principais Conceitos e Teoremas

Demonstração. Como mdc(c, n) = 1 temos que n|ac − bc ⇔ n|(a − b)c ⇔ n|a − b pela Proposi-
ção 4.

Vejamos alguns exemplos:

1) Demonstrar que 31|2015 − 1.

Isso equivale a mostrar que 2015 ≡ 1 (mod 31). Para isso, podemos notar que

20 ≡ −11 (mod 31)

e assim 202 ≡ (−11)2(mod 31) ⇔ 202 ≡ 121 (mod 31).

Como 121 ≡ −3 (mod 31) temos que

202 ≡ −3 (mod 31).

Multiplicando

(cid:40)

20 ≡ −11 (mod 31)
202 ≡ −3 (mod 31)

membro a membro

obtemos 203 ≡ 33 (mod 31) e como 33 ≡ 2 (mod 31) temos,

203 ≡ 2(mod 31).

Elevando a 5, temos que 2015 ≡ 25 = 32 e como 32 ≡ 1 (mod 31), obtemos 2015 ≡

1 (mod 31), como desejado.

2) Se a ≡ b (mod 4), mostre que a ≡ b (mod 2).

Para resolver esse exercício faz-se o uso da seguinte proposição.

Proposição 13. Sejam a, b ∈ N, m, n ∈ N∖{0, 1}. Temos que se a ≡ b (mod m) e n|m então
a ≡ b (mod n).

Demonstração. Se a ≡ b (mod m) então m|(b − a). Como n|m, segue que n|(b − a). Logo,
a ≡ b (mod n).

Como no exercício temos a ≡ b (mod 4) e 2|4, então a ≡ b (mod 2).

Em congruências ainda podemos estabelecer a seguinte deﬁnição

Deﬁnição 10. Dado n ∈ N. Uma congruência linear é uma congruência da forma

onde a, b ∈ Z são dados e as soluções x ∈ Z são procuradas.

ax ≡ b (mod n)

3.3. Congruências

61

Exemplo 3.20. 2x ≡ 5 (mod 6).

Essa congruência linear não tem solução. Podemos escrever 2x − 5 ≡ 0 (mod 6). Para
isso, precisamos de um número ímpar, 2x − 5, que dividido por um número par, no caso 6, resulte
em uma divisão exata, o que é impossível.

Primeiramente, vamos dar um critério para estabelecer se tais congruências admitem ou

não soluções.

Proposição 14. Dados n ∈ N, e a, c ∈ Z, com n > 1, a congruência ax ≡ c (mod n) possui
solução se e somente se, mdc(a, n)|c.

Demonstração. Suponha que a congruência ax ≡ c (mod n) tenha uma solução x, logo, temos
que n|c − ax ou n|ax − c, o que equivale a existência de y tal que c − ax = ny ou ax − c = ny.
Portanto, pelo menos uma das seguintes equações ny + ax = c ou ax − ny = c admite solução.
Logo, pela Proposição 7, mdc(a, n)|c.

Reciprocamente, suponha que mdc(a, n)|c. Logo, em virtude da Proposição 7, a equação
ax − ny = c admite uma solução x, y. Portanto, ax = c + ny e, consequentemente, x é solução da
congruência pois, ax ≡ c (mod n).

Se x0 é solução da congruência ax ≡ c (mod n), então todo x tal que x ≡ x0 (mod n) é

também solução da congruência pois,

ax ≡ ax0 ≡ c (mod n).

Com isso toda solução particular, determina, automaticamente, uma inﬁnidade de solu-

ções da congruência, congruentes entre si.

O interesse é determinar uma coleção completa de soluções duas a duas incongruen-
tes módulo n, as quais serão chamadas de sistema completo de soluções incongruentes da
congruência.

Proposição 15. Sejam n ∈ N e a, b ∈ Z e seja d = mdc(a, n). Se d|b, então ax ≡ b (mod n) possui
exatamente d soluções incongruentes entre si módulo n. Se x0 ∈ Z é uma solução particular
(chamada de solução minimal), então d soluções incongruentes são obtidas por

x0, x0 + n

d , x0 + 2n

d , x0 + 3n

d ,..., x0 + (d − 1) n
d .

Demonstração. Seja d|b e seja x0 ∈ Z com ax0 ≡ b (mod n), isto é, ax0 + ny0 = b para algum
y0 ∈ Z. Pela Proposição 8, toda solução de ax ≡ b (mod n) é então da forma x = x0 + n
d t, com
t ∈ Z.

Escrevendo-se t = qd + k, com q, k ∈ Z e com 0 ≤ k ≤ d − 1 temos

Capítulo 3. Principais Conceitos e Teoremas

x = x0 +

n
d

t = x0 +

n
d

(qd + k) = x0 + qn + k

n
d

≡ x0 + k

n
d

(mod n).

Mostramos portanto que toda solução é congruente módulo n a um dos números indica-

62

dos.

Mais ainda, de x0 + j n

d ≡ x0 + k n

d (mod n), com 0 ≤ j, k ≤ d − 1 segue que

Assim,

j n
d ≡ k n

d (mod n).

d = k n
j n

d + ln, com l ∈ Z.

Dividindo-se por n

d , segue j = k + ld ≡ k (mod d).

De 0 ≤ | j − k| ≤ d − 1, concluímos l = 0 e j = k.

Isto mostra que as d soluções indicadas são incongruentes módulo n.

Exemplo 3.21. A aplicação de congruência a seguir nos conta algo interessante. Em 1969, D. J.
Lewis aﬁrmou que a equação x3 − 117y3 = 5 tem no máximo 18 soluções inteiras. Dois anos
depois, R Finkelstein e H.Lodon, usando métodos de Teoria Algébrica dos Números, provaram
que essa equação não possuía nenhuma solução. Mas em 1973, F. Halter-Koche e V.St.Udresco
conseguiram enxergar uma prova mais simples para esse caso, que é descrita abaixo.

Queremos mostrar que a equação x3 − 117y3 = 5 não possui soluções inteiras. Observa-

mos que como 117 é múltiplo de 9, qualquer solução inteira deve satisfazer

x3 − 117y3 ≡ 5 (mod 9) ⇔ x3 ≡ 5 (mod 9).

Porém, x só pode deixar resto 0, 1, ..., 8 na divisão por 9. Analisando estes 9 casos, temos

x (mod 9)
x3 (mod 9)

0

0

1

1

2

8

3

0

4

1

5

8

6

0

7

1

8

8

Ou seja, x3 só pode deixar resto 0, 1 ou 8 na divisão por 9. Logo, x3 ≡ 5 (mod 9) é

impossível e a equação não possui soluções inteiras.

Exemplo 3.22. Resolver a equação 8x ≡ 4 (mod 12).

Como d = mdc(8, 12) = 4 e 4|4, a congruência tem 4 soluções módulo 12.

Por tentativa, obtém-se, x0 = 2 como solução minimal. Portanto, as soluções módulo 12

são

2, 2 + 12

4 , 2 + 2 12

4 , 2 + 3 12

4 = 2, 5, 8, 11.

3.3. Congruências

63

Pela Proposições 13 e 14 podemos estabelecer o seguinte resultado.

Corolário 4. Sejam n ∈ N, e a, x, y ∈ Z com d = mdc(a, n). Então,

ax ≡ ay (mod n) ⇒ x ≡ y (mod n

d ).

Demonstração. Como d = mdc(a, n), temos que a = d.a′ e n = d.n′ e que mdc(a′, n′) = 1.
Assim,

ax ≡ ay (mod n) ⇔ n|ax − ay ⇔ n|a(x − y) ⇔ dn′|da′(x − y) ⇔ n′|a′(x − y) ⇔ n

d =

n′|(x − y) ⇔ x ≡ y (mod n

d ).

Portanto, numa congruência módulo n um fator comum pode ser cancelado, desde que

se observe que a nova congruência só é válida módulo n
d .

Consideremos a, n ∈ N com n > 1 e d = mdc(a, n). Quando d = 1, temos o seguinte

resultado.

Lema 4. Se mdc(a, n) = 1, então existe x inteiro tal que ax ≡ 1 (mod n). Tal inteiro é único
módulo n. Se mdc(a, n) > 1 não existe tal inteiro.

Demonstração. Se mdc(a, n) = 1, pelo Teorema de Bézout, existem x, y ∈ Z com ax + ny = 1,
mas ax + ny ≡ ax (mod n); logo ax ≡ 1 (mod n).

Se x′ = x (mod n) ⇒ ax′ ≡ ax ≡ 1 (mod n).

Se aZ ≡ 1 (mod n) ⇒ aZ ≡ 1 ≡ ax (mod n) ⇒ n|aZ − ax = a(Z − x).

Como mdc(a, n) = 1 ⇒ n|Z − x ⇒ Z ≡ x (mod n).

Se mdc(a, n) = d > 1 e ax ≡ 1 (mod n) ⇒ n|1 − ax ⇒ ∃ y; 1 − ax = ny ⇒ ax + ny = 1.

(cid:41)

d|a ⇒ d|ax
d|n ⇒ d|ny

⇒ d|ax + ny = 1, o que é um absurdo, pois 1 não pode ser múltiplo de d > 1.

A solução de ax ≡ 1 (mod n), com mdc(a, n) = 1 é única e será chamada de inverso

multiplicativo módulo n.

Exemplo 3.23. Encontre x ∈ Z, tal que x ≡ 1 (mod 11) e x ≡ 2 (mod 7):

Solução: Se x ≡ 1 (mod 11) ⇒ x = 11k + 1, k ∈ Z.

Como x ≡ 2 (mod 7) podemos escrever que:

64

Capítulo 3. Principais Conceitos e Teoremas

11k + 1 ≡ 2 (mod 7) ⇔ 11k ≡ 1 (mod 7) ⇔ 4k ≡ 1 (mod 7).

Como mdc(4, 7) = 1, essa congruência possui solução, que é o inverso multiplicativo de

4 módulo 7.

Quando fazemos 4.2 encontramos 8, que quando dividido por 7 resta 1. Então,

k ≡ 2 (mod 7) ⇔ k = 7r + 2, r ∈ Z.

Substituindo k em x, obtemos que

x = 11(7r + 2) + 1 = 77r + 23, r ∈ Z, são soluções.

A possibilidade de associar a divisão euclidiana à congruência modular nos permite

utilizá-la para trabalhar com polinômios (Ver [12]).

Exemplo 3.24. Calcular o resto da divisão de P(x) = x5 + x + 1 por x3 − 1.

Sabe-se que x3 − 1 ≡ 0 (mod x3 − 1).

Somando 1 a ambos os lados da congruência, tem-se

x3 ≡ 1 (mod x3 − 1).

Multiplicando ambos os lados da congruência por x2, obtemos

x3.x2 ≡ 1.x2 (mod x3 − 1)

x5 ≡ x2 (mod x3 − 1).

Podemos somar x + 1 a ambos os lados, pois x + 1 ≡ x + 1 (mod x3 − 1).

Com isso,

x5 + x + 1 ≡ x2 + x + 1 (mod x3 − 1).

Ou seja, o resultado da divisão de x5 + x + 1 por x3 − 1 é igual a x2 + x + 1.

Exemplo 3.25. Provar que P(x) = x999 + x888 + x777 + ... + x111 + 1 é divisível pelo polinômio
D(x) = x9 + x8 + x7 + ... + x1 + 1.

Podemos escrever x10 − 1 como (x − 1)(x9 + x8 + x7 + ... + x1 + 1).

Utilizando-se da notação de congruência podemos escrever que x10 − 1 ≡ 0 (mod x9 +

x8 + x7 + ... + 1), ou ainda que

x10 ≡ 1 (mod x9 + x8 + x7 + ... + 1).

3.3. Congruências

65

Com isso, todas as potências x10 no P(x) podem ser substituídas por 1.
P(x) = x999 +x888 +x777 +...+x111 +1 ⇒ P(x) = x9(x10)99 +x8(x10)88 +x7(x10)77 + ...

+x(x10)11 + 1 ≡ x9 + x8 + ... + x + 1 ≡ 0 (mod x9 + x8 + x7 + ... + x + 1).

Logo, P(x) é divisível por D(x).

A vantagem de usarmos congruência é que podemos substituir as potências grandes de x
por outros termos que correspondem ao resto da divisão dessas potências pelo módulo dado no
exercício.

Apresentaremos agora um algoritmo para resolver sistemas de congruências lineares.
Como visto em [3], esse algoritmo é muito antigo e foi inventado pelos chineses e pelos gregos
para resolver problemas de astronomia.

Esse método recebe o nome de Algoritmo Chinês do resto porque um dos primeiros
lugares em que aparece é no livro Manual de Aritmética do Mestre Sun, escrito entre 287 d.C. e
473 d.C. O mesmo também é mencionado na Aritmética de Nicômaco de Gerasa.

Teorema 3.22. (Teorema Chinês dos Restos)

Sejam m1, m2, ..., mr, inteiros positivos primos entre si, dois a dois, isto é, mdc(mi, m j) =

1 sempre que i ̸= j, e sejam a1, a2, ..., ar inteiros quaisquer. Então o sistema de congruências

x ≡ a1 (mod m1)
x ≡ a2 (mod m2)

...

x ≡ ar (mod mr)
admite uma solução x. Além disso, as soluções são únicas módulo m, sendo m = m1.m2....mr.

Demonstração. Seja m = m1.m2....mr.

Temos que M j = m
m j
.b j ≡ 1 (mod m j), pelo Lema 4.

≡ 0 (mod mi), ∀ j ̸= i e mdc( m
m j

m
m j

, m j) = 1, logo ∃ b j ∈ Z tal que

Considere

x = a1. m
m1

.b1 + a2. m
m2

.b2 + ... + ar. m
mr

.br.

Temos x ≡ ai. m
mi

.bi (mod mi).

Assim, m
mi

sistema.

.bi ≡ 1 (mod mi) ⇒ x ≡ ai.1 ≡ ai (mod mi) ∀i ≤ r , isto é, x é solução do

Imaginemos que exista outra solução y ∈ Z.

Temos y ≡ ai (mod mi), ∀i ≤ r ⇔ y ≡ x (mod mi), ∀i ≤ r ⇔ mi|y−x, ∀i ≤ r ⇔ m1.m2...mr

|y − x ⇔ y ≡ x (mod m1.m2...mr).

66

Capítulo 3. Principais Conceitos e Teoremas

Uma aplicação do Teorema Chinês do Resto seria na astronomia. Veja um exemplo que

ilustra esse fato, visto em [3].

Três satélites passarão sobre o Rio esta noite. O primeiro à 1 hora da madrugada, o
segundo às 4 horas e o terceiro às 8 horas da manhã. Cada satélite tem um período diferente.
O primeiro leva 13 horas para completar uma volta em torno da Terra, o segundo 15 horas e o
terceiro 19 horas. Determine quantas horas decorrerão, a partir da meia-noite, até que os três
satélites passem ao mesmo tempo sobre o Rio.

Para resolvermos este problema usando o Teorema Chinês dos Restos, chamaremos de x
o número de horas contadas a partir da meia-noite de hoje, quando os três satélites passarão juntos
sobre o Rio. O primeiro satélite passa sobre o Rio a cada 13 horas, a contar da 1 da madrugada.
Logo, precisamos ter que x = 1 + 13t, para algum t inteiro positivo, o que é equivalente a
congruência x ≡ 1 (mod 13). As equações correspondentes aos outros dois satélites são

x ≡ 4 (mod 15)

e

x ≡ 8 (mod 19).

Como os módulos são diferentes não podemos somar ou subtrair. Para resolver usaremos

o Teorema Chinês dos Restos, descrito anteriormente.

1o) Escrevendo m = m1.m2.m3, temos m = 13.15.19 = 3705.

2o) Encontrar os M j, que são da forma M j = m
m j

.

M1 =

M2 =

M3 =

13.15.19
13
13.15.19
15
13.15.19
19

= 285 ;

= 247;

= 195.

3o) Encontrar os b j, que é o inverso multiplicativo M j, módulo m j, ou seja, M j.b j ≡

1 (mod m j).

b1:

285b1 ≡ 1 (mod 13).

Correspondendo a uma equação diofantina temos que

285b1 − 13t = 1, com t ∈ Z.

Através do algoritmo de Euclides, obtemos

3.3. Congruências

67

12

1

21

13

1

1

12

0

285

12

1 = 13 − 12.1
1 = 13 − (285 − 13.21).1
1 = 13 − 285 + 13.21
1 = (−1).285 + 13.22

Então b1 = −1.

247b2 ≡ 1 (mod 15).

b2:

Correspondendo a uma equação diofantina, temos que

247b2 − 15t = 1, com t ∈ Z.

Através do algoritmo de Euclides, obtemos

7

1

16

15

1

2

7

0

247

7

1 = 15 − 7.2
1 = 15 − (247 − 15.16).2
1 = 15 − 2.247 + 32.15
1 = 33.15 − 2.247

Então b2 = −2.

195b3 ≡ 1 (mod 19).

b3:

Correspondendo a uma equação diofantina, temos que

195b3 − 19t = 1, com t ∈ Z.

68

Capítulo 3. Principais Conceitos e Teoremas

Através do algoritmo de Euclides, obtemos

10

19

4

3

5

1

1

4

0

4

1

195

5

1 = 5 − 4.1
1 = 5 − 1(19 − 3.5).1
1 = 1.5 − 1.19 + 3.5
1 = 4.5 − 1.19
1 = 4(195 − 19.10) − 1.19
1 = 4.195 − 40.19 − 1.19
1 = 4.195 − 41.19.

Então b3 = 4.

A solução é única e da forma

x =

m
m1

b1.a1 +

m
m2

b2.a2 +

m
m3

b3.a3.

x =

3705
13

(−1).1 +

3705
15

.(−2).4 +

3705
19

.4.8.

x = −285 − 1976 + 6240

x = 3979.

Como 3979 ≡ 274 (mod 3705), segue-se que 274 é a solução minimal única módulo

3705 e qualquer outra solução é da forma 274 + 3705λ , com λ ∈ N.

Portanto, os satélites passarão novamente juntos sobre o Rio após 274 horas, que corres-

ponde a 11 dias e 10 horas.

Uma outra aplicação do Teorema Chinês do Resto por ser usada em uma brincadeira que

pode ser proposta por um professor em sala de aula, como consta em [7].

O professor pede ao aluno que escolha um número menor que 1001 e que diga os restos
r7, r11, r13 desse número quando dividido por 7, 11 e 13, respectivamente. Sem nenhuma outra
informação dada pelo aluno, o professor pode adivinhar o número escolhido pelo aluno.

Seja x um número natural e sejam r7, r11 e r13 os seus restos pela divisão por 7,11 e 13,

respectivamente.

Tem-se então que

x ≡ r7 (mod7)

3.3. Congruências

69

x ≡ r11 (mod11)

x ≡ r13 (mod13)

Pelo Teorema Chinês do Resto, temos que

1o) m = m1.m2.m3 = 7.11.13 = 1001.

=

M1 =

= 143.

2o) Encontrando os M j obtemos
1001
7
1001
11
1001
13

m
m1
m
m2
m
m3

M3 =

M2 =

= 91.

= 77.

=

=

3o) Encontrar os b j, que é o inverso multiplicativo M j, módulo m j:

b1:

143b1 ≡ 1 (mod 7).

Correspondendo a equação diofantina temos que

143b1 − 7t = 1, com t ∈ Z.

Através do algoritmo de Euclides, obtemos

3

1

20

7

1

2

3

0

143

3

1 = 7 − 3.2
1 = 7 − (143 − 7.20).2
1 = 7 − 2.143 + 7.40
1 = (−2).143 + 41.7

Então b1 = −2.

91b2 ≡ 1 (mod 11).

b2:

Correspondendo à equação diofantina temos que

91b2 − 11t = 1, com t ∈ Z.

70

Capítulo 3. Principais Conceitos e Teoremas

Através do algoritmo de Euclides, obtemos

8

11

2

3

3

1

1

2

0

2

1

91

3

1 = 3 − 2.1
1 = 3 − (11 − 3.3).1
1 = 3 − 11 + 3.3
1 = 4.3 − 1.11
1 = 4.(91 − 11.8) − 1.11
1 = 4.91 − 32.11 − 1.11
1 = 4.91 − 33.11

b2 = 4.

b3:

77b3 ≡ 1 (mod 13).

Correspondendo a equação diofantina temos que

77b3 − 13t = 1, com t ∈ Z.

Através do Algoritmo de Euclides, obtemos

12

1

5

13

1

1

12

0

77

12

1 = 13 − 12.1
1 = 13 − (77 − 13.5).1
1 = 13 − 77 + 13.5
1 = 6.13 − 77.1

b3 = −1.

Logo, o sistema tem por solução x, que pode ser representado por

143.r7(−2) + 91.r11.4 + 77.r13(−1) ≡ x (mod 1001)

= −286r7 + 364r11 − 77r13 ≡ x (mod 1001).

3.3. Congruências

71

De fato, o número que o aluno escolheu é o resto da divisão de −286r7 + 364r11 − 77r13

por 1001.

O professor poderá adaptar essa atividade para outros números contanto que observe que
os números escolhidos para serem os divisores devem ser primos entre si e que o número deve
ser menor que o produto destes.

3.3.1 Classes Residuais

Considere um número inteiro positivo qualquer m > 1. Dividiremos o conjunto dos
números inteiros Z em subconjuntos, cada um formado pelos números inteiros que deixam o
mesmo resto quando dividimos por m.

Assim, podemos deﬁnir classes residuais da seguinte maneira:

Deﬁnição 11. Seja m um número inteiro positivo ﬁxo. Se a é um inteiro qualquer então a classe
residual módulo m de a, denotada por a (ou [a]), consiste do conjunto formado por todos os
inteiros que são congruentes ao inteiro módulo m, isto é,

a = {x ∈ Z; x ≡ a (mod m)} = {x ∈ Z; m|(x − a)} = {a + km; k ∈ Z}.

Observação:

1a) Se m = 1 e a ∈ Z temos a = {x ∈ Z; 1|(x − a)} = Z.

2a) As classes residuais módulo m também são denominadas inteiros módulo m ou

classes de restos módulo m ou ainda, classes de congruência ou equivalência módulo m.

3a) Se a ∈ Z, então a ̸= /0, pois como a ≡ a(mod m) temos que a ∈ a.

Podemos obter os subconjuntos:

0 = {x ∈ Z; x ≡ 0 (mod m)};

1 = {x ∈ Z; x ≡ 1 (mod m)};
...

m − 1 = {x ∈ Z; x ≡ m − 1 (mod m)}.

Paramos em m − 1 pois, a partir daqui teremos repetições, pois m = 0, m + 1 = 1 e assim

por diante. Em particular, 0 é o conjunto dos múltiplos de m.

Para ilustrar, é apresentado um exemplo de uso de classe residual para solucionar um

problema de paridade (Ver [16]).

Exemplo 3.26. Seja m = 2. Então,

0 = {x ∈ Z; x ≡ 0 (mod 2)} = {x ∈ Z; x é par }.

72

Capítulo 3. Principais Conceitos e Teoremas

1 = {x ∈ Z; x ≡ 1 (mod 2)} = {x ∈ Z; x é ímpar }.

Temos, portanto, que a = 0 se, e somente se, a é par e a = 1 se, e somente se, a é ímpar.

Proposição 16. Seja m um inteiro positivo ﬁxo e sejam a e b as classes residuais módulo m de a
e b. Então:

1) a = b ⇔ a ≡ b (mod m).

2) a ∩ b = /0 ou a = b.

Demonstração. 1) Suponhamos que a = b.

Seja x ∈ a = b, então a ≡ x (mod m) e x ≡ b (mod m), pela propriedade da transitividade

obtém-se que

a ≡ b (mod m).

Portanto, a = b ⇒ a ≡ b (mod m).

Reciprocamente, suponha que a ≡ b (mod m) e seja x ∈ a.

Então,

(cid:40)

a ≡ b (mod m)
x ≡ a (mod m)

. Pela transitividade, temos que x ≡ b (mod m), e assim, x ∈ b.

A mesma análise é feita supondo x ∈ b. Logo, a = b.

2) Se considerarmos a ∩ b ̸= /0, então existe x ∈ a e x ∈ b, isto é, x ≡ a (mod m) e

x ≡ b (mod m). Assim, a ≡ b (mod m) e pelo item anterior , a = b.

Daí concluímos que se a ∩ b ̸= /0, então todo elemento de a pertence a b, ou seja,

a = b.

O conjunto de todas as classes residuais módulo m será representada por

Proposição 17. O conjunto Zm tem exatamente m elementos.

Zm = {0, 1, ..., m − 1}.

Demonstração. Sabemos que {0, 1, ..., m − 1} ⊂ Zm.

Seja a ∈ Zm, onde a ∈ Z. Pelo algoritmo da divisão de a por m, existem inteiros q e r

tais que a = mq + r, 0 ≤ r ≤ m − 1.

Assim, a − r = mq ⇒ m|(a − r).

Logo, a ≡ r(mod m) e, pela Proposição 16 item 1, temos a = r.

3.3. Congruências

73

Como 0 ≤ r ≤ (m − 1) então a = r ∈ {0, 1, ..., m − 1}.

Portanto, Zm ⊂ {0, 1, ..., m − 1} e concluímos que Zm = {0, 1, ..., m − 1}.

Suponha que r = s, onde r, s ∈ Z tais que 0 ≤ r < s ≤ m − 1. Pela Proposição 16 item 1
temos que r ≡ s (mod m) e m|(s − r) mas isto é um absurdo, pois 0 < s − r < m. Logo, r = s e
{0, 1, ..., m − 1} tem exatamente m elementos.

Corolário 5. As classes 0, 1, ..., m − 1 são duas a duas distintas.

A demonstração deste segue da demonstração da proposição anterior e da unicidade do

resto, visto em Divisão Euclidiana.

Como poderíamos pensar na representação do Zm?

Imaginemos uma reta horizontal e marquemos m pontos equidistantes, começando de
0 até m − 1. Imaginemos agora, que enrolamos esta reta no contorno de uma circunferência,
fazendo com que m coincida com o ponto 0. Como a reta é inﬁnita, continuaremos a enrolá-la
de modo que os múltiplos de m coincidam com o ponto 0, obtendo a classe de equivalência
0, os pontos que coincidirem com 1, pertencerão à classe 1, os pontos que coincidirem com 2,
pertencerão à classe 2 e assim sucessivamente.

O conjunto de m representantes, um de cada uma das classes residuais 0, 1, ..., m − 1 é

um sistema completo de resíduos módulo m.

Temos as seguintes operações deﬁnidas em Zm.

1) Adição e Multiplicação

Seja m um inteiro positivo ﬁxo. Iremos agora deﬁnir as operações de adição e multiplica-

ção no conjunto Zm das classes residuais módulo m. Sejam a, x, y, b ∈ Zm.

Temos que a = x e b = y. Então,

(cid:40)

a ≡ x (mod m)
b ≡ y (mod m)

(cid:40)

⇒

a + b ≡ x + y (mod m)
a.b ≡ x.y (mod m)

Consequentemente,

a + b = x + y

e ab = xy.

Isso torna verdadeiras as deﬁnições a seguir.

Deﬁnição 12. Dadas duas classes, a, b ∈ Zm, chama-se soma a + b à classe a + b (que é única,
independente do representante tomado para a ou para b). Ou seja,

a + b = a + b.

74

Capítulo 3. Principais Conceitos e Teoremas

Deﬁnição 13. Dadas duas classes, a, b ∈ Zm, chama-se produto a.b à classe ab (que é única,
independente do representante tomado para a ou para b). Ou seja,

a.b = ab.

Observamos que as operações em Zm foram deﬁnidas a partir das operações de seus re-
presentantes. Assim, como em [16], podemos enunciar as propriedades abaixo para as operações
em Zm.

Propriedades da Adição

Dados a, b e c ∈ Zm, temos:

1o) Associatividade: (a + b) + c = a + (b + c).

2o) Comutatividade: a + b = b + a.

3o) Existência do zero: a + 0 = a, ∀ a ∈ Zm.

4o) Existência do simétrico: a + (−a) = 0.

Propriedades da Multiplicação

1o) Associatividade: (a.b).c = a.(b.c).

2o) Comutatividade: a.b = b.a.

3o) Existência da unidade: a.1 = a.

4o) Distributividade: a(b + c) = a.b + a.c.

A demonstração de cada um destes itens é relativamente simples, pois utilizamos a

validade destas propriedades em Z.

Observação: O elemento −a é chamado de o simétrico de a para a operação de soma,

exatamente como no caso dos inteiros.

Deﬁnição 14. Um conjunto com as operações de adição e de multiplicação com as propriedades
descritas acima é chamado de anel.

Logo, Zm com as operações acima é um anel, chamado anel das classes residuais módulo

m, ou anel dos inteiros módulo m.

Para ilustrarmos, em Z6 temos as seguintes tabelas de soma e produto.

3.3. Congruências

75

+ 0

1

1

2

3

4

5

0

2

2

3

4

5

0

1

3

3

4

5

0

1

2

4

4

5

0

1

2

3

0

1

2

3

4

5

Tabela 2: Soma em Z6.

0

0

0

0

0

0

0

1

0

1

2

3

4

5

2

0

2

4

0

2

4

3

0

3

0

3

0

3

4

0

4

2

0

4

2

0

1

2

3

4

5

.

0

1

2

3

4

5

5

5

0

1

2

3

4

5

0

5

4

3

2

1

Tabela 3: Multiplicação em Z6.

2) Divisão

Veremos agora como calcular divisões em Zm. Pensando nos números reais a e b, a frase
dividir a por b é equivalente a multiplicar a por 1/b. O número real 1/b é conhecido como
inverso multiplicativo de b, com b ̸= 0. Agora vamos transpor isso para Zm. Digamos que a ∈ Zm.
Diremos que a classe α ∈ Zm é o inverso de a se a equação a.α = 1 é veriﬁcada em Zm.

Em Zm, 0 não possui inverso. De fato,

0.α = (0 + 0).α = 0.α + 0.α

0.α + (−0.α) = 0.α + (0.α − 0.α)

0 = 0.α.

É preciso observar que em Zm pode haver outros elementos sem inverso, além da classe

0, veja por exemplo, a tabela acima obtida para Z6.

Para determinarmos esse inverso faremos o uso de equação diofantina , como veremos a

seguir.

a.α = 1 corresponde a dizer que aα − 1 é divisível por m, isto é,

76

Capítulo 3. Principais Conceitos e Teoremas

aα + km = 1, para algum k inteiro.

Esta equação implica que mdc(a, m) = 1, como visto nas equações diofantinas. Portanto,

o inverso de a só existe se mdc(a, m) = 1.

Com isso, como visto em [16], podemos enunciar as seguintes deﬁnição e proposição.

Deﬁnição 15. Um elemento a ∈ Zm será dito invertível quando existir α ∈ Zm tal que a.α = 1.

Proposição 18. Um elemento a de Zm é invertível se, e somente se, mdc(a, m) = 1.

A demonstração vista anteriormente, nos diz que para calcular o inverso, quando ele

existe, basta usar o algoritmo euclidiano estendido, como nas equações diofantinas.

Quanto à existência de inverso, ainda temos a seguinte deﬁnição:

Deﬁnição 16. Um anel onde todo elemento não nulo possui um inverso multiplicativo é chamado
de corpo.

E depois de conhecida essa deﬁnição, temos o seguinte corolário:

Corolário 6. Zm é um corpo se, e somente se, m é primo.

Vamos denotar o subconjunto de Zm, cujos elementos possuem inverso multiplicativo

por U(m) = {a ∈ Zm; mdc(a, m) = 1}.

Segue o seguinte exemplo

U(8) = {1, 3, 5, 7}.

7.5 = 3 3.7 = 5.

Digamos que a tem inverso α e b tem inverso β em Zm. O inverso de a.b será α.β , pois

(a.b).(α.β ) = (a.α).(b.β ) = 1.1 = 1.

Esse conjunto que denotamos por U(m) é chamado de sistema reduzido de resíduos

módulo m.

Podemos usar o que foi estudado nessa seção para resolvermos congruências lineares em

Zm.

Considere uma congruência linear do tipo ax ≡ b(mod m), com a, b ∈ Z. Para resolvê-
la, podemos isolar o x, dividindo a equação por a. Se mdc(a, m) = 1, existe α ∈ Z tal que
α.a ≡ 1 (mod m).

Multiplicando a equação acima por α, obtemos α.ax ≡ α.b (mod m). Como α é o

inverso de a em Zm esta equação se reduz a

3.3. Congruências

77

x ≡ α.b (mod m).

Exemplo 3.27. Resolver a congruência 7x ≡ 3 (mod15).

Primeiramente, como mdc(7, 15) = 1, então existe solução.

Então, precisamos multiplicar a equação pelo inverso de 7 em Z15. Como 15 − 2.7 = 1,

o inverso de 7 é −2 = 13. Multiplicando por 13, temos

13.7.x ≡ 3.13(mod15).

x ≡ 39 ≡ 9(mod15).

Com isso, ﬁca resolvida a congruência dada.

Exemplo 3.28. Qual a paridade do número

2010.11200 + 2119?

Podemos decidir a paridade de um a expressão envolvendo produtos e somas de inteiros

lembrando que 0 corresponde aos números pares e 1, aos números ímpares.

Com isso, podemos estabelecer as seguintes tabelas que regem a paridade das somas e

produtos dos números inteiros.

+ 0 1

0
1

0 1
1 0

.

0
1

0

0
0

1

0
1

Então, para sabermos a paridade do número acima, basta substituir o número 20 por 0,

por ser par; e os números 11 e 21 por 1, por serem ímpares.

Assim, obtemos a expressão

10.1
0

200 + 1

19

,

que nos dá como resultado 1. Portanto, o número dado é ímpar.

79

CAPÍTULO

4

SISTEMAS DE CODIFICAÇÃO

Hoje em dia os códigos fazem parte da nossa vida. Já na maternidade recebemos uma
identiﬁcação e daí por diante, os códigos se tornam cada vez mais presentes: Registro de
Certidão de Nascimento, Registro de Identidade (RG), Cadastro de Pessoa Física (CPF), Carteira
Proﬁssional, Título de Eleitor e outros documentos utilizados para identiﬁcação.

Além disso, nas farmácias, nos supermercados, nas bancas de revistas, nas livrarias os
produtos são acompanhados de etiquetas com seu código. Nosso Código de Endereçamento
Postal (CEP), nossa agência bancária, a conta corrente possuem seu código de identiﬁcação.

Os números de identiﬁcação são gerados por sistemas capazes de detectar a maioria dos
erros cometidos durante a sua leitura, digitação ou transmissão. Esses sistemas utilizam um ou
mais algarismos acrescentados ao número de identiﬁcação que permitem alertar o operador da
ocorrência de um erro e é conhecido como dígito veriﬁcador. O dígito veriﬁcador é obtido por
algoritmos que utilizam conceitos de Teoria dos Números, mais especiﬁcamente a Congruência
Modular.

4.1 Estudo de Alguns Sistemas de Codificação

Esse capítulo apresenta um estudo sobre os códigos de barras e alguns outros códigos

numéricos de acordo com [10].

4.1.1 Códigos de Barras

Na maior parte do século XX, os supermercados precisavam fechar suas portas por um
dia para realizar o balanço, que era a contagem manual dos produtos por mais de uma vez e por
mais de um funcionário. Tal procedimento acarretava perda da venda do dia e ainda havia erros.

Pela necessidade de contabilizar automaticamente a entrada e saída de produtos, o

80

Capítulo 4. Sistemas de Codiﬁcação

presidente de uma cadeia de mercados solicitou ao diretor do Instituto de Tecnologia da Filadélﬁa,
nos Estados Unidos, que tentasse criar algo para sanar essa exigência do mercado.

Depois de alguns estudos, um aluno da graduação Bernard Silver e o professor Norman
Joseph Woodland produziram as primeiras ideias sobre os modernos códigos de barra (Ver [10]).

(a) Norman J. Woodland
(1921-2012).

(b) Bernard Silver
1963).

(1924-

Figura 2: Woodland e Silver

Os estudos iniciais resultaram em um sistema de linhas e círculos que depois foi subs-
tituído por um padrão de circunferências concêntricas de largura variável (Figura 3). Silver
e Woodland registraram uma patente para o seu sistema de codiﬁcação em 20 de outubro de
1949, porém receberam a concessão desta apenas em 1952. O invento era classiﬁcado como
"classiﬁcação de artigos através de identiﬁcação de padrões", como visto em [10].

(a) Código de barras.

(b) Código de Barras.

Figura 3: Modelo do Primeiro Código de Barras.

Por volta de 1970, uma ﬁrma de assessoria, a Mc Kinsey & Co., junto com a Uniform
Grocery Product Code Council, deﬁniu um formato numérico para identiﬁcar produtos e pediu a
diversas companhias que elaborassem um código adequado.

Na elaboração de um código adequado, das companhias contactadas, a que apresentou a

melhor proposta foi a IBM, e o autor desse código foi George J. Laurer (Figura 4).

4.1. Estudo de Alguns Sistemas de Codiﬁcação

81

Figura 4: George J. Laurer.

O código proposto só foi aceito formalmente em 1973, passando a ser conhecido como

código UPC (Universal Product Code), adotado nos Estados Unidos e no Canadá.

Assim, na manhã em 06 de junho de 1974, no estado de Ohio, Estados Unidos, uma
funcionária que trabalhava em uma rede de supermercados Marshs passou uma caixa de chicletes
por um scanner e foi lido o código de barras do primeiro produto vendido com esse tipo de
codiﬁcação.

Ele consistia de uma sequência de 12 dígitos, traduzidos para barras brancas e pretas,

seguindo padrões estabelecidos.

Figura 5: Exemplo de códigos de barras UPC.

Existem algumas versões posteriores do UPC, com pequenas modiﬁcações. Posterior-
mente foi solicitado, a Laurer que ampliasse o código, de modo a identiﬁcar também o país de
origem de cada produto classiﬁcado.

Baseado no UPC, ele acabou criando um novo código, com 13 dígitos (Figura 6), que foi

adotado em dezembro de 1976 com o nome EAN (European Article Numbering System).

Mais tarde, constatou-se a eﬁciência desse tipo de código e sua utilização foi estendida
rapidamente para o Brasil em 1983. O Brasil deu um grande passo à frente de outros países da
América Latina, aderindo ao sistema de código de barras na maioria das cidades e estados.

82

Capítulo 4. Sistemas de Codiﬁcação

Figura 6: Exemplo de códigos de barras EAN-13.

4.1.2 Estrutura do Código de Barras

O código de barras é uma forma de representação gráﬁca, no formato de barras, que

através de uma leitura por meio óptico informa dados de um determinado objeto.

Os códigos de barras são formados por sequências de barras verticais de cores brancas e

pretas, com larguras variáveis: ﬁna, média, grossa ou muito grossa.

Cada espessura e cor de uma listra podem ser interpretados de acordo com a tabela

abaixo:

Espessura

Fina Média Grossa Muito Grossa

Cor

Branca
Preta

0
1

00
11

000
111

0000
1111

Tabela 4: Cor e espessura das listras.

Esses dados também são representados por uma sequência numérica que aparece abaixo
das barras. A cada número lhe é atribuído um espaço de espessura ﬁxa que corresponde sempre
a uma sequência de sete dígitos iguais a 1 ou 0.

Os códigos EAN-13 possuem três blocos de barras, com três barras cada um, sendo estas
um pouco mais compridas que as outras, que servem de delimitadores e não são interpretados
como números.

Os códigos de barras UPC, também possuem os mesmos delimitadores que o EAN-13
representados por barras mais compridas, com a diferença que o primeiro e o último dígito estão
codiﬁcados com barras do mesmo comprimento das dos delimitadores.

Comecemos o estudo dos códigos de barras pelos códigos do tipo UPC.

A leitura distingue a direita da esquerda, já que o produto pode ser passado em uma
direção ou outra, porque os dígitos são codiﬁcados de maneira diferente quando estão do lado
direito ou lado esquerdo do código de barras, conforme a tabela a seguir:

4.1. Estudo de Alguns Sistemas de Codiﬁcação

83

Dígito Lado Esquerdo Lado Direito

0
1
2
3
4
5
6
7
8
9

0001101
0011001
0010011
0111101
0100011
0110001
0101111
0111011
0110111
0001011

1110010
1100110
1101100
1000010
1011100
1001110
1010000
1000100
1001000
1110100

Tabela 5: Codiﬁcação para código UPC.

Note que a codiﬁcação de um dado número, à direita, se obtém da sua codiﬁcação à
esquerda, trocando cada 0 por 1 e reciprocamente. O mecanismo de reconhecimento da máquina
consiste em notar que cada sequência do lado esquerdo tem um número ímpar de dígitos iguais
a 1, e consequentemente, cada uma das que estão à direita tem um número par. Então, pela
paridade de cada sequência a máquina detecta de que lado está lendo o código.

A elaboração do código EAN se deparou com a necessidade de adicionar um dígito à
cada código, para permitir a identiﬁcação do país de origem do produto, mas de tal forma que a
máquina leitora pudesse ler ambos os códigos.

Para isso os países que utilizavam o código UPC, EUA e Canadá, são identiﬁcados com
um 0 na frente, e o resto da codiﬁcação é feito utilizando-se o sistema anterior. Para outros países,
como era necessário adicionar um dígito e também manter o mesmo padrão de tamanho do
código de barras, para não ter que modiﬁcar todos os leitores, não foi modiﬁcada a codiﬁcação do
lado direito (permitindo assim que as leitoras continuassem a identiﬁcar o lado correspondente).
Mas, a codiﬁcação do lado esquerdo varia dependendo do dígito inicial. Um dígito do lado
esquerdo pode ser codiﬁcado com um número par ou ímpar de dígitos iguais a 1, de acordo com
a tabela a seguir.

84

Capítulo 4. Sistemas de Codiﬁcação

Dígito Lado Esquerdo Ímpar Lado Esquerdo Par Lado Direito

0
1
2
3
4
5
6
7
8
9

0001101
0011001
0010011
0111101
0100011
0110001
0101111
0111011
0110111
0001011

0100111
0110011
0011011
0100001
0011101
0111001
0000101
0010001
0001001
0010111

1110010
1100110
1101100
1000010
1011100
1001110
1010000
1000100
1001000
1110100

Tabela 6: Codiﬁcação EAN-13.

Assim, para cada dígito inicial escolhe-se uma alternância diferente de pares e ímpares

de acordo com o seguinte critério:

Dígito Inicial
0
1
2
3
4
5
6
7
8
9

1o
Ímpar
Ímpar
Ímpar
Ímpar
Ímpar
Ímpar
Ímpar
Ímpar
Ímpar
Ímpar

2o
Ímpar
Ímpar
Ímpar
Ímpar
Par
Par
Par
Par
Par
Par

3o
Ímpar
Par
Par
Par
Ímpar
Par
Par
Ímpar
Ímpar
Par

4o
Ímpar
Ímpar
Par
Par
Ímpar
Ímpar
Par
Par
Par
Ímpar

5o
Ímpar
Par
Ímpar
Par
Par
Ímpar
Ímpar
Ímpar
Par
Par

6o
Ímpar
Par
Par
Ímpar
Par
Par
Ímpar
Par
Ímpar
Ímpar

Tabela 7: Codiﬁcação do lado esquerdo do código EAN-13.

É interessante observar que, para o sistema EAN-13, o primeiro dígito não é apresentado

em barras. Ele ﬁca implícito na ordem da codiﬁcação dos próximos seis algarismos.

Exemplo 4.1. Um pacote de macarrão instantâneo, produzido e cadastrado no Brasil, é identiﬁ-
cado pelo código 7891079001523.

A sequência começa com 789, de modo que o primeiro dígito é 7.

Consequentemente, de acordo com a tabela anterior deve-se usar, no lado esquerdo, a

seguinte ordem de codiﬁcação:

ímpar, par, ímpar, par, ímpar, par.

Consultando a tabela de codiﬁcação do EAN-13, obtemos:

4.1. Estudo de Alguns Sistemas de Codiﬁcação

85

8 → 0110111

9 → 0010111

1 → 0011001

0 → 0100111

7 → 0111011

9 → 0010111

Para os dígitos do lado direito não temos que nos preocupar com a paridade, então

obtemos:

0 → 1110010

0 → 1110010

1 → 1100110

5 → 1001110

2 → 1101100

3 → 1000010

Então o código de barras correspondente, de modo que o primeiro dígito estará implícito

na codiﬁcação dos demais, é:

Figura 7: Código de Barras de um macarrão instantâneo.

Em ambos os sistemas, UPC e EAN-13, os dígitos têm codiﬁcações diferentes depen-
dendo do lado que se encontram. Se estiverem do lado esquerdo, iniciam com zeros (barras
brancas), se estiverem do lado direito, iniciam com uns (barras pretas).

Isso permite que a leitura, mesmo sendo feita de cabeça para baixo, produza o mesmo

número.

Para o sistema EAN-13, que é mais usado atualmente, deve-se ter a seguinte interpretação:
os primeiros dois ou três dígitos identiﬁcam o país de origem (país onde foi cadastrado o produto),
os próximos quatro ou cinco dígitos servem para identiﬁcar a empresa, já os cinco números
seguintes, representam o código do produto, e por ﬁm, o último dígito é o dígito veriﬁcador,
conforme ilustra a Figura 8.

Esse último dígito, chamado dígito veriﬁcador, é adicionado no ﬁnal da sequência de
elaboração do código, de acordo com um algoritmo que se obtém a partir dos dígitos anteriores,
obedecendo ao padrão do sistema adotado, como veremos posteriormente. Esse dígito não faz
parte da sequência dos dígitos que contém as informações sobre o produto e tem a ﬁnalidade de
certiﬁcar a validade do código numérico.

86

Capítulo 4. Sistemas de Codiﬁcação

Figura 8: Estrutura do Código de Barras.

Quando por algum motivo o leitor óptico não conseguir efetuar a leitura do código de
barras, o operador terá que digitar a sequência numérica do código, podendo assim ocorrer erros.

O dígito veriﬁcador é um recurso para ajudar a máquina a detectar alguns erros.

Considere a1, a2, a3, ..., a13 a sequência de dígitos de um determinado código de barras
EAN-13. Como foi dito anteriormente, os 12 primeiros dígitos já são pré-estabelecidos. O último
dígito, que é o dígito veriﬁcador, será determinado por um algoritmo que envolve os primeiros
dígitos, os doze primeiros no caso do EAN-13 e pelos onze primeiros dígitos, no caso do sistema
UPC.

A utilização de um dígito veriﬁcador não permite a correção automática do erro. Con-
tudo, permite que o sistema alerte o operador sobre a ocorrência deste e consequentemente da
necessidade de reescrever os números.

Considerando o sistema EAN-13, chamaremos de x o décimo terceiro dígito. A sequência

numérica dos 12 primeiros dígitos do código pode ser representada por:

(a1, a2, a3, ..., a12).

Efetua-se o produto dos números da sequência ordenadamente por:

(1, 3, 1, 3, ..., 1, 3).

Observa-se que cada dígito pertencente a uma ordem ímpar, multiplica-o por 1, e cada

dígito pertencente a uma ordem par, multiplica-o por 3.

Somando-se os produtos obtidos temos:

a1.1 + a2.3 + a3.1 + a4.3 + a5.1 + a6.3 + a7.1 + a8.3 + a9.1 + a10.3 + a11.1 + a12.3.

O dígito veriﬁcador, que chamaremos de x, é determinado de tal forma que a soma obtida

acima somada com x, seja um múltiplo de 10, ou seja:

a1.1 + a2.3 + a3.1 + a4.3 + ... + a10.3 + a11.1 + a12.3 + x ≡ 0 (mod 10).

4.1. Estudo de Alguns Sistemas de Codiﬁcação

87

Se a leitura estiver correta, o resultado desse cálculo é igual ao do dígito veriﬁcador.
O interessante do assunto código de barras para esse trabalho, é que para o cálculo do dígito
veriﬁcador, o algoritmo usado é uma congruência módulo 10.

Exemplo 4.2. Considere o código de barras da Figura 7 e chamemos o dígito veriﬁcador, no
caso 3, de x.

Seja então 789107900152x o número referente ao código de barras da Figura 8.

Multiplicando esses algarismos ordenadamente por (1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1), obtém-

se:

87 + x.

7.1 + 8.3 + 9.1 + 1.3 + 0.1 + 7.3 + 9.1 + 0.3 + 0.1 + 1.3 + 5.1 + 2.3 + x.1 que resulta em

Para descobrirmos x é preciso que a soma 87 + x seja um múltiplo de 10. Usando as

congruências modulares podemos escrever que:

87 + x ≡ 0 (mod 10).

Logo, x = 3.

4.1.3 Erros detectáveis e Erros não detectáveis

Como dito anteriormente, caso durante a leitura do código de barras, ocorra um problema
com o leitor óptico ou um problema que impeça a leitura óptica do código, será necessário que o
operador digite os algarismos localizados logo abaixo do código de barras.

Nesse momento, podem ocorrer erros de digitação, onde o resultado não seja congruente
a zero módulo 10 e então o processador emitirá um sinal sonoro alertando que houve um erro de
digitação.

Se o operador digitar um único algarismo errado, comete um erro denominado único.
Certamente, a soma encontrada não será congruente a zero módulo 10, sendo o erro sempre
detectado, como veremos adiante.

Caso o operador digite dois ou mais algarismos errados, há uma possibilidade dos
números digitados se compensarem uns aos outros e o resultado da soma obtida ser congruente a
zero módulo dez, não sendo possível a máquina detectar o erro nesse caso.

Ainda pode ocorrer de dois algarismos consecutivos serem digitados em posições troca-

das, chamado de erro de transposição adjacente.

Nesse caso, o erro pode ou não ser detectado, o que será detalhado posteriormente.

Quando os erros não são detectados, o produto é registrado pelo leitor óptico como outro.
É por isso, que algumas vezes, ao conferirmos uma compra feita em um supermercado, por

88

Capítulo 4. Sistemas de Codiﬁcação

exemplo, exista na nota entregue ao consumidor produtos que não foram levados ou divergências
no valor observado pelo consumidor.

Segundo [10], autores como D.F.Beckley e J.Verhoeff investigaram sistematicamente

esses erros e a pesquisa apontou como mais frequentes:

∙ O erro único (...a... → ...b...), com 79% de ocorrência;

∙ O erro de transposição adjacente (...ab... → ...ba...), com 10, 2%.

Os 10, 8% restantes correspondem a erros com frequências menores de 1% cada.

Para uma melhor compreensão desses erros serão apresentados exemplos a seguir.

Exemplo 4.3. Considere o código de barras abaixo:

Figura 9: Código de Barras de um Medicamento.

Suponha que houve um erro de digitação no dígito da posição a9, e que o código tenha

sido transmitido da seguinte forma: 7898495615007.

O computador detectaria o erro, pois:

7.1 + 8.3 + 9.1 + 8.3 + 4.1 + 9.3 + 5.1 + 6.3 + 1.1 + 5.3 + 0.1 + 0.3 + 7.1 = 141 ̸≡

0 (mod 10).

Imagine que a troca tenha ocorrido com um algarismo, an, que ocupa uma ordem ímpar,
que é multiplicado por 1. E que S representa a soma de todos os outros algarismos que ocupam
ordem ímpar e foram multiplicados por 1 com todos os algarismos que ocupam ordem par e
foram multiplicados por 3. Então teríamos que:

S + an ≡ 0 (mod 10).

Sabemos que an só pode assumir um valor dentre os algarismos 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.

Considerando as classes residuais, esse conjunto de algarismos é denominado sistema
completo de resíduos módulo 10, que é composto pelos restos possíveis em uma divisão por 10.
Como estudado anteriormente, pela unicidade do resto, duas classes residuais não podem ser
iguais.

4.1. Estudo de Alguns Sistemas de Codiﬁcação

89

Assim existe um único valor para an que quando somado com S resultará em um múltiplo

de 10.

O mesmo ocorre para a troca de um algarismo an, que ocupa uma ordem par e é
multiplicado por 3. Se S representa a soma de todos os algarismos que ocupam ordem ímpar
e foram multiplicados por 1 com todos os outros algarismos que ocupam ordem par e foram
multiplicados por 3. Então, temos que

S + 3an ≡ 0 (mod 10).

Se o sistema completo de resíduos módulo 10, que é de onde sai o valor de an, for
multiplicado por 3, obtemos: (0, 3, 6, 9, 12, 15, 18, 21, 24, 27) que nos retorna os possíveis restos
em uma divisão por 10: (0, 3, 6, 9, 2, 5, 8, 1, 4, 7) que é o próprio sistema completo de resíduos
módulo 10, de onde apenas um valor quando somado com S resultará em um múltiplo de 10.

Portanto se o erro é único, esse erro será sempre detectado, independente de sua posição.

Além do erro único, podem ocorrer outros tipos de erros, como por exemplo a troca da
posição dos algarismos digitados, chamados erros de transposição. Um erro de transposição
muito comum é o chamado de transposição adjacente, que é quando troca-se a ordem de dois
algarismos consecutivos. Nesse caso o erro pode ou não ser detectado, como pode ser observado
nos exemplos a seguir.

Exemplo 4.4. Para os casos a seguir, vamos considerar o código de barras de uma embalagem
de um leite condensado

Figura 10: Código de Barras de um Leite Condensado.

1o Caso: Imagine que a operadora do caixa, digitou o número e ocorreu um erro de
digitação em que dois destes números ﬁcaram em posições trocadas, ﬁcando a sequência
numérica da seguinte forma:

7892659412762.

Como o código é um EAN-13, os algarismos de ordem ímpar devem ser multiplicados

por 1 e os algarismos de ordem par devem ser multiplicados por 3, obtendo-se

7.1 + 8.3 + 9.1 + 2.3 + 6.1 + 5.3 + 9.1 + 4.3 + 1.1 + 2.3 + 7.1 + 6.3 + 2.1 = 122.

90

Capítulo 4. Sistemas de Codiﬁcação

Como 122 ̸≡ 0 (mod 10), a máquina irá detectar o erro.

2o Caso: Para este 2o caso, suponhamos que existiu uma troca entre os algarismos a7 e

a8 e o número digitado fosse o seguinte:

7896254912762.

Como foi feito no 1o caso, devemos multiplicar a sequência numérica acima por

1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, obtendo:

7.1 + 8.3 + 9.1 + 6.3 + 2.1 + 5.3 + 4.1 + 9.3 + 1.1 + 2.3 + 7.1 + 6.3 + 2.1 = 140.

Como 140 ≡ 0 (mod 10), o erro não será detectado.

Através desses dois casos estudados acima, observamos que um erro de transposição

adjacente pode ou não ser detectado. Então, quando será detectado ou não?

Seja a1, a2, a3, ..., ai, ai+1, ..., a12, a13 uma sequência de dígitos de um código de barras
no sistema EAN-13. Multiplicando os algarismos de ordem ímpar por 1 e os que estão na ordem
par por 3 obtemos:

a1 + 3a2 + a3 + ... + 3ai + ai+1 + ... + 3a12 + a13 ≡ 0 (mod 10).

(1)

Suponhamos que tenha ocorrido um erro e que essa sequência tenha sido digitada da

seguinte forma:

a1, a2, a3, ..., ai+1, ai, ..., a12, a13.

O erro não será detectado se, e somente se:

a1 + 3a2 + a3 + ... + 3ai+1 + ai + ... + 3a12 + a13 ≡ 0 (mod 10).

(2)

Fazendo (2)-(1) tem-se:

(a1 + 3a2 + a3 + ... + 3ai+1 + ai + ... + 3a12 + a13) − (a1 + 3a2 + ... + 3ai + ai+1 + ... +

3a12 + a13) ≡ 0 (mod 10).

3ai+1 − ai+1 + ai − 3ai ≡ 0 (mod 10)

2ai+1 − 2ai ≡ 0 (mod 10)

2(ai+1 − ai) ≡ 0 (mod 10).

4.1. Estudo de Alguns Sistemas de Codiﬁcação

91

Como os dígitos da sequência a1, a2, a3, ..., a12, a13 são números entre 0 e 9, podemos

escrever que |ai+1 − ai| ≤ 9.

Então para que 2(ai+1 − ai) seja congruente a zero módulo dez é preciso que

|ai+1 − ai| = 5.

Com essa demonstração, podemos enunciar a seguinte proposição.

Proposição 19. Uma transposição adjacente é detectada pelo sistema EAN-13 e pelo sistema
UPC, se e somente se, |ai+1 − ai| ̸= 5.

Podem ocorrer também erros de troca de algarismos que não sejam consecutivos, que

são chamados de transposição não adjacente.

Exemplo 4.5. Consideremos ainda o código de barras do leite condensado 7896259412762.

1o Caso: Para esse caso, vamos considerar que o termo a5 foi digitado no lugar de a8 e

vice-versa, obtendo assim a seguinte sequência

7896459212762.

Ao multiplicarmos os algarismos de ordem ímpar por 1 e os algarismos de ordem par

por 3, temos como resultado

7.1 + 8.3 + 9.1 + 6.3 + 4.1 + 5.3 + 9.1 + 2.3 + 1.1 + 2.3 + 7.1 + 6.3 + 2.1 = 126.

126 ̸≡ 0 (mod 10).

Então, nesse caso, o erro será detectado.

2o Caso: Agora, imaginemos trocar o termo a3 com o a11. Com isso, a sequência a

considerar será:

7876259412962.

Fazendo a multiplicação por 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, tem-se que

7.1 + 8.3 + 7.1 + 6.3 + 2.1 + 5.3 + 9.1 + 4.3 + 1.1 + 2.3 + 9.1 + 6.3 + 2.1 = 130.

130 ≡ 0 (mod 10).

Para esse caso, o erro já não será detectado.

92

Capítulo 4. Sistemas de Codiﬁcação

Após analisarmos os dois casos anteriores, percebemos que no 1o caso, ao trocarmos o
termo a5 com o termo a8, a diferença entre as ordens, ou seja 8 − 5 = 3, é um número ímpar,
portanto o erro foi detectado. Já para o 2o caso, ao trocarmos o termo a3 com o termo a11, a
diferença entre as ordens, ou seja, 11 − 3 = 8, é um número par, e nessas condições o erro não
foi detectado.

Então podemos enunciar a seguinte proposição:

Proposição 20. Um erro de transposição, em que dois dígitos não adjacentes ai e a j são trocados,
não pode ser detectado pelos sistemas UPC e EAN-13, se a diferença i − j for par.

Demonstração. Ao realizar o produto da sequência numérica de um código de barras do sistema
UPC ou EAN-13 por 1, 3, 1, 3, 1, 3, ..., 1, 3 percebemos que os algarismos de ordens ímpares são
multiplicados por 1 e os algarismos de ordens pares são multiplicados por 3. Portanto, se a troca
for entre dois algarismos:

∙ ambos de ordem par: o fator de multiplicação, que é 3, não muda. Com isso, ao serem
trocados, ambos continuam sendo multiplicados por 3, não alterando a soma ﬁnal. Por
isso, o erro não será detectado.

∙ ambos de ordem ímpar: o fator de multiplicação, que é 1, não muda. Com isso, ao serem
trocados, ambos continuam sendo multiplicados por 1, não alterando a soma ﬁnal. Assim,
o erro também não será detectado.

∙ um de ordem par e outro de ordem ímpar: o fator de multiplicação do algarismo de ordem
ímpar é 1 e o de ordem par é 3. Com isso, ao serem trocados, o algarismo de ordem ímpar,
agora ocupa uma ordem par e será multiplicado por 3 e o algarismo, antes de ordem par,
agora estará na ordem ímpar e será multiplicado por 1, alterando assim a soma ﬁnal. Com
isso, o erro será detectado.

Agora, analisaremos um último caso, ainda referente ao código de barras do Exemplo

4.4.

3o Caso: Para esse caso, ainda considerando a sequência numérica 7896259412762,
referente ao leite condensado, trocaremos agora o termo a1 com o termo a10. De acordo com a
proposição anterior, como a diferença entre as ordens 10 − 1 = 9 é um número ímpar, então o
erro poderia ser detectado.

Vejamos então:

Fazendo o produto da seguinte sequência 2896259417762 por 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,

obtemos:

4.1. Estudo de Alguns Sistemas de Codiﬁcação

93

2.1 + 8.3 + 9.1 + 6.3 + 2.1 + 5.3 + 9.1 + 4.3 + 1.1 + 7.3 + 7.1 + 6.3 + 2.1 = 140

140 ≡ 0 (mod 10).

Como 140 é múltiplo de 10, então o erro não será detectado.

O que ocorreu é que o módulo da diferença entre os termos é 5, ou seja |2 − 7| = 5.
Portanto, se a diferença entre as ordens dos termos trocados for um número ímpar, o erro só será
detectado se o módulo da diferença dos termos trocados for diferente de 5.

Com isso, podemos enunciar mais uma proposição.

Proposição 21. Um erro de transposição não adjacente, em que os termos ai e a j são trocados,
com a diferença i − j ímpar, será detectado pelos sistemas EAN-13 e UPC, se e somente se,
|a j − ai| ̸= 5.

Demonstração. Considere a seguinte sequência numérica de um código de barras de um deter-
minado produto pelo sistema EAN-13, a1, a2, a3, ..., ai,
..., ...a j, ..., a12, a13.

Ao multiplicarmos essa sequência por 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1 temos como resultado

a1 + 3a2 + ... + ai + ... + 3a j + ... + 3a12 + a13 ≡ 0 (mod 10).

(3)

Ao realizar esse produto, sabe-se que os algarismos de ordem par são multiplicados por
3, enquanto os algarismos na posição ímpar, são multiplicados por 1. Portanto, se a variação de
i para j é ímpar, o fator de multiplicação, seja 1 ou 3, vai mudar. Dessa forma, se um código
sofreu uma transposição não adjacente dos algarismos ai e a j, sendo i − j um número ímpar, ao
efetuarmos o produto obteremos:

a1 + 3a2 + ... + 3ai + ... + a j + ... + 3a12 + a13 ≡ 0 (mod 10).

(4)

Se ﬁzermos (3)-(4), tem-se que

(a1 + 3a2 + ... + ai + ... + 3a j + ... + 3a12 + a13) − (a1 + 3a2 + ... + 3ai + ... + a j + ... +

3a12 + a13) ≡ 0 (mod 10).

ai − 3ai + 3a j − a j ≡ 0 (mod 10)

−2ai + 2a j ≡ 0 (mod 10)

2(a j − ai) ≡ 0 (mod 10).

94

Capítulo 4. Sistemas de Codiﬁcação

Como já visto, sempre |a j − ai| ≤ 9, visto que ai e a j são números entre zero e nove.

Daí, 2(a j − ai) ≡ 0 (mod 10) ⇔ |a j − ai| = 5.

Conclui-se que o erro por transposição não adjacente, com a diferença i − j ímpar, será

detectado se, e somente se, |a j − ai| ̸= 5.

Foram analisados aqui alguns erros de maior ocorrência, dentre eles erros detectáveis e
outros não detectáveis, envolvendo a digitação de códigos de barras dos sistemas EAN-13 e UPC.

4.1.4 QR Code

Já existe no mercado hoje, uma variação do código de barras UPC e EAN-13, que são os

QR Codes.

Como o código de barras possui uma série de limitações quanto às informações do
produto devido à baixa capacidade de armazenamento, os QR Codes foram criados na intenção
de suprir essa necessidade.

O termo QR deriva de Quick Response, que na língua portuguesa signiﬁca resposta

rápida; e code, traduzido para o português signiﬁca código.

O QR Code foi inventado no Japão em 1994 pela Denso Wave, uma empresa do grupo

Toyota, com a ﬁnalidade de identiﬁcar peças de carros, e agilizar o processo de logística.

Contudo, a popularização deste se deu há pouco tempo e hoje em dia é usado para
transmitir informações rápidas e precisas a dispositivos móveis. Assim, passou a fazer parte de
embalagens de produtos em supermercados e também são encontrados em outdoors e anúncios.

O QR Code é um código de barras bidimensional que contém informações através de

texto, imagem, páginas da internet, videos, cartões de visitas, entre outras.

Com uma câmera de celular e um aplicativo gratuito pode se fazer a leitura da imagem

do QR Code e decodiﬁcar o conteúdo presente nesse código.

A capacidade de armazenamento de dados de um QR Code pode variar de acordo com o

tipo de dado armazenado. Veja a tabela a seguir:

Tipo de caracter
Numéricos
Alfa-numéricos
Binário
Kanji ∖ Kame (alfabeto japonês)

Quantidade máxima de caractéres
7089
4296
2953
1817

Tabela 8: Capacidade de armazenamento de um QR Code.

4.1. Estudo de Alguns Sistemas de Codiﬁcação

95

Cada região do código QR tem sua própria função, tais como posicionamento, alinha-

mento, versão da informação e outras voltadas para segurança.

Veja uma imagem de um QR Code:

Figura 11: QR Code (a).

Os quadrados maiores e que estão presentes em três dos quatro cantos servem para

facilitar a localização, tamanho e inclinação.

O quadrado encontrado próximo ao quarto canto, que é um pouco menor que os quadrados
dos cantos e maior que os demais quadrados interiores, tem a função de alinhamento para que o
código possa ser lido e processado.

Os quadrados menores, chamados de módulos, representam as informações contidas no
código. Esses módulos trabalham em conjunto, formando um grupo a cada oito módulos. Cada
um desses grupos pode ser chamado de bytes.

A primeira versão do QR Code tem formatação de 21x21 módulos. Hoje, são conhecidas

um pouco mais de 40 versões diferentes, sendo a última formatação de 177x177 módulos.

Um sistema de correção de erros, que utiliza o algoritmo de Reed-Solomon, pode
recuperar informação de uma etiqueta que esteja daniﬁcada de acordo com a taxa de restauração
que ﬂutua de 7% a 30%. Quanto maior o nível de correção de erros, menor a capacidade de
armazenamento da etiqueta. A informação contida no código é protegida contra erros através de
um código BCH.

É importante pensar que o novo formato do código de barras quebra o paradigma de

servir apenas para identiﬁcação.

Ele funciona como uma etiqueta dinâmica, trazendo muitas vezes ao consumidor até

mesmo o mecanismo de produção do produto que este está levando para a sua residência.

Interessante também comentar que qualquer pessoa pode criar um QR Code. Para isso

precisa apenas de um serviço online.

96

Capítulo 4. Sistemas de Codiﬁcação

4.1.5 Outros Códigos Numéricos

Além dos códigos de barras, existem muitos outros códigos de identiﬁcação que também

possuem um sistema de segurança controlado por dígitos de veriﬁcação.

Nesta seção serão apresentados alguns deles.

1) Cadastro de Pessoas Físicas (CPF)

No Brasil o sistema de identiﬁcação usado para o cadastramento de pessoas físicas é o
CPF, emitido pela Receita Federal. O CPF é outro exemplo importante de sistema de identiﬁcação
que faz o uso do dígito veriﬁcador.

Este número é constituído de 11 dígitos, sendo um primeiro bloco composto de nove
algarismos e um segundo, com mais dois algarismos, que formam o dígito veriﬁcador, que são
obtidos também através da congruência modular.

A principal diferença entre o CPF e os códigos de barras UPC e EAN-13 é que este

primeiro tem como dígito veriﬁcador dois algarismos.

O primeiro deles é o resultado de uma congruência módulo 11, obtido por um algoritmo
com os 9 primeiros dígitos. E o segundo é determinado, incluindo-se o 1o dígito veriﬁcador
encontrado com os 9 primeiros algarismos, através de um algoritmo módulo 11.

Podemos então estruturar o CPF da seguinte maneira:

Sejam a1a2a3...a10a11 os dígitos de um CPF, então

∙ a1a2a3a4a5a6a7a8 são chamados de número base;

∙ a9 representa a unidade da federação onde a pessoa fez o registro;

∙ a10a11 são dígitos veriﬁcadores.

A Tabela 9 apresenta o dígito a9 que deve ser usado para o registro em cada estado

brasileiro.

Como dito anteriormente, a veriﬁcação do número do CPF deve ser feita em duas etapas,

que serão mostradas a seguir usando como exemplo os dígitos do CPF 054703796 − 12.

1a etapa: Considera-se os nove primeiros dígitos do código (a1a2a3a4a5a6a7a8a9) e
multiplica-se ordenadamente por 1, 2, 3, 4, 5, 6, 7, 8, 9 e soma-se os produtos obtidos. Essa soma
deve ser congruente ao dígito a10 módulo 11

a1.1 + a2.2 + a3.3 + a4.4 + a5.5 + a6.6 + a7.7 + a8.8 + a9.9 ≡ a10 (mod 11).

Para o número do CPF citado acima podemos escrever que

4.1. Estudo de Alguns Sistemas de Codiﬁcação

97

Brasil

Tipo de caracter
0
1
2
3
4
5
6
7
8
9

Quantidade máxima de caractéres
Rio Grande do Sul
Distrito Federal, Goiás, Mato Grosso. Mato Grosso do Sul e Tocantins
Acre, Amapá, Amazonas, Pará, Rondônia e Roraima
Ceará, Maranhão e Piauí
Alagoas, Paraíba, Pernambuco e Rio Grande do Norte
Bahia e Sergipe
Minas Gerais
Espírito Santo e Rio de Janeiro
São Paulo
Paraná e Santa Catarina

Tabela 9: Dígito da federação.

0.1 + 5.2 + 4.3 + 7.4 + 0.5 + 3.6 + 7.7 + 9.8 + 6.9 ≡ a10 (mod 11)

243 ≡ a10 (mod 11).

Como 243 ≡ 1 (mod 11), então o primeiro dígito veriﬁcador é 1.

2a etapa: Para essa etapa, deve-se considerar os nove primeiros dígitos juntamente
com o primeiro dígito de controle encontrado anteriormente, ou seja, a1a2a3a4a5a6a7a8a9a10.
Efetua-se o produto de cada um desses algarismos ordenadamente por 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 e
soma-se os produtos obtidos.

A soma resultante deve ser congruente ao dígito a11 módulo 11

a1.0 + a2.1 + a3.2 + a4.3 + a5.4 + a6.5 + a7.6 + a8.7 + a9.8 + a10.9 ≡ a11 (mod 11)

Para o CPF usado como exemplo temos

0.0 + 5.1 + 4.2 + 7.3 + 0.4 + 3.5 + 7.6 + 9.7 + 6.8 + 1.9 ≡ a11 (mod 11)

211 ≡ a11 (mod 11)

Como 211 ≡ 2 (mod 11), então o último dígito veriﬁcador é 2.

Então se a10 = 1 e a11 = 2, os dígitos veriﬁcadores desse CPF são 1 e 2, o que prova a

sua veracidade.

Se caso a soma encontrada for congruente a 10, deve-se considerar o zero para o dígito

procurado, visto que estes devem estar entre 0 e 9.

98

Capítulo 4. Sistemas de Codiﬁcação

De acordo com [1] a partir de Janeiro deste ano a Receita Federal alterou o modelo de
Cadastro de Pessoas Físicas (CPF). Os novos documentos passarão a ter, no verso, um QR Code,
com a ﬁnalidade de facilitar a comprovação da autenticidade do documento e reduzir o risco de
fraudes.

2) Número do Cartão de Crédito

Hoje grande parte dos consumidores utiliza-se do cartão de crédito para fazer suas

compras.

Os principais números de cartões de crédito no Brasil possuem uma sequência de 16
dígitos. Os 6 primeiros referem-se a instituição emissora, sendo que o primeiro desses 6 dígitos
caracteriza a bandeira do cartão. Se, por exemplo, for Visa começa com 4 e se for Mastercard
começa com 5. Os nove dígitos seguintes identiﬁcam o cliente e o último dígito representa o
dígito veriﬁcador.

Veja o esquema representado a seguir:

Figura 12: Partes que compõem o número do Cartão de Crédito.

O dígito veriﬁcador do cartão de crédito pode ser calculado por uma fórmula denominada
Algoritmo de Luhn. Essa fórmula recebeu esse nome em homenagem ao cientista Hans Peter
Luhn (1896-1964), um engenheiro da International Business Machines, IBM, que em 1960
recebeu a patente referente à invenção da técnica para este cálculo.

Hoje em dia esse algoritmo é de domínio público, sendo utilizado por bancos e demais
instituições ﬁnanceiras para validar cartões de crédito e débito. É denominado módulo 10 IBM.

A veriﬁcação da autenticidade do número de um cartão se dá da seguinte maneira:

Seja a1a2a3a4a5a6a7a8a9a10a11a12a13a14a15a16 os dígitos de uma sequência numérica
de um cartão. Os dígitos de ordem ímpar devem ser multiplicados por 2 e os dígitos de ordem
par devem ser multiplicados por 1.

Ao multiplicar os dígitos de ordem ímpar por 2, deve-se considerar:

(cid:40)

2ai =

2ai, se 2ai < 10;
2ai − 9, se 2ai ≥ 10.

4.1. Estudo de Alguns Sistemas de Codiﬁcação

99

Depois, soma-se todos os produtos obtidos. Essa soma deve ser congruente a zero módulo

10, ou seja,

2a1 + a2 + 2a3 + a4 + 2a5 + a6 + 2a7 + a8 + 2a9 + a10 + 2a11 + a12 + 2a13 + a14 + 2a15 + a16 ≡
0 (mod 10).

Para ilustrar esse algoritmo apresentaremos os exemplos a seguir.

Exemplo 4.6. Nesse exemplo veriﬁcaremos a autenticidade dos dígitos do seguinte cartão de
crédito:

Figura 13: Número de um Cartão de Crédito.

Primeiramente multiplicaremos os algarismos das ordens ímpares por 2 e os de ordem
par por 1. Logo depois, deve-se somar os produtos obtidos, lembrando que antes, se algum dos
produtos obtidos for maior ou igual a 10 devemos subtrair 9 destes.

4.2 + 5.1 + 9.2 + 3.1 + 6.2 + 0.1 + 0.2 + 0.1 + 0.2 + 9.1 + 6.2 + 8.1 + 9.2 + 0.1 + 6.2 + 0.1 ≡
0 (mod 10)

8 + 5 + (18 − 9) + 3 + (12 − 9) + 0 + 0 + 0 + 0 + 9 + (12 − 9) + 8 + (18 − 9) + 0 + (12 − 9) + 0 ≡
0 (mod 10)

60 ≡ 0 (mod 10).

Portanto, os dígitos estão corretos, pois a somatória obtida é congruente a zero módulo

10.

Exemplo 4.7. Já para esse 2o exemplo, consideremos que seja necessário veriﬁcar o dígito
veriﬁcador de um cartão.

Consideremos para isso um número de cartão ﬁctício encontrado na internet (Figura 14).

Pelo algoritmo apresentado anteriormente devemos multiplicar os algarismos de ordens
ímpares por 2 e os algarismos de ordem par por 1. Se o produto for maior ou igual a 10, lembrar
que devemos subtrair 9 destes e depois somar os valores obtidos.

100

Capítulo 4. Sistemas de Codiﬁcação

Figura 14: Cartão ﬁctício da Internet.

Para esse caso chamaremos o dígito veriﬁcador de C. Então podemos escrever que

1.2 + 2.1 + 3.2 + 4.1 + 5.2 + 6.1 + 7.2 + 8.1 + 9.2 + 1.1 + 2.2 + 3.1 + 4.2 + 5.1 + 6.2 +C ≡
0 (mod 10)

2 + 2 + 6 + 4 + (10 − 9) + 6 + (14 − 9) + 8 + (18 − 9) + 1 + 4 + 3 + 8 + 5 + (12 − 9) +C ≡
0 (mod 10)

67 +C ≡ 0 (mod 10).

Então o dígito veriﬁcador nesse cartão deveria ser 3 e não 7 como se apresenta.

O último dígito do número do cartão, o dígito veriﬁcador, previne a digitação errada da
sequência de números do cartão e também que hackers gerem números de cartão que funcionem.
Essa última função é reforçada pelo código de segurança que ﬁca no verso do cartão. Este é gerado
pela própria instituição e é calculado pela criptograﬁa do número do cartão e sua data de validade.

4.1.6 Relação entre pesos e módulo

Fizemos o estudo de três sistemas de codiﬁcação: códigos de barras, cadastro de pessoas

físicas (CPF) e o número do cartão de crédito.

Para os códigos de barras foi feito um levantamento e estudo, dentre os erros que mais

ocorrem, de situações em que os erros são ou não detectáveis.

Sabemos que o dígito veriﬁcador também é encontrado nos números de processos judici-
ais, nos códigos para catalogação de livros, ISBN, no título eleitoral, no código de endereçamento
postal entre muitos outros.

Todos esses sistemas citados utilizam-se da congruência modular para obter o número

do dígito veriﬁcador ou veriﬁcar a autenticidade da sequência numérica do documento.

Nesses sistemas que utilizam a congruência modular um número de identiﬁcação é da

forma

4.1. Estudo de Alguns Sistemas de Codiﬁcação

101

a1a2a3...anC,

onde C é o algarismo de controle ou dígito veriﬁcador. O valor de C é determinado pela
congruência

p1a1 + p2a2 + p3a3 + ... + pnan +C ≡ 0 (mod k),

onde os elementos {p1, p2, p3, ..., pn} são previamentes escolhidos e podem ser chamados de
pesos.

Os sistemas desse tipo são chamados de sistema módulo k e a soma p1a1 + p2a2 + p3a3 +

... + pnan +C pode ser designada por S.

Utiliza-se o zero nesta congruência embora qualquer outro valor inteiro entre 0 e k − 1

pode ser usado.

Essa escolha do zero se deve à vantagem de que, se S ≡ 0 (mod k), temos que k|S e
portanto essa soma, utilizada para veriﬁcar a autenticidade de um documento, é múltipla de k.

Ao criar um sistema de codiﬁcação, a escolha do módulo e dos pesos é o que determinará

a capacidade de um sistema detectar um número maior de erros únicos e de transposição.

Isso será demonstrado em dois teoremas a seguir, como visto em [2].

Teorema 4.1. Um sistema de identiﬁcação módulo k, com pesos {p1, p2, ..., pn} detecta todo
erro único, ai → a′

i, na i-ésima posição se e somente se, mdc(pi, k) = 1.

Demonstração. Considere um número a1a2a3...C de um sistema de identiﬁcação módulo k,
cujo dígito de veriﬁcação é C e a soma é S. Sabe-se que S ≡ 0 (mod k). Representaremos por S′
i na i-ésima posição. Apesar de S′ representar uma soma incorreta
a soma com a troca ai → a′
podemos ter S′ ≡ 0 (mod k) ou S′ ̸≡ 0 (mod k), para caso em que o erro não foi detectado e para
quando o erro é detectado, respectivamente.

Calculando a diferença S′ − S, temos

S′ − S = (p1a1 + p2a2 + ... + pia′

i + ... + pnC − p1a1 − p2a2 − ... − piai − ... − pnC = pia′

i + ... + pnC) − (p1a1 + p2a2 + ... + piai + ... + pnC) =
i −

i − piai = pi(a′

p1a1 + p2a2 + ... + pia′
ai).

Dessa forma, um erro ai → a′

i na i-ésima posição é detectável se, e somente se,

pi(a′

i − ai) ̸≡ 0 (mod k), para ai, a′

i ∈ {0, 1, 2, ..., k − 1} e ai ̸= a′
i.

E esta condição é equivalente a mdc(pi, k) = 1 pelo teorema a seguir.

Teorema 4.2. Sejam p e k números inteiros. Então pb ̸≡ 0 (mod k), para todo b ∈ {1, ..., k − 1}
se, e somente se, mdc(p, k) = 1.

102

Capítulo 4. Sistemas de Codiﬁcação

Demonstração. Suponha que mdc(p, k) = d > 1. Então d|p e d|k, e assim p = dd1 e k = dd2
com d2 ∈ {1, ..., k − 1}. Fazendo b = d2 temos que

pb = pd2 = dd1d2 = d1dd2 = d1k ≡ 0 (mod k).

Como pb ̸≡ 0 (mod k) temos um absurdo. Portanto, d = 1, ou seja, mdc(p, k) = 1.

Reciprocamente, como mdc(p, k) = 1 temos que k (cid:45) p. Seja b ∈ {1, ....k − 1} tal que
pb ≡ 0 (mod k). Logo k|pb e mdc(p, k) = 1. Segue que k|b, absurdo, pois 0 < b ≤ k − 1.
Portanto, pb ̸≡ 0 (mod k).

Assim, um sistema modular de identiﬁcação vai detectar todo erro único se, e somente

se, mdc(pi, k) = 1.

Teorema 4.3. Um sistema de identiﬁcação módulo k, com pesos {p1, p2, ..., pn}, detecta todos os
erros de transposição dos algarismos ai e a j nas posições i e j se, e somente se, mdc(pi − p j, k) =
1.

Demonstração. Neste caso, a diferença entre a soma com os algarismos trocados e a soma
correta é

S′ − S = (p1a1 + ... + pia j + ... + p jai + ... + pnC) − (p1a1 + ... + piai + ... + p ja j + ... + pnC)

= p1a1 + ... + pia j + ... + p jai + ... + pnC − p1a1 − ... − p ja j − ... − pnC

= pia j + p jai − piai − p ja j = pia j − piai + p jai − p ja j = pi(a j − ai) − p j(a j − ai) =
(pi − p j)(a j − ai).

Portanto, o sistema detecta todas as transposições de algarismos nas posições i e j, se
e somente se, para quaisquer ai, a j ∈ {0, 1, 2, ..., k} com ai ̸= a j, se tem (pi − p j)(a j − ai) ̸≡
0 (mod k), que é equivalente a mdc(pi − p j, k) = 1, pelo Teorema 4.2.

A maior utilização do módulo 11 se justiﬁca pela facilidade de encontrar pesos primos
com 11, usando apenas um algarismo para dígito de veriﬁcação. A desvantagem do módulo
11 é que no conjunto de dígitos de 0 a 9 não existe nenhum símbolo que represente o número
10 (resto possível nas divisões por 11). Em geral utiliza-se para sua representação o algarismo
romano X ou utiliza-se o dígito 0 para representar o 10.

No caso de sistemas módulo 10, os Teoremas 4.1 e 4.3 trabalhados anteriormente podem

ser incompatíveis, dependendo dos pesos adotados.

4.2. Aplicação em sala de aula

103

Portanto, um sistema módulo k pode ter 100% de eﬁciência na detecção de erros únicos

e não detectar os erros de transposição.

Ao se construir um sistema de identiﬁcação ou codiﬁcação modular é essencial que se
conheça os Teoremas 4.1 e 4.3 anteriores, para assim fazer uma boa escolha dos pesos e do
módulo que será usado.

4.2 Aplicação em sala de aula

Diante das diﬁculdades relacionadas à aprendizagem de conceitos matemáticos, que
acabam desmotivando o aluno, o professor precisa investir na busca de novas formas de aprimorar
as atividades de ensino. Nessa direção, os recursos de ensino constituídos por novas tecnologias,
como a internet, o computador e os celulares tem-se apresentados como fortes recursos que
desempenham esse papel. Esta seção apresenta uma proposta de sequências de atividades de
autoria própria, abordando conteúdos matemáticos do Ensino Fundamental, relacionando aos
códigos estudados na seção anterior deste trabalho.

Assim, as atividades aqui propostas buscam ser motivadoras e levam à construção do

conhecimento pelo próprio aluno.

Essas atividades foram desenvolvidas com alunos do 9oano/8a série do Ensino Funda-
mental, de uma escola pública. Estas podem ser adaptadas e trabalhadas em outras séries do
Ensino Fundamental e do Ensino Médio.

Para desenvolvê-las os alunos precisam dominar as operações básicas com números

naturais e ter um conhecimento básico de informática.

O material necessário para realização das atividades foi o uso da sala de informática da
escola, celulares dos próprios alunos e embalagens de produtos que os alunos trouxeram de casa.
O tempo para realização da atividade depende do envolvimento e empenho dos alunos. Em cada
etapa é importante que o professor auxilie e incentive seus alunos na realização dos registros dos
resultados obtidos, para análise posterior.

1a etapa: Conhecendo os QR codes.

Primeiramente, foi exibido aos alunos uma imagem de um QR code e questionado a
eles se já haviam visto imagem parecida em algum produto ou em anúncios. A maioria dos
alunos presentes, aﬁrmaram já terem visto, porém não sabiam a função deste. Foi explicado
aos alunos sobre o que é esse código, um pouco de sua história e sua principal função, que é o
armazenamento de informações.

Para ilustrar a aula, os alunos foram levados para a sala de vídeo da escola e assistiram
ao vídeo do link:https://www.youtube.com/watch?v=1ipMnFLjxdQ. Nesse vídeo, os alunos
puderam ver a grande aplicabilidade dos QR codes e como eles já estão espalhados pelo mundo
todo.

104

Capítulo 4. Sistemas de Codiﬁcação

Figura 15: Alunos na sala de vídeo.

Logo após, os alunos ﬁzeram uso do celular, conectados à internet, para baixar um leitor
de QR code, o Barcode (existem muitos outros aplicativos de leitura de um QR code que podem
ser baixados gratuitamente). Como atividade, os alunos foram divididos em grupos e receberam
o QR code da imagem abaixo.

Figura 16: Imagem de um QR code com atividade Matemática.

Cada grupo decodiﬁcou a imagem usando o aplicativo baixado. O conteúdo da imagem
era o seguinte link:http://professoraju-mat.blogspot.com.br/2010/06/enigmas-da-ju-aranha-e-
sua-teia.html, que os direcionava para a página do Blog de uma professora, onde continha um
exercício de Matemática. Cada grupo resolveu o exercício proposto e explicou o método adotado.

2a etapa:

Nessa parte do desenvolvimento do trabalho, foi explicado aos alunos como criar um
QR code. Foi mostrado a eles, que existem diversos sites que fazem essa criação gratuitamente,
como por exemplo:

∙ http://www.qr-code-generator.com/.

∙ http://e-lemento.com/gerador-qr-code.

∙ https://www.invertexto.com/qrcode.

4.2. Aplicação em sala de aula

105

Cada grupo foi para a sala de informática, e começou a fazer tentativas para criar seus
próprios QR codes. Nesse ponto do trabalho, é interessante salientar que o interesse dos alunos
nessa parte do desenvolvimento do trabalho foi surpreendente. Criaram vários QR codes com
links, com imagens, com texto, com ﬁguras, fazendo o uso das formas mais criativas possíveis.
A escola preparava-se para uma Feira do Conhecimento. Então, cada grupo, aproveitou-se da
nova forma de informar para criar QR codes voltados para o tema que cada grupo apresentaria
no dia dessa feira. A escola ﬁcou tomada de QR codes pelos corredores. A seguir, alguns QR
codes criados pelos alunos:

(a) QR code criado pelo grupo 2.

(b) QR code criado pelo grupo 5.

Figura 17: QR codes criados pelos alunos.

Um aluno de cada grupo ﬁcou responsável de informar os visitantes da escola no dia
da Feira do Conhecimento sobre o que era o QR code e como fazer a leitura deste. Despertou
a curiosidade até mesmo de outros professores que quiseram se aprofundar no assunto para
também fazer uso do QR code em suas aulas.

3a etapa:

Ao fazer o estudo do QR code, foi informado aos alunos que este poderia algum dia
substituir o código de barras convencional, encontrados nos produtos. Então, na terceira etapa,
foi realizado com os alunos, o estudo do código de barras tradicional.

Primeiramente, foi contado um pouco da história e evolução do código de barras. Já na
sala de informática foi proposto aos alunos que visitassem a página da internet: http://gizmodo.uol.
com.br/a-historia-nao-contada-da-origem-dos-codigos-de-barras/, onde existe o relato da criação
e evolução dos códigos de barra no decorrer dos anos.

Em outro momento, na sala de aula, os alunos tiveram uma aula expositiva sobre a
estrutura dos números do código de barras, composto por 13 algarismos, para entenderem o que
cada parte do código representa e também foi falado sobre a existência do dígito veriﬁcador e
sua função. Ao ﬁnal dessa aula, foi pedido aos alunos que levassem embalagens de produtos
com códigos de barras para a próxima aula.

106

Capítulo 4. Sistemas de Codiﬁcação

Com as embalagens que os alunos trouxeram, foi pedido que estes analisassem as
diferenças entre os códigos das embalagens presentes. Espera-se que com essa parte da atividade
os alunos identiﬁquem: a parte da sequência que seja igual em mais de um produto e a quantidade
de dígitos presente. A sala foi separada em grupos novamente e cada grupo foi até a frente na
sala de aula, mostrou a embalagem, o signiﬁcado de cada parte do código, criando na lousa uma
tabela para representar o código do país onde o produto foi cadastrado, código do fabricante,
código do produto e dígito veriﬁcador.

Para ﬁnalizar esta etapa, foi exposto aos alunos como determinar um dígito veriﬁcador
do código de barras da seguinte maneira: deve-se considerar os 12 primeiros dígitos, da esquerda
para a direita, e multiplicar os algarismos de ordem ímpar por 1 e de ordem par por 3, somando
os produtos obtidos. Para determinar o dígito veriﬁcador basta descobrir qual número devemos
acrescentar a essa soma obtida para termos um múltiplo de 10. Esse número é o dígito veriﬁcador.

Figura 18: Alunos expondo embalagem e a estrutura de um código de barras (a).

Figura 19: Alunos expondo embalagem e a estrutura de um código de barras (b).

4.2. Aplicação em sala de aula

107

Figura 20: Alunos expondo embalagem e a estrutura de um código de barras (c).

O comentário geral é que a atividade foi muito interessante, pois sempre iam aos super-
mercados com os pais e nunca imaginavam que aquele código tinha uma estrutura e um cálculo
matemático envolvido nele.

É importante salientar que nessa atividade os alunos utilizaram-se de cálculos da arit-
mética do dia-a-dia, mas futuramente, quando tiverem contato com as congruências modulares
e classes residuais ﬁcará mais fácil entender os conceitos usados. Foi interessante também ao
trabalhar códigos de barras a oportunidade de rever, no 9oano, critérios de divisibilidade, divisão
euclidiana e operações matemáticas fundamentais.

4a etapa:

Para ﬁnalizar, foi exposto aos alunos que existem muitos outros números, usados por
eles, no dia-a-dia, que também fazem uso do dígito veriﬁcador. Foi citado como exemplo, o
número do cartão de crédito, o número do título de eleitor, o número de CPF, entre outros.

Dentre esses números existentes, foi escolhido o número de CPF (cadastro de pessoas

físicas) para a realização da última atividade.

Primeiramente foi informado a eles que o CPF é o registro de um cidadão na Receita
Federal e que esse documento é necessário em várias situações, como abertura de contas em
bancos, emissão de passaporte, entre outras.

Foi ressaltado também que o CPF difere do código de barras, pois este tem nove dígitos de
identiﬁcação e dois dígitos veriﬁcadores. Foi exibido a eles que o nono dígito do CPF representa
a unidade federativa em que a pessoa registrou-se, e ilustrada em sala de aula pela tabela a seguir.

108

Capítulo 4. Sistemas de Codiﬁcação

Brasil

Tipo de caracter
0
1
2
3
4
5
6
7
8
9

Quantidade máxima de caracteres
Rio Grande do Sul
Distrito Federal, Goiás, Mato Grosso. Mato Grosso do Sul e Tocantins
Acre, Amapá, Amazonas, Pará, Rondônia e Roraima
Ceará, Maranhão e Piauí
Alagoas, Paraíba, Pernambuco e Rio Grande do Norte
Bahia e Sergipe
Minas Gerais
Espírito Santo e Rio de Janeiro
São Paulo
Paraná e Santa Catarina

Tabela 10: Dígito da federação.

Para que os alunos entendessem como se determina os dígitos veriﬁcadores do CPF, foi
feito um exemplo do cálculo na lousa, explicando da seguinte maneira: considera-se os nove
primeiros dígitos, da esquerda para a direita, do CPF, multiplicando-os por 1, 2, 3, 4, 5, 6, 7, 8, 9,
nesta ordem; depois soma-se os produtos obtidos, dividindo essa soma por 11; o resto obtido
é o 10o dígito, ou seja, o primeiro algarismo do dígito veriﬁcador. Para determinar o segundo
dígito veriﬁcador, deve-se novamente considerar os nove primeiros dígitos, da esquerda para
a direita, juntamente com o primeiro dígito veriﬁcador obtido anteriormente, multiplicando-
os por 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, nesta ordem; depois, soma-se os produtos obtidos e divide essa
soma novamente por 11; o resto obtido é o 11o dígito, ou seja, o segundo algarismo do dígito
veriﬁcador.

Após ouvirem esta explicação, foi pedido aos alunos que para próxima aula trouxessem
o CPF para a aula com os algarismos do dígito veriﬁcador tampados, com ﬁta adesiva, para
realização de uma atividade em grupo. Essa atividade foi realizada em duplas e consistia de que
os alunos trocassem de CPF, já estando esse com os dois últimos dígitos tampados. O aluno
de posse do CPF do colega deveria usar o algoritmo exposto na aula anterior para descobrir os
algarismos que compunham o dígito veriﬁcador do colega.

4.2. Aplicação em sala de aula

109

Figura 21: Alunos determinando o dígito veriﬁcador do CPF.

Ao terminar, cada aluno, já com seu próprio CPF em mãos novamente, tirava a ﬁta

adesiva e veriﬁcava se o colega havia encontrado os dois algarismos corretamente.

Foi uma atividade produtiva, pois usou-se de operações matemáticas e ao mesmo tempo,
constitui-se numa atividade lúdica, pois o fato de descobrir o número corretamente tornou-se um
desaﬁo.

Espera-se que com atividades como essas a Matemática, que constitui ferramenta funda-
mental para a formação de cidadãos, possa ser vista como algo que proporciona um ambiente
investigativo e criativo, onde é possível fazer conexões entre diversas formas de pensamentos
com outras áreas do saber e com aplicações na atualidade.

111

REFERÊNCIAS

[1] CORREIO. CPF terá QR Code e dados poderão ser atualizados na receita federal.
Disponível em:http://www.correiobraziliense.com.br/app/noticia/brasil/2017/01/12/internas_-
polbraeco,564690/cpf-tera-qr-code-e-dados-poderao-ser-atualizados-no-site-da-receita-
fe.shtml. Acesso em 03 de Março de 2017. Citado na página 98.

[2] COSTA, F.R.A. Sistemas de Identiﬁcação Modular: uma aplicação no ensino fundamental.
TCC - PROFMAT- UFSJ, 2014. Citado na página 101.

[3] COUTINHO, S.C. Números inteiros e Criptograﬁa RSA. Rio de Janeiro: IMPA, 2014.
Citado nas páginas 65 e 66.

[4] FORMIN, D. Círculos Matemáticos. Rio de Janeiro: IMPA, 2012. Citado na página 39.

[5] FREIRE, B.T.V. Notas de Aula: Teoria dos Números. Citado na página 29.

[6] HEFEZ, A. Aritmética. Rio de Janeiro: SBM, 2014. Citado na página 42.

[7] HEFEZ, A. Elementos de Aritmética. Rio de Janeiro: SBM, 2005. Citado na página 68.

[8] MAIER, R.R. Teoria dos Números. Notas de aula 2005. Citado na página 27.

[9] MARTINEZ, F.B. Teoria dos Números: um passeio com primos e outros números familiares
pelo mundo inteiro. 2. ed. Rio de Janeiro: IMPA, 2013. Citado na página 27.

[10] MILIES, C.P. A Matemática dos Códigos de Barras. 19 f. São Paulo, SP.IME/USP- Depar-
tamento de Matemática. Citado nas páginas 79, 80 e 88.

[11] MOREIRA, C.G.T.A. Tópicos de Teoria dos Números. Rio de Janeiro: SBM, 2012. Citado
na página 59.

[12] MOREIRA, F.R.S. Congruências Lineares. ITA, 2006. Citado na página 64.

[13] Ribenboim, P. Números Primos. Velhos mistérios e novos recordes. 1. ed. Rio de Janeiro:
IMPA, 2014. Citado na página 55.

[14] SAUTOY, M.D. A Música dos Números Primos: A História de um Problema não Resolvido
na Matemática. Rio de Janeiro: Zahar, 2007. Citado na página 51.

112

Referências

descobrem o maior

[15] VEJA Cientistas
http://veja.abril.com.br/ciencia/cientistas-descobrem-o-maior-numero-primo-e-ele-tem-
mais-de-22-milhoes-de-digitos/. Acesso em 05 de Fevereiro de 2017. Citado na página
54.

primo. Disponível

número

em

[16] WALL, E.S. Teoria dos Números para professores do ensino fundamental. Porto Alegre:
AMGH, 2014. Citado nas páginas 55, 71, 74 e 76.

UNIVERSIDADE DE SÃO PAULOInstituto de Ciências Matemáticas e de Computação