SOCIEDADE BRASILEIRA DE MATEMÁTICA 
FUNDAÇÃO UNIVERSIDADE FEDERAL DE RONDÔNIA 
MESTRADO PROFISSIONAL EM MATEMÁTICA EM REDE NACIONAL 

SÉZANI MORAIS GONÇALVES DE CARVALHO 

MATRIZES, DETERMINANTES E POLINÔMIOS: Aplicações em códigos corretores 
de erros, como estratégia motivacional para o ensino de matemática.  

PORTO VELHO 
2014 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SÉZANI MORAIS GONÇALVES DE CARVALHO 

MATRIZES, DETERMINANTES E POLINÔMIOS: Aplicações em códigos corretores 
de erros, como estratégia motivacional para o ensino de matemática.  

Trabalho  de  conclusão  apresentado  ao  Mestrado 
Profissional  em  Matemática  em  Rede  Nacional  – 
PROFMAT  no  polo  da  Universidade  Federal  de 
Rondônia  –  UNIR,  como  requisito  parcial  para  a 
obtenção  do 
título  de  Mestre  em  Matemática 
Profissional. 

Orientador:  Prof.  Dr.  Tomás  Daniel  Menéndez 
Rodriguez. 

Porto Velho 
2014 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Aos meus pais Dorival e Terezinha. 
À minha amada filha Aízis. 
Ao saudoso Professor Domingos dos Reis. 
Ao grande amigo e professor Marinaldo. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Com muita sinceridade e bastante carinho, externo meus agradecimentos: 

A Deus pela oportunidade de vitória a mim concedida, pois nos momentos mais difíceis dessa 

caminhada encontrei nele o conforto e a força necessária para prosseguir. 

Ao meu orientador Prof. Dr. Tomás Daniel Menéndez Rodriguez por acreditar em mim desde 

o saudoso período da graduação. 

Aos  meus  pais  Dorival  Gonçalves  de  Carvalho  e  Terezinha  Morais  de  Carvalho  por  me 

incentivarem sempre nos estudos, além de me apoiarem. 

À minha filha Aízis Morais de Carvalho por ser a razão pela qual sempre insisto em alcançar 

maiores conquistas. 

Ao grande professor e estimado amigo Dr. Marinaldo Felipe por contribuir comigo e demais 

alunos com seu extraordinário conhecimento de matemática e com sua peculiaridade em ser 

sempre entusiasta. 

À  Querida  professora  e  amiga  Maria  das  Graças  por  ser  uma  fonte  inspiradora  em  como 

ensinar e amar a matemática. 

Aos  professores  e  amigos  Adeilton  Costa,  Flávio  Batista  Simão  e  Ronaldo  Chaves  pelas 

contribuições em minha formação além da boa amizade. 

Aos meus grandes amigos e companheiros de academia que ao meu lado batalharam durante 

esses  anos  e  foram  incorporados  à  minha  vida:  Adalberto  Carlos,  Alisson,  Francenildo, 

Francisco Sales, Gilson Caliani, Jean, José Inildo, Kleber Sales, Luci, Marizete Nink, Magno 

Martins,  Vicente  e,  em  especial  ao  jovem  Guilherme,  com  quem  aprendi  muito,  me  diverti 

muito e construí uma sólida e eterna amizade. 

A  todos  os  que  contribuíram  com  minha  formação,  aos  quais  mencionei  acima,  e  aos 

colaboradores que por ventura deixei de mencionar, externo minha eterna gratidão. 

 
 
 
 
 
 
 
 
 
 
RESUMO 

Este trabalho  consiste em  um  material  de apoio aos professores de matemática atuantes nas 
séries finais do ensino médio, bem como para os alunos concluintes desse ciclo da educação 
básica, que desejem aprofundar seus conhecimentos. 
Inicialmente, abordamos neste texto os fatores motivadores para a construção deste material 
de apoio.  Em seguida apresentamos os  conteúdos de matrizes,  determinantes e polinômios, 
que  estão  presentes  no  currículo  da  disciplina  de  matemática  no  ensino  médio.  São 
apresentadas  também  as  estruturas  algébricas  elementares  que,  embora  não  façam  parte  dos 
currículos  de  matemática  na  educação  básica,  aparecem  parcialmente  desde  o  ensino 
fundamental  mesmo  que  de  forma  implícita  nessa  disciplina.  Por  fim,  apresentamos  as 
aplicações desses conteúdos matemáticos na teoria dos códigos corretores de erros, que é foco 
deste trabalho, além de um rol de atividades propostas sobre os conteúdos abordados.  

Palavras  Chave:  Matrizes.  Determinantes.  Polinômios.  Estruturas  Algébricas.  Códigos 

Corretores de Erros. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ABSTRACT 

This  work  consists  of  a  support  material  for  teachers  of  mathematics  acting  in  high  school 
finals series, as well as for students graduating from this cycle of basic education, who aim to 
deepen their knowledge on the subject. 
Initially, we discussed in this text the motivating factors for the construction of this support 
material.  Then  we  present  the  contents  of  matrix,  determinants  and  polynomials,  which  are 
present in the high school mathematics discipline curriculum. Also the elementary algebraic 
structures  are  presented  which,  although  not  part  of  the  curriculum  of  mathematics  in  basic 
education,  appear  partially  since  elementary  school,  even  if  implicitly  in  this  discipline. 
Finally,  applications  of  these  mathematic  contents  are  presented  in  the  theory  of  errors 
correcting  codes,  main  focus  of  this  work,  besides  a  roster  of  proposed  activities  about  the 
addressed contents.  

Key words: Matrix, Determinants, Polynomials, Algebraic structures, Errors correcting codes. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1: Telefone celular ..................................................................................................................... 27 
Figura 2: Braço mecânico ................................................................................................................... 100 
Figura 3: Esquema de uma permutação cíclica ................................................................................... 137 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE GRÁFICOS 

GRÁFICO 1: Desempenho dos alunos em operações com matrizes...................................... 19 

GRÁFICO 2: Conhecimento e aplicação das propriedades operacionais das matrizes.......... 19 

GRÁFICO 3: Desempenho dos alunos em operações com polinômios.................................. 20 

GRÁFICO 4: Conhecimento o utilização das propriedades operacionais dos polinômios..... 20 

GRÁFICO 5: Domínio de técnicas na resolução de determinantes de matrizes..................... 21 

GRÁFICO 6: Conhecimento e utilização das propriedades dos determinantes...................... 21 

GRÁFICO 7: Habilidades na identificação da invertibilidade de uma matriz........................ 22 

GRÁFICO 8: Conhecimento dos alunos sobre a aplicabilidade dos conteúdos de matrizes 
e determinantes........................................................................................................................ 22 

GRÁFICO 9: Conhecimento dos alunos sobre a aplicabilidade dos conteúdos de 
polinômios............................................................................................................................... 23 

GRÁFICO 10: Áreas de aplicação dos conteúdos de matrizes e determinantes, segundo os 
alunos....................................................................................................................................... 23 

GRÁFICO 11: Grau de importância sobre conhecer as aplicações dos conteúdos estudados 
em matemática, segundo os alunos......................................................................................... 24 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
SUMÁRIO 

INTRODUÇÃO........................................................................................................................13 

1  MOTIVAÇÃO E ABORDAGEM DO TRABALHO ....................................................... 16 

1.1 

POR QUE ESTUDAR MATRIZES, DETERMINANTES E POLINÔMIOS? ........ 16 

1.2  A MOTIVAÇÃO PARA A REALIZAÇÃO DO TRABALHO ............................... 18 

1.3  ABORDAGEM DOS CONTEÚDOS DE MATRIZES, DETERMINANTES E 
POLINÔMIOS NO LIVRO DIDÁTICO. ............................................................................ 24 

1.4  A ESCOLHA DA APLICAÇÃO DAS MATRIZES, DETERMINANTES E 
POLINÔMIOS NOS CÓDIGOS CORRETORES DE ERROS ........................................... 26 

2  MATRIZES ....................................................................................................................... 29 

2.1  DEFINIÇÃO DE MATRIZES REAIS – ALGUNS CONCEITOS .......................... 29 

2.1.1 

Igualdade de matrizes ......................................................................................... 30 

2.2  OPERAÇÕES COM MATRIZES ............................................................................. 31 

2.2.1  Adição de matrizes ............................................................................................. 31 

2.2.2  Multiplicação de um escalar real por uma matriz............................................... 32 

2.2.3  Multiplicação de matrizes ................................................................................... 33 

2.2.4 

Potenciação de matrizes...................................................................................... 35 

2.3 

2.4 

2.5 

Transposta de uma matriz .......................................................................................... 35 

Inversa de uma matriz ................................................................................................ 37 

Transformações elementares de matrizes .................................................................. 38 

2.5.1  Matriz elementar ................................................................................................. 39 

2.5.2  Matriz escalonada ............................................................................................... 41 

3  DETERMINANTES ......................................................................................................... 45 

3.1 

PROPRIEADES DOS DETERMINANTES ............................................................. 47 

3.1.1  Alguns comentários ............................................................................................ 55 

3.2  MÉTODOS PARA O CÁLCULO DE DETERMINANTES .................................... 55 

3.2.1 

Regra de Sarrus para o cálculo do determinante de uma matriz de ordem 3 ..... 55 

3.2.2 

Regra de Laplace para o cálculo do determinante .............................................. 56 

3.2.3  O método da eliminação de Gauss ..................................................................... 57 

3.3  Determinantes e matriz inversa .................................................................................. 59 

4  ALGUMAS NOÇÕES SOBRE POLINÔMIOS............................................................... 62 

4.1 

IGUALDADE DE POLINÔMIOS ............................................................................ 63 

4.2  ADIÇÃO DE POLINÔMIOS .................................................................................... 63 

 
4.3  MULTIPLICAÇÃO DE POLINÔMIOS ................................................................... 65 

4.4  DIVISÃO EUCLIDIANA DE POLINÔMIOS ......................................................... 68 

4.5 

INTERPOLAÇÃO ..................................................................................................... 72 

5  ESTRUTURAS ALGÉBRICAS ELEMENTARES ......................................................... 74 

5.1 

LEI DE COMPOSIÇÃO INTERNA ......................................................................... 74 

5.2  GRUPOS .................................................................................................................... 74 

5.2.1 

Subgrupos ........................................................................................................... 76 

5.3  ANÉIS ........................................................................................................................ 77 

5.3.1 

Subanéis .............................................................................................................. 80 

5.4 

IDEAIS ...................................................................................................................... 81 

5.5  CORPOS .................................................................................................................... 83 

5.6 

ESPAÇOS VETORIAIS ............................................................................................ 86 

5.6.1  Algumas propriedades de um espaço vetorial .................................................... 88 

5.6.2 

Subespaços vetoriais ........................................................................................... 89 

5.6.3 

Base e Dimensão ................................................................................................ 91 

5.6.4  Noções sobre transformação linear..................................................................... 95 

5.6.5  Noções sobre produto interno ............................................................................. 98 

6  CÓDIGOS CORRETORES DE ERROS .......................................................................... 99 

6.1  O QUE É UM CÓDIGO? .......................................................................................... 99 

6.2  MÉTRICA DE HAMMING .................................................................................... 103 

6.2.1  Disco e esfera de centro c raio r ....................................................................... 104 

6.2.2  Distância mínima de um código ....................................................................... 105 

6.2.3  Número de detecções e número de correções de erros ..................................... 106 

6.2.4 

Códigos perfeitos .............................................................................................. 106 

6.2.5 

Equivalência de códigos ................................................................................... 107 

6.3  CÓDIGOS LINEARES ........................................................................................... 108 

6.3.1 

Peso de um código ............................................................................................ 109 

6.3.2  Matriz geradora de um código .......................................................................... 110 

6.3.3 

Códigos duais ................................................................................................... 114 

6.3.4  Decodificação ................................................................................................... 119 

6.3.5  Alguns exemplos de códigos lineares ............................................................... 128 

6.4  ALGUMAS NOÇÕES SOBRE CÓDIGOS CÍCLICOS ......................................... 136 

6.4.1 

Codificação em código cíclico ......................................................................... 139 

6.4.2 

Código dual de um código cíclico .................................................................... 143 

6.4.3  Decodificação em código cíclico ...................................................................... 146 

7  ATIVIDADES POPOSTAS ............................................................................................ 152 

7.1  MATRIZES REAIS ................................................................................................. 152 

7.2  DETERMINANTES DE MATRIZES REAIS ........................................................ 154 

7.3 

POLINÔMIOS EM ℝ[𝑋] ........................................................................................ 157 

7.4  CÓDIGOS CORRETORES DE ERROS ................................................................ 159 

CONSIDERAÇÕES FINAIS..................................................................................................163 

REFERÊNCIAS......................................................................................................................165 

 
13 

INTRODUÇÃO 

Na  atualidade,  vários  esforços  têm  sido  realizados  com  o  objetivo  de  proporcionar 

melhorias  no  ensino  e  aprendizagem  de  matemática,  dentre  eles  podemos  citar  o  programa 

Pacto  Nacional  pela  Alfabetização  na  Idade  Certa,  do  Governo  Federal  ou  ainda  programas 

das  Secretarias  Estaduais  e  Municipais  de  Educação  de  diversos  Estados  e  Municípios 

brasileiros. 

Embora  existam  medidas  de  diversas  partes  para  proporcionar  essa  melhoria,  temos 

visto  ao  longo  dos  anos  que  se  trata  de  um  processo  demorado  e  complexo  atingir  esse 

objetivo, uma vez que pesquisas específicas realizadas nas várias etapas da educação básica, 

como exemplos a Provinha Brasil e o Sistema de Avaliação da Educação Básica (SAEB), tem 

mostrado. 

O Índice de Desenvolvimento da Educação Básica (IDEB) mostra um avanço sutil no 

desenvolvimento da educação básica. Os dois últimos resultados do IDEB, a saber, dos anos 

de 2011 e 2013, apontam um discreto progresso, pois, do 1º ao 5º ano do ensino fundamental 

o índice  aumentou  de 5,0 para 5,2,  enquanto  que do 6º ao 9º ano do ensino  fundamental,  o 

índice aumentou de 4,1 para 4,2 e, no ensino médio o índice se manteve em 3,7. 

Com  base  nos  resultados  apresentados  acima,  percebemos  que  à  medida  que 

avançamos para as séries finais da educação básica, dois fenômenos são observados: 

1º - Os índices são menores; 

2º  -  O  progresso  em  cada  etapa  avaliada  diminui  à  medida  que  avançamos  aos  anos  finais, 

pois  de  2011  para  2013,  houve  aumento  de  0,2 pontos  no  índice  do  1º  ao  5º  ano  do  ensino 

fundamental,  0,1  ponto  do  6º  ao  9º  do  ensino  fundamental  e  não  houve  aumento  no  índice 

referente ao ensino médio. 

Como  componente  presente  nos  currículos  da  educação  básica,  a  matemática  está 

inserida  nesse  contexto  e  seu  ensino/aprendizagem  tem  participação  no  fracasso  ou  sucesso 

dos estudantes nessas etapas da educação. 

É  sabido  que  no  desenvolvimento  humano  o  sujeito,  inicialmente  adquire  suas 

experiências  a  partir  do  concreto  e  em  uma  etapa  posterior,  decorrente  das  experiências 

adquiridas,  atinge  o  estágio  de  abstração.  Segundo  Piaget,  “Após  os  11  ou  12  anos,  o 

pensamento formal torna-se possível, isto é, as operações lógicas começam a ser transpostas 

do  plano  da  manipulação  para  as  ideias”  (PIAGET,  1995,  p  59).  Com  a  matemática  não  é 

diferente:  as  experiências  iniciais  são  adquiridas  a  partir  do  concreto  e,  em  uma  etapa 

posterior, à medida que vai avançando, a matemática vai se distanciando do concreto e sendo 

 
 
 
 
  
 
 
 
14 

imersa em um contexto abstrato e cada vez mais abstrato. Porém, cabe ressaltar que embora 

adquira  status  avançado  de  abstração,  não  deixa  de  ter  aplicabilidade  no  mundo  concreto, 

mesmo  porque,  grande  parte  dos  avanços  matemáticos  existentes  surgiu  da  necessidade  de 

atender  a  alguma  demanda  do  mundo  concreto.  Meyer  et  al  evidencia  que  “os  gregos 

desenvolveram o cálculo de área por que tinham de fazer as medições das terras do Nilo; os 

fenícios  desenvolveram  conceitos  aritméticos  de  contabilidade  porque  eram  comerciantes” 

(MEYER et al, 2011, p 25). 

Nesse contexto, podemos ver nos Parâmetros Curriculares Nacionais o seguinte texto: 

A  Matemática,  por  sua  universalidade  de  quantificação  e  expressão,  como 
linguagem  portanto,  ocupa  uma  posição  singular.  No  Ensino  Médio,  quando  nas 
ciências torna-se essencial uma construção abstrata mais elaborada, os instrumentos 
matemáticos  são  especialmente  importantes.  Mas  não  é  só  nesse  sentido  que  a 
Matemática  é  fundamental.  Possivelmente,  não  existe  nenhuma  atividade  da  vida 
contemporânea,  da  música  à  informática,  do  comércio  à  meteorologia,  das 
engenharias  às  comunicações,  em  que  a  Matemática  não  compareça  de  maneira 
insubstituível  para  codificar,  ordenar,  quantificar  e  interpretar  compassos,  taxas, 
dosagens,  coordenadas,  tensões,  frequências  e  quantas  outras  variáveis  houver 
(PNC/Ensino Médio, p 9). 

Sendo assim, a abstração é essencial para “o aprender” matemática, é impensável uma 

matemática que se alimente puramente do concreto, porém, mesmo que de maneira implícita, 

a matemática está presente nas atividades cotidianas, o que leva-nos a pensar em estratégias 

de ensino que apresentem  as aplicabilidades da  matemática no dia a dia. O ato  de conhecer 

não  deve  estar  puramente  ligado  ao  “saber  para  que  serve”,  mas  quando  apresentamos 

utilidades àquilo que ensinamos e pontes de ligação entre o abstrato e o concreto, ensinamos 

uma  Matemática  possivelmente  mais  capaz  de  despertar  interesse  aos  estudantes,  revelar 

identidades e afinidades e por consequência, construir um conhecimento mais sólido. 

A proposta deste trabalho é a apresentação de alguns conteúdos do currículo escolar de 

matemática do ensino médio, dando atenção especial às demonstrações das propriedades e dos 

teoremas  pertinentes,  para  em  seguida,  apresentar  uma  aplicação  desses  conteúdos  em  um 

contexto “extramatemático” ou “extraescolar”. A escolha da aplicação na teoria dos códigos 

corretores  de  erros  deu-se  em  virtude  de  este  ser  um  assunto  pouco  conhecido  ou  discutido 

entre  os  jovens,  porém,  muito  presente  em  recursos  tecnológicos  utilizados  pelos  mesmos, 

uma vez que as telecomunicações e os dispositivos de armazenamento presentes no nosso dia 

a dia, muito mais entre os jovens, não seriam confiáveis nem eficientes sem a utilização dessa 

teoria. Sendo assim, procuramos neste trabalho, apresentar os conceitos básicos dessa teoria, 

 
 
 
 
 
15 

com uma preocupação maior em atrair a atenção dos estudantes à disciplina de matemática, a 

partir do pressuposto do conhecimento de uma das suas vastas aplicações. 

Cabe salientar que o material apresentado neste trabalho é primeiramente direcionado 

aos  professores  ou  pessoas  que  tenham  um  conhecimento  prévio  de  matemática  além  das 

operações fundamentais. Não é necessário que os alunos do ensino médio saibam demonstrar 

os teoremas apresentados no capítulo referente à teoria dos códigos corretores de erros, sendo 

mais  interessante,  a  partir  dos  conceitos  apresentados  pelos  professores  sobre  essa  teoria, 

saberem  operar  com  matrizes,  determinantes,  polinômios  e,  conhecendo  suas  propriedades, 

desenvolverem  com  mais  habilidades  os  cálculos  e  argumentações  relacionadas  com  esses 

assuntos. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
16 

1  MOTIVAÇÃO E ABORDAGEM DO TRABALHO 

1.1  POR QUE ESTUDAR MATRIZES, DETERMINANTES E POLINÔMIOS? 

O  questionamento  acima  fez  parte  da  minha  vida  em  pelo  menos  duas  ocasiões 

diferentes:  a  primeira  enquanto  eu  ainda  era  aluno  do  ensino  médio  e  presenciava  meu 

professor  destrinchar  matrizes  enormes  de  ordem  5  ou  6,  determinando  cada  um  dos  seus 

elementos através de uma sentença que aparecia em função dos “is” e dos “jotas”. Por vezes, 

recebia  listas  de  exercícios  nas  quais  volta  e  meia  aparecia  para  ser  calculado  um 

determinante  de  uma  matriz  quadrada  de  ordem  5  através  da  regra  de  Laplace,  ou  ainda 

polinômios de graus elevados, dos quais tinha que determinar o quociente e o resto ou ainda 

encontrar as raízes reais. Na condição de aluno, resolvia essas atividades, mas não sabia para 

o  que  serviam.  Por  vezes  imaginava  que  eram  caprichos  matemáticos  que  serviam 

simplesmente para treinar habilidades em multiplicar ou dividir números reais. Saí do ensino 

médio sem saber para o que serviam as matrizes, os determinantes e os polinômios. Por vezes 

encontrava  alguma  aplicação,  porém,  sempre  dentro  da  própria  matemática.  Na  segunda 

situação  na  qual  deparei-me  com  o  questionamento  acima,  anos  já  tinham  passado  e  eu 

encontrava-me na posição de professor e ouvia dos meus alunos as mesmas indagações que 

no  meu  tempo  de  ensino  médio,  fazia  a  mim  mesmo  ou  a  amigos  ou  ainda  ao  próprio 

professor: para que servem as matrizes, determinantes e os polinômios? Quando eu terminar o 

ensino médio, aonde irei usar isso? Onde aplicarei esses conhecimentos no meu trabalho? A 

primeira pergunta seguramente sou capaz de responder, pois o objetivo deste trabalho, por si 

só  traz  a  resposta.  A  segunda  pergunta,  se  interpretada  com  um  olhar  matemático,  também 

pode  ser  respondida:  toda  vez  que  um  computador  for  utilizado,  um  telefone  celular  ou 

qualquer  canal  de  comunicação,  implicitamente  estarão  sendo  usadas  as  matrizes,  os 

polinômios e tantos outros conhecimentos matemáticos. Já a terceira pergunta não possui uma 

resposta formal,  pois  tal  resposta está condicionada à atividade profissional que o  estudante 

irá executar no futuro. 

Certamente  essas  dúvidas  não  estão  presentes  somente  nos  conteúdos  de  matrizes, 

determinantes  e  polinômios,  porém,  tendo  em  vista  a  grande  quantidade  de  cálculos  que 

 
 
 
 
 
 
17 

geralmente  são  utilizados  na  resolução  de  problemas  referentes  a  esses  conteúdos,  embora 

elementares, é plausível que com maior frequência ouçamos essas indagações ao ensiná-los. 

Criar  pontes  de  acesso  entre  os  conteúdos  matemáticos  e  as  aplicações  práticas 

certamente constitui uma estratégia para o ensino desta disciplina. O ato de “saber para que 

serve” pode ser motivador ao aluno e, caso alguém sonhe em ser engenheiro ou trabalhar com 

informática  ou  áreas  afins,  certamente  terá  subsídios  para  o  seu  direcionamento.  Uma 

matemática que seja trabalhada de modo a associar os conteúdos estudados às aplicações nos 

fenômenos vivenciados  pelos  alunos é uma matemática  contextualizada. A contextualização 

segundo  Fogaça  “é  o  ato  de  vincular  o  conhecimento  à  sua  origem  e  à  sua  aplicação” 

(FOGAÇA,  2012).  As  ações  pedagógicas  no  ensino  da  matemática  devem  apresentar 

preocupações com a contextualização. Reconhecemos que quanto mais abstrato for o conceito 

matemático  a  ser  estudado,  mais  dificultosa  será  sua  contextualização,  porém,  a  abstração 

excessiva  inerente  a  alguns  conteúdos  da  matemática  não  constitui  entrave  algum  em  ações 

para  que  outros  conteúdos,  menos  abstratos,  sejam  facilmente  contextualizados  e,  por 

conseguinte  tornem-se  mais  atrativos  e  mais  facilmente  compreendidos.  Parece-nos  que  a 

teoria  e  a  prática  caminham  em  vias  divergentes  nas  quais,  à  medida  que  progredimos  nos 

conteúdos  matemáticos  presentes  nos  currículos  escolares,  mais  distantes  ficam  a  teoria  e  a 

prática. D’Ambrósio diz: “Do ponto de vista de motivação contextualizada, a matemática que 

se ensina hoje nas escolas é morta. Poderia ser tratada como fato histórico” (D’ AMBROSIO, 

2012,  p  29).  É  perceptível  esse  distanciamento  quando  observamos  os  livros  didáticos 

adotados pelas escolas de nível médio, nos quais são frequentes as listas de exercícios no fim 

de  cada  capítulo,  nas  quais  aparecem:  “calcule”,  “determine”,  “encontre”  etc.,  sem  nenhum 

elo entre os exercícios e as aplicações. Acerca da contextualização, Meyer et al dizem: 

A  maioria  das  pessoas  não  consegue  relacionar  a  Matemática  nem  com  as  outras 
ciências  e  muito  menos  com  situações  de  seus  cotidianos,  porque  foi  criado  um 
universo  à  parte,  ou  seja,  para  elas,  a  Matemática  não  está  presente  em  outros 
contextos (MEYER et al, 2011, p 24). 

Ou  ainda,  segundo  Meyer  et  al,  na  educação  básica,  a  matemática  “chega  para  os 

alunos neutra e descontextualizada, com pouca ou nenhuma relação com a realidade de quem 

está na sala de aula: professores e alunos” (MEYER et al, 2011, p. 53). 

Particularmente,  reconhecemos  a  necessidade  da  resolução  de  exercícios  do  tipo 

“calcule”,  “determine”  etc.,  porém,  para  um  aprendizado  consolidado  de  matemática,  há 

necessidade de problemas que estimulem o pensar, que sirvam de ponte entre teoria e prática, 

 
 
 
 
 
 
18 

que  suscitem  o  aluno  à  busca  por  respostas  tendo  como  referência  os  fenômenos  da  vida 

extraescolar.  

A solução de problemas baseia-se na apresentação de situações abertas e sugestivas 
que  exijam  dos  alunos  uma  atitude  ativa  ou  um  esforço  para  buscar  suas  próprias 
respostas,  seu  próprio  conhecimento.  O  ensino  baseado  na  solução  de  problemas 
pressupõe  promover  nos  alunos  o  domínio  de  procedimentos,  assim  como  a 
utilização dos conhecimentos disponíveis, para  dar resposta a situações  variáveis e 
diferentes (POZO; ECHEVERRÍA, 1988, p 9). 

Trazer a realidade cotidiana para o interior de uma sala de aula pode representar um 

avanço  pedagógico  na  educação  matemática,  pois,  à  medida  que  o  aluno  percebe  a 

necessidade  de  aprender  matemática  para  lidar  com  os  fenômenos  da  vida  real,  por  mais 

abstratos que sejam esses conteúdos, provavelmente melhor será o aprendizado. O interior de 

uma  sala  de  aula  de  matemática  deve  conter  as  realidades  vividas  pelo  aluno  quando  estão 

fora  da  escola,  assim  como  no  exterior  da  sala  de  aula  o  aluno  deve  vivenciar  os 

conhecimentos matemáticos adquiridos. Para D’Ambrosio: 

Particularmente  em  matemática,  parece  que  há  uma  fixação  na  ideia  de  haver 
necessidade  de  um  conhecimento  hierarquizado,  em  que  cada  degrau  é  galgado 
numa  certa  fase  da  vida,  com  atenção  exclusiva  durante  horas  de  aula,  como  um 
canal  de  televisão  que  se  sintoniza  para  as  disciplinas  e  se  desliga  acabada  a  aula. 
Como  se  fossem  duas  realidades  disjuntas,  a  da  aula  e  a  de  fora  da  aula 
(D’AMBROSIO, 2012, p. 76). 

A  citação  acima  evidencia  a  disparidade  existente  entre  o  mundo  dentro  e  o  mundo 

fora da sala de aula. Um dos desafios da educação, em  especial a matemática, é justamente 

colocar  a  seu  favor  a  prática  matemática  vivenciada  de  forma  explícita  ou  implícita  pelos 

alunos em seu cotidiano. 

1.2  A MOTIVAÇÃO PARA A REALIZAÇÃO DO TRABALHO 

Em relação ao exposto no tópico anterior, fomos movidos a estabelecer um  canal  de 

diálogo  com  os  alunos  de  três  turmas  do  3º  ano do  ensino  médio  de  uma  escola  pública  de 

tempo  integral  no  Município  de  Porto  Velho-RO,  para  obter  deles  informações  acerca  do 

aprendizado  dos  conteúdos  de  matrizes,  determinantes  e  polinômios.  Os  resultados  obtidos 

são apresentados a seguir: 

Questionados  sobre  terem  estudado  os  conteúdos  de  matrizes,  determinantes  e 

polinômios, tivemos unanimidade em respostas afirmativas. 

 
 
 
 
 
 
 
 
 
19 

O  Gráfico  1  apresenta  os  resultados  obtido  sobre  o  desempenho  dos  mesmos  na 

resolução de atividades que envolvam as operações com matrizes: 

Gráfico 1: Desempenho dos alunos em operações com matrizes 

27%

Bom desempenho

Pouco Desempenho

73%

O Gráfico 2 apresenta os resultados obtidos acerca do conhecimento das propriedades 

operacionais das matrizes: 

Gráfico  2:  Conhecimento  e  aplicação  das  propriedades  operacionais 
das matrizes 

3%

Sabe utilizar as 
propriedades

26%

Sabe algumas propriedades

71%

desconhece as 
propriedades operacionais

O  Gráfico  3  apresenta  os  resultados  obtido  sobre  o  desempenho  dos  mesmos  na 

resolução de atividades que envolvam as operações com polinômios: 

 
 
 
 
 
 
 
 
 
 
20 

Gráfico 3: Desempenho dos alunos em operações com polinômios 

16%

14%

70%

Bom desempenho

Pouco desempenho

Nenhum desempenho

O Gráfico 4 apresenta os resultados obtidos acerca do conhecimento das propriedades 

operacionais dos polinômios: 

Gráfico  4:  Conhecimento  e  utilização  das  propriedades  operacionais 
dos polinômios 

9%

26%

65%

Conhece e sabe utilizar

Conhece pouco e utiliza 
algumas

Não conhece

Em relação ao cálculo de determinantes de matrizes, questionados sobre as habilidades 

na resolução, as respostas obtidas são apresentadas no Gráfico 5: 

 
 
 
 
 
 
 
 
 
 
 
 
 
21 

Gráfico  5:  Domínio  de  técnicas  na  resolução  de  determinantes  de 
matrizes 

6%

14%

30%

50%

Domínio de técnicas para 
resolução de determinantes 
de matrizes de ordem 1 ou 2

Domínio de técnicas para 
resolução de determinantes 
de matrizes de ordem 1, 2 ou 
3
Domínio de técnicas para 
resolução de determinantes 
de matrizes de qualquer 
ordem
Não sabe calcular 
determinantes de matrizes

Em relação ao conhecer e saber utilizar as propriedades dos determinantes, obtivemos 

os resultados apresentados no Gráfico 6: 

Gráfico  6:  Conhecimento  e  utilização  das  propriedades  dos 
determinantes 

11%

19%

70%

Conhece e utiliza 
perfeitamente

Conhece pouco e utiliza 
pouco

Desconhece

Perguntamos  ainda  aos  alunos  se  os  mesmos  sabiam  como  identificar  quando  uma 

matriz é invertível. As respostas obtidas são apresentadas no Gráfico 7: 

 
 
 
 
 
 
 
 
 
 
 
 
22 

Gráfico  7:  Habilidades  na  identificação  da  invertibilidade  de  uma 
matriz 

21%

79%

Sim, sei identificar

Não, não sei identificar

Perguntamos aos alunos se os mesmos conheciam alguma aplicação ou utilidade para 

as matrizes e os determinantes. Os resultados obtidos são apresentados no Gráfico 8: 

Gráfico  8:  Conhecimento  dos  alunos  sobre  a  aplicabilidade  dos 
conteúdos de matrizes e determinantes   

43%

Sim, conheço aplicações

Não conheço aplicações

57%

Perguntamos aos alunos se os mesmos conheciam alguma aplicação ou utilidade para 

o estudo dos polinômios. Os resultados obtidos são apresentados no Gráfico 9: 

 
 
 
 
 
 
 
 
 
 
 
Gráfico  9:  Conhecimento  dos  alunos  sobre  a  aplicabilidade  dos 
conteúdos de polinômios   

23 

12%

88%

Sim, conheço aplicações

Não conheço aplicações

Em  virtude  de  57%  dos  alunos  terem  respondido  afirmativamente  que  conhecem 

aplicações para as matrizes e determinantes, solicitamos que fossem informadas as aplicações 

que os mesmo conhecem acerca desses conteúdos. Os resultados obtidos são apresentados no 

Gráfico 10: 

Gráfico  10:  Áreas  de  aplicação  dos  conteúdos  de  matrizes  e 
determinantes, segundo os alunos 

12%

17%

Geometria analítica

Informática: computação 
gráfica e criptografia

71%

outros

É interessante observar que grande maioria dos alunos, mais precisamente 71% deles 

conhecem aplicações das matrizes e determinantes em geometria analítica, ou seja, conhecem 

uma  aplicação  da  matemática  dentro  da  própria  matemática.  Menos  de  30%  dos  alunos  já 

ouviram  falar de alguma aplicação desses conteúdos em  outra  área do conhecimento  ou  em 

algum fenômeno. 

 
 
 
 
 
 
 
24 

Em  um  último  questionamento,  solicitamos  aos  alunos  que  opinassem  a  respeito  da 

importância de conhecer a aplicabilidade dos conteúdos estudados em matemática, nas outras 

áreas  de  conhecimento  bem  como  em  situações  do  cotidiano.  Os  resultados  obtidos  são 

apresentados no Gráfico 11: 

Gráfico 11: Grau de importância sobre conhecer a aplicabilidade dos 
conteúdos estudados em matemática, segundo os alunos  

4%

9%

Muito importante

Pouco importante

Não opinaram

87%

Os  resultados  obtidos  através  do  diálogo  com  os  alunos  constituíram  um  fator 

motivador para a realização deste trabalho, uma vez que a proposta do mesmo é justamente 

atender  parte  da  necessidade  dos  estudantes  em  conhecer  as  aplicações  para  os  conteúdos 

estudados na disciplina de matemática no ensino médio. 

1.3  ABORDAGEM DOS CONTEÚDOS DE MATRIZES, DETERMINANTES E 

POLINÔMIOS NO LIVRO DIDÁTICO. 

Além de conter aplicações para os conteúdos de matrizes, determinantes e polinômios, 

o  presente  trabalho  procura  apresentar  a  demonstração  da  validade  de  cada  uma  das 

propriedades apresentadas e dos teoremas enunciados. Reconhecemos que a complexidade de 

alguma dessas demonstrações foge ao nível de conhecimento matemático praticado hoje  em 

dia,  em  especial  no  ensino  público,  porém,  mesmo  assim  julgamos  necessário  que  essas 

demonstrações se fizessem presentes. 

Verificamos  que  nos  livros  didáticos  atualmente  adotados  nas  escolas  públicas,  as 

demonstrações estão deixando de figurar,  apenas as  propriedades  operacionais  das matrizes, 

determinantes  e  dos  polinômios  são  apresentadas.  É  sugerido  ao  aluno  que  verifique  a 

 
 
 
 
 
 
 
 
 
25 

validade dessas propriedades através da análise de casos particulares. As análises matemáticas 

obtidas  através  de  casos  particulares  são  extremamente  importantes,  pois  a  partir  dessas 

análises  é  possível  que  os  alunos  obtenham  inferências  e,  por  conseguinte,  a  capacidade  de 

generalização,  porém,  o  fato  de  uma  propriedade  ser  verificada  em  casos  particulares,  pode 

não  garantir  a  sua  validade  para  uma  infinidade  de  casos.  Um  exemplo  bem  simples  disso 

consiste  em  um  aluno  que  desconheça  as  propriedades  operacionais  das  matrizes  e  deseje 

verificar se a multiplicação de matrizes goza da propriedade comutativa. Para tanto, escolhe 

ao  acaso  duas  matrizes  quadradas  de  ordem  2:  𝐴 =  

operações 𝐴 ∙ 𝐵 e 𝐵 ∙ 𝐴 e obtém os seguintes resultados: 

1 −1
2
0

3 2
0 1

   e  𝐵 =  

     e  efetua  as 

𝐴 ∙ 𝐵 =  

𝐵 ∙ 𝐴 =  

1 −1
0
2
3 2
0 1

  ∙  

3 2
0 1
1 −1
2
0

  ∙  

  =  

  =  

3 + 0 2 − 1
0 + 0 0 + 2
3 + 0 −3 + 4
0 + 2
0 + 0

  =  

3 1
0 2

  =  

3 1
0 2

O aluno observa que  𝐴 ∙ 𝐵 = 𝐵 ∙ 𝐴. É levantada  a suspeita de que a multiplicação de 

matrizes é comutativa. 

Em uma nova tentativa, o aluno escolhe ao acaso duas outras matrizes, com finalidade 

de validar sua suspeita:  𝐶 =  

5
2
0 −3

obtém os seguintes resultados: 

  e  𝐷 =  

   e  efetua as operações  𝐶 ∙ 𝐷 e  𝐷 ∙ 𝐶  e 

2
1
0 −2

𝐶 ∙ 𝐷 =  

𝐷 ∙ 𝐶 =  

5
2
0 −3
2
1
0 −2

  ∙  

  ∙  

2
1
0 −2
5
2
0 −3

  =  

  =  

10 + 0 5 − 4
0 + 6
0 + 0
10 + 0 4 − 3
0 + 6
0 + 0

  =  

  =  

10 1
6
0
10 1
6
0

Novamente os resultados obtidos são iguais, o que leva o aluno, tendo como base os 

casos particulares que analisou, a inferir que a multiplicação de matrizes goza da propriedade 

comutativa, generalizando esse resultado equivocadamente como veremos em 2.2.3. Portanto, 

embora  a  análise  de  casos  particulares  seja  uma  ferramenta  útil  na  matemática  para  que  os 

alunos  busquem  por  padrões  e  façam  conjecturas,  essa  ferramenta  não  pode  ser  utilizada 

como  verdade  absoluta.  Em  consequência  disso,  justifica-se  a  necessidade  da  presença  das 

demonstrações das propriedades e teoremas pertinentes a cada assunto matemático abordado 

nos livros didáticos, bem como a prática dessa ação em sala de aula. 

Outro  ponto  que  observamos  em  alguns  livros  didáticos  adotados  pelas  escolas  é  a 

abordagem  dos  determinantes  como  uma  mera  operação  matemática  a  ser  realizada  com  os 

elementos de uma matriz. Assim, os alunos desconhecem, por exemplo, que o determinante 

de  uma  matriz  real  é  uma  função  com  domínio  no  conjunto  das  matrizes  reais  quadradas  e 

contradomínio  no  conjunto  dos  números  reais,  com  isso,  perdem  a  oportunidade  de 

 
   
   
   
   
26 

associarem esse conteúdo, com outros conteúdos vistos anteriormente, como a caracterização 

de  uma  função  como  injetiva,  sobrejetiva,  bijetiva,  existência  da  inversa  ou  composição  de 

funções. 

Cabe salientar ainda que a determinação da matriz inversa de uma matriz 𝐴 quadrada 
de  ordem  𝑛,  seja  por  operações  elementares  sobre  as  linhas  de  uma  matriz    𝐴 𝐼𝑛    ou  ainda 
através  do  produto  da  matriz  adjunta  de  𝐴  pelo  inverso  multiplicativo  do  determinante  da 

matriz  𝐴,  vem  perdendo  espaço  nos  livros  didáticos,  tirando  com  isso,  a  oportunidade  dos 

alunos aprenderem sobre esses conceitos que são fundamentais no estudo das matrizes. 

Com relação aos conteúdos sobre polinômios, não foi encontrado texto algum adotado 

no ensino médio que trate sobre a interpolação de Lagrange. 

1.4  A ESCOLHA DA APLICAÇÃO DAS MATRIZES, DETERMINANTES E 

POLINÔMIOS NOS CÓDIGOS CORRETORES DE ERROS 

Diante  dos  resultados  obtidos  nos  diálogos  com  os  alunos  das  turmas  de  3º  ano  do 

ensino  médio,  além  das  observações  comentadas  anteriormente  acerca  dos  livros  didáticos 

adotados pelas escolas, fomos motivados a elaborar um material que buscasse suprir as faltas 

de  demonstrações  da  validade  das  propriedades  enunciadas  nesses  livros,  bem  como  a 

ausência  dos  principais  teoremas  de  cada  um  desses  conteúdos  abordados,  além  da 

apresentação  de  alguma  aplicação  desses  conteúdos  em  alguma  área  do  conhecimento  ou 

algum fenômeno do cotidiano dos alunos. Esse fato levou-nos aos códigos corretores de erros, 

uma vez que essa teoria é vastamente utilizada em meios de comunicação e equipamentos de 

armazenamento  de  informações  que,  frequentemente,  são  utilizados  no  nosso  cotidiano,  em 

especial  por  grande  parte  dos  jovens  que  nos  dias  atuais  fazem  uso  constante  de  recursos 

tecnológicos  de  comunicação  e  armazenamento  tais  como  telefones  celulares,  tablets, 

computadores, entre outros. 

É perceptível nos dias atuais, que a sociedade, numa velocidade muito rápida, tem sido 

imersa em uma realidade digital. A tecnologia desenvolvida pelas engenharias tem avançado a 

passos rápidos e esses fatores suscitam às novas ações educacionais, capazes de aproveitar as 

novas  tecnologias  a  favor  de  um  ensino/aprendizagem  com  melhor  qualidade  e  capaz  de 

preparar o aluno para ser atuante no meio social. Para Henriques (2010): 

As mudanças sociais e o rápido desenvolvimento tecnológico que se têm verificado 
na sociedade conduzem a uma alteração nas suas necessidades e, consequentemente, 
nas  competências  que  é  preciso  desenvolver  nos  alunos  em  áreas  fundamentais 

 
 
 
 
27 

como a da Matemática. Existe actualmente a convicção de que os alunos precisarão 
de um conjunto  muito  vasto  de competências  matemáticas para desempenhar, com 
eficiência,  funções  na  sociedade  actual.  De  acordo  com  diversos  documentos  de 
referência  na área da educação matemática, ao nível do ensino básico e secundário 
[...],  os  alunos  devem  ser  capazes  de:  (i)  desenvolver  uma  profunda  compreensão 
dos conceitos e princípios  matemáticos; (ii)  raciocinar com rigor e comunicar com 
clareza;  (iii)  reconhecer  as  aplicações  matemáticas  no  mundo  que  os  rodeia  e 
enfrentar os problemas matemáticos com confiança; (iv) aprender a investigar, por si 
próprios, as ideias matemáticas; e (v) usar experiências e observações para formular 
conjecturas. (p 4) 

Em virtude da teoria dos códigos corretores de erros estar inserida em grande parte dos 

recursos tecnológicos utilizados pelos alunos, optamos por trabalhar esse tema. Muitos de nós 

utilizamos recursos tecnológicos disponíveis na atualidade, sem darmos conta da matemática 

que existe por trás do bom funcionamento de cada um deles. Ao enviarmos uma mensagem 

no  celular  ou  através  de  e-mail,  por  exemplo,  o  que  nos  dá  garantia  que  o  destinatário  irá 

receber  a  mensagem  tal  qual  a  enviamos?  O  que  garante  a  fidelidade  entre  a  mensagem 

enviada  e  a  recebida?  Quem  de  nós  ao  digitar  uma  palavra  errada  em  uma  mensagem  de 

celular  não  percebeu  que  o  próprio  equipamento  sugere  uma  correção  prévia,  conforme  a 

figura 1? 

Figura 1: Telefone celular 

Fonte: Foto retirada pelo autor 

Encontrando nesses recursos tecnológicos utilizados pela sociedade atual a matemática 

necessária das matrizes, determinantes e polinômios aplicada nos códigos corretores de erros, 

vimos  uma  oportunidade  útil  de  socializar  esses  conhecimentos  e  propiciar  aos  alunos  uma 

forma diferenciada na abordagem dos assuntos estudados por eles. 

Entre os conteúdos de matrizes, determinantes e polinômio, pertinentes ao currículo do 

ensino  médio,  e  a  teoria  dos  códigos  corretores  de  erros,  existe  um  elo  que  consiste  no 

conhecimento das estruturas algébricas elementares. As estruturas algébricas elementares não 

pertencem  ao  rol  de  conteúdos  presentes  nos  currículos  de  matemática  da  educação  básica. 

 
 
 
  
 
 
 
 
 
 
 
 
 
 
28 

Nos livros didáticos do ensino fundamental, os conjuntos numéricos não são apresentados não 

como  estruturas  algébricas  elementares,  mas  as  suas  propriedades,  em  geral,  definem  essas 

estruturas. Por exemplo, os livros do 7º ano do ensino fundamental apresentam o conjunto ℤ 

dos  números  inteiros,  como  sendo  um  conjunto  no  qual  a  adição  está  definida  e  goza  das 

seguintes  propriedades:  comutatividade,  associatividade,  elemento  neutro  aditivo,  elemento 

simétrico.  A  apresentação  dessas  propriedades  no  livro  didático  caracteriza  o  conjunto  ℤ 

como sendo um grupo aditivo, ademais, por ser apresentada a propriedade comutativa, então, 

temos ℤ como um grupo abeliano. Ao introduzir a multiplicação no conjunto ℤ dos números 

inteiros,  os  livros  didáticos  apresentam  as  propriedades  comutativa,  associativa,  elemento 

neutro multiplicativo e a distributividade em relação à adição, o que caracteriza  ℤ como um 

anel  ou,  mais  ainda,  um  anel  comutativo  com  unidade.  Posteriormente,  mais  precisamente 

quando  se  estudam  equações  em  ℤ,  é  apresentado  aos  alunos  sentenças  do  tipo  3𝑥 = 0  ⇒

  𝑥 = 0 , que, em outras palavras, significa que no conjunto ℤ não existem divisores próprios 

de zero, logo, ℤ é um domínio de integridade. 

Quando o conjunto ℚ dos números racionais e ℝ dos números reais são apresentados, 

além de serem mencionadas para ℚ e ℝ todas as propriedades anteriormente enumeradas no 

conjunto  ℤ,  é  enunciado  ainda  que  todo  elemento  não  nulo  desses  conjuntos  possui  um 

inverso multiplicativo, o que define ℚ e ℝ como corpos. Sendo assim, os conceitos de grupo, 

anéis,  domínios  de  integridade  e  corpos,  que  constituem  parte  das  estruturas  algébricas 

elementares, vão sendo construídos implicitamente no aprendizado dos alunos. Portanto, não 

encaramos  o  “elo”  das  estruturas  algébricas  elementares  como  sendo  um  obstáculo  para  o 

acesso à teoria dos códigos corretores de erros e, em consequência disso, apresentamos esses 

conceitos neste trabalho. 

 
 
 
 
 
 
 
 
 
 
 
29 

2  MATRIZES 

2.1  DEFINIÇÃO DE MATRIZES REAIS – ALGUNS CONCEITOS 

Sendo  𝑚, 𝑛 ∈ ℕ,  definimos  uma  matriz  real  de  ordem  𝑚  por  𝑛  como  uma  tabela 

formada por 𝑚 ∙ 𝑛 elementos do conjunto ℝ agrupados em 𝑚 linhas e 𝑛 colunas. 

Ao  elemento  que  ocupa  a  𝑖 − é𝑠𝑖𝑚𝑎  linha  e  𝑗 − é𝑠𝑖𝑚𝑎  coluna  de  uma  matriz  𝐴, 

representamos por 𝑎𝑖𝑗 , com 1 ≤ 𝑖 ≤ 𝑚 e 1 ≤ 𝑗 ≤ 𝑛. 

Cada elemento 𝑎𝑖𝑗  da matriz 𝐴 é denominado entrada da matriz. 

Exemplo: 

𝐴 =  

2 −1
1
 2

2

0
−3   é a representação de uma matriz de ordem  2 × 3. Observemos, 

por exemplo, que o elemento  −3  ocupa  a posição  que corresponde  à interseção da segunda 

linha com a terceira coluna, portanto −3 = 𝑎23. 

Uma  matriz  𝐴  de  ordem  𝑚  por  𝑛  é  genericamente 
𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33
⋮
⋮
⋮
𝑎𝑚1 𝑎𝑚2 𝑎𝑚3

… 𝑎1𝑛
… 𝑎2𝑛
… 𝑎3𝑛
⋱
⋮
… 𝑎𝑚𝑛  

 ou ainda 𝐴 =  𝑎𝑖𝑗  

𝑚 ×𝑛

𝐴 =

 ou, quando a ordem da matriz for 

representada  por 

conhecida, podemos representar apenas por 𝐴 =  𝑎𝑖𝑗  . 

À matriz cuja ordem seja 1 × 𝑛 denominamos matriz linha e à matriz cuja ordem seja 

𝑚 × 1 denominamos matriz coluna. 

Exemplos: 

𝐴 =  −4  3
2

1

9

  e 𝐵 =  

3

−

4
0
𝜋

  são, respectivamente, matriz linha e matriz coluna. 

À matriz 𝐴 =  𝑎𝑖𝑗   de ordem 𝑚 por 𝑛, que possui 𝑎𝑖𝑗 = 0 para todo 𝑖 ∈  1, 2, … , 𝑚  e 

todo 𝑗 ∈  1, 2, … , 𝑛 , denominamos 𝑚𝑎𝑡𝑟𝑖𝑧 𝑛𝑢𝑙𝑎. 

Dada uma matriz  𝐴 =  𝑎𝑖𝑗   de ordem 𝑚 por 𝑛, definimos a matriz oposta de 𝐴 como 

sendo a matriz −𝐴 =  −𝑎𝑖𝑗  , de mesma ordem de 𝐴. 

 
 
 
 
 
 
 
 
 
 
     
     
 
 
 
 
Se em uma matriz 𝐴 =  𝑎𝑖𝑗   de ordem 𝑚 × 𝑛 tivermos 𝑚 = 𝑛, então dizemos que 𝐴 é 

uma matriz quadrada de ordem 𝑛. 

30 

Exemplo: 

𝐴 =  

0
−  5
3
𝑒

−5 𝜋
1

2
−2 1

0

  é quadrada de ordem 3. 

Em uma matriz quadrada 𝐴 =  𝑎𝑖𝑗  , de ordem 𝑛, os elementos 𝑎𝑖𝑗 , com 𝑖 = 𝑗 formam 

a diagonal principal. 

À matriz 𝐴 =  𝑎𝑖𝑗  , quadrada, de ordem 𝑛, onde 𝑎𝑖𝑗 = 0 quando 𝑖 ≠ 𝑗, denominamos 

matriz diagonal. 

Exemplo: 

−5

𝐴 =  

0 −

0

0
2
3
0

0

0

7

Uma matriz diagonal de ordem 𝑛, cujos elementos da diagonal principal forem todos 

iguais a 1 é denominada matriz identidade de ordem 𝑛 e é representada por 𝐼𝑛 . 

Exemplo: 

𝐼3 =  

1 0 0
0 1 0
0 0 1

À  matriz  𝐴 =  𝑎𝑖𝑗  ,  quadrada  de  ordem  𝑛, que  possui  os  elementos  𝑎𝑖𝑗 = 0  quando 

𝑖 < 𝑗 (ou 𝑖 > 𝑗) denominamos matriz triangular inferior (ou matriz triangular superior). 

Exemplos: 

𝐴 =  

2
0
1 −5
1
3

2

0
0
−3

   e  𝐵 =  

−7 6
0
0

2
2 −1
4
0

   𝐴  e  𝐵  são,  respectivamente,  matriz 

triangular inferior e matriz triangular superior, ambas de ordem 3. 

O símbolo ℳ(𝑚, 𝑛) representará o conjunto de todas as matrizes de ordem 𝑚 por 𝑛. 

2.1.1 

Igualdade de matrizes 

Dadas  duas  matrizes  𝐴 =  𝑎𝑖𝑗    e  𝐵 =  𝑏𝑖𝑗  ,  pertencentes  a  ℳ(𝑚, 𝑛),  ou  seja,  de 

mesma  ordem,  dizemos  que  𝐴  e  𝐵  são  iguais,  ou  ainda  𝐴 = 𝐵,  quando  𝑎𝑖𝑗 = 𝑏𝑖𝑗   para  todo 

𝑖 ∈  1, 2, … , 𝑚  e todo 𝑗 ∈  1, 2, … , 𝑛 . 

 
  
  
 
 
 
31 

2.2  OPERAÇÕES COM MATRIZES 

2.2.1  Adição de matrizes 

Definimos a operação de adição em ℳ(𝑚, 𝑛) como sendo uma função de ℳ(𝑚, 𝑛) ×

ℳ(𝑚, 𝑛)  em  ℳ 𝑚, 𝑛 , que  a  cada  par   𝐴, 𝐵  ∈ ℳ(𝑚, 𝑛) × ℳ(𝑚, 𝑛)  faz  corresponder  a 

matriz  𝐴 + 𝐵 = 𝐶 ∈ ℳ(𝑚, 𝑛),  de  maneira  que  𝑎𝑖𝑗 + 𝑏𝑖𝑗 = 𝑐𝑖𝑗   para  todo  𝑖 ∈  1, 2, … , 𝑚   e 

todo 𝑗 ∈  1, 2, … , 𝑛 . 

Exemplo: 

Sejam  as  matrizes  𝐴 =  

−1 0
0

5
2 −3

   e  𝐵 =  

temos: 

𝐴 + 𝐵 =  

−1 0
0

5
2 −3

  +  

0
2 −1

4 −3
4

  =  

−1 + 0
0 + 2

0
2 −1

4 −3
4

   pertencentes  a  ℳ(2,3),  

0 + 4

5 +  −3 
2 +  −1  −3 + 4

  =  

=  

−1 4 2
1 1
2

  = 𝐶 ∈ ℳ 2,3                                                                                     

Propriedades da adição de matrizes 

Sejam 𝐴, 𝐵 e 𝐶 matrizes pertencentes a ℳ(𝑚, 𝑛), temos: 

I) Propriedade associativa da adição: 𝐴 +  𝐵 + 𝐶  =  𝐴 + 𝐵  + 𝐶 

II) Propriedade comutativa da adição: 𝐴 + 𝐵 = 𝐵 + 𝐴 

III) Elemento Neutro da adição: 𝐴 + 0 = 0 + 𝐴 = 𝐴, onde 0 significa a matriz nula 

IV) 𝐴 +  −𝐴  = −𝐴 + 𝐴 = 0, onde – 𝐴 representa a matriz oposta de 𝐴. 

Demonstrações: 

I) Dadas 𝐴 = [𝑎𝑖𝑗 ], 𝐵 = [𝑏𝑖𝑗 ] e 𝐶 = [𝑐𝑖𝑗 ] matrizes pertencentes a ℳ(𝑚, 𝑛), temos: 

𝐴 +  𝐵 + 𝐶  =  𝑎𝑖𝑗   +  𝑏𝑖𝑗 + 𝑐𝑖𝑗   = [𝑎𝑖𝑗 + (𝑏𝑖𝑗 + 𝑐𝑖𝑗 )] = [(𝑎𝑖𝑗 + 𝑏𝑖𝑗 ) + 𝑐𝑖𝑗 ] =   

= [𝑎𝑖𝑗 + 𝑏𝑖𝑗 ] +  𝑐𝑖𝑗   =  𝐴 + 𝐵  + 𝐶    (utilizamos  a  associatividade  da  adição  de  números 

reais) 

II) Dadas 𝐴 e 𝐵 matrizes pertencentes a ℳ(𝑚, 𝑛), temos: 

𝐴 + 𝐵 =  𝑎𝑖𝑗   +  𝑏𝑖𝑗   =  𝑎𝑖𝑗 + 𝑏𝑖𝑗   =  𝑏𝑖𝑗 + 𝑎𝑖𝑗   =  𝑏𝑖𝑗   +  𝑎𝑖𝑗   = 𝐵 + 𝐴 

(Utilizamos 

a 

comutatividade da adição de números reais) 

III) Seja 𝐴 uma matriz pertencente a ℳ(𝑚, 𝑛) e 0 a matriz nula de ℳ 𝑚, 𝑛 , temos: 

𝐴 + 0 =  𝑎𝑖𝑗   + 0 =  𝑎𝑖𝑗 + 0  =  𝑎𝑖𝑗   = 𝐴 =  0 + 𝑎𝑖𝑗   = 0 +  𝑎𝑖𝑗   = 0 + 𝐴  

 
 
 
 
 
 
 
32 

IV) Seja 𝐴 uma matriz pertencente a ℳ(𝑚, 𝑛) e – 𝐴 a sua matriz oposta. Temos: 

𝐴 +  −𝐴  =  𝑎𝑖𝑗   +  −𝑎𝑖𝑗   =  𝑎𝑖𝑗 +  −𝑎𝑖𝑗    =  𝑎𝑖𝑗 − 𝑎𝑖𝑗   = 0 =  −𝑎𝑖𝑗 + 𝑎𝑖𝑗   =  

= [−𝑎𝑖𝑗 ] +  𝑎𝑖𝑗   = −𝐴 + 𝐴  

2.2.2  Multiplicação de um escalar real por uma matriz 

Dada uma matriz 𝐴 =  𝑎𝑖𝑗   pertencente a ℳ(𝑚, 𝑛), definimos o produto da matriz 𝐴 

por um escalar 𝑘 ∈ ℝ, como a matriz 𝑘𝐴 =  𝑘𝑎𝑖𝑗  . 

Exemplo: 

Seja 𝐴 =  

−1 0
0

5
2 −3

  e 𝑘 = −5, temos: 

−5𝐴 = −5.  

−1 0
0

5
2 −3

  =  

−5. (−1) −5.0

−5.5

−5.0

−5.2 −5(−3)

  =  

0

5
0 −10

−25
15

Propriedades da multiplicação de uma matriz por um escalar real 

Sejam 𝐴 e 𝐵 matrizes pertencentes a ℳ(𝑚, 𝑛) e 𝑘1 e 𝑘2 escalares reais, temos: 
I) 𝑘1.  𝐴 + 𝐵  = 𝑘1. 𝐴 + 𝑘1. 𝐵 

II) (𝑘1 + 𝑘2). 𝐴 = 𝑘1. 𝐴 + 𝑘2. 𝐴 
III) 𝑘1.  𝑘2. 𝐴  =  𝑘1. 𝑘2 . 𝐴 

IV) 1𝐴 = 𝐴 

Demonstrações: 

Sejam 𝐴 e 𝐵 matrizes pertencentes a ℳ(𝑚, 𝑛) e 𝑘1, 𝑘2 ∈ ℝ, temos: 

I)  𝑘1 ∙  𝐴 + 𝐵  = 𝑘1 ∙  𝑎𝑖𝑗 + 𝑏𝑖𝑗   =  𝑘1 ∙  𝑎𝑖𝑗 + 𝑏𝑖𝑗    =  𝑘1 ∙ 𝑎𝑖𝑗 + 𝑘1 ∙ 𝑏𝑖𝑗   = 

= [𝑘1 ∙ 𝑎𝑖𝑗 ] +  𝑘1 ∙ 𝑏𝑖𝑗   = 𝑘1 ∙  𝑎𝑖𝑗   + 𝑘1 ∙  𝑏𝑖𝑗   = 𝑘1 ∙ 𝐴 + 𝑘1 ∙ 𝐵  

(utilizamos a distributividade da multiplicação em relação à adição de números reais) 

II) (𝑘1 + 𝑘2). 𝐴 =  𝑘1 + 𝑘2 .  𝑎𝑖𝑗   =   𝑘1 + 𝑘2 . 𝑎𝑖𝑗   =  𝑘1. 𝑎𝑖𝑗 + 𝑘2. 𝑎𝑖𝑗   = 

= [𝑘1. 𝑎𝑖𝑗 ] +  𝑘2. 𝑎𝑖𝑗   = 𝑘1 ∙  𝑎𝑖𝑗   + 𝑘2 ∙  𝑎𝑖𝑗   = 𝑘1 ∙ 𝐴 + 𝑘2 ∙ 𝐵   

(utilizamos a distributividade do produto em relação à adição de números reais) 

III) 𝑘1.  𝑘2. 𝐴  = 𝑘1 ∙  𝑘2.  𝑎𝑖𝑗    = 𝑘1 ∙  𝑘2 ∙ 𝑎𝑖𝑗   =  𝑘1 ∙  𝑘2 ∙ 𝑎𝑖𝑗    =   𝑘1 ∙ 𝑘2 . 𝑎𝑖𝑗   = 

=  𝑘1 ∙ 𝑘2  ∙  𝑎𝑖𝑗   =  𝑘1 ∙ 𝑘2  ∙ 𝐴  (utilizamos  a  associatividade  da  multiplicação  de  números 

reais) 

 
 
 
   
 
33 

IV) Sendo 𝐴 uma matriz pertencente a ℳ(𝑚, 𝑛), como 1 é um escalar real, então o produto 

1𝐴 está bem definido e 1𝐴 = 1 ∙  𝑎𝑖𝑗   =  1 ∙ 𝑎𝑖𝑗   =  𝑎𝑖𝑗   = 𝐴  

2.2.3  Multiplicação de matrizes 

A multiplicação de matrizes acontece mediante a seguinte condição: para que exista a 

multiplicação entre duas matrizes 𝐴 e 𝐵, é necessário que o número de colunas de 𝐴 seja igual 

ao número de linhas de 𝐵, ou seja, 𝐴 =  𝑎𝑖𝑗  

 e 𝐵 =  𝑏𝑖𝑗  

𝑛×𝑝

𝑚 ×𝑛

. Sendo 𝐶 o produto  𝐴 ∙ 𝐵, 

então a matriz 𝐶 é de ordem 𝑚 por 𝑝. 

De acordo com a condição acima, temos que a multiplicação de matrizes quadradas de 

mesma ordem é sempre possível. 

Passemos a definição formal da multiplicação de matrizes: 

Sejam  𝐴 =  𝑎𝑖𝑗  

  e  𝐵 =  𝑏𝑖𝑗  

𝑛×𝑝

𝑚 ×𝑛

  duas  matrizes,  definimos  o  produto  𝐴 ∙ 𝐵  como 

sendo a matriz 𝐶 =  𝑐𝑖𝑗  

𝑚 ×𝑝

  tal que 𝑐𝑖𝑗 =   (𝑎𝑖𝑘 . 𝑏𝑘𝑗 )

𝑛
𝑘=1

 ou seja,  

𝑐𝑖𝑗 = 𝑎𝑖1. 𝑏1𝑗 +𝑎𝑖2. 𝑏2𝑗 + ⋯ + 𝑎𝑖𝑛 . 𝑏𝑛𝑗      

Exemplo: 

Sejam as matrizes 𝐴 =  

  e 𝐵 =  

 . Vemos que 𝐴 é de ordem 

−1
3
1
2 −2 −4
0
0
5

0 −1
2
−2
3
1

3 × 3 e 𝐵 de ordem  3 × 2, ou seja, o número de colunas da matriz  𝐴 é igual ao número de 

linhas da matriz 𝐵, logo é possível o produto 𝐴. 𝐵 

Seja 𝐶 = 𝐴. 𝐵, temos: 

𝐶 =  

−1
3
1
2 −2 −4
0
0
5

  .  

0 −1
2
−2
3
1

  =   

−1.0 + 1.  −2  + 3.1

−1.  −1  + 1.2 + 3.3

=  

2.0 +  −2 .  −2  +  −4 . 1 2.  −1  +  −2 . 2 +  −4 . 3

  =   

5.0 + 0.  −2  + 0.1

5.  −1  + 0.2 + 0.3

=  

1 + 2 + 9

0 − 2 + 3
0 + 4 − 4 −2 − 4 − 12
0 + 0 + 0 −5 + 0 + 0

  =    

1
12
0 −18
0 −5

Propriedades da multiplicação de matrizes 

Desde  que  as  operações  sejam  possíveis,  a  multiplicação  de  matrizes  goza  das 

seguintes propriedades: 

 
 
 
 
   
 
34 

I) Distributividade à esquerda da multiplicação em relação à adição: 

𝐴.  𝐵 + 𝐶  = 𝐴. 𝐵 + 𝐴. 𝐶  

II) Distributividade à direita da multiplicação em relação à adição: 

 𝐴 + 𝐵 . 𝐶 = 𝐴. 𝐶 + 𝐵. 𝐶  

III) Associatividade: 

 𝐴. 𝐵 . 𝐶 = 𝐴. (𝐵. 𝐶)  

IV) Considerando 𝐴 uma matriz quadrada, temos  𝐴. 𝐼 = 𝐼. 𝐴 = 𝐴, onde 𝐼 é o elemento neutro 

da multiplicação (matriz identidade). 

Demonstrações: 

I) Sejam 𝐴 =  𝑎𝑖𝑗  

, 𝐵 =  𝑏𝑖𝑗  

𝑛×𝑝

𝑚 ×𝑛

 e 𝐶 =  𝑐𝑖𝑗  

𝑛×𝑝

 matrizes quaisquer, temos: 

𝑛

𝑛

𝐴.  𝐵 + 𝐶  =   𝑎𝑖𝑘 ∙  𝑏𝑘𝑗 + 𝑐𝑘𝑗   =   𝑎𝑖𝑘 ∙ 𝑏𝑘𝑗 + 𝑎𝑖𝑘 ∙ 𝑐𝑘𝑗   =

𝑘=1

𝑘=1

𝑛

=    𝑎𝑖𝑘 ∙ 𝑏𝑘𝑗

𝑘=1

𝑛
  +    𝑎𝑖𝑘 ∙ 𝑐𝑘𝑗
𝑘=1

  = 𝐴 ∙ 𝐵 + 𝐴 ∙ 𝐶 

II) Sejam 𝐴 =  𝑎𝑖𝑗  

, 𝐵 =  𝑏𝑖𝑗  

 e 𝐶 =  𝑐𝑖𝑗  

𝑛×𝑝

𝑚 ×𝑛

𝑚 ×𝑛

 matrizes quaisquer, temos: 

𝑛

𝑛

(𝐴 + 𝐵) ∙ 𝐶 =   𝑎𝑘𝑗 + 𝑏𝑘𝑗   ∙ 𝑐𝑖𝑘 =   𝑎𝑖𝑘 ∙ 𝑐𝑘𝑗 + 𝑏𝑖𝑘 ∙ 𝑐𝑘𝑗   =

𝑘=1

𝑘=1

𝑛

=    𝑎𝑖𝑘 ∙ 𝑐𝑘𝑗

𝑘=1

𝑛
  +    𝑏𝑖𝑘 ∙ 𝑐𝑘𝑗
𝑘=1

  = 𝐴 ∙ 𝐶 + 𝐵 ∙ 𝐶 

III) Sejam 𝐴 =  𝑎𝑖𝑗  

, 𝐵 =  𝑏𝑖𝑗  

𝑛×𝑝

𝑚 ×𝑛

 e 𝐶 =  𝑐𝑖𝑗  

𝑝×𝑞

 matrizes quaisquer, temos: 

𝑝

𝑝

𝑛

 𝐴. 𝐵 . 𝐶 =   𝐴. 𝐵 . 𝐶 

𝑖𝑗

=  (𝐴 ∙ 𝐵)𝑖𝑘 ∙ 𝑐𝑘𝑗 =      𝑎𝑖𝑙 ∙ 𝑏𝑙𝑘

  ∙ 𝑐𝑘𝑗 =

𝑛

𝑝

𝑘=1

𝑛

𝑘=1

𝑙=1

=   𝑎𝑖𝑙 ∙    𝑏𝑙𝑘 ∙ 𝑐𝑘𝑗

  =   𝑎𝑖𝑙 ∙  𝐵 ∙ 𝐶 𝑙𝑗 =  𝐴 ∙  𝐵 ∙ 𝐶  

= 𝐴 ∙ (𝐵 ∙ 𝐶)

𝑖𝑗

𝑙=1

𝑘=1

𝑙=1

IV) Seja 𝐴 =  𝑎𝑖𝑗  

𝑛

 e 𝐼𝑛  (𝑟𝑒𝑝𝑟𝑒𝑠𝑒𝑛𝑡𝑎𝑟𝑒𝑚𝑜𝑠 𝑎𝑝𝑒𝑛𝑎𝑠 𝑝𝑜𝑟 𝐼), temos: 

𝐴. 𝐼 =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑛

  .  

1 ⋯ 0
⋮
⋮
⋱
0 ⋯ 1

  =  

 
 
 
 
 
 
 
 
 
=  

𝑎11. 1 + 𝑎12. 0 + ⋯ + 𝑎1𝑛 . 0 ⋯ 𝑎11. 0 + 𝑎12. 0 + ⋯ + 𝑎1𝑛 . 1
⋱
𝑎𝑛1. 1 + 𝑎𝑛2. 0 + ⋯ + 𝑎𝑛𝑛 . 0 ⋯ 𝑎𝑛1. 0 + 𝑎𝑛2. 0 + ⋯ + 𝑎𝑛𝑛 . 1

⋮

⋮

  =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑛

35 

  = 𝐴   

De maneira análoga: 

𝐼. 𝐴 =  

1 ⋯ 0
⋮
⋮
⋱
0 ⋯ 1

  .  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑛

  =  

=  

1. 𝑎11 + 0. 𝑎21 + ⋯ + 𝑎𝑛1. 0 ⋯ 1. 𝑎1𝑛 + 0. 𝑎2𝑛 + ⋯ + 0. 𝑎𝑛𝑛
⋱
0. 𝑎11 + 0. 𝑎21 + ⋯ + 1. 𝑎𝑛1. ⋯ 0. 𝑎1𝑛 + 0. 𝑎2𝑛 + ⋯ + 1. 𝑎𝑛𝑛

⋮

⋮

  =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑛

  = 𝐴  

Portanto, 𝐴. 𝐼 = 𝐼. 𝐴 = 𝐴. 

A multiplicação de matrizes, em geral não goza da propriedade comutativa. Ilustramos 

essa afirmação com um contra exemplo. 

Sejam 𝐴 =  𝑎𝑖𝑗  

 e 𝐵 =  𝑏𝑖𝑗  

2

2

 tais que 𝐴 =  

𝐴. 𝐵 =  

e 

0 1
2 3

  .  

2 1
1 5

  =  

  e 𝐵 =  

0 1
2 3
0.2 + 1.1 0.1 + 1.5
2.2 + 3.1 2.1 + 3.5

2 1
1 5
1
5
7 17

  =  

 , temos: 

2.0 + 1.2 2.1 + 1.3
1.0 + 5.2 1.1 + 5.3

  =  

2
5
10 16

𝐵. 𝐴 =  

2 1
1 5

  .  

0 1
2 3

  =  

Portanto, temos 𝐴. 𝐵 ≠ 𝐵. 𝐴 

2.2.4  Potenciação de matrizes 

Definimos a potenciação de matrizes da seguinte forma: 

Dada uma matriz 𝐴 =  𝑎𝑖𝑗  

𝑛

, definimos, 𝐴0 = 𝐼𝑛 , 𝐴1 = 𝐴 e 𝐴𝑚 = 𝐴. 𝐴. 𝐴. ⋯ . 𝐴

𝑚  𝑓𝑎𝑡𝑜𝑟𝑒𝑠

2.3  Transposta de uma matriz 

Dada  uma  matriz  𝐴 =  𝑎𝑖𝑗  

,  definimos  a  matriz  transposta  de  𝐴  como 

𝑚 ×𝑛
′ = 𝑎𝑗𝑖   para  todo    𝑖 ∈  1, 2, … , 𝑛     e    todo                   

  onde  𝑎𝑖𝑗

′  
sendo  a  matriz  𝐴𝑡 =  𝑎𝑖𝑗

𝑛×𝑚

𝑗 ∈  1, 2, … , 𝑚 . 

Exemplo: 

Seja 𝐴 =  

0 −1
2
−2
3
1

 , por definição, a matriz transposta de 𝐴 é 𝐴𝑡 =  

0 −2 1
3
2
−1

 . 

 
 
  
  
 
 
         
 
 
 
 
Quando 𝐴 = 𝐴𝑡, dizemos que 𝐴 é uma matriz simétrica e quando 𝐴 = −𝐴𝑡, dizemos 

36 

que 𝐴 é uma matriz antissimétrica. 

Propriedades da transposição de matrizes 

I)   𝐴𝑡 𝑡 = 𝐴 

II)   𝐴 + 𝐵 𝑡 = 𝐴𝑡 + 𝐵𝑡 

III)   𝑘 ∙ 𝐴 𝑡 = 𝑘 ∙ 𝐴𝑡,    ∀𝑘 ∈ ℝ 

IV)  𝐴. 𝐵 𝑡 = 𝐵𝑡. 𝐴𝑡 

Demonstrações: 

 , temos  𝐴𝑡  𝑡 =   

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚 1 ⋯ 𝑎𝑚𝑛

𝑡

𝑡

=  

𝑎11 ⋯ 𝑎𝑚 1
⋱
⋮
⋮
𝑎1𝑛 ⋯ 𝑎𝑚𝑛

𝑡

= 

I)  Seja 𝐴 =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚 1 ⋯ 𝑎𝑚𝑛

=  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚 1 ⋯ 𝑎𝑚𝑛

  = 𝐴  

II)  Sejam  𝐴 =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

e  𝐵 =  

𝑏11 ⋯ 𝑏1𝑛
⋮
⋱
⋮
𝑏𝑚1 ⋯ 𝑏𝑚𝑛

 , 

temos 

 𝐴 + 𝐵 𝑡 =

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

  +  

𝑏11 ⋯ 𝑏1𝑛
⋮
⋱
⋮
𝑏𝑚1 ⋯ 𝑏𝑚𝑛

𝑡

=  

𝑎11 + 𝑏11 ⋯ 𝑎1𝑛 + 𝑏11
⋱
𝑎𝑚1 + 𝑏𝑚1 ⋯ 𝑎𝑚𝑛 + 𝑏𝑚𝑛

⋮

⋮

𝑡

=  

=  

𝑎11 + 𝑏11 ⋯ 𝑎𝑚1 + 𝑏𝑚1
⋱
𝑎1𝑛 + 𝑏11 ⋯ 𝑎𝑚𝑛 + 𝑏𝑚𝑛

⋮

⋮

  =  

𝑎11 ⋯ 𝑎𝑚1
⋱
⋮
⋮
𝑎1𝑛 ⋯ 𝑎𝑚𝑛

  +  

𝑏11 ⋯ 𝑏𝑚1
⋮
⋱
⋮
𝑏11 ⋯ 𝑏𝑚𝑛

  =  

=  

t

a11 ⋯ a1n
⋮
⋱
⋮
am1 ⋯ amn

+  

b11 ⋯ b1n
⋮
⋱
⋮
bm1 ⋯ bmn

t

= At + Bt  

III)  Sejam 𝐴 =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛
𝑡

  e 𝑘 ∈ ℝ, temos  𝑘 ∙ 𝐴 𝑡 =  𝑘 ∙  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

𝑡

= 

=  

𝑘 ∙ 𝑎11 ⋯ 𝑘 ∙ 𝑎𝑚1
⋱
𝑘 ∙ 𝑎1𝑛 ⋯ 𝑘 ∙ 𝑎𝑚𝑛

⋮

⋮

  = 𝑘 ∙  

𝑎11 ⋯ 𝑎𝑚1
⋱
⋮
⋮
𝑎1𝑛 ⋯ 𝑎𝑚𝑛

  =  

=  

⋮

⋮

𝑘 ∙ 𝑎11 ⋯ 𝑘 ∙ 𝑎1𝑛
⋱
𝑘 ∙ 𝑎𝑚1 ⋯ 𝑘 ∙ 𝑎𝑚𝑛
𝑡
𝑎11 ⋯ 𝑎1𝑛
⋱
⋮
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

= 𝑘 ∙  

= 𝑘 ∙ 𝐴𝑡  

IV)  Sejam 𝐴 =  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

  e 𝐵 =  

𝑏11 ⋯ 𝑏1𝑝
⋮
⋮
⋱
𝑏𝑛1 ⋯ 𝑏𝑛𝑝

 , como o número de colunas de 

𝐴 é igual ao número de linhas de 𝐵, então existe o produto 𝐴 ∙ 𝐵. Assim,  𝐴 ∙ 𝐵 𝑡 = 

 
 
 
 
  
  
  
 
 
 
  
 
 
=   

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

  .  

𝑏11 ⋯ 𝑏1𝑝
⋮
⋮
⋱
𝑏𝑛1 ⋯ 𝑏𝑛𝑝

𝒕

=  

=  

𝑎11 ∙ 𝑏11 + ⋯ + 𝑎1𝑛 ∙ 𝑏𝑛1 ⋯ 𝑎11 ∙ 𝑏1𝑝 + ⋯ + 𝑎1𝑛 ∙ 𝑏𝑛𝑝
⋱
𝑎𝑚1 ∙ 𝑏11 + ⋯ + 𝑎𝑚𝑛 ∙ 𝑏𝑛1 ⋯ 𝑎𝑚1 ∙ 𝑏1𝑝 + ⋯ + 𝑎𝑚𝑛 ∙ 𝑏𝑛𝑝

⋮

⋮

37 

𝑡

=  

=  

=  

𝑎11 ∙ 𝑏11 + ⋯ + 𝑎1𝑛 ∙ 𝑏𝑛1 ⋯ 𝑎𝑚1 ∙ 𝑏11 + ⋯ + 𝑎𝑚𝑛 ∙ 𝑏𝑛1
⋱
𝑎11 ∙ 𝑏1𝑝 + ⋯ + 𝑎1𝑛 ∙ 𝑏𝑛𝑝 ⋯ 𝑎𝑚1 ∙ 𝑏1𝑝 + ⋯ + 𝑎𝑚𝑛 ∙ 𝑏𝑛𝑝

⋮

⋮

  =  

𝑏11 ∙ 𝑎11 + ⋯ + 𝑏𝑛1 ∙ 𝑎1𝑛 ⋯ 𝑏11 ∙ 𝑎𝑚1 + ⋯ + 𝑏𝑛1. 𝑎𝑚𝑛
⋱
𝑏1𝑝 ∙ 𝑎11 + ⋯ + 𝑏𝑛𝑝 . 𝑎1𝑛 ⋯ 𝑏1𝑝 ∙ 𝑎𝑚1 + ⋯ + 𝑏𝑛𝑝 . 𝑎𝑚𝑛

⋮

⋮

  =  

= 

𝑏11 ⋯ 𝑏𝑛1
⋮
⋱
⋮
𝑏1𝑝 ⋯ 𝑏𝑛𝑝

  .  

𝑎11 ⋯ 𝑎𝑚1
⋱
⋮
⋮
𝑎1𝑛 ⋯ 𝑎𝑚𝑛

  =  

𝑏11 ⋯ 𝑏1𝑝
⋮
⋱
⋮
𝑏𝑛1 ⋯ 𝑏𝑛𝑝

𝑡

𝑡

.  

𝑎11 ⋯ 𝑎1𝑛
⋮
⋱
⋮
𝑎𝑚1 ⋯ 𝑎𝑚𝑛

= 𝐵𝑡. 𝐴𝑡 

2.4 

Inversa de uma matriz 

Seja 𝐴 uma matriz quadrada de ordem 𝑛. Uma matriz 𝐵 de ordem 𝑛 é denominada a 

inversa da matriz 𝐴 se 𝐴. 𝐵 = 𝐵. 𝐴 = 𝐼𝑛 . 

Exemplo: 

Sejam as matrizes 𝐴 =  

1 2
2 3

  e 𝐵 =  

−3
2
2 −1

 , temos: 

𝐴. 𝐵 =  

1 2
2 3

  .  

−3
2
2 −1

e 

  =  

1.  −3  + 2.2 1.2 + 2. (−1)
2.  −3  + 3.2 2.2 + 3. (−1)

  =  

−3 + 4 2 − 2
−6 + 6 4 − 3

  =  

1 0
0 1

  = 𝐼2 

𝐵. 𝐴 =  

2
−3
2 −1

  .  

1 2
2 3

  =  

 −3 . 1 + 2.2
2.1 +  −1 . 2 2.2 +  −1 . 3)

−3.2 + 2.3

  =  

−3 + 4 −6 + 6
4 − 3
2 − 2

  =  

1 0
0 1

  = 𝐼2 

Portanto 𝐴. 𝐵 = 𝐵. 𝐴 = 𝐼2, o que implica que a matriz 𝐵 é a inversa da matriz 𝐴. 

Teorema 2.1: Se 𝐴 é uma matriz invertível, então a sua inversa é única. 

Demonstração: Seja 𝐴 uma matriz quadrada de ordem 𝑛. Suponhamos que as matrizes 𝐵 e 

𝐵′ , ambas de ordem 𝑛, sejam matrizes inversas da matriz 𝐴. 

Utilizando  o  produto  pela  matriz  identidade,  a  definição  de  matriz  inversa  e  a  propriedade 

associativa da multiplicação de matrizes, temos: 

𝐵′ = 𝐵′ . 𝐼𝑛 = 𝐵′ .  𝐴. 𝐵  =  𝐵′ . 𝐴 . 𝐵 = 𝐼𝑛 . 𝐵 = 𝐵 

Devido à unicidade da inversa de uma matriz 𝐴, representaremo-na por 𝐴−1. 

 
  
 
 
 
 
 
 
38 

Teorema 2.2:  Se  𝐴  é uma matriz invertível,  então a sua inversa  𝐴−1  também é invertível  e 

 𝐴−1 −1 = 𝐴. 

Demonstração: Seja 𝐴 uma matriz quadrada de ordem 𝑛, invertível, então existe uma matriz 
quadrada 𝐴−1 de ordem 𝑛  tal que 𝐴. 𝐴−1 = 𝐼𝑛 . 
Utilizando  o  produto  pela  matriz  identidade,  a  definição  de  matriz  inversa  e  a  propriedade 

associativa da multiplicação de matrizes, temos: 

 𝐴−1 −1 =  𝐴−1 −1. 𝐼𝑛 =  𝐴−1 −1.  𝐴−1. 𝐴  =   𝐴−1 −1. 𝐴−1 . 𝐴 = 𝐼𝑛 . 𝐴 = 𝐴 

Portanto 𝐴−1 é invertível e sua inversa é 𝐴. 

Teorema 2.3: Sejam 𝐴 e 𝐵 matrizes quadradas de ordem 𝑛 e invertíveis, então 𝐴. 𝐵 também é 

invertível e (𝐴. 𝐵)−1 = 𝐵−1. 𝐴−1. 

Demonstração: Se 𝐴 e 𝐵 são matrizes quadradas de ordem 𝑛 e invertíveis então existem 𝐴−1 
e 𝐵−1 quadradas de ordem 𝑛, tais que 𝐴. 𝐴−1 = 𝐼𝑛  e 𝐵. 𝐵−1 = 𝐼𝑛  
Assim, temos: 

 𝐴. 𝐵 .  𝐵−1. 𝐴−1  = 𝐴.  𝐵. 𝐵−1 . 𝐴−1 = 𝐴. 𝐼𝑛 . 𝐴−1 = 𝐴. 𝐴−1 = 𝐼𝑛  

e 

 𝐵−1. 𝐴−1 .  𝐴. 𝐵  = 𝐵−1.  𝐴−1. 𝐴 . 𝐵 = 𝐵−1. 𝐼𝑛 . 𝐵 = 𝐵−1. 𝐵 = 𝐼𝑛  
Portanto,  𝐴. 𝐵 .  𝐵−1. 𝐴−1  =  𝐵−1. 𝐴−1 .  𝐴. 𝐵  = 𝐼𝑛 , o que implica que 𝐴. 𝐵 é invertível e 
sua inversa é 𝐵−1. 𝐴−1. 

Nem  todas  as  matrizes  possuem  inversa.  As  condições  para  que  uma  matriz  seja 

invertível serão abordados mais a frente. 

2.5  Transformações elementares de matrizes 

Seja  𝐴  uma  matriz  pertencente  a  ℳ(𝑚, 𝑛).  Para  cada 

𝑖 ∈  1, 2, … , 𝑚 , 

representaremos por 𝐿𝑖 a 𝑖 − é𝑠𝑖𝑚𝑎 linha da matriz 𝐴. 

Definimos as transformações elementares nas linhas da matriz 𝐴, da seguinte forma: 

I) 

Permutação entre as linhas 𝐿𝑖 e 𝐿𝑗  e representamos por 𝐿𝑖 ↔ 𝐿𝑗  

II)  Multiplicação de uma linha 𝐿𝑖 por um escalar real 𝑘 ≠ 0 e representamos por 

𝐿𝑖 → 𝑘. 𝐿𝑖 

III) 

Substituição de uma linha, digamos 𝐿𝑖, pela adição da linha 𝐿𝑖 com o produto 

𝑘. 𝐿𝑗   de  um  escalar  𝑘,  não  nulo,  pelos  elementos  da  linha  𝐿𝑗 ,  com  𝑖 ≠ 𝑗  e 

representamos por 𝐿𝑖 → 𝐿𝑖 + 𝑘. 𝐿𝑗  

 
 
 
 
Vejamos um exemplo da aplicação de algumas transformações elementares nas linhas 

39 

de uma matriz 𝐴 =  

−1
2
3 −2
4
0

 : 

−1
2
3 −2
4
0
0
4
3 −2
2
−1

Dizemos  que  as  matrizes   

−1
2
3 −2
4
0

 ,   

equivalentes por linhas. 

   𝐿1 ↔ 𝐿3

   𝐿3 → −2

            . 𝐿3     

    𝐿2 → 𝐿2 +

0
4
3 −2
2 −4
0
4
0
4
3 −2
3 −2
2 −4
2
−1

 ,   

1
2

. 𝐿1     

4
0
3
0
2 −4

   e   

4
0
3
0
2 −4

   são  matrizes 

Definição: Duas matrizes 𝐴 e 𝐵 são equivalentes por linhas se  𝐵 puder ser obtida da 

matriz 𝐴 através de um número finito de transformações elementares sobre as linhas de 𝐴 ou 

se 𝐴 puder ser obtida de 𝐵 através de um número finito de transformações elementares sobre 

as linhas de 𝐵. 

2.5.1  Matriz elementar 

Denominamos matriz elementar a toda matriz de ordem 𝑛 obtida através da aplicação 

de uma transformação elementar sobre a matriz 𝐼𝑛 . 

Exemplo: 

A  matriz  𝐸 =  

1 0 0
0 0 1
0 1 0

   é  uma  matriz  elementar,  pois  é  obtida  através  da 

transformação elementar 𝑒 correspondente a permuta 𝐿2 ↔ 𝐿3 em 𝐼3 portanto, 𝑒 𝐼3  = 𝐸. 

Teorema  2.4:  Seja  𝑒  uma  transformação  elementar  e  𝐸  uma  matriz  elementar  quadrada  de 

ordem 𝑛 tal que 𝑒 𝐼𝑛   = 𝐸. Se 𝐴 é uma matriz quadrada de ordem 𝑛, então 𝑒 𝐴  = 𝐸. 𝐴 

Demonstração: Utilizaremos na demonstração apenas a transformação elementar permutação 

entre  as  linhas  𝐿𝑖  e  𝐿𝑗   ,  sendo  que  para  as  outras  transformações  as  demonstrações  são  de 

maneira análoga. 

Seja 𝐼𝑛 =

1 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 1
0 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 0

0 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 0
1 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 1 

→ 𝐿𝑖 
→ 𝐿𝑗  

Seja 𝑒 a transformação elementar que permuta as linhas 𝐿𝑖 e 𝐿𝑗 . Assim, 

 
 
                     
                   
  
 
 
 
 
 
 
 
 
 
    
    
 
 
 
 
 
 
40 

  … 

 𝑒 𝐼𝑛   =

= 𝐸.  Seja 𝐴 a matriz de ordem 𝑛 a seguir: 

𝐴 =

→ 𝐿𝑖 
             Fazendo 𝑒 𝐴 , temos: 
→ 𝐿𝑗  

1 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 0
0 ⋯ 1
⋮ ⋯ ⋮
0 ⋯ 0
𝑎11 ⋯ 𝑎1𝑖
⋮ ⋯ ⋮
𝑎𝑖1 ⋯ 𝑎𝑖𝑖
𝑎𝑗 1 ⋯ 𝑎𝑗𝑖
⋮ ⋯ ⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑖

0 ⋯ 0
⋮ ⋯ ⋮
1 ⋯ 0
0 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 1 
𝑎1𝑗 ⋯ 𝑎1𝑛
⋮ ⋯ ⋮
𝑎𝑖𝑗 ⋯ 𝑎𝑖𝑛
𝑎𝑗𝑗 ⋯ 𝑎𝑗𝑛
⋮ ⋯ ⋮
𝑎𝑛𝑗 ⋯ 𝑎𝑛𝑛  

𝑒 𝐴  =

𝑎11 ⋯ 𝑎1𝑖
⋮ ⋯ ⋮
𝑎𝑗 1 ⋯ 𝑎𝑗𝑖
𝑎𝑖1 ⋯ 𝑎𝑖𝑖
⋮ ⋯ ⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑖

𝑎1𝑗 ⋯ 𝑎1𝑛
⋮ ⋯ ⋮
𝑎𝑗𝑗 ⋯ 𝑎𝑗𝑛
𝑎𝑖𝑗 ⋯ 𝑎𝑖𝑛
⋮ ⋯ ⋮
𝑎𝑛𝑗 ⋯ 𝑎𝑛𝑛  

=  

=

…  

⋮

1. 𝑎11 + ⋯ + 0. 𝑎𝑗 1 + 0. 𝑎𝑖1 + ⋯ + 0. 𝑎𝑛1 ⋯ 1. 𝑎1𝑖 + ⋯ + 0. 𝑎𝑗𝑖 +  0. 𝑎𝑖𝑖 + ⋯ + 0. 𝑎𝑛𝑖
⋯
0. 𝑎11 + ⋯ + 1. 𝑎𝑗 1 + 0. 𝑎𝑖1 + ⋯ + 0. 𝑎𝑛1 ⋯ 0. 𝑎1𝑖 + ⋯ + 1. 𝑎𝑗𝑖 +  0. 𝑎𝑖𝑖 + ⋯ + 0. 𝑎𝑛𝑖
0. 𝑎11 + ⋯ + 0. 𝑎𝑗 1 + 1. 𝑎𝑖1 + ⋯ + 0. 𝑎𝑛1 ⋯ 0. 𝑎1𝑖 + ⋯ + 0. 𝑎𝑗𝑖 +  1. 𝑎𝑖𝑖 + ⋯ + 0. 𝑎𝑛𝑖
⋯
0. 𝑎11 + ⋯ + 0. 𝑎𝑗 1 + 0. 𝑎𝑖1 + ⋯ + 1. 𝑎𝑛1 ⋯ 0. 𝑎1𝑖 + ⋯ + 0. 𝑎𝑗𝑖 +  0. 𝑎𝑖𝑖 + ⋯ + 1. 𝑎𝑛𝑖

⋮

⋮

⋮

⋮

1. 𝑎1𝑗 + ⋯ + 0. 𝑎𝑗𝑗 + 0. 𝑎𝑖𝑗 + ⋯ + 0. 𝑎𝑛𝑗 ⋯ 1. 𝑎1𝑛 + ⋯ + 0. 𝑎𝑗𝑛 + 0. 𝑎𝑖𝑛 + ⋯ + 0. 𝑎𝑛𝑛
⋯
0. 𝑎1𝑗 + ⋯ + 1. 𝑎𝑗𝑗 + 0. 𝑎𝑖𝑗 + ⋯ + 0. 𝑎𝑛𝑗 ⋯ 0. 𝑎1𝑛 + ⋯ + 1. 𝑎𝑗𝑛 + 0. 𝑎𝑖𝑛 + ⋯ + 0. 𝑎𝑛𝑛
0. 𝑎1𝑗 + ⋯ + 0. 𝑎𝑗𝑗 + 1. 𝑎𝑖𝑗 + ⋯ + 0. 𝑎𝑛𝑗 ⋯ 0. 𝑎1𝑛 + ⋯ + 0. 𝑎𝑗𝑛 + 1. 𝑎𝑖𝑛 + ⋯ + 0. 𝑎𝑛𝑛
⋯
0. 𝑎1𝑗 + ⋯ + 0. 𝑎𝑗𝑗 + 0. 𝑎𝑖𝑗 + ⋯ + 1. 𝑎𝑛𝑗 ⋯ 0. 𝑎1𝑛 + ⋯ + 0. 𝑎𝑗𝑛 + 0. 𝑎𝑖𝑛 + ⋯ + 1. 𝑎𝑛𝑛  

⋮

⋮

⋮

= 

=

1 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 0
0 ⋯ 1
⋮ ⋯ ⋮
0 ⋯ 0

0 ⋯ 0
⋮ ⋯ ⋮
1 ⋯ 0
0 ⋯ 0
⋮ ⋯ ⋮
0 ⋯ 1 

.

𝑎11 ⋯ 𝑎1𝑖
⋮ ⋯ ⋮
𝑎𝑖1 ⋯ 𝑎𝑖𝑖
𝑎𝑗 1 ⋯ 𝑎𝑗𝑖
⋮ ⋯ ⋮
𝑎𝑛1 ⋯ 𝑎𝑛𝑖

𝑎1𝑗 ⋯ 𝑎1𝑛
⋮ ⋯ ⋮
𝑎𝑖𝑗 ⋯ 𝑎𝑖𝑛
𝑎𝑗𝑗 ⋯ 𝑎𝑗𝑛
⋮ ⋯ ⋮
𝑎𝑛𝑗 ⋯ 𝑎𝑛𝑛  

= 𝐸. 𝐴 

Teorema 2.5: Se 𝐴 e 𝐵 são matrizes quadradas de ordem  𝑛, então a matriz 𝐴 é equivalente 

por  linhas  à  matriz  𝐵  se,  e  somente  se,  existem  matrizes  elementares  𝐸1, 𝐸2, 𝐸3, … , 𝐸𝑘  

quadradas de ordem 𝑛 tais que 𝐸𝑘. 𝐸𝑘−1. ⋯ . 𝐸2. 𝐸1. 𝐴 = 𝐵 . 

Demonstração: Por definição, para que uma matriz 𝐴 de ordem 𝑛 seja equivalente por linhas 

a uma matriz 𝐵 de mesma ordem, devem existir transformações elementares 𝑒1, 𝑒2, 𝑒3, … , 𝑒𝑘 

tal que 𝑒𝑘  …  𝑒2 𝑒1 𝐴     = 𝐵. Pelo teorema 2.4, 𝑒𝑘  …  𝑒2 𝑒1 𝐴     = 𝑒𝑘  …  𝑒2 𝐸1. 𝐴    = 

 
 
 
 
 
 
 
    
    
 
 
 
 
 
 
 
 
 
 
 
    
    
 
 
 
 
 
 
 
 
 
 
 
    
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
 
 
 
 
 
 
 
 
 
 
 
    
    
 
 
 
 
 
 
41 

= 𝑒𝑘 …  𝐸2. 𝐸1. 𝐴   = 𝐸𝑘. ⋯ . 𝐸2. 𝐸1. 𝐴 = 𝐵 com cada 𝐸𝑖 = 𝑒𝑖 𝐼𝑛  , para todo 𝑖 ∈  1, 2, … , 𝑘 . 

Teorema  2.6:  Toda  matriz  elementar  é  invertível  e  sua  inversa  também  é  uma  matriz 

elementar. 

Demonstração:  Consideremos  a  transformação  elementar  𝑒  que  transforma  𝐼𝑛   na  matriz 
elementar 𝐸, ou seja, 𝑒 𝐼𝑛   = 𝐸. Consideremos 𝑒−1 a transformação elementar inversa de 𝑒, 
ou seja, se 𝑒 for a permutação das linhas 𝐿𝑖  e 𝐿𝑗  da matriz 𝐼𝑛 , então 𝑒−1 será a transformação 

permutação das linhas 𝐿𝑖  e 𝐿𝑗  da matriz 𝐸; se 𝑒 for a multiplicação de uma linha 𝐿𝑖 da matriz 

𝐼𝑛  por um escalar 𝑘 ≠ 0, então 𝑒−1 será a multiplicação da linha 𝐿𝑖 da matriz 𝐸 pelo escalar 

1

𝑘

e se 𝑒 for a substituição de uma linha 𝐿𝑖 da matriz 𝐼𝑛  pela adição da linha 𝐿𝑖 com o produto de 
um escalar 𝑘 ≠ 0 por uma linha 𝐿𝑗 , então 𝑒−1 será a substituição da linha 𝐿𝑖 da matriz 𝐸  pela 

adição da linha 𝐿𝑖 da matriz 𝐸 com o produto do escalar – 𝑘 pela linha 𝐿𝑗   da matriz 𝐸. 

Assim,  fica  evidente  que  𝑒−1 𝐸  = 𝐼𝑛 .  Se  aplicarmos  a  transformação  𝑒−1  em  𝐼𝑛 , 
temos uma matriz elementar 𝐹, ou seja, 𝑒−1 𝐼𝑛   = 𝐹 e, pelo teorema 2.4, teremos 𝐹. 𝐸 = 𝐼𝑛 , 
ou seja, 𝐹 é a matriz inversa da matriz 𝐸, portanto 𝐹 = 𝐸−1, concluindo então que se 𝐸 é uma 

matriz  elementar,  então  é  invertível.  Como  𝐹 = 𝐸−1  é  obtida  através  de  transformações 
elementares na matriz 𝐼𝑛 , então 𝐹 = 𝐸−1 é também uma matriz elementar. 

2.5.2  Matriz escalonada 

Definição: Uma matriz 𝐴 de ordem 𝑚 × 𝑛 é apresentada na forma escalonada se: 

I) O primeiro elemento não nulo em cada linha da matriz 𝐴 é igual a 1; 

II)  Cada  coluna  da  matriz  𝐴   que  contém  o  primeiro  elemento  não  nulo  de  alguma 

linha, possui todos os outros elementos iguais a zero; 

III) Todas as linhas nulas se encontram abaixo de todas as linhas não nulas; 

IV) Se  as linhas não  nulas da matriz  𝐴 forem  𝐿1, 𝐿2, 𝐿3, … , 𝐿𝑘, sendo  𝑎1𝑗  o primeiro 

elemento  não  nulo  da  linha  𝐿1,  então  os  elementos  não  nulos  das  linhas  𝐿2, 𝐿3, … , 𝐿𝑘 
ocuparão, respectivamente, as posições 𝑎2𝑗 ′ , 𝑎3𝑗 ′′ , … , 𝑎𝑘𝑗 ′ ….′  com 𝑗 < 𝑗′ < 𝑗′′ < ⋯   < 𝑗′…′ . 

Exemplo: Seja 𝐴 a matriz de ordem 3 × 4 a seguir: 

𝐴 =  

1 0 0
0 1 0
0 0 1

2
1
−3

 .  A  matriz  apresentada  se  encontra  na  forma  escalonada,  pois 

satisfaz as condições I, II, III e IV da definição acima. 

 
 
 
 
 
    
42 

Teorema 2.7: Toda matriz é equivalente a uma matriz na forma escalonada. 

Demonstração:  Seja  𝐴  uma  matriz  quadrada  de  ordem  𝑚 × 𝑛,  se  a  primeira  linha  for  nula 

então  a  condição  (I)  é  satisfeita  nessa  linha.  Se  por  acaso  a  primeira  linha  possuir  algum 

elemento  diferente  de  zero,  por  exemplo  𝑎1𝑗 ,  então  através  da  transformação  elementar  de 

multiplicar  por  escalar,  multiplicamos  a  primeira  linha  por 

1
𝑎1𝑗

,  satisfazendo  com  isso  a 

condição (I). Para cada linha a partir da segunda, somemos −𝑎𝑖𝑗 , 𝑖 ≠ 1 vezes a primeira linha 

com a i-ésima linha, assim, obtemos uma matriz cujo primeiro elemento não nulo da primeira 

linha é 1 e ocorre na j-ésima coluna, ademais, todos os outros elementos da j-ésima coluna são 

iguais a zero. Considerando a segunda linha da matriz 𝐴, se a mesma for nula, não há nada o 

que  fazer,  caso  exista  algum  elemento  diferente  de  zero,  procedemos  de  forma  similar  ao 

realizado  na  primeira  linha.  Como  o  número  de  linhas  da  matriz  é  limitado,  no  caso  𝑚, 

repetindo  o  processo  acima  descrito,  ao  chegarmos  à  m-ésima  linha,  teremos  satisfeito  as 

condições  (I)  e  (II).  As  condições  (III)  e  (IV)  poderão  ser  satisfeitas  de  maneira  bastante 

simples através de permutações entre as linhas da matriz. Desse modo, obtemos uma matriz 𝐵 

na forma escalonada, equivalente por linhas à matriz 𝐴. 

Teorema  2.8:  Uma  matriz  𝐴,  quadrada  de  ordem  𝑛  que  possui  uma  linha  nula  não  é 

invertível. 

Demonstração: 

Suponha 𝐴 =

𝑎11 𝑎12 ⋯
𝑎21 𝑎22 ⋯
⋮
⋮
⋱
0 ⋯
0
⋱
⋮
⋮
𝑎𝑛1 𝑎𝑛2 ⋯

𝑎1𝑗 ⋯ 𝑎1𝑛
𝑎2𝑗 ⋯ 𝑎2𝑛
⋮
⋮
⋱
0 ⋯ 0
⋮
⋱
⋮
𝑎𝑛𝑗 ⋯ 𝑎𝑛𝑛  

→  𝐿𝑖 

 Se 𝐴 for invertível, então deve existir uma matriz 𝐵, quadrada de ordem 𝑛 tal que 𝐴. 𝐵 = 𝐼𝑛 . 

Suponhamos 𝐵 =

𝑏12 ⋯
𝑏11
𝑏21 𝑏22 ⋯
⋮
⋮
⋱
𝑏𝑖2 ⋯
𝑏𝑖1
⋮
⋱
⋮
𝑏𝑛1 𝑏𝑛2 ⋯

𝑏1𝑗 ⋯ 𝑏1𝑛
𝑏2𝑗 ⋯ 𝑏2𝑛
⋮
⋮
⋱
𝑏𝑖𝑗 ⋯ 𝑏𝑖𝑛
⋮
⋮
⋱
𝑏𝑛𝑗 ⋯ 𝑏𝑛𝑛  

 notemos que o produto 𝐴. 𝐵 terá a í-ésima 

linha nula, pois a i-ésima linha será determinada por: 

𝐿𝑖 =  0. 𝑏11 + ⋯ + 0. 𝑏𝑛1 0. 𝑏12 + ⋯ + 0. 𝑏𝑛2 ⋯    0. 𝑏1𝑗 + ⋯ + 0. 𝑏𝑛𝑗 ⋯ 0. 𝑏1𝑛 + ⋯ + 0. 𝑏𝑛𝑛  . 
E, portanto, 𝐿𝑖 =  0 0 ⋯    0 ⋯ 0 , fazendo com que 𝐴. 𝐵 ≠ 𝐼𝑛 , para todo 𝐵. 

 
 
 
 
 
 
 
 
 
    
    
 
 
 
 
 
  
 
 
 
 
 
 
    
    
 
 
 
 
 
43 

Logo, 𝐴 não é invertível se possuir uma linha nula. 

Os teoremas  vistos até agora nos dão  embasamento  para obter dois resultados muito 

importantes acerca de matrizes: 

Teorema  2.9:  Uma  matriz  𝐴  de  ordem  𝑛  é  invertível  se,  e  somente  se  for  equivalente  por 

linhas à matriz identidade. 

Demonstração: 

       Suponhamos  que  𝐴  é  uma  matriz  invertível  de  ordem  𝑛.  Pelo  teorema  2.8,  𝐴  não 

possui linhas nulas, além disso, pelo teorema 2.7, 𝐴 é equivalente por linhas a uma matriz na 

forma escalonada. Portanto 𝐴 é equivalente por linhas a 𝐼𝑛 .  

       Seja  𝐴  uma  matriz  quadrada  de  ordem  𝑛,  equivalente  por  linhas  a  matriz  𝐼𝑛 .  Pelo 

teorema 2.5, existem 𝐸1, 𝐸2, 𝐸3, … , 𝐸𝑘 de modo que 𝐸𝑘. 𝐸𝑘−1. ⋯ . 𝐸2. 𝐸1. 𝐴 = 𝐼𝑛 . Pelo teorema 

2.6, temos que 𝐸1, 𝐸2, 𝐸3, … , 𝐸𝑘 são todas invertíveis, por serem  matrizes elementares, então 
−1. 𝐸𝑖 = 𝐼𝑛  para todo 𝑖 ∈  1, 2, 3, … , 𝑘 . Assim, 
multiplicando  à  esquerda  ambos  os  membros  da  igualdade  𝐸1, 𝐸2, 𝐸3, … , 𝐸𝑘 . 𝐴 = 𝐼𝑛     por   

−1, de modo que 𝐸𝑖

existem 𝐸1

−1, … , 𝐸𝑘

−1, 𝐸2

−1, 𝐸3

 𝐸𝑘
E, 

−1. … . 𝐸3

−1 , temos:  𝐸𝑘

−1. 𝐸2
utilizando 
−1. … . 𝐸3

−1. 𝐸1
a 
−1. 𝐸1
−1. 𝐸2
portanto 𝐴 é uma matriz invertível. 

propriedade 

𝐴 = 𝐸𝑘

−1. … . 𝐸3

−1. 𝐸2

−1. 𝐸1

−1 . 𝐸1, 𝐸2, 𝐸3, … , 𝐸𝑘 . 𝐴 =  𝐸𝑘

−1. … . 𝐸3

−1. 𝐸2

−1. 𝐸1

−1 . 𝐼𝑛  

associativa 

do 

produto 

de  matrizes, 

temos: 

−1 e, pelo teorema 2.3, o produto de matrizes invertíveis é invertível, 

Teorema 2.10: Se 𝐴 é uma matriz invertível de ordem 𝑛 e uma sequência de transformações 

elementares  sobre  as  linhas  de  𝐴  reduz  𝐴  à  matriz  𝐼𝑛 ,  então  esta  mesma  sequência  de 
transformações elementares aplicadas às linhas de 𝐼𝑛  produzirá a matriz 𝐴−1. 
Demonstração: Se  𝐴 é invertível, então pelo teorema 2.9, 𝐴 é equivalente por linhas a matriz 

𝐼𝑛   e,  pelo  teorema  2.5,  existem  𝐸1, 𝐸2, 𝐸3, … , 𝐸𝑘  de  modo  que  𝐸𝑘. 𝐸𝑘−1. ⋯ . 𝐸2. 𝐸1. 𝐴 = 𝐼𝑛 . 
Como  por  hipótese  𝐴  é  invertível,  então  existe  a  matriz  𝐴−1.  Multiplicando  à  direita  a 
igualdade 𝐸𝑘. 𝐸𝑘−1. ⋯ . 𝐸2. 𝐸1. 𝐴 = 𝐼𝑛   por 𝐴−1, temos 𝐸𝑘. 𝐸𝑘−1. ⋯ . 𝐸2. 𝐸1. 𝐴. 𝐴−1 = 𝐼𝑛 . 𝐴−1, de 
onde obtemos 𝐸𝑘. 𝐸𝑘−1. ⋯ . 𝐸2. 𝐸1. 𝐼𝑛 = 𝐴−1. 

Os  teoremas  2.9  e  2.10  constituem  um  instrumento  muito  importante  e  eficiente  na 

determinação  da  invertibilidade  de  uma  matriz  e  o  cálculo  da  matriz  inversa,  popularmente 

conhecido como método de Gauss-Jordan. 

 
 
 
 
 
 
 
44 

Vejamos um exemplo: 

Seja  𝐴 =  

2
0
1
0 −3 2
0
1
1

 .  Apliquemos  simultaneamente  as  transformações  elementares 

nas linhas da matriz 𝐴 e da matriz 𝐼3 de modo a reduzir a matriz 𝐴 à matriz 𝐼3: 

  𝐿3   →   𝐿1

  𝐿1   →   𝐿1

            − 2𝐿3  

  𝐿2   →   𝐿2

            + 3𝐿1    

  𝐿2   →  

1

2

𝐿1  

0
1 0
0 1
0
1 0 −1

2
6
0 −1

0
1
2
            − 𝐿3    
0 −3 2
0
1
0
−1 0
0 1 0
−3 1
0 0 2
1 0 0
1
−1 0
1
3
−

0 1 0
1 0 0
0 0 1

2
0 −1
1
3

2

2

   𝐿1  ↔       𝐿2   

  𝐴 𝐼3  =   

1 0 0
0
1
2
0 1 0
0 −3 2
0 0 1
0
1
1
2
−1 0
0
1
0
→     
1
0
0
0 −3 2
0 −1
1
0
0
1

→    

0 1 0
0 0 1
1 0 0

→    

1 0 0
0 1 0
0 0 1

−1 0
1
3
−

2
3

2
1
1
−1 0
1
3
−

2
0 −1
0 −1
2
3

2

2

   𝐿2  ↔       𝐿3   

   =   𝐼3 𝐴−1   

Portanto 𝐴−1 =  

1
−1 0
1
3
−

0 −1
2
3

2

2

 . 

0
1
2
Isto pode ser facilmente verificado fazendo 𝐴. 𝐴−1 =  
0 −3 2
0
1
1

  .  

1
−1 0
1
3
−

0 −1
2
3

2

2

  = 

  2.1 + 1.  −1  + 0.  −
2
0.1 +  −3 .  −1  + 2.  −

3

=

3

2

1

2.0 + 1.0 + 0.

2
  0.0 +  −3 . 0 + 2.

2.  −1  + 1.2 + 0.3

1

2

0.  −1  +  −3 . 2 + 2.3

=  

1.1 + 1.  −1  + 0.  −

3

2

1.0 + 1.0 + 0.

1

2

1.  −1  + 1.2 + 0.3  

=  

2 − 1 + 0 0 + 0 + 0 −2 + 2 + 0
0 + 3 − 3 0 + 0 + 1
0 − 6 + 6
1 − 1 + 0 0 + 0 + 0 −1 + 2 + 0

  =  

1 0 0
0 1 0
0 0 1

  = 𝐼3 . De maneira análoga, temos  

𝐴−1. 𝐴 =  

1
−1 0
1
3
−

0 −1
2
3

2

2

  .  

2
0
1
0 −3 2
0
1
1

  =  

=  

1.2 + 0.0 +  −1 . 1 1.1 + 0.  −3  +  −1 . 1 1.0 + 0.2 +  −1 . 0
−1.1 + 0.  −3  + 2.1
−1.0 + 0.2 + 2.0
−1.2 + 0.0 + 2.1
1
1
.  −3  + 3.1

. 2 + 3.0

. 0 + 3.1

. 0 +

. 2 +

. 1 +

−

−

−

3

1

3

3

  =  

2

2

2

2
2 + 0 − 1
0 + 0 + 0
1 + 0 − 1
−2 + 0 + 2 −1 + 0 + 2 0 + 0 + 0

2

2

=  

−3 + 0 + 3 −

3
2

−

3
2

+ 3 0 + 1 + 0

  =  

1 0 0
0 1 0
0 0 1

  = 𝐼3 

 
 
 
 
 
         
 
 
 
 
 
 
 
 
 
 
 
 
 
 
45 

3  DETERMINANTES 

Consideremos  𝑛 ≥ 1  pertencente  ao  conjunto  dos  números  naturais.  Seja  𝑋𝑛 =
 1, 2, 3, … , 𝑛 .  Enunciamos  que  toda  função  bijetiva  𝑓: 𝑋𝑛 → 𝑋𝑛  é  uma  permutação  do 

conjunto 𝑋𝑛. 

Vamos representar uma permutação 𝑓 de 𝑋𝑛 em 𝑋𝑛 por 

𝑓 =  

1
2
𝑓 1  𝑓 2  𝑓 3      

3

⋯
⋯     

𝑖

⋯ 𝑗

𝑓(𝑖) ⋯ 𝑓(𝑗)

⋯
𝑛
⋯ 𝑓 𝑛   

Exemplos:  

a)  Quando  𝑛 = 1,  temos  𝑋1 =  1   e  temos  uma  possível  bijeção  de  𝑋1 → 𝑋1,  a  saber, 

1
𝑓𝑖𝑑𝑒𝑛𝑡𝑖𝑑𝑎𝑑𝑒 =  
1

b)  Quando  𝑛 = 2,  temos  𝑋2 =  1, 2   e  temos  duas  possíveis  bijeções  de  𝑋2 → 𝑋2,  a 

saber, 𝑓𝑖𝑑𝑒𝑛𝑡𝑖𝑑𝑎𝑑𝑒 =  

  e 𝑓 =  

1 2
1 2

1 2
2 1

c)  Quando 𝑛 = 3, temos 𝑋3 =  1, 2, 3  e temos 3! = 6 possíveis bijeções de 𝑋3 → 𝑋3, a 

saber,  

1 2 3
1 2 3

 ,  

1 2 3
2 1 3

 ,  

1 2 3
2 3 1

 ,  

1 2 3
1 3 2

 ,  

1 2 3
3 1 2

  e  

1 2 3
3 2 1

Denominaremos 𝐾 ao conjunto formado pelos pares ordenados  𝑖, 𝑗 , com 1 ≤ 𝑖 ≤ 𝑗 ≤

𝑛,  nos  quais  𝑓 𝑖  > 𝑓(𝑗)  e  𝑛(𝐾)  ao  número  de  elementos  de  𝐾.  Denominaremos  ainda  por 

𝑠𝑛𝑔(𝑓) ao sinal da permutação, da seguinte maneira: 

𝑠𝑛𝑔 𝑓  = 1, 𝑠𝑒 𝑛(𝐾)  é 𝑝𝑎𝑟  

𝑠𝑛𝑔(𝑓) = −1, 𝑠𝑒 𝑛(𝐾)  é 𝑖𝑚𝑝𝑎𝑟 . 

Exemplos: 

a)  Consideremos  𝑓 =  

1 2 3
1 3 2

 ,  os  pares   𝑖, 𝑗 ,  com  1 ≤ 𝑖 ≤ 𝑗 ≤ 𝑛  são   1,2 , (1,3)  e 

(2,3),  notemos  que  𝑓 1  = 1 < 𝑓 2  = 3; 𝑓 1  = 1 < 𝑓 3  = 2  e  𝑓 2  = 3 >

𝑓 3  = 2, portanto 𝐾 = { 2,3 }, o que implica que  𝑛 𝐾  = 1, que é impar, portanto 

𝑠𝑛𝑔(𝑓) = −1. 

b)  Consideremos  𝑓 =  

1 2 3
3 1 2

 ,  os  pares   𝑖, 𝑗 ,  com  1 ≤ 𝑖 ≤ 𝑗 ≤ 𝑛  são   1,2 , (1,3)  e 

(2,3),  notemos  que  𝑓 1  = 3 > 𝑓 2  = 1; 𝑓 1  = 3 > 𝑓 3  = 2  e  𝑓 2  = 1 <

 
 
 
 
      
 
   
  
  
 
 
 
46 

𝑓 3  = 2,  portanto  𝐾 = { 1,2 , (1,3)},  o  que  implica  que  𝑛 𝐾  = 2,  que  é  par, 

portanto 𝑠𝑛𝑔(𝑓) = 1. 

De acordo com o sinal, classificaremos uma permutação como par, se 𝑠𝑛𝑔(𝑓) = 1, ou 

ímpar, se 𝑠𝑛𝑔 𝑓  = −1. 

Consideremos  𝐴 =  𝑎𝑖𝑗  

𝑛

  uma  matriz  real.  Consideremos  também  o  produto 

𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛),  com  𝑓  sendo  uma  permutação  do  conjunto  𝑋𝑛. 

Notemos que nesse produto aparecem, como fatores, somente um elemento de cada linha da 

matriz  𝐴,  pois  os  índices  correspondentes  às  linhas  variam  de  1  até  𝑛,  sem  repetição;  e 

aparece também, somente um elemento de cada coluna da matriz 𝐴, uma vez que os índices 

correspondentes  às  colunas  não  se  repetem  pois  𝑓  é  bijetiva.  Notemos  ainda  que  temos  𝑛! 

possíveis permutações em 𝑋𝑛, portanto 𝑛! produtos 𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛). 

Definiremos  o  determinante  da  matriz  𝐴,  como  sendo  a  soma  das  𝑛!  parcelas 

𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛), ou ainda: 

Notemos  que,  considerando  ℳ𝑛   como  sendo  o  conjunto  de  todas  as  matrizes  reais 

quadradas  de  ordem  𝑛,  temos  que  det(A) ⁡  é  uma  função  de  ℳ𝑛   em  ℝ,  que  a  cada  matriz 
𝐴 ∈ ℳ𝑛 ,  faz  corresponder  um  escalar  real  𝑘  tal  que  det 𝐴  = 𝑘.  Tal  função  não  é  bijetiva, 

pois embora seja sobrejetiva não é injetiva. 

Se 𝐴 =  𝑎11 , temos det 𝐴  = 𝑎11. 

Se 𝐴 =  

𝑎11 𝑎12
𝑎21 𝑎22

 , temos as seguintes permutações: 

𝑓1 =  

1 2
1 2

𝑠𝑛𝑔 𝑓1  = 1. 

 ,  o  que  implica  que  𝐾1 = ∅,  ou  seja,  𝑛(𝐾1) = 0,  que  é  par,  portanto 

 𝑓2 =  

 ,  o  que  implica  que  𝐾2 = { 1,2 },  ou  seja,  𝑛 𝐾2  = 1,  que  é  ímpar, 

1 2
2 1

portanto 𝑠𝑛𝑔 𝑓2  = −1. 

 Logo, det 𝐴  = 𝑎11. 𝑎22 − 𝑎12. 𝑎21 

Se 𝐴 =  

𝑎11 𝑎12 𝑎13
𝑎21 𝑎22 𝑎23
𝑎31 𝑎32 𝑎33

 , temos as seguintes permutações: 

𝑓1 =  

1 2 3
1 2 3

 ,  o  que  implica  que  𝐾1 = ∅,  ou  seja,  𝑛 𝐾1  = 0,  que  é  par,  portanto 

𝑠𝑛𝑔 𝑓1  = 1. 

fnnffffaaaafsngA)()3(3)2(2)1(1.....).()det( 
 
 
47 

 , o que implica que 𝐾2 = { 1,3 ,  2,3 }, ou seja, 𝑛 𝐾2  = 2, que é par, 

 , o que implica que 𝐾3 = { 1,2 ,  1,3 }, ou seja, 𝑛 𝐾3  = 2, que é par, 

 ,  o  que  implica  que  𝐾4 = { 2,3 },  ou  seja,  𝑛 𝐾4  = 1,  que  é  ímpar, 

 , o que implica que 𝐾5 = { 1,2 ,  1,3 , (2,3)}, ou seja, 𝑛 𝐾5  = 3, que 

𝑓2 =  

1 2 3
2 3 1
portanto 𝑠𝑛𝑔 𝑓2  = 1. 
1 2 3
3 1 2
portanto 𝑠𝑛𝑔 𝑓3  = 1. 
1 2 3
1 3 2

𝑓3 =  

𝑓4 =  

portanto 𝑠𝑛𝑔 𝑓4  = −1. 

𝑓5 =  

1 2 3
3 2 1
é ímpar, portanto 𝑠𝑛𝑔 𝑓5  = −1. 
1 2 3
2 1 3

𝑓6 =  

 ,  o  que  implica  que  𝐾6 = { 1,2 },  ou  seja,  𝑛 𝐾6  = 1,  que  é  ímpar, 

portanto 𝑠𝑛𝑔 𝑓4  = −1. 

Logo: 

det 𝐴  = 𝑎11. 𝑎22. 𝑎33 + 𝑎12. 𝑎23. 𝑎31 + 𝑎13. 𝑎21. 𝑎32 − 𝑎11. 𝑎23. 𝑎32 − 𝑎13. 𝑎22. 𝑎31 − 𝑎12. 𝑎21. 𝑎33  

Vejamos alguns exemplos: 

a)  Seja 𝐴 =  

 , uma matriz de ordem 2. 

5
2
−3 −4

Por definição, det 𝐴  = 2.  −4  − 5. (−3), portanto, det 𝐴  = 7 

b)  Seja 𝐵 =  

0
1
−2
−1
3
2
0 −2 5

 , uma matriz de ordem 3. 

Por definição, 

det 𝐴  = −2.2.5 + 1.3.0 + 0.  −1 .  −2  − (−2).3.  −2  − 0.2.0 − 1.  −1 . 5  

det 𝐴  = −20 + 0 + 0 − 12 − 0 + 5   

det 𝐴  = −27  

3.1  PROPRIEADES DOS DETERMINANTES 

Representando  cada  linha  de  uma  matriz  real  𝐴,  quadrada  de  ordem  𝑛,  por 

𝐴1, 𝐴2, 𝐴3, … , 𝐴𝑛 ,  em  que  𝐴𝑖 = (𝑎𝑖1, 𝑎𝑖2, 𝑎13, … , 𝑎𝑖𝑛 ),  para  todo  𝑖 ∈  1, 2, 3, … , 𝑛 ,  podemos, 

com finalidade de facilitar a notação,  representar a matriz 𝐴 na seguinte configuração: 

 
 
 
 
 
48 

𝐴 =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑛  

, cujo determinante representaremos por 𝑑𝑒𝑡 𝐴  =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑛

A função determinante goza das seguintes propriedades:  

I) 

Dada  a  matriz  𝐴 =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑛  

=

𝐴1
𝐴2
𝐴3
⋮
′ + 𝑘. 𝐴𝑖
′′
𝐴𝑖
⋮
𝐴𝑛

,  então

𝐴1
𝐴2
𝐴3
⋮
′ + 𝑘. 𝐴𝑖
′′
𝐴𝑖
⋮
𝐴𝑛

=

𝐴1
𝐴2
𝐴3
⋮
′
𝐴𝑖
⋮
𝐴𝑛

+ 𝑘.

𝐴1
𝐴2
𝐴3
⋮
′′
𝐴𝑖
⋮
𝐴𝑛

,  ou 

seja, a função 𝑑𝑒𝑡 𝐴  é linear em cada uma das linhas separadamente da matriz 𝐴. 

II) 

Dada matriz real 𝐴 quadrada de ordem 𝑛, e um escalar real 𝑘, temos 𝑑𝑒𝑡 𝑘. 𝐴  =

𝑘𝑛 . 𝑑𝑒𝑡 𝐴 . 

III) 

IV) 

Considerando 𝐼𝑛  com sendo a matriz identidade de ordem 𝑛, temos 𝑑𝑒𝑡 𝐼𝑛   = 1. 

Se de uma matriz 𝐴 quadrada de ordem 𝑛 for obtida uma matriz 𝐵 através de uma 

transformação  elementar  do  tipo  𝐿𝑖 ↔ 𝐿𝑗 ,  com  𝑖 ≠ 𝑗  (permutação  entra  duas  

linhas), então 𝑑𝑒𝑡 𝐵  = −𝑑𝑒𝑡 𝐴 . 

V) 

Se 𝐴 =

VI) 

Se 𝐴 =

𝐴1
𝐴2
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛  
𝐴1
𝐴2
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛  

 e 𝐴𝑖 = 𝐴𝑗 , com 𝑖 ≠ 𝑗, então 𝑑𝑒𝑡 𝐴  = 0. 

 e 𝐴𝑖 = 𝑘. 𝐴𝑗 , com 𝑖 ≠ 𝑗 e 𝑘 ≠ 0, então 𝑑𝑒𝑡 𝐴  = 0. 

VII)  Dada uma matriz real 𝐴, quadrada de ordem 𝑛, temos 𝑑𝑒𝑡 𝐴  = 𝑑𝑒𝑡 𝐴𝑡 . 

VIII)  Dadas  duas  matrizes  reais  𝐴  e  𝐵,  quadradas  de  ordem  𝑛,  temos  𝑑𝑒𝑡 𝐴. 𝐵  =

𝑑𝑒𝑡 𝐴 . 𝑑𝑒𝑡 𝐵 . 

IX)  Uma matriz 𝐴 é invertível se, e somente se, 𝑑𝑒𝑡 𝐴  ≠ 0. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
49 

X) 

Dada  uma  matriz  real  𝐴,  quadrada  de  ordem  𝑛,  cuja  uma  linha,  digamos  𝐿𝑖  é  a 

combinação linear de duas outras linhas, então 𝑑𝑒𝑡 𝐴  = 0. 

XI) 

Se uma matriz 𝐵, quadrada de ordem 𝑛 é obtida a partir de uma matriz 𝐴, também 

quadrada  de  ordem  𝑛,  na  qual  somamos  uma  linha,  com  um  múltiplo  de  outra, 

deixando as demais linhas inalteradas, então 𝑑𝑒𝑡 𝐵  = 𝑑𝑒𝑡 𝐴 . 

As  propriedades  dos  determinantes  são  de  fundamental  importância  para  obtenção  de 

resultados mais rápidos. 

Demonstrações: 

I) 

Como vimos, por definição a função determinante de uma matriz real 𝐴, quadrada 

de  ordem  𝑛  é  𝑑𝑒𝑡 𝐴  =   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

𝑓

,  com  𝑛! 

parcelas  e  que  em  cada  parcela  aparece  somente  um  elemento  de  cada  linha  da 

matriz 𝐴. Sendo assim, se os elementos de uma das linhas da matriz, digamos a i-
′′ , 𝑎𝑖2
ésima  linha,  forem  𝐴𝑖 =  𝑎𝑖1
ao  calcularmos  o  determinante  da  matriz  𝐴,  em  cada  uma  das  𝑛!  parcelas  do 

′ + 𝑘. 𝑎𝑖𝑛

′ + 𝑘. 𝑎𝑖3

′ + 𝑘. 𝑎𝑖2

′ + 𝑘. 𝑎𝑖1

′′ , … , 𝑎𝑖𝑛

′′ , 𝑎𝑖3

′′   , 

somatório,  aparecerá  um  fator  do  tipo  (𝑎𝑖𝑓(𝑖)

′

′′

+ 𝑘. 𝑎𝑖𝑓 (𝑖)

),  o  que  fará  com  que 

𝑑𝑒𝑡 𝐴  =   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ .  𝑎𝑖𝑓  𝑖 

𝑓

′

′′

+ 𝑘. 𝑎𝑖𝑓  𝑖 

 . ⋯ . 𝑎𝑛𝑓 (𝑛)

e, 

pelas propriedades operacionais dos somatórios, temos: 

𝑑𝑒𝑡 𝐴  =   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓 1 . 𝑎2𝑓 2 . 𝑎3𝑓 3 . ⋯ .  𝑎𝑖𝑓  𝑖 

′

′′

+ 𝑘. 𝑎𝑖𝑓  𝑖 

 . ⋯ . 𝑎𝑛𝑓  𝑛 

= 

𝑓

𝑓

=    𝑠𝑛𝑔 𝑓 . 𝑎1𝑓 1 . 𝑎2𝑓 2 . 𝑎3𝑓 3 . ⋯ . 𝑎𝑖𝑓  𝑖 

. ⋯ . 𝑎𝑛𝑓  𝑛 
+ 𝑠𝑛𝑔 𝑓 . 𝑎1𝑓 1 . 𝑎2𝑓 2 . 𝑎3𝑓 3 . ⋯ . 𝑘. 𝑎𝑖𝑓  𝑖 

′′

′

  +

. ⋯ . 𝑎𝑛𝑓  𝑛   = 

=  𝑠𝑛𝑔 𝑓 . 𝑎1𝑓 1 . 𝑎2𝑓 2 . 𝑎3𝑓 3 . ⋯ . 𝑎𝑖𝑓  𝑖 

𝑓

′

. ⋯ . 𝑎𝑛𝑓  𝑛  +

𝑘.   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓 1 . 𝑎2𝑓 2 . 𝑎3𝑓 3 . ⋯ . 𝑎𝑖𝑓  𝑖 

′′

. ⋯ . 𝑎𝑛𝑓  𝑛 

Portanto, 

𝑓

𝐴1
𝐴2
𝐴3
⋮
′ + 𝑘. 𝐴𝑖
′′
𝐴𝑖
⋮
𝐴𝑛

=

𝐴1
𝐴2
𝐴3
⋮
′
𝐴𝑖
⋮
𝐴𝑛

+ 𝑘.

𝐴1
𝐴2
𝐴3
⋮
′′
𝐴𝑖
⋮
𝐴𝑛

Mostrando com isso que a função determinante é linear em cada uma das linhas de 

uma matriz 𝐴, separadamente. 

 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
50 

II) 

É uma consequência da propriedade I, pois sendo uma matriz real 𝐴 de ordem 𝑛 e 

um escalar real 𝑘, temos 𝑘. 𝐴 =

𝑘. 𝐴1
𝑘. 𝐴2
𝑘. 𝐴3
⋮
𝑘. 𝐴𝑖
⋮
𝑘. 𝐴𝑛  

 e o determinante de 𝐴, por definição será 

𝑑𝑒𝑡 𝑘. 𝐴  =   𝑠𝑛𝑔 𝑓 . 𝑘. 𝑎1𝑓(1). 𝑘. 𝑎2𝑓(2). 𝑘. 𝑎3𝑓(3). ⋯ . 𝑘. 𝑎𝑛𝑓 (𝑛 )

𝑓

= 

=   𝑠𝑛𝑔 𝑓 . 𝑘. 𝑘. 𝑘. ⋯ . 𝑘

𝑓

. 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

=  

𝑛  𝑓𝑎𝑡𝑜𝑟𝑒𝑠

= 𝑘𝑛 .   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

= 𝑘𝑛 . 𝑑𝑒𝑡 𝐴  

𝑓

III) 

Como  sabemos,  dada  uma  matriz  quadrada  de  ordem  𝑛,  temos  𝑑𝑒𝑡 𝐴  =

  𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

𝑓

, com 𝑛! parcelas e que em cada parcela 

aparece somente um elemento de cada linha da matriz 𝐴. Portanto, no cálculo do  

determinante  da  matriz  identidade  de  ordem  𝑛,  somente  uma  das  parcelas  do 

somatório , a saber, 𝑎11. 𝑎22. 𝑎22. ⋯ . 𝑎𝑛𝑛  é não nula e, por tratar-se do produto dos 

elementos da diagonal principal, que são todos iguais a 1, além de essa parcela ser 

obtida através da permutação 𝑓𝑖𝑑𝑒𝑛𝑡𝑖𝑑𝑎𝑑𝑒   e 𝑠𝑛𝑔(𝑓𝑖𝑑𝑒𝑛𝑡𝑖𝑑𝑎𝑑𝑒 )=1, temos 𝑑𝑒𝑡 𝐼𝑛   =

1. 

IV)  Ao  permutarmos  duas  linhas  de  uma  matriz  𝐴,  obtendo  com  isso  uma  matriz  𝐵, 

cada uma das parcelas do somatório da função determinante, 𝑑𝑒𝑡 𝐵 , terá ainda os 

mesmos elementos das parcelas da função  𝑑𝑒𝑡 𝐴 , porém com ordens de índices 

diferentes,  o  que  acarretará  a  mudança  de  𝑠𝑛𝑔 𝑓   em  cada  uma  das  parcelas, 

implicando com isso que 𝑑𝑒𝑡 𝐵  = −𝑑𝑒𝑡 𝐴 . 

V) 

Imaginemos  uma  matriz  quadrada    𝐴,  de  ordem  𝑛,  com  duas  linhas  iguais, 

digamos  𝐿𝑖 e 𝐿𝑗 . Se obtivermos através de uma operação elementar do tipo  𝐿𝑖 ↔

𝐿𝑗 , com 𝑖 ≠ 𝑗, uma matriz 𝐵 a partir da matriz 𝐴, então 𝐴 = 𝐵, pois permutamos 

duas linhas iguais. Isso acarreta que 𝑑𝑒𝑡 𝐵  = 𝑑𝑒𝑡 𝐴 , mas, pela propriedade IV, 

vimos que ao permutarmos duas linhas de uma matriz 𝐴, obtemos uma matriz 𝐵 tal 

que 𝑑𝑒𝑡 𝐵  = −𝑑𝑒𝑡 𝐴 . Das duas igualdades, obtermos que  𝑑𝑒𝑡 𝐴  = 0. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
       
VI) 

Pela propriedade I, temos que 𝐴 =

51 

𝐴1
𝐴2
𝐴3
⋮
𝑘. 𝐴𝑖
⋮
𝐴𝑛  

, com 𝑘 um escalar real, então 𝑑𝑒𝑡 𝐴  =

𝐴1
𝐴2
𝐴3
⋮
𝑘. 𝐴𝑖
⋮
𝐴𝑛

= 𝑘.

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑛

. Suponhamos  que na matriz 𝐴, exista  uma linha, por exemplo  a  

j-ésima,  tal  que  𝐿𝑗 = 𝑘. 𝐿𝑖.  Teremos  então,  𝑑𝑒𝑡 𝐴  =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛

=

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝑘. 𝐴𝑖
⋮
𝐴𝑛

= 𝑘.

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑖
⋮
𝐴𝑛

  e, 

pela propriedade V, temos 

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑖
⋮
𝐴𝑛

= 0, portanto, 𝑑𝑒𝑡 𝐴  = 𝑘. 0 = 0. 

VII)  Seja 𝐴 =  𝑎𝑖𝑗  

𝑛

 uma matriz real e 𝐴𝑡 a sua transposta. Se 𝑓 é uma permutação de 

𝑛  elementos,  então,  𝑎𝑡

𝑖𝑓  𝑖  = 𝑎𝑓 𝑖 𝑖  para  todo  𝑖, 𝑗 ∈  1,2, … , 𝑛 .  Sabemos,  por 

definição  que  𝑑𝑒𝑡 𝐴𝑡   =   𝑠𝑛𝑔 𝑓 . 𝑎𝑓(1)1. 𝑎𝑓(2)2. 𝑎𝑓(3)3. ⋯ . 𝑎𝑓(𝑛)𝑛
bijetiva,  existe  𝑓−1  de  modo  que  quando  𝑖 = 𝑓−1 𝑗 ,  temos    𝑎𝑓(𝑖)𝑖 = 𝑎𝑗 𝑓 −1 𝑗  . 

  e,  como  𝑓  é 

𝑓

Portanto,  temos  𝑎𝑓(1)1. 𝑎𝑓(2)2. ⋯ . 𝑎𝑓(𝑛)𝑛 = 𝑎1𝑓 −1(1). 𝑎2𝑓 −1(2). ⋯ . 𝑎𝑛𝑓 −1(𝑛)  e,  como 

𝑓𝜊𝑓−1 = 𝑓𝑖𝑑𝑒𝑛𝑡𝑖𝑑𝑎𝑑𝑒  e 𝑠𝑛𝑔 𝑓𝑖𝑑𝑒𝑛𝑡𝑖𝑑𝑎𝑑𝑒 =+1, então 𝑓 e 𝑓−1 possuem o mesmo sinal, ou seja, 
𝑠𝑛𝑔 𝑓  = 𝑠𝑛𝑔 𝑓−1 . Notemos ainda que 𝑓 percorre todas as permutações de grau 𝑛 e 

𝑓−1 

também 

percorre, 

pois 

é 

a 

inversa 

de 

𝑓. 

Sendo 

assim, 

𝑑𝑒𝑡 𝐴𝑡   =   𝑠𝑛𝑔 𝑓 . 𝑎𝑓(1)1. 𝑎𝑓(2)2. 𝑎𝑓(3)3. ⋯ . 𝑎𝑓(𝑛)𝑛

𝑓

=

  𝑠𝑛𝑔 𝑓−1 . 𝑎

𝑓

1𝑓−1(1)

. 𝑎2𝑓−1(2). ⋯ . 𝑎𝑛𝑓−1(𝑛)

= 𝑑𝑒𝑡 𝐴 . 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
52 

VIII)  Sejam 𝐴 =  𝑎𝑖𝑗  

, 𝐵 =  𝑏𝑖𝑗  

𝑛

𝑛

 e 𝐶 =  𝑐𝑖𝑗  

𝑛

, tal que 𝐶 = 𝐴. 𝐵, temos por definição 

do produto de matrizes que 𝑐𝑖𝑗 =   𝑎𝑖𝑘 . 𝑏𝑘𝑗

𝑘=1

, para todo 𝑖, 𝑗 ∈  1, 2, 3, … , 𝑛 . 

𝑛

Então, 

det 𝐶  =  

𝑐11
⋮
𝑐𝑛1

𝑐12 ⋯
⋮
⋱
𝑐𝑛2 ⋯

𝑐1𝑛
⋮
𝑐𝑛𝑛

  =    

  𝑎1𝑘1. 𝑏𝑘11   𝑎1𝑘2. 𝑏𝑘22 ⋯
⋱
  𝑎𝑛𝑘1. 𝑏𝑘11   𝑎𝑛𝑘2. 𝑏𝑘22 ⋯

⋮

⋮

  𝑎1𝑘𝑛 . 𝑏𝑘𝑛 𝑛
⋮
  𝑎𝑛𝑘𝑛 . 𝑏𝑘𝑛 𝑛

  = 

Utilizando  a  propriedade  I,  que  trata  da  linearidade  da  função  determinante  em 

cada uma das linhas de uma matriz, a propriedade VII, que garante a linearidade 

também nas colunas e, por sabermos que 𝑑𝑒𝑡 𝐴  = 𝑑𝑒𝑡 𝐴𝑡 , temos 

det 𝐶  =  .
𝑘1

 .
𝑘2

 ⋯ .  .

𝑘𝑛

𝑎1𝑘1. 𝑏𝑘11
⋮

𝑎1𝑘2. 𝑏𝑘22 ⋯
⋱
𝑎1𝑘𝑛 . 𝑏𝑘𝑛 𝑛 𝑎𝑛𝑘2. 𝑏𝑘22 ⋯

⋮

𝑎1𝑘𝑛 . 𝑏𝑘𝑛 𝑛
⋮
𝑎𝑛𝑘𝑛 . 𝑏𝑘𝑛 𝑛

Utilizando  novamente  a  linearidade  nas  𝑛  colunas  (Propriedade  I  e  Propriedade  VII), 

temos: 

det 𝐶  =   𝑏𝑘11. 𝑏𝑘22. ⋯ . 𝑏𝑘𝑛 𝑛

 𝑘1,𝑘2,⋯,𝑘𝑛  

.  

𝑎1𝑘1
⋮
𝑎1𝑘𝑛

𝑎1𝑘2 ⋯
⋱
𝑎𝑛𝑘2 ⋯

⋮

𝑎1𝑘𝑛
⋮
𝑎𝑛𝑘𝑛

Eliminemos  as  parcelas  em  que  𝑘𝑖 = 𝑘𝑗   quando  𝑖 ≠ 𝑗,  pois,  caso  contrário,  teremos 
𝑎1𝑘1
⋮
𝑎1𝑘𝑛

𝑎1𝑘2 ⋯
⋱
𝑎𝑛𝑘2 ⋯

𝑎1𝑘𝑛
⋮
𝑎𝑛𝑘𝑛

  = 0. 

⋮

det 𝐶  =   𝑏𝑘11. 𝑏𝑘22. ⋯ . 𝑏𝑘𝑛 𝑛

𝑘1,𝑘2,⋯,𝑘𝑛
𝑘𝑖≠𝑘𝑗

.  

𝑎1𝑘1
⋮
𝑎1𝑘𝑛

𝑎1𝑘2 ⋯
⋱
𝑎𝑛𝑘2 ⋯

⋮

𝑎1𝑘𝑛
⋮
𝑎𝑛𝑘𝑛

Com a eliminação das colunas iguais, a matriz  

𝑎1𝑘1
⋮
𝑎1𝑘𝑛

𝑎1𝑘2 ⋯
⋱
𝑎𝑛𝑘2 ⋯

⋮

𝑎1𝑘𝑛
⋮
𝑎𝑛𝑘𝑛

  tem as mesmas 

colunas  da  matriz  𝐴,  porém  permutadas  através  de  um  determinado  𝑓.  Assim,  a  matriz 
𝑎1𝑘1
⋮
𝑎1𝑘𝑛

  tem determinante igual ao produto de 𝑠𝑛𝑔 𝑓  por 𝑑𝑒𝑡 𝐴 , o 

𝑎1𝑘2 ⋯
⋱
𝑎𝑛𝑘2 ⋯

𝑎1𝑘𝑛
⋮
𝑎𝑛𝑘𝑛

⋮

que implica que 

 𝑓 

det 𝐶  =   𝑏𝑘11. 𝑏𝑘22. ⋯ . 𝑏𝑘𝑛 𝑛
𝑑𝑒𝑡 𝐶  = 𝑑𝑒𝑡 𝐴 .   𝑠𝑛𝑔 𝑓 . 𝑏𝑘11. 𝑏𝑘22. ⋯ . 𝑏𝑘𝑛 𝑛
Como uma permutação e sua inversa tem mesmo sinal, então  

. 𝑠𝑛𝑔 𝑓 . 𝑑𝑒𝑡 𝐴   

 𝑓 

 𝑓 

  𝑠𝑛𝑔 𝑓 . 𝑏𝑘11. 𝑏𝑘22. ⋯ . 𝑏𝑘𝑛 𝑛
que 𝑑𝑒𝑡 𝐶  = 𝑑𝑒𝑡 𝐴 .   𝑠𝑛𝑔 𝑓 . 𝑏1𝑘1. 𝑏2𝑘2. ⋯ . 𝑏𝑛𝑘𝑛
 𝑓 

=   𝑠𝑛𝑔 𝑓 . 𝑏1𝑘1. 𝑏2𝑘2 . ⋯ . 𝑏𝑛𝑘𝑛

 𝑓 

= 𝑑𝑒𝑡 𝐴 . 𝑑𝑒𝑡 𝐵 . 

 , o que implica 

 
    
    
 
    
  
    
  
 
    
 
 
    
  
    
 
    
  
 
53 

IX) 

 ⟹   Se  𝐴 =  𝑎𝑖𝑗  

𝑛

  é  uma  matriz  real  invertível,  então  existe  𝐴−1  real  tal  que 

𝐴−1. 𝐴 = 𝐴. 𝐴−1 = 𝐼𝑛 .  Fazendo  𝑑𝑒𝑡 𝐴−1. 𝐴  = 𝑑𝑒𝑡 𝐴. 𝐴−1  = 𝑑𝑒𝑡 𝐼𝑛  ,  pela 
propriedade  VIII,  temos  𝑑𝑒𝑡 𝐴. 𝐴−1  = 𝑑𝑒𝑡 𝐴 . 𝑑𝑒𝑡 𝐴−1  = 𝑑𝑒𝑡 𝐴−1 . 𝑑𝑒𝑡 𝐴  =

𝑑𝑒𝑡 𝐴. 𝐴−1 .  Por  essas  duas 
temos  que  𝑑𝑒𝑡 𝐴 . 𝑑𝑒𝑡 𝐴−1  =
igualdades, 
𝑑𝑒𝑡 𝐴−1 . 𝑑𝑒𝑡 𝐴  = 𝑑𝑒𝑡 𝐼𝑛    mas,  pela  propriedade  III,  temos  que  𝑑𝑒𝑡 𝐼𝑛   = 1. 
Portanto,  𝑑𝑒𝑡 𝐴 . 𝑑𝑒𝑡 𝐴−1  = 𝑑𝑒𝑡 𝐴−1 . 𝑑𝑒𝑡 𝐴  = 1  o  que  nos  mostra  que 

𝑑𝑒𝑡 𝐴  ≠ 0. 

 ⟸  Se 𝐴 é uma matriz quadrada de ordem 𝑛 tal que 𝑑𝑒𝑡 𝐴  ≠ 0, então todas as 

linhas  de  𝐴  são  não  nulas.  Pelo  teorema  2.7,  toda  matriz  é  equivalente  a  uma 

matriz na forma escalonada, portanto, existe uma matriz 𝐵 equivalente por linhas a 

matriz 𝐴 com todas as linhas não nulas. Logo,  𝐵 = 𝐼𝑛  e, pelo teorema 2.9 temos 

que 𝐴 é invertível.  

X) 

Suponhamos  que  𝐴 =

𝐴1
𝐴2
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑘
⋮
𝐴𝑛  

  e  que  𝐴𝑖 = 𝛼. 𝐴𝑗 + 𝛽. 𝐴𝑘,  com  𝛼, 𝛽 ∈ ℝ.  Então, 

𝐴 =

𝐴1
𝐴2
⋮
𝛼. 𝐴𝑗 + 𝛽. 𝐴𝑘
⋮
𝐴𝑗
⋮
𝐴𝑘
⋮
𝐴𝑛

  e  𝑑𝑒𝑡 𝐴  =

𝐴1
𝐴2
⋮
𝛼. 𝐴𝑗 + 𝛽. 𝐴𝑘
⋮
𝐴𝑗
⋮
𝐴𝑘
⋮
𝐴𝑛

,  mas  pela  propriedade  I,  temos 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
54 

  e,  pela  propriedade  V,  temos  que 

𝐴1
𝐴2
⋮
𝛼. 𝐴𝑗 + 𝛽. 𝐴𝑘
⋮
𝐴𝑗
⋮
𝐴𝑘
⋮
𝐴𝑛

= 𝛼.

𝐴1
𝐴2
⋮
𝐴𝑗
⋮
𝐴𝑗
⋮
𝐴𝑘
⋮
𝐴𝑛

+ 𝛽.

𝐴1
𝐴2
⋮
𝐴𝑘
⋮
𝐴𝑗
⋮
𝐴𝑘
⋮
𝐴𝑛

que  𝑑𝑒𝑡 𝐴  =

𝑑𝑒𝑡 𝐴  = 0. 

XI) 

Seja  𝐴 =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛  

  .  Suponhamos  que  uma  matriz  𝐵  é  obtida  através  da  soma  da 

𝑖 − é𝑠𝑖𝑚𝑎  linha  da  matriz  𝐴  com  um  múltiplo  da  𝑗 − é𝑠𝑖𝑚𝑎  linha  da  matriz  𝐴, 

. Assim, temos 

.  Temos  ainda, 

permanecendo as demais linhas inalteradas. Então,  𝐵 =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖 + 𝑘. 𝐴𝑗
⋮
𝐴𝑗
⋮
𝐴𝑛

𝑑𝑒𝑡 𝐵  =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖 + 𝑘. 𝐴𝑗
⋮
𝐴𝑗
⋮
𝐴𝑛

  e,  pela  propriedade  I,  𝑑𝑒𝑡 𝐵  =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛

+ 𝑘.

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑗
⋮
𝐴𝑗
⋮
𝐴𝑛

pela propriedade V, 𝑑𝑒𝑡 𝐵  =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛

+ 𝑘. 0 =

𝐴1
𝐴2
𝐴3
⋮
𝐴𝑖
⋮
𝐴𝑗
⋮
𝐴𝑛

= 𝑑𝑒𝑡 𝐴 . 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
55 

3.1.1  Alguns comentários 

A propriedade VII é de extrema importância aos determinantes, pois ela permite-nos 

assumir  todas  as  outras  propriedades  vistas  até  o  momento  com  linhas  de  matrizes  para  as 

colunas das matrizes. 

A  Propriedade  IX  tem  fundamental  importância  no  estudo  dos  determinantes.  Ela 

estabelece um critério de invertibilidade de uma matriz, ou seja, para sabermos se uma matriz 

é  invertível,  basta  verificarmos  se  o  seu  determinante  é  diferente  de  zero.  Além  disso,  essa 

propriedade  permite-nos,  juntamente  com  outros  conceitos,  determinar  a  inversa  de  uma 

matriz, caso ela exista, como veremos mais adiante. 

Em 

geral, 

o 

cálculo 

de 

determinantes 

através 

da 

função 

𝑑𝑒𝑡 𝐴  =   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

𝑓

 é um tanto quanto trabalhoso, uma vez 

que  para  𝑛 ≥ 4,  o  cálculo  do  determinante  por  essa  maneira  torna-se  inviável,  pois  um 

conjunto com 4 elementos, já possui 4! = 24  possíveis bijeções e portanto uma soma com 24 

parcelas no determinante. Com 5 elementos, já seriam possíveis 5! = 120  bijeções e portanto 

uma soma com 120 parcelas no determinante. Para isso existem outras técnicas para o cálculo 

dos determinantes, que abordaremos a seguir: 

3.2  MÉTODOS PARA O CÁLCULO DE DETERMINANTES 

3.2.1  Regra de Sarrus para o cálculo do determinante de uma matriz de ordem 3 

Exemplo: 

Seja 𝐴 =  

4
2
−1
−2
1
3
3 −2 5

  uma matriz de ordem 3. 

A  regra  de  Sarrus  consiste  em  acrescentar,  geralmente  à  direita  do  determinante,  as  duas 

primeiras colunas da matriz, obtendo a seguinte configuração: 

4
2
−1
−2
1
3
3 −2 5

2
−1
−2
3
3 −2

Às  diagonais  traçadas  em  vermelho  denominaremos  diagonais  principais  e  as 

diagonais traçadas em verde são as diagonais secundárias. 

 
 
 
 
 
 
 
 
 
 
   
   
 
56 

O  determinante  da  matriz  é  a  soma  dos  produtos  dos  elementos  das  diagonais 

principais com os simétricos dos produtos dos elementos das diagonais secundárias: 

det 𝐴  = −1.3.5 + 2.1.3 + 4.  −2 .  −2  − 4.3.3 −  −1 . 1.  −2  − 2.  −2 . 5  

det 𝐴  = −15 + 6 + 16 − 36 − 2 + 20  

det 𝐴  = −11  

Notemos  que  a  regra  de  Sarrus  nada  mais  é  do  que  a  aplicação  implícita  da  função 

𝑑𝑒𝑡 𝐴  =   𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

𝑓

. 

3.2.2  Regra de Laplace para o cálculo do determinante 

A  regra  de  Laplace  é  amplamente  utilizada  para  o  cálculo  de  determinantes  de 

matrizes de ordem 𝑛, com 𝑛 ≥ 4, pois através dessa regra, de forma recorrente, diminuímos a 

ordem dos determinantes a serem calculados a cada interação. 

3.2.2.1  Menor complementar 

Seja  𝐴 =  𝑎𝑖𝑗  

𝑛

  uma  matriz.  Considerando  um  elemento  𝑎𝑖𝑗   da  matriz  𝐴, 

denominamos o menor complementar do elemento 𝑎𝑖𝑗  e representamos por 𝐷𝑖𝑗 , como sendo o 

determinante que obtemos ao suprimir na matriz 𝐴 a 𝑖 − é𝑠𝑖𝑚𝑎 linha e a 𝑗 − é𝑠𝑖𝑚𝑎 coluna. 

𝐴 =

Exemplo: 
𝑎11
⋮
𝑎𝑕1
𝑎𝑖1
𝑎𝑗 1
⋮
𝑎𝑛1
⋯
⋱
⋯
⋯
⋱
⋯

𝑎11
⋮
𝑎𝑕1
𝑎𝑗 1
⋮
𝑎𝑛1

⋯
⋱
⋯
⋯
⋯
⋱
⋯
𝑎1𝑖
⋮
𝑎𝑕𝑖
𝑎𝑗𝑖
⋮
𝑎𝑛𝑖

𝑎1𝑖
⋮
𝑎𝑕𝑖
𝑎𝑖𝑖
𝑎𝑗𝑖
⋮
𝑎𝑛𝑖
𝑎1𝑘
⋮
𝑎𝑕𝑘
𝑎𝑗𝑘
⋮
𝑎𝑛𝑘

𝑎1𝑗
⋮
𝑎𝑕𝑗
𝑎𝑖𝑗
𝑎𝑗𝑗
⋮
𝑎𝑛𝑗
⋯
⋱
⋯
⋯
⋱
⋯

𝐷𝑖𝑗 =

𝑎1𝑘
⋮
𝑎𝑕𝑘
𝑎𝑖𝑘
𝑎𝑗𝑘
⋮
𝑎𝑛𝑘
𝑎1𝑛
⋮
𝑎𝑕𝑛
𝑎𝑗𝑛
⋮
𝑎𝑛𝑛

⋯
⋱
⋯
⋯
⋯
⋱
⋯

𝑎1𝑛
⋮
𝑎𝑕𝑛
𝑎𝑖𝑛
𝑎𝑗𝑛
⋮
𝑎𝑛𝑛  

. Considerando o elemento 𝑎𝑖𝑗 , temos que 

 é o seu menor complementar.  

 
  
 
 
 
 
 
 
 
 
 
 
 
    
    
    
    
    
    
 
 
 
 
 
 
 
 
    
    
    
    
    
 
 
  
 
 
57 

3.2.2.2  Complementar algébrico do elemento 𝑎𝑖𝑗  ou cofator de 𝑎𝑖𝑗  

O complementar algébrico ou cofator do elemento 𝑎𝑖𝑗  será representado por 𝐴𝑖𝑗  e, por 

definição, 𝐴𝑖𝑗 =  −1 𝑖+𝑗 . 𝐷𝑖𝑗 . 

O  determinante  de  uma  matriz  𝐴,  pela  regra  de  Laplace  é  -  considerando  uma  linha 

qualquer  (ou  coluna),  por  exemplo  a  𝑖 − é𝑠𝑖𝑚𝑎  -  a  soma  do  produto  de  cada  elemento  da 

linha (ou coluna) pelo seu respectivo cofator, ou seja: 

𝑑𝑒𝑡 𝐴  = 𝑎𝑖1. 𝐴𝑖1 + 𝑎𝑖2. 𝐴𝑖2 + ⋯ + 𝑎𝑖𝑛 . 𝐴𝑖𝑛 =   𝑎𝑖𝑘 . 𝐴𝑖𝑘

𝑘=1

𝑛

Exemplo:  Seja  𝐴 =  

   uma  matriz  de  ordem  3.  O  determinante  de  𝐴, 

4
2
−1
−2
1
3
3 −2 5

segundo a regra de Laplace é dado por: 

𝑑𝑒𝑡 𝐴  = −1.  −1 1+1.  

1
3
  + 2.  −1 1+2.  
−2 5

−2 1
  + 4.  −1 1+3.  
5
3

−2
3
3 −2

𝑑𝑒𝑡 𝐴  = −1.  −1 2.  15 + 2  + 2.  −1 3.  −10 − 3  + 4.  −1 4. (4 − 9)   

𝑑𝑒𝑡 𝐴  = −1.1.17 + 2. (−1).  −13  + 4.1. (−5)  

𝑑𝑒𝑡 𝐴  = −17 + 26 − 20  

𝑑𝑒𝑡 𝐴  = −11  

Notemos que, para a realização do cálculo, foi escolhida a 1ª linha da matriz 𝐴, porém, 

poderíamos ter escolhido qualquer uma das outras linhas para o calculo do determinante e, de 

acordo  com  a  propriedade  VII,  poderíamos  também  ter  utilizado  qualquer  uma  das  colunas 

em vez das linhas. 

A  regra  de  Laplace  também  é  uma  aplicação  implícita  da  função  𝑑𝑒𝑡 𝐴  =

  𝑠𝑛𝑔 𝑓 . 𝑎1𝑓(1). 𝑎2𝑓(2). 𝑎3𝑓(3). ⋯ . 𝑎𝑛𝑓 (𝑛)

𝑓

. 

3.2.3  O método da eliminação de Gauss 

O método da eliminação de Gauss fundamenta-se no teorema a seguir: 

Teorema 3.1: Se 𝐴 =  𝑎𝑖𝑗  

𝑛

 uma matriz triangular inferior (respectivamente superior), então 

temos  𝑑𝑒𝑡 𝐴  = 𝑎11. 𝑎22. 𝑎33. ⋯ . 𝑎𝑛𝑛 , ou seja, o determinante de uma matriz triangular  é o 

produto dos elementos da sua diagonal principal. 

 
 
 
  
 
 
 
58 

Demonstração:  Demonstraremos  esse  fato  utilizando  indução  sobre  𝑛  em  uma  matriz 

triangular inferior, lembrando que para as matrizes triangulares superiores a demonstração é 

análoga. 

Verifiquemos para 𝑛 = 2: 

Seja  𝐴 =  

0
𝑎11
𝑎21 𝑎22

 .  Por  definição,  𝑑𝑒𝑡 𝐴  = 𝑎11. 𝑎22 − 𝑎12. 𝑎21,  porém,  em  uma 

matriz  triangular  inferior,  temos  𝑎𝑖𝑗 = 0,  sempre  que  𝑖 < 𝑗,  assim,  temos  𝑑𝑒𝑡 𝐴  =

𝑎11. 𝑎22 − 0. 𝑎21,  o  que  implica  que  𝑑𝑒𝑡 𝐴  = 𝑎11. 𝑎22  que  é  o  produto  dos  elementos  da 

diagonal principal. Portanto, para 𝑛 = 2 a afirmação é verdadeira. 

Por  hipótese  de  indução,  seja  𝐴 =  𝑎𝑖𝑗  

(𝑛−1)

  uma  matriz  triangular  inferior  tal  que 

𝑑𝑒𝑡 𝐴  = 0.  

Calculemos o determinante de uma matriz 𝐴 =  𝑎𝑖𝑗  

, triangular inferior: 

𝑛

Utilizando a regra de Laplace aplicada à 1ª linha da matriz 𝐴, temos: 

𝑑𝑒𝑡 𝐴  =  

𝑛
𝑘=1

𝑎1𝑘. 𝐴1𝑘

= 𝑎11. 𝐴11 + 𝑎12. 𝐴12 + ⋯ + 𝑎1𝑛 . 𝐴1𝑛 ,  mas  como  𝑎𝑖𝑗 = 0, 

sempre que  𝑖 < 𝑗, então  𝑑𝑒𝑡 𝐴  = 𝑎11. 𝐴11 + 0. 𝐴12 + 0. 𝐴13 + ⋯ + 0. 𝐴1𝑛 = 𝑎11. 𝐴11  temos 
ainda  que  𝐴11 =  −1 1+1. 𝐷11 =  −1 2. 𝐷11 = 𝐷11,  o  que  faz  com  que  𝑑𝑒𝑡 𝐴  = 𝑎11. 𝐷11. 
Mas 𝐷11 é o determinante da matriz obtida ao suprimirmos a 1ª linha e a 1ª coluna da matriz 

𝐴, portanto  uma matriz quadrada de ordem  𝑛 − 1, cuja diagonal  principal são  os elementos 

𝑎22, 𝑎33, 𝑎44, ⋯ , 𝑎𝑛𝑛   e,  por  hipótese  de 
indução,  𝐷11 = 𝑎22. 𝑎33. 𝑎44. ⋯ . 𝑎𝑛𝑛 .  Assim, 
𝑑𝑒𝑡 𝐴  = 𝑎11. 𝐷11 = 𝑎11.  𝑎22. 𝑎33. 𝑎44. ⋯ . 𝑎𝑛𝑛   = 𝑎11. 𝑎22. 𝑎33. 𝑎44. ⋯ . 𝑎𝑛𝑛  que é o produto 

dos elementos da diagonal principal da matriz 𝐴, como queríamos demonstrar. 

Dada uma matriz 𝐴 =  𝑎𝑖𝑗  

𝑛

, o método da eliminação de Gauss consiste em aplicar as 

propriedades dos determinantes com a finalidade de se obter uma matriz 𝐵 =  𝑏𝑖𝑗  

 que seja 

𝑛

triangular,  pois  como  vimos,  calcular  o  determinante  de  uma  matriz  triangular  é  tarefa 

bastante simples. 

Vejamos um exemplo da aplicação do método da eliminação de Gauss no cálculo do 

determinante da matriz 𝐴 =  

4
2
−1
−2
1
3
3 −2 5

 : 

𝑑𝑒𝑡 𝐴  =  

4
2
−1
−2
1
3
3 −2 5

  = 
(𝑃𝑟𝑜𝑝 .  𝐼)

− 2.  

−1
2
1 − 3
2
3 −2

4
− 1
2
5

  = 

(𝑃𝑟𝑜𝑝 .  𝐼)

− 2.3.  

−1
2
1 − 3
2
1 − 2
3

4
− 1
2
5

3

= 
(𝑃𝑟𝑜𝑝 .  𝑋𝐼)

Façamos 𝐿2 → 𝐿1 + 𝐿2 e 𝐿3 → 𝐿1 + 𝐿3. 

 
 
   
59 

4
7

2
17

3

  = 

− 6.

(𝑃𝑟𝑜𝑝 .  𝐼)

1

2

.  −

4

3

  .  

4
2
−1
7
0
1
17
0 −1 −

4

= 
(𝑃𝑟𝑜𝑝 .  𝑋𝐼)

= 
(𝑃𝑟𝑜𝑝 .  𝑋𝐼)

− 6.  

1

−1 2
1
0

2
4

3

Façamos 𝐿3 → 𝐿2 + 𝐿3. 
4
7
11

−1 2
1
0
0
0

= 
(𝑃𝑟𝑜𝑝 .  𝑋𝐼)

4.  

4

  = 4.  −1 . 1.

11

4

= −11  

3.3  Determinantes e matriz inversa 

Uma  das  notáveis  aplicações  para  os  determinantes  é  a  determinação  da  inversa  de 

uma matriz. 

Vimos  anteriormente  que  uma  condição  necessária  e  suficiente  para  que  uma  matriz 

𝐴 =  𝑎𝑖𝑗  

𝑛

 possua inversa é o fato de 𝑑𝑒𝑡 𝐴  ≠ 0. Veremos agora como determinar a inversa 

de uma matriz a partir do seu determinante. 

, representaremos por 𝐴′ a matriz dos cofatores de 𝐴. 

Dada uma matriz 𝐴 =  𝑎𝑖𝑗  

Assim, se 𝐴 =  

𝑎11
𝑎21
⋮
𝑎𝑛1

𝑎12
𝑎22
⋮
𝑎𝑛2

𝑛
⋯
⋯
⋱
⋯

𝑎1𝑛
𝑎2𝑛
⋮
𝑎𝑛𝑛

 , então 𝐴′ =  

𝐴11
𝐴21
⋮
𝐴𝑛1

𝐴12
𝐴22
⋮
𝐴𝑛2

⋯
⋯
⋱
⋯

𝐴1𝑛
𝐴2𝑛
⋮
𝐴𝑛𝑛

 . 

À  matriz  𝐴  =  𝐴′ 𝑡 =  

𝐵11
𝐵21
⋮
𝐵𝑛1

𝐵12
𝐵22
⋮
𝐵𝑛2

⋯
⋯
⋱
⋯

𝐵1𝑛
𝐵2𝑛
⋮
𝐵𝑛𝑛

denominamos matriz adjunta de 𝐴. 

 ,  com  𝐵𝑖𝑗 = 𝐴𝑗𝑖 , 𝑖, 𝑗 ∈  1, 2, … , 𝑛 , 

Teorema  3.2:  Se  𝐴 =  𝑎𝑖𝑗  

𝑛

𝐴. 𝐴  = 𝐴 . 𝐴 = 𝑑𝑒𝑡 𝐴 . 𝐼𝑛  

  é  uma  matriz  e  𝐼𝑛   a  matriz  identidade  de  ordem  𝑛,  então 

𝐴 =  

𝑎11
𝑎21
⋮
𝑎𝑛1

𝑎12
𝑎22
⋮
𝑎𝑛2

⋯
⋯
⋱
⋯

𝑎1𝑛
𝑎2𝑛
⋮
𝑎𝑛𝑛

 , 

cuja 

matriz 

adjunta 

é 

 . Fazendo o produto 𝐴. 𝐴 , temos: 

Demonstração: 

seja 

𝐴  =  

𝐵11
𝐵21
⋮
𝐵𝑛1

𝐵12
𝐵22
⋮
𝐵𝑛2

⋯
⋯
⋱
⋯

𝐵1𝑛
𝐵2𝑛
⋮
𝐵𝑛𝑛

 
 
  
 
 
    
    
    
    
    
    
    
    
    
 
    
    
    
    
    
    
60 

𝐴. 𝐴  =  

𝑎11
𝑎21
⋮
𝑎𝑛1

𝑎12
𝑎22
⋮
𝑎𝑛2

⋯
⋯
⋱
⋯

𝑎1𝑛
𝑎2𝑛
⋮
𝑎𝑛𝑛

  .  

𝐵11
𝐵21
⋮
𝐵𝑛1

𝐵12
𝐵22
⋮
𝐵𝑛2

  =  

𝑐11
𝑐21
⋮
𝑐𝑛1

𝑐12
𝑐22
⋮
𝑐𝑛2

⋯
⋯
⋱
⋯

𝑐1𝑛
𝑐2𝑛
⋮
𝑐𝑛𝑛

𝐵1𝑛
𝐵2𝑛
⋮
𝐵𝑛𝑛

⋯
⋯
⋱
⋯

𝑛

 , 

onde, 

pela  definição  do  produto  de  matrizes,    𝑐𝑖𝑗 =   𝑎𝑖𝑘 . 𝐵𝑘𝑗

𝑘=1

,  mas  como  vimos,  𝐵𝑖𝑗 = 𝐴𝑗𝑖 , 

𝑛

então, 𝑐𝑖𝑗 =   𝑎𝑖𝑘 . 𝐴𝑗𝑘

𝑘=1

. Consideremos os dois casos a seguir: 

1º) 𝑖 = 𝑗 implica que  𝑐𝑖𝑖 =  

𝑛
𝑘=1

𝑎𝑖𝑘 . 𝐴𝑖𝑘

= 𝑑𝑒𝑡 𝐴  

𝑛

2º) 𝑖 ≠ 𝑗 implica que 𝑐𝑖𝑗 =   𝑎𝑖𝑘 . 𝐴𝑗𝑘

Considerando 𝐴 =

𝑎11
𝑎21
⋮
𝑎𝑖1
𝑎𝑗 1
⋮
𝑎𝑛1

𝑎12
𝑎22
⋮
𝑎𝑖2
𝑎𝑗 2
⋮
𝑎𝑛2

𝑘=1
⋯
⋯
⋱
⋯
⋯
⋱
⋯

𝑎1𝑛
𝑎2𝑛
⋮
𝑎𝑖𝑛
𝑎𝑗𝑛
⋮
𝑎𝑛𝑛

. Analisemos essa situação. 

, da qual obtemos uma matriz  

𝐴′ =

𝑎11
𝑎21
⋮
𝑎𝑖1
𝑎𝑖1
⋮
𝑎𝑛1

𝑎12
𝑎22
⋮
𝑎𝑖2
𝑎𝑖2
⋮
𝑎𝑛2

⋯
⋯
⋱
⋯
⋯
⋱
⋯

𝑎1𝑛
𝑎2𝑛
⋮
𝑎𝑖𝑛
𝑎𝑖𝑛
⋮
𝑎𝑛𝑛

    pela  substituição  da  𝑗 − é𝑠𝑖𝑚𝑎  pela  𝑖 − é𝑠𝑖𝑚𝑎  linha. 

→   j-ésima linha 

Pela  propriedade  V,  temos  que  𝑑𝑒𝑡 𝐴′  = 0,  pois  𝐴′   possui  duas  linhas  iguais.  E,  pela 

definição de determinante, aplicada à 𝑗 − é𝑠𝑖𝑚𝑎 linha, temos 𝑑𝑒𝑡 𝐴′  = 𝑎𝑖1. 𝐴𝑗 1 + 𝑎𝑖2. 𝐴𝑗 2 +

𝑛

𝑛

⋯ + 𝑎𝑖𝑛 . 𝐴𝑗𝑛 =   𝑎𝑖𝑘 . 𝐴𝑗𝑘

𝑘=1

, o que implica que  𝑐𝑖𝑗 =   𝑎𝑖𝑘 . 𝐴𝑗𝑘

𝑘=1

= 0, quando 𝑖 ≠ 𝑗. 

Assim,  

𝐴. 𝐴  =  

𝑑𝑒𝑡 𝐴 
0
⋮
0

⋯
0
⋯
1
⋱
⋮
⋯
0
De maneira análoga se demonstra que 𝐴 . 𝐴 = 𝑑𝑒𝑡 𝐴 . 𝐼𝑛 . 

0
0
⋮
𝑑𝑒𝑡 𝐴 

0
𝑑𝑒𝑡 𝐴 
⋮
0

  = 𝑑𝑒𝑡 𝐴 .  

1
0
⋮
0

⋯
⋯
⋱
⋯

0
0
  = 𝑑𝑒𝑡 𝐴 . 𝐼𝑛  
⋮
1

Teorema 3.3: Se 𝐴 é uma matriz invertível, então 𝐴−1 =

1
𝑑𝑒𝑡  𝐴 

. 𝐴 . 

Demonstração: Se 𝐴 é uma matriz invertível, então 𝑑𝑒𝑡 𝐴  ≠ 0. Do teorema 3.2, temos que 
𝑑𝑒𝑡 𝐴 . 𝐼𝑛 = 𝐴 . 𝐴,  multiplicando  à  direita  ambos  os  membros  da  igualdade  por  𝐴−1,  temos: 
 𝑑𝑒𝑡 𝐴 . 𝐼𝑛  . 𝐴−1 =  𝐴 . 𝐴 . 𝐴−1. Aplicando a propriedade associativa do produto de matrizes, 

 
    
    
    
    
    
    
    
    
    
 
 
 
 
 
 
 
    
    
    
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
    
    
 
 
 
 
 
 
 
    
    
    
    
    
    
 
61 

temos  𝑑𝑒𝑡 𝐴 .  𝐼𝑛 . 𝐴−1  = 𝐴 .  𝐴. 𝐴−1   o  que  implica  que  𝑑𝑒𝑡 𝐴 . 𝐴−1 = 𝐴 . 𝐼𝑛 .  Dividindo 

ambos os membros da igualdade por 𝑑𝑒𝑡 𝐴 , temos 𝐴−1 =

1
𝑑𝑒𝑡  𝐴 

. 𝐴 . 

Exemplo: Sendo 𝐴 =  

4
2
−1
 , determinemos a inversa 𝐴−1 da matriz 𝐴: 
−2
1
3
3 −2 5

Temos  que  𝑑𝑒𝑡 𝐴  = −11,  o  que,  pela  propriedade  IX  garante  sua  invertibilidade. 

Determinemos a matriz dos cofatores de 𝐴: 

𝐴′ =  

𝐴11 𝐴12 𝐴13
𝐴21 𝐴22 𝐴23
𝐴31 𝐴32 𝐴33

 , onde: 

𝐴11 =  −1 1+1.  

𝐴12 =  −1 1+2.  

𝐴13 =  −1 1+3.  

𝐴21 =  −1 2+1.  

𝐴22 =  −1 2+2.  

𝐴23 =  −1 2+3.  

𝐴31 =  −1 3+1.  

𝐴32 =  −1 3+2.  

𝐴33 =  −1 3+3.  

  =  −1 2.  3.5 − 1.  −2   = 1.  15 + 2  = 17  

  =  −1 4.  −2. (−2) − 3.3  = 1.  4 − 9  = −5  

  =  −1 3.  −2.5 − 1.3  = −1.  −10 − 3  = 13  

1
3
−2 5
−2 1
5
3
−2
3
3 −2
4
2
  =  −1 3.  2.5 − 4.  −2   = −1.  10 + 8  = −18  
−2 5
−1 4
  =  −1 4.  −1.5 − 4.3  = 1.  −5 − 12  = −17  
3
5
2
−1
3 −2
2 4
3 1
−1 4
−2 1
−1 2
−2 3

  =  −1 6.  −1.3 − 2.  −2   = 1.  −3 + 4  = 1  

  =  −1 5.  −1. (−2) − 2.3  = −1.  2 − 6  = 4  

  =  −1 4.  2.1 − 4.3  = 1.  2 − 12  = −10  

  =  −1 5.  −1.1 − 4.  −2   = −1.  −1 + 8  = −7  

Assim,  𝐴′ =  

 ,  e  a  matriz  adjunta  de  𝐴  é  𝐴  =  

17
−18 −17
−10 −7

13 −5
4
1
. 𝐴 , portanto,  

1
𝑑𝑒𝑡  𝐴 

Pelo teorema 3.3,  𝐴−1 =

17 −18 −10
13 −17 −7
1
4
−5

 . 

𝐴−1 =

1
−11

.  

17 −18 −10
13 −17 −7
1
4
−5

  =

 −

−

17
11
13
11
5
11

18
11
17
11
4
11

−

10
11
7
11
1
11 

−

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
62 

4  ALGUMAS NOÇÕES SOBRE POLINÔMIOS 

Consideremos um conjunto1 𝐴, não vazio, com as operações de adição e multiplicação 

tais que para todo 𝑎, 𝑏, 𝑐 ∈ 𝐴, temos 𝑎 + 𝑏 ∈ 𝐴 e 𝑎. 𝑏 ∈ 𝐴 . 

Consideremos que em relação à adição no conjunto 𝐴, temos as seguintes propriedades: 

I) 

II) 

III) 

IV) 

𝑎 +  𝑏 + 𝑐  =  𝑎 + 𝑏  + 𝑐; 

𝑎 + 𝑏 = 𝑏 + 𝑎; 

∃𝑜 ∈ 𝐴; 𝑎 + 𝑜 = 𝑜 + 𝑎 = 𝑎, onde 𝑜 representa o elemento neutro aditivo; 

∃𝑎′ ∈ 𝐴; 𝑎 + 𝑎′ = 𝑎′ + 𝑎 = 𝑜, no caso, representamos 𝑎′ por −𝑎 

Com relação à multiplicação no conjunto 𝐴, temos as seguintes propriedades: 

I) 

II) 

III) 

IV) 

𝑎.  𝑏. 𝑐  =  𝑎. 𝑏 . 𝑐 

𝑎. 𝑏 = 𝑏. 𝑎 

∃1 ∈ 𝐴; 𝑎. 1 = 1. 𝑎 = 𝑎 

∀𝑎, 𝑏 ∈ 𝐴, 𝑎. 𝑏 = 𝑜  ⟹ 𝑎 = 𝑜 𝑜𝑢 𝑏 = 𝑜 

Temos ainda no conjunto 𝐴 a distributividade da multiplicação em relação à adição, ou seja, 

𝑎.  𝑏 + 𝑐  = 𝑎. 𝑏 + 𝑎. 𝑐. 

Consideremos  um  símbolo  𝑥 ∉ 𝐴 ao qual  denominaremos  de  indeterminada  sobre  𝐴 

considerando 𝑥0 = 1 e 𝑥1 = 𝑥. 

Para todo 𝑛 ∈ ℕ ∪  0 , definimos um polinômio 𝑝(𝑥) com coeficientes no conjunto 𝐴 

como sendo a expressão formal 𝑝 𝑥  =  

= 𝑎0 + 𝑎1𝑥 + 𝑎2𝑥2 + 𝑎3𝑥3 + ⋯ + 𝑎𝑛 𝑥𝑛 , 
𝑎𝑘𝑥𝑘
em que para 0 ≤ 𝑘 ≤ 𝑛  os elementos 𝑎𝑘 ∈ 𝐴 são denominados os coeficientes do polinômio 

𝑛
𝑘=0

𝑝 𝑥 . 

Denominaremos  monômios  de  grau  𝑘  do  polinômio  𝑝 𝑥   às  parcelas  𝑎𝑘𝑥𝑘 ,  com 
𝑘 ≠ 0 e ao coeficiente 𝑎0 de 𝑝 𝑥 , denominaremos termo constante. Se 𝑝 𝑥  = 𝑎0, dizemos 
que 𝑝 𝑥  é um polinômio constante. Se 𝑝 𝑥  = 0, então 𝑝 𝑥  é o polinômio nulo. 

Em  um  polinômio    𝑝 𝑥 ,  não  nulo,  existem    𝑛, 𝑖 ∈ ℕ ∪ {0}    tal  que    𝑎𝑛 ≠ 0      e  
  𝑎𝑖 = 0  ∀𝑖 > 𝑛. Neste caso, dizemos que 𝑛 é o grau do polinômio 𝑝 𝑥  e representamos esse 
fato por 𝑔𝑟 𝑝(𝑥)  = 𝑛. Ao coeficiente 𝑎𝑛 , do termo de maior grau, denominamos coeficiente 
líder de 𝑝 𝑥 . Caso o coeficiente líder de um polinômio 𝑝 𝑥  seja igual a 1 então dizemos que 

1 Conjuntos com as operações de adição e multiplicação que gozam das propriedades do conjunto 𝐴 são 
classificados como domínios de integridade como veremos mais a frente. 

 
 
 
 
 
                                                           
63 

𝑝 𝑥  é um  polinômio mônico. Não definimos  grau para o polinômio nulo  𝑜 𝑥  = 0 + 0𝑥 +

⋯ + 0𝑥𝑛 −1 + 0𝑥𝑛 . 

Representaremos por 𝐴 𝑥  o conjunto de todos os polinômios com os coeficientes no 

conjunto 𝐴. Assim, ℤ 𝑥  é o conjunto de todos os polinômios com coeficientes inteiros, assim 

como  ℚ 𝑥 , ℝ 𝑥   e  ℂ 𝑥   são,  respectivamente,  os  conjuntos  de  todos  os  polinômios  com 

coeficientes  racionais,  reais  e complexos. Notemos que os conjuntos  ℤ, ℚ, ℝ e  ℂ gozam  das 

mesmas propriedades do conjunto 𝐴. 

4.1 

IGUALDADE DE POLINÔMIOS 

Dados dois polinômios 𝑝 𝑥  =  

𝑏𝑘 𝑥𝑘
𝐴, dizemos que 𝑝 𝑥  = 𝑞 𝑥  se 𝑎𝑘 = 𝑏𝑘, para todo 𝑘 ∈  0, 1, 2, … , 𝑛 . 

 e  𝑞 𝑥  =  

𝑎𝑘𝑥𝑘

𝑛
𝑘=0

𝑛
𝑘=0

 com coeficientes em 

4.2  ADIÇÃO DE POLINÔMIOS 

Dados dois polinômios 𝑝 𝑥  =  

𝑎𝑘𝑥𝑘
𝐴, definimos a soma de 𝑝 𝑥  com 𝑞 𝑥 , considerando 𝑚 = 𝑛 ao reescrever 𝑝 𝑥  e 𝑞 𝑥  com 

 com coeficientes em 

 e  𝑞 𝑥  =  

𝑏𝑘 𝑥𝑘

𝑛
𝑘=0

𝑚
𝑘=0

as  mesmas  potências  de  𝑥,  como  𝑝 𝑥  + 𝑞 𝑥  =   (𝑎𝑘 + 𝑏𝑘)𝑥𝑘
𝑏1)𝑥 + (𝑎2 + 𝑏2)𝑥2 + ⋯ + (𝑎𝑛 + 𝑏𝑛 )𝑥𝑛 . 

𝑛
𝑘=0

= (𝑎0 + 𝑏0) + (𝑎1 +

Exemplo:  Dados  os  polinômios  𝑝 𝑥  = −2 + 6𝑥 − 5𝑥2 + 2𝑥4  e  𝑞 𝑥  = 8 + 6𝑥2 +

5𝑥3 − 7𝑥4 + 3𝑥5 em ℤ 𝑥 , temos: 

𝑝 𝑥  + 𝑞 𝑥  =  −2 + 8  +  6 + 0 𝑥 +  −5 + 6 𝑥2 0 + 5 𝑥3 +  2 − 7 𝑥4 + (0 + 3)𝑥5 

𝑝 𝑥  + 𝑞 𝑥  = 6 + 6𝑥 + 𝑥2 + 5𝑥3 − 5𝑥4 + 3𝑥5  

Uma forma prática para resolver a adição de 𝑝 𝑥  com 𝑞 𝑥  é: 

−2  +6𝑥  −5𝑥2  +0𝑥3  +2𝑥4  +0𝑥5 

(+)  +8  +0𝑥  +6𝑥2  +5𝑥3  −7𝑥4  +3𝑥5 

+6  +6𝑥  +𝑥2  +5𝑥3  −5𝑥4  +3𝑥5 

Portanto, 𝑝 𝑥  + 𝑞 𝑥  = 6 + 6𝑥 + 𝑥2 + 5𝑥3 − 5𝑥4 + 3𝑥5 . 

Propriedades da adição de polinômios 

Para  quaisquer  𝑝 𝑥 , 𝑞 𝑥   e  𝑕 𝑥 ,  pertencentes  a  𝐴 𝑥   a  adição  de  polinômios  goza 

das seguintes propriedades: 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
64 

I)  𝑔𝑟 𝑝 𝑥  +  𝑞 𝑥   ≤ 𝑚𝑎𝑥 𝑔𝑟 𝑝 𝑥  , 𝑔𝑟  𝑞 𝑥    

II)   𝑝 𝑥  + 𝑞 𝑥   + 𝑕 𝑥  = 𝑝 𝑥  +  𝑞 𝑥  + 𝑕 𝑥   (associatividade) 

III) 𝑝 𝑥  + 𝑞 𝑥  = 𝑞 𝑥  + 𝑝 𝑥  (comutatividade) 

IV)  𝑝 𝑥  + 𝑜(𝑥) = 𝑝 𝑥 ,  onde  𝑜(𝑥)  representa  o  polinômio  nulo.  (elemento  neutro 

aditivo) 

V)   𝑝 𝑥  +  −𝑝 𝑥   = 0 (existência do polinômio simétrico ou inverso aditivo) 

Demonstrações: 

Consideremos  os  polinômios  𝑝 𝑥 , 𝑞 𝑥   e  𝑕 𝑥 ,  não  nulos,  pertencentes  a  𝐴 𝑥 ,  tais 

que  𝑝 𝑥  =  

𝑛
𝑘=0

𝑎𝑘𝑥𝑘

,  𝑞 𝑥  =  

𝑚
𝑘=0

𝑏𝑘𝑥𝑘

  e  𝑕 𝑥  =  

𝑟
𝑘=0

𝑐𝑘𝑥𝑘

.  Para  as  demonstrações  a 

partir  da  propriedade  II,  consideremos,  sem  perda  de  generalidade,  que  𝑛 = 𝑚 = 𝑟  (basta 

lembrar que um polinômio de grau 𝑚 < 𝑛 pode ser considerado como um polinômio no qual 

os coeficientes a partir do 𝑚 − é𝑠𝑖𝑚𝑜, exclusive, são todos iguais a zero): 

I)  1º. Consideremos 𝑛 > 𝑚: 

Seja 𝑐𝑛  o coeficiente do 𝑛 − é𝑠𝑖𝑚𝑜 termo da soma de 𝑝 𝑥  com 𝑞 𝑥 . Como a partir 
do  𝑚 − é𝑠𝑖𝑚𝑜  termo  (exclusive)  de  𝑞 𝑥   os  coeficientes  são  todos  nulos,  pois 

𝑔𝑟 𝑞 𝑥   = 𝑚, temos 𝑐𝑛 = 𝑎𝑛 + 𝑏𝑛 = 𝑎𝑛 + 0 = 𝑎𝑛 ≠ 0 e, 𝑐𝑖 = 𝑎𝑖 + 𝑏𝑖 = 0 + 0 = 0 

∀𝑖 > 𝑛, pois 𝑔𝑟 𝑝 𝑥   = 𝑛, portanto: 

 𝑔𝑟 𝑝 𝑥  + 𝑞 𝑥   = 𝑛 = 𝑚𝑎𝑥 𝑔𝑟 𝑝 𝑥  , 𝑔𝑟  𝑞 𝑥   . 

2º. Consideremos 𝑛 = 𝑚: 

Temos 𝑐𝑖 = 𝑎𝑖 + 𝑏𝑖 = 0 + 0 = 0 ∀𝑖 > 𝑛, pois 𝑔𝑟 𝑝 𝑥   = 𝑔𝑟 𝑞 𝑥   = 𝑛, mas, caso 

𝑏𝑛 = −𝑎𝑛, então 𝑐𝑛 = 𝑎𝑛 + 𝑏𝑛 = 𝑎𝑛 − 𝑎𝑛 = 0, implicando com isso que 𝑔𝑟 𝑝 𝑥  +

𝑞 𝑥   ≤ 𝑛 = 𝑚𝑎𝑥 𝑔𝑟 𝑝 𝑥  , 𝑔𝑟  𝑞 𝑥   . 

Portanto, fica demonstrado que 𝑔𝑟 𝑝 𝑥 , 𝑞 𝑥   ≤ 𝑚𝑎𝑥 𝑔𝑟 𝑝 𝑥  , 𝑔𝑟  𝑞 𝑥    sempre 

que 𝑝 𝑥  e 𝑞 𝑥  forem polinômios não nulos. 

𝑐𝑘𝑥𝑘

= 

II)  Por definição,  𝑝 𝑥  + 𝑞 𝑥   + 𝑕 𝑥  =   

𝑛
𝑘=0

=   (𝑎𝑘𝑥𝑘 +
𝑛
=   [(𝑎𝑘 +
𝑘=0
=   [𝑎𝑘𝑥𝑘 +
=  

𝑛
𝑘=0

𝑏𝑘𝑥𝑘) +  

𝑛
𝑛
𝑘=0
𝑘=0
𝑏𝑘 )𝑥𝑘 + 𝑐𝑘 𝑥𝑘 ] =   [(𝑎𝑘 +

𝑐𝑘𝑥𝑘 =
𝑛
𝑘=0
(𝑏𝑘 + 𝑐𝑘)𝑥𝑘] =  
𝑛
𝑏𝑘𝑥𝑘
𝑘=0
𝑛
𝑏𝑘 𝑥𝑘
=   (𝑎𝑘 𝑥𝑘
𝑘=0
𝑛
+ 𝑎𝑘 𝑥𝑘 ) =  
𝑘=0

𝑛
𝑎𝑘 𝑥𝑘
+  
𝑘=0
𝑛
+ 𝑎𝑘 )𝑥𝑘 =   (𝑏𝑘𝑥𝑘
𝑘=0

𝑛
𝑘=0
𝑐𝑘𝑥𝑘 ]

𝑛
𝑘=0

+  

𝑛
𝑘=0

𝑎𝑘𝑥𝑘 + [ 
𝑛
III) 𝑝 𝑥  + 𝑞 𝑥  =  
𝑘=0

𝑛
=   (𝑏𝑘
𝑘=0

𝑛
𝑘=0

𝑎𝑘𝑥𝑘
  (𝑎𝑘 +

+  

𝑛
𝑘=0

𝑏𝑘 𝑥𝑘
𝑛
𝑘=0

  +  

𝑛
𝑘=0
𝑐𝑘𝑥𝑘 =

𝑏𝑘)𝑥𝑘 +  
𝑛
𝑏𝑘 ) + 𝑐𝑘 ]𝑥𝑘 =   [𝑎𝑘 +
𝑘=0
𝑐𝑘)𝑥𝑘

=  

𝑛
𝑎𝑘𝑥𝑘 +   (𝑏𝑘 +
𝑘=0

= 𝑝 𝑥  +  𝑞 𝑥  + 𝑕 𝑥   . 

+ 𝑏𝑘 𝑥𝑘 ) =   (𝑎𝑘

𝑛
𝑘=0
𝑎𝑘 𝑥𝑘

+ 𝑏𝑘)𝑥𝑘 = 
= 𝑞 𝑥  + 𝑝 𝑥  . 

𝑏𝑘 𝑥𝑘

𝑛
+  
𝑘=0

(𝑏𝑘 + 𝑐𝑘 )]𝑥𝑘 =  

 
 
 
 
  
IV) Como  0 ∈ 𝐴,  então  o  polinômio  nulo  𝑜(𝑥) ∈ 𝐴 𝑥   e  podemos  representá-lo  por 

65 

0𝑥𝑘

𝑜 𝑥  =  

. Sendo assim, 𝑝 𝑥  + 𝑜 𝑥  =  

𝑛
𝑘=0
=   (𝑎𝑘𝑥𝑘 + 0𝑥𝑘)
polinômio nulo é o elemento neutro da adição. 

=   (𝑎𝑘 + 0)

𝑥𝑘 =  

𝑛
𝑘=0

𝑛
𝑘=0

𝑛
𝑘=0

𝑛
𝑘=0

𝑎𝑘

𝑛
𝑘=0

𝑎𝑘𝑥𝑘 +  
𝑥𝑘 = 𝑝 𝑥  

0𝑥𝑘

=

,  ou 

seja,  o 

V)  𝑝 𝑥  + 𝑞 𝑥  = 𝑜 𝑥  ⟺   𝑎𝑘𝑥𝑘

𝑛
+   𝑏𝑘𝑥𝑘
𝑘=0

=  

𝑛
𝑘=0
+ 𝑏𝑘𝑥𝑘 ) =  

𝑛
𝑘=0

0𝑥𝑘 ⟺

𝑛
⟺   (𝑎𝑘 𝑥𝑘
𝑘=0
⟺   𝑎𝑘 + 𝑏𝑘 = 0  ⟺  𝑏𝑘 = −𝑎𝑘  
𝑛
Assim,  𝑞 𝑥  =   𝑏𝑘𝑥𝑘
𝑘=0
simétrico (ou o inverso aditivo) de 𝑝 𝑥 . 

=   (−𝑎𝑘)𝑥𝑘

𝑛
𝑘=0

𝑛
0𝑥𝑘
𝑘=0 ⟺ 
𝑛
+ 𝑏𝑘)𝑥𝑘 =  
𝑘=0

0𝑥𝑘   ⟺

𝑛
  (𝑎𝑘
𝑘=0

𝑛
= −   𝑎𝑘𝑥𝑘
𝑘=0

= −𝑝 𝑥   é  o  polinômio 

4.3  MULTIPLICAÇÃO DE POLINÔMIOS 

Dados dois polinômios 𝑝 𝑥  e 𝑞 𝑥 , pertencentes a 𝐴 𝑥 , tais que 𝑝 𝑥  =  

𝑎𝑘𝑥𝑘
,  definimos  a  multiplicação  de  𝑝 𝑥   por 𝑞 𝑥   como  sendo  o  polinômio 

𝑚
𝑘=0

e  𝑞 𝑥  =  

𝑛
𝑘=0

𝑏𝑘𝑥𝑘

𝑕 𝑥  ∈ 𝐴 𝑥 ; 𝑕 𝑥  =  

𝑚 +𝑛
𝑘=0

𝑐𝑘𝑥𝑘

, onde 𝑐𝑘 =   𝑎𝑖𝑏𝑘−𝑖

𝑘
𝑖=0

, ou seja, multiplicar 𝑝 𝑥  por 𝑞 𝑥  

consiste em multiplicar cada monômio 𝑎𝑖𝑥𝑖 de 𝑝 𝑥 , 𝑖 ∈  0, 1, 2, … , 𝑚 , por cada termo 𝑏𝑗 𝑥𝑗  

de 𝑞 𝑥 , 𝑗 ∈  0, 1, 2, … , 𝑛 , obtendo 𝑎𝑖𝑥𝑖. 𝑏𝑗 𝑥𝑗 = 𝑎𝑖𝑏𝑗 𝑥𝑖+𝑗  e somando os resultados ao final. 

Exemplo:  Dados  os  polinômios  𝑝 𝑥  = −2 + 6𝑥 − 5𝑥2 + 2𝑥4  e  𝑞 𝑥  = 8 + 6𝑥2 +

5𝑥3 − 7𝑥4 + 3𝑥5 em ℤ 𝑥 , obter o produto 𝑕 𝑥  = 𝑝 𝑥 . 𝑞 𝑥 . 

Solução: 

𝑕 𝑥  =  −2 + 6𝑥 − 5𝑥2 + 2𝑥4 .  8 + 6𝑥2 + 5𝑥3 − 7𝑥4 + 3𝑥5  =  

𝑕 𝑥  = −2.8 +  −2 . 6𝑥2 +  −2 . 5𝑥3 +  −2 .  −7𝑥4  +  −2 . 3𝑥5 + 6𝑥. 8 + 6𝑥. 6𝑥2 +  

+6𝑥. 5𝑥3 + 6𝑥.  −7𝑥4  + 6𝑥. 3𝑥5 +  −5𝑥2 . 8 +  −5𝑥2 . 6𝑥2 +  −5𝑥2 . 5𝑥3 +  

+ −5𝑥2 .  −7𝑥4  +  −5𝑥2 . 3𝑥5 + 2𝑥4. 8 + 2𝑥4. 6𝑥2 + 2𝑥4. 5𝑥3 + 2𝑥4.  −7𝑥4  + 2𝑥4. 3𝑥5 = 

= −16 − 12𝑥2 − 10𝑥3 + 14𝑥4 − 6𝑥5 + 48𝑥 + 36𝑥3 + 30𝑥4 − 42𝑥5 + 18𝑥6 − 40𝑥2 −  

−30𝑥4 − 25𝑥5 + 35𝑥6 − 15𝑥7 + 16𝑥4 + 12𝑥6 + 10𝑥7 − 14𝑥8 + 6𝑥9 =  

= −16 + 48𝑥 +  −12 − 40 𝑥2 +  −10 + 36 𝑥3 +  14 + 30 − 30 + 16 𝑥4 +  

+ −6 − 42 − 25 𝑥5 +  18 + 35 + 12 𝑥6 +  −15 + 10 𝑥7 − 14𝑥8 + 6𝑥9 =  

= −16 + 48𝑥 − 52𝑥2 + 26𝑥3 + 30𝑥4 − 73𝑥5 + 65𝑥6 − 5𝑥7 − 14𝑥8 + 6𝑥9  

Uma forma prática para determinar 𝑕 𝑥  = 𝑝 𝑥 . 𝑞 𝑥  é: 

 
  
  
 
 
 
 
 
 
 
66 

8 

+6𝑥2  +5𝑥3  −7𝑥4  +3𝑥5 

 ∙  

−2  +6𝑥  −5𝑥2 

2𝑥4 

  −16 

−12𝑥2  −10𝑥3  +14𝑥4  −6𝑥5 

  +48𝑥 

+36𝑥3  +30𝑥4  −42𝑥5  +18𝑥6 

 +    

−40𝑥2 

−30𝑥4  −25𝑥5  +35𝑥6  −15𝑥7 

  −16  +48𝑥  −52𝑥2  +26𝑥3  +30𝑥4  −73𝑥5  +65𝑥6  −5𝑥7  −14𝑥8  +6𝑥9 

+16𝑥4 

+12𝑥6  +10𝑥7  −14𝑥8  +6𝑥9 

Propriedades da multiplicação de polinômios 

Para  quaisquer  𝑝 𝑥 , 𝑞 𝑥   e  𝑕 𝑥  pertencentes  a  𝐴 𝑥   a  multiplicação  de  polinômios 

goza das seguintes propriedades: 

I)  𝑔𝑟 𝑝 𝑥  ∙ 𝑞 𝑥   = 𝑔𝑟 𝑝 𝑥   + 𝑔𝑟 𝑞 𝑥   

II)   𝑝 𝑥  ∙ 𝑞 𝑥   ∙ 𝑕 𝑥  = 𝑝 𝑥  ∙  𝑞 𝑥  ∙ 𝑕 𝑥   (associatividade) 

III) 𝑝 𝑥  ∙ 𝑞 𝑥  = 𝑞 𝑥  ∙ 𝑝 𝑥  (comutatividade) 

IV)  𝑝 𝑥  ∙ 1 = 𝑝 𝑥 ,  onde  1  representa  o  polinômio  constante  1.  (elemento  neutro 

multiplicativo) 

V)   𝑝 𝑥  ∙  𝑞 𝑥  + 𝑕 𝑥   = 𝑝 𝑥  ∙ 𝑞 𝑥  + 𝑝 𝑥  ∙ 𝑕 𝑥   (distributividade  da  multiplicação 

em relação à adição) 

Demonstrações: 

Consideremos  os  polinômios  𝑝 𝑥 , 𝑞 𝑥   e  𝑕 𝑥 ,  não  nulos,  pertencentes  a  𝐴 𝑥 ,  tais 

que 𝑝 𝑥  =  

𝑛
𝑘=0

𝑎𝑘 𝑥𝑘

, 𝑞 𝑥  =  

𝑚
𝑘=0

𝑏𝑘𝑥𝑘

 e 𝑕 𝑥  =  

𝑟
𝑘=0

𝑐𝑘𝑥𝑘

. 

I)  𝑔𝑟 𝑝 𝑥   = 𝑛  e  𝑔𝑟 𝑞 𝑥   = 𝑚.  Seja  𝑐𝑘 =   𝑎𝑖𝑏𝑘−𝑖

𝑘
𝑖=0

  um  coeficiente  qualquer  de 

𝑝 𝑥  ∙ 𝑞 𝑥 .  Assim,  temos  𝑐𝑚 +𝑛 =  

𝑚 +𝑛
𝑖=0

𝑎𝑖𝑏𝑚 +𝑛−𝑖 ≠ 0

  e  𝑐𝑘 = 0 ∀𝑘 > 𝑚 + 𝑛, 

portanto, 𝑔𝑟 𝑝 𝑥 . 𝑞 𝑥   = 𝑚 + 𝑛 = 𝑔𝑟 𝑝 𝑥   + 𝑔𝑟 𝑞 𝑥  . 

II)  Primeiramente, notemos que, decorrente da propriedade I, 𝑔𝑟 𝑝 𝑥  ∙  𝑞 𝑥  ∙ 𝑕 𝑥    =

𝑔𝑟  𝑝 𝑥  ∙ 𝑞 𝑥   ∙ 𝑕 𝑥  ,  pois  𝑔𝑟 𝑞 𝑥  ∙ 𝑕 𝑥   = 𝑚 + 𝑟,  o  que 

implica  que 

𝑔𝑟  𝑝 𝑥 .  𝑞 𝑥  ∙ 𝑕 𝑥    = 𝑚 + 𝑛 + 𝑟 = 𝑡.  Em  contra  partida,  temos  𝑔𝑟 𝑝 𝑥  ∙

𝑞 𝑥   = 𝑚 + 𝑛, o que implica que 𝑔𝑟  𝑝 𝑥  ∙ 𝑞 𝑥   ∙ 𝑕 𝑥   = 𝑚 + 𝑛 + 𝑟 = 𝑡. 

Utilizando  a  definição  de  multiplicação  de  polinômios,  façamos  𝑝 𝑥  =  

𝑛
𝑘=0

𝑎𝑘𝑥𝑘

, 

𝑚
𝑖=0

𝑞 𝑥  =   𝑏𝑖𝑥𝑖
𝑚 +𝑛+𝑟
𝑡=0

𝑕(𝑥)  =  

,  𝑕 𝑥  =  

𝑟
𝑗 =0

𝑐𝑗 𝑥𝑗

, 

𝑞 𝑥  ∙ 𝑕(𝑥) =  

𝑚 +𝑟
𝑙=0

𝑑𝑙𝑥𝑙

,  𝑝 𝑥  ∙  𝑞 𝑥  ∙

𝑒𝑡𝑥𝑡

, 

𝑝 𝑥  ∙ 𝑞(𝑥) =  

𝑚 +𝑛
𝑠=0

𝑓𝑠𝑥𝑠

e 

 𝑝 𝑥  ∙ 𝑞 𝑥   ∙ 𝑕(𝑥) =

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
67 

.  Notemos  ainda  que  um  termo  de  um  produto,  por  exemplo,  𝑒𝑡,  é 

𝑚 +𝑛+𝑟
𝑡=0

𝑔𝑡𝑥𝑡
determinado por 𝑒𝑡 =  
𝑎𝑘𝑑𝑡−𝑘
𝑡,  podemos  reescrever  esse  termo  da  seguinte  forma:  𝑒𝑡 =  

𝑡
𝑘=0

 , mas, fazendo  𝑙 = 𝑡 − 𝑘, o que implica 𝑘 + 𝑙 =

𝑘+𝑙=𝑡

𝑎𝑘𝑑𝑙

.  De  maneira 

análoga,  escrevemos  𝑑𝑙 =  

𝑖+𝑗 =𝑙

𝑏𝑖𝑐𝑗

temos 𝑝 𝑥  ∙  𝑞 𝑥  ∙ 𝑕(𝑥)  =  

𝑚 +𝑛+𝑟
𝑡=0

𝑘+𝑖=𝑠

𝑎𝑘𝑏𝑖

  e  𝑔𝑡 =  

𝑠+𝑗 =𝑡

𝑓𝑠𝑐𝑗

.  Assim, 

,  𝑓𝑠 =  
𝑒𝑡𝑥𝑡

, mas 

 𝑒𝑡 =  

𝑘+𝑙=𝑡

𝑎𝑘𝑑𝑙

=  

𝑘+𝑙=𝑡

𝑎𝑘 ∙   

𝑖+𝑗 =𝑙

𝑏𝑖𝑐𝑗

  =

𝑘+𝑖+𝑗 =𝑡

𝑎𝑘 𝑏𝑖𝑐𝑗   =

=  

𝑘+𝑖+𝑗 =𝑡

 𝑎𝑘𝑏𝑖 𝑐𝑗 =

𝑠+𝑗 =𝑡

𝑘+𝑖=𝑠

𝑎𝑘𝑏𝑖

  ∙ 𝑐𝑗 =  

𝑠+𝑗 =𝑡

Portanto, 𝑝 𝑥  ∙  𝑞 𝑥  ∙ 𝑕(𝑥)  =  

𝑚 +𝑛+𝑟
𝑡=0

𝑒𝑡𝑥𝑡

=  

𝑚 +𝑛+𝑟
𝑡=0

𝑓𝑠𝑐𝑗 = 𝑔𝑡
𝑔𝑡𝑥𝑡 =  𝑝 𝑥  ∙ 𝑞 𝑥   ∙ 𝑕(𝑥)

Mostrando assim, a associatividade da multiplicação de polinômios. 

III)  Temos que  𝑝 𝑥  =  

𝑛
𝑘=0

𝑎𝑘𝑥𝑘

 e 𝑞 𝑥  =  

𝑚
𝑘=0

𝑏𝑘𝑥𝑘

.  

Consideremos  𝑝 𝑥  ∙ 𝑞 𝑥  =  

𝑚 +𝑛
𝑘=0

𝑐𝑘𝑥𝑘

,  onde  𝑐𝑘 =   𝑎𝑖𝑏𝑘−𝑖

𝑘
𝑖=0

  e  𝑞 𝑥  ∙ 𝑝 𝑥  =

, onde 𝑑𝑘 =   𝑏𝑖𝑎𝑘−𝑖

𝑘
𝑖=0

. Desenvolvendo 𝑐𝑘 temos: 

𝑚 +𝑛
𝑘=0

𝑑𝑘𝑥𝑘
𝑘
𝑐𝑘 =   𝑎𝑖𝑏𝑘−𝑖
𝑖=0

= 𝑎0𝑏𝑘 + 𝑎1𝑏𝑘−1 + 𝑎2𝑏𝑘−2 + ⋯ + 𝑎𝑘−2𝑏2 + 𝑎𝑘−1𝑏1 + 𝑎𝑘𝑏0 = 2  

𝑏0𝑎𝑘 + 𝑏1𝑎𝑘−1 + 𝑏2𝑎𝑘−2 + ⋯ + 𝑏𝑘−2𝑎2 + 𝑏𝑘−1𝑎1 + 𝑏𝑘𝑎0 =   𝑏𝑖𝑎𝑘−𝑖 = 𝑑𝑘
𝑑𝑘𝑥𝑘
𝑞 𝑥  ∙ 𝑝 𝑥 . Portanto o produto de polinômios goza da propriedade comutativa. 

que  implica  que   

,  mostrando  com  isso  que  𝑝 𝑥  ∙ 𝑞 𝑥  =

𝑐𝑘𝑥𝑘

𝑚 +𝑛
𝑘=0

𝑚 +𝑛
𝑘=0

=  

, 

o 

𝑘
𝑖=0

IV) Consideremos  o  polinômio  constante  𝑢 𝑥  = 1.  Como  1 ∈ 𝐴,  então  𝑢 𝑥  ∈ 𝐴 𝑋 .  

Temos  𝑝 𝑥  ∙ 𝑢 𝑥  =  

𝑛+0
𝑘=0

𝑐𝑘𝑥𝑘

,  com  𝑐𝑘 =   𝑎𝑖𝑏𝑘−𝑖

𝑘
𝑖=0

= 𝑎0. 0 + 𝑎1. 0 + 𝑎2. 0 +

⋯ + 𝑎𝑘−2. 0 + 𝑎𝑘−1. 0 + 𝑎𝑘. 1 = 𝑎𝑘, 

portanto, 

𝑝 𝑥  ∙ 𝑢 𝑥  =  

𝑛+0
𝑘=0

𝑐𝑘𝑥𝑘

=

𝑛
𝑘=0

𝑎𝑘𝑥𝑘 = 𝑝 𝑥 

. Logo, 𝑢 𝑥  = 1 é o elemento neutro multiplicativo em 𝐴 𝑥 . 

V)  Podemos considerar 𝑚 = 𝑟, ao reescrever 𝑞 𝑥  e 𝑕 𝑥  com as mesmas potências de 

𝑥.  Pela  definição  de  multiplicação  de  polinômios,  temos  𝑝 𝑥  ∙ 𝑞 𝑥  =  

𝑛+𝑚
𝑘=0

𝑒𝑘𝑥𝑘

, 

 e 𝑝 𝑥  ∙ 𝑕 𝑥  =  

𝑘
com 𝑒𝑘 =   𝑎𝑖 ∙ 𝑏𝑘−1
𝑖=0
Pela  definição  da  adição  de  polinômios,  temos  𝑞 𝑥  + 𝑕 𝑥  =   (𝑏𝑘 + 𝑐𝑘)𝑥𝑘
Utilizando novamente a definição de multiplicação de polinômios, temos: 

𝑘
, com 𝑓𝑘 =   𝑎𝑖 ∙ 𝑐𝑘−1
𝑖=0

𝑓𝑘 𝑥𝑘

𝑛+𝑚
𝑘=0

𝑚
𝑘=0

. 

. 

𝑝 𝑥  ∙  𝑞 𝑥  + 𝑕 𝑥   =  

𝑚 +𝑛
𝑘=0

𝑑𝑘𝑥𝑘

, onde 𝑑𝑘 =   𝑎𝑖 ∙  𝑏𝑘−1 + 𝑐𝑘−1 

𝑘
𝑖=0

. Utilizando a 

propriedade distributiva da multiplicação em relação à adição em 𝐴, temos: 

𝑑𝑘 =    𝑎𝑖 ∙ 𝑏𝑘−1 + 𝑎𝑖 ∙ 𝑐𝑘−1 

𝑘
𝑖=0

𝑘

=   𝑎𝑖 ∙ 𝑏𝑘−1
𝑖=0         
𝑒𝑘

𝑘

+   𝑎𝑖 ∙ 𝑐𝑘−1
𝑖=0         
𝑓𝑘

, 

portanto, 

𝑝 𝑥  ∙  𝑞 𝑥  + 𝑕 𝑥   =  

𝑚 +𝑛
𝑘=0

𝑑𝑘𝑥𝑘

=  

𝑚 +𝑛
𝑘=0

 𝑒𝑘 + 𝑓𝑘  𝑥𝑘 =  

𝑚 +𝑛
𝑘=0

 𝑒𝑘𝑥𝑘 + 𝑓𝑘𝑥𝑘   =

=  

𝑚 +𝑛
𝑘=0

𝑒𝑘𝑥𝑘 +  

𝑚 +𝑛
𝑘=0

𝑓𝑘 𝑥𝑘 = 𝑝 𝑥  ∙ 𝑞 𝑥  + 𝑝 𝑥  ∙ 𝑕 𝑥 

.  

2 Utilizando a comutatividade da adição e da multiplicação em 𝐴. 

 
 
 
 
 
  
  
 
 
 
 
                                                           
68 

4.4  DIVISÃO EUCLIDIANA DE POLINÔMIOS 

Dados  𝑝 𝑥   e  𝑔 𝑥   pertencentes  a  𝐴 𝑥 ,  com  𝑔 𝑥  ≠ 0,  se  existir  um  polinômio 

𝑞 𝑥  ∈ 𝐴 𝑥 ,  tal  que  𝑝 𝑥  = 𝑔 𝑥  ∙ 𝑞 𝑥 ,  então,  dizemos  que  𝑝 𝑥   é  múltiplo  de  𝑔 𝑥 ,  ou 

ainda que 𝑔 𝑥  divide 𝑝 𝑥 . 

Exemplo: 

𝑔 𝑥  = 5 + 2𝑥 + 𝑥2 ∈ ℤ 𝑥   divide  o  polinômio  𝑝 𝑥  = 10 − 11𝑥 + 𝑥2 − 𝑥3 + 𝑥4 ∈ ℤ 𝑥 , 

pois  existe  𝑞 𝑥  = 2 − 3𝑥 + 𝑥2 ∈ ℤ 𝑥  

tal  que  𝑝 𝑥  = 10 − 11𝑥 + 𝑥2 − 𝑥3 + 𝑥4 =

 5 + 2𝑥 + 𝑥2  ∙  2 − 3𝑥 + 𝑥2  = 𝑔 𝑥  ∙ 𝑞 𝑥 . 

Qualquer que seja 𝑝 𝑥  ∈ 𝐴 𝑥 , se 𝑝 𝑥  ≠ 0, então 𝑝 𝑥  divide 0, onde 0 representa o 

polinômio nulo. 

Teorema  4.1:  Considerando  𝑝 𝑥   e  𝑔 𝑥   polinômios  não  nulos  do  conjunto  𝐴 𝑥 ,  se  𝑔 𝑥  

tem coeficiente líder invertível e divide 𝑝 𝑥 , então 𝑔𝑟 𝑔 𝑥   ≤ 𝑔𝑟 𝑝 𝑥  . 

Demonstração:  Por  hipótese  𝑔 𝑥   divide  𝑝 𝑥   e  são  ambos  não  nulos.  Isto  significa  que 

existe  𝑞 𝑥  ∈ 𝐴 𝑥 ,  não  nulo,  tal  que  𝑝 𝑥  = 𝑔 𝑥  ∙ 𝑞 𝑥 ,  mas,  pela  propriedade  I  da 

multiplicação de polinômios, temos que: 

 𝑔𝑟 𝑔 𝑥   ≤ 𝑔𝑟 𝑔 𝑥   + 𝑔𝑟 𝑞 𝑥   = 𝑔𝑟 𝑔 𝑥  ∙ 𝑞 𝑥   = 𝑔𝑟 𝑝 𝑥  . 

Notemos que em ℤ os únicos elementos invertíveis são o 1 e o −1 enquanto que em 

ℚ, ℝ e ℂ, todo elemento não nulo é invertível. 

Teorema  4.2  (divisão  euclidiana):  Consideremos  o  conjunto  𝐴,  com  suas  propriedades    e 

sejam 𝑝 𝑥  e 𝑔 𝑥  polinômios de 𝐴 𝑥 , com 𝑔 𝑥  não nulo e com coeficiente líder invertível 

no conjunto 𝐴. Então, existem 𝑞 𝑥  e 𝑟 𝑥 , unicamente determinados, pertencentes a 𝐴 𝑥 , tal 

que 𝑝 𝑥  = 𝑞 𝑥  ∙ 𝑔 𝑥  + 𝑟 𝑥 , com 𝑟 𝑥  = 0 ou 𝑔𝑟 𝑟 𝑥   < 𝑔𝑟 𝑔 𝑥  . 

Demonstração:  Consideraremos  𝑔 𝑥  = 𝑏0 + 𝑏1𝑥 + 𝑏2𝑥2 + ⋯ + 𝑏𝑚 𝑥𝑚 ,  com  𝑏𝑚   invertível 
−1 = 1.  Dividiremos  a 
em  𝐴,  ou  seja,  admitindo  que  existe  𝑏𝑚

−1 ∈ 𝐴,  tal  que  𝑏 ∙ 𝑏𝑚

demonstração em duas partes, a primeira trata de provar a existência de 𝑞 𝑥  e 𝑟 𝑥  enquanto 

a segunda provará a unicidade de 𝑞 𝑥  e 𝑟 𝑥 . 

1ª  parte:  Considerando  𝑝 𝑥  = 0,  então  𝑞 𝑥  = 𝑟 𝑥  = 0 ∈ 𝐴 𝑥   e  𝑝 𝑥  = 0 = 0 ∙ 𝑔 𝑥  +

0 = 

= 𝑞 𝑥  ∙ 𝑔 𝑥  + 𝑟 𝑥 . 

 
 
 
 
 
 
69 

Considerando 𝑝 𝑥  ∈ 𝐴, com 𝑝 𝑥  ≠ 0 e 𝑔𝑟 𝑝 𝑥   = 𝑛. Se 𝑛 < 𝑚, basta tomar 𝑞 𝑥  = 0 e 

𝑟 𝑥  = 𝑝 𝑥  que teremos 𝑝 𝑥  = 0 ∙ 𝑔 𝑥  + 𝑝 𝑥  = 𝑞 𝑥  ∙ 𝑔 𝑥  + 𝑟 𝑥 . 
Considerando  𝑛 ≥ 𝑚,  escrevendo  𝑝 𝑥  = 𝑎0 + 𝑎1𝑥 + 𝑎2𝑥2 + ⋯ + 𝑎𝑛 𝑥𝑛 ,  com  𝑎𝑛 ≠ 0, 

demonstramos por indução sobre 𝑛 = 𝑔𝑟 𝑝 𝑥  : 

Se  𝑛 = 0,  temos  𝑔𝑟 𝑝 𝑥   = 0.  Como  𝑛 ≥ 𝑚,  então  0 ≥ 𝑚,  o  que  implica  que  𝑚 = 0  e 

portanto,  𝑔𝑟 𝑔 𝑥   = 0.  Logo,  𝑝 𝑥  = 𝑎0 ≠ 0  e  𝑔 𝑥  = 𝑏0.  Como  𝑏0

−1 ∈ 𝐴,  podemos 

escrever 

𝑝 𝑥  = 𝑎0 = 𝑎0 ∙ 1 + 0 = 𝑎0𝑏0

−1𝑏0 + 0 = 𝑎0𝑏0

−1𝑔 𝑥  + 0 = 𝑞 𝑥  ∙ 𝑔 𝑥  + 𝑟 𝑥 , 

com 𝑞 𝑥  = 𝑎0𝑏0

−1 e 𝑟 𝑥  = 0. 

Suponhamos  que  o  resultado  seja  válido  para  polinômios  com  grau  menor  do  que  𝑛. 

Consideremos  o  polinômio  𝑝1 𝑥  = 𝑝 𝑥  − 𝑎𝑛 𝑏𝑚

−1𝑥𝑛−𝑚 𝑔 𝑥 ,  notemos  que  𝑔𝑟 𝑝1 𝑥   <

𝑔𝑟 𝑝 𝑥    e,  por  hipótese  de  indução,  existem  𝑞1(𝑥)  e  𝑟1(𝑥)  pertencentes  a  𝐴 𝑥 ,  tais  que 

𝑝1 𝑥  = 𝑞1 𝑥  ∙ 𝑔 𝑥  + 𝑟1(𝑥) , com   𝑟1 𝑥  = 0 ou 𝑔𝑟 𝑟1 𝑥   < 𝑔𝑟 𝑔 𝑥  . Assim,  𝑝1 𝑥  =

𝑝 𝑥  − 𝑎𝑛 𝑏𝑚

−1𝑥𝑛−𝑚 𝑔 𝑥 , implicando que: 

𝑝 𝑥  = 𝑝1 𝑥  + 𝑎𝑛 𝑏𝑚
=  𝑞1 𝑥  + 𝑎𝑛 𝑏𝑚

−1𝑥𝑛−𝑚 𝑔 𝑥  =  𝑞1 𝑥  ∙ 𝑔 𝑥  + 𝑟1 𝑥   + 𝑎𝑛 𝑏𝑚

−1𝑥𝑛 −𝑚 𝑔 𝑥  =  

−1𝑥𝑛−𝑚  𝑔 𝑥  + 𝑟1 𝑥  = 𝑞 𝑥 . 𝑔 𝑥  + 𝑟(𝑥),  considerando  𝑟 𝑥  = 𝑟1 𝑥   e  

𝑞 𝑥  = 𝑞1 𝑥  + 𝑎𝑛 𝑏𝑚

−1𝑥𝑛−𝑚 . 

2ª  parte:  Sejam  𝑞1 𝑥 ,  𝑞2 𝑥 ,  𝑟1 𝑥   e  𝑟2 𝑥 ,  com  𝑞1 𝑥  ≠ 𝑞2 𝑥   e  𝑟1 𝑥  ≠ 𝑟2 𝑥 ,  tais  que 

𝑝 𝑥  = 𝑞1 𝑥  ∙ 𝑔 𝑥  + 𝑟1 𝑥  e 𝑝 𝑥  = 𝑞2 𝑥  ∙ 𝑔 𝑥  + 𝑟2 𝑥 , com 𝑟1 𝑥  = 0 ou 𝑔𝑟 𝑟1 𝑥   <

𝑔𝑟 𝑔 𝑥   e 𝑟2 𝑥  = 0 ou 𝑔𝑟 𝑟2 𝑥   < 𝑔𝑟 𝑔 𝑥  . Temos então, 

 𝑞1 𝑥  ∙ 𝑔 𝑥  + 𝑟1 𝑥  = 𝑞2 𝑥  ∙ 𝑔 𝑥  + 𝑟2 𝑥 ,  o  que  implica  que  𝑞1 𝑥  ∙ 𝑔 𝑥  − 𝑞2 𝑥  ∙ 𝑔 𝑥  =
𝑟2 𝑥  − 𝑟1 𝑥   ou  ainda   𝑞1 𝑥  − 𝑞2 𝑥   ∙ 𝑔 𝑥  = 𝑟2 𝑥  − 𝑟1 𝑥 ,  ou  seja,  𝑔 𝑥   divide  𝑟2 𝑥  −
𝑟1 𝑥 ,  mas,  por  hipótese,  𝑞1 𝑥  ≠ 𝑞2 𝑥 ,  o  que  implica  que  𝑞1 𝑥  − 𝑞2 𝑥  ≠ 0  e  𝑟2 𝑥  −

𝑟1 𝑥  ≠ 0 e, pelo teorema 4.1, o fato de  𝑟1 𝑥  = 0 ou 𝑔𝑟 𝑟1 𝑥   < 𝑔𝑟 𝑔 𝑥   e 𝑟2 𝑥  = 0 ou 

𝑔𝑟 𝑟2 𝑥   < 𝑔𝑟 𝑔 𝑥  ,  implica  que  𝑔𝑟 𝑔 𝑥   ≤ 𝑔𝑟 𝑟2 𝑥  − 𝑟1 𝑥   < 𝑔𝑟 𝑔 𝑥  ,  o  que  é 

um absurdo, portanto, a hipótese é falsa o que implica que 𝑞1 𝑥  = 𝑞2 𝑥  e 𝑟1 𝑥  = 𝑟2 𝑥 . 

Sejam  𝑝(𝑥),  𝑔(𝑥),  𝑞(𝑥)  e  𝑟(𝑥),  polinômios  pertencentes  a  𝐴 𝑥 ,  tais  que  𝑝 𝑥  =

𝑞 𝑥  ∙ 𝑔 𝑥  + 𝑟(𝑥), denominaremos 𝑝(𝑥) de dividendo, 𝑔(𝑥) de divisor, 𝑞(𝑥) de quociente e 

𝑟(𝑥)  de  resto.  Uma  maneira  prática  para  determinar  o  quociente  e  o  resto  da  divisão 

euclidiana de um polinômio 𝑝 𝑥  por um polinômio 𝑔(𝑥) com coeficiente líder invertível é a 

utilização do algoritmo a seguir: 

 
 
 
 
70 

𝑝(𝑥)  𝑔(𝑥) 
𝑞(𝑥) 

⋮ 
𝑟(𝑥) 

Exemplos: 

a)  Determinar  o  quociente  e  o  resto  da  divisão  euclidiana  do  polinômio  𝑝 𝑥  = 10 −

11𝑥 + 𝑥2 − 𝑥3 + 𝑥4 pelo polinômio 𝑔 𝑥  = 5 + 2𝑥 + 𝑥2, ambos pertencentes a ℤ 𝑥 . 

Solução: Observemos que  𝑔𝑟 𝑔 𝑥   < 𝑔𝑟 𝑝(𝑥) , além do coeficiente líder de  𝑔 𝑥  

ser invertível em ℤ. 

  +𝑥2  −11𝑥  +10  𝑥2  𝑥2  +5 
𝑥3  −3𝑥  +2 

   𝑥4 
  −𝑥3 
−𝑥4  −2𝑥3  −5𝑥2 
    0  −3𝑥3  −4𝑥2  −11𝑥  +10 
 +3𝑥3  +6𝑥2  +15𝑥 

  0  +2𝑥2  +4𝑥  +10 
−2𝑥2  −4𝑥  −10 
    0 
   0 
     0 

Notemos que  𝑞 𝑥  = 𝑥3 − 3𝑥 + 2 e o fato de 𝑟 𝑥  = 0 implica que 𝑔(𝑥) divide 𝑝(𝑥). 

b)  Determinar  o  quociente  e  o  resto  da  divisão  euclidiana  do  polinômio  𝑝 𝑥  = −1 +

4𝑥 − 2𝑥2 + 5𝑥3 pelo polinômio 𝑔 𝑥  = −2 + 3𝑥 + 𝑥2, ambos pertencentes a ℤ 𝑥 . 

Solução: Observemos que  𝑔𝑟 𝑔 𝑥   < 𝑔𝑟 𝑝(𝑥) , além do coeficiente líder de  𝑔 𝑥  

ser invertível em ℤ. 

    5𝑥3  −2𝑥2  +4𝑥  −1  𝑥2  +3𝑥  −2 

−5𝑥3  −15𝑥2  +10𝑥 

5𝑥  −17 

      0  −17𝑥2  +14𝑥  −1 

+17𝑥2  +41𝑥  −34 

     0 

+55𝑥  −35 

Assim, 𝑞 𝑥  = −17 + 5𝑥 e 𝑟 𝑥  = −35 + 55𝑥. 

Suponhamos  agora  que  o  conjunto  dos  coeficientes  de  um  polinômio  seja  𝐾,  com 

todas  as  propriedades  definidas  anteriormente  para  o  conjunto  𝐴,  e  mais  a  seguinte 

propriedade: 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
71 

∀𝑎 ∈ 𝐾, 𝑎 ≠ 0, ∃𝑏 ∈ 𝐾; 𝑎 ∙ 𝑏 = 1. O elemento 𝑏 é denominado inverso multiplicativo 

de 𝑎 e, por ser único, representamos como 𝑏 = 𝑎−1. Assim, temos um conjunto em, que todos 
os elementos não nulos são invertíveis3. 

Representamos por 𝐾[𝑥] o conjunto de todos os polinômios com coeficientes em 𝐾. 

Considerando o conjunto 𝐴, e um polinômio 𝑝(𝑥) ∈ 𝐴[𝑥], dizemos que 𝛼 é uma raiz 

de 𝑝(𝑥), se 𝑝 𝛼  = 0. 

Considerando o conjunto 𝐾 e 𝑝(𝑥) ∈ 𝐾[𝑥], formulamos o seguinte teorema: 

Teorema 4.3: Considerando 𝐾 o conjunto com as propriedades descritas anteriormente, seja 

𝑝 𝑥   um  polinômio  pertencente  a  𝐾 𝑥   e  𝛼 ∈ 𝐾,  dizemos  que  𝛼  é  uma  raiz  de  𝑝 𝑥   se,  e 

somente se,  𝑥 − 𝛼  divide 𝑝 𝑥 . 

Demonstração:  Pelo  algoritmo  da  divisão  em  𝐾[𝑥]  (idêntico  a  𝐴[𝑥]),  temos  que  existem 

𝑞(𝑥)  e  𝑟(𝑥)  pertencentes  a  𝐾[𝑥]  tais  que  𝑝 𝑥  =  𝑥 − 𝛼 . 𝑞 𝑥  + 𝑟(𝑥),  com  𝑟 𝑥  = 0  ou 

𝑔𝑟 𝑟 𝑥   = 0. Assim, 𝑟 𝑥  = 𝑟 ∈ 𝐾. Logo,  𝛼 é raiz de  𝑝(𝑥) se, e somente se,  0 = 𝑝 𝛼  =

 𝛼 − 𝛼 . 𝑞 𝑥  + 𝑟 = 𝑟,  ou  seja,  se,  e  somente  se,  𝑟 = 0,  quem  em  outras  palavras  significa 

dizer que (𝑥 − 𝛼) divide 𝑝(𝑥). 

O resultado acima se deve ao matemático francês Jean le Rond d’Alembert e, por isso, 

é popularmente conhecido como teorema de d’Alembert. 

Exemplo:  Consideremos  o  polinômio  𝑝 𝑥  = 3 − 7𝑥 − 𝑥2 + 𝑥3.  O  valor  𝛼 = 3  é 

uma raiz de 𝑝(𝑥), pois (𝑥 − 3) divide 𝑝(𝑥): 

𝑥3  −𝑥2  −7𝑥  +3  𝑥  −3 
−𝑥3  +3𝑥2 

𝑥2  +2𝑥  −1 

0  +2𝑥2  −7𝑥 
−2𝑥2  +6𝑥 

0 

−𝑥  +3 
𝑥  −3 
0 
0 

Notemos ainda que 𝑝 3  = 3 − 7 ∙ 3 − 32 + 33 = 3 − 21 − 9 + 27 = 0. 

Teorema  4.4:  Um  polinômio  de  grau  𝑛  com  coeficientes  em  um  conjunto  𝐾  com  as 

propriedades definidas anteriormente, possui, no máximo, 𝑛 raízes distintas nesse conjunto. 

Demonstração: Sejam  𝛼1, 𝛼2, 𝛼3, … , 𝛼𝑚 , 𝑚 raízes distintas em  𝐾 de um polinômio 𝑝(𝑥) 
de  grau  𝑛.  Pelo  teorema  4.3,  temos  que  existe  um  polinômio  𝑞1(𝑥) ∈ 𝐾[𝑥]  tal  que  𝑝 𝑥  =

3 Um conjunto com as propriedades do conjunto 𝐾 recebe o nome de corpo, como veremos mais a frente. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                           
72 

 𝑥 − 𝛼1  ∙ 𝑞1(𝑥).  Como  𝛼2  é  raiz  de  𝑝(𝑥),  então  𝑝 𝛼2  =  𝛼2 − 𝛼1  ∙ 𝑞1(𝛼2).  Como  𝛼1 ≠

𝛼2,  temos  que  𝑞1 𝛼2  = 0,  ou  seja,  𝛼2  é  raiz  de  𝑞1(𝑥),  logo,  existe  𝑞2(𝑥) ∈ 𝐾[𝑥]  tal  que 
𝑝 𝑥  =  𝑥 − 𝛼1  ∙ (𝑥 − 𝛼2) ∙ 𝑞2(𝑥).  Seguimos  esse  procedimento  até  obtermos  𝑞𝑚 (𝑥) ∈
𝐾 𝑥  tal que 𝑃 𝑥  =  𝑥 − 𝛼1  ∙  𝑥 − 𝛼2  ∙  𝑥 − 𝛼3  ∙ … ∙ (𝑥 − 𝛼𝑚 ) ∙ 𝑞𝑚 (𝑥). 

Do exposto acima, temos que 𝑛 = 𝑔𝑟 𝑝 𝑥   = 𝑚 + 𝑔𝑟(𝑞𝑚  𝑥 ), ou seja, 𝑚 ≤ 𝑛. 

4.5 

INTERPOLAÇÃO 

Consideremos  𝐾[𝑥] o conjunto  dos polinômios com  coeficientes no conjunto  𝐾 com 

as  propriedades  definidas  anteriormente.  Sejam  𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑛   elementos  de  𝐾,  distintos 

dois a dois. Consideremos ainda 𝑏1, 𝑏2, 𝑏3, … , 𝑏𝑛  elementos quaisquer de 𝐾. Nosso objetivo é 

determinar um  polinômio  𝑝(𝑥) ∈ 𝐾[𝑥] de grau menor ou igual  a  𝑛 − 1, tal que  𝑝 𝑎𝑖  = 𝑏𝑖, 
∀𝑖 ∈  1, 2, 3, … , 𝑛 . 

Teorema  4.5:  Dados  os  elementos  𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑛   dois  a  dois  distintos  e  𝑏1, 𝑏2, 𝑏3, … , 𝑏𝑛  
pertencentes a 𝐾, o Polinômio 𝑝 𝑥  = 𝑏1𝑝1 𝑥  + 𝑏2𝑝2 𝑥  + 𝑏3𝑝3 𝑥  + ⋯ + 𝑏𝑛 𝑝𝑛 (𝑥), onde 

𝑝𝑗  𝑥  =

 𝑥−𝑎1 ∙ 𝑥−𝑎2 ∙…∙ 𝑥−𝑎𝑗 −1 ∙ 𝑥−𝑎𝑗 +1 ∙…∙ 𝑥−𝑎𝑛 −1 ∙ 𝑥−𝑎𝑛  
 𝑎𝑗 −𝑎1 ∙ 𝑎𝑗 −𝑎2 ∙…∙ 𝑎𝑗 −𝑎𝑗 −1 ∙ 𝑎𝑗 −𝑎𝑗 +1 ∙…∙ 𝑎𝑗 −𝑎𝑛 −1 ∙ 𝑎𝑗 −𝑎𝑛  

  , é o único polinômio em  𝐾[𝑥] 

tal que 𝑝 𝑎𝑖  = 𝑏𝑖, ∀𝑖 ∈  1, 2, 3, … , 𝑛 . 

Demonstração: Escrevendo o polinômio 𝑝(𝑥), temos: 

Tal polinômio pode ser obtido resolvendo o seguinte sistema de equações: 

𝑝 𝑥  = 𝑐𝑛−1𝑥𝑛 −1 + ⋯ + 𝑐1𝑥 + 𝑐0 

𝑐𝑛−1𝑎1

𝑛−1 + ⋯ + 𝑐1𝑎1 + 𝑐0 = 𝑏1

⋮

𝑐𝑛−1𝑎2
𝑐𝑛−1𝑎𝑛

𝑛−1 + ⋯ + 𝑐1𝑎2 + 𝑐0 = 𝑏2
𝑛−1 + ⋯ + 𝑐1𝑎𝑛 + 𝑐0 = 𝑏𝑛

Notemos que o sistema acima possui  𝑛 equações e  𝑛 incógnitas  𝑐1, 𝑐2, 𝑐3, … , 𝑐𝑛  e, a medida 

que  𝑛  assume  valores  maiores,  maior  é  a  dificuldade  em  buscar  a  sua  solução.  Notemos, 

porém, que o fato do sistema possuir 𝑛 equações e 𝑛 incógnitas, implica que ele admite pelo 

menos  uma  solução.  Mais  ainda,  afirmamos  que  a  solução  é  única,  pois  se  considerarmos 

outro  polinômio  𝑞(𝑥) ∈ 𝐾[𝑥]  tal  que  𝑞 𝑎𝑖  = 𝑏𝑖,  ∀𝑖 ∈  1, 2, 3, … , 𝑛 ,  então  o  polinômio 
𝑝 𝑥  − 𝑞(𝑥), com grau menor ou igual a 𝑛 − 1, teria 𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑛  como raízes, o que, em 
virtude  do  teorema  4.4,  é  possível  somente  se  𝑝 𝑥  − 𝑞 𝑥  = 0,  o  que  implica  que  𝑝 𝑥  =

𝑞(𝑥), logo, o polinômio 𝑝(𝑥) é único. 

 
 
 
 
 
 
  
73 

Para 𝑗 ∈  1, 2, 3, … , 𝑛 , definamos os polinômios de grau 𝑛 − 1, 

𝑝𝑗  𝑥  =

 𝑥 − 𝑎1  ∙  𝑥 − 𝑎2  ∙ … ∙  𝑥 − 𝑎𝑗 −1  ∙  𝑥 − 𝑎𝑗 +1  ∙ … ∙  𝑥 − 𝑎𝑛−1  ∙  𝑥 − 𝑎𝑛  
 𝑎𝑗 − 𝑎1  ∙  𝑎𝑗 − 𝑎2  ∙ … ∙  𝑎𝑗 − 𝑎𝑗 −1  ∙  𝑎𝑗 − 𝑎𝑗 +1  ∙ … ∙  𝑎𝑗 − 𝑎𝑛−1  ∙  𝑎𝑗 − 𝑎𝑛  

Temos  𝑝𝑗  𝑎𝑖  =  

0, 𝑠𝑒 𝑖 ≠ 𝑗
1, 𝑠𝑒 𝑖 = 𝑗

 .  Como  cada  polinômio  𝑝𝑗 (𝑥)  tem  grau  𝑛 − 1,  então  a  soma 

𝑏1𝑝1 𝑥  + 𝑏2𝑝2 𝑥  + 𝑏3𝑝3 𝑥  + ⋯ + 𝑏𝑛 𝑝𝑛 (𝑥)  tem grau menor ou igual a 𝑛 − 1, além disso, 
satisfaz  as  condições  𝑝 𝑎𝑖  = 𝑏𝑖,  ∀𝑖 ∈  1, 2, 3, … , 𝑛 ,  logo,  assumimos  𝑝 𝑥  = 𝑏1𝑝1 𝑥  +
𝑏2𝑝2 𝑥  + 𝑏3𝑝3 𝑥  + ⋯ + 𝑏𝑛 𝑝𝑛 (𝑥). 

O polinômio acima é chamado de polinômio de interpolação e o processo descrito para obtê-

lo é denominado interpolação de Lagrange. 

Exemplo: Determinemos o polinômio 𝑝(𝑥) ∈ 𝐾[𝑥] tal que 𝑝 1  = 3, 𝑝 3  = 2, 𝑝 4  = 1 e 

𝑝 6  = 4. 

Solução: 

Temos: 𝛼1 = 1, 𝛼2 = 3, 𝛼3 = 4 e 𝛼4 = 6, assim: 

𝑝1 𝑥  =

 𝑥 − 3  ∙  𝑥 − 4  ∙  𝑥 − 6 
 1 − 3  ∙  1 − 4  ∙  1 − 6 

=

−𝑥3 + 13𝑥2 − 54𝑥 + 72
30

𝑝2 𝑥  =

 𝑥 − 1  ∙  𝑥 − 4  ∙  𝑥 − 6 
 3 − 1  ∙  3 − 4  ∙  3 − 6 

=

𝑥3 − 11𝑥2 + 34𝑥 − 24
6

𝑝3 𝑥  =

 𝑥 − 1  ∙  𝑥 − 3  ∙  𝑥 − 6 
 4 − 1  ∙  4 − 3  ∙  4 − 6 

=

−𝑥3 + 10𝑥2 − 27𝑥 + 18
8

𝑝4 𝑥  =

 𝑥 − 1  ∙  𝑥 − 3  ∙  𝑥 − 4 
 6 − 1  ∙  6 − 3  ∙  6 − 4 

=

𝑥3 − 8𝑥2 + 19𝑥 − 12
30

Como 𝑏1 = 3, 𝑏2 = 2, 𝑏3 = 1 e 𝑏4 = 4, então: 
−𝑥3 + 13𝑥2 − 54𝑥 + 72
30

𝑝 𝑥  = 3 ∙  

  + 2 ∙  

𝑥3 − 11𝑥2 + 34𝑥 − 24
6

  + 1

∙  

−𝑥3 + 10𝑥2 − 27𝑥 + 18
8

  + 4 ∙  

𝑥3 − 8𝑥2 + 19𝑥 − 12
30

𝑝 𝑥  =

−12𝑥3 + 156𝑥2 − 648𝑥 + 864 + 40𝑥3 − 440𝑥2 + 1360𝑥 − 960 − 15𝑥3
120

+ 

+

+150𝑥2405𝑥 + 270 + 16𝑥3 − 128𝑥2 + 304𝑥 − 192
120

𝑝 𝑥  =

29𝑥3 − 262𝑥2 + 611𝑥 − 18
120

Portanto, 𝑝 𝑥  =

29

120

𝑥3 −

131

60

𝑥2 +

611

120

𝑥 −

3

20

. 

 
 
 
 
 
 
 
  
 
 
 
74 

5  ESTRUTURAS ALGÉBRICAS ELEMENTARES 

Abordaremos a seguir as principais estruturas algébricas elementares, destacando suas 

características e as propriedades que as definem. 

5.1  LEI DE COMPOSIÇÃO INTERNA 

Consideremos  um  conjunto não vazio 𝐵. Uma função  𝑓 de  𝐵 × 𝐵  em 𝐵, que a cada 

par   𝑥, 𝑦  ∈ 𝐵 × 𝐵  faz  corresponder  o  elemento  𝑥 ⊕ 𝑦 ∈ 𝐵,  é  denominada  uma  lei  de 

composição interna em 𝐵. Assim, dizemos que 𝐵 é um conjunto munido da operação ⊕. 

Exemplo:  Consideremos  o  conjunto  ℕ  dos  números  naturais  e  seja  𝑓  de  ℕ × ℕ  em  ℕ,  a 

função que a cada par  𝑥, 𝑦  ∈ ℕ × ℕ, faz corresponder ao elemento 𝑥 + 𝑦 que também é um 

número natural. Assim, o conjunto ℕ dos números naturais é munido da operação + (adição), 

ou ainda a adição é uma lei de composição interna em ℕ. 

5.2  GRUPOS 

Consideremos um conjunto 𝐺 munido da operação ⊕. Dizemos que 𝐺 é um grupo em 

relação  à  lei  de  composição  interna  ⊕,  se,  para  todo  𝑥, 𝑦, 𝑧 ∈ 𝐺,  em  relação  a  ⊕  são 

observadas as seguintes propriedades: 

I) 

x ⊕  y ⊕ z  = (x⨁y)⨁z (associatividade) 

II)  ∃𝑒 ∈ 𝐺 tal que 𝑥⨁𝑒 = 𝑒⨁𝑥 = 𝑥 (elemento neutro) 

III)  ∃𝑥′ ∈ 𝐺 tal que 𝑥⨁𝑥′ = 𝑥′ ⨁𝑥 = 𝑒 (todo elemento de G possui simétrico aditivo) 

Quando a lei de composição interna em 𝐺 for a adição  + , dizemos que 𝐺 é um grupo 

aditivo e quando a lei de composição interna em  𝐺 for a multiplicação  ∙ , dizemos que 𝐺 é 

um grupo multiplicativo. 

Representaremos por  𝐺, ⨁  um grupo com a lei de composição interna ⨁. 

Se  além  das  três  propriedades  mencionadas  acima,  dados  𝑥, 𝑦 ∈ 𝐺,  ocorrer  que 

𝑥⨁𝑦 = 𝑦⨁𝑥, então dizemos que 𝐺 é um grupo comutativo ou grupo abeliano4. 

4 Homenagem ao matemático norueguês Niels Henrik Abel (1802-1829). 

 
 
 
 
 
 
 
 
 
 
 
 
 
                                                           
75 

Exemplos: 

1)  Grupo aditivo das matrizes reais quadradas de ordem 𝑛, ou seja,  ℳ𝑛 , + . 

Vimos  no  estudo  das  matrizes  que  a  adição  goza  das  propriedades  associativa, 

elemento  neutro  (matriz  nula)  e  simétrico  aditivo  (matriz  oposta),  portanto,  o  conjunto  ℳ𝑛  

das matrizes quadradas de ordem 𝑛, munido da operação usual de adição é um grupo. Além 

disso,  vimos  que  além  das  três  propriedades  mencionadas  acima,  a  adição  de  matrizes  é 

comutativa, portanto,  ℳ𝑛 , +  é um grupo abeliano. 

2) O conjunto 𝐴 𝑥  de todos os polinômios com coeficientes em 𝐴 (considere 𝐴 com 

as  propriedades  descritas  no  capítulo  sobre  polinômios),  visto  anteriormente,  é  um  grupo 

aditivo  para  a  operação  usual  de  adição,  pois  vimos  que  a  adição  de  polinômios  em  𝐴 𝑥   é 

associativa, existe elemento neutro (polinômio nulo) e todo polinômio em 𝐴 𝑥  é simetrizável. 

Portanto,   𝐴 𝑥 , +   é  um  grupo.  Além  disso,   𝐴 𝑥 , +   é  grupo  abeliano,  pois  a  adição  em 

𝐴 𝑥  é comutativa conforme demonstrado anteriormente. 

3)  O  conjunto  dos  números  inteiros  para  a  operação  usual  de  adição  é  um  grupo 

abeliano, pois dados 𝑥, 𝑦, 𝑧 ∈ ℤ, temos 𝑥 +  𝑦 + 𝑧  =  𝑥 + 𝑦  + 𝑧, 0 ∈ ℤ e 0 + 𝑥 = 𝑥 + 0 =

𝑥  além  de  −𝑥 ∈ ℤ  e  – 𝑥 + 𝑥 = 𝑥 +  −𝑥  = 0.  Notemos  ainda  que  em  ℤ,  𝑥 + 𝑦 = 𝑦 + 𝑥, 

portanto,  ℤ, +  é um grupo abeliano. 

4) O conjunto ℤ3 =  0 , 1 , 2  , dos restos das divisões euclidianas de um numero inteiro 
qualquer  por  3  é  um  grupo    abeliano    em    relação    a    operação    de  adição  definida  por 

𝑥  + 𝑦  = 𝑥 + 𝑦

       ,  ∀𝑥 , 𝑦  ∈ ℤ3. Observemos a tábua de operação em ℤ3: 
+  0   1   2  
0   0   1   2  
1   1   2   0  
2   2   0   1  

Notemos  que  quaisquer  que  sejam  𝑥, 𝑦, 𝑧 ∈ ℤ3,  temos  𝑥 +  𝑦 + 𝑧  = (𝑥 + 𝑦) + 𝑧, 
𝑥 + 𝑦 = 𝑦 + 𝑥 , 0  é o elemento neutro da adição, pois 𝑥 + 0  = 0  + 𝑥 = 𝑥 além de 1  e 2  serem os 

simétricos aditivos, respectivamente, de 2  e 1 . Portanto,  ℤ3, +  é um grupo abeliano. 

 5) O conjunto 𝐺 =  −1,1 , munido da lei de composição interna multiplicação usual 

é um grupo abeliano, vejamos a tábua da operação: 

∙  −1 

1 
1  −1 
1 

−1 
1  −1 

Notemos que para todo 𝑥, 𝑦, 𝑧 ∈ 𝐺, temos 𝑥 ∙  𝑦 ∙ 𝑧  = (𝑥 ∙ 𝑦) ∙ 𝑧, 
𝑥. 𝑦 = 𝑦. 𝑥,  𝑥. 1 = 1. 𝑥 = 𝑥,  além  de  −1  e  1  serem  os  simétricos 
multiplicativos (inversos), respectivamente de −1 e 1. 

Portanto,  𝐺,∙  é um grupo abeliano. 

 
 
 
 
 
 
  
 
 
76 

6) O Conjunto ℕ =  1, 2, 3, …   com a operação usual de adição não é um grupo, pois, 

embora  a  adição  de  números  naturais  seja  associativa,  esse  conjunto  não  possui  elemento 

neutro aditivo e seus elementos não são simetrizáveis na adição. 

De  maneira  análoga,  o  conjunto  ℕ =  1, 2, 3, …    com  a  operação  de  multiplicação 

usual não é um grupo, pois, embora a multiplicação de números naturais seja associativa, e o 

número 1 seja o elemento neutro multiplicativo, o único elemento simetrizável (invertível) na 

multiplicação é o número 1. 

7) O conjunto ℤ dos números inteiros com a multiplicação usual não é um grupo, pois 

embora  a  multiplicação  de  números  inteiros  seja  associativa  e  o  número  1  seja  o  elemento 

neutro multiplicativo, somente os elementos 1 e −1 são invertíveis. 

8)  O  conjunto  ℳ𝑛   das  matrizes  quadradas  de  ordem  𝑛,  com  a  operação  de 

multiplicação  usual  de  matrizes  não  é  um  grupo,  pois  embora  a    multiplicação  de  matrizes 

seja  associativa  e  a  matriz  𝐼𝑛     (matriz  identidade  de  ordem  𝑛)  seja  o  elemento  neutro 

multiplicativo, nem todas as matrizes quadradas de ordem 𝑛 são invertíveis. 

9)  O  conjunto  ℤ4 =  0 , 1 , 2 , 3  ,  dos  restos  das  divisões  euclidianas  de  um  número 
inteiro  qualquer  por  4  não  é  um  grupo  em  relação  à  operação  usual  de  multiplicação,  pois 

embora  a  multiplicação  usual  seja  associativa  em  ℤ4    e  o  número  1  seja  o  elemento  neutro 

multiplicativo, o elemento 2 não é invertível. 

5.2.1  Subgrupos 

Considerando  𝐺, ⨁  um grupo e 𝐻 um subconjunto não vazio de 𝐺, dizemos que 𝐻 é 

um  subgrupo  de  𝐺  se  dados  𝑥, 𝑦 ∈ 𝐻  temos  𝑥⨁𝑦 ∈ 𝐻  e  além  disso,   𝐻, ⨁   é  também  um 

grupo. 

Exemplo: 

Considerando  o  Grupo  aditivo  dos  números  reais   ℝ, + ,  temos  que   ℤ, +   é  um 

subgrupo de ℝ, pois ℤ ⊂ ℝ, dados 𝑥, 𝑦 ∈ ℤ temos 𝑥 + 𝑦 ∈ ℤ além de a adição nos inteiros ser 

associativa, possuir elemento neutro e, para todo 𝑥 ∈ ℤ, temos −𝑥 ∈ ℤ tal que – 𝑥 + 𝑥 = 𝑥 +

 −𝑥  = 0, isto é, todo elemento de ℤ possui simétrico. 

Notemos que se  𝐻, ⨁  é um subgrupo  𝐺, ⨁  e, sendo 𝑒𝑕  e 𝑒 os elementos neutros de 

𝐻 e 𝐺, respectivamente, então é fácil verificar que 𝑒𝑕 = 𝑒, pois temos que 𝑒𝑕 ⨁𝑥 = 𝑥 = 𝑒⨁𝑥 

operando a direita da dos membros da igualdade com o elemento  𝑥′ que é o simétrico de 𝑥, 

 
 
 
77 

temos 𝑒𝑕 ⨁ 𝑥⨁𝑥′  = 𝑒⨁ 𝑥⨁𝑥′  o que implica que 𝑒𝑕 ⨁𝑒 = 𝑒⨁𝑒, concluindo com isso que 

𝑒𝑕 = 𝑒. 

O  teorema  a  seguir  constitui  uma  ferramenta  fácil  para  verificar  se  um  subconjunto 

não vazio 𝐻 ⊂ 𝐺 é um subgrupo de 𝐺 em relação a uma lei de composição interna ⨁ de 𝐺: 

Teorema 5.1: Seja  𝐺, ⨁  um grupo. Um conjunto não vazio 𝐻 ⊂ 𝐺 é um subgrupo de 𝐺 se, 

e somente se, ∀𝑥, 𝑦 ∈ 𝐻, temos 𝑥⨁𝑦′ ∈ 𝐻. Onde 𝑦′ representa o simétrico de 𝑦. 

Demonstração: 

 ⟹   Se  𝐻 ⊂ 𝐺  é  um  subgrupo  de  𝐺  então,  ∀𝑥, 𝑦 ∈ 𝐻,  vale  que  𝑦′ ∈ 𝐻  e,  sendo  ⨁ 

uma operação definida em 𝐻, então 𝑥⨁𝑦′ ∈ 𝐻. 

 ⟸   Suponhamos  que  ∀𝑥, 𝑦 ∈ 𝐻,  𝑥⨁𝑦′ ∈ 𝐻.  Tomando  𝑦 = 𝑥,  temos  que  𝑥⨁𝑥′ =

𝑒 ∈ 𝐻. Por hipótese, e pelo fato de 𝑒 ∈ 𝐻, temos que 𝑒⨁𝑦′ = 𝑦′ ∈ 𝐻. Com isso garantimos a 

existência do elemento neutro da operação ⨁ em 𝐻, além de mostrar que todos os elementos 

de  𝐻  são  simetrizáveis  em  relação  a  essa  operação.  Dados  𝑥, 𝑦 ∈ 𝐻,  em  virtude  do  que  foi 

visto, temos que 𝑥⨁ 𝑦′  ′ = 𝑥⨁𝑦 ∈ 𝐻, garantindo que 𝐻 é fechado para a operação ⨁ que é 

lei de composição interna de 𝐺. Além disso, por herança, a igualdade 𝑥⨁ 𝑦⨁𝑧  = (𝑥⨁𝑦)⨁𝑧 

é válida em 𝐻. Portanto, 𝐻 é um subgrupo de 𝐺. 

5.3  ANÉIS 

Consideremos  um  conjunto  𝐴  não  vazio  munido  das  leis  de  composição  internas  + 

(adição) e • (multiplicação). 

Dizemos  que  𝐴  é  um  anel  se,  em  relação  à  adição  em  𝐴,  for  um  grupo  abeliano,  ou 

seja, ∀𝑥, 𝑦, 𝑧 ∈ 𝐴: 

I) 

x +  y + z  =  x + y  + z (associatividade) 

II)  ∃𝑒 ∈ 𝐺 tal que 𝑥 + 𝑒 = 𝑒 + 𝑥 = 𝑥 (elemento neutro) 

III)  ∃𝑥′ ∈ 𝐺 tal que 𝑥 + 𝑥′ = 𝑥′ + 𝑥 = 𝑒 (todo elemento de G é simetrizável) 

IV)  𝑥 + 𝑦 = 𝑦 + 𝑥 (comutatividade) 

e, se em relação a multiplicação, temos 𝑥 ∙  𝑦 ∙ 𝑧  = (𝑥 ∙ 𝑦) ∙ 𝑧 (associatividade). Além disso, 

a multiplicação é distributiva em relação à adição, ou seja, 𝑥 ∙  𝑦 + 𝑧  = 𝑥 ∙ 𝑦 + 𝑥 ∙ 𝑧. 

Nas  condições  expostas  acima,  dizemos  que  𝐴  é  um  anel  e  representamos  isso  por 

 𝐴, +,∙  . 

 
 
 
 
 
78 

Se  para  todo  𝑥, 𝑦 ∈ 𝐴,  tivermos  𝑥 ∙ 𝑦 = 𝑦 ∙ 𝑥,  dizemos  que  𝐴  é  um  anel  comutativo. 

Além disso, se existir 𝑢 ∈ 𝐴 tal que para todo 𝑥 ∈ 𝐴 𝑢 ∙ 𝑥 = 𝑥 ∙ 𝑢 = 𝑥, então 𝐴 é um anel com 

unidade. 

Em um anel 𝐴, comutativo com unidade, onde para todo 𝑥, 𝑦 ∈ 𝐴, se 𝑥. 𝑦 = 0 implicar 

que  𝑥 = 0  ou  𝑦 = 0,  então  dizemos  que  𝐴  é  um  anel  de  integridade  ou  um  domínio  de 

integridade.  Decorre  dessa  observação,  uma  propriedade  dos  domínios  de  integridade,  que 

conhecemos como lei do anulamento do produto e enunciaremos a seguir: 

Sejam  𝑥, 𝑦, 𝑧 ∈ 𝐴  e   𝐴, +,∙   é  um  domínio  de  integridade,  se  𝑧 ≠ 0  e  𝑥 ∙ 𝑧 = 𝑦 ∙ 𝑧, 

então 𝑥 = 𝑦. 

Demonstração: 

Se 𝑥, 𝑦, 𝑧 ∈ 𝐴 e  𝐴, +,∙  é um domínio de integridade, então cada elemento de 𝐴 possui 

simétrico aditivo, além de a multiplicação ser distributiva em relação à adição e 𝐴 não possuir 

divisores próprios de zero. Sendo assim, somando −𝑦 ∙ 𝑧 a ambos os membros da igualdade 

𝑥 ∙ 𝑧 = 𝑦 ∙ 𝑧, temos  𝑥 ∙ 𝑧 − 𝑦. 𝑧 = 𝑦 ∙ 𝑧 − 𝑦. 𝑧, o que implica  que  (𝑥 − 𝑦) ∙ 𝑧 = 0. Como 𝑧 ≠

0,  então  𝑥 − 𝑦 = 0.  Somando  𝑦  a  ambos  os  membros  da  igualdade  𝑥 − 𝑦 = 0,  temos 

𝑥 − 𝑦 + 𝑦 = 0 + 𝑦, o que implica que 𝑥 = 𝑦. 

Exemplos: 

1) O Conjunto ℳ2  das matrizes reais,  quadradas de  ordem  2,  munido das operações 

usuais de adição e multiplicação é um anel, pois em relação a adição é um grupo abeliano. Em 

relação à multiplicação,  temos a propriedade associativa e  a multiplicação é distributiva em 

relação  à  adição.  Portanto,   ℳ2, +,∙   é  um  anel.  Além  disso,  a  matriz  identidade  𝐼2  é  o 
elemento neutro multiplicativo, portanto,  ℳ2, +,∙  é anel com unidade. Notemos, porém, que 

 ℳ2, +,∙   não  é  comutativo  e  apresenta  divisores  próprios  de  zero,  vejamos:   

0 1
0 0

  ∙

1 0
0 0

  =  

0 0
0 0

  e  

1 0
0 0

  ∙  

0 1
0 0

  =  

0 1
0 0

 . Logo,  ℳ2, +,∙  não é domínio de integridade. 

2) O conjunto   ℤ, +,∙  é um domínio de integridade, pois  ℤ é um grupo abeliano em 

relação  à  adição,  como  já  vimos  e,  a  multiplicação  em  ℤ  é  associativa,  é  distributiva  em 

relação  à  adição,  é  comutativa  e  o  número  1  é  a  unidade.  Além  disso,  dados  𝑥, 𝑦 ∈ ℤ,  se 

𝑥. 𝑦 = 0, então 𝑥 = 0 ou 𝑦 = 0. 

3)  O  conjunto  𝐴  dos  coeficientes  dos  polinômios  do  conjunto  𝐴 𝑥 ,  com  as 

propriedades apresentadas no capítulo 4 é um domínio de integridade. 

4) O conjunto ℤ3 =  0 , 1 , 2  , dos restos das divisões euclidianas de um numero inteiro 

qualquer por 3 é um domínio de integridade, observe as tábuas de operações em ℤ3: 

 
 
 
79 

+  0   1   2  
0   0   1   2  
1   1   2   0  
2   2   0   1  

∙  0   1   2  
0   0   0   0  
1   0   1   2  
2   0   2   1  

Notemos que em relação à adição ℤ3 é um grupo abeliano e que a multiplicação é associativa, 

comutativa e possui a unidade. Além disso, a multiplicação é distributiva em relação à adição 

e ℤ3 não possui divisores próprios de zero. 

5)  O  conjunto  ℤ4 =  0 , 1 , 2 , 3  ,  dos  restos  das  divisões  euclidianas  de  um  número 
inteiro  qualquer  por  4  é  um  anel  comutativo  com  unidade,  porém  não  é  um  domínio  de 

integridade, pois em ℤ4 temos 2.2 = 4 = 0, ou seja, ℤ4 possui divisores próprios de zero. 

6) O conjunto 𝐴 𝑥  dos polinômios com coeficientes no domínio de integridade  𝐴, é 

também  um  domínio  de  integridade.  Como  vimos  em  4.2  e  4.3,  em  relação  à  adição,  𝐴 𝑥  

possui  as  propriedades  associativa,  comutativa,  elemento  neutro  aditivo  (polinômio  nulo)  e 

cada  polinômio  em  𝐴 𝑥   possui  um  polinômio  simétrico.  A  multiplicação  de  polinômio  é 

associativa,  é  comutativa,  existe  o  polinômio  constante  𝑝 𝑥  = 1  que  é  a  unidade 

multiplicativa e, além disso, se 𝑝 𝑥 . 𝑞 𝑥  = 0  então 𝑝 𝑥  ou 𝑞 𝑥  é o polinômio nulo. 

Observemos que o conjunto dos restos das divisões de um inteiro qualquer por  𝑚, o 

        }  é  um  anel  comutativo  com  unidade.  A  seguir 

conjunto  ℤ𝑚 = {1,   2 , 3 , … , 𝑚 − 1
demonstraremos um importante teorema sobre anéis: 
Teorema  5.2:  O  anel  comutativo  com  unidade  ℤ𝑚 = {1,   2 , 3 , … , 𝑚 − 1
integridade se, e somente se 𝑚 é primo. 

        }  é  um  domínio  de 

Demonstração: 

(⇒) Se 𝑚 não for primo, então existem 𝑥 e 𝑦 pertencentes a ℤ de tal forma que tal que 
𝑥 ∙ 𝑦 = 𝑚, com 1 < 𝑥 < 𝑦 < 𝑚, o que implica que 𝑥 , 𝑦  ∈ ℤ𝑚  e 𝑥  ∙ 𝑦  = 𝑚  = 0 , ou seja, ℤ𝑚  
possui divisores próprios de zero e, portanto, não é um domínio de integridade. 

(⇐)  Suponhamos  que  existam  𝑥 , 𝑦  ∈ ℤ𝑚 ,  de  modo  que  𝑥  ∙ 𝑦  = 𝑥 ∙ 𝑦       = 0 ,  então 
𝑥 ∙ 𝑦 = 𝑘 ∙ 𝑚,  𝑘 ∈ ℤ.  Decorre  desse  fato  que  𝑚|𝑥 ∙ 𝑦.  Como  𝑚  é  um  número  primo,  então 
𝑚|𝑥 ou 𝑚|𝑦, o que implica que 𝑥 = 𝑎 ∙ 𝑚 ou 𝑦 = 𝑏 ∙ 𝑚, 𝑎, 𝑏 ∈ ℤ, portanto 𝑥  = 0  ou 𝑦  = 0 , 

logo, ℤ𝑚  é um domínio de integridade.  

 
 
 
 
 
 
 
 
 
 
80 

5.3.1  Subanéis 

Considerando   𝐴, +,∙  um  anel, dizemos  que um subconjunto  não vazio  𝐵 ⊂ 𝐴 é um 

subanel  de  𝐴,  se  𝐵  é  fechado  para  as  duas  leis  de  composição  interna  de  𝐴,  ou  seja,  dados 

𝑥, 𝑦 ∈ 𝐵, temos 𝑥 + 𝑦 ∈ 𝐵 e 𝑥 ∙ 𝑦 ∈ 𝐵 e, além disso, 𝐵 for um anel em relação às operações + 

e ∙. 

Exemplo: 

Considerando  o  anel  (ℤ, +,∙)  dos  inteiros,  o  subconjunto  2ℤ  dos  números  inteiros 

pares é um subanel de ℤ. Verifiquemos: 

Para  todo  𝑥, 𝑦 ∈ 2ℤ,  temos  𝑥 = 2𝑎  e  𝑦 = 2𝑏,  𝑎, 𝑏 ∈ ℤ.  Sendo  assim,  𝑥 + 𝑦 = 2𝑎 + 2𝑏 =

2(𝑎 + 𝑏) ∈ 2ℤ  e  𝑥. 𝑦 = 2𝑎. 2𝑏 = 4𝑎𝑏 = 2(2𝑎𝑏) ∈ 2ℤ,  portanto,  a  adição  e  a  multiplicação 

de ℤ são fechadas em  2ℤ.  Além  disso, para todo 𝑥, 𝑦, 𝑧 ∈ 2ℤ, temos 𝑥 = 2𝑎,  𝑦 = 2𝑏 e 𝑧 =

2𝑐,  com  𝑎, 𝑏, 𝑐 ∈ ℤ,  assim,  𝑥 +  𝑦 + 𝑧  = 2𝑎 +  2𝑏 + 2𝑐  = 2𝑎 + 2 𝑏 + 𝑐  = 2 𝑎 +

 𝑏 + 𝑐   = 2  𝑎 + 𝑏  + 𝑐  = 2 𝑎 + 𝑏  + 2𝑐 =  2𝑎 + 2𝑏  + 2𝑐 =  𝑥 + 𝑦  + 𝑧; 

0 = 2.0 ∈

2ℤ e é o elemento neutro da adição pois 𝑥 + 0 = 2𝑎 + 2.0 = 2 𝑎 + 0  = 2𝑎 = 𝑥; para todo 

𝑥 ∈ 2ℤ, fazendo  𝑥 + 𝑥′ = 0, temos 2𝑎 + 𝑥′ = 0, como 2𝑎 ∈ ℤ e ℤ é uma anel, então −2𝑎 é 

o  simétrico  de  2𝑎  em  ℤ.  Somando  −2𝑎  em  ambos  os  membros  da  igualdade  2𝑎 + 𝑥′ = 0 

temos  −2𝑎 + 2𝑎 + 𝑥′ = −2𝑎 + 0,  o  que  implica  que    𝑥′ = −2𝑎 = −𝑥 ∈ 2ℤ;  temos  ainda 

que 𝑥 + 𝑦 = 2𝑎 + 2𝑏 = 2 𝑎 + 𝑏  = 2 𝑏 + 𝑎  = 2𝑏 + 2𝑎 = 𝑦 + 𝑥. Mostrando com isso que 

 2ℤ, +  é um grupo abeliano. 

Com  relação  à  multiplicação, 

temos  𝑥.  𝑦. 𝑧  = 2𝑎.  2𝑏. 2𝑐  =  2𝑎. 2𝑏 . 2𝑐 =  𝑥. 𝑦 . 𝑧. 

Temos 

ainda 

𝑥.  𝑦 + 𝑧  = 2𝑎.  2𝑏 + 2𝑐  = 2𝑎. 2. 𝑏 + 2𝑎. 2𝑐 = 𝑥. 𝑦 + 𝑥. 𝑧. 

Portanto, 

 2ℤ, +,∙  é um anel e, portanto, um subanel de ℤ. 

Notemos  ainda  que  para  todo  𝑥, 𝑦 ∈ ℤ,  temos  𝑥 + 𝑦 = 2𝑎 + 2𝑏 = 2 𝑎 + 𝑏  = 2 𝑏 + 𝑎  =

2𝑏 + 2𝑎 = 𝑦 + 𝑥, o que implica que  2ℤ, +,∙  é um anel comutativo, porém, enquanto ℤ é um 

domínio de integridade, 2ℤ não o é, pois não é um anel com unidade. 

O  teorema  a  seguir  constitui  uma  ferramenta  útil  e  fácil  para  verificar  se  um 

subconjunto não vazio 𝐵 é um subanel de 𝐴: 

Teorema 5.3: Seja  𝐴, +,∙  um anel. Um conjunto não vazio 𝐵 ⊂ 𝐴 é um subanel de 𝐴 se, e 

somente se, ∀𝑥, 𝑦 ∈ 𝐵, temos 𝑥 − 𝑦 ∈ 𝐵 e 𝑥. 𝑦 ∈ 𝐵. 

 
 
 
 
 
 
 
81 

Demonstração:  

(⟹) Consideremos 𝐵 um subanel de 𝐴, então, por hipótese, (𝐵, +) é um subgrupo abeliano 

de  (𝐴, +)  e,  portanto,  para  todo  𝑥, 𝑦 ∈ 𝐵,  temos  𝑥 − 𝑦 ∈ 𝐵.  Considerando  ainda  a  hipótese, 

temos que 𝑥. 𝑦 ∈ 𝐵, pois em um anel a multiplicação é fechada. Portanto, se 𝐵 um subanel de 

𝐴 e 𝑥, 𝑦 ∈ 𝐵, então 𝑥 − 𝑦 ∈ 𝐵 e 𝑥. 𝑦 ∈ 𝐵. 

(⟸) Consideremos, por hipótese, que dados 𝑥, 𝑦 ∈ 𝐵, temos 𝑥 − 𝑦 ∈ 𝐵 e 𝑥. 𝑦 ∈ 𝐵. 

Como  𝑥 − 𝑦 ∈ 𝐵,  então  (𝐵, +)  é  um  subgrupo  de  (𝐴, +)  e,  como  (𝐴, +)  é  abeliano,  então 

(𝐵, +) também é abeliano. Como 𝐵 ⊂ 𝐴, então, para todo 𝑥, 𝑦, 𝑧 ∈ 𝐵, temos que 𝑥, 𝑦, 𝑧 ∈ 𝐴 e, 

portanto, 𝑥.  𝑦. 𝑧  =  𝑥. 𝑦 . 𝑧 ∈ 𝐴 pois 𝐴 é um anel. Mas, por hipótese, a multiplicação de 𝐴 é 

fechada  em  𝐵,  portanto,  𝑥.  𝑦. 𝑧  =  𝑥. 𝑦 . 𝑧 ∈ 𝐵,  logo,  a  multiplicação  é  associativa  em  𝐵. 

Além disso, pelo mesmo motivo, temos 𝑥.  𝑦 + 𝑧  = 𝑥. 𝑦 + 𝑥. 𝑧 ∈ 𝐵, portanto,  𝐵, +,∙  é um 

subanel de  𝐴, +,∙ . 

5.4 

IDEAIS 

Seja 𝐴 um anel. Um subconjunto não vazio 𝐼 ⊂ 𝐴 é denominado um ideal à esquerda 

de 𝐴 se 𝐼 é um subanel de 𝐴 e ∀𝑥, 𝑦 ∈ 𝐼 e 𝑎 ∈ 𝐴, temos 𝑥 − 𝑦 ∈ 𝐼 e 𝑎 ∙ 𝑥 ∈ 𝐼. 

De  maneira  análoga,  dizemos  que  um  subconjunto  não  vazio  𝐼 ⊂ 𝐴  é  um  ideal  à 

direita de 𝐴 se 𝐼 é um subanel de 𝐴 e ∀𝑥, 𝑦 ∈ 𝐼 e 𝑎 ∈ 𝐴, temos 𝑥 − 𝑦 ∈ 𝐼 e 𝑥 ∙ 𝑎 ∈ 𝐼. 

Quando 𝐴 é um anel comutativo os ideais à esquerda e à direita coincidem e dizemos 

então que 𝐼 é um ideal de 𝐴. 

Dado  um  anel  𝐴,  os  subconjuntos   0   e  𝐴  são  denominados  ideais  triviais  ou  ideais 

próprios de 𝐴. 

Vejamos: 

1)  ∀𝑥, 𝑦 ∈  0   temos  𝑥 − 𝑦 = 0 − 0 = 0 ∈  0 ,  além  disso,  dados  𝑎 ∈ 𝐴  e  𝑥 ∈ {0}, 

temos que 𝑎 ∙ 𝑥 = 𝑎 ∙ 0 = 0 ∈ {0} e 𝑥 ∙ 𝑎 = 𝑥 ∙ 0 = 0 ∈ {0} que nos mostra que  0  é ideal à 

esquerda e à direita de 𝐴. Portanto,  0  é um ideal de 𝐴. 

2)  Como  𝐴  é  um  anel  e  𝐴 ⊂ 𝐴,  então  𝐴  é  um  subanel  de  𝐴.  É  evidente  que  dados 

𝑎 ∈ 𝐴 e 𝑥 ∈ 𝐴, temos que 𝑎 ∙ 𝑥 ∈ 𝐴 e 𝑥 ∙ 𝑎 ∈ 𝐴 que nos mostra que 𝐴 é ideal à esquerda e à 

direita de 𝐴. Portanto, 𝐴 é um ideal de 𝐴. 

Seja  𝐴  um  anel  comutativo.  Sejam  𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑛 ∈ 𝐴; 𝑛 ≥ 1.  O  conjunto   𝑎1, 𝑎2,

… , 𝑎𝑛   ⊂ 𝐴, definido como: 

 𝑎1, 𝑎2, … , 𝑎𝑛   =  𝑥1 ∙ 𝑎1 +   𝑥2 ∙ 𝑎2 + ⋯ +   𝑥𝑛 ∙ 𝑎𝑛 ; 𝑥𝑖 ∈ 𝐴, 1 ≤ 𝑖 ≤ 𝑛  é um ideal em 𝐴. 

 
 
 
82 

Vejamos: 

0 = 0 ∙ 𝑎1 + 0 ∙ 𝑎2+...+0 ∙ 𝑎𝑛 , portanto, 0 ∈  𝑎1, 𝑎2, … , 𝑎𝑛  . 
Dados  𝑚, 𝑛 ∈  𝑎1, 𝑎2, … , 𝑎𝑛  ,  então  existem  𝑥𝑖, 𝑦𝑖 ∈ 𝐴, 1 ≤ 𝑖 ≤ 𝑛    tais  que  𝑚 =

𝑥1 ∙ 𝑎1 +   𝑥2 ∙ 𝑎2 + ⋯ +   𝑥𝑛 ∙ 𝑎𝑛   e  𝑛 = 𝑦1 ∙ 𝑎1 +   𝑦2 ∙ 𝑎2 + ⋯ +   𝑦𝑛 ∙ 𝑎𝑛 , 

logo, 

teremos 

𝑚 − 𝑛 = (𝑥1 − 𝑦1) ∙ 𝑎1 +   (𝑥2 − 𝑦2) ∙ 𝑎2 + ⋯ + (𝑥𝑛 − 𝑦𝑛 ) ∙ 𝑎𝑛 .  Como  𝑥𝑖 − 𝑦𝑖 ∈ 𝐴,  então 
𝑚 − 𝑛 ∈  𝑎1, 𝑎2, … , 𝑎𝑛  .  Seja  𝛼 ∈ 𝐴  e  𝑚 ∈  𝑎1, 𝑎2, … , 𝑎𝑛  ,  então  existem  𝑥𝑖 ∈ 𝐴, 1 ≤ 𝑖 ≤ 𝑛  

tal  que  𝑚 = 𝑥1 ∙ 𝑎1 +   𝑥2 ∙ 𝑎2 + ⋯ +   𝑥𝑛 ∙ 𝑎𝑛 .  Assim,  temos  𝛼 ∙ 𝑚 = 𝛼 ∙ 𝑥1 ∙ 𝑎1 +   𝛼 ∙ 𝑥2 ∙

𝑎2 + ⋯ +   𝛼 ∙ 𝑥𝑛 ∙ 𝑎𝑛 = 𝑥1 ∙ (𝛼 ∙ 𝑎1) +   𝑥2 ∙ (𝛼 ∙ 𝑎2) + ⋯ +   𝑥𝑛 ∙ (𝛼 ∙ 𝑎𝑛 ) = 𝑥1 ∙ 𝑏1 +   𝑥2 ∙

𝑏2 + ⋯ +   𝑥𝑛 ∙ 𝑏𝑛 .  Como 
𝑥1 ∙ 𝑏1 +   𝑥2 ∙ 𝑏2 + ⋯ +   𝑥𝑛 ∙ 𝑏𝑛 ∈
 𝑎1, 𝑎2, … , 𝑎𝑛  , portanto 𝛼 ∙ 𝑚 ∈  𝑎1, 𝑎2, … , 𝑎𝑛  , o que mostra que  𝑎1, 𝑎2, … , 𝑎𝑛   é um ideal 

𝑏𝑖 = 𝛼 ∙ 𝑎𝑖 ∈ 𝐴, 

então 

em 𝐴. 

O ideal  𝑎1, 𝑎2, … , 𝑎𝑛   obtido acima é denominado ideal gerado por 𝑎1, 𝑎2, … , 𝑎𝑛 . Um 
ideal gerado por um só elemento 𝑎 do anel 𝐴, representado  𝑎  é denominado ideal principal 

gerado por 𝑎. 

Exemplos: 

1)  Consideremos  o  anel  das  matrizes  reais  quadradas  de  ordem  2  com  as  leis  de 

composição  interna  adição  e  a  multiplicação  usuais,  ou  seja,   ℳ, +, .  .  Consideremos  os 

conjuntos  𝐼 ⊂ ℳ  tal  que  𝐼 =  𝐴 =  𝑎𝑖𝑗  

2

; 𝑎𝑖𝑗 = 0, 𝑠𝑒 𝑗 ≠ 1 𝑒 𝑎𝑖1 ≠ 0 𝑝𝑎𝑟𝑎 𝑎𝑙𝑔𝑢𝑚 𝑖   e 

𝐼′ ⊂ ℳ  tal  que  𝐼′ =  𝐵 =  𝑏𝑖𝑗  

2

; 𝑏𝑖𝑗 = 0, 𝑠𝑒 𝑖 ≠ 1 𝑒 𝑏1𝑗   ≠ 0 𝑝𝑎𝑟𝑎 𝑎𝑙𝑔𝑢𝑚 𝑗 .  Mostraremos 

que 𝐼 é um ideal à esquerda de ℳ e 𝐼′ é um ideal à direita de ℳ. 

Seja 𝑀 ∈ ℳ uma matriz qualquer tal que 𝑀 =  

𝑚11 𝑚12
𝑚21 𝑚22

 . Consideremos ainda as matrizes 

   e  𝐴′ =  

   pertencentes  ao  conjunto  𝐼.  Fazendo  𝐴 − 𝐴′,  temos 

𝐴 =  

𝑎11 0
𝑎21 0

𝑎11 0
𝑎21 0

  −  

′
𝑎11
′
𝑎21

0
0

Fazendo 𝑀. 𝐴 temos  

0
0

′
𝑎11
′
𝑎21
𝑎11 0
𝑎21 0
𝑚11 𝑚12
𝑚21 𝑚22

  =  

  +  

′
−𝑎11
′
−𝑎21
𝑎11 0
𝑎21 0

  .  

=  

=  

𝑚11. 𝑎11 + 𝑚12. 𝑎21 0
𝑚21. 𝑎11 + 𝑚22. 𝑎21 0
𝑎11. 𝑚11 + 0. 𝑚21 𝑎11. 𝑚12 + 0. 𝑚22
𝑎21. 𝑚11 + 0. 𝑚21 𝑎21. 𝑚12 + 0. 𝑚22

que 𝐼 é um ideal à esquerda de ℳ. 

0
0

  =  

′
𝑎11−𝑎11
′
𝑎21 − 𝑎21

0
0

  ∈ 𝐼 

  =  

𝑚11. 𝑎11 + 𝑚12. 𝑎21 𝑚11. 0 + 𝑚12. 0
𝑚21. 𝑎11 + 𝑚22. 𝑎21 𝑚21. 0 + 𝑚22. 0

  = 

  ∈ 𝐼. Notemos porém que  

𝑎11 0
𝑎21 0

  .  

𝑚11 𝑚12
𝑚21 𝑚22

  = 

  =  

𝑎11. 𝑚11 𝑎11. 𝑚12
𝑎21. 𝑚11 𝑎21. 𝑚12

  ∉ 𝐼.  Deduzimos  com  isso 

 
 
 
De  maneira  análoga,  considerando  𝑀 ∈ ℳ  uma  matriz  qualquer  tal  que  𝑀 =  

𝑚11 𝑚12
𝑚21 𝑚22

 . 

83 

Considerando ainda as matrizes 𝐵 =  

𝑏11
0

𝑏12
0

𝐼′. Fazendo 𝐵 − 𝐵′, temos  

𝑏11 𝑏12
0
0

  −  

′
𝑏11
0

′
𝑏12
0

  =  

=  

′
𝑏11−𝑏11
0

′
𝑏12−𝑏12
0

  ∈ 𝐼′ . 

Fazendo 𝐵. 𝑀, temos: 

  e 𝐵′ =  

  pertencentes ao conjunto 

′
𝑏12
0

′
𝑏11
0
𝑏11 𝑏12
0
0

  +  

′
−𝑏11
0

′
−𝑏12
0

  = 

  .  

𝑚11 𝑚12
𝑚21 𝑚22

𝑏11 𝑏12
0
0
𝑏11. 𝑚11 + 𝑏12. 𝑚21 𝑏11. 𝑚12 + 𝑏12. 𝑚22

0. 𝑚11 + 0. 𝑚21

  =  

𝑏11. 𝑚11 + 𝑏12. 𝑚21 𝑏11. 𝑚12 + 𝑏12. 𝑚22

0. 𝑚12 + 0. 𝑚22

  = 

=  

0

0

  ∈ 𝐼′.  Em  contrapartida,  fazendo  𝑀. 𝐵,  temos 

  .  

𝑏11
0

𝑚11 𝑚12
𝑚21 𝑚22

𝑏12
0
𝑚11. 𝑏11 𝑚11. 𝑏12
𝑚21. 𝑏11 𝑚21. 𝑏12

=  

  =  

𝑚11. 𝑏11 + 𝑚12. 0 𝑚11. 𝑏12 + 𝑚12. 0
𝑚21. 𝑏11 + 𝑚22. 0 𝑚21. 𝑏12 + 𝑚22. 0

  = 

  ∉ 𝐼′. Deduzimos com isso que 𝐼′ é um ideal à direita de ℳ. 

Notemos porém que 𝐼 e 𝐼′ não são ideais de ℳ. 

2)  No  anel   ℤ, +,∙   dos  inteiros  com  adição  e  multiplicação  usuais,  qualquer 

subconjunto 𝑛ℤ =  𝑛. 𝑥; 𝑥 ∈ ℤ  e 𝑛 um inteiro fixo é um ideal de ℤ, pois dados 𝑦1, 𝑦2 ∈ 𝑛ℤ, 

temos  𝑦1 = 𝑛. 𝑥1  e  𝑦2 = 𝑛. 𝑥2,  com  𝑥, 𝑥2 ∈ ℤ.  Assim,  𝑦1 − 𝑦2 = 𝑛. 𝑥1 − 𝑛. 𝑥2 = 𝑛. (𝑥1 −

𝑥2) ∈ 𝑛ℤ.  Além  disso,  dados  𝑎 ∈ ℤ  e  𝑦 ∈ 𝑛ℤ,  temos  𝑦 = 𝑛. 𝑥,  com  𝑥 ∈ ℤ,  portanto,  𝑎. 𝑦 =

𝑎.  𝑛. 𝑥  =  𝑎. 𝑛 . 𝑥 =  𝑛. 𝑎 . 𝑥 = 𝑛. (𝑎. 𝑥) ∈ 𝑛ℤ, o que mostra que 𝑛ℤ é um ideal à esquerda 

de ℤ. Não é necessário verificar se  𝑛ℤ é um  ideal  à  direita de  ℤ, uma vez que  ℤ é um  anel 

comutativo.  Assim,  𝑛ℤ  é  um  ideal  de  ℤ  para  todo  𝑛 ∈ ℤ.  Além  disso,  como  o  ideal  𝑛ℤ  é 

gerado por 𝑛, então 𝑛ℤ =  𝑛 , ou seja, 𝑛ℤ é um ideal principal. 

5.5  CORPOS 

Consideremos um anel 𝐾, comutativo e com unidade. 𝐾 é denominado um corpo, se 

para todo 𝑥 ∈ 𝐾, 𝑥 ≠ 0, existe 𝑦 ∈ 𝐾 tal que 𝑥 ∙ 𝑦 = 1, ou seja, todo elemento não nulo de 𝐾 

admite  simétrico  multiplicativo.  Note  que  utilizamos  0  e  1  como  os  elementos  neutro  da 

adição  e  multiplicação  respectivamente  no  corpo  𝐾,  não  devendo  ser  confundidos  com  os 

números 0 e 1. 

Ao  elemento  𝑦 ∈ 𝐾  tal  que  𝑥 ∙ 𝑦 = 1,  que  é  o  simétrico  multiplicativo  de  𝑥, 

denominaremos inverso de 𝑥 e o representaremos por 𝑥−1. 

 
   
 
 
 
 
84 

Exemplos: 

1)  O  anel  comutativo  com  unidade  dos  números  reais,  ou  seja,   ℝ, +,∙   é  um  corpo, 

pois para todo 𝑥 ∈ ℝ, 𝑥 ≠ 0, existe 𝑥−1 =

1

𝑥

∈ ℝ tal que 𝑥 ∙ 𝑥−1 = 𝑥 ∙

1

𝑥

= 1. 

2)  O  anel  comutativo  com  unidade  dos  números  racionais,  ou  seja,   ℚ, +,∙   é  um 

corpo, pois para todo 𝑥 ∈ ℚ, 𝑥 ≠ 0, existe 𝑥−1 =

1

𝑥

∈ ℚ tal que 𝑥 ∙ 𝑥−1 = 𝑥 ∙

1

𝑥

= 1 

3)  O  anel  comutativo  com  unidade  dos  números  complexos,  ou  seja,   ℂ, +,∙   é  um 

corpo,  pois  para  todo  𝑧 ∈ ℂ, 𝑧 = 𝑥 + 𝑦𝑖, 𝑧 ≠ 0,  existe  𝑧−1 =

𝑥

𝑦

𝑥 2+𝑦 2 −
𝑦 2
𝑥 2+𝑦 2 =

𝑥 2+𝑦 2 𝑖 ∈ ℂ  tal  que 
𝑥 2+𝑦 2
𝑥 2+𝑦 2 = 1. 

𝑧 ∙ 𝑧−1 =  𝑥 + 𝑦𝑖 .  

𝑥

𝑦

𝑥𝑦𝑖

𝑥𝑦𝑖

𝑥 2+𝑦 2 +
4)  O  anel  comutativo  com  unidade  dos  números  inteiros,  ou  seja,   ℤ, +,∙   não  é  um 

𝑥 2+𝑦 2  =

𝑥 2+𝑦 2 +

𝑥 2+𝑦 2 −

𝑥 2
𝑥 2+𝑦 2 −

corpo, pois somente os elementos  −1, 1  possuem inversos. 

5) O anel comutativo com unidade do conjunto dos restos das divisões de um inteiro 

por 3, com as operações de adição e multiplicação usuais, ou seja,  ℤ3, +,∙ , é um corpo, pois  

como  vimos  anteriormente  ℤ3  é  um  anel  comutativo  com  unidade  e,  observando  a 

tábua da multiplicação em ℤ3: 

∙  0   1   2  
0   0   0   0  
1   0   1   2  
2   0   2   1  

vemos  que  1  ∙ 1  = 1.1     = 1   e  2  ∙ 2  = 2.2     = 4  = 1 ,  ou  seja,  todo  elemento  não  nulo  de  ℤ3 
possui inverso. 

6) O anel comutativo com unidade do conjunto dos restos das divisões de um inteiro 

por 4, com as operações de adição e multiplicação usuais, ou seja,  ℤ4, +,∙ , não é um corpo. 

Vimos anteriormente que ℤ4 é um anel comutativo com unidade, mas, observando a tábua da 

multiplicação em ℤ4: 

∙  0   1   2   3  
0   0   0   0   0  
1   0   1   2   3  
2   0   2   0   2  
3   0   3   2   1  

vemos que dos elementos não nulos 1 , 2  e 3 , que o 1  e o 3  possuem inversos, enquanto que o 
2  não possui inverso, logo,  ℤ4, +,∙  não é um corpo. 

 
 
 
 
 
 
 
 
 
 
 
 
85 

7)  O  conjunto  𝐹 =  0,1   cujas  tábuas  de  operações  de  adição  e  multiplicação 

apresentamos a seguir, é um corpo5: 

+  0 
0 
0 
1 
1 

1 
1 
0 

∙ 
0 
1 

0 
0 
0 

1 
0 
1 

Teorema 5.4: Todo corpo é um domínio de integridade. 

Demonstração: Suponhamos que  𝐾, +,∙  seja um corpo. Por simplicidade diremos apenas “o 

corpo 𝐾”, ficando subentendidas suas leis de composição internas. A hipótese nos garante que 

𝐾  é  um  anel  comutativo  com  unidade  e  que  todos  os  elementos  não  nulos  de  𝐾  possuem 

inversos.  Sendo  assim,  consideremos  𝑥, 𝑦 ∈ 𝐾,  com,  por  exemplo,  𝑥 ≠ 0,  tal  que  𝑥 ∙ 𝑦 = 0, 

então,  existe  𝑥−1 ∈ 𝐾  tal  que  𝑥 ∙ 𝑥−1 = 1.  Multiplicando  à  esquerda  ambos  os  membros  da 

igualdade 𝑥 ∙ 𝑦 = 0 por 𝑥−1, temos 𝑥−1 ∙  𝑥. 𝑦  = 𝑥−1 ∙ 0 o que implica que  𝑥−1 ∙ 𝑥 . 𝑦 = 0, 

implicando que 𝑦 = 0 e, portanto, 𝐾 não possui divisores próprios de zero, ou seja,  𝐾, +,∙  é 

um domínio de integridade. 

A  recíproca  do  teorema  acima  é  falsa,  pois,  por  exemplo,  ℤ  é  um  domínio  de 

integridade mas não é um corpo. 

Teorema 5.5: Todo domínio de integridade finito é um corpo. 

Demonstração:  Consideremos   𝐴, +,∙   tal  que  𝐴 =  𝑥1, 𝑥2, 𝑥3, ⋯ , 𝑥𝑛    é  um  anel  de 

integridade  com  𝑛  elementos.  Seja  𝑥  um  elemento  não  nulo  de  𝐴,  assim, 

𝑥𝐴 =  𝑥. 𝑥1, 𝑥. 𝑥2, 𝑥. 𝑥3, ⋯ , 𝑥. 𝑥𝑛  .  Como  𝐴  é  um  anel  de  integridade,  então  𝑥. 𝑥𝑖 = 𝑥. 𝑥𝑗   

implica  que  𝑥𝑖 = 𝑥𝑗 ,  ademais,  a  multiplicação  é  fechada  em  𝐴,  portanto,  para  cada  𝑥𝑘 ∈ 𝐴, 

tal  que  𝑥𝑘 = 𝑥. 𝑥𝑖,  portanto,  𝑥𝐴 =  𝑥. 𝑥1, 𝑥. 𝑥2, 𝑥. 𝑥3, ⋯ , 𝑥. 𝑥𝑛   =
existe  𝑥. 𝑥𝑖 ∈ 𝑥𝐴 
 𝑥1, 𝑥2, 𝑥3, ⋯ , 𝑥𝑛   = 𝐴.  Como  1 ∈ 𝐴,  então  para  todo  𝑥 ∈ 𝐴  existe  um  índice  𝑖  para  o  qual 

temos  𝑥. 𝑥𝑖 = 1  mostrando  com  isso  que  qualquer  elemento  de  𝐴  possui  inverso.  Como 

conseqüência,  𝐴, +,∙  é um corpo. 

Um corpo com quantidade finita de elementos é denominado corpo finito. A exemplo 

temos  (ℤ3, +,

∙)  com  as  operações  “usuais”  e  𝐹 = {0,1}  com  as  operações  de  adição  e 

multiplicação descritas no exemplo 7. 

5 Conhecido como Corpo de Galois, em homenagem ao matemático Évariste Galois, 1811-1832. 

 
 
 
 
 
 
 
                                                           
 
 
 
Decorre dos  teoremas  5.2 e 5.5 que o Conjunto ℤ𝑚 , quando  𝑚 é primo, é um corpo 

86 

finito. 

5.6  ESPAÇOS VETORIAIS 

Dado um corpo 𝐾, um conjunto não vazio 𝑉 é denominado um espaço vetorial sobre 

𝐾 ou um K-espaço vetorial quando: 

1º) Dados 𝑢, 𝑣 ∈ 𝑉, 𝑢 + 𝑣 ∈ 𝑉, ou seja, existe a adição em 𝑉. Considerando 𝑢, 𝑣, 𝑤 ∈

𝑉, na adição verificam-se os seguintes axiomas: 

I) 

𝑢 + 𝑣 = 𝑣 + 𝑢 

II)  𝑢 +  𝑣 + 𝑤  =  𝑢 + 𝑣  + 𝑤 

III)  ∃𝑜 ∈ 𝑉 tal que 𝑜 + 𝑢 = 𝑢 + 𝑜 = 𝑢, com 𝑜 representando o vetor nulo. 

IV)  ∀𝑢, ∃(−𝑢) ∈ 𝑉 tal que – 𝑢 + 𝑢 = 𝑢 +  −𝑢  = 𝑜 

2º)  Está  definida  uma  multiplicação  por  escalares  do  corpo  𝐾  em  𝑉,  ou  seja,  dados 

𝛼 ∈ 𝐾  e  𝑢 ∈ 𝑉,  temos  𝛼. 𝑢 ∈ 𝑉.  Considerando  𝛼, 𝛽 ∈ 𝐾  e  𝑢, 𝑣 ∈ 𝑉,  na  multiplicação  por 

escalar verificam-se os seguintes axiomas: 

I) 𝛼.  𝛽. 𝑢  =  𝛼. 𝛽 . 𝑢 

II)  𝛼 + 𝛽 . 𝑢 = 𝛼. 𝑢 + 𝛽. 𝑢 

III) 𝛼.  𝑢 + 𝑣  = 𝛼. 𝑢 + 𝛼. 𝑣 

IV) 1. 𝑢 = 𝑢 

Exemplos: 

1) O conjunto dos números reais  ℝ é um espaço vetorial sobre o corpo dos números 

racionais  ℚ,  pois  dados  𝑥, 𝑦, 𝑧 ∈ ℝ  e  𝛼, 𝛽 ∈ ℚ,  temos  𝑥 + 𝑦 ∈ ℝ;  𝑥 + 𝑦 = 𝑦 + 𝑥;  𝑥 +

 𝑦 + 𝑧  = (𝑥 + 𝑦) + 𝑧; 0 ∈ ℝ e é o elemento neutro da adição; ∃(−𝑥) ∈ ℝ tal que – 𝑥 + 𝑥 =

0 = 𝑥 + (−𝑥);  𝛼. 𝑥 ∈ ℝ;  𝛼.  𝛽. 𝑥  =  𝛼. 𝛽 . 𝑥;   𝛼 + 𝛽 . 𝑥 = 𝛼. 𝑥 + 𝛽. 𝑥;  𝛼.  𝑥 + 𝑦  = 𝛼. 𝑥 +

𝛼. 𝑦 e 1. 𝑥 = 𝑥. 

2) O  conjunto dos  números racionais  ℚ não  é um  espaço vetorial  sobre o  corpo dos 

números  reais  ℝ,  pois  por  exemplo,  considerando  o  escalar  𝛼 =  2,  temos,  para  𝑥 ∈ ℚ, 

𝛼. 𝑥 =  2. 𝑥 ∉ ℚ. 

3) O conjunto dos pares ordenados de ℝ2 sobre o corpo dos números reais ℝ, com as 

operações  de  adição  e  multiplicação  por  escalar  definidas  por   𝑥, 𝑦 ,  𝑥′ , 𝑦′  ∈ ℝ2,    𝛼 ∈ ℝ, 

 
 
 
 
87 

 𝑥, 𝑦  +  𝑥′ , 𝑦′  =  𝑥 + 𝑥′ , 𝑦 + 𝑦′   e  𝛼.  𝑥, 𝑦  =  𝛼. 𝑥, 𝛼. 𝑦 ,  constitui  um  espaço  vetorial. 

Verifiquemos: Dados  𝑥, 𝑦 ,  𝑥′ , 𝑦′  , (𝑥′′ , 𝑦′′ ) ∈ ℝ2 e 𝛼, 𝛽 ∈ ℝ, temos: 

a)  𝑥, 𝑦  +  𝑥′ , 𝑦′  =  𝑥 + 𝑥′ , 𝑦 + 𝑦′   =  𝑥′ + 𝑥, 𝑦′ + 𝑦  =  𝑥′ , 𝑦′   + (𝑥, 𝑦) 

b)  𝑥, 𝑦  +   𝑥′ , 𝑦′   +  𝑥′′ , 𝑦′′    =  𝑥, 𝑦  +  𝑥′ + 𝑥′′ , 𝑦′ + 𝑦′′   = 

=  𝑥 +  𝑥′ + 𝑥′′  , 𝑦 +  𝑦′ + 𝑦′′    =   𝑥 + 𝑥′   + 𝑥′′ ,  𝑦 + 𝑦′   + 𝑦′′   =  

=  𝑥 + 𝑥′ , 𝑦 + 𝑦′   +  𝑥′′ , 𝑦′′   =   𝑥, 𝑦  +  𝑥′ , 𝑦′    +  𝑥′′ , 𝑦′′    

c) (0,0) ∈ ℝ2 e  𝑥, 𝑦  +  0,0  =  𝑥 + 0, 𝑦 + 0  =  𝑥, 𝑦  =  0 + 𝑥, 0 + 𝑦  =  0,0  + (𝑥, 𝑦) 

d) (−𝑥, −𝑦) ∈ ℝ2 e  −𝑥, −𝑦  +  𝑥, 𝑦  =  −𝑥 + 𝑥, −𝑦 + 𝑦  =  0,0  =  𝑥 − 𝑥, 𝑦 − 𝑦  = 

=  𝑥 +  −𝑥 , 𝑦 +  −𝑦   =  𝑥, 𝑦  + (−𝑥, 𝑦)  

e) 𝛼.   𝛽.  𝑥, 𝑦   = 𝛼.  𝛽. 𝑥, 𝛽. 𝑦  =  𝛼.  𝛽. 𝑥 , 𝛼.  𝛽. 𝑦   =   𝛼. 𝛽 . 𝑥,  𝛼. 𝛽 . 𝑦  =  𝛼. 𝛽 . (𝑥, 𝑦) 

f)  𝛼 + 𝛽 .  𝑥, 𝑦  =   𝛼 + 𝛽 . 𝑥,  𝛼 + 𝛽 . 𝑦  =  𝛼. 𝑥 + 𝛽. 𝑥, 𝛼. 𝑦 + 𝛽. 𝑦  = 

=  𝛼. 𝑥, 𝛼. 𝑦  +  𝛽. 𝑥, 𝛽. 𝑦  = 𝛼.  𝑥, 𝑦  + 𝛽. (𝑥, 𝑦)  

g) 𝛼.   𝑥, 𝑦  +  𝑥′ , 𝑦′    = 𝛼.  𝑥 + 𝑥′ , 𝑦 + 𝑦′   =  𝛼.  𝑥 + 𝑥′  , 𝛼.  𝑦 + 𝑦′    = 

=  𝛼𝑥 + 𝛼𝑥′ , 𝛼𝑦 + 𝛼𝑦′   =  𝛼. 𝑥, 𝛼. 𝑦  +  𝛼. 𝑥′ , 𝛼. 𝑦′   = 𝛼.  𝑥, 𝑦  + 𝛼(𝑥′ , 𝑦′ )  

h) 1.  𝑥, 𝑦  =  1. 𝑥, 1. 𝑦  = (𝑥, 𝑦) 

4) O conjunto ℳ2 das matrizes reais quadradas de ordem 2, com as operações usuais 

de adição e multiplicação por escalar, é um espaço vetorial sobre o corpo dos números reais 

ℝ. Verifiquemos: 

No  capítulo  2,  referente  às  operações  com  matrizes,  já  vimos  que  na  adição  de 

matrizes  verificam-se  os  quatro  primeiros  axiomas,  portanto,  iremos  verificar  a  validade 

somente dos axiomas relativos à multiplicação por escalar: 

Sejam 𝐴, 𝐵 ∈ ℳ2, tais que 𝐴 =  

𝑎11 𝑎12
𝑎21 𝑎22

  e 𝐵 =  

a) 𝛼.  𝛽. 𝐴  = 𝛼.  𝛽.  

𝑎11 𝑎12
𝑎21 𝑎22

   = 𝛼.  

=  

(𝛼. 𝛽). 𝑎11
(𝛼. 𝛽). 𝑎21

(𝛼. 𝛽). 𝑎12
(𝛼. 𝛽). 𝑎22

  =  𝛼. 𝛽 .  

b)  𝛼 + 𝛽 . 𝐴 =  𝛼 + 𝛽 .  

𝑎11 𝑎12
𝑎21 𝑎22

  =  

=  

𝛼. 𝑎11 + 𝛽. 𝑎11 𝛼. 𝑎12 + 𝛽. 𝑎12
𝛼. 𝑎21 + 𝛽. 𝑎21 𝛼. 𝑎22 + 𝛽. 𝑎22

  =  

  e 𝛼, 𝛽 ∈ ℝ. Temos: 

𝑏11
𝑏12
𝑏21 𝑏22
𝛼.  𝛽. 𝑎11  𝛼.  𝛽. 𝑎12 
𝛼.  𝛽. 𝑎21  𝛼.  𝛽. 𝑎22 

  = 

  =  

𝛽. 𝑎11 𝛽. 𝑎12
𝛽. 𝑎21 𝛽. 𝑎22
𝑎11 𝑎12
𝑎21 𝑎22

  =  𝛼. 𝛽 . 𝐴  

 𝛼 + 𝛽 . 𝑎11
 𝛼 + 𝛽 . 𝑎21
𝛼. 𝑎11 𝛼. 𝑎12
𝛼. 𝑎21 𝛼. 𝑎22

 𝛼 + 𝛽 . 𝑎12
 𝛼 + 𝛽 . 𝑎22

  = 

  +  

𝛽. 𝑎11 𝛽. 𝑎12
𝛽. 𝑎21 𝛽. 𝑎22

  =  

= 𝛼.  

𝑎11 𝑎12
𝑎21 𝑎22

  + 𝛽.  

𝑎11 𝑎12
𝑎21 𝑎22

  = 𝛼. 𝐴 + 𝛽. 𝐴  

c) 𝛼.  𝐴 + 𝐵  = 𝛼.   

𝑎11 𝑎12
𝑎21 𝑎22

  +  

𝑏11
𝑏12
𝑏21 𝑏22

   = 𝛼.  

𝑎11 + 𝑏11
𝑎12 + 𝑏12
𝑎21 + 𝑏21 𝑎22 + 𝑏22

  =  

 
=  

𝛼.  𝑎11 + 𝑏11  𝛼.  𝑎12 + 𝑏12 
𝛼.  𝑎21 + 𝑏21  𝛼.  𝑎22 + 𝑏22 

  =  

𝛼. 𝑎11 + 𝛼. 𝑏11 𝛼. 𝑎12 + 𝛼. 𝑏12
𝛼. 𝑎21 + 𝛼. 𝑏21 𝛼. 𝑎22 + 𝛼. 𝑏22

  =  

88 

  +  

  = 𝛼.  

=  

𝛼. 𝑎11 𝛼. 𝑎12
𝛼. 𝑎21 𝛼. 𝑎22
𝑎11 𝑎12
𝑎21 𝑎22

𝛼. 𝑏11 𝛼. 𝑏12
𝛼. 𝑏21 𝛼. 𝑏22
1. 𝑎11 1. 𝑎12
1. 𝑎21 1. 𝑎22

𝑎11 𝑎12
𝑎21
𝑎11 𝑎12
𝑎21 𝑎22

d) 1. 𝐴 = 1.  

  =  

  =  

  = 𝐴 

𝛼.   + 𝛼.  

𝑏11
𝑏21

𝑏12
𝑏22

  = 𝛼. 𝐴 + 𝛼. 𝐵 

5.6.1  Algumas propriedades de um espaço vetorial 

Para  evitarmos  possível  confusão  em  relação  às  notações,  representaremos  por  0  o 

elemento neutro do corpo 𝐾, enquanto que o vetor nulo de 𝑉 representaremos por 𝑜. 

Sendo 𝑉 um espaço vetorial sobre um corpo 𝐾, dados 𝑥, 𝑦 ∈ 𝑉 e 𝛼, 𝛽 ∈ 𝐾, temos: 

I)  𝛼. 𝑜 = 𝑜 

II)  0. 𝑥 = 𝑜 

III)  𝛼. 𝑥 = 𝑜 ⟹ 𝛼 = 0 ou 𝑥 = 𝑜 

IV)   −𝛼 . 𝑥 = 𝛼.  −𝑥  = −(𝛼. 𝑥) 

V)   𝛼 −  𝛽 . 𝑥 = 𝛼. 𝑥 − 𝛽. 𝑥 

VI)  𝛼.  𝑥 − 𝑦  = 𝛼. 𝑥 − 𝛼. 𝑦 

VII) Dados, 𝛼, 𝛽1, 𝛽2, … , 𝛽𝑛 ∈ 𝐾 e 𝑥1, 𝑥2, … , 𝑥𝑛 ∈ 𝑉, então 𝛼.    𝛽𝑖 ∙ 𝑥𝑖

𝑛
𝑖=1

𝑛
  =    𝛼 ∙ 𝛽𝑖 
𝑖=1

. 𝑥𝑖 

Demonstrações: 

I)  𝛼. 𝑜 + 𝛼. 𝑜 = 𝛼. (𝑜 + 𝑜) = 𝛼. 𝑜. Somando − 𝛼. 𝑜  a ambos os membros da igualdade, 

temos: 𝛼. 𝑜 + 𝛼. 𝑜 −  𝛼. 𝑜  = 𝛼. 𝑜 −  𝛼. 𝑜 , o que implica que 𝛼. 𝑜 = 𝑜. 

II)  0. 𝑥 + 0. 𝑥 =  0 + 0 . 𝑥 = 0. 𝑥. Somando − 0. 𝑥  a ambos os membros da igualdade, 

temos: 0. 𝑥 + 0. 𝑥 −  0. 𝑥  = 0. 𝑥 − (0. 𝑥), o que implica que 0. 𝑥 = 𝑜. 

III)  Suponhamos  𝛼 ≠ 0,  então  ∃𝛼−1 ∈ 𝐾  tal  que  𝛼. 𝛼−1 = 1.  Multiplicando  a  igualdade 

𝛼. 𝑥 = 𝑜 por  𝛼−1, temos  𝛼−1. (𝛼. 𝑥) = 𝑜.  Levando  em  consideração o axioma (I) da 

multiplicação por escalar e a propriedade (I), temos  𝛼−1. 𝛼 . 𝑥 = 𝑜, mas, 𝛼−1. 𝛼 = 1, 

portanto 1. 𝑥 = 𝑜 e, pela propriedade (IV) da multiplicação por escalar, temos 𝑥 = 𝑜. 

Caso  consideremos  𝑥 ≠ 𝑜,  como  𝛼. 𝑥 = 𝑜,  considerando  a  propriedade  (II),  temos 

0. 𝑥 = 𝑜, por transitividade, temos 𝛼. 𝑥 = 0. 𝑥, o que implica que 𝛼 = 0. 

IV)  Utilizando o axioma (II) da multiplicação por escalar e a propriedade (II), temos que 

𝛼. 𝑥 +  −𝛼 . 𝑥 =  𝛼 +  −𝛼  . 𝑥 = 0. 𝑥 = 𝑜.  Sabemos  também  que  𝛼. 𝑥 +  −𝛼. 𝑥  =

𝑜, o que implica que  𝛼. 𝑥 +  −𝛼 . 𝑥 = 𝛼. 𝑥 +  −𝛼. 𝑥   e, somando  −𝛼. 𝑥 a ambos os 

membros  da  igualdade,  temos  −𝛼. 𝑥 + 𝛼. 𝑥 +  −𝛼 . 𝑥 = −𝛼. 𝑥 + 𝛼. 𝑥 +  −𝛼. 𝑥 ,  o 

 
 
 
89 

que  resulta  que   −𝛼 . 𝑥 = −𝛼. 𝑥.  Por  outro  lado,  a  propriedade  (I)  nos  garante  que 

𝛼. 𝑜 = 𝑜,  temos  também,  pelo  axioma  (IV)  da  adição,  que  𝑥 +  −𝑥  = 𝑜,  assim, 

temos  𝛼. (𝑥 +  −𝑥 ) = 𝑜  e,  pelo  axioma  (III)  da  multiplicação,  𝛼. 𝑥 + 𝛼.  −𝑥  = 𝑜. 

Somando −𝛼. 𝑥 a essa última igualdade, temos  −𝛼. 𝑥 + 𝛼. 𝑥 + 𝛼.  −𝑥  = −𝛼. 𝑥 + 𝑜, 

o que implica que 𝛼.  −𝑥  = −𝛼. 𝑥 . Logo,  −𝛼 . 𝑥 = 𝛼.  −𝑥  = −𝛼. 𝑥. 

V)   𝛼 − 𝛽 . 𝑥 =  𝛼 +  −𝛽  . 𝑥.  Pelo  axioma  (II)  da  multiplicação  por  escalar,  temos 

 𝛼 +  −𝛽  . 𝑥 = 𝛼. 𝑥 +  −𝛽 . 𝑥  e,  pela  propriedade  (IV),  𝛼. 𝑥 +  −𝛽 . 𝑥 = 𝛼. 𝑥 −

𝛽. 𝑥. Portanto,  𝛼 − 𝛽 . 𝑥 = 𝛼. 𝑥 − 𝛽. 𝑥 

VI)  𝛼.  𝑥 − 𝑦  = 𝛼. (𝑥 +  −𝑦 ). Pelo axioma (III) da multiplicação por escalar, temos que 

𝛼.  𝑥 +  −𝑦   = 𝛼. 𝑥 + 𝛼. (−𝑦) mas, pela propriedade (IV), 𝛼.  −𝑦  = −𝛼. 𝑦, assim, 

𝛼. 𝑥 + 𝛼.  −𝑦  = 𝛼. 𝑥 − 𝛼. 𝑦. Portanto, 𝛼.  𝑥 − 𝑦  = 𝛼. 𝑥 − 𝛼. 𝑦. 

VII) Utilizando  indução  sobre  𝑛,  temos,  para  𝑛 = 1,  𝛼.    𝛽𝑖 ∙ 𝑥𝑖

1
𝑖=1

  = 𝛼. (𝛽1 ∙ 𝑥1). 

Utilizando  o axioma  (II)  da  multiplicação  por  escalar,  temos  𝛼.  𝛽1 ∙ 𝑥1  =  𝛼. 𝛽1 . 𝑥1 =

   𝛼. 𝛽𝑖 . 𝑥𝑖

1
𝑖=1

. Portanto, a igualdade é válida para 𝑛 = 1. 

Suponhamos  que  a  igualdade  seja  válida  para  𝑛 = 𝑘,  ou  seja,  𝛼.    𝛽𝑖 ∙ 𝑥𝑖

𝑘
𝑖=1

  =

   𝛼 ∙ 𝛽𝑖 

𝑘
𝑖=1

. 𝑥𝑖 e verifiquemos se essa hipótese implica na validez da igualdade para 

𝑛 = 𝑘 + 1: 𝛼.   

𝑘+1
𝑖=1

𝛽𝑖 ∙ 𝑥𝑖

  = 𝛼.  𝛽1 ∙ 𝑥1 + 𝛽2 ∙ 𝑥2 + ⋯ + 𝛽𝑘 ∙ 𝑥𝑘 + 𝛽𝑘+1 ∙ 𝑥𝑘+1  = 

= 𝛼.  (𝛽1 ∙ 𝑥1 + 𝛽2 ∙ 𝑥2 + ⋯ + 𝛽𝑘 ∙ 𝑥𝑘 ) + 𝛽𝑘+1 ∙ 𝑥𝑘+1 . Pelo axioma (III) da multiplicação 

por  escalar,  temos  𝛼. (𝛽1 ∙ 𝑥1 + 𝛽2 ∙ 𝑥2 + ⋯ + 𝛽𝑘 ∙ 𝑥𝑘 ) + 𝛼. (𝛽𝑘+1 ∙ 𝑥𝑘+1),  mas  𝛼. (𝛽1 ∙

𝑥1 + 𝛽2 ∙ 𝑥2 + ⋯ + 𝛽𝑘 ∙ 𝑥𝑘 ) = 𝛼.    𝛽𝑖 ∙ 𝑥𝑖

𝑘
𝑖=1

 ,  assim,  𝛼. (𝛽1 ∙ 𝑥1 + 𝛽2 ∙ 𝑥2 + ⋯ + 𝛽𝑘 ∙

𝑥𝑘 ) + 𝛼.  𝛽𝑘+1 ∙ 𝑥𝑘+1  = 𝛼.    𝛽𝑖 ∙ 𝑥𝑖

𝑘
𝑖=1

  + 𝛼. (𝛽𝑘+1 ∙ 𝑥𝑘+1).  Por  hipótese  de  indução  e 

utilizando o axioma (I) da multiplicação por escalar, temos 

𝑘
𝛼.    𝛽𝑖 ∙ 𝑥𝑖
𝑖=1

  + 𝛼.  𝛽𝑘+1 ∙ 𝑥𝑘+1  =     𝛼 ∙ 𝛽𝑖 

𝑘
𝑖=1

. 𝑥𝑖  +  𝛼. 𝛽𝑘+1 . 𝑥𝑘+1 =   

=    𝛼 ∙ 𝛽𝑖 

𝑘+1
𝑖=1

. 𝑥𝑖  

5.6.2  Subespaços vetoriais 

Seja  𝑉  um  espaço  vetorial  sobre  um  corpo  𝐾.  Dizemos  que  um  conjunto  não  vazio 

𝑊 ⊂ 𝑉  é  um  subespaço  vetorial  de  𝑉  se  𝑊  é  um  espaço  vetorial  em  relação  à  adição  e  à 

multiplicação por escalar em 𝑉. 

 
 
 
90 

Em outras palavras, dizer que 𝑊 é um subespaço vetorial de 𝑉, é afirmar que para as 

operações de Adição e de multiplicação por escalar do espaço 𝑉, são verificados os 8 axiomas 

que definem um espaço vetorial em 𝑊. 

Exemplo: 

O conjunto 𝑊 ⊂ ℝ2 tal que 𝑊 =   𝑥, 𝑦  ∈ ℝ2; 𝑥 = 𝑦  é um subespaço vetorial de ℝ2, 

pois, dados   𝑥, 𝑥 ,  𝑦, 𝑦 ,  𝑧, 𝑧  ∈ 𝑊  e  𝛼, 𝛽 ∈ ℝ, temos: 

 𝑥, 𝑥  +  𝑦, 𝑦  = (𝑥 + 𝑦, 𝑥 + 𝑦) ∈ 𝑊 e 𝛼.  𝑥, 𝑥  =  𝛼. 𝑥, 𝛼. 𝑥  ∈ 𝑊. Além disso, temos: 

I) 

 𝑥, 𝑥  +  𝑦, 𝑦  =  𝑥 + 𝑦, 𝑥 + 𝑦  =  𝑦 + 𝑥, 𝑦 + 𝑥  =  𝑦, 𝑦  +  𝑥, 𝑥  

II)   𝑥, 𝑥  +   𝑦, 𝑦  +  𝑧, 𝑧   =  𝑥, 𝑥  +  𝑦 + 𝑧, 𝑦 + 𝑧  =  𝑥 +  𝑦 + 𝑧 , 𝑥 + (𝑦 + 𝑧)  = 

  𝑥 + 𝑦  + 𝑧,  𝑥 + 𝑦  + 𝑧  =  𝑥 + 𝑦, 𝑥 + 𝑦  +  𝑧, 𝑧  =   𝑥, 𝑥  +  𝑦, 𝑦   + (𝑧, 𝑧)  

III)   0,0  ∈ 𝑊, pois 0 = 0 e  𝑥, 𝑥  +  0,0  =  𝑥 + 0, 𝑥 + 0  =  𝑥, 𝑥  e  0,0  +  𝑥, 𝑥  =

 0 + 𝑥, 0 + 𝑥  =  𝑥, 𝑥  

IV)  (−𝑥, −𝑥) ∈ 𝑊, pois – 𝑥 = −𝑥 e  𝑥, 𝑥  +  −𝑥, −𝑥  =  𝑥 +  −𝑥 , 𝑥 +  −𝑥   = (0,0) 

e  −𝑥, −𝑥  +  𝑥, 𝑥  =  −𝑥 + 𝑥, −𝑥 + 𝑥  = (0,0) 

V)  𝛼.  𝛽.  𝑥, 𝑥   = 𝛼.  𝛽. 𝑥, 𝛽. 𝑥  =  𝛼.  𝛽. 𝑥 , 𝛼.  𝛽. 𝑥   =   𝛼. 𝛽 . 𝑥,  𝛼. 𝛽 . 𝑥  =

 𝛼. 𝛽 . (𝑥, 𝑥) 

VI)   𝛼 + 𝛽 .  𝑥, 𝑥  =   𝛼 + 𝛽 . 𝑥,  𝛼 + 𝛽 . 𝑥  =  𝛼. 𝑥 + 𝛽. 𝑥, 𝛼. 𝑥 + 𝛽. 𝑥  =

 𝛼. 𝑥, 𝛼. 𝑥  +  𝛽. 𝑥, 𝛽. 𝑥  = 𝛼.  𝑥, 𝑥  + 𝛽. (𝑥, 𝑥) 

VII) 𝛼.   𝑥, 𝑥  +  𝑦, 𝑦   = 𝛼.  𝑥 + 𝑦, 𝑥 + 𝑦  =  𝛼.  𝑥 + 𝑦 , 𝛼.  𝑥 + 𝑦   =  𝛼. 𝑥 +

𝛼. 𝑦, 𝛼. 𝑥 + 𝛼. 𝑦  =  𝛼. 𝑥, 𝛼. 𝑥  +  𝛼. 𝑦, 𝛼. 𝑦  = 𝛼.  𝑥, 𝑥  + 𝛼. (𝑦, 𝑦) 

VIII) 1.  𝑥, 𝑥  =  1. 𝑥, 1. 𝑥  = (𝑥, 𝑥) 

Portanto, 𝑊 =   𝑥, 𝑦  ∈ ℝ2; 𝑥 = 𝑦  é subespaço vetorial de ℝ2. 

Teorema  5.6:  Seja  𝑉  um  espaço  vetorial  sobre  um  corpo  𝐾.  Um  subconjunto  não  vazio 

𝑊 ⊂ 𝑉  é  um  subespaço  vetorial  de  𝑉  se,  e  somente  se,  dados  𝑥, 𝑦 ∈ 𝑊  e  𝛼, 𝛽 ∈ 𝐾,  temos 

𝛼. 𝑥 + 𝛽. 𝑦 ∈ 𝑊. 

Demonstração: 

 ⟹  Seja 𝑊 ⊂ 𝑉 um subespaço vetorial de 𝑉. Por definição de subespaço, dados 𝑥, 𝑦 ∈ 𝑊 e 

𝛼, 𝛽 ∈ 𝐾,  temos  𝛼. 𝑥 ∈ 𝑊  e  𝛽. 𝑦 ∈ 𝑊.  Como  a  soma  de  vetores  é  fechada  em  𝑊,  então 

𝛼. 𝑥 + 𝛽. 𝑦 ∈ 𝑊. 

 ⟸   Consideremos  𝑊 ⊂ 𝑉,  𝑊 ≠ ∅  tal  que  para  todo  𝑥, 𝑦 ∈ 𝑊  e  𝛼, 𝛽 ∈ 𝐾,  temos  𝛼. 𝑥 +

𝛽. 𝑦 ∈ 𝑊. Para 𝛼 = 𝛽 = 1 temos 𝛼. 𝑥 + 𝛽. 𝑦 = 1. 𝑥 + 1. 𝑦 = 𝑥 + 𝑦 ∈ 𝑊 e para 𝛽 = 0, temos 

 
 
 
91 

𝛼. 𝑥 + 𝛽. 𝑦 = 𝛼. 𝑥 + 0. 𝑦 = 𝛼. 𝑥 ∈ 𝑊,  ou  seja,  as  operações  de  adição  e  multiplicação  por 

escalar  em  𝑉  são  fechadas  em  𝑊.  Como  para  todo  𝑥, 𝑦, 𝑧 ∈ 𝑉,  temos  que  𝑥 + 𝑦 = 𝑦 + 𝑥  e 

𝑥 +  𝑦 + 𝑧  =  𝑥 + 𝑦  + 𝑧  e  como  𝑊  é  fechado  para  a  operação  de  adição  de  𝑉,  então,  se 

𝑥, 𝑦, 𝑧 ∈ 𝑊,  as  igualdades  𝑥 + 𝑦 = 𝑦 + 𝑥  e  𝑥 +  𝑦 + 𝑧  =  𝑥 + 𝑦  + 𝑧  são  válidas  em  W, 

garantindo  com  isso  a  comutatividade  e  a  associatividade  da  adição  em  𝑊.  Como  a 

multiplicação por escalar é fechada em 𝑊, ou seja, ∀𝛼 ∈ 𝐾 e 𝑥 ∈ 𝑊, temos 𝛼. 𝑥 ∈ 𝑊, então, 

tomando 𝛼 = 1, temos 𝛼. 𝑥 = 1. 𝑥 = 𝑥 ∈ 𝑊 e, tomando 𝛼 = −1, temos 𝛼. 𝑥 = −1. 𝑥 = −𝑥 ∈

𝑊. Como  por hipótese  𝛼. 𝑥 + 𝛽. 𝑦 ∈ 𝑊  para todo  𝑥, 𝑦 ∈ 𝑉 e  𝛼, 𝛽 ∈ 𝐾, tomando  𝛽 = −𝛼 e 

𝑦 = 𝑥, temos 𝛼. 𝑥 + 𝛽. 𝑦 = 𝛼. 𝑥 +  −𝛼 . 𝑥 = 𝛼. 𝑥 − 𝛼. 𝑥 = 𝑜 ∈ 𝑊. Como para todo 𝛼, 𝛽 ∈ 𝐾 

e  𝑥, 𝑦 ∈ 𝑉 temos  𝛼.  𝛽. 𝑥  =  𝛼. 𝛽 . 𝑥,   𝛼 + 𝛽 . 𝑥 = 𝛼. 𝑥 + 𝛽. 𝑥 e  𝛼.  𝑥 + 𝑦  = 𝛼. 𝑥 + 𝛼. 𝑦 e, 

como a multiplicação por escalar é fechada em 𝑊, então essas igualdades são válidas em 𝑊, 

mostrando  com  isso  que  𝑊  é  um  espaço  vetorial.  Por  hipótese,  temos  𝑊 ⊂ 𝑉,  o  que  nos 

mostra que 𝑊 é um subespaço vetorial de 𝑉, completando a demonstração. 

Retomando  o  exemplo  anterior,  consideremos  o  conjunto  𝑊 ⊂ ℝ2  tal  que  𝑊 =

  𝑥, 𝑦  ∈ ℝ2; 𝑥 = 𝑦 , para mostrar que 𝑊  é um subespaço vetorial de ℝ2, de acordo com o  

teorema      5.6,      basta      mostrar      que      dados     𝑥, 𝑥 , (𝑦, 𝑦) ∈ 𝑊    e    𝛼, 𝛽 ∈ 𝐾,    temos  

𝛼.  𝑥, 𝑥  + 𝛽. (𝑦, 𝑦) ∈ 𝑊, o que é fácil de comprovar: 

𝛼.  𝑥, 𝑥  + 𝛽.  𝑦, 𝑦  =  𝛼. 𝑥, 𝛼. 𝑥  +  𝛽. 𝑦, 𝛽. 𝑦  = (𝛼. 𝑥 + 𝛽. 𝑦, 𝛼. 𝑥 + 𝛽. 𝑦) ∈ 𝑊  por 

terem 

coordenadas iguais. Portanto, 𝑊 =   𝑥, 𝑦  ∈ ℝ2; 𝑥 = 𝑦  é um subespaço vetorial de ℝ2. 

5.6.3  Base e Dimensão 

5.6.3.1  Independência Linear 

Considerando  𝑉  um  espaço  vetorial  sobre  um  corpo  𝐾.  Dizemos  que  um  conjunto 

𝐼 ⊂ 𝑉,  𝐼 =  𝑥1, 𝑥2, 𝑥3, … , 𝑥𝑛    é  linearmente  independente,  quando  para  todo  𝛼 ∈ 𝐾,  a 

igualdade 𝛼1 ∙ 𝑥1 + 𝛼2 ∙ 𝑥2 + 𝛼3 ∙ 𝑥3 + ⋯ + 𝛼𝑛 ∙ 𝑥𝑛 = 𝑜 for verdadeira somente se 𝛼1 = 𝛼2 =
𝛼3 = ⋯ = 𝛼𝑛 = 0. Caso  exista algum  𝑖 ∈  1, 2, 3, … , 𝑛 , para o  qual  se tenha  𝛼𝑖 ≠ 0, então 

dizemos  que  𝐼  é  linearmente  dependente.  A  uma  igualdade  do  tipo  𝛼1 ∙ 𝑥1 + 𝛼2 ∙ 𝑥2 + 𝛼3 ∙

𝑥3 + ⋯ + 𝛼𝑛 ∙ 𝑥𝑛 = 𝑥 denominamos combinação linear. 

 
 
 
 
 
 
 
 
92 

5.6.3.2  Conjunto de geradores 

Trataremos nesse tópico somente de espaços vetoriais finitamente gerados. 

Dados  um  espaço  vetorial  𝑉  sobre  um  corpo  𝐾,  dizemos  que  um  conjunto  finito  

𝐺 ⊂ 𝑉,  𝐺 =  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    é  um  gerador  do  espaço  vetorial  𝑉,  se  para  todo  𝑥 ∈ 𝑉, 

existirem  𝛼1, 𝛼2, 𝛼3, … , 𝛼𝑛 ∈ 𝐾 

tal  que,  𝑥 = 𝛼1 ∙ 𝑢1 + 𝛼2 ∙ 𝑢2 + 𝛼3 ∙ 𝑢3 + ⋯ + 𝛼𝑛 ∙ 𝑢𝑛 . 

Assim, dizemos que 𝑉 é gerado por 𝐺 ou que 𝐺 gera 𝑉 ou ainda que 𝑉 = [𝐺]. 

5.6.3.3  Base e dimensão de um espaço vetorial 

Seja  𝐵 ⊂ 𝑉  um  conjunto  finito,  onde  𝑉  é  um  espaço  vetorial  sobre  um  corpo  𝐾.  Se 

 𝐵  = 𝑉  e  𝐵  é  um  conjunto  de  vetores  linearmente  independentes,  então,  dizemos  que  𝐵  é 

uma base do espaço vetorial 𝑉. 

Exemplo: 

Vimos anteriormente que o conjunto dos pares ordenados de coordenadas reais  ℝ2 é 

um espaço vetorial sobre o corpo ℝ para as operações convencionais de soma e multiplicação 

por  escalar.  Consideremos  o  conjunto  𝐵 =   1,0 ,  0,1    contido  em  ℝ2.  Observemos  que 

qualquer  que  seja  o  vetor  𝑣 =  𝑥, 𝑦  ∈ ℝ2,  vale  que  𝑣 =  𝑥, 𝑦  =  𝑥, 0  +  0, 𝑦  = 𝑥 ∙

 1,0  + 𝑦 ∙  0,1 ,      assim,    vemos      que   𝐵  = ℝ2.    Além  disso,    para  𝛼, 𝛽 ∈ ℝ,  temos 

𝛼 ∙  1,0  + 𝛽 ∙  0,1  =  0,0  ⇔  𝛼, 0  +  0, 𝛽  =  0,0  ⇔  𝛼, 𝛽  =  0,0  ⇔ 𝛼 = 0  e  𝛽 = 0,  o 

que acarreta que 𝐵 é linearmente independente e portanto é uma base de ℝ2. 

Teorema 5.7: Seja 𝑉 um espaço vetorial sobre um corpo 𝐾. Se 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛  são vetores 
de 𝑉 e  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    = 𝑉, então existe 𝐵 ⊂  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    tal que 𝐵 é uma base de 

𝑉. 

Demonstração:    Se  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛     são    linearmente    independentes,      então      𝐵 =
 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    é uma base de 𝑉 e não há nada o que demonstrar. Caso  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛  

sejam vetores linearmente dependentes, então, na  combinação linear  𝛼1 ∙ 𝑢1 + 𝛼2 ∙ 𝑢2 + 𝛼3 ∙

𝑢3 + ⋯ + 𝛼𝑛 ∙ 𝑢𝑛 = 𝑜,  𝛼𝑖 ∈ 𝐾, 1 ≤ 𝑖 ≤ 𝑛  existe  pelo  menos  um  coeficiente  não  nulo. 

Suponhamos,  sem  perda  de  generalidade,  que  𝛼1 ≠ 0,  então  “dividimos”  a    equação    𝛼1 ∙

𝑢1 + 𝛼2 ∙ 𝑢2 + 𝛼3 ∙ 𝑢3 + ⋯ + 𝛼𝑛 ∙ 𝑢𝑛 = 𝑜   por   𝛼1,  obtendo                    𝑢1 =  −

𝛼2
𝛼1

  ∙ 𝑢2 +

 −

𝛼3
𝛼1

  ∙ 𝑢3 +  −

𝛼4
𝛼1

  ∙ 𝑢4 + ⋯ +  −

𝛼𝑛
𝛼1

  ∙ 𝑢𝑛 ,  fazendo  𝛽𝑗 = −

𝛼𝑗 +1
𝛼1

,  1 ≤ 𝑗 ≤ 𝑛 − 1,  temos 

 
 
 
 
 
 
 
 
 
 
93 

𝑢1 = 𝛽1 ∙ 𝑢2 + 𝛽2 ∙ 𝑢3 + 𝛽3 ∙ 𝑢4 + ⋯ + 𝛽𝑛−1 ∙ 𝑢𝑛 , ou seja,  𝑢1 é combinação linear dos  𝑛 − 1 

vetores  𝑢2, 𝑢3, 𝑢4, … , 𝑢𝑛 ,  ou  seja,  𝑢2, 𝑢3, 𝑢4, … , 𝑢𝑛   ainda  geram  𝑉.  Caso  𝑢2, 𝑢3, 𝑢4, … , 𝑢𝑛  
forem  linearmente independentes, então temos  𝐵 =  𝑢2, 𝑢3, 𝑢4, … , 𝑢𝑛   uma base de  𝑉. Caso 

𝑢2, 𝑢3, 𝑢4, … , 𝑢𝑛  forem linearmente dependentes, repetimos o processo anterior e encontramos 

um vetor dentre os vetores 𝑢2, 𝑢3, 𝑢4, … , 𝑢𝑛  que é escrito como combinação linear dos outros 

𝑛 − 2  vetores  e,  portanto,  os  𝑛 − 2  vetores  ainda  geram  𝑉.  Após  uma  quantidade  finita  de 

repetições  do  processo  descrito  anteriormente  teremos,  dentre  os  𝑢𝑖′𝑠,  um  conjunto  com 

vetores linearmente independentes, constituindo assim, uma base 𝐵 do espaço 𝑉. 

Teorema 5.8: Seja 𝑉 uma espaço vetorial sobre um corpo 𝐾. Se 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛  são vetores 
de 𝑉 e  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    = 𝑉, então qualquer conjunto com mais de 𝑛 vetores é linearmente 

dependente,  ou  seja,  qualquer  conjunto  linearmente  independente  de  vetores  de  𝑉  tem  no 

máximo 𝑛 vetores. 

Demonstração: Como  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    = 𝑉, pelo teorema 5.7, podemos extrair uma base 

dentre  os  vetores  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛 .  Suponhamos  que  os  vetores  𝑥1, 𝑥2, 𝑥3, … , 𝑥𝑡,  com  𝑡 ≤ 𝑛 

formam  essa  base.  Consideremos  agora  os  vetores  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚   de  𝑉,  com  𝑚 > 𝑛. 

Existem então escalares 𝛼𝑖𝑗 ∈ 𝐾, com 1 ≤ 𝑖 ≤ 𝑚 e 1 ≤ 𝑗 ≤ 𝑛 tais que: 

𝑣1 = 𝛼11 ∙ 𝑥1 + 𝛼12 ∙ 𝑥2 + ⋯ 𝛼1𝑡 ∙ 𝑥𝑡 

                                      𝑣2 = 𝛼21 ∙ 𝑥1 + 𝛼22 ∙ 𝑥2 + ⋯ 𝛼2𝑡 ∙ 𝑥𝑡 

(I) 

    ⋮                                 ⋮                           

𝑣𝑚 = 𝛼𝑚1 ∙ 𝑥1 + 𝛼𝑚2 ∙ 𝑥2 + ⋯ 𝛼𝑚𝑡 ∙ 𝑥𝑡 

Consideremos agora uma combinação linear nula dos vetores 𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚 : 

(II) 

𝛽1 ∙ 𝑣1 + 𝛽2 ∙ 𝑣2 + ⋯ + 𝛽𝑚 ∙ 𝑣𝑚 = 𝑜 

Substituindo (I) em (II), temos: 

𝛽1 ∙  𝛼11 ∙ 𝑥1 + 𝛼12 ∙ 𝑥2 + ⋯ 𝛼1𝑡 ∙ 𝑥𝑡  + 𝛽2 ∙  𝛼21 ∙ 𝑥1 + 𝛼22 ∙ 𝑥2 + ⋯ 𝛼2𝑡 ∙ 𝑥𝑡  + ⋯ 

… + 𝛽𝑚 ∙  𝛼𝑚1 ∙ 𝑥1 + 𝛼𝑚2 ∙ 𝑥2 + ⋯ 𝛼𝑚𝑡 ∙ 𝑥𝑡  = 𝑜  

Reagrupando temos: 

 𝛼11 ∙ 𝛽1 + 𝛼21 ∙ 𝛽2 + ⋯ + 𝛼𝑚1 ∙ 𝛽𝑚  . 𝑥1 +  𝛼12 ∙ 𝛽1 + 𝛼22 ∙ 𝛽2 + ⋯ + 𝛼𝑚2 ∙ 𝛽𝑚  . 𝑥2 + ⋯ 
… +  𝛼1𝑡 ∙ 𝛽1 + 𝛼2𝑡 ∙ 𝛽2 + ⋯ + 𝛼𝑚𝑡 ∙ 𝛽𝑚  . 𝑥𝑡 = 𝑜,  mas,  por  hipótese,  𝑥1, 𝑥2, 𝑥3, … , 𝑥𝑡  é  uma 

base e portanto, são vetores linearmente independentes, o que implica que temos: 

𝛼11 ∙ 𝛽1 + 𝛼21 ∙ 𝛽2 + ⋯ + 𝛼𝑚1 ∙ 𝛽𝑚 = 0
𝛼12 ∙ 𝛽1 + 𝛼22 ∙ 𝛽2 + ⋯ + 𝛼𝑚2 ∙ 𝛽𝑚 = 0
⋮
𝛼1𝑡 ∙ 𝛽1 + 𝛼2𝑡 ∙ 𝛽2 + ⋯ + 𝛼𝑚𝑡 ∙ 𝛽𝑚 = 0

 
 
 
 
 
  
94 

Que  é  um  sistema  linear  homogêneo  com  𝑡  equações  e  𝑚  incógnitas  𝛽1, 𝛽2, … , 𝛽𝑚 .  Como 

𝑡 ≤ 𝑛 < 𝑚, então esse sistema admite uma solução não trivial, ou seja, existe algum 𝛽𝑖 ≠ 0, 

com  1 < 𝑖 < 𝑚,  acarretando  com  isso  que  os  vetores  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚   são  linearmente 

independentes. 

Teorema 5.9: Se 𝑉 um K-espaço vetorial finitamente gerado, então duas bases quaisquer de 

𝑉 tem o mesmo número de vetores. 

Demonstração:  Sejam  𝐵1 =  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛    e  𝐵2 =  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚      duas  bases  do 

espaço  vetorial  𝑉.  Então,  por  definição,  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛   são  linearmente  independentes  e 

geram 𝑉 e 𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚  são linearmente independentes e geram 𝑉. Como 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛  

geram  𝑉  e  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚   são  linearmente  independentes,  então,  pelo  teorema  5.8,  temos 

𝑚 ≤ 𝑛. Em contrapartida, como 𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑚  geram 𝑉 e 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑛  são linearmente 

independentes, então, pelo teorema 5.8, temos 𝑛 ≤ 𝑚. Essas duas desigualdades são possíveis 

somente se 𝑚 = 𝑛 e, portanto, 𝐵1 e 𝐵2 possuem o mesmo número de vetores. 

O teorema 5.9 permite-nos apresentar a seguinte definição: 

Seja  𝑉  um  espaço  vetorial  finitamente  gerado,  denominamos  dimensão  de  𝑉  e 

representamos por dim 𝑉 o número de elementos de qualquer uma de suas bases. Neste caso, 

dizemos que 𝑉 é um espaço de dimensão finita. 

Exemplo:  Vimos  anteriormente  que  𝐵 =   1,0 ,  0,1    é  uma  base  de  ℝ2.  Pelo 

teorema 5.9, qualquer outra base de ℝ2 possuirá também dois vetores, o que, de acordo com o 

que acabamos de definir, faz com que dim ℝ2 = 2. 

O  K-espaço  vetorial  𝐸 =  𝑜   (contendo  apenas  o  vetor  nulo)  tem  dimensão  zero,  ou 

seja, dim 𝐸 = 0, pois para todo 𝛼 ∈ 𝐾 tem-se 𝛼 ∙ 𝑜 = 𝑜, o que implica que 𝐸 =  ∅ .  

Teorema  5.10:  Sendo  𝑉  um  K-espaço  vetorial  de  dimensão  finita,  qualquer  conjunto  de 

vetores linearmente independentes de 𝑉 pode ser completado de modo a se obter uma base de 

𝑉. 

Demonstração:  Consideremos  dim 𝑉 = 𝑛  e  sejam  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡  pertencentes  a  𝑉  e 
linearmente independentes. Pelo teorema 5.8, temos 𝑡 ≤ 𝑛. Se  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡   = 𝑉, então 
𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡 formam uma base e não a nada o que demonstrar. Caso  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡   ≠
𝑉,  então  existe  𝑣𝑡+1 ∈ 𝑉  tal  que  𝑣𝑡+1 ∉  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡 ,  o  que  implica  que  𝑣𝑡+1  não  é 

escrito  como  combinação  linear  dos  vetores  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡,  logo  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡, 𝑣𝑡+1  são 
linearmente  independentes  e  caso   𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡, 𝑣𝑡+1  = 𝑉,  então  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡, 𝑣𝑡+1 

 
 
 
95 

formam uma base de  𝑉, caso contrário, repetimos  o processo  por no máximo  𝑛 − 𝑡  vezes e 

obtemos assim uma base para 𝑉. 

5.6.4  Noções sobre transformação linear 

Sejam  𝑉  e  𝑊  dois  K-espaços  vetoriais.  Uma  função  𝑇: 𝑉 → 𝑊  é  denominada  uma 

transformação linear de 𝑉 em 𝑊 quando para todo 𝑣1, 𝑣2 ∈ 𝑉 e 𝛼 ∈ 𝐾, temos 𝑇 𝑣1 + 𝑣2  =
𝑇 𝑣1  + 𝑇(𝑣2) e 𝑇 𝛼. 𝑣1  = 𝛼. 𝑇(𝑣1). 

Exemplo:  

Consideremos  a  função  𝑇: ℝ3 → ℝ2,  definida  por  𝑇 𝑥, 𝑦, 𝑧  = (3𝑥, 2𝑥 − 𝑦 + 5𝑧). 

Notemos que dados dois vetores 𝑣1 = (𝑥1, 𝑦1, 𝑧1) e 𝑣2 = (𝑥2, 𝑦2, 𝑧2) e 𝛼 ∈ ℝ, temos: 

𝑇 𝑣1 + 𝑣2  = 𝑇  𝑥1, 𝑦1, 𝑧1  +  𝑥2, 𝑦2, 𝑧2   = 𝑇 𝑥1 + 𝑥2, 𝑦1 + 𝑦2, 𝑧1 + 𝑧2  =   

=  3 ∙  𝑥1 + 𝑥2 , 2 ∙  𝑥1 + 𝑥2  −  𝑦1 + 𝑦2  + 5 ∙  𝑧1 + 𝑧2   =  

=  3 ∙ 𝑥1 + 3 ∙ 𝑥2, 2 ∙ 𝑥1 + 2 ∙ 𝑥2 − 𝑦1 − 𝑦2 + 5 ∙ 𝑧1 + 5. 𝑧2  =  

= ((3 ∙ 𝑥1) + (3 ∙ 𝑥2), (2 ∙ 𝑥1 − 𝑦1 + 5 ∙ 𝑧1) + (2 ∙ 𝑥2 − 𝑦2 + 5. 𝑧2)) =  

=  3 ∙ 𝑥1, 2 ∙ 𝑥1 − 𝑦1 + 5 ∙ 𝑧1  +  3 ∙ 𝑥2, 2 ∙ 𝑥2 − 𝑦2 + 5. 𝑧2  =  
= 𝑇(𝑥1, 𝑦1, 𝑧1) + 𝑇 𝑥2, 𝑦2, 𝑧2  = 𝑇(𝑣1) + 𝑇(𝑣2)  

E  𝑇 𝛼. 𝑣1  = 𝑇 𝛼.  𝑥1, 𝑦1, 𝑧1   = 𝑇 𝛼. 𝑥1, 𝛼. 𝑦1, 𝛼. 𝑧1  = 

=  3𝛼. 𝑥1, 2𝛼. 𝑥1 − 𝛼. 𝑦1 + 5 𝛼. 𝑧1  =  𝛼. (3𝑥1), 𝛼. (2𝑥1 − 𝑦1 + 5𝑧1)  =  
= 𝛼.  3𝑥1, 2𝑥1 − 𝑦1 + 5𝑧1  = 𝛼. 𝑇 𝑥1, 𝑦1, 𝑧1  = 𝛼. 𝑇(𝑣1)  
Portanto, 𝑇 é uma transformação linear de ℝ3 em ℝ2. 

5.6.4.1  Núcleo e Imagem de uma Transformação Linear 

Sejam 𝑉 e 𝑊 dois K-espaços vetoriais e  𝑇: 𝑉 → 𝑊 uma transformação linear de 𝑉 em 

𝑊.  Denominamos  núcleo  da  transformação  linear  𝑇  e  representamos  por  𝐾𝑒𝑟 (𝑇)  ao 

seguinte subconjunto de 𝑉: 

𝐾𝑒𝑟  𝑇  =  𝑣 ∈ 𝑉; 𝑇 𝑣  = 0  

Exemplo: Considerando a transformação linear 𝑇: ℝ3 → ℝ2, definida por 𝑇 𝑥, 𝑦, 𝑧  =

(3𝑥, 2𝑥 − 𝑦 + 5𝑧), para todo  𝑥, 𝑦, 𝑧  ∈ 𝐾𝑒𝑟(𝑇), temos 𝑇 𝑥, 𝑦, 𝑧  = (0,0), o que implica que 

 3𝑥, 2𝑥 − 𝑦 + 5𝑧  = (0,0), ou seja, 𝑥 = 0 e 𝑦 = 5𝑧, portanto, 𝐾𝑒𝑟  𝑇  =   0, 5𝑧, 𝑧 ; 𝑧 ∈ ℝ  . 

 
 
 
 
 
 
96 

Teorema 5.11: Sejam 𝑉 e 𝑊 dois K-espaços vetoriais e 𝑇: 𝑉 → 𝑊 uma transformação linear, 

então 𝐾𝑒𝑟 (𝑇) é um subespaço vetorial de 𝑉. 

Demonstração:  Dados  𝑣1, 𝑣2 ∈ 𝐾𝑒𝑟 (𝑇),  por  definição  de  núcleo,  temos  que  𝑇 𝑣1  = 0  e 
𝑇 𝑣2  = 0.  Sejam  𝛼, 𝛽 ∈ 𝐾,  para  que  𝐾𝑒𝑟 (𝑇)  seja  um  subespaço  vetorial  de  𝑉  devemos 
mostrar que 𝛼𝑣1 + 𝛽𝑣2 ∈ 𝐾𝑒𝑟 (𝑇), ou seja, devemos ter 𝑇 𝛼𝑣1 + 𝛽𝑣2  = 0, o que é fácil de 
comprovar,  pois,  como  𝑇  é  linear,  temos  𝑇 𝛼𝑣1 + 𝛽𝑣2  = 𝑇 𝛼𝑣1  + 𝑇 𝛽𝑣2  = 𝛼𝑇 𝑣1  +
𝛽𝑇 𝑣2  = 𝛼. 0 + 𝛽. 0 = 0 = 0 = 0. Logo, 𝐾𝑒𝑟 (𝑇) é um subespaço vetorial de 𝑉. 

Teorema 5.12: Sejam 𝑉 e 𝑊 dois K-espaços vetoriais e 𝑇: 𝑉 → 𝑊 uma transformação linear, 

então 𝑇 é injetiva se, e somente se, 𝐾𝑒𝑟  𝑇  =  0 . 

Demonstração:  

(⟹)  Suponhamos  que  𝑇  seja  injetiva  e  seja  𝑣 ∈ 𝐾𝑒𝑟 (𝑇),  então  temos  𝑇 𝑣  = 0.  Mas,  no 

teorema  5.11  vimos  que  𝐾𝑒𝑟 (𝑇)  é  um  subespaço  vetorial  de  𝑉,  então  0 ∈ 𝐾𝑒𝑟(𝑇),  o  que 

implica que 𝑇 0  = 0 e, portanto, 𝑇 𝑣  = 𝑇(0), mas, por hipótese 𝑇 é injetiva, o que acarreta 

que 𝑣 = 0 e, portanto, 𝐾𝑒𝑟  𝑇  =  0 . 

(⇐) Suponhamos 𝑣1, 𝑣2 ∈ 𝑉 e 𝐾𝑒𝑟  𝑇  =  0 . Se 𝑇 𝑣1  = 𝑇(𝑣2) então, subtraindo 𝑇(𝑣2) de 
ambos os membros da igualdade, temos 𝑇 𝑣1  − 𝑇(𝑣2) = 0 e, como 𝑇 é linear, 𝑇(𝑣1 − 𝑣2) =

0, ou seja, 𝑣1 − 𝑣2 ∈ 𝐾𝑒𝑟 (𝑇), ou seja, 𝑣1 − 𝑣2 = 0, o que implica que  𝑣1 = 𝑣2 ou seja, 𝑇 é 

injetiva. 

Dados 𝑉 e 𝑊 dois K-espaços vetoriais e  𝑇: 𝑉 → 𝑊 uma transformação linear de 𝑉 em 

𝑊. Denominamos imagem da transformação T e representamos por 𝐼𝑚(𝑇) ao conjunto: 

𝐼𝑚 𝑇  =  𝑇 𝑣 ; 𝑣 ∈ 𝑉  

A imagem de uma transformação linear 𝑇: 𝑉 → 𝑊 é um subespaço vetorial de 𝑊, pois 

dados  𝑤1, 𝑤2 ∈ 𝐼𝑚(𝑇)  e  𝛼, 𝛽 ∈ 𝐾,  existem  𝑣1, 𝑣2 ∈ 𝑉  tais  que  𝑤1 = 𝑇(𝑣1)  e  𝑤2 = 𝑇(𝑣2), 

assim: 

 𝛼 ∙ 𝑤1 + 𝛽 ∙ 𝑤2 = 𝛼 ∙ 𝑇 𝑣1  + 𝛽 ∙ 𝑇 𝑣2  = 𝑇 𝛼 ∙ 𝑣1  + 𝑇 𝛽 ∙ 𝑣2  = 𝑇(𝛼 ∙ 𝑣1 + 𝛽 ∙ 𝑣2) ∈ 𝐼𝑚(𝑇) 

Se 𝐼𝑚 𝑇  = 𝑊, então 𝑇 é sobrejetiva. 

Teorema  5.13: Sejam  𝑉 e  𝑊 dois  K-espaços vetoriais  de dimensão  finita e  𝑇: 𝑉 → 𝑊 uma 

transformação linear, então, dim 𝑉 = dim 𝐾𝑒𝑟(𝑇) + dim 𝐼𝑚(𝑇). 

Demonstração: Seja 𝐵1 =  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡  uma base de 𝐾𝑒𝑟(𝑇). De acordo com o teorema 

5.10, essa base pode ser completada de modo a se obter uma base                          𝐵2 =

 
 
 
 
97 

 𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡, 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑚    do  espaço  vetorial  𝑉.  Devemos  demonstrar  então  que 
𝑇 𝑢1 , 𝑇 𝑢2 , 𝑇 𝑢3 , … , 𝑇 𝑢𝑚    é uma base de 𝐼𝑚(𝑇): 
Qualquer que seja 𝑤 ∈ 𝐼𝑚(𝑇), existe 𝑣 ∈ 𝑉 tal que 𝑇 𝑣  = 𝑤. Como 𝑣 ∈ 𝑉, então 𝛼𝑖, 𝛽𝑗 ∈ 𝐾, 

1 ≤ 𝑖 ≤ 𝑡 e 1 ≤ 𝑗 ≤ 𝑚 tal que 𝑣 = 𝛼1 ∙ 𝑣1 + 𝛼2 ∙ 𝑣2 + ⋯ + 𝛼𝑡 ∙ 𝑣𝑡 + 𝛽1 ∙ 𝑢1 + 𝛽2 ∙ 𝑢2 + ⋯ +

𝛽𝑚 ∙ 𝑢𝑚 ,  mas,  𝑤 = 𝑇(𝑣),  então,  𝑤 = 𝑇(𝛼1 ∙ 𝑣1 + 𝛼2 ∙ 𝑣2 + ⋯ + 𝛼𝑡 ∙ 𝑣𝑡 + 𝛽1 ∙ 𝑢1 + 𝛽2 ∙ 𝑢2 +

⋯ + 𝛽𝑚 ∙ 𝑢𝑚 ) 
e,  𝑤 = 𝛼1𝑇(𝑣1) + 𝛼2𝑇(𝑣2) + ⋯ + 𝛼𝑡𝑇(𝑣𝑡) + 𝛽1𝑇(𝑢1) + 𝛽2𝑇(𝑢2) + ⋯ +
𝛽𝑚 𝑇(𝑢𝑚 ).  Como  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡  pertencem  a  𝐾𝑒𝑟(𝑇),  então  𝑇(𝑣1) = 𝑇 𝑣2  = 𝑇 𝑣3  =
⋯ = 𝑇 𝑣𝑡  = 0, 
 𝑇 𝑢1 ,
logo  𝑤 = 𝛽1𝑇(𝑢1) + 𝛽2𝑇(𝑢2) + ⋯ + 𝛽𝑚 𝑇(𝑢𝑚 ),  ou 
𝑇 𝑢2 ,   𝑇 𝑢3 , … , 𝑇(𝑢𝑚 )   = 𝐼𝑚(𝑇).  Por  outro  lado,  considerando  a  combinação  linear 
𝛽1𝑇 𝑢1  + 𝛽2𝑇 𝑢2  + 𝛽3𝑇 𝑢3  + ⋯ + 𝛽𝑚 𝑇 𝑢𝑚   = 0  como  𝑇  é  uma  transformação  linear, 

seja 

então  temos  𝑇(𝛽1 ∙ 𝑢1 + 𝛽2 ∙ 𝑢2 + 𝛽3 ∙ 𝑢3 + ⋯ + 𝛽𝑚 ∙ 𝑢𝑚 ) = 0,  o  que  implica  que  𝛽1 ∙ 𝑢1 +

𝛽2 ∙ 𝑢2 + 𝛽3 ∙ 𝑢3 + ⋯ + 𝛽𝑚 ∙ 𝑢𝑚 ∈ 𝐾𝑒𝑟(𝑇)  e,  portanto,  pode  ser  escrito  como  combinação 

linear dos vetores da  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡 que constituem uma base de  𝐾𝑒𝑟(𝑇), ou seja, existem 

escalares  𝛾1, 𝛾2, 𝛾3, … , 𝛾𝑡 

tais  que  𝛽1 ∙ 𝑢1 + 𝛽2 ∙ 𝑢2 + 𝛽3 ∙ 𝑢3 + ⋯ + 𝛽𝑚 ∙ 𝑢𝑚 = 𝛾1. 𝑣1 +

𝛾2. 𝑣2 + 𝛾3. 𝑣3 + ⋯ + 𝛾𝑡. 𝑣𝑡,  ou  seja,  𝛽1 ∙ 𝑢1 + 𝛽2 ∙ 𝑢2 + 𝛽3 ∙ 𝑢3 + ⋯ + 𝛽𝑚 ∙ 𝑢𝑚 − 𝛾1. 𝑣1 −

𝛾2. 𝑣2 − 𝛾3. 𝑣3 − ⋯ − 𝛾𝑡. 𝑣𝑡 = 0,  porém  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑡, 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑚   é  uma  base  de  𝑉, 

logo  𝛽1 = 𝛽2 = 𝛽3 = ⋯ = 𝛽𝑚 = 𝛾1 = 𝛾2 = 𝛾3 = ⋯ 𝛾𝑡 = 0.  Como  𝛽1 = 𝛽2 = 𝛽3 = ⋯ =
𝛽𝑚 = 0,  então  𝑇 𝑢1 , 𝑇 𝑢2 ,   𝑇 𝑢3 , … , 𝑇(𝑢𝑚 )  são  linearmente  independentes,  e  portanto 

formam  uma  base  para  𝐼𝑚(𝑇).  Como  uma  base  de  𝑉  tem  𝑡 + 𝑚  elementos  e,  portanto 

dim 𝑉 = 𝑡 + 𝑚,  sendo  dim 𝐾𝑒𝑟 𝑇  = 𝑡,  acabamos  de  verificar  que  dim 𝐼𝑚 𝑇  = 𝑚.  Logo, 

dim 𝑉 = dim 𝐾𝑒𝑟 𝑇  + dim 𝐼𝑚(𝑇). 

Teorema  5.14: Sejam  𝑉 e  𝑊 dois  K-espaços vetoriais  de dimensão  finita e  𝑇: 𝑉 → 𝑊 uma 

transformação linear injetiva. Se dim 𝑉 = dim 𝑊 então 𝑇 transforma uma base qualquer de 𝑉 

em uma base de 𝑊. 

Demonstração:  Consideremos  que  dim 𝑉 = dim 𝑊 = 𝑛 e  𝐵 =  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑛   seja  uma 

das 

bases 

de 

𝑉.  Mostraremos 

que 

o 

conjunto 

𝑆 ⊂ 𝑊 

tal 

que 

𝑆 =  𝑇(𝑣1), 𝑇(𝑣2), 𝑇(𝑣3), … , 𝑇(𝑣𝑛 )  é linearmente independente e tem uma quantidade 𝑛 de 

vetores,  e,  portanto,  é  uma  das  bases  de  𝑊:  Como  𝑇  é  injetiva,  então  𝑇(𝑣1) ≠ 𝑇(𝑣2) ≠

𝑇(𝑣3) ≠ ⋯ ≠ 𝑇(𝑣𝑛 ),  ou  seja,  𝑆  possui  exatamente  𝑛  vetores.  Sejam  𝛼1, 𝛼2, 𝛼3, … , 𝛼𝑛  
escalares  do  corpo  𝐾,  tais  que  𝛼1 ∙ 𝑇(𝑣1) + 𝛼2 ∙ 𝑇(𝑣2) + 𝛼3 ∙ 𝑇 𝑣3  + ⋯ + 𝛼𝑛 ∙ 𝑇(𝑣𝑛 ) = 0, 
como  𝑇  é  linear,  então  𝑇 𝛼1 ∙ 𝑣1 + 𝛼2 ∙ 𝑣2 + 𝛼3 ∙ 𝑣3 + ⋯ + 𝛼𝑛 ∙ 𝑣𝑛   = 0,  o  que  implica  que 

𝛼1 ∙ 𝑣1 + 𝛼2 ∙ 𝑣2 + 𝛼3 ∙ 𝑣3 + ⋯ + 𝛼𝑛 ∙ 𝑣𝑛 = 0,  mas  𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑛  

são 

linearmente 

 
 
98 

independentes, 

𝛼1 = 𝛼2 = 𝛼3 = ⋯ = 𝛼𝑛 = 0, 
𝑆 =  𝑇(𝑣1), 𝑇(𝑣2), 𝑇(𝑣3), … , 𝑇(𝑣𝑛 )  é um conjunto de 𝑛 vetores linearmente independentes, e 

portanto, 

implica 

que 

que 

o 

portanto, uma base de 𝑊. 

5.6.5  Noções sobre produto interno 

Definição: Considerando 𝑉 um espaço vetorial finitamente gerado sobre um corpo 𝐾, 

denominamos produto interno sobre 𝑉 à função que transforma cada par de vetores  𝑢, 𝑣  ∈

𝑉 × 𝑉  em  um  escalar  𝑎 ∈ 𝐾,  o  qual  representaremos  por   𝑢, 𝑣 ,  com  as  seguintes 

propriedades: 

∀𝑢, 𝑣, 𝑤 ∈ 𝑉 e 𝛼 ∈ 𝐾, temos: 

I)   𝑢 + 𝑣, 𝑤  =  𝑢, 𝑤  +  𝑣, 𝑤  

II)   𝛼 ∙ 𝑢, 𝑣  = 𝛼.  𝑢, 𝑣  

III)  𝑢, 𝑣  =  𝑣, 𝑢  

IV)  𝑢, 𝑢  > 0𝑘,  para  todo  𝑢 ≠ 0𝑣,  onde  0𝑘  representa  o  elemento  neutro  da  adição  no 

corpo 𝐾 e 0𝑣 representa o vetor nulo no espaço 𝑉. 
Exemplo: Consideremos o espaço vetorial ℝ3 sobre o corpo ℝ. Dados 𝑢, 𝑣, 𝑤 ∈ ℝ3, e 

𝛼 ∈ ℝ,  a  operação   𝑢, 𝑣  =   𝑥1, 𝑦1, 𝑧1  ∙  𝑥2, 𝑦2, 𝑧2   = 𝑥1 ∙ 𝑥2 + 𝑦1 ∙ 𝑦2 + 𝑧1 ∙ 𝑧2  é  um 

produto interno sobre 𝑉. Verifiquemos: 

I)   𝑢 + 𝑣, 𝑤  =    𝑥1, 𝑦1, 𝑧1  +  𝑥2, 𝑦2, 𝑧2  ,  𝑥3, 𝑦3, 𝑧3   = 

=   𝑥1 + 𝑥2, 𝑦1 + 𝑦2, 𝑧1 + 𝑧2 ,  𝑥3, 𝑦3, 𝑧3   =  
=  𝑥1 + 𝑥2 . 𝑥3 +  𝑦1 + 𝑦2  ∙ 𝑦3 +  𝑧1 + 𝑧2  ∙ 𝑧3 =  

= 𝑥1 ∙ 𝑥3 + 𝑥2 ∙ 𝑥3 + 𝑦1 ∙ 𝑦3 + 𝑦2 ∙ 𝑦3 + 𝑧1 ∙ 𝑧3 + 𝑧2 ∙ 𝑧3 =  
=  𝑥1 ∙ 𝑥3 + 𝑦1 ∙ 𝑦3 + 𝑧1 ∙ 𝑧3  +  𝑥2 ∙ 𝑥3 + 𝑦2 ∙ 𝑦3 + 𝑧2 ∙ 𝑧3  =  
=   𝑥1, 𝑦1, 𝑧1 ,  𝑥3, 𝑦3, 𝑧3   +   𝑥2, 𝑦2, 𝑧2 ,  𝑥3, 𝑦3, 𝑧3   =  𝑢, 𝑤  +  𝑣, 𝑤   
II)   𝛼 ∙ 𝑢, 𝑣  =  𝛼 ∙  𝑥1, 𝑦1, 𝑧1 ,  𝑥2, 𝑦2, 𝑧2   =   𝛼 ∙ 𝑥1, 𝛼 ∙ 𝑦1, 𝛼 ∙ 𝑧1 ,  𝑥2, 𝑦2, 𝑧2   = 

=  𝛼 ∙ 𝑥1  ∙ 𝑥2 +  𝛼 ∙ 𝑦1  ∙ 𝑦2 +  𝛼 ∙ 𝑧1  ∙ 𝑧2 =  
= 𝛼 ∙  𝑥1 ∙ 𝑥2  + 𝛼 ∙  𝑦1 ∙ 𝑦2  + 𝛼 ∙  𝑧1 ∙ 𝑧2  = 𝛼 ∙  𝑥1 ∙ 𝑥2 + 𝑦1 ∙ 𝑦2 + 𝑧1 ∙ 𝑧2  =   
= 𝛼 ∙   𝑥1, 𝑦1, 𝑧1 ,  𝑥2, 𝑦2, 𝑧2   = 𝛼 ∙  𝑢, 𝑣   

III)  𝑢, 𝑣  =   𝑥1, 𝑦1, 𝑧1 ,  𝑥2, 𝑦2, 𝑧2   = 𝑥1 ∙ 𝑥2 + 𝑦1 ∙ 𝑦2 + 𝑧1 ∙ 𝑧2 =  
= 𝑥2 ∙ 𝑥1 + 𝑦2 ∙ 𝑦1 + 𝑧2 ∙ 𝑧1 =   𝑥2, 𝑦2, 𝑧2 ,  𝑥1, 𝑦1, 𝑧1   =  𝑣, 𝑢   

IV) Se  𝑢 ≠  0,0,0 ,  então,  temos  𝑥1 ≠ 0  ou  𝑦1 ≠ 0  ou    𝑧1 ≠ 0,  assim,  temos   𝑢, 𝑢  =

  𝑥1, 𝑦1, 𝑧1 ,  𝑥1, 𝑦1, 𝑧1   = 𝑥1 ∙ 𝑥1 + 𝑦1 ∙ 𝑦1 + 𝑧1 ∙ 𝑧1 = 𝑥1

2 + 𝑦1

2 + 𝑧1

2 > 0. 

 
 
 
99 

6  CÓDIGOS CORRETORES DE ERROS 

O  avanço  rápido  da  tecnologia  está  presente  no  nosso  cotidiano.  Dispomos  hoje  de 

grande  facilidade  em  armazenar  dados  ou  nos  comunicar  de  maneira  prática  e  rápida 

utilizando aparelhos eletrônicos como celulares, tablets, microcomputadores, além dos meios 

de  comunicação  convencionais  tais  como  televisão,  rádio  etc.,  que  geram  ao  mesmo  tempo 

eficiência, conforto e lazer para nós usuários. No entanto passam despercebidos à maioria dos 

usuários  todo  um  contexto  matemático  utilizado  e  necessário  para  o  funcionamento  desses 

aparelhos. Embora não utilizemos matemática de maneira direta ao, por exemplo, enviarmos 

uma  mensagem  via  celular,  de  maneira  indireta  isso  só  é  possível  por  meio  da  utilização 

indireta da matemática.  

Um  aspecto  importante  no  envio  ou  armazenamento  de  informações  consiste  na 

incerteza em saber se a informação por nós enviada através de um dispositivo eletrônico de 

comunicação será recebida tal qual enviamos ou se um dado hoje armazenado será acessado 

amanhã  com  o  mesmo  grau  de  fidedignidade.  Informações  enviadas  ou  armazenadas  serão 

passíveis  de  erros?  Caso  haja  um  erro  na  transmissão  de  uma  informação  ou  no 

armazenamento  da  mesma,  serão  possíveis  as  detecções  e  correções?  Pensando  nessas 

questões, abordaremos a seguir a teoria dos Códigos Corretores de Erros. 

A teoria dos códigos foi criada pelo matemático americano Claude Elwood Shannon, 

no laboratório Bell, e foi apresentada de um trabalho publicado no ano de 1948. Nas décadas 

de  50  e  60  vários  matemáticos  que  se  interessaram  pelo  assunto,  contribuíram  de  forma 

considerável  com  o  desenvolvimento  dessa  teoria.  A  partir  da  década  de  70,  profissionais 

engenheiros  passaram  a  ter  interesse  pela  teoria  em  virtude  das  pesquisas  espaciais, 

telecomunicações e o uso difundido de computadores. Nos dias atuais, qualquer aparelho que 

seja utilizado para a transmissão ou armazenamento de dados, faz uso dessa teoria, portanto, a 

teoria dos códigos está a cada dia mais presente em nossas vidas.   

6.1  O QUE É UM CÓDIGO? 

Podemos citar como exemplo de um código o idioma que usamos. Consideremos um 

alfabeto 

formado  por  38  caracteres,  sendo  37  deles  os  caracteres  a  seguir: 

 
 
 
 
 
 𝑎, 𝑏, 𝑐, 𝑑, 𝑒, 𝑓, 𝑔, 𝑕, 𝑖, 𝑗, 𝑘, 𝑙, 𝑚, 𝑛, 𝑜, 𝑝, 𝑞, 𝑟, 𝑠, 𝑡, 𝑢, 𝑣, 𝑤, 𝑥, 𝑦, 𝑧, á, à, â, ã, é, ê, í, ó, ô, õ, ú   e  mais 

um  caractere  correspondendo  ao  espaço  entre  palavras.  Denominaremos  esse  alfabeto  de  𝑃. 

100 

Consideremos 
seja 
“pneumoultramicroscopicossilicovulcanoconiótico”6.  Percebe-se  que  𝑃  possui  38  elementos 

alfabeto 

palavra 

maior 

desse 

que 

a 

(caracteres) e sua maior palavra possui 46 caracteres. Podemos fazer com que cada palavra de 

𝑃 possua exatamente o mesmo número de caracteres da sua maior palavra, ou seja, por meio 

do acréscimo de espaços no fim de cada palavra de 𝑃, fazemos com que todas elas possuam 

exatamente 46 caracteres. Definimos assim um código como sendo um conjunto 𝐶 ⊂ 𝑃46 de 

todas as palavras existentes no nosso idioma. Notemos, porém que o código 𝐶 não é eficiente 

para  detectar  e  corrigir  erros,  por  exemplo,  se  transmitíssemos  a  palavra  “telefone”  e 

ocorresse um erro na transmissão, de modo que a palavra recebida fosse “belefone”, o código 

𝐶 detectaria que houve um erro, pois belefone não pertence ao conjunto 𝐶. Uma vez detectado 

o erro, seria fácil corrigi-lo, pois a palavra pertencente a 𝐶 que mais se aproxima de belefone é 

telefone. Sendo assim, saberíamos que a palavra transmitida, na realidade havia sido telefone. 

Em contrapartida, se  a palavra transmitida fosse  “bola”  e por ventura ocorresse um  erro na 

transmissão, de modo que a palavra recebida fosse “wola”, o erro seria detectado, pois wola 

não  é  uma  palavra  pertencente  a  𝐶,  porém,  a  correção  seria  impossível,  uma  vez  que  em  𝐶 

existem várias palavras que igualmente se aproximam de wola, por exemplo bola, cola, mola, 

sola e gola. Em uma terceira hipótese, se a palavra transmitida fosse “caneca” e ocorresse um 

erro  na  transmissão,  de  modo  que  a  palavra  recebida  fosse  “canela”,  o  código  𝐶  nem 

detectaria o erro, pois a palavra canela também pertence a 𝐶. 

Para exemplificar os princípios da teoria dos códigos, analisemos o seguinte caso: 

Suponhamos  que  o  braço  mecânico  de  base  fixa  da  figura  2,  através  de  comandos 

digitais, possibilite quatro movimentos básicos: para cima, para baixo, para a direita e para 

a esquerda: 

Figura 2: Braço mecânico 

Fonte: <http://thing-better.blogspot.com.br/2013/04/o-que-e-robotica_6379.html> 

6 Doença pulmonar causada pela inalação de cinzas de origem vulcânica. 

 
 
  
 
 
 
 
                                                           
 
 
101 

Aos comandos acima denominaremos “fonte”. 

Os  circuitos  digitais  (ou  circuitos  lógicos)  baseiam  seu  funcionamento  na  lógica 

binária, ou seja, cada informação deve ser expressa utilizando-se de dois dígitos, a saber, 0 e 

1.  Como  temos  dois  dígitos  disponíveis  para  expressar  os  comandos  e  dispomos  de  quatro 

comandos  básicos  para  o  braço  mecânico,  considerando  o  conjunto  𝐹 =  0,1 ,  podemos 

codificar os quatro comandos como elementos de 𝐹2 = 𝐹 × 𝐹 =   0,0 ,  0,1 ,   1,0 ,  1,1 }. 

Por simplicidade de notação, consideraremos cada par  𝑎, 𝑏  ∈ 𝐹2 simplesmente como 𝑎𝑏 e a 

cada  um  dos  quatro  comandos  00,  01,  10  e  11  denominaremos  “código  da  fonte”.  Por 

exemplo: 

Fonte 

Código da fonte 

Para a esquerda: 

Para a direita: 

Para cima: 

Para baixo: 

00 

01 

10 

11 

Imaginemos  agora  que  os  comandos  (mensagens)  sejam  transmitidos  ao  braço 

mecânico  via  sinais  de  rádio  frequência,  através  de  um  controle  remoto  por  exemplo. 

Suponhamos  que  seja  dado  ao  braço  mecânico  o  comando  “para  a  esquerda”,  o  que  será 

convertido para o código de fonte 00 e enviado ao braço mecânico, indicando para que ele se 

mova  para  a  esquerda.  Suponhamos  ainda  que  a  transmissão  do  sinal,  por  alguma 

interferência externa, sofra um erro e chegue até o braço mecânico como  10, o que acarreta 

que o braço em vez de mover-se para a esquerda, fosse movido para cima. Observemos que o 

circuito  digital  do  braço  mecânico  seria  incapaz  de  detectar  o  erro,  pois  10  é  um  comando 

existente em seu banco de dados.  

Diante de uma situação como a descrita acima, o que fazemos é inserir redundâncias, 

através do acréscimo de dígitos nos códigos da fonte, de modo que se possa detectar e corrigir 

possíveis  erros  de  transmissão,  dando  origem  a  um  novo  código  ao  qual  denominamos  de 

“código de canal”: 

Fonte 

Código da fonte  Código de canal 

Para a esquerda: 

Para a direita: 

Para cima: 

Para baixo: 

00 

01 

10 

11 

00000 

01011 

10110 

11101 

 
 
 
 
 
 
102 

Nesta  nova  codificação,  as  duas  primeiras  posições  representam  o  código  da  fonte 

enquanto as três últimas posições são as redundâncias inseridas. 

Façamos a seguir uma nova análise: 

Suponhamos que seja dado ao braço mecânico o comando “para a direita”, o que será 

convertido para o código da fonte 01 e em seguida acrescido de redundâncias será convertido 

para o código de canal 01011 e enviado ao braço mecânico, indicando para que ele se mova 

para  a  direita.  Suponhamos  ainda  que  a  transmissão  do  sinal,  por  alguma  interferência 

externa,  sofra  um  erro  e  chegue  até  o  braço  mecânico  como  01010.  Notemos  que  esse 

comando  não  existe  em  banco  de  dados  e  isso  acarretaria  a  identificação  de  um  erro  pelo 

circuito digital do braço mecânico. Consultando seu banco de dados, o comando que mais se 

aproxima de  01010  é  01011  e, portanto,  o circuito  digital  faria a correção, interpretando o 

comando recebido como 01011 e movendo o braço mecânico para a direita. 

Vejamos em diagrama de blocos a seguir,  todas as etapas desde o comando dado até a 

chegada da mensagem transmitida: 

Fonte 

⟶ 

Codificador 
da fonte 

⟶ 

Codificador 
de canal 

↓ 

Canal 

↓ 

Decodificador 
de canal 

⟶ 

Decodificador 
da fonte 

⟶ 

Usuário 

O estudo da teoria dos códigos apresentado nesse trabalho, objetivará a transformação 

de  códigos  da  fonte  em  códigos  de  canal,  as  detecções  e  correções  de  possíveis  erros 

ocorridos  durante  o  processo  de  transmissão  e  a  decodificação  de  códigos  de  canal  em 

códigos  da  fonte.  Consideraremos  nesse  estudo  apenas  canais  simétricos,  canais  estes  que 

possuem as seguintes características: 

-  Todos  os  caracteres  transmitidos  tem  a  mesma  probabilidade  (ínfima)  de  serem  recebidos 

errados; 

-  Se  um  caractere  é  recebido  errado,  a  probabilidade  de  ele  ser  qualquer  um  dos  outros 

caracteres disponíveis é a mesma. 

 
 
 
 
 
 
 
 
 
 
 
 
103 

6.2  MÉTRICA DE HAMMING 

Primeiramente entendamos o que é uma métrica. 

Uma métrica é uma generalização do conceito geométrico de distância. Dizemos que, 

dado  um  conjunto  𝑇,  uma  métrica  em  𝑇  é  uma  função  𝑑: 𝑇 × 𝑇  →  ℝ    que  a  cada   𝑥, 𝑦  ∈

𝑇 × 𝑇    faz  corresponder  o  elemento  𝑑 𝑥, 𝑦  ∈ ℝ,  denominado  a  distância  de  𝑥  a  𝑦,  tal  que 

para todo 𝑥, 𝑦, 𝑧 ∈ 𝑇, temos: 

  𝑑 𝑥, 𝑦  ≥ 0, valendo a igualdade quando 𝑥 = 𝑦  

  𝑑 𝑥, 𝑦  = 𝑑(𝑦, 𝑥) (simetria) 

  𝑑 𝑥, 𝑧  ≤ 𝑑 𝑥, 𝑦  + 𝑑(𝑦, 𝑧) (desigualdade triangular) 

Dado um conjunto 𝐴, finito, ao qual denominaremos de alfabeto. Representaremos  o 

número de elementos de 𝐴 por  𝐴  = 𝑞. Definimos um código corretor de erros como sendo 

um  subconjunto  próprio  qualquer  de  𝐴𝑛 ,  com  𝑛 ∈ ℕ.  Dados  𝑢, 𝑣 ∈ 𝐴𝑛 ,  denominamos  de 

“distância de Hamming” ao valor 𝑑 𝑢, 𝑣  =   𝑖, 𝑢𝑖 ≠ 𝑣𝑖, 1 ≤ 𝑖 ≤ 𝑛    . 

Vejamos um exemplo: 

Sendo 𝐴 =  0,1 , para 𝑛 = 4, temos  𝐴4  = 16 e  0000, 0001, 1010,1011, 1111   ⊂

𝐴4. Assim: 

𝑑 1010,1011  = 1  

𝑑 0001,1011  = 2  

𝑑 0001,1111  = 3  

𝑑 0000, 1111  = 4  

Consideremos,  de  maneira  geral,  os  elementos  𝑢, 𝑣, 𝑤 ∈ 𝐴𝑛 , 

tais  que  𝑢 =

𝑢1𝑢2𝑢3 … 𝑢𝑛 ,  𝑣 = 𝑣1𝑣2𝑣3 … 𝑣𝑛   e  𝑤 = 𝑤1𝑤2𝑤3 … 𝑤𝑛.  Como  𝑢𝑖, 𝑣𝑖 ∈  0,1   para  todo  𝑖 ∈
 1, 2, … , 𝑛 ,  se  tivermos  𝑢𝑖 = 𝑣𝑖,  então  𝑑 𝑢, 𝑣  = 0,  caso  existam  𝑘  índices  𝑖  para  os  quais 
𝑢𝑖 ≠ 𝑣𝑖  então,  por  definição,  𝑑 𝑢, 𝑣  = 𝑘 > 0,  logo,  deduzimos  que  𝑑 𝑢, 𝑣  ≥ 0.  Por  outro 
lado, se tivermos 𝑢𝑖 = 𝑣𝑖 para todo 𝑖 ∈  1, 2, … , 𝑛 , então 𝑢 = 𝑣, o que implica que 𝑑 𝑢, 𝑣  =
0 e 𝑑 𝑣, 𝑢  = 0, acarretando que  𝑑 𝑢, 𝑣  = 𝑑 𝑣, 𝑢 . Caso existam 𝑘 índices  𝑖 para os quais 

𝑢𝑖 ≠ 𝑣𝑖 então, por definição, 𝑑 𝑢, 𝑣  = 𝑘 e 𝑑 𝑣, 𝑢  = 𝑘, implicando que 𝑑 𝑢, 𝑣  = 𝑑 𝑣, 𝑢 .  

Para  cada  índice  𝑖,  a  contribuição  para  a  distância  𝑑(𝑢, 𝑣),  das  𝑖 − é𝑠𝑖𝑚𝑎𝑠 

coordenadas de  𝑢  e  𝑣 é igual  a  0  ou 1, respectivamente se  𝑢𝑖 = 𝑣𝑖  ou  𝑢𝑖 ≠ 𝑣𝑖. De maneira 

análoga  a  contribuição  para  a  distância  𝑑(𝑣, 𝑤),    das  𝑖 − é𝑠𝑖𝑚𝑎𝑠  coordenadas  de  𝑣  e  𝑤  é 

igual  a  0  ou  1,  respectivamente  se  𝑣𝑖 = 𝑤𝑖  ou  𝑣𝑖 ≠ 𝑤𝑖  e  a  contribuição  para  a  distância 

𝑑(𝑢, 𝑤), das 𝑖 − é𝑠𝑖𝑚𝑎𝑠 coordenadas de 𝑢 e 𝑤 é igual a 0 ou 1, respectivamente se 𝑢𝑖 = 𝑤𝑖 

 
 
 
 
104 

ou  𝑢𝑖 ≠ 𝑤𝑖.  Considerando  que  a  contribuição  para  a  distância  𝑑(𝑢, 𝑤),  das  𝑖 − é𝑠𝑖𝑚𝑎𝑠 
coordenadas  de  𝑢  e  𝑤  seja  0,  ou  seja,  𝑢𝑖 = 𝑤𝑖, então  temos  𝑑 𝑢, 𝑤  ≤ 𝑑 𝑢, 𝑣  + 𝑑(𝑣, 𝑤), 
pois a contribuição das 𝑖 − é𝑠𝑖𝑚𝑎𝑠 coordenadas de 𝑢𝑖 e 𝑣𝑖  e 𝑣𝑖 e 𝑤𝑖 em 𝑑 𝑢, 𝑣  + 𝑑(𝑣, 𝑤) é 

igual a 0, 1 ou 2. Caso consideremos 𝑢𝑖 ≠ 𝑤𝑖, então não se tem 𝑢𝑖 = 𝑣𝑖 e 𝑣𝑖 = 𝑤𝑖, pois seria 

contrário a hipótese, assim, temos que a contribuição das 𝑖 − é𝑠𝑖𝑚𝑎𝑠 coordenadas de 𝑢𝑖 e 𝑣𝑖  
e 𝑣𝑖 e 𝑤𝑖 em 𝑑 𝑢, 𝑣  + 𝑑(𝑣, 𝑤) é maior ou igual a 1, que, por hipótese, é a contribuição das 
𝑖 − é𝑠𝑖𝑚𝑎𝑠 coordenadas de 𝑢𝑖 e 𝑤𝑖 em 𝑑 𝑢, 𝑤 . Portanto, temos sempre 𝑑 𝑢, 𝑤  ≤ 𝑑 𝑢, 𝑣  +

𝑑(𝑣, 𝑤). 

Concluímos com isso que a distância de Hamming  entre os elementos de 𝐴𝑛  cumpre 

as  três  condições  necessárias  para  classificá-la  como  uma  métrica,  portanto,  a  partir  desse 

momento a denominaremos de métrica de Hamming. 

6.2.1  Disco e esfera de centro c e raio r 

Consideremos um elemento 𝑐 ∈ 𝐴𝑛  e 𝑟 ∈ ℝ, tal que 𝑟 ≥ 0. 

Dizemos  que  um  disco  de  centro  𝑐  e  raio  𝑟  é  um  conjunto  𝐷 𝑐, 𝑟  =  𝑢 ∈

𝐴𝑛 ; 𝑑(𝑢, 𝑐) ≤ 𝑟 .  De  maneira  análoga,  definimos  uma  esfera  de  centro  𝑐  e  raio  𝑟  como  um 

conjunto 𝑆 𝑐, 𝑟  =  𝑢 ∈ 𝐴𝑛 ; 𝑑 𝑢, 𝑐  = 𝑟 . 

Discos e esferas são conjuntos finitos como veremos a seguir: 

Sendo   𝐴  = 𝑞  o  número  de  elementos  do  alfabeto  𝐴  e  𝑢 ∈ 𝐴  uma  palavra  desse 

alfabeto, em cada coordenada de 𝑢 temos 𝑞 − 1 elementos de 𝐴𝑛  distintos, que podem variar 

nas 𝑖 coordenadas de 𝑢, obtendo com isso  𝑞 − 1 𝑖. Como 𝑢 tem tamanho 𝑛 e as 𝑖 entradas 

distintas  podem  percorrer  qualquer  coordenada  de  𝑢,  temos  então  a  combinação   

𝑛
𝑖

 .  Se 

 𝑆 𝑐, 𝑖   representa o número de elementos da esfera 𝑆 de centro 𝑐 e raio 𝑖, então  𝑆 𝑐, 𝑖   =
𝑛
𝑖

  .  𝑞 − 1 𝑖, o que nos mostra que 𝑆 𝑐, 𝑖  possui um número finito de elementos. Notemos 

ainda que 𝑆 𝑐, 𝑖  ∩ 𝑆 𝑐, 𝑗  = ∅ quando 𝑖 ≠ 𝑗 e que   𝑆 𝑐, 𝑖  = 𝐷 𝑐, 𝑟 

, portanto, o número 

𝑟
𝑖=0

de  elementos  do  conjunto  𝐷 𝑐, 𝑟 ,  representado  por   𝐷 𝑐, 𝑟  ,  também  é  finito,  pois 

 𝐷 𝑐, 𝑟   =    𝑆(𝑐, 𝑖)

𝑟
𝑖=0

  =    𝑆(𝑐, 𝑖)  =    

𝑟
𝑖=0

𝑟
𝑖=0

𝑛
𝑖

  .  𝑞 − 1 𝑖

. 

Vejamos um exemplo: 

Consideremos  o  alfabeto  𝐴 =  0,1 ,  portanto   𝐴  = 𝑞 = 2.  Para  𝑛 = 3,  temos 

𝐴3 =  000, 001, 010, 011, 100, 101, 110, 111 . Consideremos 𝑐 = 010 ∈ 𝐴3 e 𝑟 = 2. Temos 

 
 
 
 
 
105 

então  o 

conjunto  𝑆 𝑐, 𝑟  = 𝑆 010, 2  =  001, 100,111  

e  𝐷 𝑐, 𝑟  = 𝐷 010, 2  =

 000, 001, 010, 011, 100,110, 111 .  Notemos  que   𝑆 010, 2   =  

  . (2 − 1)2 = 3.1 = 3  e 

3
2

que  𝐷 010, 2   =    

3
𝑖=0

3
  . (2 − 1)𝑖 =  
𝑖

3
0

. 10 +  

3
  . 11 +  
1

3
  . 12 = 1 + 3 + 3 = 7 . 
2

6.2.2  Distância mínima de um código 

Dado um código 𝐶, definimos sua distância mínima como sendo um número 𝑑, tal que 

𝑑 = 𝑚𝑖𝑛 𝑑 𝑢, 𝑣 ; 𝑢, 𝑣 ∈ 𝐶 𝑒 𝑢 ≠ 𝑣 . 

No exemplo do braço mecânico, tínhamos o alfabeto 𝐹 =  0,1 , do qual obtivemos o 

código de fonte 𝐹2 =  00, 01, 10, 11  e, através do acréscimo de redundâncias, obtivemos o 

código  𝐶 ⊂ 𝐹5  tal que  𝐶 =  𝑢1, 𝑢2, 𝑢3, 𝑢4  =  00000, 01011, 10110, 11101 . Notemos que 
𝑑 𝑢1, 𝑢2  = 3, 𝑑 𝑢1, 𝑢3  = 3, 𝑑 𝑢1, 𝑢4  = 4, 𝑑 𝑢2, 𝑢3  = 4, 𝑑 𝑢2, 𝑢4  = 3 e 𝑑 𝑢3, 𝑢4  = 3, 
portanto, 𝑑 = 𝑚𝑖𝑛 𝑑 𝑢, 𝑣 ; 𝑢, 𝑣 ∈ 𝐶 𝑒 𝑢 ≠ 𝑣  = 𝑚𝑖𝑛 3, 4  = 3. 

Percebe-se que para determinarmos 𝑑 no exemplo dado, foram necessários os cálculos 

de seis distâncias e que à medida que 𝐶 possua um número maior de palavras, mais cálculos 

de distâncias serão necessários para a determinação de 𝑑. De maneira geral, para o cálculo de 

𝑑 são necessários os cálculos de  

 𝐶 
2

  distâncias, onde  𝐶  representa o número de elementos 

do conjunto 𝐶. Porém, o cálculo de  

 𝐶 
2

  demanda um custo computacional exagerado, o que 

inviabiliza esse método e, para tanto, veremos mais adiante outras maneiras para se encontrar 

𝑑 com um esforço computacional minimizado. 

Considerando  𝐶  um  código  de  distância  mínima  𝑑,  definimos  𝜅 =  

𝑑−1

2

 ,  onde   

𝑑−1

2

representa a parte inteira do número real 

𝑑−1

2

. 

Teorema 6.1: Considerando 𝐶 um código de distância mínima 𝑑. Se 𝑐,𝑐′ ∈ 𝐶 e 𝑐 ≠ 𝑐′, então 

𝐷 𝑐, 𝜅 ⋂𝐷 𝑐′ , 𝜅  = ∅. 

Demonstração: 

Suponhamos 

que 

𝐷 𝑐, 𝜅 ⋂𝐷 𝑐′ , 𝜅  ≠ ∅, 

ou 

seja, 

existe 

𝑢 ∈ 𝐷 𝑐, 𝜅 ⋂𝐷 𝑐′ , 𝜅 ,  então  temos  que  𝑑(𝑢, 𝑐) ≤ 𝜅  e  𝑑(𝑢, 𝑐′) ≤ 𝜅,  mas  pela  métrica  de 

Hamming,  temos  𝑑 𝑢, 𝑐  = 𝑑(𝑐, 𝑢)  e  𝑑 𝑐, 𝑐′   ≤ 𝑑 𝑐, 𝑢  + 𝑑(𝑢, 𝑐′ ),  o  que  implica  que 

𝑑 𝑐, 𝑐′   ≤ 𝜅 + 𝜅 = 2𝜅 ≤ 𝑑 − 1, o que contradiz a hipótese, pois  𝑑 é a distância mínima, ou 

seja, 𝑑 𝑐, 𝑐′   ≥ 𝑑. Portanto se 𝑐,𝑐′ ∈ 𝐶 e 𝑐 ≠ 𝑐′, então 𝐷 𝑐, 𝜅 ⋂𝐷 𝑐′ , 𝜅  = ∅. 

 
 
 
 
  
 
106 

6.2.3  Número de detecções e número de correções de erros 

A  distância  mínima  𝑑  de  um  código  𝐶  tem  grande  relevância  nos  processos  de 

detecção e correção de erros. 

Teorema  6.2:  Considere  um  código  𝐶  com  distância  mínima  𝑑.  𝐶  pode  detectar  até  𝑑 − 1 

erros. 

Demonstração: Sendo 𝑑 a distância mínima de um código 𝐶, sabemos que dada uma palavra 

𝑐 ∈ 𝐶,  qualquer  outra  palavra  𝑐′  do  código  𝐶  está  a  uma  distância  no  mínimo  igual  a  𝑑  da 

palavra  𝑐.  Isso  significa  que  podemos  introduzir  em  uma  palavra  qualquer  de  𝐶  até  𝑑 − 1 

erros sem encontrar outra palavra de 𝐶, tornando possível a detecção do erro. 

Teorema 6.3:  Consideremos um código 𝐶 com distância mínima 𝑑. O código 𝐶 pode corrigir 

até 𝜅 =  

𝑑−1

2

  erros. 

Demonstração:  Suponhamos  que  uma  palavra  𝑐 ∈ 𝐶  sofra  𝑡  erros,  com  𝑡 ≤ 𝜅,  ao  ser 

transmitida,  de  modo  que  𝑟  seja  a  palavra  recebida.  Temos  então  𝑑 𝑟, 𝑐  = 𝑡 ≤ 𝜅  e,  pelo 

teorema 6.1, a distância de 𝑟 a qualquer outra palavra de 𝐶 é maior do que 𝜅, assim, a palavra 

𝑐 é univocamente determinada a partir da palavra 𝑟. 

Exemplo: 

Considerando o código 𝐶 dos comandos do braço mecânico, como vimos que 𝑑 = 3, 

então 𝑑 − 1 = 3 − 1 = 2 e 𝜅 =  

𝑑−1

2

  =  

3−1

2

  = 1, portanto, no código 𝐶 é possível detectar 

até 2 erros e corrigir 1 erro. 

6.2.4  Códigos perfeitos 

Um  código  𝐶 ⊂ 𝐴𝑛 ,  com  distância  mínima  𝑑  e  𝜅 =  

𝑑−1

2

   é  denominado  código 

perfeito se   𝐷 𝑐, 𝑘  = 𝐴𝑛
𝑐∈𝐶

. 

Observemos  que  o  código  𝐶  do  braço  mecânico  não  é  perfeito,  pois  𝐶 ⊂ 𝐹5,  𝐶 =

 𝑢1, 𝑢2, 𝑢3, 𝑢4  =  00000, 01011, 10110, 11101   e  𝜅 = 1,  mas  considerando  a  palavra 
𝑝 = 11010 ∈ 𝐹5,  vemos  que  𝑑 𝑢1, 𝑝  = 𝑑 𝑢4, 𝑝  = 3  e  𝑑 𝑢2, 𝑝  = 𝑑 𝑢3, 𝑝  = 2.  Como 

 
 
 
 
 
 
 
 
107 

𝑘 = 1,  significa  que  𝑝 ∉ 𝐷(𝑢1, 1) ∪ 𝐷(𝑢2, 1) ∪ 𝐷(𝑢3, 1) ∪ 𝐷(𝑢4, 1),  o  que  implica  que 

𝐷 𝑢𝑖, 1  ≠ 𝐹𝑛

𝑢𝑖∈𝐶

, ou seja, 𝐶 ⊂ 𝐹5 não é código perfeito. 

6.2.5  Equivalência de códigos 

Primeiramente falemos sobre isometrias. 

Dados dois espaços métricos (conjuntos munidos de uma métrica) 𝑋 e 𝑌 e dados dois 

elementos  𝑥1, 𝑥2 ∈ 𝑋,  de  modo  que  a  distância  entre  𝑥1  e  𝑥2  no  espaço  𝑋  seja  𝑑𝑋 𝑥1, 𝑥2 . 

Uma  função  𝑓: 𝑋 → 𝑌  que  a  cada  𝑥 ∈ 𝑋  faça  corresponder  a  𝑓(𝑥) ∈ 𝑌  é  denominada  uma 

isometria  se  em  relação  a  distância  no  espaço  métrico  𝑌,  for  válida  a  igualdade 

𝑑𝑌 𝑓 𝑥1 , 𝑓 𝑥2   = 𝑑𝑋 𝑥1, 𝑥2   para  todo  𝑥1, 𝑥2 ∈ 𝑋,  ou  seja,  𝑓  é  uma  transformação  que 

preserva a distância. 

Considerando um conjunto 𝐴, ao qual denominamos alfabeto e um número natural 𝑛, 

o  conjunto  𝐴𝑛   de  todas  as  palavras  de  tamanho  𝑛  é  um  espaço  métrico,  pois  nele  temos 

definida a métrica de Hamming. Sendo assim, uma função 𝑓: 𝐴𝑛 → 𝐴𝑛  é uma isometria de 𝐴𝑛  

se preservar distâncias de Hamming, ou seja, 𝑑 𝑓 𝑥 , 𝑓 𝑦   = 𝑑(𝑥, 𝑦) para todo 𝑥, 𝑦 ∈ 𝐴𝑛 . 

Considerando isometrias para a métrica de Hamming: 

Teorema 6.4: Se 𝑓: 𝐴𝑛 → 𝐴𝑛  é uma isometria, então 𝑓 é uma bijeção. 

Demonstração: Consideremos 𝑓: 𝐴𝑛 → 𝐴𝑛  uma isometria. Suponhamos que dados 𝑥, 𝑦 ∈ 𝐴𝑛 , 

tenhamos 𝑓 𝑥  = 𝑓(𝑦), o que implica que 𝑑 𝑓 𝑥 , 𝑓 𝑦   = 0. Mas, por hipótese, 𝑓: 𝐴𝑛 → 𝐴𝑛  

é  uma  isometria,  então  𝑑 𝑥, 𝑦  = 𝑑 𝑓 𝑥 , 𝑓 𝑦    o  que  implica  que  𝑑 𝑥, 𝑦  = 0  e,  portanto, 

𝑥 = 𝑦,  mostrando  que  𝑓  é  injetiva.  Como  𝐴𝑛   é  um  conjunto  finito  e  toda  bijeção  de  um 

conjunto finito nele próprio é uma sobrejeção, temos com isso que 𝑓 é sobrejetiva e portanto 

bijetiva. 

Teorema 6.5: A função identidade 𝐼𝐴𝑛 : 𝐴𝑛 → 𝐴𝑛  é uma isometria. 
Demonstração:  Temos  que  para  todo  𝑥, 𝑦 ∈ 𝐴𝑛 ,  𝐼𝐴𝑛  𝑥  = 𝑥  e  𝐼𝐴𝑛  𝑦  = 𝑦,  o  que  implica 

𝑑 𝐼𝐴𝑛  𝑥 , 𝐼𝐴𝑛  𝑦   = 𝑑(𝑥, 𝑦), mostrando que 𝐼𝐴𝑛  é uma isometria. 

Teorema 6.6: Se 𝑓 é uma isometria de 𝐴𝑛 , então 𝑓−1 também o é. 

 
 
 
 
 
 
 
108 

Demonstração: Se 𝑓 é uma isometria, então pelo teorema 6.4, 𝑓 é bijetiva, o que garante a 

existência  de  𝑓−1.  Como  por  hipótese  𝑓  é  uma  isometria,  então  𝑑 𝑓−1 𝑥 , 𝑓−1 𝑦   =

𝑑 𝑓 𝑓−1 𝑥  , 𝑓 𝑓−1 𝑦     = 𝑑(𝑥, 𝑦), mostrando com isso, que 𝑓−1 é uma isometria. 

Teorema 6.7: Se 𝑓1 e 𝑓2 são isometrias de 𝐴𝑛 , então 𝑓1 ∘ 𝑓2 é uma isometria de 𝐴𝑛 . 

Demonstração:  Se  𝑓1  e  𝑓2  são  isometrias  de  𝐴𝑛 ,  então  𝑑  𝑓1 𝑓2 𝑥  , 𝑓1 𝑓2 𝑦    =

𝑑 𝑓2 𝑥 , 𝑓2 𝑦   = 𝑑(𝑥, 𝑦), mostrando com isso que 𝑓1 ∘ 𝑓2 é uma isometria de 𝐴𝑛 . 

Dados  dois  códigos  𝐶1  e  𝐶2  contidos  em  𝐴𝑛 ,  dizemos  que  𝐶1  e  𝐶2  são  códigos 

equivalentes quando existe uma isometria 𝑓 de 𝐴𝑛  tal que 𝑓 𝐶1  = 𝐶2. 

Os  parâmetros  fundamentais  de  um  código  𝐶 ⊂ 𝐴𝑛   são  o  seu  comprimento  𝑛,  o  seu 

número de elementos  𝐶  = 𝑀 e a sua distância mínima 𝑑. Representamos os parâmetros de 

um código 𝐶 ⊂ 𝐴𝑛  pela terna  𝑛, 𝑀, 𝑑 . 

Teorema 6.8: Dois códigos equivalentes 𝐶1 e 𝐶2 de 𝐴𝑛  possuem os mesmos parâmetros. 
Demonstração:  Suponhamos  que  os  parâmetros  do  código  𝐶1  são   𝑛, 𝑀, 𝑑 .  Como  𝐶2  é 
código  de  𝐴𝑛 ,  então  todas  as  suas  palavras  tem  comprimento  𝑛.  Como  𝐶1  e  𝐶2  são 
equivalentes, então existe uma isometria 𝑓 de 𝐴𝑛  tal que 𝑓 𝐶1  = 𝐶2 e, pelo teorema 6.4 𝑓 é 
bijetiva,  logo   𝐶2  =  𝐶1  = 𝑀.  Por  fim,  sejam  𝑥, 𝑦 ∈ 𝐶1  tais  que  𝑑 𝑥, 𝑦  = 𝑑,  temos  então, 

𝑑 𝑥, 𝑦  = 𝑑 𝑓 𝑥 , 𝑓 𝑦   = 𝑑, mostrando que a mínima distância em 𝐶2 também é 𝑑. Assim, 

os parâmetros do código 𝐶2 são  𝑛, 𝑀, 𝑑 . 

6.3  CÓDIGOS LINEARES 

Consideremos  um  corpo  finito  𝐾  com  um  número  𝑞  de  elementos,  ao  qual 

denominaremos alfabeto. 

Seja 𝑛 ∈ ℕ, temos que 𝐾𝑛  é um 𝑘-espaço vetorial de dimensão 𝑛. 

Um código 𝐶 ⊂ 𝐾𝑛  é classificado como um código linear quando 𝐶 for um subespaço 

vetorial de 𝐾𝑛 . 

O  exemplo  do  braço  mecânico  utilizado  anteriormente  é  um  código  linear,  pois  o 

conjunto 𝐶 =  00000, 01011, 10110, 11101 , contido em 𝐹5 é um subespaço vetorial de 𝐹5, 

verifiquemos: 

 
 
 
 
 
109 

O  corpo  de  escalares  𝐹 =  0,1   contém  dois  elementos  e,  qualquer  que  seja  o  vetor 

𝑢 ∈ 𝐶,  temos  0. 𝑢 = 00000  e  1. 𝑢 = 𝑢.  Notemos  também  que  00000 +  01011 = 01011, 

00000 + 10110 = 10110, 00000 + 11101 = 11101, 01011 + 10110 = 11101, 01011 +

11101 = 10110  e  10110 + 11101 = 01011.  Desse  modo,  para  todo  𝛼, 𝛽 ∈ 𝐹  e  𝑢, 𝑣 ∈ 𝐶, 

temos 𝛼𝑢 + 𝛽𝑣 ∈ 𝐶, mostrando com isso que 𝐶 é subespaço vetorial de 𝐹5. 

Como um código linear é um subespaço de um K-espaço vetorial de dimensão finita, 

então  todo  código  linear  é,  também,  um  K-espaço  vetorial  de  dimensão  finita.  Sendo  𝑘  o 

número de elementos de uma das bases de 𝐶 (dimensão de 𝐶) e, sendo 𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑘 uma 

dessas    bases  ,  então    qualquer    que    seja    𝑢 ∈ 𝐶,  𝑢  se  escreve  de  maneira  única  como 

𝑢 = 𝛼1 ∙ 𝑢1 + 𝛼2 ∙ 𝑢2 + 𝛼3 ∙ 𝑢3 + ⋯ + 𝛼𝑘 ∙ 𝑢𝑘,  ∀𝛼𝑖 ∈ 𝐾  e,  portanto,  o  número  de  elementos 
do código 𝐶 é 𝑀 =  𝐶  = 𝑞𝑘 ou seja, dim 𝐶 = 𝑘 = log𝑞 𝑞𝑘 = log𝑞 𝑀. 

No  exemplo  do  braço  mecânico,  temos  𝐶 =  00000, 01011, 10110, 11101   e 

𝐹 =  0,1 , o que implica que 𝑀 = 4 e 𝑞 = 2, portanto dim 𝐶 = log2 4 = 2, ou seja, qualquer 

base de 𝐶 possui dois vetores. 

6.3.1  Peso de um código 

Considerando  𝑑  a  métrica  de  Hamming,  dado  um  vetor  𝑢  do  K-espaço  vetorial  𝐾𝑛 , 

definimos o peso de 𝑢 como sendo o número inteiro 𝜔 𝑢  = 𝑑(𝑢, 0) e, o peso de um código 

𝐶 é definido como sendo a distância de Hamming mínima não nula dos vetores de 𝐶 ao vetor 

nulo. Em outras palavras: 

𝜔 𝐶  = 𝑚𝑖𝑛 𝜔 𝑢 ; 𝑢 ∈ 𝐶\ 0  . 

Teorema  6.9:  Considerando  um  código  linear  𝐶 ⊂ 𝐾𝑛 ,  com  distância  mínima  𝑑,  temos 

∀𝑢, 𝑣 ∈ 𝐾𝑛 , 𝑑 𝑢, 𝑣  = 𝜔(𝑢 − 𝑣) e 𝑑 = 𝜔(𝐶). 

Demonstração:  Dados  𝑢, 𝑣 ∈ 𝐾𝑛 ,  pela  definição  de  distância,  temos  𝑑 𝑢, 𝑣  = 𝑑 𝑢 −

𝑣, 0  = 𝜔(𝑢 − 𝑣)  e,  se  𝑢, 𝑣 ∈ 𝐶  e  𝑢 ≠ 𝑣,  e  a  distância  mínima  do  código  𝐶  é  𝑑 = 𝑑 𝑢, 𝑣 , 

então existe 𝑤 ∈ 𝐶\ 0  tal que 𝑤 = 𝑢 − 𝑣 e 𝑑 = 𝑑 𝑢, 𝑣  = 𝜔 𝑢 − 𝑣  = 𝜔 𝑤  = 𝜔(𝐶). 

 
 
 
 
 
 
 
 
110 

6.3.2  Matriz geradora de um código 

Consideramos  um  corpo  finito  𝐾  com  𝑞  elementos  e  um  código  linear  𝐶 ⊂ 𝐾𝑛 .  À 

terna   𝑛, 𝑘, 𝑑   denominamos  parâmetros  do  código  linear  𝐶.  O  parâmetro  𝑛  representa  o 

número  de  coordenadas  de  cada  vetor  (palavra)  do  código  𝐶;  o  parâmetro  𝑘  representa  a 

dimensão  do  Código  (espaço  vetorial)  𝐶  sobre  o  corpo  𝐾  e  o  parâmetro  𝑑 representa  a 

distância mínima do código 𝐶, que é igual ao peso 𝜔(𝐶) do código 𝐶. 

Consideremos  𝐵 =  𝑢1, 𝑢2, 𝑢3, … , 𝑢𝑘   uma  base  ordenada  de  𝐶,  onde  cada  vetor 

𝑢𝑖 = (𝑣𝑖1, 𝑣𝑖2, 𝑣𝑖3, … , 𝑣𝑖𝑛 ),      com      1 ≤ 𝑖 ≤ 𝑘      e      uma      matriz      𝐺 =  

𝑢1
𝑢2
⋮
𝑢𝑘

 ,      ou      seja,   

𝐺 =  

𝑣11
𝑣12
𝑣21 𝑣22
⋮
⋮
𝑣𝑘1 𝑣𝑘2

⋯ 𝑣1𝑛
⋯ 𝑣2𝑛
⋱
⋮
⋯ 𝑣𝑘𝑛

 .  A  matriz  𝐺  é  denominada  matriz  geradora  de  𝐶  associada  à  

base 𝐵 e não é a única matriz geradora de  𝐶, pois,  para cada base diferente de  𝐶 , obtemos 

uma geradora diferente. Notemos que uma matriz geradora de um código 𝐶 pode ser obtida de 

outra matriz geradora através de transformações elementares sobre matrizes, vistas em 2.5. 

Consideremos  agora  uma  transformação  linear  𝑇: 𝐾𝑘 → 𝐾𝑛   de  modo  que  dado  𝑥 ∈

𝐾𝑘,  tenhamos  𝑇 𝑥  = 𝑥 ∙ 𝐺.  Como  𝑥 ∈ 𝐾𝑘,  então  possui  𝑘  coordenadas  𝑥1, 𝑥2, 𝑥3, … , 𝑥𝑘  e, 
portanto,  𝑇 𝑥  = 𝑥1 ∙ 𝑣1 + 𝑥2 ∙ 𝑣2 + 𝑥3 ∙ 𝑣3 + ⋯ + 𝑥𝑘 ∙ 𝑣𝑘 ,  o  que  implica  que  𝑇(𝐾𝑘) = 𝐶, 
assim,  temos  𝐾𝑘  o  código  da  fonte,  𝐶  é  o  código  de  canal  e  𝑇  é  a  codificação,  que  leva  o 

código da fonte ao código de canal. 

Para obter uma matriz geradora de um código de dimensão 𝑘, contido em um espaço 

𝐾𝑛 ,  basta  tomar  uma  matriz  com  𝑘  linhas  linearmente  independentes  e  𝑛  colunas.  Por 

exemplo,  considerando  o  corpo  galoisiano  𝐹 =  0,1   e  uma  matriz  𝐺 =  

1 0 0
1 1 0
0 1 1

1 0
0 1
1 0

 . 

Consideremos as palavras do código da fonte como sendo vetores de  𝐹3. Uma palavra 𝑥 do 

código da fonte é codificada em código de canal através da transformação 𝑇: 𝐹3 → 𝐹5, tal que 

𝑇 𝑥  = 𝑥 ∙ 𝐺. Suponhamos 𝑥 = 110, assim, temos: 

 𝑇 110  =  1 1 0 .  

1 0 0
1 1 0
0 1 1

1 0
0 1
1 0

  = 

=  1.1 + 1.1 + 0.0 1.0 + 1.1 + 0.1 1.0 + 1.0 + 0.1    1.1 + 1.0 + 0.1 1.0 + 1.1 + 0.0  = 

 
 
    
    
    
    
111 

=  0 1 0    1 1  , portanto, a palavra 110 do código da fonte é codificada como 01011 no 

código do canal. 

Notemos  nesse  exemplo  que  𝑞 = 2,  pois  adotamos  o  corpo  finito  (galoisiano)  𝐹 =

 0,1   e  k = dim 𝐶 = 3,  logo,  o  número  de  elementos  de  𝐶  é  𝑀 = 23 = 8.  O  código  𝐶  é, 

portanto, o seguinte conjunto: 

 𝐶 =  00000, 10101, 11010, 11111, 01111, 01010, 00101, 10000 , que facilmente pode ser 

verificado que foi obtido através dos vetores 10010, 11001 e 01110, que constituem uma base 

de 𝐶. 

Caso  deseje-se  decodificar  as  palavras  do  código  de  canal  𝐶  de  modo  a  obter  as 
palavras do código de fonte, basta tomar os vetores  𝑥 = 𝑥1𝑥2𝑥3 de 𝐹3 e resolver a equação 
𝑥. 𝐺 = 𝑦,  onde  𝑦 = 𝑦1𝑦2𝑦3𝑦4𝑦5é  uma  palavra  do  código  de  canal  𝐶.  Porém,  esse 

procedimento consiste em resolver a equação matricial: 

  𝑥1 𝑥2

𝑥3  ∙  

1 0 0
1 1 0
0 1 1

1 0
0 1
1 0

  =  𝑦1 𝑦2 𝑦3    𝑦4 𝑦5 , 

que 

gera 

o 

sistema 

𝑥1 + 𝑥2 = 𝑦1
𝑥2 + 𝑥3 = 𝑦2
𝑥3 = 𝑦3
𝑥1 + 𝑥3 = 𝑦4
𝑥2 = 𝑦5

  que, em geral exige um alto custo computacional e, portanto, é inviável. Mas 

efetuando as operações elementares (vistas em 2.5) sobre as linhas da matriz 𝐺, obtemos uma 

matriz 𝐺′ com a seguinte forma: 

1 0 0
1 1 0
0 1 1

1 0
0 1
1 0

  𝐿2   →   𝐿1 + 𝐿2

1 0 0
0 1 0
0 1 1

1 0
1 1
1 0

  𝐿3    →    𝐿2 + 𝐿3

1 0 0
0 1 0
0 0 1

1 0
1 1
0 1

  = 𝐺′. 

A  matriz  𝐺′  é  equivalente  por  linhas  à  matriz  𝐺  e,  portanto,  suas  linhas  são  linearmente 

independentes  e  em  consequência  disso  formam  outra  base  de  𝐶.  Assim,  podemos  obter  as 

palavras  do  código  de  fonte  resolvendo  a  equação  matricial  𝑥. 𝐺′ = 𝑦,  que  equivale  a 

 𝑥1 𝑥2

𝑥3  ∙  

1 0 0
0 1 0
0 0 1

1 0
1 1
0 1

  =  𝑦1 𝑦2 𝑦3    𝑦4 𝑦5 , 

ou 

ainda 

a 

 𝑥1 𝑥2

𝑥3    𝑥1 + 𝑥2

𝑥2 + 𝑥3  =  𝑦1 𝑦2 𝑦3    𝑦4 𝑦5 ,  ou  seja  as  palavras  do  código 

da  fonte  são  obtidas  considerando  as  três  primeiras  coordenadas  das  palavras  do  código  de 

canal. Assim, as palavras do código de fonte são  000, 101, 110, 111, 011, 010, 001, 100 . 

Dizemos que uma matriz geradora de um código 𝐶 se encontra na forma padrão, se for 
apresentada na forma    𝐼𝑘 𝐴 , com  𝐼𝑘 sendo a matriz identidade de ordem  𝑘 e 𝐴  uma matriz 
cuja  ordem  é  𝑘 × (𝑛 − 𝑘).  No  exemplo  anterior  a  matriz  𝐺  não  estava  na  forma  padrão, 

 
 
    
 
 
 
 
 
 
    
                                
    
                                  
    
    
 
porém ao serem efetuadas operações elementares sobre as linhas de 𝐺, foi obtida uma matriz 

𝐺′, equivalente por linhas à matriz 𝐺 e apresentada na forma padrão. 

112 

Outra maneira de se obter uma matriz 𝐺′ na forma padrão, equivalente a matriz 𝐺, é 
resolver o produto 𝑀−1 ∙ 𝐺, onde 𝑀 é a matriz quadrada de ordem 𝑘 obtida pelo bloco das 𝑘 
∙ 𝑀 ,  
primeiras colunas da matriz 𝐺. Pelo teorema 3.3 do capítulo 3, temos que 𝑀−1 =

1

det (M)⁡

quando det 𝑀  ≠ 0. No exemplo anterior, 𝑀 =  

1
1
0

0
1
1

0
0
1

  e pelo teorema 3.1, det 𝑀  = 1. 

Calculemos a seguir a matriz dos cofatores de 𝑀: 

𝑀′ =  

𝑀11
𝑀21
𝑀31

𝑀12
𝑀22
𝑀32

𝑀13
𝑀23
𝑀33

1
𝑀11 =  −1 1+1 ∙  
1
1
𝑀13 =  −1 1+3 ∙  
0
1
𝑀22 =  −1 2+2 ∙  
0
0
𝑀31 =  −1 3+1 ∙  
1
1
𝑀33 =  −1 3+3 ∙  
1
1
1
0

Logo, 𝑀′ =  

1
0
0

  = 1 ∙ 1 = 1  

  = 1 ∙ 1 = 1  

1
0
𝑀12 =  −1 1+2 ∙  
0
1
1
0
𝑀21 =  −1 2+1 ∙  
1
1
1
0
  = 1 ∙ 1 = −1 = 1   𝑀23 =  −1 2+3 ∙  
0
1
0
1
𝑀32 =  −1 3+2 ∙  
0
1
0
1
1
1
 . Como 𝑀  =  𝑀′ 𝑡, temos 𝑀  =  
1
1
1
1

  = 1 ∙ 1 = 1  

  = 1 ∙ 0 = 0  

0
1
1

0
0
1

0
1
0
1
0
1
0
0

  = −1 ∙ 1 = −1 = 1  

  = −1 ∙ 0 = 0  

  = −1 ∙ 1 = −1 = 1  

  = −1 ∙ 0 = 0  

 . Assim, temos: 

𝑀−1 =

1

det (M)

∙ 𝑀  =

1

1

∙  

1
1
1

0
1
1

0
0
1

  =  

Como 𝐺′ = 𝑀−1 ∙ 𝐺, então 𝐺′ =  

1
1
1

Notemos que 𝐺′ =  

1 0 0
0 1 0
0 0 1

1
1
1
0
1
1

0
1
1
0
0
1
1 0
1 1
0 1

 . 

0
0
1
1 0 0
1 1 0
0 1 1

  ∙  

1 0
1 1
0 1

1 0
0 1
1 0

  =  

1 0 0
0 1 0
0 0 1
1 0
1 1
0 1

  =   𝐼3 𝐴 , com 𝐴 =  

 . Cabe salientar que 

nem  sempre  é  possível  obter  uma  matriz    𝐺  na  forma  padrão,  de  um  código  𝐶,  apenas 

realizando operações elementares sobre linhas. Veja o exemplo: 

Consideremos  um  código  𝐶 ⊂ 𝐹5  cuja  matriz  geradora  é  𝐺 =  

0 1 0
0 0 1
0 0 0

1 0
0 0
0 1

 .  É  fácil 

verificar  que  nenhuma  operação  elementar  sobre  as  linhas  de  𝐺  fará  com  que  a  matriz  se 

apresente  na  forma  padrão,  uma  vez  que  todos  os  elementos  da  primeira  coluna  de  𝐺  são 

nulos.  Porém,  aplicando  as  operações  de  permutação  entre  duas  colunas  da  matriz  𝐺  e 

multiplicação  de  uma  coluna  de  𝐺  por  um  escalar  não  nulo,  podemos  obter  uma  matriz  𝐺′, 

 
 
   
   
    
    
  
   
   
   
   
   
   
   
   
   
 
    
    
    
    
    
    
    
    
    
    
    
    
  
    
    
113 

geradora  na  forma  padrão,  de  um  código  𝐶′ ⊂ 𝐹5  que  é  equivalente  ao  código  𝐶.  Por 

exemplo: 

𝐺 =  

0 1 0
0 0 1
0 0 0

1 0
0 0
0 1

  𝑐1 → 𝑐2

1 0 0
0 0 1
0 0 0

1 0
0 0
0 1

  𝑐2 → 𝑐3

1 0 0
0 1 0
0 0 0

1 0
0 0
0 1

  𝑐3 → 𝑐5

1 0 0
0 1 0
0 0 1

1 0
0 0
0 0

  = 𝐺′ . 

Teorema 6.10: Sendo 𝐶 um código, existe um código 𝐶′, equivalente a 𝐶, cuja matriz 

geradora se apresenta na forma padrão. 

Demonstração:  Seja  𝐶  um  código  cuja  matriz  geradora  é  𝐺 =  

𝑥11
𝑥12
𝑥21
𝑥22
⋮
⋮
𝑥𝑘1 𝑥𝑘2

… 𝑥1𝑛
… 𝑥2𝑛
⋱
⋮
… 𝑥𝑘𝑛

 . 

Utilizando  as  operações  elementares  sobre  as  linhas  de  um  matriz  (vistas  no  capítulo  2)  e 

operações sobre as colunas de 𝐺, temos: 

Como as linhas de 𝐺 constituem uma base de 𝐶, então são linearmente independentes 

Como  𝑥11  é  elemento  de  um  corpo,  então  possui  um  inverso  multiplicativo  𝑥11

e,  portanto  nenhuma  linha  é  nula.  Consideremos,  sem  perda  de  generalidade,  que  𝑥11 ≠ 0. 
−1  tal  que 
… 𝑦1𝑛
… 𝑥2𝑛
⋱
⋮
… 𝑥𝑘𝑛

−1 = 1. Multiplicando a primeira linha de 𝐺 por 𝑥11

−1, obtermos:  

1
𝑥21
⋮
𝑥𝑘1

𝑦12
𝑥22
⋮
𝑥𝑘2

𝑥11 ∙ 𝑥11

 . 

Substituindo cada linha dessa matriz, a partir da segunda, pela soma da respectiva linha com a 

primeira  multiplicada  por  −𝑥21,  ...,  −𝑥𝑘1,  respectivamente,  temos  a  seguinte  matriz: 
1 𝑦12
0 𝑦22
⋮
⋮
0 𝑦𝑘2

 .  A  segunda  linha  dessa  matriz  possui  algum  elemento  não  nulo  e,  por 

… 𝑦1𝑛
… 𝑦2𝑛
⋱
⋮
… 𝑦𝑘𝑛

meio  de  uma  permutação  entre  colunas,  é  possível  fazer  com  que  esse  elemento  não  nulo 

ocupe a posição segunda linha e segunda coluna. Multiplicando a segunda linha pelo inverso 

desse  elemento  não  nulo  e  somando  cada  uma  das  linhas  restantes,  pela  segunda  linha 

multiplicada  respectivamente  por  −𝑦12,  −𝑦13,  ...,  −𝑦𝑘2,  temos  a  matriz   

1 0
0 1
⋮
⋮
0 0

… 𝑧1𝑛
… 𝑧2𝑛
⋮
⋱
… 𝑧𝑘𝑛

 . 

Repetindo  o  processo  descrito  acima,  uma  quantidade  de  até  𝑘  vezes,  obtemos  uma  matriz 
𝐺′ =   𝐼𝑘 𝐴 , na forma padrão. 

 
    
                  
    
                  
    
                  
 
    
    
    
    
    
 
    
    
    
    
114 

Uma matriz geradora que não se apresenta na forma padrão, gera palavras código não 

sistemáticas,  ou  seja,  palavras  código  nas  quais  os  dígitos  das  palavras  do  código  da  fonte 

estão  misturados  com  os  dígitos  da  redundância  acrescentada.  Enquanto  que  uma  matriz 

geradora que se apresente na forma padrão, gera palavras do código sistemáticas, nas quais os 

𝑘  primeiros  dígitos  correspondem  aos  dígitos  do  código  da  fonte,  enquanto  que  os  𝑛 − 𝑘 

últimos dígitos correspondem aos dígitos da redundância acrescida. 

6.3.3  Códigos duais 

Considerando  𝐶  um  código  linear  contido  em  um  espaço  vetorial  𝐾𝑛   definimos  o 

complemento ortogonal de 𝐶 como sendo o conjunto 𝐶⊥ =  𝑣 ∈ 𝐾𝑛 ;  𝑢, 𝑣  = 0, ∀𝑢 ∈ 𝐶 . 

Se  temos  um  código  linear  𝐶 ⊂ 𝐾𝑛 ,  então  𝐶⊥  é  um  subespaço  vetorial  de  𝐾𝑛 ,  pois 

dados  𝑢, 𝑣 ∈ 𝐶⊥,  𝛼, 𝛽 ∈ 𝐾  e  𝑤 ∈ 𝐶,  temos   𝛼 ∙ 𝑢 + 𝛽 ∙ 𝑣, 𝑤  = 𝛼 ∙  𝑢, 𝑤  + 𝛽 ∙  𝑣, 𝑤  = 0. 

Além  disso,  se  𝐺  é  matriz  geradora  do  código  𝐶  e  𝑤 ∈ 𝐶⊥,  então  𝐺 ∙ 𝑤𝑡 = 0,  o  que  é 

facilmente verificável, uma vez que cada linha 𝑣1, 𝑣2, 𝑣3, … , 𝑣𝑘 de 𝐺 é um vetor de uma das 
bases  de  𝐶  e,  portanto,   𝑣1, 𝑤𝑡  =  𝑣2, 𝑤𝑡  =  𝑣3, 𝑤𝑡  = ⋯ =  𝑣𝑘, 𝑤𝑡  = 0.  Como  foi 
mostrado,  𝐶⊥  é  um  subespaço  vetorial  de  𝐾𝑛 ,  portanto,  por  definição,  𝐶⊥  é  também  um 

código linear. 

Definição:  Um  subespaço  vetorial  𝐶⊥ ⊂ 𝐾𝑛   que  é  um  complemento  ortogonal  do 

código 𝐶 e é também um código linear, é denominado código dual de 𝐶. 

Teorema  6.11:  Considerando  𝐶  um  código  linear  contido  em  𝐾𝑛 ,  com  dimensão  𝑘,  cuja 
matriz geradora na forma padrão é 𝐺 =   𝐼𝑘  𝐴 , temos dim 𝐶⊥ = 𝑛 − 𝑘. 
Demonstração:  Vimos  anteriormente  que  𝑤 = 𝑤1, 𝑤2, 𝑤3, … , 𝑤𝑛    pertence  a  𝐶⊥,  quando 
𝐺 ∙ 𝑤𝑡 = 0. Como 𝐺 =   𝐼𝑘 𝐴  se apresenta na forma padrão, então, temos: 
𝑔 𝑘+2 1
𝑔 𝑘+2 2
⋮
𝑔 𝑘+2 𝑘

𝑤1
𝑤2
⋮
𝑤𝑛

𝐺 ∙ 𝑤𝑡 =  

𝑔𝑛1
𝑔𝑛2
⋮
𝑔𝑛𝑘

       ⇔  

  =  

0
0
⋮
0

  ∙  

0
1
⋮
0

0
0
⋮
1

⋯
⋯    
⋱
⋯

𝑔 𝑘+1 1
⋯
1
⋯    
𝑔 𝑘+1 2
0
⋮
⋱
⋮
𝑔 𝑘+1 𝑘
⋯
0
𝑤1 + 𝑔 𝑘+1 1 ∙ 𝑤𝑘+1 + ⋯ + 𝑔𝑛1 ∙ 𝑤𝑛
𝑤2 + 𝑔 𝑘+1 2 ∙ 𝑤𝑘+1 + ⋯ + 𝑔𝑛2 ∙ 𝑤𝑛
⋮
𝑤𝑘 + 𝑔 𝑘+1 𝑘 ∙ 𝑤𝑘+1 + ⋯ + 𝑔𝑛𝑘 ∙ 𝑤𝑛

0
0
⋮
0

⇔       

  =  

       ⇔  

 
 
 
 
 
    
    
    
    
    
    
    
    
    
    
    
    
115 

       ⇔  

⇔       

𝑤1
𝑤2
⋮
𝑤𝑘

  +  

⇔       

  =  

𝑤1
𝑤2
⋮
𝑤𝑘
𝑤1
𝑤2
⋮
𝑤𝑘

  =  

0
0
⋮
0

𝑔 𝑘+1 1 ∙ 𝑤𝑘+1 + ⋯ + 𝑔𝑛1 ∙ 𝑤𝑛
𝑔 𝑘+1 2 ∙ 𝑤𝑘+1 + ⋯ + 𝑔𝑛2 ∙ 𝑤𝑛
⋮
𝑔 𝑘+1 𝑘 ∙ 𝑤𝑘+1 + ⋯ + 𝑔𝑛𝑘 ∙ 𝑤𝑛
−𝑔 𝑘+1 1 ∙ 𝑤𝑘+1 − ⋯ − 𝑔𝑛1 ∙ 𝑤𝑛
−𝑔 𝑘+1 2 ∙ 𝑤𝑘+1 − ⋯ − 𝑔𝑛2 ∙ 𝑤𝑛
⋮
−𝑔 𝑘+1 𝑘 ∙ 𝑤𝑘+1 − ⋯ − 𝑔𝑛𝑘 ∙ 𝑤𝑛
𝑔 𝑘+2 1
𝑔 𝑘+2 2
⋮
𝑔 𝑘+2 𝑘

𝑔 𝑘+1 1
𝑔 𝑘+1 2
⋮
𝑔 𝑘+1 𝑘

⋯
⋯    
⋱
⋯

𝑔𝑛1
𝑔𝑛2
⋮
𝑔𝑛𝑘

       ⇔  

  ∙  

  . 

𝑤𝑘+1
𝑤𝑘+2
⋮
𝑤𝑛

⇔       

  = −  

Os 𝑛 − 𝑘 elementos 𝑤𝑘+1, 𝑤𝑘+2, … , 𝑤𝑛  podem ser escolhidos de forma aleatória. Logo, temos 
que dim 𝐶⊥ = 𝑛 − 𝑘. 

Teorema  6.12:  Considerando  𝐶  um  código  linear  contido  em  𝐾𝑛 ,  com  dimensão  𝑘,  cuja 
matriz geradora na forma padrão é 𝐺 =   𝐼𝑘  𝐴 , temos 𝐻 =   −𝐴𝑡 𝐼𝑛−𝑘   é uma matriz geradora 
de 𝐶⊥. 

Demonstração:  Considerando  𝑖 ∈  1, 2, … , 𝑘 ,  temos  que  cada  coordenada  𝑤𝑖  de  um  vetor 
𝑤 ∈ 𝐶⊥ é escrita como  𝑤𝑖 = −𝑔 𝑘+1 𝑖 ∙ 𝑤𝑘+1 − 𝑔 𝑘+2 𝑖 ∙ 𝑤𝑘+2 − ⋯ − 𝑔𝑛𝑖 ∙ 𝑤𝑛 , o que implica 

que 

𝑤 = (−𝑔 𝑘+1 1 ∙ 𝑤𝑘+1 − 𝑔 𝑘+2 1 ∙ 𝑤𝑘+2 − ⋯ − 𝑔𝑛1 ∙ 𝑤𝑛 , −𝑔 𝑘+1 2 ∙ 𝑤𝑘+1 − 𝑔 𝑘+2 2 ∙

𝑤𝑘+2 − ⋯ − 𝑔𝑛2 ∙ 𝑤𝑛 , … , −𝑔 𝑘+1 𝑘 ∙ 𝑤𝑘+1 − 𝑔 𝑘+2 𝑘 ∙ 𝑤𝑘+2 − ⋯ − 𝑔𝑛𝑘 ∙

𝑤𝑛 , 𝑤𝑘+1, 𝑤𝑘+2, … , 𝑤𝑛 ), o que implica que 

 −𝑔 𝑘+1 1, −𝑔 𝑘+1 2, … , −𝑔 𝑘+1 𝑘, 1, 0, … ,0 ,  −𝑔 𝑘+2 1, −𝑔 𝑘+2 2, … , −𝑔 𝑘+2 𝑘, 0, 1, … ,0 , … 
… ,  −𝑔 𝑘+1 3, −𝑔 𝑘+1 3, … , −𝑔 𝑘+1 3, 0, 0,1, … ,0 ,  −𝑔𝑛1, −𝑔𝑛2, … , −𝑔𝑛𝑘 , 0,0,0, … ,1 

é uma base de 𝐶⊥, portanto 𝐻 =  

−𝑔 𝑘+1 1
−𝑔 𝑘+2 1
⋮
−𝑔𝑛1

−𝑔 𝑘+1 2
−𝑔 𝑘+2 2
⋮
−𝑔𝑛2

⋯
⋯
⋱
⋯

−𝑔 𝑘+1 𝑘
−𝑔 𝑘+2 𝑘
⋮
−𝑔𝑛𝑘

1
0
⋮
0

0
1
⋮
0

⋯
⋯
⋱
⋯

0
0
⋮
1

  é uma 

matriz geradora de 𝐶⊥ na forma 𝐻 =   −𝐴𝑡 𝐼𝑛−𝑘 . 

Teorema 6.13: Considerando 𝐶 um código linear de dimensão 𝑘, contido em 𝐾𝑛 , cuja matriz 

geradora seja 𝐺. Uma matriz 𝐻 de ordem  𝑛 − 𝑘  × 𝑛, com elementos pertencentes a 𝐾, cujas 

linhas sejam linearmente independentes é geradora do código 𝐶⊥ se, e somente se, 𝐺 ∙ 𝐻𝑡 = 0. 

Demonstração: Como as linhas de 𝐻 são linearmente independentes, então formam uma base 

de  um  subespaço  vetorial  de  𝐾𝑛 ,  cuja  dimensão  é  𝑛 − 𝑘,  mas  dim 𝐶⊥ = 𝑛 − 𝑘.  O  produto 

 
    
    
    
    
    
 
 
 
  
    
    
    
    
    
    
    
 
116 

𝐺 ∙ 𝐻𝑡  consiste  no  produto  interno  de  dos  vetores  linhas  de  𝐺  pelos  vetores  colunas  de  𝐻𝑡, 

mas os vetores colunas de 𝐻𝑡 são os vetores linhas de 𝐻 e, caso se tenha 𝐺 ∙ 𝐻𝑡 = 0, então os 

vetores linhas de 𝐺 e os vetores linhas de 𝐻 são, entre si, ortogonais, logo, todos os vetores do 

subespaço gerado por 𝐻 estão em 𝐶⊥ e, portanto, 𝐻 é matriz geradora de 𝐶⊥. 

Teorema 6.14: Seja 𝐶 um código linear contido em um espaço 𝐾𝑛 , temos  𝐶⊥ ⊥ = 𝐶. 

Demonstração:  Consideremos  as  matrizes  𝐺  e  𝐻  geradoras  dos  códigos  𝐶  e  𝐶⊥, 

respectivamente.  Pelo  teorema  6.13,  𝐺 ∙ 𝐻𝑡 = 0.  Mas  se  𝐺 ∙ 𝐻𝑡 = 0,  então   𝐺 ∙ 𝐻𝑡 𝑡 = 0  e, 

pela  propriedade  IV,  apresentada  em  2.3,  temos  que   𝐺 ∙ 𝐻𝑡 𝑡 =  𝐻𝑡 𝑡 ∙ 𝐺𝑡 = 0  e  pela 

propriedade  I  em  2.3,  temos   𝐻𝑡 𝑡 = 𝐻.  Assim,  𝐻 ∙ 𝐺𝑡 = 0,  o  que  implica  que  𝐺  é  matriz 

geradora de  𝐶⊥ ⊥, mas por hipótese, 𝐺 é matriz geradora de 𝐶, portanto,  𝐶⊥ ⊥ = 𝐶. 

Teorema  6.15: Considerando  𝐶  um  código linear  e  𝐻 a matriz geradora do  código  𝐶⊥, um 

vetor 𝑣 pertence ao código 𝐶 se, e somente se, 𝐻 ∙ 𝑣𝑡 = 0. 

Demonstração:  Pelo  teorema  13,  temos  que   𝐶⊥ ⊥ = 𝐶,  portanto,  𝑣 ∈ 𝐶  se,  e  somente  se, 

𝑣 ∈  𝐶⊥ ⊥.  Vimos  anteriormente  que  o  produto  de  uma  matriz  geradora  de  um  código  pela 

matriz transposta cuja coluna é vetor pertencente ao complemento ortogonal  desse código  é 

igual ao vetor nulo, sendo assim, 𝑣 ∈  𝐶⊥ ⊥ se, e somente se, 𝐻 ∙ 𝑣𝑡 = 0. 

O  teorema  6.15  constitui  uma  ferramenta  eficiente  pra  determinar  se  um  dado  vetor 

𝑣 ∈ 𝐾𝑛  pertence a um dado código linear 𝐶 ⊂ 𝐾𝑛 , bastando para isso, verificar se 𝐻 ∙ 𝑣𝑡 = 0. 

À matriz 𝐻, geradora de 𝐶⊥, denominamos matriz teste de paridade do código 𝐶 e ao 

vetor 𝐻 ∙ 𝑣𝑡, com 𝑣 ∈ 𝐾𝑛 , denominamos síndrome do vetor 𝑣. 

Exemplo: 

Considere  𝐶 ⊂ 𝐹6  um  código  linear  sobre  𝐹 =  0,1 ,  cuja  matriz  geradora  é  𝐺 =

1 0 1
1 1 0
0 1 0
 010101 , desejamos verificar se 𝑢 e 𝑣 são vetores de 𝐶. 

0 1 1
0 0 1
1 1 0

 .  Dados  dois  vetores  𝑢, 𝑣 ∈ 𝐹6,  tal  que  𝑢 =  111101   e  𝑣 =

Observemos  que  a  matriz  𝐺  não  se  apresenta  na  forma  padrão,  porém,  por  meio  de 

operações elementares sobre as linhas de 𝐺 é possível obter uma matriz 𝐺′ que se apresente na 

forma padrão: 

 
 
 
 
 
    
117 

1 0 1
1 0 0
0 1 0

0 1 1
1 1 1
1 1 0

  𝐿1 →   𝐿1 + 𝐿2

  𝐿2 →   𝐿2 + 𝐿3

1 0 1
1 1 0
0 1 0
0 0 1
1 0 0
0 1 0

0 1 1
0 0 1
1 1 0
1 0 0
1 1 1
1 1 0

  𝐿1 ↔ 𝐿2

1 0 0
0 0 1
0 1 0

1 1 1
1 0 0
1 1 0

   𝐿1 ↔ 𝐿2

1 0 0
0 1 0
0 0 1

1 1 1
1 1 0
1 0 0

  = 𝐺′ . 

Assim, 𝐺′ =  

1 0 0
0 1 0
0 0 1

1 1 1
1 1 0
1 0 0

  é uma matriz geradora do código  𝐶, que se apresenta na 

forma  padrão.  Notemos  que  𝐺′ =   𝐼3 𝐴 ,  o  que  implica  que  𝐴 =  

1 1 1
1 1 0
1 0 0

   e  −𝐴𝑡 =

1 1 1
1 1 0
0 0 1

 .  Pelo  teorema  6.12,  a  matriz  teste  de  paridade  𝐻,  do  código  𝐶  é  𝐻 =   −𝐴𝑡 𝐼3 , 

portanto, 𝐻 =  

1 1 1
1 1 0
1 0 0

1 0 0
0 1 0
0 0 1

  .  

A síndrome de 𝑢 é 𝐻 ∙ 𝑢𝑡 =  

1 1 1
1 1 0
1 0 0

1 0 0
0 1 0
0 0 1

   ∙

que implica que 𝑢 ∈ 𝐶. 

A síndrome de 𝑣 é 𝐻 ∙ 𝑣𝑡 =  

1 1 1
1 1 0
1 0 0

1 0 0
0 1 0
0 0 1

   ∙

que implica que 𝑣 ∉ 𝐶. 

1
1
1
1
0
1 

0
1
0
1
0
1 

=  

1 + 1 + 1 + 1 + 0 + 0
1 + 1 + 0 + 0 + 0 + 0
1 + 0 + 0 + 0 + 0 + 1

  =  

0
0
0

 , 0 

=  

0 + 1 + 0 + 1 + 0 + 0
0 + 1 + 0 + 0 + 0 + 0
0 + 0 + 0 + 0 + 0 + 1

  =  

0
1
1

 , o 

Teorema  6.16:  Consideremos  𝐻  uma matriz teste de paridade de um  código linear  𝐶 sobre 

um corpo 𝐾. Então o peso 𝜔(𝐶) do código 𝐶 é maior ou igual 𝑝 se, e somente se, quaisquer 

𝑝 − 1 colunas da matriz 𝐻 são linearmente independentes. Valendo a igualdade se, e somente 

se, quaisquer  𝑝 − 1 colunas de 𝐻 forem linearmente independentes e existirem 𝑝 colunas de 

𝐻 linearmente dependentes. 

Demonstração:  Dividiremos  a  demonstração  em  duas  partes,  sendo  que  a  segunda  será 

encarregada de demonstrar a igualdade: 

1ª  parte:   ⇐   Suponhamos  que  cada  (𝑝 − 1)-uplas  de  colunas  da  matriz  𝐻  sejam 

linearmente independentes e que 𝜔 𝑣  ≤ 𝑝 − 1. Seja 𝑣 = 𝑣1𝑣2 … 𝑣𝑛  uma palavra não nula de 

 
 
    
                               
    
                               
 
    
                   
    
                   
    
    
 
    
    
 
 
 
 
 
 
 
 
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
𝐶.  Sabemos  que  𝐻. 𝑣𝑡 = 0,  o  que  implica  que  𝐻. 𝑣𝑡 =  

𝑕11
𝑕21
⋮
𝑕 𝑛−𝑘 1

118 

𝑕12
𝑕22
⋮
𝑕 𝑛−𝑘 2

⋯
⋯
⋱
⋯

𝑕1𝑛
𝑕2𝑛
⋮
𝑕 𝑛−𝑘 𝑛

  ∙

𝑣1
𝑣2
⋮
𝑣𝑛

  =  

0
0
⋮
0

 ,  o  que  gera  o  sistema   

𝑕11 ∙ 𝑣1 + 𝑕12 ∙ 𝑣2 + ⋯ + 𝑕1𝑛 ∙ 𝑣𝑛 = 0
𝑕21 ∙ 𝑣1 + 𝑕22 ∙ 𝑣2 + ⋯ + 𝑕2𝑛 ∙ 𝑣𝑛 = 0
⋮
𝑕 𝑛−𝑘 1 ∙ 𝑣1 + 𝑕 𝑛 −𝑘 2 ∙ 𝑣2 + ⋯ + 𝑕 𝑛 −𝑘 1𝑛 ∙ 𝑣𝑛 = 0

 . 

Somando as equações, e reagrupando, temos: 

(𝑕11 + 𝑕21 + ⋯ + 𝑕 𝑛 −𝑘 1) ∙ 𝑣1 + ⋯ + (𝑕1𝑛 + 𝑕2𝑛 + ⋯ + 𝑕 𝑛 −𝑘 𝑛 ) ∙ 𝑣𝑛 = 0.  Como  𝜔 𝑣  

representa o número de coordenadas não nulas de  𝑣, teríamos então uma combinação linear 

nula  com  no  máximo  𝑝 − 1  colunas  da  matriz  𝐻,  contradizendo  a  hipótese  inicial  de  que 

𝜔 𝑣  ≤ 𝑝 − 1. Assim, 𝜔 𝑣  > 𝑝 − 1, o que implica que 𝜔 𝑣  ≥ 𝑝 e, portanto, 𝜔 𝐶  ≥ 𝑝. 

 ⇒  Em contrapartida, se considerarmos 𝜔 𝐶  ≥ 𝑝 e suponhamos que existam 𝑝 − 1 colunas 

linearmente  dependentes  na  matriz  𝐻,  então  existem,  por  exemplo,  𝑣1𝑣2 … 𝑣𝑝−1 ∈ 𝐾,  nem 

todos nulos, tal que (𝑕11 + 𝑕21 + ⋯ + 𝑕 𝑛 −𝑘 1) ∙ 𝑣1 + (𝑕12 + 𝑕22 + ⋯ + 𝑕 𝑛 −𝑘 2) ∙ 𝑣2 + ⋯  

… + (𝑕1(𝑝−1) + 𝑕2(𝑝−1) + ⋯ + 𝑕 𝑛−𝑘 (𝑝−1)) ∙ 𝑣𝑝−1 = 0, 

o 

que 

implica 

que 

𝑣 = 𝑣1𝑣2 … 0 … 0 … 𝑣𝑝−1 … 0  pertence  ao  código  𝐶,  implicando  com  isso,  que  𝜔 𝑣  ≤ 𝑝 −

1 < 𝑝,  e,  portanto,  𝜔 𝐶  < 𝑝,  contradizendo  a  hipótese.  Logo,  𝐻  possui  𝑝 − 1  colunas 

linearmente independentes. 

2ª  parte:  Para  demonstrar  a  igualdade,  suponhamos  𝜔 𝐶  = 𝑝,  temos  que  todo  conjunto  de 

𝑝 − 1  colunas  de  𝐻  é  linearmente  independente.  Se  existissem  𝑝  colunas  linearmente 

independentes em  𝐻, então, pelo  que foi visto anteriormente, teríamos  𝜔 𝐶  ≥ 𝑝 + 1, logo, 

em  𝐻  existem  𝑝  colunas  linearmente  dependentes.  Por  outro  lado,  se  na  matriz  𝐻  existem 

𝑝 − 1  colunas  linearmente  independentes  e  𝑝  colunas  linearmente  dependentes  então  temos 

𝜔 𝐶  ≥ 𝑝, Mas se 𝜔 𝐶  > 𝑝, por exemplo 𝜔 𝐶  ≥ 𝑝 + 1, pelo visto anteriormente, teríamos 

em  𝐻  que  todo  conjunto  com  𝑝  colunas  seria  linearmente  independente,  contradizendo  a 

hipótese, logo 𝜔 𝐶  = 𝑝. 

Teorema  6.17:  Os  parâmetros   𝑛, 𝑑, 𝑘   de  um  código  linear  𝐶  satisfazem  a  desigualdade 

𝑑 ≤ 𝑛 − 𝑘 + 1. 

Demonstração: Seja 𝐶 um código linear sobre um corpo 𝐾, tal que 𝐶 ⊂ 𝑘𝑘. Uma matriz teste 

de  paridade  𝐻  do  código  linear  𝐶  tem  ordem  (𝑛 − 𝑘) × 𝑛  ou  seja,  possui  𝑛 − 𝑘  linhas 

linearmente  independentes,  o  que  implica  que  𝐻  tem  colunas  em  𝐾𝑛−𝑘.  Pelo  teorema  6.16, 

quaisquer 𝑑 − 1 colunas de 𝐻 são linearmente independentes e como 𝐾𝑛−𝑘 possui no máximo 

 
    
    
    
 
 
119 

𝑛 − 𝑘  vetores  linearmente  independentes,  então  𝑑 − 1 ≤ 𝑛 − 𝑘,  o  que  implica  que  𝑑 ≤ 𝑛 −

𝑘 + 1. 

 À desigualdade acima denominamos cota de Singleton. 

Um  código  𝐶  no  qual  valha  a  igualdade  𝑑 = 𝑛 − 𝑘 + 1  é  denominado  de  MDS,  que 

representa as iniciais das palavras Maximum Distance Separable. 

6.3.4  Decodificação 

O processo de decodificação consiste em ao ser recebida uma palavra através do canal 

de  comunicação,  o  decodificador  de  canal  se  incumbe  da  detecção  e  correção  da  palavra 

recebida se, por acaso, por alguma interferência, tenha sofrido algum erro, para depois enviá-

la  ao  decodificador  de  fonte  e  por  fim  chegar  ao  usuário.  Para  que  o  processo  de 

decodificação seja eficiente, deve possuir um custo computacional baixo tornando viável sua 

utilização. 

A seguir apresentaremos o processo de decodificação. 

Consideremos  o  vetor  𝑐  como  sendo  uma  palavra  transmitida  e  o  vetor  𝑟  a  palavra 

recebida  com  erro.  Definimos  o  vetor  erro  𝑒  como  a  diferença  entre  a  palavra  recebida  e  a 

palavra transmitida: 

𝑒 = 𝑟 − 𝑐 

Quando 𝑒 = 0 significa que a palavra recebida é igual a palavra transmitida e, neste caso, não 

houve erro na transmissão. Caso 𝑒 ≠ 0, entendemos que houve erro na transmissão. Notemos, 

ainda,  que  o  peso  do  vetor  𝑒  define  o  número  de  erros  ocorridos  na  transmissão,  ou  seja, 

𝜔 𝑒  = 𝑝 implica em 𝑝 erros na palavra recebida. 

Vejamos um exemplo: 

Suponha  que  de  um  código  𝐶  sobre  o  corpo  galoisiano  𝐹= 0,1 ,  seja  transmitida  uma  a 

palavra   0101100   e  por  alguma  interferência  no  canal  de  transmissão,  a  palavra  recebida 

seja  (1001010).  Temos  então,  𝑐 = 0101100  e  𝑟 = 1001010,  logo,  𝑒 = 1001010 −

0101100, ou seja, 𝑒 = 1100110. Como 𝜔 𝑒  = 𝜔 1100110  = 4, vemos que ocorreram 4 

erros na transmissão. 

Considerando 𝐻 a matriz teste de paridade de um código 𝐶, considerando 𝑐 um vetor 

(palavra) de 𝐶, sabemos que a síndrome de 𝑐 é nula, ou seja, 𝐻 ∙ 𝑐𝑡 = 0. Portanto, a síndrome 

do vetor erro 𝑒 é dada por: 

𝐻 ∙ 𝑒𝑡 = 𝐻 ∙  𝑟 − 𝑐 𝑡 = 𝐻.  𝑟𝑡 − 𝑐𝑡  = 𝐻 ∙ 𝑟𝑡 − 𝐻 ∙ 𝑐𝑡 = 𝐻 ∙ 𝑟𝑡 − 0 = 𝐻 ∙ 𝑟𝑡 

 
 
 
 
 
Portanto,  a  síndrome  do  erro  é  igual  a  síndrome  da  palavra  recebida.  De  uma  outra  forma, 

120 

considerando 𝑒 =  𝛼1, 𝛼2, … , 𝛼𝑛   , temos: 
𝑕12
𝑕22
⋮
𝑕 𝑛−𝑘 2

𝑕11
𝑕21
⋮
𝑕 𝑛 −𝑘 1

𝐻 ∙ 𝑟𝑡 = 𝐻. 𝑒𝑡 =  

⋯
⋯
⋱
⋯

𝑕1𝑛
𝑕2𝑛
⋮
𝑕 𝑛 −𝑘 𝑛

  ∙  

𝛼1
𝛼2
⋮
𝛼𝑛

  =  

=  

𝑕11 ∙ 𝛼1 + 𝑕12 ∙ 𝛼2 + ⋯ + 𝑕1𝑛 ∙ 𝛼𝑛
𝑕21 ∙ 𝛼1 + 𝑕22 ∙ 𝛼2 + ⋯ + 𝑕2𝑛 ∙ 𝛼𝑛
⋮
𝑕 𝑛−𝑘 1 ∙ 𝛼1 + 𝑕 𝑛 −𝑘 2 ∙ 𝛼2 + ⋯ + 𝑕 𝑛−𝑘 1𝑛 ∙ 𝛼𝑛

  =  

= 𝛼1 ∙  

𝑕11
𝑕21
⋮
𝑕 𝑛−𝑘 1

  + 𝛼2 ∙  

𝑕12
𝑕22
⋮
𝑕 𝑛 −𝑘 2

  + ⋯ + 𝛼𝑛 ∙  

𝑕1𝑛
𝑕2𝑛
⋮
𝑕 𝑛−𝑘 1𝑛

  =  

= 𝛼1 ∙ 𝑕1 + 𝛼2 ∙ 𝑕2 + ⋯ + 𝛼𝑛 ∙ 𝑕𝑛 =   𝛼𝑖 ∙ 𝑕𝑖
matriz 𝐻. 

𝑛
𝑖=1

,  onde  𝑕𝑖  representa  a  𝑖 −ésima  coluna  da 

Teorema  6.18:  Considerando  𝐶  um  código  linear  contido  em  𝐾𝑛 ,  capaz  de  corrigir  até  𝜅 

erros. Se uma palavra recebida 𝑟 pertence ao espaço 𝐾𝑛  e a palavra transmitida 𝑐 pertence ao 

código  𝐶  são  tais  que  𝑑(𝑐, 𝑟) ≤ 𝜅,  então  existe  um  único  vetor  𝑒  tal  que  𝜔(𝑒) ≤ 𝜅,  cuja 

síndrome é igual a síndrome de 𝑟, ou seja, 𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑟𝑡, tal que 𝑐 = 𝑟 − 𝑒. 

Demonstração:  Para  provar  a  existência,  vejamos  que  pelo  enunciado  do  teorema,  temos 

𝑑(𝑐, 𝑟) ≤ 𝜅 e, por tratar-se de uma métrica, sabemos que 𝑑 𝑐, 𝑟  = 𝑑(𝑟, 𝑐) e pelo teorema 6.9, 

𝑑 𝑟, 𝑐  = 𝑑 𝑟 − 𝑐  = 𝜔(𝑟 − 𝑐),  logo,  𝜔(𝑟 − 𝑐) ≤ 𝜅  implica  que  𝜔(𝑒) ≤ 𝜅,  mostrando  a 

existência de 𝑒.  

Para provar a unicidade, suponhamos 𝐻 seja a matriz teste de paridade de um código 𝐶 
em 𝐾𝑛  e que existam 𝑒 =  𝛼1, 𝛼2, … , 𝛼𝑛   e 𝑒′ =  𝛽1, 𝛽2, … , 𝛽𝑛   tais que 𝜔(𝑒) ≤ 𝜅, 𝜔(𝑒′) ≤
𝜅 e 𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑒′𝑡 = 𝐻 ∙ 𝑟, com 𝑟 sendo uma palavra recebida. Temos então: 
 𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑒′𝑡   ⇒    𝛼1 ∙ 𝑕1 + 𝛼2 ∙ 𝑕2 + ⋯ + 𝛼𝑛 ∙ 𝑕𝑛 = 𝛽1 ∙ 𝑕1 + 𝛽2 ∙ 𝑕2 + ⋯ + 𝛽𝑛 ∙ 𝑕𝑛 ,  onde 
𝑕𝑖 representa a 𝑖 −ésima coluna de 𝐻. Daí, temos: 
  𝛼1 − 𝛽1  ∙ 𝑕1 +  𝛼2 − 𝛽2  ∙ 𝑕2 + ⋯ +  𝛼𝑛 − 𝛽𝑛   ∙ 𝑕𝑛 = 0  e,  pelo  teorema  6.16,  quaisquer 
𝑑 − 1 colunas de 𝐻 são linearmente independentes, portanto, temos 𝛼𝑖 = 𝛽𝑖  ∀𝑖, logo, 𝑒 = 𝑒′. 

Para  a  determinação  do  vetor  𝑒,  quando  𝜔(𝑒) ≤ 1,  ou  seja,  quando  ocorreu  no 

máximo um erro entre a palavra transmitida 𝑐 e a palavra recebida 𝑟, considerando um código 

𝐶 com 𝑑 ≥ 3, temos: 

 
    
    
    
 
 
I)  Se 𝐻. 𝑒𝑡 = 0, então 𝜔 𝑒  = 0, o que implica que  𝑟 ∈ 𝐶 e não ocorreu erro, portanto, 

tomamos 𝑐 = 𝑟. 

121 

II) Se  𝐻. 𝑒𝑡 ≠ 0,  então  𝜔 𝑒  = 1  e  temos  um  coordenada  não  nula  no  vetor  𝑒,  por 
exemplo  a  𝑖 −ésima,  ou  seja,  𝑒 =  0, 0, … , 𝛼𝑖, … , 0 .  Como  𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑟𝑡 =
  𝛼𝑖 ∙ 𝑕𝑖
𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑟𝑡 = 𝛼𝑖 ∙ 𝑕𝑖, onde 𝑕𝑖 é a 𝑖 −ésima coluna da matriz 𝐻. 

  e,  no  caso,  𝑒  possui  coordenadas  nulas,  com  exceção  da  𝑖 −ésima,  então 

𝑛
𝑖=1

Exemplo: 

Suponhamos  o  código  do  braço  mecânico  visto  anteriormente  e  que  uma  palavra 

recebida pelo circuito do braço seja 𝑟 =  10101 . 

O código 𝐶 do braço mecânico está contido em 𝐹5 e o código de canal está contido em 

𝐹2,  então,  tomando  quaisquer  dois  vetores  linearmente  independentes  de  𝐶,  por  exemplo 

 10110  e  01011 , constituímos uma base de 𝐶 e por conseqüência uma matriz geradora do 

código 𝐶: 

𝐺 =  

1
0

0
1

1
0

1
1

0
1

 . Note que 𝐺 apresenta-se na forma padrão, ou seja, 𝐺 =   𝐼2 𝐴 , 

com  𝐴 =  

1
0

1
1

0
1

 .  Como  devemos  ter  𝐻 =   −𝐴𝑡 𝐼3 ,  então  𝐻 =  

1
1
0

0
1
1

1
0
0

0
1
0

0
0
1

   é  a 

matriz teste de paridade do código 𝐶. 

Calculando a síndrome de 𝑟, temos: 

𝐻 ∙ 𝑟𝑡 =  

1
1
0

0
1
1

1
0
0

0
1
0

0
0
1

  ∙

1
0
1
0
1 

=  

1 + 0 + 1 + 0 + 0
1 + 0 + 0 + 0 + 0
0 + 0 + 0 + 0 + 1

  =  

0
   .  Vemos  que  𝐻 ∙ 𝑟𝑡 = 1 ∙ 𝑕2. 
1
1

Como  𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑟𝑡,  então  𝐻 ∙ 𝑒𝑡 = 1 ∙ 𝑕2,  o  que  implica  que  𝑒 =  01000   e,  por 

consequência, 𝑐 = 𝑟 − 𝑒 =  10101  −  01000  =  11101 . 

6.3.4.1  Classe lateral 

Consideremos  um  código  corretor  de  erros  𝐶  contido  em  𝐾𝑛 ,  com  matriz  teste  de 

paridade  𝐻,  com  distância  mínima  𝑑  e  capacidade  de  correção  𝜅 =  

𝑑−1

2

 .  Como  vimos, 

𝐻 ∙ 𝑒𝑡 = 𝐻 ∙ 𝑟𝑡 e se 𝜔 𝑒  ≤ 𝜅, então 𝑒 é univocamente determinado por 𝑟. 

 
 
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
 
 
 
 
 
 
 
 
 
 
 
122 

Considerando  um  vetor  𝑣  do  espaço  𝐾𝑛 ,  definimos  o  conjunto  𝑣 + 𝐶,  denominado 

classe lateral de 𝑣 segundo 𝐶, da seguinte forma: 

𝑣 + 𝐶 =  𝑣 + 𝑐, 𝑐 ∈ 𝐶  

Teorema 6.19: Dados dois vetores 𝑢, 𝑣 ∈ 𝐾𝑛 , 𝐻 ∙ 𝑢𝑡 = 𝐻 ∙ 𝑣𝑡 se, e somente se, 𝑢 ∈ 𝑣 + 𝐶. 

Demonstração: 𝐻 ∙ 𝑢𝑡 = 𝐻 ∙ 𝑣𝑡   ⇔  𝐻 ∙ 𝑢𝑡 − 𝐻 ∙ 𝑣𝑡 = 0  ⟺ 𝐻 ∙  𝑢𝑡 − 𝑣𝑡  = 0  ⇔  

⟺ 𝐻 ∙  𝑢 − 𝑣 𝑡 = 0  ⟺ 𝑢 − 𝑣 ∈ 𝐶  ⟺ 𝑢 ∈ 𝑣 + 𝐶. 

O conjunto 𝑣 + 𝐶 goza das seguintes propriedades: 

I)  𝑣 + 𝐶 = 𝑣′ + 𝑐  ⟺ 𝑣 − 𝑣′ ∈ 𝐶 

II)   𝑣 + 𝐶  ∩  𝑣′ + 𝐶  ≠ ∅  ⟹  𝑣 + 𝐶 = 𝑣′ + 𝑐  

III)  

𝑣∈𝐾𝑛

 𝑣 + 𝐶  = 𝐾𝑛

IV)  (𝑣 + 𝐶)  =  𝐶  = 𝑞𝑘 

V)  𝑣 + 𝐶 = 𝐶   ⇔   𝑣 ∈ 𝐶 

Demonstrações: 

I)   ⇒   Se  𝑣 + 𝐶 = 𝑣′ + 𝐶,  então  existem  𝑐1, 𝑐2 ∈ 𝐶  tais  que  𝑣 + 𝑐1 = 𝑣′ + 𝑐2,  o  que 
implica  que  𝑣 − 𝑣′ = 𝑐2 − 𝑐1,  mas  𝐶  é  um  subespaço  vetorial  de  𝐾𝑛 ,  portanto, 
𝑐2 − 𝑐1 ∈ 𝐶, o que implica que 𝑣 − 𝑣′ ∈ 𝐶. 
 ⇐   Suponhamos  que  𝑣 − 𝑣′ ∈ 𝐶,  isso  implica  que  𝑐1, 𝑐2 ∈ 𝐶  tais  que  𝑐1 +
 𝑣 − 𝑣′   = 𝑐2,  ou  seja,  𝑣 + 𝑐1 = 𝑣′ + 𝑐2.  Notemos  que  𝑣 + 𝑐1 ∈ 𝑣 + 𝐶  e  𝑣′ + 𝑐2 ∈
𝑣′ + 𝐶, portanto, 𝑣 + 𝐶 = 𝑣′ + 𝐶. 

II)  Se   𝑣 + 𝐶  ∩  𝑣′ + 𝐶 ,  então  existe  𝑢 ∈  𝑣 + 𝐶  ∩  𝑣′ + 𝐶 ,  o  que  implica  que 

𝑢 ∈  𝑣 + 𝐶  e 𝑢 ∈  𝑣′ + 𝐶 . Então, existem 𝑐1, 𝑐2 ∈ 𝐶 tais que 𝑢 = 𝑣 + 𝑐1 e 𝑢 = 𝑣′ +
𝑐2  e por conseqüência  𝑣 + 𝑐1 =  𝑣′ + 𝑐2. Da igualdade anterior temos  𝑣 − 𝑣′ = 𝑐2 −
𝑐1.  Como  𝑐2 − 𝑐1 ∈ 𝐶,  então  𝑣 − 𝑣′ ∈ 𝐶  e,  pela  propriedade  I,  temos  que  𝑣 + 𝐶 =
𝑣′ + 𝑐. 

III) 𝐾𝑛   é  um  espaço  vetorial  sobre  o  corpo  𝐾,  logo,  0 ∈ 𝐾𝑛 .  Como  𝐶  é  um  subespaço 

vetorial de 𝐾𝑛 , então 0 ∈ 𝐶. Para todo 𝑣 ∈ 𝐾𝑛 , 𝑣 pode ser escrito como 𝑣 + 0, o que 

implica que  𝑣  pertence a  uma classe lateral  𝑣 + 𝐶, portanto,  temos   

𝑣∈𝐾𝑛

 𝑣 + 𝐶  =

𝐾𝑛 . 

IV) Sabemos  que   𝐶  = 𝑞𝑘 = 𝑀,  ou  seja,  𝐶 =  𝑐1, 𝑐2, 𝑐3, … , 𝑐𝑀 .  Seja  𝑣  um  vetor  do 
conjunto  𝑣 + 𝐶.  Por  definição,  𝑣 + 𝐶 =  𝑣 + 𝑐, 𝑐 ∈ 𝐶 ,  assim,  𝑣 + 𝐶 =  𝑣 +

 
 
 
 
 
 
123 

𝑐1, 𝑣 + 𝑐2, 𝑣 + 𝑐3, … , 𝑣 + 𝑐𝑀 ,  ou  seja,  𝑣 + 𝐶 =  𝑐′1, 𝑐′2, 𝑐′3, … , 𝑐′𝑀 ,  ou  seja,   𝑣 +
𝐶  = 𝑀 = 𝑞𝑘 =  𝐶 . 

V)  Notemos  que  𝐶 =  𝑐1, 𝑐2, 𝑐3, … , 𝑐𝑚   =  0 + 𝑐1, 0 + 𝑐2, 0 + 𝑐3, … , 0 + 𝑐𝑚   = 0 + 𝐶. 

Se  𝑣 + 𝐶 = 𝐶,  então  𝑣 + 𝐶 = 0 + 𝐶  e  pela  propriedade  I,  temos  que  𝑣 + 𝐶 = 0 +

𝐶  ⇔ 𝑣 − 0 ∈ 𝐶  ⇔ 𝑣 ∈ 𝐶. 

Pela  propriedade  II,  temos  que  classes  laterais  diferentes  segundo  C  são  disjuntas. 

Sabemos que  𝐾  = 𝑞, o que implica que   𝐾𝑛   = 𝑞𝑛 . Pela propriedade III,   
𝐾𝑛 ,  o  que  implica  que    

  =  𝐾𝑛   = 𝑞𝑛   e  pela  propriedade  IV,  temos  que 

 𝑣 + 𝐶  =

 𝑣 + 𝐶 

𝑣∈𝐾𝑛

𝑣∈𝐾𝑛

 (𝑣 + 𝐶)  =  𝐶  = 𝑞𝑘.  Assim,  o  número  de  classes  laterais  segundo  𝐶  é  dado  por 

 𝑣+𝐶 

𝑣∈𝐾𝑛
 (𝑣+𝐶) 

=

𝑞 𝑛
𝑞 𝑘 = 𝑞𝑛−𝑘. 

Exemplo: 

Considerando o código linear 𝐶 utilizado no exemplo do braço mecânico, vimos que a 

matriz 

geradora 

de 

𝐶 

é 

𝐺 =  

1
0

0
1

1
0

1
1

0
1

 , 

o 

que 

implica 

que 

𝐶 =  00000, 10110, 01011, 11101 .  Dados  𝑣1, 𝑣2, 𝑣3 ∈ 𝐹5, 
𝑣2 =  01000  e 𝑣3 =  01110 .As classes laterais de 𝑣1, 𝑣2, 𝑣3 segundo 𝐶 são: 

tais  que  𝑣1 =  00000 , 

00000 + 𝐶 =  00000, 10110, 01011, 11101  

01000 + 𝐶 =  01000, 11110, 00011, 10101  

01110 + 𝐶 =  01110, 11000, 00101, 10011  

O  teorema  6.19  garante  uma  correspondência  biunívoca  entre  classes  laterais  e 

síndromes, de modo  que todos os vetores de uma classe lateral  possuam síndromes iguais  e 

vetores de classes laterais diferentes possuem síndromes diferentes. 

Seja  𝑥  um  vetor  pertencente  a  uma  classe  lateral  de  𝑣  segundo  𝐶.  Se  𝜔 𝑥  =

𝑚𝑖𝑛 𝜔 𝑣𝑖 ; 𝑣𝑖 ∈ 𝑣 + 𝐶 , então dizemos que 𝑥 é o líder de 𝑣 + 𝐶. 

No exemplo anterior, temos que  00000 é o líder de  00000 + 𝐶, 01000 é o líder de 

01000 + 𝐶  e  11000  e  00101  são  os  líderes  de  01110 + 𝐶.  Notemos  que  o  líder  de  uma 

classe não necessariamente é único. 

Teorema 6.20: Considerando 𝐶 ⊂ 𝐾𝑛  um código com distância mínima 𝑑. Se 𝑣 ∈ 𝐾𝑛  é um 

vetor tal que 𝜔 𝑣  ≤  

𝑑−1

2

  = 𝜅, então 𝑣 é o único elemento líder em sua classe lateral. 

 
 
  
 
 
    
    
    
    
 
124 

Demonstração: Sejam 𝑣1, 𝑣2 ∈ 𝐾𝑛  tais que 𝜔 𝑣1  ≤  

𝑑−1

2

  e 𝜔 𝑣2  ≤  

𝑑−1

2

 . Se 𝑣1 − 𝑣2 ∈ 𝐶, 

então  𝜔 𝑣1 − 𝑣2  ≤ 𝜔 𝑣1  + 𝜔 𝑣2  ≤  

𝑑−1

2

  +  

𝑑−1

2

  ≤ 𝑑 − 1,  portanto,  𝑣1 − 𝑣2 = 0,  o  que 

implica que 𝑣1 = 𝑣2. 

O teorema 6.19 constitui uma ferramenta importante para a determinação dos líderes 

de classes de peso menor ou igual a  

𝑑−1

2

 . Para isso, basta tomar os vetores 𝑣𝑖 ∈ 𝐾𝑛 , para os 

quais se tenha 𝜔 𝑣𝑖  ≤  

𝑑−1

2

 . Cada um dos 𝑣𝑖 é líder de uma e somente uma classe. 

Exemplo: 

Vimos  que  a  matriz  teste  de  paridade  do  código  𝐶 ⊂ 𝐹5,  do  braço  mecânico  é 

𝐻 =  

1
1
0

0
1
1

1
0
0

0
1
0

0
0
1

 .  Sabemos  que  nesse  código,  a  distância  mínima  𝑑 = 3,  pois  vemos 

facilmente que quaisquer duas colunas de 𝐻 são linearmente independentes enquanto que três 

colunas  de  𝐻  são  linearmente  dependentes  (teorema  6.16),  o  que  implica  que  𝜅 =  

𝑑−1

2

  =

3−1

2

  = 1,  ou  seja,  𝐶  tem  capacidade  de  correção  de  1  erro.  Os  vetores  𝑣𝑖 ∈ 𝐹5  tais  que 

𝜔 𝑣𝑖  ≤ 1 são 00000, 00001, 00010, 00100, 01000, 10000. Os líderes 𝑣𝑖 e suas respectivas 

síndromes 𝐻 ∙ 𝑣𝑖

𝑡 são apresentados na tabela a seguir: 

Líder  Síndrome 
00000 
00001 
00010 
00100 
01000 
10000 

000 
001 
010 
100 
011 
110 

Suponhamos  que  duas  palavras  (comandos)  𝑐1  e  𝑐2  sejam  transmitidas  ao  braço 
mecânico e, devido a algum ruído, as palavras (comandos) recebidas sejam 𝑟1 =  11110  e 

𝑟2 =  11010 .  Temos  que  𝐻 ∙ 𝑟1

𝑡 =  

1
1
0

0
1
1

1
0
0

0
1
0

0
0
1

  ∙

1
1
1
1
0 

=  

1 + 0 + 1 + 0 + 0
1 + 1 + 0 + 1 + 0
0 + 1 + 0 + 0 + 0

0
1
1

  =  

  =

 0 1 1 𝑡,  comparando  com  a  tabela,  temos  𝑒 =  01000 .  Como  𝑐 = 𝑟 − 𝑒,  temos 

𝑐1 =  11110  −  01000  =  10110 . O comando transmitido foi para cima. Por outro lado, 

 
 
    
    
    
    
 
 
    
    
    
    
 
 
 
 
 
 
 
 
 
125 

𝐻 ∙ 𝑟2

𝑡 =  

1
1
0

0
1
1

1
0
0

0
1
0

0
0
1

  ∙

1
1
0
1
0 

=  

1 + 0 + 0 + 0 + 0
1 + 1 + 0 + 1 + 0
0 + 1 + 0 + 0 + 0

  =  

1
  =  1 1 1 𝑡.  Vemos  que  a 
1
1

síndrome   111   não  é  encontrada  na  tabela,  portanto  em  𝑟2  ocorreu  mais  de  um  erro  e  o 

código 𝐶 não é capaz de corrigir. 

Outro exemplo: 

Suponha que desejemos transmitir a mensagem  PROFMAT BRASIL através de um 

código linear sobre o corpo galoisiano 𝐹 =  0,1 . 

Abaixo mostraremos uma lista de procedimentos necessários até a obtenção do código 

de canal necessário à transmissão da mensagem: 

1)  Fonte: (espaço), A, B, C, D, E, F, G, H, I, J, L, M, N, O, P, Q, R, S, T, U, V, X e Z, 

com 24 caracteres. 

2)  Código da fonte: notemos que o código da fonte deve possuir no mínimo 24 palavras 

código, portanto, adotaremos 𝑘 = 5, o que implica que o código de fonte está contido 

em 𝐹5. Utilizemos as seguintes informações: 

𝐽 = 01100  𝑃 = 00011  𝑈 = 11001 
𝑒𝑠𝑝𝑎ç𝑜 = 00000  𝐸 = 00001 
𝐿 = 01010  𝑄 = 11100  𝑉 = 01110 
𝐹 = 11000 
𝐺 = 10100  𝑀 = 01001  𝑅 = 10110  𝑋 = 00111 
𝐻 = 10010  𝑁 = 00110 
𝑆 = 10101  𝑍 = 11110 
𝐼 = 10001  𝑂 = 00101  𝑇 = 11010 

𝐴 = 10000 
𝐵 = 01000 
𝐶 = 00100 
𝐷 = 00010 

Observemos  que  ao  transmitir  a  fonte  𝑃,  utilizando  o  código  de  fonte  00011,  se 

ocorrer um  erro, por exemplo, na quinta coordenada, o código recebido  será  00010, 

que equivale a fonte 𝐷 e por consequência o erro não seria detectado. 

3)  Código  de  canal:  por  meio  do  acréscimo  de  redundâncias,  o  código  de  fonte  é 

convertido  em  código  de  canal.  Suponhamos  que  o  código  de  canal  tenha 

comprimento 𝑛 = 9. Temos então que o código 𝐶 é um subespaço vetorial do espaço 

𝐹9. Ou seja, 𝐶 é obtido através de uma transformação linear 𝑇: 𝐹5 → 𝐹9 e, pelo que foi 

visto,  dim 𝐶 = 𝑘 = 5.  Tomemos  quaisquer  cinco  vetores  linearmente  independentes 

de 𝐹9 para obtermos uma base de 𝐶 e, consequentemente, uma matriz 𝐺 geradora do 

código 𝐶: 

 
    
    
    
    
 
 
 
 
 
 
 
 
 
 
 
 
 
  110010000 ,  100100010 ,  001001001 ,  000010110 ,  000101010    é  uma 

base de 𝐶, pois os cinco vetores desse conjunto são linearmente independentes, logo, 

126 

𝐺 =

0
0
1
0
0

1
1
0
0
0

1
0
0
0
0

0
0
1
0
1

0
1
0
0
1

1
0
0
1
0

0
1
0
1
1
praticidade,  determinaremos  𝐺′ =   𝐼5 𝐴   equivalente  por 
apresentada na forma padrão: 

0
0
1
0
0 

0
0
0
1
0

  é  uma  matriz  geradora  do  código  𝐶.  Por 

linhas  à  matriz  𝐺, 

1
1
0
0
0
0
1
0
0
0

1
0
0
0
0
1
0
0
0
0

0
0
1
0
0
0
0
1
0
0

0
1
0
0
1
0
0
0
0
1

1
0
0
1
0
0
0
0
1
0

0
0
1
0
1

0
0
0
1
0

0
1
0
1
1

1
1
1
0
1

1
0
0
1
0

1
0
0
1
1

temos: 

0
0
1
0
0 
0
0
1
0
0 

𝐿1   →   𝐿1 + 𝐿4
𝐿2   →   𝐿2 + 𝐿5

𝐿1   ⟷   𝐿2
𝐿4   ↔   𝐿5

1
1
0
0
0

1
0
0
0
0

1
0
0
0
0
0
1
0
0
0

0
0
1
0
0
0
0
1
0
0

0
0
0
0
1
0
0
0
1
0

0
0
0
1
0
0
0
0
0
1

0
1
1
0
1
1
1
1
1
0

1
0
0
1
0
0
1
0
0
1

1
0
0
1
1
0
1
0
1
1

0
0
1
0
0 
0
0
1
0
0 

𝐿1   →   𝐿1 + 𝐿2

= 𝐺′. 

Assim 

Fonte 
espaço 
A 
B 
C 
D 
E 
F 
G 
H 
I 
J 
L 
M 
N 
O 
P 
Q 
R 
S 
T 
U 
V 
X 
Z 

Código da fonte 
00000 
10000 
01000 
00100 
00010 
00001 
11000 
10100 
10010 
10001 
01100 
01010 
01001 
00110 
00101 
00011 
11100 
10110 
10101 
11010 
11001 
01110 
00111 
11110 

(Código daFonte).G 
00000.G 
10000.G 
01000.G 
00100.G 
00010.G 
00001.G 
11000.G 
10100.G 
10010.G 
10001.G 
01100.G 
01010.G 
01001.G 
00110.G 
00101.G 
00011.G 
11100.G 
10110.G 
10101.G 
11010.G 
11001.G 
01110.G 
00111.G 
11110.G 

Código do canal 
000000000 
100001000 
010001110 
001001001 
000010110 
000101010 
110000110 
101000001 
100100010 
100011110 
011000111 
010100100 
010011000 
010100100 
001011111 
000111100 
111001111 
101101011 
101010111 
110101100 
110010000 
011101101 
001110101 
111100101 

 
 
 
 
 
 
    
    
    
    
    
    
    
    
 
 
 
 
 
 
 
 
 
    
    
    
    
    
    
    
    
 
 
 
 
 
                              
                              
 
 
 
 
 
 
    
    
    
    
    
    
    
    
 
 
 
 
                                 
 
 
 
 
 
 
    
    
    
    
    
    
    
    
 
 
 
 
 
                     
                   
  
 
 
 
 
 
    
    
    
    
    
    
    
    
 
 
 
 
 
127 

Portanto, as palavras do código a serem transmitidas, na ordem em que aparecem, são: 

000111100  101101011  001011111  110000110  010011000  100001000  110101100 

000000000  010001110  101101011  100001000  101010111  100011110  010100100 

Suponhamos que ao utilizar o código acima, a seguinte mensagem seja recebida: 

010011000  000101010  101010110  110101100  101101111  100001000  000010110 
101011111  000000010  000111100  101101011  001011110  110000110  100011110 
101010101  101010111  100011110  101011111  010100100  100001000  010100110 

a  qual  desejamos  decodificar.  Suponhamos  ainda  que  no  máximo  um  erro  tenha  sido 

introduzido em cada palavra transmitida. 

Da  matriz  geradora  𝐺′ =

0
0
1
0
0
apresentada na forma padrão, obtemos uma matriz teste de paridade 𝐻 =   −𝐴𝑡 𝐼𝑛−𝑘 . Como 

  do  código 

0
0
1
0
0 

linear  𝐶, 

0
0
0
0
1

0
1
0
1
1

0
1
0
0
1

0
0
0
1
0

0
1
0
0
0

1
1
1
1
0

1
0
0
0
0

𝑛 = 9  e  𝑘 = 5,  então  𝐻 =   −𝐴𝑡 𝐼4 .  Notemos  que  𝐴 =

1
0
0
0

1
1
1
0

1
0
0
1

1
0
1
0

0
1
1
0

 , o que implica que 𝐻 =  

1
0
0
0

1
1
1
0

1
0
0
1

1
0
1
0

0
1
1
0

1
0
0
0

0
0
1
0
0 

,  então,  −𝐴𝑡 =

1
1
1
1
0
0
1
0
0

0
1
0
0
1
0
0
1
0

0
1
0
1
1
0
0
0
1

  . 

Vemos que quaisquer duas colunas de 𝐻 são linearmente independentes enquanto que 

três colunas de 𝐻 são linearmente dependentes. Pelo teorema 6.16 temos que 𝜔 𝐶  = 3, o que 

implica  que  𝜅 =  

𝑑−1

2

  =  

3−1

2

correção de 1 erro. 

  = 1,  ou  seja,  𝐶  tem  capacidade  de  detecção  de  2  erros  e 

Os  vetores  𝑣𝑖 ∈ 𝐹9,  para  os  quais  se  tenha  𝜔 𝑣𝑖  ≤ 1,  classificados  como  líderes  de 
classe  são:  000000000,  00000001,  000000010,  000000100,  000001000,  000010000, 

00010000,  001000000,  010000000  e  100000000.  Resolvendo  os  produtos  𝐻 ∙ 𝑣𝑖
determinamos as síndromes dos líderes de classe, conforme a seguinte tabela: 

𝑡, 

Líder 
000000000 
000000001 
000000010 
000000100 
000001000 

Síndrome 
0000 
0001 
0010 
0100 
1000 

 
 
 
 
 
 
 
 
 
 
    
    
    
    
    
    
    
    
 
 
 
 
 
 
 
 
 
    
    
    
 
 
 
 
 
    
    
    
    
    
    
    
    
    
    
    
    
128 

000010000 
000100000 
001000000 
010000000 
100000000 

0110 
1010 
1001 
1110 
1000 

𝑡 
Das vinte e uma palavras recebidas 𝑟𝑖, calcularemos suas respectivas síndromes 𝐻 ∙ 𝑟𝑖
e os erros  𝑒𝑖, comparando com  a tabela anterior e determinando as palavras  transmitidas 𝑐𝑖, 

identificando suas respectivas fontes. O procedimento descrito acima é apresentado na tabela 

a seguir: 

Palavra 
recebida  𝒓𝒊  
010011000 
000101010 
101010110 
110101100 
101101111 
100001000 
000010110 
101011111 
000000010 
000111100 
101101011 
001011110 
110000110 
100011110 
101010101 
101010111 
100011110 
101011111 
010100100 
100001000 
010100110 

Síndrome 
𝒕  
 𝑯 ∙ 𝒓𝒊
0000 
0000 
0001 
0000 
0100 
0000 
0000 
1000 
0010 
0000 
0000 
0001 
0000 
0000 
0010 
0000 
0000 
1000 
0000 
0000 
0010 

Erro  𝒆𝒊  
(líder) 

Observação 

000000000  Não houve erro 
000000000  Não houve erro 
000000001  Houve um erro 
000000000  Não houve erro 
000000100  Houve um erro 
000000000  Não houve erro 
000000000  Não houve erro 
100000000  Houve um erro 
000000010  Houve um erro 
000000000  Não houve erro 
000000000  Não houve erro 
000000001  Houve um erro 
000000000  Não houve erro 
000000000  Não houve erro 
000000010  Houve um erro 
000000000  Não houve erro 
000000000  Não houve erro 
100000000  Houve um erro 
000000000  Não houve erro 
000000000  Não houve erro 
000000010  Houve um erro 

Palavra transmitida 
 𝒄𝒊 = 𝒓𝒊 − 𝒆𝒊  
010011000 
000101010 
101010111 
110101100 
101101011 
100001000 
000010110 
001011111 
000000000 
000111100 
101101011 
001011111 
110000110 
100011110 
101010111 
101010111 
100011110 
001011111 
010100100 
100001000 
010100100 

Fonte 

M 
E 
S 
T 
R 
A 
D 
O 
espaço 
P 
R 
O 
F 
I 
S 
S 
I 
O 
N 
A 
L 

Portanto, a mensagem transmitida foi MESTRADO PROFISSIONAL. 

6.3.5  Alguns exemplos de códigos lineares 

6.3.5.1  Código de repetição 

As características fundamentais de um código  𝑅(𝑛) ⊂ 𝐹𝑛  de repetição sobre o corpo 

galoisiano 𝐹 =  0,1  são sua dimensão 𝑘 = 1, o número de palavras do código é 𝑀 = 2𝑘 =

21 = 2 e sua distância mínima 𝑑 = 𝑛. 

 
 
 
 
 
129 

O  código  de  repetição  descrito  acima  detecta  até  𝑛 − 1  erros  e  sua  capacidade  de 

correção é 𝜅 =  

𝑛−1

2

  erros, o que leva-nos a deduzir que se 𝑛 for ímpar, então o código 𝑅 𝑛  

corrige até 

𝑛−1

2

 erros enquanto que se 𝑛 for par, então o código 𝑅(𝑛) corrige até 

𝑛−2

2

 erros. 

O processo de decodificação consiste na contagem do número de “zeros” e do número 

de “uns” na palavra recebida, sendo que se houver um número maior de “uns”, ou seja, esse 

número estiver entre 

𝑛+1

2

 e 𝑛, para 𝑛 ímpar ou estiver entre 

𝑛+2

2

 e 𝑛 para 𝑛 par, então a palavra 

é corrigida para (111 … 1
     )
𝑛  𝑑í𝑔𝑖𝑡 𝑜𝑠

, caso contrário, a palavra é corrigida para (000 … 0
𝑛 𝑑í𝑔𝑖𝑡𝑜𝑠

). 

Exemplo: 

Um circuito digital comandado por controle remoto entra em funcionamento quando o 

comando acionado é “on”, e deixa de funcionar quando o comando acionado é “off”. 

Temos então a fonte como sendo os comandos “on” e “off” e podemos codificar esses 

comandos de modo a se obter o código de fonte 1 e 0 respectivamente. 

Já vimos anteriormente que a transmissão direta do código de fonte não é viável pois 

caso ocorra um erro não é possível sua detecção e sua correção. Em virtude disso, utilizemos, 

por exemplo, o código de repetição 6 representado por 𝑅(6), temos então: 

Fonte 
Off 
On 

Código de fonte  Código de canal 

0 
1 

000000 
111111 

Ao ser transmitido o comando “on”, suponhamos que a transmissão sofra um erro e a palavra 

código  de  𝐹6  recebida  seja  101101.  O  decodificador  de  fonte  detectará  o  erro,  pois  101101 

não pertence a 𝑅(6). Como o 𝑛 = 6 é par e o número de dígitos 1 está entre 

𝑛+2

2

=

6+2

2

= 4 e 

𝑛 = 6, então a palavra código 101101 é corrigida para 111111. 

Notemos  porém  que  um  código  de  repetição  não  é  viável,  seja  pela  demora  na 

transmissão  de  palavras  código  com  grande  número  de  dígitos  (bits),  ou  ainda  pela 

ineficiência  na  correção,  pois  no  exemplo  acima,  se  a  palavra  recebida  fosse  101100,  seria 

impossível ao decodificador de canal decidir se a palavra correta transmitida era 000000 ou 

111111. 

 
     
 
 
 
 
 
 
130 

6.3.5.2  Código de um dígito de paridade (Código de peso par) 

Em alguns casos é mais interessante detectar a ocorrência de um erro do que corrigi-lo 

propriamente, pois podemos ter um custo  elevado na construção de redundâncias que sejam 

capazes  de  corrigir  esses  erros,  sendo  mais  viável  a  retransmissão  da  informação  do  que  a 

correção do erro detectado. 

Uma forma de detectar um erro, com um baixo custo computacional, é o acréscimo de 

um  único  dígito  (bit)  no  código  da  fonte,  obtendo  assim,  um  código  de  canal  com 

comprimento maior que o código da fonte, por um dígito. 

O  dígito  acrescido  ao  código  de  fonte,  de  modo  a  se  obter  o  código  de  canal  é 

denominado dígito de verificação de paridade e é univocamente determinado em cada palavra 

do código da fonte, com finalidade de obter um número par de dígitos “uns”, de modo que se 

houver um (único) erro de transmissão, o mesmo seja detectado, mas não corrigido. 

Em um código 𝐶 ⊂ 𝐾𝑛  de um dígito de paridade com dimensão 𝑘, temos 𝑛 − 𝑘 = 1. 

Como o dígito de paridade é acrescido para que seja obtido um número par de “uns”, então a 

quantidade  mínina  de  “uns”  em  um  vetor  não  nulo  de  𝐶  é  igual  a  2,  o  que  implica  que  a 

distância mínima desse código (ou o seu peso) é 𝑑 = 2. Essa observação permite-nos verificar 

que  a  capacidade  de  detecção  do  código  𝐶  é  𝑑 − 1 = 2 − 1 = 1  erro  e  sua  capacidade  de 

  = 0, ou seja, 𝐶 não é capaz de corrigir erros como mencionado 

correção é 𝜅 =  

𝑑−1

2

  =  

2−1

2

anteriormente. 

Exemplo: 

Voltemos  ao  braço  mecânico  apresentado  anteriormente,  do  qual  temos  a  seguinte 

tabela: 

Fonte 

Código da fonte 

Para a esquerda: 

Para a direita: 

Para cima: 

Para baixo: 

00 

01 

10 

11 

 
 
 
 
 
 
 
131 

Diferente  do  que  foi  feito  anteriormente,  acrescentaremos  como  redundância  apenas 

um dígito, de modo que a quantidade de “uns” seja par, obtendo com isso o código de canal 

apresentado a seguir:   

Fonte 

Código da fonte  Código de canal 

Para a esquerda: 

Para a direita: 

Para cima: 

Para baixo: 

00 

01 

10 

11 

000 

011 

101 

110 

É  evidente  que  se  um  comando  fosse  dado  ao  braço  mecânico,  por  exemplo  “para 

baixo”, cujo código de fonte e de canal são respectivamente 11 e 110 e ocorresse um erro, de 

modo  que  o  decodificador  de  canal  recebesse  a  palavra  100,  um  erro  seria  imediatamente 

detectado,  pois  100  possui  uma  quantidade  ímpar  de  “uns”,  porém,  a  correção  seria 

impossível uma vez que qualquer um dos três dígitos de100 poderia estar errado, acarretando 

três possibilidades para a palavra transmitida: 000, 101 e 110. 

6.3.5.3  Código de Hamming 

Um código 𝐶 sobre o corpo galoisiano 𝐹, cuja matriz teste de paridade é 𝐻𝑚 , de ordem 

𝑚 × 𝑛, com colunas em 𝐹𝑚 \ 0 , em qualquer ordem, é denominado código de Hamming. 

Como a matriz 𝐻𝑚  possui colunas em 𝐹𝑚 \ 0 , então, o seu número de colunas é dado 
por 2𝑚 − 1, o que implica que cada palavra de 𝐶 tem comprimento 𝑛 = 2𝑚 − 1. A dimensão 

do código 𝐶 é dada por 𝑘 = 𝑛 − 𝑚, ou seja, 𝑘 = (2𝑚 − 1) − 𝑚, o que implica que 𝑘 = 2𝑚 −

𝑚 − 1.  A  distância  mínima  (ou  o  peso)  em  um  código  de  Hamming  é  𝜔 𝐶  = 3  (teorema 

6.16). 

As 

matrizes 

𝐻3 =  

1
1
1

1
1
0

1
0
1

0
1
1

1
0
0

0
1
0

0
0
1

e 

1
1
𝐻4 =  
1
1

1
1
1
0

0
1
1
1

1
1
0
1

1
0
1
1

1
1
0
0

0
1
1
0

0
0
1
1

1
0
1
0

1
0
0
1

0
1
0
1

1
0
0
0

0
1
0
0

0
0
1
0

0
0
0
1

  são matrizes teste de paridade dos 

códigos de Hamming correspondentes a 𝑚 = 3 e 𝑚 = 4 respectivamente. 

 
 
 
 
 
 
 
 
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
    
    
   
    
    
    
 
 
132 

Teorema 6.21: Todo código de Hamming é perfeito. 
Demonstração:  Por definição, um  código é perfeito se    𝐷 𝑐, 𝑘  = 𝐹𝑛
código 𝐶 ⊂ 𝐹𝑛  como sendo um código de Hamming, então 𝐶 possui distância mínima 𝑑 = 3, 

. Consideremos  o 

𝑐∈𝐶

o que implica que 𝜅 =  

𝑑−1

2

  =  

3−1

2

  = 1. Seja 𝑐 um vetor de 𝐹𝑛 . Sabemos que o número de 

discos  de  centro  𝑐  e  raio  𝑟  em  𝐹𝑛   é  dado  por   𝐷 𝑐, 𝑟   =    

𝑟
𝑖=0

𝑛
𝑖

  ∙  𝑞 − 1 𝑖

,  portanto, 

 𝐷 𝑐, 1   =  

   𝐷 𝑐, 1 

𝑐∈𝐶

  ∙  2 − 1 0 +  

𝑛
0
  =  1 + 𝑛  ∙ 2𝑘 =  1 + 2𝑚 − 1  ∙ 2𝑛 −𝑚 = 2𝑛 ,  ou  seja,     𝐷 𝑐, 1 

  ∙  2 − 1 1 = 1 ∙ 1 + 𝑛 ∙ 1 = 1 + 𝑛. 

𝑛
1

𝑐∈𝐶

Assim, 

  = 𝐹𝑛 . 

Portanto, 𝐶 é um código perfeito. 

Teorema 6.22: Um código de Hamming é MDS se, e somente se, 𝑚 = 2. 

Demonstração: 

 ⇒   Se  um  código  de  Hamming  é  MDS,  então  𝑑 = 𝑛 − 𝑘 + 1,  mas  em  todo  código  de 

Hamming, 𝑑 = 3, o que implica que 𝑛 − 𝑘 + 1 = 3, portanto, temos: 

  2𝑚 − 1  −  2𝑚 − 𝑚 − 1  + 1 = 3, o que implica que 𝑚 = 2. 

 ⇐    Em um código de Hamming de ordem 𝑚 = 2, temos 𝑛 = 22 − 1 = 3 e 𝑘 = 22 − 2 −

1 = 1. Como em um código de Hamming temos sempre 𝑑 = 3, então 𝑑 = 3 − 1 + 1 = 𝑛 −

𝑘 + 1, portanto para 𝑚 = 2 um código de Hamming é MDS. 

6.3.5.4  Código de Reed-Solomon 

Consideremos  um  corpo  finito  𝐾  e  um  espaço  vetorial  𝐾 𝑋 𝑘−1  de  todos  os 
polinômios  𝑝 𝑥   em  𝐾 𝑋   cujo  grau  seja  menor  ou  igual  a  𝑘 − 1,  juntamente  com  o 

polinômio  nulo.  Uma  base  para  o  espaço  vetorial  𝐾 𝑋 𝑘−1  é  o  conjunto 
𝐵 =  1, 𝑋, 𝑋2, 𝑋3, … , 𝑋𝑘−1 . Portanto, dim 𝐾 𝑋 𝑘−1 = 𝑘. 

Consideremos 𝑛 ∈ ℕ e 𝛼𝑖 ∈ 𝐾, com 𝑖 ∈  1, 2, … , 𝑛 , tal que 𝛼𝑖 ≠ 𝛼𝑗  sempre que 𝑖 ≠ 𝑗. 
Uma  função  𝑇: 𝐾 𝑋 𝑘−1   → 𝐾𝑛 , 𝑘 < 𝑛,  que  a  cada  elemento  𝑝 𝑥  ∈ 𝐾 𝑋 𝑘−1  associa  a 
𝑛 −upla  𝑝 𝛼1 , 𝑝 𝛼2 , 𝑝 𝛼3 , … , 𝑝 𝛼𝑛    ∈ 𝐾𝑛 .  

𝑇 é uma transformação linear, pois dados 𝑝 𝑥 , 𝑞(𝑥) ∈ 𝐾 𝑋 𝑘−1 e 𝛽 ∈ 𝐾, temos: 

𝑇 𝑝 𝑥  + 𝑞 𝑥   =  𝑝 𝛼1  + 𝑞 𝛼1 , 𝑝 𝛼2  + 𝑞 𝛼2 , … , 𝑝 𝛼𝑛   + 𝑞 𝛼𝑛    =   

=  𝑝 𝛼1 , 𝑝 𝛼2 , … , 𝑝 𝛼𝑛   + 𝑞 𝛼𝑛    +  𝑞 𝛼1 , 𝑞 𝛼2 , … , 𝑞 𝛼𝑛    = 𝑇 𝑝 𝑥   + 𝑇(𝑞 𝑥 )  

e 

𝑇 𝛽 ∙ 𝑝 𝑥   =  𝛽 ∙ 𝑝 𝛼1 , 𝛽 ∙ 𝑝 𝛼2 , … , 𝛽 ∙ 𝑝 𝛼𝑛    = 𝛽 ∙  𝑝 𝛼1 , 𝑝 𝛼2 , 𝑝 𝛼3 , … , 𝑝 𝛼𝑛    =  

 
 
 
 
 
133 

= 𝛽 ∙ 𝑇 𝑝 𝑥  .  

Além  disso,  𝑇  é  uma  transformação  linear  injetiva,  pois  𝑇(𝑝 𝑥 ) = 0  implica  que 

 𝑝 𝛼1 , 𝑝 𝛼2 , 𝑝 𝛼3 , … , 𝑝 𝛼𝑛    =  0, 0, 0, … , 0 ,  ou  seja,  𝑝 𝛼1  =  𝑝 𝛼2  =  𝑝 𝛼3  =   … =

 𝑝 𝛼𝑛   = 0,  pois  um  polinômio  de  grau  𝑘 − 1  não  pode  possuir  𝑛  raízes  distintas.  Assim, 
temos 𝐾𝑒𝑟  𝑇  =  𝑝 𝑥  ∈ 𝐾 𝑋 𝑘−1; 𝑝 𝛼1  =  𝑝 𝛼2  =    … =  𝑝 𝛼𝑛   = 0 , o que implica que 
𝐾𝑒𝑟  𝑇  = {𝑜}, logo, 𝑇 é injetiva. 

Pelo  Teorema  5.13,  temos  que  dim 𝐾 𝑋 𝑘−1 = dim ker(T) ⁡+ dim 𝐼𝑚(𝑇).  Como 

𝐾𝑒𝑟  𝑇  = {𝑜},  então  dim ker(T) = 0,  o  que  implica  que  dim 𝐼𝑚(𝑇) = dim 𝐾 𝑋 𝑘−1 = 𝑘, 
ou seja,  𝐼𝑚(𝑇)  é um  subespaço vetorial  de  𝐾𝑛 , com dimensão 𝑘. Podemos  adotar  𝐾 𝑋 𝑘−1 
com sendo o código de fonte, 𝐼𝑚 𝑇  = 𝐶 como sendo o código de canal (um código linear) e  

a transformação 𝑇 como sendo a codificação. 

Ao código descrito acima denominamos código de Reed- Solomon, com comprimento 

𝑛 e dimensão 𝑘, definido por 𝛼1, 𝛼2, 𝛼3, … , 𝛼𝑛 . 

Notemos  que  dado  𝑐 ∈ 𝐶, 

tal  que  𝑐 ≠ 0,  então  ∃𝑝(𝑥) ∈ 𝐾 𝑋 𝑘−1 

tal  que 

𝑐 =  𝑝 𝛼1 , 𝑝 𝛼2 , 𝑝 𝛼3 , … , 𝑝 𝛼𝑛   .         Por    definição    de   peso    de    um    código,     temos   

que  𝜔 𝑐  =   𝑖 ∈  1, 2, 3, … , 𝑛 ; 𝑝 𝛼𝑖  ≠ 0  .    Como    𝑐  possui    𝑛  coordenadas,  então    

  𝑖 ∈  1, 2, 3, … , 𝑛 ; 𝑝 𝛼𝑖  ≠ 0   = 𝑛 −   𝑖 ∈  1, 2, 3, … , 𝑛 ; 𝑝 𝛼𝑖  = 0   ≥ 𝑛 − 𝑔𝑟 𝑝 𝑥  . 

Portanto, 𝜔 𝑐  ≥ 𝑛 − (𝑘 − 1), o que implica que 𝜔 𝑐  ≥ 𝑛 − 𝑘 + 1, portanto, 𝑑 ≥ 𝑛 − 𝑘 +

1.  Pelo  teorema  6.17  vimos  que  parâmetros   𝑛, 𝑑, 𝑘   de  um  código  linear  𝐶  satisfazem  a 

desigualdade 𝑑 ≤ 𝑛 − 𝑘 + 1. Das duas desigualdades acima temos 𝑑 = 𝑛 − 𝑘 + 1. 

Como  𝐵 =  1, 𝑋, 𝑋2, 𝑋3, … , 𝑋𝑘−1   é  uma  base  de  𝐾 𝑋 𝑘−1,  temos  que  𝐵′ =
 𝑇(1), 𝑇(𝑋), 𝑇(𝑋2), 𝑇(𝑋3), … , 𝑇(𝑋𝑘−1)   é  uma  base  de  𝐶,  logo  uma  matriz  geradora  do 

código 𝐶 pode ser representada por: 

𝐺 =

𝑇(1)
𝑇 𝑋 
𝑇(𝑋2)
⋮
𝑇(𝑋𝑘−1) 

=

1
𝛼1
2
𝛼1
⋮
𝑘−1
𝛼1

1
𝛼2
2
𝛼2
⋮
𝑘−1
𝛼2

⋯
⋯
⋯
⋱
⋯

1
𝛼𝑛
2
𝛼𝑛
⋮
𝑘−1 
𝛼𝑛

. 

Exemplo:  Consideremos  um  corpo  finito  𝐾 = ℤ7,  𝑘 = 3,  𝑛 = 5  e  𝛼1 = 1,  𝛼2 = 2, 

𝛼3 = 3,  𝛼4 = 4 

e  𝛼5 = 5.  Pela  definição  de  matriz  geradora, 

temos  que 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
    
 
 
 
 
 
134 

𝐺 =

1
𝛼1
2
𝛼1
⋮
𝑘−1
𝛼1

1
𝛼2
2
𝛼2
⋮
𝑘−1
𝛼2

⋯
⋯
⋯
⋱
⋯

1
𝛼𝑛
2
𝛼𝑛
⋮
𝑘−1 
𝛼𝑛

=  

1
1
12

1
2
22

1
3
32

1
4
42

1
5
52

  =  

1
1
1

1
2
4

1
3
2

1
4
2

1
5
4

   é  uma  matriz 

geradora  do  código  de  Reed-Solomon  de  comprimento  5,  dimensão  3  e  definida  pelos 

elementos 1, 2, 3, 4, 5 do corpo ℤ7, com distância mínima 𝑑 = 𝑛 − 𝑘 + 1 = 5 − 3 + 1 = 3 

Para  determinar  uma  matriz  𝐺′ =   𝐼𝑘 𝐴 ,  na  forma  padrão,  equivalente  à  matriz  𝐺, 
observemos  que,  através  do  polinômio  de  Lagrange,  visto  em  4.5,  podemos  obter  os 

polinômios  𝑝1 𝑥 , 𝑝2 𝑥 , 𝑝3(𝑥) ∈ 𝐾 𝑋 𝑘−1, 
𝑝1 𝛼2  = 𝑝1 𝛼3  = 𝑝2 𝛼1  = 𝑝2 𝛼3  = 𝑝3 𝛼1  = 𝑝3 𝛼2  = 0, da seguinte forma: 

tais  que  𝑝1 𝛼1  = 𝑝2 𝛼2  = 𝑝3 𝛼3  = 1  e 

𝑝1 𝑥  =

𝑝2 𝑥  =

𝑝3 𝑥  =

 𝑥 − 𝛼2  ∙  𝑥 − 𝛼3 
 𝛼1 − 𝛼2  ∙  𝛼1 − 𝛼3 
 𝑥 − 𝛼1  ∙  𝑥 − 𝛼3 
 𝛼2 − 𝛼1  ∙  𝛼2 − 𝛼3 
 𝑥 − 𝛼1  ∙  𝑥 − 𝛼2 
 𝛼3 − 𝛼1  ∙  𝛼3 − 𝛼2 

=

 𝑥 − 2  ∙  𝑥 − 3 
 1 − 2  ∙  1 − 3 

=

𝑥2 − 5𝑥 + 6
2

= 4𝑥2 + 𝑥 + 3 

=

=

 𝑥 − 1  ∙  𝑥 − 3 
 2 − 1  ∙  2 − 3 

 𝑥 − 1  ∙  𝑥 − 2 
 3 − 1  ∙  3 − 2 

=

=

𝑥2 − 4𝑥 + 3
−1

𝑥2 − 3𝑥 + 2
2

= 6𝑥2 + 4𝑥 + 4 

= 4𝑥2 + 2𝑥 + 1 

Notemos  que  𝑝1 𝑥 , 𝑝2 𝑥   e  𝑝3(𝑥)  são  linearmente  independentes,  pois  dados 
𝛽1, 𝛽2, 𝛽3 ∈ 𝐾,  𝛽1 ∙ 𝑝1 𝑥  + 𝛽2 ∙ 𝑝2 𝑥  + 𝛽3 ∙ 𝑝3 𝑥  = 0  implica  que  𝛽1 ∙  4𝑥2 + 𝑥 + 3  +
𝛽2 ∙  6𝑥2 + 4𝑥 + 4  + 𝛽3 ∙  4𝑥2 + 2𝑥 + 1  = 0,  o  que  equivale  a  ter  o  sistema  de  equações 

lineares   

4𝛽1 + 6𝛽2 + 4𝛽3 = 0
𝛽1+4𝛽2 + 2𝛽3 = 0
3𝛽1 + 4𝛽2+𝛽3 = 0

 ,  que  implica  que  𝛽1 = 𝛽2 = 𝛽3 = 0.  Assim,  𝑝1 𝑥 , 𝑝2 𝑥   e 

𝑝3(𝑥)  formam  uma  base  para  𝐾 𝑋 𝑘−1  e,  como  𝑇  é  injetiva,  então  𝑇 𝑝1 𝑥  , 𝑇 𝑝2 𝑥    e 

𝑇 𝑝3(𝑥)   formam  uma  base  do  código  de  Reed-Solomon  de  comprimento  5,  dimensão  3  e 

definida pelos  elementos 1, 2, 3, 4, 5 do corpo  ℤ7, com  distância mínima  𝑑 = 𝑛 − 𝑘 + 1 =

5 − 3 + 1 = 3. 

Logo, 

𝐺′ =  

𝑇 𝑝1 
𝑇 𝑝2 
𝑇 𝑝3 

  =  

𝑝1 𝛼1 
𝑝2 𝛼1 
𝑝3 𝛼1 

𝑝1 𝛼2 
𝑝2 𝛼2 
𝑝3 𝛼2 

𝑝1 𝛼3 
𝑝2 𝛼3 
𝑝3 𝛼3 

𝑝1 𝛼4 
𝑝2 𝛼4 
𝑝3 𝛼4 

𝑝1 𝛼5 
𝑝2 𝛼5 
𝑝3 𝛼5 

 , 

portanto, 𝐺′ =  

1
0
0

0
1
0

0
0
1

1
4
3

3
6
6

  é a matriz geradora na forma padrão. 

 
 
 
 
 
 
    
    
    
 
 
 
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
 
 
 
135 

6.3.5.5  O código do Mariner 9 (Código de Reed-Muller de 1ª ordem) 

A Mariner 9 foi uma sonda espacial lançada ao espaço em 30 de maio de 1971, com 

objetivo  de  explorar  o  planeta  Marte.  Durante  seu  período  de  atividade,  a  sonda  Mariner  9 

enviou à terra mais de 7.000 fotos desse planeta.  

O código utilizado para a detecção e correção de erros dos dados enviados pela sonda 

Mariner 9 à terra, pertence a uma família de códigos 𝑅(1, 𝑚) sobre 𝐹 =  0,1 , denominados 

Códigos de Reed-Muller de Primeira Ordem. 

A matriz 𝐺 geradora desse código é obtida através da matriz teste de paridade de um 

código de Hamming de dimensão 𝑚 − 𝑛, ou seja, a matriz 𝐻𝑚 . 

A  matriz  𝐺  possui  ordem  (𝑚 + 1) × 2𝑚   e,  para  construí-la,  consideremos  a  matriz 

𝐻𝑚 =

𝑕11
𝑕21
⋮
𝑕𝑚1

𝑕12
𝑕22
⋮
𝑕𝑚2

…
…
⋱
…

𝑕1 2𝑚 −1 
𝑕2 2𝑚 −1 
⋮
𝑕𝑚  2𝑚 −1  

. A matriz 𝐺 possui a primeira linha com todos os elementos 

iguais  a  1  e  a  coluna  de  ordem  2𝑚   (última  coluna)  possui  todos  os  elementos  nulos,  com 

exceção do primeiro. O bloco  

𝑔21
𝑔31
⋮
𝑔(𝑚 +1)1

𝑔22
𝑔32
⋮
𝑔(𝑚 +1)2

…
…
⋱
…

𝑔2 2𝑚 −1 
𝑔3 2𝑚 −1 
⋮
𝑔(𝑚 +1) 2𝑚 −1 

  é igual a matriz 𝐻𝑚 , ou 

seja, 𝐺 =

1
𝑔21
𝑔31
⋮
𝑔(𝑚 +1)1

1
𝑔22
𝑔32
⋮
𝑔(𝑚 +1)2

⋯
⋯
⋯
⋱
⋯

1
𝑔2 2𝑚 −1 
𝑔3 2𝑚 −1 
⋮
𝑔(𝑚 +1) 2𝑚 −1 

1
0
0
⋮
0 

=

1
𝑕11
𝑕21
⋮
𝑕𝑚1

1
𝑕12
𝑕22
⋮
𝑕𝑚2

⋯
⋯
⋯
⋱
⋯

1
𝑕1 2𝑚 −1 
𝑕2 2𝑚 −1 
⋮
𝑕𝑚  2𝑚 −1 

1
0
0
⋮
0 

Notemos  que  a  primeira  linha  de  𝐺  é  linearmente  independente  das  demais,  basta 

observar a última coluna dessa matriz. Temos também que todas as outras linhas de 𝐺, a partir 

da segunda, também são linearmente independentes, pois o bloco 𝐻𝑚  garante esse fato. Sendo 

assim,  a  dimensão  do  código  𝑅(1, 𝑚)  é  𝑚 + 1.  O  comprimento  do  código  𝑅(1, 𝑚)  é 

evidentemente  2𝑚 ,  pois  𝐺  possui  2𝑚   colunas.  Determinemos  agora  a  distância  mínima  do 

código 𝑅(1, 𝑚). 

Primeiramente,  observemos  que  uma  matriz  cujas  colunas  sejam  cada  um  dos 

2𝑚  vetores de 𝐹𝑚  possui linhas com 2𝑚 −1 elementos iguais a 1 e 2𝑚 −1 elementos iguais a 0. 

Como  as  colunas  de  uma  matriz  𝐻𝑚   de  um  código  de  Hamming  são  todos  os  vetores  de 
𝐹𝑚 \ 0 , então cada linha de 𝐻𝑚  possui 2𝑚 −1 elementos iguais a 1 e 2𝑚 −1 − 1 dígitos iguais 
a 0. Na matriz 𝐺 geradora do código 𝑅(1, 𝑚), excetuando-se a primeira linha, todas as demais 

 
 
 
 
 
 
   
   
   
 
 
 
   
   
   
 
 
 
 
 
   
   
   
   
 
 
 
 
 
 
 
 
 
   
   
   
   
 
 
 
 
 
136 

são formadas por linhas da matriz 𝐻𝑚 , acrescidas do dígito zero. Sendo assim, qualquer linha 

da  matriz  𝐺,  com  exceção  da  primeira,  tem  a  metade  dos  elementos  iguais  a  1  e  a  outra 

metade igual a zero, ou seja, cada vetor formado pela combinação linear dessas linhas possui 

2𝑚 −1  dígitos  iguais  a  1  e  2𝑚 −1  dígitos  iguais  a  zero,  acarretando  que  o  peso  de  cada  um 

desses vetores é igual a 2𝑚 −1. Resta-nos avaliar as combinações lineares com o vetor primeira 

linha da matriz 𝐺, que possui peso 2𝑚 , pois possui suas 2𝑚  coordenadas iguais a 1. Notemos 

que qualquer que seja 𝑣 ∈ 𝑅(1, 𝑚),  2𝑚 −1 coordenadas de 𝑣 são iguais a 1. Consideremos um 

vetor 𝑢 = 𝑣 + (111 … 11
2𝑛  𝑑í𝑔𝑖𝑡𝑜𝑠

), o que implica que a soma das 2𝑚 −1 coordenadas do vetor 𝑣 com o 

vetor  (111 … 11
2𝑛  𝑑í𝑔𝑖𝑡𝑜𝑠

) resultará em zero, fazendo com que  𝑢 possua 2𝑚 −1 dígitos iguais a zero. 

De maneira análoga, somando as  2𝑚 −1 coordenadas iguais  a zero do vetor  𝑣, com  as  2𝑚 −1 

coordenadas do vetor (111 … 11
2𝑛  𝑑í𝑔𝑖𝑡𝑜𝑠

), obtermos 2𝑚 −1 coordenadas iguais a 1, fazendo com que 𝑢 

possua 2𝑚 −1 coordenadas iguais a 1. 

Portanto, temos que no código 𝑅(1, 𝑚), a distância mínima é 𝑑 = 2𝑚 −1. 

Diante do exposto, os parâmetros  𝑛, 𝑘, 𝑑  do código 𝑅(1, 𝑚) são  2𝑚 , 𝑚 + 1, 2𝑚 −1 . 

A  capacidade  de  detecção  e  de  correção  de  erros  num  código  𝑅 1, 𝑚   são, 

respectivamente, 𝑑 − 1 = 2𝑚 −1 − 1 e 𝜅 =  

𝑑−1

2

  =  

2𝑚 −1−1
2

 . 

O código de detecção e correção de erros, utilizado nas transmissões da sonda espacial 

Mariner 9, corresponde a 𝑅(1,5). Seus parâmetros  𝑛, 𝑘, 𝑑  são  25, 5 + 1, 25−1  =  32,6,16  

e sua capacidade de detecção e correção de erros são, respectivamente,  𝑑 − 1 = 25−1 − 1 =

15 e 𝜅 =  

2𝑚 −1−1
2

  =  

25−1−1
2

  = 7. 

6.4  ALGUMAS NOÇÕES SOBRE CÓDIGOS CÍCLICOS 

Consideremos 𝐾 um corpo finito e um espaço vetorial 𝐾𝑛  no qual um vetor 𝑣 possua 

coordenadas  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1 . 

Dizemos que um código 𝐶 contido no espaço vetorial 𝐾𝑛  é um código cíclico quando 
𝐶 é linear e  ∀𝑣 ∈ 𝐶, 𝑣 =  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛−1 , o vetor  𝑣′ = (𝑣𝑛−1, 𝑣0, 𝑣1, … , 𝑣𝑛 −2)  também 
pertence a 𝐶. 

 
       
       
       
 
 
137 

Em  outras  palavras,  𝐶  é  um  código  cíclico  quando  existe  uma  transformação 

permutação  cíclica  𝑇: 𝐶 → 𝐶  que  a  cada  vetor  𝑣 =  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1   associa  o  vetor 
𝑇 𝑣  =  𝑣𝑛−1, 𝑣0, 𝑣1, … , 𝑣𝑛−2 , conforme a figura a seguir: 

Figura 3: Esquema de uma permutação cíclica 

Notemos  que  de  acordo  com  exposto,  temos  𝑇(𝐶) ⊂ 𝐶  e  que  𝑛  transformações 

aplicadas a um vetor 𝑣 retorna ao vetor  𝑣. 

𝑇 

é 

uma 

transformação 

linear, 

pois 

dados  𝛼 ∈ 𝐾  𝑢, 𝑣 ∈ 𝐶, 

com 

𝑢 =  𝑢0, 𝑢1, 𝑢2, … , 𝑢𝑛−1  e 𝑣 =  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛−1 , temos: 

𝑇 𝑢 + 𝑣  = 𝑇  𝑢0, 𝑢1, 𝑢2, … , 𝑢𝑛−1  +  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1   =  
= 𝑇 𝑢0 + 𝑣0, 𝑢1 + 𝑣1, 𝑢2 + 𝑣2, … , 𝑢𝑛−1 + 𝑣𝑛 −1  =  
=  𝑢𝑛−1 + 𝑣𝑛−1, 𝑢0 + 𝑣0, 𝑢1 + 𝑣1, … , 𝑢𝑛−2 + 𝑣𝑛 −2  =  
=  𝑢𝑛−1, 𝑢0, 𝑢1, … , 𝑢𝑛 −2  +  𝑣𝑛−1, 𝑣0, 𝑣1, … , 𝑣𝑛 −2  =  
= 𝑇 𝑢0, 𝑢1, 𝑢2, … , 𝑢𝑛 −1  + 𝑇 𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1  = 𝑇 𝑢  + 𝑇(𝑣)  e  

𝑇 𝛼 ∙ 𝑢  = 𝑇 𝛼 ∙  𝑢0, 𝑢1, 𝑢2, … , 𝑢𝑛 −1   = 𝑇 𝛼 ∙ 𝑢0, 𝛼 ∙ 𝑢1, 𝛼 ∙ 𝑢2, … , 𝛼 ∙ 𝑢𝑛−1  = 
=  𝛼 ∙ 𝑢𝑛−1, 𝛼 ∙ 𝑢0, 𝛼 ∙ 𝑢1, … , 𝛼 ∙ 𝑢𝑛−2  = 𝛼 ∙  𝑢𝑛−1, 𝑢0, 𝑢1, … , 𝑢𝑛−2  =  
= 𝛼 ∙ 𝑇 𝑢0, 𝑢1, 𝑢2, … , 𝑢𝑛 −1  = 𝛼 ∙ 𝑇(𝑢). 
Ao  vetor   𝑣𝑛−1, 𝑣0, 𝑣1, … , 𝑣𝑛 −2   denominamos  desvio  cíclico  de  𝑣 ∈ 𝐶  e 

representamos por 𝑇 𝑣 . 

𝑇 𝑣   é  uma 

transformação  que 

leva  o  vetor  𝑣 ∈ 𝐶  ao  eu  desvio  cíclico 

 𝑣𝑛−1, 𝑣0, 𝑣1, … , 𝑣𝑛 −2 . Notemos que 𝑇 é uma permutação cíclica, portanto, 𝑇 é bijetiva, logo, 
existe 𝑇−1 tal que 𝑢 ∈ 𝐶 tal que 𝑇−1(𝑢) ∈ 𝐶. 

Exemplos: 
a)  O código 𝐶1 =  000, 110, 101, 011  contido em 𝐹3 é cíclico, pois: 
𝑇 000  = 000 ∈ 𝐶1  
𝑇 110  = 011 ∈ 𝐶1  

 
 
 
138 

𝑇 101  = 110 ∈ 𝐶1  
𝑇 011  = 101 ∈ 𝐶1  
b)  O  código  𝐶2 =  00000, 10110, 01011, 11101   contido  em  𝐹5,  apresentado 
anteriormente no exemplo do braço mecânico, não é cíclico, pois:  

𝑇 00000  = 00000 ∈ 𝐶2  
𝑇 10110  = 01011 ∈ 𝐶2  
𝑇 01011  = 10101 ∉ 𝐶2  
𝑇 11101  = 11110 ∉ 𝐶2 . 

Consideremos  um  corpo  𝐾𝑛   e  o  anel  𝑅𝑛 = 𝐾 𝑥 / 𝑥𝑛 − 1   quociente  de  𝐾 𝑥   pelo 
ideal  gerado  por  𝑥𝑛 − 1.  Temos  que  𝑅𝑛 =  𝑣0 + 𝑣1𝑥 + 𝑣2𝑥2 + ⋯ +   𝑣𝑛 −1𝑥𝑛 −1; 𝑣𝑖 ∈ 𝐾 . 
Notemos que existe uma correspondência biunívoca entre os vetores de 𝐾𝑛  e os elementos de 
𝑅𝑛 , que são polinômios (restos de divisão por 𝑥𝑛 − 1): 

𝑣 =  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1    ↔ 𝑣 𝑥  = 𝑣0 + 𝑣1𝑥 + 𝑣2𝑥2 + ⋯ +   𝑣𝑛 −1𝑥𝑛−1. 
Como 𝐾𝑛  é um espaço vetorial, então 𝑅𝑛  tem natureza de espaço vetorial. 
Notemos   que   se   𝑣′ =  𝑣𝑛−1, 𝑣0, 𝑣1, … , 𝑣𝑛 −2    é   uma   permutação   cíclica   do 
vetor    𝑣,      então      𝑥𝑣(𝑥)      deixa      resto      𝑣′ (𝑥)      quando      dividido      por  𝑥𝑛 − 1,      pois  
𝑥𝑣 𝑥  = 𝑥 ∙  𝑣0 + 𝑣1𝑥 + 𝑣2𝑥2 + ⋯ +   𝑣𝑛 −1𝑥𝑛−1  = 𝑣0𝑥 + 𝑣1𝑥2 + 𝑣2𝑥3 + ⋯ +   𝑣𝑛−1𝑥𝑛  
e 
𝑣𝑛 −1 ∙  𝑥𝑛 − 1  +  𝑣𝑛−1 + 𝑣0𝑥 + 𝑣1𝑥2 + ⋯ +   𝑣𝑛−2𝑥𝑛 −1  = 𝑣0𝑥 + 𝑣1𝑥2 + ⋯ +   𝑣𝑛−1𝑥𝑛 , ou 
seja, 𝑥𝑣 𝑥  = 𝑣𝑛−1 ∙  𝑥𝑛 − 1  + 𝑣′  𝑥 . Assim, qualquer código cíclico 𝐶 contido em 𝑅𝑛  pode 
ser definido como um subespaço de 𝑅𝑛  tal que, se 𝑣(𝑥) ∈ 𝐶, então 𝑥𝑣(𝑥) ∈ 𝐶. 

Do exposto acima decorre que, se o código cíclico 𝐶 está contido em 𝑅𝑛  e 𝑣(𝑥) ∈ 𝐶, 
então  𝑥𝑣(𝑥) ∈ 𝐶,  𝑥2𝑣 𝑥  ∈ 𝐶, 𝑥3𝑣(𝑥) ∈ 𝐶,  etc.  Observemos  ainda  que  multiplicar  por  𝑥 

significa  realizar  um  deslocamento  cíclico  de  uma  posição  e  multiplicar  por  𝑥𝑖  significa 

realizar 𝑖 deslocamentos cíclicos. 

Teorema 6.23: Um código linear 𝐶 ⊂ 𝑅𝑛  é um código cíclico se, e somente se, 𝐶 é um ideal 

de 𝑅𝑛 . 

Demonstração: 
 ⇒   Consideremos  quem  𝐶  é  um  código  linear  cíclico.  Sejam  𝑢 𝑥  = (𝑢0 + 𝑢1𝑥 + 𝑢2𝑥2 +
⋯ +   𝑢𝑛 −1𝑥𝑛−1) ∈ 𝑅𝑛   e  𝑣 𝑥  = (𝑣0 + 𝑣1𝑥 + 𝑣2𝑥2 + ⋯ +   𝑣𝑛−1𝑥𝑛 −1) ∈ 𝐶.  Vejamos  que 
𝑢 𝑥  ∙ 𝑣 𝑥  = 𝑢0 ∙ 𝑣 𝑥  + 𝑢1𝑥 ∙ 𝑣 𝑥  + 𝑢2𝑥2 ∙ 𝑣 𝑥  + ⋯ +   𝑢𝑛 −1𝑥𝑛 −1 ∙ 𝑣 𝑥 .  Como  𝐶  é 
cíclico, então, 𝑥𝑖 ∙ 𝑣 𝑥  ∈ 𝐶, além disso, 𝐶 é linear, o que implica que a multiplicação de um 

 
 
 
139 

vetor 𝑣 𝑥  ∈ 𝐶 por um escalar 𝑢𝑖 ∈ 𝐾 e a soma de vetores em 𝐶 resultam em vetores de 𝐶, 

logo 𝑢 𝑥  ∙ 𝑣 𝑥  ∈ 𝐶, o que mostra que 𝐶 é um ideal de 𝑅𝑛 . 
 ⇐   Se  𝐶  é  um  ideal  de  𝑅𝑛 ,  então,  dado  𝑥 ∈ 𝑅𝑛   e  𝑣(𝑥) ∈ 𝐶,  então  𝑥𝑣(𝑥) ∈ 𝐶.  Mas,  como 

vimos  anteriormente,  𝑥𝑣(𝑥)  representa  um  deslocamento  cíclico  de  uma  posição,  logo,  𝐶  é 

cíclico.  

𝑅𝑛  é um anel de ideais principais, pois 𝑅𝑛  recebe essa propriedade de  𝐾 𝑥  e, como 

vimos em 5.4, todos os ideais de 𝐾 𝑥  são principais. 

Qualquer  que  seja  o  ideal  𝐼  de  𝐾 𝑥 ,  tal  que  𝐼 ⊇  𝑥𝑛 − 1 ,  então  𝐼  é  gerado  por 

polinômios  mônicos  que  dividem  𝑥𝑛 − 1,  ou  seja,  𝐼 =  𝑔(𝑥)   tal  que  𝑔 𝑥 |𝑥𝑛 − 1.  Desta 

forma, um código cíclico 𝐶 é um ideal gerado por 𝑔 𝑥 : 

𝐶 =  𝑔(𝑥) ;  𝑔 𝑥 |𝑥𝑛 − 1, daí, dizemos que 𝑔 𝑥  é um polinômio gerador de 𝐶. 

Como o comprimento de cada palavra código da fonte é  𝑘 e o comprimento de cada 

palavra do código de canal é 𝑛, então, temos 𝑔𝑟 𝑔 𝑥   = 𝑛 − 𝑘. 

6.4.1  Codificação em código cíclico 

6.4.1.1  Codificação polinomial 

Voltemos ao exemplo do braço mecânico, porém, nesse momento, desejamos obter um 

código 𝐶 cíclico sobre o corpo galoisiano 𝐹 =  0,1 . Vimos que o código de fonte necessário 

para a codificação dos quatro comandos é o conjunto 𝐹2 =  00, 01, 10, 11 , cujos elementos 

representaremos  por  𝑚0 =  0,0 ,  𝑚1 =  0,1 ,  𝑚2 =  1,0   e  𝑚3 =  1,1 .  A  representação 
dos códigos do canal na forma polinomial é 𝑚0(𝑥) = 0, 𝑚1(𝑥) = 1, 𝑚2(𝑥) = 𝑥 e 𝑚3 𝑥  =

1 + 𝑥.  Vamos  obter  um  código  𝐶  cíclico  de  comprimento  𝑛 = 6  e  dimensão  𝑘 = 2.  Um 

polinômio  𝑔(𝑥)  gerador  do  código  𝐶  é  tal  que  𝑔𝑟 𝑔 𝑥   = 6 − 2 = 4  e  𝑔 𝑥 |𝑥6 − 1. 

Decompondo  𝑥6 − 1, encontramos os polinômios fatores   𝑥 − 1 ,  𝑥 + 1  e  𝑥4 + 𝑥2 + 1 , 

ou seja, 𝑥6 − 1 =  𝑥 − 1  ∙  𝑥 + 1  ∙  𝑥4 + 𝑥2 + 1 . Como 𝑔𝑟 𝑔 𝑥   = 4, então o polinômio 

gerador  de  𝐶  é  𝑔 𝑥  = 1 + 𝑥2 + 𝑥4.  Seja  𝑐𝑖(𝑥) ∈ 𝐶  uma  palavra  do  código,  na  forma 
polinomial não sistemática, assim, 𝑐𝑖 𝑥  = 𝑚𝑖(𝑥) ∙ 𝑔(𝑥), portanto, temos: 

𝑐0 𝑥  = 𝑚0 𝑥  ∙ 𝑔 𝑥  = 0 ∙  1 + 𝑥2 + 𝑥4  = 0  
𝑐1 𝑥  = 𝑚1 𝑥  ∙ 𝑔 𝑥  = 1 ∙  1 + 𝑥2 + 𝑥4  = 1 + 𝑥2 + 𝑥4  
𝑐2 𝑥  = 𝑚2 𝑥  ∙ 𝑔 𝑥  = 𝑥 ∙  1 + 𝑥2 + 𝑥4  = 𝑥 + 𝑥3 + 𝑥5  

 
 
 
 
140 

𝑐3 𝑥  = 𝑚3 𝑥  ∙ 𝑔 𝑥  =  1 + 𝑥  ∙  1 + 𝑥2 + 𝑥4  = 1 + 𝑥 + 𝑥2 + 𝑥3 + 𝑥4 + 𝑥5, 

assim, temos 𝐶 =  000000, 101010, 010101, 111111 . 

Se quisermos determinar as palavras de um código cíclico 𝐶, na forma sistemática, ou 

seja, onde os 𝑘 últimos dígitos correspondem aos dígitos da palavra do código de fonte e os 

𝑛 − 𝑘 primeiros dígitos representam a redundância acrescida, então, procedemos da seguinte 

forma: 

Dada uma palavra 𝑚 do código da fonte, à qual desejamos acrescentar redundâncias e 

obter uma palavra  𝑐 do código de  canal,  escrevemos  𝑚 na forma polinomial  𝑚 𝑥  = 𝑚0 +
𝑚1𝑥 + 𝑚2𝑥2 + ⋯ + 𝑚𝑘−1𝑥𝑘−1  e  multiplicamos  por  𝑥𝑛 −𝑘,  obtendo  um  polinômio  𝑝 𝑥  =
𝑚(𝑥) ⋅ 𝑥𝑛 −𝑘  de  grau  𝑛 − 1.  Em  seguida,  dividimos  o  polinômio  𝑝 𝑥   pelo  polinômio  𝑔(𝑥) 

gerador  do  código  do  código  cíclico,  obtendo  um  polinômio  resto  𝜌(𝑥),  ou  seja,  𝑚 𝑥  ⋅

𝑝(𝑥) = 𝑞 𝑥  ∙ 𝑔 𝑥  + 𝜌(𝑥).  Note  que  𝑞 𝑥  ∙ 𝑔 𝑥  = 𝑝 𝑥  − 𝜌(𝑥),  ou  seja,  𝑝 𝑥  − 𝜌 𝑥  =

𝑐(𝑥) ∈ 𝐶.  Logo,  determinamos  a  palavra  código  do  canal,  na  forma  polinomial,  fazendo 

𝑐 𝑥  = −𝜌 𝑥  + 𝑚(𝑥) ⋅ 𝑥𝑛 −𝑘.  A  palavra  𝑐  do  código  cíclico  é  obtida  dos  coeficientes  do 
polinômio 𝑐 𝑥  = 𝑐0 + 𝑐1𝑥 + 𝑐2𝑥2 + ⋯ + 𝑐𝑛−1𝑥𝑛 −1.  

Observemos  que,  se  o  código  𝐶  é  sobre  um  corpo  𝐾 = 𝐹 =  0,1 ,  temos    −𝜌 𝑥  =

𝜌(𝑥), o que implica que 𝑐 𝑥  = −𝜌 𝑥  + 𝑚 𝑥  ⋅ 𝑥𝑛−𝑘 = 𝜌 𝑥  + 𝑚(𝑥) ⋅ 𝑥𝑛 −𝑘. 

Exemplo: 

Vimos acima que um código cíclico  𝐶 de comprimento 𝑛 = 6, para os comandos do 

braço  mecânico,  possui  dimensão  𝑘 = 2  e  é  gerado  pelo  polinômio  𝑔 𝑥  = 1 + 𝑥2 + 𝑥4. 

Apresentaremos na tabela a seguir as etapas da codificação polinomial: 

𝒎  𝒎(𝒙)  𝒙𝒏−𝒌 ∙ 𝒎(𝒙) 
00 
01 
10 
11 

0 
𝑥5 
𝑥4 
𝑥4 + 𝑥5 

0 
𝑥 
1 
1 + 𝑥 

𝝆(𝒙) 
0 
𝑥 + 𝑥3 
1 + 𝑥2 

𝒄(𝒙) 
0 
𝑥 + 𝑥3 + 𝑥5 
1 + 𝑥2 + 𝑥4 

1 + 𝑥 + 𝑥2 + 𝑥3  1 + 𝑥 + 𝑥2 + 𝑥3 + 𝑥4 + 𝑥5 

c 
000000 
010101 
101010 
111111 

6.4.1.2  Codificação matricial 

Teorema 6.24: Seja 𝐶 um código cíclico gerado por um polinômio 𝑔 𝑥  tal que 𝑔𝑟 𝑔 𝑥   =

𝑛 − 𝑘  então  os  polinômios  código  𝑔 𝑥 , 𝑥 ∙ 𝑔 𝑥 , 𝑥2 ∙ 𝑔 𝑥  , … , 𝑥𝑘−1 ∙ 𝑔 𝑥    formam  uma 

base para 𝐶. 

 
 
 
 
141 

Demonstração:  Para  demonstrar  esse  fato,  devemos  provar  que  os  polinômios  𝑔 𝑥 , 𝑥 ∙

𝑔 𝑥 , 𝑥2 ∙ 𝑔 𝑥  , … , 𝑥𝑘−1 ∙ 𝑔 𝑥  são linearmente independentes e que geram o Código 𝐶 (que 

é um espaço vetorial sobre 𝐾). 

Dados  𝛼0, 𝛼1, … , 𝛼𝑘−1  pertencentes  a  𝐾  tais  que,  se  𝛼0 ∙ 𝑔 𝑥  +   𝛼1 ∙ 𝑥 ∙ 𝑔 𝑥  + ⋯ +
 +𝛼𝑘−1 ∙ 𝑥𝑘−1 ∙ 𝑔 𝑥  = 0,  então,  temos    (𝛼0 +   𝛼1𝑥 +   𝛼2𝑥2 + ⋯ +   𝛼𝑘−1𝑥𝑘−1) ∙ 𝑔 𝑥  = 0 
como  𝑔𝑟 (𝛼0 +   𝛼1𝑥 +   𝛼2𝑥2 + ⋯ +   𝛼𝑘−1𝑥𝑘−1  ≤ 𝑘 − 1  e  𝑔𝑟 𝑔 𝑥   = 𝑛 − 𝑘,  então 

𝑔𝑟 (𝛼0 +   𝛼1𝑥 +   𝛼2𝑥2 + ⋯ +   𝛼𝑘−1𝑥𝑘−1) ∙ 𝑔 𝑥   ≤ 𝑛 − 𝑘 + 𝑘 − 1 = 𝑛 − 1 < 𝑛,  o  que 

implica  que  𝛼0 ∙ 𝑔 𝑥  +   𝛼1 ∙ 𝑥 ∙ 𝑔 𝑥  +   𝛼2 ∙ 𝑥2 ∙ 𝑔 𝑥  + ⋯ +   𝛼𝑘−1 ∙ 𝑥𝑘−1 ∙ 𝑔 𝑥  = 0  só  se 
portanto 
verifica 

𝛼0 = 𝛼1 = 𝛼2 = ⋯ , = 𝛼𝑘−1 = 0, 

quando 

𝑔 𝑥 , 𝑥 ∙ 𝑔 𝑥 , 𝑥2 ∙ 𝑔 𝑥  , … , 𝑥𝑘−1 ∙ 𝑔 𝑥   são  polinômios  linearmente  independentes.  Além 

disso,  pelo  teorema  6.17,  temos  que  ∀𝑣(𝑥) ∈ 𝐶,  temos  que  𝑣 𝑥  = 𝑢 𝑥  ∙ 𝑔 𝑥 ,  onde 

𝑢 𝑥  ∈ 𝑅𝑛 , 𝑔𝑟 𝑢 𝑥   ≤ 𝑘 − 1 e 𝑔 𝑥  é o gerador de 𝐶. Assim: 
𝑣 𝑥  = 𝑢 𝑥  ∙ 𝑔 𝑥  =  𝑢0 + 𝑢1𝑥 + 𝑢2𝑥2 + ⋯ + 𝑢𝑘−1𝑥𝑘−1  ∙ 𝑔 𝑥  =  
= 𝑢0 ∙ 𝑔 𝑥  + 𝑢1𝑥 ∙ 𝑔 𝑥  + 𝑢2𝑥2 ∙ 𝑔 𝑥  + ⋯ + 𝑢𝑘−1𝑥𝑘−1 ∙ 𝑔 𝑥  =  

= 𝑢0 ∙  𝑔 𝑥   + 𝑢1 ∙  𝑥 ∙ 𝑔 𝑥   + 𝑢2 ∙  𝑥2 ∙ 𝑔 𝑥   + ⋯ + 𝑢𝑘−1 ∙  𝑥𝑘−1 ∙ 𝑔 𝑥  , 

ou 

seja, 

qualquer que seja 𝑣(𝑥) ∈ 𝐶, temos que  𝑣(𝑥) é escrito como combinação linear de 𝑔 𝑥 , 𝑥 ∙

𝑔 𝑥 , 𝑥2 ∙ 𝑔 𝑥  , … , 𝑥𝑘−1 ∙ 𝑔 𝑥 .  Portanto,  𝑔 𝑥 , 𝑥 ∙ 𝑔 𝑥 , 𝑥2 ∙ 𝑔 𝑥  , … , 𝑥𝑘−1 ∙ 𝑔 𝑥   é  uma 

base de 𝐶. 

O teorema 6.24 é de extrema importância para a representação matricial de um código 

cíclico, pois, se um código 𝐶 tem comprimento 𝑛, dimensão 𝑘, é gerado pelo polinômio 𝑔(𝑥), 

com 𝑔𝑟 𝑔 𝑥   = 𝑛 − 𝑘, então, como 𝑔 𝑥 , 𝑥 ∙ 𝑔 𝑥 , 𝑥2 ∙ 𝑔 𝑥  , … , 𝑥𝑘−1 ∙ 𝑔 𝑥  é uma base de 

𝐶, a matriz 𝐺 de ordem 𝑘 × 𝑛, geradora desse código é representada como: 

𝐺 =

𝑔 𝑥 
𝑥𝑔(𝑥)
𝑥2𝑔(𝑥)
⋮
𝑥𝑘−1𝑔(𝑥) 

=

𝑔0
0
0
⋮
0

𝑔1
𝑔0
0
⋮
0

𝑔2
𝑔1
𝑔0
⋮
0

⋯
⋯
⋯
⋱
0

𝑔𝑛−𝑘
𝑔𝑛−𝑘−1
𝑔𝑛−𝑘−2
⋮
0

0
𝑔𝑛−𝑘
𝑔𝑛−𝑘−1
⋮
𝑔0

⋯
0
𝑔𝑛−𝑘
⋮
𝑔1

0
⋯
0
⋱
⋯

0
0
⋯
⋮
𝑔𝑛−𝑘 

, 

coeficientes do polinômio gerador. 

onde 

𝑔𝑖 

são 

Exemplo: 

Seja    𝐶    um    código    cíclico    de    comprimento    𝑛 = 7    e    dimensão    𝑘 = 4,    sobre         

o    corpo    galoisiano    𝐹 =  0,1 .    Um    polinômio    𝑔(𝑥),    gerador  de  𝐶      possui  grau 

𝑔𝑟(𝑔 𝑥  = 𝑛 − 𝑘 = 7 − 4 = 3  e  divide  o  polinômio  𝑥7 − 1.  Decompondo  𝑥7 − 1, 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
   
   
   
   
   
   
   
 
 
 
 
 
 
 
142 

encontramos os fatores  𝑥 − 1 ,  𝑥3 + 𝑥2 + 1  e  𝑥3 + 𝑥 + 1 , ou seja,  𝑥7 − 1  =  𝑥 − 1  ∙

 1 + 𝑥2 + 𝑥3  ∙  1 + 𝑥 + 𝑥3 . 

Isso  pode  ser  facilmente  verificado  efetuando  o  produto   𝑥 − 1  ∙  1 + 𝑥2 + 𝑥3  ∙

 1 + 𝑥 + 𝑥3  =  −1 + 𝑥 − 𝑥2 + 𝑥4  ∙  1 + 𝑥 + 𝑥3  =  −1 − 𝑥 − 𝑥3 + 𝑥 + 𝑥2 + 𝑥4 − 𝑥2 −

𝑥3 − 𝑥5 + 𝑥4 + 𝑥5 + 𝑥7  =  −1 − 2𝑥3 + 2𝑥4 + 𝑥7 ,   não   devemos   esquecer   que   os  

coeficientes    desses    polinômios    são    elementos    de  𝐹 =  0,1 ,    portanto,  a  aritmética 

utilizada  deve  ser  compatível  com  esse  corpo,  assim,   −1 − 2𝑥3 + 2𝑥4 + 𝑥7  =

 −1 − 0𝑥3 + 0𝑥4 + 𝑥7  =  𝑥7 − 1 .  Dessa  decomposição,  vemos  que  existem  dois 

polinômios  de  grau  3  que  dividem  𝑥7 − 1,  a  saber  1 + 𝑥2 + 𝑥3  e  1 + 𝑥 + 𝑥3,  sendo  que 

qualquer um desses polinômios é um gerador do código 𝐶. 

Um polinômio gerador de um código cíclico 𝐶 é da forma 𝑔 𝑥  = 𝑔0 + 𝑔1𝑥 + 𝑔2𝑥2 +
⋯ + 𝑔𝑘−1𝑥𝑛 −𝑘. Como  o comprimento do código  𝐶  acima é  𝑛 = 7 e sua dimensão é  𝑘 = 4, 
então  polinômio  gerador  de  𝐶  é  da  forma  𝑔 𝑥  = 𝑔0 + 𝑔1𝑥 + 𝑔2𝑥2 + 𝑔3𝑥3.  Comparando 
com um dos polinômios geradores acima, por exemplo, o polinômio 1 + 𝑥2 + 𝑥3, temos: 

𝑔0 + 𝑔1𝑥 + 𝑔2𝑥2 + 𝑔3𝑥3 = 1 + 𝑥2 + 𝑥3 = 1 + 0𝑥 + 𝑥2 + 𝑥3,  o  que  implica  que 
𝑔0 = 1, 𝑔1 = 0, 𝑔2 = 1 e 𝑔3 = 1. Assim, uma matriz 𝐺 de ordem 𝑘 × 𝑛, geradora do código 

𝐶 é: 

𝐺 =  

1
0
0
0

0
1
0
0

1
0
1
0

1
1
0
1

0
1
1
0

0
0
1
1

0
0
0
1

Note que a matriz 𝐺 não se apresenta na forma padrão, portanto, gera palavras código 

na forma não sistemática, mas, por meio de transformações elementares sobre as linhas de 𝐺, 
podemos determinar uma matriz 𝐺′ =   𝑅 𝐼𝑘  equivalente a 𝐺 e apresentada na forma padrão. 
A partir de 𝐺′ geramos palavras código na forma sistemática. 

Voltando ao exemplo anterior, do código cíclico  𝐶 referente aos  comandos do braço 

mecânico,  um  polinômio  gerador  de  um  código  cíclico  𝐶  é  da  forma  𝑔 𝑥  = 𝑔0 + 𝑔1𝑥 +
𝑔2𝑥2 + ⋯ + 𝑔𝑘−1𝑥𝑛−𝑘. Como o comprimento do código 𝐶 acima é 𝑛 = 6 e sua dimensão é 
𝑘 = 2,  então  polinômio  gerador  de  𝐶  é  da  forma  𝑔 𝑥  = 𝑔0 + 𝑔1𝑥 + 𝑔2𝑥2 + 𝑔3𝑥3 + 𝑔4𝑥4. 
Comparando com o polinômio gerador 𝑔 𝑥  = 1 + 𝑥2 + 𝑥4, temos: 

𝑔0 + 𝑔1𝑥 + 𝑔2𝑥2 + 𝑔3𝑥3 + 𝑔4𝑥4 = 1 + 𝑥2 + 𝑥4 = 1 + 0𝑥 + 𝑥2 + 0𝑥3 + 𝑥4,  o  que 
implica  que  𝑔0 = 1, 𝑔1 = 0, 𝑔2 = 1,  𝑔3 = 0  e  𝑔4 = 1.  Assim,  uma  matriz  𝐺  de  ordem 

𝑘 × 𝑛 = 2 × 6, geradora do código 𝐶 é: 

 
 
   
   
   
   
   
   
  
 
 
143 

𝐺 =  

1
0

0
1

1
0

0
1

1
0

0
1

Note que a matriz 𝐺 já se encontra na forma padrão 𝐺 =   𝑅 𝐼2 . 
Para  obter  os  elementos  (palavras)  do  código  𝐶  é  suficiente  realizar  o  produto  dos 

vetores do código de canal pela matriz 𝐺: 

 0 0  ∙  

 0 1  ∙  

 1 0  ∙  

 1 1  ∙  

1
0
1
0
1
0
1
0

0
1
0
1
0
1
0
1

1
0
1
0
1
0
1
0

0
1
0
1
0
1
0
1

1
0
1
0
1
0
1
0

0
1
0
1
0
1
0
1

  =  0 0     0 0     0 0  

  =  0 1     0 1     0 1  

  =  1 0     1 0     1 0  

  =  1 1     1 1     1 1  

Observe que as palavras código foram obtidas na forma sistemática em  virtude de  𝐺 

ser apresentada na forma padrão. 

6.4.2  Código dual de um código cíclico 

Teorema 6.25: Da do um código cíclico 𝐶 ⊂ 𝐾𝑛 , um código 𝐶⊥ dual do código 𝐶, é também 

um código cíclico. 

Demonstração: Se  𝐶 é um  código cíclico, então, por definição,  𝐶 é linear. Como  o código 

dual  de um  código linear é também  um  código linear, então o código dual  𝐶⊥  é um  código 

linear.  Verifiquemos  então  que  𝐶⊥  é  cíclico.  Para  todo  𝑐 ∈ 𝐶,  temos  que  𝑇−1(𝑐) ∈ 𝐶,  dado 

𝑣 ∈ 𝐶⊥,  temos  que    𝑣 ∙ 𝑇−1 𝑐  = 0,  mas  𝑣 ∙ 𝑇−1 𝑐  =  

𝑛 −1
𝑖=0

𝑣𝑖 ∙ 𝑐𝑖+1 = 𝑇(𝑣) ∙ 𝑐

,  portanto,  o 

fato de 𝑣 ∈ 𝐶⊥, implica que 𝑇(𝑣) ∈ 𝐶⊥, portanto, 𝐶⊥ é um código cíclico. 

Se 𝐶 é um código cíclico de comprimento 𝑛, com polinômio gerador 𝑔(𝑥), cujo grau é 

𝑔𝑟 𝑔 𝑥   = 𝑛 − 𝑘,  então  existe  𝑕(𝑥) ∈ 𝐾[𝑥]  tal  que  𝑕 𝑥  ∙ 𝑔 𝑥  = 𝑥𝑛 − 1.  Ao  polinômio 

𝑕(𝑥) denominamos polinômio de paridade do código 𝐶. Como 𝑔(𝑥) e 𝑥𝑛 − 1 são polinômios 

mônicos, então 𝑕(𝑥) é também um polinômio Mônico. Notemos ainda que se 𝑕 𝑥  ∙ 𝑔 𝑥  =

𝑥𝑛 − 1,  então  temos  𝑔𝑟 𝑕 𝑥  ∙ 𝑔 𝑥   = 𝑔𝑟 𝑥𝑛 − 1   e,  portanto,  𝑔𝑟 𝑕 𝑥   + 𝑔𝑟 𝑔 𝑥   =

𝑔𝑟 𝑥𝑛 − 1 , ou seja, 𝑔𝑟 𝑕 𝑥   + 𝑛 − 𝑘 = 𝑛, o que implica que 𝑔𝑟 𝑕 𝑥   = 𝑘. 

Em geral, o polinômio 𝑕(𝑥) de paridade de um  código 𝐶 não é o gerador do código 

dual 𝐶⊥. 

 
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 
 
 
 
144 

Teorema 6.26: 𝑐(𝑥) ∈ 𝐶 se, e somente se, 𝑐(𝑥) ∙ 𝑕(𝑥) deixa resto zero quando dividido por 

𝑥𝑛 − 1. 

Demonstração: Dizer que 𝑐(𝑥) ∙ 𝑕(𝑥) deixa resto zero quando dividido por 𝑥𝑛 − 1 equivale 

a  dizer  que  existe  𝑧(𝑥) ∈ 𝐾[𝑥]  tal  que  𝑐 𝑥  ∙ 𝑕 𝑥  = 𝑧(𝑥) ∙  𝑥𝑛 − 1 ,  o  que  equivale  a 

𝑐 𝑥  = 𝑧(𝑥) ∙ 𝑔(𝑥) ou ainda que 𝑐 𝑥  ∈  𝑔(𝑥)  = 𝐶. 

Teorema 6.27: Seja 𝐶 um código cíclico de comprimento 𝑛 e dimensão 𝑘, cujo polinômio de 

paridade é 𝑕 𝑥  = 𝑕0 + 𝑕1𝑥 + 𝑕2𝑥2 + ⋯ + 𝑕𝑘𝑥𝑘 , então a matriz 𝐻(𝑛−𝑘)×𝑛, definida por 
⋯
0
⋱
⋯
𝑕𝑘−1

⋯
𝑕𝑘−1
⋱
0
⋯

⋯
⋯
⋱
𝑕0
⋯

𝑕𝑘−1
𝑕𝑘
⋱
⋯
⋯

0
𝑕0
⋱
𝑕𝑘−1
𝑕𝑘

0
0
⋱
0
𝑕0 

𝑕0
⋯
⋱
𝑕𝑘
0

𝑕𝑘
0
⋱
0
0

 𝐻 =

  é  a  matriz  teste  de  paridade  para  o 

código 𝐶. 

Demonstração: 𝑕𝑘 = 1, pois 𝑕(𝑥) é um polinômio mônico e as linhas de 𝐻 são linearmente 
independentes.  Dado  𝑐 ∈ 𝐶  tal  que  𝑐 𝑥  = 𝑐0 + 𝑐1𝑥 + 𝑐2𝑥2 + ⋯ + 𝑐𝑛−1𝑥𝑛 −1,  pelo  teorema 
6.26  𝑐(𝑥) ∈ 𝐶  se,  e  somente  se,  𝑐(𝑥) ∙ 𝑕(𝑥)  deixa  resto  zero  quando  dividido  por  𝑥𝑛 − 1, 

assim, desenvolvendo 𝑐(𝑥) ∙ 𝑕(𝑥), temos: 

𝑐 𝑥  ∙ 𝑕 𝑥  = 𝑐0𝑕0 +  𝑐0𝑕1 + 𝑐1𝑕0  + ⋯ +     𝑐𝑖𝑕𝑗

  𝑥𝑘 + ⋯ +     𝑐𝑖𝑕𝑗

  𝑥𝑛 −1

𝑖+𝑗 =𝑘

𝑖+𝑗 =𝑛−1

+ ⋯ +     𝑐𝑖𝑕𝑗

  𝑥𝑛 + ⋯ + 𝑐𝑛−1𝑕𝑘𝑥𝑛 +𝑘−1 

𝑖+𝑗 =𝑛

O desenvolvimento  acima deixa resto zero quando dividido  por  𝑥𝑛 − 1, portanto, os 

termos  de  graus  𝑛  até  𝑛 + 𝑘 − 1  transformam-se  em  termos  de  grau  0  a  𝑘 − 1, 

respectivamente, portanto, os termos de graus 𝑘 a 𝑛 − 1 deixam resto zero quando divididos 

por 𝑥𝑛 − 1. Assim, 𝑐(𝑥) ∈ 𝐶 se, e somente se, é solução do seguinte sistema de equações: 

𝑐0𝑕𝑘 + 𝑐1𝑕𝑘−1 + ⋯ + 𝑐𝑘𝑕0 = 0
𝑐1𝑕𝑘 + ⋯ + 𝑐𝑘𝑕1+𝑐𝑘+1𝑕0 = 0
⋮
𝑐𝑛−𝑘−1𝑕𝑘 + ⋯ +𝑐𝑛−1𝑕0 = 0

Representando o sistema acima em notação matricial, temos 𝐻 ∙ 𝑐𝑡, o que implica que 

𝐻 é a matriz teste de paridade do código 𝐶. 

 
 
 
 
 
 
 
   
   
   
   
   
   
   
 
 
 
 
 
  
 
145 

Teorema  6.28:    Seja    𝐶    um    código    cíclico    de    comprimento    𝑛    e    dimensão    𝑘,    cujo 

polinômio de paridade é 𝑕 𝑥  = 𝑕0 + 𝑕1𝑥 + 𝑕2𝑥2 + ⋯ + 𝑕𝑘 𝑥𝑘, então o polinômio  𝑕∗ 𝑥  =
𝑥𝑘 𝑕(𝑡−1) ∈ 𝐾[𝑥]  é  um  gerador  do  código  dual  𝐶⊥.  (O  polinômio  𝑕∗(𝑥)  é  denominado 

polinômio recíproco de 𝑕(𝑥)) 

Demonstração:  Temos  𝑕𝑘 = 1  pois  𝑕  é  um  polinômio  Mônico,  portanto,  resta-nos  provar 
que  𝑕∗ 𝑥 |𝑥𝑛 − 1.  Como  𝑕 𝑥  ∙ 𝑔 𝑥  = 𝑥𝑛 − 1,  então,  𝑕 𝑥−1  ∙ 𝑔 𝑥−1  = 𝑥−𝑛 − 1. 

Multiplicando  a  igualdade  por  −𝑥𝑛 ,  temos  −𝑥𝑛 ∙ 𝑕 𝑥−1  ∙ 𝑔 𝑥−1  = −𝑥𝑛 ∙  𝑥−𝑛 − 1 ,  que 

equivale  a  𝑥𝑘 ∙ 𝑕 𝑥−1  ∙  −𝑥𝑛−𝑘 ∙ 𝑔 𝑥−1   = 𝑥𝑛 − 1,  ou  seja,  𝑕∗ 𝑥  ∙  −𝑥𝑛−𝑘 ∙ 𝑔 𝑥−1   =

𝑥𝑛 − 1. Logo, 𝑕∗ 𝑥  divide 𝑥𝑛 − 1 e, portanto, é um polinômio gerador do código dual 𝐶⊥ do 

código 𝐶. 

Exemplo:  Considerando  código  𝐶  de  comprimento  7  e  dimensão  4  sobre  𝐹{0, 1}, 

visto  anteriormente,  cujo  polinômio  gerador  é  𝑔 𝑥  = 1 + 𝑥2 + 𝑥4.  Da  igualdade  𝑕 𝑥  ∙

𝑔 𝑥  = 𝑥7 − 1, temos: 

𝑥7  −1 
−𝑥7  −𝑥6  −𝑥4 

𝑥3  +𝑥2  +1 
𝑥4  −𝑥3  +𝑥2  +1 

−𝑥6  −𝑥4  −1 
𝑥6  +𝑥5  +𝑥3 

+𝑥5  −𝑥4  +𝑥3  −1 
−𝑥5  −𝑥4  −𝑥2 

+𝑥3  −𝑥2  −1 
−𝑥3  −𝑥2  −1 
0 
0 

0 

Note que estamos operando em  𝐹 = {0,1}, portando,  𝑥4 − 𝑥3 + 𝑥2 + 1 = 𝑥4 + 𝑥3 +

𝑥2 + 1.  Assim,  temos  𝑕 𝑥  = 1 + 𝑥2 + 𝑥3 + 𝑥4  como  polinômio  de  paridade  de  𝐶.  Isso 

implica que a matriz teste de paridade para 𝐶 é: 

0
1
1
Como  𝑕 𝑥  = 1 + 𝑥2 + 𝑥3 + 𝑥4 = 1 ∙ 𝑥0 + 0 ∙ 𝑥 + 1 ∙ 𝑥2 + 1 ∙ 𝑥3 + 1 ∙ 𝑥4,  então  o 

𝐻 =  

1
0
1

0
0
1

1
1
1

0
1
0

1
1
0

1
0
0

polinômio recíproco de 𝑕(𝑥) é: 

𝑕∗ 𝑥  = 1 ∙  𝑥0 −1 + 0 ∙  𝑥1 −1 + 1 ∙  𝑥2 −1 + 1.  𝑥3 −1 + 1 ∙  𝑥4 −1  

𝑕∗ 𝑥  = 1 ∙ 𝑥4 + 0 ∙ 𝑥3 + 1 ∙ 𝑥2 + 1. 𝑥1 + 1 ∙ 𝑥0  

𝑕∗ 𝑥  = 1 + 𝑥 + 𝑥2 + 𝑥4  

Portanto, 𝑕∗ 𝑥  = 1 + 𝑥 + 𝑥2 + 𝑥4 é o polinômio gerador do código dual 𝐶⊥ de 𝐶. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
   
   
   
   
   
  
146 

6.4.3  Decodificação em código cíclico 

Seja 𝐶 um código cíclico, 𝑐 ⊂ 𝐶 a mensagem enviada e  𝑟 a mensagem recebida. Na 

forma polinomial, temos 𝑐(𝑥) e 𝑟(𝑥). 

Notemos inicialmente que se 𝐺 é uma matriz geradora do código 𝐶, então, por meio de 

transformações elementares sobre as linhas de 𝐺 obtemos uma matriz 𝐺′ na forma padrão, ou 
seja,  𝐺′ =   𝑅 𝐼𝑘 ,  da  qual  se  obtém  uma  matriz  teste  de  paridade  𝐻 =   𝐼𝑛−𝑘  − 𝑅𝑇 . 

Representemos por – 𝜌𝑖(𝑥) o polinômio correspondente à 𝑖 −ésima linha da matriz 𝑅. Assim, 
a  𝑖 −ésima  linha  da  matriz  𝐺′  é  representada  pelo  polinômio  −𝜌𝑖 𝑥  + 𝑥𝑛 −𝑘+𝑖,  com 

𝑔𝑟 −𝜌𝑖 𝑥   ≤ 𝑛 − 𝑘 − 1, pois a matriz 𝑅 possui 𝑛 − 𝑘 colunas. 

Sabemos  que  cada linha da matriz  𝐺′ é uma palavra do  código cíclico  𝐶. Como  𝐶 é 

gerado por 𝑔(𝑥), então, cada linha de 𝐺′ é um múltiplo de 𝑔(𝑥), ou seja, existe 𝑞𝑖(𝑥), tal que 
−𝜌𝑖 𝑥  + 𝑥𝑛 −𝑘+𝑖 = 𝑞𝑖(𝑥) ∙ 𝑔(𝑥)  ou  ainda  que  𝑥𝑛 −𝑘+𝑖 = 𝑞𝑖 𝑥  ∙ 𝑔 𝑥  + 𝜌𝑖 𝑥 , 
 1, 2, … , 𝑘 − 1 , ou seja, 𝜌𝑖 𝑥  é o resto da divisão de 𝑥𝑛 −𝑘+𝑖 por 𝑔(𝑥). 

  ∀𝑖 ∈

Como  um  código  cíclico  é  linear,  então,  podemos  utilizar  a  decodificação  por 

síndrome para códigos lineares, ou seja, se 𝑟(𝑥) ⊂ 𝐾𝑛 , é uma palavra recebida, onde 𝐾 é um 

corpo finito, então devemos determinar uma síndrome 𝑠(𝑟). 

Teorema 6.29: A síndrome 𝑠(𝑟 𝑥 ) de uma palavra 𝑟 recebida é o resto da divisão de 𝑟(𝑥) 

pelo polinômio gerador 𝑔(𝑥) do código 𝐶. 

Demonstração:  Considerando  que  𝐶  é  um  código  linear  com  matriz  geradora  na  forma 
padrão  𝐺′ =   𝑅 𝐼𝑘 ,  então  existe  uma  matriz  teste  de  paridade  de  𝐶  na  forma  padrão, 
representada  por  𝐻 =   𝐼𝑛−𝑘  − 𝑅𝑇 .  Notemos  que  as  colunas  de  −𝑅𝑇  são  os  vetores 
representados  por  𝜌0 𝑥 , 𝜌1 𝑥 , … , 𝜌𝑘−1(𝑥).  Como 
a 
representação  polinomial  de  𝑟  é  𝑟 𝑥  = 𝑟0 + 𝑟1𝑥 + 𝑟2𝑥2 + ⋯ + 𝑟𝑛−1𝑥𝑛 −1.  Por  definição,  a 
síndrome  de  𝑟  é  𝑠(𝑟) = 𝐻 ∙ 𝑟𝑡  e,  em  representação  polinomial,  utilizando  a  matriz  𝐻 =
  𝐼𝑛−𝑘  − 𝑅𝑇 , temos: 
𝑠 𝑟 𝑥   = 𝑟0 + 𝑟1𝑥 + 𝑟2𝑥2 + ⋯ + 𝑟𝑛−𝑘−1𝑥𝑛−𝑘−1 + 𝑟𝑛−𝑘𝜌0 𝑥  + 𝑟𝑛−𝑘+1𝜌1 𝑥  + ⋯ + 𝑟𝑛−1𝜌𝑘−1(𝑥)  

𝑟 = (𝑟0, 𝑟1, … , 𝑟𝑛−1), 

então 

𝑘−1

𝑠 𝑟 𝑥   = 𝑟 𝑥  −   𝑟𝑛−𝑘+𝑖(𝜌𝑖 𝑥  − 𝑥𝑛−𝑘+𝑖

𝑖=0

𝑘−1

𝑘−1

𝑠 𝑟 𝑥   = 𝑟 𝑥  −   𝑟𝑛−𝑘+𝑖 𝑞𝑖 𝑥  ∙ 𝑔(𝑥)  =

𝑟 𝑥  −    𝑟𝑛−𝑘+𝑖𝑞𝑖 𝑥 

  ∙ 𝑔 𝑥  

𝑖=0

𝑖=0

 
 
 
 
147 

Sendo  𝑄 𝑥  =  

𝑘−1
𝑖=0

𝑟𝑛−𝑘+𝑖𝑞𝑖 𝑥 

,  temos  𝑠 𝑟 𝑥   = 𝑟 𝑥  − 𝑄(𝑥) ∙ 𝑔(𝑥),  ou  seja, 

𝑟 𝑥  = 𝑄 𝑥  ∙ 𝑔 𝑥  + 𝑠 𝑟 𝑥  , o que implica que a síndrome 𝑠 𝑟 𝑥   é o resto da divisão do 

polinômio 𝑟 𝑥  pelo polinômio gerador 𝑔(𝑥). 

Temos ainda que caso haja erros na transmissão de uma palavra código 𝑐 de modo que 

a palavra recebida seja 𝑟, então o vetor erro 𝑒 é tal que 𝑟 = 𝑐 + 𝑒 e 𝑠 𝑒  = 𝑠(𝑟). Caso 𝑠(𝑟) 

seja o vetor nulo, então 𝑠(𝑒) é o vetor nulo e não 𝑟 = 𝑐. 

O  peso  de  um  elemento  𝑣(𝑥) ∈ 𝑅𝑛 ,  com  𝑣 𝑥  = 𝑣0 + 𝑣1𝑥 + ⋯ + 𝑣𝑛−1𝑥𝑛 −1,   é 

definido  como  sendo  𝜔 𝑣 𝑥   = 𝜔 𝑣  = 𝜔 𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛−1 .  Pelo  teorema  6.29,  se  um 

código  linear  possui  distância  mínima  𝑑,  e,  se  𝑠(𝑟 𝑥 )  é  tal  que  𝜔 𝑠 𝑟(𝑥)   ≤  

𝑑−1

2

  = 𝜅, 

então    𝑠(𝑟(𝑥))  é  um  líder  da  classe  𝑠 𝑟(𝑥)  + 𝐶,    logo,    decodificamos    𝑟 𝑥 ,  obtendo 

𝑐 𝑥  = 𝑟 𝑥  − 𝑠(𝑟(𝑥)),  onde  𝑠(𝑟 𝑥 )  é  o  resto  da  divisão  de  𝑟(𝑥)  pelo  polinômio  gerador 

𝑔(𝑥). 

Exemplos: 

1) Considerando o código cíclico 𝐶 do braço mecânico. O polinômio gerador de 𝐶 é 

𝑔 𝑥  = 1 + 𝑥2 + 𝑥4  e  𝜅 = 1.  Seja  𝑐 = 111111  a  palavra  transmitida,  que  na  forma 

polinomial  é  𝑐 𝑥  = 1 + 𝑥 + 𝑥2 + 𝑥3 + 𝑥4 + 𝑥5. Suponhamos  que a palavra recebida tenha 

sido 𝑟 = 110111, cuja representação polinomial é 𝑟 𝑥  = 1 + 𝑥 + 𝑥3 + 𝑥4 + 𝑥5. 

Resolvendo o quociente 

𝑟(𝑥)

𝑔(𝑥)

, temos:  

𝑥5  +𝑥4  +𝑥3  +𝑥  +1  𝑥4  +𝑥2  +1 
−𝑥5 

−𝑥3  −𝑥 

𝑥 + 1 

+𝑥4 
−𝑥4  −𝑥2 
−𝑥2 

  +1 
  −1 

Veja que 𝑟 𝑥  = −𝑥2 + (𝑥 + 1) ∙ (1 + 𝑥2 + 𝑥4), portanto, a síndrome da palavra recebida é  

𝑠 𝑟(𝑥)  = −𝑥2.    Como  𝜔 𝑠 𝑟(𝑥)   = 1,      então      𝑐 𝑥  = 𝑟 𝑥  − 𝑠(𝑟(𝑥))  equivale  a 

𝑐 𝑥  =  1 + 𝑥 + 𝑥3 + 𝑥4 + 𝑥5  −  −𝑥2  = 1 + 𝑥 + 𝑥2 + 𝑥3 + 𝑥4 + 𝑥5, o que implica que a 

palavra transmitida foi 𝑐 = 111111. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
148 

2) Suponhamos  agora  que  a  palavra  transmitida  seja  𝑐 = 010101,  cuja  forma 

polinomial equivalente é 𝑐 𝑥  = 𝑥 + 𝑥3 + 𝑥5 e que a palavra recebida seja 𝑟 = 010111 cuja 

representação polinomial é 𝑟 𝑥  = 𝑥 + 𝑥3 + 𝑥4 + 𝑥5. 

Resolvendo o quociente 

𝑟(𝑥)

𝑔(𝑥)

, temos:  

𝑥5  +𝑥4  +𝑥3  +𝑥  𝑥4  +𝑥2  +1 
−𝑥5 

−𝑥3  −𝑥 

𝑥 + 1 

+𝑥4 
−𝑥4  −𝑥2  −1 
−𝑥2  −1 

Veja  que  𝑟 𝑥  = (1 + 𝑥2) + (𝑥 + 1) ∙ (1 + 𝑥2 + 𝑥4),  portanto,  a  síndrome  da  palavra 

recebida  é  𝑠 𝑟(𝑥)  = 1 + 𝑥2,  como  𝜔 𝑠 𝑟(𝑥)   = 2 > 1 = 𝜅,  então  não  podemos  ainda 

decodificar 𝑟 𝑥  utilizando  𝑐 𝑥  = 𝑟 𝑥  − 𝑠(𝑟(𝑥)). Porém, os polinômios 𝑟 𝑥  = 𝑥 + 𝑥3 +

𝑥4 + 𝑥5  e  𝑟′(𝑥) = 𝑥3 + 𝑥4 + 𝑥5 + 𝑥7  deixam  mesmo  resto  quando  divididos  por  𝑥6 − 1, 

assim, façamos o quociente 

𝑟′(𝑥)

𝑔(𝑥)

: 

𝑥7  +𝑥5  +𝑥4  +𝑥3  𝑥4  +𝑥2  +1 
−𝑥7  −𝑥5 
−𝑥3 

𝑥3 

+𝑥4 

Note  que 𝑔𝑟 𝑥4  = 𝑔𝑟(𝑔 𝑥 ),  o que  implica  que  𝑥4  não  é  o  resto da divisão de 𝑟(𝑥) 

por  𝑔(𝑥),    porém,    𝜔(𝑥4) = 1 = 𝜅,    logo,    𝑥4    é    líder    da    classe    𝑟 𝑥  + 𝐶,  portanto, 

𝑐 𝑥  = 𝑟 𝑥  − 𝑥4, que equivale a  𝑐 𝑥  = 𝑥 + 𝑥3 + 𝑥4 + 𝑥5 − 𝑥4 = 𝑥 + 𝑥3 + 𝑥5, ou seja, a 

palavra transmitida foi 𝑐 = 010101 

Vimos  que  obter  o  líder  de  classe  não  acontece  de  forma  direta  com  a  aplicação  do 

sintoma se esse tiver peso maior que 𝜅. Notemos, porém, que um desvio cíclico 𝑥𝑖𝑟(𝑥) ∈ 𝑅𝑛  
carrega a mesma informação que 𝑅𝑛 , portanto, se decodificarmos 𝑥𝑖𝑟(𝑥) para algum 𝑖, como 
consequência, decodificaremos 𝑟(𝑥). 

Teorema 6.30: Seja 𝑟 𝑥  ∈ 𝑅𝑛 . A síndrome de um desvio cíclico 𝑥𝑟 𝑥  de 𝑟 𝑥  é 𝑠 𝑟 𝑥   =

𝑥𝑠 𝑟 𝑥   − 𝑠𝑛−𝑘−1𝑔 𝑥 ,  onde  𝑠𝑛−𝑘−1  é  o  coeficiente  do  termo  de  grau  𝑛 − 𝑘 − 1  de 

𝑠 𝑟 𝑥  . 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
149 

Demonstração:  Considerando  𝑠 𝑟 𝑥   como  a síndrome de  𝑟(𝑥), temos que  𝑟 𝑥  = 𝑞 𝑥  ∙

𝑔 𝑥  + 𝑠(𝑟 𝑥 ), com grau de 𝑠 𝑟 𝑥   ≤ 𝑛 − 𝑘 − 1, para algum 𝑞(𝑥). Escrevendo 𝑠 𝑟 𝑥   =

𝑠𝑛−𝑘−1𝑥𝑛 −𝑘−1 + 𝑠′ (𝑥)  e  𝑔 𝑥  = 𝑥𝑛 −𝑘 + 𝑔(𝑥),  onde  𝑔𝑟 𝑠 𝑥   < 𝑛 − 𝑘 − 1  e  𝑔𝑟 𝑔′  𝑥   <

𝑛 − 𝑘, temos: 

𝑥𝑟 𝑥  = 𝑥𝑞 𝑥  ∙ 𝑔 𝑥  + 𝑥𝑠 𝑟 𝑥   = 𝑥 𝑞 𝑥  + 𝑠𝑛−𝑘−1  ∙ 𝑔 𝑥  + (𝑥𝑠 𝑟 𝑥   − 𝑠𝑛−𝑘−1𝑔 𝑥 ). 

Mas 𝑥𝑠 𝑟 𝑥   − 𝑠𝑛−𝑘−1 = 𝑥𝑠′  𝑟 𝑥   − 𝑠𝑛−𝑘−1𝑔′ (𝑥) tem grau menor que  𝑛 − 𝑘, logo, pelo 

teorema 6.29, temos que 𝑠(𝑥𝑟 𝑥  = 𝑥𝑠 𝑟 𝑥   − 𝑠𝑛−𝑘−1𝑔(𝑥). 

Com  base  do  descrito  acima,  levando  em  consideração  o  exemplo  anterior  (2),  onde 

𝑟 𝑥  = 𝑥 + 𝑥3 + 𝑥4 + 𝑥5,  𝑔 𝑥  = 1 + 𝑥2 + 𝑥4  e  𝑛 − 𝑘 − 1 = 6 − 4 − 1 = 3,  vimos  que  a 

síndrome de 𝑟(𝑥) é 𝑠 𝑟 𝑥   = 1 + 𝑥2, portanto, as demais síndromes são: 

𝑠1 𝑥𝑟 𝑥   = 𝑥𝑠 𝑟 𝑥   − 𝑠3𝑔 𝑥  = 𝑥 ∙  1 + 𝑥2  − 0 ∙  1 + 𝑥2 + 𝑥4  = 𝑥 + 𝑥3  

𝑠2 𝑥2𝑟 𝑥   = 𝑥𝑠1 𝑥𝑟 𝑥   − 𝑠3𝑔 𝑥  = 𝑥 ∙  𝑥 + 𝑥3  − 1 ∙  1 + 𝑥2 + 𝑥4  =  
= 𝑥2 + 𝑥4 − 1 − 𝑥2 − 𝑥4 = 1   

𝑠3 𝑥3𝑟 𝑥   = 𝑥𝑠2 𝑥2𝑟 𝑥   − 𝑠3𝑔 𝑥  = 𝑥 ∙ 1 − 0 ∙  1 + 𝑥2 + 𝑥4  = 𝑥  

𝑠4 𝑥4𝑟 𝑥   = 𝑥𝑠3 𝑥3𝑟 𝑥   − 𝑠3𝑔 𝑥  = 𝑥 ∙ 𝑥 − 0 ∙  1 + 𝑥2 + 𝑥4  = 𝑥2  

𝑠5 𝑥5𝑟 𝑥   = 𝑥𝑠4 𝑥4𝑟 𝑥   − 𝑠3𝑔 𝑥  = 𝑥 ∙ 𝑥2 − 0 ∙  1 + 𝑥2 + 𝑥4  = 𝑥3. 

Dizemos que um vetor 𝑣 =  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1  de 𝑘𝑛  contém uma sequência cíclica 

de 𝑘 zeros se existe 𝑗 tal que 𝑣𝑗 = 𝑣𝑗 +1 = 𝑣𝑗 +2 = ⋯ = 𝑣𝑗 +𝑘−1 = 0. 
Exemplo:  O  vetor  𝑣1 = (1, 0, 0, 0, 1, 0, 1) ∈ 𝐹7  possui  uma  sequência  cíclica  de  3  zeros.  O 
vetor 𝑣2 = (0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0) ∈ 𝐹11 possui uma sequência cíclica de sete zeros pois 
basta realizar um deslocamento cíclico de cinco unidades para a direita que obtemos o vetor 

𝑇 𝑣2  = (0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1).  Se  𝑣 =  𝑣0, 𝑣1, 𝑣2, … , 𝑣𝑛 −1   contém  uma  sequência 

cíclica de 𝑘 zeros, então existe 𝑖 ∈  0, 1, 2, … , 𝑛 − 1  tal que 𝑔𝑟  𝑥𝑖𝑣 𝑥   ≤ 𝑛 − 𝑘 − 1, para 

isso, basta permutar ciclicamente as coordenadas de 𝑣 de modo que os 𝑘 zeros ocupem as 𝑘 

últimas  coordenadas  de  𝑣,  que  obtemos  um  vetor  com  no  máximo  as  𝑛 − 𝑘 − 1  primeiras 

coordenadas não nulas, que corresponde a um polinômio de grau no máximo 𝑛 − 𝑘 − 1. 

Teorema 6.31:  Se   um   vetor   erro   𝑒 ∈ 𝑘𝑛 ,  cujo  peso  é 𝜔 𝑒  ≤  

𝑑−1

2

  = 𝜅  e  possui  

uma  sequência    cíclica    de    𝑘  zeros,    então    𝜔  𝑠  𝑥𝑖𝑒 𝑥    ≤  

𝑑−1

2

  = 𝜅,    para    algum 

𝑖 ∈  0, 1, 2, … , 𝑛 − 1 . 

 
 
 
 
 
150 

Demonstração: Pelo visto anteriormente, se 𝑒 possui uma sequência cíclica de 𝑘 zeros, então 

existe  𝑖 ∈  0, 1, 2, … , 𝑛 − 1   tal que 𝑔𝑟  𝑥𝑖𝑒 𝑥   ≤ 𝑛 − 𝑘 − 1. Pelo teorema 6.30 temos que 

𝑠 𝑥𝑖𝑒(𝑥)  = 𝑥𝑖𝑠(𝑒 𝑥 ). Como as permutações entre as coordenadas de um vetor não alteram 

seu peso, então temos que se 𝜔 𝑒  ≤  

𝑑−1

2

  = 𝜅 então 𝜔  𝑠  𝑥𝑖𝑒 𝑥    ≤  

𝑑−1

2

  = 𝜅. 

Com  base  no  exposto,  uma  sequência  para  decodificação  consiste  em  determinar  os 

sintomas de um vetor 𝑟(𝑥) recebido e, se 𝜔(𝑠𝑖 𝑟 𝑥  ) ≤ 𝜅 para algum 𝑖 ∈ {0, 1, 2, … , 𝑛 − 1}, 

então  assumimos  que  𝑒 𝑥  = 𝑥𝑛 −1𝑠𝑖 𝑟 𝑥    é  o  vetor  erro  e  decodificamos  𝑟(𝑥)  como 

𝑐 𝑥  = 𝑟 𝑥  − 𝑥𝑛 −1𝑠𝑖 𝑟 𝑥  . Caso contrário, o erro não é corrigível. 

Para concluir, apresentamos um último exemplo referente à decodificação em códigos 

cíclicos: 

Consideremos  um  código  cíclico  𝐶  contido  em  𝐹7,  onde  𝐹 = {0,1}  é  um  corpo 

galoisiano, tal que dim 𝐶 = 4 e um polinômio gerador de 𝐶 é 𝑔 𝑥  = 1 + 𝑥 + 𝑥3. A distância 

mínima desse código é 𝑑 = 3, o que implica que ele tem capacidade de detecção de 𝑑 − 1 =

3 = 1 = 2 erros e capacidade de correção 𝜅 =  

𝑑−1

2

  =  

3−1

2

  = 1 erro. Como 𝜅 = 1, então os 

líderes de classe são os vetores com peso 𝜔 ≤ 1. 

Consideremos  que  a  palavra  recebida  seja  𝑟 = 1000100  cuja  representação  polinomial  é 

𝑟 𝑥  = 1 + 𝑥4. Resolvendo o quociente 

𝑟(𝑥)

𝑔(𝑥)

, temos: 

𝑥4  +1 
−𝑥4  −𝑥2  −𝑥 
−𝑥2  −𝑥  +1 

𝑥3  +𝑥  +1 
𝑥 

O resto da divisão de 𝑟(𝑥) por 𝑔(𝑥) é −𝑥2 − 𝑥 + 1 = 𝑥2 + 𝑥 + 1. 

Assim, 𝑥4 + 1 = 𝑥 ∙  𝑥3 + 𝑥 + 1  + (1 + 𝑥 + 𝑥2), o que implica que 𝑠 𝑟 𝑥   = 1 + 𝑥 + 𝑥2. 

Mas  𝜔(𝑠 𝑟 𝑥   = 3 > 1 = 𝜅,  sendo  assim,  não  podemos  ainda  decodificar  𝑟 𝑥   utilizando  

𝑐 𝑥  = 𝑟 𝑥  − 𝑠(𝑟(𝑥)), portanto, determinaremos as síndromes de todos os desvios cíclicos 

de 𝑟(𝑥): 

𝑠1 𝑥𝑟 𝑥   = 𝑥𝑠 𝑟 𝑥   − 𝑠2𝑔 𝑥  = 𝑥 ∙  1 + 𝑥 + 𝑥2  − 1 ∙  1 + 𝑥2 + 𝑥3  = 𝑥2 − 1 = 1 + 𝑥2  

𝑠2 𝑥2𝑟 𝑥   = 𝑥𝑠1 𝑥𝑟 𝑥   − 𝑠2𝑔 𝑥  = 𝑥 ∙  1 + 𝑥2  − 1 ∙  1 + 𝑥2 + 𝑥3  =  
= 𝑥2 + 𝑥3 − 1 − 𝑥 − 𝑥3 = −1 = 1   

𝑠3 𝑥3𝑟 𝑥   = 𝑥𝑠2 𝑥2𝑟 𝑥   − 𝑠2𝑔 𝑥  = 𝑥 ∙ 1 − 0 ∙  1 + 𝑥 + 𝑥3  = 𝑥  

 
 
 
 
 
 
 
 
 
 
 
 
151 

𝑠4 𝑥4𝑟 𝑥   = 𝑥𝑠3 𝑥3𝑟 𝑥   − 𝑠2𝑔 𝑥  = 𝑥 ∙ 𝑥 − 0 ∙  1 + 𝑥 + 𝑥3  = 𝑥2  

𝑠5 𝑥5𝑟 𝑥   = 𝑥𝑠4 𝑥4𝑟 𝑥   − 𝑠2𝑔 𝑥  = 𝑥 ∙ 𝑥2 − 1 ∙  1 + 𝑥 + 𝑥3  = 𝑥3 − 1 − 𝑥 − 𝑥3 =  

= −1 − 𝑥 = 1 + 𝑥  

𝑠6 𝑥5𝑟 𝑥   = 𝑥𝑠5 𝑥5𝑟 𝑥   − 𝑠2𝑔 𝑥  = 𝑥 ∙  1 + 𝑥  − 0 ∙  1 + 𝑥 + 𝑥3  = 𝑥 + 𝑥2. 

Qualquer  um  dos  𝑠𝑖  𝑥𝑖𝑟 𝑥    tal  que  𝜔  𝑠𝑖  𝑥𝑖𝑟 𝑥    = 1  é  um  líder  da  classe,  portanto, 

qualquer um deles pode ser utilizado no processo de decodificação. Utilizemos, por exemplo, 

𝑠2 𝑥2𝑟 𝑥   = 1:  pelo  que  foi  visto  anteriormente,  𝑒 𝑥  = 𝑥𝑛 −1𝑠𝑖 𝑟 𝑥  ,  logo,  𝑒 𝑥  =

𝑥7−2𝑠2 𝑟 𝑥   = 𝑥5 ∙ 1 = 𝑥5,  assim,  a  decodificação  correta  de  𝑟(𝑥)  é  𝑐 𝑥  = 𝑟 𝑥  − 𝑥5 =
1 + 𝑥4−𝑥5 = 1 + 𝑥4 + 𝑥5. A palavra transmitida é 𝑐 = 100011. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
152 

7  ATIVIDADES POPOSTAS 

Este  capítulo  tem  como  objetivo  apresentar  uma  coletânea  de  atividades  propostas 

sobre  os  conteúdos  apresentados  neste  trabalho,  cujo  objetivo  principal  é  a  aplicação  das 

propriedades  estudas  e,  por  conseguinte,  a  familiarização  dos  estudantes  aos  conceitos  aqui 

apresentados.  

A rotina de atividades propostas segue a seguinte ordem: 

1º - Atividades sobre matrizes, operações e propriedades; 

2º - Atividades sobre determinantes e suas propriedades; 

3º - Atividades sobre polinômios, operações e propriedades; 

4º - Atividades sobre códigos corretores de erros, aplicação de matrizes, determinantes 

e polinômios. 

7.1  MATRIZES REAIS 

1) Indique explicitamente os elementos da matriz 𝐴 =  𝑎𝑖𝑗  

 tal que 𝑎𝑖𝑗 = 𝑖2 − 3𝑖𝑗 + 𝑗2. 

3×4

2) Construa a matriz 𝐴 =  𝑎𝑖𝑗  

4×4

 tal que 𝑎𝑖𝑗 =  

1, 𝑠𝑒 𝑖 = 𝑗
0, 𝑠𝑒 𝑖 ≠ 𝑗

 . O que se pode dizer a respeito 

dessa matriz? 

3)  Construa  a  matriz  𝐴 =  𝑎𝑖𝑗  

5×5

  tal  que  𝑎𝑖𝑗 =  

𝑖2 + 2𝑗, 𝑠𝑒 𝑖 ≤ 𝑗
0, 𝑠𝑒 𝑖 > 𝑗

 .  O  que  se  pode  dizer  a 

respeito dessa matriz? 

4) Dadas as matrizes 𝐴 =  

5𝑎 4𝑏
3
6

  e 𝐵 =  

𝑎 + 4
6

6𝑏
𝑏 + 3

 , quais são os valores de 𝑎 e 𝑏 para 

que se tenha 𝐴 = 𝐵? 

5)  Dadas  as  matrizes  𝐴 =  

2 −3 4
−1 −6 0
2
5
3

 ,  𝐵 =  

0
1
1
1
5
−2
3 −3 −1

   e  𝐶 =  

determine a matriz 𝑋 tal que 𝐴2 + 𝑋 = 3 ∙ 𝐵 − 𝐶𝑡. 

3
−3 2
0
2

1 −5
4
2

 , 

 
 
 
 
 
 
 
 
 
153 

6) Obtenha todas as matrizes 𝑀 que comutam com 𝐴 =  

−1 2
−2 3

 . 

7) Determine todas as matrizes 𝐴 quadradas de ordem 2 tais que 𝐴2 =  

0 0
0 0

 . 

8) Dadas as matrizes 𝐴 =  𝑎𝑖𝑗  

 tal que 𝑎𝑖𝑗 = 𝑖3 − 4𝑗,  𝐵 =  𝑏𝑖𝑗  

 tal que 𝑏𝑖𝑗 = 8𝑖 − 𝑗2 

3×4

3×4

e 𝐶 =  𝑐𝑖𝑗  

3×4

 tal que 𝑐𝑖𝑗 = 𝑖2 − 𝑗2, determine: 

a) 𝐴 + 𝐵 
b) 𝐴 − 𝐵 
c) – 𝐴 + (−𝐵) 
d) 𝐵 + 𝐴 

e) 𝐴 + 𝐶 

f)  𝐴 + 𝐵  + 𝐶  

g) 𝐴 +  𝐵 + 𝐶   

h) 3𝐴 − 5𝐶 
i)  𝐵 ∙ 𝐶𝑡 𝑡 
j) 𝐵𝑡 ∙ 𝐶 
l) 𝐴 ∙ 𝐵𝑡 
m)  𝐴 ∙ 𝐵𝑡  ∙ 𝐶 

n) 𝐴 ∙  𝐵𝑡 ∙ 𝐶  
o) − 𝐶𝑡 𝑡 

p)  𝐴 + 𝐶 𝑡 
q) 𝐴𝑡 + 𝐶𝑡 
r)  𝐴 + 𝐵 + 𝐶 𝑡 
s) 𝐼3 ∙ (𝐴 + 𝐵) 
t) −6𝐴𝑡 + 4𝐵𝑡 −

1

𝐶𝑡 
2
2
 𝐴 ∙ 𝐵𝑡  ∙ 𝐶 +

3

5

u) 
v)  𝐴 ∙ 𝐴𝑡  2 

 𝐴 ∙ 𝐶𝑡  ∙ 𝐵 

3

9) Considerando as matrizes 𝐴, 𝐵 e 𝐶 do exercício anterior, é possível obter 𝐴 ∙ 𝐵, 𝐴 ∙ 𝐶 e 𝐵 ∙

𝐶? Justifique sua resposta. 

10)  Se  𝑀  e  𝑁  são  matrizes  quadradas  de  ordem  2  que  comutam  com  a  matriz   

1
0
−1 0

 , 

mostre que 𝑀 ∙ 𝑁 = 𝑁 ∙ 𝑀. 

11) Determine os valores desconhecidos nas sentenças abaixo: 

a)  

2𝑥 + 𝑦
−7

7
3𝑥 − 2𝑦

  =  

5
3𝑤 − 4𝑧

𝑤 + 𝑧
4

b)  

3
5
2
0
3
−1
4 −2 −1

  ∙  

𝑥
𝑦
𝑧

  =  

0
1
9

12) Considere uma matriz 𝑀 de ordem 𝑛 que não é equivalente por linhas à matriz identidade 

𝐼𝑛 . A matriz 𝑀 é invertível? Justifique sua resposta. 

13) Seja 𝑁 uma matriz invertível, cuja a inversa é 𝑁−1.  A matriz 𝑁−1 é invertível? Caso seja, 

qual é a sua inversa? Caso não seja, justifique. 

14)  Sendo  𝐴  e  uma  matriz  quadrada  de  ordem  𝑛  tal  que  𝐵  e  𝐶  são  suas  matrizes  inversas. 

Qual é a relação que existe entre 𝐵 e 𝐶? 𝐵 e 𝐶 são matrizes quadradas? Qual a ordem de 𝐵? 

 
 
 
 
 
 
  
  
 
 
 
15) Escreva a matriz 𝑀 =  

1
2
3
4

2
1
0
3

1
4
0
2

1
3
2
−5

  na forma escalonada. 

154 

16)  Dada  a  matriz  𝐴 =  

0
1
−3 4
2

2
1
1 −1

 ,  efetue  operações  elementares  sobre  suas  linhas  e 

verifique se 𝐴 é invertível. Caso seja, explicite sua inversa. 

17)  Para  as  matrizes  𝐴, 𝐵  e  𝐶,  abaixo,  utilizando  operações  elementares  sobre  as  linhas, 

determine suas inversas: 

a) 𝐴 =  

b) 𝐵 =  

c) 𝐶 =  

2 −3
1
−4
1 −1
2 −3
−2
2
1
3
0

1
0
2
3

0
1
1 −3
3
0
3
2
1
0
2
1

18) Resolva as seguintes equações matriciais: 

b) 𝑋 ∙  

  =  −3 2  

a)  

  ∙ 𝑋 =  

6
−4

3 −1
5
−2
−1 1
1
1
0 −1
2
1
−1
3
1
3 −2

c)  

  ∙ 𝑋 =  

−1
2
0 −3
1
2

19) É possível obter 𝑥 e 𝑦 de modo que a matriz  

2 3
𝑥 𝑦

  seja ortogonal? 

20) Dada uma matriz 𝐴 invertível, podemos afirmar que 𝐴𝑡 é invertível? Justifique. 

7.2  DETERMINANTES DE MATRIZES REAIS 

21) Calcule o determinante de cada uma das matrizes a seguir e identifique se as mesmas são 

invertíveis ou não: 

 
   
   
   
 
 
  
  
    
    
    
  
 
  
  
 
 
 
 
155 

b)  

4 8
1 2

− 2 −
−4

d)  

3

4

3 8

1

2

a)  

0
2
−3 1

c)  

1

3
−

2

5

3

4

−
4

3

22) Aplicando a regra de Sarrus, calcular o determinante de cada uma das seguintes matrizes: 

a)  

−1
3
0
4 −2 −5
3 −1
0

b) 

c)  

 2 −1
1

0
3
 3 −

2
5
1 −1  6

d) 

  𝑎 −
2
2
−1
−

7

𝑎 −2

  1
4

5
−2 −

1

6

2
−3 0
1

3

1

4 

−𝑏

5
1
3  

23) Aplique a triangulação de Gauss e calcule os seguintes determinantes: 

a)  

−1
2
1
3
1
2
1 −2 3

b)  

−2
1
−1
0

1
−3
−2
2

1
2
1
−2

−1
1
3
1

c)  

3
2
−1
2
0

2
−2
1
−4
0

1
1
0
1
−4

0
−1
4
−1
3

−1
0
−3
4
3

24) Determine 𝑥 para o qual se tenha  

1

𝑥 −2
2
2𝑥 −3 2
1
𝑥
−1

5

  ≠ 0. 

25) Determine a matriz dos cofatores de cada uma das matrizes abaixo: 

a)  

−3 2
2
1
−

2

3

                                     b)  

−1
2

2 −3
5 −1

3
4 −3

1

26) Calcule os determinantes abaixo utilizando a regra de Laplace: 

a)  

−2
2
3
0

3
−1
1
−5

0
3
0
2

1
−4
1
−3

b)  

−9
0
−3
1

3
5
2
3

0
0
1
−4

−1
0
1
1

 
  
 
  
 
  
 
 
  
 
  
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
  
    
    
    
  
 
    
    
    
    
 
  
 
 
  
 
    
    
    
  
    
    
    
  
  
27) Mostre que para todo 𝑎, 𝑏, 𝑐 ∈ ℝ, sempre temos  

𝑏 −15

  = 0. 

156 

3

−1 𝑎
5
−3 𝑐

9

28) Prove que  

1
1
𝑥2 𝑦2
𝑥3 𝑦3

1
𝑧2
𝑧3

  =  

𝑦𝑧 𝑥𝑧 𝑥𝑦
𝑧
𝑦
𝑥
𝑥2
𝑥2 𝑦2

 . 

29) Quais as condições necessárias e suficientes para que um determinante seja nulo? 

30) 

Aplicando 

as 

propriedades 

dos 

determinantes, 

mostre 

que 

cos(2𝑥) ⁡ 𝑐𝑜𝑠2(𝑥)
𝑐𝑜𝑠2(𝑦)
cos(2𝑦)
𝑐𝑜𝑠2(𝑧)
cos(2𝑧)

𝑠𝑒𝑛2(𝑥)
𝑠𝑒𝑛2(𝑦)
𝑠𝑒𝑛2(𝑧)

  = 0 

31) Prove que o determinante  

  é múltiplo de 7, sem desenvolvê-lo. 

1 5 4
1 2 6
1 8 2

32) Por qual motivo se tem  

−2
1
3
−1

4
−2
−1
3

1
2
1
0

2
−1
7
3

  = 0? 

33) Se o determinante de uma matriz 𝐴 é igual a zero, a matriz 𝐴 é invertível? Justifique. 

34) Dada a matriz 𝐴 =  

1 −1
−3
𝑎
2
𝑎
𝑎
5 −3

 , para quais valores de 𝑎 não existe 𝐴−1? 

35) Dada a matriz 𝐴 =  

det(𝐵)? Justifique. 

3
3
−3 −2
2

1
1
0 −5

  e 𝐵 =  

2 −3 3
0 −2 3
1
1
−5

 , qual a relação entre det(𝐴) e 

36) Determine a adjunta das seguintes matrizes: 

a) 𝐴 =  

5 −2 −3
2
4 −1
0
1
3

b) 𝐵 =  

1

0

7

3
4 −4 0
2
−1 2

5

c) 𝐶 =  

1

7

7
6
−
13 −8 2
−5 3
1

1

3

 
 
 
 
 
 
 
    
    
    
 
 
 
 
 
  
  
  
157 

37) Utilizando determinantes, calcule a matriz inversa das seguintes matrizes: 

a) 𝐴 =  

3 −1
5
2

c) 𝐶 =  

3
2
0
2
5
−3
4 −2 1

b) 𝐵 =  

2

3

−
3

7

1

5
−

2

7

d) 𝐷 =  

−6 3
2
4

1
5 −1
0
0

38)  Sabendo  que  a  matriz  inversa  de  uma  matriz  𝐴  é    𝐴−1 =  

det 𝐴  = −

5

7

, determine a matriz dos cofatores da matriz 𝐴. 

1

3
2

5
−1

−2
2

     e  que 

3

3

7
−

4
3

3
5

39) Dadas duas matrizes 𝐴 e 𝐵, quadradas de ordem 𝑛 e invertíveis, mostre que: 

a) det(𝐴𝑡 ∙ 𝐵𝑡) = det(𝐴) ∙ det(𝐵)  

b) det 𝐴𝑡 ∙ 𝐵−1  =

1
det (𝐴−1)∙det (𝐵𝑡)

40) Seja ℳ𝑛  o conjunto de todas as matrizes quadradas de ordem 𝑛, definimos o determinante 

como uma função de ℳ𝑛  em ℝ, que a cada matriz 𝑀 ∈ ℳ𝑛  faz corresponder o número real 

det⁡(𝑀). Mostre que a função determinante não é bijetiva. 

7.3  POLINÔMIOS EM ℝ[𝑋] 

41)  Justifique  por  qual  motivo  a  expressão  𝑝 𝑥  = 3𝑥2 − 2𝑥 +

1

3

−

5

𝑥

+

3

𝑥 2  não  é  um 

polinômio em ℝ[𝑥]. 

42) Determine a condição necessária e suficiente para que a expressão 

𝑎0+𝑎1𝑥+𝑎2𝑥 2+𝑎3𝑥 3
𝑏0+𝑏1𝑥+𝑏2𝑥 2+𝑏3𝑥 3  seja 

independente de 𝑥. 

43)  Determinar    os    valores    reais    de    𝑎, 𝑏  e  𝑐,    de    modo    que    se    tenha    o    polinômio 

𝑝 𝑥  =  𝑎2 − 4 𝑥3 +  3𝑏2 − 5𝑎 𝑥2 −  𝑎 + 𝑏 + 𝑐 𝑥 + (𝑎𝑏 − 𝑐) igual ao polinômio nulo. 

 
  
  
  
  
 
 
 
 
 
 
 
 
 
158 

44)  Dados  os  polinômios  𝑝 𝑥  =  𝑎 + 3 𝑥4 −  2𝑎 + 𝑏 𝑥2 + (3𝑎 − 𝑏 + 𝑐)  e  𝑞 𝑥  =

 4𝑎 − 2 𝑥2 +  3 − 5𝑏 𝑥2 + (𝑏 − 4𝑐).  Determine  os  valores  de  𝑎, 𝑏  e  𝑐  para  que  se  tenha 

𝑝 𝑥  = 𝑞(𝑥). 

45)  Dados  os  polinômios  𝑝 𝑥  = 2𝑥2 + 5𝑥 − 3,  𝑞 𝑥  = 3𝑥3 − 4𝑥2 + 5𝑥 − 1  e  𝑔 𝑥  =

−6𝑥3 + 7𝑥 − 2, calcular: 

a) 𝑝 𝑥  + 𝑞(𝑥)           b) 𝑝 𝑥  + 𝑔(𝑥)              c) 𝑞 𝑥  + 𝑔(𝑥)             d) 𝑝 𝑥  + 𝑞 𝑥  + 𝑔(𝑥) 

46) Dados os polinômios 𝑝 𝑥  = 7𝑥4 − 5𝑥3 − 𝑥, 𝑞 𝑥  = −3𝑥3 + 5𝑥2 − 12𝑥 + 8 e  𝑔 𝑥  =

3𝑥4 + 𝑥3 − 9𝑥2 + 3𝑥 − 4, determine: 

a) 𝑝 𝑥  − 𝑞(𝑥)    b) 𝑝 𝑥  − 𝑔 𝑥  − 𝑞(𝑥)    c) 𝑝 𝑥  − 𝑞 𝑥  + 𝑔(𝑥)     d) 𝑔 𝑥  − 𝑞 𝑥  + 𝑝(𝑥) 

47)    Dados    os    polinômios    𝑝 𝑥  = −𝑥2 + 3𝑥 − 4,      𝑞 𝑥  = 4𝑥3 − 2𝑥 + 1        e              

𝑔 𝑥  = 𝑥3 − 3𝑥2 + 2𝑥 − 4, determine: 

a) 𝑝(𝑥) ∙ 𝑞(𝑥)             b) 𝑝(𝑥) ∙ 𝑔(𝑥)             c) 𝑝(𝑥) ∙ 𝑞(𝑥) ∙ 𝑔(𝑥)           d)  𝑝 𝑥  2 −  𝑔 𝑥  2 

48)        Dados        os        polinômios        𝑝 𝑥  = 𝑥4 − 4𝑥2 − 3𝑥 + 1,  𝑞 𝑥  = 𝑥3 − 3𝑥2 + 2  e 

𝑔 𝑥  = 𝑥2 − 5𝑥 + 1,  determine  os  polinômios  quociente  e  resto  das  seguintes  divisões 

euclidianas: 

a) 𝑝 𝑥 : 𝑞(𝑥)      b) 𝑝 𝑥 : 𝑔(𝑥)      c) 𝑞 𝑥 : 𝑔(𝑥)       d)  𝑞 𝑥  2: 𝑔(𝑥)      e)  𝑝 𝑥  2:  𝑔 𝑥  3 

49) Se 𝑝(𝑥) e 𝑞 𝑥  são dois polinômios não nulos de grau respectivamente 𝑚 e 𝑛, qual o grau 

de 𝑝 𝑥  + 𝑞 𝑥 ? E de 𝑝 𝑥  ∙ 𝑞(𝑥)? 

50) Considerando os polinômios 𝑝(𝑥) e 𝑞(𝑥) do exercício anterior, se 𝑚 > 𝑛, qual o grau do 

quociente 

𝑝(𝑥)

𝑞(𝑥)

? Qual o grau máximo do polinômio 𝑟(𝑥) que é o resto dessa divisão? 

51)  Dividindo      um      polinômio      𝑝 𝑥   por  𝑔 𝑥  = 𝑥2 + 5𝑥 − 3,  obtemos  o  quociente 

𝑞 𝑥  = 𝑥3 + 4𝑥2 − 3 e o resto 𝑟 𝑥  = 3𝑥 + 4. Determine o polinômio 𝑝(𝑥). 

52) Determinar os números reais 𝑎 e 𝑏 de modo que o polinômio 𝑝 𝑥  = 𝑥6 − 4 seja divisível 

por 𝑥2 + 𝑎𝑥 + 𝑏. 

 
 
 
 
 
 
 
 
 
 
159 

53) Mostrar que se 𝑝(𝑥) e 𝑔(𝑥) são polinômios divisíveis pelo polinômio 𝑞(𝑥), então o resto 

da divisão de 𝑝(𝑥) por 𝑔(𝑥) também é divisível por 𝑞(𝑥). 

54) Dados 𝑝(𝑥), 𝑔(𝑥) e 𝑞(𝑥) polinômios de ℝ[𝑥] tais que 𝑞 𝑥 |𝑝(𝑥) e 𝑞 𝑥 |𝑔(𝑥), prove que 

𝑞 𝑥 |[𝑝 𝑥  + 𝑔 𝑥 ], 𝑞 𝑥 |𝑝(𝑥) ∙ 𝑔(𝑥) e 𝑞 𝑥 |[𝑝 𝑥  − 𝑔 𝑥 ]. 

55) Verificar se o polinômio 𝑝 𝑥  = 𝑥4 + 5𝑥3 − 4𝑥2 + 3𝑥 + 11 é divisível por 𝑥 − 2 e por 

𝑥 + 1. Justifique. 

56) Determinar o quociente e o resto da divisão de 𝑝 𝑥  = 𝑥𝑚 − 𝛼𝑚  por 𝑔 𝑥  = 𝑥 − 𝛼. 

57) Consideremos o polinômio de coeficientes reais 𝑝 𝑥  = 𝑎0 + 𝑎1𝑥 + 𝑎2𝑥2 + ⋯ + 𝑎30𝑥30. 
Se 𝑎0 = 𝑎1 = 𝑎2 = ⋯ = 𝑎30, mostre que 𝑝(𝑥) é divisível por 𝑥 − 1. Generalize. 

58) Mostre que se 𝑝(𝑥) é divisível por 𝑥 − 𝛼, então 𝑝 𝛼  = 0. 

59) Seja  𝑝(𝑥) ∈ ℝ[𝑥] um  polinômio tal que  𝑝 2  = 1, 𝑝 1  = 2 e  𝑝 3  = −1. Utilizando a 

interpolação de Lagrange, determine 𝑝(𝑥). 

60) Encontre o polinômio 𝑝(𝑥), de coeficientes reais, que atende as seguintes condições: 

𝑝 𝑎  = 𝑏, 𝑝 𝑏  = 𝑐,  𝑝 𝑐  = 𝑑 e 𝑝 𝑑  = 𝑎. 

7.4  CÓDIGOS CORRETORES DE ERROS 

61)  Considere  um  código  𝐶  linear  de  comprimento  𝑛 = 4  sobre  o  corpo  galoisiano  𝐹{0,1}, 
obtido  da  seguinte  maneira:  para  cada  𝑥1𝑥2 ∈ 𝐹2,  obtemos  o  elemento  𝑥2𝑥1𝑥2𝑥1 ∈ 𝐹4. 
Determinar a distância mínima de 𝐶 e a capacidade de correção desse código. 

62) Mostre que a distância de Hamming cumpre as condições necessárias para caracterizá-la 

como uma métrica. 

63)  Mostre  que  os  códigos  𝐶 =  00000, 00100, 01010   e  𝐶′ =  00000, 10000, 10101  

contidos em 𝐹5 possuem os mesmos parâmetros porém, não são equivalentes. 

 
 
 
 
 
 
 
 
 
 
 
 
160 

64) Imagine que um braço mecânico que possua os movimentos: “para cima”, “para baixo”, 

“para  a  esquerda”  e  “para  a  direita”.  Além  disso,  o  mesmo  possua  uma  base  móvel  que  se 

desloca horizontalmente locomovendo o braço, com comandos: “para o norte”, “para o sul”, 

“para o leste” e “para o oeste”. 

Construa um código de fonte sobre 𝐹 =  0,1  e um código de canal 𝐶 para esses comandos. 

𝐶 é um código perfeito? Justifique. 

65) Obtenha uma matriz geradora para o código 𝐶 do problema anterior. 

66)  Dado  um 

código  𝐶  definido 

sobre  𝐹 = {0,1}, 

com  matriz  geradora 

𝐺 =  

1
1
1
0

1
0
0
1

1
0
0
0

0
1
0
1

0
1
0
0

0
0
1
1

0
0
1
0

 ,  obtenha  uma  matriz  geradora  para  𝐶  que  se  apresente  na  forma 

padrão 𝐺′ =   𝐼4 𝐴 , onde 𝐴 é uma matriz de ordem 𝑘 × (𝑛 − 𝑘). Mostre ainda que existe um 
código  𝐶′  equivalente  ao  código  𝐶,  tal  que  sua  matriz  geradora  na  forma  padrão  seja  𝐺′′ =
  𝐵 𝐼4 , onde 𝐵 é uma matriz de ordem 𝑘 × (𝑛 − 𝑘). 

67)  Obtenha  a  matriz  teste  de  paridade  𝐻  do  código  𝐶  do  exercício  64,  apresentando-a  na 

forma padrão. 

68) Seja 𝐶 um código sobre 𝐹 = {0,1}, cuja matriz geradora seja 𝐺 =  

1
0
0

0
0
1

1
1
0

0
1
1

0
1
0

 . 

a) Determine o comprimento, a dimensão e o número de elementos do código 𝐶; 

b) Encontre uma matriz teste de paridade do código 𝐶 e determine a sua distância mínima. 

69) Seja 𝐶 um código sobre 𝐹 = {0,1}, com matriz teste de paridade 𝐻 =  

a) Obtenha a matriz teste de paridade 𝐻′ na forma padrão. 

b) 𝐶 é um código perfeito? Justifique. 

c) Determine todas as palavras do código 𝐶. 

d) Determine os líderes de classes e as síndromes. 

e) Decodifique as mensagens: 𝑣1 = 10101, 𝑣2 = 11111 e 𝑣3 = 10111. 

1
0
1

1
1
1

0
1
1

0
1
0

1
0
0

 . 

 
 
 
 
   
   
   
   
   
   
 
 
   
   
   
   
 
   
   
   
   
70)  Considere  𝐶  um  código  linear  sobre  𝐹 = {0,1}  tal  que  sua  matriz  geradora  seja    𝐺 =

161 

0
0
1
0
0

1
0
0
0
0

0
0
0
1
0

0
1
0
0
0

0
0
0
0
1

0
0
1
0
1

1
0
1
1
0

1
1
1
0
0

1
1
0
0
1

0
1
0
1
1 

. 

a) Determine a dimensão, o comprimento e o número de elementos de 𝐶. 

b) Construa uma matriz teste de paridade 𝐻 do código 𝐶 e determine o peso de 𝐶. 

c) Dada a tabela de informações: 

𝐽 = 01100  𝑃 = 00011  𝑈 = 11001 
𝑒𝑠𝑝𝑎ç𝑜 = 00000  𝐸 = 00001 
𝐹 = 11000 
𝐿 = 01010  𝑄 = 11100  𝑉 = 01110 
𝐺 = 10100  𝑀 = 01001  𝑅 = 10110  𝑋 = 00111 
𝐻 = 10010  𝑁 = 00110 
𝑆 = 10101  𝑍 = 11110 
𝐼 = 10001  𝑂 = 00101  𝑇 = 11010 

𝐴 = 10000 
𝐵 = 01000 
𝐶 = 00100 
𝐷 = 00010 

Utilizando as informações acima, codifique as mensagens: 

𝑚1: RUMO AO SUCESSO 

𝑚2: MUNDO DE PAZ 

71) Calcule uma tabela de líderes e síndromes referentes ao código 𝐶 do problema anterior. 

72) Supondo que no máximo ocorreu um erro por palavra, levando em consideração o código 

𝐶 do exercício 70, decodifique a mensagem: 

1001010011 
0010000000 

1010111010 
0100110011 

1100100101 
1011010011 

0111000001 
1001010010 

0010110011 
1010111010 

73)  Determine  o  polinômio  𝑔(𝑥)  gerador  de  um  código  cíclico  𝐶  sobre  𝐹 = {0,1},  cujo 

comprimento  seja  𝑛 = 9  e  a  dimensão  𝑘 = 5.  A  partir  de  𝑔(𝑥)  determine  uma  matriz  𝐺 

geradora do código 𝐶. 

74) Determine o polinômio de paridade  𝑕(𝑥) do código 𝐶 do problema anterior. A partir de 

𝑕(𝑥), determine uma matriz verificação de paridade do código 𝐶. 

75) Determine o polinômio recíproco 𝑕∗(𝑥) de 𝑕(𝑥) do problema 74. Determine uma matriz 

geradora do código dual 𝐶⊥ de 𝐶. Multiplique essa matriz pela matriz 𝐺 geradora do código 

𝐶. O que acontece? Explique.  

 
 
 
 
 
 
   
   
   
   
   
   
   
   
   
 
 
 
 
 
 
 
 
 
 
 
 
162 

76)  Construa  dez  palavras  na  forma  sistemática  e  na  forma  não  sistemática  de  um  código 

cíclico 𝐶 sobre 𝐹 = {0,1}, cujo polinômio gerador é 𝑔 𝑥  = 1 + 𝑥2 + 𝑥3. 

77)  Considere  o  código  cíclico  𝐶  sobre  𝐹 = {0,1},  de  comprimento  𝑛 = 15  e  dimensão 

𝑘 = 11, cujo polinômio gerador é 𝑔 𝑥  = 1 + 𝑥 + 𝑥4. 

a) Determine a matriz 𝐺 geradora de 𝐶. 

b) Determine o polinômio de paridade do 𝐶. 

c) Determine a matriz teste de paridade 𝐻 do código 𝐶. 

d) Determine o polinômio gerador do código dual de 𝐶. 

e) Coloque as matrizes 𝐺 e 𝐻 na forma padrão. 

78) Supondo que 𝑚 = 10110110010 é uma palavra do código de fonte, escreva essa palavra 

na forma polinomial. Utilize o código 𝐶 do exercício anterior para obter um código de canal 

para 𝑚. Suponha que 𝑐 ∈ 𝐶 é uma palavra, cuja forma polinomial é 𝑐(𝑥), tenha sido enviada 

e,  por  algum  motivo  a  palavra  recebida  tenha  sido  𝑟 𝑥  = 1 + 𝑥3 + 𝑥4 + 𝑥9 + 𝑥10 + 𝑥12. 

Sabendo que ocorreu um único erro nessa transmissão, determine as síndromes de 𝑟(𝑥) e de 

todos os seus desvios cíclicos e decodifique 𝑟(𝑥), corrigindo o erro e determinando 𝑐(𝑥). 

79) Forme grupos com seus alunos. Ofereça mensagens curtas, de no máximo três palavras da 

língua  portuguesa.  Proponha  a  cada  grupo  que  crie  códigos  lineares  de  comprimentos  e 

dimensões diferentes e codifique cada um dos caracteres das mensagens propostas. Compare 

os  resultados.  Teste  a  capacidade  de  detecção  e  correção  de  cada  código  e  eleja  o  mais 

eficiente. Dê bastante ênfase a cada uma das operações e propriedades matriciais utilizadas. 

80) Forme grupos com seus alunos. Ofereça mensagens curtas, de no máximo três palavras da 

língua  portuguesa.  Proponha  a  cada  grupo  que  crie  códigos  cíclicos  de  comprimentos  e 

dimensões  diferentes  e  codifique  cada  um  dos  caracteres  das  mensagens  propostas  dando 

preferência  para  a  forma  polinomial  de  codificação.  Compare  os  resultados.  Teste  a 

capacidade de detecção e correção de cada código e eleja o mais eficiente. Dê bastante ênfase 

a cada uma das operações e propriedades polinomiais utilizadas. 

81)  Forme  grupos  com  seus  alunos.  Ofereça  mensagens  a  serem  decodificadas,  que 

contenham erros, solicite que façam as correções e decodifiquem as mensagens. 

 
 
 
 
 
 
163 

CONSIDERAÇÕES FINAIS 

O  ensino/aprendizagem  de  matemática  no  Brasil,  ao  longo  dos  últimos  anos,  tem 

passado por várias transformações na busca pelo oferecimento de uma educação com melhor 

qualidade aos estudantes do ensino básico. 

Índices  como  o  IDEB  mostram  um  discreto  progresso  na  educação,  porém,  a  passos 

lentos. 

Temos  observado  que  o  distanciamento  entre  matemática  praticada  nas  escolas  e  as 

experiências  vivenciadas  pelos  alunos  em  ambiente  extraescolar  pode  contribuir  de  forma 

negativa para o alcance dos objetivos da educação. A contextualização da matemática consiste 

em uma proposta pedagógica que busca estreitar essa lacuna, apresentando uma matemática 

não  mais  vista  como  uma  mera  disciplina  escolar,  mas  como  uma  necessidade  humana  de 

interpretar o mundo, adaptar-se e interagir com ele. 

Nas relações sociais, a matemática também se faz presente e, portanto, o domínio dos 

seus  conceitos  e  da  sua  linguagem  é  de  fundamental  importância  nessas  relações.  O  sujeito 

Cidadão participa do meio social ao qual está inserido e para tanto, deve ter o conhecimento 

matemático necessário para sua atuação. 

O material apresentado nesse trabalho não tem como objetivo formar especialistas em 

teoria dos códigos corretores de erros e sim usar essa teoria como um fator motivacional ao 

aluno  que,  ao  conhecê-la,  poderá  perceber  o  quão  útil  é  a  matemática.  É  de  extrema 

importância que ao ser utilizada a teoria dos códigos corretores de erros como uma estratégia 

para o ensino de matrizes, determinantes e polinômios, seja dada a devida atenção a cada uma 

das  propriedades  e  operações  utilizadas,  pois,  nessa  teoria,  frequentemente  é  trabalhado 

conceitos  como  matriz  inversa,  matriz  identidade,  transposição  de  matrizes,  operações 

elementares  sobre  linhas,  determinantes,  produto  de  matrizes,  operações  e  propriedades  dos 

polinômios, interpolação de Lagrange, enfim, uma vastidão de operações e propriedades, que 

quando  bem  evidenciadas  durante  o  processo  de  aplicação  na  teoria  dos  códigos,  poderá 

construir um aprendizado consolidado desses conceitos. 

Achamos  importante  ainda  mencionar  que  o  uso  da  teoria  dos  códigos  corretores  de 

erros, por si  só,  não consolidará a aprendizagem dos  conceitos utilizados se for apresentada 

aos alunos meramente como mais um conteúdo a ser estudado. É importante ao profissional 

docente  que,  ao  apresentar  essa  teoria  aos  seus  alunos,  utilize  estratégias  com  ênfase  na 

prática,  sejam  oficinas,  dinâmicas  ou  qualquer  recurso  em  que  os  alunos  tenham  a 

oportunidade de manipular esses conceitos na codificação e decodificação de mensagens, de 

 
 
 
 
 
 
 
 
164 

modo que a sua participação, não apenas como expectador, seja de fundamental importância 

no decorrer desse processo. 

Por fim, além esse trabalho apropriar-se da teoria dos códigos corretores de erros, na 

tentativa  de  contextualizar  a  matemática  ensinada  nas  séries  finais  do  ensino  médio,  tem 

também  como  proposta,  fomentar  a  discussão  sobre  teoria  e  prática,  abstrato  e  concreto, 

escolar  e  extraescolar,  com  intuito  de  incentivar  o  gosto  pela  matemática  com  toda  sua 

abstração e rigor. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
165 

REFERÊNCIAS 

BAHIA,  Flaviano.  Um  primeiro  curso  sobre  códigos  corretores  de  erros.  ERMAC  2010:  I 
Encontro  Regional  de  Matemática  Aplicada  e  Computacional,  2010.  Disponível  em: 
<http://www.ufsj.edu.br/portal2-repositorio/File/i-ermac/anais/minicursos/mc8.pdf> 
acesso 
em 13 de setembro de 2014. 

BARBOSA, Tauan de S.; ASSIS, Aline M. Princípio teóricos dos códigos corretores de erros: 
códigos 
em: 
<seer.ucg.br/index.php/estudos/article/download/3364/1951>  acesso  em  21  de  outubro  de 
2014. 

Disponível 

cíclicos. 

lineares 

e 

BOLDRINI,  José  Luiz  [et  al].  Álgebra  linear.  2.  ed.  São  Paulo:  Harper  &  Row  do  Brasil, 
1980. 

BRASIL,  Secretaria  do  Ensino  Médio.  Parâmetros  Curriculares  Nacionais.  Ensino  Médio. 
Brasília: MEC/SEM, 2002. 

CALLIOLI, Carlos A.; COSTA, Roberto C. F.; DOMINGUES, Hygino H. Álgebra linear e 
aplicações. 7. ed. São Paulo: Atual, 1990. 

COLOMBO, 
em 
<http://www.professores.uff.br/jcolombo/artigos/codigosCiclicosBCH.pdf>  acesso  em  06  de 
agosto de 2014. 

Disponível 

cíclicos: 

Códigos 

códigos 

Jones. 

BCH. 

D’Ambrosio,  Ubiratan.  Educação  matemática:  Da  teoria  à  prática.  23  ed.  Campinas,  SP: 
Papirus, 2012. 

DOMINGUES, Hygino H.; IEZZI, Gelson. Álgebra moderna. 3. ed. São Paulo: Atual, 1982. 

FOGAÇA, 
em: 
<http://educador.brasilescola.com/trabalho-docente/contextualizacao.html>. Acesso em: 02 de 
outubro de 2014. 

Contextualização. 

Disponível 

Jennifer. 

GARCIA, Arnaldo; LEQUAIN, Yves. Elementos de álgebra. 5. ed. Rio de Janeiro: IMPA, 
2010. 

GONÇALVES, Adilson. Introdução à álgebra. 5. ed. Rio de Janeiro: IMPA, 2009. 

GONZÁLEZ,  Mario  Enrique  Duarte.  Monografia  –  Códigos  cíclicos,  anéis  e  corpos. 
Disponível 
em: 
<http://www.ime.unicamp.br/~ftorres/ENSINO/MONOGRAFIAS/mono2_mario.pdf>  acesso 
em 28 de agosto de 2014. 

HENRIQUES, Ana Cláudia C. B. O pensamento matemático avançado e a aprendizagem 
da análise numérica num contexto de actividades de investigação. 2010. Tese (Doutorado 
em  Educação  -  Didáctica  da  Matemática).  Instituto  de  Educação,  Universidade  de  Lisboa, 
Lisboa (Portugal). 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
166 

HERNÁNDEZ,  Cruz 
em: 
<http://paginaspersonales.deusto.es/cruz.borges/Papers/05Codigos.pdf>  acesso  em  21  de 
setembro de 2014. 

Enrique  Borges.  Códigos 

cíclicos.  Disponível 

HOFFMAN, Kenneth; KUNZE, Ray. Álgebra linear. Trad. Renate Watanabe. 2. ed. Rio de 
Janeiro: Livros Técnicos e Científicos Editora S. A., 1979. 

HEFEZ,  Abramo;  FERNANDEZ,  Cecília  S.  Introdução  à  álgebra  linear.  1.  ed.  Rio  de 
Janeiro: Sociedade Brasileira de Matemática, 2012. 

HEFEZ,  Abramo;  VILLELA,  Maria  Lúcia  T.  Códigos  corretores  de  erros.  2.  ed.  Rio  de 
Janeiro: IMPA, 2008. 

–––––––. Polinômios e equações algébricas. 1. ed. Rio de Janeiro: Sociedade Brasileira de 
Matemática, 2012. 

LIMA, Elon Lages. Álgebra linear. 5. ed. Rio de Janeiro: IMPA, 2001. 

LIPSCHUTS,  Seymour.  Álgebra  linear.  Trad.  Roberto  Ribeiro  Baldino.  2.  ed.  Rio  de 
Janeiro: McGRAW-HILL do Brasil LTDA, 1978. 

MENEGHESSO, 
<http://www.dm.ufscar.br/dm/attachments/article/5/monografia_carla%20TCC.pdf> 
em 21 de agosto de 2014. 

corretores 

Códigos 

Carla. 

erros. 

Disponível 

de 

em: 
acesso 

MEYER,  João  Frederico  da  Costa  de  Azevedo  (org.);  CALDEIRA,  Ademir  Donizeti; 
MALHEIROS,  Ana  Paula  dos  Santos.  Modelagem  em  Educação  Matemática.  Belo 
Horizonte: Autêntica Editora, 2011. 

MILIES, César Polcino. Breve introdução à teoria dos códigos corretores de erros. Disponível 
em: < http://www.sbm.org.br/docs/coloquios/CO-1-09.pdf> acesso em 07 de outubro de 2014. 

PIAGET, Jean. Seis estudos de psicologia. Trad. Maria Alice Magalhães D’Amorim e Paulo Sergio 

Lima Silva. 21. ed. Rio de Janeiro: Forense Universitária, 1995.  

POZO,  Juan  Ignacio  e  ECHEVERRÍA,  María  Del  Pui  Pérez.  Aprender  a  resolver 
problemas e resolver problemas para aprender. Porto Alegre: Artes Médicas, 1988. 

SOUZA,  Mário 
<http://semanadoime.mat.ufg.br/up/34/o/min_mario.pdf> acesso em 02 de outubro de 2014. 

erros.  Disponível 

corretores 

Códigos 

José. 

de 

em: 

José 

em 
VOLOCH, 
<http://www.impa.br/opencms/pt/biblioteca/cbm/16CBM/16_CBM_87_06.pdf> acesso em 28 
de agosto de 2014. 

erros.  Disponível 

corretores 

Códigos 

Felipe. 

de 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
