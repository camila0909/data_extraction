Universidade do Estado do Rio de Janeiro 

Centro Tecnologia e CiÃªncias 

Instituto de MatemÃ¡tica e Estatistica 

Isaque DamiÃ£o Siqueira Costa 

CÃ³digo de Hamming: detecÃ§Ã£o e correÃ§Ã£o de erros 

Rio de Janeiro 

2018

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Isaque DamiÃ£o Siqueira Costa 

CÃ³digo de Hamming: detecÃ§Ã£o e correÃ§Ã£o de erros 

DissertaÃ§Ã£o  apresentada,  como  requisito  parcial 
para obtenÃ§Ã£o do tÃ­tulo de Mestre, ao Programa de 
PÃ³s-graduaÃ§Ã£o  em  MatemÃ¡tica,  da  Universidade 
do Estado do Rio de Janeiro.  

Orientador: Prof. Dr. Roberto Alfonso Olivares Jara 

Rio de Janeiro 

2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
CATALOGAÃ‡ÃƒO NA FONTE 
UERJ / REDE SIRIUS / BIBLIOTECA CTC-A 

C837 

Costa, Isaque DamiÃ£o Siqueira. 

CÃ³digo de Hamming: detecÃ§Ã£o e correÃ§Ã£o de erros / Isaque DamiÃ£o 

Siqueira Costa â€“ 2018.  

65 f. : il. 

Orientador: Roberto Alfonso Olivares Jara. 
DissertaÃ§Ã£o (Mestrado Profissional em MatemÃ¡tica em Rede 
Nacional) - Universidade do Estado do Rio de Janeiro, Instituto de 
MatemÃ¡tica e EstatÃ­stica. 

1. AnÃ¡lise numÃ©rica â€“ Processamento de dados â€“ Teses. I. Jara, 

Roberto Alfonso Olivares. II. Universidade do Estado do Rio de 
Janeiro. PROFMAT.  III. TÃ­tulo. 

CDU 519.6 

Patricia Bello Meijinhos â€“ CRB-7/5217 â€“ ResponsÃ¡vel pela elaboraÃ§Ã£o da ficha catalogrÃ¡fica 

Autorizo para fins acadÃªmicos e cientÃ­ficos, a reproduÃ§Ã£o total ou parcial desta dissertaÃ§Ã£o, 
desde que citada a fonte. 

______________________________  

________________________ 

Assinatura  

Data 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Isaque DamiÃ£o Siqueira Costa 

CÃ³digo de Hamming: detecÃ§Ã£o e correÃ§Ã£o de erros 

DissertaÃ§Ã£o  apresentada,  como  requisito  parcial 
para obtenÃ§Ã£o do tÃ­tulo de Mestre, ao Programa de 
Mestrado  Profissional  em  MatemÃ¡tica,  da 
Universidade do Estado do Rio de Janeiro.  

Aprovada em 27 de fevereiro de 2018. 

Banca Examinadora   

_____________________________________________ 
Prof. Dr. Roberto Alfonso Olivares Jara (Orientador) 
Instituto de MatemÃ¡tica e EstatÃ­stica - UERJ 

_____________________________________________ 
ProfÂª. Dra. PatrÃ­cia Nunes da Silva 
Instituto de MatemÃ¡tica e EstatÃ­stica - UERJ 

_____________________________________________ 
Prof. Dr. Johnny Villavicencio Tafur 
Centro UniversitÃ¡rio Carioca 

Rio de Janeiro 

2018

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
DEDICATÃ“RIA 

Ã€ memÃ³ria do prof. Elon Lages Lima. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

NÃ£o posso deixar de agradecer ao meu orientador, pelo comprometimento, seriedade, 

apoio  e  todo  esforÃ§o  que  dedicou,  a  despeito  dos  problemas  mÃ©dicos  que  teve  (desejo 

melhoras!). E pelo seu olhar rigoroso, que escrutinou cada detalhe deste trabalho, acusando com 

propriedade  desde  os  meus  erros  matemÃ¡ticos  atÃ©  os  de  estilo  e  gramÃ¡tica  â€“  apesar  de  o 

portuguÃªs nÃ£o ser sua lÃ­ngua materna. 

AgradeÃ§o  aos  meus  pais,  que  sempre  se  orgulharam  de  mim,  mesmo  talvez  nÃ£o 

entendendo  muito  bem  o  que  Ã©  MatemÃ¡tica,  nem  para  que  serve  exatamente  um  curso  de 

Mestrado. Nem mesmo â€œa quem terÃ¡ puxado esse garoto para escolher fazer uma coisas dessas 

da sua vida? Puxa, criei com tanto carinho!â€. 

AgradeÃ§o  aos  Mestres  que  tive,  colegas  professores  e  excelentes  alunos  com  quem 

aprendi e continuo aprendendo. 

Mas o meu maior agradecimento tem de ser para minha grande companheira de vida, 

Josineia Mendes da Costa, que estÃ¡ tÃ£o presente e de modo tÃ£o impactante hÃ¡ tanto tempo em 

minha histÃ³ria que chega a ser impossÃ­vel dimensionar sua importÃ¢ncia. Eu nÃ£o seria professor 

de MatemÃ¡tica se nÃ£o fosse pela sua influÃªncia. Mas nÃ£o Ã© sÃ³ isso. Eu nÃ£o teria ido aos lugares 

que eu fui, tomado as decisÃµes que tomei, conhecido as mÃºsicas que ouÃ§o, abraÃ§ado as ideias 

que defendo, nÃ£o moraria onde moro, nÃ£o usaria as roupas que visto, nÃ£o seria feliz como eu 

sou.  Eu  simplesmente  nÃ£o  existiria,  teria  sido  uma  pessoa  completamente  diferente. 

Irreconhecivel. Um estranho pra mim mesmo. Mas por um capricho do cosmos, do destino, do 

universo, das leis da probabilidade quÃ¢ntica â€“ o que seja â€“ nos encontramos. E por isso, para o 

bem ou para o mal, eu sou quem eu sou. E ela Ã© quem Ã©. E nÃ³s somos um. 

 
 
 
 
 
 
 
 
 
 
 
 
Um problema que vale a pena ser atacado prova seu valor contra-atacando  

Piet Hein 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

COSTA, Isaque DamiÃ£o Siqueira. CÃ³digo de Hamming: detecÃ§Ã£o e correÃ§Ã£o de erros. 2018. 
65 f. DissertaÃ§Ã£o (Mestrado em MatemÃ¡tica) â€“ PROFMAT, Universidade do Estado do Rio 
de Janeiro, Rio de Janeiro, 2018. 

Neste  trabalho,  vamos  estudar  o  uso  de  cÃ³digos  para  transmissÃµes  mecÃ¢nicas  e 
eletrÃ´nicas de dados, e os mÃ©todos matemÃ¡ticos usados para a detecÃ§Ã£o e correÃ§Ã£o de erros de 
envio. A detecÃ§Ã£o de erros serÃ¡ feita por dÃ­gitos de checagem, exemplificadas nos seguintes 
cÃ³digos: CPF, UPC e ISBN. Para correÃ§Ã£o de erros, veremos os cÃ³digos de Hamming. 

Palavras-chave: CÃ³digo de Hamming. CorreÃ§Ã£o de erros. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ABSTRACT 

COSTA, Isaque DamiÃ£o Siqueira. Hammingâ€™s code: error detection and correction. 2018. 65 
f. DissertaÃ§Ã£o (Mestrado em MatemÃ¡tica) â€“ PROFMAT, Universidade do Estado do Rio de 
Janeiro, Rio de Janeiro, 2018. 

In  this  work,  we  will  study  the  use  of  codes  for  mechanical  and  electronic  data 
transmissions, and the mathematical methods used for the detection and correction of sending 
errors. Error detection will be made by check digits, exemplified in the following codes: CPF, 
UPC and ISBN. For error correction, we will see the Hamming codes.  

Keywords: Hamming codes. Error correction. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1 â€“ 

Visor da calculadora.................................................................................. 

Figura 2 â€“ 

CÃ³digo de barras........................................................................................ 

Figura 3 â€“ 

CÃ³digo de barras........................................................................................ 

24 

32 

33 

Figura 4 â€“ 

RelatÃ³rio de processamento....................................................................... 

35 

Figura 5 â€“ 

CÃ³digo de barras........................................................................................ 

38 

 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE TABELAS 

Tabela 1 â€“ 

AdiÃ§Ã£o 

em 

18 

em 

1 

2 

3 

18 

25 

25 

26 

26 

28 

29 

31 

32 

37 

38 

40 

42 

43 

Tabela 

10- 

Tabela 

11- 

Tabela 2 â€“ 

â„¤2................................................................................................... 

Tabela 3 â€“ 

MultiplicaÃ§Ã£o 

Tabela 4 â€“ 

â„¤2........................................................................................ 

Tabela 5 â€“ 

Tabela 

Tabela 6 â€“ 

ASCII................................................................................................... 

Tabela 7 â€“ 

CÃ³digo 

guindaste 

Tabela 8 â€“ 

......................................................................................... 

Tabela 9 â€“ 

CÃ³digo 

guindaste 

......................................................................................... 

CÃ³digo 

guindaste 

......................................................................................... 

Codigo 

SDR1................................................................................................... 

Tabela 

Codigo 

12- 

SDR2................................................................................................... 

Tabela 

AdiÃ§Ã£o 

13- 

â„¤10................................................................................................. 

Tabela 

MultiplicaÃ§Ã£o 

14- 

Tabela 

15- 

â„¤10.......................................................................................  AdiÃ§Ã£o 

â„¤11................................................................................................. 

MultiplicaÃ§Ã£o 

â„¤11....................................................................................... 

ComparaÃ§Ã£o 

em 

em 

em 

em 

de 

cÃ³digos...................................................................................  Hamming  1 

...................................................................................................... 

Hamming 

2 

...................................................................................................... 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE ABREVIATURAS E SIGLAS 

ASCII 

American Standard Code for Information Interchange 

CPF 

Cadastro de Pessoas FÃ­sicas 

ISBN  

International Standard Book Number 

LD  

LI  

UPC  

SDR 

Linearmente dependente 

Linearmente independente 

Universal Product Code 

Sistema de direcionamento remote 

 
 
 
 
 
 
SUMÃRIO 

1 

1.1 

1.2 

1.3 

2 

3 

3.1 

3.2 

3.3 

3.4 

4 

4.1 

4.2 

4.3 

4.4 

5 

5.1 

5.2 

6 

INTRODUÃ‡ÃƒO.............................................................................................. 

RESULTADOS PRELIMINARES............................................................... 

AritmÃ©tica modular........................................................................................ 

EspaÃ§o e subespaÃ§o vetorial........................................................................... 

Produto interno, norma e distÃ¢ncia.............................................................. 

CÃ“DIGOS....................................................................................................... 

DETECÃ‡ÃƒO DE ERROS.............................................................................. 

DÃ­gito de checagem......................................................................................... 

UPC: cÃ³digo de barras................................................................................... 

ISBN: cÃ³digo de identificaÃ§Ã£o de livros........................................................ 

CPF: Cadastro de Pessoas FÃ­sicas ............................................................... 

CORREÃ‡ÃƒO DE ERROS............................................................................. 

Matriz  geradora  padrÃ£o  e  matriz  de  verificaÃ§Ã£o  de  paridade 

padrÃ£o............................................................................................................. 

Matriz geradora e matriz de verificaÃ§Ã£o de paridade................................. 

CÃ³digos lineares.............................................................................................. 

CÃ³digos duais e autoduais.............................................................................. 

MÃ‰TRICA DE HAMMING.......................................................................... 

DistÃ¢ncia de Hamming................................................................................... 

CÃ³digos de correÃ§Ã£o de erros......................................................................... 

CÃ“DIGO DE HAMMING............................................................................. 

CONCLUSÃƒO................................................................................................. 

REFERÃŠNCIAS.............................................................................................. 

14 

15 

15 

18 

21 

24 

28 

28 

31 

35 

40 

42 

42 

45 

50 

51 

56 

56 

58 

63 

65 

66 

 
 
 
 
 
 
 
 
 
 
15 

INTRODUÃ‡ÃƒO 

Neste  trabalho,  vamos  estudar  o  uso  de  cÃ³digos  lineares  para  o  envio  de  transmissÃµes 

eletrÃ´nicas,  e  os  mÃ©todos  matemÃ¡ticos  usados  para  a  detecÃ§Ã£o  e  correÃ§Ã£o  de  erros  nessas 

transmissÃµes. Deste modo, teremos a oportunidade de explorar a aplicaÃ§Ã£o de conceitos como 

vetores e matrizes em problemas reais, com a possibilidade de justificar para o aluno do ensino 

mÃ©dio a importÃ¢ncia desses conteÃºdos para alÃ©m da sala de aula. 

A  ubiquidade  da  informÃ¡tica  em  nossos  dias  e  o  exercÃ­cio  da  cidadania  nos  oferecem  uma 

variedade de exemplos, acessÃ­veis pela experiÃªncia quotidiana como os dÃ­gitos verificadores 

dos documentos oficiais de identificaÃ§Ã£o (CPF), os cÃ³digos de barras dos produtos (UPC), o 

sistema ISBN de catalogaÃ§Ã£o de livros, e etc.  

Em seguida, nos concentraremos nos cÃ³digos lineares â€“ em particular nos cÃ³digos Hamming  

para correÃ§Ã£o de erros de transmissÃ£o, tomando como base principalmente Poole (2014). 

 
 
 
 
 
 
 
16 

1. RESULTADOS PRELIMINARES 

1.1. AritmÃ©tica modular 

Apresentamos nesta seÃ§Ã£o, de maneira resumida, uma construÃ§Ã£o e as principais propriedades 

do  conjunto  das  classes  de  congruÃªncias  mÃ³dulo  um  nÃºmero  inteiro.    Tais  resultados  serÃ£o 

utilizados por todo o texto. O leitor interessado em maiores esclarecimentos, ou em aprofundar 

os resultados apresentados aqui, pode consultar Hefez (2002). 

DefiniÃ§Ã£o 1.1.1.  

Sejam ğ‘, ğ‘, ğ‘˜ inteiros com ğ‘˜ > 0.  Dizemos que ğ’‚ Ã© congruente a ğ’ƒ mÃ³dulo ğ’Œ, e escrevemos 

â€œğ‘ â‰¡ ğ‘ mod ğ‘˜â€, quando ğ‘˜ divide ğ‘ âˆ’ ğ‘. 

Exemplo:  25 â‰¡ 13 mod 6,  pois  6  divide  25 âˆ’ 13  = 12.    Analogamente,  âˆ’10 â‰¡ 4 mod 7, 

pois 7 divide âˆ’10  âˆ’ 4  =   âˆ’14.  

DefiniÃ§Ã£o 1.1.2.  

Sejam ğ‘ e ğ‘˜ inteiros com ğ‘˜ > 0.  A classe de congruÃªncia de ğ’‚ mÃ³dulo ğ’Œ, denotada por [ğ‘], 

consiste em todos os nÃºmeros inteiros que sÃ£o congruentes a ğ‘ mÃ³dulo ğ‘˜, isto Ã©, 

Dizer que ğ‘ â‰¡ ğ‘ mod ğ‘˜ significa que ğ‘ âˆ’ ğ‘ = ğ‘›ğ‘˜ para algum inteiro ğ‘› ou, equivalentemente, 

[ğ‘] = {ğ‘: ğ‘  âˆˆ â„¤ ğ‘’ ğ‘  â‰¡  ğ‘ ğ‘šğ‘œğ‘‘ ğ‘˜}. 

que ğ‘ = ğ‘ + ğ‘›ğ‘˜.  Assim 

[ğ‘]   =   {ğ‘  +  ğ‘›ğ‘˜ âˆ¶  ğ‘› âˆˆ â„¤}. 

Exemplo: Na congruÃªncia mÃ³dulo 5 temos 

[11] =   {11  +  5ğ‘›: ğ‘› âˆˆ â„¤} = {11, 11 Â± 5, 11 Â± 10, 11 Â± 15, . . . }  

=   {. . . , âˆ’14, âˆ’9, âˆ’4, 1, 6, 11, 16, 21, 24, . . . }. 

Um importante resultado sobre as classes de congruÃªncias Ã© o seguinte. 

Teorema 1.1.3.   

Seja ğ‘˜ um nÃºmero inteiro maior do que 1. 

i) Se ğ‘ Ã© um nÃºmero inteiro e ğ‘Ÿ Ã© seu resto (0 â‰¤ ğ‘Ÿ < ğ‘˜) quando dividido por ğ‘˜, entÃ£o [ğ‘] = [ğ‘Ÿ]. 

 
 
 
 
 
 
 
 
 
 
 
17 

ii)  Existem  exatamente  ğ‘˜  distintas  classes  de  congruÃªncias  mÃ³dulo  ğ‘˜,  a  saber 

[0], [1], [2], . . . , [ğ‘˜ âˆ’ 1]. 

O conjunto de todas as classes de congruÃªncias modulo ğ‘˜ Ã© denotado por â„¤ğ‘˜, isto Ã©, 

â„¤ğ‘˜ = {[0], [1], [2], . . . , [ğ‘˜ âˆ’ 1]}. 

Em â„¤ğ‘˜ sÃ£o definidas para quaisquer [ğ‘] e [ğ‘] em â„¤ğ‘˜ as seguintes duas operaÃ§Ãµes: 

[ğ‘] + [ğ‘] = [ğ‘ + ğ‘] 

[ğ‘] Ã— [ğ‘] = [ğ‘ Ã— ğ‘]. 

Exemplo: Em â„¤6 temos [3] + [5] = [3 + 5] = [8] = [2] e [2] Ã— [5] = [2 Ã— 5] = [10] =

[4]. 

De agora em diante toda classe de congruÃªncia [ğ‘] serÃ¡ denotada apenas por ğ‘. 

As operaÃ§Ãµes de adiÃ§Ã£o e multiplicaÃ§Ã£o no conjunto â„¤ğ‘˜ possuem as seguintes propriedades para 

quaisquer ğ‘, ğ‘, ğ‘ em â„¤ğ‘˜: 

ProposiÃ§Ã£o 1.1.4.  

Propriedades de â„¤ğ‘˜. 

P1) Comutatividade:   

ğ‘ + ğ‘ = ğ‘ + ğ‘ 

ğ‘ âˆ™ ğ‘ = ğ‘ âˆ™ ğ‘ 

P2) Associatividade:   

(ğ‘ + ğ‘) + ğ‘ = ğ‘ + (ğ‘ + ğ‘)  (ğ‘ âˆ™ ğ‘) âˆ™ ğ‘ = ğ‘ âˆ™ (ğ‘ âˆ™ ğ‘) 

P3) ExistÃªncia do elemento neutro:  ğ‘ + 0 = ğ‘ 

ğ‘ âˆ™ 1 = ğ‘. 

P4) ExistÃªncia do elemento oposto:  Para cada ğ‘ âˆˆ â„¤ğ‘˜ existe um Ãºnico elemento âˆ’ğ‘ âˆˆ â„¤ğ‘˜ tal 

que ğ‘  +   (âˆ’ğ‘)   =  0  =   âˆ’ğ‘  +  ğ‘. E âˆ’ğ‘ Ã© chamado o â€œopostoâ€ de ğ‘. 

P5) Distributividade:   

(ğ‘ + ğ‘) âˆ™ ğ‘ = ğ‘ âˆ™ ğ‘ + ğ‘ âˆ™ ğ‘. 

Em geral, qualquer conjunto munido de duas operaÃ§Ãµes (adiÃ§Ã£o e multiplicaÃ§Ã£o) satisfazendo 

as cinco propriedades acima Ã© chamado de anel comutativo com identidade.  Os Principais 

modelos para essa estrutura algÃ©brica sÃ£o o conjunto â„¤ dos nÃºmeros inteiros e o conjunto â„¤ğ‘˜. 

Um diferencial entre anÃ©is, e em particular entre os anÃ©is â„¤ e â„¤ğ‘˜, Ã© o seguinte:  

DefiniÃ§Ã£o 1.1.5.  

Um domÃ­nio de integridade Ã© um anel comutativo com identidade que satisfaz a propriedade: 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
18 

P6) Se  ğ‘ âˆ™ ğ‘ = 0, entÃ£o ğ‘ = 0 ou ğ‘ = 0. 

Equivalentemente, num domÃ­nio de integridade, o produto de dois elementos nÃ£o nulos Ã© nÃ£o 

nulo. Sabe-se que â„¤ goza dessa propriedade e â„¤ğ‘˜ nÃ£o. De fato, em â„¤10 por exemplo, tem-se que 

2 â‰  0 e 5 â‰  0, mas 2 âˆ™ 5  =  10  =  0. 

Um caso muito importante, tratando-se da estrutura algÃ©brica de â„¤ğ‘˜, acontece quando ğ‘˜ = ğ‘ Ã© 

um nÃºmero primo.  Observe primeiramente que em â„¤ os Ãºnicos elementos que possuem inverso 

(multiplicativo) sÃ£o 1 e âˆ’1 enquanto que em â„¤ğ‘ todos os elementos nÃ£o nulos possuem inverso 

(lembre que um elemento ğ‘ âˆˆ â„¤ğ‘˜ Ã© invertÃ­vel se, e somente se, ğ‘šğ‘‘ğ‘(ğ‘, ğ‘˜)   =  1)) . DaÃ­ segue 

que â„¤ğ‘ com ğ‘ primo se enquadra na seguinte estrutura. 

DefiniÃ§Ã£o 1.1.6.   

Um corpo Ã© um anel comutativo com identidade que satisfaz a propriedade: 

P7) Para cada  ğ‘ â‰  0, existe um  Ãºnico elemento  ğ‘âˆ’1 tal que  ğ‘ âˆ™ ğ‘âˆ’1 = ğ‘âˆ’1 âˆ™ ğ‘ = 1. E  ğ‘âˆ’1 Ã© 

chamado o â€œinversoâ€ de ğ‘. 

Exemplo: Em â„¤5, os elementos 1, 2, 3, e 4 sÃ£o invertÃ­veis e: 
1âˆ’1 = 1 

2âˆ’1 = 3  

3âˆ’1 = 2  

4âˆ’1 = 4 

Os principais modelos para a estrutura de corpo sÃ£o os conjuntos numÃ©ricos â„š dos nÃºmeros 

racionais,  â„  dos  nÃºmeros  reais,  juntamente  com  o  conjunto  â„¤ğ‘  de  todas  as  classes  de 

congruÃªncias mÃ³dulo um primo ğ‘. 

CorolÃ¡rio 1.1.7. Todo corpo Ã© um domÃ­nio de integridade1. 

DemonstraÃ§Ã£o.  Suponha que ğ‘ âˆ™ ğ‘ = 0.  Se ğ‘ = 0 nÃ£o hÃ¡ o que demonstrar. Suponha agora 

que ğ‘ â‰  0.  Logo ğ‘ Ã© invertÃ­vel (isto Ã©, existe ğ‘âˆ’1 no corpo). Multiplicando pelo inverso de ğ‘ 

na igualdade ğ‘ âˆ™ ğ‘ = 0 temos: 

ğ‘âˆ’1 âˆ™ ğ‘ âˆ™ ğ‘ = ğ‘âˆ’1 âˆ™ 0 

1 âˆ™  ğ‘  =  0 

ğ‘  =  0. 

1Em particular â„¤ğ’‘ com ğ’‘ primo tambÃ©m o Ã© 

 
 
 
 
 
 
 
 
                                                 
19 

Exemplo: Como 2 Ã© primo, â„¤2 Ã© um corpo, as operaÃ§Ãµes de adiÃ§Ã£o e multiplicaÃ§Ã£o em â„¤2 =

{0, 1} sÃ£o do seguinte modo: 

0 + 0 = 0 

0 + 1 = 1 

1 + 0 = 1 

1 + 1 = 0 

0 âˆ™ 0 = 0 

0 âˆ™ 1 = 0 

1 âˆ™ 0 = 0 

1 âˆ™ 1 = 1 

De forma mais compacta, podemos escrever: 

+ 

0 

1 

0 

0 

1 

1 

1 

0 

âˆ™ 

0 

1 

0 

0 

0 

1 

0 

1 

Tabela 1. AdiÃ§Ã£o em â„¤2. 

Tabela 2. MultiplicaÃ§Ã£o em â„¤2. 

1.2. EspaÃ§o e subespaÃ§o vetorial 

Apresentamos nesta seÃ§Ã£o um resumo dos conceitos de Ã¡lgebra linear que serÃ£o necessÃ¡rios ao 

longo do trabalho. Mais detalhes podem ser obtidos em Poole (2014). 

DefiniÃ§Ã£o 1.2.1. (EspaÃ§o vetorial)  

Um conjunto ğ‘‰ nÃ£o vazio Ã© dito um espaÃ§o vetorial sobre um corpo ğ¾ (por exemplo, â„š, â„ ou 

â„‚), se: 

a) Se ğ‘¢, ğ‘£ âˆˆ ğ‘‰, entÃ£o ğ‘¢ + ğ‘£ âˆˆ ğ‘‰.  

b) Se ğ‘£ âˆˆ ğ‘‰ e ğ‘˜ âˆˆ ğ¾, entÃ£o ğ‘˜ âˆ™ ğ‘£ âˆˆ ğ‘‰.  

Com as seguintes propriedades. 

Considere ğ‘¢, ğ‘£, ğ‘¤ âˆˆ ğ‘‰ e ğ›¼, ğ›½ âˆˆ ğ¾. 

P1) ğ‘¢ + ğ‘£ = ğ‘£ + ğ‘¢. 

P2) (ğ‘¢ + ğ‘£) + ğ‘¤ = ğ‘¢ + (ğ‘£ + ğ‘¤). 

P3) Existe 0 âˆˆ ğ‘‰, tal que para todo ğ‘£ âˆˆ ğ‘‰, temos que: ğ‘£ + 0 = ğ‘£. 

P4) Existe âˆ’ğ‘£ âˆˆ ğ‘‰, tal que para todo ğ‘£ âˆˆ ğ‘‰, temos que: ğ‘£ + (âˆ’ğ‘£) = 0. 

P5) ğ›¼(ğ‘¢ + ğ‘£) = ğ›¼ğ‘¢ + ğ›¼ğ‘£. 

P6) (ğ›¼ + ğ›½)ğ‘£ = ğ›¼ğ‘£ + ğ›½ğ‘£. 

P7) ğ›¼(ğ›½ğ‘¢) = (ğ›¼ğ›½)ğ‘¢. 

P8) 1 âˆ™ ğ‘¢ = ğ‘¢. 

 
 
 
 
 
 
 
 
 
20 

Fazendo ğ¾ = â„, temos os seguintes exemplos de espaÃ§os vetoriais: 

a) â„ğ‘›, com ğ‘› âˆˆ â„•\{0}: conjunto de todas as ğ‘›-uplas de componentes reais. 

b) ğ‘€ğ‘šÃ—ğ‘›(â„): conjunto de todas as matrizes reais de ğ‘š linhas e ğ‘› colunas, com elementos reais. 
c)  {ğ‘ğ‘›ğ‘¥ğ‘› + ğ‘ğ‘›âˆ’1ğ‘¥ğ‘›âˆ’1 + â‹¯ + ğ‘1ğ‘¥ + ğ‘0|ğ‘ğ‘– âˆˆ â„, ğ‘– = 1, 2, â€¦ , ğ‘› }:  conjunto  de 
polinÃ´mios de grau menor ou igual a ğ‘›, incluindo o polinÃ´mio identicamente nulo. 

todos  os 

Fazendo ğ¾ = â„¤ğ‘, com ğ‘ primo, temos que â„¤ğ‘

ğ‘› Ã© um espaÃ§o vetorial. 

ObservaÃ§Ã£o: os elementos de um espaÃ§o vetorial sÃ£o ditos vetores. 

Um cÃ³digo pode ser criado tomando como sÃ­mbolos vetores sobre â„¤ğ‘˜. Definimos â„¤ğ‘˜

ğ‘› o conjunto 
ğ‘› = {(ğ‘¥1, ğ‘¥2, â€¦ . . , ğ‘¥ğ‘›): ğ‘¥1, ğ‘¥2, â€¦ . ğ‘¥ğ‘› âˆˆ

de todos os vetores com ğ‘› coordenadas em â„¤ğ‘˜. Isto Ã©, â„¤ğ‘˜

â„¤ğ‘˜}.  

Quando ğ‘˜ = 2, dizemos que os elementos de â„¤2

ğ‘› formam um cÃ³digo binÃ¡rio de comprimento 

ğ‘›.  Por exemplo, a tabela ASCII Ã© um exemplo de cÃ³digo binÃ¡rio (aceita apenas coordenadas 

iguais a zero ou um) de comprimento 8 (tÃªm exatamente oito coordenadas) e (0, 1, 1, 0, 0, 0, 0, 

1) Ã© um de seus sÃ­mbolos, mais especificamente, o que representa o caractere â€œaâ€. 

DefiniÃ§Ã£o 1.2.3 (SubespaÃ§o vetorial)  

ğ‘Š Ã© subespaÃ§o vetorial de ğ‘‰ se:  

a) ğ‘Š Ã© um subconjunto nÃ£o vazio de ğ‘‰; e 

b) ğ‘Š Ã© um espaÃ§o vetorial, em relaÃ§Ã£o Ã s mesmas operaÃ§Ãµes definidas em V. 

Na prÃ¡tica, para concluir que ğ‘Š Ã© subespaÃ§o vetorial de ğ‘‰, basta verificar que: 

a) 0 âˆˆ ğ‘Š 

b) Se ğ‘¢, ğ‘£ âˆˆ ğ‘Š, entÃ£o ğ‘¢ + ğ‘£ âˆˆ ğ‘Š.  

c) Se ğ‘£ âˆˆ ğ‘Š e ğ‘˜ âˆˆ ğ¾, entÃ£o ğ‘˜ âˆ™ ğ‘£ âˆˆ ğ‘Š.  

ObservaÃ§Ã£o: {0} e ğ‘‰ sÃ£o ditos subespaÃ§os triviais de ğ‘‰. 

SubespaÃ§os vetoriais de â„2: 

a) a origem; 

b) toda reta que contÃ©m a origem; 

c) o prÃ³prio â„2. 

 
 
 
 
 
 
 
 
 
21 

SubespaÃ§os vetoriais de â„3: 

a) a origem; 

b) toda reta que contÃ©m a origem; 

c) todo plano que contÃ©m a origem; 

d) o prÃ³prio â„3. 

2: 
SubespaÃ§os vetoriais de â„¤2

a) {[

]} 

0
0
0
0
0
0

b) {[

] , ğ‘£}, onde ğ‘£ pode ser [

] , [

1
0

0
1

] ou [

1
1

] 

c) {[

] , [

] , [

] , [

1
0

0
1

1
1

2. 
]} que Ã© o prÃ³prio â„¤2

DefiniÃ§Ã£o 1.2.4 (CombinaÃ§Ã£o linear)  

Considere  ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›âˆ’1, ğ‘¢ğ‘› âˆˆ ğ‘‰.  Dizemos  que  ğ‘¢ğ‘›  Ã©  uma  combinaÃ§Ã£o 

linear  de 

ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›âˆ’1 se existem ğ›¼1, ğ›¼2, â€¦ , ğ›¼ğ‘›âˆ’1 âˆˆ ğ¾ tais que: 

ğ‘¢ğ‘› = ğ›¼1ğ‘¢1 + ğ‘2ğ‘¢2 + â‹¯ + ğ›¼ğ‘›âˆ’1ğ‘¢ğ‘›âˆ’1 

DefiniÃ§Ã£o 1.2.5 (DependÃªncia linear)  

Um conjunto ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›âˆ’1, ğ‘¢ğ‘› âˆˆ ğ‘‰ Ã© dito linearmente independente (L.I.) quando: 

ğ›¼1ğ‘¢1 + ğ›¼2ğ‘¢2 + â‹¯ + ğ›¼ğ‘›ğ‘¢ğ‘› = 0 â‡’ ğ›¼1 = ğ›¼2 = â‹¯ = ğ›¼ğ‘› = 0 

Caso  contrÃ¡rio,  o  conjunto  Ã©  dito  linearmente  dependente  (L.D.)  e  existe  um  elemento  do 

conjunto que pode ser escrito como combinaÃ§Ã£o linear dos outros. 

DefiniÃ§Ã£o 1.2.6. (Vetores geradores)  

Se ğµ = {ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›} âŠ‚ ğ‘‰ e todo elemento de ğ‘‰ pode ser escrito como combinaÃ§Ã£o linear dos 

elementos de ğµ, entÃ£o dizemos que ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘› sÃ£o geradores de ğ‘‰ e indicamos por: 

ğ‘”ğ‘’ğ‘Ÿ(ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›) = ğ‘‰ 

O conjunto de geradores de um espaÃ§o vetorial nÃ£o Ã© Ãºnico. 

DefiniÃ§Ã£o 1.2.7 (Base)  

Dizemos que {ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›} Ã© uma base de ğ‘‰, se: 

 
 
 
 
 
 
 
 
 
 
22 

a) ğ‘”ğ‘’ğ‘Ÿ(ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›) = ğ‘‰; e 

b) ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘› sÃ£o L.I. 

Teorema 1.2.8.  

Se ğµ1 = {ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›} e ğµ2 = {ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘š} sÃ£o bases de ğ‘‰, entÃ£o ğ‘š = ğ‘›. 

ObservaÃ§Ã£o. Nas condiÃ§Ãµes do Teorema 1.2.8, dizemos que ğ‘› Ã© a dimensÃ£o de ğ‘‰, e indicamos 

ğ‘‘ğ‘–ğ‘š ğ‘‰ = ğ‘›. 

1.3. Produto interno, norma e distÃ¢ncia 

DefiniÃ§Ã£o 1.3.1 (Produto interno) 

Seja V um espaÃ§o vetorial.  Um Produto interno em V Ã© uma funÃ§Ã£o que a cada par de vetores 

u e v em V associa o nÃºmero real âŒ©ğ‘¢, ğ‘£âŒª que satisfaz as seguintes propriedades: 

1.  âŒ©ğ‘¢, ğ‘£âŒª = âŒ©ğ‘£, ğ‘¢âŒª 

2.  âŒ©ğ‘¢, ğ‘£ + ğ‘¤âŒª = âŒ©ğ‘¢, ğ‘£âŒª + âŒ©ğ‘¢, ğ‘¤âŒª 

3.  âŒ©ğ‘ğ‘¢, ğ‘£âŒª = ğ‘âŒ©ğ‘¢, ğ‘£âŒª 

4.  âŒ©ğ‘¢, ğ‘¢âŒª â‰¥ 0 e âŒ©ğ‘¢, ğ‘¢âŒª = 0 se, e somente se, ğ‘¢ = 0 

Onde ğ‘¢, ğ‘£ e ğ‘¤ sÃ£o quaisquer vetores em V e ğ‘ Ã© qualquer escalar. 

DefiniÃ§Ã£o 1.3.2 (Produto interno usual) 
Sejam ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›) e ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›) em â„ğ‘›.  Definimos 
âŒ©ğ‘¢, ğ‘£âŒª = ğ‘¢1 âˆ™ ğ‘£1 + ğ‘¢2 âˆ™ ğ‘£2 + â‹¯ + ğ‘¢ğ‘› âˆ™ ğ‘£ğ‘›. 

Ã‰ fÃ¡cil ver que a operaÃ§Ã£o acima define um produto interno, chamado de produto interno usual 
de â„ğ‘›.  Sem qualquer problema pode-se considerar tambÃ©m o produto interno usual em â„¤2
vez de â„ğ‘›.  Neste caso, <u, v> ğœ– â„¤2.  
A partir de agora vamos usar a notaÃ§Ã£o ğ‘¢ âˆ™ ğ‘£ para representar o produto interno usual. 

ğ‘› em 

DefiniÃ§Ã£o 1.3.3 (Vetores ortogonais) 

Quando ğ‘¢ âˆ™ ğ‘£ = 0, dizemos que o vetores ğ‘¢ e ğ‘£ sÃ£o ortogonais. 

DefiniÃ§Ã£o 1.3.4 (Norma) 

 
 
 
 
 
 
 
 
 
 
 
23 

Uma norma em um espaÃ§o vetorial V Ã© uma aplicaÃ§Ã£o que associa a cada vetor v  um nÃºmero 

real â€–ğ‘£â€–, chamado norma de v, de modo que as seguintes propriedades sejam satisfeitas para 

todos os vetores u e v e todos os escalares c: 

1.  â€–ğ‘£â€– â‰¥ 0 e â€–ğ‘£â€– = 0 se, e somente se, ğ‘£ = 0 

2.  â€–ğ‘ğ‘£â€– = |ğ‘| âˆ™ â€–ğ‘£â€–  

3.  â€–ğ‘¢ + ğ‘£â€– â‰¤ â€–ğ‘¢â€– + â€–ğ‘£â€–  

Existem vÃ¡rios tipos de norma, segue abaixo dois exemplos. 

DefiniÃ§Ã£o 1.3.5 (Norma do produto interno). 

Em qualquer espaÃ§o vetorial com produto interno, â€–ğ‘£â€– = âˆš< ğ’—, ğ’— > define uma norma. 
Como ilustraÃ§Ã£o, considerando â„ğ‘›com o produto interno usual usual: 

Se ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ ğ‘¢ğ‘›), entÃ£o 

â€–ğ‘¢â€– = âˆšğ’– âˆ™  ğ’– = âˆšğ‘¢1

2 + ğ‘¢2

2 + â‹¯ + ğ‘¢ğ‘›
2 

Exemplo: â€–(3, 4, 0)â€– = âˆš32 + 42 + 02 = 5 

DefiniÃ§Ã£o 1.3.6 (Norma de Hamming) 

Considere o vetor ğ‘¢ âˆˆ â„¤2

ğ‘›, entÃ£o a norma de Hamming Ã© dada por 

â€–ğ‘¢â€–ğ» = ğ‘¤(ğ‘¢) 
Onde ğ‘¤(ğ‘¢) Ã© chamado peso de ğ‘¢ e corresponde Ã  quantidade de 1â€™s que existem no vetor ğ‘¢. 

Exemplo: â€–(1, 0, 1, 0, 1)â€–ğ» = ğ‘¤(1, 0, 1, 0, 1) = 3. 

DefiniÃ§Ã£o 1.3.7 (DistÃ¢ncia) 

Em  qualquer  espaÃ§o  vetorial  normado,  a  distÃ¢ncia  entre  os  vetores ğ‘¢  e  ğ‘£  Ã©  o  nÃºmero  real 

ğ‘‘(ğ‘¢, ğ‘£) = â€–ğ‘¢ âˆ’ ğ‘£â€–.   

As seguintes propriedades sÃ£o vÃ¡lidas para todos os vetores u, v e w em V: 

1.  ğ‘‘(ğ‘¢, ğ‘£) â‰¥ 0 e ğ‘‘(ğ‘¢, ğ‘£) = 0 se, e somente se, ğ‘¢ = ğ‘£. 

2.  ğ‘‘(ğ‘¢, ğ‘£) = ğ‘‘(ğ‘£, ğ‘¢) 

3.  ğ‘‘(ğ‘¢, ğ‘¤) â‰¤ ğ‘‘(ğ‘¢, ğ‘£) + ğ‘‘(ğ‘£, ğ‘¤). 

Para uma demostraÃ§Ã£o das afirmaÃ§Ãµes contidas nas definiÃ§Ãµes 1.3.6 e 1.3.7 veja por exemplo 

o exemplo 4 e o Teorema 1, respectivamente, da seÃ§Ã£o 7.3 do livro de David Pool citado na 

bibliografia. 

 
 
 
 
 
 
 
 
24 

DefiniÃ§Ã£o 1.3.8 (DistÃ¢ncia de Hamming) 

Como em â„¤2, uâˆ’v = u + v, a distÃ¢ncia 

ğ‘‘ğ»(ğ‘¢, ğ‘£) = â€–ğ‘¢ âˆ’ ğ‘£â€–ğ» = â€–ğ‘¢ + ğ‘£â€–ğ» = ğ‘¤(ğ‘¢ + ğ‘£) 

Ã© chamada distÃ¢ncia de Hamming. 

Uma funÃ§Ã£o distÃ£ncia ğ‘‘ com essas propriedades Ã© chamada de mÃ©trica. Um espaÃ§o vetorial 

que possui uma mÃ©trica Ã© chamado de espaÃ§o mÃ©trico.  DaÃ­, a distÃ¢ncia de Hamming  Ã© tambÃ©m 

chamada de mÃ©trica de Hamming. 

 
 
 
 
 
 
25 

2. CÃ“DIGOS 

A funÃ§Ã£o primÃ¡ria de um cÃ³digo Ã© permitir a comunicaÃ§Ã£o de informaÃ§Ãµes. A lÃ­ngua portuguesa, 

com suas palavras e regras para combinÃ¡-las Ã© um bom exemplo de cÃ³digo altamente complexo 

cujo aprendizado Ã© uma tarefa para anos. Essa complexidade Ã© necessÃ¡ria porque a lÃ­ngua exige 

grande versatilidade, para que ela seja apta Ã  codificaÃ§Ã£o dos mais variados assuntos e estilos: 

desde textos tÃ©cnicos cientÃ­ficos, onde se espera o mÃ¡ximo de precisÃ£o; aos textos poÃ©ticos ou 

humorÃ­sticos, onde propositadamente se explora a polissemia e a ambiguidade. 

Por outro lado, um cÃ³digo criado exclusivamente para um assunto mais especÃ­fico pode e deve 

ser mais simples, como, por exemplo, as placas de trÃ¢nsito, que podem ambicionar criar figuras 

e sÃ­mbolos de entendimento universal. Entretanto, algumas vezes o cÃ³digo tem como objetivo 

nÃ£o ser compreendido por pessoas nÃ£o autorizadas. Para esse fim, utiliza-se desde o inÃ­cio da 

civilizaÃ§Ã£o  as  tÃ©cnicas  de  criptografia,  como  o  sistema  do  imperador  romano  CÃ©sar  de 

permutaÃ§Ã£o de letras. 

De acordo com Formiga (2005) 

O primeiro relato de um algoritmo de criptografia que se tem Ã© conhecido como 
algoritmo de CÃ©sar, usado pelo imperador JÃºlio CÃ©sar na Roma Antiga. Era um 
algoritmo simples que fazia substituiÃ§Ãµes alfabÃ©ticas no texto da mensagem. As 
substituiÃ§Ãµes  aconteciam  trocando  letras  por  outras,  trÃªs  posiÃ§Ãµes  Ã   frente  no 
alfabeto, ou seja, a letra A seria substituÃ­da por D, a letra B por E, e assim por 
diante como mostrado a seguir.  

Texto simples: Vamos atacar o norte durante a noite.  
Texto cifrado: Zdprv dxdfdu r qruxh gyudqxh d qrlxh. 

CÃ³digos eletrÃ´nicos 

As mÃ¡quinas de calcular compartilham um modo interessante de codificar os algarismos de um 

nÃºmero. Elas se utilizam de um padrÃ£o de sete barras, no qual algumas sÃ£o iluminadas e outras 

ficam apagadas. Por exemplo, para codificar o algarismo oito, todas as sete barras sÃ£o acesas.  

Figura 1. Visor calculadora 

 
 
 
 
 
 
 
 
 
 
 
26 

Como cada uma das sete barras admite duas possibilidades (acesa ou apagada), cada espaÃ§o no 

visor de uma mÃ¡quina de calcular desse tipo pode codificar atÃ© 27 âˆ’ 1 = 127 sÃ­mbolos. Repare 

que a situaÃ§Ã£o em que as sete barras estÃ£o apagadas nÃ£o codifica sÃ­mbolo algum. 

Uma  estratÃ©gia  semelhante  Ã©  usada  pelos  computadores,  nos  quais  cada  byte  (unidade  de 

armazenamento) Ã© codificado por oito bits. Um bit Ã© um algarismo binÃ¡rio, ou seja, cujo valor 

Ã© zero ou um, que podem ser associados com os estados de desligado e ligado, respectivamente. 

Assim, cada byte Ã© capaz de codificar 28 âˆ’ 1 = 255 sÃ­mbolos. (O byte 00000000 nÃ£o Ã© usado). 

Desta forma, cada sequÃªncia de oito dÃ­gitos cada um deles igual a zero ou um, pode codificar 

um  sÃ­mbolo,  que  pode  ser  uma  letra  maiÃºscula,  minÃºscula,  algarismo,  e  outros.  A  seguir, 

apresentamos uma parte da tabela ASCII, que permite fazer a conversÃ£o entre o conteÃºdo de 

um byte e seu significado.  

Tabela 3. Tabela ASCII .Fonte: Brooksher (2003) 

DetecÃ§Ã£o e correÃ§Ã£o de erros 

Considere o cÃ³digo binÃ¡rio abaixo que controla o braÃ§o de um guindaste. 

COMANDO  CÃ“DIGO 

DESCER 

SUBIR 

0 

1 

Tabela 4. CÃ³digo guindaste 1 

Levando em conta a falta de confiabilidade na transmissÃ£o de informaÃ§Ãµes, a aplicaÃ§Ã£o desse 

cÃ³digo na prÃ¡tica seria no mÃ­nimo imprudente. Imagine que haja um erro no envio que troque 

 
 
 
 
 
 
 
27 

o valor de zero por um. Isso pode fazer, por exemplo, com que a mÃ¡quina tente ir alÃ©m do seu 

limite tÃ©cnico, provocando um acidente. Tudo porque o erro na transmissÃ£o gera uma palavra-

cÃ³digo vÃ¡lida, ou seja, porque o erro nÃ£o pode ser detectado. 

Neste caso, podemos rapidamente vislumbrar uma soluÃ§Ã£o simples: acrescentar mais um dÃ­gito 

pode tornar o cÃ³digo detector de erros. De fato, o cÃ³digo abaixo Ã© detector,  

COMANDO  CÃ“DIGO 

DESCER 

SUBIR 

00 

11 

Tabela 5. CÃ³digo guindaste 2 

pois um erro simples (alteraÃ§Ã£o de apenas uma componente) de envio no cÃ³digo 00 gera 01 ou 

10, que nÃ£o sÃ£o cÃ³digos vÃ¡lidos. O mesmo ocorre se houver um erro simples no envio do cÃ³digo 

11, que pode gerar os cÃ³digos 10 ou 01, ambos invÃ¡lidos.  

Entretanto esse cÃ³digo nÃ£o Ã© corrigÃ­vel, pois se o cÃ³digo recebido for 01 ou 10, o receptor nÃ£o 

poderÃ¡ identificar qual Ã© a mensagem correta. Portanto, nestes casos, seria necessÃ¡rio programar 

um protocolo na mÃ¡quina para solicitar um reenvio do comando. 

Por uma questÃ£o de eficiÃªncia, ou mesmo de necessidade, pode nÃ£o ser desejÃ¡vel ou possÃ­vel 

esperar  por  esse  reenvio.  Seria  preciso,  nestes  casos,  criar  uma  maneira  de  que  a  prÃ³pria 

mÃ¡quina pudesse ser capaz de corrigir o erro sem auxÃ­lio externo, da mesma forma que um 

editor de texto troca a palavra HIPOPÃ“TANO por HIPOPÃ“TAMO. 

Surge a necessidade de criar um cÃ³digo nÃ£o somente detectÃ¡vel, mas tambÃ©m corrigÃ­vel. Veja 

que novamente podemos encontrar a soluÃ§Ã£o na redundÃ¢ncia. Acrescentar um terceiro dÃ­gito ao 

cÃ³digo torna-o corretor de erros. De fato, o cÃ³digo abaixo Ã© corretor, 

COMANDO  CÃ“DIGO 

DESCER 

SUBIR 

000 

111 

Tabela 6. CÃ³digo guindaste 3 

pois:  

Um erro simples de envio em 000 gera: 001, 010, 100. 

Um erro simples de envio em 111 gera: 011, 101, 110. 

Neste  trabalho  estudaremos  alguns  exemplos  de  cÃ³digos  detectores  (CapÃ­tulo  3)  e  veremos 

como criar um cÃ³digo corretor (CapÃ­tulos 4 a 6) de Hamming, e porque eles funcionam. 

 
 
 
 
 
 
 
 
28 

De acordo com Hefez (2008) 

A  Teoria  dos  CÃ³digos  Corretores  de  Erros  foi  fundada  pelo  matemÃ¡tico  C.E. 
Shannon, do LaboratÃ³rio Bell, num trabalho publicado em 1948. Inicialmente, 
os  maiores  interessados  em  Teoria  dos  CÃ³digos  foram  os  matemÃ¡ticos  que  a 
desenvolveram seriamente nas dÃ©cadas de 50 e 60. A partir da dÃ©cada de 70, com 
as pesquisas espaciais e a grande popularizaÃ§Ã£o dos computadores, essa teoria 
comeÃ§ou  a  interessar  tambÃ©m  aos  engenheiros.  Hoje  em  dia,  os  cÃ³digos 
corretores de erros sÃ£o utilizados sempre que se deseja transmitir ou armazenar 
dados,  garantindo  a  sua  confiabilidade.  SÃ£o  exemplos  disso  todas  as 
comunicaÃ§Ãµes via satÃ©lite, as comunicaÃ§Ãµes internas de um computador, [...] ou 
o armazenamento Ã³tico de dados. 

De acordo com Poole (2014) 

Richard  W.  Hamming  (1915  â€“  1988)  obteve  seu  Ph.D  em  MatemÃ¡tica  na 
Universidade de Illinois, em 1942. [...] De 1946 a 1976, trabalhou no Bell Labs, 
depois  integrou-se  ao  corpo  docente  na  US  Naval  Postgraduate  School,  em 
Monterey,  CalifÃ³rnia.    Em  1950,  publicou  seu  trabalho  fundador  em  cÃ³digos 
corretores  de  erros,  dando  uma  construÃ§Ã£o  explÃ­cita  para  os  cÃ³digos  de 
otimizaÃ§Ã£o que Claude Shannon tinha provado serem teoricamente possÃ­veis, em 
19482. 

2Os 

artigos 

originais 

de 

Hamming 

e 

Shannon 

podem 

ser 

acessados 

em: 

http://www.sns.ias.edu/~tlusty/courses/InfoInBio/Papers/Hamming1950.pdf 

e 

http://worrydream.com/refs/Shannon%20-%20A%20Mathematical%20Theory%20of%20Communication.pdf, 

respectivamente. 

 
 
 
 
 
 
 
 
 
 
 
 
 
                                                 
 
29 

3. DETECÃ‡ÃƒO DE ERROS 

Infelizmente, a transmissÃ£o de um cÃ³digo nÃ£o Ã© absolutamente confiÃ¡vel. Do mesmo modo que 

em  uma  conversa  algumas  palavras  podem  nÃ£o  ser  ouvidas  ou  mal  compreendidas  pelo 

interlocutor, tambÃ©m nas comunicaÃ§Ãµes eletrÃ´nicas alguns dados se perdem ou sÃ£o alterados 

durante a transmissÃ£o. Por exemplo, um zero pode ser trocado por um durante o envio de um 

byte. Por esse motivo, Ã© Ãºtil dispor de um mecanismo capaz de identificar a ocorrÃªncia desses 

erros. Neste capÃ­tulo veremos alguns exemplos de cÃ³digos criados com essa motivaÃ§Ã£o. 

3.1. DÃ­gito de checagem 

Considere  um  sistema  de  direÃ§Ã£o  remota  que  receba  apenas  os  quatro  comandos  abaixo. 

Chamaremos o cÃ³digo abaixo de SDR (Sistema de DireÃ§Ã£o Remota). 

COMANDO  CÃ“DIGO 

CIMA 

BAIXO 

001 

010 

ESQUERDA  011 

DIREITA 

100 

Tabela 7. CÃ³digo SDR 1 

Em determinado momento, Ã© possÃ­vel que o cÃ³digo enviado seja 011 (ESQUERDA), mas que 

um erro de transmissÃ£o troque o primeiro dÃ­gito, transmitindo, desta forma, o cÃ³digo incorreto 

111. Como esse cÃ³digo nÃ£o representa nenhum comando Ã© fÃ¡cil perceber que houve um erro de 

envio. Entretanto, se o erro tivesse ocorrido no Ãºltimo digito, o cÃ³digo enviado teria sido 010 

(BAIXO), que Ã© um cÃ³digo vÃ¡lido, e, portanto, o erro nÃ£o seria detectÃ¡vel. 

Uma maneira de contornar esse tipo de situaÃ§Ã£o Ã© inserir um quarto dÃ­gito â€“ que chamaremos 

de dÃ­gito verificador, ou dÃ­gito de checagem â€“ de modo que a soma dos dÃ­gitos do cÃ³digo, em 

â„¤2, seja igual a zero. Por exemplo: 

 
 
 
 
 
 
 
 
 
 
 
 
30 

COMANDO  CÃ“DIGO 

CIMA 

BAIXO 

0011 

0101 

ESQUERDA  0110 

DIREITA 

1001 

Tabela 8. CÃ³digo SDR 2 

Aplicando a aritmÃ©tica da soma no conjunto â„¤2, e a propriedade associativa da adiÃ§Ã£o: 

(((0 + 0) + 1) + 1) = ((0 + 1) + 1) = (1 + 1) = 0 

Analogamente: 

0 + 1 + 0 + 1 = 0 

0 + 1 + 1 + 0 = 0 

1 + 0 + 0 + 1 = 0 

Outra maneira de fazer as somas acima Ã© contar a quantidade de dÃ­gitos iguais a 1 (um). Se essa 

quantidade  for  par,  a  soma  serÃ¡  zero,  se  a  quantidade  for  Ã­mpar,  a  soma  serÃ¡  igual  a  um. 

Portanto, em todo cÃ³digo vÃ¡lido o nÃºmero de dÃ­gitos iguais a um Ã© par. E, no caso de ocorrer 

um erro em apenas um dÃ­gito (ou seja, um erro simples), serÃ¡ gerado um cÃ³digo invÃ¡lido, jÃ¡ 

que a quantidade de dÃ­gitos iguais a um serÃ¡ Ã­mpar. Ou seja, se for recebido um cÃ³digo como 

1011 (erro simples no envio da primeira coordenada de CIMA), entÃ£o serÃ¡ possÃ­vel constatar a 

ocorrÃªncia do erro de envio, pois: 

1 + 0 + 1 + 1 = 1 

Assim, o dispositivo receptor poderÃ¡ solicitar ao emissor o reenvio da informaÃ§Ã£o. Observe que 

o receptor nÃ£o tem condiÃ§Ãµes de corrigir o erro, pois de seu ponto de vista, mesmo que ele saiba 

que houve um erro simples, nÃ£o hÃ¡ como saber em qual das coordenadas ele ocorreu, afinal 

1011 poderia ter se originado de um erro simples na terceira coordenada de DIREITA (1001). 

Outro problema com esse tipo de soluÃ§Ã£o Ã© que um erro em duas coordenadas (mais geralmente, 

em um nÃºmero par de coordenadas) nÃ£o seria detectÃ¡vel, pois a soma de suas coordenadas seria 

igual Ã  zero.  

 
 
 
 
 
 
 
31 

Formalizando, o que estamos fazendo Ã© considerar os vetores  ğ‘¢ e ğ‘ sobre â„¤2
cÃ³digo transmitido, e ğ‘ = [1, 1, 1, 1] Ã© o vetor de checagem. Em seguida, calculamos o produto 

4. O vetor ğ‘¢ Ã© o 

interno ğ‘¢ âˆ™ ğ‘, em â„¤2. Se o resultado for diferente de zero, isso significa que o cÃ³digo Ã© invÃ¡lido. 

DefiniÃ§Ã£o 3.1.1.  

Sejam ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›) e ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›) dois vetores em â„¤ğ‘š

ğ‘› , definimos produto interno 

de ğ‘¢ por ğ‘£, e indicamos por ğ‘¢ âˆ™ ğ‘£ a soma: ğ‘¢1 âˆ™ ğ‘£1 + ğ‘¢2 âˆ™ ğ‘£2 + â‹¯ + ğ‘¢ğ‘› âˆ™ ğ‘£ğ‘›. 

Teorema 3.1.2.  

Sejam os vetores ğ‘¢ e ğ‘ = [1, 1, 1, â€¦ ,1] em â„¤ğ‘š

ğ‘› , e ğ‘£ um vetor obtido trocando exatamente um 

dÃ­gito de ğ‘¢. EntÃ£o ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

DemonstraÃ§Ã£o  

Fazendo ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›), temos que:  

Fazendo ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›), temos que:  

ğ‘¢ âˆ™ ğ‘ = ğ‘¢1 + ğ‘¢2 + â‹¯ + ğ‘¢ğ‘› 

ğ‘£ âˆ™ ğ‘ = ğ‘£1 + ğ‘£2 + â‹¯ + ğ‘£ğ‘› 

Se  ğ‘¢  e  ğ‘£  sÃ£o  idÃªnticos,  exceto  pela  ğ‘˜-Ã©sima  coordenada,  em  sÃ­mbolos:  ğ‘¢ğ‘– = ğ‘£ğ‘–  para  ğ‘– =

1, 2, â€¦ , ğ‘˜ âˆ’ 1, ğ‘˜ + 1, â€¦ ğ‘› e ğ‘¢ğ‘˜ â‰  ğ‘£ğ‘˜, entÃ£o: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ = (ğ‘¢1 âˆ’ ğ‘£1) + (ğ‘¢2 âˆ’ ğ‘£2) + â‹¯ + (ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + â‹¯ + (ğ‘¢ğ‘› âˆ’ ğ‘£ğ‘›)

= 0 + 0 + â‹¯ + ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜ + â‹¯ + 0 = ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜ â‰  0 

Portanto, 

Implicando que: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ â‰  0 

ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘ 

O Teorema 3.1.2 mostra que o vetor de checagem  ğ‘ = [1,1,1, â€¦ ,1]  sempre acusa a ocorrÃªncia 

de erros simples, isto Ã©, em apenas uma coordenada. Nas prÃ³ximas seÃ§Ãµes veremos aplicaÃ§Ãµes 

dessas ideias em cÃ³digos usados na prÃ¡tica. 

3.2. UPC: cÃ³digo de barras 

 
 
 
 
 
 
 
 
 
 
32 

De acordo com Milies (2006), o cÃ³digo UPC (Universal Product Code) foi criado por George 

J.  Laurer  da  IBM  e  passou  a  ser  usado  nos  EUA  e  CanadÃ¡  em  1973.  Esse  cÃ³digo  Ã©  uma 

sequÃªncia de 12 dÃ­gitos decimais (algarismos de 0 a 9), representados, de forma redundante, 

por nÃºmeros e tambÃ©m por barras. Ou seja, o UPC trabalha com vetores em â„¤10

12.  

A  regra  Ã©  parecida  com  a  do  nosso  SDR  (seÃ§Ã£o  3.1.),  mas  com  vetor  de  checagem  ğ‘ =

[3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1].  

Como estamos trabalhando em â„¤10, usaremos as seguintes tabelas: 

+ 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

1 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

2 

2 

3 

4 

5 

6 

7 

8 

9 

0 

1 

3 

3 

4 

5 

6 

7 

8 

9 

0 

1 

2 

4 

4 

5 

6 

7 

8 

9 

0 

1 

2 

3 

5 

5 

6 

7 

8 

9 

0 

1 

2 

3 

4 

6 

6 

7 

8 

9 

0 

1 

2 

3 

4 

5 

7 

7 

8 

9 

0 

1 

2 

3 

4 

5 

6 

8 

8 

9 

0 

1 

2 

3 

4 

5 

6 

7 

Tabela 9. AdiÃ§Ã£o em â„¤10. 

9 

9 

0 

1 

2 

3 

4 

5 

6 

7 

8 

âˆ™ 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

 
 
 
 
 
 
 
 
 
 
 
 
33 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

2 

4 

6 

8 

0 

2 

4 

6 

8 

0 

3 

6 

9 

2 

5 

8 

1 

4 

7 

0 

4 

8 

2 

6 

0 

4 

8 

2 

6 

0 

5 

0 

5 

0 

5 

0 

5 

0 

5 

0 

6 

2 

8 

4 

0 

6 

2 

8 

4 

0 

7 

4 

1 

8 

5 

2 

9 

6 

3 

0 

8 

6 

4 

2 

0 

8 

6 

4 

2 

Tabela 10. MultiplicaÃ§Ã£o em â„¤10. 

0 

9 

8 

7 

6 

5 

4 

3 

2 

1 

Exemplo: Mostrar que o cÃ³digo de barras abaixo Ã© vÃ¡lido. 

Figura 2. CÃ³digo de Barras 

SoluÃ§Ã£o: ğ‘¢ = (1, 8, 8, 1, 1, 4, 7, 7, 1, 2, 1,1) Ã© um cÃ³digo de barras vÃ¡lido, pois: 

ğ‘¢ âˆ™ ğ‘ = 1 âˆ™ 3 + 8 âˆ™ 1 + 8 âˆ™ 3 + 1 âˆ™ 1 + 1 âˆ™ 3 + 4 âˆ™ 1 + 7 âˆ™ 3 + 7 âˆ™ 1 + 1 âˆ™ 3 + 2 âˆ™ 1 + 1 âˆ™ 3 + 1 âˆ™ 1 

= 3(1 + 8 + 1 + 7 + 1 + 1) + (8 + 1 + 4 + 7 + 2 + 1) 

= 3(9) + 3 = 7 + 3 = 0 

Exemplo: Calcular o dÃ­gito verificador ğ‘‘ que torna o cÃ³digo de barras abaixo vÃ¡lido.  

Figura 3. CÃ³digo de Barras 

 
 
 
 
 
 
 
34 

SoluÃ§Ã£o:  

ğ‘¢ âˆ™ ğ‘ = 0 âˆ™ 3 + 2 âˆ™ 1 + 2 âˆ™ 3 + 3 âˆ™ 1 + 3 âˆ™ 3 + 4 âˆ™ 1 + 5 âˆ™ 3 + 4 âˆ™ 1 + 5 âˆ™ 3 + 4 âˆ™ 1 + 5 âˆ™ 3 + 1

âˆ™ ğ‘‘ 

= 3(0 + 2 + 3 + 5 + 5 + 5) + (2 + 3 + 4 + 4 + 4 + ğ‘‘) 

= 3(0) + 7 + ğ‘‘ = 7 + ğ‘‘ = 0 

Portanto, ğ‘‘ = 3 torna esse cÃ³digo vÃ¡lido. 

O teorema a seguir nos garante que o UPC detecta os erros simples. 

Teorema 3.2.1.  

Sejam os vetores ğ‘¢ e ğ‘ = [3,1,3,1,3,1,3,1,3,1,3,1] em â„¤10

12, e ğ‘£ um vetor obtido trocando 

exatamente um dÃ­gito de ğ‘¢. EntÃ£o ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

DemonstraÃ§Ã£o:  

Fazendo ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢12), temos que:  

ğ‘¢ âˆ™ ğ‘ = 3(ğ‘¢1 + ğ‘¢3 + â‹¯ + ğ‘¢11) + (ğ‘¢2 + ğ‘¢4 + â‹¯ + ğ‘¢12) 

Fazendo ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£12), temos que:  

ğ‘£ âˆ™ ğ‘ = 3(ğ‘£1 + ğ‘£3 + â‹¯ + ğ‘£11) + (ğ‘£2 + ğ‘£4 + â‹¯ + ğ‘£12) 

Se  ğ‘¢  e  ğ‘£  sÃ£o  idÃªnticos,  exceto  pela  ğ‘˜-Ã©sima  coordenada,  em  sÃ­mbolos:  ğ‘¢ğ‘– = ğ‘£ğ‘–  para  ğ‘– =

1, 2, â€¦ , ğ‘˜ âˆ’ 1, ğ‘˜ + 1, â€¦ 12 e ğ‘¢ğ‘˜ â‰  ğ‘£ğ‘˜, entÃ£o: 

i) Caso ğ‘˜ Ã© impar: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ = 3[(ğ‘¢1 âˆ’ ğ‘£1) + â‹¯ + (ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + â‹¯ (ğ‘¢11 âˆ’ ğ‘£11)] + (ğ‘¢2 âˆ’ ğ‘£2) + â‹¯

+ (ğ‘¢12 âˆ’ ğ‘£12) = 3(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) 

Como ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜ â‰  0 e 3 Ã© primo com 10, temos que 3(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) â‰  0. Portanto, ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

ii) Caso ğ‘˜ Ã© par: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ = 3[(ğ‘¢1 âˆ’ ğ‘£1) + â‹¯ + (ğ‘¢11 âˆ’ ğ‘£11)] + (ğ‘¢2 âˆ’ ğ‘£2) + â‹¯ + (ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + â‹¯

+ (ğ‘¢12 âˆ’ ğ‘£12) = ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜ â‰  0 

Portanto, ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

O  teorema  abaixo  nos  mostra  o  comportamento  do  UPC  quando  hÃ¡  permuta  de  dÃ­gitos 

adjacentes (o que pode ocorrer no caso de o cÃ³digo ser digitado por uma pessoa). 

 
 
 
 
 
 
 
 
 
35 

Teorema 3.2.2.  

Sejam os vetores ğ‘¢ e  ğ‘ = [3,1,3,1,3,1,3,1,3,1,3,1] em  â„¤10

12, e ğ‘£  um  vetor obtido permutando 

entre  si  dois  dÃ­gitos  adjacentes  de  ğ‘¢.  Se  ğ‘¢ âˆ™ ğ‘ = ğ‘£ âˆ™ ğ‘,  entÃ£o  uma  das  seguintes  situaÃ§Ãµes 

acontece: 

a) os dÃ­gitos permutados sÃ£o iguais entre si; 

b) a diferenÃ§a absoluta entre os dÃ­gitos permutados Ã© igual a cinco.     

DemonstraÃ§Ã£o: 

Fazendo ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢12), temos que:  

ğ‘¢ âˆ™ ğ‘ = 3(ğ‘¢1 + ğ‘¢3 + â‹¯ + ğ‘¢11) + (ğ‘¢2 + ğ‘¢4 + â‹¯ + ğ‘¢12) 

Fazendo ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£12), temos que:  

ğ‘£ âˆ™ ğ‘ = 3(ğ‘£1 + ğ‘£3 + â‹¯ + ğ‘£11) + (ğ‘£2 + ğ‘£4 + â‹¯ + ğ‘£12) 
Se ğ‘¢ e ğ‘£ sÃ£o idÃªnticos, exceto, possivelmente, pelas ğ‘˜-Ã©sima e (ğ‘˜ + 1)-Ã©sima coordenadas, com 

ğ‘˜ Ã­mpar (sem perda de generalidade) em sÃ­mbolos: ğ‘¢ğ‘– = ğ‘£ğ‘– para ğ‘– = 1, 2, â€¦ , ğ‘˜ âˆ’ 1, ğ‘˜ + 2, â€¦ 12 

e ğ‘£ğ‘˜ = ğ‘¢ğ‘˜+1, e  ğ‘£ğ‘˜+1 = ğ‘¢ğ‘˜ entÃ£o: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ = 3[(ğ‘¢1 âˆ’ ğ‘£1) + â‹¯ + (ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + â‹¯ (ğ‘¢11 âˆ’ ğ‘£11)] + (ğ‘¢2 âˆ’ ğ‘£2) + â‹¯

+ (ğ‘¢ğ‘˜+1 âˆ’ ğ‘£ğ‘˜+1) + â‹¯ + (ğ‘¢12 âˆ’ ğ‘£12) = 3(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + (ğ‘¢ğ‘˜+1 âˆ’ ğ‘£ğ‘˜+1)
= 3(ğ‘¢ğ‘˜ âˆ’ ğ‘¢ğ‘˜+1) + (ğ‘¢ğ‘˜+1 âˆ’ ğ‘¢ğ‘˜) = 2ğ‘¢ğ‘˜ âˆ’ 2ğ‘¢ğ‘˜+1 = 2(ğ‘¢ğ‘˜ âˆ’ ğ‘¢ğ‘˜+1) 

Repare que 2(ğ‘¢ğ‘˜ âˆ’ ğ‘¢ğ‘˜+1) = 0 somente nos casos: 

i) ğ‘¢ğ‘˜ = ğ‘¢ğ‘˜+1, ou seja, os dÃ­gitos permutados sÃ£o idÃªnticos (neste caso ğ‘¢ = ğ‘£) ou; 
ii)  |ğ‘¢ğ‘˜ âˆ’ ğ‘¢ğ‘˜+1| = 5,  ou  seja,  a  diferenÃ§a  absoluta  entre  os  dÃ­gitos  permutados  Ã©  cinco,  por 

exemplo 0 e 5, 1 e 6, 2 e 7, 3 e 8, 4 e 9. 

Portanto, o Teorema 3.2.4 nos mostra que nÃ£o Ã© possÃ­vel detectar todos os erros de permuta de 

dÃ­gitos adjacentes no cÃ³digo UPC, o que compromete a sua confiabilidade. Para termos uma 

ideia mais quantitativa do significado disso, vamos resolver um problema. 

Problema 3.2.5.  

Supondo  que  a  escolha  dos  dÃ­gitos  em  uma  palavra  no  cÃ³digo  UPC  seja  aleatÃ³ria,  qual  Ã©  a 

probabilidade de que a diferenÃ§a entre dois dÃ­gitos adjacentes seja igual a cinco? 

SoluÃ§Ã£o:  Dois  dÃ­gitos  adjacentes  (escolhidos  entre  os  algarismos  de  0  a  9,  podendo  haver 

repetiÃ§Ã£o) podem ser escolhidos de 10 Ã— 10 = 100 modos. Dos quais, em dez desses casos a 

diferenÃ§a entre os algarismos Ã© cinco (SÃ£o elas: (0, 5) (1, 6), (2, 7), (3, 8), (4, 9), (5, 0), (6, 1), 

 
 
 
 
 
 
 
36 

(7, 2), (8, 3), (9, 4)). Logo, dados dois dÃ­gitos adjacentes, a probabilidade de a diferenÃ§a entre 

eles seja igual a cinco Ã© 

10

100

= 10%. E dado um cÃ³digo UPC com 12 dÃ­gitos, a probabilidade 

de que haja pelo menos dois adjacentes cuja diferenÃ§a Ã© igual a cinco Ã© 1 âˆ’ (

9

11
)
10

â‰… 0,686. 

Segue abaixo o resultado de um experimento computacional que confirma esses cÃ¡lculos. 

Figura 4. RelatÃ³rio de processamento 

No  experimento,  o  sorteio  foi  repetido  um  milhÃ£o  de  vezes,  e  a  situaÃ§Ã£o  nÃ£o  ocorreu  com 

frequÃªncia 31,38%, ou seja, ocorreu em 68,62% das vezes. Isso nÃ£o quer dizer, entretanto que 

o  UPC  terÃ¡  68,62%  de  probabilidade  de  falhar,  pois  o  simples  fato  de  haver  dÃ­gitos  cuja 

diferenÃ§a seja cinco na palavra-cÃ³digo nÃ£o significa que eles serÃ£o de fato permutadas. 

3.3. ISBN: cÃ³digo de identificaÃ§Ã£o de livros 

O endereÃ§o eletrÃ´nico do representante oficial do ISBN no Brasil explica que: 

O  ISBN  â€“  International  Standard Book Number  â€“ Ã© um  sistema internacional 
padronizado que identifica numericamente os livros segundo o tÃ­tulo, o autor, o 
paÃ­s, a editora, individualizando-os inclusive por ediÃ§Ã£o.  
Criado  em  1967  por  editores  ingleses,  o  sistema  passou  a  ser  amplamente 
empregado, tanto pelos comerciantes de livros quanto pelas bibliotecas, atÃ© ser 
International 
oficializado,  em  1972,  como  norma 
Organization for Standartization - ISO 2108 - 1972. 
O sistema ISBN Ã© controlado pela AgÃªncia Internacional do ISBN, que orienta, 
coordena e delega poderes Ã s agÃªncias nacionais designadas em cada paÃ­s. Desde 

internacional  pela 

 
 
 
 
 
 
 
 
37 

1978, a FundaÃ§Ã£o Biblioteca Nacional representa a AgÃªncia Brasileira, com a 
funÃ§Ã£o de atribuir o nÃºmero de identificaÃ§Ã£o aos livros editados no paÃ­s. 
Uma vez fixada  a identificaÃ§Ã£o,  ela sÃ³ se  aplica  Ã quela obra e  ediÃ§Ã£o, nÃ£o se 
repetindo jamais em outra.  
<http://www.isbn.bn.br/website/o-que-e-isbn>. Acesso em 04/08/2017 

O cÃ³digo ISBN Ã© uma sequÃªncia de 10 dÃ­gitos, podendo assumir os valores de 0 a 10, neste 

Ãºltimo caso, substituÃ­mos 10 por sua representaÃ§Ã£o em algarismos romanos X para que ocupe 

um Ãºnico dÃ­gito. Ou seja, o ISBN trabalha com vetores em â„¤11
[10, 9, 8, 7, 6, 5, 4, 3, 2,1].  

10, com vetor de checagem ğ‘ =

Vale a pena aqui fazer um comentÃ¡rio sobre a estratÃ©gia de escolha das componentes do vetor 

de checagem: 

ï‚·  Quando estudamos o UPC, cujos cÃ¡lculos sÃ£o feitos em â„¤10, vimos que as componentes 

eram 1 ou 3, esses nÃºmeros foram escolhidos por serem primos com 10. PoderÃ­amos 

criar um cÃ³digo igualmente eficiente do pontos de vista da detecÃ§Ã£o de erros, usando os 

nÃºmeros 7 e 9, embora talvez fosse menos eficiente do ponto de vista computacional, 

porque nÃºmeros nÃºmeros maiores geram contas mais trabalhosas. 

ï‚·  JÃ¡ no ISBN, cujos cÃ¡lculos sÃ£o feitos em â„¤11, as componentes podem ser escolhidas de 

modo mais livre, jÃ¡ que todos os valores de 1 a 10 sÃ£o primos com 11. 

Como estamos trabalhando em â„¤11, usaremos as seguintes tabelas: 

+ 

0 

0 

0 

1 

1 

2 

2 

3 

3 

4 

4 

5 

5 

6 

6 

7 

7 

8 

8 

9 

9 

10 

10 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
38 

1 

2 

3 

4 

5 

6 

7 

8 

9 

1 

2 

3 

4 

5 

6 

7 

8 

9 

2 

3 

4 

5 

6 

7 

8 

9 

10 

10 

10 

0 

3 

4 

5 

6 

7 

8 

9 

10 

0 

1 

4 

5 

6 

7 

8 

9 

10 

0 

1 

2 

5 

6 

7 

8 

9 

10 

0 

1 

2 

3 

6 

7 

8 

9 

10 

0 

1 

2 

3 

4 

7 

8 

9 

10 

0 

1 

2 

3 

4 

5 

8 

9 

10 

0 

1 

2 

3 

4 

5 

6 

Tabela 11. AdiÃ§Ã£o em â„¤11. 

9 

10 

10 

0 

1 

2 

3 

4 

5 

6 

7 

0 

1 

2 

3 

4 

5 

6 

7 

8 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

âˆ™ 

0 

1 

2 

0 

0 

0 

0 

1 

0 

1 

2 

2 

0 

2 

4 

3 

0 

3 

6 

4 

0 

4 

8 

5 

0 

5 

10 

6 

0 

6 

1 

7 

0 

7 

3 

8 

0 

8 

5 

9 

0 

9 

7 

10 

0 

10 

9 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
39 

3 

4 

5 

6 

7 

8 

9 

10 

0 

0 

0 

0 

0 

0 

0 

0 

3 

4 

5 

6 

7 

8 

9 

10 

6 

8 

10 

1 

3 

5 

7 

9 

9 

1 

4 

7 

10 

2 

5 

8 

1 

5 

9 

2 

6 

10 

3 

7 

4 

9 

3 

8 

2 

7 

1 

6 

7 

2 

8 

3 

9 

4 

10 

5 

10 

2 

6 

2 

9 

5 

1 

8 

4 

10 

7 

4 

1 

9 

6 

3 

5 

3 

1 

10 

8 

6 

4 

2 

8 

7 

6 

5 

4 

3 

2 

1 

Tabela 12. MultiplicaÃ§Ã£o em â„¤11. 

Exemplo: Mostrar que o cÃ³digo ISBN abaixo Ã© vÃ¡lido. 

SoluÃ§Ã£o: 

Figura 5. CÃ³digo de barras 

ğ‘¢ = (8, 1, 7, 5, 2, 5, 7, 6, 6, 0) Ã© um cÃ³digo de barras vÃ¡lido, pois: 

ğ‘¢ âˆ™ ğ‘ = 8 âˆ™ 10 + 1 âˆ™ 9 + 7 âˆ™ 8 + 5 âˆ™ 7 + 2 âˆ™ 6 + 5 âˆ™ 5 + 7 âˆ™ 4 + 6 âˆ™ 3 + 6 âˆ™ 2 + 0 âˆ™ 1

= 3 + 9 + 1 + 2 + 1 + 3 + 6 + 7 + 1 = 0 

Recorde que os cÃ¡lculos sÃ£o em â„¤11. 

O resultado abaixo nos diz que o ISBN Ã© capaz de detectar erros simples. 

Teorema 3.3.1.  

Sejam  os  vetores  ğ‘¢  e  ğ‘ = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]  em  â„¤11

10,  e  ğ‘£  um  vetor  obtido  trocando 

exatamente um dÃ­gito de ğ‘¢. EntÃ£o ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

DemonstraÃ§Ã£o: 

 
 
 
 
 
 
 
 
 
 
40 

Fazendo ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢10), temos que:  

ğ‘¢ âˆ™ ğ‘ = 10 âˆ™ ğ‘¢1 + 9 âˆ™ ğ‘¢2 + 8 âˆ™ ğ‘¢3 + 7 âˆ™ ğ‘¢4 + 6 âˆ™ ğ‘¢5 + 5 âˆ™ ğ‘¢6 + 4 âˆ™ ğ‘¢7 + 3 âˆ™ ğ‘¢8 + 2 âˆ™ ğ‘¢9 + 1 âˆ™ ğ‘¢10 

Fazendo ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£10), temos que:  

ğ‘£ âˆ™ ğ‘ = 10 âˆ™ ğ‘£1 + 9 âˆ™ ğ‘£2 + 8 âˆ™ ğ‘£3 + 7 âˆ™ ğ‘£4 + 6 âˆ™ ğ‘£5 + 5 âˆ™ ğ‘£6 + 4 âˆ™ ğ‘£7 + 3 âˆ™ ğ‘£8 + 2 âˆ™ ğ‘£9 + 1 âˆ™ ğ‘£10 

Se  ğ‘¢  e  ğ‘£  sÃ£o  idÃªnticos,  exceto  pela  ğ‘˜-Ã©sima  coordenada,  em  sÃ­mbolos:  ğ‘¢ğ‘– = ğ‘£ğ‘–  para  ğ‘– =

1, 2, â€¦ , ğ‘˜ âˆ’ 1, ğ‘˜ + 1, â€¦ 10 e ğ‘¢ğ‘˜ â‰  ğ‘£ğ‘˜, entÃ£o: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ = 10(ğ‘¢1 âˆ’ ğ‘£1) + â‹¯ + (11 âˆ’ ğ‘˜)(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + â‹¯ + 1(ğ‘¢10 âˆ’ ğ‘£10)

= (11 âˆ’ ğ‘˜)(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) 

Mas, 11 âˆ’ ğ‘˜ > 0, ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜ â‰  0 e 11 primo, segue pelo CorolÃ¡rio 1.1.7 que 
 (11 âˆ’ ğ‘˜)(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) â‰  0 . Logo, ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

O  ISBN  tambÃ©m  Ã©  capaz  de  detectar  erros  de  permuta  de  dÃ­gitos  adjacentes  (erros  de 

transposiÃ§Ã£o). 

Teorema 3.3.2.  

Sejam os vetores ğ‘¢ e ğ‘ = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] em â„¤11

10, e ğ‘£ um vetor obtido trocando entre 

si dois dÃ­gitos adjacentes distintos de ğ‘¢. EntÃ£o ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

DemonstraÃ§Ã£o: 

Fazendo ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢10), temos que:  

ğ‘¢ âˆ™ ğ‘ = 10 âˆ™ ğ‘¢1 + 9 âˆ™ ğ‘¢2 + 8 âˆ™ ğ‘¢3 + 7 âˆ™ ğ‘¢4 + 6 âˆ™ ğ‘¢5 + 5 âˆ™ ğ‘¢6 + 4 âˆ™ ğ‘¢7 + 3 âˆ™ ğ‘¢8 + 2 âˆ™ ğ‘¢9 + 1 âˆ™ ğ‘¢10 

Fazendo ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£10), temos que:  

ğ‘£ âˆ™ ğ‘ = 10 âˆ™ ğ‘£1 + 9 âˆ™ ğ‘£2 + 8 âˆ™ ğ‘£3 + 7 âˆ™ ğ‘£4 + 6 âˆ™ ğ‘£5 + 5 âˆ™ ğ‘£6 + 4 âˆ™ ğ‘£7 + 3 âˆ™ ğ‘£8 + 2 âˆ™ ğ‘£9 + 1 âˆ™ ğ‘£10 

Se ğ‘¢ e ğ‘£ sÃ£o idÃªnticos, exceto pelas ğ‘˜-Ã©sima e ğ‘˜ + 1-Ã©sima coordenadas, em sÃ­mbolos: ğ‘¢ğ‘– = ğ‘£ğ‘– 

para ğ‘– = 1, 2, â€¦ , ğ‘˜ âˆ’ 1, ğ‘˜ + 2, â€¦ 10 e ğ‘£ğ‘˜ = ğ‘¢ğ‘˜+1, e  ğ‘£ğ‘˜+1 = ğ‘¢ğ‘˜ entÃ£o: 

ğ‘¢ âˆ™ ğ‘ âˆ’ ğ‘£ âˆ™ ğ‘ = 10(ğ‘¢1 âˆ’ ğ‘£1) + â‹¯ + (11 âˆ’ ğ‘˜)(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + (10 âˆ’ ğ‘˜)(ğ‘¢ğ‘˜+1 âˆ’ ğ‘£ğ‘˜+1) + â‹¯

+ 1(ğ‘¢10 âˆ’ ğ‘£10) = (11 âˆ’ ğ‘˜)(ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜) + (10 âˆ’ ğ‘˜)(ğ‘£ğ‘˜ âˆ’ ğ‘¢ğ‘˜) =   ğ‘¢ğ‘˜ âˆ’ ğ‘£ğ‘˜ â‰  0 

Logo, ğ‘¢ âˆ™ ğ‘ â‰  ğ‘£ âˆ™ ğ‘. 

 
 
 
 
 
 
 
 
 
 
41 

3.4. CPF: Cadastro de Pessoas FÃ­sicas 

O CPF Ã© uma sequÃªncia de 11 dÃ­gitos, podendo assumir os valores de 0 a 9, ou seja, o CPF 
11,  com  dois  vetores  de  checagem  ğ‘1 = [10, 9, 8, 7, 6, 5, 4, 3, 2]  e 

trabalha  com  vetores  em  â„¤10
ğ‘2 = [11, 10, 9, 8, 7, 6, 5, 4, 3, 2]. 

Sejam ğ‘‘1 e ğ‘‘2 os dÃ­gitos verificadores, ou seja, os dois Ãºltimos dÃ­gitos do CPF, e ğ‘¢9 o vetor 

composto pelos primeiros nove dÃ­gitos do CPF. EntÃ£o, ğ‘‘1 = ğ‘¢9 âˆ™ ğ‘1, em â„¤10.  

Seja ğ‘¢10 o vetor de dez componentes cujas nove primeiras correspondem a ğ‘¢9 e Ãºltima Ã© igual 

a ğ‘‘1. EntÃ£o, ğ‘‘2 = ğ‘¢10 âˆ™ ğ‘2, em â„¤10. 

Da mesma forma que o ISBN, o CPF tambÃ©m corrige erros simples e de transposiÃ§Ã£o. 

Detecta 

Detecta 

CÃ“DIGO 

erros 

erros de 

simples  

transposiÃ§Ã£o 

SDR 

UPC 

ISBN 

CPF 

SIM 

SIM 

SIM 

SIM 

NÃƒO 

SIM* 

SIM 

SIM 

Corrige 

erros 

NÃƒO 

NÃƒO 

NÃƒO 

NÃƒO 

Tabela 13. ComparaÃ§Ã£o de cÃ³digos 

*Exceto quando a diferenÃ§a absoluta entre os algarismos transpostos Ã© igual a cinco. 

Vimos que o ISBN tem vantagem de seguranÃ§a sobre o UPC, pois detecta todos os erros de 

transposiÃ§Ã£o. Por outro lado, o UPC tem 11 dÃ­gitos disponÃ­veis para codificaÃ§Ã£o do produto 

(mais o dÃ­gito de checagem), enquanto o ISBN tem apenas 9 dÃ­gitos para isso (mais o dÃ­gito de 

checagem), portanto, o UPC tem vantagem sobre o ISBN na quantidade de produtos possÃ­veis 

de serem catalogados. 

O CPF usa 9 dÃ­gitos para codificaÃ§Ã£o (mais dois dÃ­gitos verificadores), a principio ele poderia 

ser trocado por um sistema similar ao ISBN, com a mesma seguranÃ§a, mas com a vantagem de 

usar apenas um dÃ­gito de checagem. Entretanto, o ISBN tem a desvantagem de usar o X no 

dÃ­gito de checagem, e, tendo em vista que alguns dispositivos nÃ£o permitem a transmissÃ£o do 

X,  por  apresentarem  apenas  teclado  numÃ©rico  (como  telefones),  nestes  casos,  Ã©  necessÃ¡rio 

 
 
 
 
 
 
 
 
42 

trocar o X por zero, o que compromete a detecÃ§Ã£o de erros nesses casos. DaÃ­, o fato de o CPF 

usar apenas algarismos de 0 a 9 Ã© uma vantagem. Por outro lado, o CPF exige dois cÃ¡lculos 

para a checagem, tendo, portanto, uma desvantagem computacional. 

 
 
 
 
 
 
43 

4. CORREÃ‡ÃƒO DE ERROS 

No capÃ­tulo anterior, apresentamos alguns exemplos de cÃ³digos que detectam erros simples, 

mas que nÃ£o possuem a capacidade de corrigi-los. Neste capÃ­tulo apresentamos uma forma de 

criar alguns tipos de cÃ³digos que possam tanto detectar quanto corrigir alguns erros. Dentre eles 

os cÃ³digos de Hamming. 

4.1. Matriz geradora padrÃ£o e matriz de verificaÃ§Ã£o de paridade padrÃ£o 

Veremos um algoritmo, devido a Hamming, que permite: 

a) transformar as palavras de um cÃ³digo binÃ¡rio em palavras corrigÃ­veis (caso em que ocorre 

apenas um erro), multiplicando o vetor original por uma matriz geradora;  

b) identificar o dÃ­gito incorreto, multiplicando o vetor recebido por uma matriz de verificaÃ§Ã£o 

de paridade, para em seguida corrigi-lo. 

O seguinte exemplo servirÃ¡ para ilustrar a abordagem desta seÃ§Ã£o. 

Exemplo:  Considere  a  tabela  abaixo  mostrando  o  cÃ³digo  da  fonte  ou  cÃ³digo  de  mensagem 

correspondente a cada comando: 

COMANDO  CÃ“DIGO 

CIMA 

BAIXO 

00 

01 

ESQUERDA  10 

DIREITA 

11 

Tabela 14. Hamming 1 

Vamos criar um cÃ³digo que detecte e corrija um erro ocorrido em apenas uma coordenada. A 

partir de um cÃ³digo de comprimento ğ‘˜, criaremos um novo cÃ³digo de comprimento ğ‘› (ğ‘› > ğ‘˜), 

acrescentando ğ‘› âˆ’ ğ‘˜ dÃ­gitos ao final de cada cÃ³digo. 

Para isso usaremos duas matrizes: 

 
 
 
 
 
 
 
 
 
 
44 

ï‚·  Uma  matriz  ğº  da  forma  ğº = [

]  de  ordem  ğ‘› Ã— ğ‘˜  que  transforme  um  vetor  de 

ğ¼ğ‘˜
ğ´
ğ‘˜ num vetor de cÃ³digo ğºğ‘¥ em â„¤2

ğ‘› chamada de matriz geradora do 

mensagem ğ‘¥ em â„¤2
cÃ³digo; 

ï‚·  E uma matriz de checagem ğ‘ƒ = [ğµ ğ¼ğ‘›âˆ’ğ‘˜],, de ordem (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘›, chamada matriz de 

verificaÃ§Ã£o de paridade de modo que para cada ğ‘¥ âˆˆ â„¤2

ğ‘˜, se ğ‘ = ğºğ‘¥, entÃ£o ğ‘ƒğ‘ = 0.  

No nosso exemplo particular, consideramos: ğ‘› = 5, ğ‘˜ = 2 e ğ´ = ğµ = [

1 0
1 1
0 1

].  Desta forma, 

  e ğ‘ƒ = [ğ´ ğ¼3] = [

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1

].  DaÃ­, 

ğº = [

ğ¼2
ğ´

] =

ğ‘1 =

[

ğ‘3 =

[

1 0
0 1
1 0
1 1
0 1]
1 0
0 1
1 0
1 1
0 1]
1 0
0 1
1 0
1 1
0 1]

[

[

[

0
0

] =

[

1
0

] =

0
0
0
0
0]
1
0
1
1
0]

[

ğ‘2 =

[

ğ‘4 =

1 0
0 1
1 0
1 1
0 1]
1 0
0 1
1 0
1 1
0 1]

[

[

0
1
0
1
1]
1
1
1
0
1]

[

0
1

] =  

[

1
1

] =

[

Onde ğ‘1, ğ‘2, ğ‘3 e ğ‘4 sÃ£o chamados vetores de cÃ³digo. 

A tabela abaixo mostra os vetores de cÃ³digo associados a cada comando 

COMANDO  CÃ“DIGO 

CIMA 

BAIXO 

00000 

01011 

ESQUERDA  10110 

DIREITA 

11101 

Tabela 15. Hamming 2 

Ã‰  fÃ¡cil  verificar  que  ğ‘ƒğ‘ğ‘–   =  0  para  cada  ğ‘– = 1, 2, 3, 4.    O  que  confirma  que  os  cÃ³digos  sÃ£o 

vÃ¡lidos.  Por exemplo, 

ğ‘ƒğ‘1 = [

1 0 1 0 0
]
1 1 0 1 0
0 1 0 0 1

0
1
0
1
1]

[

= [

0
] confirma que ğ‘1 Ã© um vetor de cÃ³digo vÃ¡lido. 
0
0

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
45 

Por outro lado, se houvesse um erro em alguma componente do vetor de cÃ³digo, digamos ğ‘, = 

[0, 1, 1, 1, 1] com erro na terceira componente de ğ‘2, entÃ£o 

[

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1

]

0
1
1
1
1]

[

= [

1
0
0

] confirma o erro na terceira componente pois o vetor resultante Ã© 

igual ao vetor da terceira coluna da matriz ğ‘ƒ e portanto o erro pode ser corrigido. 

Agora vamos formalizar estas ideias. 

DefiniÃ§Ã£o 4.1.1.  

Sejam ğ‘› e ğ‘˜ dois inteiros positivos com ğ‘˜ < ğ‘›. Toda matriz ğ‘› Ã— ğ‘˜ da forma ğº = [

ğ¼ğ‘˜
ğ´

], em que 

ğ´ Ã© uma matriz de ordem (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘˜ sobre â„¤2 Ã© chamada de matriz geradora padrÃ£o para 
ğ‘›.  
ğ‘˜ em vetores de cÃ³digo em â„¤2
um cÃ³digo binÃ¡rio (ğ’, ğ’Œ) que transforma vetores de cÃ³digo de â„¤2
Qualquer matriz (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘› da forma ğ‘ƒ = [ğµ ğ¼ğ‘›âˆ’ğ‘˜], em que ğµ Ã© uma matriz (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘˜ 

sobre  â„¤2  Ã©  chamada  de  matriz  de  verificaÃ§Ã£o  de  paridade  padrÃ£o.   Dizemos  entÃ£o  que  o 

cÃ³digo tem comprimento ğ‘› e dimensÃ£o ğ‘˜. 

As  matrizes  ğº  e  ğ‘ƒ  do  exemplo  acima  obedecem  a  definiÃ§Ã£o  4.1.1.  Observa-se  ainda  nesse 

exemplo, que a matriz ğ´ que completa a matriz ğº Ã© igual a matriz ğµ que completa a matriz ğ‘ƒ. 

O seguinte resultado diz que esse fato Ã© necessÃ¡rio e suficiente para que ğ‘ƒ seja uma matriz de 

verificaÃ§Ã£o de paridade.   

Teorema 4.1.2.  

Se ğº = [

ğ¼ğ‘˜
ğ´

] for uma matriz geradora padrÃ£o e ğ‘ƒ = [ğµ ğ¼ğ‘›âˆ’ğ‘˜] for uma matriz de verificaÃ§Ã£o 

padrÃ£o, entÃ£o 

(a)  ğ‘ƒ serÃ¡ a matriz de verificaÃ§Ã£o de paridade associada a ğº se, e somente se, ğ´ = ğµ.  

(b) O cÃ³digo binÃ¡rio correspondente (ğ‘›, ğ‘˜) serÃ¡ um corretor de erros (em uma componente) 

se, e somente se, as colunas de ğ‘ƒ forem nÃ£o nulas e distintas. 

DemonstraÃ§Ã£o 

(a) Seja ğ‘ğ‘– a ğ‘–-Ã©sima coluna de ğ´. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
46 

Suponha que ğ‘ƒ e ğº estÃ£o associados ao mesmo cÃ³digo. Isso quer dizer que ğ‘ƒğºğ‘¥ = 0, para todo 

ğ‘¥ âˆˆ â„¤2

ğ‘˜. EntÃ£o:  

ğµğ‘¥ + ğ´ğ‘¥ = (ğµ + ğ´)ğ‘¥ = (ğµğ¼ + ğ¼ğ´)ğ‘¥ = [ğµ ğ¼] [

ğ¼
ğ´

] ğ‘¥ = ğ‘ƒğºğ‘¥ = 0 

ğ‘˜. 
Portanto, ğµğ‘¥ + ğ´ğ‘¥ = 0, ou seja, ğµğ‘¥ = ğ´ğ‘¥3 para todo ğ‘¥ âˆˆ â„¤2

Seja ğ‘¥ = ğ‘’ğ‘– o ğ‘–-Ã©simo vetor de base canÃ´nica de â„¤2

ğ‘˜.  

EntÃ£o: ğ‘ğ‘– = ğµğ‘’ğ‘– = ğ´ğ‘’ğ‘– = ğ‘ğ‘–, para todo ğ‘–.  

Logo, ğµ = ğ´. 

Reciprocamente, suponha que ğµ = ğ´. EntÃ£o: 

ğ‘ƒğºğ‘¥ = [ğµ ğ¼] [

ğ¼
ğµ

] ğ‘¥ = (ğµ + ğµ4)ğ‘¥ = 0ğ‘¥ = 0 

Logo, ğ‘ƒ e ğº estÃ£o associados ao mesmo cÃ³digo. 

(b) Suponha que as colunas de ğ‘ƒ sejam nÃ£o nulas e distintas. Se ğ‘¥ for um vetor de mensagem 

ğ‘˜ e ğ‘ = ğºğ‘¥ for o vetor de cÃ³digo correspondente, entÃ£o: ğ‘ƒğ‘ = 0. 
em â„¤2
Se ğ‘â€² = ğ‘ + ğ‘’ğ‘– Ã© o vetor ğ‘ com um erro na ğ‘–-Ã©sima componente, entÃ£o: 
ğ‘ƒğ‘â€² = ğ‘ƒ(ğ‘ + ğ‘’ğ‘–) = ğ‘ƒğ‘ + ğ‘ƒğ‘’ğ‘– = 0 + ğ‘ğ‘– = ğ‘ğ‘– 
ï‚·  Se ğ‘ğ‘– = 0, entÃ£o um erro na ğ‘–-Ã©sima componente nÃ£o serÃ¡ detectado.  De fato, se ğ‘â€² =

ğ‘ + ğ‘’ğ‘– Ã© um vetor com erro na ğ‘–-Ã©sima componente, entÃ£o ğ‘ƒğ‘â€² = 0. 

ï‚·  Se ğ‘ğ‘– = ğ‘ğ‘— = ğ‘ â‰  0, com ğ‘– â‰  ğ‘—, o erro serÃ¡ detectÃ¡vel, mas nÃ£o corrigÃ­vel, pois nÃ£o serÃ¡ 

possÃ­vel saber se ele ocorreu na  ğ‘–-Ã©sima ou na ğ‘—-Ã©sima componente. De fato, se ğ‘â€² =
ğ‘ + ğ‘’ğ‘–, ou se ğ‘â€² = ğ‘ + ğ‘’ğ‘—, entÃ£o ğ‘ƒğ‘â€² = ğ‘. 

Na verdade, a matriz geradora e a de verificaÃ§Ã£o de paridade sÃ£o definidas de forma menos 

restrita do que foi feito acima. Na seÃ§Ã£o seguinte generalizamos esses conceitos. 

4.2. Matriz geradora e matriz de verificaÃ§Ã£o de paridade  
Para motivar a definiÃ§Ã£o destas matrizes lembre-se primeiramente que a matriz geradora padrÃ£o 

ğ‘› Ã— ğ‘˜ e a de verificaÃ§Ã£o de paridade padrÃ£o de ordem (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘› para um cÃ³digo sÃ£o da forma 

G = [

ğ¼ğ‘˜
ğ´

] e  ğ‘ƒ = [ğµ ğ¼ğ‘›âˆ’ğ‘˜] 

3 Como estamos trabalhando em â„¤ğŸ, ğ‘¨ğ’™ = âˆ’ğ‘¨ğ’™ 
4 Como estamos trabalhando em â„¤ğŸ, ğ‘© + ğ‘© = ğŸ 

 
 
 
 
 
 
                                                 
47 

e, portanto pode-se garantir que as colunas de ğº e as linhas de ğ‘ƒ sÃ£o linearmente independentes.  

Alem disso, pelo Teorema 4.1.2, ğº e ğ‘ƒ sÃ£o associadas ao mesmo cÃ³digo se, e somente se, ğ´ =

ğµ, o que Ã© equivalente a ğ‘ƒğº = 0.  

DefiniÃ§Ã£o 4.2.1  

Para ğ‘› > ğ‘˜, uma matriz ğº, ğ‘› Ã— ğ‘˜, e uma matriz ğ‘ƒ, (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘› (com elementos em â„¤2) sÃ£o 

uma matriz geradora e uma matriz de verificaÃ§Ã£o de paridade, respectivamente, para um 

cÃ³digo binÃ¡rio  ğ¶(ğ‘›, ğ‘˜), se as seguintes condiÃ§Ãµes forem satisfeitas: 

i) As colunas de ğº sÃ£o linearmente independentes. 

ii) As linhas de ğ‘ƒ sÃ£o linearmente independentes. 

iii) ğ‘ƒğº = ğ‘‚. 

ObservaÃ§Ãµes 

1.  Como â„¤2 Ã© um corpo, â„¤2

ğ‘š Ã© um espaÃ§o vetorial sobre â„¤2 para qualquer inteiro positivo 

ğ‘š. 

2.  Se ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘˜ sÃ£o as ğ‘˜ colunas de ğº, entÃ£o, como 

0 = ğ‘ƒğº = ğ‘ƒ[ğ‘£1 ğ‘£2 â€¦ . ğ‘£ğ‘˜] = [ğ‘ƒğ‘£1 ğ‘ƒğ‘£2. . . . . ğ‘ƒğ‘£ğ‘˜] 

Tem-se que ğ‘ƒğ‘£ğ‘– = 0 para cada ğ‘– = 1, 2, . . . , ğ‘˜ e, portanto, cada coluna de ğº Ã© um vetor 
ğ‘˜, ğºğ‘¥ = ğ‘£1ğ‘¥ + ğ‘£2ğ‘¥ +
â‹¯ ğ‘£ğ‘˜ğ‘¥.  DaÃ­, ğ¶ Ã© gerado pelos vetores colunas de ğº. Isto Ã©, ğ¶ Ã© um espaÃ§o coluna de ğº. 

de cÃ³digo em ğ¶. AlÃ©m disso, se ğ‘¥ Ã© um cÃ³digo de mensagem em â„¤2

3.  Sabe-se que o espaÃ§o linha de uma matriz nÃ£o muda com as operaÃ§Ãµes elementares linha 

na matriz e analogamente, o espaÃ§o coluna de uma matriz nÃ£o muda com as operaÃ§Ãµes 

elementares coluna na matriz. 

4.  Para  uma  matriz  com  entradas  em  â„¤2  existem  apenas  duas  operaÃ§Ãµes  elementares 

coluna: permutar duas colunas (C1) e somar uma coluna a outra (C2).  E existem duas 

operaÃ§Ãµes elementares linha: permutar duas linhas (L1) e somar uma linha a outra (L2). 

5.  Se ğ¸ Ã© uma matriz elementar, ğ‘ƒ uma matriz de verificaÃ§Ã£o de paridade e ğ‘ Ã© um vetor 

de cÃ³digo, entÃ£o (ğ¸ğ‘ƒ)ğ‘ = ğ¸(ğ‘ƒğ‘) = ğ¸0 = 0. 

Portanto, ğ¸ğ‘ƒ tambÃ©m Ã© uma matriz de verificaÃ§Ã£o de paridade para ğ¶. 

Essas  observaÃ§Ãµes  mostram  que  existem  muitas  matrizes  geradoras  e  muitas  matrizes  de 

verificaÃ§Ã£o de paridade diferentes para um mesmo cÃ³digo.  

 
 
 
 
 
 
 
48 

Nem sempre Ã© possÃ­vel trazer a matriz geradora ou de verificaÃ§Ã£o de paridade Ã  forma padrÃ£o, 

usando  apenas  operaÃ§Ãµes  elementares  coluna  em  ğº  e  operaÃ§Ãµes  elementares  linha  em  ğ‘ƒ. 

Veremos que para garantir essa possibilidade precisaremos acrescentar uma operaÃ§Ã£o elementar 

linha na matriz ğº e uma operaÃ§Ã£o elementar coluna em ğ‘ƒ.  

Mas antes de enunciar esse resultado precisamos de outra definiÃ§Ã£o. 

DefiniÃ§Ã£o 4.2.2.  

Dizemos que dois cÃ³digos ğ¶1 e ğ¶2 sÃ£o equivalentes quando existe uma matriz de permutaÃ§Ã£o 

ğ‘€ tal que  

{ğ‘€ğ‘¥: ğ‘¥ em ğ¶1}   =   ğ¶2 

Exemplo. Considere o cÃ³digo ğ¶1 = {ğ‘¢1, ğ‘¢2, ğ‘¢3, ğ‘¢4}, onde ğ‘¢1 = [

0
] , ğ‘¢2 = [
0
0

1
] , ğ‘¢3 =
0
0

[

1
]  e ğ‘¢4 = [
0
1

1
1
1

]. E a matriz ğ‘€ = [

0 1 0
1 0 0
0 0 1

]. O efeito da matriz ğ‘€ sobre um vetor ğ‘£ = [

] Ã© 

ğ‘
ğ‘
ğ‘

permutar entre si a primeira e a segunda componentes. De fato: 

ğ‘€ğ‘£ = [

0 1 0
1 0 0
0 0 1

] [

ğ‘
ğ‘
ğ‘

] = [

ğ‘
ğ‘
ğ‘

] 

Repare que a matriz de permutaÃ§Ã£o deve ser quadrada e ter exatamente um elemento igual a 1 

em cada linha e em cada coluna. Os outros elementos devem ser nulos. 

0
Portanto,  ğ¶2 = {ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4,} = {ğ‘€ğ‘¢1, ğ‘€ğ‘¢2, ğ‘€ğ‘¢3, ğ‘€ğ‘¢4} = {[
0
0

] , [

0
1
0

] , [

0
1
1

] , [

1
1
1

]},  o  que  nos 

mostra que os cÃ³digos ğ¶1 e ğ¶2 sÃ£o equivalentes. 

0
Exemplo: ğ¶1 = {[
0
0

] , [

1
0
0

] , [

1
0
1

] , [

0
0
]}  e ğ¶2 = {[
0
0
0
1

] , [

SÃ£o equivalentes pela matriz de permutaÃ§Ã£o ğ‘€ = [

1
0
0

]}   

] , [

] , [

1
1
0

0
1
0
0 0 1
1 0 0
0 1 0

]. 

Das observaÃ§Ãµes anteriores mais o fato de que permutar os elementos dos vetores de cÃ³digo 

corresponde a permutar linhas da matriz geradora e a permutar colunas da matriz de verificaÃ§Ã£o, 

segue o seguinte resultado. 

 
 
 
 
 
 
 
49 

Teorema 4.2.3 

(a) Pode-se trazer Ã  forma padrÃ£o qualquer matriz geradora para um cÃ³digo por intermÃ©dio das 

operaÃ§Ãµes C1, C2 e L1.  Se L1 nÃ£o for usada, tem-se o mesmo cÃ³digo; se L1 for usada, se obtÃ©m 

um cÃ³digo equivalente. 

(b) Pode-se trazer Ã  forma padrÃ£o qualquer matriz de verificaÃ§Ã£o de paridade para um cÃ³digo 

por meio das operaÃ§Ãµes L1, L2 e C1.  Se C1 nÃ£o for usada, obtÃ©m-se o mesmo cÃ³digo; se C1 

for usada, tem-se um cÃ³digo equivalente. 

Vejamos nos prÃ³ximos exemplos como isso pode ser feito. 

Exemplo: Trazer a matriz geradora ğº = [

1 0
1 0
0 1

verificaÃ§Ã£o de paridade correspondente. 

SoluÃ§Ã£o: Basta usar a operaÃ§Ã£o L1 em ğº: 

] para a forma padrÃ£o e encontrar a matriz de 

ğº = [

1 0
]
1 0
0 1

â†’     [
â„“1â†”â„“2

1 0
0 1
1 0

] = [

ğ¼
ğ´

] = ğºâ€² 

Temos que ğ´ = [1 0], e, portanto,  

Seja ğ¶1 o cÃ³digo gerado por ğº, entÃ£o: 

ğ‘ƒ = [ğ´ ğ¼] = [1 0 1] 

[

1 0
1 0
0 1

] [

ğ‘
ğ‘

] = [

ğ‘
ğ‘
ğ‘

] 

ğ‘
ğ‘
ğ¶1 = {[
ğ‘

] : ğ‘, ğ‘ âˆˆ â„¤2} {ğ‘ [

1
1
0

] + ğ‘ [

0
0
1

0
] : ğ‘, ğ‘ âˆˆ â„¤2} = {[
0
0

] , [

1
1
0

] , [

0
0
1

] , [

1
1
1

]} 

Seja ğ¶2 o cÃ³digo gerado por ğºâ€², entÃ£o: 

[

1 0
0 1
1 0

] [

ğ‘
ğ‘

] = [

ğ‘
ğ‘
ğ‘

] 

ğ‘
ğ‘
ğ¶1 = {[
ğ‘

0
1
0
Repare que ğ¶1 e ğ¶2 sÃ£o cÃ³digos equivalentes. Eles admitem a seguinte matriz de permutaÃ§Ã£o: 

0
] : ğ‘, ğ‘ âˆˆ â„¤2} = {[
0
0

] : ğ‘, ğ‘ âˆˆ â„¤2} {ğ‘ [

] + ğ‘ [

1
0
1

1
0
1

0
1
0

1
1
1

] , [

] , [

] , [

]} 

ğ‘€ = [

1 0 0
0 0 1
0 1 0

] 

 
 
 
 
 
 
50 

Essa matriz tem o efeito de permutar a segunda e terceira componentes. 

Exemplo: Trazer a matriz de verificaÃ§Ã£o de paridade ğ‘ƒ = [1 1 0] para a forma padrÃ£o e 

encontrar a matriz geradora correspondente. 

SoluÃ§Ã£o: Basta usar a operaÃ§Ã£o C1 em ğ‘ƒ: 

ğ‘ƒ = [1 1 0]

â†’    [1 0 1] = [ğ´â€²
ğ‘2â†”ğ‘3

ğ¼] = ğ‘ƒâ€² 

E neste caso, a matriz geradora Ã© ğºâ€² = [

ğ¼
ğ´â€²

] = [

1 0
0 1
1 0

] 

Ou entÃ£o, poderÃ­amos fazer: 

ğ‘ƒ = [1 1 0]

â†’    [0 1 1] = [ğ´â€²â€²
ğ‘1â†”ğ‘3

ğ¼] = ğ‘ƒâ€²â€² 

E neste caso, a matriz geradora Ã© ğºâ€²â€² = [

ğ¼
ğ´â€²â€²

] = [

1 0
0 1
0 1

] 

Comparando as duas possÃ­veis matrizes geradoras, verificamos que elas geram cÃ³digos 

equivalentes. 

[

1 0
0 1
1 0

] [

ğ‘
ğ‘

] = [

ğ‘
ğ‘
ğ‘

[

1 0
0 1
0 1

] [

ğ‘
ğ‘

] = [

ğ‘
ğ‘
ğ‘

], que gera o cÃ³digo ğ¶1 = {[

], que gera o cÃ³digo ğ¶2 = {[

0
0
0

] , [

1
0
1

] , [

0
1
0

] , [

1
1
1

]}. 

0
0
0

] , [

1
0
0

] , [

0
1
1

] , [

1
1
1

]}. 

De fato, a matriz de permutaÃ§Ã£o entre eles Ã© ğ‘€ = [

0 1 0
1 0 0
0 0 1

]  

Exemplo: Trazer a matriz de verificaÃ§Ã£o de paridade ğ‘ƒ = [

0 1 0 1
1 0 0 1

] para a forma padrÃ£o 

e encontrar a matriz geradora correspondente. 

SoluÃ§Ã£o: Basta usar a operaÃ§Ã£o C1 em ğ‘ƒ: 

ğ‘ƒ = [

0 1 0 1
1 0 0 1

â†’    [
] ğ‘1â†”ğ‘4
ğ‘2â†”ğ‘3

1 0 1 0
1 0 0 1

] = [ğ´â€²

ğ¼] = ğ‘ƒâ€² 

E neste caso, a matriz geradora Ã© ğºâ€² = [

ğ¼
ğ´â€²

] = [

1 0
0 1
1 0
1 0

]. 

Observe que neste Ãºltimo exemplo ğ‘ƒ nÃ£o corrige erros, pois possui uma coluna nula (Teorema 

4.1.2). 

 
 
 
 
 
 
51 

4.3. CÃ³digos lineares 

DefiniÃ§Ã£o 4.3.1  

Seja ğ‘ um nÃºmero primo. Um cÃ³digo linear p-Ã¡rio Ã© um subespaÃ§o ğ¶5 de â„¤ğ‘

ğ‘›. Em particular, 

para ğ‘ = 2, dizemos que o cÃ³digo linear Ã© binÃ¡rio. 

0
1

1
1

] , [

] , [

Exemplo:  ğ¶1 = {[

]}  nÃ£o  Ã©  subespaÃ§o  de  â„¤2

1
0
portanto, ğ¶1 nÃ£o Ã© um cÃ³digo linear. 
1
1
0
fato, apesar de conter o vetor nulo, ğ¶2 nÃ£o Ã© fechado para a adiÃ§Ã£o, pois: 

0
TambÃ©m o cÃ³digo ğ¶2 = {[
0
0

0
1
0

1
0
1

] , [

] , [

] , [

0
2,  pois  nÃ£o  contÃ©m  o  vetor  nulo  [
0

], 

]} nÃ£o Ã© linear, porque nÃ£o Ã© um subespaÃ§o de â„¤2

3. De 

[

1
0
1

] + [

1
1
0

] = [

0
] âˆ‰ ğ¶2 
1
1

Finalmente, ğ¶ = {[

0
0
0

] , [

0
1
0

] , [

0
1
1

] , [

0
]} Ã© um subespaÃ§o de â„¤2
0
1

3, pois contÃ©m o vetor nulo, e, alÃ©m 

disso, para todo ğ‘¢ e ğ‘£ em ğ¶, temos que ğ‘¢ + ğ‘£ estÃ¡ em ğ¶. De fato, 

i) Para ğ‘¢ = 0, ğ‘¢ + ğ‘£ = ğ‘£ âˆˆ ğ¶. 

ii) Para ğ‘¢ = ğ‘£, ğ‘¢ + ğ‘£ = 0 âˆˆ ğ¶. 

iii) Quanto aos outros casos, os cÃ¡lculos mostram que: 

[

0
1
0

] + [

0
1
1

] = [

0
0
1

] âˆˆ ğ¶, [

0
1
0

] + [

0
0
1

] = [

0
1
1

] âˆˆ ğ¶ e [

0
1
1

] + [

0
0
1

] = [

0
1
0

] âˆˆ ğ¶ 

Portanto, ğ¶ Ã© um cÃ³digo linear. 

Se um cÃ³digo linear binÃ¡rio ğ¶ for um subespaÃ§o de â„¤2

ğ‘›, de dimensÃ£o ğ‘˜, entÃ£o diremos que ğ¶ Ã© 

um cÃ³digo (ğ’, ğ’Œ). 

4.4. CÃ³digos duais e autoduais 

DefiniÃ§Ã£o 4.4.1  

5 â„¤ğ’‘ Ã© o oconjunto de escalares 

 
 
 
 
 
 
 
                                                 
Seja ğ¶ um conjunto de vetores de cÃ³digo em  â„¤2
cÃ³digo dual de ğ¶, Ã© denotado por ğ¶âŠ¥ e definido como segue: 

ğ‘›. O complemento ortogonal  de  ğ¶, chamado 

52 

Exemplo: Considere ğ¶ = {[

ğ‘›: ğ‘ âˆ™ ğ‘¥ = 0, âˆ€ğ‘ âˆˆ ğ¶} 

ğ¶âŠ¥ = {ğ‘¥ âˆˆ â„¤2
1
1
]}. O conjunto de todos os vetores em â„¤2
0
1

] , [

] , [

0
1

] , [

0
0

2 que sÃ£o 

ortogonais a ğ¶ Ã© ğ¶âŠ¥ = {[

0
0

]}. 

Teorema 4.4.2.  

Se ğ¶ Ã© um cÃ³digo binÃ¡rio (ğ‘›, ğ‘˜) com matriz geradora ğº e matriz de verificaÃ§Ã£o de paridade ğ‘ƒ, 

entÃ£o ğ¶âŠ¥ Ã© um cÃ³digo binÃ¡rio (ğ‘›, ğ‘› âˆ’ ğ‘˜) tal que: 

i) ğºğ‘‡ Ã© uma matriz de verificaÃ§Ã£o de paridade de ğ¶âŠ¥. 

ii) ğ‘ƒğ‘‡ Ã© uma matriz geradora para ğ¶âŠ¥. 

DemonstraÃ§Ã£o: Como ğº Ã© uma matriz ğ‘› Ã— ğ‘˜ com colunas linearmente independentes e ğ‘ƒ Ã© 

uma matriz (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘› com linhas linearmente independentes e ğ‘ƒğº = 0. Logo, as linhas de 

ğºğ‘‡ e as colunas de ğ‘ƒğ‘‡ sÃ£o linearmente independentes, e 

ğºğ‘‡ğ‘ƒğ‘‡ = (ğ‘ƒğº)ğ‘‡ = ğ‘‚ğ‘‡ = ğ‘‚ 

Isso mostra que ğºğ‘‡ Ã© a matriz de verificaÃ§Ã£o de paridade para ğ¶âŠ¥ e ğ‘ƒğ‘‡ Ã© uma matriz geradora 

para ğ¶âŠ¥. Como ğ‘ƒâŠ¥ Ã© ğ‘› Ã— (ğ‘› âˆ’ ğ‘˜), ğ¶âŠ¥ Ã© um cÃ³digo (ğ‘›, ğ‘› âˆ’ ğ‘˜). 

Teorema 4.4.3.  

Seja ğ¶ um cÃ³digo linear (ğ‘›, ğ‘˜). Pode-se afirmar que: 

i) O cÃ³digo dual ğ¶âŠ¥ Ã© um cÃ³digo linear (ğ‘›, ğ‘› âˆ’ ğ‘˜). 

ii) ğ¶ contÃ©m 2ğ‘˜ vetores, e ğ¶âŠ¥ contÃ©m 2ğ‘›âˆ’ğ‘˜ vetores. 

DemonstraÃ§Ã£o: 

i) Como ğ¶ Ã© um cÃ³digo linear (ğ‘›, ğ‘˜), ele Ã© um subespaÃ§o de dimensÃ£o ğ‘˜ de â„¤2

ğ‘›. Seu dual Ã© o 

complemento ortogonal de ğ¶ e Ã© tambÃ©m um subespaÃ§o de â„¤2
Para finalizar, basta observar que: 

ğ‘›. Portanto, ğ¶âŠ¥ Ã© um cÃ³digo linear. 

dim ğ¶âŠ¥ = ğ‘› âˆ’ dim ğ¶ = ğ‘› âˆ’ ğ‘˜ 

ii) Seja {ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘˜} uma base para ğ¶. EntÃ£o, os elementos de ğ¶ sÃ£o da forma 

ğ‘£ = ğ‘1ğ‘£1 + ğ‘2ğ‘£2 + â‹¯ + ğ‘ğ‘˜ğ‘£ğ‘˜ 

 
 
 
 
 
 
 
53 

Onde cada  ğ‘ğ‘–  Ã© zero ou um.  Portanto,  existem  duas possibilidades para  ğ‘1, e para cada uma 
delas, duas possibilidades para ğ‘2, e assim por diante. Portanto, sÃ£o 2ğ‘˜ possÃ­veis vetores. 
O mesmo argumento mostra que o seu dual (ğ‘›, ğ‘› âˆ’ ğ‘˜) tem 2ğ‘›âˆ’ğ‘˜ vetores. 

DefiniÃ§Ã£o 4.4.4.  

Um cÃ³digo com a propriedade ğ¶âŠ¥ = ğ¶ Ã© chamado autodual. 

Exemplo: Considere ğ¶ = {[

] , [

0
0

1
]}. O conjunto de todos os vetores em â„¤2
1

2, que sÃ£o ortogonais 

a ğ¶ Ã© ğ¶âŠ¥ = {[

0
0

] , [

1
1

]}. Portanto, ğ¶ Ã© autodual. 

Teorema 4.4.6.  

Seja ğ¶ um cÃ³digo linear. O dual do dual de ğ¶ Ã© o prÃ³prio ğ¶, em sÃ­mbolos: (ğ¶âŠ¥)âŠ¥ = ğ¶. 

DemonstraÃ§Ã£o:  Suponha  que  ğ‘¥ âˆˆ ğ¶.  Para  todo  ğ‘¦ âˆˆ ğ¶âŠ¥,  temos  que  ğ‘¥ âˆ™ ğ‘¦ = 0.  Como  (ğ¶âŠ¥)âŠ¥ 

contÃ©m todos os vetores ortogonais a ğ‘¦, entÃ£o tambÃ©m contÃ©m o vetor ğ‘¥, ou seja, ğ‘¥ âˆˆ (ğ¶âŠ¥)âŠ¥. 

Portanto, ğ¶ âŠ‚ (ğ¶âŠ¥)âŠ¥. 

Suponha  que  ğ‘¥ âˆˆ (ğ¶âŠ¥)âŠ¥.  Para  todo  ğ‘¦ âˆˆ ğ¶âŠ¥,  temos  que  ğ‘¥ âˆ™ ğ‘¦ = 0.  Como  ğ¶  contÃ©m  todos  os 

vetores ortogonais a ğ‘¦, entÃ£o tambÃ©m contÃ©m o vetor ğ‘¥, ou seja, ğ‘¥ âˆˆ ğ¶. Portanto, (ğ¶âŠ¥)âŠ¥ âŠ‚ ğ¶. 

Logo, vale a igualdade: ğ¶ = (ğ¶âŠ¥)âŠ¥. 

CorolÃ¡rio 4.4.7  
Se ğ¶1 e ğ¶2 sÃ£o cÃ³digos lineares (ğ‘›, ğ‘˜) tais que (ğ¶1)âŠ¥ = ğ¶2, entÃ£o (ğ¶2)âŠ¥ = ğ¶1. 
DemonstraÃ§Ã£o Se (ğ¶1)âŠ¥ = ğ¶2, entÃ£o ((ğ¶1)âŠ¥)âŠ¥ = (ğ¶2)âŠ¥. Do teorema anterior, ((ğ¶1)âŠ¥)âŠ¥ = ğ¶1. 
Logo, ğ¶1 = (ğ¶2)âŠ¥. 

DefiniÃ§Ã£o 4.4.8.  

Seja ğ‘¥ um vetor em â„¤2
Exemplo: ğ‘¤(1, 1, 0, 1) = 3 e ğ‘¤(1, 0, 0, 1,0) = 2. 

ğ‘›. O peso de ğ‘¥, denotado por ğ‘¤(ğ‘¥) Ã© o nÃºmeros de 1s em ğ‘¥. 

Exemplo: Seja ğ¸ğ‘› o cÃ³digo binÃ¡rio formado por todos os vetores em â„¤2

ğ‘› que tem peso par. 

Seja ğ‘…ğ‘’ğ‘ğ‘› o cÃ³digo binÃ¡rio com ğ‘› componentes que possui apenas dois vetores: 0 e 1 (onde 1 

Ã© o vetor com todas as componentes iguais a 1). 

Mostre que ğ¸ğ‘› e ğ‘…ğ‘’ğ‘ğ‘› sÃ£o duais um do outro. 

SoluÃ§Ã£o: Vamos pensar primeiramente no caso ğ‘› = 3, para em seguida generalizar. 

 
 
 
 
 
 
 
 
54 

ğ¸3 = {[

0
0
0

] , [

1
1
0

] , [

0
1
1

] , [

0
1
]} e ğ‘…ğ‘’ğ‘3 = {[
0
0
0
1

] , [

1
1
1

]} 

Para mostrar que esses cÃ³digos sÃ£o duais, podemos verificar que:  

a) cada elemento de ğ‘…ğ‘’ğ‘3 Ã© ortogonal a cada um dos elementos de ğ¸3.  

De fato, 

E ainda, 

[

0
3. 
] âˆ™ ğ‘£ = 0, para todo vetor ğ‘£ em â„¤2
0
0

1
1
0
3 ortogonal a cada elemento de ğ¸3. 
b) nÃ£o existe outro elemento em â„¤2
Podemos  proceder  por  tentativas,  verificando  para  cada  um  dos  vetores  do  conjunto 

] = 0. 

] = [

] = [

1
1
1

1
0
1

0
1
1

1
1
1

1
1
1

] âˆ™ [

] âˆ™ [

] âˆ™ [

[

{[

1
0
0

] , [

0
1
0

] , [

0
0
1

] , [

1
1
0

] , [

0
1
1

] , [

1
0
1

]} que nenhum deles cumpre a condiÃ§Ã£o. 

Outra  maneira  Ã©  encontrar  o  vetor  ğ‘¥ = [

resolvendo o sistema abaixo: 

ğ‘¥1
ğ‘¥2
ğ‘¥3

]  que  Ã©  o  ortogonal  a  todos  os  vetores  de  ğ¸3, 

ğ‘¥ âˆ™ [

] = 0 

1
1
0

] = ğ‘¥ âˆ™ [

] = ğ‘¥ âˆ™ [

1
0
0
1
1
1
ğ‘¥1 + ğ‘¥2              = 0
       + ğ‘¥2 + ğ‘¥3    = 0
{
ğ‘¥1 +        + ğ‘¥3 = 0

[

1 1 0
0 1 1
1 0 1

0
]
|
0
0

â†’       [
â„“3â†â„“3+â„“1

1 1 0
0
]
|
0 1 1
0
0 1 1
0
ğ‘¥1 = ğ‘¥2
ğ‘¥2 = ğ‘¥3

â‡’ {

â†’       [
â„“3â†â„“3+â„“2

0
1 1 0
|
0
0 1 1
0
0 0 0

] 

â‡’ ğ‘¥1 = ğ‘¥2 = ğ‘¥3 

ğ‘¥1 + ğ‘¥2 = 0
{
ğ‘¥2 + ğ‘¥3 = 0

Portanto,  

{ğ‘¥1 [

1
1
1

0
] |ğ‘¥1 âˆˆ â„¤2} = {[
0
0

] , [

1
1
1

]} = ğ‘…ğ‘’ğ‘3 

Portanto, a afirmaÃ§Ã£o Ã© vÃ¡lida para ğ‘› = 3. 

No caso geral, observe primeiramente que 

 
 
 
 
55 

]} 

0
0
ğ‘…ğ‘’ğ‘ğ‘› = {[
â‹®
0

] , [

1
1
â‹®
1

Ã© um subespaÃ§o de â„¤2

ğ‘› . 

ğ‘› e em particular, qualquer vetor 

Continua verdadeiro que [

0
0
] Ã© ortogonal a qualquer vetor de â„¤2
â‹®
0
1
1
de ğ¸ğ‘›. Basta verificar que [
â‹®
1

] tambÃ©m o Ã©. Para isso, vamos considerar um vetor genÃ©rico ğ‘¥ =

ğ‘¥1
ğ‘¥2
â‹®
ğ‘¥ğ‘›

[

] em â„¤2

ğ‘›. EntÃ£o: 

[

1
1
â‹®
1

ğ‘¥1
ğ‘¥2
â‹®
ğ‘¥ğ‘›

] âˆ™ [

] = ğ‘¥1 + ğ‘¥2 + â‹¯ + ğ‘¥ğ‘› 

A expressÃ£o acima Ã© nula se, e somente se existe uma quantidade par de 1s entre as componentes 

ğ‘¥1, ğ‘¥2, â€¦ , ğ‘¥ğ‘›, Ou seja, se e somente se ğ‘¥ âˆˆ ğ¸ğ‘›. 

Teorema 4.4.9  

Se ğ¶(ğ‘›, ğ‘˜) Ã© um cÃ³digo auto dual, com vetores em â„¤2

ğ‘›, entÃ£o 

i) Todo vetor em ğ¶ tem peso par 

ii) 1 estÃ¡ em ğ¶. 

iii) ğ‘› Ã© par 

DemonstraÃ§Ã£o 

i)  Suponha  que  o  vetor  ğ‘¥ = [

ğ‘¥1
ğ‘¥2
â‹®
ğ‘¥ğ‘›

] âˆˆ ğ¶  tenha  peso  Ã­mpar,  entÃ£o  ğ‘¥1 + ğ‘¥2 + â‹¯ + ğ‘¥ğ‘› = 1,  e, 

portanto, ğ‘¥ âˆ™ ğ‘¥ = 1. Mas isso nÃ£o pode ocorrer, pois como ğ¶ Ã© auto dual, ğ‘¥ deve ser ortogonal 

a si mesmo, ou seja, ğ‘¥ âˆ™ ğ‘¥ = 0. Portanto, o peso de ğ‘¥ nÃ£o Ã© Ã­mpar, logo, Ã© par. 

 
 
 
 
 
 
56 

ii) O vetor 1 = [

1
1
â‹®
1

] Ã© tal que 1 âˆ™ ğ‘¥ = 0, para qualquer ğ‘¥ âˆˆ ğ¶ (do item anterior, jÃ¡ sabemos que 

ğ‘¥  tem  peso  par).  E  como  todo  elemento  de  â„¤2

ğ‘›  que  Ã©  ortogonal  a  todos  os  elementos  de  ğ¶, 

tambÃ©m pertence a ğ¶, concluÃ­mos que 1 âˆˆ ğ¶. 

iii) Dos fatos: todo elemento de ğ¶ tem peso par (item i), e 1 âˆˆ ğ¶ (item ii), concluÃ­mos que 1 =

1
1
[
â‹®
1

] tem peso par, ou seja, a quantidade de coordenadas, ğ‘›, Ã© necessariamente par. 

Teorema 4.4.10  

Seja ğ¶ um cÃ³digo binÃ¡rio (ğ‘›, ğ‘˜) com matriz geradora ğº e matriz de verificaÃ§Ã£o de paridade 

ğ‘ƒ.  Se ğ¶ Ã© autodual, entÃ£o ğ‘› = 2ğ‘˜, ğº Ã© de ordem (2ğ‘˜) Ã— ğ‘˜ e ğ‘ƒ = ğºğ‘‡ Ã© uma matriz de verificaÃ§Ã£o 

de paridade para ğ¶. 

DemonstraÃ§Ã£o Se ğ¶ Ã© um cÃ³digo binÃ¡rio (ğ‘›, ğ‘˜) entÃ£o, pelo Teorema 4.4.2., ğ¶âŠ¥ Ã© um cÃ³digo 

binÃ¡rio (ğ‘›, ğ‘› âˆ’ ğ‘˜).  Mas se ğ¶ = ğ¶âŠ¥ entÃ£o ğ‘˜  =  ğ‘› âˆ’ ğ‘˜ e portanto ğ‘› = 2ğ‘˜.   

AlÃ©m disso, ainda pelo Teorema 4.4.2. ğ‘ƒğ‘‡ Ã© a matriz geradora de ğ¶âŠ¥, mas como ğ¶âŠ¥ = ğ¶, entÃ£o 

ğ‘ƒ = ğºğ‘‡, onde ğº Ã© uma matriz de ordem (2ğ‘˜) Ã— ğ‘˜ e obviamente ğ‘ƒ Ã© de ordem ğ‘˜ Ã— (2ğ‘˜). 

 
 
 
 
 
 
 
 
57 

5. MÃ‰TRICA DE HAMMING  

Nosso  objetivo  principal  neste  capÃ­tulo  Ã©  estabelecer  um  resultado  que  permita  determinar 

quantos erros o cÃ³digo pode detectar e quantos erros podem ser corrigidos. Para mais detalhes 

veja a seÃ§Ã£o 1.3. 

5.1. DistÃ¢ncia de Hamming 

DefiniÃ§Ã£o 5.1.1.  

Dados  dois  elementos  ğ‘¢ = (ğ‘¢1, ğ‘¢2, â€¦ , ğ‘¢ğ‘›)  e  ğ‘£ = (ğ‘£1, ğ‘£2, â€¦ , ğ‘£ğ‘›)  em  â„¤2

ğ‘›,  a  distÃ¢ncia  de 

Hamming entre ğ‘¢ e ğ‘£ Ã© definida por 

onde ğ‘¤(ğ‘¢ + ğ‘£) Ã© o peso do vetor ğ‘¢ + ğ‘£ 

ğ‘‘ğ»(ğ‘¢, ğ‘£) = â€–ğ‘¢ + ğ‘£â€–ğ» = ğ‘¤(ğ‘¢ + ğ‘£) 

Exemplo:  Encontre  a  distÃ¢ncia  de  Hamming  entre  os  vetores  ğ‘¢ = (1, 0, 1, 0, 1)  e  ğ‘£ =

5. 
(1, 0, 0, 1, 1) em â„¤2
SoluÃ§Ã£o: Como ğ‘¢ + ğ‘£ = (0, 0, 1, 1, 0), entÃ£o 

ğ‘‘ğ»(ğ‘¢, ğ‘£) = â€–ğ‘¢ + ğ‘£â€–ğ» = â€–(0, 0, 1, 1, 0)â€–ğ» = ğ‘¤(0, 0, 1, 1, 0) = 2 

Toda  funÃ§Ã£o  distÃ¢ncia  definida  a  partir  de  uma  norma  num  espaÃ§o  vetorial  ğ‘‰  satisfaz  Ã s 

seguintes propriedades: 

Teorema 5.1.2  

Para todos os vetores ğ‘¢, ğ‘£, ğ‘¤ em ğ‘‰ valem: 

a) ğ‘‘(ğ‘¢, ğ‘£) â‰¥ 0 e ğ‘‘(ğ‘¢, ğ‘£) = 0 se, e somente se, ğ‘¢ = ğ‘£ (positividade) 

b) ğ‘‘(ğ‘¢, ğ‘£) = ğ‘‘(ğ‘£, ğ‘¢) (simetria) 

c) ğ‘‘(ğ‘¢, ğ‘£) â‰¤ ğ‘‘(ğ‘¢, ğ‘¤) + ğ‘‘(ğ‘¤, ğ‘£) (desigualdade triangular) 

ğ‘›, se ğ‘‘ Ã© a distÃ¢ncia ğ‘‘ğ» de Hamming e â€–ğ‘¢â€– Ã© a norma 
Em particular, para o espaÃ§o vetorial â„¤2
â€–ğ‘¢â€–ğ»  de  Hamming,  o  teorema  anterior  tambÃ©m  vale  e,  portanto,  as  propriedades  acima 

permitem dizer que ğ‘‘ğ» Ã© uma mÃ©trica em â„¤2

ğ‘›, chamada mÃ©trica de Hamming. 

Introduziremos a seguir a noÃ§Ã£o de distÃ¢ncia nos cÃ³digos binÃ¡rios. 

 
 
 
 
 
 
 
 
 
 
 
 
58 

DefiniÃ§Ã£o 5.1.3.  

Seja  ğ¶  um  cÃ³digo  binÃ¡rio,  a  distÃ¢ncia  mÃ­nima  de  ğ¶  Ã©  a  menor  distÃ¢ncia  de  Hamming  entre 

quaisquer dois vetores distintos de ğ¶. Isto Ã©, 

ğ‘‘(ğ¶) = min{ğ‘‘ğ»(ğ‘¥, ğ‘¦): ğ‘¥ â‰  ğ‘¦ em ğ¶} 

Exemplo: Encontre a distÃ¢ncia mÃ­nima do cÃ³digo ğ¶ = {ğ‘0, ğ‘1, ğ‘2, ğ‘3} onde ğ‘0 =

0
0
0
0
0]

, ğ‘1 =

0
1
0
1
1]

, 

[

[

1
0
1
1
0]

 e ğ‘3 =

1
1
1
0
1]

[

ğ‘2 =

[

SoluÃ§Ã£o: Precisamos calcular a distÃ¢ncia de Hamming entre os (

) = 6 pares de vetores: 

ğ‘‘ğ»(ğ‘0, ğ‘1) = 3 
ğ‘‘ğ»(ğ‘1, ğ‘2) = 4 
Logo,  

ğ‘‘ğ»(ğ‘0, ğ‘2) = 3 
ğ‘‘ğ»(ğ‘1, ğ‘3) = 3 

4
2
ğ‘‘ğ»(ğ‘0, ğ‘3) = 4 
ğ‘‘ğ»(ğ‘2, ğ‘3) = 3 

ğ‘‘(ğ¶) = min{3, 3, 4, 4, 3, 3} = min{3, 4} = 3 

Em geral, para calcular  ğ‘‘(ğ¶) num cÃ³digo  ğ¶ de  ğ‘€ vetores â€“ por este mÃ©todo â€“ Ã© necessÃ¡rio 

calcular (

ğ‘€
2

) distÃ¢ncias, o que Ã© inviÃ¡vel para ğ‘€ muito grande. Veremos adiante um mÃ©todo 

mais eficiente. 

O seguinte resultado mostra que em cÃ³digos lineares com ğ‘€ elementos, pode-se calcular ğ‘‘(ğ¶) 

apenas com ğ‘€ âˆ’ 1 cÃ¡lculos de distÃ¢ncias em vez dos (

ğ‘€
2

) cÃ¡lculos anteriormente requeridos. 

ProposiÃ§Ã£o 5.1.4  

Se ğ¶ âŠ‚ â„¤2

ğ‘› Ã© um cÃ³digo linear com distÃ¢ncia mÃ­nima ğ‘‘, entÃ£o 

ğ‘‘ = ğ‘¤(ğ¶) â‰” min{ğ‘¤(ğ‘¥): ğ‘¥ âˆˆ ğ¶\{0}} 

onde ğ‘¤(ğ¶) Ã© o peso mÃ­nimo de ğ¶ ou simplesmente o peso de ğ¶. 

DemonstraÃ§Ã£o  Basta  provar  que  os  conjuntos  finitos  ğ´ = {ğ‘‘ğ»(ğ‘¥, ğ‘¦): ğ‘¥ â‰  ğ‘¦  âˆˆ  ğ¶}  e  ğµ =
{ğ‘¤(ğ‘§): ğ‘§ âˆˆ ğ¶\{0}} sÃ£o  iguais,  pois  se  ğ´ = ğµ,  ğ‘‘(ğ¶) = min ğ´ = min ğµ = ğ‘¤(ğ¶)  e  tem-se  o 

resultado.  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
59 

Para fazer isto, considere ğ‘¤(ğ‘§) âˆˆ ğµ com ğ‘§ arbitrÃ¡rio em ğ¶\{0}. Como ğ‘¤(ğ‘§) = ğ‘‘ğ»(ğ‘§, 0), com 
ğ‘§ â‰  0 segue que ğ‘¤(ğ‘§) âˆˆ ğ´ e, portanto ğµ âŠ‚ ğ´.  

Reciprocamente, seja  ğ‘‘ğ»(ğ‘¥, ğ‘¦) âˆˆ ğ´. Como ğ‘¥ + ğ‘¦ âˆˆ ğ¶, com ğ‘¥ â‰  ğ‘¦, e  ğ¶ Ã© um espaÃ§o vetorial 
tem-se  que  ğ‘§ = ğ‘¥ + ğ‘¦ âˆˆ ğ¶\{0} e,  portanto  ğ‘‘ğ»(ğ‘¥, ğ‘¦) = ğ‘¤(ğ‘¥ + ğ‘¦) = ğ‘¤(ğ‘§)  com  ğ‘§ â‰  0.  Logo, 
ğ‘‘ğ»(ğ‘¥, ğ‘¦) âˆˆ ğµ e, portanto ğ´ âŠ‚ ğµ. 

Agora estamos em condiÃ§Ãµes de refazer o exemplo anterior com menos esforÃ§o. Primeiramente, 

observe que ğ¶ = {ğ‘0, ğ‘1, ğ‘2, ğ‘3} como definido anteriormente Ã© um subespaÃ§o de â„¤2
trata-se de um cÃ³digo linear. Vimos que ğ‘‘(ğ¶) = min{3, 3, 4, 4, 3, 3} = min{3, 4} = 3. Agora 

5 e, portanto, 

vamos calcular ğ‘¤(ğ¶) = min{ğ‘¤(ğ‘1), ğ‘¤(ğ‘2), ğ‘¤(ğ‘3)}: 

ğ‘¤(ğ‘1) = ğ‘¤(0, 1, 0, 1, 1) = 3 
ğ‘¤(ğ‘2) = ğ‘¤(1, 0, 1, 1, 0) = 3 
ğ‘¤(ğ‘3) = ğ‘¤(1, 1, 1, 0, 1) = 4 

DaÃ­, ğ‘‘(ğ¶) = ğ‘¤(ğ¶) = min{3, 3, 4} = min{3, 4} = 3. 

5.2. CÃ³digos de correÃ§Ã£o de erros 

Quando digitamos a palavra ELEFANTR em um editor de textos, Ã© possÃ­vel  que ele faÃ§a a 

correÃ§Ã£o, se for programado para fazer duas suposiÃ§Ãµes: 

ï‚·  Nossa intenÃ§Ã£o foi escrever uma palavra em portuguÃªs, e nÃ£o em outra lÃ­ngua, nem uma 

sigla; 

ï‚·  A quantidade de erros que cometemos na digitaÃ§Ã£o foi a menor possÃ­vel. 

Deste modo, o editor pode fazer a correÃ§Ã£o para ELEFANTE. 

Por outro lado, se a palavra fosse ELETANTE o programa enfrentaria maiores dificuldades. A 

palavra  correta  seria  ELEFANTE  ou  ELEGANTE?  O  fato  de  existir  duas  palavras  como 

elefante e elegante cuja distÃ¢ncia (nÃºmero de componentes diferentes) Ã©  igual a 1, nÃ£o permite 

que a correÃ§Ã£o seja feita sempre. 

Se a palavra fosse MOLO, novamente seria difÃ­cil decidir. A palavra correta seria BOLO ou 

MOLA, por exemplo. O fato de a distÃ¢ncia entre bolo e mola ser igual a 2 gera essa dificuldade.  

De maneira geral, para que seja sempre possÃ­vel corrigir um erro, Ã© necessÃ¡rio que a distÃ¢ncia 

mÃ­nima entre duas palavras seja maior ou igual a 3 Isso garante que haja uma Ãºnica palavra 

mais prÃ³xima da palavra com um erro, que Ã© justamente a palavra correta. 

 
 
 
 
 
 
60 

Ã‰ exatamente desta forma que o cÃ³digo de Hamming funciona, como veremos nesta seÃ§Ã£o e no 

capÃ­tulo seguinte. 

DefiniÃ§Ã£o 5.2.1.  

Dado um elemento ğ‘¥ âˆˆ â„¤2
sÃ£o respectivamente os conjuntos 

ğ‘› e um nÃºmero real ğ‘¡ > 0, o disco e a esfera de centro em ğ‘¥ e raio ğ‘¡ 

ğ·(ğ‘¥, ğ‘¡) = {ğ‘¦ âˆˆ â„¤2
ğ‘†(ğ‘¥, ğ‘¡) = {ğ‘¦ âˆˆ â„¤2

ğ‘›: ğ‘‘(ğ‘¥, ğ‘¦) â‰¤ ğ‘¡} 

ğ‘›: ğ‘‘(ğ‘¦, ğ‘¥) = ğ‘¡} 

DefiniÃ§Ã£o 5.2.2  

Para cada vetor cÃ³digo ğ‘¥ âˆˆ ğ¶ e um nÃºmero real ğ‘¡ > 0, o disco (de Hamming) com centro ğ‘¥ e 

raio ğ‘¡ serÃ¡ o conjunto  

Observe inicialmente que se ğ‘ âˆˆ ğ¶, ğ‘‘ğ»(ğ‘, ğ‘) â‰¥ ğ‘‘ para ğ‘ â‰  ğ‘ âˆˆ ğ¶, e, portanto: 

ğ·ğ»(ğ‘¥, ğ‘¡) = {ğ‘¦ âˆˆ ğ¶: ğ‘‘ğ»(ğ‘¦, ğ‘¥) â‰¤ ğ‘¡} 

ï‚·  Se ğ‘¡ < ğ‘‘, ğ‘ Ã© o Ãºnico vetor cÃ³digo no disco ğ·ğ»(ğ‘, ğ‘¡) 

ï‚·  Se ğ‘‘ < 2ğ‘¡, ğ·ğ»(ğ‘, ğ‘¡) âˆ© ğ·ğ»(ğ‘, ğ‘¡) = âˆ…. 

Para que ğ¶ seja um cÃ³digo (binÃ¡rio) corretor de ğœ… erros Ã© usado o processo conhecido como 

â€œdecodificador pelo vizinho mais prÃ³ximoâ€. Para isso deve-se encontrar um raio ğœ… apropriado 

tal  que  todos  os  discos  centrados  em  vetores  de  cÃ³digo  nÃ£o  se  interceptem,  e,  portanto,  ao 

receber  ğ‘â€²  obtido  por  atÃ©  ğœ…  trocas  nas  entradas  de  ğ‘ âˆˆ ğ¶,  ele  se  encontrarÃ¡  apenas  no  disco 

ğ·ğ»(ğ‘, ğœ…) e, portanto ğ‘â€² serÃ¡ decodificado por ğ‘, pois ğ‘ serÃ¡ seu vizinho mais prÃ³ximo (dentre 

todos os vetores cÃ³digo). Agora vamos formalizar esses conceitos. 

DefiniÃ§Ã£o 5.2.3.  

Seja ğ¶ um cÃ³digo (binÃ¡rio). Para um vetor ğ‘ âˆˆ ğ¶, seja ğ‘â€² um vetor obtido por atÃ© ğœ… trocas nas 

entradas de ğ‘. Dizemos que: 

a) ğ¶ detecta ğœ… erros se ğ‘â€² nÃ£o Ã© um vetor cÃ³digo. 

b) ğ¶ corrige ğœ… erros se o vizinho decodificado mais prÃ³ximo de ğ‘â€² produz ğ‘. 

Dado um cÃ³digo ğ¶ com distÃ¢ncia mÃ­nima ğ‘‘, define-se ğœ… = [

ğ‘‘âˆ’1

2

], onde [ğ‘¡] representa a parte 

inteira de um nÃºmero real ğ‘¡, isto Ã©, [ğ‘¡] Ã© o maior inteiro menor do que ou igual a ğ‘¡. 

 
 
 
 
 
 
 
 
 
61 

Lema 5.2.4.  

Seja ğ¶ um cÃ³digo com distÃ¢ncia mÃ­nima ğ‘‘. Se ğ‘ e ğ‘ sÃ£o vetores cÃ³digo distintos de ğ¶, entÃ£o 

ğ·(ğ‘, ğœ…) âˆ© ğ·(ğ‘, ğœ…) = âˆ… 

DemonstraÃ§Ã£o: Suponha por absurdo que  ğ·(ğ‘, ğœ…) âˆ© ğ·(ğ‘, ğœ…) â‰  âˆ… e considere  ğ‘¥ âˆˆ ğ·(ğ‘, ğ‘˜) âˆ©

ğ·(ğ‘, ğœ…).  Logo  ğ‘‘ğ»(ğ‘¥, ğ‘) â‰¤ ğœ…  e  ğ‘‘ğ»(ğ‘¥, ğ‘) â‰¤ ğœ…  e,  portanto,  pela  simetria  e  pela  desigualdade 

triangular 

ğ‘‘(ğ‘, ğ‘) â‰¤ ğ‘‘(ğ‘, ğ‘¥) + ğ‘‘(ğ‘¥, ğ‘) â‰¤ 2ğœ… 

Da definiÃ§Ã£o de ğœ… tem-se que ğœ… â‰¤

ğ‘‘âˆ’1

2

 e, portanto, 2ğœ… â‰¤ ğ‘‘ âˆ’ 1. 

Logo, ğ‘‘(ğ‘, ğ‘) â‰¤ ğ‘‘ âˆ’ 1 o que Ã© uma contradiÃ§Ã£o, pois ğ‘‘ğ»(ğ‘, ğ‘) â‰¥ ğ‘‘. 

O resultado mais importante deste capÃ­tulo Ã© o seguinte. 

Teorema 5.2.5 Seja ğ¶ um cÃ³digo com distÃ¢ncia mÃ­nima ğ‘‘. EntÃ£o, ğ¶ pode corrigir atÃ© ğœ… = [

erros e detectar atÃ© ğ‘‘ âˆ’ 1 erros. 

ğ‘‘âˆ’1

] 

2

DemonstraÃ§Ã£o Seja ğ‘ um vetor cÃ³digo em ğ¶. Se ao transmitirmos ğ‘ Ã© recebido o vetor ğ‘â€² com 
ğ‘¡ erros nas componentes de ğ‘, com ğ‘¡ â‰¤ ğœ…, entÃ£o ğ‘‘ğ»(ğ‘â€², ğ‘) = ğ‘¡ â‰¤ ğœ… e, portanto ğ‘â€² âˆˆ ğ·ğ»(ğ‘, ğœ…). 
Pelo  Lema  5.2.4  segue  que  para  cada  ğ‘ âˆˆ ğ¶  com  ğ‘ â‰  ğ‘,  ğ‘â€² âˆ‰ ğ·ğ»(ğ‘, ğœ…)  e,  portanto  ğ‘â€²  Ã© 
decodificado pelo vizinho mais prÃ³ximo, que Ã© ğ‘. 

Por  outro  lado,  dado  um  vetor  cÃ³digo  ğ‘ âˆˆ ğ¶,  se  sÃ£o  introduzidos  ğ‘‘ âˆ’ 1  erros  nas  suas 
coordenadas,  recebendo  o  vetor  ğ‘â€²,  entÃ£o  ğ‘‘ğ»(ğ‘, ğ‘â€²) = ğ‘‘ âˆ’ 1  e,  portanto  ğ‘â€² âˆ‰ ğ¶  pois,  caso 
contrÃ¡rio, terÃ­amos ğ‘‘ğ»(ğ‘, ğ‘â€²) â‰¥ ğ‘‘. 

Por exemplo, vimos que o cÃ³digo ğ¶ apresentado apÃ³s a definiÃ§Ã£o 5.1.3 Ã© tal que ğ‘‘ = 3. Logo, 

nele Ã© possÃ­vel corrigir atÃ© ğœ… = [

3âˆ’1

2

] = 1 erro e detectar atÃ© 3 âˆ’ 1 = 2 erros. 

O teorema anterior ressalta a importÃ¢ncia de se conhecer a distÃ¢ncia mÃ­nima de um cÃ³digo. No 

caso de cÃ³digos lineares a proposiÃ§Ã£o 5.1.4 facilita essa tarefa. TambÃ©m Ã© possÃ­vel determinar 

ğ‘‘(ğ¶) examinando a matriz de verificaÃ§Ã£o de paridade de ğ¶. 

Teorema 5.2.6  

Seja  ğ¶  um  cÃ³digo  linear  (ğ‘›, ğ‘˜)  com  matriz  de  verificaÃ§Ã£o  de  paridade  ğ‘ƒ.  EntÃ£o  a  distÃ¢ncia 

mÃ­nima de ğ¶ Ã© o menor inteiro ğ‘‘ para o qual existem ğ‘‘ colunas linearmente dependentes. 

 
 
 
 
 
 
 
62 

DemonstraÃ§Ã£o  Suponha  que  ğ‘‘(ğ¶) = ğ‘‘.  Se  ğ¶  Ã©  um  cÃ³digo  linear  (ğ‘›, ğ‘˜)  com  matriz  de 

verificaÃ§Ã£o  de  paridade  ğ‘ƒ,  entÃ£o  ğ‘ƒ  Ã©  de  ordem  (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘›  e  ğ‘ƒğ‘¥ = 0,  âˆ€ğ‘¥ âˆˆ ğ¶ âŠ‚ â„¤2

ğ‘›.  Pela 

ProposiÃ§Ã£o  5.1.4,    ğ¶  contÃ©m  um  vetor  ğ‘  de  peso  ğ‘‘.  EntÃ£o  ğ‘ƒğ‘  Ã©  uma  combinaÃ§Ã£o  linear  de 

exatamente ğ‘‘ colunas de ğ‘ƒ. Mas como ğ‘ƒğ‘ = 0 tem-se que existe um subconjunto com ğ‘‘ colunas 

de ğ‘ƒ que Ã© linearmente dependente. A seguir provaremos que ğ‘‘ Ã© o nÃºmero mÃ­nimo de colunas 

linearmente dependentes na matriz ğ‘ƒ.  

De  fato,  suponha  por  absurdo  que  existam  ğ‘¡,  com  ğ‘¡ < ğ‘‘,  colunas  linearmente  dependentes, 

digamos que 

ğ‘ƒğ‘–1, ğ‘ƒğ‘–2, â€¦ , ğ‘ƒğ‘–ğ‘¡ 

sejam ğ‘¡ colunas linearmente dependentes dentre as colunas de ğ‘ƒ. Logo, existem escalares nÃ£o 

todos nulos ğ›¼ğ‘–ğ‘— âˆˆ â„¤2 tais que 

Pela minimalidade de  ğ‘¡ segue que esses escalares sÃ£o todos iguais a 1 e portanto 

ğ›¼ğ‘–1ğ‘ƒğ‘–1 + ğ›¼ğ‘–2ğ‘ƒğ‘–2 + â‹¯ + ğ›¼ğ‘–ğ‘¡ğ‘ƒğ‘–ğ‘¡ = 0 

ğ‘ƒğ‘–1 +   ğ‘ƒğ‘–2 + â‹¯ + ğ‘ƒğ‘–ğ‘¡ = 0 

ğ‘› com entradas 1 nas posiÃ§Ãµes ğ‘–1, ğ‘–2, â€¦ , ğ‘–ğ‘¡ e zero nas demais. EntÃ£o ğ‘¤(ğ‘¥) = ğ‘¡ e ğ‘ƒğ‘¥ =
Seja ğ‘¥ âˆˆ â„¤2
0.  Logo  ğ‘¥  Ã©  um  vetor  cÃ³digo  com  peso  ğ‘¡ < ğ‘‘ = ğ‘‘(ğ¶).  Isto  contradiz  a  ProposiÃ§Ã£o  5.1.4  e, 

portanto temos um absurdo. 

Reciprocamente, suponha que qualquer ğ‘‘ âˆ’ 1 colunas de ğ‘ƒ sejam L.I. e que alguns conjuntos 

de  ğ‘‘  colunas  de  ğ‘ƒ  sejam  L.D.  Como  ğ‘ƒğ‘¥  Ã©  uma  combinaÃ§Ã£o  linear  das  colunas  de  ğ‘ƒ 

correspondentes Ã s posiÃ§Ãµes dos 1s em ğ‘¥, ğ‘ƒğ‘¥ â‰  0 para qualquer vetor ğ‘¥ com peso ğ‘‘ âˆ’ 1 ou 

menos. Portanto,  nÃ£o existem vetores cÃ³digo nÃ£o nulos com  peso menor que  ğ‘‘. Mas  algum 

conjunto de ğ‘‘ colunas de ğ‘ƒ Ã© L.D., portanto, existe um vetor ğ‘¥ com peso ğ‘‘ tal que ğ‘ƒğ‘¥ = 0. 

Logo, esse ğ‘¥ Ã© um vetor cÃ³digo com peso ğ‘‘. Novamente, pela ProposiÃ§Ã£o 5.1.4, deduzimos que 

ğ‘‘(ğ¶) = ğ‘‘. 

Exemplo:  Suponha  que  uma  mensagem  contenha  os  vetores  ğ‘¥0 = (0, 0),  ğ‘¥1 = (0, 1),  ğ‘¥2 =
2 e que a matriz geradora padrÃ£o seja tal que 

(1, 0) e ğ‘¥3 = (1, 1) em â„¤2

ğºğ‘¥0 = ğ‘0, ğºğ‘¥1 = ğ‘1, ğºğ‘¥2 = ğ‘2, ğºğ‘¥3 = ğ‘3, onde ğ¶ = {ğ‘0, ğ‘1, ğ‘2, ğ‘3} 

Ã© o cÃ³digo do exemplo dado apÃ³s definiÃ§Ã£o 5.1.3. Ã‰ fÃ¡cil determinar ğº como sendo a matriz 

 
 
 
 
63 

(

ğ¼2
ğ´

) =

1 0
0 1
1 0
1 1
0 1)

(

paridade.  

   e  portanto  ğ‘ƒ = (ğ´|ğ¼) = (

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1

)  Ã©  a  matriz  de  verificaÃ§Ã£o  de 

Temos  que  ğ¶  Ã©  um  cÃ³digo  linear  (5, 2).  Observe  que  os  vetores  ğ‘’1,  ğ‘’2  e  ğ‘’1 + ğ‘’2  (que 

correspondem Ã s 3Âª, 4Âª e 1Âª colunas de ğ‘ƒ) sÃ£o L.D. e que quaisquer duas colunas de ğ‘ƒ sÃ£o L.I. 

Pelo Teorema 5.2.6, isto significa que ğ‘‘(ğ¶) = 3 (coincidindo com nossas contas anteriores). 

Em vista da importÃ¢ncia da distÃ¢ncia mÃ­nima nos cÃ³digos lineares, existe a seguinte: 

NotaÃ§Ã£o: Se um cÃ³digo linear (ğ‘›, ğ‘˜) tem distÃ¢ncia mÃ­nima ğ‘‘, ele Ã© chamado de cÃ³digo (ğ‘›, ğ‘˜, ğ‘‘). 

 
 
 
 
 
 
 
 
 
 
64 

6. CÃ“DIGO DE HAMMING  

Ao buscarmos um cÃ³digo que possa transmitir a maior quantidade de informaÃ§Ãµes possÃ­vel Ã© 

desejado que ğ‘˜ (e, portanto ğ‘›) seja o maior possÃ­vel.  Pelo Teorema 4.1.2 as ğ‘› colunas de ğ‘ƒ 

precisam ser nÃ£o nulas e distintas, entÃ£o o mÃ¡ximo ocorre quando elas consistem de todos os 

vetores nÃ£o nulos de â„¤2
mÃ¡ximo Ã© atingido quando ğ‘› = 2ğ‘›âˆ’ğ‘˜ âˆ’ 1. 

ğ‘›âˆ’ğ‘˜.  Como â„¤2

ğ‘›âˆ’ğ‘˜ possui 2ğ‘›âˆ’ğ‘˜ âˆ’ 1 vetores nÃ£o nulos e distintos, esse 

DefiniÃ§Ã£o 6.1.1. (CÃ³digos de Hamming)  

Um cÃ³digo de Hamming (ğ’, ğ’Œ) sobre â„¤2 Ã© um cÃ³digo com matriz de verificaÃ§Ã£o de paridade 
ğ‘›âˆ’ğ‘˜ âˆ– {0}  numa  ordem 

ğ‘ƒ  de  ordem  (ğ‘› âˆ’ ğ‘˜) Ã— ğ‘›  cujas  colunas  sÃ£o  todos  os  vetores  de  â„¤2
qualquer. 

Observe que para cada inteiro ğ‘š = ğ‘› âˆ’ ğ‘˜ > 1, existem Ãºnicos ğ‘› e ğ‘˜ tais que ğ‘› = 2ğ‘›âˆ’ğ‘˜ âˆ’ 1. 

Exemplo:  Se  ğ‘š = 2,  ğ‘› = 3  entÃ£o  ğ‘˜ = 1  e,  portanto,  existem  cÃ³digos  de  Hamming  (3,1).  

Como ilustraÃ§Ã£o, se ğº = [

] Ã© a matriz geradora padrÃ£o do cÃ³digo, entÃ£o ğ‘ƒ = [

1 1 0
1 0 1

] Ã© a 

1
1
1

matriz de verificaÃ§Ã£o de paridade padrÃ£o associada a ğº para esse cÃ³digo.  Neste caso, os vetores 

de mensagem sÃ£o os dÃ­gitos 0 e 1 e os vetores de cÃ³digo sÃ£o [0, 0, 0] e [1, 1, 1]. 

Exemplo: Se ğ‘š = 3, ğ‘› = 7 e ğ‘˜ = 4.  Uma matriz candidata a matriz de verificaÃ§Ã£o de paridade 

para um cÃ³digo de Hamming (7, 4) Ã©  

ğ‘ƒ = [

1 0 1 1 1 0 0
1 1 0 1 0 1 0
0 1 1 1 0 0 1

] = [ğ´ ğ¼3] e, pelo Teorema 4.1.2, a matriz geradora padrÃ£o 

desse cÃ³digo Ã© ğº = [

ğ¼4
ğ´

] 

CorolÃ¡rio 6.1.2.  

Se ğ¶(ğ‘›, ğ‘˜) Ã© um cÃ³digo binÃ¡rio autodual, entÃ£o ğ¶ nÃ£o Ã© um cÃ³digo de Hamming (ğ‘›, ğ‘˜). 

DemonstraÃ§Ã£o Se ğ¶ fosse de Hamming entÃ£o ğ‘› seria Ã­mpar (pois ğ‘›  =   2ğ‘›âˆ’ğ‘˜ âˆ’ 1), mas isto Ã© 

um absurdo, pois pelo Teorema 4.4.9, ğ‘› deve ser par. 

 
 
 
 
 
 
 
 
 
 
65 

Teorema 6.1.4.  

Todo cÃ³digo de Hamming tem distÃ¢ncia mÃ­nima 3. Isto Ã©, cÃ³digos de Hamming sÃ£o cÃ³digos 

(ğ‘›, ğ‘˜, ğ‘‘) onde ğ‘› = 2ğ‘›âˆ’ğ‘˜ âˆ’ 1 e ğ‘‘ = 3. 

DemonstraÃ§Ã£o: Considere um cÃ³digo de Hamming ğ¶ com matriz de verificaÃ§Ã£o de paridade 

ğ‘ƒ. Duas colunas em ğ‘ƒ sÃ£o sempre LI, e sempre Ã© possÃ­vel achar trÃªs colunas LD em  ğ‘ƒ, por 

exemplo, ğ‘’1, ğ‘’2 e ğ‘’1 + ğ‘’2. Portanto, pelo Teorema 5.2.6, temos que ğ‘‘ = 3. 

CorolÃ¡rio 6.1.5.  

Os cÃ³digos de Hamming detectam atÃ© dois erros e corrigem um erro. 

DemonstraÃ§Ã£o: Pelo Teorema 6.1.4 sabe-se que Se ğ‘‘ = 3, entÃ£o ğœ… = [

tem-se o resultado. 

ğ‘‘âˆ’1

2

] = 1 e, portanto, 

 
 
 
 
 
 
 
66 

CONCLUSÃƒO 

Neste  trabalho,  tivemos  a  oportunidade  de  estudar  os  cÃ³digos  de  Hamming  para  detecÃ§Ã£o  e 

correÃ§Ã£o de erros, mostrando uma aplicaÃ§Ã£o prÃ¡tica da matemÃ¡tica na Ã¡rea da Tecnologia da 

InformaÃ§Ã£o. Ter conhecimento de aplicaÃ§Ãµes como essas Ã© Ãºtil ao professor de matemÃ¡tica, que 

estÃ¡ sempre sendo questionado pelos alunos sobre a importÃ¢ncia da matemÃ¡tica para alÃ©m da 

sala de aula. Por exemplo, os cÃ³digos de detecÃ§Ã£o e correÃ§Ã£o de erros que vimos ao longo do 

texto  podem  ser  apresentados  aos  alunos,  com  as  devidas  simplificaÃ§Ãµes,  como  motivaÃ§Ã£o 

adcional ao ensino aritmÃ©tica e de matrizes. 

O leitor interessado em se aprofundar, pode pesquisar sobre outras famÃ­lias de cÃ³digos lineares 

como os cÃ³digos de Reed-Muller e o cÃ³digo de Golay, ambos utilizados pela NASA nas dÃ©cadas 

de 1970 e 1980, de acordo com Poole (2014) para transmissÃ£o confiÃ¡vel de fotos vindas de 

sondas espaciais como a Mariner 9 e o Voyager 1 e 2. AlÃ©m destes, hÃ¡ o CRC (estudado em 

cursos  de  Redes  de  Computadores)  como  um  exemplo  de  cÃ³digo  utilizado  atualmente. 

Entretanto, o CRC usa outras ferramentas matemÃ¡ticas para corregir os erros de transmissÃ£o. 

 
 
 
 
 
 
 
 
 
67 

REFERÃŠNCIAS 

BROOKSHEAR,  J.G.  CiÃªncia  da  computaÃ§Ã£o:  uma  visÃ£o  abrangente.  7.  Ed.  SÃ£o  Paulo: 

Artmed, 2003.  

FERREIRA,  AndrÃ©  Arantes.  DetecÃ§Ã£o  e  CorreÃ§Ã£o  de  Erros  em  CÃ³digos  BinÃ¡rios. 

DissertaÃ§Ã£o 

de  mestrado.  Universidade 

do 

Porto, 

2007.  DisponÃ­vel 

em 

http://www.fc.up.pt/fcup/contactos/teses/t_030370081.pdf 

FORMIGA, MaurÃ­cio Marinho. ComunicaÃ§Ã£o de Dados para um Sistema de Telemetria de 

Baixo 

Custo. 

DissertaÃ§Ã£o 

de 

Mestreado. 

DisponÃ­vel 

em 

http://docs.computacao.ufcg.edu.br/posgraduacao/dissertacoes/2005/Dissertacao_MauricioMa

rinhoFormiga.pdf 

HAMMING, Richard W.  Error Detecting and Error Correcting Codes. The Bell System 

Technical 

Journal 

vol.XXVI. 

April, 

1950. 

DisponÃ­vel 

em 

http://www.sns.ias.edu/~tlusty/courses/InfoInBio/Papers/Hamming1950.pdf 

HEFEZ, Abramo. Curso de Ãlgebra. v.1. 3Âª ed. Rio de Janeiro: IMPA, 2002. 

HEFEZ, Abramo; VILLELA, Maria LÃºcia Torres. CÃ³digos Corretores de Erros. 2 ed. Rio de 

Janeiro: IMPA, 2008. 

MILIES,  CÃ©sar  Polcino.  A  MatemÃ¡tica  dos  CÃ³digos  de  Barras.  Campina  Grande:  UFCG, 

2006. DisponÃ­vel em www.mat.ufg.br/bienal/2006/mini/polcino.pdf 

POOLE, David. Ãlgebra Linear. 8Âª ed. SÃ£o Paulo: Cengage Learning, 2014. 

SHANNON,  Claude  E.  A  Mathematical  Theory  of  Communication.  The  Bell  System 

Technical 

Journal 

vol.XXVII. 

July, 

1948. 

DisponÃ­vel 

em 

http://worrydream.com/refs/Shannon%20-

%20A%20Mathematical%20Theory%20of%20Communication.pdf 

 
 
 
 
 
 
