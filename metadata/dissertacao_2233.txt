Universidade do Estado do Rio de Janeiro 

Centro Tecnologia e Ciências 

Instituto de Matemática e Estatistica 

Isaque Damião Siqueira Costa 

Código de Hamming: detecção e correção de erros 

Rio de Janeiro 

2018

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Isaque Damião Siqueira Costa 

Código de Hamming: detecção e correção de erros 

Dissertação  apresentada,  como  requisito  parcial 
para obtenção do título de Mestre, ao Programa de 
Pós-graduação  em  Matemática,  da  Universidade 
do Estado do Rio de Janeiro.  

Orientador: Prof. Dr. Roberto Alfonso Olivares Jara 

Rio de Janeiro 

2018 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
CATALOGAÇÃO NA FONTE 
UERJ / REDE SIRIUS / BIBLIOTECA CTC-A 

C837 

Costa, Isaque Damião Siqueira. 

Código de Hamming: detecção e correção de erros / Isaque Damião 

Siqueira Costa – 2018.  

65 f. : il. 

Orientador: Roberto Alfonso Olivares Jara. 
Dissertação (Mestrado Profissional em Matemática em Rede 
Nacional) - Universidade do Estado do Rio de Janeiro, Instituto de 
Matemática e Estatística. 

1. Análise numérica – Processamento de dados – Teses. I. Jara, 

Roberto Alfonso Olivares. II. Universidade do Estado do Rio de 
Janeiro. PROFMAT.  III. Título. 

CDU 519.6 

Patricia Bello Meijinhos – CRB-7/5217 – Responsável pela elaboração da ficha catalográfica 

Autorizo para fins acadêmicos e científicos, a reprodução total ou parcial desta dissertação, 
desde que citada a fonte. 

______________________________  

________________________ 

Assinatura  

Data 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Isaque Damião Siqueira Costa 

Código de Hamming: detecção e correção de erros 

Dissertação  apresentada,  como  requisito  parcial 
para obtenção do título de Mestre, ao Programa de 
Mestrado  Profissional  em  Matemática,  da 
Universidade do Estado do Rio de Janeiro.  

Aprovada em 27 de fevereiro de 2018. 

Banca Examinadora   

_____________________________________________ 
Prof. Dr. Roberto Alfonso Olivares Jara (Orientador) 
Instituto de Matemática e Estatística - UERJ 

_____________________________________________ 
Profª. Dra. Patrícia Nunes da Silva 
Instituto de Matemática e Estatística - UERJ 

_____________________________________________ 
Prof. Dr. Johnny Villavicencio Tafur 
Centro Universitário Carioca 

Rio de Janeiro 

2018

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
DEDICATÓRIA 

À memória do prof. Elon Lages Lima. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AGRADECIMENTOS 

Não posso deixar de agradecer ao meu orientador, pelo comprometimento, seriedade, 

apoio  e  todo  esforço  que  dedicou,  a  despeito  dos  problemas  médicos  que  teve  (desejo 

melhoras!). E pelo seu olhar rigoroso, que escrutinou cada detalhe deste trabalho, acusando com 

propriedade  desde  os  meus  erros  matemáticos  até  os  de  estilo  e  gramática  –  apesar  de  o 

português não ser sua língua materna. 

Agradeço  aos  meus  pais,  que  sempre  se  orgulharam  de  mim,  mesmo  talvez  não 

entendendo  muito  bem  o  que  é  Matemática,  nem  para  que  serve  exatamente  um  curso  de 

Mestrado. Nem mesmo “a quem terá puxado esse garoto para escolher fazer uma coisas dessas 

da sua vida? Puxa, criei com tanto carinho!”. 

Agradeço  aos  Mestres  que  tive,  colegas  professores  e  excelentes  alunos  com  quem 

aprendi e continuo aprendendo. 

Mas o meu maior agradecimento tem de ser para minha grande companheira de vida, 

Josineia Mendes da Costa, que está tão presente e de modo tão impactante há tanto tempo em 

minha história que chega a ser impossível dimensionar sua importância. Eu não seria professor 

de Matemática se não fosse pela sua influência. Mas não é só isso. Eu não teria ido aos lugares 

que eu fui, tomado as decisões que tomei, conhecido as músicas que ouço, abraçado as ideias 

que defendo, não moraria onde moro, não usaria as roupas que visto, não seria feliz como eu 

sou.  Eu  simplesmente  não  existiria,  teria  sido  uma  pessoa  completamente  diferente. 

Irreconhecivel. Um estranho pra mim mesmo. Mas por um capricho do cosmos, do destino, do 

universo, das leis da probabilidade quântica – o que seja – nos encontramos. E por isso, para o 

bem ou para o mal, eu sou quem eu sou. E ela é quem é. E nós somos um. 

 
 
 
 
 
 
 
 
 
 
 
 
Um problema que vale a pena ser atacado prova seu valor contra-atacando  

Piet Hein 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESUMO 

COSTA, Isaque Damião Siqueira. Código de Hamming: detecção e correção de erros. 2018. 
65 f. Dissertação (Mestrado em Matemática) – PROFMAT, Universidade do Estado do Rio 
de Janeiro, Rio de Janeiro, 2018. 

Neste  trabalho,  vamos  estudar  o  uso  de  códigos  para  transmissões  mecânicas  e 
eletrônicas de dados, e os métodos matemáticos usados para a detecção e correção de erros de 
envio. A detecção de erros será feita por dígitos de checagem, exemplificadas nos seguintes 
códigos: CPF, UPC e ISBN. Para correção de erros, veremos os códigos de Hamming. 

Palavras-chave: Código de Hamming. Correção de erros. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ABSTRACT 

COSTA, Isaque Damião Siqueira. Hamming’s code: error detection and correction. 2018. 65 
f. Dissertação (Mestrado em Matemática) – PROFMAT, Universidade do Estado do Rio de 
Janeiro, Rio de Janeiro, 2018. 

In  this  work,  we  will  study  the  use  of  codes  for  mechanical  and  electronic  data 
transmissions, and the mathematical methods used for the detection and correction of sending 
errors. Error detection will be made by check digits, exemplified in the following codes: CPF, 
UPC and ISBN. For error correction, we will see the Hamming codes.  

Keywords: Hamming codes. Error correction. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE FIGURAS 

Figura 1 – 

Visor da calculadora.................................................................................. 

Figura 2 – 

Código de barras........................................................................................ 

Figura 3 – 

Código de barras........................................................................................ 

24 

32 

33 

Figura 4 – 

Relatório de processamento....................................................................... 

35 

Figura 5 – 

Código de barras........................................................................................ 

38 

 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE TABELAS 

Tabela 1 – 

Adição 

em 

18 

em 

1 

2 

3 

18 

25 

25 

26 

26 

28 

29 

31 

32 

37 

38 

40 

42 

43 

Tabela 

10- 

Tabela 

11- 

Tabela 2 – 

ℤ2................................................................................................... 

Tabela 3 – 

Multiplicação 

Tabela 4 – 

ℤ2........................................................................................ 

Tabela 5 – 

Tabela 

Tabela 6 – 

ASCII................................................................................................... 

Tabela 7 – 

Código 

guindaste 

Tabela 8 – 

......................................................................................... 

Tabela 9 – 

Código 

guindaste 

......................................................................................... 

Código 

guindaste 

......................................................................................... 

Codigo 

SDR1................................................................................................... 

Tabela 

Codigo 

12- 

SDR2................................................................................................... 

Tabela 

Adição 

13- 

ℤ10................................................................................................. 

Tabela 

Multiplicação 

14- 

Tabela 

15- 

ℤ10.......................................................................................  Adição 

ℤ11................................................................................................. 

Multiplicação 

ℤ11....................................................................................... 

Comparação 

em 

em 

em 

em 

de 

códigos...................................................................................  Hamming  1 

...................................................................................................... 

Hamming 

2 

...................................................................................................... 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
LISTA DE ABREVIATURAS E SIGLAS 

ASCII 

American Standard Code for Information Interchange 

CPF 

Cadastro de Pessoas Físicas 

ISBN  

International Standard Book Number 

LD  

LI  

UPC  

SDR 

Linearmente dependente 

Linearmente independente 

Universal Product Code 

Sistema de direcionamento remote 

 
 
 
 
 
 
SUMÁRIO 

1 

1.1 

1.2 

1.3 

2 

3 

3.1 

3.2 

3.3 

3.4 

4 

4.1 

4.2 

4.3 

4.4 

5 

5.1 

5.2 

6 

INTRODUÇÃO.............................................................................................. 

RESULTADOS PRELIMINARES............................................................... 

Aritmética modular........................................................................................ 

Espaço e subespaço vetorial........................................................................... 

Produto interno, norma e distância.............................................................. 

CÓDIGOS....................................................................................................... 

DETECÇÃO DE ERROS.............................................................................. 

Dígito de checagem......................................................................................... 

UPC: código de barras................................................................................... 

ISBN: código de identificação de livros........................................................ 

CPF: Cadastro de Pessoas Físicas ............................................................... 

CORREÇÃO DE ERROS............................................................................. 

Matriz  geradora  padrão  e  matriz  de  verificação  de  paridade 

padrão............................................................................................................. 

Matriz geradora e matriz de verificação de paridade................................. 

Códigos lineares.............................................................................................. 

Códigos duais e autoduais.............................................................................. 

MÉTRICA DE HAMMING.......................................................................... 

Distância de Hamming................................................................................... 

Códigos de correção de erros......................................................................... 

CÓDIGO DE HAMMING............................................................................. 

CONCLUSÃO................................................................................................. 

REFERÊNCIAS.............................................................................................. 

14 

15 

15 

18 

21 

24 

28 

28 

31 

35 

40 

42 

42 

45 

50 

51 

56 

56 

58 

63 

65 

66 

 
 
 
 
 
 
 
 
 
 
15 

INTRODUÇÃO 

Neste  trabalho,  vamos  estudar  o  uso  de  códigos  lineares  para  o  envio  de  transmissões 

eletrônicas,  e  os  métodos  matemáticos  usados  para  a  detecção  e  correção  de  erros  nessas 

transmissões. Deste modo, teremos a oportunidade de explorar a aplicação de conceitos como 

vetores e matrizes em problemas reais, com a possibilidade de justificar para o aluno do ensino 

médio a importância desses conteúdos para além da sala de aula. 

A  ubiquidade  da  informática  em  nossos  dias  e  o  exercício  da  cidadania  nos  oferecem  uma 

variedade de exemplos, acessíveis pela experiência quotidiana como os dígitos verificadores 

dos documentos oficiais de identificação (CPF), os códigos de barras dos produtos (UPC), o 

sistema ISBN de catalogação de livros, e etc.  

Em seguida, nos concentraremos nos códigos lineares – em particular nos códigos Hamming  

para correção de erros de transmissão, tomando como base principalmente Poole (2014). 

 
 
 
 
 
 
 
16 

1. RESULTADOS PRELIMINARES 

1.1. Aritmética modular 

Apresentamos nesta seção, de maneira resumida, uma construção e as principais propriedades 

do  conjunto  das  classes  de  congruências  módulo  um  número  inteiro.    Tais  resultados  serão 

utilizados por todo o texto. O leitor interessado em maiores esclarecimentos, ou em aprofundar 

os resultados apresentados aqui, pode consultar Hefez (2002). 

Definição 1.1.1.  

Sejam 𝑎, 𝑏, 𝑘 inteiros com 𝑘 > 0.  Dizemos que 𝒂 é congruente a 𝒃 módulo 𝒌, e escrevemos 

“𝑎 ≡ 𝑏 mod 𝑘”, quando 𝑘 divide 𝑎 − 𝑏. 

Exemplo:  25 ≡ 13 mod 6,  pois  6  divide  25 − 13  = 12.    Analogamente,  −10 ≡ 4 mod 7, 

pois 7 divide −10  − 4  =   −14.  

Definição 1.1.2.  

Sejam 𝑎 e 𝑘 inteiros com 𝑘 > 0.  A classe de congruência de 𝒂 módulo 𝒌, denotada por [𝑎], 

consiste em todos os números inteiros que são congruentes a 𝑎 módulo 𝑘, isto é, 

Dizer que 𝑏 ≡ 𝑎 mod 𝑘 significa que 𝑏 − 𝑎 = 𝑛𝑘 para algum inteiro 𝑛 ou, equivalentemente, 

[𝑎] = {𝑏: 𝑏  ∈ ℤ 𝑒 𝑏  ≡  𝑎 𝑚𝑜𝑑 𝑘}. 

que 𝑏 = 𝑎 + 𝑛𝑘.  Assim 

[𝑎]   =   {𝑎  +  𝑛𝑘 ∶  𝑛 ∈ ℤ}. 

Exemplo: Na congruência módulo 5 temos 

[11] =   {11  +  5𝑛: 𝑛 ∈ ℤ} = {11, 11 ± 5, 11 ± 10, 11 ± 15, . . . }  

=   {. . . , −14, −9, −4, 1, 6, 11, 16, 21, 24, . . . }. 

Um importante resultado sobre as classes de congruências é o seguinte. 

Teorema 1.1.3.   

Seja 𝑘 um número inteiro maior do que 1. 

i) Se 𝑎 é um número inteiro e 𝑟 é seu resto (0 ≤ 𝑟 < 𝑘) quando dividido por 𝑘, então [𝑎] = [𝑟]. 

 
 
 
 
 
 
 
 
 
 
 
17 

ii)  Existem  exatamente  𝑘  distintas  classes  de  congruências  módulo  𝑘,  a  saber 

[0], [1], [2], . . . , [𝑘 − 1]. 

O conjunto de todas as classes de congruências modulo 𝑘 é denotado por ℤ𝑘, isto é, 

ℤ𝑘 = {[0], [1], [2], . . . , [𝑘 − 1]}. 

Em ℤ𝑘 são definidas para quaisquer [𝑎] e [𝑏] em ℤ𝑘 as seguintes duas operações: 

[𝑎] + [𝑏] = [𝑎 + 𝑏] 

[𝑎] × [𝑏] = [𝑎 × 𝑏]. 

Exemplo: Em ℤ6 temos [3] + [5] = [3 + 5] = [8] = [2] e [2] × [5] = [2 × 5] = [10] =

[4]. 

De agora em diante toda classe de congruência [𝑎] será denotada apenas por 𝑎. 

As operações de adição e multiplicação no conjunto ℤ𝑘 possuem as seguintes propriedades para 

quaisquer 𝑎, 𝑏, 𝑐 em ℤ𝑘: 

Proposição 1.1.4.  

Propriedades de ℤ𝑘. 

P1) Comutatividade:   

𝑎 + 𝑏 = 𝑏 + 𝑎 

𝑎 ∙ 𝑏 = 𝑏 ∙ 𝑎 

P2) Associatividade:   

(𝑎 + 𝑏) + 𝑐 = 𝑎 + (𝑏 + 𝑐)  (𝑎 ∙ 𝑏) ∙ 𝑐 = 𝑎 ∙ (𝑏 ∙ 𝑐) 

P3) Existência do elemento neutro:  𝑎 + 0 = 𝑎 

𝑎 ∙ 1 = 𝑎. 

P4) Existência do elemento oposto:  Para cada 𝑎 ∈ ℤ𝑘 existe um único elemento −𝑎 ∈ ℤ𝑘 tal 

que 𝑎  +   (−𝑎)   =  0  =   −𝑎  +  𝑎. E −𝑎 é chamado o “oposto” de 𝑎. 

P5) Distributividade:   

(𝑎 + 𝑏) ∙ 𝑐 = 𝑎 ∙ 𝑐 + 𝑏 ∙ 𝑐. 

Em geral, qualquer conjunto munido de duas operações (adição e multiplicação) satisfazendo 

as cinco propriedades acima é chamado de anel comutativo com identidade.  Os Principais 

modelos para essa estrutura algébrica são o conjunto ℤ dos números inteiros e o conjunto ℤ𝑘. 

Um diferencial entre anéis, e em particular entre os anéis ℤ e ℤ𝑘, é o seguinte:  

Definição 1.1.5.  

Um domínio de integridade é um anel comutativo com identidade que satisfaz a propriedade: 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
18 

P6) Se  𝑎 ∙ 𝑏 = 0, então 𝑎 = 0 ou 𝑏 = 0. 

Equivalentemente, num domínio de integridade, o produto de dois elementos não nulos é não 

nulo. Sabe-se que ℤ goza dessa propriedade e ℤ𝑘 não. De fato, em ℤ10 por exemplo, tem-se que 

2 ≠ 0 e 5 ≠ 0, mas 2 ∙ 5  =  10  =  0. 

Um caso muito importante, tratando-se da estrutura algébrica de ℤ𝑘, acontece quando 𝑘 = 𝑝 é 

um número primo.  Observe primeiramente que em ℤ os únicos elementos que possuem inverso 

(multiplicativo) são 1 e −1 enquanto que em ℤ𝑝 todos os elementos não nulos possuem inverso 

(lembre que um elemento 𝑎 ∈ ℤ𝑘 é invertível se, e somente se, 𝑚𝑑𝑐(𝑎, 𝑘)   =  1)) . Daí segue 

que ℤ𝑝 com 𝑝 primo se enquadra na seguinte estrutura. 

Definição 1.1.6.   

Um corpo é um anel comutativo com identidade que satisfaz a propriedade: 

P7) Para cada  𝑎 ≠ 0, existe um  único elemento  𝑎−1 tal que  𝑎 ∙ 𝑎−1 = 𝑎−1 ∙ 𝑎 = 1. E  𝑎−1 é 

chamado o “inverso” de 𝑎. 

Exemplo: Em ℤ5, os elementos 1, 2, 3, e 4 são invertíveis e: 
1−1 = 1 

2−1 = 3  

3−1 = 2  

4−1 = 4 

Os principais modelos para a estrutura de corpo são os conjuntos numéricos ℚ dos números 

racionais,  ℝ  dos  números  reais,  juntamente  com  o  conjunto  ℤ𝑝  de  todas  as  classes  de 

congruências módulo um primo 𝑝. 

Corolário 1.1.7. Todo corpo é um domínio de integridade1. 

Demonstração.  Suponha que 𝑎 ∙ 𝑏 = 0.  Se 𝑎 = 0 não há o que demonstrar. Suponha agora 

que 𝑎 ≠ 0.  Logo 𝑎 é invertível (isto é, existe 𝑎−1 no corpo). Multiplicando pelo inverso de 𝑎 

na igualdade 𝑎 ∙ 𝑏 = 0 temos: 

𝑎−1 ∙ 𝑎 ∙ 𝑏 = 𝑎−1 ∙ 0 

1 ∙  𝑏  =  0 

𝑏  =  0. 

1Em particular ℤ𝒑 com 𝒑 primo também o é 

 
 
 
 
 
 
 
 
                                                 
19 

Exemplo: Como 2 é primo, ℤ2 é um corpo, as operações de adição e multiplicação em ℤ2 =

{0, 1} são do seguinte modo: 

0 + 0 = 0 

0 + 1 = 1 

1 + 0 = 1 

1 + 1 = 0 

0 ∙ 0 = 0 

0 ∙ 1 = 0 

1 ∙ 0 = 0 

1 ∙ 1 = 1 

De forma mais compacta, podemos escrever: 

+ 

0 

1 

0 

0 

1 

1 

1 

0 

∙ 

0 

1 

0 

0 

0 

1 

0 

1 

Tabela 1. Adição em ℤ2. 

Tabela 2. Multiplicação em ℤ2. 

1.2. Espaço e subespaço vetorial 

Apresentamos nesta seção um resumo dos conceitos de álgebra linear que serão necessários ao 

longo do trabalho. Mais detalhes podem ser obtidos em Poole (2014). 

Definição 1.2.1. (Espaço vetorial)  

Um conjunto 𝑉 não vazio é dito um espaço vetorial sobre um corpo 𝐾 (por exemplo, ℚ, ℝ ou 

ℂ), se: 

a) Se 𝑢, 𝑣 ∈ 𝑉, então 𝑢 + 𝑣 ∈ 𝑉.  

b) Se 𝑣 ∈ 𝑉 e 𝑘 ∈ 𝐾, então 𝑘 ∙ 𝑣 ∈ 𝑉.  

Com as seguintes propriedades. 

Considere 𝑢, 𝑣, 𝑤 ∈ 𝑉 e 𝛼, 𝛽 ∈ 𝐾. 

P1) 𝑢 + 𝑣 = 𝑣 + 𝑢. 

P2) (𝑢 + 𝑣) + 𝑤 = 𝑢 + (𝑣 + 𝑤). 

P3) Existe 0 ∈ 𝑉, tal que para todo 𝑣 ∈ 𝑉, temos que: 𝑣 + 0 = 𝑣. 

P4) Existe −𝑣 ∈ 𝑉, tal que para todo 𝑣 ∈ 𝑉, temos que: 𝑣 + (−𝑣) = 0. 

P5) 𝛼(𝑢 + 𝑣) = 𝛼𝑢 + 𝛼𝑣. 

P6) (𝛼 + 𝛽)𝑣 = 𝛼𝑣 + 𝛽𝑣. 

P7) 𝛼(𝛽𝑢) = (𝛼𝛽)𝑢. 

P8) 1 ∙ 𝑢 = 𝑢. 

 
 
 
 
 
 
 
 
 
20 

Fazendo 𝐾 = ℝ, temos os seguintes exemplos de espaços vetoriais: 

a) ℝ𝑛, com 𝑛 ∈ ℕ\{0}: conjunto de todas as 𝑛-uplas de componentes reais. 

b) 𝑀𝑚×𝑛(ℝ): conjunto de todas as matrizes reais de 𝑚 linhas e 𝑛 colunas, com elementos reais. 
c)  {𝑎𝑛𝑥𝑛 + 𝑎𝑛−1𝑥𝑛−1 + ⋯ + 𝑎1𝑥 + 𝑎0|𝑎𝑖 ∈ ℝ, 𝑖 = 1, 2, … , 𝑛 }:  conjunto  de 
polinômios de grau menor ou igual a 𝑛, incluindo o polinômio identicamente nulo. 

todos  os 

Fazendo 𝐾 = ℤ𝑝, com 𝑝 primo, temos que ℤ𝑝

𝑛 é um espaço vetorial. 

Observação: os elementos de um espaço vetorial são ditos vetores. 

Um código pode ser criado tomando como símbolos vetores sobre ℤ𝑘. Definimos ℤ𝑘

𝑛 o conjunto 
𝑛 = {(𝑥1, 𝑥2, … . . , 𝑥𝑛): 𝑥1, 𝑥2, … . 𝑥𝑛 ∈

de todos os vetores com 𝑛 coordenadas em ℤ𝑘. Isto é, ℤ𝑘

ℤ𝑘}.  

Quando 𝑘 = 2, dizemos que os elementos de ℤ2

𝑛 formam um código binário de comprimento 

𝑛.  Por exemplo, a tabela ASCII é um exemplo de código binário (aceita apenas coordenadas 

iguais a zero ou um) de comprimento 8 (têm exatamente oito coordenadas) e (0, 1, 1, 0, 0, 0, 0, 

1) é um de seus símbolos, mais especificamente, o que representa o caractere “a”. 

Definição 1.2.3 (Subespaço vetorial)  

𝑊 é subespaço vetorial de 𝑉 se:  

a) 𝑊 é um subconjunto não vazio de 𝑉; e 

b) 𝑊 é um espaço vetorial, em relação às mesmas operações definidas em V. 

Na prática, para concluir que 𝑊 é subespaço vetorial de 𝑉, basta verificar que: 

a) 0 ∈ 𝑊 

b) Se 𝑢, 𝑣 ∈ 𝑊, então 𝑢 + 𝑣 ∈ 𝑊.  

c) Se 𝑣 ∈ 𝑊 e 𝑘 ∈ 𝐾, então 𝑘 ∙ 𝑣 ∈ 𝑊.  

Observação: {0} e 𝑉 são ditos subespaços triviais de 𝑉. 

Subespaços vetoriais de ℝ2: 

a) a origem; 

b) toda reta que contém a origem; 

c) o próprio ℝ2. 

 
 
 
 
 
 
 
 
 
21 

Subespaços vetoriais de ℝ3: 

a) a origem; 

b) toda reta que contém a origem; 

c) todo plano que contém a origem; 

d) o próprio ℝ3. 

2: 
Subespaços vetoriais de ℤ2

a) {[

]} 

0
0
0
0
0
0

b) {[

] , 𝑣}, onde 𝑣 pode ser [

] , [

1
0

0
1

] ou [

1
1

] 

c) {[

] , [

] , [

] , [

1
0

0
1

1
1

2. 
]} que é o próprio ℤ2

Definição 1.2.4 (Combinação linear)  

Considere  𝑢1, 𝑢2, … , 𝑢𝑛−1, 𝑢𝑛 ∈ 𝑉.  Dizemos  que  𝑢𝑛  é  uma  combinação 

linear  de 

𝑢1, 𝑢2, … , 𝑢𝑛−1 se existem 𝛼1, 𝛼2, … , 𝛼𝑛−1 ∈ 𝐾 tais que: 

𝑢𝑛 = 𝛼1𝑢1 + 𝑎2𝑢2 + ⋯ + 𝛼𝑛−1𝑢𝑛−1 

Definição 1.2.5 (Dependência linear)  

Um conjunto 𝑢1, 𝑢2, … , 𝑢𝑛−1, 𝑢𝑛 ∈ 𝑉 é dito linearmente independente (L.I.) quando: 

𝛼1𝑢1 + 𝛼2𝑢2 + ⋯ + 𝛼𝑛𝑢𝑛 = 0 ⇒ 𝛼1 = 𝛼2 = ⋯ = 𝛼𝑛 = 0 

Caso  contrário,  o  conjunto  é  dito  linearmente  dependente  (L.D.)  e  existe  um  elemento  do 

conjunto que pode ser escrito como combinação linear dos outros. 

Definição 1.2.6. (Vetores geradores)  

Se 𝐵 = {𝑣1, 𝑣2, … , 𝑣𝑛} ⊂ 𝑉 e todo elemento de 𝑉 pode ser escrito como combinação linear dos 

elementos de 𝐵, então dizemos que 𝑣1, 𝑣2, … , 𝑣𝑛 são geradores de 𝑉 e indicamos por: 

𝑔𝑒𝑟(𝑣1, 𝑣2, … , 𝑣𝑛) = 𝑉 

O conjunto de geradores de um espaço vetorial não é único. 

Definição 1.2.7 (Base)  

Dizemos que {𝑣1, 𝑣2, … , 𝑣𝑛} é uma base de 𝑉, se: 

 
 
 
 
 
 
 
 
 
 
22 

a) 𝑔𝑒𝑟(𝑣1, 𝑣2, … , 𝑣𝑛) = 𝑉; e 

b) 𝑣1, 𝑣2, … , 𝑣𝑛 são L.I. 

Teorema 1.2.8.  

Se 𝐵1 = {𝑣1, 𝑣2, … , 𝑣𝑛} e 𝐵2 = {𝑢1, 𝑢2, … , 𝑢𝑚} são bases de 𝑉, então 𝑚 = 𝑛. 

Observação. Nas condições do Teorema 1.2.8, dizemos que 𝑛 é a dimensão de 𝑉, e indicamos 

𝑑𝑖𝑚 𝑉 = 𝑛. 

1.3. Produto interno, norma e distância 

Definição 1.3.1 (Produto interno) 

Seja V um espaço vetorial.  Um Produto interno em V é uma função que a cada par de vetores 

u e v em V associa o número real 〈𝑢, 𝑣〉 que satisfaz as seguintes propriedades: 

1.  〈𝑢, 𝑣〉 = 〈𝑣, 𝑢〉 

2.  〈𝑢, 𝑣 + 𝑤〉 = 〈𝑢, 𝑣〉 + 〈𝑢, 𝑤〉 

3.  〈𝑐𝑢, 𝑣〉 = 𝑐〈𝑢, 𝑣〉 

4.  〈𝑢, 𝑢〉 ≥ 0 e 〈𝑢, 𝑢〉 = 0 se, e somente se, 𝑢 = 0 

Onde 𝑢, 𝑣 e 𝑤 são quaisquer vetores em V e 𝑐 é qualquer escalar. 

Definição 1.3.2 (Produto interno usual) 
Sejam 𝑢 = (𝑢1, 𝑢2, … , 𝑢𝑛) e 𝑣 = (𝑣1, 𝑣2, … , 𝑣𝑛) em ℝ𝑛.  Definimos 
〈𝑢, 𝑣〉 = 𝑢1 ∙ 𝑣1 + 𝑢2 ∙ 𝑣2 + ⋯ + 𝑢𝑛 ∙ 𝑣𝑛. 

É fácil ver que a operação acima define um produto interno, chamado de produto interno usual 
de ℝ𝑛.  Sem qualquer problema pode-se considerar também o produto interno usual em ℤ2
vez de ℝ𝑛.  Neste caso, <u, v> 𝜖 ℤ2.  
A partir de agora vamos usar a notação 𝑢 ∙ 𝑣 para representar o produto interno usual. 

𝑛 em 

Definição 1.3.3 (Vetores ortogonais) 

Quando 𝑢 ∙ 𝑣 = 0, dizemos que o vetores 𝑢 e 𝑣 são ortogonais. 

Definição 1.3.4 (Norma) 

 
 
 
 
 
 
 
 
 
 
 
23 

Uma norma em um espaço vetorial V é uma aplicação que associa a cada vetor v  um número 

real ‖𝑣‖, chamado norma de v, de modo que as seguintes propriedades sejam satisfeitas para 

todos os vetores u e v e todos os escalares c: 

1.  ‖𝑣‖ ≥ 0 e ‖𝑣‖ = 0 se, e somente se, 𝑣 = 0 

2.  ‖𝑐𝑣‖ = |𝑐| ∙ ‖𝑣‖  

3.  ‖𝑢 + 𝑣‖ ≤ ‖𝑢‖ + ‖𝑣‖  

Existem vários tipos de norma, segue abaixo dois exemplos. 

Definição 1.3.5 (Norma do produto interno). 

Em qualquer espaço vetorial com produto interno, ‖𝑣‖ = √< 𝒗, 𝒗 > define uma norma. 
Como ilustração, considerando ℝ𝑛com o produto interno usual usual: 

Se 𝑢 = (𝑢1, 𝑢2, … 𝑢𝑛), então 

‖𝑢‖ = √𝒖 ∙  𝒖 = √𝑢1

2 + 𝑢2

2 + ⋯ + 𝑢𝑛
2 

Exemplo: ‖(3, 4, 0)‖ = √32 + 42 + 02 = 5 

Definição 1.3.6 (Norma de Hamming) 

Considere o vetor 𝑢 ∈ ℤ2

𝑛, então a norma de Hamming é dada por 

‖𝑢‖𝐻 = 𝑤(𝑢) 
Onde 𝑤(𝑢) é chamado peso de 𝑢 e corresponde à quantidade de 1’s que existem no vetor 𝑢. 

Exemplo: ‖(1, 0, 1, 0, 1)‖𝐻 = 𝑤(1, 0, 1, 0, 1) = 3. 

Definição 1.3.7 (Distância) 

Em  qualquer  espaço  vetorial  normado,  a  distância  entre  os  vetores 𝑢  e  𝑣  é  o  número  real 

𝑑(𝑢, 𝑣) = ‖𝑢 − 𝑣‖.   

As seguintes propriedades são válidas para todos os vetores u, v e w em V: 

1.  𝑑(𝑢, 𝑣) ≥ 0 e 𝑑(𝑢, 𝑣) = 0 se, e somente se, 𝑢 = 𝑣. 

2.  𝑑(𝑢, 𝑣) = 𝑑(𝑣, 𝑢) 

3.  𝑑(𝑢, 𝑤) ≤ 𝑑(𝑢, 𝑣) + 𝑑(𝑣, 𝑤). 

Para uma demostração das afirmações contidas nas definições 1.3.6 e 1.3.7 veja por exemplo 

o exemplo 4 e o Teorema 1, respectivamente, da seção 7.3 do livro de David Pool citado na 

bibliografia. 

 
 
 
 
 
 
 
 
24 

Definição 1.3.8 (Distância de Hamming) 

Como em ℤ2, u−v = u + v, a distância 

𝑑𝐻(𝑢, 𝑣) = ‖𝑢 − 𝑣‖𝐻 = ‖𝑢 + 𝑣‖𝐻 = 𝑤(𝑢 + 𝑣) 

é chamada distância de Hamming. 

Uma função distãncia 𝑑 com essas propriedades é chamada de métrica. Um espaço vetorial 

que possui uma métrica é chamado de espaço métrico.  Daí, a distância de Hamming  é também 

chamada de métrica de Hamming. 

 
 
 
 
 
 
25 

2. CÓDIGOS 

A função primária de um código é permitir a comunicação de informações. A língua portuguesa, 

com suas palavras e regras para combiná-las é um bom exemplo de código altamente complexo 

cujo aprendizado é uma tarefa para anos. Essa complexidade é necessária porque a língua exige 

grande versatilidade, para que ela seja apta à codificação dos mais variados assuntos e estilos: 

desde textos técnicos científicos, onde se espera o máximo de precisão; aos textos poéticos ou 

humorísticos, onde propositadamente se explora a polissemia e a ambiguidade. 

Por outro lado, um código criado exclusivamente para um assunto mais específico pode e deve 

ser mais simples, como, por exemplo, as placas de trânsito, que podem ambicionar criar figuras 

e símbolos de entendimento universal. Entretanto, algumas vezes o código tem como objetivo 

não ser compreendido por pessoas não autorizadas. Para esse fim, utiliza-se desde o início da 

civilização  as  técnicas  de  criptografia,  como  o  sistema  do  imperador  romano  César  de 

permutação de letras. 

De acordo com Formiga (2005) 

O primeiro relato de um algoritmo de criptografia que se tem é conhecido como 
algoritmo de César, usado pelo imperador Júlio César na Roma Antiga. Era um 
algoritmo simples que fazia substituições alfabéticas no texto da mensagem. As 
substituições  aconteciam  trocando  letras  por  outras,  três  posições  à  frente  no 
alfabeto, ou seja, a letra A seria substituída por D, a letra B por E, e assim por 
diante como mostrado a seguir.  

Texto simples: Vamos atacar o norte durante a noite.  
Texto cifrado: Zdprv dxdfdu r qruxh gyudqxh d qrlxh. 

Códigos eletrônicos 

As máquinas de calcular compartilham um modo interessante de codificar os algarismos de um 

número. Elas se utilizam de um padrão de sete barras, no qual algumas são iluminadas e outras 

ficam apagadas. Por exemplo, para codificar o algarismo oito, todas as sete barras são acesas.  

Figura 1. Visor calculadora 

 
 
 
 
 
 
 
 
 
 
 
26 

Como cada uma das sete barras admite duas possibilidades (acesa ou apagada), cada espaço no 

visor de uma máquina de calcular desse tipo pode codificar até 27 − 1 = 127 símbolos. Repare 

que a situação em que as sete barras estão apagadas não codifica símbolo algum. 

Uma  estratégia  semelhante  é  usada  pelos  computadores,  nos  quais  cada  byte  (unidade  de 

armazenamento) é codificado por oito bits. Um bit é um algarismo binário, ou seja, cujo valor 

é zero ou um, que podem ser associados com os estados de desligado e ligado, respectivamente. 

Assim, cada byte é capaz de codificar 28 − 1 = 255 símbolos. (O byte 00000000 não é usado). 

Desta forma, cada sequência de oito dígitos cada um deles igual a zero ou um, pode codificar 

um  símbolo,  que  pode  ser  uma  letra  maiúscula,  minúscula,  algarismo,  e  outros.  A  seguir, 

apresentamos uma parte da tabela ASCII, que permite fazer a conversão entre o conteúdo de 

um byte e seu significado.  

Tabela 3. Tabela ASCII .Fonte: Brooksher (2003) 

Detecção e correção de erros 

Considere o código binário abaixo que controla o braço de um guindaste. 

COMANDO  CÓDIGO 

DESCER 

SUBIR 

0 

1 

Tabela 4. Código guindaste 1 

Levando em conta a falta de confiabilidade na transmissão de informações, a aplicação desse 

código na prática seria no mínimo imprudente. Imagine que haja um erro no envio que troque 

 
 
 
 
 
 
 
27 

o valor de zero por um. Isso pode fazer, por exemplo, com que a máquina tente ir além do seu 

limite técnico, provocando um acidente. Tudo porque o erro na transmissão gera uma palavra-

código válida, ou seja, porque o erro não pode ser detectado. 

Neste caso, podemos rapidamente vislumbrar uma solução simples: acrescentar mais um dígito 

pode tornar o código detector de erros. De fato, o código abaixo é detector,  

COMANDO  CÓDIGO 

DESCER 

SUBIR 

00 

11 

Tabela 5. Código guindaste 2 

pois um erro simples (alteração de apenas uma componente) de envio no código 00 gera 01 ou 

10, que não são códigos válidos. O mesmo ocorre se houver um erro simples no envio do código 

11, que pode gerar os códigos 10 ou 01, ambos inválidos.  

Entretanto esse código não é corrigível, pois se o código recebido for 01 ou 10, o receptor não 

poderá identificar qual é a mensagem correta. Portanto, nestes casos, seria necessário programar 

um protocolo na máquina para solicitar um reenvio do comando. 

Por uma questão de eficiência, ou mesmo de necessidade, pode não ser desejável ou possível 

esperar  por  esse  reenvio.  Seria  preciso,  nestes  casos,  criar  uma  maneira  de  que  a  própria 

máquina pudesse ser capaz de corrigir o erro sem auxílio externo, da mesma forma que um 

editor de texto troca a palavra HIPOPÓTANO por HIPOPÓTAMO. 

Surge a necessidade de criar um código não somente detectável, mas também corrigível. Veja 

que novamente podemos encontrar a solução na redundância. Acrescentar um terceiro dígito ao 

código torna-o corretor de erros. De fato, o código abaixo é corretor, 

COMANDO  CÓDIGO 

DESCER 

SUBIR 

000 

111 

Tabela 6. Código guindaste 3 

pois:  

Um erro simples de envio em 000 gera: 001, 010, 100. 

Um erro simples de envio em 111 gera: 011, 101, 110. 

Neste  trabalho  estudaremos  alguns  exemplos  de  códigos  detectores  (Capítulo  3)  e  veremos 

como criar um código corretor (Capítulos 4 a 6) de Hamming, e porque eles funcionam. 

 
 
 
 
 
 
 
 
28 

De acordo com Hefez (2008) 

A  Teoria  dos  Códigos  Corretores  de  Erros  foi  fundada  pelo  matemático  C.E. 
Shannon, do Laboratório Bell, num trabalho publicado em 1948. Inicialmente, 
os  maiores  interessados  em  Teoria  dos  Códigos  foram  os  matemáticos  que  a 
desenvolveram seriamente nas décadas de 50 e 60. A partir da década de 70, com 
as pesquisas espaciais e a grande popularização dos computadores, essa teoria 
começou  a  interessar  também  aos  engenheiros.  Hoje  em  dia,  os  códigos 
corretores de erros são utilizados sempre que se deseja transmitir ou armazenar 
dados,  garantindo  a  sua  confiabilidade.  São  exemplos  disso  todas  as 
comunicações via satélite, as comunicações internas de um computador, [...] ou 
o armazenamento ótico de dados. 

De acordo com Poole (2014) 

Richard  W.  Hamming  (1915  –  1988)  obteve  seu  Ph.D  em  Matemática  na 
Universidade de Illinois, em 1942. [...] De 1946 a 1976, trabalhou no Bell Labs, 
depois  integrou-se  ao  corpo  docente  na  US  Naval  Postgraduate  School,  em 
Monterey,  Califórnia.    Em  1950,  publicou  seu  trabalho  fundador  em  códigos 
corretores  de  erros,  dando  uma  construção  explícita  para  os  códigos  de 
otimização que Claude Shannon tinha provado serem teoricamente possíveis, em 
19482. 

2Os 

artigos 

originais 

de 

Hamming 

e 

Shannon 

podem 

ser 

acessados 

em: 

http://www.sns.ias.edu/~tlusty/courses/InfoInBio/Papers/Hamming1950.pdf 

e 

http://worrydream.com/refs/Shannon%20-%20A%20Mathematical%20Theory%20of%20Communication.pdf, 

respectivamente. 

 
 
 
 
 
 
 
 
 
 
 
 
 
                                                 
 
29 

3. DETECÇÃO DE ERROS 

Infelizmente, a transmissão de um código não é absolutamente confiável. Do mesmo modo que 

em  uma  conversa  algumas  palavras  podem  não  ser  ouvidas  ou  mal  compreendidas  pelo 

interlocutor, também nas comunicações eletrônicas alguns dados se perdem ou são alterados 

durante a transmissão. Por exemplo, um zero pode ser trocado por um durante o envio de um 

byte. Por esse motivo, é útil dispor de um mecanismo capaz de identificar a ocorrência desses 

erros. Neste capítulo veremos alguns exemplos de códigos criados com essa motivação. 

3.1. Dígito de checagem 

Considere  um  sistema  de  direção  remota  que  receba  apenas  os  quatro  comandos  abaixo. 

Chamaremos o código abaixo de SDR (Sistema de Direção Remota). 

COMANDO  CÓDIGO 

CIMA 

BAIXO 

001 

010 

ESQUERDA  011 

DIREITA 

100 

Tabela 7. Código SDR 1 

Em determinado momento, é possível que o código enviado seja 011 (ESQUERDA), mas que 

um erro de transmissão troque o primeiro dígito, transmitindo, desta forma, o código incorreto 

111. Como esse código não representa nenhum comando é fácil perceber que houve um erro de 

envio. Entretanto, se o erro tivesse ocorrido no último digito, o código enviado teria sido 010 

(BAIXO), que é um código válido, e, portanto, o erro não seria detectável. 

Uma maneira de contornar esse tipo de situação é inserir um quarto dígito – que chamaremos 

de dígito verificador, ou dígito de checagem – de modo que a soma dos dígitos do código, em 

ℤ2, seja igual a zero. Por exemplo: 

 
 
 
 
 
 
 
 
 
 
 
 
30 

COMANDO  CÓDIGO 

CIMA 

BAIXO 

0011 

0101 

ESQUERDA  0110 

DIREITA 

1001 

Tabela 8. Código SDR 2 

Aplicando a aritmética da soma no conjunto ℤ2, e a propriedade associativa da adição: 

(((0 + 0) + 1) + 1) = ((0 + 1) + 1) = (1 + 1) = 0 

Analogamente: 

0 + 1 + 0 + 1 = 0 

0 + 1 + 1 + 0 = 0 

1 + 0 + 0 + 1 = 0 

Outra maneira de fazer as somas acima é contar a quantidade de dígitos iguais a 1 (um). Se essa 

quantidade  for  par,  a  soma  será  zero,  se  a  quantidade  for  ímpar,  a  soma  será  igual  a  um. 

Portanto, em todo código válido o número de dígitos iguais a um é par. E, no caso de ocorrer 

um erro em apenas um dígito (ou seja, um erro simples), será gerado um código inválido, já 

que a quantidade de dígitos iguais a um será ímpar. Ou seja, se for recebido um código como 

1011 (erro simples no envio da primeira coordenada de CIMA), então será possível constatar a 

ocorrência do erro de envio, pois: 

1 + 0 + 1 + 1 = 1 

Assim, o dispositivo receptor poderá solicitar ao emissor o reenvio da informação. Observe que 

o receptor não tem condições de corrigir o erro, pois de seu ponto de vista, mesmo que ele saiba 

que houve um erro simples, não há como saber em qual das coordenadas ele ocorreu, afinal 

1011 poderia ter se originado de um erro simples na terceira coordenada de DIREITA (1001). 

Outro problema com esse tipo de solução é que um erro em duas coordenadas (mais geralmente, 

em um número par de coordenadas) não seria detectável, pois a soma de suas coordenadas seria 

igual à zero.  

 
 
 
 
 
 
 
31 

Formalizando, o que estamos fazendo é considerar os vetores  𝑢 e 𝑐 sobre ℤ2
código transmitido, e 𝑐 = [1, 1, 1, 1] é o vetor de checagem. Em seguida, calculamos o produto 

4. O vetor 𝑢 é o 

interno 𝑢 ∙ 𝑐, em ℤ2. Se o resultado for diferente de zero, isso significa que o código é inválido. 

Definição 3.1.1.  

Sejam 𝑢 = (𝑢1, 𝑢2, … , 𝑢𝑛) e 𝑣 = (𝑣1, 𝑣2, … , 𝑣𝑛) dois vetores em ℤ𝑚

𝑛 , definimos produto interno 

de 𝑢 por 𝑣, e indicamos por 𝑢 ∙ 𝑣 a soma: 𝑢1 ∙ 𝑣1 + 𝑢2 ∙ 𝑣2 + ⋯ + 𝑢𝑛 ∙ 𝑣𝑛. 

Teorema 3.1.2.  

Sejam os vetores 𝑢 e 𝑐 = [1, 1, 1, … ,1] em ℤ𝑚

𝑛 , e 𝑣 um vetor obtido trocando exatamente um 

dígito de 𝑢. Então 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

Demonstração  

Fazendo 𝑢 = (𝑢1, 𝑢2, … , 𝑢𝑛), temos que:  

Fazendo 𝑣 = (𝑣1, 𝑣2, … , 𝑣𝑛), temos que:  

𝑢 ∙ 𝑐 = 𝑢1 + 𝑢2 + ⋯ + 𝑢𝑛 

𝑣 ∙ 𝑐 = 𝑣1 + 𝑣2 + ⋯ + 𝑣𝑛 

Se  𝑢  e  𝑣  são  idênticos,  exceto  pela  𝑘-ésima  coordenada,  em  símbolos:  𝑢𝑖 = 𝑣𝑖  para  𝑖 =

1, 2, … , 𝑘 − 1, 𝑘 + 1, … 𝑛 e 𝑢𝑘 ≠ 𝑣𝑘, então: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 = (𝑢1 − 𝑣1) + (𝑢2 − 𝑣2) + ⋯ + (𝑢𝑘 − 𝑣𝑘) + ⋯ + (𝑢𝑛 − 𝑣𝑛)

= 0 + 0 + ⋯ + 𝑢𝑘 − 𝑣𝑘 + ⋯ + 0 = 𝑢𝑘 − 𝑣𝑘 ≠ 0 

Portanto, 

Implicando que: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 ≠ 0 

𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐 

O Teorema 3.1.2 mostra que o vetor de checagem  𝑐 = [1,1,1, … ,1]  sempre acusa a ocorrência 

de erros simples, isto é, em apenas uma coordenada. Nas próximas seções veremos aplicações 

dessas ideias em códigos usados na prática. 

3.2. UPC: código de barras 

 
 
 
 
 
 
 
 
 
 
32 

De acordo com Milies (2006), o código UPC (Universal Product Code) foi criado por George 

J.  Laurer  da  IBM  e  passou  a  ser  usado  nos  EUA  e  Canadá  em  1973.  Esse  código  é  uma 

sequência de 12 dígitos decimais (algarismos de 0 a 9), representados, de forma redundante, 

por números e também por barras. Ou seja, o UPC trabalha com vetores em ℤ10

12.  

A  regra  é  parecida  com  a  do  nosso  SDR  (seção  3.1.),  mas  com  vetor  de  checagem  𝑐 =

[3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1].  

Como estamos trabalhando em ℤ10, usaremos as seguintes tabelas: 

+ 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

1 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

2 

2 

3 

4 

5 

6 

7 

8 

9 

0 

1 

3 

3 

4 

5 

6 

7 

8 

9 

0 

1 

2 

4 

4 

5 

6 

7 

8 

9 

0 

1 

2 

3 

5 

5 

6 

7 

8 

9 

0 

1 

2 

3 

4 

6 

6 

7 

8 

9 

0 

1 

2 

3 

4 

5 

7 

7 

8 

9 

0 

1 

2 

3 

4 

5 

6 

8 

8 

9 

0 

1 

2 

3 

4 

5 

6 

7 

Tabela 9. Adição em ℤ10. 

9 

9 

0 

1 

2 

3 

4 

5 

6 

7 

8 

∙ 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

 
 
 
 
 
 
 
 
 
 
 
 
33 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

0 

2 

4 

6 

8 

0 

2 

4 

6 

8 

0 

3 

6 

9 

2 

5 

8 

1 

4 

7 

0 

4 

8 

2 

6 

0 

4 

8 

2 

6 

0 

5 

0 

5 

0 

5 

0 

5 

0 

5 

0 

6 

2 

8 

4 

0 

6 

2 

8 

4 

0 

7 

4 

1 

8 

5 

2 

9 

6 

3 

0 

8 

6 

4 

2 

0 

8 

6 

4 

2 

Tabela 10. Multiplicação em ℤ10. 

0 

9 

8 

7 

6 

5 

4 

3 

2 

1 

Exemplo: Mostrar que o código de barras abaixo é válido. 

Figura 2. Código de Barras 

Solução: 𝑢 = (1, 8, 8, 1, 1, 4, 7, 7, 1, 2, 1,1) é um código de barras válido, pois: 

𝑢 ∙ 𝑐 = 1 ∙ 3 + 8 ∙ 1 + 8 ∙ 3 + 1 ∙ 1 + 1 ∙ 3 + 4 ∙ 1 + 7 ∙ 3 + 7 ∙ 1 + 1 ∙ 3 + 2 ∙ 1 + 1 ∙ 3 + 1 ∙ 1 

= 3(1 + 8 + 1 + 7 + 1 + 1) + (8 + 1 + 4 + 7 + 2 + 1) 

= 3(9) + 3 = 7 + 3 = 0 

Exemplo: Calcular o dígito verificador 𝑑 que torna o código de barras abaixo válido.  

Figura 3. Código de Barras 

 
 
 
 
 
 
 
34 

Solução:  

𝑢 ∙ 𝑐 = 0 ∙ 3 + 2 ∙ 1 + 2 ∙ 3 + 3 ∙ 1 + 3 ∙ 3 + 4 ∙ 1 + 5 ∙ 3 + 4 ∙ 1 + 5 ∙ 3 + 4 ∙ 1 + 5 ∙ 3 + 1

∙ 𝑑 

= 3(0 + 2 + 3 + 5 + 5 + 5) + (2 + 3 + 4 + 4 + 4 + 𝑑) 

= 3(0) + 7 + 𝑑 = 7 + 𝑑 = 0 

Portanto, 𝑑 = 3 torna esse código válido. 

O teorema a seguir nos garante que o UPC detecta os erros simples. 

Teorema 3.2.1.  

Sejam os vetores 𝑢 e 𝑐 = [3,1,3,1,3,1,3,1,3,1,3,1] em ℤ10

12, e 𝑣 um vetor obtido trocando 

exatamente um dígito de 𝑢. Então 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

Demonstração:  

Fazendo 𝑢 = (𝑢1, 𝑢2, … , 𝑢12), temos que:  

𝑢 ∙ 𝑐 = 3(𝑢1 + 𝑢3 + ⋯ + 𝑢11) + (𝑢2 + 𝑢4 + ⋯ + 𝑢12) 

Fazendo 𝑣 = (𝑣1, 𝑣2, … , 𝑣12), temos que:  

𝑣 ∙ 𝑐 = 3(𝑣1 + 𝑣3 + ⋯ + 𝑣11) + (𝑣2 + 𝑣4 + ⋯ + 𝑣12) 

Se  𝑢  e  𝑣  são  idênticos,  exceto  pela  𝑘-ésima  coordenada,  em  símbolos:  𝑢𝑖 = 𝑣𝑖  para  𝑖 =

1, 2, … , 𝑘 − 1, 𝑘 + 1, … 12 e 𝑢𝑘 ≠ 𝑣𝑘, então: 

i) Caso 𝑘 é impar: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 = 3[(𝑢1 − 𝑣1) + ⋯ + (𝑢𝑘 − 𝑣𝑘) + ⋯ (𝑢11 − 𝑣11)] + (𝑢2 − 𝑣2) + ⋯

+ (𝑢12 − 𝑣12) = 3(𝑢𝑘 − 𝑣𝑘) 

Como 𝑢𝑘 − 𝑣𝑘 ≠ 0 e 3 é primo com 10, temos que 3(𝑢𝑘 − 𝑣𝑘) ≠ 0. Portanto, 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

ii) Caso 𝑘 é par: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 = 3[(𝑢1 − 𝑣1) + ⋯ + (𝑢11 − 𝑣11)] + (𝑢2 − 𝑣2) + ⋯ + (𝑢𝑘 − 𝑣𝑘) + ⋯

+ (𝑢12 − 𝑣12) = 𝑢𝑘 − 𝑣𝑘 ≠ 0 

Portanto, 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

O  teorema  abaixo  nos  mostra  o  comportamento  do  UPC  quando  há  permuta  de  dígitos 

adjacentes (o que pode ocorrer no caso de o código ser digitado por uma pessoa). 

 
 
 
 
 
 
 
 
 
35 

Teorema 3.2.2.  

Sejam os vetores 𝑢 e  𝑐 = [3,1,3,1,3,1,3,1,3,1,3,1] em  ℤ10

12, e 𝑣  um  vetor obtido permutando 

entre  si  dois  dígitos  adjacentes  de  𝑢.  Se  𝑢 ∙ 𝑐 = 𝑣 ∙ 𝑐,  então  uma  das  seguintes  situações 

acontece: 

a) os dígitos permutados são iguais entre si; 

b) a diferença absoluta entre os dígitos permutados é igual a cinco.     

Demonstração: 

Fazendo 𝑢 = (𝑢1, 𝑢2, … , 𝑢12), temos que:  

𝑢 ∙ 𝑐 = 3(𝑢1 + 𝑢3 + ⋯ + 𝑢11) + (𝑢2 + 𝑢4 + ⋯ + 𝑢12) 

Fazendo 𝑣 = (𝑣1, 𝑣2, … , 𝑣12), temos que:  

𝑣 ∙ 𝑐 = 3(𝑣1 + 𝑣3 + ⋯ + 𝑣11) + (𝑣2 + 𝑣4 + ⋯ + 𝑣12) 
Se 𝑢 e 𝑣 são idênticos, exceto, possivelmente, pelas 𝑘-ésima e (𝑘 + 1)-ésima coordenadas, com 

𝑘 ímpar (sem perda de generalidade) em símbolos: 𝑢𝑖 = 𝑣𝑖 para 𝑖 = 1, 2, … , 𝑘 − 1, 𝑘 + 2, … 12 

e 𝑣𝑘 = 𝑢𝑘+1, e  𝑣𝑘+1 = 𝑢𝑘 então: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 = 3[(𝑢1 − 𝑣1) + ⋯ + (𝑢𝑘 − 𝑣𝑘) + ⋯ (𝑢11 − 𝑣11)] + (𝑢2 − 𝑣2) + ⋯

+ (𝑢𝑘+1 − 𝑣𝑘+1) + ⋯ + (𝑢12 − 𝑣12) = 3(𝑢𝑘 − 𝑣𝑘) + (𝑢𝑘+1 − 𝑣𝑘+1)
= 3(𝑢𝑘 − 𝑢𝑘+1) + (𝑢𝑘+1 − 𝑢𝑘) = 2𝑢𝑘 − 2𝑢𝑘+1 = 2(𝑢𝑘 − 𝑢𝑘+1) 

Repare que 2(𝑢𝑘 − 𝑢𝑘+1) = 0 somente nos casos: 

i) 𝑢𝑘 = 𝑢𝑘+1, ou seja, os dígitos permutados são idênticos (neste caso 𝑢 = 𝑣) ou; 
ii)  |𝑢𝑘 − 𝑢𝑘+1| = 5,  ou  seja,  a  diferença  absoluta  entre  os  dígitos  permutados  é  cinco,  por 

exemplo 0 e 5, 1 e 6, 2 e 7, 3 e 8, 4 e 9. 

Portanto, o Teorema 3.2.4 nos mostra que não é possível detectar todos os erros de permuta de 

dígitos adjacentes no código UPC, o que compromete a sua confiabilidade. Para termos uma 

ideia mais quantitativa do significado disso, vamos resolver um problema. 

Problema 3.2.5.  

Supondo  que  a  escolha  dos  dígitos  em  uma  palavra  no  código  UPC  seja  aleatória,  qual  é  a 

probabilidade de que a diferença entre dois dígitos adjacentes seja igual a cinco? 

Solução:  Dois  dígitos  adjacentes  (escolhidos  entre  os  algarismos  de  0  a  9,  podendo  haver 

repetição) podem ser escolhidos de 10 × 10 = 100 modos. Dos quais, em dez desses casos a 

diferença entre os algarismos é cinco (São elas: (0, 5) (1, 6), (2, 7), (3, 8), (4, 9), (5, 0), (6, 1), 

 
 
 
 
 
 
 
36 

(7, 2), (8, 3), (9, 4)). Logo, dados dois dígitos adjacentes, a probabilidade de a diferença entre 

eles seja igual a cinco é 

10

100

= 10%. E dado um código UPC com 12 dígitos, a probabilidade 

de que haja pelo menos dois adjacentes cuja diferença é igual a cinco é 1 − (

9

11
)
10

≅ 0,686. 

Segue abaixo o resultado de um experimento computacional que confirma esses cálculos. 

Figura 4. Relatório de processamento 

No  experimento,  o  sorteio  foi  repetido  um  milhão  de  vezes,  e  a  situação  não  ocorreu  com 

frequência 31,38%, ou seja, ocorreu em 68,62% das vezes. Isso não quer dizer, entretanto que 

o  UPC  terá  68,62%  de  probabilidade  de  falhar,  pois  o  simples  fato  de  haver  dígitos  cuja 

diferença seja cinco na palavra-código não significa que eles serão de fato permutadas. 

3.3. ISBN: código de identificação de livros 

O endereço eletrônico do representante oficial do ISBN no Brasil explica que: 

O  ISBN  –  International  Standard Book Number  – é um  sistema internacional 
padronizado que identifica numericamente os livros segundo o título, o autor, o 
país, a editora, individualizando-os inclusive por edição.  
Criado  em  1967  por  editores  ingleses,  o  sistema  passou  a  ser  amplamente 
empregado, tanto pelos comerciantes de livros quanto pelas bibliotecas, até ser 
International 
oficializado,  em  1972,  como  norma 
Organization for Standartization - ISO 2108 - 1972. 
O sistema ISBN é controlado pela Agência Internacional do ISBN, que orienta, 
coordena e delega poderes às agências nacionais designadas em cada país. Desde 

internacional  pela 

 
 
 
 
 
 
 
 
37 

1978, a Fundação Biblioteca Nacional representa a Agência Brasileira, com a 
função de atribuir o número de identificação aos livros editados no país. 
Uma vez fixada  a identificação,  ela só se  aplica  àquela obra e  edição, não se 
repetindo jamais em outra.  
<http://www.isbn.bn.br/website/o-que-e-isbn>. Acesso em 04/08/2017 

O código ISBN é uma sequência de 10 dígitos, podendo assumir os valores de 0 a 10, neste 

último caso, substituímos 10 por sua representação em algarismos romanos X para que ocupe 

um único dígito. Ou seja, o ISBN trabalha com vetores em ℤ11
[10, 9, 8, 7, 6, 5, 4, 3, 2,1].  

10, com vetor de checagem 𝑐 =

Vale a pena aqui fazer um comentário sobre a estratégia de escolha das componentes do vetor 

de checagem: 

  Quando estudamos o UPC, cujos cálculos são feitos em ℤ10, vimos que as componentes 

eram 1 ou 3, esses números foram escolhidos por serem primos com 10. Poderíamos 

criar um código igualmente eficiente do pontos de vista da detecção de erros, usando os 

números 7 e 9, embora talvez fosse menos eficiente do ponto de vista computacional, 

porque números números maiores geram contas mais trabalhosas. 

  Já no ISBN, cujos cálculos são feitos em ℤ11, as componentes podem ser escolhidas de 

modo mais livre, já que todos os valores de 1 a 10 são primos com 11. 

Como estamos trabalhando em ℤ11, usaremos as seguintes tabelas: 

+ 

0 

0 

0 

1 

1 

2 

2 

3 

3 

4 

4 

5 

5 

6 

6 

7 

7 

8 

8 

9 

9 

10 

10 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
38 

1 

2 

3 

4 

5 

6 

7 

8 

9 

1 

2 

3 

4 

5 

6 

7 

8 

9 

2 

3 

4 

5 

6 

7 

8 

9 

10 

10 

10 

0 

3 

4 

5 

6 

7 

8 

9 

10 

0 

1 

4 

5 

6 

7 

8 

9 

10 

0 

1 

2 

5 

6 

7 

8 

9 

10 

0 

1 

2 

3 

6 

7 

8 

9 

10 

0 

1 

2 

3 

4 

7 

8 

9 

10 

0 

1 

2 

3 

4 

5 

8 

9 

10 

0 

1 

2 

3 

4 

5 

6 

Tabela 11. Adição em ℤ11. 

9 

10 

10 

0 

1 

2 

3 

4 

5 

6 

7 

0 

1 

2 

3 

4 

5 

6 

7 

8 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

∙ 

0 

1 

2 

0 

0 

0 

0 

1 

0 

1 

2 

2 

0 

2 

4 

3 

0 

3 

6 

4 

0 

4 

8 

5 

0 

5 

10 

6 

0 

6 

1 

7 

0 

7 

3 

8 

0 

8 

5 

9 

0 

9 

7 

10 

0 

10 

9 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
39 

3 

4 

5 

6 

7 

8 

9 

10 

0 

0 

0 

0 

0 

0 

0 

0 

3 

4 

5 

6 

7 

8 

9 

10 

6 

8 

10 

1 

3 

5 

7 

9 

9 

1 

4 

7 

10 

2 

5 

8 

1 

5 

9 

2 

6 

10 

3 

7 

4 

9 

3 

8 

2 

7 

1 

6 

7 

2 

8 

3 

9 

4 

10 

5 

10 

2 

6 

2 

9 

5 

1 

8 

4 

10 

7 

4 

1 

9 

6 

3 

5 

3 

1 

10 

8 

6 

4 

2 

8 

7 

6 

5 

4 

3 

2 

1 

Tabela 12. Multiplicação em ℤ11. 

Exemplo: Mostrar que o código ISBN abaixo é válido. 

Solução: 

Figura 5. Código de barras 

𝑢 = (8, 1, 7, 5, 2, 5, 7, 6, 6, 0) é um código de barras válido, pois: 

𝑢 ∙ 𝑐 = 8 ∙ 10 + 1 ∙ 9 + 7 ∙ 8 + 5 ∙ 7 + 2 ∙ 6 + 5 ∙ 5 + 7 ∙ 4 + 6 ∙ 3 + 6 ∙ 2 + 0 ∙ 1

= 3 + 9 + 1 + 2 + 1 + 3 + 6 + 7 + 1 = 0 

Recorde que os cálculos são em ℤ11. 

O resultado abaixo nos diz que o ISBN é capaz de detectar erros simples. 

Teorema 3.3.1.  

Sejam  os  vetores  𝑢  e  𝑐 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]  em  ℤ11

10,  e  𝑣  um  vetor  obtido  trocando 

exatamente um dígito de 𝑢. Então 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

Demonstração: 

 
 
 
 
 
 
 
 
 
 
40 

Fazendo 𝑢 = (𝑢1, 𝑢2, … , 𝑢10), temos que:  

𝑢 ∙ 𝑐 = 10 ∙ 𝑢1 + 9 ∙ 𝑢2 + 8 ∙ 𝑢3 + 7 ∙ 𝑢4 + 6 ∙ 𝑢5 + 5 ∙ 𝑢6 + 4 ∙ 𝑢7 + 3 ∙ 𝑢8 + 2 ∙ 𝑢9 + 1 ∙ 𝑢10 

Fazendo 𝑣 = (𝑣1, 𝑣2, … , 𝑣10), temos que:  

𝑣 ∙ 𝑐 = 10 ∙ 𝑣1 + 9 ∙ 𝑣2 + 8 ∙ 𝑣3 + 7 ∙ 𝑣4 + 6 ∙ 𝑣5 + 5 ∙ 𝑣6 + 4 ∙ 𝑣7 + 3 ∙ 𝑣8 + 2 ∙ 𝑣9 + 1 ∙ 𝑣10 

Se  𝑢  e  𝑣  são  idênticos,  exceto  pela  𝑘-ésima  coordenada,  em  símbolos:  𝑢𝑖 = 𝑣𝑖  para  𝑖 =

1, 2, … , 𝑘 − 1, 𝑘 + 1, … 10 e 𝑢𝑘 ≠ 𝑣𝑘, então: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 = 10(𝑢1 − 𝑣1) + ⋯ + (11 − 𝑘)(𝑢𝑘 − 𝑣𝑘) + ⋯ + 1(𝑢10 − 𝑣10)

= (11 − 𝑘)(𝑢𝑘 − 𝑣𝑘) 

Mas, 11 − 𝑘 > 0, 𝑢𝑘 − 𝑣𝑘 ≠ 0 e 11 primo, segue pelo Corolário 1.1.7 que 
 (11 − 𝑘)(𝑢𝑘 − 𝑣𝑘) ≠ 0 . Logo, 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

O  ISBN  também  é  capaz  de  detectar  erros  de  permuta  de  dígitos  adjacentes  (erros  de 

transposição). 

Teorema 3.3.2.  

Sejam os vetores 𝑢 e 𝑐 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] em ℤ11

10, e 𝑣 um vetor obtido trocando entre 

si dois dígitos adjacentes distintos de 𝑢. Então 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

Demonstração: 

Fazendo 𝑢 = (𝑢1, 𝑢2, … , 𝑢10), temos que:  

𝑢 ∙ 𝑐 = 10 ∙ 𝑢1 + 9 ∙ 𝑢2 + 8 ∙ 𝑢3 + 7 ∙ 𝑢4 + 6 ∙ 𝑢5 + 5 ∙ 𝑢6 + 4 ∙ 𝑢7 + 3 ∙ 𝑢8 + 2 ∙ 𝑢9 + 1 ∙ 𝑢10 

Fazendo 𝑣 = (𝑣1, 𝑣2, … , 𝑣10), temos que:  

𝑣 ∙ 𝑐 = 10 ∙ 𝑣1 + 9 ∙ 𝑣2 + 8 ∙ 𝑣3 + 7 ∙ 𝑣4 + 6 ∙ 𝑣5 + 5 ∙ 𝑣6 + 4 ∙ 𝑣7 + 3 ∙ 𝑣8 + 2 ∙ 𝑣9 + 1 ∙ 𝑣10 

Se 𝑢 e 𝑣 são idênticos, exceto pelas 𝑘-ésima e 𝑘 + 1-ésima coordenadas, em símbolos: 𝑢𝑖 = 𝑣𝑖 

para 𝑖 = 1, 2, … , 𝑘 − 1, 𝑘 + 2, … 10 e 𝑣𝑘 = 𝑢𝑘+1, e  𝑣𝑘+1 = 𝑢𝑘 então: 

𝑢 ∙ 𝑐 − 𝑣 ∙ 𝑐 = 10(𝑢1 − 𝑣1) + ⋯ + (11 − 𝑘)(𝑢𝑘 − 𝑣𝑘) + (10 − 𝑘)(𝑢𝑘+1 − 𝑣𝑘+1) + ⋯

+ 1(𝑢10 − 𝑣10) = (11 − 𝑘)(𝑢𝑘 − 𝑣𝑘) + (10 − 𝑘)(𝑣𝑘 − 𝑢𝑘) =   𝑢𝑘 − 𝑣𝑘 ≠ 0 

Logo, 𝑢 ∙ 𝑐 ≠ 𝑣 ∙ 𝑐. 

 
 
 
 
 
 
 
 
 
 
41 

3.4. CPF: Cadastro de Pessoas Físicas 

O CPF é uma sequência de 11 dígitos, podendo assumir os valores de 0 a 9, ou seja, o CPF 
11,  com  dois  vetores  de  checagem  𝑐1 = [10, 9, 8, 7, 6, 5, 4, 3, 2]  e 

trabalha  com  vetores  em  ℤ10
𝑐2 = [11, 10, 9, 8, 7, 6, 5, 4, 3, 2]. 

Sejam 𝑑1 e 𝑑2 os dígitos verificadores, ou seja, os dois últimos dígitos do CPF, e 𝑢9 o vetor 

composto pelos primeiros nove dígitos do CPF. Então, 𝑑1 = 𝑢9 ∙ 𝑐1, em ℤ10.  

Seja 𝑢10 o vetor de dez componentes cujas nove primeiras correspondem a 𝑢9 e última é igual 

a 𝑑1. Então, 𝑑2 = 𝑢10 ∙ 𝑐2, em ℤ10. 

Da mesma forma que o ISBN, o CPF também corrige erros simples e de transposição. 

Detecta 

Detecta 

CÓDIGO 

erros 

erros de 

simples  

transposição 

SDR 

UPC 

ISBN 

CPF 

SIM 

SIM 

SIM 

SIM 

NÃO 

SIM* 

SIM 

SIM 

Corrige 

erros 

NÃO 

NÃO 

NÃO 

NÃO 

Tabela 13. Comparação de códigos 

*Exceto quando a diferença absoluta entre os algarismos transpostos é igual a cinco. 

Vimos que o ISBN tem vantagem de segurança sobre o UPC, pois detecta todos os erros de 

transposição. Por outro lado, o UPC tem 11 dígitos disponíveis para codificação do produto 

(mais o dígito de checagem), enquanto o ISBN tem apenas 9 dígitos para isso (mais o dígito de 

checagem), portanto, o UPC tem vantagem sobre o ISBN na quantidade de produtos possíveis 

de serem catalogados. 

O CPF usa 9 dígitos para codificação (mais dois dígitos verificadores), a principio ele poderia 

ser trocado por um sistema similar ao ISBN, com a mesma segurança, mas com a vantagem de 

usar apenas um dígito de checagem. Entretanto, o ISBN tem a desvantagem de usar o X no 

dígito de checagem, e, tendo em vista que alguns dispositivos não permitem a transmissão do 

X,  por  apresentarem  apenas  teclado  numérico  (como  telefones),  nestes  casos,  é  necessário 

 
 
 
 
 
 
 
 
42 

trocar o X por zero, o que compromete a detecção de erros nesses casos. Daí, o fato de o CPF 

usar apenas algarismos de 0 a 9 é uma vantagem. Por outro lado, o CPF exige dois cálculos 

para a checagem, tendo, portanto, uma desvantagem computacional. 

 
 
 
 
 
 
43 

4. CORREÇÃO DE ERROS 

No capítulo anterior, apresentamos alguns exemplos de códigos que detectam erros simples, 

mas que não possuem a capacidade de corrigi-los. Neste capítulo apresentamos uma forma de 

criar alguns tipos de códigos que possam tanto detectar quanto corrigir alguns erros. Dentre eles 

os códigos de Hamming. 

4.1. Matriz geradora padrão e matriz de verificação de paridade padrão 

Veremos um algoritmo, devido a Hamming, que permite: 

a) transformar as palavras de um código binário em palavras corrigíveis (caso em que ocorre 

apenas um erro), multiplicando o vetor original por uma matriz geradora;  

b) identificar o dígito incorreto, multiplicando o vetor recebido por uma matriz de verificação 

de paridade, para em seguida corrigi-lo. 

O seguinte exemplo servirá para ilustrar a abordagem desta seção. 

Exemplo:  Considere  a  tabela  abaixo  mostrando  o  código  da  fonte  ou  código  de  mensagem 

correspondente a cada comando: 

COMANDO  CÓDIGO 

CIMA 

BAIXO 

00 

01 

ESQUERDA  10 

DIREITA 

11 

Tabela 14. Hamming 1 

Vamos criar um código que detecte e corrija um erro ocorrido em apenas uma coordenada. A 

partir de um código de comprimento 𝑘, criaremos um novo código de comprimento 𝑛 (𝑛 > 𝑘), 

acrescentando 𝑛 − 𝑘 dígitos ao final de cada código. 

Para isso usaremos duas matrizes: 

 
 
 
 
 
 
 
 
 
 
44 

  Uma  matriz  𝐺  da  forma  𝐺 = [

]  de  ordem  𝑛 × 𝑘  que  transforme  um  vetor  de 

𝐼𝑘
𝐴
𝑘 num vetor de código 𝐺𝑥 em ℤ2

𝑛 chamada de matriz geradora do 

mensagem 𝑥 em ℤ2
código; 

  E uma matriz de checagem 𝑃 = [𝐵 𝐼𝑛−𝑘],, de ordem (𝑛 − 𝑘) × 𝑛, chamada matriz de 

verificação de paridade de modo que para cada 𝑥 ∈ ℤ2

𝑘, se 𝑐 = 𝐺𝑥, então 𝑃𝑐 = 0.  

No nosso exemplo particular, consideramos: 𝑛 = 5, 𝑘 = 2 e 𝐴 = 𝐵 = [

1 0
1 1
0 1

].  Desta forma, 

  e 𝑃 = [𝐴 𝐼3] = [

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1

].  Daí, 

𝐺 = [

𝐼2
𝐴

] =

𝑐1 =

[

𝑐3 =

[

1 0
0 1
1 0
1 1
0 1]
1 0
0 1
1 0
1 1
0 1]
1 0
0 1
1 0
1 1
0 1]

[

[

[

0
0

] =

[

1
0

] =

0
0
0
0
0]
1
0
1
1
0]

[

𝑐2 =

[

𝑐4 =

1 0
0 1
1 0
1 1
0 1]
1 0
0 1
1 0
1 1
0 1]

[

[

0
1
0
1
1]
1
1
1
0
1]

[

0
1

] =  

[

1
1

] =

[

Onde 𝑐1, 𝑐2, 𝑐3 e 𝑐4 são chamados vetores de código. 

A tabela abaixo mostra os vetores de código associados a cada comando 

COMANDO  CÓDIGO 

CIMA 

BAIXO 

00000 

01011 

ESQUERDA  10110 

DIREITA 

11101 

Tabela 15. Hamming 2 

É  fácil  verificar  que  𝑃𝑐𝑖   =  0  para  cada  𝑖 = 1, 2, 3, 4.    O  que  confirma  que  os  códigos  são 

válidos.  Por exemplo, 

𝑃𝑐1 = [

1 0 1 0 0
]
1 1 0 1 0
0 1 0 0 1

0
1
0
1
1]

[

= [

0
] confirma que 𝑐1 é um vetor de código válido. 
0
0

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
45 

Por outro lado, se houvesse um erro em alguma componente do vetor de código, digamos 𝑐, = 

[0, 1, 1, 1, 1] com erro na terceira componente de 𝑐2, então 

[

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1

]

0
1
1
1
1]

[

= [

1
0
0

] confirma o erro na terceira componente pois o vetor resultante é 

igual ao vetor da terceira coluna da matriz 𝑃 e portanto o erro pode ser corrigido. 

Agora vamos formalizar estas ideias. 

Definição 4.1.1.  

Sejam 𝑛 e 𝑘 dois inteiros positivos com 𝑘 < 𝑛. Toda matriz 𝑛 × 𝑘 da forma 𝐺 = [

𝐼𝑘
𝐴

], em que 

𝐴 é uma matriz de ordem (𝑛 − 𝑘) × 𝑘 sobre ℤ2 é chamada de matriz geradora padrão para 
𝑛.  
𝑘 em vetores de código em ℤ2
um código binário (𝒏, 𝒌) que transforma vetores de código de ℤ2
Qualquer matriz (𝑛 − 𝑘) × 𝑛 da forma 𝑃 = [𝐵 𝐼𝑛−𝑘], em que 𝐵 é uma matriz (𝑛 − 𝑘) × 𝑘 

sobre  ℤ2  é  chamada  de  matriz  de  verificação  de  paridade  padrão.   Dizemos  então  que  o 

código tem comprimento 𝑛 e dimensão 𝑘. 

As  matrizes  𝐺  e  𝑃  do  exemplo  acima  obedecem  a  definição  4.1.1.  Observa-se  ainda  nesse 

exemplo, que a matriz 𝐴 que completa a matriz 𝐺 é igual a matriz 𝐵 que completa a matriz 𝑃. 

O seguinte resultado diz que esse fato é necessário e suficiente para que 𝑃 seja uma matriz de 

verificação de paridade.   

Teorema 4.1.2.  

Se 𝐺 = [

𝐼𝑘
𝐴

] for uma matriz geradora padrão e 𝑃 = [𝐵 𝐼𝑛−𝑘] for uma matriz de verificação 

padrão, então 

(a)  𝑃 será a matriz de verificação de paridade associada a 𝐺 se, e somente se, 𝐴 = 𝐵.  

(b) O código binário correspondente (𝑛, 𝑘) será um corretor de erros (em uma componente) 

se, e somente se, as colunas de 𝑃 forem não nulas e distintas. 

Demonstração 

(a) Seja 𝑎𝑖 a 𝑖-ésima coluna de 𝐴. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
46 

Suponha que 𝑃 e 𝐺 estão associados ao mesmo código. Isso quer dizer que 𝑃𝐺𝑥 = 0, para todo 

𝑥 ∈ ℤ2

𝑘. Então:  

𝐵𝑥 + 𝐴𝑥 = (𝐵 + 𝐴)𝑥 = (𝐵𝐼 + 𝐼𝐴)𝑥 = [𝐵 𝐼] [

𝐼
𝐴

] 𝑥 = 𝑃𝐺𝑥 = 0 

𝑘. 
Portanto, 𝐵𝑥 + 𝐴𝑥 = 0, ou seja, 𝐵𝑥 = 𝐴𝑥3 para todo 𝑥 ∈ ℤ2

Seja 𝑥 = 𝑒𝑖 o 𝑖-ésimo vetor de base canônica de ℤ2

𝑘.  

Então: 𝑏𝑖 = 𝐵𝑒𝑖 = 𝐴𝑒𝑖 = 𝑎𝑖, para todo 𝑖.  

Logo, 𝐵 = 𝐴. 

Reciprocamente, suponha que 𝐵 = 𝐴. Então: 

𝑃𝐺𝑥 = [𝐵 𝐼] [

𝐼
𝐵

] 𝑥 = (𝐵 + 𝐵4)𝑥 = 0𝑥 = 0 

Logo, 𝑃 e 𝐺 estão associados ao mesmo código. 

(b) Suponha que as colunas de 𝑃 sejam não nulas e distintas. Se 𝑥 for um vetor de mensagem 

𝑘 e 𝑐 = 𝐺𝑥 for o vetor de código correspondente, então: 𝑃𝑐 = 0. 
em ℤ2
Se 𝑐′ = 𝑐 + 𝑒𝑖 é o vetor 𝑐 com um erro na 𝑖-ésima componente, então: 
𝑃𝑐′ = 𝑃(𝑐 + 𝑒𝑖) = 𝑃𝑐 + 𝑃𝑒𝑖 = 0 + 𝑝𝑖 = 𝑝𝑖 
  Se 𝑝𝑖 = 0, então um erro na 𝑖-ésima componente não será detectado.  De fato, se 𝑐′ =

𝑐 + 𝑒𝑖 é um vetor com erro na 𝑖-ésima componente, então 𝑃𝑐′ = 0. 

  Se 𝑝𝑖 = 𝑝𝑗 = 𝑝 ≠ 0, com 𝑖 ≠ 𝑗, o erro será detectável, mas não corrigível, pois não será 

possível saber se ele ocorreu na  𝑖-ésima ou na 𝑗-ésima componente. De fato, se 𝑐′ =
𝑐 + 𝑒𝑖, ou se 𝑐′ = 𝑐 + 𝑒𝑗, então 𝑃𝑐′ = 𝑝. 

Na verdade, a matriz geradora e a de verificação de paridade são definidas de forma menos 

restrita do que foi feito acima. Na seção seguinte generalizamos esses conceitos. 

4.2. Matriz geradora e matriz de verificação de paridade  
Para motivar a definição destas matrizes lembre-se primeiramente que a matriz geradora padrão 

𝑛 × 𝑘 e a de verificação de paridade padrão de ordem (𝑛 − 𝑘) × 𝑛 para um código são da forma 

G = [

𝐼𝑘
𝐴

] e  𝑃 = [𝐵 𝐼𝑛−𝑘] 

3 Como estamos trabalhando em ℤ𝟐, 𝑨𝒙 = −𝑨𝒙 
4 Como estamos trabalhando em ℤ𝟐, 𝑩 + 𝑩 = 𝟎 

 
 
 
 
 
 
                                                 
47 

e, portanto pode-se garantir que as colunas de 𝐺 e as linhas de 𝑃 são linearmente independentes.  

Alem disso, pelo Teorema 4.1.2, 𝐺 e 𝑃 são associadas ao mesmo código se, e somente se, 𝐴 =

𝐵, o que é equivalente a 𝑃𝐺 = 0.  

Definição 4.2.1  

Para 𝑛 > 𝑘, uma matriz 𝐺, 𝑛 × 𝑘, e uma matriz 𝑃, (𝑛 − 𝑘) × 𝑛 (com elementos em ℤ2) são 

uma matriz geradora e uma matriz de verificação de paridade, respectivamente, para um 

código binário  𝐶(𝑛, 𝑘), se as seguintes condições forem satisfeitas: 

i) As colunas de 𝐺 são linearmente independentes. 

ii) As linhas de 𝑃 são linearmente independentes. 

iii) 𝑃𝐺 = 𝑂. 

Observações 

1.  Como ℤ2 é um corpo, ℤ2

𝑚 é um espaço vetorial sobre ℤ2 para qualquer inteiro positivo 

𝑚. 

2.  Se 𝑣1, 𝑣2, … , 𝑣𝑘 são as 𝑘 colunas de 𝐺, então, como 

0 = 𝑃𝐺 = 𝑃[𝑣1 𝑣2 … . 𝑣𝑘] = [𝑃𝑣1 𝑃𝑣2. . . . . 𝑃𝑣𝑘] 

Tem-se que 𝑃𝑣𝑖 = 0 para cada 𝑖 = 1, 2, . . . , 𝑘 e, portanto, cada coluna de 𝐺 é um vetor 
𝑘, 𝐺𝑥 = 𝑣1𝑥 + 𝑣2𝑥 +
⋯ 𝑣𝑘𝑥.  Daí, 𝐶 é gerado pelos vetores colunas de 𝐺. Isto é, 𝐶 é um espaço coluna de 𝐺. 

de código em 𝐶. Além disso, se 𝑥 é um código de mensagem em ℤ2

3.  Sabe-se que o espaço linha de uma matriz não muda com as operações elementares linha 

na matriz e analogamente, o espaço coluna de uma matriz não muda com as operações 

elementares coluna na matriz. 

4.  Para  uma  matriz  com  entradas  em  ℤ2  existem  apenas  duas  operações  elementares 

coluna: permutar duas colunas (C1) e somar uma coluna a outra (C2).  E existem duas 

operações elementares linha: permutar duas linhas (L1) e somar uma linha a outra (L2). 

5.  Se 𝐸 é uma matriz elementar, 𝑃 uma matriz de verificação de paridade e 𝑐 é um vetor 

de código, então (𝐸𝑃)𝑐 = 𝐸(𝑃𝑐) = 𝐸0 = 0. 

Portanto, 𝐸𝑃 também é uma matriz de verificação de paridade para 𝐶. 

Essas  observações  mostram  que  existem  muitas  matrizes  geradoras  e  muitas  matrizes  de 

verificação de paridade diferentes para um mesmo código.  

 
 
 
 
 
 
 
48 

Nem sempre é possível trazer a matriz geradora ou de verificação de paridade à forma padrão, 

usando  apenas  operações  elementares  coluna  em  𝐺  e  operações  elementares  linha  em  𝑃. 

Veremos que para garantir essa possibilidade precisaremos acrescentar uma operação elementar 

linha na matriz 𝐺 e uma operação elementar coluna em 𝑃.  

Mas antes de enunciar esse resultado precisamos de outra definição. 

Definição 4.2.2.  

Dizemos que dois códigos 𝐶1 e 𝐶2 são equivalentes quando existe uma matriz de permutação 

𝑀 tal que  

{𝑀𝑥: 𝑥 em 𝐶1}   =   𝐶2 

Exemplo. Considere o código 𝐶1 = {𝑢1, 𝑢2, 𝑢3, 𝑢4}, onde 𝑢1 = [

0
] , 𝑢2 = [
0
0

1
] , 𝑢3 =
0
0

[

1
]  e 𝑢4 = [
0
1

1
1
1

]. E a matriz 𝑀 = [

0 1 0
1 0 0
0 0 1

]. O efeito da matriz 𝑀 sobre um vetor 𝑣 = [

] é 

𝑎
𝑏
𝑐

permutar entre si a primeira e a segunda componentes. De fato: 

𝑀𝑣 = [

0 1 0
1 0 0
0 0 1

] [

𝑎
𝑏
𝑐

] = [

𝑏
𝑎
𝑐

] 

Repare que a matriz de permutação deve ser quadrada e ter exatamente um elemento igual a 1 

em cada linha e em cada coluna. Os outros elementos devem ser nulos. 

0
Portanto,  𝐶2 = {𝑣1, 𝑣2, 𝑣3, 𝑣4,} = {𝑀𝑢1, 𝑀𝑢2, 𝑀𝑢3, 𝑀𝑢4} = {[
0
0

] , [

0
1
0

] , [

0
1
1

] , [

1
1
1

]},  o  que  nos 

mostra que os códigos 𝐶1 e 𝐶2 são equivalentes. 

0
Exemplo: 𝐶1 = {[
0
0

] , [

1
0
0

] , [

1
0
1

] , [

0
0
]}  e 𝐶2 = {[
0
0
0
1

] , [

São equivalentes pela matriz de permutação 𝑀 = [

1
0
0

]}   

] , [

] , [

1
1
0

0
1
0
0 0 1
1 0 0
0 1 0

]. 

Das observações anteriores mais o fato de que permutar os elementos dos vetores de código 

corresponde a permutar linhas da matriz geradora e a permutar colunas da matriz de verificação, 

segue o seguinte resultado. 

 
 
 
 
 
 
 
49 

Teorema 4.2.3 

(a) Pode-se trazer à forma padrão qualquer matriz geradora para um código por intermédio das 

operações C1, C2 e L1.  Se L1 não for usada, tem-se o mesmo código; se L1 for usada, se obtém 

um código equivalente. 

(b) Pode-se trazer à forma padrão qualquer matriz de verificação de paridade para um código 

por meio das operações L1, L2 e C1.  Se C1 não for usada, obtém-se o mesmo código; se C1 

for usada, tem-se um código equivalente. 

Vejamos nos próximos exemplos como isso pode ser feito. 

Exemplo: Trazer a matriz geradora 𝐺 = [

1 0
1 0
0 1

verificação de paridade correspondente. 

Solução: Basta usar a operação L1 em 𝐺: 

] para a forma padrão e encontrar a matriz de 

𝐺 = [

1 0
]
1 0
0 1

→     [
ℓ1↔ℓ2

1 0
0 1
1 0

] = [

𝐼
𝐴

] = 𝐺′ 

Temos que 𝐴 = [1 0], e, portanto,  

Seja 𝐶1 o código gerado por 𝐺, então: 

𝑃 = [𝐴 𝐼] = [1 0 1] 

[

1 0
1 0
0 1

] [

𝑎
𝑏

] = [

𝑎
𝑎
𝑏

] 

𝑎
𝑎
𝐶1 = {[
𝑏

] : 𝑎, 𝑏 ∈ ℤ2} {𝑎 [

1
1
0

] + 𝑏 [

0
0
1

0
] : 𝑎, 𝑏 ∈ ℤ2} = {[
0
0

] , [

1
1
0

] , [

0
0
1

] , [

1
1
1

]} 

Seja 𝐶2 o código gerado por 𝐺′, então: 

[

1 0
0 1
1 0

] [

𝑎
𝑏

] = [

𝑎
𝑏
𝑎

] 

𝑎
𝑏
𝐶1 = {[
𝑎

0
1
0
Repare que 𝐶1 e 𝐶2 são códigos equivalentes. Eles admitem a seguinte matriz de permutação: 

0
] : 𝑎, 𝑏 ∈ ℤ2} = {[
0
0

] : 𝑎, 𝑏 ∈ ℤ2} {𝑎 [

] + 𝑏 [

1
0
1

1
0
1

0
1
0

1
1
1

] , [

] , [

] , [

]} 

𝑀 = [

1 0 0
0 0 1
0 1 0

] 

 
 
 
 
 
 
50 

Essa matriz tem o efeito de permutar a segunda e terceira componentes. 

Exemplo: Trazer a matriz de verificação de paridade 𝑃 = [1 1 0] para a forma padrão e 

encontrar a matriz geradora correspondente. 

Solução: Basta usar a operação C1 em 𝑃: 

𝑃 = [1 1 0]

→    [1 0 1] = [𝐴′
𝑐2↔𝑐3

𝐼] = 𝑃′ 

E neste caso, a matriz geradora é 𝐺′ = [

𝐼
𝐴′

] = [

1 0
0 1
1 0

] 

Ou então, poderíamos fazer: 

𝑃 = [1 1 0]

→    [0 1 1] = [𝐴′′
𝑐1↔𝑐3

𝐼] = 𝑃′′ 

E neste caso, a matriz geradora é 𝐺′′ = [

𝐼
𝐴′′

] = [

1 0
0 1
0 1

] 

Comparando as duas possíveis matrizes geradoras, verificamos que elas geram códigos 

equivalentes. 

[

1 0
0 1
1 0

] [

𝑎
𝑏

] = [

𝑎
𝑏
𝑎

[

1 0
0 1
0 1

] [

𝑎
𝑏

] = [

𝑎
𝑏
𝑏

], que gera o código 𝐶1 = {[

], que gera o código 𝐶2 = {[

0
0
0

] , [

1
0
1

] , [

0
1
0

] , [

1
1
1

]}. 

0
0
0

] , [

1
0
0

] , [

0
1
1

] , [

1
1
1

]}. 

De fato, a matriz de permutação entre eles é 𝑀 = [

0 1 0
1 0 0
0 0 1

]  

Exemplo: Trazer a matriz de verificação de paridade 𝑃 = [

0 1 0 1
1 0 0 1

] para a forma padrão 

e encontrar a matriz geradora correspondente. 

Solução: Basta usar a operação C1 em 𝑃: 

𝑃 = [

0 1 0 1
1 0 0 1

→    [
] 𝑐1↔𝑐4
𝑐2↔𝑐3

1 0 1 0
1 0 0 1

] = [𝐴′

𝐼] = 𝑃′ 

E neste caso, a matriz geradora é 𝐺′ = [

𝐼
𝐴′

] = [

1 0
0 1
1 0
1 0

]. 

Observe que neste último exemplo 𝑃 não corrige erros, pois possui uma coluna nula (Teorema 

4.1.2). 

 
 
 
 
 
 
51 

4.3. Códigos lineares 

Definição 4.3.1  

Seja 𝑝 um número primo. Um código linear p-ário é um subespaço 𝐶5 de ℤ𝑝

𝑛. Em particular, 

para 𝑝 = 2, dizemos que o código linear é binário. 

0
1

1
1

] , [

] , [

Exemplo:  𝐶1 = {[

]}  não  é  subespaço  de  ℤ2

1
0
portanto, 𝐶1 não é um código linear. 
1
1
0
fato, apesar de conter o vetor nulo, 𝐶2 não é fechado para a adição, pois: 

0
Também o código 𝐶2 = {[
0
0

0
1
0

1
0
1

] , [

] , [

] , [

0
2,  pois  não  contém  o  vetor  nulo  [
0

], 

]} não é linear, porque não é um subespaço de ℤ2

3. De 

[

1
0
1

] + [

1
1
0

] = [

0
] ∉ 𝐶2 
1
1

Finalmente, 𝐶 = {[

0
0
0

] , [

0
1
0

] , [

0
1
1

] , [

0
]} é um subespaço de ℤ2
0
1

3, pois contém o vetor nulo, e, além 

disso, para todo 𝑢 e 𝑣 em 𝐶, temos que 𝑢 + 𝑣 está em 𝐶. De fato, 

i) Para 𝑢 = 0, 𝑢 + 𝑣 = 𝑣 ∈ 𝐶. 

ii) Para 𝑢 = 𝑣, 𝑢 + 𝑣 = 0 ∈ 𝐶. 

iii) Quanto aos outros casos, os cálculos mostram que: 

[

0
1
0

] + [

0
1
1

] = [

0
0
1

] ∈ 𝐶, [

0
1
0

] + [

0
0
1

] = [

0
1
1

] ∈ 𝐶 e [

0
1
1

] + [

0
0
1

] = [

0
1
0

] ∈ 𝐶 

Portanto, 𝐶 é um código linear. 

Se um código linear binário 𝐶 for um subespaço de ℤ2

𝑛, de dimensão 𝑘, então diremos que 𝐶 é 

um código (𝒏, 𝒌). 

4.4. Códigos duais e autoduais 

Definição 4.4.1  

5 ℤ𝒑 é o oconjunto de escalares 

 
 
 
 
 
 
 
                                                 
Seja 𝐶 um conjunto de vetores de código em  ℤ2
código dual de 𝐶, é denotado por 𝐶⊥ e definido como segue: 

𝑛. O complemento ortogonal  de  𝐶, chamado 

52 

Exemplo: Considere 𝐶 = {[

𝑛: 𝑐 ∙ 𝑥 = 0, ∀𝑐 ∈ 𝐶} 

𝐶⊥ = {𝑥 ∈ ℤ2
1
1
]}. O conjunto de todos os vetores em ℤ2
0
1

] , [

] , [

0
1

] , [

0
0

2 que são 

ortogonais a 𝐶 é 𝐶⊥ = {[

0
0

]}. 

Teorema 4.4.2.  

Se 𝐶 é um código binário (𝑛, 𝑘) com matriz geradora 𝐺 e matriz de verificação de paridade 𝑃, 

então 𝐶⊥ é um código binário (𝑛, 𝑛 − 𝑘) tal que: 

i) 𝐺𝑇 é uma matriz de verificação de paridade de 𝐶⊥. 

ii) 𝑃𝑇 é uma matriz geradora para 𝐶⊥. 

Demonstração: Como 𝐺 é uma matriz 𝑛 × 𝑘 com colunas linearmente independentes e 𝑃 é 

uma matriz (𝑛 − 𝑘) × 𝑛 com linhas linearmente independentes e 𝑃𝐺 = 0. Logo, as linhas de 

𝐺𝑇 e as colunas de 𝑃𝑇 são linearmente independentes, e 

𝐺𝑇𝑃𝑇 = (𝑃𝐺)𝑇 = 𝑂𝑇 = 𝑂 

Isso mostra que 𝐺𝑇 é a matriz de verificação de paridade para 𝐶⊥ e 𝑃𝑇 é uma matriz geradora 

para 𝐶⊥. Como 𝑃⊥ é 𝑛 × (𝑛 − 𝑘), 𝐶⊥ é um código (𝑛, 𝑛 − 𝑘). 

Teorema 4.4.3.  

Seja 𝐶 um código linear (𝑛, 𝑘). Pode-se afirmar que: 

i) O código dual 𝐶⊥ é um código linear (𝑛, 𝑛 − 𝑘). 

ii) 𝐶 contém 2𝑘 vetores, e 𝐶⊥ contém 2𝑛−𝑘 vetores. 

Demonstração: 

i) Como 𝐶 é um código linear (𝑛, 𝑘), ele é um subespaço de dimensão 𝑘 de ℤ2

𝑛. Seu dual é o 

complemento ortogonal de 𝐶 e é também um subespaço de ℤ2
Para finalizar, basta observar que: 

𝑛. Portanto, 𝐶⊥ é um código linear. 

dim 𝐶⊥ = 𝑛 − dim 𝐶 = 𝑛 − 𝑘 

ii) Seja {𝑣1, 𝑣2, … , 𝑣𝑘} uma base para 𝐶. Então, os elementos de 𝐶 são da forma 

𝑣 = 𝑐1𝑣1 + 𝑐2𝑣2 + ⋯ + 𝑐𝑘𝑣𝑘 

 
 
 
 
 
 
 
53 

Onde cada  𝑐𝑖  é zero ou um.  Portanto,  existem  duas possibilidades para  𝑐1, e para cada uma 
delas, duas possibilidades para 𝑐2, e assim por diante. Portanto, são 2𝑘 possíveis vetores. 
O mesmo argumento mostra que o seu dual (𝑛, 𝑛 − 𝑘) tem 2𝑛−𝑘 vetores. 

Definição 4.4.4.  

Um código com a propriedade 𝐶⊥ = 𝐶 é chamado autodual. 

Exemplo: Considere 𝐶 = {[

] , [

0
0

1
]}. O conjunto de todos os vetores em ℤ2
1

2, que são ortogonais 

a 𝐶 é 𝐶⊥ = {[

0
0

] , [

1
1

]}. Portanto, 𝐶 é autodual. 

Teorema 4.4.6.  

Seja 𝐶 um código linear. O dual do dual de 𝐶 é o próprio 𝐶, em símbolos: (𝐶⊥)⊥ = 𝐶. 

Demonstração:  Suponha  que  𝑥 ∈ 𝐶.  Para  todo  𝑦 ∈ 𝐶⊥,  temos  que  𝑥 ∙ 𝑦 = 0.  Como  (𝐶⊥)⊥ 

contém todos os vetores ortogonais a 𝑦, então também contém o vetor 𝑥, ou seja, 𝑥 ∈ (𝐶⊥)⊥. 

Portanto, 𝐶 ⊂ (𝐶⊥)⊥. 

Suponha  que  𝑥 ∈ (𝐶⊥)⊥.  Para  todo  𝑦 ∈ 𝐶⊥,  temos  que  𝑥 ∙ 𝑦 = 0.  Como  𝐶  contém  todos  os 

vetores ortogonais a 𝑦, então também contém o vetor 𝑥, ou seja, 𝑥 ∈ 𝐶. Portanto, (𝐶⊥)⊥ ⊂ 𝐶. 

Logo, vale a igualdade: 𝐶 = (𝐶⊥)⊥. 

Corolário 4.4.7  
Se 𝐶1 e 𝐶2 são códigos lineares (𝑛, 𝑘) tais que (𝐶1)⊥ = 𝐶2, então (𝐶2)⊥ = 𝐶1. 
Demonstração Se (𝐶1)⊥ = 𝐶2, então ((𝐶1)⊥)⊥ = (𝐶2)⊥. Do teorema anterior, ((𝐶1)⊥)⊥ = 𝐶1. 
Logo, 𝐶1 = (𝐶2)⊥. 

Definição 4.4.8.  

Seja 𝑥 um vetor em ℤ2
Exemplo: 𝑤(1, 1, 0, 1) = 3 e 𝑤(1, 0, 0, 1,0) = 2. 

𝑛. O peso de 𝑥, denotado por 𝑤(𝑥) é o números de 1s em 𝑥. 

Exemplo: Seja 𝐸𝑛 o código binário formado por todos os vetores em ℤ2

𝑛 que tem peso par. 

Seja 𝑅𝑒𝑝𝑛 o código binário com 𝑛 componentes que possui apenas dois vetores: 0 e 1 (onde 1 

é o vetor com todas as componentes iguais a 1). 

Mostre que 𝐸𝑛 e 𝑅𝑒𝑝𝑛 são duais um do outro. 

Solução: Vamos pensar primeiramente no caso 𝑛 = 3, para em seguida generalizar. 

 
 
 
 
 
 
 
 
54 

𝐸3 = {[

0
0
0

] , [

1
1
0

] , [

0
1
1

] , [

0
1
]} e 𝑅𝑒𝑝3 = {[
0
0
0
1

] , [

1
1
1

]} 

Para mostrar que esses códigos são duais, podemos verificar que:  

a) cada elemento de 𝑅𝑒𝑝3 é ortogonal a cada um dos elementos de 𝐸3.  

De fato, 

E ainda, 

[

0
3. 
] ∙ 𝑣 = 0, para todo vetor 𝑣 em ℤ2
0
0

1
1
0
3 ortogonal a cada elemento de 𝐸3. 
b) não existe outro elemento em ℤ2
Podemos  proceder  por  tentativas,  verificando  para  cada  um  dos  vetores  do  conjunto 

] = 0. 

] = [

] = [

1
1
1

1
0
1

0
1
1

1
1
1

1
1
1

] ∙ [

] ∙ [

] ∙ [

[

{[

1
0
0

] , [

0
1
0

] , [

0
0
1

] , [

1
1
0

] , [

0
1
1

] , [

1
0
1

]} que nenhum deles cumpre a condição. 

Outra  maneira  é  encontrar  o  vetor  𝑥 = [

resolvendo o sistema abaixo: 

𝑥1
𝑥2
𝑥3

]  que  é  o  ortogonal  a  todos  os  vetores  de  𝐸3, 

𝑥 ∙ [

] = 0 

1
1
0

] = 𝑥 ∙ [

] = 𝑥 ∙ [

1
0
0
1
1
1
𝑥1 + 𝑥2              = 0
       + 𝑥2 + 𝑥3    = 0
{
𝑥1 +        + 𝑥3 = 0

[

1 1 0
0 1 1
1 0 1

0
]
|
0
0

→       [
ℓ3←ℓ3+ℓ1

1 1 0
0
]
|
0 1 1
0
0 1 1
0
𝑥1 = 𝑥2
𝑥2 = 𝑥3

⇒ {

→       [
ℓ3←ℓ3+ℓ2

0
1 1 0
|
0
0 1 1
0
0 0 0

] 

⇒ 𝑥1 = 𝑥2 = 𝑥3 

𝑥1 + 𝑥2 = 0
{
𝑥2 + 𝑥3 = 0

Portanto,  

{𝑥1 [

1
1
1

0
] |𝑥1 ∈ ℤ2} = {[
0
0

] , [

1
1
1

]} = 𝑅𝑒𝑝3 

Portanto, a afirmação é válida para 𝑛 = 3. 

No caso geral, observe primeiramente que 

 
 
 
 
55 

]} 

0
0
𝑅𝑒𝑝𝑛 = {[
⋮
0

] , [

1
1
⋮
1

é um subespaço de ℤ2

𝑛 . 

𝑛 e em particular, qualquer vetor 

Continua verdadeiro que [

0
0
] é ortogonal a qualquer vetor de ℤ2
⋮
0
1
1
de 𝐸𝑛. Basta verificar que [
⋮
1

] também o é. Para isso, vamos considerar um vetor genérico 𝑥 =

𝑥1
𝑥2
⋮
𝑥𝑛

[

] em ℤ2

𝑛. Então: 

[

1
1
⋮
1

𝑥1
𝑥2
⋮
𝑥𝑛

] ∙ [

] = 𝑥1 + 𝑥2 + ⋯ + 𝑥𝑛 

A expressão acima é nula se, e somente se existe uma quantidade par de 1s entre as componentes 

𝑥1, 𝑥2, … , 𝑥𝑛, Ou seja, se e somente se 𝑥 ∈ 𝐸𝑛. 

Teorema 4.4.9  

Se 𝐶(𝑛, 𝑘) é um código auto dual, com vetores em ℤ2

𝑛, então 

i) Todo vetor em 𝐶 tem peso par 

ii) 1 está em 𝐶. 

iii) 𝑛 é par 

Demonstração 

i)  Suponha  que  o  vetor  𝑥 = [

𝑥1
𝑥2
⋮
𝑥𝑛

] ∈ 𝐶  tenha  peso  ímpar,  então  𝑥1 + 𝑥2 + ⋯ + 𝑥𝑛 = 1,  e, 

portanto, 𝑥 ∙ 𝑥 = 1. Mas isso não pode ocorrer, pois como 𝐶 é auto dual, 𝑥 deve ser ortogonal 

a si mesmo, ou seja, 𝑥 ∙ 𝑥 = 0. Portanto, o peso de 𝑥 não é ímpar, logo, é par. 

 
 
 
 
 
 
56 

ii) O vetor 1 = [

1
1
⋮
1

] é tal que 1 ∙ 𝑥 = 0, para qualquer 𝑥 ∈ 𝐶 (do item anterior, já sabemos que 

𝑥  tem  peso  par).  E  como  todo  elemento  de  ℤ2

𝑛  que  é  ortogonal  a  todos  os  elementos  de  𝐶, 

também pertence a 𝐶, concluímos que 1 ∈ 𝐶. 

iii) Dos fatos: todo elemento de 𝐶 tem peso par (item i), e 1 ∈ 𝐶 (item ii), concluímos que 1 =

1
1
[
⋮
1

] tem peso par, ou seja, a quantidade de coordenadas, 𝑛, é necessariamente par. 

Teorema 4.4.10  

Seja 𝐶 um código binário (𝑛, 𝑘) com matriz geradora 𝐺 e matriz de verificação de paridade 

𝑃.  Se 𝐶 é autodual, então 𝑛 = 2𝑘, 𝐺 é de ordem (2𝑘) × 𝑘 e 𝑃 = 𝐺𝑇 é uma matriz de verificação 

de paridade para 𝐶. 

Demonstração Se 𝐶 é um código binário (𝑛, 𝑘) então, pelo Teorema 4.4.2., 𝐶⊥ é um código 

binário (𝑛, 𝑛 − 𝑘).  Mas se 𝐶 = 𝐶⊥ então 𝑘  =  𝑛 − 𝑘 e portanto 𝑛 = 2𝑘.   

Além disso, ainda pelo Teorema 4.4.2. 𝑃𝑇 é a matriz geradora de 𝐶⊥, mas como 𝐶⊥ = 𝐶, então 

𝑃 = 𝐺𝑇, onde 𝐺 é uma matriz de ordem (2𝑘) × 𝑘 e obviamente 𝑃 é de ordem 𝑘 × (2𝑘). 

 
 
 
 
 
 
 
 
57 

5. MÉTRICA DE HAMMING  

Nosso  objetivo  principal  neste  capítulo  é  estabelecer  um  resultado  que  permita  determinar 

quantos erros o código pode detectar e quantos erros podem ser corrigidos. Para mais detalhes 

veja a seção 1.3. 

5.1. Distância de Hamming 

Definição 5.1.1.  

Dados  dois  elementos  𝑢 = (𝑢1, 𝑢2, … , 𝑢𝑛)  e  𝑣 = (𝑣1, 𝑣2, … , 𝑣𝑛)  em  ℤ2

𝑛,  a  distância  de 

Hamming entre 𝑢 e 𝑣 é definida por 

onde 𝑤(𝑢 + 𝑣) é o peso do vetor 𝑢 + 𝑣 

𝑑𝐻(𝑢, 𝑣) = ‖𝑢 + 𝑣‖𝐻 = 𝑤(𝑢 + 𝑣) 

Exemplo:  Encontre  a  distância  de  Hamming  entre  os  vetores  𝑢 = (1, 0, 1, 0, 1)  e  𝑣 =

5. 
(1, 0, 0, 1, 1) em ℤ2
Solução: Como 𝑢 + 𝑣 = (0, 0, 1, 1, 0), então 

𝑑𝐻(𝑢, 𝑣) = ‖𝑢 + 𝑣‖𝐻 = ‖(0, 0, 1, 1, 0)‖𝐻 = 𝑤(0, 0, 1, 1, 0) = 2 

Toda  função  distância  definida  a  partir  de  uma  norma  num  espaço  vetorial  𝑉  satisfaz  às 

seguintes propriedades: 

Teorema 5.1.2  

Para todos os vetores 𝑢, 𝑣, 𝑤 em 𝑉 valem: 

a) 𝑑(𝑢, 𝑣) ≥ 0 e 𝑑(𝑢, 𝑣) = 0 se, e somente se, 𝑢 = 𝑣 (positividade) 

b) 𝑑(𝑢, 𝑣) = 𝑑(𝑣, 𝑢) (simetria) 

c) 𝑑(𝑢, 𝑣) ≤ 𝑑(𝑢, 𝑤) + 𝑑(𝑤, 𝑣) (desigualdade triangular) 

𝑛, se 𝑑 é a distância 𝑑𝐻 de Hamming e ‖𝑢‖ é a norma 
Em particular, para o espaço vetorial ℤ2
‖𝑢‖𝐻  de  Hamming,  o  teorema  anterior  também  vale  e,  portanto,  as  propriedades  acima 

permitem dizer que 𝑑𝐻 é uma métrica em ℤ2

𝑛, chamada métrica de Hamming. 

Introduziremos a seguir a noção de distância nos códigos binários. 

 
 
 
 
 
 
 
 
 
 
 
 
58 

Definição 5.1.3.  

Seja  𝐶  um  código  binário,  a  distância  mínima  de  𝐶  é  a  menor  distância  de  Hamming  entre 

quaisquer dois vetores distintos de 𝐶. Isto é, 

𝑑(𝐶) = min{𝑑𝐻(𝑥, 𝑦): 𝑥 ≠ 𝑦 em 𝐶} 

Exemplo: Encontre a distância mínima do código 𝐶 = {𝑐0, 𝑐1, 𝑐2, 𝑐3} onde 𝑐0 =

0
0
0
0
0]

, 𝑐1 =

0
1
0
1
1]

, 

[

[

1
0
1
1
0]

 e 𝑐3 =

1
1
1
0
1]

[

𝑐2 =

[

Solução: Precisamos calcular a distância de Hamming entre os (

) = 6 pares de vetores: 

𝑑𝐻(𝑐0, 𝑐1) = 3 
𝑑𝐻(𝑐1, 𝑐2) = 4 
Logo,  

𝑑𝐻(𝑐0, 𝑐2) = 3 
𝑑𝐻(𝑐1, 𝑐3) = 3 

4
2
𝑑𝐻(𝑐0, 𝑐3) = 4 
𝑑𝐻(𝑐2, 𝑐3) = 3 

𝑑(𝐶) = min{3, 3, 4, 4, 3, 3} = min{3, 4} = 3 

Em geral, para calcular  𝑑(𝐶) num código  𝐶 de  𝑀 vetores – por este método – é necessário 

calcular (

𝑀
2

) distâncias, o que é inviável para 𝑀 muito grande. Veremos adiante um método 

mais eficiente. 

O seguinte resultado mostra que em códigos lineares com 𝑀 elementos, pode-se calcular 𝑑(𝐶) 

apenas com 𝑀 − 1 cálculos de distâncias em vez dos (

𝑀
2

) cálculos anteriormente requeridos. 

Proposição 5.1.4  

Se 𝐶 ⊂ ℤ2

𝑛 é um código linear com distância mínima 𝑑, então 

𝑑 = 𝑤(𝐶) ≔ min{𝑤(𝑥): 𝑥 ∈ 𝐶\{0}} 

onde 𝑤(𝐶) é o peso mínimo de 𝐶 ou simplesmente o peso de 𝐶. 

Demonstração  Basta  provar  que  os  conjuntos  finitos  𝐴 = {𝑑𝐻(𝑥, 𝑦): 𝑥 ≠ 𝑦  ∈  𝐶}  e  𝐵 =
{𝑤(𝑧): 𝑧 ∈ 𝐶\{0}} são  iguais,  pois  se  𝐴 = 𝐵,  𝑑(𝐶) = min 𝐴 = min 𝐵 = 𝑤(𝐶)  e  tem-se  o 

resultado.  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
59 

Para fazer isto, considere 𝑤(𝑧) ∈ 𝐵 com 𝑧 arbitrário em 𝐶\{0}. Como 𝑤(𝑧) = 𝑑𝐻(𝑧, 0), com 
𝑧 ≠ 0 segue que 𝑤(𝑧) ∈ 𝐴 e, portanto 𝐵 ⊂ 𝐴.  

Reciprocamente, seja  𝑑𝐻(𝑥, 𝑦) ∈ 𝐴. Como 𝑥 + 𝑦 ∈ 𝐶, com 𝑥 ≠ 𝑦, e  𝐶 é um espaço vetorial 
tem-se  que  𝑧 = 𝑥 + 𝑦 ∈ 𝐶\{0} e,  portanto  𝑑𝐻(𝑥, 𝑦) = 𝑤(𝑥 + 𝑦) = 𝑤(𝑧)  com  𝑧 ≠ 0.  Logo, 
𝑑𝐻(𝑥, 𝑦) ∈ 𝐵 e, portanto 𝐴 ⊂ 𝐵. 

Agora estamos em condições de refazer o exemplo anterior com menos esforço. Primeiramente, 

observe que 𝐶 = {𝑐0, 𝑐1, 𝑐2, 𝑐3} como definido anteriormente é um subespaço de ℤ2
trata-se de um código linear. Vimos que 𝑑(𝐶) = min{3, 3, 4, 4, 3, 3} = min{3, 4} = 3. Agora 

5 e, portanto, 

vamos calcular 𝑤(𝐶) = min{𝑤(𝑐1), 𝑤(𝑐2), 𝑤(𝑐3)}: 

𝑤(𝑐1) = 𝑤(0, 1, 0, 1, 1) = 3 
𝑤(𝑐2) = 𝑤(1, 0, 1, 1, 0) = 3 
𝑤(𝑐3) = 𝑤(1, 1, 1, 0, 1) = 4 

Daí, 𝑑(𝐶) = 𝑤(𝐶) = min{3, 3, 4} = min{3, 4} = 3. 

5.2. Códigos de correção de erros 

Quando digitamos a palavra ELEFANTR em um editor de textos, é possível  que ele faça a 

correção, se for programado para fazer duas suposições: 

  Nossa intenção foi escrever uma palavra em português, e não em outra língua, nem uma 

sigla; 

  A quantidade de erros que cometemos na digitação foi a menor possível. 

Deste modo, o editor pode fazer a correção para ELEFANTE. 

Por outro lado, se a palavra fosse ELETANTE o programa enfrentaria maiores dificuldades. A 

palavra  correta  seria  ELEFANTE  ou  ELEGANTE?  O  fato  de  existir  duas  palavras  como 

elefante e elegante cuja distância (número de componentes diferentes) é  igual a 1, não permite 

que a correção seja feita sempre. 

Se a palavra fosse MOLO, novamente seria difícil decidir. A palavra correta seria BOLO ou 

MOLA, por exemplo. O fato de a distância entre bolo e mola ser igual a 2 gera essa dificuldade.  

De maneira geral, para que seja sempre possível corrigir um erro, é necessário que a distância 

mínima entre duas palavras seja maior ou igual a 3 Isso garante que haja uma única palavra 

mais próxima da palavra com um erro, que é justamente a palavra correta. 

 
 
 
 
 
 
60 

É exatamente desta forma que o código de Hamming funciona, como veremos nesta seção e no 

capítulo seguinte. 

Definição 5.2.1.  

Dado um elemento 𝑥 ∈ ℤ2
são respectivamente os conjuntos 

𝑛 e um número real 𝑡 > 0, o disco e a esfera de centro em 𝑥 e raio 𝑡 

𝐷(𝑥, 𝑡) = {𝑦 ∈ ℤ2
𝑆(𝑥, 𝑡) = {𝑦 ∈ ℤ2

𝑛: 𝑑(𝑥, 𝑦) ≤ 𝑡} 

𝑛: 𝑑(𝑦, 𝑥) = 𝑡} 

Definição 5.2.2  

Para cada vetor código 𝑥 ∈ 𝐶 e um número real 𝑡 > 0, o disco (de Hamming) com centro 𝑥 e 

raio 𝑡 será o conjunto  

Observe inicialmente que se 𝑐 ∈ 𝐶, 𝑑𝐻(𝑏, 𝑐) ≥ 𝑑 para 𝑐 ≠ 𝑏 ∈ 𝐶, e, portanto: 

𝐷𝐻(𝑥, 𝑡) = {𝑦 ∈ 𝐶: 𝑑𝐻(𝑦, 𝑥) ≤ 𝑡} 

  Se 𝑡 < 𝑑, 𝑐 é o único vetor código no disco 𝐷𝐻(𝑐, 𝑡) 

  Se 𝑑 < 2𝑡, 𝐷𝐻(𝑐, 𝑡) ∩ 𝐷𝐻(𝑏, 𝑡) = ∅. 

Para que 𝐶 seja um código (binário) corretor de 𝜅 erros é usado o processo conhecido como 

“decodificador pelo vizinho mais próximo”. Para isso deve-se encontrar um raio 𝜅 apropriado 

tal  que  todos  os  discos  centrados  em  vetores  de  código  não  se  interceptem,  e,  portanto,  ao 

receber  𝑐′  obtido  por  até  𝜅  trocas  nas  entradas  de  𝑐 ∈ 𝐶,  ele  se  encontrará  apenas  no  disco 

𝐷𝐻(𝑐, 𝜅) e, portanto 𝑐′ será decodificado por 𝑐, pois 𝑐 será seu vizinho mais próximo (dentre 

todos os vetores código). Agora vamos formalizar esses conceitos. 

Definição 5.2.3.  

Seja 𝐶 um código (binário). Para um vetor 𝑐 ∈ 𝐶, seja 𝑐′ um vetor obtido por até 𝜅 trocas nas 

entradas de 𝑐. Dizemos que: 

a) 𝐶 detecta 𝜅 erros se 𝑐′ não é um vetor código. 

b) 𝐶 corrige 𝜅 erros se o vizinho decodificado mais próximo de 𝑐′ produz 𝑐. 

Dado um código 𝐶 com distância mínima 𝑑, define-se 𝜅 = [

𝑑−1

2

], onde [𝑡] representa a parte 

inteira de um número real 𝑡, isto é, [𝑡] é o maior inteiro menor do que ou igual a 𝑡. 

 
 
 
 
 
 
 
 
 
61 

Lema 5.2.4.  

Seja 𝐶 um código com distância mínima 𝑑. Se 𝑏 e 𝑐 são vetores código distintos de 𝐶, então 

𝐷(𝑏, 𝜅) ∩ 𝐷(𝑐, 𝜅) = ∅ 

Demonstração: Suponha por absurdo que  𝐷(𝑏, 𝜅) ∩ 𝐷(𝑐, 𝜅) ≠ ∅ e considere  𝑥 ∈ 𝐷(𝑏, 𝑘) ∩

𝐷(𝑐, 𝜅).  Logo  𝑑𝐻(𝑥, 𝑏) ≤ 𝜅  e  𝑑𝐻(𝑥, 𝑐) ≤ 𝜅  e,  portanto,  pela  simetria  e  pela  desigualdade 

triangular 

𝑑(𝑏, 𝑐) ≤ 𝑑(𝑏, 𝑥) + 𝑑(𝑥, 𝑐) ≤ 2𝜅 

Da definição de 𝜅 tem-se que 𝜅 ≤

𝑑−1

2

 e, portanto, 2𝜅 ≤ 𝑑 − 1. 

Logo, 𝑑(𝑏, 𝑐) ≤ 𝑑 − 1 o que é uma contradição, pois 𝑑𝐻(𝑏, 𝑐) ≥ 𝑑. 

O resultado mais importante deste capítulo é o seguinte. 

Teorema 5.2.5 Seja 𝐶 um código com distância mínima 𝑑. Então, 𝐶 pode corrigir até 𝜅 = [

erros e detectar até 𝑑 − 1 erros. 

𝑑−1

] 

2

Demonstração Seja 𝑐 um vetor código em 𝐶. Se ao transmitirmos 𝑐 é recebido o vetor 𝑐′ com 
𝑡 erros nas componentes de 𝑐, com 𝑡 ≤ 𝜅, então 𝑑𝐻(𝑐′, 𝑐) = 𝑡 ≤ 𝜅 e, portanto 𝑐′ ∈ 𝐷𝐻(𝑐, 𝜅). 
Pelo  Lema  5.2.4  segue  que  para  cada  𝑏 ∈ 𝐶  com  𝑏 ≠ 𝑐,  𝑐′ ∉ 𝐷𝐻(𝑏, 𝜅)  e,  portanto  𝑐′  é 
decodificado pelo vizinho mais próximo, que é 𝑐. 

Por  outro  lado,  dado  um  vetor  código  𝑐 ∈ 𝐶,  se  são  introduzidos  𝑑 − 1  erros  nas  suas 
coordenadas,  recebendo  o  vetor  𝑐′,  então  𝑑𝐻(𝑐, 𝑐′) = 𝑑 − 1  e,  portanto  𝑐′ ∉ 𝐶  pois,  caso 
contrário, teríamos 𝑑𝐻(𝑐, 𝑐′) ≥ 𝑑. 

Por exemplo, vimos que o código 𝐶 apresentado após a definição 5.1.3 é tal que 𝑑 = 3. Logo, 

nele é possível corrigir até 𝜅 = [

3−1

2

] = 1 erro e detectar até 3 − 1 = 2 erros. 

O teorema anterior ressalta a importância de se conhecer a distância mínima de um código. No 

caso de códigos lineares a proposição 5.1.4 facilita essa tarefa. Também é possível determinar 

𝑑(𝐶) examinando a matriz de verificação de paridade de 𝐶. 

Teorema 5.2.6  

Seja  𝐶  um  código  linear  (𝑛, 𝑘)  com  matriz  de  verificação  de  paridade  𝑃.  Então  a  distância 

mínima de 𝐶 é o menor inteiro 𝑑 para o qual existem 𝑑 colunas linearmente dependentes. 

 
 
 
 
 
 
 
62 

Demonstração  Suponha  que  𝑑(𝐶) = 𝑑.  Se  𝐶  é  um  código  linear  (𝑛, 𝑘)  com  matriz  de 

verificação  de  paridade  𝑃,  então  𝑃  é  de  ordem  (𝑛 − 𝑘) × 𝑛  e  𝑃𝑥 = 0,  ∀𝑥 ∈ 𝐶 ⊂ ℤ2

𝑛.  Pela 

Proposição  5.1.4,    𝐶  contém  um  vetor  𝑐  de  peso  𝑑.  Então  𝑃𝑐  é  uma  combinação  linear  de 

exatamente 𝑑 colunas de 𝑃. Mas como 𝑃𝑐 = 0 tem-se que existe um subconjunto com 𝑑 colunas 

de 𝑃 que é linearmente dependente. A seguir provaremos que 𝑑 é o número mínimo de colunas 

linearmente dependentes na matriz 𝑃.  

De  fato,  suponha  por  absurdo  que  existam  𝑡,  com  𝑡 < 𝑑,  colunas  linearmente  dependentes, 

digamos que 

𝑃𝑖1, 𝑃𝑖2, … , 𝑃𝑖𝑡 

sejam 𝑡 colunas linearmente dependentes dentre as colunas de 𝑃. Logo, existem escalares não 

todos nulos 𝛼𝑖𝑗 ∈ ℤ2 tais que 

Pela minimalidade de  𝑡 segue que esses escalares são todos iguais a 1 e portanto 

𝛼𝑖1𝑃𝑖1 + 𝛼𝑖2𝑃𝑖2 + ⋯ + 𝛼𝑖𝑡𝑃𝑖𝑡 = 0 

𝑃𝑖1 +   𝑃𝑖2 + ⋯ + 𝑃𝑖𝑡 = 0 

𝑛 com entradas 1 nas posições 𝑖1, 𝑖2, … , 𝑖𝑡 e zero nas demais. Então 𝑤(𝑥) = 𝑡 e 𝑃𝑥 =
Seja 𝑥 ∈ ℤ2
0.  Logo  𝑥  é  um  vetor  código  com  peso  𝑡 < 𝑑 = 𝑑(𝐶).  Isto  contradiz  a  Proposição  5.1.4  e, 

portanto temos um absurdo. 

Reciprocamente, suponha que qualquer 𝑑 − 1 colunas de 𝑃 sejam L.I. e que alguns conjuntos 

de  𝑑  colunas  de  𝑃  sejam  L.D.  Como  𝑃𝑥  é  uma  combinação  linear  das  colunas  de  𝑃 

correspondentes às posições dos 1s em 𝑥, 𝑃𝑥 ≠ 0 para qualquer vetor 𝑥 com peso 𝑑 − 1 ou 

menos. Portanto,  não existem vetores código não nulos com  peso menor que  𝑑. Mas  algum 

conjunto de 𝑑 colunas de 𝑃 é L.D., portanto, existe um vetor 𝑥 com peso 𝑑 tal que 𝑃𝑥 = 0. 

Logo, esse 𝑥 é um vetor código com peso 𝑑. Novamente, pela Proposição 5.1.4, deduzimos que 

𝑑(𝐶) = 𝑑. 

Exemplo:  Suponha  que  uma  mensagem  contenha  os  vetores  𝑥0 = (0, 0),  𝑥1 = (0, 1),  𝑥2 =
2 e que a matriz geradora padrão seja tal que 

(1, 0) e 𝑥3 = (1, 1) em ℤ2

𝐺𝑥0 = 𝑐0, 𝐺𝑥1 = 𝑐1, 𝐺𝑥2 = 𝑐2, 𝐺𝑥3 = 𝑐3, onde 𝐶 = {𝑐0, 𝑐1, 𝑐2, 𝑐3} 

é o código do exemplo dado após definição 5.1.3. É fácil determinar 𝐺 como sendo a matriz 

 
 
 
 
63 

(

𝐼2
𝐴

) =

1 0
0 1
1 0
1 1
0 1)

(

paridade.  

   e  portanto  𝑃 = (𝐴|𝐼) = (

1 0 1 0 0
1 1 0 1 0
0 1 0 0 1

)  é  a  matriz  de  verificação  de 

Temos  que  𝐶  é  um  código  linear  (5, 2).  Observe  que  os  vetores  𝑒1,  𝑒2  e  𝑒1 + 𝑒2  (que 

correspondem às 3ª, 4ª e 1ª colunas de 𝑃) são L.D. e que quaisquer duas colunas de 𝑃 são L.I. 

Pelo Teorema 5.2.6, isto significa que 𝑑(𝐶) = 3 (coincidindo com nossas contas anteriores). 

Em vista da importância da distância mínima nos códigos lineares, existe a seguinte: 

Notação: Se um código linear (𝑛, 𝑘) tem distância mínima 𝑑, ele é chamado de código (𝑛, 𝑘, 𝑑). 

 
 
 
 
 
 
 
 
 
 
64 

6. CÓDIGO DE HAMMING  

Ao buscarmos um código que possa transmitir a maior quantidade de informações possível é 

desejado que 𝑘 (e, portanto 𝑛) seja o maior possível.  Pelo Teorema 4.1.2 as 𝑛 colunas de 𝑃 

precisam ser não nulas e distintas, então o máximo ocorre quando elas consistem de todos os 

vetores não nulos de ℤ2
máximo é atingido quando 𝑛 = 2𝑛−𝑘 − 1. 

𝑛−𝑘.  Como ℤ2

𝑛−𝑘 possui 2𝑛−𝑘 − 1 vetores não nulos e distintos, esse 

Definição 6.1.1. (Códigos de Hamming)  

Um código de Hamming (𝒏, 𝒌) sobre ℤ2 é um código com matriz de verificação de paridade 
𝑛−𝑘 ∖ {0}  numa  ordem 

𝑃  de  ordem  (𝑛 − 𝑘) × 𝑛  cujas  colunas  são  todos  os  vetores  de  ℤ2
qualquer. 

Observe que para cada inteiro 𝑚 = 𝑛 − 𝑘 > 1, existem únicos 𝑛 e 𝑘 tais que 𝑛 = 2𝑛−𝑘 − 1. 

Exemplo:  Se  𝑚 = 2,  𝑛 = 3  então  𝑘 = 1  e,  portanto,  existem  códigos  de  Hamming  (3,1).  

Como ilustração, se 𝐺 = [

] é a matriz geradora padrão do código, então 𝑃 = [

1 1 0
1 0 1

] é a 

1
1
1

matriz de verificação de paridade padrão associada a 𝐺 para esse código.  Neste caso, os vetores 

de mensagem são os dígitos 0 e 1 e os vetores de código são [0, 0, 0] e [1, 1, 1]. 

Exemplo: Se 𝑚 = 3, 𝑛 = 7 e 𝑘 = 4.  Uma matriz candidata a matriz de verificação de paridade 

para um código de Hamming (7, 4) é  

𝑃 = [

1 0 1 1 1 0 0
1 1 0 1 0 1 0
0 1 1 1 0 0 1

] = [𝐴 𝐼3] e, pelo Teorema 4.1.2, a matriz geradora padrão 

desse código é 𝐺 = [

𝐼4
𝐴

] 

Corolário 6.1.2.  

Se 𝐶(𝑛, 𝑘) é um código binário autodual, então 𝐶 não é um código de Hamming (𝑛, 𝑘). 

Demonstração Se 𝐶 fosse de Hamming então 𝑛 seria ímpar (pois 𝑛  =   2𝑛−𝑘 − 1), mas isto é 

um absurdo, pois pelo Teorema 4.4.9, 𝑛 deve ser par. 

 
 
 
 
 
 
 
 
 
 
65 

Teorema 6.1.4.  

Todo código de Hamming tem distância mínima 3. Isto é, códigos de Hamming são códigos 

(𝑛, 𝑘, 𝑑) onde 𝑛 = 2𝑛−𝑘 − 1 e 𝑑 = 3. 

Demonstração: Considere um código de Hamming 𝐶 com matriz de verificação de paridade 

𝑃. Duas colunas em 𝑃 são sempre LI, e sempre é possível achar três colunas LD em  𝑃, por 

exemplo, 𝑒1, 𝑒2 e 𝑒1 + 𝑒2. Portanto, pelo Teorema 5.2.6, temos que 𝑑 = 3. 

Corolário 6.1.5.  

Os códigos de Hamming detectam até dois erros e corrigem um erro. 

Demonstração: Pelo Teorema 6.1.4 sabe-se que Se 𝑑 = 3, então 𝜅 = [

tem-se o resultado. 

𝑑−1

2

] = 1 e, portanto, 

 
 
 
 
 
 
 
66 

CONCLUSÃO 

Neste  trabalho,  tivemos  a  oportunidade  de  estudar  os  códigos  de  Hamming  para  detecção  e 

correção de erros, mostrando uma aplicação prática da matemática na área da Tecnologia da 

Informação. Ter conhecimento de aplicações como essas é útil ao professor de matemática, que 

está sempre sendo questionado pelos alunos sobre a importância da matemática para além da 

sala de aula. Por exemplo, os códigos de detecção e correção de erros que vimos ao longo do 

texto  podem  ser  apresentados  aos  alunos,  com  as  devidas  simplificações,  como  motivação 

adcional ao ensino aritmética e de matrizes. 

O leitor interessado em se aprofundar, pode pesquisar sobre outras famílias de códigos lineares 

como os códigos de Reed-Muller e o código de Golay, ambos utilizados pela NASA nas décadas 

de 1970 e 1980, de acordo com Poole (2014) para transmissão confiável de fotos vindas de 

sondas espaciais como a Mariner 9 e o Voyager 1 e 2. Além destes, há o CRC (estudado em 

cursos  de  Redes  de  Computadores)  como  um  exemplo  de  código  utilizado  atualmente. 

Entretanto, o CRC usa outras ferramentas matemáticas para corregir os erros de transmissão. 

 
 
 
 
 
 
 
 
 
67 

REFERÊNCIAS 

BROOKSHEAR,  J.G.  Ciência  da  computação:  uma  visão  abrangente.  7.  Ed.  São  Paulo: 

Artmed, 2003.  

FERREIRA,  André  Arantes.  Detecção  e  Correção  de  Erros  em  Códigos  Binários. 

Dissertação 

de  mestrado.  Universidade 

do 

Porto, 

2007.  Disponível 

em 

http://www.fc.up.pt/fcup/contactos/teses/t_030370081.pdf 

FORMIGA, Maurício Marinho. Comunicação de Dados para um Sistema de Telemetria de 

Baixo 

Custo. 

Dissertação 

de 

Mestreado. 

Disponível 

em 

http://docs.computacao.ufcg.edu.br/posgraduacao/dissertacoes/2005/Dissertacao_MauricioMa

rinhoFormiga.pdf 

HAMMING, Richard W.  Error Detecting and Error Correcting Codes. The Bell System 

Technical 

Journal 

vol.XXVI. 

April, 

1950. 

Disponível 

em 

http://www.sns.ias.edu/~tlusty/courses/InfoInBio/Papers/Hamming1950.pdf 

HEFEZ, Abramo. Curso de Álgebra. v.1. 3ª ed. Rio de Janeiro: IMPA, 2002. 

HEFEZ, Abramo; VILLELA, Maria Lúcia Torres. Códigos Corretores de Erros. 2 ed. Rio de 

Janeiro: IMPA, 2008. 

MILIES,  César  Polcino.  A  Matemática  dos  Códigos  de  Barras.  Campina  Grande:  UFCG, 

2006. Disponível em www.mat.ufg.br/bienal/2006/mini/polcino.pdf 

POOLE, David. Álgebra Linear. 8ª ed. São Paulo: Cengage Learning, 2014. 

SHANNON,  Claude  E.  A  Mathematical  Theory  of  Communication.  The  Bell  System 

Technical 

Journal 

vol.XXVII. 

July, 

1948. 

Disponível 

em 

http://worrydream.com/refs/Shannon%20-

%20A%20Mathematical%20Theory%20of%20Communication.pdf 

 
 
 
 
 
 
