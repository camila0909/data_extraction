Universidade do Estado do Rio de Janeiro

Centro de Educação e Humanidades

Faculdade de Formação de Professores

Alexandre Peixoto Marcet

Códigos Corretores de Erros BCH: uma aplicação de polinômios

em Corpos Finitos

São Gonçalo

2019

Alexandre Peixoto Marcet

Códigos Corretores de Erros BCH: uma aplicação de polinômios em Corpos
Finitos

como 

apresentada, 

Dissertação 
requisito 
parcial  para  obtenção  do  título  de  Mestre,  ao 
em 
Programa  de  Mestrado  Profissional 
Matemática em Rede Nacional (PROFMAT) da 
Universidade do Estado do Rio de Janeiro.

Orientador: Profa. Dra. Clícia Valladares Peixoto Friedmann

São Gonçalo

2019

CATALOGAÇÃO NA FONTE
UERJ / REDE SIRIUS  / BIBLIOTECA CEH/D

M314

Marcet, Alexandre Peixoto

Códigos Corretores de Erros BCH: uma aplicação de polinômios em Cor-

pos  Finitos  /  Alexandre  Peixoto  Marcet  -  2019.

77 f.

Orientador: Profa. Dra. Clícia Valladares Peixoto Friedmann
Dissertação  (Mestrado)  –  Mestrado Profissional em Matemática em Rede 
Nacional (PROFMAT) - Universidade do Estado do Rio de Janeiro, Faculdade de 
Formação de Professores.

1. Polinômios.  2.  Códigos  Corretores  de  Erros  (Teoria  da  informação).

  I.  Friedmann,  ClíciaValladares  Peixoto  .  II.  Universidade  do Estado  do 
Rio  de  Janeiro.  III.  Faculdade  de  Formação  de  Professores.  IV. Título

CRB-7 - 4994

CDU  519.725

Autorizo, apenas para ﬁns acadêmicos e cientíﬁcos, a reprodução total ou parcial desta
dissertação, desde que citada a fonte.

Assinatura

Data

Alexandre Peixoto Marcet

Códigos Corretores de Erros BCH: uma aplicação de polinômios em Corpos
Finitos

como 

apresentada, 

Dissertação 
requisito 
parcial  para  obtenção  do  título  de  Mestre,  ao 
em 
Programa  de  Mestrado  Profissional 
Matemática em Rede Nacional (PROFMAT) da 
Universidade do Estado do Rio de Janeiro.

Aprovada em 31 de outubro de 2019.
Banca Examinadora:

Profa. Dra. Clícia Valladares Peixoto Friedmann (Orientador)
Faculdade de Formação de Professores – UERJ

Prof. Dr. Abel Rodolfo García Lozano
Faculdade de Formação de Professores – UERJ

Profa. Dra. Andréa Gomes Guimarães
Instituto de Matemática – Universidade Federal Fluminense

São Gonçalo

2019

DEDICATÓRIA

Dedico esse trabalho à minha mãe por sempre acreditar em mim, ao meu pai (in
memorian), à minha esposa Tatiana por sua inﬁnita compreensão e incentivo e ao meu
mestre Dr. Daisaku Ikeda por ter propagado o Budismo Nichiren para o Brasil.

AGRADECIMENTOS

Agradeço à minha mãe por sempre estar me apoiando e incentivando carinhosa-

mente.

Agradeço ao meu pai (in memorian) por ter me apoiado em diversas situações da

minha vida.

Agradeço à minha esposa pelo seu amor, apoio, companheirismo e dedicação.
Agradeço à minha orientadora Clícia pela paciência, compreensão e apoio que

foram importantes para a realização deste trabalho.

Agradeço aos professores e colegas do Profmat da Uerj - São Gonçalo por terem

participado positivamente da minha vida.

Agradeço à todas as demais pessoas que ﬁzeram ou fazem parte da minha vida e

que contribuíram para o meu crescimento individual em todos os aspectos.

Agradeço aos professores da banca pelo apoio.
Agradeço à CAPES pelo apoio ﬁnanceiro, que foi fundamental para a realização

deste mestrado.

O presente trabalho foi realizado com apoio da Coordenação de Aperfeiçoamento

de Pessoal de Nível Superior - Brasil (CAPES) - Código de Financiamento 001.

A mente que se abre a uma nova ideia jamais voltará ao seu tamanho original.
Albert Einstein

RESUMO

MARCET, A.P.M. Códigos  Corretores  de  Erros  BCH:  uma  aplicação  de  polinômios 
em Corpos  Finitos.  2019.  77  f.  Dissertação (Mestrado Profissional em Matemática em 
Rede Nacional - PROFMAT) –  Faculdade de Formação de Professores, Universidade do 
Estado do  Rio de Janeiro, Rio de Janeiro, 2019.

Códigos corretores de erros são usados para recuperar informações que, no pro-
cesso de armazenamento ou trnasmissão, sofreram algum tipo de alteração. Pretendemos
mostrar neste trabalho a relevância dos polinômios, conteúdo matemático abordado desde
o Ensino Fundamental. E para isso, apresentaremos sua aplicação nos códigos correto-
res de erros BCH (Bose-Chaudhuri-Hocquenghem), que trabalham sobre Corpos Finitos.
Introduziremos alguns conceitos e resultados de Álgebra e exploraremos exemplos que
mostram como é feita a utilização dos polinômios nos códigos BCH.
Palavras-chave: Polinômios. Códigos Corretores de Erros. BCH. Corpos Finitos.

ABSTRACT

MARCET, A.P.M. BCH  Error-Correcting  Codes:  an  application  of  polynomials  in
Finite  Fields.  2019.  77  f.  Dissertação (Mestrado  Profissional em Matemática em 
Rede Nacional - PROFMAT) – Faculdade de Formação de Professores, Universidade 
do Estado do Rio  de Janeiro, Rio  de Janeiro,  2019.

Error-correcting  codes  are  used  to  retrieve  information  that  has  changed  in  the 
process  of  storing  or  transmitting  data.  This  TCC  intends  to  show  the  relevance  of 
polynomials,  mathematical  content  approached  since  elementary  school.  And  for  that, 
we  will  present  its  application  in  the  error  correcting  codes  BCH  (Bose-Chaudhuri- 
Hocquenghem)  er-ror  correcting  codes,  which  work  on  Finite  Fields.  We  will  present 
some  concepts  and results of Algebra and explore examples showing how polynomials are 
used in BCH codes.

Keywords: Polynomials. Error Correcting Codes. BCH. Finite Fields.

LISTA DE FIGURAS

Figura 1
Figura 2
Figura 3

- Divisões de v(x) = x4 + 1 e u(x) = x5 + 1 por g(x) = x3 + x + 1 . . . . 26
- Divisões de h(x) = x6 + 1 e f (x) = x7 + 1 por g(x) = x3 + x + 1 . . . . 27
. . 38
- Diagrama simpliﬁcado de transmissão ou armazenamento de dados

LISTA DE TABELAS

Tabela 1
Tabela 2
Tabela 3
Tabela 4
Tabela 5
Tabela 6
Tabela 7
Tabela 8
Tabela 9

- Operações em Z2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
- Operações em Z5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
- Polinômios primitivos de grau m (3 ≤ m ≤ 10) . . . . . . . . . . . . . . 27
- Representações dos elementos de F23
. . . . . . . . . . . . . . . . . . . 31
- Polinômios mínimos dos elementos de F23 gerado por p(x) = x3 + x + 1 35
- Código cíclico binário C(7, 4) gerado por g(x) = 1 + x + x3 . . . . . . . 58
- Parâmetros dos códigos BCH(n, k) binários para 3 ≤ m ≤ 5 . . . . . . 62
- Representações dos elementos de F24, gerado por p(x) = 1 + x + x4
. . 73
- Polinômios mínimos dos elementos de F24 gerado por p(x) = 1 + x + x4
74

LISTA DE ALGORITMOS

. . 51
Algoritmo 1 - Algoritmo de Decodiﬁcação em Códigos Corretores de Um Erro
Algoritmo 2 - Algoritmo de Decodiﬁcação em Códigos Corretores de k Erros
. . . 53
Algoritmo 3 - Algoritmo de Peterson . . . . . . . . . . . . . . . . . . . . . . . . . 70

SUMÁRIO

1
1.1
1.2
1.3
2
2.1
2.2
2.3
2.4
3
3.1
3.2
3.3
3.4

INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
FUNDAMENTOS MATEMÁTICOS
. . . . . . . . . . . . . . . . . 14
Conceitos Básicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
Anel dos Inteiros Módulo m . . . . . . . . . . . . . . . . . . . . . . . 16
Polinômios sobre um Corpo . . . . . . . . . . . . . . . . . . . . . . . . 18
CORPOS FINITOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Conceitos Básicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Extensão de um Corpo Finito . . . . . . . . . . . . . . . . . . . . . . 25
Construção de Extensões de Corpos Finitos com 2m elementos
. 26
Algumas Propriedades de Corpos Finitos com 2m elementos . . . 31
CÓDIGOS CORRETORES DE ERROS . . . . . . . . . . . . . . . 37
Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Códigos Lineares
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Códigos Cíclicos Binários . . . . . . . . . . . . . . . . . . . . . . . . . 53
Códigos BCH Binários . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
CONCLUSÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
REFERÊNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

INTRODUÇÃO

12

No Brasil, o estudo de polinômios na escola se inicia nos anos ﬁnais do Ensino
Fundamental, onde são vistos, entre outros, os seguintes conteúdos: expressões algébricas,
produtos notáveis, fatoração e polinômios sobre o conjunto dos números reais. Depois,
no Ensino Médio, o tema polinômios é retomado e aprofundado, sendo abordado nos
conteúdos: equações polinomiais e polinômios sobre o conjunto dos números complexos.
Nos dois níveis de ensino – Fundamental e Médio – os polinômios são estudados sobre os
seguintes conjuntos: N, Z, Q, R e C. Contudo, várias aplicações que surgiram com o desen-
volvimento de Ciência da Computação, o uso maciço de computadores e as comunicações
via satétile trabalham com polinômios sobre Corpos Finitos e suas extensões, como é o
caso de algumas aplicações relacionadas à Criptograﬁa e Teoria dos Códigos Corretores
de Erros. Dessa forma, a abordagem de polinômios sobre Corpos Finitos passou a ser
valorizada nas graduações da área tecnológica, principalmente em algumas engenharias
como: elétrica, de computação, eletrônica, de telecomunicações e etc.., além da Matemá-
tica. Com isso, é natural pensarmos que, em algum momento, necessitaremos trabalhar,
ainda no Ensino Médio, com polinômios sobre os Corpos Finitos, o que nos remete ao
Corpo dos inteiros módulo m (Zm), sendo m um número primo.

A constatação de que precisaremos abordar polinômios sobre Zm no Ensino Médio
é uma provável consequência da valorização dos conteúdos de congruência modular e no-
ções de Criptograﬁa na Educação Básica, o que já pode ser visto em trabalhos acadêmicos
que se relacionam ao ensino de Matemática, inclusive dentro do PROFMAT, como por
exemplo (CARVALHO, 2014), (NICOLETTI, 2015) e (ARAGÃO, 2017). Essa constata-
ção e o desejo de trabalhar com códigos corretores de erros em nossa pesquisa serviram
de motivação para a elaboração deste trabalho.

Começamos então a pesquisar algum tipo de código corretor de erros que valorizasse
o uso de polinômios de uma forma mais direta e que trabalhasse sobre Corpos Finitos, o
que conﬂuiu para a escolha dos códigos BCH binários, que foram descobertos por R.C.
Bose e D.K. Chaudhuri (1960) e independentemente por A. Hocquenghem (1959). Tais
códigos pertencem à classe dos cíclicos, os quais admitem uma representação em termos
de polinômios sobre extensões de Z2.

Este trabalho está dividido em três capítulos. No primeiro, ﬁzemos uma revisão
de deﬁnições e propriedades dos corpos em geral e o Anel dos Inteiros módulo m, com
ênfase para a condição de ser um corpo. Também mostramos os principais resultados
que envolvem polinômios sobre corpos. No segundo capítulo, apresentamos algumas das
principais propriedades e resultados de Corpos Finitos, com destaque para os que envolvem
extensões do corpo Z2. Já no terceiro capítulo, tratamos de Códigos Corretores de Erros.
Além de introduzirmos o assunto, a ênfase foi dada aos códigos BCH binários, mas antes

13

apresentamos os códigos lineares e os cíclicos binários, que formam, respectivamente, a
classe e subclasse as quais os BCH binários pertencem.

O leitor poderá observar que os polinômios, embora tratados no capítulo 1, tran-
sitam nos demais. Advertimos que muitos resultados apresentados no último capítulo
foram focados apenas sobre corpos ﬁnitos com 2m elementos e algumas demonstrações
foram omitidas, por fugirem ao escopo deste trabalho, mas podem ser encontradas nas
seguintes referências bibliográﬁcas (LIN; DANIEL, 1983) e (HEFEZ; VILLELA, 2017).
Optamos por essa forma de proceder para tratarmos dos códigos BCH binários de uma
maneira mais prática e por meio de exemplos que valorizassem a utilização de polinômios.

1 FUNDAMENTOS MATEMÁTICOS

14

Neste capítulo apresentaremos, de forma breve, alguns conceitos e resultados que
dão embasamento teórico a este trabalho, tais como a deﬁnição de corpo e suas proprieda-
des, o Anel dos inteiros módulo m e polinômios sobre corpos ﬁnitos. A ênfase será dada ao
estudo dos polinômios, porque o código corretor de erros BCH trabalha com polinômios
sobre corpos ﬁnitos.

1.1 Conceitos Básicos

Deﬁnição 1.1.1. Seja A um conjunto, com A 6= ∅. Um anel é a terna (A, +, ·) que possui
duas operações em A; chamadas de adição e multiplicação, denotadas respectivamente
da seguinte forma:

+ : A × A

−→

A

e

· : A × A

−→

A

(a, b)

7−→

a + b

(a, b)

7−→

a · b

e que possuem as seguintes propriedades:

A1) Associatividade da adição:

∀a, b, c ∈ A,

(a + b) + c = a + (b + c) = a + b + c.

A2) Existência do elemento neutro para a adição:
Existe um elemento neutro, denotado por 0, denominado elemento neutro do anel, tal
que

∀a ∈ A,

a + 0 = 0 + a = a.

A3) Todos os elementos de A são simetrizáveis em relação à adição:
∀a ∈ A, existe um elemento chamado simétrico de a, denotado por −a, tal que

a + (−a) = (−a) + a = 0

A4) Comutatividade da adição:

∀a, b ∈ A,

a + b = b + a.

M1) Associatividade da multiplicação:

∀a, b, c ∈ A,

(a · b) · c = a · (b · c) = a · b · c.

15

AM) Distributividade da multiplicação com relação à adição:

∀a, b, c ∈ A,

a · (b + c) = a · b + a · c

e

(a + b) · c = a · c + b · c.

Os elementos a+b e a·b (ou ab) são chamados respectivamente de soma e produto

de a e b. Nesse texto, muitas vezes iremos nos referir ao anel (A, +, ·) apenas por A.

Observação 1.1.2. Sabemos que todo elemento a de um anel tem inverso para a adição
(−a) e ele é único. Podemos assim, deﬁnir uma operação chamada de subtração como:

a − b = a + (−b), ∀a, b ∈ A

Os conjuntos dos números inteiros Z, dos números racionais Q, dos números re-
ais R e dos números complexos C, juntamente com as suas operações de adição e de
multiplicação, são exemplos de anéis.

Um anel A é um Anel com Unidade se for veriﬁcada a seguinte propriedade.

M2) Existência do elemento neutro para a multiplicação:
Existe um elemento chamado unidade e denotado por 1 tal que

∀a ∈ A,

a · 1 = 1 · a = a.

Um anel A é um Anel Comutativo se for veriﬁcada a seguinte propriedade.

M3) Comutatividade da multiplicação:

∀a, b ∈ A,

a · b = b · a.

Um anel A é um Anel sem Divisores de Zero se for veriﬁcada a seguinte

propriedade.
M4) ∀a, b ∈ A, a 6= 0 e
b 6= 0 =⇒ a · b 6= 0.
A propriedade acima é equivalente à seguinte:

∀a, b ∈ A, a · b = 0 =⇒ a = 0 ou b = 0.

Um anel A é um Domínio de Integridade se forem veriﬁcadas as propriedades

M2, M3 e M4.

Deﬁnição 1.1.3. Seja A um anel comutativo com unidade. Um elemento a 6= 0 de A
será dito invertível, se tiver inverso multiplicativo a−1, isto é, a · a−1 = 1. Além disso
(a · b)−1 = b−1 · a−1 = a−1 · b−1.

Se a é invertível, então a−1 é invertível e (a−1)−1 = a.

Deﬁnição 1.1.4. Um domínio de integridade em que todo elemento diferente do elemento
neutro aditivo do domínio é invertível, é chamado de corpo.

16

Os anéis Q, R e C são corpos porque, nesses conjuntos, todo elemento diferente
de 0 é invertível. Por outro lado, o anel Z não é um corpo, pois seus únicos elementos
invertíveis são −1 e 1.

Um corpo é ﬁnito se o conjunto de seus elementos é ﬁnito. No capítulo 2 voltaremos

a falar sobre esses corpos.

A seguir apenas enunciaremos algumas propriedades básicas que envolvem anéis,

domínios de integridade e corpos.

Sejam A um anel e a, b, c ∈ A, então:

1) 0 · a = a · 0 = 0
2) − (a · b) = (−a) · b = a · (−b)
3) (−a) · (−b) = a · b
4) a · (b − c) = a · b − a · c
5) (b − c) · a = b · a − c · a
6) (−1) · a = −a
7) (−1) · (−1) = 1
8) (−1) · (−a) = a

Além das propriedades acima, se o anel A for um domínio de integridade e se a 6= 0,

a · b = a · c então b = c. (Lei do Cancelamento da Multiplicação).

1.2 Anel dos Inteiros Módulo m

Deﬁnição 1.2.1. Sejam o anel Z e m ∈ Z, com m > 1. Dois elementos a, b ∈ Z são
congruentes módulo m se m divide b − a. Neste caso, denotaremos por a ≡ b (mod
m).

É imediato da deﬁnição que para quaisquer a, b, c, a0, b0 ∈ Z:

i) a ≡ a (mod m);
ii) Se a ≡ b (mod m) então b ≡ a (mod m);
iii) Se a ≡ b (mod m) e b ≡ c (mod m) então a ≡ c (mod m);
iv) Se a ≡ a0 (mod m) e b ≡ b0 (mod m) então a + b ≡ a0 + b0 (mod m) e a · b ≡ a0 · b0
(mod m).

As três primeiras propriedades acima indicam que a congruência módulo m é uma
relação de equivalência. A propriedade (iv) é compatível com as operações aditiva e
multiplicativa de Z.

Deﬁnição 1.2.2. Sejam o anel Z e m ∈ Z, m > 1. A classe residual de um elemento
a ∈ Z módulo m é o conjunto

a = {a + km, k ∈ Z}.

17

O elemento a é denominado um representante da classe residual a.
O conjunto formado por todas as classes residuais em Z módulo m é denotado por

Zm. Observamos que

Zm = {0, 1, . . . , m − 1}

e que se i, j = 0, . . . , m − 1 com i 6= j, então i 6= j.

De fato, dado a ∈ Z, pelo algoritmo da divisão euclidiana, temos que existem
inteiros q e r univocamente determinados tais que: a = mq + r e 0 ≤ r ≤ m − 1.
Portanto, há um único inteiro r com 0 ≤ r ≤ m − 1, tal que a = r.

Logo, Zm é um anel ﬁnito com exatamente m elementos.
Como a congruência módulo m em Z é uma relação de equivalência, então Zm é
uma partição de Z. Além disso, podemos deﬁnir as operações de adição e multiplicação
em Zm.

Deﬁnição 1.2.3. Sejam a, b quaisquer classes residuais módulo m. A adição e a multi-
plicação em Zm são deﬁnidas por:

a + b = a + b

e

a · b = a · b.

Podemos observar que as deﬁnições acima não dependem dos representantes das
classes residuais. De fato, sabemos que se a ≡ a0 (mod m) e b ≡ b0 (mod m) então
a + b ≡ a0 + b0 (mod m) e a · b ≡ a0 · b0 (mod m) e, portanto, a + b = a0 + b0, o que acarreta
que a + b = a0 + b0.

É imediato que Zm munido das operações de adição e multiplicação deﬁnidas acima
formam um anel comutativo com unidade com 0 e 1. Sendo estes os elementos neutros
da adição e da multiplicação respectivamente.

Exemplo 1.2.4. Seja m = 2. Logo, Z2 = {0, 1} com as operações da tabela 1 é um anel.

Tabela 1 - Operações em Z2

1
1
0

Adição em Z2
+
0
0
0
1
1
Multiplicação em Z2
0
0
0
Fonte: (HEFEZ; VILLELA,

·
0
1

1
0
1

2017)

18

Veremos que nem todo Zm é um corpo. Então, com o objetivo de determinar quais

são corpos, precisaremos inicialmente caracterizar os elementos invertíveis desses anéis.

Proposição 1.2.5. a ∈ Z é invertível se, e somente se, MDC(a, m) = 1.

Demonstração: Suponhamos que a seja invertível. Consequentemente, existe b ∈ Z tal
que a · b = 1. Logo, a · b = 1 e, portanto, a · b ≡ 1 (mod m). Isso implica que existe um
inteiro s tal que a · b + s · m = 1, logo MDC(a, m) = 1.

Reciprocamente, suponhamos que MDC(a, m) = 1. Então, pelo teorema de Bé-
zout, existem inteiros b e c tais que b · a + c · m = 1. Logo, b · a ≡ 1 (mod m). Consequen-
temente, a · b = a · b = 1 e, portanto, a é invertível.

Teorema 1.2.6. O anel Zm é um corpo se, e somente se, m é um número primo.

Demonstração: Zm é um corpo se, e somente se, todos os elementos 1, 2, . . . , m − 1
são invertíveis, o que, pela Proposição 1.2.5, equivale ao fato de que MDC(1, m) =
MDC(2, m) = . . . = MDC(m−1, m) = 1; e isso é, portanto, equivalente a m ser primo.

Temos assim garantida a existência de um corpo com m elementos para todo

número primo positivo m.

O anel Z2 do Exemplo 1.2.4 é um corpo.

1.3 Polinômios sobre um Corpo

O código corretor de erros BCH trabalha com polinômios sobre corpos ﬁnitos. Por

esse motivo, faremos uma breve apresentação de polinômios sobre corpos.

Deﬁnição 1.3.1. Sejam K um corpo e x uma indeterminada ou variável. Um po-
linômio p(x) com coeﬁcientes em K, na indeterminada x, é uma expressão do tipo

p(x) =

n
X

i=0

aixi = a0 + a1x + · · · + anxn,

onde n ∈ Z+ e ai ∈ K, ∀i = 0, 1, . . . , n.. Omitiremos, na expressão do polinômio, o termo
aixi, toda vez que ai = 0.

Na deﬁnição acima usamos a notação formal de polinômios sobre um corpo, mas
um polinômio p(x) = a0 + a1x + · · · + anxn está associado à uma n-upla (a0, a1, . . . , an),
em que ai 6= 0 para um número de índices. Ao longo deste trabalho, poderemos usar
indistintamente as duas notações, dependendo do contexto.

Dados dois polinômios p(x) = a0 +a1x1 +· · ·+anxn e q(x) = b0 +b1x1 +· · ·+bmxm,

dizemos que p(x) = q(x) se ai = bi, para todo i.

19

O conjunto de todos os polinômios na indeterminada x com coeﬁcientes em K será

denotado por K[x]. Observamos que K ⊂ K[x].

Se p(x) = 0 + 0x + 0x2 + . . . + 0xn então dizemos que p(x) é o polinômio iden-
ticamente nulo e será denotado por p(x) = 0. Se p(x) = a0, com a0 ∈ K, então p(x) é
o polinômio constante a0.

Deﬁnição 1.3.2. Seja p(x) = a0 + a1x1 + · · · + anxn ∈ K[x] um polinômio não nulo,
an 6= 0. O grau de p(x), que será denotado por gr(p(x)), é o inteiro não negativo n. E,
nesse caso, an é chamado coeﬁciente líder de p(x).

Se p(x) é o polinômio nulo, gr(p(x)) não está deﬁnido. Além disso, notemos que

gr(p(x)) = 0 se, e somente se, p(x) é um polinômio constante não nulo.

Deﬁnição 1.3.3. Se gr(p(x)) = n, dizemos que p(x) ∈ K[x] é um polinômio mônico
se an = 1.

Sejam os polinômios p(x) = a0 + a1x1 + · · · + anxn e q(x) = b0 + b1x1 + · · · + bmxm
pertencentes a K[x], deﬁnimos as operações de adição e de multiplicação em K[x],
como a seguir:

p(x) + q(x) =

máx{n,m}
X

(ai + bi)xi,

i=0

p(x) · q(x) =

n+m
X

i=0

cixi, onde ci =

i
X

j=0

aj · bi−j

As operações de adição e multiplicação deﬁnidas acima, em K[x], possuem propri-
edades semelhantes às das respectivas operações em K. Isso será mostrado no teorema a
seguir.

Teorema 1.3.4. Com as operações de adição e de multiplicação deﬁnidas acima, K[x] é
um anel.

A demonstração deste teorema pode ser encontrada em (BIAZZI, 2014, pp. 19–23).
De acordo com as deﬁnições das operações em K[x], dados os polinômios p(x), q(x) ∈
K[x], com gr(p(x)) = n e gr(q(x) = m, temos que gr(p(x)+q(x)) = máx(gr(p(x)), gr(q(x)))
e que gr(p(x) · q(x)) = n + m.

Deﬁnição 1.3.5. Sejam K um corpo e os polinômios f (x) 6= 0, g(x) ∈ K[x]. Dizemos
que f (x) divide g(x) ou g(x) é divisível por f (x), se existe h(x) ∈ K[x] tal que

g(x) = f (x) · h(x).

Se f (x) divide g(x) denotaremos por f (x) | g(x).

20

Teorema 1.3.6 (Algoritmo da Divisão). Sejam f (x), g(x) ∈ K[x], com g(x) 6= 0. Existem
únicos q(x), r(x) ∈ K[x] tais que:

f (x) = q(x) · g(x) + r(x),

onde r(x) = 0 ou gr(r(x)) < gr(g(x)).

Demonstração. Sejam os polinômios f (x) = a0 + a1x + . . . + anxn e g(x) = b0 + b1x +
. . . + bmxm, com gr(g(x)) = m.
Existência: Se f (x) = 0 então q(x) = r(x) = 0. Suponhamos f (x) 6= 0 e gr(f (x)) = n.
Se n < m então q(x) = 0 e r(x) = f (x). Agora, assumiremos que n ≥ m.

Demonstraremos o teorema por indução sobre gr(f (x)) = n. Se n = 0, então
teremos m = 0 pois supomos n ≥ m. Nesse caso, f (x) = a0 6= 0, g(x) = b0 6= 0. Logo,
obtemos q(x) = a0b−1
0

e r(x) = 0.

Assumiremos a validade do resultado para polinômios g(x) de grau menor do que

n = gr(f (x)).

Seja o polinômio f1(x) = f (x) − anb−1

m xn−m · g(x), onde gr(f1(x)) < gr(f (x)).

Logo, pela hipótese de indução, existem únicos q1(x), r1(x) ∈ K[x], tais que:

f1(x) = q1(x) · g(x) + r1(x),

onde r1(x) = 0 ou gr(r1(x)) < gr(g(x)). Então, temos que

f (x) = q1(x)g(x) + r1(x) + anb−1

n xn−mg(x)

e, consequentemente

f (x) = (q1(x) + anb−1

m xn−m)g(x) + r1(x).

m xn−m e r1(x) = r(x), provamos a existência
Portanto, tomando q(x) = q1(x) + anb−1
dos polinômios q(x), r(x) ∈ K[x] tais que f (x) = q(x) · g(x) + r(x), onde r(x) = 0 ou
gr(r(x)) < gr(g(x)).

Unicidade: Sejam os polinômios q1(x), q2(x), r1(x), r2(x) ∈ K[x], tais que:

f (x) = q1(x) · g(x) + r1(x) = q2(x) · g(x) + r2(x),

onde r1(x) = 0 ou gr(r1(x)) < gr(g(x)) e r2(x) = 0 ou gr(r2(x)) < gr(g(x)). Então,
temos que

(q1(x) − q2(x)) · g(x) = r2(x) − r1(x).

Se q1(x) = q2(x), então r1(x) = r2(x) e a unicidade está provada. Por outro lado,

21

se q1(x) 6= q2(x), temos que gr(r2(x) − r1(x)) ≥ gr(g(x)), o que é uma contradição,
pois devemos ter gr(r2(x) − r1(x)) < gr(g(x)) por hipótese. Logo, q1(x) = q2(x) e,
consequentemente, temos r1(x) = f (x) − q1(x)g(x) = f (x) − q2(x)g(x) = r2(x).

Exemplo 1.3.7. Vamos efetuar a divisão de f (x) = x4 + x3 + x + 1 por g(x) = x + 1,
onde f (x), g(x) ∈ Z2[x].

x4 + x3

x4 + x3

+ x + 1

x + 1

x3 + 1

x + 1

x + 1

0

Temos que: x4 + x3 + x + 1 = (x + 1) · (x3 + 1), onde q(x) = x3 + 1 e r(x) = 0.
Portanto, g(x) = x + 1 divide f (x) = x4 + x3 + x + 1.

Deﬁnição 1.3.8. Sejam K um corpo e p(x) ∈ K[x] um polinômio. Dizemos que x0 ∈ K
é uma raiz do polinômio p(x) se p(x0) = 0.

Proposição 1.3.9. Sejam K um corpo, p(x) ∈ K[x] um polinômio e x0 ∈ K. Temos que
x0 é uma raiz de p(x) se, e somente se, x − x0 divide p(x).

Demonstração: Sejam K um corpo, os polinômios f (x), g(x) ∈ K[x], x0 uma raiz
de f (x) e g(x) = x − x0. Pelo algoritmo da divisão, existem dois únicos polinômios
q(x), r(x) ∈ K[x], tais que

f (x) = g(x) · q(x) + r(x), com r(x) = 0 ou gr(r(x)) = 0.

Se r(x) = 0 temos que f (x) = g(x) · q(x) e, portanto, g(x) = x − x0 divide f (x). Por
outro lado, se gr(r(x)) = 0 então r(x) = r0 constante não nula. Logo, x0 é raiz de f (x)
se, e somente se,

0 = f (x0) = (x0 − x0) · q(x) + r0 = r0,

ou seja, se, e somente se, r0 = 0. Portanto, temos que

f (x) = g(x) · q(x),

que signiﬁca g(x) = x − x0 dividir f (x).

O Exemplo 1.3.7 mostra esse fato, onde f (1) = 14 + 13 + 1 + 1 = 0 em Z2, e

x − 1 = x + 1 = g(x) divide f (x).

Deﬁnição 1.3.10. Sejam K um corpo e p(x) ∈ K[x] tal que gr(p(x)) ≥ 1. Dizemos que
p(x) é um polinômio irredutível sobre K se p(x) = s(x) · t(x), tal que s(x), t(x) ∈ K[x],
então s(x) = c1 ∈ K\{0} ou t(x) = c2 ∈ K\{0}.

22

Como consequência da deﬁnição acima, dado f (x) ∈ K[x], se f (x) divide o po-
linômio irredutível p(x) ∈ K[x], então ou f (x) ∈ K\{0} ou existe c ∈ K\{0} tal que
f (x) = c · p(x).

Deﬁnição 1.3.11. Seja K um corpo. Dados f (x), g(x) ∈ K[x], um polinômio d(x) ∈ K[x]
é o máximo divisor comum de f (x) e g(x) se:

i) d(x) | f (x) e d(x) | g(x)
ii) ∀d1(x) ∈ K[x], se d1(x) | f (x) e d1(x) | g(x) então d1(x) | d(x).

O máximo divisor comum de f (x) e g(x) é denotado por MDC(f (x), g(x)).

Deﬁnição 1.3.12. Seja K um corpo. Dados os polinômios não nulos f (x), g(x) ∈ K[x],
um polinômio m(x) ∈ K[x] é o mínimo múltiplo comum de f (x) e g(x) se:

i) m(x) é mônico
ii) f (x) | m(x) e g(x) | m(x)
iii) ∀m1(x) ∈ K[x], se f (x) | m1(x) e g(x) | m1(x) então m(x) | m1(x).
O mínimo múltiplo comum de f (x) e g(x) é denotado por MMC(f (x), g(x)).

Teorema 1.3.13. Um polinômio de grau n com coeﬁcientes num corpo possui, no má-
ximo, n raízes distintas.

Demonstração: Sejam o corpo K, o polinômio p(x) ∈ K[x] e α1, . . . , αm ∈ K raízes
distintas de p(x). Seja g1(x) ∈ K[x]. Pela Proposição 1.3.9,

f (x) = (x − α1) · g1(x).

Como α2 também é raiz de f (x). Então f (α2) = 0, logo f (α2) = (α − α1) · g1(α2). Como
α1 6= α2, g1(α2) = 0, portanto α2 é raiz de g1(x). Então, existe g2(x) ∈ K[x] tal que

g1(x) = (x − α2) · g2(x).

Logo,

f (x) = (x − α1) · (x − α2) · g2(x).

Podemos repetir esse raciocínio até que tenhamos:

f (x) = (x − α1) · (x − α2) · . . . · (x − αm) · gm(x)

então gr(f (x)) = n = m + gr(gm(x)). Portanto, m ≤ n.

Voltaremos a deﬁnições e resultados envolvendo polinômios nos demais capítulos

deste trabalho sempre que for necessário.

23

2 CORPOS FINITOS

2.1 Conceitos Básicos

Deﬁnição 2.1.1. Seja K um corpo ﬁnito com elemento unidade 1. Deﬁnimos a carac-
terística de K, como o menor inteiro positivo λ, tal que

λ
X

i=1

1 = 0.

Exemplo 2.1.2. A característica do corpo Z2 é 2, pois P2

i=1 1 = 1 + 1 = 0.

Teorema 2.1.3. Sejam K um corpo ﬁnito e λ a característica de K, então λ é um número
primo.

Demonstração: Suponhamos que λ não seja primo. Então existem λ1, λ2 ∈ Z tais que
1 < λ1 < λ e 1 < λ2 < λ, onde λ = λ1 · λ2. Logo, temos que:

0 = λ · 1 = (λ1 · λ2) · 1 = λ1 · (λ2 · 1) = (λ1 · 1) · (λ2 · 1).

Como K é também um domínio de integridade, temos então que λ1 · 1 = 0 ou λ2 · 1 = 0,
o que é uma contradição, pois λ é o menor inteiro positivo tal que λ · 1 = 0. Portanto, λ
é primo.

Teorema 2.1.4. Sejam K um corpo ﬁnito com q elementos e α ∈ K, onde α 6= 0. Então,
αq−1 = 1.

Demonstração: Sejam K um corpo ﬁnito com q elementos, β1, . . . , βq−1 os q − 1 ele-
mentos não nulos de K e α um elemento não nulo de K. Como a multiplicação é fechada
em K, os q − 1 elementos α · β1, . . . , α · βq−1 são não nulos e distintos entre si, dois a dois.
Então, temos que

(α · β1) · . . . · (α · βq−1) = β1 · . . . · βq−1

αq−1 · (β1 · . . . · βq−1) = β1 · . . . · βq−1

Mas como, por hipótese, temos α 6= 0 e β1 · . . . · βq−1 6= 0, devemos ter αq−1 = 1.

Como consequência do Teorema 2.1.4, temos que αq = α, α 6= 0 ∈ K.

Deﬁnição 2.1.5. Sejam K ∗ = K\{0} um corpo ﬁnito e α ∈ K ∗. A ordem de α é o
menor inteiro positivo n tal que αn = 1.

Teorema 2.1.6. Sejam K um corpo ﬁnito com q elementos e α ∈ K, onde α 6= 0. Seja
n a ordem de α. Então, n divide q − 1.

24

Demonstração: Suponhamos que n não divida q−1. Ao dividirmos q−1 por n, obtemos
q − 1 = ns + r, onde n > r > 0. Então, temos que

αq−1 = αns+r = αns · αr = (αn)s · αr.

Mas como αq−1 = 1 e αn = 1, pois n é a ordem de α, então devemos ter αr = 1. Mas isto
é um absurdo porque n > r > 0 e n é o menor inteiro tal que αn = 1. portanto, n divide
q − 1.

Deﬁnição 2.1.7. Seja K um corpo ﬁnito com q elementos. Chamamos de elemento
primitivo a um elemento não nulo α ∈ K cuja ordem é q − 1

Uma consequência direta da deﬁnição acima é que as potências de um elemento

primitivo de um corpo ﬁnito geram todos os elementos não nulos desse corpo ﬁnito.

Teorema 2.1.8. Todo corpo ﬁnito possui elementos primitivos.

A demonstração desse teorema pode ser consultada em (HEFEZ; VILLELA, 2017,

p. 78).

O exemplo a seguir ilustra o que foi dito nos teoremas e deﬁnições acima sobre

elemento primitivo e ordem de um elemento de um corpo ﬁnito.

Exemplo 2.1.9. Considere o corpo ﬁnito Z5, cujas operações de adição e multiplicação
estão ilustradas na tabela 2 a seguir.

Tabela 2 - Operações em Z5

2
2
3
4
0
1

1
1
2
3
4
0

Adição em Z5
3
3
4
0
1
2

4
+ 0
4
0
0
0
1
1
1
2
2
2
3
3
3
4
4
Multiplicação em Z5
4
·
0
0
4
1
3
2
4
3
1
4

3
0
3
1
3
2
Fonte: O autor, 2019

1
0
1
2
1
4

2
0
2
4
2
3

0
0
0
0
0
0

25

O corpo ﬁnito Z5 tem característica λ = 5 e possui q = 5 elementos. Se usarmos a
tabela da multiplicação para calcularmos as potências do elemento 2, obteremos: 21 = 2,
22 = 4, 23 = 3 e 24 = 1. Observamos então que o elemento 2 é primitivo, pois 25−1 =
24 = 1. Isto é, a ordem do elemento 2 é q − 1 = 5 − 1 = 4. Portanto, as potências do
elemento 2 geram todos os elementos não nulos do corpo ﬁnito Z5.

Por outro lado, o elemento 4 não é um elemento primitivo em Z5. Isto pode ser
veriﬁcado analisando as potências desse elemento, que são as seguintes: 41 = 4, 42 = 1,
43 = 4 e 44 = 1. A ordem do elemento 4 é 2 6= 4 = 5−1 = q−1 e 2 divide 4 = 5−1 = q−1.
Logo, as potências do elemento 4 não geram todos os elementos do corpo ﬁnito Z5.

Nas duas próximas seções apresentaremos um método para construir extensões do
corpo Z2 e, em seguida, daremos algumas propriedades de corpos ﬁnitos que sejam relevan-
tes para o embasamento do código corretor de erros BCH binários. Alertamos que muitos
dos resultados serão apenas mencionados no texto, sem que haja um aprofundamento por
exceder à ﬁnalidade deste trabalho.

2.2 Extensão de um Corpo Finito

Deﬁnição 2.2.1. Sejam F e K dois corpos ﬁnitos. F é uma extensão de K se K ⊂ F ,
F 6= K.

Observação 2.2.2. Não é difícil veriﬁcar que se F é uma extensão de K, então F é um
espaço vetorial sobre K. Para isso, basta termos as seguintes operações:

+ : F × F

−→

F

e

K × F

−→

F

(u, v)

7−→

u + v

(λ, u)

7−→

λ · u

Deﬁnição 2.2.3. O grau de extensão do corpo F é sua dimensão como espaço vetorial
sobre K, que será denotada por [F : K].

Como F e K são ﬁnitos, então [F : K] é um número inteiro positivo.

Proposição 2.2.4. Sejam F e K corpos ﬁnitos, K com q elementos. Se F é extensão de
K então F possui qm elementos, onde m = [F : K].

Demonstração: Como F pode ser visto como um espaço vetorial sobre K, logo a di-
mensão deste espaço vetorial é ﬁnita e igual a m, sendo m = [F : K].
Temos que F possui uma base b = (b1, b2, . . . , bm) e qualquer elemento y ∈ F ; y pode ser
escrito de forma única como y = λ1b1+λ2b2+· · ·+λmbm, sendo λ1, λ2, . . . , λm pertencentes
a K. Como K tem q elementos então F possui exatamente qm elementos.

Exemplo 2.2.5. Se K = Zp então qualquer extensão ﬁnita F de K terá pm elementos,
sendo m = [F : K] a dimensão do espaço vetorial F .

Exemplo 2.2.6. Seja K = Z2 e m = 3 então a dimensão de F , como espaço vetorial, é 3.
E F tem 23 elementos que são: (0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,1,1),(1,1,0),(1,0,1),(1,1,1).

26

2.3 Construção de Extensões de Corpos Finitos com 2m elementos

O código corretor de erros que mostraremos neste texto trabalha com polinômios
sobre extensões F de Z2, ou seja, sobre corpos com 2m elementos, sendo m a dimensão de
F . Portanto, nesta seção apresentaremos um método para a construção de corpos ﬁnitos
de 2m elementos, com m > 1. E usaremos como base a referência bibliográﬁca (LIN;
DANIEL, 1983).

Teorema 2.3.1. Seja p(x) um polinômio irredutível em Z2 com gr(p(x)) = m, então
p(x) | (x2m−1 + 1).

Demonstração: A demonstração deste teorema encontra-se em (BERLEKAMP, 2015,
p. 103).

Deﬁnição 2.3.2. Seja p(x) um polinômio irredutível em Z2, com gr(p(x)) = m. Dizemos
que p(x) é um polinômio primitivo se p(x) não divide nenhum polinômio da forma
xt + 1 para 1 ≤ t < 2m − 1.

Exemplo 2.3.3. Seja o corpo K = Z2. Sejam os polinômios f (x), g(x) ∈ Z2. O polinô-
mio g(x) = x3 + x + 1 é um polinômio primitivo sobre Z2, pois ele divide f (x) = x7 + 1
com n = 23 − 1 = 7, mas não divide nenhum dos seguintes polinômios h(x) = x6 + 1,
u(x) = x5 + 1, v(x) = x4 + 1 e w(x) = x3 + 1, onde h(x), u(x), v(x), w(x) ∈ Z2.
Obviamente que g(x) não divide w(x). Porém, os resultados das outras divisões podem
ser veriﬁcadas nas ﬁguras 1 e 2 a seguir.

Figura 1 - Divisões de v(x) = x4 + 1 e u(x) = x5 + 1 por g(x) = x3 + x + 1

Fonte: O autor, 2019

Figura 2 - Divisões de h(x) = x6 + 1 e f (x) = x7 + 1 por g(x) = x3 + x + 1

27

Fonte: O autor, 2019

Em geral, não é fácil identiﬁcar um polinômio primitivo. Além disso, dado um
valor de m, podem existir mais de um polinômio primitivo de grau m. Na tabela 3 a
seguir estão listados alguns polinômios primitivos sobre Z2, sendo um para cada valor de
m, onde 3 ≤ m ≤ 10, com o menor número possível de termos.

Tabela 3 - Polinômios primitivos de grau m (3 ≤ m ≤ 10)

m polinômio primitivo m polinômio primitivo
3
4
5
6

x7 + x3 + 1
x8 + x4 + x3 + x2 + 1
x9 + x4 + 1
x10 + x3 + 1

x3 + x + 1
x4 + x + 1
x5 + x2 + 1
x6 + x + 1

7
8
9
10

Fonte: (LIN; DANIEL, 1983)

Consideremos os elementos 0, 1 ∈ Z2 e um novo símbolo α. Construiremos um
conjunto formado por 0,1 e potências de α e, para isso, deﬁnimos a multiplicação ” · ” da
seguinte forma:

0 · 0 = 0,

0 · 1 = 1 · 0 = 0,

1 · 1 = 1,

0 · α = α · 0 = 0,

1 · α = α · 1 = α,

(1)

i vezes
}|

z
α · . . . · α, com i ≥ 2.

{

αi =

Como consequência da deﬁnição de multiplicação dada acima, temos que

0 · αi = αi · 0 = 0,

1 · αi = αi · 1 = αi,

αi · αj = αj · αi = αi+j.

28

(2)

Dessa forma, temos o conjunto E = {0, 1, α, α2, . . . , αi, . . .} no qual a operação de multi-
plicação está deﬁnida. Notemos que o elemento 1 será denotado por α0.

Necessitamos impor uma condição ao elemento α para que o conjunto E tenha
apenas 2m elementos e seja fechado em relação à operação de multiplicação deﬁnida em (1).
Seja p(x) um polinômio primitivo de grau m sobre Z2. Logo, p(x) é irredutível em

Z2 e divide x2m−1 + 1. Então , temos que

x2m−1 + 1 = p(x) · q(x), com q(x) ∈ Z2.

(3)

Assumimos que α é raiz de p(x) em E, ou seja, p(α) = 0. Substituindo x por α em (3)
obtemos

Mas como p(α) = 0, temos

α2m−1 + 1 = p(α) · q(α)

α2m−1 + 1 = 0 · q(α)

O que resulta na seguinte igualdade, pelas operações deﬁnidas em (1)

α2m−1 + 1 = 0.

Adicionando 1 a ambos os lados dessa igualdade, usando a adição em Z2, obtemos

α2m−1 = 1.

(4)

Portanto, sob a condição de que α é raiz de p(x), obtemos a igualdade (4) que juntamente
com as operações em (1), torna E ﬁnito contendo os seguintes elementos

E∗ = {0, 1, α, α2, . . . , α2m−2}.

Observemos que o conjunto E∗ tem 2m elementos, é fechado em relação a operação de mul-
tiplicação deﬁnida em (1) e ainda pode-se provar que E∗\{0} forma um grupo comutativo
com a operação ” · ”.

A seguir, deﬁniremos a operação de adição ” + ” em E∗.
Para 0 ≤ i < 2m − 1, dividimos o polinômio xi por p(x) e obtemos

xi = qi(x)p(x) + ai(x)

(5)

sendo qi(x) e ai(x) polinômios sobre Z2 e gr(ai(x)) ≤ m − 1. Assim,

ai(x) = ai,0 + ai,1x + ai,2x2 + . . . + ai,m−1xm−1.

29

(6)

Como x e p(x) não têm nenhum fator em comum diferente de 1, então x não é divisível
por p(x), logo

ai(x) 6= 0

(7)

para todo i ≥ 0.

Além disso, mostraremos que ai(x) 6= aj(x) para todo 0 ≤ i, j < 2m − 1.
Suponhamos que ai(x) = aj(x) para algum i e j, i 6= j. Vamos considerar i < j.

Temos que

xi + xj = [qi(x) + qj(x)]p(x) + ai(x) + aj(x) = [qi(x) + qj(x)]p(x),

logo p(x) | (xi + xj) e, portanto, p(x) | xi(1 + xj−i). Como xi e p(x) não têm fator em
comum diferente de 1, então p(x) | (1 + xj−i). O que é um absurdo, pois p(x) é um
polinômio primitivo de grau m, logo p(x) não divide (1 + xj−i), então

ai(x) 6= aj(x)

(8)

Podemos observar que, desta forma, existirão 2m−1 polinômios não nulos a0(x), a1(x), . . . ,
a2m−2(x), todos distintos tais que gr(ai(x)) ≤ m − 1.

Se substituirmos x por α em (5)

αi = qi(α)p(α) + ai(α).

αi = ai(α)

Como α é raiz de p(x) então

De (6) e (9), temos que

αi = ai,0 + ai,1α + ai,2α2 + . . . + ai,m−1αm−1.

(9)

(10)

Além disso, de (7), (8) e (10), vemos que os elementos não nulos α0, α1, α2, . . . , α2m−2 de
E∗ podem ser representados por 2m − 1 polinômios não nulos de α sobre Z2, com graus
menores ou iguais do que m − 1.

O elemento 0 ∈ E∗ será representado pelo polinômio identicamente nulo. Dessa
forma, os 2m elementos de E∗, que são distintos entre si, serão representados por 2m

30

polinômios distintos de α sobre Z2, com grau menor ou igual a m − 1.
Deﬁnimos a operação de adição ” + ” em E∗ da seguinte forma:

0 + 0 = 0,

0 + αi = αi + 0 = αi,
αi + αj = (ai,0 + ai,1α + · · · + ai,m−1αm−1) + (aj,0 + aj,1α + · · · + aj,m−1αm−1)
= (ai,0 + aj,0) + (ai,1 + aj,1)α + · · · + (ai,m−1 + aj,m−1)αm−1.

(11)

sendo 0(zero) o polinômio nulo em Z2 e para 0 ≤ i, j < 2m − 1, cada coeﬁciente dado por
ai,k + aj,k pertence a Z2 (0 ≤ k ≤ m − 1).
Como consequência da deﬁnição dada acima, observamos que:

αi + αj =






i = j,

0 se
(ai,0 + aj,0) + (ai,1 + aj,1)α + · · · + (ai,m−1 + aj,m−1)αm−1

se

i 6= j.

A expressão polinomial (ai,0 + aj,0) + (ai,1 + aj,1)α + · · · + (ai,m−1 + aj,m−1)αm−1
é não nula e é a representação de algum αk ∈ E∗. Portanto, conforme (LIN; DANIEL,
1983) o conjunto E∗ é fechado em relação à operação de adição ” + ” deﬁnida em (11) e
forma um grupo comutativo.

Não é difícil mostrar que a multiplicação em E∗ é distributiva. Basta usarmos
a notação polinomial para os elementos de E∗. Como a multiplicação em E∗\{0} é
um grupo comutativo, então o conjunto E∗ = {0, 1, α, α2, . . . , α2m−2} é um corpo ﬁnito
de 2m elementos, que será denotado por F2m. Notemos que as operações de adição e
multiplicação deﬁnidas em E∗ = F2m são as operações de adição e multiplicação em Z2.
Portanto, Z2 é um subcorpo de F2m, cuja característica é 2.

Durante o processo de construção deste corpo a partir de Z2, foram desenvolvidas
duas representações para os elementos não nulos de F2m, que são as seguintes: a represen-
tação por meio de potências e a representação polinomial. Nas operações de multiplicação
é conveniente utilizarmos a primeira representação. Enquanto que, nas operações de adi-
ção, é oportuno trabalharmos com a segunda representação. Vejamos o exemplo abaixo.

Exemplo 2.3.4. Vamos construir o corpo ﬁnito F23, por exemplo. Sejam m = 3 e
p(x) = 1 + x + x3 ∈ Z2[x] um polinômio primitivo. Seja α uma raiz de p(x). Então,
p(α) = 1 + α + α3 = 0. Logo, α3 = α + 1. Usando esta igualdade, podemos construir os
elementos de F23 cujos expoentes são maiores que 3. Vejamos:

α4 = α · α3 = α · (1 + α) = α + α2,

α5 = α2 · α3 = α2 · (1 + α) = α2 + α3 = 1 + α + α2,

α6 = α3 · α3 = (1 + α) · (1 + α) = 1 + α + α + α2 = 1 + α2.

Todos os elementos de F23, gerados por p(x) = 1 + x + x3, estão representados de

três formas distintas na tabela 4.

31

Tabela 4 - Representações dos

elementos de F23

Potência Polinômio Vetor
(0 0 0)
(1 0 0)
(0 1 0)
(0 0 1)
(1 1 0)
(0 1 1)
(1 1 1)
(1 0 1)

0
1
α
α2
1 + α
α + α2
1 + α + α2
1 + α2
Fonte: O autor, 2019

0
1
α
α2
α3
α4
α5
α6

Observação 2.3.5. No corpo ﬁnito F23, para efetuarmos a multiplicação de dois elemen-
tos, αi e αj, 0 ≤ i, j ≤ 6, somamos seus respectivos expoentes e usamos α7 = 1 caso essa
soma seja maior do que 7. Por exemplo, α5 · α6 = α11 = α4 · α7 = α4. Para efetuarmos
a divisão de αi por αj, multiplicamos αi pelo inverso multiplicativo de αj, que é α7−j.
Assim, α2/α3 = α2 · α7−3 = α2 · α4 = α6. Para efetuarmos a adição de dois elementos αi
e αj, usamos a representação polinomial desses elementos dadas na tabela 4. Então, para
efetuarmos a adição α3 + α5, procedemos da seguinte forma:

α3 + α5 = (1 + α) + (1 + α + α2) = α2.

2.4 Algumas Propriedades de Corpos Finitos com 2m elementos

Ao nos referirmos ao corpo R, sabemos que existem polinômios com coeﬁcientes
reais cujas raízes não pertencem a esse corpo, e sim ao conjunto C, que é uma extensão de
R. Para exempliﬁcar, consideremos o polinômio p(x) = x2 + 2x + 2 ∈ R[x], que não possui
raízes em R. As raízes de p(x) são os números complexos −1 − i e −1 + i, que estão em C.
Isto também ocorre com os polinômios com coeﬁcientes em Z2. Há polinômios em Z2[x]
cujas raízes não pertencem ao corpo Z2, mas estão em um corpo que é uma extensão de
Z2. Por exemplo, consideremos o polinômio q(x) = x3 + x2 + 1 ∈ Z2[x], que é irredutível
em Z2. Entretanto, q(x) possui três raízes no corpo F23, que é uma extensão de Z2. É
imediato que 0, 1 e α de F23 não são raízes de q(x). Mas, ao substituirmos os demais
elementos desse corpo em q(x), dados pela tabela 4, veriﬁcamos que α3, α5 e α6 são as

32

raízes de q(x) = x3 + x2 + 1, como podemos ver a seguir:

q(α2) = (α2)3 + (α2)2 + 1 = α6 + α4 + 1 = α2 + 1 + α2 + α + 1 = α,

q(α3) = (α3)3 + (α3)2 + 1 = α9 + α6 + 1 = α2 + α2 + 1 + 1 = 0,

q(α4) = (α4)3 + (α4)2 + 1 = α12 + α8 + 1 = α5 + α + 1 = α2 + α + 1 + α + 1 = α2,

q(α5) = (α5)3 + (α5)2 + 1 = α15 + α10 + 1 = α + α3 + 1 = α + α + 1 + 1 = 0,

q(α6) = (α6)3 + (α6)2 + 1 = α18 + α12 + 1 = α4 + α5 + 1 = α2 + α + α2 + α + 1 + 1 = 0.

Como q(x) = x3 + x2 + 1 é um polinômio de grau 3, ele só pode ter, no máximo, três
raízes que são α3, α5 e α6. Então, temos que q(x) = x3 + x2 + 1 é igual ao produto
(x + α3)(x + α5)(x + α6).

Deﬁnição 2.4.1. Seja o corpo F2m e β ∈ F2m. O elemento β2l, para qualquer l ≥ 0, é
chamado de conjugado de β.

Teorema 2.4.2. Sejam p(x) ∈ Z2[x], o corpo F2m e β ∈ F2m. Se β é uma raiz de p(x),
então todos os conjugados de β também são raízes de p(x).

A demonstração deste teorema pode ser vista em (LIN; DANIEL, 1983, pp. 34–35).

Exemplo 2.4.3. O elemento α3 do corpo F23 é uma raiz de q(x) = x3 + x2 + 1. De acordo
com o Teorema 2.4.2, os conjugados de α3 também são raízes de q(x) = x3 + x2 + 1. Isto
pode ser veriﬁcado, usando a tabela 4 e α7 = 1. Portanto, os conjugados de α3 são:

(α3)2 = α6,

(α3)22 = α12 = α5,

(α3)23 = α24 = α3.

Notemos que (α3)24 = α48 = α6. Portanto, não calcularemos os valores dos próxi-

mos conjugados de α3, pois obteremos os já encontrados α6, α5 e o próprio α3.

Teorema 2.4.4. Seja o corpo ﬁnito F2m. Então, os 2m − 1 elementos não nulos de F2m
geram todas as raízes de x2m−1 + 1.

Demonstração: Sejam um corpo ﬁnito F2m e β ∈ F2m, com β 6= 0. De acordo com o
Teorema 2.1.4, temos que

Somando 1 a ambos os lados dessa igualdade, obtemos

β2m−1 = 1.

β2m−1 + 1 = 0.

Isto signiﬁca que β é uma raiz do polinômio x2m−1 + 1. Portanto, todo elemento não nulo
do corpo F2m é uma raiz de x2m−1 + 1. Como o grau de x2m−1 + 1 é 2m − 1, então os
2m − 1 elementos não nulos de F2m geram todas as raízes do polinômio x2m−1 + 1.

33

Corolário 2.4.5. Seja o corpo ﬁnito F2m. Os elementos de F2m geram todas as raízes de
x2m + x.

Demonstração: Seja o corpo ﬁnito F2m. Considerando que o elemento 0 (zero) de F2m
é a raiz do polinômio p(x) = x, e de acordo com o Teorema 2.4.4, temos que os elementos
não nulos de F2m geram todas as raízes de x2m−1 + 1. Portanto, os elementos de F2m
geram todas as raízes de x2m + x = x(x2m−1 + 1).

Deﬁnição 2.4.6. Sejam os corpos ﬁnitos Z2 e F2m. Sejam β ∈ F2m e minβ(x) ∈ Z2[x]
o polinômio de menor grau, tal que minβ(β) = 0. O polinômio minβ(x) é chamado de
polinômio mínimo de β.

Exemplo 2.4.7. O polinômio mínimo do elemento 0 (zero) de F2m é o polinômio min0(x) =
x ∈ Z2[x], pois min0(0) = 0. E o polinômio mínimo do elemento 1 (unitário) de F2m é o
polinômio min1(x) = x + 1 ∈ Z2[x], pois min1(1) = 1 + 1 = 0.

Teorema 2.4.8. Sejam o corpo ﬁnito F2m e β ∈ F2m. O polinômio mínimo de β, minβ(x),
é um polinômio irredutível.

Demonstração: Sejam o corpo ﬁnito F2m e β ∈ F2m. Suponhamos que minβ(x) não seja
irredutível e, portanto, pode ser escrito como produto dos dois polinômios p1(x) e p2(x).
Então, minβ(x) = p1(x) · p2(x), onde os graus de ambos p1(x) e p2(x) são maiores do que
0 e menores do que o grau de minβ(x). Como minβ(β) = p1(β) · p2(β) = 0, então temos
que p1(β) = 0 ou p2(β) = 0. E, isto contradiz a hipótese de que minβ(x) é o polinômio
de menor grau, tal que minβ(β) = 0. Logo, minβ(x) é irredutível.

Teorema 2.4.9. Sejam os corpos ﬁnitos Z2 e F2m. Sejam um polinômio p(x) ∈ Z2[x],
β ∈ F2m e minβ(x). Se p(β) = 0, então minβ(x) divide p(x).

Demonstração: Na divisão de p(x) por minβ(x), temos que p(x) = minβ(x)·q(x)+r(x),
onde q(x) é o quociente e r(x) é o resto da divisão. Logo, devemos ter gr(r(x)) <
gr(minβ(x)) ou r(x) = 0. Como β é raiz de p(x) e minβ(x) é o polinômio mínimo
de β, então ao substituirmos x por β, obtemos p(β) = minβ(β) · q(β) + r(β) = 0. E,
consequentemente, temos que r(β) = 0. Se r(x) é o polinômio identicamente nulo, o
Teorema 2.4.9 está provado. Por outro lado, se r(x) 6= 0, então r(x) é o polinômio
mínimo de β. O que contradiz a hipótese de que minβ(x) é o polinômio mínimo de β.
Portanto, r(x) é o polinômio identicamente nulo e minβ(x) divide p(x).

Teorema 2.4.10. Sejam o corpo ﬁnito F2m, β ∈ F2m e minβ(x) o polinômio mínimo de
β. O polinômio x2m + x é divisível por minβ(x).

Demonstração: Segue do Corolário 2.4.5 e do Teorema 2.4.9.

Considerando β um elemento do corpo ﬁnito F2m, o teorema acima nos diz que
todas as raízes de um polinômio mínimo de β pertencem a F2m. Os dois seguintes teoremas
nos dirão como encontrar essas raízes.

34

Teorema 2.4.11. Sejam o corpo ﬁnito F2m, β ∈ F2m e p(x) irredutível em Z2[x]. Seja
minβ(x) o polinômio mínimo de β. Se p(β) = 0, então minβ(x) = p(x).

Demonstração: De acordo com o Teorema 2.4.9, temos que minβ(x) divide p(x). Como
minβ(x) 6= 1 e p(x) é irredutível, devemos ter minβ(x) = p(x).

Teorema 2.4.12. Sejam o corpo ﬁnito F2m, β ∈ F2m e p(x) ∈ Z2[x]. Seja e o menor
inteiro não negativo tal que β2e = β. Então

p(x) =

e−1
Y

i=0

(x + β2i)

é um polinômio irredutível em Z2[x].

A demonstração desse teorema pode ser encontrada em (LIN; DANIEL, 1983).

Teorema 2.4.13. Sejam o corpo ﬁnito F2m, β ∈ F2m e minβ(x) o polinômio mínimo de
β. Seja e o menor inteiro não negativo tal que β2e = β. Então

minβ(x) =

e−1
Y

(x + β2i).

i=0

(12)

sendo β2i os conjugados de β.

Demonstração. Esse teorema é uma consequência direta dos teoremas 2.4.11 e 2.4.12.

Exemplo 2.4.14. Consideremos o corpo ﬁnito F23, cujos elementos estão ilustrados na
tabela 4 (página 31). Seja β = α. Então, os conjugados de β são

β21 = α2

e β22 = α4.

O polinômio mínimo de β = α é dado por

minβ(x) = (x + α) · (x + α2) · (x + α4).

Efetuando as multiplicações no lado direito dessa igualdade de acordo com as informações
da tabela 4 (página 31), e considerando que α7 = 1, obtemos

minβ(x) = (x2 + (α + α2)x + α3) · (x + α4)

= (x3 + (α + α2 + α4)x2 + (α3 + α5 + α6)x + α7

= x3 + x + 1.

Todos os polinômios mínimos dos elementos de F23 são dados na tabela 5.

35

Tabela 5 - Polinômios mínimos dos elementos

de F23 gerado por p(x) = x3 + x + 1

Raízes conjugadas Polinômios mínimos

0
1
α, α2, α4
α3, α5, α6
Fonte: O autor, 2019

x
x + 1
x3 + x + 1
x3 + x2 + 1

Teorema 2.4.15. Sejam o corpo ﬁnito F2m, β ∈ F2m e minβ(x) o polinômio mínimo de
β. Seja e o grau de minβ(x). Então e é o menor inteiro tal que β2e = β. Além disso,
e ≤ m.

Demonstração: O Teorema 2.4.15 é consequência direta do Teorema 2.4.13.

Teorema 2.4.16. Sejam o corpo ﬁnito F2m e β ∈ F2m. Se β é um elemento primitivo de
F2m, então todos os conjugados de β também são elementos primitivos de F2m.

Demonstração: Sejam o corpo ﬁnito F2m e β um elemento primitivo de F2m. Seja n a
ordem de β2l, para l > 0. Então (β2l)n = 1, portanto

βn·2l = 1.

(13)

Além disso, de acordo com o Teorema 2.1.6, n divide 2m − 1. Então, podemos dizer que

2m − 1 = k · n.

Como β é um elemento primitivo de F2m, a ordem de β é 2m − 1. Logo, temos que

De (13) e (15) temos que

β2m−1 = 1.

βn·2l = β2m−1,

(14)

(15)

e portanto, n · 2l é um múltiplo de 2m − 1. Como 2l e 2m − 1 são primos entre si, n é
divisível por 2m − 1. Então

n = q · (2m − 1).

(16)

De (14) e (16) concluimos que n = 2m −1. Portanto, β2l é também um elemento primitivo
de F2m.

36

Exemplo 2.4.17. Considere o corpo ﬁnito F23, dado pela tabela 4 (página 31), e o
elemento β = α3 ∈ F23. As potências de β são as seguintes: β0 = 1, β1 = α3,
β2 = (α3)2 = α6, β3 = (α3)3 = α9 = α2, β4 = (α3)4 = α12 = α5, β5 = (α3)5 = α15 = α,
β6 = (α3)6 = α18 = α4, β7 = (α3)7 = α21 = 1.

Notemos que as potências de β = α3 geram todos os elementos não nulos de F23,

então β = α3 é um elemento primitivo de F23.

Como já vimos anteriormente, os conjugados de α3 são os elementos α5 e α6. As

potências desses dois elementos também geram todos os elementos não nulos de F23.

O teorema a seguir é uma forma generalizada do Teorema 2.4.16.

Teorema 2.4.18. Sejam o corpo ﬁnito F2m e β ∈ F2m. Se a ordem de β é igual a n, então
todos os conjugados de β têm ordem igual a n.

3 CÓDIGOS CORRETORES DE ERROS

37

Conforme nos referimos anteriormente, neste texto pretendemos mostrar a utiliza-
ção de polinômios em códigos corretores de erros, mais especiﬁcamente, nos códigos BCH
binários, que pertencem à classe dos códigos lineares e à subclasse dos códigos cíclicos.
Para tanto, faremos uma introdução sobre os códigos corretores de erros. Em seguida,
veremos os códigos lineares e algumas propriedades dos códigos cíclicos.

Neste capítulo, tomaremos principalmente como base as referências bibliográﬁcas

(HEFEZ; VILLELA, 2017) e (MILIES, 2009).

3.1 Introdução

Os códigos corretores de erros fazem parte do nosso dia a dia nas mais variadas
formas, tanto na transmissão como no armazenamento de informações digitalizadas. São
exemplos disso: o uso do celular, navegar pela internet, assistir a um ﬁlme em DVD e
usar uma rede Wi-Fi.

Uma determinada informação pode sofrer algum tipo de alteração durante seu
armazenamento ou transmissão. Essa alteração é chamada de ruído e pode ser gerada
por um erro humano de digitação ou por uma interferência eletromagnética durante o
envio de uma mensagem, por exemplo. A ﬁnalidade dos códigos corretores de erros é
justamente detectar e corrigir tais erros.

Em 1948, o matemático C. E. Shannon criou a Teoria dos Códigos Corretores de
Erros, que foi bastante desenvolvida nas duas décadas seguintes por outros matemáticos.
Por causa das pesquisas espaciais e da grande popularização dos computadores, houve
grande interesse por essa teoria a partir da década de 70. Atualmente, a utilização dos
códigos corretores de erros visa garantir a conﬁabilidade das informações ao se transmitir
ou armazenar dados.

O exemplo abaixo ilustra a utilização de códigos corretores de erros.

Exemplo 3.1.1. Vamos supor que um semáforo (sinal de trânsito) com as três cores
(vermelho, amarelo e verde) receba um comando da central de tráfego. Cada comando
acenderá uma dessas cores e irá apagar as duas restantes. Os três comandos acima podem
ser codiﬁcados da seguinte forma:

Vermelho 7−→ 00

Amarelo

7−→ 01

Verde

7−→ 10

38

O conjunto {00,01,10} é denominado código da fonte. A central de tráfego vai
transmitir esses códigos através de um canal que pode sofrer com interferências, as quais
podem causar apenas um erro no código transmitido. Vamos imaginar que o comando
01 foi enviado ao semáforo, que recebeu o comando 10. Nesse caso, nenhum erro seria
percebido pelo código, pois o comando 10 pertence ao código da fonte, e o semáforo iria
acender a luz verde ao invés de acender a amarela e apagar as outras duas.

Por outro lado, se o comando 01 fosse enviado pela central de tráfego e o sinal de
trânsito recebesse o comando 11. O código veriﬁcaria que houve um erro, pois o comando
11 não pertence ao código da fonte. Mesmo assim, ele não conseguiria corrigir esse erro,
já que não teria como saber qual foi o comando realmente enviado pela central de tráfego.
Nesse caso, o que pode ser feito, então, é acrescentar redundâncias que permitem a
detecção e correção de erros, gerando um novo código. Portanto, o código seria modiﬁcado
como mostramos a seguir:

00 7−→ 00000

01 7−→ 01101

10 7−→ 10011

O conjunto {00000,01101,10011} é denominado código do canal. Com esse novo
código, se algum erro for causado pelo canal de transmissão, o erro poderá ser detectado
e corrigido.

Suponhamos agora, que o comando 01101 foi enviado ao semáforo, mas este recebeu
o comando 01111, o qual não pertence ao código da fonte. Portanto, o código detectou
o erro. Sabendo que esse canal pode causar apenas um erro a cada comando enviado,
o código corrige o que foi recebido constatando que o comando efetivamente enviado foi
01101. Isto foi veriﬁcado porque o comando 01101 é o que tem o menor número de dígitos
distintos em relação ao comando 01111.

A ﬁgura 3 descreve o procedimento adotado acima.

Figura 3 - Diagrama simpliﬁcado de transmissão ou armazenamento de dados

Fonte: Adaptada de (LIN; DANIEL, 1983)

Ao trabalharmos com códigos corretores de erros, temos como objetivo acrescen-
tar redundâncias ao código da fonte transformando-o em código de canal. Com isso,

39

poderemos detectar e corrigir os possíveis erros que surgiram durante a trasnsmissão da
informação. E, ﬁnalmente, decodiﬁcar o código de canal em código da fonte.

A seguir mostraremos os conceitos básicos dos códigos corretores de erros.
A construção de um código corretor de erros é feita a partir de um conjunto ﬁnito
A, que será denominado alfabeto. Denotaremos por q = |A| o número de elementos de
A. Dessa forma, dizemos que A é um código q-ário. Além disso, um código corretor
de erros é formado por palavras, que são sequências ﬁnitas de símbolos do alfabeto.
O comprimento de cada palavra do código corresponde ao número de símbolos dessa
palavra. Um código corretor de erros é um subconjunto próprio qualquer de An, para
algum número natural n.

No Exemplo 3.1.1, utilizamos a quantidade de dígitos distintos entre dois comandos
para decodiﬁcar e corrigir um erro. Nesse caso, o comando é uma palavra do código. Essa
quantidade de dígitos diferentes entre palavras pode ser expressa como veremos a seguir.

Deﬁnição 3.1.2. Dados dois elementos x = (x1, x2, . . . , xn) e y = (y1, y2, . . . , yn) de um
conjunto ﬁnito An, chama-se distância de Hamming de x a y ao número de coordenadas
em que estes elementos diferem entre si; isto é:

d(x, y) = |{i : xi 6= yi, 1 ≤ i ≤ n}|.

Exemplo 3.1.3. Usando a deﬁnição acima, podemos calcular as distâncias de Hamming
entre as palavras do código usado no Exemplo 3.1.1. Sendo assim, temos:
d(00000, 01101) = 3, d(01101, 10011) = 4 e d(00000, 10011) = 3.

Observamos que a distância de Hamming satisfaz as seguintes propriedades:
i) Positividade: d(x, y) ≥ 0, ∀x, y ∈ An, valendo a igualdade se, e somente se, x = y.
ii) Simetria: d(x, y) = d(y, x), ∀x, y ∈ An.
iii) Desigualdade Triangular: d(x, y) ≤ d(x, z) + d(z, y).

Demonstração: A terceira propriedade (desigualdade triangular) não decorre direta-
mente da deﬁnição como as duas primeiras. Portanto, é a única que será demonstrada.

De fato, dados x, y ∈ An, a contribuição das i-ésimas coordenadas de x e y para
6= yi. Assim, dado z ∈ An, se
d(x, y) é igual a zero se xi = yi, e igual a um se xi
a contribuição das i-ésimas coordenadas para d(x, y) for zero, teremos que ela é sempre
menor ou igual às contribuições das i-ésimas coordenadas para d(x, z)+d(z, y), que podem
ser iguais a 0,1 ou 2. Por outro lado, temos que xi 6= yi, de modo que não é possível
termos xi = zi e yi = zi, o que nos dá que a contribuição das i-ésimas coordenadas
para d(x, z) + d(z, y) é sempre maior ou igual a um, que é a contribuição das i-ésimas
coordenadas para d(x, y).

As propriedades citadas acima caracterizam uma métrica. Portanto, a distância

de Hamming entre elementos de An é também chamada de métrica de Hamming.

Usaremos a distância de Hamming para deﬁnir disco e esfera em An.

Deﬁnição 3.1.4. Dados um elemento x ∈ An e um inteiro positivo r, chama-se disco de
centro em x e raio r, ao conjunto

40

D(x, r) = {y ∈ An; d(x, y) ≤ r},

e esfera de centro em x e raio r, ao conjunto

S(x, r) = {y ∈ An; d(x, y) = r}.

Deﬁnição 3.1.5. Dado um código C ∈ An chama-se distância mínima de C ao número

d = min{d(x, y); x, y ∈ C e x 6= y}.

Dado um código C com distância mínima d, deﬁne-se

k =

#

" d − 1
2

,

onde [t] representa a parte inteira de um número real t.

Lema 3.1.6. Seja C um código com distância mínima d. Se c e c0 são palavras distintas
de C, então

D(c, k) ∩ D(c0, k) = ∅.

Demonstração: Vamos supor que existe x ∈ D(c, k)∩D(c0, k). Então, teríamos d(x, c) ≤
k e d(x, c0) ≤ k, e, portanto, pela simetria e pela desigualdade triangular,

d(c, c0) ≤ d(c, x) + d(x, c0) ≤ 2k ≤ d − 1,

o que é um absurdo, pois d(c, c0) ≥ d.

Teorema 3.1.7. Seja C um código com distância mínima d. Então C pode corrigir até
k =

erros e detectar até d − 1 erros.

i

h d−1
2

Demonstração: Se durante a transmissão de uma palavra c do código C forem cometi-
dos t erros, com t ≤ k, e por causa disso, for recebida a palavra r, então d(r, c) = t ≤ k.
Pelo Lema 3.1.6, a distância de r a qualquer outra palavra de C é maior do que k, o que
determina c univocamente a partir de r.

Por outro lado, dada uma palavra c do código, podemos nela introduzir até d − 1

erros sem encontrar outra palavra do código, e assim, será possível detectar o erro.

Exemplo 3.1.8. O código do Exemplo 3.1.1 possui distância mínima d = 3, pois esta é
a menor distância de Hamming entre duas palavras distintas do código. Ele pode corrigir
até k =

= 1 erro e detectar até 3 − 1 = 2 erros.

i

h 3−1
2

41

O teorema acima evidencia a importância de se calcular a distância mínima, visto
que quanto maior for a distância mínima de um código, maior será a sua capacidade de
detecção e correção de erros .

Deﬁnição 3.1.9. Seja C ⊂ An um código com distância mínima d e seja k = [ d−1
código C será dito perfeito se

2 ]. O

D(c, k) = An.

[

c∈C

Assim, podemos dizer que um código C sobre um alfabeto A possui 3 parâmte-
tros fundamentais [n, M, d], que são, respectivamente, o comprimento n, o número de
elementos M e a distância mínima d.

Muitas vezes queremos saber se dois códigos são equivalentes, para isso daremos a

seguir a deﬁnição de isometria em An.

Deﬁnição 3.1.10. Sejam A um alfabeto e n um número natural. Diremos que uma
função F : An → An é uma isometria de An se ela preserva distâncias de Hamming. Isto
é,

d(F (x), F (y)) = d(x, y);

∀x, y ∈ An.

Teorema 3.1.11. Toda isometria de An é uma bijeção em An.

Demonstração: Seja F uma isometria em An. Suponhamos que F (x) = F (y), então
d(F (x), F (y)) = 0 = d(x, y). Logo x = y. Assim, provamos que F é injetora, e como toda
aplicação injetora de um conjunto ﬁnito nele próprio é sobrejetora, temos que F é uma
bijeção.

Deﬁnição 3.1.12. Sejam C e C 0 dois códigos em An, diremos que C 0 é equivalente a C
se existir uma isometria F de An tal que F (C) = C 0.

A seguir, enunciaremos um teorema que indica quando dois códigos são equivalen-

tes.

Teorema 3.1.13. Sejam C e C 0 dois códigos em An. Temos que C e C 0 são equivalentes
se, e somente se, existem uma permutação π de {1, . . . , n} e bijeções f1, . . . , fn de A tais
que

C 0 = {(fπ(1)(xπ(1)), . . . , fπ(n)(xπ(n))); (x1, . . . , xn) ∈ C}.

Demonstração: A demonstração deste teorema pode ser vista no apêndice 2 de (HE-
FEZ; VILLELA, 2017).

Como consequência do teorema acima, temos que dois códigos C e C 0, de compri-
mento n sobre um alfabeto A, são equivalentes se, e somente se, um deles pode ser obtido
a partir do outro através de uma sequência das seguintes operações:

(i) Substituição dos símbolos numa dada posição ﬁxa em todas as palavras do código

42

por meio de uma bijeção de A.

(ii) Permutação das posições dos símbolos em todas as palavras do código, mediante

uma permutação ﬁxa de {1, 2, . . . , n}.

Exemplo 3.1.14. Consideremos o código C = {00000, 01101, 10011} usado no Exemplo
3.1.1. Utilizaremos as operações citadas acima para gerarmos códigos equivalentes a C.
Aplicando a operação (i), substituindo os símbolos da segunda coordenada em cada pala-
vra de C da seguinte forma: 0 → 1 e 1 → 0, obtemos o código C 0 = {01000, 00101, 11011},
que é equivalente a C. E, aplicando a operação (ii), permutando os símbolos da primeira
coordenada com os da terceira coordenada em cada palavra de C, obtemos o código
C 00 = {00000, 11001, 00111}, que é equivalente a C.

Os códigos que apresentaremos na próxima seção são subespaços vetoriais. Por-
tanto, partiremos do princípio que o leitor esteja familiarizado com as principais deﬁnições
e resultados a respeito de espaços vetoriais.

3.2 Códigos Lineares

Incialmente, faremos uma introdução aos códigos lineares apresentando algumas

de suas propriedades básicas.

Consideremos um corpo ﬁnito K com q elementos, que denominaremos alfabeto.

Seja n ∈ N, temos que K n é um espaço vetorial de dimensão n sobre K.

Deﬁnição 3.2.1. Um código C ⊂ K n será chamado de código linear se for um subes-
paço vetorial de K n.

Observação 3.2.2. As palavras de um código linear são representadas por vetores (n-
uplas) de elementos de K. Tais vetores são também chamados de palavra código.

Exemplo 3.2.3. Consideremos o alfabeto K = {0, 1}, que é o próprio Z2, e o código
linear C = {(0000), (1011), (0110), (1101)}, que é um subespaço vetorial de Z4
2. Portanto,
temos que: C ⊂ Z4
2.

Observação 3.2.4. O código do Exemplo 3.2.3 é binário, pois seu alfabeto é o con-
junto Z2, que possui dois elementos. Tal código é um subconjunto de Z4
2 porque tem
comprimento n = 4. Isto é, cada palavra código de C possui 4 símbolos.

De acordo com a deﬁnição acima, todo código linear é um espaço vetorial de
dimensão ﬁnita. Seja C ∈ K um código linear de dimensão k com q elementos. E seja
{v1, v2, . . . , vk} uma base de C. Então, C possui M = |C| = qk elementos e todo elemento
de C é escrito de maneira única como

a1v1 + a2v2 + · · · + akvk,

43

onde os ai, i = 1, . . . , k, são elementos de K. Portanto,

dim C = k = logq qk = logq M.

Além disso, se denotarmos por 0 o elemento neutro da soma no espaço vetorial,
temos que 0 ∈ C. Abaixo, deﬁnimos o peso de um elemento pertencente a um espaço
vetorial.

Deﬁnição 3.2.5. Dado x ∈ K n, chama-se peso de x ao número inteiro

w(x) = d(x, 0),

onde d é a distância de Hamming.

Deﬁnição 3.2.6. O peso de um código linear C é o inteiro

w(C) = min{w(x); x ∈ C \ {0}}.

Proposição 3.2.7. Seja C ⊂ K n um código linear com distância mínima d. Temos que
i) ∀x, y ∈ K n,
ii) d = w(C).

d(x, y) = w(x − y).

Demonstração: A partir das deﬁnições de distância de Hamming e de peso, a prova
do item (i) é torna trivial. Para provar o item (ii), vamos considerar um código linear C
de distância mínima d. Então, para quaisquer elementos x e y de C com x 6= y, temos
que x − y também pertence a C\{0}. Além disso, d(x, y) = w(x − y), pois o número
de coordenadas diferentes entre x e y é igual ao número de coordenadas não nulas da
diferença entre x e y. Portanto, minimizar o peso do código é equivalente a minimizar a
distância entre quaisquer duas palavras dele.

Cabe a observação de que para conhecermos a distância mínima de um código
com M elementos, necessitaríamos (teoricamente) avaliar
distâncias mínimas. No
entanto, a proposição acima garante que tal número é reduzido para (M − 1) cálculos,
pelo fato de o peso do código ser igual a sua distância mínima.

(cid:16)M
2

(cid:17)

Exemplo 3.2.8. Seja o código linear C = {(00000), (01011), (10110), (11101)} ⊂ Z5
2
de distância mínima d = 3. Os pesos das palavras não nulas de C são: w(01011) =
3, w(10110) = 3 e w(11101) = 4. De acordo com a Deﬁnição 3.2.6, o peso do código linear
C é w(C) = 3, pois este é o menor valor entre os pesos das palavras não nulas de C.
Conhecendo sua distância mínima, poderemos calcular o peso de C de outra forma. Isto
é, de acordo com a Proposição 3.2.7, temos que: w(C) = d = 3.

Como códigos lineares são subespaços vetoriais de K n, as isometrias a serem con-

sideradas são lineares.

44

Deﬁnição 3.2.9. Um código linear C ∈ K n é linearmente equivalente ao código
C 0 ∈ K n se existir uma isometria linear T : K n → K n tal que

T (C) = C 0

.

Desta deﬁnição, podemos concluir que dois códigos lineares são linearmente equi-
valentes se, e somente se, cada um deles puder ser obtido a partir do outro mediante uma
sequência de operações do tipo:

(i) Multiplicação dos elementos numa dada posição ﬁxa por um escalar não nulo em

todas as palavras.

(ii) Permutação das posições de todas as palavras do código, mediante uma permu-

tação ﬁxa de {1, 2, . . . , n}.

Deﬁnição 3.2.10. Seja C ∈ K n um código linear. Chamaremos de parâmetros do
código linear C à terna (n, k, d), onde n é o comprimento de C, k é a dimensão de C sobre
K e d é a distância mínima de C.

Observação 3.2.11. Em algumas situações utilizaremos a notação código linear (n, k),
para nos referirmos a um código linear de comprimento n, distância mínima d e dimensão
k de C sobre K.

Exemplo 3.2.12. O código linear dado no Exemplo 3.2.8 possui M = 4 elementos e é
binário, pois q = 2. Então, temos que k = dim C = log2 4 = 2. Logo, podemos denotar
tal código C por código linear (5, 2).

A seguir, mostraremos um tipo de matriz que é utilizada para gerar um código

linear.

Deﬁnição 3.2.13. Sejam C ∈ K n um código linear e B = {v1, . . . , vk} uma base ordenada
de C. A matriz G, cujas linhas são os vetores vi = (vi1, . . . , vin), i = 1, . . . , k é denominada
matriz geradora do código C associada à base B. Isto é,

G =

















v1
...
vk









=

v11 v12
...
...
vk1 vk2

· · · v1n
...
· · · vkn









.

A matriz G não é a única matriz geradora de C, pois ela depende da escolha da

base. Isto é, para cada base diferente de C obtemos uma matriz geradora diferente.

Consideremos uma transformação linear T : K k → K n deﬁnida por T (x) = x · G,

com x ∈ K k. Se x = (x1, . . . , xk), temos que

T (x) = xG = x1v1 + · · · + xkvk,

45

logo T (K k) = C. Sendo assim, temos K k como o código da fonte e C como o código
de canal. A transformação T é considerada uma codiﬁcação, que transforma o código da
fonte no código de canal.

Sabemos que uma base de um espaço vetorial pode ser obtida a partir de outra
por meio de sequências de operações elementares. Analogamente, também obtemos uma
matriz geradora a partir de outra matriz geradora, efetuando operações elementares.

Vamos supor que seja dada uma palavra y ∈ K n de um código linear C, que
foi gerado por uma matriz G. Desejamos decodiﬁcar a palavra y. Então, precisamos
determinar a palavra x ∈ K n da qual y se origina, por meio da transformação T . Logo,
temos que resolver o sistema

x · G = y

.

Deﬁnição 3.2.14. Uma matriz geradora G de um código C está na forma padrão se

G = [Idk|A],

onde Idk é a matriz identidade de ordem k e A é uma matriz k × (n − k).

Ao efetuarmos sequências de operações como: permutação de duas colunas ou
multiplicação de uma coluna por um escalar não nulo, sobre a matriz geradora G de um
código linear C, obtemos uma matriz G0 de um código C 0 linearmente equivalente a C.

Teorema 3.2.15. Dado um código C, existe um código equivalente C 0 com matriz gera-
dora na forma padrão.

Demonstração: A demonstração deste teorema encontra-se em (HEFEZ; VILLELA,
2017, p. 92).

Exemplo 3.2.16. Consideremos o código linear (5,2) do Exemplo 3.2.8, que tem dimen-
são k = 2 sobre Z5

2. Sejam b = {10110, 01011} uma base e






G =

1 0 1 1 0

0 1 0 1 1






uma matriz geradora associada à base b, ambos desse código linear. Observemos que a
matriz G = [Idk|A] está na forma padrão. Logo, temos que






A =



 .

1 1 0

0 1 1

Seja a transformção linear T : Z2

2 → Z5

2 deﬁnida por T (x) = x · G, com x ∈ Z2

2. Aplicando

46

T para x = (10), temos

T (10) =

(cid:20)

1 0






(cid:21)

·

1 0 1 1 0

0 1 0 1 1



 =

(cid:20)

1 0 1 1 0

(cid:21)

,

que pertence ao código linear (5,2) acima. Portanto, a palavra x = (10) do código da
fonte foi codiﬁcada como T (10) = (10110) do código do canal.

Deﬁnição 3.2.17. Seja C ⊂ K n um código linear, o complemento ortogonal de C,
denotado por C ⊥, é deﬁnido como

C ⊥ = {v ∈ K n; hu, vi = 0, ∀u ∈ C}.

sendo hu, vi o produto interno dos elementos u e v pertencentes a K n.

A partir das propriedades de produto interno, temos que C ⊥ é um subespaço

vetorial de K n. Logo, C ⊥ também é um código linear. Além disso, (C ⊥)⊥ = C.

Deﬁnição 3.2.18. Seja C ⊂ K n um código linear. O código linear C ⊥ chama-se código
dual de C.

Proposição 3.2.19. Seja C ⊂ K n um código linear, com matriz geradora G. Dado
x ∈ K n, teremos x ∈ C ⊥ se, e somente se,

G · xt = 0.

Demonstração: Seja x ∈ K n. Teremos x ∈ C ⊥ se, e somente se, x for ortogonal a todos
os elementos de C se, e somente se, x for ortogonal a todos os elementos de uma base de
C, o que é equivalente a dizer que G · xt = 0, pois as linhas de G são uma base de C.

Proposição 3.2.20. Seja C ⊂ K n um código de dimensão k com matriz geradora
G = [Idk|A], na forma padrão. Então
i) dim C ⊥ = n − k;
ii) H = [−At|Idn−k] é uma matriz geradora de C ⊥.

Demonstração: (i) Pela Proposição 3.2.19, x = (x1, . . . , xn) ∈ C ⊥ ⇐⇒ G · xt = 0.
A matriz G está na forma padrão e a matriz A é de ordem k × (n − k), temos então que:

[Idk|A]n×n ·









x1
...
xn









n×1

= 0 ⇐⇒









x1
...
xk









k×1

= −Ak×(n−k)









xk+1
...
xn









.

(n−k)×1

Portanto, C ⊥ possui qn−k elementos, que são as possíveis escolhas arbitrárias de

xk+1, . . . , xn. Logo, C ⊥ tem dimensão n − k.

47

(ii) Por causa de Idn−k, as linhas de H são linearmente independentes, portanto, geram
um subespaço vetorial de dimensão n − k. Como as linhas de H são ortogonais às linhas
de G, temos que o espaço gerado pelas linhas de H está contido em C ⊥; e como esses
dois subespaços vetoriais têm a mesma dimensão, eles coincidem, provando assim que
H = [−At|Idn−k] é uma matriz geradora de C ⊥.

A matriz H, que é a geradora do código linear C ⊥, pode ser considerada também

uma matriz na forma padrão, quando estiver escrita na forma

H = [−At|Idn−k]

.

Lema 3.2.21. Seja C ∈ K n um código linear de dimensão k, com matriz geradora G.
Uma matriz H de ordem (n − k) × n, com coeﬁcientes em K n e com linhas linearmente
independentes, é uma matriz geradora de C ⊥ se, e somente se,

G · H t = 0.

Demonstração: (⇒) É imediata.
(⇐) Como as linhas de H são linearmente independentes, elas geram um subespaço ve-
torial de K n de dimensão n − k, que é igual a dimensão de C ⊥. Se representarmos por
h1, . . . , hn−k e por g1, . . . , gk, respectivamente, as linhas de H e de G, temos que

[G · H t]i,j = hgi, hji.

Por hipótese, G · H t = 0, logo todos os vetores do subespaço vetorial gerado pelas
linhas de H estão em C ⊥. Porém, como esse subespaço tem a mesma dimensão de C ⊥,
concluimos que são o mesmo subespaço vetorial.

Proposição 3.2.22. Sejam C um código linear e H uma matriz geradora de C ⊥. Temos
então que

v ∈ C se, e somente se, H · vt = 0.

Demonstração: É consequência imediata do Lema 3.2.21 e do fato de que (C ⊥)⊥ = C.

Observação 3.2.23. A matriz geradora H de C ⊥ é chamada de matriz teste de pa-
ridade de C. A proposição acima nos permite utilizar essa matriz para veriﬁcar se um
dado vetor v pertence ou não a um determinado código.

Observação 3.2.24. Sejam C ∈ K n um código linear com matriz teste de paridade H e
um vetor v ∈ K n, chamamos o vetor H · vt de síndrome de v .

48

Exemplo 3.2.25. Consideremos o código linear (5,2) do Exemplo 3.2.8. A matriz teste
de paridade deste código é



H =







1 0 1 0 0

1 1 0 1 0

0 1 0 0 1



.







Utilizaremos essa matriz H para veriﬁcarmos se a palavra v = (11101) pertence ao código
mencionado acima. Efetuando o produto H · vt, obtemos









0 1 1 0 0

1 1 0 1 0

1 0 0 0 1









·





























1

1

1

0

1









,









0

0

0

=

que é o vetor nulo. Portanto, v = (11101) pertence ao código linear (5,2) em questão.
Além disso, a síndrome de v é o vetor H · vt = 0.

A proposição a seguir nos mostrará que a matriz teste de paridade de um código
contém informações sobre o valor do peso do código, ou seja, sua própria distância mínima.

Proposição 3.2.26. Sejam C ∈ K n um código linear e H a matriz teste de paridade de
C. Temos que

w(C) ≥ s ⇐⇒ quaisquer s − 1 colunas de H são linearmente independentes.

Demonstração: Sejam x = (x1, . . . , xn) uma palavra não nula de C e h1, . . . , hn as
colunas de H. Suponhamos que cada conjunto de s − 1 colunas de H é linearmente
independente. Como Hxt = 0, temos que

H · xt = x1h1 + x2h2 + . . . + xnhn = 0.

(17)

O peso w(x) é o número de componentes não nulas de x, então se w(x) ≤ s − 1,
teríamos por (17) uma combinação nula de t colunas de H, com 1 ≤ t ≤ s − 1, o que é
uma contradição. Logo, w(x) ≥ s e, portanto, w(C) ≥ s.

Por outro lado, suponhamos que w(C) ≥ s. Suponhamos também, por absurdo,
que H tenha s − 1 colunas linearmente dependentes, digamos hi1, hi2, . . . , his−1. Logo,
existiriam xi1, . . . , xis−1, nem todos nulos, tais que

xi1hi1 + · · · + xis−1his−1 = 0.

Portanto, x = (0, . . . , xi1, 0, . . . , xis−1, 0, . . . , 0) ∈ C e consequentemente,

49

w(x) ≤ s − 1 < s, o que seria um absurdo, pois a hipótese inicial é a de que w(C) ≥ s.

Teorema 3.2.27. Seja H a matriz teste de paridade de um código C. Temos que o
peso de C é igual a s se, e somente se, quaisquer s − 1 colunas de H são linearmente
independentes e existem s colunas de H linearmente dependentes.

Demonstração: Suponhamos que w(C) = s, logo da Proposição 3.2.26, todo conjunto
de s − 1 colunas de H é linearmente independente. Por outro lado, existem s colunas de
H linearmente dependentes, pois, caso contrário, teríamos w(C) ≥ s + 1.

Reciprocamente, suponhamos que todo conjunto de s − 1 vetores colunas de H é
linearmente independente e existem s colunas linearmente dependentes. Logo, da Pro-
posição 3.2.26, temos que w(C) ≥ s. Caso w(C) seja maior do que s, novamente da
Proposição 3.2.26, todo conjunto com s colunas de H é linearmente independente, ge-
rando uma contradição.

Corolário 3.2.28. (Cota de Singleton) Os parâmetros (n, k, d) de um código linear sa-
tisfazem à desigualdade

d ≤ n − k + 1.

Demonstração: Sejam C um código linear de distância mínima d e H uma matriz teste
de paridade de C. Pelo Teorema 3.2.27, temos que d − 1 é menor ou igual ao posto de H,
que é n − k. Portanto, temos: d − 1 ≤ n − k =⇒ d ≤ n − k + 1.

Caso se veriﬁque a igualdade d = n − k + 1 em um código, este será chamado de
MDS (Maximum Distance Separable). Isto é, um código que tem máxima distância
mínima.

O processo de decodiﬁcação consiste na detecção e correção de erros num determi-
nado código. A seguir, introduziremos um método de decodiﬁcação que, segundo (HEFEZ;
VILLELA, 2017), é um aperfeiçoamento do que foi inventado por D. Slepian na década
de 60. Além disso, consideraremos que um vetor é uma palavra do código.

Deﬁnição 3.2.29. O vetor erro ve é a diferença entre o vetor recebido vr e o vetor
transmitido vt, isto é,

ve = vr − vt.

Podemos citar duas características importantes em relação ao vetor erro ve. A
primeira é que o peso de ve corresponde, exatamente, ao número de erros cometidos num
vetor durante sua transmissão. A segunda é que ve tem a mesma síndrome que o vetor
recebido vr. De fato, se considerarmos H a matriz teste de paridade de um código C,
como vt pertence a C, temos que Hvt
t = 0. Portanto:

Hvt

e = H(vt

r − vt

t) = Hvt

r − Hvt

t = Hvt
r.

De outra forma, se denotarmos por hi a i-ésima coluna de H e considerarmos

ve = (α1, . . . , αn), teremos então que

50

n
X

i=1

αihi = Hvt

e = Hvt
r.

Lema 3.2.30. Seja C ∈ K n um código linear com capacidade de correção k. Se vr ∈ K n
e vt ∈ C são tais que d(vt, vr) ≤ k, então existe um único vetor ve com ω(ve) ≤ k, cuja
síndrome é igual à de vr e

vt = vr − ve

.

Demonstração: Inicialmente, para provarmos a existência do vetor ve, basta conside-
rarmos ve = vr − vt, já que w(ve) = d(vt, vr) ≤ k. Para provarmos a unicidade, vamos
supor dois vetores ve1 = (x1 . . . xn) e ve2 = (y1 . . . yn) tais que w(ve1) ≤ k e w(ve2) ≤ k
e tenham mesma síndrome que vr. Então, se H é uma matriz teste de paridade de C,
temos

H · vt

e1 = H · vt

e2 =⇒

n
X

n
X

xihi =

yihi,

i=1

i=1

A igualdade acima nos fornece uma relação de dependência linear entre 2k (≤ d − 1)
colunas de H. De acordo com o Teorema 3.2.15, quaisquer d − 1 colunas de H são
linearmente independentes. Então, temos que xi = yi para todo i, portanto ve1 = ve2.

Consideradas as hipóteses do Lema 3.2.30, o problema que surge, então, é como
r. Vejamos como ve poderá ser

determinar esse único vetor erro ve a partir de H · vt
determinado a seguir:

Vamos supor um código C com distância mínima d ≥ 3, matriz teste de paridade
H e que o vetor erro ve, introduzido entre o vetor transmitido vt e o vetor recebido vr, seja
tal que w(ve) ≤ 1. (No máximo, apenas um erro foi cometido durante a transmissão).

Observamos que se H · vt

e = 0, então vr ∈ C e, neste caso, tomamos vt = vr. Isto
é, nenhum erro foi introduzido durante a transmissão. Por outro lado, se H · vt
e 6= 0;
w(ve) = 1 e, portanto, ve tem apenas uma coordenada não nula. Vamos considerar que
ve = (0, . . . , α, . . . , 0) com α 6= 0 na i-ésima posição. Logo,

H · vt

e = αhi,

onde hi é a i-ésima coluna de H. Como vr e ve têm a mesma síndrome, então,

H · vt

e = H · vt

r = αhi.

Podemos determinar ve como sendo o vetor com todas as componentes nulas exceto a
i-ésima componente que é α. Note que i acima é bem determinado, pois d ≥ 3.

51

A seguir apresentamos o algoritmo de decodiﬁcação em códigos corretores de um

erro, que foi extraído de (HEFEZ; VILLELA, 2017).

Algoritmo 1 - Algoritmo de Decodiﬁcação em Códigos Corretores de Um Erro

Seja H a matriz teste de paridade do código C e seja vr um vetor recebido.
(Suponha d ≥ 3.) Passo 1: Calcule H · vt
r.
Passo 2: Se H · vt
r = 0, aceite vr como sendo o vetor transmitido.
r = st 6= 0, compare st com as colunas de H.
Passo 3: Se H · vt
Passo 4: Se existirem i e α tais que st = αhi, para α ∈ K, então ve é a n-upla com α
na posição i e zeros nas outras posições. Corrija vr colocando vt = vr − ve.
Passo 5: Se ocorrer o contrário do Passo 4, então foi cometido mais de um erro.

Exemplo 3.2.31. Consideremos o código linear (5,2) do Exemplo 3.2.8 com matriz teste
de paridade



H =







1 0 1 0 0

1 1 0 1 0

0 1 0 0 1



.







Suponhamos que este código seja utilizado por um monitor de TV, que possui 4 canais.
Cada um desses canais é selecionado através de um comando enviado por um controle
remoto para o monitor. E cada comando é um elemento do código. Suponhamos tam-
bém que o controle remoto enviou um comando para o monitor e, por causa de alguma
interferência, o comando recebido foi vr = (01010). Utilizando a matriz teste de paridade









1 0 1 0 0

1 1 0 1 0

0 1 0 0 1









·





























0

1

0

1

0

(cid:20)

=

0 0 1

(cid:21)

,

veriﬁcamos que vr = (01010) não pertence ao código, pois o resultado do produto acima
não foi o vetor nulo. Vemos que a síndrome de vr corresponde a quinta coluna de H, ou
seja,

H · vt

r = 1 · h5.

Então, pelo algoritmo acima, temos que ve = (00001). Logo, poderemos corrigir vt fazendo

vt = vr − ve = (01010) − (00001) = (01011).

Portanto, o comando enviado pelo controle remoto ao monitor foi vt = (01011).

52

Em algumas situações podem ser introduzidos mais de um erro durante a trans-
missão de um vetor. Para corrigir um vetor vr, que foi recebido com mais de um erro,
iremos apresentar algumas deﬁnições e outro algoritmo de decodiﬁcação mais geral.

Seja C ⊂ K n um código corretor de erros com matriz teste de paridade H. Sejam
2 ]. Como ve e vr têm a mesma síndrome e, se

d a distância mínima de C e k = [ d−1
w(ve) = d(vr, vt) ≤ k, então ve é univocamente determinado por vr.

Deﬁnição 3.2.32. Seja v ∈ K n. Chama-se classe lateral de v determinada por C
ao conjunto

Note que

v + C = {v + u; u ∈ C}.

v + C = C ⇐⇒ v ∈ C.

Lema 3.2.33. Os vetores u e v de K n têm a mesma síndrome se, e somente se, u ∈ v + C.

Demonstração: H · ut = H · vt ⇐⇒ H · (u − v)t = 0 ⇐⇒ u − v ∈ C ⇐⇒ u ∈ v + C.

A seguir, apenas enunciaremos as propriedades das classes laterais determinadas

por C.

Proposição 3.2.34. Seja C ∈ K n um código linear de dimensão k com q elementos.
Temos que
i) v + C = v0 + C ⇔ v − v0 ∈ C;
ii) (v + C) ∩ (v0 + C) 6= ∅ =⇒ v + C = v0 + C;
iii) S
v∈Kn(v + C) = K n;
iv) |(v + C)| = |C| = qk.

Segue imediatamente de (ii)-(iv) da Proposição 3.2.34 que o número de classes

laterais segundo C é

qn
qk = qn−k.

Notemos que o Lema 3.2.33 estabelece uma correspondência 1 a 1 entre classes
laterais e síndromes. Todos os elementos de uma classe lateral determinada por um código
têm a mesma síndrome, e elementos de classes distintas possuem síndromes distintas.

Deﬁnição 3.2.35. Um vetor de peso mínimo numa classe lateral é chamado de elemento
líder dessa classe.

Proposição 3.2.36. Seja C um código linear em K n com distância mínima d. Se u ∈ K n
é tal que

w(u) ≤

#

" d − 1
2

= k,

então u é o único elemento líder de sua classe.

53

Demonstração: Suponhamos que u, v ∈ K n tais que

w(u) ≤ [

d − 1
2

]

e w(v) ≤ [

d − 1
2

].

Se u − v ∈ C, então

w(u − v) ≤ w(u) + w(v) ≤

#

" d − 1
2

+

#

" d − 1
2

≤ d − 1;

logo, u − v = 0 e, portanto, u = v.

A seguir, apresentaremos um algoritmo que permite corrigir vetores que tenham
2 ] é a capacidade de correção

sido recebidos com até k erros. Devemos lembrar que k = [ d−1
do código.

Inicialmente, precisamos determinar os líderes de classes laterais, sendo cada um
deles o único líder em sua classe. Faremos isso encontrando todos os elementos u de K n,
tal que w(u) ≤ k.

Em seguida, devemos calcular as síndromes desses elementos e inserir esses vetores
com suas respectivas síndromes numa tabela. Após esses passos, é só seguir o algoritmo
abaixo, que foi extraído de (HEFEZ; VILLELA, 2017):

Algoritmo 2 - Algoritmo de Decodiﬁcação em Códigos Corretores de k Erros

Seja vr um vetor recebido.

Passo 1: Calcule a síndrome st = H · vt
r.
Passo 2: Se s está na tabela, seja l o elemento líder da classe determinada por s;

troque vr por vr − l.

Passo 3: Se s não está na tabela, então foram cometidos mais do que k erros

no vetor recebido.

e = H · vt

Se vr, vt e ve forem respectivamente os vetores recebido, transmitido e erro, como
H · vt
r, temos que a classe lateral onde ve se encontra está determinada pela
síndrome de vr. Se w(ve) ≤ k, então ve é o único elemento líder l de sua classe e,
portanto, é conhecido e se encontra na tabela. Consequentemente, pelo Lema 3.2.30,
vt = vr − ve = vr − l é determinado.

3.3 Códigos Cíclicos Binários

Os códigos cíclicos formam uma subclasse importante dos códigos lineares e pos-
suem propriedades algébricas que simpliﬁcam a sua implementação. Nesta seção, aborda-

54

remos tais propriedades dos códigos cíclicos binários, em particular trataremos os códigos
BCH binários, que também são cíclicos.

Deﬁnição 3.3.1. Sejam o corpo Z2, um código linear C ⊂ Zn
2 e v = (v0, v1, . . . , vn−1) um
vetor de C. Se cada uma das n − 1 primeiras componentes de v forem deslocadas uma
posição para a direita e a última componente vn−1 for deslocada para a primeira posição
à esquerda, obteremos o vetor

vd1 = (vn−1, v0, v1, . . . , vn−2),

que é chamado de vetor deslocamento cíclico de v. Neste caso, o deslocamento foi de
uma posição. Se o deslocamento cíclico for de i ∈ N (1 ≤ i ≤ n − 1) posições para a
direita no vetor v, o vetor deslocamento cíclico obtido será o seguinte

vdi = (vn−i, . . . , v0, . . . , vn−1−i).

Observação 3.3.2. O deslocamento cíclico de i = n posições para a direita gera um vetor
deslocamento cíclico igual ao vetor original. E o deslocamento cíclico de uma posição para
a esquerda é o mesmo que um deslocamento cíclico de i = n − 1 posições para a direita.

Deﬁnição 3.3.3. Um código linear C ⊂ Zn
2 será chamado de código cíclico biná-
rio C se, para todo vetor v = (v0, . . . , vn−1) de C, então o vetor deslocamento vdi =
(vn−i, . . . , vn−1−i) também pertence a C, ∀i = 1, . . . , n − 1.

Observação 3.3.4. Em algumas situações utilizaremos a notação C(n, k), para nos re-
ferirmos a um código cíclico binário de comprimento n, distância mínima d e dimensão k
de C sobre Z2.

Sabemos que um polinômio p(x) = a0 + a1x + · · · + an−1xn−1 pode ser represen-
tado como uma n-upla p = (a0, a1, . . . , an−1), onde as componentes da n-upla p são os
coeﬁcientes de p(x) e vice-versa. Portanto, cada vetor v = (a0, a1, . . . , an−1) de um có-
digo cíclico C está associado a um polinômio p(x) = a0 + a1x + · · · + an−1xn−1 tal que
gr(p(x)) ≤ n − 1. A representação vetorial de um polinômio é útil no desenvolvimento de
propriedades algébricas dos códigos cíclicos binários, e será usada em algumas situações
daqui em diante neste trabalho.

Observação 3.3.5. Sejam v = (v0, v1, . . . , vn−1) um vetor de um código cíclico C e

v(x) = v0 + v1x + · · · + vn−1xn−1

(18)

o polinômio associado a v. Como C é cíclico, o vetor vdi = (vn−i, vn−i+1, . . . , vn−i−1), com
0 ≤ i ≤ n − 1, também pertence a C.

55

Podemos escrever a representação polinomial de vdi da seguinte forma:

vdi(x) = vn−i + vn−i+1x + . . . + vn−1xi−1 + v0xi + v1xi+1 + . . . + vn−i−1xn−1.

Existe uma relação entre v(x) e vdi(x) que veremos a seguir.
Multiplicaremos v(x), dado em (18), por xi

xiv(x) = v0xi + v1xi+1 + . . . + vn−i−1xn−1 + . . . + vn−1xn+i−1.

A expressão acima pode ser reescrita como:

xiv(x) = vn−i + vn−i+1x + . . . + vn−1xi−1 + v0xi + . . . + vn−i−1xn−1+
+vn−i(xn + 1) + vn−i+1x(xn + 1) + . . . + vn−1xi−1(xn + 1).

E obtemos

xiv(x) = [vn−i + vn−i+1x + · · · + vn−1xi−1](xn + 1) + vdi(x)

(19)

De (19), temos que vdi(x) é o resto da divisão de xiv(x) por (xn + 1).

Exemplo 3.3.6. Consideremos o polinômio v(x) = v0 + v1x + v2x2 + v3x3 + v4x4 + v5x5.
Vamos efetuar um deslocamento cíclico de três posições para a direita em v(x). Então,
multiplicando v(x) por x3, obtemos

x3v(x) = v0x3 + v1x4 + v2x5 + v3x6 + v4x7 + v5x8

= (v5x2 + v4x + v3)(x6 + 1) + vd3(x).

De (19), temos que vd3(x) é o resto da divisão de x3v(x) por (x6 + 1). Logo,

vd3(x) = v2x5 + v1x4 + v0x3 + v5x2 + v4x + v3.

Observação 3.3.7. Ao longo deste texto, usaremos o vetor v = (v0, v1, . . . , vn−1) e o
polinômio v(x) = v0 + v1x + · · · + vn−1xn−1 associado a ele indistintamente como elemen-
tos de um código cíclico C(n, k). O polinômio v(x) poderá ser chamado de polinômio
código.

A seguir, mostraremos algumas propriedades dos códigos cíclicos binários que ser-

virão de base para a apresentação dos códigos BCH binários.

Teorema 3.3.8. O polinômio não nulo de grau mínimo de um código cíclico binário
C(n, k) é único.

Demonstração: Seja g(x) = g0 + g1x + · · · + gr−1xr−1 + xr um polinômio não nulo de
grau mínimo r, de um código cíclico binário C(n, k). Suponhamos que g(x) não seja único

56

e que exista outro polinômio de grau r,

h(x) = h0 + h1x + · · · + hr−1xr−1 + xr.

Como C(n, k) é linear, a soma de grau r − 1,

g(x) + h(x) = (g0 + h0) + (g1 + h1)x + · · · + (gr−1 + hr−1)xr−1

pertence a C(n, k). Se g(x) + h(x) 6= 0, então g(x) + h(x) é um polinômio não nulo de
grau menor do que r. Isto é um absurdo, pois r é o grau mínimo. Então, devemos ter

g(x) + h(x) = 0.

Logo, g(x) = h(x). Portanto, g(x) é único.

Teorema 3.3.9. Seja g(x) = g0 + g1x + · · · + gr−1xr−1 + xr um polinômio não nulo de
grau mínimo r de um código cíclico binário C(n, k). Então, o termo independente g0 de
g(x) é igual a 1.

Demonstração: Suponhamos que g0 = 0. Então

g(x) = g1x + g2x2 + · · · + gr−1xr−1 + xr.

Efetuando um deslocamento cíclico de n − 1 posições para a direita, obtemos

g(x) = g1 + g2x + · · · + gr−1xr−2 + xr−2 + xr−1,

que tem grau menor que r, que é o grau mínimo. Isto é um absurdo. Pela hipótese, g(x)
é o polinômio não nulo de grau mínimo r. Logo, g0 = 1.

Teorema 3.3.10. Seja g(x) = 1 + g1x + · · · + gr−1xr−1 + xr um polinômio não nulo de
grau mínimo r de um código cíclico binário C(n, k). Um polinômio p(x) de grau s ≤ n − 1
pertence a C(n, k) se, e somente se, p(x) for múltiplo de g(x).

Demonstração: (⇒) Seja p(x) um polinômio de grau s ≤ n − 1. Suponhamos que p(x)
seja múltiplo de g(x). Então

p(x) = (p0 + p1x + · · · + psxs) · g(x) = p0g(x) + p1xg(x) + · · · + psxsg(x).

De acordo com a Observação 3.3.5, os polinômios g(x), xg(x), . . . , xsg(x) são deslocamen-
tos cíclicos de g(x) e, portanto, pertencem a C(n, k). Se p(x) é uma combinação linear dos
polinômios g(x), xg(x), . . . , xsg(x) e como C(n, k) é linear, então p(x) pertence a C(n, k).

57

(⇐) Seja p(x) um polinômio de um código cíclico binário C(n, k). Dividindo p(x) por
g(x), obtemos

p(x) = g(x) · q(x) + r(x),

onde r(x) = 0 ou gr(r(x)) < gr(g(x)). A equação acima pode ser escrita da seguinte
forma

r(x) = p(x) + g(x) · q(x).

Segue da prova da primeira parte do teorema, que g(x)q(x) pertence a C(n, k). Como
p(x) também pertence a C(n, k), então r(x) deve pertencer a C(n, k). Se r(x) 6= 0, então
r(x) é um polinômio não nulo de grau menor do que o grau de g(x). Isto é um absurdo.
Pela hipótese do teorema, g(x) é um polinômio não nulo de grau mínimo. Então, devemos
ter r(x) = 0. Logo,

p(x) + g(x)q(x) = 0

e p(x) = g(x)q(x).

Ou seja, p(x) é múltiplo de g(x).

Observação 3.3.11. De acordo com o Teorema 3.3.8, g(x) é único. Como C(n, k) é
binário e possui dimensão k, existem 2k polinômios nesse código. Por outro lado, existem
2n−r polinômios de grau s ≤ n − 1, que são múltiplos de g(x) de grau mínimo r. Esses
polinômios formam todos os polinômios de um código cíclico binário C(n, k), conforme o
Teorema 3.3.10. Dessa forma, devemos ter: 2n−r = 2k. E, consequentemente, r = n − k.
Isto é,

gr(g(x)) = r = n − k.

Teorema 3.3.12. Seja g(x) = 1 + g1x + g2x2 + · · · + gr−1xr−1 + grxr um polinômio não
nulo de grau mínimo r de um código cíclico binário C(n, k). Existe um e somente um
polinômio de grau n − k em C(n, k) e r = n − k. Então,

g(x) = 1 + g1x + g2x2 + · · · + gn−k−1xn−k−1 + gn−kxn−k.

(20)

Deﬁnição 3.3.13. Seja g(x) = 1+g1x+g2x2+· · ·+gn−k−1xn−k−1+gn−kxn−k um polinômio
não nulo de grau mínimo n − k de um código cíclico binário C(n, k). O polinômio g(x) é
chamado de polinômio gerador de C(n, k).

Observação 3.3.14. Seja g(x) um polinômio não nulo de grau mínimo n − k de um
código cíclico binário C(n, k). O número de dígitos de veriﬁcação de paridade de C(n, k)
é igual a n − k.

Exemplo 3.3.15. O código cíclico binário C(7, 4), que está representado na tabela 6, é
gerado pelo polinômio g(x) = 1 + x + x3. Notemos que neste código, n = 7 e k = 4. Além
disso, gr(g(x)) = 7 − 4 = 3 e todos os polinômios pertencentes a C são múltiplos de g(x).

58

Tabela 6 - Código cíclico binário C(7, 4) gerado por g(x) = 1 + x + x3

Mensagem Palavra código Polinômios
0 = 0 · g(x)
(0,0,0,0,0,0,0)
(0,0,0,0)
1 + x + x3 = g(x)
(1,1,0,1,0,0,0)
(1,0,0,0)
x + x2 + x4 = xg(x)
(0,1,1,0,1,0,0)
(0,1,0,0)
1 + x2 + x3 + x4 = (1 + x)g(x)
(1,0,1,1,1,0,0)
(1,1,0,0)
1 + x + x2 + x5 = (1 + x2)g(x)
(1,1,1,0,0,1,0)
(0,0,1,0)
x2 + x3 + x5 = x2g(x)
(0,0,1,1,0,1,0)
(1,0,1,0)
1 + x4 + x5 = (1 + x + x2)g(x)
(1,0,0,0,1,1,0)
(0,1,1,0)
x + x3 + x4 + x5 = (x + x2)g(x)
(0,1,0,1,1,1,0)
(1,1,1,0)
1 + x2 + x6 = (1 + x + x3)g(x)
(1,0,1,0,0,0,1)
(0,0,0,1)
x + x2 + x3 + x6 = (x + x3)g(x)
(0,1,1,1,0,0,1)
(1,0,0,1)
1 + x + x4 + x6 = (1 + x3)g(x)
(1,1,0,0,1,0,1)
(0,1,0,1)
x3 + x4 + x6 = x3g(x)
(0,0,0,1,1,0,1)
(1,1,0,1)
x + x5 + x6 = (x + x2 + x3)g(x)
(0,1,0,0,0,1,1)
(0,0,1,1)
1 + x3 + x5 + x6 = (1 + x + x2 + x3)g(x)
(1,0,0,1,0,1,1)
(1,0,1,1)
x2 + x4 + x5 + x6 = (x2 + x3)g(x)
(0,0,1,0,1,1,1)
(0,1,1,1)
1 + x + x2 + x3 + x4 + x5 + x6 = (1 + x2 + x5)g(x)
(1,1,1,1,1,1,1)
(1,1,1,1)

Fonte: (LIN; DANIEL, 1983)

Teorema 3.3.16. O polinômio gerador g(x) de um código cíclico binário C(n, k) é um
fator de xn + 1.

Demonstração: Multiplicando g(x) por xk obtemos o polinômio xkg(x), que tem grau
n. Dividindo xkg(x) por xn + 1 obtemos

xkg(x) = (xn + 1) + gdk(x),

(21)

onde gdk(x) é o resto da divisão. De acordo com a Deﬁnição 3.3.3, gdk(x) representa o
vetor deslocamento cíclico de k posições para direita do vetor g(x). Portanto, gdk(x) é
um múltiplo de g(x). Isto é, gdk(x) = g(x)p(x). Substituindo essa igualdade em (21),
obtemos

xkg(x) = (xn + 1) + g(x)p(x).

Reorganizando essa igualdade, temos

xn + 1 = [xk + p(x)]g(x).

Portanto, g(x) é um fator de xn + 1.

Teorema 3.3.17. Se g(x) é um fator de xn + 1 e gr(g(x)) = n − k, então g(x) gera um
código cíclico binário C(n, k).

59

Demonstração: Sejam os k polinômios g(x), xg(x), . . . , xk−1g(x), todos com grau menor
ou igual a n − 1 e g(x) um polinômio de grau n − k. Seja v(x) uma combinação linear
desses k polinômios,

v(x) = a0g(x) + a1xg(x) + · · · + ak−1xk−1g(x) = (a0 + a1x + · · · + ak−1xk−1)g(x).

O polinômio v(x) é um polinômio de grau menor ou igual a n − 1 e é múltiplo de g(x).
Existe um total de 2k polinômios que formam um código cíclico binário C(n, k).

Seja v(x) = v0 + v1x + · · · + vn−1xn−1 um polinômio de C(n, k). Multiplicando v(x)

por x, obtemos

xv(x) = v0x + v1x2 + · · · + vn−2xn−1 + vn−1xn

= vn−1(xn + 1) + (vn−1 + v0x + · · · + vn−2xn−1)
= vn−1(xn + 1) + vd1(x),

onde vd1(x) é um deslocamento cíclico de v(x). Se os polinômios xv(x) e xn + 1 são múlti-
plos de g(x), então vd1(x) também deve ser múltiplo de g(x). Logo, vd1(x) é um múltiplo
de g(x) e é uma combinação linear dos k polinômios g(x), xg(x), . . . , xk−1g(x). Portanto,
vd1(x) também pertence a C(n, k). De acordo com a Deﬁnição 3.3.3, o código linear
gerado pelos polinômios g(x), xg(x), . . . , xk−1g(x) é um código cíclico binário C(n, k).

Exemplo 3.3.18. O polinômio x7 + 1 pode ser fatorado da seguinte forma:

x7 + 1 = (1 + x)(1 + x + x3)(1 + x2 + x3).

Na fatoração acima há dois fatores de grau 3: 1 + x2 + x3 e 1 + x + x3. Cada um deles
gera um código cíclico binário C(7, 4). O polinômio g(x) = 1 + x + x3 gera o código cíclico
binário C(7, 4) do Exemplo 3.3.15, que está representado na tabela 6 (página 58). Este
código tem distância mínima d = 3 e é um código corretor de 1 erro.

Dada uma mensagem u(x) que foi transmitida por um canal de comunicação.
A codiﬁcação de u(x) é feita multiplicando-se u(x) por g(x), gerando o vetor v(x) =
vt(x)g(x), pertencente ao código cíclico binário C(n, k).

Suponhamos que a mensagem u = (u0, u1, . . . , uk−1) foi transmitida e precisa ser

codiﬁcada. O polinômio correspondente é

u(x) = u0 + u1x + · · · + uk−1xk−1.

multiplicando u(x) por xn−k, obtemos um polinômio de grau menor ou igual a n − 1,

xn−ku(x) = u0xn−k + u1xn−k+1 + · · · + uk−1xn−1.

Dividindo xn−ku(x) pelo polinômio gerador g(x), temos

xn−ku(x) = g(x)q(x) + r(x)

60

(22)

onde q(x) e r(x) são respectivamente o quociente e o resto da divisão. Como o grau de
g(x) é n − k, então o grau de r(x) tem que ser menor ou igual a n − k − 1. Isto é,

r(x) = r0 + r1x + · · · + rn−k−1xn−k−1.

Reorganizando a igualdade (22), obtemos o seguinte polinômio de grau menor ou igual a
n − k:

r(x) + xn−ku(x) = g(x)q(x).

(23)

O polinômio r(x) + xn−ku(x) é múltiplo do polinômio gerador g(x) e, portanto, pertence
ao código cíclico binário gerado por g(x). Escrevendo r(x) + xn−ku(x) em função de seus
coeﬁcientes, temos

r(x) + xn−ku(x) = r0 + r1x + · · · + rn−k−1xn−k−1 + u0xn−k + · · · + uk−1xn−1,

(24)

cujo vetor correspondente é

(r0, r1, . . . , rn−k−1, u0, . . . , uk−1).

Notemos que o vetor acima consiste de k dígitos de informação (r0, r1, . . . , rn−k−1), segui-
dos de n − k dígitos de veriﬁcação de paridade (u0, . . . , uk−1). O processo descrito acima
gera um código cíclico binário C(n, k) na forma sistemática. Dessa maneira, considerando
o polinômio r(x) + xn−ku(x), os coeﬁcientes de 1, x, . . . , xn−k−1 são os n − k dígitos de
veriﬁcação de paridade, e os coeﬁcientes de xn−k, x n − k + 1, . . . , xn−1 são os k dígitos
da informação, que correspondem a mensagem transmitida.

Exemplo 3.3.19. Consideremos o código cíclico binário C(7, 4) gerado por g(x) = 1 +
x + x3. Seja u = (1, 0, 0, 1) a mensagem transmitida que será codiﬁcada. O polinômio
correspondente de u é u(x) = 1 + x3. Dividindo x3u(x) = x3 + x6 por g(x), obtemos

x3 + x6 = (1 + x + x3)(x + x3) + (x + x2),

onde r(x) = x + x2 é o resto da divisão. Então, o polinômio resultante da codiﬁcação é

v(x) = r(x) + x3u(x) = x + x2 + x3 + x6,

61

cujo vetor correspondente é

v = (0, 1, 1, 1, 0, 0, 1),

onde os quatro (k = 4) últimos dígitos da direita são os dígitos da mensagem u = (1, 0, 0, 1).
E os três (n−k = 3) primeiros dígitos da esquerda são os dígitos de veriﬁcação de paridade.

Na próxima seção, veremos uma classe de códigos corretores de erros chamados có-
digos BCH binários. Tais códigos foram primeiramente descobertos por A. Hocquenghem
em 1959 e, de forma independente, por R.C. Bose e D.K. Ray-Chaudhuri em 1960.

Embora os códigos BCH sejam cíclicos, não nos aprofundaremos a respeito disso,
pois nossa intenção é exempliﬁcar a utilização de polinômios vinculando-os aos códigos
corretores de erros. Muitas das deﬁnições e resultados que apresentaremos encontram-se
mais detalhados em (LIN; DANIEL, 1983).

3.4 Códigos BCH Binários

Inicialmente, apresentaremos algumas propriedades básicas dos códigos BCH bi-

nários.

Vimos na Deﬁnição 3.2.10 que os parâmetros de um código linear C são: a dimensão

k de C sobre o corpo ﬁnito K, a distância mínima d de C e o comprimento n de C.

Deﬁnição 3.4.1. Chamamos de código BCH binário com capacidade de correção
de t erros ao código cíclico binário de distância mínima d ≥ 2t + 1, com n − k ≤ mt
dígitos de veriﬁcação de paridade e comprimento n = 2m − 1, para quaisquer inteiros
positivos m ≥ 3 e t < 2m − 1.

O código BCH binário deﬁnido acima é gerado por um polinômio que é especiﬁcado

em termos de suas raízes no corpo ﬁnito F2m. Isto nos conduz à seguinte deﬁnição.

Deﬁnição 3.4.2. Sejam o corpo ﬁnito F2m e α um elemento primitivo de F2m. Seja
minαi(x) o polinômio mínimo de αi. O polinômio gerador g(x) do código BCH binário
de comprimento n = 2m −1 com capacidade de correção de t erros é o polinômio de menor
grau de Z2[x], que tem como raízes os elementos

α, α2, . . . , αi, . . . , α2t

(25)

Então, g(x) deve ser o mínimo múltiplo comum de minα1(x), minα2(x), . . . , minα2t, ou
seja,

g(x) = MMC(minα1(x), minα2(x), . . . , minα2t(x)).

(26)

Em (25), se i ∈ Z é par, então pode ser expresso como um produto da seguinte

62

forma: i = j · 2l, onde j ∈ Z é ímpar e l ≥ 1 ∈ Z. Logo, αi = (αj)2l é um conjugado de
αj e, portanto, αi e αj têm o mesmo polinômio mínimo, ou seja,

minαi = minαj .

Como resultado, cada potência par de α tem o mesmo polinômio mínimo de alguma
potência ímpar de α precedente na mesma sequência. Consequentemente, o polinômio
gerador g(x) de um código BCH binário de comprimento n = 2m − 1 com capacidade de
correção de t erros dado por (26) pode ser reduzido para

g(x) = mmc(minα1(x), minα3(x), . . . , minα2t−1(x)).

(27)

Como o grau de cada polinômio mínimo é menor ou igual a m, então temos que

gr(g(x)) = n − k ≤ mt.

De acordo com (LIN; DANIEL, 1983), não existe uma fórmula simples para a enumeração
de n−k, mas para valores pequenos de t, n−k é exatamente igual a mt. Na tabela 7 estão
indicados os parâmetros de todos os códigos BCH binários de comprimento n = 2m − 1,
com m ≤ 5.

Tabela 7 - Parâmetros dos códigos BCH(n, k) binários para 3 ≤ m ≤ 5

Código

BCH(7,4)
BCH(15,11)
BCH(15,7)
BCH(15,5)
XXXXX

n = 2m − 1
7

Parâmetros
k
4
11
7
5
X X

15

X

Código

t
1 BCH(31,26)
1 BCH(31,21)
2 BCH(31,16)
3 BCH(31,11)
BCH(31,6)

n = 2m − 1

Parâmetros
k
26
21
16
11
6

31

t
1
2
3
5
6

Fonte: O autor, com informações extraídas de (LIN; DANIEL, 1983), 2019

Observação 3.4.3. Em algumas situações, utilizaremos a notação BCH(n, k) para nos
referirmos a um código BCH de comprimento n = 2m − 1 com capacidade de correção de
t erros.

De (27) podemos observar que um código BCH binário de comprimento n = 2m −1

com capacidade de correção de um erro é gerado pelo polinômio

g(x) = minα(x),

63

e

minα(x) = minα2t−1(x).

Observação 3.4.4. De acordo com a Deﬁnição 3.4.2, α é um elemento primitivo de F2m.
Logo, minα(x) é um polinômio primitivo de grau m. Portanto, um código BCH binário
de comprimento n = 2m − 1 com capacidade de correção de um erro é um código de
Hamming.

Exemplo 3.4.5. Consideremos o corpo ﬁnito F23 gerado por p(x) = 1 + x + x3 e dado
pela tabela 4 (página 31). Seja α um elemento primitivo de F23. Da tabela 5 (página 35),
obtemos o polinômio mínimo de α que é

minα(x) = 1 + x + x3.

De (27) veriﬁcamos que o código BCH binário de comprimento n = 23 − 1 = 7 com
capacidade de correção de um erro é gerado por

ou seja

Então, temos que

g(x) = mmc(minα(x)),

g(x) = minα(x).

g(x) = 1 + x + x3.

Portanto, de acordo com a tabela 7, o código acima é um código BCH(7,4) binário, que
tem distância mínima maior ou igual a 3. Como o polinômio gerador g(x) tem peso
3, a distância mínima deste código BCH binário é exatamente 3. Além disso, o código
BCH(7,4) binário é o código cíclico C(7,4) binário dado pela tabela 6 (página 58). Isto
porque, este código cíclico atende às condições da Deﬁnição 3.4.1 e ambos os códigos
citados possuem o mesmo polinômio gerador g(x) = 1 + x + x3.

De acordo com as deﬁnições 3.4.1 e 3.4.2, o polinômio gerador g(x) de um código
BCH binário de comprimento n = 2m − 1 com capacidade de correção de t erros possui
como raízes, os elementos α, α2, . . . , α2t e seus conjugados. Com isso, podemos veriﬁcar se
um determinado polinômio pertence a um código BCH binário. Para tanto, consideremos
o polinômio v(x) = v0 + v1x + · · · + vn−1xn−1 ∈ Z2[x]. Se os elementos α, α2, . . . , α2t
são as raízes de v(x), então, pelo Teorema 2.4.9, v(x) é divisível pelos polinômios míni-
mos minα(x), minα2(x), . . . , minα2t(x). E, consequentemente, v(x) é divisível pelo MMC
desses polinômios, que é polinômio gerador g(x) do código BCH binário de comprimento
n = 2m − 1 com capacidade de correção de t erros, dado por (26). Portanto, v(x) pertence
ao código BCH binário. Isso nos conduz às seguintes deﬁnições.

64

Deﬁnição 3.4.6. Sejam o corpo ﬁnito F2m e o polinômio v(x) = v0+v1x+· · ·+vn−1xn−1 ∈
Z2[x]. Se o polinômio v(x) pertence a um código BCH binário de comprimento 2m − 1
com capacidade de correção de t erros, então v(x) é um polinômio código.

Conforme mencionado no capítulo 1, um polinômio p(x) = a0 + a1x + a2x2 + · · · +
anxn pode ser expresso como uma n-upla, da seguinte forma: p = (a0, a1, a2, . . . , an). Esta
representação vetorial de um polinômio será utilizada na próxima deﬁnição e em outras
partes desta seção.

Deﬁnição 3.4.7. Sejam o corpo ﬁnito F2m, o polinômio v(x) = v0 +v1x+· · ·+vn−1xn−1 ∈
Z2[x] e os elementos α, α2, . . . , α2t ∈ F2m. A n-upla binária v = (v0, v1, . . . , vn−1) é uma
palavra código se, e somente se, os elementos α, α2, . . . , α2t são as raízes do polinômio
v(x).

Seja v(x) um polinômio código de um código BCH binário de comprimento n =
2m − 1 com capacidade de correção de t erros. Seja αi uma raiz de v(x). Então, para
i = 1, . . . , 2t, temos que

v(αi) = v0 + v1αi + v2α2i + · · · + vn−1α(n−1)i = 0

(28)

Esta igualdade pode ser escrita como o seguinte produto de matrizes

[v0, v1, . . . , vn−1] ·















1

αi

α2i
...
α(n−1)i















= 0

(29)

para i = 1, . . . , 2t, e onde (v0, v1, . . . , vn−1) é a representação vetorial de v(x). Em (29),
temos a condição de que o produto interno de (v0, v1, . . . , vn−1) por α, α2, . . . , α2t é igual
a zero.

Consideremos a seguinte matriz de ordem 2t × n

H =















1

α

α2

α3

1 (α2)

(α2)2

(α2)3

1 (α3)
...
...
1 (α2t)

(α3)2
...
(α2t)2

(α3)3
...
(α2t)3

· · ·

· · ·

· · ·

· · ·















.

αn−1

(α2)n−1

(α3)n−1
...
(α2t)n−1

(30)

De acordo com (29), se v = (v0, v1, . . . , vn−1) é uma palavra código de um código BCH

binário de comprimento n = 2m − 1 com capacidade de correção de t erros, então

v · H T = 0.

65

(31)

Se uma n-upla v = (v0, v1, . . . , vn−1) satisfaz a condição da igualdade (31), segue de (28)
e (29), que αi é uma raiz do polinômio v(x), para i = 1, . . . , 2t. Neste caso, v deve ser uma
palavra código de um código BCH binário de comprimento n = 2m − 1 com capacidade
de correção de t erros. Consequentemente, o produto em (31) é o vetor nulo do código.
E a matriz H é a matriz teste de paridade do código. Se para algum i e j, temos que αi
é um conjugado de αj, então, de acordo com o Teorema 2.4.2, v(αj) = 0 se, e somente se,
v(αi) = 0. Assim sendo, se o produto interno de v = (v0, v1, . . . , vn−1) e a i-ésima linha
da matriz H é zero, então o produto interno de v = (v0, v1, . . . , vn−1) e a j-ésima linha da
matriz H também é zero. Logo, a j-ésima linha da matriz H pode ser omitida e a matriz
H dada em (30) pode ser reduzida a uma matriz de ordem t × n, da seguinte forma:

H =















1

1

α

α2

α3

(α3)

(α3)2

(α3)3

(α5)
1
...
...
1 (α2t−1)

(α5)2
...
(α2t−1)2

(α5)3
...
(α2t−1)3

· · ·

· · ·

· · ·

· · ·

αn−1

(α3)n−1

(α5)n−1
...
(α2t−1)n−1















.

(32)

Notemos que as entradas da matriz H são elementos do corpo ﬁnito F2m. Cada elemento de
F2m pode ser representado por uma m-upla sobre Z2. Se cada entrada de H é substituída
por sua correspondente m-upla sobre Z2 e colocada na forma de coluna, obtemos uma
matriz binária de teste de paridade do código.

Exemplo 3.4.8. Consideremos o código BCH(7,4) binário com capacidade de correção
de 1 erro, dado no Exemplo 3.4.5. Seja α um elemento primitivo do corpo ﬁnito F23.
Então, a matriz teste de paridade deste código BCH binário é

(cid:20)

H =

1 α α2 α3 α4 α5 α6

(cid:21)

.

Agora, vamos utilizar essa matriz H para veriﬁcarmos se a palavra v = (1, 1, 1, 1, 1, 1, 1)
é uma palavra código. Isto é, se v pertence ao código BCH(7,4) binário com capacidade
de correção de 1 erro. Para tanto, usaremos os valores da tabela 4, que se encontra na

página 31. Efetuando o produto de v e H t, temos

66

[1, 1, 1, 1, 1, 1, 1] ·






















1

α

α2

α3

α4

α5

α6






















= 1 + α + α2 + α3 + α4 + α5 + α6 = α3 + α4 + α6 = 0.

Como o resultado foi o vetor nulo, então a identidade (31) foi veriﬁcada. Portanto,
v = (1, 1, 1, 1, 1, 1, 1) pertence ao código BCH(7,4) binário.

Observação 3.4.9. A distância mínima d de um código BCH binário de comprimento
n = 2m − 1 com capacidade de correção de t erros é maior ou igual a 2t + 1. A prova
desta aﬁrmação pode ser veriﬁcada em (LIN; DANIEL, 1983, pp. 148–150).

A observação acima nos conduz a deﬁnição de um novo parâmetro, conforme a

seguir.

Deﬁnição 3.4.10. Seja um código BCH binário de comprimento n = 2m − 1 com capa-
cidade de correção de t erros. O parâmetro 2t + 1 é chamado de distância projetada
d0 de um código BCH binário.

Na realidade, a distância mínima de um código BCH binário pode ser ou não igual

a distância projetada.

Veremos agora, uma deﬁnição mais geral de código BCH binário.

Deﬁnição 3.4.11. Sejam o corpo ﬁnito F2m, o elemento β ∈ F2m e l0 ≥ 0 ∈ Z. Um
código BCH binário com distância projetada d0 é gerado pelo polinômio binário
g(x) de grau mínimo que tem como raízes as seguintes potências consecutivas de β:

β(l0), β(l0+1), . . . , β(l0+d0−2)

Para i = 0, . . . , d0 − 1, sejam o polinômio mínimo minβ(l0+i)(x) de β(l0+i) e ni a ordem de
β(l0+i). Então

g(x) = mmc(minβ(l0)(x), minβ(l0+1)(x), . . . , minβ(l0+d0−2)(x))

e o comprimento do código é

n = mmc(n0, n1, . . . , nd0−2).

67

Observação 3.4.12. O código BCH binário deﬁnido acima tem distância mínima maior
ou igual a d0 e, no máximo, m(d0 − 1) dígitos de veriﬁcação de paridade. Então, esse
código BCH binário possui capacidade de corrigir até [(d0 − 1)/2] erros. Caso l0 = 1,
d0 = 2t + 1 e se β é um elemento primitivo de um corpo ﬁnito F2m, temos um código
BCH primitivo binário de comprimento n = 2m − 1 com capacidade de correção de t
erros . Se ﬁzermos: l0 = 1, d0 = 2t + 1 e se β não é um elemento primitivo de um corpo
ﬁnito F2m, temos um código BCH não primitivo binário com capacidade de correção
de t erros e de tamanho n que é a ordem do elemento β. Neste texto, trabalharemos
apenas com códigos BCH primitivos binários.

Observemos que, na Deﬁnição 3.4.11, foi exigido que o polinômio gerador g(x) do
código tenha d0 − 1 potências consecutivas do elemento β como raízes. Essa exigência
garante que a distância mínima do código BCH binário assim deﬁnido seja maior ou igual
a d0. Desta forma, d0 é um limite inferior para a distância mínima do código BCH binário
e é denominado de BCH bound.

Apresentaremos a seguir o processo de decodiﬁcação dos códigos BCH binários,

que é similar ao da decodiﬁcação de códigos lineares mostrado na seção 3.3.

Suponhamos que uma palavra código vt = (v0, v1, . . . , vn−1) seja transmitida, e
que os erros introduzidos pelo canal durante a sua transmissão tenham gerado a seguinte
palavra recebida

vr = (r0, r1, . . . , rn−1).

Consideremos as representações polinomiais da palavra código transmitida vt e da palavra
recebida vr como sendo, respectivamente, os polinômios vt(x) = vt0 + vt1x + · · · + vtn−1xn−1
e vr(x) = vr0 + vr1x + · · · + vrn−1xn−1. Seja ve o padrão de erro introduzido pelo canal,
cuja representação polinomial é ve(x), então temos que

vr(x) = vt(x) + ve(x).

(33)

O primeiro passo do processo de decodiﬁcação de um código BCH binário com capacidade
de correção de t erros é o calculo da síndrome do vetor recebido vr (ou vr(x)). E nesse
processo de decodiﬁcação, essa síndrome é uma 2t-upla como a seguir

S = (S1, S2, . . . , S2t) = vr · H T ,

(34)

onde H é a matriz teste de paridade dada por (30). De (30) e (34), temos que a síndrome
Si do i-ésimo componente é dada por

Si = vr(αi) = vr0 + vr1αi + vr2α2i + · · · + vrn−1α(n−1)i

(35)

para i = 1, . . . , 2t. Podemos observar que as componentes da síndrome são elementos

68

do corpo ﬁnito F2m. Essas componentes podem ser calculadas a partir de vr(x), como
mostraremos a seguir.

Dividindo vr(x) pelo polinômio mínimo minαi(x) de αi, obtemos

vr(x) = ai(x) · minαi(x) + bi(x),

onde bi(x) é o resto dessa divisão e possui grau menor que minαi(x). Como minαi(αi) = 0,
temos que

Si = vr(αi) = bi(αi).

(36)

Logo, a síndrome Si do i-ésimo componente é obtida substituindo-se x por αi em bi(x).

Exemplo 3.4.13. Consideremos o código BCH(7,4) binário com capacidade de cor-
reção de um erro dado no Exemplo 3.4.5. Suponhamos que a palavra código vt =
(0, 0, 0, 0, 0, 0, 0) foi transmitida por um canal de comunicação. E que, por causa de
algum ruído durante essa transmissão, foi recebida a palavra vr = (0, 1, 0, 0, 0, 0, 0). O
polinômio correspondente a vr é

vr(x) = x.

A síndrome consiste de 2 componentes, pois para t = 1, 2t = 2 . Então, temos que

S = (S1, S2).

De acordo com a tabela 5 (página 35), os polinômios mínimos de α e α2 são iguais e,
portanto, temos minα(x) = minα2(x) = 1 + x + x3. Dividindo vr(x) = x por minα(x) =
1 + x + x3, obtemos o resto

b1(x) = x.

Usando os valores do corpo ﬁnito F23 dados pela tabela 4 (página 31) e substituindo α e
α2 em b1(x), obtemos

S1 = b1(α) = α

e

S2 = b1(α2) = α2.

Portanto, a síndrome procurada é

S = (α, α2).

Os componentes dessa síndrome também podem ser obtidos substituindo-se α e α2 em
vr(x) = x, de acordo com (35). Então, dessa forma, temos que

S1 = vr(α) = α

e

S2 = vr(α2) = α2.

69

Logo, a síndrome procurada é

S = (α, α2).

Como α, α2, . . . , α2t são as raízes de cada polinômio código, então vt(αi) = 0 para
i = 1, . . . , 2t. De (33) e (35) obtemos a seguinte relação entre os componentes Si da
síndrome e o padrão de erro:

Si = ve(αi)

(37)

para i = 1, . . . , 2t. Notemos que, de acordo com (37), a síndrome S depende apenas
do padrão de erro. Suponhamos que o padrão de erro ve(x) tenha w erros nas posições
xj1, xj2, . . . , xjw. Isto é,

e(x) = xj1 + xj2 + · · · + xjw,

(38)

onde 0 ≤ j1 < j2 < · · · < jw < n. De (37) e (38) obtemos o seguinte conjunto de equações:






S1 = αj1 + αj2 + · · · + αjw
S2 = (αj1)2 + (αj2)2 + · · · + (αjw)2
S3 = (αj1)3 + (αj2)3 + · · · + (αjw)3
...
S2t = (αj1)2t + (αj2)2t + · · · + (αjw)2t,

(39)

onde αj1, αj2, . . . , αjw são desconhecidos.

Observação 3.4.14. Qualquer método para a solução do sistema de equações (39) é um
algoritmo de decodiﬁcação dos códigos BCH.

As potências j1, j2, . . . , jw indicam as posições dos erros no padrão de erro e(x)
como em (38), ao serem encontrados os valores de αj1, αj2, . . . , αjw. De um modo geral, o
sistema de equações (39) tem muitas soluções possíveis. E cada solução gera um padrão
de erro diferente. Então, entre as soluções cujo padrão de erro e(x) possui um número
de erros menor ou igual a t, a solução correta é a que tem o menor número de erros. Ou
seja, o padrão de erro correspondente à esta solução é o mais provável padrão de erro e(x)
causado pelo ruído do canal de comunicação. Para valores grandes de t, calcular uma
solução direta para o sistema de equações (39) é difícil e ineﬁcaz.

Apresentaremos a seguir, o algoritmo de Peterson (3) (citado em (LIN; DANIEL,
1983)), que é um procedimento eﬁcaz para a determinação de αjl, para l = 1, . . . , w, dos
componentes Sl da síndrome.

Nosso objetivo será apenas apresentar o algoritmo sem entrarmos em detalhes sobre
sua fundamentação matemática, a qual envolve conhecimentos que fogem do escopo deste

trabalho. Para mais informações, consultar <http://www.professores.uﬀ.br/nmedeiros/
wp-content/uploads/sites/88/2017/08/Algebra-III-2016_2-galois.pdf>.

70

Algoritmo 3 - Algoritmo de Peterson

Para l = 1, . . . , w, seja

θl = αjl

(40)

Estes elementos são chamados de números de localização de erros, pois eles indicam
as posições dos erros. Então, o sistema de equações (39) pode ser escrito da seguinte
forma:






S1 = θ1 + θ2 + · · · + θw
2 + · · · + θ2
1 + θ2
S2 = θ2
w
...
S2t = θ2t

1 + θ2t

2 + · · · + θ2t
w .

Consideremos o seguinte polinômio

σ(x) = (1 + θ1x)(1 + θ2x) · . . . · (1 + θwx)

= σ0 + σ1x + σ2x2 + · · · + σwxw.

(41)

(42)

As raízes de σ(x) são os inversos dos números de localização de erros: θ−1
2 , . . . , θ−1
w .
Por esta razão, o polinômio σ(x) é chamado de polinômio localizador de erros. Ob-
servemos que σ(x) é um polinômio desconhecido com coeﬁcientes que precisam ser deter-
minados. Os coeﬁcientes de σ(x) e os números de localização de erros estão relacionados
pelo seguinte sistema de equações:

1 , θ−1






σ0 = 1

σ1 = θ1 + θ2 + · · · + θw

σ2 = θ1θ2 + θ2θ3 + · · · + θw−1θw
...
σw = θ1θ2 · . . . · θw.

(43)

De (41) e (43) vemos que os σi’s se referem às componentes Si da síndrome. Essa relação

está indicada nas seguintes identidades:

S1 + σ1

S2 + σ1S1 + 2σ2

= 0

= 0

S3 + σ1S2 + σ2S1 + 3σ3
...
Sw + σ1Sw−1 + · · · + σw−1S1 + wσw = 0

= 0

Sw+1 + σ1Sw + · · · + σw−1S2 + σwS1 = 0

Para o caso binário, como 1 + 1 = 2 = 0, temos que

iσi =






σi para i ímpar

0

para i par.

71

(44)

(45)

Portanto, ao aplicarmos as alterações de (45) nas identidades (44), temos que as iden-
tidades dos componentes de ordem par não estabelecem relações entre os σi’s com os
componentes Si’s da síndrome. Logo, o sistema (44) resulta em:

S1 + σ1

S3 + σ1S2 + σ2S1 + σ3

= 0

= 0

S5 + σ1S4 + σ2S3 + σ3S2 + σ4S1 + σ5 = 0
...

que é um sistema de 2t

2 = t identidades.

(46)

Suponhamos que seja possível determinar as funções elementares σ1, σ2, . . . , σw
das equações (44). Então, os números de localização de erros θ1, θ2, . . . , θw podem ser
encontrados pela determinação das raízes do polinômio localizador de erros σ(x). As
equações (44) possuem muitas soluções possíveis. Entretanto, a solução será aquela que
gerar um σ(x) de grau mínimo. Este polinômio σ(x) produzirá um padrão de erro com
um número mínimo de erros. Se w ≤ t, o polinômio σ(x) fornecerá o verdadeiro padrão
de erro.

Basicamente, o algoritmo de Peterson (3) pode ser resumido em 3 passos principais:

1) Calcular a síndrome S = (S1, S2, . . . , S2t) a partir do polinômio recebido vr(x);
2) Determinar o polinômio localizador de erros σ(x) dos componentes S1, S2, . . . , Sw da
síndrome;
3) Determinar os números localizadores de erros θ1, θ2, . . . , θw, através das raízes de σ(x)
e corrigir os erros em vr(x).

Observação 3.4.15. Os passos 1 e 3 são simples. Por outro lado, o passo 2 é o mais
complicado da decodiﬁcação de códigos BCH binários.

72

Exemplo 3.4.16. Consideremos o código BCH(7,4) binário com capacidade de correção
de 1 erro dado no Exemplo 3.4.5. Suponhamos que a palavra código vt = (0, 0, 0, 0, 0, 0, 0)
foi transmitida por um canal de comunicação. Mas, por causa de algum ruído no canal,
foi recebida a palavra vr = (0, 0, 0, 1, 0, 0, 0) . O polinômio correspondente a palavra vr é

vr(x) = x3.

Como o código é binário usaremos as identidades do sistema (46). Logo, da primeira
identidade desse sistema, obtemos a igualdade

S1 = σ1.

Além disso, pelo fato de o código BCH(7,4) binário ter capacidade de correção de 1 erro,
a síndrome tem apenas um componente, então, temos que

e o polinômio localizador de erros, dado por (42), ﬁca

S = (S1),

Então, calculando S1 temos que

σ(x) = 1 + σ1x.

S1 = vr(α) = α3.

E o polinômio localizador de erros para esse caso é

σ(x) = 1 + σ1x = 1 + α3x.

Calculando as raízes de σ(x) temos que

σ(1) = 1 + α3 = α

σ(α) = 1 + α3 · α = 1 + α4 = α5

σ(α2) = 1 + α3 · α2 = 1 + α5 = α4

σ(α3) = 1 + α3 · α3 = 1 + α6 = α2

σ(α4) = 1 + α3 · α4 = 1 + α7 = 1 + 1 = 0

σ(α5) = 1 + α3 · α5 = 1 + α8 = 1 + α = α3

σ(α6) = 1 + α3 · α6 = 1 + α9 = 1 + α2 = α6

Observamos que α4 é raiz do polinômio localizador de erros σ(x) = 1 + σ1x = 1 + α3x.

73

A posição do erro é o inverso da raiz α4. Então, temos que

θ1 =

1
α4 = α−4 = α3.

Portanto, o padrão de erro é ve(x) = x3 e temos que a palavra transmitida foi

vt(x) = ve(x) + vr(x) = x3 + x3 = 0,

que é o polinômio identicamente nulo correspondente a palavra vt = (0, 0, 0, 0, 0, 0, 0).

No Exemplo 3.4.16 foi utilizado o código BCH(7,4) binário com capacidade de
correção de 1 erro. Porém, existem situações em que ocorrem mais de um erro. Veremos
a seguir um exemplo que ilustra como é feita a correção de 2 erros, usando um código
BCH binário.

Exemplo 3.4.17. Consideremos o corpo ﬁnito F24, gerado por p(x) = 1 + x + x4, dado
pela tabela 8.

Tabela 8 - Representações dos elementos de
F24, gerado por p(x) = 1 + x + x4

Potência
0
1
α
α2
α3
α4
α5
α6
α7
α8
α9
α10
α11
α12
α13
α14

Polinômio
0
1
α
α2
α3
1 + α
α + α2
α2 + α3
1 + α + α3
1 + α2
α + α3
1 + α + α2
α + α2 + α3
1 + α + α2 + α3
1 + α2 + α3
1 + α3

Fonte: (LIN; DANIEL, 1983)

Vetor
(0 0 0 0)
(1 0 0 0)
(0 1 0 0)
(0 0 1 0)
(0 0 0 1)
(1 1 0 0)
(0 1 1 0)
(0 0 1 1)
(1 1 0 1)
(1 0 1 0)
(0 1 0 1)
(1 1 1 0)
(0 1 1 1)
(1 1 1 1)
(1 0 1 1)
(1 0 0 1)

Consideremos agora os polinômios mínimos de F24, gerado por p(x) = 1 + x + x4,

dados pela tabela 9.

74

Tabela 9 - Polinômios mínimos dos elementos
de F24 gerado por p(x) = 1 + x + x4

Raízes conjugadas Polinômios mínimos

0
1
α, α2, α4, α8
α3, α6, α9, α12
α5, α10
α7, α11, α13, α14

x
x + 1
x4 + x + 1
x4 + x3 + x2 + x + 1
x2 + x + 1
x4 + x3 + 1

Fonte: (LIN; DANIEL, 1983)

Sejam α e α3 dois elementos primitivos de F24. Da tabela 9, obtemos o polinômio

mínimo desses elementos, que são os seguintes:

minα(x) = 1 + x + x4

e minα3(x) = 1 + x + x2 + x3 + x4.

De (27) veriﬁcamos que o código BCH com capacidade de correção de dois erros e com-
primento n = 24 − 1 = 15 é gerado por

g(x) = MMC(minα(x), minα3(x)),

ou seja

Então, temos que

g(x) = (1 + x + x4)(1 + x + x2 + x3 + x4).

g(x) = 1 + x4 + x6 + x7 + x8.

Logo, de acordo com a tabela 7 (página 62), o código acima é o código BCH(15,7) binário,
que tem distância mínima maior ou igual a 5. Como o polinômio gerador g(x) tem peso
5, a distância mínima deste código é 5.

Suponhamos que a palavra código vt = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) tenha
sido transmitida por um canal de comunicação e que, por causa de alguma interferência
neste canal, a palavra código recebida foi vr = (1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0). O
polinômio correspondente desta palavra código é

vr(x) = 1 + x.

Como estamos trabalhando com o código BCH(15,7) binário, devemos calcular as seguin-

75

tes síndromes, usando os valores da tabela 8 e considerando que α15 = 1:

S1 = vr(α) = 1 + α e S3 = vr(α3) = 1 + α3.

Usando as identidades do sistema (46), obtemos

σ1 = 1 + α e σ2 = α.

E o polinômio localizador de erros é

σ(x) = 1 + (1 + α)x + αx2.

σ(1) = 1 + (1 + α) · 1 + α · 12 = 0

Efetuando os cálculos

e

σ(α14) = 1 + (1 + α) · α14 + α · (α14)2 = 1 + α14 + α15 + α29 = 0,

veriﬁcamos que as raízes de σ(x) são os elementos 1 e α14. Como as posições dos erros
são os inversos dessas raízes, temos que

θ1 =

1
1

= 1 e

θ2 =

1
α14 = α−14 = α,

e os erros estão nas posições 1 e x. Portanto, o padrão de erro é ve(x) = 1 + x e a palavra
transmitida foi

vt(x) = ve(x) + vr(x) = 1 + x + 1 + x = 0,

que corresponde ao vetor vt = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0).

CONCLUSÃO

76

Em nossa prática docente como professores de Matemática, vemos que é comum
os alunos questionarem sobre a necessidade de estudarem esta disciplina e quais são as
aplicações dos conteúdos matemáticos vistos por eles. Isso também é observado quando
ensinamos polinômios e funções polinomiais na Escola Básica. Os exemplos que apresen-
tamos em sala de aula, tais como: trajetórias de projéteis, expressões de áreas ou alguns
modelos de fenômenos naturais, entre outros, envolvem expressões polinomiais cujos coeﬁ-
cientes são números reais ou complexos. No entanto, conforme comentamos na introdução
deste texto, podemos ter polinômios que não usam tais conjuntos, como é o caso daqueles
que ocorrem em Criptograﬁa, mais precisamente em alguns tipos de códigos corretores de
erros.

Estes tipos de códigos foram criados com o propósito de tratarem da segurança da
informação, tanto no armazenamento como na transmissão de dados e são cada vez mais
usados no nosso dia-a-dia. Neste texto, escolhemos abordar códigos corretores de erros
BCH que trabalham sobre Corpos Finitos. Mostramos de maneira direta e objetiva e por
meio de vários exemplos, como os polinômios são utilizados nesses códigos. Fizemos isso
de uma forma que não fosse muito aprofundada, mas nem por isso, superﬁcial.

Além de polinômios, abordamos, de forma direta ou indireta, outros conteúdos
matemáticos essenciais para o estudo desses códigos corretores de erros, tais como: anéis,
corpos, transformação linear, matrizes, vetores e aritmética modular. Dessa maneira,
trouxemos uma aplicação de polinômios vinculada a um tema da atualidade (segurança
da informação) e provavelmente do futuro; um assunto estudado nas aulas de Matemática
e que é usado diariamente por todos que acessam à internet, assistem TV digital, usam
celular, entre outras tecnologias.

REFERÊNCIAS

77

ARAGÃO, Canuto Ruan Santos. Códigos cíclicos: uma introdução aos códigos corretores
de erros. Universidade Federal de Sergipe, 2017.

BERLEKAMP, Elwyn R. Algebraic coding theory-revised edition. World Scientiﬁc
Publishing Co., Inc., 2015.

BIAZZI, Ricardo Neves. Polinômios irredutíveis: critérios e aplicações. Universidade
Estadual Paulista (UNESP), 2014.

BOLDRINI, José Luiz et al. Álgebra linear. [S.l.]: Harper & Row, 1980.

CARVALHO, Sézani Morais de. Matrizes, determinantes e polinômios: aplicações
em códigos em corretores de erros, como estratégias motivacional para o ensino de
matemática. 2014.

COUTINHO, M. Corpos ﬁnitos e códigos corretores de erros. Juiz de Fora: Universidade
Federal de Juiz de Fora, 2014.

HEFEZ, Abramo. Curso de algebra, vol. 1. Coleção Matemática Universitária,
IMPA/CNPq, RJ, 1993.

HEFEZ, Abramo; VILLELA, Maria Lúcia. Códigos Corretores de Erros. 2. ed. Rio de
Janeiro: IMPA, 2017.

IEZZI, Gelson. Fundamentos de matemática elementar: complexos, polinômios, equações.
[S.l.]: Atual, 2005.

LIN, Shu; DANIEL, Costello. COSTELLO. Error Control Coding: Fundamentals and
Applications. [S.l.]: Prentice-Hall, Englewood Cliﬀs, NJ, 1983.

MILIES, César Polcino. Breve introdução à teoria dos códigos corretores de
erros. Colóquio de Matemática da Região Centro-Oeste, 2009. Disponível em:
<https://www.sbm.org.br/docs/coloquios/NE-1.04.pdf>. Acesso em: 10 mar 2018.

NICOLETTI, Everton Rodrigo. Aplicações de ágebra linear aos códigos corretos de erros
e ao ensino médio. Universidade Estadual Paulista (UNESP), 2015.

STALLINGS, William. Criptograﬁa e segurança de redes, tradução Vieira, Daniel. [S.l.]:
São Paulo. Pearson Prentice Hall, 2008.

