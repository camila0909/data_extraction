UNIVERSIDADE FEDERAL DA PARAÍBA
CENTRO DE CIÊNCIAS EXATAS E DA NATUREZA
MESTRADO PROFISSIONAL EM MATEMÁTICA
EM REDE NACIONAL - PROFMAT

Teoria dos números e Criptograﬁa
RSA

por

Wélisson Martins Mota

2023

UNIVERSIDADE FEDERAL DA PARAÍBA
CENTRO DE CIÊNCIAS EXATAS E DA NATUREZA
MESTRADO PROFISSIONAL EM MATEMÁTICA
EM REDE NACIONAL - PROFMAT

Teoria dos números e Criptograﬁa
RSA †

por

Wélisson Martins Mota

sob a orientação do

Prof. Dr. José Laudelino de Menezes Neto

Dissertação apresentada ao Corpo Docente
do Mestrado Proﬁssional em Matemática em
Rede Nacional - PROFMAT/CCEN/UFPB,
como requisito parcial para a obtenção do
título de Mestre em Matemática.

Fevereiro/ 2023
João Pessoa - PB

†O presente trabalho foi realizado com apoio da CAPES, Coordenação de Aperfeiçoamento de

Pessoal de Nível Superior.

Agradecimentos

Gostaria de agradecer a todos que de forma direta ou indiretamente me deram

forças para concluir essa jornada.

iv

Dedicatória

A minha mãe Ana Maria e meu pai
João Bosco

v

Resumo

Neste trabalho, fazemos uma abordagem de alguns conceitos básicos de teoria
dos números visando o entendimento dos modelos de criptograﬁa. Apresentamos
inicialmente tópicos de divisibilidade, congruências, números primos e funções
fazemos um breve estudo sobre criptograﬁa, com
aritméticas.
ênfase no sistema RSA (Rivest-Shamir-Adleman). Após o estudo de criptograﬁa,
apresentamos duas propostas de atividades a serem desenvolvidas em sala de aula
que abordam criptograﬁa com função aﬁm e congruência de números inteiros.

Em seguida,

Palavras-chaves: Teoria dos Números; Criptograﬁa; Ensino.

vi

Abstract

In this work, we approach some basic concepts of number theory in order
to understand cryptography models. We initially present topics of divisibility,
congruences, prime numbers and arithmetic functions, then we make a brief study on
cryptography, with emphasis on the RSA system (Rivest-Shamir-Adleman). After
the study of cryptography, we present two proposals for activities to be developed
in the classroom that address cryptography with linear function and congruence of
integers.

Key-words: Number Theory; Cryptography ; Teaching

vii

Sumário

Introdução

1

1 Conceitos básicos de divisibilidade e números primos

3
3
1.1 Divisibilidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.1.1 Algoritmo da divisão e Algoritmo Euclidiano . . . . . . . . . .
1.2 Números primos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.2.1 Alguns critérios de divisibilidade . . . . . . . . . . . . . . . . 15
. . . . . . . . . . . . . . . . . . 17
1.2.2 Encontrando números primos

2 Aritmética dos restos

22
2.1 Congruências
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2 Classes de resíduos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3 Funções aritméticas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.3.1 A função τ (n): número de divisores positivos de n . . . . . . . 28
2.3.2 A função σ(n): soma dos divisores positivos de n . . . . . . . 28
2.3.3 A função π(n): número de primos menores ou iguais a n . . . 29
. . . . . . . . . . . . . . . 30
2.3.4 A função φ(n): função φ de Euler

3 Criptograﬁa

31
3.1
Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.2 Um sistema de criptograﬁa simétrico com Função Aﬁm . . . . . . . . 33
3.3 O RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.4 Variação do RSA (codiﬁcando palavras em palavras)
. . . . . . . . . 40
3.5 Comentários acerca das duas variações do RSA . . . . . . . . . . . . 42

4 Sugestões de atividades para sala de aula

4.1 Criando um modelo de Criptograﬁa Simples
4.2

Implementando um modelo de criptograﬁa com função aﬁm no
Construct

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.3 Comentário sobre as aplicações feitas em sala de aula . . . . . . . . . 46

43
. . . . . . . . . . . . . . 43

Referências Bibliográﬁcas

50

viii

Introdução

Neste trabalho realizamos um estudo de teoria dos números e sua aplicação em
modelos de criptograﬁa, buscando atrelar isso ao ensino de matemática, visando
levar curiosidades e tecnologia para sala de aula.

No capítulo 1 resgatamos alguns conceitos de divisibilidade, apresentando
algorítimos fundamentais sobre divisibilidade e fazendo uma checagem sobre o
processo de busca de números primos, o que é a chave do sucesso do sistema
criptográﬁco RSA (Rivest-Shamir-Adleman). Um tópico interessante deste capítulo
é o Teorema 1.6 que nos ensina a gerar critérios de divisibilidade para qualquer
número primo,
isso é interessante pois também pode ser adaptado para o uso
em sala de aula, evitando assim o "decoreba"(ato de decorar várias fórmulas ou
procedimentos).

Abordamos a aritmética dos restos no segundo capítulo, apresentando o conceito
de congruências de números inteiros e quatro funções aritméticas particularmente
interessantes. As funções τ (n) e σ(n) que tratam respectivamente da quantidade
e da soma dos divisores positivos de um número inteiro, a função π(n) que estuda
a frequência dos números primos e a famosa função φ(n) (Função de Euler) que
é fundamental para os sistemas de criptograﬁa RSA. Vale ressaltar que as duas
primeiras funções podem ser aplicadas no ensino médio atreladas ao estudo das
progressões geométricas e análise combinatória, as mesmas já foram abordadas
em algumas questões da Olimpíada Brasileira de Matemática das Escolas Públicas
(OBMEP).

No capítulo 3 estudamos sobre criptograﬁa. Abordamos um pouco do contexto
histórico da criptograﬁa, apresentamos um sistema simétrico simples fazendo o uso
de função aﬁm e o sistema assimétrico RSA em duas formas, a primeira visa
codiﬁcação de letras em números e a segunda letras em letras. O processo é
essencialmente o mesmo em ambos, com nível de segurança se bem aplicados. A
escolha do qual usar ﬁca a critério do gosto de linguagem a ser ser usada, só números?
ou letras? qual o menos trabalhoso para minha perspectiva de uso?

No capítulo 4 apresentamos duas aplicações do estudo de criptograﬁa em sala
de aula, tratam-se de dois planos de aula para primeira e segunda séries do ensino
médio. O primeiro plano trata da construção de um sistema de criptograﬁa simples
utilizando função aﬁm, o segundo plano acrescenta o conceito de congruência de

1

números inteiros e cria um pequeno programa como forma de aplicação prática. O
principal objetivo desses planos é instigar a curiosidade no processo de aprendizado
de matemática, o que para estudiosos da Educação como Paulo Freire [6] e Hugo
Assmann [1] é muito importante.

2

Capítulo 1

Conceitos básicos de divisibilidade e
números primos

Neste capítulo apresentamos conceitos básicos de divisibilidade de números
inteiros, algoritmo da divisão, critérios de divisibilidade, números primos e o
processo de busca de números primos. No decorrer do capítulo enunciaremos alguns
resultados que envolvem a deﬁnição de congruência de números inteiros, tal conteúdo
é abordado no capítulo 2.

1.1 Divisibilidade

Estudamos nessa secção algumas características básicas da divisibilidade de

números inteiros.

Deﬁnição 1.1 Dados os números inteiros a e b (com b (cid:54)= 0), dizemos que a divide
b (em símbolos a | b) quando existir um número inteiro c, tal que

b = a · c

Neste caso, dizemos que b é múltiplo de a, ou de maneira equivalente b é divisível
por a.

De maneira um tanto mais elegante, temos que:

Para algum c ∈ Z.

a | b ⇔ b = a · c

Denotamos o conjunto de divisores positivos de a por Da = {n ∈ N : n | a} e o

conjunto de múltiplos de a por Ma = {n ∈ N : a | n}.

3

1.1. DIVISIBILIDADE

Exemplo 1.1 Determinar todos os números inteiros n para os quais 3n + 1 divide
9n3 + 11n + 12.

Solução: É fácil ver que 9n3 + 11n + 12 = (3n2 − n + 4) · (3n + 1) + 8, daí podemos
concluir que:

9n3 + 11n + 12
3n + 1

= 3n2 − n + 4 +

8
3n + 1

Como 3n2 − n + 4 ∈ Z, então 3n + 1 divide 9n3 + 11n + 12 se, e somente se, 3n + 1
divide 8. Como D8 = {±1, ±2, ±4, ±8}, devemos ter:

3n + 1 = ±1, 3n + 1 = ±2, 3n + 1 = ±4, 3n + 1 = ±8

De onde obtemos n = −3, n = −1, n = 0 e n = 1 como as soluções inteiras.

Proposição 1.1 Se b | a com a (cid:54)= 0, então |b| ≤ |a|.

Demonstração: Como b | a, por deﬁnição a = b · c com c ∈ Z e c (cid:54)= 0, logo
|a| = |b| · |c| = |b · c|. Pelo fato de c (cid:54)= 0, resulta que 1 ≤ |c| multiplicando essa
desigualdade por |b| obtemos |b| ≤ |b| · |c| = |a|. Como queríamos.

Perceba que decorre imediatamente da Proposição 1.1 que os únicos divisores de

1 são −1 e 1.

inteiros

de números

Teorema 1.1 A divisibilidade
propriedades:
(1) 1 | a, a | a e a | 0 para todo a ∈ Z
(2) Se a | b e b | a, então a = ±b
(3) Se a | b e b | c então a | c
(4) Se a | b e c | d então a · c | b · d
(5) Se a | (b ± c). Então, a | b ⇔ a | c
(6) Se a1, a2, ..., an são números inteiros divisíveis por a, então:

satisfaz

as

seguintes

a | (a1 · b1 + a2 · b2 + ... + an · bn)

para quaisquer que sejam os inteiros b1, b2, ..., bn.

As demonstrações dos itens 1,3,4,5 e 6 do Teorema 1.1 decorrem imediatamente
da deﬁnição de divisibilidade, já o item 2 é imediato da Proposição 1.1. As mesmas
podem ser encontradas no livro do Abramo [7] e no livro do Vandemberg [14]. A
seguir, resolvemos três exemplos, que podem ser excelentes artifícios para solução
de questões que envolvem divisibilidade de números inteiros.

4

1.1. DIVISIBILIDADE

Exemplo 1.2 Sejam, a, b ∈ Z (com a − b (cid:54)= 0) e n ∈ N. Mostre que a − b divide
an − bn.

Solução: Quando n = 1 o resultado é óbvio, sendo assim, nos resta mostrar para
n ≥ 2. Ora, mas isso é equivalente a mostrar que a sentença

an − bn
a − b

= an−1 + an−2 · b + ... + a · bn−2 + bn−1

é válida para todo n ≥ 2. Para isso usemos indução matemática. Perceba que a
sentença é valida quando n = 2, pois,

a2 − b2
a − b

=

(a − b) · (a + b)
a − b

= a + b

Suponhamos a validade da mesma para um certo n ∈ N, ou seja,

an − bn
a − b

= an−1 + an−2 · b + ... + a · bn−2 + bn−1

Devemos mostrar que também valerá para n + 1. De fato, multiplicando ambos os
membros da igualdade acima por a, obtemos:

an+1 − a · bn
a − b

= an + an−1 · b + ... + a2 · bn−2 + a · bn−1

Agora somando bn a ambos os lados da igualdade, resulta que:

an+1 − a · bn
a − b

+bn =

an+1 − a · bn
a − b

+

bn · (a − b)
a − b

= an+an−1·b+...+a2·bn−2+a·bn−1+bn

o que equivale a

an+1 − bn+1
a − b

= an + an−1 · b + ... + a2 · bn−2 + a · bn−1 + bn

Logo a sentença também vale para n+1, com isso obtemos o resultado que desejamos.

Exemplo 1.3 Sejam, a, b ∈ Z (com a + b (cid:54)= 0) e n ∈ N. Mostre que a + b divide
a2n+1 + b2n+1.

Solução: Analogamente ao Exemplo 1.2, basta usar indução para mostrar que:

a2n+1 + b2n+1
a + b

= a2n − a2n−1 · b + ... − a · b2n−1 + b2n

5

1.1. DIVISIBILIDADE

De fato, quando n = 1 temos que,

a2n+1 + b2n+1
a + b

=

a3 + b3
a + b

=

(a + b) · (a2 − a · b + b2)
a + b

= a2 − a · b + b2

Tomando por hipótese a validade para n, e multiplicando por a2 e depois somando
−a · b2n+1 + b2n+2 a ambos os membros da igualdade:

a2n+1 + b2n+1
a + b

= a2n − a2n−1 · b + ... − a · b2n−1 + b2n

Obtemos:

a2(n+1)+1 + b2(n+1)+1
a + b

= a2(n+1) − a2n+1 · b + ... − a3 · b2n−1 + a2 · b2n − a · b2n+1 + b2(n+1)

E com isso, pelo princípio de indução está provada a igualdade para todo número
natural, como queríamos.

Exemplo 1.4 Sejam, a, b ∈ Z (com a + b (cid:54)= 0) e n ∈ N. Mostre que a + b divide
a2n − b2n.

Solução: De modo semelhante ao Exemplo 1.2, basta usar indução para mostrar
que:

a2n − b2n
a + b

= a2n−1 − a2n−2 · b + ... + a · b2n−2 − b2n−1

De fato, quando n = 1 temos:

a2 − b2
a + b

=

(a + b) · (a − b)
a + b

= a − b

Supondo a validade para n e multiplicando por a2 e depois somando a · b2n − b2n+1
a ambos os membros da igualdade:

a2n − b2n
a + b

= a2n−1 − a2n−2 · b + ... + a · b2n−2 − b2n−1

Obtemos,

a2(n+1) − b2(n+1)
a + b

= a2n+1 − a2n · b + ... + a3 · b2n−2 − a2 · b2n−1 + a · b2n − b2n+1

E com isso, pelo princípio de indução está provada a igualdade para todo número

natural, como queríamos.

6

1.1. DIVISIBILIDADE

1.1.1 Algoritmo da divisão e Algoritmo Euclidiano

Antes de enunciar os resultados desta seção, é de fundamental importância
saber do que trata um algoritmo. Pois bem, de maneira essencial um algoritmo
é uma "receita"para resolver determinado tipo de problema. Imagine que temos a
tarefa de fazer um yakisoba, se pesquisarmos a receita, encontramos uma lista de
ingredientes e um conjunto de instruções a seguir para conseguirmos alcançar nosso
objetivo. Depois de conseguir os ingredientes e seguir as instruções, temos como
resultado o yakisoba. Assim é o algoritmo, quando formos especiﬁcá-lo devemos
deixar claro qual é a sua entrada e sua saída. Ou seja, deﬁnimos a entrada (como
os ingredientes) e listamos as operações e passos a serem executados que nos levam
a um determinado resultado (saída que desejamos: "o produto"). Podemos então
enunciar o algoritmo como um fato ou teorema, deixando claro os ingredientes e
os passos a serem executados em busca do produto ﬁnal, como podemos ver nos
algoritmos fundamentais que são apresentados nessa secção.

Algoritmo da divisão

Teorema 1.2 Sejam a e b inteiros com b > 0, então existem únicos inteiros q e r
tais que:

a = b · q + r

com 0 ≤ r < b.
Demonstração: Seja o conjunto L = {x = a − b · q; q ∈ Z e a − b · q ≥ 0}. Podemos
aﬁrmar que L não é vazio, pois |a| · b ≥ |a| ⇒ a + |a| · b ≥ a + |a| ≥ 0. Daí,
x = a − (−|a|) · b é da forma a − bq com q = −|a|, com isso x ∈ L.
Sendo L limitado inferiormente por 0, pelo Principio da boa ordenação existe r =min
L, com isso temos que r ≥ 0 e

r = a − b · q, com q ∈ Z.

E ainda, r < b pois, caso contrário r − b = a − b · q − b = a − b(q + 1) > 0 (r − b ∈ L)
e r − b < b, o que contraria a minimalidade de r. Isso nos garante a existência de q
e r.
A unicidade é garantida pelo fato que se existissem q(cid:48), r(cid:48) ∈ Z tais que

Com isso, b · q + r = b · q(cid:48) + r(cid:48) o que equivale a

a = b · q(cid:48) + r(cid:48), com 0 ≤ r(cid:48) < b.

r − r(cid:48) = b · (q(cid:48) − q).

Ou seja, b | (r − r(cid:48)). E pela Proposição 1.1 |r − r(cid:48)| < b, segue que r − r(cid:48) = 0, logo,
r = r(cid:48), o que resulta q(cid:48) = q, uma vez que b (cid:54)= 0.

7

1.1. DIVISIBILIDADE

Corolário 1.1 (versão geral do Algoritmo da divisão): Sejam a e b números
inteiros, com b (cid:54)= 0, então, existem únicos inteiros q e r tais que

a = b · q + r, com 0 ≤ r < |b|.

A demonstração pode ser encontrada [7].

Exemplo 1.5 Determine o quociente e o resto da divisão de a por b quando:
a) a = 73 e b = 21
b) a = −73 e b = 21
c) a = −73 e b = −21
d) a = 73 e b = −21

Solução:
a) Como 73 = 21 · 3 + 10 e 10 < 21, então q = 3 e r = 10.
b) Pelo item anterior temos que 73 = 21 · 3 + 10, então

−73 = −21 · 3 − 10 = −21 · 3 − 10 − 21 + 21 = 21 · (−4) + 11

Logo, q = −4 e r = 11.
c) Como 73 = 21 · 3 + 10, então

−73 = −21 · 3 − 10 − 21 + 21 = −21 · (3 + 1) + 11 = −21 · 4 + 11.

Logo, q = 4 e r = 11.
d) Como 73 = 21 · 3 + 10, então

73 = −21 · −3 + 10

Logo, q = −3 e r = 10.

Algoritmo Euclidiano

Deﬁnição 1.2 (Máximo divisor comum:) Sejam a, b ∈ Z. Dizemos que d ≥ 0
é um máximo divisor comum (mdc) de a e b, se

1) d | a e d | b;

2) Se c ∈ Z é tal que c | a e c | b então c | d.

É fácil ver que se o mdc existir ele é único, pois, caso contrário, se d e d(cid:48) fossem
mdc’s de a e b, teríamos que d | d(cid:48) e d(cid:48) | d com d, d(cid:48) ≥ 0, logo d = d(cid:48). Ou seja, na
existência de d ele é único. Usualmente usaremos a notação d =mdc(a, b).

8

1.1. DIVISIBILIDADE

Em alguns casos particulares é imediato calcular o mdc. Por exemplo, se a é um

número inteiro não nulo é imediato que:

I) mdc(0, a) = |a|.

II) mdc(1, a) = 1.

III) mdc(a, a) = |a|.

IV) Se b ∈ Z, então a | b ⇔ mdc(a, b) = |a|.

V) mdc(a, b) = mdc(−a, b) = mdc(−a, −b) = mdc(a, −b).

Perceba que os itens acima decorrem imediatamente da deﬁnição de mdc unida
com a deﬁnição de divisibilidade, note ainda que o item V) nos permite assumir sem
perda de generalidade mdc(a, b) =mdc(|a|, |b|), isso facilitará o trabalho de encontrar
o mdc de dois inteiros quaisquer.

Teorema 1.3 (Teorema de Bachet-Bézout:) Seja d o mdc de dois inteiros a e
b, então existem inteiros x0 e y0 tais que a · x0 + b · y0 = d.

Demonstração: Como comentado anteriormente, adotemos a, b ≥ 0. Seja o
conjunto

X+ = {a · x + b · y; x, y ∈ Z e a · x + b · y > 0}.

É fácil ver que X+ não é vazio, pois quando x, y > 0 e a, b não ambos nulos, temos
a · x + b · y > 0 ∈ X+. Assim sendo, pelo princípio da boa ordenação X+ possui um
menor elemento, seja k = min X+. Note que

k = a · x0 + b · y0 com x0, y0 ∈ Z

Pelo algoritmo da divisão, temos que:

a = k · q + r, com 0 ≤ r < k.

(cid:63)

(cid:63)(cid:63)

Substituindo o valor de k em (cid:63) na igualdade de (cid:63)(cid:63), obtemos:

r = a − k · q = a − (a · x0 + b · y0)q = a − a · q · x0 − b · q · y0

⇒ r = a(1 − q · x0) + b(−q · y0)

Logo, concluímos que r = a · u + b · v, com u = (1 − q · x0) e v = (−q · y0). Com
isso, r = 0, pois caso contrário r > 0, e por conseguinte r ∈ X+, o que contraria a

9

1.1. DIVISIBILIDADE

minimalidade de k (absurdo). Daí de (cid:63)(cid:63) a = k · q, ou seja, k | a. De modo análogo,
podemos constatar que k | b.

Sendo d = mdc (a, b), então a = d · k1 e b = d · k2 e por (cid:63) deduzimos que:

k = (d · k1)x0 + (d · k2)y0 = d(k1 · x0 + k2 · y0)

Ou seja, d | k, e como k | d, pois d = mdc (a, b), segue que d = k. Portanto,

a · x0 + b · y0 = d

Corolário 1.2 Se d = mdc(a, b) então

X = {a · x + b · y; x, y ∈ Z} = Md

onde Md é o conjunto dos múltiplos de d.

Teorema 1.4 (Lema de Gauss): Sejam a, b e c números inteiros. Se a | b · c e
mdc(a, b) = 1, então a | c.

Demonstração: Se a | b · c então b · c = a · x com x ∈ Z. Se mdc(a, b) = 1 pelo
teorema de Bachet-Bézout, temos que existem x0, y0 ∈ Z tais que

Multiplicando ambos os membros da igualdade acima por c, obtemos:

x0 · a + y0 · b = 1

E como b · c = a · x temos que

x0 · a · c + y0 · b · c = c

c = x0 · a · c + y0 · a · x = a(x0 · c + y0 · x)

E portanto, a | c.

Lema 1.1 Sejam a, b, n ∈ Z. Se existir o mdc(a, b − n · a), então o mdc(a, b) existe,
e ainda,

mdc(a, b) = mdc(a, b − n · a).

Demonstração: Seja mdc(a, b − n · a) = d, pela deﬁnição de mdc, temos que d | a e
d | (a − b · n). E a partir disso, o conceito de divisibilidade nos permite concluir que
d | (b − n · a) + n · a, o que equivale a d | b. Assim, d | a e d | b. Suponhamos agora
que c | a e c | b, para algum c ∈ N, disso resulta que c também divide (b − n · a),
logo pela deﬁnição de mdc, como c | a e c | (b − n · a), temos que c | d.
Portanto,

10

1.1. DIVISIBILIDADE

Como queríamos.

d = mdc(a, b − n · a) = mdc (a, b)

Teorema 1.5 (Algoritmo Euclidiano) Para todos a, b ∈ Z. Existe mdc(a, b) =
d.

Demonstração: Note que é equivalente mostrar para a, b ∈ N, pois como vimos
mdc(a, b) = mdc(|a|, |b|), e ainda, como mdc(a, b) = a quando a | b, nos resta
analisar o caso em que 1 < a < b e a (cid:45) b. Pois bem, aplicando o Algoritmo da
divisão, temos que:

Assim, se r1 | a, então

b = a · q1 + r1, com 0 < r1 < a.

mdc(a, b) = mdc(a, b − a · q1) = mdc(a, r1) = r1

Se r1 (cid:45) a, então

a = r1 · q2 + r2 com 0 < r2 < r1 (r2 = a − r1 · q2)

Assim, se r2 | r1 então,

mdc(a, b) = mdc(a, r1) = mdc(a − r1 · q2, r1) = mdc(r2, r1) = r2

Caso contrário de r2 (cid:45) r1, então

r1 = r2 · q3 + r3 com 0 < r3 < r2 (r3 = r1 − r2 · q3).

E assim continuamos o procedimento, até que pare (quando encontrarmos o mdc).
Note que isso sempre ocorre, pois do contrário, teríamos uma sequência de números
naturais a > r1 > r2 > ... que não possui menor elemento, o que é um absurdo pelo
princípio da boa ordenação. Sendo assim, para algum k, temos que rk | rk−1, o que
nos dá mdc(a, b) = rk.

De modo simples, podemos dizer que o mdc(a, b) = rk onde rk é o último resto

não nulo das divisões sucessivas elencadas anteriormente.

Exemplo 1.6 Determine o valor de d, tal que mdc(551, 874) = d e determine
inteiros x e y tais que a · x + b · y = d.

Solução: Aplicando o Algoritmo Euclidiano, temos

874 = 551 · 1 + 323
551 = 323 · 1 + 288
323 = 228 · 1 + 95
228 = 95 · 2 = 38
95 = 38 · 2 + 19
38 = 19 · 2 + 0.

11

1.2. NÚMEROS PRIMOS

Logo, o mdc(551, 874)=19.

E a partir disso, temos:

19 = 95 − 38 · 2 = 95 − (228 − 95 · 2) · 2 =
= 95 · 5 − 228 · 2 = (323 − 228) · 5 − 228 · 2 =
= 323 · 5 − 228 · 7 = 323 · 5 − (551 − 323) · 7 =
= 323 · 12 − 551 · 7 = (874 − 551) · 12 − 551 · 7 =
= 874 · 12 − 551 · 19

Logo, 551 · (−19) + 874 · 12 = 19 = mdc(551, 874), como queríamos.

Portanto, x = −19 e y = 12 é uma solução.

Comentário 1.1 Esse resultado é de fundamental importância para o processo de
busca se soluções de equações diofantinas lineares, que tem importantes aplicações.
Uma delas é a busca do inverso multiplicativo módulo m, ou seja, encontrar x tal que
a · x ≡ 1 mod m, o que é de fundamental importância para sistemas de criptograﬁa
como o RSA.

1.2 Números primos

"Grande parte dos resultados soﬁsticados da teoria dos números deve-se ao
estudo feito sobre números primos"[14]. Como o objetivo desse trabalho é analisar
o funcionamento dos sistemas de criptograﬁa, dando ênfase ao RSA, nesse capítulo
estudaremos alguns fatos sobre os números primos, tendo em vista que a segurança
do RSA depende de fato de sermos capazes de escolher dois números primos
extremamente grandes, como veremos a última secção.

Deﬁnição 1.3 Um número natural p (cid:54)= 1 é dito um número primo, quando seus
únicos divisores positivos são 1 e p. Caso contrário, p será composto.

Exemplo 1.7 Os números 2, 5 e 11 são primos, equanto os números 4 = 2 · 2, 10 =
5 · 2 e 12 = 2 · 6 são compostos.

Exemplo 1.8 O número 119999999 − 79999999 é composto, pois pelos Exemplos 1.2 e
1.3 da secção de divisibilidade 11-7=4 e 11+7=18 são divisores do mesmo.

Observação 1.1 Um número n é composto se existe 1 < k1 < n tal que k1 | n e
pela deﬁnição de divisibilidade decorre que existe 1 < k2 < n tal que n = k1 · k2.

12

1.2. NÚMEROS PRIMOS

Observação 1.2 É imediato da deﬁnição que se p e p(cid:48) são dois números primos e
a ∈ N, então:

(I) p | p(cid:48) se, e somente se p = p(cid:48);

(II) Se p (cid:45) a, então mdc(a, p) = 1.

Proposição 1.2 (Lema de Euclides): Sejam a, b, p ∈ Z, com p primo. Se p | a·b
então p | a ou p | b.

Demonstração: Suponhamos que p | a·b e p (cid:45) a, logo mdc(a, p) = 1 e pelo Lema de
Gauss (Teorema 1.4) concluímos que p | b. Se p | a·b e p (cid:45) b, temos que mdc(b, p) = 1
logo pelo Lema de Gauss p | a. Com Isso provamos que p | a ou p | b.

Corolário 1.3 Sejam p, p1, p2, ..., pn números primos. Se p | p1 · p2 · ... · pn, então
p = pi para algum i = 1, 2, ..., n.

Demonstração: Seja p um número primo. Considere a seguinte sentença aberta:

P (n) : p, p1, p2, ..., pn números primos e p | p1 · p2 · ... · pn ⇒ p | pi para algum
i = 1, 2, ..., n.

Vamos mostrar por indução que P (n) é verdadeira para todo n ∈ N>1. Inicialmente
note que pela proposição anterior garantimos a validade de P (2). Suponhamos então
a validade de P (n), e assim devemos provar que P (n) ⇒ P (n + 1).
n+1 números primos tais que p | p(cid:48)
1 · p(cid:48)
n+1 que ocorre se, e somente se, p | p(cid:48)

n · p(cid:48)
2 · ... · p(cid:48)
n+1 atrelando a hipótese resulta que [p | pi para algum i = 1, 2, ..., n] ou [p | p(cid:48)

Ora pois, sejam p(cid:48)
isso equivale à p | (p(cid:48)
p | p(cid:48)
ou seja, p | p(cid:48)
Portanto, pelo princípio de indução ﬁnita está provada a sentença.

n+1
n ou
n+1]
i para algum i = 1, 2, ..., n+1, com isso provamos que P (n) ⇒ P (n+1).

2, ..., p(cid:48)
2 · ... · p(cid:48)

2 · ... · p(cid:48)
1 · p(cid:48)

n, p(cid:48)
n) · p(cid:48)

1, p(cid:48)
1 · p(cid:48)

E por ﬁm, unindo a validade de P (n) a Observação 1.2 concluímos a

demonstração.

Teorema 1.6 (Teorema Fundamental da Aritmética) Todo número natural
maior que 1 ou é primo ou se escreve de modo único (a menos da ordem dos fatores)
como um produto de fatores primos.

Demonstração: Considere a seguinte sentença aberta:

P (n) : Dado n ∈ N>1, n é primo ou pode ser escrito como um produto de primos.

13

1.2. NÚMEROS PRIMOS

Note que P (2) é verdadeira, pois 2 é um número primo. Suponhamos a validade
de P (k) para todo k < n. Devemos mostrar que P (n) também é verdadeira. Ora,
mas se n for primo não temos o que fazer. Suponhamos então que n é composto, ou
seja, existem 1 < k1, k2 < n tais que n = k1 · k2. Por hipótese de indução temos que
k1 = p1 · ... · pr e k2 = q1 · ... · qs, com pi e qj primos para i = 1, 2, ..., r e j = 1, 2, .., s.
Assim,

n = k1 · k2 = p1 · ... · pr · q1 · ... · qs

Ou seja, n é escrito como produto de primos. Logo pelo princípio de indução ﬁnita
está provado que n ∈ N>1, n é primo ou pode ser escrito como produto de números
primos.

Veja que com isto, nos resta mostrar a unicidade da decomposição em fatores

primos. Para isso, tomemos a seguinte sentença:

W (n) : a decomposição de n ∈ N>1 em fatores primos é única.

É fácil ver que W (2) é válida. Suponhamos agora que W (k) é válida para todo
k < n. Agora, seja n = p(cid:48)
j são primos. Pelo
corolário anterior, segue que,

s, donde p(cid:48)

r e n = q(cid:48)

1 · ... · p(cid:48)

1 · ... · q(cid:48)

i e q(cid:48)

p(cid:48)
1 · ... · p(cid:48)

r = q(cid:48)

1 · ... · q(cid:48)

s ⇒ p(cid:48)

1 | q(cid:48)

1 · ... · q(cid:48)

s ⇒ p(cid:48)

1 = q(cid:48)

j(1).

2 · ... · q(cid:48)
Assim, podemos reordenar os índices e supor que j(1) = 1. Daí, p(cid:48)
s.
i e q(cid:48)
Como p2 · ... · pr < n, então por hipótese de indução temos que r = s e que p(cid:48)
j
são iguais aos pares. Segue por Indução que W (n) é verdadeira para todo n ∈ N>1.
Logo, está provada que a decomposição de n em fatores primos é única.

2 · ... · p(cid:48)

r = q(cid:48)

Logo, a validade de P (n) e W (n) prova o que gostaríamos.

Por meio de uma ordenação e agrupamento dos primos da decomposição

apresentada no teorema anterior, podemos enunciar o seguinte resultado:

Corolário 1.4 Dado n ∈ Z − {−1, 0, 1}, existem primos p1 < ... < pr e α1, ..., αr ∈
N univocamente determinados, tais que:

n = ±pα1
1

· ... · pαr
r .

Um importante resultado em teoria dos números que decorre imediatamente do

Teorema Fundamental da Aritmética, trata da inﬁnidade dos números primos.

Teorema 1.7 Existem inﬁnitos números primos.

Demonstração: Suponhamos por absurdo que existem ﬁnitos números primos, a
saber p1, ..., pr e seja o número

n = p1 · ... · pr + 1

14

1.2. NÚMEROS PRIMOS

Por hipótese, n não pode ser primo. Mas, pelo Teorema Fundamental da Aritmética,
n possui um fator primo p, tal que p | p1 · ... · pr + 1 e por hipótese p = pi para algum
i = 1, 2, ...r, o que resulta p | p1 · ... · pr e p | 1, o que é um absurdo, logo devem
existir inﬁnitos números primos.

1.2.1 Alguns critérios de divisibilidade

Em teoria dos números são conhecidos alguns critérios de divisibilidade. Os
mesmos visam facilitar o processo de decomposição de um número em fatores primos.
Aqui, apresentamos alguns casos particulares conhecidos e enunciamos um teorema
que nos permite encontrar um critério de divisibilidade de um número inteiro por
um número primo p de modo geral.

Proposição 1.3 (Divisão por 2, 5 e 10) Seja w ∈ Z, temos que w é divisível
por 2,5 e 10 se, e somente se, o algarismo das unidades (a0) de w for divisível por
2,5 e 10 respectivamente.

Demonstração: Basta veriﬁcar que w = an10n + an−110n−1 + ... + a110 + a0 para
todo w ∈ Z com ai ∈ {0, ±1, ±2, ±3, ±4, ±5, ±6, ±7, ±8, ±9} e n ∈ N.

Proposição 1.4 (Divisão por 3 e 9) Dado um número inteiro w = anan−1...a1a0
com ai ∈ 1, 2, 3, 4, 5, 6, 7, 8, 9, temos que w é divisível por 3 e por 9 se, e somente se,
a0 + a1 + ... + an for divisível por 3 e por 9 respectivamente.

Demonstração: Basta tomar w = an10n + an−110n−1 + ... + a110 + a0 e unir a fato
que 9 | 10n − 1 (pode ser veriﬁcado por indução) para todo n ∈ N.

Proposição 1.5 (Divisibilidade por 7) Seja w = an10n+an−110n−1+...+a110+a0
que de modo equivalente pode ser escrito como w = 10k + a0, com k = a1 + a210 +
... + an10n−1. Temos que:

7 | w ⇔ 7 | k − 2a0

A demonstração pode ser encontrada [14].

Exemplo 1.9 5887 é divisível por 7, pois:

7 | 5887 ⇔ 7 | 588 − 2 · 7 = 574 ⇔ 7 | 57 − 2 · 4 = 49 = 7 · 7.

Poderíamos passar anos enunciando proposições sobre critérios de divisibilidade
de um número inteiro por um número primo especíﬁco. Surge então a dúvida:
será que vale a pena aprender tantos critérios de divisibilidade? Será que existe
um padrão de divisibilidade para todos os primos? A resposta para essa pergunta
encontra-se no teorema a seguir:

15

1.2. NÚMEROS PRIMOS

Teorema 1.8 (Quebra da unidade): Sejam n = arar−1ar−2...a2a1a0 com ai ∈
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} um número natural, p um número primo (diferente de 2 e 5)
e x ∈ Z tal que 10·x ≡ 1 mod p. Ou seja, x é um inverso multiplicativo de 10 módulo
p. O critério de divisibilidade então é o seguinte: se m = arar−1ar−2...a2a1 + x · a0
então p divide n se, e somente se, p divide m.

Demonstração: Sendo n = ar10r + ar−1 · 10r−1 + ... + a1 · 10 + a0 e m =
ar · 10r−1 + ar−1 · 10r−2 + ... + a1 + x · a0. Perceba inicialmente que:

n = 10 · m + (1 − 10x) · a0

Como x é um inverso multiplicativo de 10 módulo p, então o termo 1 − 10 · x é
divisível por p. Portanto, para qualquer que seja a0, temos:

n ≡ 10 · m mod p

Disso resulta que n é divisível por p se, e somente se, 10 · m também é divisível por
p. No entanto, como p é primo e p não divide 10 (já que p não é igual a 2 nem 5),
então temos que p divide n se, e somente se, p divide m.

Exemplo 1.10 Note que 10 · 1 ≡ 1 mod 3, daí, pelo teorema anterior n =
arar−1ar−2...a2a1a0 é divisível por 3 se, e somente se, m = arar−1ar−2...a2a1 + a0 é
divisível por 3. Testando a divisibilidade de 12345 por 3 usando esse novo critério
temos:

12345 ≡ 1234 + 5 = 1239 ≡ 123 + 9 = 132 ≡
13 + 2 = 15 ≡ 1 + 5 = 6 ≡ 3 ≡ 0 mod 3.

Logo 12345 é divisível por 3.

Observação 1.3 Como o inverso não é único, note que pelo Teorema 1.8 existem
diversos critérios a serem criados de acordo com o inverso adotado para gerar o
critério de divisibilidade desejado. Com isso, surge a dúvida de qual seria o melhor
inverso? A resposta, é o que tornar o critério mais rápido, para determiná-lo
devemos colocar na balança o tamanho do número a ser veriﬁcado e a quantos dígitos
queremos reduzir o número. Pois quando o inverso for negativo quanto maior for em
módulo, mais rápido será o processo, por isso é interessante usar um inverso negativo
com número de dígitos equivalente a o máximo de dígitos que queremos reduzir
os números testados. Outro fato interessante, é que existem outros teoremas que
permitem criar critérios de divisibilidade por meio da quebra da dezena e centena,
no entanto, esses métodos são trabalhosos, não sendo tão práticos se comparados a
quebra da unidade, os mesmos podem ser encontrados no artigo [10].

16

1.2. NÚMEROS PRIMOS

1.2.2 Encontrando números primos

Ao iniciar o estudo dos números primos, um dos primeiros questionamentos a
surgir é sobre como encontrar números primos? Qual o padrão dos números primos?
O processo de busca por números primos é antigo e as respostas para o padrão dos
números primos são vagas ou complexas demais sem aplicação prática, sendo em
cima disso que reside a segurança de sistemas de criptograﬁa que vemos no ﬁnal
deste trabalho.

Fórmulas Polinomiais

O uso de fórmulas polinomiais é antigo no processo de obtenção de números
primos, podemos citar a conjectura que aﬁrma a existência de inﬁnitos primos da
forma n2 + 1 (com n ∈ N), que até então ainda não foi provada. Perceba que
12 + 1 = 2, 22 + 1 = 5, 42 + 1 = 17 são exemplos de primos dessa forma. Mas, será
que existem inﬁnitos?

Um teorema interessante, nos garante que não existe uma função polinomial com

coeﬁcientes inteiros que gere apenas números primos, como segue:

Teorema 1.9 Dado um polinômio P (x), como coeﬁcientes inteiros, existe uma
inﬁnidade de inteiros positivos n tais que P (n) é composto.

A Demonstração desse teorema pode ser encontrada no livro do Coutinho [2].

Exemplo 1.11 Mostre que 7 é o único primo da forma x3 − 1, com x ∈ N.

Solução: A inﬁnidade de números compostos da forma x3 − 1 é garantida pelo
teorema anterior, no entanto queremos mostrar que 7 é o único primo que pode
ser escrito dessa forma. Note que isso realmente ocorre, pois 7 = 23 − 1 e ainda,
x3 − 1 = (x − 1) · (x2 + x + 1) o que mostra que x3 − 1 é composto para todo x (cid:54)= 2,
tendo em vista que se x > 2, (x − 1) ≥ 2 e (x2 + x + 1) > 2 e se x = 1, x3 − 1 = 0,
isso implica a composição de x3 − 1 como queríamos.

Números de Mersenne

Deﬁnição 1.4 Seja n ∈ N, o número

é dito número de Mersene.

M (n) = 2n − 1

Note que M (2) = 22 − 1 = 3, M (3) = 23 − 1 = 7, M (5) = 25 − 1 = 31 são primos.
No entanto, ainda não temos garantia que existem inﬁnitos primos dessa forma e
uma conjectura que encontra-se em aberto é a que segue:

17

1.2. NÚMEROS PRIMOS

Conjectura 1.1 Existem inﬁnitos primos de Mersenne.

Os números de Mersenne, tem sua devida importância nessa teoria, pois existem
diversas maneiras de testar se um número de Mersenne é primo, tanto que alguns
dos maiores números primos conhecidos são de Mersenne. A título de curiosidade,
veja o capítulo 9 do livro do Coutinho [2].

Números de Fermat
Deﬁnição 1.5 Seja n ∈ N (cid:83){0}, o número

F (n) = 22n + 1

é dito número de Fermat.

Assim, os cinco primeiros números de Fermat são F (0) = 220 + 1 = 3, F (1) =
221 + 1 = 5, F (2) = 222 + 1 = 17, F (3) = 223 + 1 = 257, F (4) = 224 + 1 = 65537.
Todos esses números são primos. Observando esse comportamento, Fermat aﬁrmou
que todos os números dessa forma são primos, até que em 1732, Leonhard Euler
mostrou que

F (5) = 225 + 1 = 4294967297

é divisível por 641. Com os recursos que temos hoje, testar a primalidade de F (5)
torna-se fácil, no entanto na época de Fermat, esse tipo de decisão ainda era muito
difícil.

Crivo de Eratóstenes

O crivo de Eratóstenes é o mais antigo dos métodos para achar primos e um dos
mais simples. O mesmo nos permite listar os números primos p ≤ n para um n ∈ N
qualquer. Fazendo uma implementação a programas computacionais convenientes,
o mesmo pode fazer a lista de primos menores ou iguais a n ∈ N, para um n
consideravelmente grande.

Teorema 1.10 Se n > 1 for composto, então n possui um divisor primo p, tal que
p ≤

n.

√

Demonstração: Sendo n um número composto, então n = a · b, com 1 < a, b < n.
Note que, se a >

n, então

n e b >

√

√

n.
O que é um absurdo. Logo a ≤
Pelo teorema fundamental da aritmética, existe p primo, tal que p | b e como b | n,

n. Suponhamos então que b ≤

n ou b ≤

√

√

√

n ·

n = n

n = a · b >
√

√

18

1.2. NÚMEROS PRIMOS

por transitividade p | n com p ≤ b ≤

√

n.

O Teorema 1.10 mostra que, para veriﬁcar se um dado n > 1 é primo, é suﬁciente

veriﬁcar sua divisibilidade pelos primos p ≤

n.

√

Perceba que o teste de primalidade dado pelo Teorema 1.10 perde sua eﬁciência
quando n é muito grande, e que mesmo de um ponto de vista computacional torna-se
n vai para o inﬁnito a mediada que n vai para o inﬁnito. Ainda não
inviável pois
possuímos um algoritmo de grande eﬁcácia do ponto de vista computacional.
O método de Eratóstenes para um n > 2 consiste nos seguintes passos:

√

Passo 1: Como 2 é um número primo, faça a lista de 2 unido com os números
ímpares menores ou iguais a n;

Passo 2: Excluímos da lista todos os múltiplos de 3 maiores que 3;

Passo 3: Excluímos da lista todos os múltiplos de 5 maiores que 5;

...

Passo k: Excluímos da lista todos os múltiplos de p maiores que p, onde p é o maior
número primo menor que

n.

√

Após concluir esses passos, teremos todos os primos menores ou iguais a n.

Exemplo 1.12 Liste todos os primos menores ou iguais a 100.

√

100 = 10 basta eliminar todos os múltiplos de 2 maiores que 2,
Solução: Como
todos os múltiplos de 3 maiores que 3,todos os múltiplos de 5 maiores que 5 e todos
os múltiplos de 7 maiores que 7 da lista dos 100 primeiros naturais, obtendo:

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97

Fatoração de Fermat

Apresentamos a seguir um algoritmo de fatoração que é muito eﬁciente quando n
n, tal método foi apresentado por
tem um fator primo que não é muito menor que
Fermat para decompor um número composto em fatores primos. A ideia consiste
em determinar divisores para cada divisor impar b de n. O algoritmo é o que segue:
Algoritmo de fatoração de Fermat: Se n ∈ N é um número composto, então

√

podemos escrevê-lo na forma:

n = 2k · b

19

1.2. NÚMEROS PRIMOS

Sendo b um número impar e k ∈ N ∪ {0}. Se b for primo então a fatoração de n em
primos é dada por n = 2k · b, caso contrário procedemos da seguinte forma:

√

√

Etapa 1: Determine a = [
Etapa 2: Se a2 − b = r2, então b = (a + r) · (a − r)
Etapa 3: Caso a2 − b (cid:54)= r2, então somamos 1 a a e voltamos a etapa 2.

n] (a parte inteira da

n).

Comentário 1.2 A prova da validade do algoritmo de Fermat não é difícil, no
entanto é um tanto longa, por isso não apresentamos nesse trabalho. A mesma pode
ser encontrada no livro do Vandeberg [14].

Na prática, procedemos da seguinte forma, supondo que já conhecemos um

algoritmo para o cálculo da raiz quadrada:

Exemplo 1.13 Determine a decomposição em fatores primos de 572.

Solução: Como 572 é par, percebemos facilmente que 572 = 22 · 143. Com isso
temos que b = 143 agora é só aplicar as etapas do algoritmo:

Etapa 1: Temos que a = 11.
Etapa 2: Como 112 − 143 = −22, e -22 não é quadrado perfeito, usamos 11+1.
Daí temos 122 − 143 = 1 e 1 é quadrado perfeito, então:

143 = (12 + 1) · (12 − 1)

E como 572 = 22 · 143, obtemos a decomposição de 572 em fatores primos como
sendo: 572 = 22 · 11 · 13.

Exemplo 1.14 Determine a decomposição em fatores primos de 49283.

Solução:: Como trata-se de um número impar, temos que b = 49283. Aplicando
as estapas do algoritmo, temos:

Etapa 1: Temos que a = 221.
Etapa 2: Temos que: 2212 − 49283 = −442 não é quadrado perfeito, daí fazemos
2222 − 49283 = 12. Logo

49283 = (222 + 1) · (222 − 1) = 223 · 221.

(∗)

Como 223 é primo, devemos repetir o algoritmo para b = 221, ora pois, neste caso:

Etapa 1: a = 14.

20

1.2. NÚMEROS PRIMOS

Etapa 2: Temos que 142 − 221 = −25 que não é quadrado perfeito, seguindo o
processo temos que 152 − 221 = 22, e com isso

221 = (15 + 2) · (15 − 2) = 17 · 13.

(∗∗)

E por ﬁm, unindo ∗ a ∗∗ resulta que 49283 = 13 · 17 · 223.

Comentário 1.3 Perceba que o metódo de Fermat possui eﬁciência quando a
diferença em módulo entre os divisores iniciais de n relativamente pequena, caso
contrário, o número de etapas aumentará consideravelmente tornando o algoritmo
ineﬁcaz.

21

Capítulo 2

Aritmética dos restos

Neste capítulo estudamos congruência de números inteiros, classes de resíduos e

funções aritméticas.

2.1 Congruências

Uma das áreas de estudo mais importantes da teoria dos números são as
congruências módulo m, pois tem fundamental importância no processo de checagem
da divisibilidade de um número por outro e ainda tem importante aplicação nos
sistemas de criptograﬁa mais seguros da atualidade. Nesta secção faremos um estudo
de congruências de números inteiros e classes de resíduos.

Deﬁnição 2.1 Dados a, b e m números inteiros com m > 1 dizemos que a é
congruente a b módulo m, em notação a ≡ b mod m, se a e b deixam mesmos
restos quando divididos por m.

Exemplo 2.1 7 ≡ 2 mod 5 pois, 7 = 5 · 1 + 2 e 2 = 5 · 0 + 2.

Proposição 2.1 a ≡ b mod m ⇔ m | a − b

A demonstração é imediata das Deﬁnições 1.1 e 2.1.

Proposição 2.2 (Lei do cancelamento) Se a·c ≡ b·c mod m com mdc(c, m) = 1,
então a ≡ b mod m.

Demonstração: Se a · c ≡ b · c mod m, pela proposição 1 temos que m | ac − bc =
c(a − b), como mdc(c, m) = 1, pelo Teorema 1.4 resulta que m | a − b, ou seja, a ≡ b
mod m.

22

2.1. CONGRUÊNCIAS

Proposição 2.3 Seja m, n ∈ N. Dados a, b, c e d números inteiros, temos:

(i) a ≡ a mod m
(ii) se a ≡ b mod m, então b ≡ a mod m
(iii) Se a ≡ b mod m e c ≡ d mod m, então a ≡ c mod m
(iv) Se a ≡ b mod m e c ≡ d mod m então a + c ≡ b + d mod m
(v) Se a ≡ b mod m e c ≡ d mod m então a · c ≡ b · d mod m
(vi) Se a ≡ b mod m então an ≡ bn mod m
(vii) a + c ≡ b + c mod m ⇔ a ≡ b mod m
(viii) Se a ≡ b mod m e n | m então a ≡ b mod n
(ix) Se a ≡ b mod m então mdc (a, m)= mdc (b, m)
(x) a ≡ b mod mi ∀i = 1, 2, ..., k ⇔ a ≡ b mod mmc (m1, m2, ...mr)

Observação 2.1 A volta da implicação do item (v) só vale quando o mdc (c, m) = 1

Observação 2.2 As demonstrações dos itens acima decorrem imediatamente da
deﬁnição de congruência, sendo assim não farei as mesmas aqui, haja vista que o
objetivo deste trabalho é outro. As mesmas podem ser encontradas em [7] e [14].

Teorema 2.1 (Pequeno Teorema de Fermat) Se p é um número primo e a ∈ Z
tal que p (cid:45) a, então:

ap ≡ a mod p

Demonstração: Sejam a, 2a, ..., (p − 1) · a os primeiros p − 1 múltiplos de a, note
que esses números são dois a dois incongruentes módulo p, pois caso contrário, se
ak1 ≡ ak2 mod p, com 1 ≤ k1 < k2 ≤ p − 1, pelo fato do mdc(a, p) = 1, pela lei do
cancelamento k1 ≡ k2 mod p isto é, p | k2 − k1, o que é impossível. Além disso, se
1 ≤ w ≤ p − 1 e p | wa, então p | a ou p | w, o que também não é possível. Logo,
p (cid:45) wa ∀w = 1, 2, ...p − 1.

Pelo algoritmo da divisão, cada inteiro é congruente módulo p a um, e somente
um, número da sequência, 1, 2, ..., p − 1, daí temos que em uma determinada ordem:

a ≡ w1 mod p

2a ≡ w2 mod p
...

(p − 1)a ≡ wp−1 mod p

Com wi ∈ {1, 2, .., p − 1} para i = 1, 2, ..., p − 1. Multiplicando membro a membro
as congruências acima obtemos:

23

2.1. CONGRUÊNCIAS

ap−1(p − 1)! ≡ (p − 1)! mod p

E pela lei do cancelamento,

ap−1 ≡ 1 mod p

E por ﬁm, multiplicando ambos os membros por a obtemos:

ap ≡ a mod p.

Adotemos sem demonstração os seguintes lemas, cujas demonstrações podem ser

encontradas em [7] e [14].

Lema 2.1 Seja p um número primo, então as únicas soluções módulo p da
congruência x2 ≡ 1 mod p são 1 e p − 1.

Lema 2.2 Sejam p um número primo e A = {1, 2, ..., p − 1}. Então, para cada
a ∈ A existe um único b ∈ A tal que ab ≡ 1 mod p.
Lema 2.3 Seja n ∈ Z, com n > 4, temos que n é composto se, e somente se,
n | (n − 2)!.

Teorema 2.2 (Teorema de Wilson) Um número natural p é primo se, e somente
se,

(p − 1)! ≡ −1 mod p.

Demonstração: O resultado é trivialmente satisfeito para p = 2, 3, suponhamos
que é válido para p ≥ 5. Pelo lema 2.2, temos que para cada a ∈ {1, 2, ..., p − 1},
existe um único b ∈ {1, 2, ..., p − 1} tais que ab ≡ 1 mod p. De modo particular, pelo
lema 2.1, os únicos valores de a que satisfazem a2 ≡ 1 mod p são a = 1 ou a = p − 1.
Daí, se a ∈ {2, ..., p − 2} então existe um único b ∈ {2, ..., p − 2}, diferente de a, tal
que ab ≡ 1 mod p. Fazendo o produto de todos eles obtemos:

Disso resulta que

2 · 3 · ... · (p − 2) ≡ 1 mod p

1 · 2 · 3 · ... · (p − 2) · (p − 1) ≡ (p − 1) ≡ −1 mod p

Portanto,

(p − 1)! ≡ −1 mod p

A recíproca resulta imediatamente do lema 2.3. Veja que para p = 2, 3, 4 é imediato.
Supondo, p > 4 não primo, teriamos que p | (p − 1)! e com isso, p (cid:45) [(p − 1)! + 1] ou
seja, (p − 1)! (cid:54)≡ −1 mod p, o que é um absurdo. Logo, p é primo.
Portanto, um número natural p é primo se, e somente se,

(p − 1)! ≡ −1 mod p.

24

2.2. CLASSES DE RESÍDUOS

2.2 Classes de resíduos

Deﬁnição 2.2 Seja m > 1 um número inteiro, temos que todo conjunto de números
inteiros cujos restos da divisão por m são os números 0, 1, 2, .., m − 1 sem repetições,
independentemente da ordem, é dito um sistema completo de resíduos módulo m.

Exemplo 2.2 0,1,2,3,4,5,6 é um sistema completo de resíduos módulo 7. 700, 22,
1402, 10, 704, 2105, 2106 também o é.

Proposição 2.4 Sejam a, k e m ∈ Z com m > 1 e mdc (k, m) = 1 se r1, r2, ..., rm
é um sistema completo de resíduos módulo m, então

a + k · r1, a + k · r2 + ... + a + k · rm

também é um sistema completo de resíduos módulo m.

Demonstração: Da Lei do cancelamento e da Proposição 2.3 (v), obtemos que
para i, j = 0, 1, 2, ..., m − 1, temos que

a + k · ri ≡ a + k · rj mod m ⇔ k · ri ≡ k · rj mod m
⇔ ri ≡ rj mod m ⇔ ri = rj.

Disso concluímos que a+k ·r1, a+k ·r2 +...+a+k ·rm são dois a dois não congruentes
módulo m e, portanto, formam um sistema completo de resíduos módulo m.

Deﬁnição 2.3 Seja m ∈ Z com m > 1. Um sistema reduzido de resíduos módulo
m é um conjunto de números r1, r2, ..., rs tais que:

(i) mdc(ri, m) = 1 para todo i = 1, 2, ..., s;

(ii) ri (cid:54)≡ rj mod m, se i (cid:54)= j;

(iii) Para cada n ∈ Z tal que mdc(n, m) = 1, existe i tal que n ≡ ri mod m.

Observação 2.3 Para qualquer m ∈ Z, com m > 1 existe um sistema reduzido de
resíduos módulo m, para encontrá-lo é só tomar o sistema completo e eliminar os
elementos que não são coprimos com m. Qualquer sistema reduzido terá o mesmo
número de elementos, o qual é a quantidade de elementos do conjunto {1, 2, ..., m−1}
que são coprimos com m.

Exemplo 2.3 Dado m = 10 um sistema reduzido de resíduos módulo m seria
{1, 3, 7, 9}.

25

2.2. CLASSES DE RESÍDUOS

Deﬁnição 2.4 Seja m ∈ Z, com m > 1. Considere φ(m) o número de elementos
de um sistema reduzido de resíduos módulo m. Para m = 1 escrevemos φ(1) = 1, e
assim temos a função:

φ : N (cid:55)−→ N

Denominada função ﬁ de Euler.

Observação 2.4 Note que m é primo se, e somente se, φ(m) = m − 1, além disso,
φ(m) ≤ m − 1 para todo m ≥ 2.

Proposição 2.5 Sejam k, d ∈ N e n = kd então a quantidade de números naturais
m, tais que 1 ≤ m ≤ n e mdc(m, n) = d é φ(k).

Demonstração: Perceba que 1 ≤ m ≤ n e mdc(m, kd) = d se, e somente se,
m = αd, com 1 ≤ α ≤ k e mdc(α, k) = 1. Sendo assim, a quantidade de naturais m
com as condições acima é igual a quantidade α tal que 1 ≤ α ≤ k e mdc(α, k) = 1,
o que equivale a φ(k).

Corolário 2.1 Seja n ∈ N, então,

(cid:88)

d∈N;d|n

φ(d) = n.

Comentário 2.1 Sobre a demonstração do corolário 2.1 Sendo I =
{1, 2, ..., n}, basta notar que para cada d ∈ N tal que d | n sendo Id = {m ∈
I, mdc(m, n) = d}, temos que se d (cid:54)= d(cid:48) então Id ∩ Id(cid:48) = ∅ e

(cid:91)

Id = I

d∈N;d|n

com isso, é só usar a proposição 2.5 para chegar no resultado que queremos.

Lema 2.4 Sejam r1, ..., rφ(m) um sistema reduzido de resíduos módulo m e seja
a ∈ Z tal que mdc(a, m) = 1. Então ar1, ..., arφ(m) é um sistema reduzido de resíduos
módulo m.

Demonstração: Seja a1, ..., am o sistema completo de resíduos do qual foi retirado
o sistema reduzido r1, ..., rφ(m). Pelo fato do mdc(a, m) = 1, tem-se que o
mdc(ai, m) = 1 se, e somente, se mdc(aai, m) = 1. Donde segue o resultado.

Teorema 2.3 (Teorema de Euler) Sejam a, m ∈ Z, com m > 1 e mdc(a, m) = 1.
Então:

aφ(m) ≡ 1 mod m.

26

2.3. FUNÇÕES ARITMÉTICAS

Demonstração: Seja r1, ..., rφ(m) um sistema reduzido de resíduos módulo m. Pelo
lema 2,4, temos que ar1, ..., arφ(m) também forma um sistema reduzido de resíduos
módulo m. Com isso,

ar1 · ar2 · ... · arφ(m) ≡ r1 · r2 · ... · rφ(m) mod m

O que equivale a

aφ(m) · r1 · r2 · ... · rφ(m) ≡ r1 · r2 · ... · rφ(m) mod m

Aplicando a lei do cancelamento, obtemos:

aφ(m) ≡ 1 mod m

Como queríamos.

A seguir serão enunciados alguns resultados de utilidade futura, os quais não

faremos as demonstrações. As demonstrações podem ser encontradas em [7].
Proposição 2.6 Sejam m, m(cid:48) ∈ N tais que mdc(m, m(cid:48)) = 1. Então, φ(m · m(cid:48)) =
φ(m) · φ(m(cid:48)).
Corolário 2.2 Seja m ∈ Z livre de quadrados, então para todo a ∈ Z e k ∈ N
tem-se que

akφ(m)+1 ≡ a mod m

Proposição 2.7 Sejam p, r ∈ N, com p primo. Então,
1
p

φ(pr) = pr − pr−1 = pr

1 −

(cid:18)

(cid:19)

Atrelando as proposições 2.6 e 2.7, podemos enunciar o seguinte teorema:

Teorema 2.4 Seja m = pα1
fatores primos. Então

1 · pα2

2 · ...pαr

r a decomposição em fatores primos de m em

φ(m) = pα1
1

· pα2
2

· ... · pαr
r

·

(cid:18)

1 −

1
p1

(cid:19)

(cid:18)

·

1 −

(cid:19)

1
p2

(cid:18)

· ... ·

1 −

(cid:19)

1
pr

2.3 Funções aritméticas

Algumas funções em teoria dos números merecem destaque devido a sua

importância, são elas:

1. τ (n) : número de divisores positivos de n.
2. σ(n) : Soma dos divisores positivos de n
3. π(n) : número de primos menores ou iguais a n.
4. φ(n) : Função φ de Euler.
Deﬁnição 2.5 Toda função f : N (cid:55)−→ R é dita uma função aritmética.

27

2.3. FUNÇÕES ARITMÉTICAS

2.3.1 A função τ (n): número de divisores positivos de n

Seja n ∈ N, temos que n pode ser escrito como n = pα1
1

com
pi números primos distintos ∀i 1 ≤ i ≤ k. Usando o princípio fundamental da
contagem podemos deﬁnir a função τ (n), como segue:

· ... · pαk
k

· pα2
2

Deﬁnição 2.6 A função τ (n) é dada pela aplicação:

f : N → R

n (cid:55)→ τ (n) = (α1 + 1) · (α2 + 1) · ... · (αk + 1)

Exemplo 2.4 Determine o número de divisores positivos de 26 · 34 · 58 · 132 · 17.
Quantos desses divisores são ímpares?

Solução: o número de divisores é dado por: τ (26·34·58·132·17) = 7·5·9·3·2 = 1890.
Como os números ímpares não são divisíveis por 2, o número de divisores ímpares
de 26 · 34 · 58 · 132 · 17 é dado por τ (34 · 58 · 132 · 17) = 5 · 9 · 3 · 2 = 270.

2.3.2 A função σ(n): soma dos divisores positivos de n

Seja n ∈ N, decomposto em fatores primos, sob a forma: n = pα1
1

· ... · pαk
k ,
por meio da fórmula da soma dos termos de uma PG não é tão difícil deduzir o
resultado apresentado na deﬁnição da função σ(n) que segue:

· pα2
2

Teorema 2.5 A função σ(n) é dada pela seguinte lei

f : N → R

n (cid:55)→ σ(n) =

− 1

pα1+1
1
p1 − 1

· ... ·

− 1

pαk+1
k
pk − 1

Demonstração: Seja n = pα1
1

· pα2
2

· ... · pαk

k . Note que o produto

(1 + p1 + p2

1 + ... + pα1

1 ) · (1 + p2 + p2

2 + ... + pα2

2 ) · ... · (1 + pk + p2

k + ... + pαk
k )

é igual a soma dos divisores positivos de n. Para visualizar isso, basta checar a
expansão desse produto, onde cada divisor positivo de n aparece uma única vez.
Perceba também que para cada αi, (1 + pi + p2
i ) representa a soma dos
αi + 1 primeiros termos de uma progressão geométrica de primeiro termo a1 = 1 e
razão q = pi. Sendo assim,

i + ... + pαi

1 + pi + p2

i + ... + pαi

i =

− 1

pαi+1
i
pi − 1

28

2.3. FUNÇÕES ARITMÉTICAS

E daí concluímos que

σ(n) =

− 1

pα1+1
1
p1 − 1

· ... ·

− 1

pαk+1
k
pk − 1

.

Exemplo 2.5 a soma dos divisores de 34 · 58 · 132 é dada por

σ(34 · 58 · 132) =

35 − 1
3 − 1

·

59 − 1
5 − 1

· ... ·

133 − 1
13 − 1

= 121 · 488281 · 183 = 10812006183

2.3.3 A função π(n): número de primos menores ou iguais a

n

A frequência de números primos menores ou iguais a n é dada por π(n), ou seja
selecionando ao acaso um número p ≤ n, a probabilidade de p ser um número primo
é dada por π(n)
n .

Como podemos ver em [11], não é simples determinar valores π(n), visando
facilitar, Legendre e Gauss, analisando tabelas, chegaram a conclusão que esse
1
ln n . Esse fato veio a ser provado por volta de 1900,
quociente se aproxima de
quando J. Hadamard e Ch. de la Valléc-Poussin, independentemente, provaram o
profundo teorema dos números primos, cujo enunciado é:

lim
n→∞

π(n)
n

·

1
ln x

−1

= 1

Uma fórmula para π(n) dada por Willians em 1964 é a que que segue:

Para todo k ∈ N, Seja

F (k) =

(cid:20)

cos2 π

(cid:21)

(k − 1)! + 1
k

Donde [x] é o maior inteiro menor ou igual a x.

Então, para k > 1, F (k) = 1 quando k é primo e caso contrário F (k) = 0, além

disso, F (1) = 1.(isso é garantido pelo teorema de Wilson)

Disso resulta que

π(n) = −1 +

n
(cid:88)

k=1

F (k)

Observação 2.5 Willians também expressou π(n) de modo semelhante usando o
seno, mas não apresentarei aqui, pois, o trabalho das duas fórmulas é equivalente.

29

2.3. FUNÇÕES ARITMÉTICAS

Miná˘c, estabeleceu outra fórmula, que foi publicada pela primeira vez em [11],

na qual não existem valores de cossenos e senos, como segue:

π(n) =

n
(cid:88)

k=2

(cid:20)(k − 1)! + 1
k

−

(cid:20)(k − 1)!
k

(cid:21)(cid:21)

A demonstração é simples, e pode ser encontrada em [11].

O autor aﬁrma que disso, obtém-se a fórmula de Willans para o enésimo número

primo, a dedução pode ser encontrada em [8]. A fórmula é a que segue:

pn = 1 +

(cid:34)(cid:18)

2n
(cid:88)

m=1

n
k=1 F (k)

(cid:80)m

(cid:35)

(cid:19) 1

n

A mesma tem aplicação muito difícil e se torna inviável quando tratamos de números
grandes.

2.3.4 A função φ(n): função φ de Euler

Trata-se do número de elementos de um sistema reduzido de resíduos módulo
n > 1, em outras palavras, trata-se da quantidade de números naturais entre 0 e
n − 1, que são primos com n. Com isso, tomando φ(1) = 1, e unindo a Deﬁnição 2.4
ao Teorema 2.4 podemos enunciar a seguinte função:

φ : N → N

E ainda, Seja n ∈ N, decomposto em fatores primos, sob a forma: n = pα1
pelo teorema 2.4 temos que:

1 ·pα2

2 ·...·pαk
k ,

φ(n) = pα1−1

1

· ... · pαk−1
k

· (p1 − 1) · ... · (pk − 1)

.

Essa função é de grande utilidade no sistema de criptograﬁa RSA. Vejamos sua

aplicabilidade no capítulo seguinte.

30

Capítulo 3

Criptograﬁa

3.1

Introdução

"Essas mensagens estão criptografadas de ponta a ponta", essa é a mensagem
que vemos em nosso WhatsApp quando vamos enviar uma mensagem para alguém
pela primeira vez. Mas, o que signiﬁca isso? Bem, signiﬁca que só quem saberá do
que se trata a mensagem é quem está enviando e quem está recebendo, pois caso
um terceiro intercepte a mensagem, não saberá do que se trata, pois a mesma se
encontrará embaralhada de modo que o processo para desembaralhar sem a chave
de embaralhamento torna-se praticamente impossível.

Em resumo, a criptograﬁa é responsável pelo estudo e aplicação de técnicas que
possibilitam a codiﬁcação e decodiﬁcação de mensagens, tornando o processo de
troca de informações seguro, evitando fraudes. Noutras palavras, a criptograﬁa
deﬁne uma chave de entrada na qual as mensagens e dados a serem transitados são
embaralhados e uma chave de saída que desembaralha os dados quando recebidos, de
modo que só quem tem acesso a chave de entrada é quem está enviando a mensagem
e quem tem acesso a chave de saída é quem está recebendo.

Um dos primeiros modelos de criptograﬁa conhecido é denominado Cifras de

César, o mesmo se baseia na seguinte correspondência:

Entrada A B C D E ... X Y Z
(cid:108)
(cid:108)
Saída D E F G H ... A B C

...

(cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:108)

Onde a chave de entrada transforma A em D, B em C, C em F e assim
sucessivamente. Já a chave de saída faz o inverso disso, ou seja D em A, E em
B e assim sucessivamente.

Nesse sistema a palavra AMOR seria codiﬁcada da seguinte forma DPRU e a

mensagem PRWR decodiﬁcada é MOTO.

31

3.1.

INTRODUÇÃO

Esse tipo de sistema de criptograﬁa é chamado de cifra de substituição simples,
onde as letras de um alfabeto são substituídas por outras. O código de César possui
pelo menos 25 variantes, que corresponde a iniciar a segunda linha da chave de
codiﬁcação com qualquer letra diferente de A. Note que a segurança desse sistema
não é de qualidade, pois poderíamos decodiﬁcar facilmente uma mensagem usando
a frequência das letras que mais se repetem. O problema de criar um modelo de
criptograﬁa seguro foi muito estudado durante um longo período. Ao longo do
tempo surgiram outros métodos, como o de Bellaso que teve sua chave considerada
inquebrável por mais de 300 anos, tendo sido quebrada em meados do século XIX,
pelo inglês Charles Babbage e pelo polonês Friedrich Kasiski, independentemente.
Os detalhes dessa história podem ser encontrados em [13].

Além do processo de troca de mensagens, surgiu o problema de transporte e
troca de chaves de decodiﬁcação de maneira segura, para que o único destinatário
da mensagem seja o único a decodiﬁcar a mesma.

No decorrer do processo, chegamos ao advento das máquinas, onde máquinas
famosas como a japonesa Purple e a alemã Enigma perduraram por um bom tempo.
Uma bela história a ser retratada é a de Alan Turing, o matemático responsável
pela quebra das chaves da Enigma que auxiliou ao ﬁm da segunda guerra mundial.
Não descreverei aqui os detalhes dessa história espetacular, no entanto recomendo
o ﬁlme "O jogo da Imitação", que apresenta muito bem essa história.

Todos os sistemas citados até aqui são simétricos, ou seja, a mesma chave é
usada para cifrar e decifrar uma mensagem. Por muito tempo pairou sobre a
comunidade dos criptologistas o paradigma da impossibilidade da troca de senhas
sem a intermediação de um portador. Coube aos norte americanos, Whitﬁeld
Driﬃe, Martin Hellman e Ralph Merkle quebrar esse paradigma trazendo para o
campo da criptograﬁa a teoria dos números por meio da noção de congruências. O
sistema criado por eles denominado DHM em homenagem aos criadores é bastante
engenhoso e foi o primeiro passo na busca para a solução do problema da troca
de chaves de modo seguro sem a necessidade de um intermediário. O defeito do
sistema é a serventia apenas para a troca de chaves entre dois indivíduos. No
entanto, ele serviu de inspiração para o desenvolvimento de sistemas com chaves
assimétricas. Na criptograﬁa assimétrica, existem duas chaves, a chave pública e
a chave privada. Para cifrar uma mensagem para alguém, precisa-se ter a chave
pública, de conhecimento geral, e utilizar esta chave para cifrar a mensagem; o
receptor decifra a mensagem secretamente. (A descrição do sistema DHM pode ser
encontrada no capítulo 13 do livro [7] de maneira simples por meio de uma troca de
mensagens entre "João e Maria").

Hoje em dia o sistema de criptograﬁa mais utilizado é o RSA, o qual vemos

detalhadamente neste capítulo.

O sistema RSA é um dos mais seguros atualmente, sendo utilizado nas principais
trocas de mensagens de teor privado e/ou sigiloso. Diante de uma sociedade onde

32

3.2. UM SISTEMA DE CRIPTOGRAFIA SIMÉTRICO COM FUNÇÃO AFIM

a quantidade de conteúdo é aumentada exponencialmente e grande parte deste
conteúdo é sigiloso, como mensagens pessoais, senha de contas bancárias e cartões
de crédito, torna-se essencial proteger esse sistema de troca. Com isso, é de suma
importância buscar aprimorar o mesmo cada vez mais e estudar técnicas de criação
de chaves cada vez mais eﬁcazes.

Para poder implementar o RSA precisamos de dois números primos que vamos
chamar de p e q. Para codiﬁcar uma mensagem é suﬁciente saber do produto entre
n = p · q. Para decodiﬁcar a mensagem precisamos conhecer os primos p e q. Cada
usuário no método tem sua própria chave de codiﬁcação. A chave n é pública, ou
seja, todos podem ter conhecimento dela. Já a chave de decodiﬁcação constituída
por p e q é secreta, logo, deve ser mantida em sigilo por cada usuário ou a segurança
do sistema estará comprometida.

Note que o processo de decodiﬁcação do RSA é teoricamente simples, pois basta
fatorar n = p · q e teremos a chave de decodiﬁcação, de fato, na teoria é simples,
mas quando usamos números primos muito grandes essa fatoração pode levar alguns
milhares de anos, devido aos métodos que dispomos atualmente para fazer isso não
serem tão eﬁcazes. Vide [2].

Ora, mas se fatorar é tão difícil, como podemos encontrar primos tão grandes? A
resposta é que existem métodos para determinar se um número é primo ou composto
sem tentar fatorá-lo. Como exemplo podemos citar os Primos de Mersene que foram
estudados no decorrer desse trabalho, sendo que o maior descoberto é 282589933 − 1
que tem quase 25 milhões de dígitos. Já o número 2214 + 1 é composto e nenhum de
seus fatores é conhecido.

Fazemos a seguir a apresentação de um sistema simétrico de Criptograﬁa
estudando um modelo com função aﬁm, e após isso, estudamos o sistema assimétrico
RSA em duas de suas variações, com o passo a passo de seu desenvolvimento e
exemplos. Também comentamos algumas estratégias que devem ser utilizadas para
garantir a segurança do RSA, pois não trata-se apenas de encontrar dois primos
grandes, mas sim encontrar dois primos grandes de modo estratégico para tornar os
algoritmos de fatoração que dispomos atualmente inúteis.

3.2 Um sistema de criptograﬁa simétrico com

Função Aﬁm

Nesta seção, estudamos o desenvolvimento de um sistema simétrico simples de
criptograﬁa que faz o uso de Função Aﬁm. Por ser simples e interessante, esse
sistema pode render uma excelente prática em sala de aula para o ensino médio,
como podemos ver no capítulo 4.

33

3.2. UM SISTEMA DE CRIPTOGRAFIA SIMÉTRICO COM FUNÇÃO AFIM

Pré codiﬁcação

Inicialmente deﬁnimos um alfabeto de S símbolos e fazemos uma correspondência
biunívoca entre os símbolos deste alfabeto e os números inteiros do intervalo [0, S−1].

Exemplo 3.1 Como exemplo prático, se tomarmos nosso alfabeto usual de 26
letras, podemos fazer a seguinte correspondência:

Entrada A B C D E ... X Y Z
(cid:108)
... 23 24 25

(cid:108)
Saída

(cid:108) ...
4

(cid:108)
2

(cid:108)
0

(cid:108)
3

(cid:108)
1

(cid:108)

(cid:108)

O motivo da correspondência ser feita com os números do intervalo [0, S −
1] é tornar possível o uso da aritmética dos restos no processo de codiﬁcação
, como veremos mais a frente. Note ainda que para que isso seja possível
poderíamos ter tomado qualquer sistema completo de resíduos módulo S para fazer
a correspondência no lugar do intervalo [0, S − 1].

O próximo passo é a escolha de uma Função Aﬁm dada por f (x) = ax + b
com a, b ∈ Z e mdc(a, S) = 1 onde S é o número de símbolos do alfabeto. Como
queremos usar congruência módulo S, justiﬁca-se mdc(a, S) = 1, pois caso contrário
não existiria inverso de a módulo S (vide capítulo 2), o que é essencial para o
processo de decodiﬁcação como veremos adiante.

Exemplo 3.2 Adotando o alfabeto do Exemplo 3.1 poderíamos escolher f (x) =
3x+7 Essa função é a função de codiﬁcação, ou simplesmente "chave de codiﬁcação".

Codiﬁcando uma mensagem

O processo de codiﬁcação de uma mensagem é bem simples. Basta aplicar a
função de codiﬁcação e usar congruência módulo S para transformar letra em letra.

Exemplo 3.3 Adotando a função f (x) = 3x + 7 do Exemplo 3.2 e o alfabeto do
Exemplo 3.1 codiﬁque a mensagem "EU SOU O MILIOR".

Solução: Associando as letras da frase aos números temos:

EU
(cid:108)
(4 − 20)

SOU
(cid:108)
(18 − 14 − 20)

O
(cid:108)
(14)

M ILIOR
(cid:108)
(12 − 8 − 11 − 8 − 14 − 17)

Codiﬁcamos letra a letra da seguinte forma:

1 Para codiﬁcar a letra E=4 fazemos f (E) = f (4) = 3 · 4 + 7 = 19 e 19 ≡ 19 mod
26, como 19 = T temos que E ↔ T .

34

3.2. UM SISTEMA DE CRIPTOGRAFIA SIMÉTRICO COM FUNÇÃO AFIM

2 Para codiﬁcar a letra U=20 fazemos f (U ) = f (20) = 3 · 20 + 7 = 67 e 67 ≡ 15 mod
26, como 15 = P temos que U ↔ P .

Dos itens 1 e 2 obtemos EU ↔ T P

Seguindo O processo para as demais letras obtemos:

EU SOU O MILIOR ↔ TP JXP X RFOFXG

Logo a mensagem codiﬁcada é: TP JXP X RFOFXG.

Isso se

Observação 3.1 Perceba que podemos tomar inﬁnitas funções de codiﬁcação
e o processo não vai passar de uma correspondência com uma permutação
do alfabeto.
Usando a chave
f (x) = 3x + 7 para codiﬁcar todo o alfabeto do Exemplo 3.1 teremos:
H,K,N,Q,T,W,Z,C,F,I,L,O,R,U,X,A,D,G,J,M,P,S,V,Y,B,E como resultado do
alfabeto codiﬁcado. Isso é interessante pois independente da função tomada (que são
inﬁnitas), o Princípio Fundamental da Contagem nos garante que para um alfabeto
de S símbolos o número de chaves de codiﬁcação distintas possíveis é S!.

garante pela Proposição 2.4.

Decodiﬁcando uma mensagem

O processo de decodiﬁcação também é simples. Deﬁnida a função de codiﬁcação
f (x) = ax + b basta encontrar a inversa dada por f −1(x) = a(cid:48)x + b(cid:48) onde
a · a(cid:48) ≡ 1 mod S (a(cid:48) é o inverso de a mod S) e b(cid:48) = −a(cid:48) · b. Deste modo
f −1(ax + b) = a(cid:48) · (ax + b) − a(cid:48) · b = a(cid:48) · a · x ≡ x mod S. Note que f −1(x) sempre
existe, uma vez que na pré codiﬁcação era exigido que mdc(a, S) = 1. Encontrada
f −1(x) o processo de decodiﬁcação torna-se semelhante ao de codiﬁcação. Veja o
Exemplo 3.4

Exemplo 3.4 Decodiﬁque a mensagem codiﬁcada no Exemplo 3.3

Solução: Sabendo que f (x) = 3x + 7 inicialmente devemos encontrar a(cid:48) tal que
3 · a(cid:48) ≡ 1 mod 26, isso equivale a resolver a equação: 3a(cid:48) + 26k = 1, a qual tem
solução garantida pelo Teorema 1.3, seguindo o passo a passo do Exemplo 1.6 temos:

26 = 8 · 3 + 2
3 = 2 · 1 + 1

e consequentemente:

1 = 3 − 2 = 3 − 26 + 8 · 3 = 3 · 9 + 26 · (−1).

35

3.3. O RSA

Logo a(cid:48) = 9. E consequentemente

f −1(x) = 9x − 9 · 7 = 9x − 63

Como −63 ≡ 15 mod 26, podemos reescrever a inversa como

f −1(x) = 9x + 15

Agora, iniciamos a decodiﬁcação da mensagem TP JXP X RFOFXG da seguinte
forma:

1 Como T=19, fazemos f −1(T ) = f −1(19) = 9 · 19 + 15 = 186 e 186 ≡ 4 mod 26,
como 4=E, temos que T ↔ E.
2 Como P=15, fazemos f −1(T ) = f −1(15) = 9 · 15 + 15 = 150 e 150 ≡ 20 mod 26,
como 20=U, temos que P ↔ U .

Dos itens 1 e 2 obtemos

T P ↔ EU

Seguindo o processo para as demais letras obtemos:

T P JXP XRF OF XG ↔ EU SOU OM ILIOR

E temos como mensagem decodiﬁcada: "EU SOU O MILIOR".

3.3 O RSA

O método apresentado a seguir pode ser encontrado no livro de Coutinho [2]

sendo possível a veriﬁcação de sua validade no mesmo.

Pré-codiﬁcação

Inicialmente devemos deﬁnir o alfabeto a ser utilizado em nosso sistema e fazer
cada elemento de nosso alfabeto corresponder a um número. É de fundamental
importância ser estrategista nesse momento e buscar evitar ambiguidades. Se o nosso
alfabeto tiver menos de 10 caracteres podemos associá-lo aos números 0,1,2,...9.
Se tiver até 90 caracteres podemos associar cada elemento a um número de dois
dígitos. Se tiver até 900 caracteres podemos associar cada elemento a um número
de 3 dígitos e assim sucessivamente. Note que se fosse usada uma correspondência
com quantidade de dígitos diferentes podemos gerar ambiguidades do tipo: Na
correspondência A ↔ 1, B ↔ 2, C ↔ 3, ...Z ↔ 26 A palavra 191512 Pode ser
interpretada como AIAEAB interpretando A ↔ 1, I ↔ 9, E ↔ 5, B ↔ 2 como

36

3.3. O RSA

SAEL se S ↔ 19, A ↔ 1, E ↔ 5, L ↔ 12, como SOL se S ↔ 19, O ↔ 15, L ↔ 12,
e assim por diante. Com isso percebemos a importância de deixar bem deﬁnido o
alfabeto e tornar a correspondência dos caracteres com os números não ambígua.

Vamos deﬁnir nosso alfabeto como sendo A, B, C, D, E, F, G, H, I, J, K, L, M,

N, O, P, Q, R, S, T, U, V, W, X, Y, Z e façamos a seguinte correspondência:

A ↔ 11, B ↔ 13, C ↔ 15, D ↔ 17, E ↔ 22, F ↔ 33, G ↔ 70, H ↔ 71, I ↔
72, J ↔ 73, K ↔ 74, L ↔ 75, M ↔ 41, N ↔ 57, O ↔ 58, P ↔ 67, Q ↔ 65, R ↔
28, S ↔ 42, T ↔ 43, U ↔ 44, V ↔ 45, W ↔ 47, X ↔ 88, Y ↔ 83, Z ↔ 37

O espaço entre duas palavras será substituído por 99.

Vamos usar como exemplo a frase "ESSE CARA SOU EU" que convertida em

números torna-se:

22424222991511281199425844992244

Agora vamos deﬁnir os parâmetros do sistema RSA, ou seja, vamos deﬁnir os
dois primos p e q e tomemos n = p · q como exemplo, tomemos p = 17 e q = 19, daí
n = 323.

A última fase do processo é a quebra do número produzido na mensagem em
blocos com a condição de que esses blocos devem ser números menores que n. Essa
quebra também deve ser estratégica, a primeira coisa que devemos ter cuidado é para
que nenhum bloco comece por 0, pois isso traria problemas na hora de decodiﬁcar
(como vemos mais a frente). Também é interessante fazer com que os blocos
não correspondam a nenhuma unidade linguística, pois isso torna a decodiﬁcação
por contagem de frequência essencialmente impossível. Seguindo essas instruções
podemos quebrar o número do exemplo acima nos seguintes blocos:

2 − 242 − 4 − 222 − 9 − 91 − 51 − 128 − 119 − 94 − 25 − 84 − 49 − 92 − 244

Vale ressaltar que a maneira de escolher os blocos não é única, no entanto devemos
sempre tomar os cuidados citados anteriormente para tornar sistema seguro. Com
isso encerramos as etapas de pré-codiﬁcação do sistema RSA.

Codiﬁcando

Para o processo de codiﬁcação precisamos do valor de n = p · q (produto
dos primos escolhidos) e um número inteiro α tal que mdc(α, φ(n)) = 1, pois
queremos que α seja inversível módulo φ(n). Chamamos o par (n, α) de chave
de codiﬁcação, note que para um mesmo n escolhido podemos criar mais de uma
chave de codiﬁcação, pois α não é único. Note ainda que é fácil encontrar um α,

37

3.3. O RSA

pois como α depende de φ(n), pelo que estudamos sobre a função φ(n) no Teorema
2.4 e na subseção 2.3.4 sabemos que conhecidos os valores de p e q torna-se muito
fácil encontrar o valor de φ(n = p · q) que é dado por φ(n) = (p − 1) · (q − 1). Por
isso p e q devem ser mantidos em segredo e o sucesso desse sistema depende disso.
Vejamos na prática como funciona a codiﬁcação. Para isso, sigamos o exemplo

usado na pré codiﬁcação, cujos blocos gerados foram:

2 − 242 − 4 − 222 − 9 − 91 − 51 − 128 − 119 − 94 − 25 − 84 − 49 − 92 − 244

Com n = 323, p = 17, q = 19 e consequentemente φ(n) = 17·18 = 288, daí podemos
escolher α = 5 pois mdc(5, 288) = 1.

Devemos codiﬁcar os blocos separadamente e o resultado da codiﬁcação de cada
bloco deve permanecer separado, visando tornar viável o processo de decodiﬁcação.
Mas como é o processo de codiﬁcação?

Bem, denotando por C(b) um bloco codiﬁcado, a receita para chegar a C(b) é
C(b) = Resto da divisão de bα por n (onde b é o bloco a ser codiﬁcado), noutras
palavras,

bα ≡ C(b) mod n com C(b) =Mín N que satisfaz a congruência.

Assim, o bloco 2 da mensagem anterior é codiﬁcado como o resto da divisão de 25
por 323. Como 32 = 25 ≡ 32 mod323, concluímos que C(2) = 32. Fazendo as contas
para os demais blocos temos:

C(4)=55

C(242)=276
C(9)=263
C(51)=204 C(128)=314 C(119)=85 C(94)=246
C(49)=121 C(92)=232 C(244)=194
C(84)=50

C(222)=52

C(91)=211
C(25)=43

Logo a mensagem codiﬁcada é dada por:

32 − 276 − 55 − 52 − 263 − 211 − 204 − 314 − 85 − 246 − 43 − 50 − 121 − 232 − 194

e assim, ﬁnalizamos a etapa de codiﬁcação.

Decodiﬁcando

O segredo do sistema RSA está na decodiﬁcação, pois a mesma só pode ser feita
por quem tem conhecimento dos primos p e q escolhidos. Mesmo conhecendo a
chave de codiﬁcação e sabendo codiﬁcar, não saber os valores de p e q faz com que o
processo de decodiﬁcação seja praticamente impossível. Por isso, o RSA é dito um
sistema de chave pública (Todos podem tem acesso a chave de codiﬁcação). Mas
como decodiﬁcar uma mensagem?

38

3.3. O RSA

Anteriormente usando n = 323, α = 5 e φ(323) = 288 chegamos a seguinte

mensagem codiﬁcada

32 − 276 − 55 − 52 − 263 − 211 − 204 − 314 − 85 − 246 − 43 − 50 − 121 − 232 − 194

Para decodiﬁcar a mensagem precisamos de duas informações, a primeira é n = p · q
e a segunda é o inverso de α módulo φ(n) ao qual denominaremos α(cid:48). O par (n, α(cid:48))
é a chave de decodiﬁcação. Deﬁnindo D(x) como sendo um bloco decodiﬁcado, a
receita para calcular D(x) é dada por D(x) = resto da divisão de xα(cid:48) por n(onde x
é um bloco codiﬁcado), ou de modo equivalente:

xα(cid:48) ≡ D(x) mod n, com D(x) =mín N que satisfaz a congruência.

Iniciamos o processo calculando o inverso de α módulo φ(n) resolvendo a congruência
5 · α(cid:48) ≡ 1 mod 288, isso equivale a 5 · α(cid:48) − 1 = 288w que pode ser reescrito como
5 · α(cid:48) − 288 · w = 1, aplicando o Algoritmo Euclidiano temos:

288 = 5 · 57 + 3
5 = 1 · 3 + 2
3 = 1 · 2 + 1

E consequentemente,

1 = 3 − 2 = 3 − (5 − 3) = 3 − 5 + 3 = 2 · 3 − 5 = 2(288 − 5 · 57) − 5 = 2 · 288 − 115 · 5
Daí α(cid:48) = −115 + 288t com t ∈ Z e com t = 1 podemos tomar α(cid:48) = 173.

Agora, aplicando a receita no bloco x = 32, temos que encontrar o resto da
divisão de 32173 por 323, o que pode ser resolvendo a congruência 32173 ≡ b mod
323, para isso, basta utilizar as propriedades de congruência, no entanto, fazer isso
manualmente é desgastante, por isso é de fundamental importância o uso de uma
calculadora algébrica. Para isso usaremos a WolframAlpha que pode ser acessada em
www.wolframalpha.com, nela para resolver essa equação basta digitar "32173 mod
323"e veremos que o resto que queremos é 2, logo D(32) = 2. Repetindo o processo
para os demais blocos temos:

D(55)=4

D(52)=222 D(263)=9 D(211)=91
D(276)=242
D(204)=51 D(314)=128 D(85)=119 D(246)=94 D(43)=25
D(121)=49 D(232)=92 D(194)=244
D(50)=84

E daí a lista de blocos decodiﬁcados é dada por:

2 − 242 − 4 − 222 − 9 − 91 − 51 − 128 − 119 − 94 − 25 − 84 − 49 − 92 − 244

Agora juntando esses blocos formamos o número

22424222991511281199425844992244

Como na pré codiﬁcação cada letra tinha dois dígitos, basta associar o resultado
ao alfabeto deﬁnido 22-E, 42-S, 99-espaço, 15-C,... chegando a frase "ESSE CARA
SOU EU".

39

3.4. VARIAÇÃO DO RSA (CODIFICANDO PALAVRAS EM PALAVRAS)

3.4 Variação do RSA (codiﬁcando palavras em

palavras)

Essa variação é encontrada em [8]. O processo é semelhante,

inicialmente
escolhemos dois primos p e q extremamente grandes e deﬁnimos n = p·q, calculamos
φ(n) = (p−1)·(q−1) = n+1−p−q, escolhemos 1 < α < φ(n) tal que mdc(α, φ(n))=1
e calculamos o inverso multiplicativo de α módulo φ(n) resolvendo a congruência
α · α(cid:48) ≡ 1 mod n. A chave de codiﬁcação é (n, α) e a chave de decodiﬁcação é (n, α(cid:48))

Codiﬁcação

A receita de codiﬁcação para um bloco b é dada por C(b) ≡ bα mod n, onde C(b)
é o resultado do bloco b codiﬁcado. A mudança dessa variação com relação a anterior
na receita de codiﬁcação é que nessa os blocos gerados na pré codiﬁcação devem ter
a mesma quantidade de caracteres, ou seja, quebramos a mensagem original em
blocos de 2, ou 3 ou 4... dígitos uniformemente.

Decodiﬁcação

A receita decifradora de um bloco codiﬁcado C(b) = x é dada por D(x) ≡ xα(cid:48)
mod n. Ora, mas até aqui o processo é essencialmente o mesmo se comparado com
o descrito anteriormente. O que muda de fato? A mudança é que nessa variação
deseja-se codiﬁcar uma palavra em um bloco de letras, e não de números, para isso a
mudança se dá pelo uso das bases numéricas e a aritmética dos restos implementada
a associação de um alfabeto bem organizado no processo de pré codiﬁcação.

Pré codiﬁcação

Devemos ter um mínimo de organização na escolha do alfabeto, para que assim
torne-se viável a associação de números a letras por meio da aritmética dos restos. Se
estamos trabalhando com um alfabeto de S símbolos, fazemos uma correspondência
biunívoca entre os símbolos do alfabeto e os inteiros do intervalo [0, S − 1]. Depois
disso, dividimos o texto que queremos cifrar (já associado aos números) em blocos de
k dígitos e escolhemos a quantidade m de dígitos que os blocos codiﬁcados devem ter
(ou seja, no processo serão transformados blocos de k dígitos em blocos de m dígitos).
Para que não ocorram falhas devemos escolher k e m de modo que Sk < n < Sm
se k < m ou Sm < n < Sk caso m < k, pois com isso qualquer unidade de texto
simples corresponde a um elemento em Zn e a unidade codiﬁcada C(b) ≡ bα mod n
que também é um elemento de Zn pode ser escrita como um bloco de m letras.

40

3.4. VARIAÇÃO DO RSA (CODIFICANDO PALAVRAS EM PALAVRAS)

Exemplo 3.5 Tomemos L = 26, k = 3 e m = 4, ou seja, o texto original deve
ser dividido em blocos de 3 caracteres o texto cifrado em blocos de 4 caracteres. No
alfabeto usual, façamos a seguinte associação:

A B C ... K L ... X Y Z
(cid:108)
(cid:108)
(cid:108) ...
2 ... 10 11 ... 23 24 25
0

(cid:108)
1

...

(cid:108)

(cid:108)

(cid:108)

(cid:108)

Para enviarmos a mensagem sol, para o usuário A com a chave de codiﬁcação:
(nA, αA) = (46927, 39423) gerada pelos primos p = 167 e q = 281, primeiro
determinamos a equivalência numérica:

SOL ↔ 18 · 262 + 14 · 26 + 11 = 12543

E então calculamos

C(b) ≡ 1254339423 mod 46927

Que é 24599 = 1 · 263 + 10 · 262 + 10 · 26 + 3 que equivale a mensagem codiﬁcada
BKKC.

O destinatário conhece a chave de decodiﬁcação (46927, 26767) e portanto calcula:

D(x) ≡ 2459926767 mod 46927

Que é 12543 = 18 · 262 + 14 · 26 + 11 e portanto recupera a mensagem SOL.

Exemplo 3.6 Usando os mesmos dados do exemplo anterior, vamos analisar como
seria o processo para a mensagem "FLAMENGOL".

Inicialmente dividimos a mensagem em blocos de 3 letras e associamos aos

números do alfabeto obtendo:

FLA(5-11-0↔ 5 · 262 + 11 · 26 + 0)
MEN(12-4-13↔ 12 · 262 + 4 · 26 + 3)
GOL(6-14-11↔ 6 · 262 + 14 · 26 + 11)

Ou seja FLA↔ 3666, MEN↔ 8219 e GOL↔ 4431.

Daí calculamos:

1. C(3666) ≡ 366639423 mod 46927 o que resulta em C(3666) = 13754 =

0 · 263 + 20 · 262 + 9 · 26 + 0 que equivale a palavra AUJA.

41

3.5. COMENTÁRIOS ACERCA DAS DUAS VARIAÇÕES DO RSA

2. C(8219) ≡ 821939423 mod 46927 = 3606 = 0 · 263 + 5 · 262 + 8 · 26 + 15 o que

nos dá a palavra AFIP.

3. C(4431) ≡ 443139423 mod 46927 = 15589 = 0 · 263 + 23 · 262 + 1 · 26 + 15 o

que gera a palavra AXBP.

Agora, unindo 1,2 e 3 obtemos a mensagem codiﬁcada:

FLAMENGOL↔ AUJAAFIPAXBP

Para decodiﬁcar aplicamos a chave (46927, 26767) e calculamos:

1. D(13754) ≡ 1375426767 mod 46927 o que resulta em D(13754) = 3666 =

5 · 262 + 11 · 26 + 0 · 26 + 0 que equivale a palavra FLA.

2. D(3603) ≡ 360326767 mod 46927 = 8219 = 12 · 262 + 4 · 26 + 3 o que nos dá a

palavra MEN.

3. D(15589) ≡ 1558926767 mod 46927 o que resulta em D(15589) = 4431 =

6 · 262 + 14 · 26 + 11 · 26 + 0 que equivale a palavra GOL.

E com isso obtemos a mensagem decifrada FLAMENGOL.

3.5 Comentários acerca das duas variações do RSA

Note que em ambos os sistemas apresentados aqui a segurança é equivalente
quando tomados dois números primos extremamente grandes. Poderíamos pensar
que no segundo método a mensagem poderia ser quebrada por frequência, mas
perceba que se a variação do tamanho dos blocos for utilizada de maneira estratégica
torna-se inviável a análise por frequência.

Outro fato é que mesmo sendo extremamente grandes, se os números primos não
forem escolhidos de maneira estratégica, o sistema pode se tornar fraco. Pois se os
p · q,
números p, q forem escolhidos de modo que p ou q estejam próximos de
a chave pode ser quebrada utilizando uma calculadora algébrica avançada atrelada
ao método de fatoração de Fermat visto no capítulo 1.

n =

√

√

42

Capítulo 4

Sugestões de atividades para sala de
aula

4.1 Criando um modelo de Criptograﬁa Simples

Público: Alunos da 1a série do ensino médio

Material: Lápis, borracha, folhas de papel, celulares, tablets, computadores e
projetor multimídia.

Tempo previsto: Quatro horas aulas.

Objetivos

1. Compreender o conceito de função por meio da noção de chaves de entradas

e saídas de modelos de criptograﬁa;

2. Fazer o uso de critérios de divisibilidade para deﬁnição de primalidade de um

número;

3. Mostrar a importância da matemática e sua aplicação em meios tecnológicos

e sistemas de segurança;

4. Ampliar o conhecimento histórico sobre a segunda guerra, analisando a

importância de Alan Turing para o ﬁm da mesma.
5. Instigar a autonomia e o autodidatismo;
6. Estimular a pesquisa cientíﬁca.

Pré-requisitos: Noções iniciais do conceito de função, relação, função inversa e
relação inversa.

43

4.1. CRIANDO UM MODELO DE CRIPTOGRAFIA SIMPLES

Desenvolvimento da atividade

Inicialmente o professor deve expor o conceito de criptograﬁa e o seu contexto
histórico, apresentando os primeiros modelos de criptograﬁa e a sua relação com
a ideia de relações e funções por meio das chaves de entrada e relações e funções
inversas por meio das chaves de saída.

Em seguida, o professor deve resgatar a disciplina de história de modo
interdisciplinar
(como propõe o novo ensino médio) e comentar a parte
"desconhecida"da segunda guerra mundial onde Alan Turing e sua equipe tiveram
um papel importante para quebrar os segredos da Enigma e de maneira estratégica
prever os movimentos dos Nazistas, ajudando a por ﬁm na guerra.

Após isso, o professor pode comentar as fragilidades do sistema de Júlio César
(cifras de César, vide seção 3.1), e sugerir como atividade para os alunos a criação
de um modelo aprimorado baseado na cifra de césar corrigindo algumas de suas
fragilidades. É importante que nesse momento os alunos tenham em mente a
importância de apresentar de forma clara e objetiva as chaves de entrada e saída do
modelo criado, para isso, deve-se solicitar a criação de uma mensagem codiﬁcada
com esse modelo, à qual deve ser decodiﬁcada por um colega.

Perguntas a serem feitas: Quanto mais demorado o processo de decodiﬁcação,
melhor o modelo? Como reduzir os padrões nas palavras do modelo? É possível fazer
a troca de chaves sem contato presencial de modo seguro? É possível converter esse
modelo para o sistema binário?

Divisão do tempo

Uma aula será destinada a apresentação do contexto histórico e o conceito de
criptograﬁa. Uma aula será destinada a revisão do conceito de função inversa e
a sua interligação com os sistemas de criptograﬁa, fazendo associação as chaves
de entrada e de saída. Uma aula será destinada a criação de um modelo de
criptograﬁa por cada um dos estudantes no qual eles devem associar a relação
de função inversa com as chaves de entrada e saída de seus modelos, feito isso
cada um deverá escrever uma mensagem com o modelo criado. A última aula será
destinada ao processo de decodiﬁcação de mensagem e eleição dos modelos mais
seguros, fazendo uma análise baseada na diﬁculdade de codiﬁcação e decodiﬁcação,
nesta aula devem ser apresentadas propostas de melhoria dos modelos por parte do
professor e apresentadas indagações que quando respondidas podem dar a ideia de
funcionamento de sistemas de criptograﬁa mais complexos.

44

IMPLEMENTANDO UM MODELO DE CRIPTOGRAFIA COM FUNÇÃO

4.2.
AFIM NO CONSTRUCT

4.2

Implementando um modelo de criptograﬁa com
função aﬁm no Construct

Para aplicação em sala de aula a nível médio o modelo usando função aﬁm torna-
se viável e atrativo, pois é simples e aborda uma gama de habilidades já trabalhadas
no decorrer do ensino médio. Por isso, implementamos de modo inicial esse sistema
simétrico simples (vide seção 3.2), no entanto a aplicação do RSA também pode
acontecer, mas com ﬁnalidades diferentes como preparação para olimpíadas ou um
curso de extensão. Para um melhor detalhamento sobre o a implementação desse
modelo em sala de aula e no Construct ver [4], [5] e [9].

Público: Alunos da 1a série do ensino médio

Material: Lápis, borracha, folhas de papel, celulares, tablets, computadores e
projetor multimídea.

Tempo previsto: Quatro horas aulas.

Objetivos

1. Compreender o conceito de função por meio da noção de chaves de entradas

e saídas de modelos de criptograﬁa;

2. Usar o algoritmo de Euclides para o cálculo do mdc de dois números inteiros

e encontrar o inverso módulo m de um número inteiro;

3. Mostrar a importância da matemática e sua aplicação em meios tecnológicos

e sistemas de segurança;

4. Determinar a inversa de uma função aﬁm,
5. Instigar a autonomia e o autodidatismo;
6. Estimular a pesquisa cientíﬁca.

Pré-requisitos: Noções iniciais do conceito de função, relação, função inversa e
relação inversa. Conhecimentos de função aﬁm. Noção de funcionalidade de um
sistema de criptograﬁa e aplicação prática do mesmo.

Desenvolvimento da atividade

Inicialmente o professor deve expor o conceito de criptograﬁa e seu contexto
histórico, apresentando os primeiros modelos de criptograﬁa e a sua associação com
a ideia de relações e funções por meio das chaves de entrada e relações e funções
inversas por meio das chaves de saída.

45

4.3. COMENTÁRIO SOBRE AS APLICAÇÕES FEITAS EM SALA DE AULA

Em Seguida o professor deve apresentar o Algoritmo Euclidiano para o cálculo
do mdc de dois inteiros e apresentar a ideia de congruência e inverso multiplicativo
na aritmética dos restos.

Após isso, o professor deve juntamente com os alunos deﬁnir o alfabeto a ser
utilizado no modelo de criptograﬁa a ser criado, criar e fazer ensaios do mesmo
utilizando função aﬁm (Vide seção 3.2) e por ﬁm implementá-lo no Costruct e fazer
um ensaio de seu funcionamento. O Construct é um programa online, utilizado para
criação de jogos, pode ser acessado através do endereço https://editor.construct.net.
Mais detalhes e o passo dessa etapa são encontrados em [4].

Perguntas a serem feitas: Esse modelo é eﬁcaz? Qual o nível de segurança desse
modelo? É possível fazer a troca de chaves sem contato presencial de modo seguro?
É possível converter esse modelo para o sistema binário?

Por ﬁm, é interessante apresentar a ideia de funcionamento do sistema RSA,
visando estimular os estudantes a pesquisa. Essa etapa deve ser trabalhada como
um fato curioso, para que o estudante estimule-se a pesquisar. Não é necessário
aprofundar-se na mesma.

Divisão do tempo

Uma aula será destinada a revisão do conceito de função inversa de uma função
aﬁm e a sua interligação com os sistemas de criptograﬁa, fazendo associação as
chaves de entrada e de saída. Uma aula será destinada ao estudo da aritmética dos
restos, abordando o conceito de congruência, inverso multiplicativo e o Algoritmo
Euclidiano. E duas aulas serão destinadas a criação de um modelo de criptograﬁa
de função aﬁm e implementação do mesmo no Construct.

Passo a passo: O passo a passo para construção de um modelo de criptograﬁa
usando função aﬁm e sua implementação no Construct pode ser encontrado no artigo
[4].

4.3 Comentário sobre as aplicações feitas em sala

de aula

O desenvolvimento das aulas citadas acima foi feito com 15 estudantes das 1o e
2o séries do ensino médio da escola cidadã integral técnica Lynaldo Cavalcanti de
Albuquerque na cidade de Patos-PB.

As práticas permitiram a abordagem dos conceitos de função, função inversa,
analise combinatória e aprofundamento de estudos abordando equações diofantinas
e congruência de números inteiros (que são conteúdos abordados nas aulas do
programa OBMEP na escola da Sociedade Brasileira de Matemática), além de

46

4.3. COMENTÁRIO SOBRE AS APLICAÇÕES FEITAS EM SALA DE AULA

que, dentro da proposta de nivelamento do novo ensino médio foi possível revisar
operações com números inteiros e interpretação gráﬁca, que são duas das habilidades
de propulsão (nivelamento) elencadas pela matriz curricular do novo ensino médio.
Os resultados foram satisfatórios e a avaliação de aprendizagem foi feita por
meio de atividades propostas no decorrer do processo como: criação de modelos
de criptograﬁa por parte dos alunos, aprimoramento desses modelos por meio
da noção de funções e congruências de números inteiros e implementação no
Construct. As contas envolvidas no processo em um primeiro instante foram feitas
manualmente, depois disso instigou-se o uso de calculadoras algébricas, em especíﬁco
a Wolframalpha que pode ser acessada em https://www.wolframalpha.com. Os
estudantes se mostraram participativos e bastante interessados no desenvolvimento
de cada etapa das aulas, inclusive alguns projetos de vida foram despertados dentro
das etapas das aula, pois dois dos estudantes aﬁrmaram que as temáticas abordadas
inﬂuenciaram na formulação de seus projetos de vida, tendo em vista que nas aulas
foram abordados temas de interesse deles.

Para ter sucesso na aplicação dessas práticas, deve-se ter planejamento voltado
a realidade de cada turma, pois, por ser um conteúdo amplo e com níveis
diferentes, podemos estipular ﬁnalidades de aprendizado especíﬁco, pois tanto
podemos trabalhar como prática experimental ou curso de aprofundamento (política
da OBMEP na escola), ou até mesmo como nivelamento de conceitos básicos, dentro
da proposta de nivelamento do novo ensino médio.

Estas propostas de atividades visam despertar curiosidade no aluno com relação
às aplicações da matemática, mostrando a importância do estudo da mesma para
si e a importância da mesma no desenvolvimento de tecnologias no decorrer da
história. Por que despertar curiosidade sobre a matemática? Estudiosos como
Freire [6] e Assmann [1] discutem que a curiosidade faz com que os discentes
quebrem as barreiras da sala de aula e busquem o conhecimento de modo amplo.
"Alunos curiosos não fazem só perguntas, mas vão em busca de respostas"[1]. A
curiosidade prepara o cérebro para aprender, exercita a mente para o novo, isso faz
com que a aprendizagem ocorra com excelência, haja vista que segundo a teoria da
inteligência multifocal nossa memória necessita de estimulo e emoções para gravar
a aprendizagem ao longo prazo [3]. Para estimular, as práticas sugerem um estudo
das tecnologias de segurança incorporadas no decorrer da história visando troca de
informações de maneira segura.

impresso
Observação 4.1 Mediante
aplicado no ﬁnal do desenvolvimento das aulas acima, constatou-se que obteve-se
uma média de aproveitamento de 80% de todas as temáticas abordadas. A seguir,
nas Figuras 4.1 e 4.2, temos dois dos formulários aplicados com as respostas dos
estudantes A e B.

formulário

47

4.3. COMENTÁRIO SOBRE AS APLICAÇÕES FEITAS EM SALA DE AULA

Figura 4.1: Formulário respondido pelo aluno A

48

4.3. COMENTÁRIO SOBRE AS APLICAÇÕES FEITAS EM SALA DE AULA

Figura 4.2: Formulário respondido pelo aluno B

49

Referências Bibliográﬁcas

[1] ASSMANN, Hugo, Curiosidade e Prazer de Aprender – O papel da curiosidade

na aprendizagem criativa. – Petropolis, RJ: Editora Vozes, 2004.

[2] COUTINHO, S. C. Números inteiros e criptograﬁa RSA. 2. ed. Rio de Janeiro:

IMPA, 2014. 226 p. ISBN 978-85-244-0124-4.

[3] CURY, Augustu. Inteligência Multifocal. São Paulo: Cultrix, 1998.

[4] DE MENEZES NETO, Jose Laudelino. Escrevendo em código: aprendendo
em:

a
http://dx.doi.org/10.13140/RG.2.2.30266.47044. Acesso em 24/12/2022.

criptografar.

Disponível

2022.

[5] DE MENEZES NETO, José Laudelino, Primeiros Passos em Criptograﬁa. 1.
ed. Editora UFPB, 2021. Disponível em: https://laudelino.dcx.ufpb.br/livro

[6] FREIRE, Paulo. Pedagogia do oprimido, 17a ed., Rio de Janeiro: Paz e Terra,

1987.

[7] HEFEZ, Abramo. Aritmética. 2. ed. Rio de Janeiro: SBM, 2016. 298 p. ISBN

978-85-8337-105-2.

[8] KOBLITZ, Neal. A course in number theory and cryptography. Springer, 1994.

[9] MIRANDA, Ariane Andressa Noronha de Sousa; PAULA, Fernanda Vital
de. Uma proposta para o ensino de funções aﬁns por meio da criptograﬁa.
REAMEC - Rede Amazônica de Educação em Ciências e Matemática, v.9, n.
2, 2021. DOI: https://doi.org/10.26571/reamec.v9i2.12652

[10] RIBEIRO, Bruno; SILVA, Talysson Paulo da. Montando critérios de
divisibilidade diferentes. Professor de matemática, Revista eletrônica da
sociedade brasileira de matemática, ano 2020, v. 8, n. 2, p. 170-179.

[11] RIBENBOIM, Paulo. Números primos: Velhos mistérios, novos recordes. 3. ed.

Rio de Janeiro: SBM, 2020. 317 p. v. 1. ISBN 978-65-89124-03-0.

50

REFERÊNCIAS BIBLIOGRÁFICAS

[12] RIBENBOIM, Paulo. Números primos, amigos que causam problemas: Um
triálogo com o Papa Paulo. 1. ed. aum. Rio de Janeiro: SBM, 2015. 408 p. v.
1. ISBN 978-85-8337-021-5.

[13] SINGH, S. O livros dos Códigos, Editora Record, Terceira Edição, 2003.

[14] VIEIRA, Vandemberg Lopes. Um curso básico em teoria dos números. 1. ed.

Campina Grande: Eduepb, 2015. 560 p. v. 1. ISBN 987-85-7879-275-6.

51

