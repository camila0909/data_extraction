ANDRÃ‰ VINÃCIUS SPINA

NÃšMEROS PRIMOS E CRIPTOGRAFIA

CAMPINAS
2014

i

ii

Ficha catalogrÃ¡ficaUniversidade Estadual de CampinasBiblioteca do Instituto de MatemÃ¡tica, EstatÃ­stica e ComputaÃ§Ã£o CientÃ­ficaMaria Fabiana Bezerra Muller - CRB 8/6162      Spina, AndrÃ© VinÃ­cius, 1986-  Sp46nSpiNÃºmeros primos e criptografia / AndrÃ© VinÃ­cius Spina. â€“ Campinas, SP : [s.n.],2014.      SpiOrientador: Ricardo Miranda Martins.  SpiDissertaÃ§Ã£o (mestrado profissional) â€“ Universidade Estadual de Campinas,Instituto de MatemÃ¡tica, EstatÃ­stica e ComputaÃ§Ã£o CientÃ­fica.       Spi1. NÃºmeros primos. 2. Criptografia - MatemÃ¡tica. I. Martins, RicardoMiranda,1983-. II. Universidade Estadual de Campinas. Instituto de MatemÃ¡tica,EstatÃ­stica e ComputaÃ§Ã£o CientÃ­fica. III. TÃ­tulo. InformaÃ§Ãµes para Biblioteca DigitalTÃ­tulo em outro idioma: Prime numbers and encryptionPalavras-chave em inglÃªs:Primes numbersCryptography - MathematicsÃrea de concentraÃ§Ã£o: MatemÃ¡tica em Rede NacionalTitulaÃ§Ã£o: Mestre em MatemÃ¡tica em Rede NacionalBanca examinadora:Ricardo Miranda Martins [Orientador]Ary Orozimbo ChiacchioAngelo Calil BianchiData de defesa: 31-03-2014Programa de PÃ³s-GraduaÃ§Ã£o: MatemÃ¡tica em Rede NacionalPowered by TCPDF (www.tcpdf.org)ivAbstract

The paper presents a Number Theory introduction, trough a RSA and Diffie-Hellman crypto-
graphic methods approach, where one can observe situations where they are effective. The mathe-
matical theory introduced in this paper encompass prime numbers, Modular arithmetic,Primality
test, groups and other Number Theory related branches.

Keywords: Primes numbers, Cryptography-Mathematics.

Resumo

A pesquisa apresentarÃ¡ uma introduÃ§Ã£o a Teoria dos NÃºmeros atravÃ©s de uma abordagem
sobre os mÃ©todos criptogrÃ¡ficos RSA e Diffie-Hellman, onde pode-se constatar situaÃ§Ãµes onde eles
sÃ£o eficientes. A teoria matemÃ¡tica presente nesse trabalho envolve conhecimentos em nÃºmeros
primos, aritmÃ©tica modular, testes de primalidade, grupos e outras questÃµes envolvendo teoria dos
nÃºmeros.

Palavras-chave: NÃºmeros primos, Criptografia-MatemÃ¡tica.

vi

SumÃ¡rio

DedicatÃ³ria

Agradecimentos

IntroduÃ§Ã£o

1 PRELIMINARES

1.1 Teorema Fundamental da AritmÃ©tica . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Pequeno Teorema de Fermat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Grupos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

viii

ix

1

3
4
6
9

2 TESTES DE PRIMALIDADE

2.1 Teste De Leibniz
2.2 Teste de Miller
2.3 Teste de Lucas

15
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

3 MÃ‰TODOS CRIPTOGRÃFICOS

22
3.1 Criptografia RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.2 Criptografia Diffie-Hellman . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

4 SEQUÃŠNCIA DIDÃTICA

35
IntroduÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.1
4.2 Objetivos
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.3 Metodologia e ApresentaÃ§Ã£o de Materiais . . . . . . . . . . . . . . . . . . . . . . . . 36
4.4 Roteiro detalhado da proposta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.5 ConsideraÃ§Ãµes finais sobre a aplicaÃ§Ã£o . . . . . . . . . . . . . . . . . . . . . . . . . . 39

ReferÃªncias

43

vii

Dedico esta dissertaÃ§Ã£o a toda minha famÃ­lia, amigos e principalmente a meus alunos, que ao
estudÃ¡-la consigam sentir um pouco do prazer que a matemÃ¡tica Ã© capaz de proporcionar.

viii

Agradecimentos

A Deus por ter me dado forÃ§as que me permitiram chegar atÃ© aqui, por ter me apontado a
direÃ§Ã£o a qual me levou a conquistar esse meu sonho. Obrigado Pai, o Senhor Ã© meu caminho,
minha verdade e minha vida. A minha famÃ­lia por toda a educaÃ§Ã£o, carinho, confianÃ§a e paciÃªncia
que me foram concedidas e que serviram de alicerce para o meu comprometimento e paixÃ£o com
os estudos. Muito obrigado por terem me permitido sonhar. Em especial a minha MÃ£e e meu
Pai, meus primeiros professores, meu porto seguro. A todos os amigos que Deus colocou no meu
caminho, os quais me levaram a ser quem sou. A todos os meus professores que me ajudaram a
chegar atÃ© aqui, desde minha mÃ£e que me ensinou minhas primeiras palavras atÃ© meu orientador,
Ricardo Miranda Martin, o qual acompanhou todos os passos da elaboraÃ§Ã£o dessa dissertaÃ§Ã£o.
AgradeÃ§o tambÃ©m a CAPES pelo apoio financeiro e ao IMECC UNICAMP por abrir as portas
para que eu pudesse realizar o sonho de cursar mestrado.

ix

IntroduÃ§Ã£o

Todos os nÃºmeros inteiros ğ‘› â‰¥ 2 sÃ£o formados como produtos de nÃºmeros primos, ou seja,
os nÃºmeros primos sÃ£o a matÃ©ria prima para a construÃ§Ã£o dos nÃºmeros. Mas, como encontrar
nÃºmeros primos? Os nÃºmeros primos aparecem ao acaso no nosso conjunto numÃ©rico e descobrir
uma maneira eficaz de encontrÃ¡-los tem sido a tarefa de alguns matemÃ¡ticos por mais de dois
mil anos, tarefa que, apesar de alguns avanÃ§os, continua sem soluÃ§Ã£o. Assim sendo, dar sentido
a ordem dos nÃºmeros primos e descobrir uma maneira eficaz de encontrÃ¡-los Ã© um problema e,
tambÃ©m, um desafio.

Nos Ãºltimos anos essa questÃ£o ganhou uma nova forma de incentivo, devido a um mÃ©todo
criptogrÃ¡fico chamado RSA, no qual todo o sistema financeiro atual esta apoiado e o qual se
utiliza de nÃºmeros primos para tornar essas operaÃ§Ãµes seguras. SeguranÃ§a essa, que se baseia na
dificuldade de encontrar os fatores primos de um dado nÃºmero. Se esse problema tivesse soluÃ§Ã£o, se
fosse possÃ­vel fatorar um nÃºmero rapidamente, a seguranÃ§a do sistema financeiro atual deixaria de
existir, pois tal mÃ©todo criptogrÃ¡fico seria inutilizado, bem como todas as suas atuais aplicaÃ§Ãµes.
Sabemos que grande parte das transaÃ§Ãµes que envolvem dinheiro, tais como compras com
cartÃ£o de crÃ©dito e atÃ© mesmo saques em caixas eletrÃ´nicos sÃ£o feitas via internet, podendo assim,
serem interceptadas sem que ninguÃ©m perceba. Para que essas transaÃ§Ãµes tornem-se seguras,
mesmo sendo interceptadas por pessoas mal intencionadas, elas devem ser protegidas, de modo
que somente o destinatÃ¡rio (banco ou empresa do cartÃ£o de crÃ©dito) consiga ler e utilizar as
informaÃ§Ãµes ali contidas e para isso usamos a criptografia. Criptografia Ã© o estudo de mÃ©todos
para codificar mensagens de maneira que sÃ³ o destinatÃ¡rio possa ler e entender o conteÃºdo que
ela contÃ©m, de modo que para qualquer outra pessoa que consiga ter acesso a tal mensagem essa
torne-se ilegÃ­vel, sendo entÃ£o incapaz de ter acesso Ã s suas informaÃ§Ãµes. Os cÃ³digos utilizados na
criptografia para codificar uma mensagem e tambÃ©m para decodificÃ¡-la sÃ£o chamadas de chaves.
Embora o conceito utilizado seja bem simples, encontrar uma maneira de codificar tais mensa-
gens com a seguranÃ§a necessÃ¡ria, nÃ£o foi tarefa fÃ¡cil. Isso Ã© devido Ã  maneira como estas transaÃ§Ãµes
bancÃ¡rias ocorrem, por exemplo, quando Ã© realizada uma compra com cartÃ£o de crÃ©dito via in-
ternet, o comprador precisa informar a loja sobre os dados de seu cartÃ£o de crÃ©dito, porÃ©m, se
esses dados forem revelados a outra pessoa, essa pessoa conseguirÃ¡ fazer compras com tal cartÃ£o
e, assim, para que isso nÃ£o ocorra, as informaÃ§Ãµes do cartÃ£o de crÃ©dito precisam ser codificadas
pelo computador antes de serem enviadas.

O problema Ã© que a codificaÃ§Ã£o feita pelo computador do comprador nÃ£o pode acontecer de
maneira aleatÃ³ria, pois a loja que receberÃ¡ os dados do cartÃ£o de crÃ©dito precisa saber decodificar.
O que ocorre, Ã© que a loja informa como deve ser feito a codificaÃ§Ã£o (a chave de codificaÃ§Ã£o),
tornando possÃ­vel para o computador do comprador codificar os dados do cartÃ£o de crÃ©dito de
maneira que a loja consiga decodifica-los e, assim, utilizar tais dados. PorÃ©m, como o processo de

1

codificaÃ§Ã£o foi enviado via internet pela loja atÃ© o comprador, ele fica vulnerÃ¡vel Ã  interceptaÃ§Ãµes
de terceiros, os quais uma vez sabendo o cÃ³digo (chave) utilizado para codificar os dados do cartÃ£o
de crÃ©dito, podem decodificÃ¡-los desfazendo a codificaÃ§Ã£o realizada. O que, assim sendo, qualquer
que seja o cÃ³digo que seu computador utilize para criptografar, ele sempre estarÃ¡ sujeito a cair nas
mÃ£os de terceiros, tornando assim essa operaÃ§Ã£o nada segura.

AtÃ© pouco tempo atrÃ¡s, isso poderia ser verdade, porÃ©m nos dias atuais existem mÃ©todos crip-
togrÃ¡ficos que, mesmo tendo acesso a chave utilizada para codificar a mensagem, decodificÃ¡-la nÃ£o
Ã© tÃ£o simples assim. Decodificar a mensagem simplesmente desfazendo o processo de codificaÃ§Ã£o
(utilizando um processo inverso ao utilizado para codificar) torna-se tÃ£o trabalhoso e demorado de
maneira que Ã© impossÃ­vel colocÃ¡-lo em prÃ¡tica.

Os mÃ©todos criptograficos vÃªm sendo aprimorados desde a Ã©poca do Imperador Julio CÃ©sar,
que utilizava mensagens codificadas para se comunicar com seus soldados durante Ã©poca de guerra.
Por volta do ano de 1960 foi inventada a criptografia que utiliza chaves pÃºblicas, uma criptografia
onde mesmo se a chave transmitida for interceptada nÃ£o serÃ¡ suficiente para a decodificaÃ§Ã£o da
mensagem. A principal diferenÃ§a entre a utilizaÃ§Ã£o da chave pÃºblica de uma chave convencional,
estÃ¡ na decodificaÃ§Ã£o da mensagem, pois para se decodificar uma mensagem que se utiliza de uma
chave convencional bastava realizar um processo inverso ao realizado para codificar tal mensagem.
JÃ¡ na utilizaÃ§Ã£o da chave pÃºblica, realizar o processo inverso se torna tÃ£o trabalhoso e demorado
que vem a ser impossÃ­vel decodificar a mensagem atravÃ©s deste processo. O porque desse processo
se tornar tÃ£o trabalhoso tem a mesma essÃªncia do problema em descobrir se um nÃºmero Ã© primo.
A chave pÃºblica utilizada na criptografia RSA Ã© constituÃ­da de um nÃºmero composto suficiente-
mente grande, enquanto que a chave que ficarÃ¡ privada (e serÃ¡ utilizada para decodificar) consiste
dos fatores primos de tal nÃºmero composto. Como dito anteriormente, Ã© um processo que nÃ£o
conhecemos nenhum mÃ©todo eficaz o suficiente, tornando segura a Criptografia RSA. Desfazer o
processo, ou seja, fatorar tal nÃºmero ou encontrar os primos que o compÃµe, Ã© um processo que
ainda nÃ£o conhecemos nenhum mÃ©todo eficaz suficiente, e esse fato Ã© o que torna tal chave segura.
Assim sendo, esse trabalho se pautarÃ¡ no estudo de mÃ©todos para se detectar nÃºmeros primos
e de uma aplicaÃ§Ã£o envolvendo nÃºmeros primos, a Criptografia de Chave PÃºblica, a qual se utiliza
de propriedades especiais dos nÃºmeros primos. No capÃ­tulo 1 serÃ¡ abordado um estudo a partir da
definiÃ§Ã£o dos nÃºmeros primos, onde, com a ajuda de alguns resultados matemÃ¡ticos importantes,
avanÃ§aremos o conhecimento sobre os nÃºmeros primos, a ponto de traÃ§ar testes de primalidades
modernos que serÃ£o analisados no CapÃ­tulo 2 no qual levantaremos as vantagens e desvantagens
de cada um. Ao final do CapÃ­tulo 2 poderÃ¡ se constatar o grande problema que todos os testes de
primalidade sofrem, e que serÃ¡ a essÃªncia dos mÃ©todos criptogrÃ¡ficos, que serÃ£o apresentados no
CapÃ­tulo 3. No CapÃ­tulo 4 serÃ¡ apresentada uma sequÃªncia didÃ¡tica idealizada que pode servir de
molde para uma utilizaÃ§Ã£o em sala de aula.

2

CapÃ­tulo 1

PRELIMINARES

SerÃ¡ tratado nesse capÃ­tulo o estudo de alguns teoremas, ideias e conceitos sobre nÃºmeros
inteiros os quais sÃ£o imprescindÃ­veis para a anÃ¡lise e compreensÃ£o dos nÃºmeros primos, bem como
a dificuldade em se detectar a primalidade de um nÃºmero, sendo esse o grande trunfo do mÃ©todo
criptogrÃ¡fico RSA.

O resultado mais relevante atÃ© o momento para se detectar a primalidade de um nÃºmero Ã© o
chamado teste de Miller, o qual utiliza a aritmÃ©tica modular para analisar e encontrar nÃºmeros
primos. Esse teste de primalidade Ã© o que se tem de mais moderno para se detectar se um nÃºmero Ã©
primo ou nÃ£o, mas mesmo assim ainda sÃ³ Ã© viÃ¡vel sua utilizaÃ§Ã£o atÃ© certo ponto, pois dependendo
do tamanho do nÃºmero a ser examinado, tal teste pode demorar tanto tempo para encontrar uma
resposta, que utilizÃ¡-lo se torna inviÃ¡vel.
Afinal, o que Ã© um nÃºmero primo?

DefiniÃ§Ã£o 1. Um nÃºmero inteiro positivo Ã© chamado de primo quando possui somente dois divi-
sores: 1 e ele prÃ³prio.

DefiniÃ§Ã£o 2. Um nÃºmero inteiro positivo Ã© chamado de composto quando possui 3 ou mais
divisores.

Exemplo 1. 8 nÃ£o Ã© primo, pois 4 divide 8
5 Ã© primo, pois 2 nÃ£o divide 5, 3 nÃ£o divide 5 e 4 nÃ£o divide 5.

Quando um nÃºmero ğ‘ divide um nÃºmero ğ‘›, escrevemos: ğ‘ | ğ‘› , exemplo: 4 | 8 (4 divide 8). O
que equivale a dizer que a divisÃ£o de ğ‘› por ğ‘ deixa resto zero ou ainda que: ğ‘› = ğ‘ Â· ğ‘, exemplo:
8 = 4 Â· 2.

Se um nÃºmero ğ‘ nÃ£o divide um nÃºmero ğ‘›, escrevemos: ğ‘ (cid:45) ğ‘›. O que equivale a dizer que a
divisÃ£o de ğ‘› por ğ‘ deixa resto diferente de zero, ou ainda: ğ‘› = ğ‘ Â· ğ‘ + ğ‘Ÿ, com 0 < ğ‘Ÿ < ğ‘, exemplo:
11 = 4 Â· 2 + 3.

Neste ponto Ã© importante utilizarmos, como recurso, o Algoritmo da DivisÃ£o, o qual ajudarÃ¡
a identificarmos mais rapidamente os possÃ­veis resultados. Tal Algoritmo nos diz que todo ğ‘› âˆˆ Z
pode ser escrito como:

3

Figura 1.1: Algoritmo da divisÃ£o

ğ‘› = ğ‘ Â· ğ‘ + ğ‘Ÿ, onde 0 â‰¤ ğ‘Ÿ < ğ‘, sendo ğ‘ âˆˆ N.
Assim sendo, temos os possÃ­veis casos:

â€¢ Se ğ‘Ÿ = 0, temos que ğ‘ divide ğ‘› e podemos escrever: ğ‘ | ğ‘›.

â€¢ Se ğ‘Ÿ Ì¸= 0, temos que ğ‘ nÃ£o divide ğ‘› e escrevemos ğ‘ (cid:45) ğ‘›.

Como saber se um nÃºmero Ã© primo?
Quanto maior for o nÃºmero a ser verificado, maior a quantidade de candidatos a divisores este

nÃºmero terÃ¡.

Exemplo 2. 5021 Ã© primo?

Para verificar se ele Ã© primo olhando para a definiÃ§Ã£o de nÃºmeros primos, temos que 5021 Ã©
primo se for divisÃ­vel somente por 1e por ele mesmo, logo teria que se verificar se 5021 nÃ£o Ã©
divisÃ­vel por 2, por 3, por 4, por 5, por 6,..., por 5020, o que dÃ¡ um total de 5018 candidatos a
verificar.

1.1 Teorema Fundamental da AritmÃ©tica

Todos os nÃºmeros nÃ£o primos podem ser formados como produtos de primos e de maneira

Ãºnica, Ã© o que diz o Teorema Fundamental da AritmÃ©tica:

Teorema 1. (Teorema Fundamental da AritmÃ©tica) Um nÃºmero natural maior que 1, ou Ã© primo,
ou se escreve de maneira Ãºnica como um produto de primos, a menos de ordenaÃ§Ã£o.

DemonstraÃ§Ã£o: Vamos primeiro demonstrar que um nÃºmero natural ğ‘› se escreve como um

produto de primos:

Para isso iremos utilizar o prÃ­ncipio de induÃ§Ã£o finita. Observe que ğ‘› = 2, o teorema Ã© valido,
pois 2 Ã© primo. Suponha agora que o teorema Ã© valido para todo nÃºmero natural maior que 2 e
menor que ğ‘› e, entÃ£o, provaremos que tambÃ©m Ã© vÃ¡lido para ğ‘›. Observe que dessa forma ğ‘› nÃ£o Ã©
primo e, portanto, existe 2 â‰¤ ğ‘›1 < ğ‘› que divide ğ‘›, e entÃ£o escrevemos ğ‘› = ğ‘›1 Â· ğ‘˜ sendo 2 â‰¤ ğ‘˜ < ğ‘›.
Dessa forma por hipÃ³tese de induÃ§Ã£o, temos que ğ‘›1 e ğ‘˜ podem ser escrito como produto de primos:
ğ‘›1 = ğ‘1 Â· Â· Â· ğ‘ğ‘› e ğ‘˜ = ğ‘1 Â· Â· Â· ğ‘ğ‘›, e entÃ£o podemos escrever ğ‘› = ğ‘›1 Â· ğ‘˜ = ğ‘1 Â· Â· Â· ğ‘ğ‘› Â· ğ‘1 Â· Â· Â· ğ‘ğ‘›.

Falta agora demonstrar a unicidade dessa escrita.

4

Suponha por absurdo que ğ‘› possa ser escrito de duas maneiras diferentes ao menos da ordem

de seus fatores, ou seja:
ğ‘› = ğ‘1 Â· ğ‘2 Â· ... Â· ğ‘ğ‘› e tambÃ©m:
ğ‘› = ğ‘1 Â· ğ‘2 Â· ... Â· ğ‘ğ‘ , com ğ‘ğ‘– e ğ‘ğ‘— nÃºmeros primos sendo ğ‘– âˆˆ {1, 2, ..., ğ‘›} e ğ‘— âˆˆ {1, 2, ..., ğ‘ }.
Observe que ğ‘1|ğ‘› pois ğ‘› = ğ‘1 Â· ğ‘2 Â· ... Â· ğ‘ğ‘› , e dessa forma temos tambÃ©m que:

ğ‘1|ğ‘1 Â· ğ‘2 Â· ... Â· ğ‘ğ‘  que tambÃ©m podemos escrever:
ğ‘1 Â· ğ‘2.... Â· ğ‘ğ‘  = ğ‘1 Â· ğ‘

Podemos reordenar os ğ‘ğ‘— de forma que ğ‘1 = ğ‘1.

Como ğ‘1 Ã© um nÃºmero primo e ğ‘ğ‘— tambÃ©m sÃ£o primos, conclui-se que ğ‘1 = ğ‘ğ‘— para algum ğ‘—.

Desta forma podemos simplificar a igualdade ğ‘1 Â· ğ‘2 Â· ... Â· ğ‘ğ‘  = ğ‘1 Â· ğ‘ obtendo: ğ‘2 Â· ... Â· ğ‘ğ‘  = ğ‘
Lembrando que ğ‘› = ğ‘1 Â· ğ‘2 Â· ... Â· ğ‘ğ‘› , temos entÃ£o que ğ‘ = ğ‘2 Â· ... Â· ğ‘ğ‘›, e portanto:

ğ‘2|ğ‘ , e portanto, como ğ‘2 Â· ... Â· ğ‘ğ‘  = ğ‘, temos que:
ğ‘2|ğ‘2 Â· ... Â· ğ‘ğ‘  que Ã© o mesmo de:
ğ‘2 Â· ... Â· ğ‘ğ‘  = ğ‘2 Â· ğ‘ onde ğ‘ = ğ‘3 Â· ... Â· ğ‘ğ‘›

Como ğ‘2 Ã© um nÃºmero primo e ğ‘ğ‘— tambÃ©m sÃ£o primos, conclui-se que ğ‘2 = ğ‘ğ‘— para algum ğ‘—.

Podemos reordenar os ğ‘ğ‘— de forma que ğ‘2 = ğ‘2.

Podendo assim simplificar a igualdade ğ‘2 Â· ... Â· ğ‘ğ‘  = ğ‘ obtendo: ğ‘3 Â· ... Â· ğ‘ğ‘  = ğ‘3 Â· ... Â· ğ‘ğ‘›
Prosseguindo desta forma, podemos concluir que ğ‘1 = ğ‘1, ğ‘2 = ğ‘2, ..., ğ‘ğ‘› = ğ‘ğ‘ , provando assim,

que ğ‘› se escreve como produtos de primos de maneira Ãºnica.

O Teorema Fundamental da AritmÃ©tica Ã© o resultado que nos permite escrever qualquer nÃºmero
como um produto de primos. No ensino Fundamental o utilizamos em muitas ocasiÃµes, simplificar
fraÃ§Ãµes, calcular o m.m.c., m.d.c. entre outras aplicaÃ§Ãµes.

Exemplo 3. Escrevendo 10 e 18 como um produto de primos, temos:

10 = 2 Â· 5
18 = 32 Â· 2

O Teorema Fundamental da AritmÃ©tica garante que um nÃºmero composto terÃ¡ sempre os
mesmos nÃºmeros primos em sua composiÃ§Ã£o. Desta maneira, utilizando o algoritmo da fatoraÃ§Ã£o
podemos encontrar os fatores primos de um nÃºmero e escrevÃª-lo como um produto de primos.

Podemos melhorar um pouco esse mÃ©todo se notarmos o seguinte:
Voltando ao exemplo 2, ao verificar que o nÃºmero 5021 nÃ£o Ã© divisÃ­vel por 2, podemos afirmar
que este nÃºmero (pelo Teorema Fundamental da AritmÃ©tica) nÃ£o contÃ©m o fator 2 em sua decompo-
siÃ§Ã£o em fatores primos, e portanto, nenhum outro nÃºmero que contenha o 2 em sua decomposiÃ§Ã£o
(os mÃºltiplos de 2) pode dividir o nÃºmero 5021. Nenhum nÃºmero do conjunto ğ‘€ (2) = {2, 4, 6, 8, ...}
divide o nÃºmero 5021.

Utilizando o mesmo pensamento para todos os outros primos menores que 5021, podemos
concluir que basta verificar entÃ£o se o nÃºmero em questÃ£o, no caso 5021, Ã© divisÃ­vel pelos primos
que serÃ£o menores que ele.

Se pensarmos um pouco adiante, conseguiremos deduzir que tambÃ©m nÃ£o se faz necessÃ¡rio

verificar todos os primos menores que o nÃºmero em questÃ£o.

Exemplo 4. Para o nÃºmero 73, temos que: 2 nÃ£o divide 73, 3 nÃ£o divide 73, 5 nÃ£o divide 73 e 7
73 < 9, temos que 9 Â· 9 > 73 , e dessa forma nÃ£o existe nenhum fator primo
nÃ£o divide 73 e como

âˆš

5

de 73 maior do que
âˆš

73 ( jÃ¡ que verificamos para todos os menores do que

73, porque se houvesse o outro fator primo tambÃ©m teria que ser maior que
73,) o que gera um absurdo, uma vez

âˆš

âˆš

que a multiplicaÃ§Ã£o de dois nÃºmeros maiores do que 9 Ã© sempre maior do que 73.

Dessa forma para saber se um nÃºmero Ã© primo, basta verificar se ele Ã© divisÃ­vel por algum

nÃºmero primo menor ou igual a raiz quadrada deste nÃºmero.

âˆš

No caso do 5021, basta verificar se ele Ã© divisÃ­vel por algum nÃºmero primo menor ou igual a

5021 â‰ƒ 71, se nenhuma destas verificaÃ§Ãµes acontecer 5021 serÃ¡ primo.

Embora torne o mÃ©todo mais eficaz ele ainda funciona atÃ© certo ponto, jÃ¡ que quando se trata
de nÃºmeros grandes, os nÃºmeros que precisam ser verificados acabam sendo muitos, sem contar
que, faz-se necessÃ¡rio conhecer todos os nÃºmeros primos que sÃ£o menores que a raiz quadrada
deste.

Para seguir em frente, Ã© fundamental utilizar uma aritmÃ©tica focada nos restos de divisÃµes, a

chamada arimÃ©tica modular.

Utilizando a divisÃ£o euclidiana, temos que um nÃºmero ğ‘› âˆˆ Z pode ser escrito como: ğ‘› = ğ‘šÂ·ğ‘+ğ‘Ÿ

onde ğ‘š âˆˆ N e 0 â‰¤ ğ‘Ÿ < ğ‘š.

Mas, e se o que se precisa analisar for somente o resto desta divisÃ£o sem se preocupar com o

valor do quociente?

Nesse caso, poderemos escrever: ğ‘› â‰¡ ğ‘Ÿ mod ğ‘š, ou seja, ğ‘› deixa resto ğ‘Ÿ quando dividido por

ğ‘š, ou ainda de uma maneira mais geral:
ğ‘› â‰¡ ğ‘ mod ğ‘š, dizemos que ğ‘› Ã© congruo a ğ‘ no mÃ³dulo ğ‘š, o que significa que ğ‘› e ğ‘ tem o mesmo
resto na divisÃ£o por ğ‘š.

TraÃ§ando um paralelo com a divisibilidade, podemos escrever tambÃ©m:

ğ‘š|ğ‘› âˆ’ ğ‘ â‡” ğ‘› â‰¡ ğ‘ mod ğ‘š, pois, se ğ‘› e ğ‘ deixam o mesmo resto na divisÃ£o por ğ‘š, temos que a
diferenÃ§a entre ğ‘› e ğ‘ Ã© divisÃ­vel por ğ‘š.

Exemplo 5. 34 â‰¡ 10 mod 3, pois ambos deixam resto 1 quando divididos por 3. Utilizando
divisibilidade temos entÃ£o: 3|34 âˆ’ 10.

A utilizaÃ§Ã£o da aritmÃ©tica modular facilita-rÃ¡ cÃ¡lculos com nÃºmeros grandes, em que, estamos

preocupados somente com o resto que eles deixam quando divididos por algum outro nÃºmero.

Como ilustraÃ§Ã£o, vejamos um exemplo:

Exemplo 6. Qual o resto da divisÃ£o de 475 por 17?

42 â‰¡ âˆ’1 mod 17 pois 42 = 16, portanto:
4 Â· 474 â‰¡ 4 Â· (42)37 mod 17
4 Â· (42)37 â‰¡ 4 Â· (âˆ’1)37 mod 17
475 â‰¡ âˆ’4 â‰¡ 13 mod 17 , ou seja, o resto da divisÃ£o de 475 por 17 Ã© 13.

1.2 Pequeno Teorema de Fermat

Um resultado muito importante e que nos auxilia no cÃ¡lculo de congruÃªncias Ã© o Pequeno

Teorema de Fermat.

6

Teorema 2. (Pequeno Teorema de Fermat) Se ğ‘ for um nÃºmero primo, entÃ£o ğ‘ divide ğ‘ğ‘ âˆ’ ğ‘ para
todo nÃºmero inteiro ğ‘ :

ğ‘|ğ‘ğ‘ âˆ’ ğ‘, ou ainda: ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘.

DemonstraÃ§Ã£o:
Uma maneira de se provar tal resultado, Ã© utilizar o PrincÃ­pio de InduÃ§Ã£o Finita, jÃ¡ que ele nos

fornece um mÃ©todo eficaz de demonstraÃ§Ãµes em situaÃ§Ãµes envolvendo nÃºmeros Naturais.

Com o Pequeno Teorema de Fermat faz uso dos NÃºmeros Inteiros, provaremos primeiro que ele

Ã© vÃ¡lido para os NÃºmeros Naturais e em seguida estenderems a prova para os NÃºmeros Inteiros.

Queremos provar entÃ£o, em um primeiro momento, que a proposiÃ§Ã£o ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘ Ã© vÃ¡lida

para os NÃºmeros Naturais.

1)Utilizando ğ‘ = 1 como base, temos:
ğ‘ğ‘ = 1ğ‘ = 1, âˆ€ primo ğ‘, logo: 1ğ‘ â‰¡ 1 mod ğ‘

2) ApÃ³s ter concluÃ­do que para ğ‘ = 1 Ã© verdade. Suponhamos que ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘, âˆ€ğ‘ âˆˆ N esta

Ã© nossa HipÃ³tese de InduÃ§Ã£o.

3) Em seguida utilizando nossa hipÃ³tese provaremos que:

(ğ‘ + 1)ğ‘ â‰¡ ğ‘ + 1 mod ğ‘

Expandindo (ğ‘ + 1)ğ‘ segundo o BinÃ´mio de Newton: âˆ‘ï¸€ğ‘
Se ğ‘– = 0 , temos (ï¸ğ‘
Â· ğ‘ğ‘ Â· 10 = ğ‘ğ‘.
Se ğ‘– = ğ‘ , temos (ï¸ğ‘
Â· ğ‘ğ‘âˆ’ğ‘ Â· 1ğ‘ = 1ğ‘.
Logo tirando estes dois casos do somatÃ³rio, temos:

)ï¸

)ï¸

ğ‘

0

ğ‘–=0

)ï¸

(ï¸ğ‘
ğ‘–

Â· ğ‘ğ‘âˆ’ğ‘– Â· 1ğ‘–.

(ğ‘ + 1)ğ‘ = ğ‘ğ‘ + 1ğ‘ +

)ï¸ƒ

ğ‘âˆ’1
âˆ‘ï¸

ğ‘–=1

(ï¸ƒğ‘
ğ‘–

Â· ğ‘ğ‘âˆ’ğ‘– Â· 1ğ‘–

Como (ï¸ğ‘
ğ‘–

ğ‘–!

)ï¸ = ğ‘Â·(ğ‘âˆ’1)Â·...Â·(ğ‘âˆ’ğ‘–+1)

, Ã© sempre inteiro e como ğ‘ nÃ£o divide ğ‘–!, temos que(ï¸ğ‘

)ï¸ possui ğ‘

ğ‘–

como um de seus fatores primos e, portanto, ğ‘ divide (ï¸ğ‘

)ï¸.

ğ‘–

Em termos de congruÃªncia: (ï¸ğ‘
ğ‘–
Assim:

)ï¸

â‰¡ 0 mod ğ‘.

)ï¸ƒ

ğ‘âˆ’1
âˆ‘ï¸

ğ‘–=1

(ï¸ƒğ‘
Â·
ğ‘–

Â· ğ‘ğ‘âˆ’ğ‘– Â· 1ğ‘– â‰¡ 0 mod ğ‘.

E como por HipÃ³tese de InduÃ§Ã£o temos que ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘, âˆ€ğ‘ âˆˆ N, podemos concluir que:

ğ‘ğ‘ + 1ğ‘ +

)ï¸ƒ

ğ‘âˆ’1
âˆ‘ï¸

ğ‘–=1

(ï¸ƒğ‘
ğ‘–

Â· ğ‘ğ‘âˆ’ğ‘– Â· 1ğ‘– â‰¡ ğ‘ + 1 mod ğ‘

Encontrando assim que:
(ğ‘ + 1)ğ‘ â‰¡ ğ‘ğ‘ + 1ğ‘ + âˆ‘ï¸€ğ‘âˆ’1
Â· ğ‘ğ‘âˆ’ğ‘– Â· 1ğ‘– â‰¡ ğ‘ğ‘ + 1ğ‘ â‰¡ (ğ‘ + 1) mod ğ‘.
ğ‘–=1
Desta forma provamos que : ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘ Ã© valido para todo ğ‘ âˆˆ N

(ï¸ğ‘
ğ‘–

)ï¸

7

Precisamos agora, estender esse resultado para os NÃºmeros Inteiros (Z), para isso falta que

provemos que ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘ tambÃ©m Ã© valido para os nÃºmeros negativos.

Em um primeiro momento suponha que ğ‘ = 2 e ğ‘ = âˆ’ğ›¼, com ğ›¼ positivo:
(âˆ’ğ›¼)2 â‰¡ âˆ’ğ›¼ mod 2
ğ›¼2 â‰¡ âˆ’ğ›¼ mod 2
ğ›¼2 + ğ›¼ â‰¡ 0 mod 2
Observe agora que, se ğ›¼ for par , ou seja : ğ›¼ = 2ğ‘˜, temos: (2ğ‘˜)2 + 2ğ‘˜ â‰¡ 0 mod 2 , que Ã©

sempre verdade.

Se ğ›¼ for Ã­mpar, ou seja: ğ›¼ = 2ğ‘˜ + 1, temos:
(2ğ‘˜ + 1)2 + 2ğ‘˜ + 1 â‰¡ 2.2ğ‘˜2 + 2 Â· 2ğ‘˜ + 1 + 2ğ‘˜ + 1 â‰¡ 0 mod 2, que tambÃ©m Ã© sempre verdade.
Assim, concluÃ­mos que, se ğ‘ = 2, temos que ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘ Ã© sempre verdade âˆ€ğ‘ âˆˆ Z. Por
Ãºltimo falta provarmos que, se ğ‘ for um nÃºmero Ã­mpar (uma vez que o Ãºnico primo par existente
Ã© o 2) e ğ‘ um nÃºmero negativo, continua sendo vÃ¡lido: ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘.

Suponhamos entÃ£o ğ‘ = âˆ’ğ›¼ e ğ‘ um primo Ã­mpar, sendo ğ›¼ âˆˆ N, temos:
(âˆ’ğ›¼)ğ‘ = âˆ’ğ›¼ğ‘, pois ğ‘ Ã© Ã­mpar.
Utilizemos entÃ£o ğ›¼ğ‘ â‰¡ ğ›¼ mod ğ‘, resultado que jÃ¡ provamos para os NÃºmeros Naturais utili-
zando o PrincÃ­pio da InduÃ§Ã£o Finita, e em seguida podemos multiplicar por (âˆ’1) ambos os lados
da congruÃªncia, obtendo:

âˆ’ğ›¼ğ‘ â‰¡ âˆ’ğ›¼ mod ğ‘, como ğ‘ Ã© Ã­mpar:
(âˆ’ğ›¼)ğ‘ â‰¡ âˆ’ğ›¼ mod ğ‘, resultado entÃ£o que o Teorema tambÃ©m Ã© valido para os nÃºmeros nega-

tivos.

Como o caso ğ‘ = 0 Ã© trivial, concluimos assim, a demonstraÃ§Ã£o de que ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘ Ã© valido

para todo ğ‘ âˆˆ Z e ğ‘ primo.

Exemplo 7.

43 â‰¡ 4 mod 3 â‡’ 43 â‰¡ 1 mod 3

62 â‰¡ 6 mod 2 â‡’ 62 â‰¡ 0 mod 2

Ã‰ importante observar que o Pequeno Teorema de Fermat diz respeito a congruÃªncias cujo
mÃ³dulo sÃ£o apenas nÃºmeros primos, o que traz uma restriÃ§Ã£o quanto a sua utilizaÃ§Ã£o. Essa restriÃ§Ã£o
jÃ¡ nÃ£o existe no Teorema apresentado por Euler o qual abrange todos os nÃºmeros inteiros.

Teorema 3. (Teorema de Euler) Sejam ğ‘ âˆˆ Z e ğ‘› âˆˆ N, se (ğ‘, ğ‘›) = 1 entÃ£o:

ğ‘ğœ‘(ğ‘›) â‰¡ 1 mod ğ‘›,

primo com ğ‘›, onde Ã© possÃ­vel calculÃ¡-la escrevendo ğ‘› como um produto de primos: ğ‘› = ğ‘ğ›¼1

sendo ğœ‘(ğ‘›) a quantidade de elementos do conjunto dos possÃ­veis restos na divisÃ£o por n que sÃ£o
1 Â·...Â·ğ‘ğ›¼ğ‘›
ğ‘› ,
com ğ‘1, ğ‘2, ..., ğ‘ğ‘› nÃºmeros primos distintos e ğ›¼1, ğ›¼2, ..., ğ›¼ğ‘› nÃºmeros inteiros positivos.Desta

forma:

ğœ‘(ğ‘›) = ğœ‘(ğ‘ğ›¼1
1

Â· ... Â· ğ‘ğ›¼ğ‘›
ğ‘›

) = ğ‘ğ›¼1âˆ’1
1

Â· ... Â· ğ‘ğ›¼ğ‘›âˆ’1

ğ‘›

Â· (ğ‘1 âˆ’ 1) Â· ... Â· (ğ‘ğ‘› âˆ’ 1)

8

Observe que se n for um nÃºmero primo, temos: ğœ‘(ğ‘›) = ğœ‘(ğ‘) = ğ‘1âˆ’1 Â· (ğ‘ âˆ’ 1) = ğ‘ âˆ’ 1, e entÃ£o:
ğ‘ğœ‘(ğ‘›) â‰¡ 1 mod ğ‘› â‡’ ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘ , que nada mais Ã© do que o Pequeno Teorema de Fermat

em uma outra versÃ£o a qual estudaremos mais adiante.

Para compreender um pouco mais sobre o Pequeno Teorema de Fermat e sobre a ordem de um

nÃºmero ğ‘›, se faz necessÃ¡rio estudar um pouco sobre Grupos.

1.3 Grupos

Um Grupo Ã© um conjunto que possui uma operaÃ§Ã£o bem definida alÃ©m de satisfazer algumas

propriedades.

Para tal operaÃ§Ã£o estar bem definida ela deve associar a cada dois elementos desse grupo um

terceiro elemento tambÃ©m desse grupo:

PorÃ©m para tal conjunto constituir um grupo, precisa tambÃ©m satisfazer as seguintes proprie-

ğ‘, ğ‘ âˆˆ ğº â‡’ ğ‘ * ğ‘ âˆˆ ğº.

dades:

1. Associatividade: ğ‘ * (ğ‘ * ğ‘) = (ğ‘ * ğ‘) * ğ‘

2. Elemento Neutro: ğ‘ * ğ‘’ = ğ‘’ * ğ‘ = ğ‘

3. Elemento Inverso ğ‘ * ğ‘â€² = ğ‘â€² * ğ‘ = ğ‘’

Um grupo muito utilizado Ã© o dos NÃºmeros Inteiros com a operaÃ§Ã£o da adiÃ§Ã£o:
Temos que ğ‘, ğ‘ âˆˆ Z â‡’ ğ‘ + ğ‘ âˆˆ Z e tambÃ©m que vale:

1. Associatividade ğ‘ + (ğ‘ + ğ‘) = (ğ‘ + ğ‘) + ğ‘

2. Elemento Neutro ğ‘ + 0 = 0 + ğ‘ = ğ‘

3. Elemento Inverso ğ‘ + (âˆ’ğ‘) = (âˆ’ğ‘) + ğ‘ = 0

Caracterizando, assim, o conjunto dos NÃºmeros Inteiros como um grupo para com a adiÃ§Ã£o.
Entretanto, o conjunto dos NÃºmeros Inteiros nÃ£o forma um grupo com a operaÃ§Ã£o de multipli-
caÃ§Ã£o,pois apesar da operaÃ§Ã£o estar bem definida: ğ‘, ğ‘ âˆˆ ğ‘ â‡’ ğ‘ Â· ğ‘ âˆˆ Z, e possuir as propriedades
Associativa e Elemento Neutro, ela nÃ£o possui Elemento Inverso:

1. Associatividade ğ‘ Â· (ğ‘ Â· ğ‘) = (ğ‘ Â· ğ‘) Â· ğ‘;

2. Elemento Neutro ğ‘ Â· 1 = 1 Â· ğ‘ = ğ‘.

9

PorÃ©m, (cid:64)ğ‘â€² âˆˆ Z, tal que: ğ‘ Â· ğ‘â€² = ğ‘â€² Â· ğ‘ = 1, e, portanto, podemos concluir que os NÃºmeros
Inteiros nÃ£o formam um grupo para com a operaÃ§Ã£o de multiplicaÃ§Ã£o, pois ela nÃ£o possui elemento
inverso.

Ao se utilizar congruÃªncias, os grupos utilizados sÃ£o os Zğ‘›, ou seja, Inteiros mÃ³dulo ğ‘›, vejamos

alguns exemplos:

1) Ao se analisar Z4, temos como classes residuais: Â¯0, Â¯1, Â¯2, Â¯3 (os possÃ­veis restos na divisÃ£o por

4). Logo, temos uma congruÃªncia do tipo: ğ‘ â‰¡ ğ‘ mod 4 onde ğ‘, ğ‘ğ‘’ âˆˆ Z e Â¯ğ‘ âˆˆ

{ï¸Â¯0, Â¯1, Â¯2, Â¯3}ï¸.

Vejamos se Z4 Ã© um grupo com a operaÃ§Ã£o de adiÃ§Ã£o:
Temos que ğ‘¥, ğ‘¦ âˆˆ Z â‡’ ğ‘¥ + ğ‘¦ âˆˆ Z e ğ‘¥ â‰¡ ğ‘1 mod ğ‘› e ğ‘¦ â‰¡ ğ‘2 mod ğ‘› â‡’ ğ‘¥ + ğ‘¦ â‰¡ ğ‘1 + ğ‘2 mod ğ‘›.
Como ğ‘1 ğ‘’ ğ‘2 âˆˆ

, vejamos todas as possibilidades de ğ‘1 + ğ‘2 mod 4 :

{ï¸Â¯0, Â¯1, Â¯2, Â¯3}ï¸

+ 0
0
0
1
1
2
2
3
3

1
1
2
3
0

2
2
3
0
1

3
3
0
1
2

Tabela 1.1: AdiÃ§Ã£o em Z4

Verifica-se que ğ‘1 + ğ‘2 âˆˆ Z4 e que:

1. Associatividade: ğ‘ + (ğ‘ + ğ‘) = (ğ‘ + ğ‘) + ğ‘

2. Elemento Neutro: ğ‘ + 0 = 0 + ğ‘ = ğ‘

3. Elemento Inverso ğ‘ + (âˆ’ğ‘) = (âˆ’ğ‘) + ğ‘ = 0

Desta forma Z4 Ã© um grupo com a operaÃ§Ã£o de AdiÃ§Ã£o.
Vejamos agora se Z4 tambÃ©m Ã© um grupo com a operaÃ§Ã£o de MultiplicaÃ§Ã£o:
Seguindo os mesmos passos, temos que ğ‘¥, ğ‘¦ âˆˆ Z â‡’ ğ‘¥ Â· ğ‘¦ âˆˆ Z e ğ‘¥ â‰¡ ğ‘1 mod ğ‘› e ğ‘¦ â‰¡ ğ‘2

mod ğ‘› â‡’ ğ‘¥ Â· ğ‘¦ â‰¡ ğ‘1 Â· ğ‘2 mod ğ‘›.

Como ğ‘1 e ğ‘2 âˆˆ

{ï¸Â¯0, Â¯1, Â¯2, Â¯3}ï¸

, vejamos todas as possibilidades de ğ‘1 Â· ğ‘2 mod 4.

.
0
1
2
3

0
0
0
0
0

1
0
1
2
3

2
0
2
0
2

3
0
3
2
1

Tabela 1.2: MultiplicaÃ§Ã£o em Z4

Verifica-se que ğ‘1 Â· ğ‘2 âˆˆ Z4 .
Em seguida precisamos analisar se Ã© vÃ¡lido:

10

1. Associatividade: ğ‘ Â· (ğ‘ Â· ğ‘) â‰¡ (ğ‘ Â· ğ‘) Â· ğ‘ mod 4

2. Elemento Neutro: ğ‘ Â· 1 â‰¡ 1 Â· ğ‘ â‰¡ ğ‘ mod 4

3. Elemento Inverso ğ‘ Â· ğ‘ â‰¡ ğ‘ Â· ğ‘ â‰¡ 1 mod 4

As propriedades 1 e 2 podem ser facilmente analisadas pelas propriedades da multiplicaÃ§Ã£o, jÃ¡
a propriedade 3 precisa ser analisado com um pouco mais de cuidado. Analisando todas as classes
residuais de Z4 temos:

Estamos analisando se ğ‘ Â· ğ‘ â‰¡ ğ‘ Â· ğ‘ â‰¡ 1 mod 4 para todo ğ‘ âˆˆ Z4âˆ–{0}
Repare que, quando ğ‘ = 2, nÃ£o existe nenhum ğ‘ âˆˆ Z4 tal que:

ğ‘ Â· ğ‘ â‰¡ ğ‘ Â· ğ‘ â‰¡ 1 mod 4

Logo, Z4 nÃ£o Ã© um grupo com a operaÃ§Ã£o de multiplicaÃ§Ã£o.
A ausÃªncia deste inverso multiplicativo muitas vezes Ã© um problema, inclusive no estudo de
nÃºmeros primos e de fatoraÃ§Ã£o, onde Ã© utilizada a multiplicaÃ§Ã£o com frequÃªncia. Por esse motivo,
precisamos utilizar um grupo para com a operaÃ§Ã£o de multiplicaÃ§Ã£o, e como a falta do Elemento
Inverso Ã© sempre um problema, comecemos procurando condiÃ§Ãµes para que ğ‘â€², ğ‘ âˆˆ Zğ‘›, tenham a
propriedade:

ğ‘ Â· ğ‘â€² â‰¡ ğ‘â€² Â· ğ‘ â‰¡ 1 mod ğ‘›, o que sÃ³ acontecerÃ¡ se: ğ‘ Â· ğ‘â€² + ğ‘ Â· ğ‘› = 1, com ğ‘› âˆˆ Z, observe que
podemos encontrar tal resultado utilizando o algoritmo extendido de Euclides em (ğ‘, ğ‘›) = 1, e
dessa forma para que o conjunto possua Elemento Inverso precisamos encontrar um ğ‘› que seja
primo com ğ‘.

Observe que ao utilizar o conjunto Zğ‘, sendo ğ‘ um nÃºmero primo, a condiÃ§Ã£o (ğ‘, ğ‘) = 1 Ã©
respeitada sempre que ğ‘ (cid:45) ğ‘, mas observe que quando ğ‘ | ğ‘, temos que ğ‘ = ğ‘.ğ‘ para algum ğ‘ âˆˆ Z,
e assim sendo, ğ‘ = Â¯0, portanto tal conjunto possui Elemento Inverso para todos os seus elementos
com excessÃ£o Ã© claro do zero (vale lembrar que em um grupo com a operaÃ§Ã£o de multiplicaÃ§Ã£o nÃ£o
teremos Elemento Neutro e nem Elemento Inverso para o zero).

Nas congruÃªncias podemos obter um grupo para com a operaÃ§Ã£o de multiplicaÃ§Ã£o ao utilizar
o conjunto Zğ‘› desde que ğ‘› seja um nÃºmero primo, jÃ¡ que assim, desta maneira, temos tambÃ©m
o inverso multiplicativo (uma demonstraÃ§Ã£o para tal resultado pode ser encontrada em Coutinho
2.013 p.141, 142.)

Vamos analisar o conjunto Z5 e provar que ele constitui um grupo para com a operaÃ§Ã£o de

adiÃ§Ã£o e tambÃ©m para com a operaÃ§Ã£o de multiplicaÃ§Ã£o:

Temos que ğ‘, ğ‘, ğ‘ âˆˆ Z5 â‡’ ğ‘ + ğ‘ âˆˆ Z e tambÃ©m que vale:

1. Associatividade: ğ‘ + (ğ‘ + ğ‘) â‰¡ (ğ‘ + ğ‘) + ğ‘ mod 5;

2. Elemento Neutro: ğ‘ + 0 â‰¡ 0 + ğ‘ â‰¡ ğ‘ mod 5;

3. Elemento Inverso ğ‘ + (âˆ’ğ‘) â‰¡ (âˆ’ğ‘) + ğ‘ â‰¡ 0 mod 5.

Com relaÃ§Ã£o a MultiplicaÃ§Ã£o :
ğ‘, ğ‘ âˆˆ Z â‡’ ğ‘ Â· ğ‘ âˆˆ Z

11

1. Associatividade ğ‘ Â· (ğ‘ Â· ğ‘) â‰¡ (ğ‘ Â· ğ‘) Â· ğ‘ mod 5;
2. Elemento Neutro ğ‘ Â· 1 â‰¡ 1 Â· ğ‘ â‰¡ ğ‘ mod 5,sendo ğ‘ Ì¸= Â¯0;
3. Elemento Inverso ğ‘ Â· ğ‘ â‰¡ ğ‘ Â· ğ‘ â‰¡ 1 mod 5sendo ğ‘ Ì¸= Â¯0.

Falta atentarmos com a questÃ£o do inverso multiplicativo, observe que verificasse que para todo

ğ‘ âˆˆ Z5âˆ–{0} , existe seu inverso multiplicativo ğ‘ âˆˆ Z5

ğ‘ Â· ğ‘ â‰¡ ğ‘ Â· ğ‘ â‰¡ 1 mod 5
1 Â· 1 â‰¡ 1 Â· 1 â‰¡ 1 mod 5
2 Â· 3 â‰¡ 3 Â· 2 â‰¡ 1 mod 5
4 Â· 4 â‰¡ 4 Â· 4 â‰¡ 1 mod 5
E, desta forma, Z5 Ã© um grupo tanto para a adiÃ§Ã£o quanto para a multiplicaÃ§Ã£o.
Voltemos ao Pequeno Teorema de Fermat: ele nos diz que se ğ‘ Ã© primo, temos: ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘,
tomemos aqui o inverso multiplicativo de ğ‘, ou seja, ğ‘ âˆˆ Z, tal que: ğ‘ Â· ğ‘ â‰¡ 1 mod ğ‘. Podemos
multiplicar ambos os lados da congruÃªncia ğ‘ğ‘ â‰¡ ğ‘ mod ğ‘ por ğ‘, obtendo:

ğ‘ Â· ğ‘ğ‘ â‰¡ ğ‘ Â· ğ‘ mod ğ‘, e, como ğ‘ Ã© inverso de ğ‘:
ğ‘ Â· ğ‘ Â· ğ‘ğ‘âˆ’1 â‰¡ ğ‘ Â· ğ‘ mod ğ‘
1 Â· ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘
ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘.
Dessa forma, podemos entender com mais alguns detalhes o Pequeno Teorema de Fermat. JÃ¡ o
Teorema de Euler que Ã© uma versÃ£o mais geral do Pequeno Teorema de Fermat contÃ©m o nÃºmero
ğœ‘(ğ‘›), que chamamos de fuÃ§Ã£o phi de Euler, esse nÃºmero Ã© a quantidade de elementos de um sistema
reduzido de resÃ­duos mÃ³dulo ğ‘›, as vezes tambÃ©m chamado de quantidade de classes reduzidas de
resÃ­duos, observemos a congruÃªncia: ğ‘¥ â‰¡ ğ‘¦ mod 14.

A congruÃªncia acima apresenta o sistema completo de resÃ­duos: 0, 1, 2, 3, ..., 13, que sÃ£o os

possÃ­veis restos de uma divisÃ£o por 14.

Podemos encontrar tambÃ©m o sistema reduzido de resÃ­duos:1, 3, 5, 9, 11, 13. Esse sistema redu-
zido de resÃ­duos foi formado apenas com os elementos do sistema completo de resÃ­duos que sÃ£o
primos com 14.

Logo como dito acima, temos que ğœ‘(14) Ã© a quantidade dos elementos do sistema reduzido de

resÃ­duos, ou seja: ğœ‘(14) = 6.

Generalizando, podemos escrever: ğ‘¥ â‰¡ ğ‘¦ mod ğ‘›, tem como sistema completo de resÃ­duos:
0, 1, 2, 3, ..., ğ‘› âˆ’ 1 e como sistema reduzido de resÃ­duos: Os elementos ğ‘– tais que (ğ‘–, ğ‘›) = 1 e
ğ‘– âˆˆ {0, 1, 2, 3, 4, 5, ..., ğ‘› âˆ’ 1} , ou seja, os elementos do sistema completo de resÃ­duos que sÃ£o primos
com ğ‘›.

Como calcular ğœ‘(ğ‘›), ou seja, como calcular a quantidade de elementos do sistema reduzido de

resÃ­duos?

ComeÃ§amos com o caso mais simples, quando ğ‘› = ğ‘ ou seja se ğ‘› Ã© um nÃºmero primo, temos
que (ğ‘–, ğ‘) = 1 para todos ğ‘– âˆˆ {1, 2, 3, 4, 5, ..., ğ‘ âˆ’ 1} , e, portanto, concluÃ­mos que o nÃºmero de
elementos desse sistema reduzido de resÃ­duos Ã© ğ‘ âˆ’ 1, isto Ã©, ğœ‘(ğ‘) = ğ‘ âˆ’ 1.

Agora que jÃ¡ sabemos como calcular a ordem de ğ‘ primo, podemos com esse resultado calcular

a ordem de ğ‘ğ‘˜, com ğ‘ primo e ğ‘˜ âˆˆ N.

12

Utilizando o mesmo pensamento, buscaremos encontrar todos os (ğ‘–, ğ‘ğ‘˜) = 1 , onde ğ‘– âˆˆ {1, 2, 3, ..., ğ‘ âˆ’ 1},

ou seja, queremos encontrar os ğ‘– âˆˆ {1, 2, 3, ..., ğ‘ âˆ’ 1} que nÃ£o sÃ£o divisÃ­veis por ğ‘ğ‘˜. Como estra-
tÃ©gia, em primeiro lugar, contaremos todos os que sÃ£o divisÃ­veis por ğ‘ğ‘˜ e, em seguida, tiramos do
total, restando assim, os que nÃ£o sÃ£o divisÃ­veis por ğ‘ğ‘˜.

Suponhamos 0 â‰¤ ğ‘ < ğ‘ğ‘˜, sendo ğ‘ divisÃ­vel por ğ‘, logo ğ‘ se escreve: ğ‘ = ğ‘ Â· ğ‘ e, portanto,

0 â‰¤ ğ‘ < ğ‘ğ‘˜âˆ’1.

ConcluÃ­mos, entÃ£o, que existem ğ‘ğ‘˜âˆ’1 inteiros que sÃ£o divisÃ­veis por ğ‘. Como temos um total

de ğ‘ğ‘˜ nÃºmeros, temos que existem ğ‘ğ‘˜ âˆ’ ğ‘ğ‘˜âˆ’1 nÃºmeros que nÃ£o sÃ£o divisÃ­veis por ğ‘.

Logo, ğœ‘(ğ‘) = ğ‘ğ‘˜ âˆ’ ğ‘ğ‘˜âˆ’1 = ğ‘ğ‘˜âˆ’1 Â· (ğ‘ âˆ’ 1).
Falta agora provar a seguinte proposiÃ§Ã£o:

ProposiÃ§Ã£o 1. Se ğ‘š e ğ‘› âˆˆ N com ğ‘š > 1 e ğ‘› > 1 sendo (ğ‘š, ğ‘›) = 1 entÃ£o: ğœ‘(ğ‘š Â· ğ‘›) = ğœ‘(ğ‘š) Â· ğœ‘(ğ‘›)

DemonstraÃ§Ã£o:
Para provar tal resultado serÃ¡ utilizada a abordagem feita por [?, p. 133]:

Consideremos a seguinte tabela formada pelos nÃºmeros naturais de 1 a ğ‘š Â· ğ‘›:

1
ğ‘› + 1
...

2
ğ‘› + 2
...

...
...

(ğ‘š âˆ’ 1) Â· Â· Â· (ğ‘› + 1) ğ‘š âˆ’ 1 Â· Â· Â· (ğ‘› + 2)

...

ğ‘˜
ğ‘› + ğ‘˜
...
(ğ‘š âˆ’ 1) Â· Â· Â· (ğ‘› + ğ‘˜)

...
...

ğ‘›
2 Â· ğ‘›
...

... ğ‘š Â· ğ‘›

Como se tem que (ğ‘¡, ğ‘š Â· ğ‘›) = 1 se, e somente se, (ğ‘¡, ğ‘›) = (ğ‘¡, ğ‘š) = 1, para calcular
ğœ‘(ğ‘š Â· ğ‘›), devemos determinar os inteiros na tabela acima que sÃ£o simultaneamente
primos com ğ‘› e ğ‘š.

Se o primeiro elemento de uma coluna nÃ£o for primo com ğ‘›, entÃ£o todos os ele-
mentos da coluna nÃ£o sÃ£o primos com ğ‘›. Portanto, os elementos primos com ğ‘› estÃ£o
necessariamente nas colunas restantes que sÃ£o em nÃºmero ğœ‘(ğ‘›), cujos elementos sÃ£o
primos com ğ‘›, como Ã© fÃ¡cil verificar. Vejamos agora quais sÃ£o os elementos primos com
ğ‘š em cada uma dessas colunas.

Como (ğ‘š, ğ‘›) = 1 , a sequÃªncia :

ğ‘˜, ğ‘› + ğ‘˜, ..., (ğ‘š âˆ’ 1)ğ‘› + ğ‘˜

forma um sistema completo de resÃ­duo mÃ³dulo ğ‘š e, portanto, ğœ‘(ğ‘š) desses elementos
sÃ£o primos com ğ‘š. Logo, o nÃºmero de elementos simultaneamente primos com ğ‘› e ğ‘š
Ã© ğœ‘(ğ‘š) Â· ğœ‘(ğ‘›).

ApÃ³s provado que ğœ‘(ğ‘š Â· ğ‘›) = ğœ‘(ğ‘š) Â· ğœ‘(ğ‘›) tais que ğ‘šğ‘‘ğ‘(ğ‘š, ğ‘›) = 1 basta tomarmos a decomposiÃ§Ã£o
em fatores primos de n:
Â· ... Â· ğ‘ğ›¼ğ‘›
ğ‘›

, temos: ğœ‘(ğ‘›) = ğœ‘(ğ‘ğ›¼1
1

Â· (ğ‘1 âˆ’ 1) Â· ... Â· ğ‘ğ›¼ğ‘›âˆ’1

Â· (ğ‘ğ‘› âˆ’ 1) =

Se ğ‘› = ğ‘ğ›¼1
1

) = ğ‘ğ›¼1âˆ’1
1

Â· ... Â· ğ‘ğ›¼ğ‘›
ğ‘›

ğ‘›

ğ‘ğ›¼1âˆ’1
1

Â· ... Â· ğ‘ğ›¼ğ‘›âˆ’1

ğ‘›

Â· (ğ‘1 âˆ’ 1) Â· ... Â· (ğ‘ğ‘› âˆ’ 1).

13

Assim sendo, podemos calcular a ordem de um nÃºmero, bastando para isso conhecermos a
sua decomposiÃ§Ã£o em fatores primos. PorÃ©m, como vimos atÃ© entÃ£o, saber tal decomposiÃ§Ã£o nem
sempre Ã© tarefa fÃ¡cil, pois, dependendo do tamanho do nÃºmero em questÃ£o, torna-se complicado atÃ©
mesmo saber se ele Ã© primo. No capÃ­tulo a seguir serÃ¡ apresentado alguns testes de primalidade,
estes testes sÃ£o os utilizados nos dias atuais pelos computadores quando se precisa verificar a
primalidade de um nÃºmero.

14

CapÃ­tulo 2

TESTES DE PRIMALIDADE

Nesse capÃ­tulo procuraremos falar sobre testes de primalidade atuais, os quais sÃ£o utilizados
pelos computadores para se detectar se um nÃºmero Ã© primo, analisando as suas vantagens e des-
vantagens apresentadas. Para tanto, partiremos de uma ideia inicial utilizada pelo matemÃ¡tico
Leibniz, a qual nÃ£o estava totalmente certa, mas representou um avanÃ§o na maneira de se pensar
e analisar a primalidade de um nÃºmero. ApÃ³s o matemÃ¡tico Fermat ter enunciado seu teorema
tratado no capÃ­tulo anterior, Leibniz pensou que, se um nÃºmero qualquer ğ‘ satisfaz tal teorema,
isso bastaria para tal nÃºmero ser primo.

2.1 Teste De Leibniz

Como dito anteriormente, para Leibniz verificar se um nÃºmero ğ‘ era primo, ele verificava a
congruÃªncia: ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘, âˆ€ğ‘ tal que (ğ‘, ğ‘) = 1, entÃ£o, se isso acontecesse, seria suficiente
para que esse nÃºmero fosse primo. Sem ao menos provar tal argumento, Leibniz utilizou essa
recÃ­proca como seu critÃ©rio de primalidade, como observaremos abaixo.

Pequeno Teorema de Fermat: Se ğ‘ for um nÃºmero primo, entÃ£o tem-se que ğ‘ divide ğ‘ğ‘âˆ’1 âˆ’ 1

com (ğ‘, ğ‘) = 1, ou seja, ğ‘ Ã© primo â‡’ ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘.

RecÃ­proca do Teorema de Fermat: Se ğ‘ divide ğ‘ğ‘âˆ’1 âˆ’ 1 sendo (ğ‘, ğ‘) = 1, entÃ£o tem-se que ğ‘ Ã©

um nÃºmero primo, ou seja, ğ‘ğ‘âˆ’1 â‰¡ 1 mod ğ‘, âˆ€ğ‘ âˆˆ Z tal que (ğ‘, ğ‘) = 1 â‡’ ğ‘ Ã© primo.

Um outro detalhe importante em seu teste de primalidade, Ã© que Leibniz utilizava sempre ğ‘ = 2,

para tornar seus cÃ¡lculos menores.

Teste de Primalidade 1. (Teste de Leibniz) Dado um nÃºmero Ã­mpar ğ‘› âˆˆ N, se 2ğ‘›âˆ’1 â‰¡ 1 mod ğ‘›,
entÃ£o, ğ‘› Ã© primo.

EntÃ£o, se Leibniz quizesse descobrir se um nÃºmero, por exemplo, 229 era primo, bastava para

ele verificar se a congruÃªncia abaixo era satisfeita:

2229âˆ’1 â‰¡ 2 mod 229
2228 â‰¡ 1 mod 229

15

Com um pouco de cuidado e uma calculadora Ã© possÃ­vel verificar tal congruÃªncia e, portanto,

afirmar que 229 Ã© um nÃºmero primo.

PorÃ©m, esse mÃ©todo nem sempre Ã© verdadeiro, ou seja, a recÃ­proca do Pequeno Teorema de
Fermat nÃ£o Ã© vÃ¡lida, pois existem nÃºmeros compostos que tambÃ©m a verificam, exemplo o nÃºmero
341:

2341 â‰¡ 2 mod 341

Acontece que 341 nÃ£o Ã© um nÃºmero primo, pois 341 = 11 Â· 31
Pode-se concluir entÃ£o, que este mÃ©todo nÃ£o traz a certeza de que o nÃºmero verificado Ã© primo,
jÃ¡ que as vezes ele acerta e as vezes ele erra. Contudo, mesmo assim, ao se verificar uma grande
quantidade de nÃºmeros utilizando tal mÃ©todo, foi constatado que ele acerta muito mais do que
erra, e portanto um nÃºmero que passa em tal teste tem grande possibilidade de ser primo. Quando
um nÃºmero passa por este mÃ©todo e nÃ£o Ã© primo, passa a se denominar pseudo-primo.

2.2 Teste de Miller

A incerteza causada pelo mÃ©todo de Leibniz nÃ£o Ã© boa quando o que precisamos Ã© saber se
um nÃºmero Ã© primo. PorÃ©m, uma mudanÃ§a neste mÃ©todo realizada por G. L. Miller, em 1976, foi
capaz de melhorÃ¡-lo aumentando sua precisÃ£o e retirando em parte esta incerteza.

O Teste de Miller Ã© realizado da seguinte maneira:

Teste de Primalidade 2. (Teste de Miller)

Seja n o nÃºmero a ser verificado, podemos admitir n Ã­mpar uma vez que, o Ãºnico primo par Ã©

2. Se n Ã© Ã­mpar temos que ğ‘› âˆ’ 1 Ã© par e portanto pode ser escrito como:

ğ‘› âˆ’ 1 = 2ğ‘˜ Â· ğ‘ , onde extraÃ­mos a maior potÃªncia de 2, sendo assim q um nÃºmero Ã­mpar.
EntÃ£o escolhe-se uma base ğ‘ inteira, tal que 1 < ğ‘ < ğ‘› âˆ’ 1, se algum nÃºmero entre ğ‘ğ‘,
ğ‘2Â·ğ‘, . . . , ğ‘2ğ‘˜âˆ’1Â·ğ‘ for congruente a (âˆ’1) mÃ³dulo ğ‘›, ou ğ‘2ğ‘˜Â·ğ‘ for congruente a 1 mÃ³dulo ğ‘›, dessa forma
temos que ğ‘› Ã© primo.

O exemplo abaixo utiliza um nÃºmero pequeno para facilitar a compreensÃ£o:

Exemplo 8. Seja ğ‘› = 5021, entÃ£o ğ‘› âˆ’ 1 = 5020 = 22 Â· 1255, ou seja:

ğ‘˜ = 2 e ğ‘ = 1255, escolhemos uma base ğ‘ tal que 1 < ğ‘ < 5020, faÃ§amos entÃ£o ğ‘ = 2, se algum

nÃºmero entre:

21255 e 22510 for congruente a âˆ’1 mÃ³dulo 5021, ou 25020 for congruente a 1 mÃ³dulo 5021, entÃ£o

consideremos 5021 um nÃºmero primo.

Calculando assim tais congruÃªncias, teremos:
21255 â‰¡ 3658 mod 5021
22510 â‰¡ 5020 mod 5021 â‡’ 22510 â‰¡ âˆ’1 mod 5021 e temos para a base 2 que o teste Ã© conclusivo.

Ã‰ importante saber que o Teste de Miller tambÃ©m nÃ£o dÃ¡ certo sempre. Se acaso utilizarmos
a base 2 e testarmos todos os nÃºmeros entre 1 e 1000000000 ele errarÃ¡ 1282 vezes, o que Ã© um
nÃºmero muito pequeno de vezes. Quando um nÃºmero composto passa pelo Teste de Miller tendo
como resultado ser um nÃºmero primo, dizemos que tal nÃºmero Ã© um pseudoprimo forte para a
base utilizada. A seguir serÃ£o apresentados dois exemplos onde Ã© utilizado o Teste de Miller

16

para verificar a primalidade de um nÃºmero, para que assim possamos compreender melhor a sua
utilidade.

Exemplo 9. Queremos saber se 7561 Ã© um nÃºmero primo:

â€¢ Escolhemos como base o nÃºmero 17, lembrando que a base tem que estar sempre entre 1 e

ğ‘› âˆ’ 1.

â€¢ Tiramos uma unidade de 7561, ficando assim com 7560 e em seguida fazemos divisÃµes suces-

sivas por 2 atÃ© encontrar um quociente Ã­mpar.

â€¢ Calculamos os restos de ğ‘ğ‘Â·2ğ‘– por ğ‘›, sendo no caso ğ‘– âˆˆ {0, 1, 2, 3}.

7560 = 23 Â· 945

ğ‘ğ‘Â·ğ‘– â‰¡ ğ‘Ÿ mod 7561
17945 â‰¡ 1 mod 7561
17945Â·2 â‰¡ 1 mod 7561
17945Â·4 â‰¡ 1 mod 7561
17945Â·8 â‰¡ 1 mod 7561

â€¢ Os resultados sÃ£o analisados da seguinte forma: se ğ‘– = 0 e ğ‘Ÿ = 1 ou ğ‘– â‰¥ 0 e ğ‘Ÿ = âˆ’1, temos

que 7561 Ã© primo para essa base.
Como temos ğ‘– = 0 com ğ‘Ÿ = 1, nosso resultado Ã© que 7561 Ã© primo para a base 17, ou seja, Ã©
um pseudoprimo forte para a base 17.

Exemplo 10. Queremos saber se 1256347 Ã© um nÃºmero primo:

â€¢ Escolhemos como base o nÃºmero 5, lembrando que a base tem que estar sempre entre 1 e

ğ‘› âˆ’ 1;

â€¢ Tiramos uma unidade de 1256347, ficando assim com 1256346 e em seguida, fazemos divisÃµes

sucessivas por 2 atÃ© encontrar um quociente Ã­mpar: 1256346 = 2 Â· 628173;

â€¢ Calculamos os restos de ğ‘ğ‘Â·2ğ‘– por ğ‘› , sendo no caso ğ‘– âˆˆ {0, 1}.

ğ‘ğ‘Â·ğ‘– â‰¡ ğ‘Ÿ mod ğ‘›
5628173 â‰¡ âˆ’1 mod 1256347
5628173Â·2 â‰¡ 1 mod 1256347

â€¢ Os resultados sÃ£o analisados da seguinte forma: se ğ‘– = 0 e ğ‘Ÿ = 1 ou ğ‘– â‰¥ 0 e ğ‘Ÿ = âˆ’1 temos

que 1256347 Ã© primo para esta base.
Como temos ğ‘– = 0 com ğ‘Ÿ = âˆ’1 , nosso resultado Ã© que 1256347 Ã© primo para a base 5, ou
seja, Ã© um pseudo-primo forte para a base 5.

17

Como jÃ¡ dito neste trabalho, ainda nÃ£o existe um teste de primalidade que determine todos
os nÃºmeros primos de modo eficiente. Nos casos dos nÃºmeros 7561 e 1256347, por serem nÃºmeros
pequenos, os computadores atuais conseguem atravÃ©s do Teste de Miller trazer a certeza de que
se trata de um nÃºmero primo, basta para isso segundo Coutinho (2013) realizar tal teste para 1
4
das bases entre 1 e ğ‘› âˆ’ 1. PorÃ©m se um nÃºmero for suficientemente grande, o nÃºmero de bases
entre 1 e ğ‘› âˆ’ 1 tambÃ©m serÃ¡, e assim serÃ¡ impossÃ­vel, atÃ© mesmo para o computador, realizar este
das bases em tempo hÃ¡bil. O prÃ³prio software xMÃ¡xima, que utilizamos para realizar
teste para 1
4
as contas, possui um comando o qual realiza automaticamente um teste de primalidade e, entÃ£o,
consegue detectar que se trata de nÃºmeros primos.

O que se faz hoje em dia quando se precisa descobrir se um nÃºmero Ã© primo Ã© utilizar o Teste
de Miller para uma quantidade de bases que acredite ser suficiente, fazendo com que a chance de
erro diminua ainda mais. Alguns softwares utilizam 10 bases previamente escolhidas, e afirmam
que um nÃºmero Ã© primo quando ele consegue passar pelo Teste de Miller para todas as 10 bases.
A seguir analisaremos o Teste de Lucas, o qual Ã© tambÃ©m um teste determinÃ­stico de primalidade

com vantagens e desvantagens em relaÃ§Ã£o ao Teste de Miller.

2.3 Teste de Lucas

Esse teste utiliza como estratÃ©gia tentar mostrar que a ordem ğœ‘(ğ‘›) (phi de ğ‘›) no nÃºmero ğ‘› a
ser testado Ã© ğ‘› âˆ’ 1. Desta maneira sabemos que existem ğ‘› âˆ’ 1 nÃºmeros menores que ğ‘› os quais
(ğ‘, ğ‘›) = 1, e sendo assim conclui-se que ğ‘› Ã© primo.

Teste de Primalidade 3. (Teste de Lucas)

Seja ğ‘› um inteiro positivo Ã­mpar e ğ‘ um inteiro tal que 2 â‰¤ ğ‘ â‰¤ ğ‘› âˆ’ 1. Se: ğ‘ğ‘›âˆ’1 â‰¡ 1 mod ğ‘› e

ğ‘›âˆ’1
ğ‘

ğ‘

Ì¸â‰¡ 1 mod ğ‘› para cada fator primo ğ‘ de ğ‘› âˆ’ 1 , entÃ£o ğ‘› Ã© primo.

O teste de Lucas possui a vantagem de afirmar com certeza que um determinado nÃºmero Ã©
primo, ou seja, se um nÃºmero passar em tal teste ele com certeza Ã© um nÃºmero primo, diferente-
mente dos testes anteriores, onde quando um nÃºmero passava no teste havia uma grande chance
de ser primo, porÃ©m em alguns poucos casos o teste falhava.

Exemplo 11. Vamos utilizar o teste de Lucas para saber se o nÃºmero 7561 Ã© um nÃºmero primo.

â€¢ Escolhemos uma base para realizar o teste, vamos utilizar ğ‘ = 888

â€¢ Verificamos se a primeira condiÃ§Ã£o Ã© valida: ğ‘ğ‘›âˆ’1 â‰¡ 1 mod ğ‘›

8887560 â‰¡ 1 mod 7561

â€¢ Verificamos se a segunda condiÃ§Ã£o Ã© vÃ¡lida:

ğ‘›âˆ’1
ğ‘

Ì¸â‰¡ 1 mod ğ‘›

ğ‘
para cada fator primo ğ‘ de ğ‘› âˆ’ 1 , entÃ£o ğ‘› Ã© primo.
Logo, para isso, fatoramos ğ‘› âˆ’ 1. Utilizando o algoritmo da fatoraÃ§Ã£o encontramos ğ‘› âˆ’ 1 =
23.33.5.7 e, portanto, temos que verificar para 4 fatores primos:

18

888 7560

2 = 8883780 â‰¡ âˆ’1 mod 7561
3 = 8882520 â‰¡ 6262 mod 7561
5 = 8881512 â‰¡ 5935 mod 7561
7 = 8881080 â‰¡ 5291 mod 7561

888 7560

888 7560

888 7560

Uma vez tendo as duas condiÃ§Ãµes satisfeitas podemos concluir que 7561 Ã© um nÃºmero primo.

Vale lembrar que, se uma das condiÃ§Ãµes nÃ£o Ã© satisfeita no teste de Lucas, nÃ£o significa que o

nÃºmero que temos nÃ£o Ã© primo, nesse caso a estratÃ©gia Ã© trocar a base que estamos utilizando.

Exemplo 12. Queremos provar que 31 Ã© primo utilizando o teste de Lucas:

â€¢ Escolhemos uma base para realizar o teste, vamos utilizar ğ‘ = 2

â€¢ Verificamos se a primeira condiÃ§Ã£o ğ‘ğ‘›âˆ’1 â‰¡ 1 mod ğ‘› Ã© valida:

230 â‰¡ 1 mod 31;

â€¢ Verificamos se a segunda condiÃ§Ã£o ğ‘

Ì¸â‰¡ 1 mod ğ‘› Ã© vÃ¡lida para cada fator primo ğ‘ de ğ‘›âˆ’1:
Logo, para isso, fatoramos ğ‘› âˆ’ 1 = 30. Utilizando o algoritmo da fatoraÃ§Ã£o encontramos
30 = 2 Â· 3 Â· 5 e, portanto, temos que verificar para 3 fatores primos.
2 30

2 â‰¡ 1 mod 31

ğ‘›âˆ’1
ğ‘

Observe que o teste falhou jÃ¡ no primeiro fator primo de ğ‘› âˆ’ 1, porÃ©m 31 Ã© um nÃºmero primo
muito conhecido. Logo o teste tinha que ter uma resposta positiva, para isso sÃ³ o que temos a
fazer Ã© trocar a base e realizar os passos novamente.

â€¢ Escolhemos uma nova base para realizar o teste, vamos utilizar ğ‘ = 12;

â€¢ Verificamos se a primeira condiÃ§Ã£o ğ‘ğ‘›âˆ’1 â‰¡ 1 mod ğ‘› Ã© valida:

1230 â‰¡ 1 mod 31

â€¢ Verificamos se a segunda condiÃ§Ã£o ğ‘

ğ‘›âˆ’1
ğ‘

Ì¸â‰¡ 1 mod ğ‘› Ã© vÃ¡lida para cada fator primo ğ‘ de ğ‘›âˆ’1:

12 30

2 â‰¡ âˆ’1 mod 31
3 â‰¡ 25 mod 31
5 â‰¡ 2 mod 31

12 30

12 30

Assim, apÃ³s termos comprovados as duas condiÃ§Ãµes, podemos afirmar que 31 Ã© um nÃºmero

primo.

19

A escolha de uma base que satisfaÃ§a ambas as condiÃ§Ãµes pode ser um tanto trabalhosa. Feliz-
mente, segundo Coutinho (2013, p.171) â€œEm 1.975 Brilhart, Lehmer e Selfridge observaram que
nÃ£o Ã© necessÃ¡rio usar uma base Ãºnica no teste de Lucas. Podemos nos dar ao luxo de escolher uma
base distinta para cada primo. Com isto obtemos um teste um pouco mais eficienteâ€.

Seja ğ‘› > 0 um inteiro tal que: ğ‘› âˆ’ 1 = ğ‘ğ‘’1

1 Â· Â· Â· ğ‘ğ‘’ğ‘Ÿ

ğ‘Ÿ , onde ğ‘1 < Â· Â· Â· < ğ‘ğ‘Ÿ sÃ£o primos. Se, para cada

ğ‘– = 1, Â· Â· Â· , ğ‘Ÿ, existirem inteiros positivos ğ‘ğ‘– com 2 â‰¤ ğ‘ğ‘– â‰¤ ğ‘› âˆ’ 1 que satisfaÃ§am:

ğ‘– â‰¡ 1 mod ğ‘›
ğ‘ğ‘›âˆ’1

ğ‘›âˆ’1
ğ‘ğ‘–

Ì¸â‰¡ 1 mod ğ‘›, entÃ£o ğ‘› Ã© primo. NÃ£o sendo necessÃ¡rio que os ğ‘ğ‘–â€™s sejam todos distintos.

ğ‘
ğ‘–
Vejamos como utilizar tal versÃ£o aprimorada deste teste de primalidade:

Exemplo 13. Vamos utilizar o teste de Lucas para provar que o nÃºmero 7 Ã© um nÃºmero primo.

â€¢ Escolhemos uma nova base para realizar o teste, valor utilizar ğ‘ = 2

â€¢ Verificamos se a primeira condiÃ§Ã£o ğ‘ğ‘›âˆ’1 â‰¡ 1 mod ğ‘› Ã© valida:

26 â‰¡ 1 mod 7;

â€¢ Verificamos se a segunda condiÃ§Ã£o Ã© vÃ¡lida:

ğ‘›âˆ’1
ğ‘

Ì¸â‰¡ 1 mod ğ‘› para cada fator primo ğ‘ de ğ‘› âˆ’ 1. Assim sendo, ğ‘› Ã© primo.

ğ‘
Logo, para isso fatoramos ğ‘›âˆ’1 = 6. Utilizando o algoritmo da fatoraÃ§Ã£o encontramos 6 = 2Â·3
e, portanto, temos que verificar para 2 fatores primos.

ğ‘›âˆ’1
ğ‘

Ì¸â‰¡ 1 mod ğ‘›

ğ‘
2 6
2 â‰¡ 1 mod 7 , e o teste falha, desta forma mudamos a base para 3.
3 6
2 â‰¡ âˆ’1 mod 7
3 6
3 â‰¡ 2 mod 7,

tendo como saida assim que o nÃºmero 7 Ã© primo.

Apesar do teste de Lucas possuir a grande vantagem de ter como saÃ­da a certeza de que um
determinado nÃºmero Ã© primo, ele padece tambÃ©m de um grande problema. JÃ¡ que ao se observar
com atenÃ§Ã£o seu enunciado percebemos que ele tem que ser verificado para cada fator primo
de ğ‘› âˆ’ 1, ou seja, precisamos fatorar ğ‘› âˆ’ 1, e como jÃ¡ sabemos fatorar um nÃºmero suficientemente
grande pode levar tanto tempo que se torna inviÃ¡vel.

No teste de Lucas a estratÃ©gia utilizada Ã© provar que a ordem de ğ‘› Ã© igual a ğœ‘(ğ‘›), significando
assim que se ğ‘ < ğ‘› Ã© um inteiro positivo, temos (ğ‘, ğ‘›) = 1 o que significaria que ğ‘› Ã© primo. Para
encontrar a ordem de um nÃºmero ğ‘›, ou seja, encontrar a quantidade de nÃºmeros menores que ğ‘› e
que tambÃ©m sÃ£o primos com ğ‘›, em um primeiro pensamento, pode se tentar contar os elementos
um a um, tarefa essa impossÃ­vel se o nÃºmero em questÃ£o for grande o suficiente. Para contornar
esse problema, faz se uso do Teorema da Raiz Primitiva.

Quando ğœ‘(ğ‘›) Ã© a ordem de ğ‘ com respeito a ğ‘›, entÃ£o dizemos que ğ‘ Ã© uma raiz primitiva mÃ³dulo

ğ‘›. ğ‘ Ã© raiz primitiva com respeito a ğ‘› â‡” ordem de ğ‘ com respeito a ğ‘› Ã© igual ğœ‘(ğ‘›) .

20

Teorema 4. (Teorema da Raiz Primitiva)

Se a Ã© raiz primitiva de p, entÃ£o:
ğ‘ mod ğ‘, ğ‘2 mod ğ‘, ğ‘3 mod ğ‘, ..., ğ‘ğ‘âˆ’1 mod ğ‘, sÃ£o distintos e pertencem a {ï¸Â¯1... Â¯ğ‘ âˆ’ 1}ï¸

, ou

seja, a raiz primitiva gera todos os elementos do grupo multiplicativo Zğ‘.

A seguir Ã© apresentado um exemplo para melhor ilustrar o Teorema:

Exemplo 14. Vamos calcular a ordem de 5 com respeito a 9, o que podemos denotar como:
ğ‘œğ‘Ÿğ‘‘9(5).

Como sabemos que ğœ‘(9) = ğœ‘(32) = 32âˆ’1 Â· (3 âˆ’ 1) = 6 e que ğ‘œğ‘Ÿğ‘‘9(5)|ğœ‘(9) = 6, basta calcular as

potÃªncias dos divisores de 6 para encontrarmos tal ordem:

51 â‰¡ 5 mod 9
52 â‰¡ 7 mod 9
53 â‰¡ 8 mod 9
56 â‰¡ 1 mod 9

Desta forma ğ‘œğ‘Ÿğ‘‘95 = 6. Como ğ‘œğ‘Ÿğ‘‘95 = 6 = ğœ‘(9), dizemos que 5 Ã© uma raiz primitiva mÃ³dulo 9.

O Teorema da raiz primitiva nos garante que sempre existirÃ¡ um nÃºmero ğ‘ que cumpra as

condiÃ§Ãµes descritas acima se ğ‘› for realmente um nÃºmero primo.

No capÃ­tulo a seguir serÃ¡ abordado mÃ©todos criptogrÃ¡ficos os quais se utilizam dos teoremas
que foram apresentados atÃ© entÃ£o, juntamente com as fragilidades dos testes de primalidade exis-
tente. SerÃ¡ possÃ­vel analisar como a dificuldade em se fatorar um nÃºmero serve de apoio para a
Criptografia RSA e tambÃ©m como o Teorema da raiz primitva Ã© Ãºtil para o mÃ©todo criptogrÃ¡fico
Diffie-Hellman os quais estudaremos mais adiante.

21

CapÃ­tulo 3

MÃ‰TODOS CRIPTOGRÃFICOS

SerÃ¡ abordado neste capÃ­tulo, uma aplicaÃ§Ã£o matemÃ¡tica que nos Ãºltimos anos passou a tirar
proveito da dificuldade em se fatorar um nÃºmero e, tambÃ©m, da dificuldade em descobrir se um
nÃºmero (âˆˆ N) Ã© primo, a criptografia.

A criptografia Ã© muito utilizada nos dias atuais para proteger transaÃ§Ãµes financeiras realizadas
atravÃ©s do computador. Um exemplo muito comum sÃ£o as compras realizadas via Internet e pagas
com cartÃ£o de crÃ©dito, nelas o comprador digita o nÃºmero e alguns dados de seu cartÃ£o de crÃ©dito
no site da loja e somente com estas informaÃ§Ãµes Ã© realizado o pagamento da compra. Se esses
dados caÃ­ssem nas mÃ£os de um terceiro, ele conseguiria utilizar este cartÃ£o para novas compras
em seu nome, sem nenhuma dificuldade. Por esse motivo, essas informaÃ§Ãµes do cartÃ£o de crÃ©dito
precisam ser codificadas de maneira que somente o destinatÃ¡rio real (a loja) consiga compreender.
Essa codificaÃ§Ã£o precisa atender alguns requisitos para que possa ser eficaz, o primeiro deles Ã©
que o destinatÃ¡rio (em nosso exemplo, a loja) saiba como decodificar os dados. Portanto, a
codificaÃ§Ã£o nÃ£o pode ocorrer de forma aleatÃ³ria, significando assim que tanto a loja quanto o
comprador precisam saber como codificar tais dados. Mas, nesse ponto temos um problema, pois
a comunicaÃ§Ã£o entre a loja e o comprador estÃ¡ sendo realizada via internet e, da mesma maneira
que os dados do cartÃ£o de crÃ©dito podem ser interceptados por um terceiro (e por este motivo
precisam ser codificados), a codificaÃ§Ã£o utilizada tambÃ©m corre este risco. Assim quando a loja
comunica ao comprador o cÃ³digo que ele utilizarÃ¡ para codificar, esse cÃ³digo nÃ£o Ã© mais seguro.

Tal fato era verdade atÃ© algum tempo atrÃ¡s, pois antigamente as maneiras conhecidas de se
codificar tinham uma relaÃ§Ã£o muito forte com as de decodificar, bastando para isso â€œdesfazer"a
codificaÃ§Ã£o ( voltar os passos realizados para codificar). O que acontece Ã© que quando vamos codi-
ficar alguma informaÃ§Ã£o, existe uma â€œreceita"contendo o passo a passo do processo de codificaÃ§Ã£o,
chegando assim ao terminar esse processo no resultado final que Ã© a mensagem codificada. Se
essa maneira de codificar (â€œreceita") caÃ­sse nas mÃ£os de um terceiro, juntamente com a mensagem
codificada, bastava para ele voltar os passos realizados para codificar, conseguindo decodificar tal
mensagem.

Como dito anteriormente isto era verdade atÃ© algum tempo atrÃ¡s, o que acontece Ã© que existe
uma maneira de se codificar a qual nÃ£o sofre deste mal, pois ao tentar realizar tal processo inverso

22

da codificaÃ§Ã£o, esse processo se torna tÃ£o trabalhoso a ponto de ser impossÃ­vel ser realizado, ou
seja, um processo fÃ¡cil de ser feito mais muito difÃ­cil de ser desfeito, garantindo assim que mesmo
se um terceiro soubesse como a codificaÃ§Ã£o foi realizada, este terceiro nÃ£o conseguiria decodificar os
dados. Essa nova maneira de se codificar Ã© conhecida como Criptografia de Chave PÃºblica, levando
em conta que o processo de codificaÃ§Ã£o pode se tornar pÃºblico sem comprometer a seguranÃ§a do
mÃ©todo.

Na Criptografia de Chave PÃºblica a codificaÃ§Ã£o Ã© realizada utilizando uma chave (mÃ©todo de
codificaÃ§Ã£o) pÃºblica, porÃ©m para ser decodificada se faz necessÃ¡rio o uso de uma outra chave
(mÃ©todo), chave esta que, fica privada somente ao destinatÃ¡rio da mensagem, ou seja, aquele que
decodificarÃ¡ tal mensagem. O que resolve o problema descrito acima, haja visto que desta forma
a pessoa que irÃ¡ codificar os dados nÃ£o precisa conhecer o mÃ©todo de decodificaÃ§Ã£o e, dessa forma,
mesmo que exista um terceiro que encontre a mensagem criptografada junto com o mÃ©todo de
codificaÃ§Ã£o, este terceiro nÃ£o conseguirÃ¡ decodificar tais dados.

A Criptografia de Chave PÃºblica utilizada no exemplo da compra via internet paga com cartÃ£o
de credito Ã© conhecida como Criptografia RSA, sigla essa que leva as iniciais de seus criadores
R.L.Rivest, A. Shamir e L. Adleman, como homenagem. Vejamos a seguir como tal mÃ©todo se
utiliza da matemÃ¡tica para seu funcionamento.

3.1 Criptografia RSA

Aqui vamos entender um pouco como funciona o mÃ©todo RSA. A chave de codificaÃ§Ã£o utilizada
neste mÃ©todo Ã© composta pelo nÃºmero ğ‘› formado pelo produto de dois nÃºmeros primos distintos
ğ‘ e ğ‘, tal chave Ã© conhecida como chave pÃºblica. A chave de decodificaÃ§Ã£o Ã© composta pelos dois
nÃºmeros primos ğ‘ e ğ‘, essa Ã© a chave privada. Embora exista aparentemente uma proximidade
entre ambas, nÃ£o Ã© possÃ­vel encontrar a chave privada (os dois nÃºmeros primos ğ‘ e ğ‘) a partir da
chave pÃºblica ğ‘›, pois, para isso, precisarÃ­amos decompor a chave ğ‘›. Como vimos atÃ© agora, se um
nÃºmero for grande o suficiente, se torna impossÃ­vel atÃ© mesmo com a utilizaÃ§Ã£o de um computador
decompor esse nÃºmero, em tempo hÃ¡bil.

Dados necessÃ¡rios para a utilizaÃ§Ã£o da criptografia RSA:

â€¢ escolhe-se dois nÃºmeros primos distintos ğ‘ e ğ‘ grandes o suficiente e calcula-se o produto ğ‘ Â· ğ‘

, o resultado chamamos de ğ‘› (ğ‘› = ğ‘ Â· ğ‘):

â€¢ ğ‘› Ã© utilizado para codificar a mensagem (ğ‘› Ã© a chave pÃºblica);

â€¢ ğ‘ e ğ‘ sÃ£o utilizados para decodificar a mensagem (ğ‘ e ğ‘ sÃ£o as chaves privadas);

â€¢ para quebrar o cÃ³digo RSA Ã© necessÃ¡rio fatorar ğ‘› descobrindo assim os nÃºmeros ğ‘ e ğ‘, porÃ©m
ao se utilizar nÃºmeros grandes o suficiente (de cerca de 100 digitos), fatorÃ¡-lo se torna um
processo inviÃ¡vel, devido ao tempo que os mÃ©todos atuais levariam, sendo assim impossÃ­vel
de colocÃ¡-los em prÃ¡tica.

Assim sendo, as chaves de codificaÃ§Ã£o e de decodificaÃ§Ã£o sÃ£o nÃºmeros, e a codificaÃ§Ã£o Ã© realizada
por meio do cÃ¡lculo de uma potÃªncia mÃ³dulo ğ‘› (chave pÃºblica de codificaÃ§Ã£o). Para que isso seja

23

possÃ­vel, a mensagem a ser codificada precisa ser um nÃºmero inteiro e, portanto, quando tal
mensagem for um texto devemos converter tal texto em uma sequÃªncia de nÃºmeros para assim
codificÃ¡-la.

1. Na primeira etapa, converteremos as letras em nÃºmeros de dois dÃ­gitos para evitar ambigui-

dades, conforme a tabela a seguir:

11

J K L M
F G H
A B C D E
10
22
19
17
16
15
14
12
N O P Q R S T U V W X Y Z
35
29
23

I
18

32

34

33

31

30

13

26

20

24

28

21

25

27

Na conversÃ£o, o espaÃ§o entre duas palavras Ã© substituido pelo nÃºmero 99 e, desta forma,
temos a mensagem convertida para uma sequÃªncia de nÃºmeros.

2. Feito toda a conversÃ£o da mensagem a ser codificada para nÃºmeros, o prÃ³ximo passo Ã© a
escolha dos dois nÃºmeros primos distintos ğ‘ e ğ‘, os quais chamaremos de parÃ¢metros e o
cÃ¡lculo de ğ‘›, tal que ğ‘› = ğ‘ Â· ğ‘.

3. O Ãºltimo passo antes de iniciarmos a codificaÃ§Ã£o em si, Ã© quebrar a sequÃªncia de nÃºmeros em
blocos, de maneira que cada bloco produzido seja menor que o nÃºmero ğ‘›. Existem diversas
maneiras em que pode-se quebrar os blocos, porÃ©m, eles nÃ£o podem ser iniciados com 0, a fim
de evitar problemas na hora de decodificar. Esses blocos nÃ£o correspondem a letras, sÃ­mbolos
ou qualquer outra unidade linguÃ­stica e, portanto, elimina a possibilidade da utilizaÃ§Ã£o da
decodificaÃ§Ã£o por frequÃªncia.

4. ApÃ³s esta etapa, jÃ¡ pode-se dar inÃ­cio a codificaÃ§Ã£o da mensagem que esta divida em blocos.
Para codificar a mensagem Ã© utilizada a chave pÃºblica a qual Ã© composta pelos nÃºmeros ğ‘›
e ğ‘’, sendo ğ‘’ um inteiro positivo inversÃ­vel mÃ³dulo ğœ‘(ğ‘›), ou seja, ğ‘šğ‘‘ğ‘(ğ‘’, ğœ‘(ğ‘›)) = 1. Observe
que o cÃ¡lculo de ğœ‘(ğ‘›) Ã© possÃ­vel se soubermos a chave de decodificaÃ§Ã£o, pois ğ‘› = ğ‘.ğ‘ e assim
sendo ğœ‘(ğ‘›) = ğœ‘(ğ‘ Â· ğ‘) = (ğ‘ âˆ’ 1) Â· (ğ‘ âˆ’ 1). Dessa forma, juntamente com ğ‘› temos como parte
da chave de codificaÃ§Ã£o o nÃºmero ğ‘’.

5. Seja ğ‘ o bloco a ser codificado, logo ğ‘ Ã© um inteiro positivo menor que ğ‘›. Denotando o bloco
codificado como ğ¶(ğ‘), calculamos ğ¶(ğ‘) atravÃ©s do seguinte cÃ¡lculo: ğ‘ğ‘’ â‰¡ ğ¶(ğ‘) mod ğ‘›, sendo
0 â‰¤ ğ¶(ğ‘) < ğ‘› , dessa forma podemos dizer que ğ¶(ğ‘) Ã© o resto da divisÃ£o de ğ‘ğ‘’ por ğ‘›.
Feita a codificaÃ§Ã£o de todos os blocos, blocos esses que, apÃ³s terem sido codificados, nÃ£o
podem mais serem reunidos de modo a formar novamente um grande nÃºmero, pois se isto
ocorrer serÃ¡ impossÃ­vel sua decodificaÃ§Ã£o.

6. Para realizar a decodificaÃ§Ã£o se faz necessÃ¡rio a posse de dois nÃºmeros: ğ‘› e ğ‘‘ , onde ğ‘‘ Ã© o

inverso de ğ‘’ mÃ³dulo ğœ‘(ğ‘›). Os nÃºmeros ğ‘‘ e ğ‘’ formam a chave de decodificaÃ§Ã£o.
De posse da chave de decodificaÃ§Ã£o juntamente com os blocos jÃ¡ codificados, precisamos
compreender quais sÃ£o os passos que nos permitem reconstruir os blocos originais de antes
da codificaÃ§Ã£o.

24

7. Seja ğ‘ o bloco codificado, o qual queremos decodificar, e ğ·(ğ‘) o resultado do processo desta
decodificaÃ§Ã£o. Calculamos ğ·(ğ‘) da seguinte forma: ğ‘ğ‘‘ â‰¡ ğ·(ğ‘) mod ğ‘›, sendo 0 â‰¤ ğ·(ğ‘) < ğ‘›
, dessa forma podemos dizer que ğ·(ğ‘) Ã© o resto da divisÃ£o de ğ‘ğ‘‘ por ğ‘›.
Desta forma temos que encontrar ğ‘‘. Observe que ele pode ser calculado com facilidade
atravÃ©s do algoritmo euclidiano estendido, desde que ğœ‘(ğ‘›) e ğ‘’ sejam conhecidos.

8. ApÃ³s este passo precisamos provar que, sendo ğ‘ um bloco da mensagem original, temos
ğ·(ğ¶(ğ‘)) = ğ‘ , ou seja, decodificando um bloco da mensagem codificada, sempre encontramos
o bloco da mensagem original correspondente. Em seguida, basta colocar novamente os
blocos em uma sequÃªncia longa de nÃºmeros e convertÃª-los na mensagem original.

A seguir um exemplo de como a Criptografia RSA pode ser utilizada:

Exemplo 15. Vamos codificar a mensagem â€œNÃšMEROS INTEIROSâ€.

1. Num primeiro momento devemos converter as letras em nÃºmeros com auxÃ­lio da tabela:

11

F G H
A B C D E
J K L M
22
17
16
14
12
10
15
19
N O P Q R S T U V W X Y Z
35
29
23

I
18

28

25

13

24

21

26

32

20

31

30

34

33

27

Assim sendo, conseguimos a sequÃªncia numÃ©rica a seguir:

23302214272428991823291418272428

2. O prÃ³ximo passo Ã© a escolha dos parÃ¢metros, ou seja, dos dois nÃºmeros primos ğ‘ e ğ‘. Para
simplificar um pouco, escolheremos nÃºmeros primos pequenos a fim de facilitar as contas, as
quais podem ser realizadas atÃ© mesmo com a calculadora cientÃ­fica do computador, tornando
mais evidente o mÃ©todo que estÃ¡ sendo utilizado.
Seja entÃ£o, ğ‘ = 11 e ğ‘ = 13 , sendo assim temos ğ‘› = 143

3. Temos que quebrar esta sequÃªncia numÃ©rica em pequenos blocos, de maneira que cada bloco

seja menor que o nÃºmero ğ‘›, em nosso caso menor que 143.
23302214272428991823291418272428

Assim procedendo, temos os blocos separados por um traÃ§o:
23 âˆ’ 30 âˆ’ 22 âˆ’ 142 âˆ’ 72 âˆ’ 42 âˆ’ 89 âˆ’ 91 âˆ’ 82 âˆ’ 32 âˆ’ 91 âˆ’ 41 âˆ’ 82 âˆ’ 72 âˆ’ 42 âˆ’ 8

4. Em seguida calculamos ğœ‘(ğ‘›) a fim de encontrar um nÃºmero ğ‘’ tal que ğ‘šğ‘‘ğ‘(ğ‘’, ğœ‘(ğ‘›)) = 1, onde:

ğœ‘(ğ‘›) = ğœ‘(ğ‘.ğ‘) = ğœ‘(13.11) = 12.10 = 120
TambÃ©m, a fim de facilitar os cÃ¡lculos, visto que, o objetivo deste exemplo Ã© evidenciar o
mÃ©todo que estÃ¡ sendo utilizado, utilizaremos ğ‘’ = 7, podemos fazer isto pois ğ‘šğ‘‘ğ‘(7, 120) = 1.
Produzimos assim os itens necessÃ¡rio da chave pÃºblica (de codificaÃ§Ã£o), que sÃ£o os nÃºmeros
â€œğ‘’â€ e â€œğ‘›â€.

25

5. De posse da chave de codificaÃ§Ã£o e dos blocos convertidos em nÃºmeros, podemos dar inÃ­cio

Ã  codificaÃ§Ã£o:

23 âˆ’ 30 âˆ’ 22 âˆ’ 142 âˆ’ 72 âˆ’ 42 âˆ’ 89 âˆ’ 91 âˆ’ 82 âˆ’ 32 âˆ’ 91 âˆ’ 41 âˆ’ 82 âˆ’ 72 âˆ’ 42 âˆ’ 8
ğ‘ğ‘’ â‰¡ ğ¶(ğ‘) mod ğ‘› , sendo ğ¶(ğ‘) < ğ‘›
237 â‰¡ 23 mod 143
307 â‰¡ 134 mod 143
227 â‰¡ 22 mod 143
1427 â‰¡ 142 mod 143
727 â‰¡ 19 mod 143
427 â‰¡ 81 mod 143
897 â‰¡ 67 mod 143
917 â‰¡ 130 mod 143
827 â‰¡ 69 mod 143
327 â‰¡ 98 mod 143
917 â‰¡ 130 mod 143
417 â‰¡ 24 mod 143
827 â‰¡ 69 mod 143
727 â‰¡ 19 mod 143
427 â‰¡ 81 mod 143
87 â‰¡ 57 mod 143
Feito os cÃ¡lculos, temos os blocos agora codificados:

23 âˆ’ 134 âˆ’ 22 âˆ’ 142 âˆ’ 19 âˆ’ 81 âˆ’ 67 âˆ’ 130 âˆ’ 69 âˆ’ 98 âˆ’ 130 âˆ’ 24 âˆ’ 69 âˆ’ 19 âˆ’ 81 âˆ’ 57

6. Para realizar a decodificaÃ§Ã£o da mensagem, se faz necessÃ¡rio os nÃºmeros ğ‘› e ğ‘‘, entÃ£o devemos

calcular o valor de ğ‘‘ para que possamos prosseguir com a decodificaÃ§Ã£o:
ğ‘‘.ğ‘’ â‰¡ 1 mod ğœ‘(ğ‘›)
ğ‘‘.7 â‰¡ 1 mod 120
103.7 â‰¡ 1 mod 120 , encontramos ğ‘‘ = 103, utilizando aqui o algoritmo de Euclides estendido
com os nÃºmeros 7 e 120.
Temos assim a chave privada (de decodificaÃ§Ã£o), composta por ğ‘‘ e ğ‘›.

7. De posse da chave privada (ğ‘› = 143, ğ‘‘ = 103) e dos blocos codificados, podemos iniciar a

decoficaÃ§Ã£o que acontecerÃ¡ da seguinte maneira:

23 âˆ’ 134 âˆ’ 22 âˆ’ 142 âˆ’ 19 âˆ’ 81 âˆ’ 67 âˆ’ 130 âˆ’ 69 âˆ’ 98 âˆ’ 130 âˆ’ 24 âˆ’ 69 âˆ’ 19 âˆ’ 81 âˆ’ 57
ğ‘ â‰¡ ğ·(ğ‘)ğ‘‘ mod ğ‘›, sendo ğ·(ğ‘) < ğ‘› , ğ‘ um bloco codificado e ğ·(ğ‘) o bloco jÃ¡ decodificado.

26

ğ‘ â‰¡ ğ·(ğ‘)ğ‘‘ mod ğ‘›
23103 â‰¡ 23 mod 143
134103 â‰¡ 30 mod 143
22103 â‰¡ 22 mod 143
142103 â‰¡ 142 mod 143
19103 â‰¡ 72 mod 143
81103 â‰¡ 42 mod 143
67103 â‰¡ 89 mod 143
130103 â‰¡ 91 mod 143
69103 â‰¡ 82 mod 143
98103 â‰¡ 32 mod 143
130103 â‰¡ 91 mod 143
24103 â‰¡ 41 mod 143
69103 â‰¡ 82 mod 143
19103 â‰¡ 72 mod 143
81103 â‰¡ 42 mod 143
57103 â‰¡ 8 mod 143
E assim, conseguimos realizar toda a decodificaÃ§Ã£o, encontrando novamente os blocos numÃ©-
ricos de antes da codificaÃ§Ã£o:

23 âˆ’ 30 âˆ’ 22 âˆ’ 142 âˆ’ 72 âˆ’ 42 âˆ’ 89 âˆ’ 91 âˆ’ 82 âˆ’ 32 âˆ’ 91 âˆ’ 41 âˆ’ 82 âˆ’ 72 âˆ’ 42 âˆ’ 8

8. Como Ãºltimo passo, devemos entÃ£o, juntar os blocos de maneira a formar uma grande lista
de nÃºmeros e em seguida converter novamente os nÃºmeros nas letras conforme tabela descrita
anteriormente.

23302214272428991823291418272428

23 âˆ’ 30 âˆ’ 22 âˆ’ 14 âˆ’ 27 âˆ’ 24 âˆ’ 28 âˆ’ 99 âˆ’ 18 âˆ’ 23 âˆ’ 29 âˆ’ 14 âˆ’ 18 âˆ’ 27 âˆ’ 24 âˆ’ 28
NÃšMEROS INTEIROS

Ao observar a codificaÃ§Ã£o e a decodificaÃ§Ã£o do mÃ©todo de Criptografia RSA observamos que,

para codificar, utilizamos:

ğ‘ğ‘’ â‰¡ ğ¶(ğ‘) mod ğ‘›, com ğ¶(ğ‘) < ğ‘›, e, para decodificar, utilizamos:
ğ‘ğ‘‘ â‰¡ ğ·(ğ‘) mod ğ‘›, com ğ·(ğ‘) < ğ‘›.
PorÃ©m, observamos que na etapa de codificaÃ§Ã£o utilizamos ğ¶(ğ‘) para o bloco jÃ¡ codificado e na

etapa de decodificaÃ§Ã£o este mesmo bloco codificado passou a se denominar ğ‘, logo ğ¶(ğ‘) = ğ‘.

Logo, temos que provar que ğ·(ğ¶(ğ‘)) = ğ‘ para 1 â‰¤ ğ‘ â‰¤ ğ‘› âˆ’ 1.
Desta forma podemos utilizar congruÃªncias, pois tanto ğ·(ğ¶(ğ‘)) quanto ğ‘ sÃ£o menores que ğ‘› :

ğ·(ğ¶(ğ‘)) â‰¡ ğ·(ğ‘ğ‘’) â‰¡ (ğ‘ğ‘’)ğ‘‘ â‰¡ ğ‘ğ‘’Â·ğ‘‘ mod ğ‘›.

27

Lembrando que: ğ‘’ Â· ğ‘‘ â‰¡ 1 mod ğœ‘(ğ‘›), ou ainda, ğ‘’ Â· ğ‘‘ = 1 + ğ‘˜ Â· ğœ‘(ğ‘›), com ğ‘˜ âˆˆ Z, segue que:
ğ‘ğ‘’Â·ğ‘‘ â‰¡ ğ‘1+ğ‘˜Â·ğœ‘(ğ‘›) mod ğ‘›.
ğ‘1+ğ‘˜Â·ğœ‘(ğ‘›) â‰¡ ğ‘1 Â· (ğ‘ğœ‘(ğ‘›))ğ‘˜ mod ğ‘›
Como sabemos fatorar ğ‘›, podemos calcular ğœ‘(ğ‘›) (ğœ‘(ğ‘›) = ğœ‘(ğ‘Â·ğ‘) = (ğ‘âˆ’1)Â·(ğ‘ âˆ’1)), substituindo

em nossa congruÃªncia:

ğ‘1+ğ‘˜Â·ğœ‘(ğ‘›) â‰¡ ğ‘1 Â· (ğ‘((ğ‘âˆ’1)Â·(ğ‘âˆ’1)))ğ‘˜ mod ğ‘›
ğ‘1 Â· ğ‘(ğ‘âˆ’1)Â·(ğ‘âˆ’1)Â·ğ‘˜ â‰¡ ğ‘1 Â· (ğ‘(ğ‘âˆ’1))(ğ‘âˆ’1)Â·ğ‘˜ mod ğ‘›
Temos atÃ© o momento:
ğ·(ğ¶(ğ‘)) â‰¡ ğ·(ğ‘ğ‘’) â‰¡ (ğ‘ğ‘’)ğ‘‘ â‰¡ ğ‘ğ‘’Â·ğ‘‘ â‰¡ ğ‘1 Â· (ğ‘(ğ‘âˆ’1))(ğ‘âˆ’1)Â·ğ‘˜ mod ğ‘›
Pelo Pequeno Teorema de Fermat sabemos que:
ğ‘1 Â· (ğ‘(ğ‘âˆ’1))(ğ‘âˆ’1)Â·ğ‘˜ â‰¡ ğ‘ Â· 1(ğ‘âˆ’1)Â·ğ‘˜ mod ğ‘
Analogamente encontramos que :
ğ‘1 Â· (ğ‘(ğ‘âˆ’1))(ğ‘âˆ’1)Â·ğ‘˜ â‰¡ ğ‘ Â· 1(ğ‘âˆ’1)Â·ğ‘˜ mod ğ‘
Como ğ‘ e ğ‘ sÃ£o primos distintos , temos (ğ‘, ğ‘) = 1, das congruÃªncias acima temos:
ğ‘|ğ‘(ğ‘’Â·ğ‘‘) âˆ’ ğ‘ e ğ‘|ğ‘(ğ‘’Â·ğ‘‘) âˆ’ ğ‘, e assim podemos concluir que:
ğ‘ Â· ğ‘|ğ‘(ğ‘’Â·ğ‘‘) âˆ’ ğ‘ , como ğ‘› = ğ‘ Â· ğ‘, podemos escrever em termos de congruÃªncia:
ğ‘(ğ‘’Â·ğ‘‘) â‰¡ ğ‘ mod ğ‘›
Concluimos assim, que:
ğ·(ğ¶(ğ‘)) â‰¡ ğ‘ mod ğ‘›.
Mostramos, que esse mÃ©todo funciona, mas precisamos agora entender um pouco sobre o que
torna o RSA seguro. A seguranÃ§a deste mÃ©todo reside no fato de que a pessoa que codifica os
dados tem acesso apenas a chave pÃºblica (os nÃºmeros ğ‘› e ğ‘’) enquanto que para decodificar os
dados faz-se necessÃ¡rio conhecer a chave privada (os nÃºmeros ğ‘› e ğ‘‘), ou seja o RSA se torna seguro
devido a grande dificuldade em calcular ğ‘‘ conhecendo apenas ğ‘› e ğ‘’.

Sabemos que ğ‘‘ Ã© o inverso de ğ‘’ mÃ³dulo ğœ‘(ğ‘›), desta forma bastaria aplicar o algoritmo de
Euclides estendido aos nÃºmeros ğ‘’ e ğœ‘(ğ‘›), porÃ©m assim se faz necessÃ¡rio conhecer ğœ‘(ğ‘›) e, para isso,
devemos fatorar ğ‘›, o que jÃ¡ vimos ser muito difÃ­cil se ğ‘› for grande o suficiente. Logo, sÃ³ Ã© possÃ­vel
calcular ğ‘‘ se soubermos os valores de ğ‘ e ğ‘ tal que ğ‘› = ğ‘ Â· ğ‘ e tais valores sÃ³ estÃ£o disponÃ­veis a
quem decodificarÃ¡ a mensagem, tornando o mÃ©todo de Criptografia RSA seguro.

Assim sendo, podemos entender como e porquÃª este mÃ©todo de Criptografia funciona. Em
seguida serÃ¡ apresentada uma aplicaÃ§Ã£o mais prÃ¡tica que a anterior, utilizando nÃºmeros maiores
para codificar e decodificar os dados de um cartÃ£o de crÃ©dito, que foi utilizado em uma compra via
internet. As contas realizadas no exemplo a seguir foram feitas utilizando o software xMaxima.

Exemplo 16. JoÃ£o estÃ¡ realizando uma compra via internet, a qual decidiu pagar com seu cartÃ£o
de crÃ©dito. Ao efetivar sua compra, JoÃ£o deve preencher os seus dados pessoais bem como seu
endereÃ§o para o qual serÃ¡ enviado seu produto e, em algum momento, apÃ³s esta etapa ele serÃ¡ en-
caminhado a uma pÃ¡gina na qual deverÃ¡ efetuar o pagamento pela compra realizada. Nessa pÃ¡gina
JoÃ£o deverÃ¡ informar os dados do seu cartÃ£o de crÃ©dito e, ao digitar tais dados, seu computador
codificarÃ¡ esses dados com a chave pÃºblica que foi enviada pelo site da loja.

A loja Ã© a responsÃ¡vel pela distribuiÃ§Ã£o da chave pÃºblica, dessa maneira vÃ¡rios compradores
podem utilizar a mesma chave pÃºblica sem nenhum problema, pois somente ela tem a chave privada
a qual permite decodificar tais dados e, assim, conseguir compreender os dados enviados. Desse

28

modo, a loja envia ao computador de JoÃ£o a chave pÃºblica composta dos nÃºmeros ğ‘› = 11.413 e
ğ‘’ = 3.

JoÃ£o digita o nÃºmero de seu cartÃ£o de crÃ©dito: 1234567812345678, o seu computador os separa

em blocos e em seguida os codifica:
123 âˆ’ 4567 âˆ’ 8123 âˆ’ 456 âˆ’ 78
1233 â‰¡ 548 mod 11413
45673 â‰¡ 1558 mod 11413
81233 â‰¡ 10.120 mod 11413
4563 â‰¡ 11.025 mod 11413
783 â‰¡ 6.619 mod 11413
O Computador apÃ³s codificar os blocos em que foram separados os dados, os envia para a loja:
548 âˆ’ 1558 âˆ’ 10120 âˆ’ 11025 âˆ’ 6619
A loja, de posse da chave privada composta pelos nÃºmeros ğ‘‘ = 7467 e ğ‘› = 11413, recebe os
blocos devidamente codificados e entÃ£o realiza os cÃ¡lculos para decodificar os dados contidos nos
blocos.

5487467 â‰¡ 123 mod 11413
15587467 â‰¡ 4567 mod 11413
101207467 â‰¡ 8123 mod 11413
110257467 â‰¡ 456 mod 11413
66197467 â‰¡ 78 mod 11413
Encontrando assim os blocos jÃ¡ decodificados:
123 âˆ’ 4567 âˆ’ 8123 âˆ’ 456 âˆ’ 78
Bastando agora juntÃ¡-los, voltando assim a forma original dos dados do cartÃ£o de crÃ©dito.
Uma vez com os dados necessÃ¡rios em mÃ£os, a loja efetua o pagamento e envia a mercadoria,
concretizando a compra.

Os nÃºmeros primos utilizados no exemplo acima possuem apenas 3 casas decimais e, mesmo
assim, jÃ¡ se faz necessÃ¡rio o uso de um software matemÃ¡tico capaz de calcular com nÃºmeros grandes,
em operaÃ§Ãµes reais os nÃºmeros primos utilizados possuem cerca de 100 dÃ­gitos.

3.2 Criptografia Diffie-Hellman

Uma outra criptografia que tambÃ©m utiliza chave pÃºblica Ã© a criptografia de Diffie-Hellman,
esse mÃ©todo tem sua seguranÃ§a baseada na dificuldade em se encontrar logarÃ­tmos discretos e foi
criado para solucionar o seguinte problema:

Imagine que duas pessoas Alice e Bob precisam se comunicar via internet de maneira segura,
ou seja, de forma que somente Alice leia as mensagens enviadas por Bob e de que somente Bob leia
as mensagens enviadas por Alice. Para ter seguranÃ§a tais mensagens devem ser codificadas a fim
de evitar que um terceiro as interceptem obtendo acesso as informaÃ§Ãµes descritas nas mensagens.
Pensando assim, quando Alice mandar uma mensagem para Bob, ela deve codificÃ¡-la de ma-
neira que somente Bob consiga decodificar e ler a mensagem, e tambÃ©m quando ele mandar uma
mensagem para Alice ele deve condificÃ¡-la de maneira que somente ela consiga decodificar e ler a

29

mensagem. O Problema aqui Ã© que, quando um deles transmite a mensagem codificada deve tam-
bÃ©m enviar uma chave contendo as informaÃ§Ãµes necessÃ¡rias para que o receptor possa decodificÃ¡-las
e, se essa informaÃ§Ã£o for interceptada, um terceiro pode ter acesso as mensagens trocadas, deixando
assim de serem secretas.

Esse problema teria soluÃ§Ã£o simples se Alice e Bob pudessem se encontrar e combinar com
antecedÃªncia a chave que utilizariam, porÃ©m o problema aqui apresentado trata de situaÃ§Ãµes onde
o Ãºnico meio de comunicaÃ§Ã£o possÃ­vel Ã© a internet e, portanto, eles devem encontrar uma maneira
segura de combinarem uma chave a ser usada, podendo assim se comunicarem de maneira segura.
Segundo Pires (2010), Whitfield Diffie e Martin Hellman propuseram uma soluÃ§Ã£o para este
problema, a qual ficou conhecida como protocolo Diffie-Hellman para a troca de chaves. O Pro-
tocolo Diffie-Hellman Ã© uma maneira segura de compartilhar uma chave, atravÃ©s de uma sÃ©rie de
procedimentos, duas pessoas conseguem compartilhar uma chave de codificaÃ§Ã£o e decodificaÃ§Ã£o
sem que mais ninguÃ©m tenha acesso, podendo utilizÃ¡-la para codificar as mensagens que serÃ£o
enviadas ao parceiro e decodificar as mensagens que serÃ£o recebidas pelo mesmo.

Vejamos como funciona tal procedimento para troca de chaves, talvez a melhor maneira de se
compreender o funcionamento deste mÃ©todo Criptografico seja utilizando um â€œesquema de cores".
Vamos voltar ao nosso problema de inÃ­cio, no qual duas pessoas precisavam se comunicar via
internet de maneira segura, a Alice e o Bob.

Antes de iniciar a conversa Alice e Bob devem utilizar a troca de chaves, para isto eles seguem

os passos a seguir:

1. Combinam uma cor que serÃ¡ de conhecimento de ambos (c), alÃ©m dessa cor cada um tambÃ©m

escolhe uma outra cor secreta a qual nÃ£o mostrarÃ£o a ninguÃ©m.

2. Alice mistura a cor comum (c) a sua cor secreta (a) produzindo uma nova cor (ca) e entÃ£o

a envia para Bob.

3. Bob tambÃ©m mistura a cor comum (c) a sua cor secreta (b) produzindo tambÃ©m uma nova

cor (cb) e entÃ£o a envia para Alice.

4. Alice recebe a cor obtida da mistura feita por Bob (cb) e entÃ£o adiciona a esta mistura sua

cor secreta obtendo uma nova cor (cba).

5. O mesmo Ã© feito por Bob, ele pega a mistura feita por Alice e adiciona sua cor secreta,

obtendo assim a mesma nova cor (cab) obtida por Alice.

Mesmo que em ordem diferente, a cor encontrada por Bob e a cor encontrada por Alice sÃ£o
iguais, pois foram produzidas com os mesmos ingredientes, esta nova cor Ã© o segredo comum de
Alice e Bob.

Se alguÃ©m interceptar as cores enviadas entre Alice e Bob, essa pessoa nÃ£o conseguirÃ¡ descobrir
os ingredientes necessÃ¡rios para obter a nova cor que Ã© o segredo a ser utilizado por Alice e Bob.
Isso devido ao fato de que antes de enviar a cor secreta, cada um a misturou a cor comum formando
assim uma nova cor, e apÃ³s ter misturado duas cores obtendo uma terceira Ã© impossÃ­vel desfazer
o processo para descobrir as cores secretas de Alice e de Bob as quais sÃ£o ingredientes para a cor
secreta.

30

Ao compararmos o procedimento das cores ao mÃ©todo Diffie-Hellman temos que a cor secreta
obtida serÃ¡ a chave secreta que Alice e Bob utilizariam para conversarem em seguranÃ§a, vejamos
como tal mÃ©todo funciona utilizando nÃºmeros ao invÃ©s de cores.

1. Alice e Bob combinam dois nÃºmeros ğ›¼, ğ‘ âˆˆ N , sendo ğ‘ primo e ğ›¼ uma raiz primitiva de ğ‘,

esses nÃºmeros sÃ£o a chave pÃºblica do mÃ©todo.

2. Em seguida, Alice escolhe um nÃºmero que seja menor que ğ‘ e o mantÃ©m em segredo, ou seja,
ğ‘¥ğ‘ < ğ‘. Bob tambÃ©m escolhe um nÃºmero menor que ğ‘ e o mantÃ©m em segredo, ou seja,
ğ‘¥ğ‘ < ğ‘.

3. O prÃ³ximo passo de Alice Ã© misturar seu nÃºmero secreto com a chave pÃºblica, para isso

calcula ğ‘¦ğ‘ da seguinte forma:
ğ›¼ğ‘¥ğ‘ â‰¡ ğ‘¦ğ‘ mod ğ‘, sendo ğ‘¦ğ‘ < ğ‘.
Bob tambÃ©m executa esse passo misturando seu nÃºmero secreto com a chave pÃºblica, pro-
duzindo assim ğ‘¦ğ‘ da seguinte forma:
ğ›¼ğ‘¥ğ‘ â‰¡ ğ‘¦ğ‘ mod ğ‘, sendo ğ‘¦ğ‘ < ğ‘.

4. Nesta etapa Alice envia para Bob o nÃºmero obtido de seu cÃ¡lculo: ğ‘¦ğ‘ e Bob tambÃ©m envia

para Alice o nÃºmero obtido de seu cÃ¡lculo: ğ‘¦ğ‘.

5. Alice entÃ£o recebe o nÃºmero ğ‘¦ğ‘ enviado por Bob e faz o seguinte cÃ¡lculo para obter o nÃºmero

ğ‘˜:
ğ‘ â‰¡ ğ‘˜ mod ğ‘.
ğ‘¦ğ‘¥ğ‘
Bob tambÃ©m realiza seus cÃ¡lculos para obter ğ‘˜:
ğ‘ â‰¡ ğ‘˜ mod ğ‘.
ğ‘¦ğ‘¥ğ‘

Com isto Alice e Bob chegam ao mesmo nÃºmero ğ‘˜, sem terem compartilhado tal nÃºmero com

mais ninguÃ©m, essa Ã© a chave privada do mÃ©todo Diffie-Hellman.

Vejamos um exemplo numÃ©rico para melhor entendermos o funcionamento deste mÃ©todo Crip-

togrÃ¡fico:

Exemplo 17.

1. Alice e Bob combinam a chave pÃºblica que serÃ¡ utilizada: 5 e 113, sendo que

5 Ã© raiz primitiva de 113.

2. Alice escolhe seu nÃºmero privado: 16.

Bob tambÃ©m escolhe seu nÃºmero privado: 73.

3. Alice mistura seu nÃºmero privado com a chave pÃºblica:

516 â‰¡ 30 mod 113, e encontra assim o nÃºmero 30, Bob tambÃ©m executa esse passo mistu-
rando seu nÃºmero privado com a chave pÃºblica:

573 â‰¡ 76 mod 113, encontrando assim o nÃºmero 76.

31

4. Alice envia para Bob o nÃºmero 30, e Bob envia para Alice o nÃºmero 76.

5. Alice entÃ£o recebe o nÃºmero 76 enviado por Bob e faz o seguinte cÃ¡lculo para obter o nÃºmero

ğ‘˜ :
7616 â‰¡ ğ‘˜ mod 113, sendo 0 â‰¤ ğ‘˜ < 113
7616 â‰¡ 106 mod 113
Encontrando ğ‘˜ = 106.

6. Bob recebe o nÃºmero 30 enviado por Alice e faz o seguinte cÃ¡lculo para obter o nÃºmero ğ‘˜ :

3073 â‰¡ ğ‘˜ mod 113, sendo 0 â‰¤ ğ‘˜ < 113
3073 â‰¡ 106 mod 113
Encontrando ğ‘˜ = 106.

Alice e Bob agora possuem a chave privada 106, que serÃ¡ utilizada por ambos para codificarem

e decoficarem suas mensagens e assim se comunicarem em seguranÃ§a.

O prÃ³ximo passo Ã© entender o porque deste mÃ©todo ser considerado seguro, apesar de toda a
combinaÃ§Ã£o da chave a ser utilizada ter ocorrido via internet, sendo assim passÃ­vel de interceptaÃ§Ã£o.
Vejamos:

â€¢ Ao iniciar Alice e Bob combinaram dois nÃºmeros ğ‘ = 5 e ğ‘ = 113 que formariam a chave
pÃºblica. Esses nÃºmeros foram enviados de um para o outro e portanto poderiam cair nas
mÃ£os de um interceptador que no caso em questÃ£o chamaremos de Eva.

â€¢ ApÃ³s Alice ter â€œmisturado"seu nÃºmero secreto com a chave pÃºblica ela envia o nÃºmero
encontrado ğ‘¦ğ‘ = 30 para Bob. Ao ser enviado esse nÃºmero tambÃ©m pode cair nas mÃ£os de
Eva.

â€¢ Bob tambÃ©m envia o nÃºmero ğ‘¦ğ‘ = 76 encontrado da â€œmistura"da chave pÃºblica com seu

nÃºmero secreto. Esse nÃºmero ao ser enviado tambÃ©m pode ser interceptado por Eva.

Desta forma Eva ao investigar a conversa entre Alice e Bob consegue interceptar os nÃºmeros
ğ‘, ğ‘, ğ‘¦ğ‘ e ğ‘¦ğ‘(5, 113, 30, 76), porÃ©m nenhum deles corresponde a chave secreta ğ‘˜ que serÃ¡ utilizada
por Alice e Bob.

O nÃºmero ğ‘˜ = 106 foi calculado das seguintes forma:
(516)73 â‰¡ (30)73 â‰¡ 106 mod 113
(573)16 â‰¡ (76)16 â‰¡ 106 mod 113
Para que Eva consiga descobrir o valor de ğ‘˜ ela precisa resolver:
5ğ‘¥ğ‘ â‰¡ 30 mod 113 ou
5ğ‘¥ğ‘ â‰¡ 76 mod 113
Neste caso temos que ğ‘¥ğ‘ Ã© chamado de logaritmo discreto de 30 mÃ³dulo 113 na base 5, temos

tambÃ©m que ğ‘¥ğ‘ Ã© o logaritmo discreto de 76 mÃ³dulo 113 na base 5. Podemos denotÃ¡-los por:

ğ‘‘ğ‘™ğ‘œğ‘”5,113(30) = ğ‘¥ğ‘ e ğ‘‘ğ‘™ğ‘œğ‘”5,113(76) = ğ‘¥ğ‘.

32

Os logaritmos discretos sÃ£o os responsÃ¡veis por garantir a seguranÃ§a do mÃ©todo Diffie-Hellman,
isso devido a complexidade em resolver tais congruÃªncias como as descritas acima. Obviamente
existem softwares computacionais capazes de resolver tais congruÃªncias, mas isso Ã© devido a estar-
mos utilizando apenas nÃºmeros pequenos. PorÃ©m, na prÃ¡tica, o Algoritmo Diffie-Hellman utiliza
um nÃºmero primo de centenas de dÃ­gitos, aumentando de tal maneira as possibilidades para tal
logaritmo discreto que os softwares conhecidos para se calcular demorariam anos para conseguir
encontrar uma resposta, tornando assim tal busca por encontrar a chave utilizada um fracasso.

Os softwares computacionais inventados para calcular estes logaritmos discretos operam pelo
mÃ©todo da tentativa e erro. Portanto, quanto maiores forem os nÃºmeros que estÃ£o sendo utilizados,
mais tempo este software demorarÃ¡ para encontrar uma resposta, atÃ© que em determinado ponto
os nÃºmeros utilizados sejam grande o suficiente para que o tempo gasto torne estes softwares
ineficazes e garantindo a seguranÃ§a deste mÃ©todo criptogrÃ¡fico.

ApÃ³s ter comprovado a seguranÃ§a da chave utilizada no mÃ©todo Diffie-Hellman, pode-se dar
inÃ­cio a etapa de codificaÃ§Ã£o. Nesta etapa o mÃ©todo Diffie-Hellman jÃ¡ foi utilizado, na verdade tal
mÃ©todo Ã© util apenas para o acordo da senha que sera utilizada durante a conversa para codificaÃ§Ã£o
e decodificaÃ§Ã£o das mensagens, e se faz necessÃ¡rio utilizar um mÃ©todo de codificaÃ§Ã£o e decodificaÃ§Ã£o
das mensagens.

Para concluÃ­rmos o nosso exemplo da Alice e do Bob, utilizaremos um mÃ©todo simples, onde
mudamos a posiÃ§Ã£o do alfabeto conforme a chave obtida, lembrando que a chave que Alice e Bob
tinham combinado era 106. tabela. Na verdade tem mais opÃ§Ãµes, mas estas sÃ£o as mais simples.

f

c

e

a

b

/
h
d
1 B C D E F G H I
0 A B C D E F G H I
6 G H I

i
l m
k
J K L M N
J K L M
J K L M N O P Q R S

g

j

r

s

o

q

p

n

z
/
1 O P Q R S T U V W X Y Z A
0 N O P Q R S T U V W X Y Z
6 T U V W X Y Z A B C D E F

w x

u

y

v

t

Alice envia para Bob a seguinte mensagem:
â€œQual mesmo o dia do aniversÃ¡rio de sua mÃ£e?â€
Codificando a mensagem utilizando alternadamente os alfabetos permutados de ordem (1, 0 e

6) obtÃ©m-se:

RUGNEYNOUEIGEOGOIBFRYBROPDKTUGNAK
Como Bob possui a chave de codificaÃ§Ã£o e decodificaÃ§Ã£o, ele decodifica, compreende a mensagem

e, entÃ£o, responde Ã  Alice:

â€œSerÃ¡ dia noveâ€
Que Ã© enviada atÃ© a Alice codificada:
TEXBDOBNUWE

33

Alice, por possuir o cÃ³digo, compreende a resposta enviada por Bob. Qualquer outra pessoa

que intercepte a conversa obterÃ¡ a conversa criptografada:

Alice: RUGNEYNOUEIGEOGOIBFRYBROPDKTUGNAK
Bob: TEXBDOBNUWE,
nÃ£o sendo possÃ­vel descobrir qual o significado.
Na prÃ¡tica existem softwares capazes de aplicar o Algoritmo Diffie-Hellman, bem como realizar
toda a parte de codificaÃ§Ã£o e decodificaÃ§Ã£o, ficando por parte do usuÃ¡rio somente escrever o texto
em tal software munido de sua senha privada. Toda a informaÃ§Ã£o enviada de um computador para
o outro acontecerÃ¡ de maneira segura. PorÃ©m, esse mÃ©todo sofre de uma fraqueza se comparado a
criptografia RSA.

Se o computador da Alice ou o do Bob for invadido por um hacker e este por sua vez obtiver
as informaÃ§Ãµes contidas no computador, o mÃ©todo Diffie-Hellman perde sua seguranÃ§a assim, tal
hacker consegue acesso direto Ã  senha de codificaÃ§Ã£o e decodificaÃ§Ã£o, nÃ£o sendo necessÃ¡rio ele
interceptar os dados que estÃ£o sendo enviandos pela internet e descobrir o logaritmo discreto, o
qual comentamos anteriormente. Como a senha de codificaÃ§Ã£o e decodificaÃ§Ã£o Ã© uma sÃ³, se tal
hacker conseguir acesso a um dos computadores utilizados para a comunicaÃ§Ã£o, a seguranÃ§a do
mÃ©todo Diffie-Hellman ficarÃ¡ comprometida.

Dizemos assim, que, para que o mÃ©todo Diffie-Hellman ser realmente eficaz, ele deverÃ¡ ocorrer
em um ambiente em que se possa garantir a seguranÃ§a dos computadores contra vÃ­rus e invasÃµes
de hackers. Tal mal jÃ¡ nÃ£o ocorre na criptografia RSA, pois mesmo que o hacker obtenha todo o
acesso ao computador de quem estÃ¡ codificando, conseguindo acesso Ã  chave de codificaÃ§Ã£o, essa
chave nÃ£o Ã© util para decodificar os dados.

A criptografia RSA possui a vantagem de somente o computador do destinatÃ¡rio precisar se-
guranÃ§a. Por esse motivo, o mÃ©todo criptogrÃ¡fico utilizado nas operaÃ§Ãµes financeiras Ã© o RSA, o
que o torna mais utilizado do que o mÃ©todo Diffie-Hellman, porÃ©m isso nÃ£o significa que o Ãºltimo
nÃ£o tenha suas aplicaÃ§Ãµes, ele pode ser usado em conversas entre duas pessoas, por exemplo, na
troca de e-mails confidenciais entre duas pessoas.

A seguir serÃ¡ apresentado um modelo de sequÃªncia didÃ¡tica, no qual aplicaremos os conceitos

vistos aqui, no cotidiano escolar.

34

CapÃ­tulo 4

SEQUÃŠNCIA DIDÃTICA

SerÃ¡ apresentada a seguir uma sequÃªncia didÃ¡tica idealizada tendo como intuito o ensino dos
conteÃºdos matemÃ¡ticos contidos neste trabalho. Ela serÃ¡ apresentada atravÃ©s de uma abordagem
investigativa em sala de aula, na qual serÃ¡ abordada a dificuldade em se encontrar nÃºmeros primos
e em se fatorar nÃºmeros inteiros. Dificuldades essas que servirÃ£o de suporte para uma aplicaÃ§Ã£o:
a Criptografia de chave pÃºblica. Vale lembrar que esta Ã© uma sequÃªncia didÃ¡tica idealizada e,
desse modo, deverÃ¡ ser adaptada a cada realidade escolar visando suprir sempre Ã s necessidades
da escola em questÃ£o.

A sequÃªncia didÃ¡tica apresenta alguns conteÃºdos matemÃ¡ticos referentes aos aprendidos pelos
alunos durante o Ensino Fundamental e MÃ©dio, sendo que os conteÃºdos restantes podem ser en-
sinados durante o caminhar da atividade, deste modo ela poderÃ¡ ter como pÃºblico-alvo os alunos
que estÃ£o cursando qualquer um dos trÃªs anos do Ensino MÃ©dio. PorÃ©m, visto que ela apresenta
conteÃºdos como: potÃªncias, logarÃ­tmos e anÃ¡lise do resto de divisÃµes com nÃºmeros inteiros, que
sÃ£o assuntos tratados no durante o 1Å¾ ano do Ensino MÃ©dio, seria de bom tom o desenvolvimento
dessa atividade ao final desta etapa de ensino.

Em um primeiro momento, serÃ¡ abordada a dificuldade em se encontrar nÃºmeros primos. Nessa
etapa os alunos apresentarÃ£o conhecimentos jÃ¡ adquiridos sobre nÃºmeros primos e, juntamente
com o professor, irÃ£o estudar os testes de primalidades existentes, se atentando as dificuldades que
esses mÃ©todos apresentam conforme aumenta-se o tamanho dos nÃºmeros a serem analisados. Ã‰
justamente nessa etapa que o professor ficarÃ¡ encarregado de aproximar os alunos do conhecimento
e, para tanto, deverÃ¡ apresentar o conhecimento matemÃ¡tico que se faz necessÃ¡rio na utilizaÃ§Ã£o
desses testes de primalidades.

Feito isso, os alunos utilizarÃ£o tais testes de modo a analisarem atÃ© onde conseguem ser eficientes
e, em seguida, serÃ¡ apresentado atravÃ©s de vÃ­deos uma aplicaÃ§Ã£o que se utiliza da fragilidade dos
testes de primalidade, a Criptografia de chave pÃºblica. Os alunos apÃ³s terem contato com tal
aplicaÃ§Ã£o, aprenderÃ£o a utilizÃ¡-las. O professor formarÃ¡ pequenos grupos de alunos, os quais
trocarÃ£o mensagens codificadas. Ã‰ importante frisar que o professor deve ser sempre o mediador,
ou seja, deve ser aquele que instiga e aproxima o aluno da busca pelo conhecimento.

35

4.1

IntroduÃ§Ã£o

Este plano de aula terÃ¡ como intuito estimular a curiosidade e o interesse dos alunos por meio de
aplicaÃ§Ãµes prÃ¡ticas dos conteÃºdos abordados durante esse trabalho. As atividades aqui preparadas
permitirÃ£o ao aluno analisar e compreender melhor o funcionamento dos mÃ©todos criptogrÃ¡ficos
estudados bem como a importÃ¢ncia que a matemÃ¡tica tem para o funcionamento deles.

Os educandos realizarÃ£o uma investigaÃ§Ã£o na busca de descobrir mÃ©todos eficazes para en-
contrar nÃºmeros primos e fatorar nÃºmeros inteiros, para que possam compreender a dificuldade
existente nesses dois itens quando estamos tratando de nÃºmeros grandes, dificuldade essa, que Ã©
responsÃ¡vel pela seguranÃ§a do mÃ©todo CriptogrÃ¡fico RSA. Em um segundo momento, eles serÃ£o
convidados a utilizarem os mÃ©todos criptogrÃ¡ficos RSA e Diffie-Hellman para que possam se co-
municar em segredo, contextualizando assim, o conteÃºdo aprendido em sala de aula. A abordagem
apresentada neste trabalho tem como objetivo ser uma ponte para que o aluno se aproxime e iden-
tifique a importÃ¢ncia da matemÃ¡tica aprendida na escola em aplicaÃ§Ãµes prÃ¡ticas, promovendo uma
participaÃ§Ã£o mais ativa a com o ensejo de construir um conhecimento matemÃ¡tico com significado.
Essa sequÃªncia didÃ¡tica poderÃ¡ proporcionar o aumento da capacidade de percepÃ§Ã£o do aluno,
uma vez que motivados e convencidos da importÃ¢ncia da matemÃ¡tica em seu dia a dia, poderÃ£o
estudÃ¡-la com novos olhares, ampliando assim o raio de utilizaÃ§Ã£o dos seus conhecimentos matemÃ¡-
ticos, uma vez que estÃ¡ ligada Ã  resoluÃ§Ã£o de problemas da realidade, ajudando-os a compreender
melhor a importÃ¢ncia da matemÃ¡tica em sua vida cotidiana, conforme concepÃ§Ãµes apresentadas
por AraÃºjo (2009). O aluno poderÃ¡ adquirir uma compreensÃ£o mais ampla dos conceitos aqui
discutidos, jÃ¡ que buscaremos focar mais no despertar da criatividade do discente, para que ele
consiga utilizar o pensamento lÃ³gico matemÃ¡tico em um raio maior de situaÃ§Ãµes.

4.2 Objetivos

A abordagem apresentada neste trabalho tem como objetivo ser uma ponte para que o aluno se
aproxime e identifique a importÃ¢ncia da matemÃ¡tica aprendida na escola em aplicaÃ§Ãµes prÃ¡ticas,
promovendo assim uma participaÃ§Ã£o mais ativa e visando construir um conhecimento matemÃ¡tico
com significado.

A escolha de uma aplicaÃ§Ã£o presente nos dias atuais e ligada a tecnologia, tem por objetivo
evidenciar a importÃ¢ncia da matemÃ¡tica na sociedade e, assim, ser um motivador para o estudo
dessa disciplina, promovendo uma maior dedicaÃ§Ã£o, comprometimento e interesse do aluno.

O maior objetivo deste trabalho Ã© dar ao aluno uma compreensÃ£o mais ampla dos conceitos
aqui discutidos, na busca de instigÃ¡-los ao pensamento lÃ³gico, bem como despertar sua criatividade
nas mais diversas situaÃ§Ãµes nas quais se Ã© possÃ­vel aplicar seus conceitos.

4.3 Metodologia e ApresentaÃ§Ã£o de Materiais

Por meio de uma atividade aplicada, serÃ¡ possÃ­vel mostrar aos educandos aplicaÃ§Ãµes da mate-
mÃ¡tica aprendida na escola. Tal atividade tem como intenÃ§Ã£o mostrar como a matemÃ¡tica aliada
com ideias criativas sÃ£o Ãºteis na resoluÃ§Ã£o de problemas que pareciam nÃ£o ter soluÃ§Ã£o.

36

AtravÃ©s de uma problemÃ¡tica inicial o professor instigarÃ¡ o aluno a refletir sobre seu grau
de complexidade, promovendo assim uma maior atenÃ§Ã£o e comprometimento na construÃ§Ã£o do
conhecimento necessÃ¡rio para resolver tal problemÃ¡tica.

A avaliaÃ§Ã£o acontecerÃ¡ durante todo o projeto, com o intuito de observar a autonomia e a
participaÃ§Ã£o de cada educando, para que possam compreender e participar de maneira ativa das
aulas. TambÃ©m deverÃ£o ocorrer observaÃ§Ãµes, mediaÃ§Ãµes e se necessÃ¡rio futuras intervenÃ§Ãµes e
mudanÃ§as no caminhar do projeto, visando se adequar a realidade da sala. A avaliaÃ§Ã£o se darÃ¡
por meio da:

â€¢ ObservaÃ§Ã£o do professor nas interaÃ§Ãµes entre aluno-aluno e professor-aluno;

â€¢ RelatÃ³rio;

â€¢ Aulas expositivas;

â€¢ Irabalho em grupo.

4.4 Roteiro detalhado da proposta

Na atividade em questÃ£o, o sÃ³cio-interacionismo terÃ¡ papel de destaque, pois Ã© interagindo com
seus colegas e professor que o adolescente construirÃ¡ suas conclusÃµes necessÃ¡rias a cada etapa do
projeto. O construtivismo tambÃ©m terÃ¡ sua relevÃ¢ncia no que diz respeito Ã  sequÃªncia de ideias e
pensamentos que resultarÃ£o na soluÃ§Ã£o do problema apresentado.

Percebe-se tambÃ©m neste projeto, que a busca pelo conhecimento serÃ¡ algo contÃ­nuo, construÃ­do

por etapas, e que cada passo dado serÃ¡ de grande importÃ¢ncia para Ã queles que virÃ£o.

1. Levantamento da ProblemÃ¡tica

Numa primeira etapa o professor deverÃ¡ apresentar uma problemÃ¡tica para os alunos, a qual
servirÃ¡ como questÃ£o norteadora de seus estudos alÃ©m de ter a funÃ§Ã£o de motivÃ¡-los durante
os estudos.

Tal problemÃ¡tica serÃ¡ iniciada tendo em vista a dificuldade existente atÃ© hoje em se encon-
trar nÃºmeros primos e tambÃ©m de se fatorar nÃºmeros inteiros e como matemÃ¡ticos famosos
souberam utilizar tal dificuldade para seu benefÃ­cio, utilizando-a em uma aplicaÃ§Ã£o que Ã©
utilizada cada vez com maior frequÃªncia a criptografia RSA e de Diffie-Hellman, que sÃ£o
responsÃ¡veis por proteger comunicaÃ§Ãµes via-internet tornando tal meio de comunicaÃ§Ã£o um
ambiente seguro.

Para isso, o professor farÃ¡ uma abordagem a fim de levantar o conhecimento dos alunos sobre
como encontrar nÃºmeros inteiros e, a partir de tal, atravÃ©s de uma investigaÃ§Ã£o mediada pelo
professor, os alunos deverÃ£o aprimorar tal mÃ©todo de se encontrar nÃºmeros primos, passando
desde o crivo de ErastÃ³tenes atÃ© os mais atuais como o teste de Miller e o de Lucas, para
os quais os alunos precisarÃ£o ter conhecimento sobre alguns conteÃºdos matemÃ¡ticos como
congruÃªncias e alguns teoremas, que precisarÃ£o ser trabalhados durante essa investigaÃ§Ã£o.

37

ApÃ³s a familiarizaÃ§Ã£o com os testes de primalidades mais atuais, serÃ¡ apresentada sua prin-
cipal aplicaÃ§Ã£o utilizada nos dias atuais, a Criptografia de chave pÃºblica. Para isso, pode ser
utilizado vÃ­deos como os listados nas referÃªncias, os quais exemplificam o funcionamentode
tais mÃ©todos criptogrÃ¡ficos, evidenciando a matemÃ¡tica utilizada. Ã‰ importante ressaltar
que o professor deve agir como mediador escolhendo momentos que julgar mais importan-
tes, fazendo comentÃ¡rios que auxiliem os alunos a se aproximarem mais do tema e, assim,
ajudando a fixar a ideia que estÃ¡ sendo utilizada.

ApÃ³s a exibiÃ§Ã£o dos vÃ­deos e explicaÃ§Ã£o teÃ³rica sobre o assunto, deve se abrir um espaÃ§o
para um debate, no qual atravÃ©s de perguntas o professor tenta aproximar os alunos cada
vez mais do conhecimento matemÃ¡tico necessÃ¡rio, deixando claro assim quais os conteÃºdos
que serÃ£o aprendidos e os quais sÃ£o necessÃ¡rio para utilizar tais tÃ©cnicas CriptogrÃ¡ficas, o
que alÃ©m de incentivÃ¡-los, deixarÃ¡ claro o objetivo a ser alcanÃ§ado.

2. Pressupostos TeÃ³ricos

Para a segunda etapa o professor deverÃ¡ recordar conteÃºdos jÃ¡ estudados em anos anteriores
pelos alunos sobre os nÃºmeros inteiros como a definiÃ§Ã£o de nÃºmeros primos, o algoritmo da
divisÃ£o, o algoritmo fatoraÃ§Ã£o e o crivo de ErastÃ³stenes. Nesta etapa, pode se lanÃ§ar como
desafio para os alunos alguns nÃºmeros Ã­mpares grandes de atÃ© 10 algarismos para que eles
tentem fatorar tais nÃºmeros, e caso nÃ£o consigam, peÃ§a que jÃ¡ que nÃ£o se Ã© possÃ­vel fatorÃ¡-los
para que provem que tais nÃºmeros sÃ£o primos.

Exemplos de nÃºmeros a serem aplicados:

4051 âˆ’ 6967 âˆ’ 3739 âˆ’ 12547 âˆ’ 654369 âˆ’ 1256347 âˆ’ 25365351 âˆ’ 231258657
ApÃ³s terem vivenciado a dificuldade em se determinar se um nÃºmero Ã© primo ou nÃ£o, o
professor pode argumentar sobre a existÃªncia de testes de primalidade que surgiram ao longo
da histÃ³ria matemÃ¡tica, bem como o avanÃ§o de sua eficiÃªncia em detectar se um nÃºmero
Ã© primo. ApÃ³s essa etapa, o professor pode introduzir o conceito de divisibilidade e de
congruÃªncias, assim como os Teoremas de Fermat e Euler que servirÃ£o de ferramentas para
os testes de primalidade que aprenderÃ£o a seguir.

3. Testes de Primalidade

Nesta etapa serÃ£o apresentados alguns testes de primalidade que surgiram ao longo da histÃ³ria
da matemÃ¡tica:

â€¢ DivisÃ£o por tentativa

â€¢ Crivo de EratÃ³stenes

â€¢ Teste de primalidade de Leibniz

â€¢ Teste de primalidade de Miller

â€¢ Teste de primalidade de Lucas

38

O professor poderÃ¡ abordar as vantagens e desvantagens da utilizaÃ§Ã£o de cada um dos tes-
tes de primalidade, bem como comparÃ¡-los, evidenciando assim a evoluÃ§Ã£o do pensamento
humano durante a construÃ§Ã£o do conhecimento.

AlÃ©m do conhecimento sobre os testes de primalidade essa etapa tem por objetivo mostrar a
dificuldade em se fatorar um nÃºmero e, atÃ© mesmo, de detectar se tal nÃºmero Ã© primo.

Ã‰ de suma importÃ¢ncia que o aluno compreenda tal dificuldade, pois ela serÃ¡ utilizada nos
mÃ©todos criptogrÃ¡ficos da prÃ³xima etapa.

4. Criptografia

Nesta etapa os alunos se dividirÃ£o em grupos com quantidade prÃ©-estabelecido pelo professor,
e terÃ£o que se comunicar com um outro grupo em segredo, para isso utilizarÃ£o os mÃ©todos
criptogrÃ¡ficos apresentados neste trabalho.

Em um primeiro momento serÃ¡ utilizada a criptografia Diffie-Hellman. Para isso, cada grupo
de aluno deverÃ¡ se comunicar com um outro grupo, aos pares, o professor serÃ¡ responsÃ¡vel
por analisar e ver se o mÃ©todo esta sendo empregado corretamente. Ã‰ importante aqui, que
o professor auxilie os alunos na escolha da chave pÃºblica, definindo o tamanho dos nÃºmeros
a serem utilizados, o que depende diretamente dos instrumentos que serÃ£o utilizados para
realizar os cÃ¡lculos (calculadora cientÃ­fica, calculadora do computador, softwares matemÃ¡ti-
cos).

ApÃ³s os alunos terem trocado mensagens utilizando a criptografia Diffie-Hellman, serÃ¡ a vez
de utilizarem a criptografia RSA. Para isso, o professor serÃ¡ o destinatÃ¡rio das mensagens.
Portanto, o professor escolherÃ¡ a chave privada e criarÃ¡ a chave pÃºblica do mÃ©todo RSA,
repassando somente a chave pÃºblica para os outros grupos e ficando de posse da chave
privada, a qual utilizarÃ¡ para decodificar as mensagens enviadas a ele pelos grupos.

4.5 ConsideraÃ§Ãµes finais sobre a aplicaÃ§Ã£o

Os alunos poderÃ£o realizar uma redaÃ§Ã£o sobre as aulas apresentadas a fim de identificarem o
conhecimento adquirido e expressarem suas opiniÃµes sobre o modelo de atividade realizada. SerÃ¡
importante buscar destacar o quanto a criatividade acompanha o desenvolvimento da MatemÃ¡tica.
Espera-se que o aluno aumente sua capacidade de interligar os conteÃºdos vistos em sala de aula a
outras aplicaÃ§Ãµes, conseguindo identificar situaÃ§Ãµes onde possa utilizar tais conhecimentos.

AraÃºjo(2009) nos diz que o aprendizado Ã© algo que precisa ser interiorizado, ou seja, precisa
estar numa zona proximal de conhecimento, para que assim seja possÃ­vel unir o conhecimento que
estÃ¡ descobrindo com os que jÃ¡ possui, fazendo sentido tal aprendizado. Desta forma, sempre que
descobrimos algo ele se tornarÃ¡ alicerce para novas descobertas, e que o aprender faz parte do ser
humano.

O uso do vÃ­deo e das histÃ³rias deverÃ¡ ajudar o aluno a entrar no mundo imaginÃ¡rio, a fim de
vivenciar a problemÃ¡tica vivida ao longo do tempo, reviver etapas da construÃ§Ã£o do conhecimento
e perceber como o raciocÃ­nio pode ser utilizado para resolver situaÃ§Ãµes complicadas. Com isso,

39

construir um conhecimento mais amplo, no intuito de conseguir utilizÃ¡-lo nÃ£o sÃ³ em situaÃ§Ãµes
â€œprogramadasâ€, mas sim, em situaÃ§Ãµes reais com naturalidade e dinamismo.

40

ConclusÃ£o

Durante este trabalho foi possÃ­vel estudar propriedades fundamentais sobre NÃºmeros Inteiros,
atravÃ©s de uma aplicaÃ§Ã£o muito utilizada no dia a dia a Criptografia de chave pÃºblica, a qual
sÃ³ se tornou possÃ­vel atravÃ©s de ideias criativas que utilizam tecnologia aliada a conhecimentos
matemÃ¡ticos.Tivemos como norte o estudo dos nÃºmeros primos e da Criptografia a medida que
avanÃ§avamos por entre conteÃºdos matemÃ¡ticos que tal aplicaÃ§Ã£o se utiliza.

Foi possÃ­vel observar ainda, de maneira lÃ³gica, o avanÃ§o da eficiÃªncia dos mÃ©todos utilizados
para detectar nÃºmeros primos, conseguindo distinguir com eficiencia um nÃºmeros primos com
tamanho considerÃ¡vel. O trabalho apresentou a evoluÃ§Ã£o de alguns testes de primalidades, evi-
denciando as ideias e o processo de construÃ§Ã£o de cada um, atÃ© alcanÃ§ar os testes de primalidades
atuais: o teste de primalidade de Lucas Lehmer o qual consegue detectar com exatidÃ£o nÃºme-
ros primos atÃ© um certo tamanho, e o Teste de Miller cujo qual devida sua tamanha eficiÃªncia Ã©
utilizado por softwares computacionais nos dias atuais.

PorÃ©m, constatou-se que apesar de tal melhora nos testes de primalidades, ainda nÃ£o existe
um mÃ©todo que consiga detectar se um nÃºmero qualquer Ã© primo, pois os testes de primalidade
apresentados funcionam atÃ© certo ponto, sendo que se o nÃºmero a ser testado for muito grande,
tal teste perde sua eficiÃªncia devido a capacidade limitada do computador, o qual pode levar anos
para terminar tal teste, tornando assim o mesmo inviÃ¡vel.

Com o passar dos tempos, vimos que o problema matemÃ¡tico de se detectar a primalidade
de um nÃºmero, e atÃ© mesmo de se encontrar fatores primos de nÃºmeros inteiros teve um grande
avanÃ§o, porÃ©m, quando se trata de nÃºmeros muito grande, esse problema ainda continua sem
soluÃ§Ã£o. Vimos tambÃ©m, que o fato desse problema continuar sem soluÃ§Ã£o, passou a ser a chave
para resolver um outro problema: o problema da troca de chaves, pois tal dificuldade em se detectar
nÃºmeros primos e fatorar nÃºmeros Inteiros, se torna entÃ£o soluÃ§Ã£o para a troca de informaÃ§Ãµes
de maneira segura via internet, atravÃ©s da criptografia de chave publica (RSA e Diffie-Hellman),
aplicaÃ§Ã£o essa que se tornou essencial para o desenvolvimento de nossa sociedade. Desta maneira,
pode-se perceber que se usada de maneira criativa, a matemÃ¡tica torna-se suporte para novas
aplicaÃ§Ãµes.

A Escrita em CÃ³digos (Criptografia) desperta a curiosidade humana em explorar o desco-
nhecido, motivando assim a busca pelo saber . A Criptografia presente neste trabalho faz uso
de conhecimentos matemÃ¡ticos importantes, assim sendo foi possÃ­vel durante a abordagem aqui
apresentada, estudar desde conceitos bÃ¡sicos como nÃºmeros primos, divisibilidade e fatoraÃ§Ã£o atÃ©
conceitos mais avanÃ§ados como o estudo de grupos, congruÃªncias e testes de primalidades para
nÃºmeros grandes. A utilizaÃ§Ã£o desta aplicaÃ§Ã£o a qual esta presente atualmente no meio digital
teve por objetivo apresentar a importÃ¢ncia da matemÃ¡tica no meio em que vivemos, analisando
e compreendendo seu mÃ©todo de funcionamento, o que consequentemente promoveu um interesse

41

maior pela matemÃ¡tica, incentivando e despertando para um aprendizado mais significativo.

No Ãºltimo capitulo foi apresentada uma sequÃªncia didÃ¡tica, visando a aplicaÃ§Ã£o em sala de aula
dos conteÃºdos, conceitos e aplicaÃ§Ãµes estudados ao longo dessa dissertaÃ§Ã£o para alunos do ensino
mÃ©dio, a fim de ilustrar uma proposta que busca despertar o raciocÃ­nio lÃ³gico dos alunos atravÃ©s
de uma abordagem investigativa cuja qual instiga o aluno na busca pelo conhecimento.

Ao longo de todo este trabalho foi possÃ­vel notar tambÃ©m, a evoluÃ§Ã£o da matemÃ¡tica atravÃ©s dos
tempos, ao estudarmos os testes de primalidade pode-se notar como o conhecimento matemÃ¡tico
existente se torna alicerce para que um novo passo possa surgir, atravÃ©s da evoluÃ§Ã£o de ideias
e da maneira de pensar. Essa evoluÃ§Ã£o do pensamento humano permite o surgimento de novas
aplicaÃ§Ãµes como a criptografia de chave pÃºblica, a qual se tornou indispensÃ¡vel no mundo financeiro
atual.

42

ReferÃªncias BibliogrÃ¡ficas

[1] Khan

Academy.

DocumentÃ¡rio:

Criptografia

diffie-hellman.

http://www.youtube.com/watch?v=YEBfamv-_do (acesso em 24/02/2014).

[2] Khan Academy. DocumentÃ¡rio: Criptografia rsa. https://www.youtube.com/watch?v=wXB-

V_Keiu8 (acesso em 24/02/2014).

[3] Site do software matemÃ¡tico maxima.

http://MAXIMA.sourceforge.net

(acesso em

13/03/2014).

[4] SPM. DocumentÃ¡rio: NÃºmeros primos. http://www.youtube.com/watch?v=FCMyFgUK5jM

(acesso em 24/02/2014).

[5] SPM. DocumentÃ¡rio: A chave das chaves. http://www.youtube.com/watch?v=Vm1Y6Kr9DCw

(acesso em 24/02/2014).

[6] HEFEZ A. Elementos de aritmÃ©tica. ColeÃ§Ã£o Textos UniversitÃ¡rios, SBM, 2011.

[7] SANTOS B.

IntroduÃ§Ã£o ao software maxima. Centro de MatemÃ¡tica da Universidade do

Porto, CMUP, 2009.

[8] COUTINHO S. C. NÃºmeros inteiros e criptografia rsa. ColeÃ§Ã£o MatemÃ¡tica e AplicaÃ§Ãµes,

IMPA, 2013.

[9] ARAÃšJO J. L. Uma abordagem sÃ³cio-crÃ­tica da modelagem matemÃ¡tica: a perspectiva da
educaÃ§Ã£o matemÃ¡tica crÃ­tica. ALEXANDRIA Revista de EducaÃ§Ã£o em CiÃªncia e Tecnologia,
2(2):55â€“68, Julho 2009.

[10] PIRES R. M. AplicaÃ§Ã£o do algoritmo diffie-hellman no compartilhamento de volumes crip-
tografados do truecrypt. Departamento de CiÃªncia da ComputaÃ§Ã£o, Universidade Federal de
GoiÃ¡s, 2010.

43

