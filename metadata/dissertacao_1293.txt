COLÉGIO PEDRO II

Pró-Reitoria de Pós-Graduação, Pesquisa, Extensão e Cultura
Mestrado Proﬁssional em Matemática em Rede Nacional

Cid de Araújo Moraes

UMA INTRODUÇÃO À COMPUTAÇÃO ALGÉBRICA:

Resolvendo algebricamente um Shidoku

Rio de Janeiro

2019

Cid de Araújo Moraes

UMA INTRODUÇÃO À COMPUTAÇÃO ALGÉBRICA:

Resolvendo algebricamente um Shidoku

de Mestrado Proﬁssional

Dissertação de Mestrado apresentada ao
em
Programa
Matemática em Rede Nacional, vinculado
à Pró-Reitoria de Pós-Graduação, Pesquisa,
Extensão e Cultura do Colégio Pedro II, como
requisito parcial para obtenção do título de
Mestre em Matemática.

Orientadora: Dra. Patrícia Erthal de Moraes

Rio de Janeiro

2019

COLÉGIO PEDRO II 

PRÓ-REITORIA DE PÓS-GRADUAÇÃO, PESQUISA, EXTENSÃO E CULTURA 

BIBLIOTECA PROFESSORA SILVIA BECHER 

CATALOGAÇÃO NA FONTE 

M827    Moraes, Cid de Araújo  

      Uma introdução à computação algébrica: resolvendo algebricamente 
um shidoku / Cid de Araújo Moraes. – Rio de Janeiro, 2019. 

                     96 f. 

         Dissertação (Mestrado Profissional em Matemática em Rede 

Nacional) – Colégio Pedro II. Pró-Reitoria de Pós-Graduação, Pesquisa,   
Extensão e Cultura. 
      Orientador: Patrícia Erthal de Moraes. 

                     1. Matemática – Estudo e ensino. 2. Álgebra computacional. 3. 

Bases de Grobner. 4. Algoritmo de Buchberger. 5. Shidoku. I. Moraes, 
Patrícia Erthal de. II. Título.                                                                                                                       

                                                                                                       CDD 510 

Ficha catalográfica elaborada pela Bibliotecária Simone Alves – CRB7 5692. 

 
 
 
 
                                
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
                                                                                                                 
                                                                                                                
Cid de Araújo Moraes

UMA INTRODUÇÃO À COMPUTAÇÃO ALGÉBRICA:
Resolvendo algebricamente um Shidoku

de Mestrado Proﬁssional

Dissertação de Mestrado apresentada ao
em
Programa
Matemática em Rede Nacional, vinculado
à Pró-Reitoria de Pós-Graduação, Pesquisa,
Extensão e Cultura do Colégio Pedro II, como
requisito parcial para obtenção do título de
Mestre em Matemática.

Aprovado em: ___/___/___.

Banca Examinadora:

Dra. Patrícia Erthal de Moraes
Colégio Pedro II

Dra. Liliana Manuela Gaspar Cerveira da Costa
Colégio Pedro II

Dr. Helder Manoel Venceslau
CEFET-RJ

Rio de Janeiro

2019

Dedico este trabalho à minha mãe, Geralda, e ao
meu irmão, Osvaldo. Pessoas que não mediram
esforços para me ajudar a chegar aqui.

AGRADECIMENTOS

À minha orientadora, Professora Dra. Patrícia Erthal de Moraes, por toda paciência, dedicação e
conhecimentos transmitidos.
À todos professores do PROFMAT-CPII, que com muita dedicação, nos guiaram por esses dois
anos.
À equipe da Pós Graduação do Colégio Pedro II, por todo suporte durante o mestrado.
À minha namorada, Ana Cristina Beltrán, por todo apoio e motivação.
Ao amigo Professor Diogo Comba Canavezes, pela revisão na parte Histórica.
Ao amigo Professor Me. Jansley Alves Chaves, pela constante motivação, cobrança e as agradá-
veis corridas.
Aos novos colegas de trabalho do CPII, unidade São Cristovão II, que também muito me apoia-
ram.
Ao amigo e mentor Professor Gil Max Ferreira, que despertou o meu interesse pela Matemática,
e me mostrou o quanto é recompensador ensinar.

“A Matemática não conhece raças ou fronteiras geográﬁcas; para a matemática, o mundo
cultural é um país. ”.
(David Hilbert)

RESUMO

MORAES, Cid de Araújo. Uma Introdução à Computação Algébrica: Resolvendo algebrica-
mente um Shidoku. 2019 96f. Dissertação (Mestrado) – Colégio Pedro II, Pró-Reitoria de Pós-
Graduação, Pesquisa, Extensão e Cultura, Programa de Mestrado Proﬁssional em Matemática
em Rede Nacional, Rio de Janeiro, 2019.

Nesse trabalho apresentamos como as Bases de Gröbner juntamente com o sistema de com-
putação algébrica CoCoA podem ser usados para resolver algebricamente um quebra-cabeça
Shidoku (uma versão reduzida do conhecido Sudoku). Apresentamos os pré-requisitos necessá-
rios da Álgebra como o Algoritmo da Pseudodivisão até a Teoria das Bases de Gröbner com
os S-polinômios e o Algoritmo de Buchberger. Fazemos uma breve introdução ao CoCoA e
por ﬁm apresentamos uma implementação da resolução algébrica do Shidoku neste software. A
dissertação tem o objetivo de ser uma base para um projeto de iniciação cientíﬁca com estudantes
do Ensino Médio e também como fonte de aprofundamento para professores e graduandos de
Matemática.

Palavras-chave: Bases de Gröbner; Álgebra Computacional; Shidoku; Pseudodivisão; CoCoA;
Algoritmo de Buchberger.

ABSTRACT

MORAES, Cid de Araújo. Uma Introdução à Computação Algébrica: Resolvendo algebrica-
mente um Shidoku. 2019 96f. Dissertação (Mestrado) – Colégio Pedro II, Pró-Reitoria de Pós-
Graduação, Pesquisa, Extensão e Cultura, Programa de Mestrado Proﬁssional em Matemática
em Rede Nacional, Rio de Janeiro, 2019.

In this work, we present how Gröbner Bases coupled with CoCoA computer algebra system can
be used to algebraically solve the Shidoku puzzle (a small variant of the well-known Sudoku).
We show Algebra requirements covering the Pseudo-Divison Algorithm to the Gröbner Bases
theory including S-polynomials and Buchberger’s Algorithm. We also make a brief introduction
to the CoCoA system and propose an algebraic implementation for solving a Shidoku in this
software. The dissertation aims to be a scientiﬁc project for high school students and also stand
as a study source for mathematics teachers and undergraduates.

Keywords: Gröbner Bases; Computational Algebra; Shidoku; Pseudo-Division; CoCoA; Buch-
berger’s Algorithm.

LISTA DE ILUSTRAÇÕES

Figura 1 – W. Gröbner ∗1899 −†1980 . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 2 – Tirol Italiano (roxo e bege) e Tirol Austríaco (vermelho) . . . . . . . . . . .
Figura 3 – Tirol do Sul: Cidade de Gröbner
. . . . . . . . . . . . . . . . . . . . . . .
Figura 4 – Bruno Buchberger ∗1942 . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .
Figura 5 – Monômios de um Ideal Monomial
Figura 6 – Página principal do CoCoA . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 7 – Tela principal do CoCoA . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 8 – Um Sudoku .
Figura 9 – Um Shidoku .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 10 – Modelando um Shidoku . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 11 – O Shidoku proposto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 12 – Shidoku Resolvido . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

13
13
14
15
55
66
67
74
74
75
76
84

SUMÁRIO

INTRODUÇÃO .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11

.

.

.

HISTÓRIA .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
O início com Wolfgang Gröbner . . . . . . . . . . . . . . . . . . . . . . .
Buchberger: O criador do Algoritmo das Bases de Gröbner . . . . . . .

.

.

.

.

.

.
.

.
.

PRELIMINARES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Anéis e Corpos
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ideais
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Polinômios em K[x] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
O Algoritmo da Divisão . . . . . . . . . . . . . . . . . . . . . . . . . . .
O Máximo Divisor Comum de Polinômios . . . . . . . . . . . . . . . . .
O problema da pertinência à um Ideal
. . . . . . . . . . . . . . . . . . .
Polinômios em K[x1, . . . , xn] . . . . . . . . . . . . . . . . . . . . . . . . .
Ordem Monomial em K[x1, . . . , xn] . . . . . . . . . . . . . . . . . . . . .
O Algoritmo da Divisão em K[x1, . . . , xn] . . . . . . . . . . . . . . . . . .
O Algoritmo da Pseudodivisão em K[x1, . . . , xn] . . . . . . . . . . . . . .

SISTEMAS POLINOMIAIS . . . . . . . . . . . . . . . . . . . . . . . . .
Sistemas Polinomiais em Várias Indeterminadas

. . . . . . . . . . . . .

BASES DE GRÖBNER . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ideais Monomiais .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Teoria de Gröbner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Critério e Algoritmo de Buchberger
. . . . . . . . . . . . . . . . . . . .

O SOFTWARE COCOA . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instalação no Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Interface e Alguns Comandos . . . . . . . . . . . . . . . . . . . . . . . .
Polinômios no CoCoA . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

.

APLICAÇÃO DAS BASES DE GRÖBNER NA RESOLUÇÃO DE UM
SHIDOKU .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
O que é um Sudoku? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
O que é um Shidoku? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Representando um Shidoku usando polinômios . . . . . . . . . . . . . .
Programando para resolver um Shidoku . . . . . . . . . . . . . . . . . .

13
13
15

17
17
21
23
27
31
33
34
35
40
44

51
51

54
54
56
59

66
66
67
69

73
73
73
74
76

1

2
2.1
2.2

3
3.1
3.2
3.3
3.4
3.5
3.6
3.7
3.8
3.9
3.10

4
4.1

5
5.1
5.2
5.3

6
6.1
6.2
6.3

7

7.1
7.2
7.3
7.4

8

CONCLUSÃO .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

85

REFERÊNCIAS .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

86

APÊNDICES

A.1
A.2
A.3

APÊNDICE A – ALGUMAS DEMONSTRAÇÕES . . . . . . . . . . .
K[x] é um domínio de integridade . . . . . . . . . . . . . . . . . . . . . .
O domínio de integridade (D[x])[y]
. . . . . . . . . . . . . . . . . . . . .
Demonstrações do capítulo 5 . . . . . . . . . . . . . . . . . . . . . . . . .

87

88
88
90
91

1 INTRODUÇÃO

11

Nesta dissertação apresentamos a teoria das Bases de Gröbner com o objetivo de resolver
sistemas de equações polinomiais. Essas Bases generalizam o processo de eliminação Gaussiana
para polinômios de várias indeterminadas.

Nos últimos 50 anos, com o desenvolvimento da computação, as Bases de Gröbner
tiveram aplicações em diferentes áreas, tais como resolução de Sudokus, Coloração de Grafos,
desenvolvimento da Criptograﬁa, Prova Automática de Teoremas, e muitas outras. A escolha
pelo estudo deste Tema se deu pelo amplo espectro de aplicações interessantes dessa Teoria
possibilitando um aprofundamento de conceitos matemáticos relevantes, além de associar o uso
de computadores para resolução de problemas.

Devido à sua especiﬁcidade, esse Trabalho é indicado para uma oﬁcina de Iniciação
Cientíﬁca com alunos do Ensino Médio interessados em um aprofundamento de Matemática,
bem como para docentes que desejam um maior estudo no campo da Computação Algébrica.

Pensando nessa oﬁcina, optamos por fazer neste Trabalho uma abordagem das Bases de
Gröbner visando a resolução de um Shidoku, que é uma versão simpliﬁcada do Sudoku. Esses
quebra-cabeças se tornaram muito populares nos jornais da Inglaterra em 2004 e desde então
aparecem em várias revistas e jornais do mundo. A principal motivação para esse estudo é a
oportunidade de apresentar aos alunos o quanto de Matemática Aplicada se “esconde” por trás
da modelagem matemática de um simples quebra-cabeça.

A nova BNCC (Base Nacional Comum Curricular) destaca, na competência 5 - Cultura
Digital, a importância do uso de linguagens de programação para solucionar Problemas e também,
o domínio do uso de Algoritmos. Seguindo essa diretriz, destacamos outra relevância para essa
Iniciação Cientíﬁca que é o papel fundamental do uso da computação na resolução de um Shidoku
por uma modelagem matemática, uma vez que, para a determinação de Bases de Gröbner, devido
à complexidade dos cálculos, é indicado o uso de sistemas de computação algébrica. Desta
forma, os alunos podem, mediante a modelagem de situações problema, ser apresentados ao
uso de Algoritmos e linguagens de Programação Básica. Neste trabalho utilizamos o sistema de
computação algébrica CoCoA, embora existam outras opções como: SINGULAR, Macaulay 2,
SageMath, Derive, entre outros

No capítulo 2, é feita uma breve introdução histórica sobre os dois principais matemáticos
que contribuíram para o desenvolvimento da Teoria das Bases de Gröbner: Wolfgang Gröbner e
seu aluno, Bruno Buchberger.

Já no capítulo 3, exploraremos os conceitos de Álgebra Abstrata que vamos usar no
trabalho. Destacaremos a transição do Anel K[x] para o Anel K[x1, . . . , xn], salientando as
diﬁculdades que ocorrem ao tentar estender o Algoritmo da Divisão para várias indeterminadas.

12

O capítulo 4 trata da importância das Bases de Gröbner para a resolução de sistemas
polinomiais em várias indeterminadas. É ressaltado que o processo de escalonamento de sistemas
é um caso particular do cálculo de Bases de Gröbner.

No capítulo 5, apresentamos todos os resultados e algoritmos relacionados com o cálculo
das Bases de Gröbner. Com isso, ﬁca clara a necessidade do uso de um sistema de computação
algébrica.

Já no capítulo 6, introduzimos o software CoCoA que é especiﬁcamente usado para
cálculos em álgebra comutativa. Esse ambiente computacional tem um papel relevante para a
determinação das Bases de Gröbner.

O capítulo ﬁnal, 7, de certa forma, é a culminância dessa Dissertação. Nele, mediante
uma modelagem matemática, resolvemos um Shidoku por meio do cálculo das bases de Gröbner,
programando no CoCoA.

Finalmente no Capítulo 8 apresentamos as considerações ﬁnais e os possíveis desdobra-
mentos desse Trabalho. A leitura desse trabalho pode ser feita de forma independente ao longo
dos capítulos, de acordo com o interesse do leitor. Para isso, tivemos o cuidado de detalhar cada
etapa da aquisição desse conhecimento de forma que seja possível uma adequação para cada
objetivo, seja ele voltado para alunos, no caso da Iniciação Cientíﬁca, ou para docentes, uma vez
que o trabalho fornece uma ideia inicial do tema Álgebra Computacional e abre caminho para
uma vasta área de pesquisa.

2 HISTÓRIA

13

Gröbner e Buchberger são os principais responsáveis pelo desenvolvimento da teoria das
Bases Gröbner. Baseados nas referências Hong et al. (2006) e Reitberger (2001), apresentaremos
neste capítulo, um pouco da história destes importantes matemáticos.

2.1 O início com Wolfgang Gröbner

Wolfgang Gröbner, Figura 1, nasceu em 11 de fevereiro de 1899 num território italiano,
o Tirol do Sul. A sua cidade natal, Colle Isarco, ﬁca a 10 km da fronteira com a Áustria e
na época era predominantemente germanófona. Por tanto, Colle Isarco é também chamado de
“Gossenssas” em alemão. No mapa da Figura 2, está próxima de Sterzing. Esse território hoje
é Italiano, mas de 1867 à 1918 pertenceu ao Império Austro-Húngaro e também foi dominado
pela Alemanha nazista durante a segunda guerra mundial.

Figura 1 – W. Gröbner ∗1899 −†1980

Figura 2 – Tirol Italiano (roxo e bege) e Tirol

Austríaco (vermelho)

COMMONS,

Fonte:
<https://commons.wikimedia.org/
w/index.php?title=File:Wolfgang_
Grobner.jpg&oldid=311940406>

2018.

Fonte: COMMONS, 2017. <https://commons.
wikimedia.org/w/index.php?title=File:
Tirol-Suedtirol-Trentino.png&oldid=
264555553>

Gröbner cresceu com quatro irmãos e passou por um internato jesuíta, o que inﬂuenciou
muito a sua visão do mundo. Pode ser considerado por muitos, até mesmo, paradoxal, um
cientista ter uma formação também religiosa tão intensa, mas que era algo comum na época. Teve
uma breve participação na Primeira Guerra com a frente italiana e logo depois cursou engenharia
na Universidade de Tecnologia de Graz na Áustria.

14

Sua primeira obra foi um livro de cunho religioso “Der Weg aufwärts.” (“O caminho até
o céu”), fruto de uma ruptura pessoal com a igreja Católica após a trágica morte do seu irmão
num acidente de moto. Depois de se casar, migrou seus estudos para a matemática pois “passou
a rejeitar qualquer autoridade fora da sua própria mente”.

Esteve de 1929 a 1932 na universidade de Viena, onde defendeu sua tese de doutorado.
Em seguida, por recomendação do seu orientador Philipp Furtwängler, teve aulas com Emmy
Noether em Göttingen na Alemanha. Por problemas ﬁnanceiros voltou para Áustria em 1933 e
não conseguindo emprego numa faculdade, acabou por construir centrais elétricas em Gossenssas.
Por um acaso, conheceu um professor de Matemática Italiano, de nome Picone, o qual lhe
ofereceu emprego na universidade de Roma.

No ﬁnal da de década de 30, Gröbner teve que escolher entre a cidadania Alemã (Na
época Alemanha nazista de Hitler) e a Italiana (Reino da Itália Fascista). Decidindo pela Alemã,
teve que sair da Itália. Trabalhou uma temporada para a academia Prussiana de Ciências antes
de receber o título de “Extraordinário” na universidade de Viena em 1941. Em seguida, teve
que prestar serviço militar de onde se dedicou a constituir um instituto de força aérea para
aplicação de métodos matemáticos avançados a problemas aeronáuticos. O instituto estava em
Braunschweig e seu diretor se chamava Gustav Doetsch, um matemático de Freiburg.

Em 1938, no trabalho intitulado: “Ueber eine neue idealtheoretische Grundlegung der
algebraischen Geometrie” [ “Sobre uma nova fundação ideal teórica de Geometria Algébrica”],
caracterizou ideais primários por condições diferencias. Basicamente, tratou da relação entre a
multiplicidade da raiz de um polinômio e a sua derivada.

Em 1945, Gröbner se refugiou no Tirol (Figura 3), onde vivia sua família. Depois do ﬁm
da guerra, não voltou imediatamente para Viena, somente em 1947, foi trabalhar na universidade
de Innsbruck.

Figura 3 – Tirol do Sul: Cidade de Gröbner

Fonte:
Gossensass_01.JPG&oldid=323108703>

COMMONS,

2018.

<https://commons.wikimedia.org/w/index.php?title=File:

15

Seus alunos de doutorado mais famosos são: Heinrich Reitberger, Bruno Buchberger e
G. Sonderegger. Especiﬁcamente no verão de 1964, Gröbner deu um seminário sobre a teoria da
dimensão de ideais de polinômios. Bruno Buchberger indagou Gröbner sobre a possibilidade de
desenvolver a sua tese nos problemas abertos apresentados. Recebendo o sim, o resultado do
trabalho de Buchberger foi publicado em 1965 na sua tese de doutorado “Ein Algorithmus zum
Aufﬁnden der Basis Elemente des Restklassenrings nach einem nulldimensionalen Polynomideal”
[Um algoritmo para determinar os elementos da base de um anel de classes de resíduos de
um ideal polinomial de dimensão zero]. Bruno nomeou essas bases como bases de Gröbner em
homenagem ao seu orientador.

Gröbner trabalhou até 1970 em Innsbruck, e morreu em 1980 no Tirol, depois de sofrer

um derrame.

2.2 Buchberger: O criador do Algoritmo das Bases de Gröbner

Bruno Buchberger, Figura 4, nasceu no ano de 1942, em Innsbruck, a capital do Tirol
Austríaco. Nessa época, a Áustria estava sob domínio da Alemanha nazista. Sabe-se que teve
ótimo desempenho acadêmico nos estudos secundários e portanto podia escolher qualquer
caminho proﬁssional.

Buchberger escolheu o curso de matemática da Universidade de Innsbruck, onde defendeu
em 1965, a sua tese de doutorado intitulada “Ein Algorithmus zum Aufﬁnden der Basiselemente
des Restklassenringes nach einem nulldimensionalen Polynomideal” [“Um algoritmo para
determinar os elementos da base de um anel de classes de resíduos de um ideal polinomial
de dimensão zero”] sob a orientação de Wolfgang Gröbner. A teoria apresentada nessa tese

Figura 4 – Bruno Buchberger ∗1942

Fonte: COMMONS, 2018. <https://commons.wikimedia.org/w/index.php?title=File:Bruno_
Buchberger.jpg&oldid=311937690>

16

ﬁcou adormecida por aproximadamente 10 anos, quando Bruno, por recomendação de Ruediger
Loos, publicou um artigo com a sua teoria no SIGSAM (Special Interest Group in Symbolic
and Algebraic Manipulation). A partir daí, a teoria das bases de Gröbner se impulsionou e teve
muito sucesso em variados ramos da matemática. Até agora, sobre esta teoria foram publicados
10 livros e mais de 600 artigos. Em particular, nos últimos 10 anos, essa teoria teve mais de
3500 citações. O algoritmo que calcula os elementos dessas bases está presente na maioria dos
sistemas de álgebra computacional atuais.

Bruno implementou pela primeira vez o cálculo das Bases de Gröbner na própria Univer-
sidade de Innsbruck, onde trabalhava com um time de pesquisadores na vanguarda da pesquisa
computacional desta universidade. Depois de ter feito um intercâmbio num instituto de pesquisas
nucleares na União Soviética, foi contratado em 1974 pela Universidade de Linz. O seu cargo
inicial era o de professor de Teoria dos Algoritmos e Lógica Matemática. Buchberger é professor
da Universidade Johannes Kepler de Linz desde então.

Nos seus primeiros anos na Universidade de Linz, Bruno contribuiu de maneira pioneira
para a criação de um protótipo de máquina em parelelo. Depois, se voltou a Álgebra Construtiva
e coeditou o livro “Computer Algebra: Symbolic and Algebraic Computation”.

No início de 1994, Buchberger criou o projeto Theorema,1 cujo objetivo é a integração
das demonstrações lógicas com a computação algébrica. Hoje, o projeto foca na extensão
dos sistemas de computação algébrica criando funcionalidades que permitam demonstrações
matemáticas (raciocínio autônomo).

Em 2002, Bruno se aposentou como professor para se concentrar na pesquisa acadêmica.

1 <https://risc.jku.at/pj/theorema-project/>

3 PRELIMINARES

17

No início deste capítulo apresentaremos um rol de noções de Álgebra: Os anéis que
são conjuntos com propriedades abstraídas dos inteiros, os ideais que são subconjuntos de um
anel com propriedades abstraídas do conjunto dos múltiplos de um inteiro, os corpos que são
abstrações do conjunto dos reais. Continuaremos o capítulo introduzindo os polinômios de uma
indeterminada juntamente com o seu famoso Algoritmo da Divisão. Posteriormente, estendere-
mos os resultados anteriores obtidos, para polinômios em várias indeterminadas. Mostraremos a
necessidade da incorporação das Ordens Monomiais nesse estudo. Finalizaremos com o mais
importante resultado deste capítulo: O Algoritmo da Pseudodivisão, uma forma de dividir um
polinômio de várias indeterminadas por uma lista de outros polinômios de várias indeterminadas.

3.1 Anéis e Corpos

A seguir teremos a deﬁnição de três estruturas básicas da Álgebra Abstrata: Anéis,
Corpos e Ideais. A ideia da deﬁnição de anel é estudar conjuntos que possuem duas operações
denominadas adição e multiplicação que gozam das propriedades também encontradas no
conjunto dos números inteiros1. A abstração das particularidades destes conjuntos permite uma
análise global que revela importantes resultados acerca dessas estruturas. Não nos alongaremos
nesse estudo, que pode ser detalhado no livro de Fraleigh e Katz (2003).

Deﬁnição 1 (Anel). Um anel é um conjunto A (cid:54)= ∅ munido de duas operações usualmente
chamadas de adição ⊕ e multiplicação (cid:12) que gozam das seguintes propriedades:

1. A é fechado em relação à adição: Se a ∈ A e b ∈ A então a ⊕ b ∈ A.

2. A adição é associativa: Se a, b, c ∈ A então a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c.

3. Existe um elemento neutro para a adição 0A tal que a ⊕ 0A = a = 0A ⊕ a para qualquer

a ∈ A.

4. Para todo a ∈ A existe um inverso aditivo denotado por −a em A, isto é: a equação

a ⊕ x = 0A possui uma solução em A.

5. A adição é comutativa: Se a, b ∈ A então a ⊕ b = b ⊕ a.

6. A é fechado em relação à multiplicação: Se a, b ∈ A então a (cid:12) b ∈ A.

7. A multiplicação é associativa: Se a, b, c ∈ A então a (cid:12) (b (cid:12) c) = (a (cid:12) b) (cid:12) c.

1 O conjunto Z goza da comutatividade na multiplicação, porém essa propriedade não faz parte da deﬁnição de anel.

Veja a deﬁnição 4.

18

8. As leis distributivas são válidas em A: Se a, b, c ∈ A, então a (cid:12) (b ⊕ c) = (a (cid:12) b) ⊕ (a (cid:12) c)

e (a ⊕ b) (cid:12) c = (a (cid:12) c) ⊕ (b (cid:12) c)

Deﬁnição 2 (Anel com unidade). Um anel (A, ⊕, (cid:12)) possui unidade se existir 1A ∈ A com a
propriedade a (cid:12) 1A = a = 1A (cid:12) a para todo a ∈ A. O elemento 1A ∈ A é chamado de unidade
de A.

Deﬁnição 3 (Elemento invertível de um anel com unidade). Sendo (A, ⊕, (cid:12)) um anel com
unidade dizemos que a ∈ A é um elemento invertível se existir a−1 ∈ A tal que a (cid:12) a−1 = u =
a−1 (cid:12) a, ou seja a−1 é o inverso multiplicativo de a.

Deﬁnição 4 (Anel comutativo). Dizemos que (A, ⊕, (cid:12)) é comutativo quando a multiplicação
goza da comutatividade, isto é, se a, b ∈ A então a (cid:12) b = b (cid:12) a.

Exemplo 1. Os conjuntos abaixo, munidos com as operações usuais são anéis:

1. O conjunto dos inteiros Z = {. . . , −3, −2, −1, 0, 1, 2, 3, . . .}.

2. O conjunto dos racionais Q = (cid:8) a

b

: a, b ∈ Z com b (cid:54)= 0(cid:9).

3. O conjunto dos números reais R.

4. O conjunto dos números complexos C.

Observe que N = {0, 1, 2, 3, . . .} com as operações usuais não é um anel pela falha da proprie-
dade 5 da deﬁnição de anéis. Para uma investigação profunda sobre a construção dos conjuntos
numéricos recomendamos consultar a obra de Kramer e Pippich (2017).

Deﬁnição 5 (Domínio de Integridade). Um anel comutativo (A, ⊕, (cid:12)) com unidade 1A (cid:54)= 0A
é um domínio de integridade se para todo a, b ∈ A com a (cid:12) b = 0A implicar que a = 0A ou
b = 0A.

Exemplo 2. O conjunto das matrizes diagonais quadradas com entradas reais e as operações
usuais de adição e multiplicação satisfaz as condições de anel comutativo com unidade porém
não é um domínio de integridade. Pode veriﬁcar-se facilmente que a unidade desse anel é o
elemento

1A =

(cid:32)

(cid:33)

1 0
0 1

É sabido que existem matrizes diagonais não nulas cujo produto é a matriz nula. De fato:

(cid:32)

1 0
0 0

(cid:33)

(cid:32)

(cid:12)

0 1
0 0

(cid:33)

(cid:32)

=

1 · 0 + 0 · 0 1 · 1 + 0 · 0
0 · 0 + 0 · 0 0 · 1 + 0 · 0

(cid:33)

(cid:33)

(cid:32)

0 0
0 0

=

Exemplo 3. O conjunto (Z4, ⊕, (cid:12)) dos inteiros módulo 4 munido das operações usuais satisfaz
as condições para ser um anel comutativo com unidade porém não é um domínio de integridade.
Na tabela de multiplicação deste anel

19

(cid:12) 0

0

1

2

3

0

0

0

0

1

0

1

2

3

2

0

2

0

2

3

0

3

2

1

observa-se que 2 (cid:12) 2 = 4 = 0 (4 deixa resto 0 quando dividido por 4).

Exemplo 4. O conjunto (Z3, ⊕, (cid:12)) dos inteiros módulo 3 é um anel comutativo com unidade e
é um domínio de integridade. Observe a tabela de multiplicação do anel Z3.

(cid:12) 0

0

1

2

0

0

0

1

0

1

2

2

0

2

1

É um resultado conhecido da teoria dos números que se tomarmos a, b ∈ Zn com n
primo a equação a (cid:12) b = 0 implica a = 0 ou b = 0. Assim, Zp, p primo, com as operações de ⊕
e (cid:12) usuais é um domínio de integridade.

Deﬁnição 6 (Corpo). Um domínio de integridade (A, ⊕, (cid:12)) é um corpo se todo elemento não
nulo for invertível.

Como exemplos de corpos temos: Q, R e C com as operações de adição e de multiplicação
usuais. Z não é corpo pois nem todo elemento possui inverso multiplicativo. Revendo os exemplos
3 e 4 é possível concluir que Z4 não é corpo, pois não é domínio e que Z3 é um corpo. Tem-se
também que: Zn é corpo se, e somente se n é primo.

Proposição 1. Num anel (A, ⊕, (cid:12)) são válidas as seguintes propriedades:

1. O elemento neutro aditivo é único;

2. O elemento neutro multiplicativo, quando existe, é único;

3. O inverso aditivo de um elemento a ∈ A é único;

4. O inverso multiplicativo de um elemento a ∈ A, quando existe, é único;

Demonstração.

1. Se existissem dois elementos neutros 0A e 0(cid:48)

A então

0A = 0(cid:48)

A ⊕ 0A = 0A ⊕ 0(cid:48)

A = 0(cid:48)
A

onde na segunda igualdade foi usada a comutatividade da adição;

20

2. Se u e v são unidades, então pelo fato de u ser unidade tem-se u (cid:12) v = v, pelo fato de v

ser unidade tem-se u (cid:12) v = u, assim, necessariamente, v = u;

3. Se a(cid:48) e a(cid:48)(cid:48) são inversos aditivos de a ∈ A então usando a comutatividade e associatividade

da adição obtemos

a(cid:48)(cid:48) = 0 + a(cid:48)(cid:48) = (a(cid:48) + a) + a(cid:48)(cid:48) = a(cid:48) + (a + a(cid:48)(cid:48)) = a(cid:48) + 0 = a(cid:48)

4. Se i e i(cid:48) são inversos de a ∈ A e 1A é a unidade de A então usando a associatividade da

multiplicação obtemos

i = i · 1A = i · (a · i(cid:48)) = (i · a) · i(cid:48) = 1A · i(cid:48) = i(cid:48)

A partir de agora, simpliﬁcaremos as notações e iremos nos referir a um anel (A, ⊕, (cid:12))

simplesmente por A sendo a adição denotada por + e a multiplicação por ·. Além disso:

• O elemento neutro aditivo, que é único, será representado por 0 e chamado de zero;

• Já convencionamos que inverso o aditivo de a, que é único, será representado por −a.
Além disso, usaremos a notação a − b para representar a + (−b). Esta operação será
chamada de subtração;

• O elemento neutro multiplicativo, que é único, será representado por 1 e chamado de

unidade ou um;

• O inverso multiplicativo de um elemento a, que é único, será representado por a−1;

• A multiplicação de a por b poderá tanto ser representada por ab ou por a · b;

Proposição 2. Se A é um anel então para quaisquer a, b, c ∈ A

1. Se a + b = a + c então b = c

2. −(−a) = a

3. 0a = a0 = 0

4. a(−b) = (−a)b = −(ab)

5. (−a)(−b) = ab

Demonstração.

1. Adicionando −a a ambos membros da igualdade, usando a propriedade associativa, a

existência do inverso aditivo e do elemento neutro aditivo, obtemos o resultado;

21

2. Pelas propriedades 4 e 8 da deﬁnição (1) temos 0a = (0 + 0)a = 0a + 0a, agora usando
a propriedade 5, podemos adicionar −0a à ambos membros dessa igualdade para obter
0a = 0. De maneira análoga temos a0 = a(0 + 0) = a0 + a0 ⇒ 0 = a0 e assim ﬁca
provado que 0a = a0 = 0;

3. Como a(−b) + ab = a(−b + b) = a0 = 0 adicionando −(ab) à ambos membros da
igualdade obtemos a(−b) = −(ab). Analogamente temos que (−a)b + ab = (−a + a)b =
0b ⇒ (−a)b = −(ab).

4. Usando o item anterior temos (−a)(−b) = −(a(−b)). Novamente usando o item anterior
temos, −(a(−b)) = −(−(ab)). Como −(−(ab)) é o inverso aditivo de −(ab) temos

−(−(ab)) + (−(ab)) = 0

Adicionando ab em ambos membros obtemos:

−(−(ab)) = ab

de forma que ﬁca provadas as igualdades

(−a)(−b) = −(a(−b)) = −(−(ab)) = ab

3.2

Ideais

Seguiremos agora para a terceira ideia deste capítulo: A noção de Ideal.

A ideia básica por trás da deﬁnição de um ideal é a de generalizar um tipo especíﬁco de
subconjunto dos inteiros. Por exemplo, considere o conjunto dos inteiros múltiplos de 5:

5 Z = {. . . , −15, −10, −5, 0, 5, 10, . . .} ⊂ Z

Ao somarmos ou subtrairmos múltiplos de 5 continuaremos com um inteiro múltiplo de 5.
Observe que o produto de um múltiplo de 5 por qualquer número inteiro resulta num inteiro
também múltiplo de 5. Essas são as propriedades que queremos que um ideal possua.

Deﬁnição 7. Seja (A, +, ·) um anel comutativo com unidade. Um ideal I é um subconjunto não
vazio de A que goza das propriedades:

1. Dados f, g ∈ I então f + g ∈ I

2. Dado f ∈ I e h ∈ A então h · f ∈ I

Exemplo 5.

22

1. O conjunto unitário {0} e o próprio conjunto A são ideais do anel A. Os chamamos de

ideais triviais.

2. O conjunto 2 Z = {. . . , −4, −2, 0, 2, 4 . . .} é um ideal de Z

3. O conjunto dos números ímpares {. . . , −3, −1, 1, 3 . . .} não é um ideal de Z, pois ao

somarmos dois números ímpares não obtemos um número ímpar.

Proposição 3. Seja (A, +, ·) um anel comutativo com unidade. Então:

1. 0 ∈ I para todo ideal I de A.

2. Se I é um ideal de A que contém um elemento invertível então I = A.

3. Dado um subconjunto não vazio G de A o conjunto

(cid:104)G(cid:105) =

(cid:40) n

(cid:88)

i=1

hifi : n ∈ N, fi ∈ G e hi ∈ A

(cid:41)

é um ideal de A.

Demonstração.

1. Como um ideal é um subconjunto não vazio de A, podemos tomar um elemento x ∈ I.
Como A possui unidade 1, o inverso aditivo de 1 denotado por −1 também pertence à A.
Assim pela deﬁnição de ideal (−1) · x = −x ∈ I. Como a soma de dois elementos de um
ideal tem que permanecer no ideal obtemos x + (−x) = 0 ∈ I.

2. Por deﬁnição de ideal temos I ⊆ A. Assim, basta provarmos que A ⊆ I para termos
I = A. De fato, seja u ∈ I esse elemento invertível cujo inverso denotaremos por v. Dado
um r ∈ A qualquer podemos escrever

r = r · 1 = r · (vu) = (rv)
(cid:124)(cid:123)(cid:122)(cid:125)
∈A

· u
(cid:124)(cid:123)(cid:122)(cid:125)
∈I

∈ I

3. Sejam f e g elementos de (cid:104)G(cid:105). Então

f =

n
(cid:88)

i=1

hifi e g =

m
(cid:88)

j=1

qjgj

com hi, qj ∈ A e fi, gj ∈ G. Daí,

f + g =

n
(cid:88)

i=1

hifi +

m
(cid:88)

j=1

qjgj

Fazendo hn+j = qj e fn+j = gj podemos escrever a soma da seguinte forma:

f + g =

n+m
(cid:88)

k=1

∈ (cid:104)G(cid:105)

hk
(cid:124)(cid:123)(cid:122)(cid:125)
∈A

fk
(cid:124)(cid:123)(cid:122)(cid:125)
∈G

23

Por ﬁm, dado h ∈ A temos

h · f = h

n
(cid:88)

i=1

hifi =

n
(cid:88)

i=1

(hhi)
(cid:124) (cid:123)(cid:122) (cid:125)
∈A

fi
(cid:124)(cid:123)(cid:122)(cid:125)
∈G

∈ (cid:104)G(cid:105)

o que termina a demonstração.

Chamamos o conjunto (cid:104)G(cid:105) de ideal gerado por G. Quando (cid:104)G(cid:105) pode ser gerado por
um único elemento o chamamos de ideal principal. Por exemplo no anel (Z, +, ·) o ideal
gerado pelo conjunto unitário G = {5} é um ideal principal. Este ideal é representado por
(cid:104)5(cid:105) = {(cid:80)n

i=1 ai · 5 : n ∈ N, ai ∈ Z}.

Na próxima seção apresentaremos com detalhes a estrutura do anel de polinômios K[x].
Esse será um conjunto de muita importância neste trabalho. Por exemplo, no conjunto dos
polinômios com coeﬁcientes reais, simbolizado por R[x], considere o ideal (cid:104)x2 − 1(cid:105). Observe
que multiplicando x2 − 1 por qualquer polinômio de R[x] obteremos um polinômio que também
estará no ideal. Por exemplo:

• (x2 − 1) · x = x3 − x ∈ (cid:104)x2 − 1(cid:105)

• (x2 − 1) · 3 = 3x2 − 3 ∈ (cid:104)x2 − 1(cid:105)

• (x2 − 1) · (x2 + 1) = x4 − 1 ∈ (cid:104)x2 − 1(cid:105)

Da mesma forma, se somarmos quaisquer dois elementos do ideal (cid:104)x2 − 1(cid:105) o resultado

também pertence no ideal. Por exemplo:

• (x2 − 1) + (x3 − x) = x3 + x2 − x − 1 = (x2 − 1)(x + 1) ∈ (cid:104)x2 − 1(cid:105)

• (x2 − 1) + (3x2 − 3) = 4x2 − 4 = 4(x2 − 1) ∈ (cid:104)x2 − 1(cid:105)

• (x2 − 1) + (x4 − 1) = x4 + x2 − 2 = (x2 − 1)(x2 + 2) ∈ (cid:104)x2 − 1(cid:105)

Como vimos, é fácil obter elementos do ideal (cid:104)x2 − 1(cid:105). A pergunta que naturalmente
surge é: Como determinar se um polinômio f pertence a um ideal? Por exemplo f = x3 pertence
ao ideal (cid:104)x2 − 1(cid:105)? Essa questão será completamente respondida na seção 3.6.

3.3 Polinômios em K[x]

Nesta seção nos concentraremos no conjunto de polinômios em uma indeterminada.
Apresentaremos as deﬁnições necessárias para ilustrar o Algoritmo da Divisão com mais rigor
na próxima seção.

24

Deﬁnição 8. Um polinômio é uma expressão ﬁnita da forma

f = anxn + · · · + a1x + a0

com n ∈ N, com os coeﬁcientes ai num corpo K e an (cid:54)= 0. O grau do polinômio f é o maior índice
para o qual ai (cid:54)= 0. Neste caso o grau de f é n. Caso tenhamos f = 0 = · · · + 0x2 + 0x1 + 0x0,
deﬁniremos deg(f ) = −∞.

Dado um corpo K, considere o conjunto

K[x] = {anxn + · · · + a1x + a0 : n ∈ N e ai ∈ K}

dos polinômios em x com coeﬁcientes em K. Sejam

f = anxn + · · · + a1x + a0

g = bmxm + · · · + b1x + b0

elementos de K[x]. Deﬁnimos a multiplicação de f por g como abaixo:

f · g = c0 + c1x + c2x2 + · · · + cn+mxn+m

onde

c0 = a0b0

c1 = a0b1 + a1b0

c2 = a0b2 + a1b1 + a2b0

· · ·

ck =

(cid:88)

aibj

i+j=k

Caso seja m (cid:54)= n, podemos completar alguns termos com coeﬁcientes 0 para que

tenhamos m = n, assim, deﬁnimos a adição de f e g como:

f + g = (an + bn)xn + · · · + (a1 + b1)x + a0 + b0

O conjunto K[x] será de grande importância no nosso estudo. Se K for um domínio de
integridade, então K[x] também será um domínio de integridade. Demonstraremos esse fato no
apêndice seção A.1.

Para exempliﬁcar os próximos conceitos considere o polinômio

f = 3x5 + 7x2 − 3x + 1 ∈ Q[x]

25

Observe que o polinômio f está ordenado segundos as potências decrescentes. Temos que f é a
soma de 4 termos, a saber: 3x5, 7x2, −3x e 1. O termo de maior grau, 3x5, chama-se termo líder,
sendo x5 o monômio líder e 3 o coeﬁciente líder. Usando a simbologia, em inglês, usada na obra
de Cox, Little e O’Shea (2015), escrevemos

LT(f ) = 3x5, LM(f ) = x5, LC(f ) = 3

respectivamente para representar: Termo Líder de f , Monômio Líder de f e Coeﬁciente Líder de
f . Resumindo temos a deﬁnição 9

Deﬁnição 9. Dado um polinômio não nulo

f =

n
(cid:88)

i=0

aixi = anxn + · · · + a1x + a0

onde os ai ∈ K e an (cid:54)= 0 dizemos que:

• xn é o monômio líder de f , simbolicamente denotamos por LM(f ) = xn.

• an é o coeﬁciente líder de f , simbolicamente denotamos por LC(f ) = an.

• anxn é o termo líder de f , simbolicamente denotamos por LT(f ) = anxn.

• O grau de f é n, simbolicamente denotamos por deg(f ) = n.

Exemplo 6. Vejamos alguns exemplos:

1. um polinômio de grau 2:

f = 3x2 − 5x + 6

com LM(f ) = x2, LC(f ) = 3 e LT(f ) = 3x2.

2. um polinômio de grau 8:

g = 4x3 + 6x8 − 7

com LM(g) = x8, LC(g) = 6 e LT(g) = 6x8.

3. um polinômio de grau 0:

h = 9

observe que h = · · · + 0x2 + 0x1 + 9x0. Assim temos LM(h) = x0, LC(h) = 9 e
LT(h) = 9x0.

4. No polinômio nulo, f = 0 = · · · + 0x2 + 0x1 + 0x0, não se deﬁnem LM, LT e LC, mas

deﬁniremos deg(f ) = −∞.

Exemplo 7. É muito importante notar que na soma de polinômios em K[x] pode ocorrer um
cancelamento dos termos líderes.

26

(x2 + 5x
(cid:124) (cid:123)(cid:122) (cid:125)
grau 2

) + (−x2 − 3x
(cid:125)

(cid:124)

(cid:123)(cid:122)
grau 2

) = 2x
(cid:124)(cid:123)(cid:122)(cid:125)
grau 1

Como veremos na próxima proposição, esse fenômeno não ocorre na multiplicação em

K[x].

Proposição 4. Sejam f, g ∈ K[x]. Então:

1. deg (f + g) ≤ max {deg (f ), deg (g)}

2. deg (f · g) = deg (f ) + deg (g)

Demonstração.

1. Suponhamos que deg (f ) = m > n = deg (g). Daí temos f = cmxm + · · · + c1x1 + c0

com cm (cid:54)= 0 e g = dnxn + · · · + d1x1 + d0 com dn (cid:54)= 0, então

f + g = (cm + 0)xm + · · · + (cn + dn)xn + · · · + (c1 + d1)x1 + c0 + d0

dessa forma deg (f + g) = m = max {deg (f ), deg (g)} pois cm (cid:54)= 0. O caso em que
deg (f ) = m < n = deg (g) é completamente análogo.

Supondo que deg (f ) = m = deg (g) temos que f = cmxm + · · · + c1x1 + c0 com cm (cid:54)= 0
e g = dmxm + · · · + d1x1 + d0 com dm (cid:54)= 0 então

f + g = (cm + dm)xm + · · · (c1 + d1)x1 + c0 + d0

Observe que cm+dm pode se anular nesse caso. Em qualquer dos casos temos deg(f +g) =
max {deg (f ), deg (g)}.

2. Considere f = (cid:80)m
polinômios obtemos

i=0 cixi, cm (cid:54)= 0 e g = (cid:80)n

i=0 dixi, dn (cid:54)= 0. Multiplicando esses dois

f · g = cmdnxm+n + · · · + c0d0

Como cm e dn são ambos não nulos e K é um corpo, temos que cmdn (cid:54)= 0 portanto
deg(f · g) = m + n = deg (f ) + deg (g)

27

3.4 O Algoritmo da Divisão

Nesta seção revisitaremos o Algoritmo da Divisão visto no ensino médio. Usaremos
as notações apresentadas na seção anterior e teremos a apresentação de um algoritmo em
pseudocódigo2.

Para ﬁxar as ideias e relembrar as etapas da divisão vamos dividir f = 3x5 + 16x3 + x2 −
10x + 9 por g = x2 + 6. Primeiro ordenaremos o dividendo e o divisor pela ordem decrescente
do grau e os disporemos no seguinte formato de chave:

3x5 + 16x3 + x2 − 10x + 9 x2 + 6

Agora devemos dividir LT(f ) = 3x5 por LT(g) = x2 obtendo LT f
primeiro termo do quociente. Para encontrar o primeiro resto parcial efetuamos

LT g = 3x3 que é o

f −

(cid:19)

(cid:18) LT f
LT g

g = 3x5 + 16x3 + x2 − 10x + 9 − 3x3(x2 + 6) = −2x3 + x2 − 10x

Observe que nesta subtração cancelamos os termos líderes e assim o resultado tem grau menor
do que 5.

3x5 + 16x3 + x2 − 10x + 9 x2 + 6

− 3x5 − 18x3

3x3

− 2x3 + x2 − 10x

Agora repetimos a ideia inicial, tomando o resto parcial r1 = −2x3 + x2 − 10x como
dividendo e o divisor continua sendo x2 + 6. Dividindo LT(r1) = −2x3 por LT(g) = x2
obtendo LT f
LT g = −2x que é o segundo termo do quociente. Para encontrar o segundo resto parcial
efetuamos

r1 −

(cid:19)

(cid:18) LT r1
LT g

g = −2x3 + x2 − 10x − (−2x)(x2 + 6) = x2 + 2x + 9

Novamente nesta subtração cancelamos os termos líderes e assim o resultado tem grau menor do
que 3.

3x5 + 16x3 + x2 − 10x + 9 x2 + 6

− 3x5 − 18x3

3x3 − 2x

− 2x3 + x2 − 10x
+ 12x

2x3

x2 + 2x + 9

e x2 + 6 como divisor. Dividindo LT(r2) = x2 por LT(g) = x2 obtendo LT f

Efetuaremos o mesmo processo anterior, considerando r2 = x2 + 2x + 9 como dividendo
LT g = 1 que é o terceiro
2 Escrever algoritmos em Pseudocódigo é comum na Matemática. Assumindo que o leitor tenha um mínimo de
experiência com uma linguagem de programação qualquer, não haverá diﬁculdades para o entendimento dos
algoritmos deste trabalho.

28

termo do quociente. Para encontrar o terceiro resto parcial efetuamos

r2 −

(cid:19)

(cid:18) LT r2
LT g

g = x2 + 2x + 9 − (1)(x2 + 6) = 2x + 3

3x5 + 16x3 + x2 − 10x + 9 x2 + 6

− 3x5 − 18x3

3x3 − 2x + 1

− 2x3 + x2 − 10x
+ 12x

2x3

x2 + 2x + 9
− 6

− x2

2x + 3

O algoritmo acaba agora pois não podemos dividir LT(r3) = 2x por LT(g) = x2. Esta
divisão não é possível pois o grau de r3 = 2x + 3 é menor do que o de x2 + 6. Assim a divisão
está terminada e temos:

3x5 + 16x3 + x2 − 10x + 9
(cid:125)
(cid:123)(cid:122)
(cid:124)
Dividendo

= (3x3 − 2x + 1)
(cid:125)
(cid:123)(cid:122)
Quociente

(cid:124)

(x2 + 6)
(cid:124) (cid:123)(cid:122) (cid:125)
Divisor

+ 2x + 3
(cid:124) (cid:123)(cid:122) (cid:125)
Resto

Exemplo 8. No exemplo a seguir dividiremos f = x3 − 4x2 + x + 6 por g = x − 2.

x3 − 4x2 + x + 6 x − 2

− x3 + 2x2

x2 − 2x − 3

− 2x2 + x
2x2 − 4x

− 3x + 6
3x − 6

0

Quando o resto da divisão de f por g é zero, diremos que g divide f , ou que f é múltiplo

de g.

x3 − 4x2 + x + 6
(cid:124)
(cid:125)
(cid:123)(cid:122)
Dividendo

= (x2 − 2x − 3)
(cid:125)
(cid:123)(cid:122)
Quociente

(cid:124)

(x − 2)
(cid:124) (cid:123)(cid:122) (cid:125)
Divisor

+ 0

(cid:124)(cid:123)(cid:122)(cid:125)
Resto

Teorema 1 (Teorema da Divisão). Seja g ∈ K[x] não nulo. Então todo f ∈ K[x] pode ser
escrito como

f = qg + r

onde q e r são polinômios em K[x] com r = 0 ou deg(r) < deg(g). Os polinômios q e r são
unicamente determinados e existe um algoritmo para determiná-los.

Demonstração. Primeiro provaremos a existência e em seguida a unicidade. Se f = 0 tomamos
q = r = 0. Se deg(f ) < deg(g) basta tomar r = f e q = 0. No caso em que deg(f ) ≥ deg(g)

29

usaremos indução no grau de f . Vamos assumir que o teorema é válido para dividir um polinômio
com grau menor do que deg(f ) e iremos mostrar que também vale se o grau for deg(f ). Observe
LT g g
que o polinômio h = f −
cancelam-se os termos líderes do minuendo e subtraendo. Assim, a hipótese indutiva garante que
existam q(cid:48), r(cid:48) ∈ K[x] tais que

g tem grau menor do que deg(f ) pois na subtração f − LT f

(cid:16) LT f
LT g

(cid:17)

h = f −

LT f
LT g

g = q(cid:48)g + r(cid:48)

com r(cid:48) = 0 ou 0 ≤ deg r(cid:48) < deg g Desta forma,

(cid:18)

q(cid:48) +

f =

(cid:19)

LT f
LT g

g + r(cid:48)

e q = q(cid:48) + LT f
suponha que f = q(cid:48)g + r(cid:48) com r(cid:48) = 0 ou deg(r(cid:48)) < deg(g). Isto implicaria que

LT g e r = r(cid:48) o que conclui a demonstração da existência. Para mostrar a unicidade

qg + r = f = q(cid:48)g + r(cid:48)

g(q − q(cid:48)) = r(cid:48) − r

Se q − q(cid:48) (cid:54)= 0 teríamos que o lado esquerdo da igualdade teria grau maior ou igual do que deg(g)
enquanto que o lado esquerdo teria grau estritamente menor do que deg(g) Isto é um absurdo,
logo temos que ter q − q(cid:48) = 0 donde tiramos pela igualdade que r(cid:48) − r = 0 e assim obtemos que
q = q(cid:48) e r = r(cid:48).

Abaixo temos o algoritmo, escrito em pseudocódigo, que efetua a divisão do polinômio

f pelo polinômio g não nulo:

Input: f, g com g (cid:54)= 0
Output: q, r

1 q := 0;
2 r := f ;
3 while r (cid:54)= 0 and LT(g) divide LT(r) do
4

q := q + LT r
LT g ;
r := r − LT r
LT g g;

5
6 return q, r

Algoritmo 1: O Algoritmo da Divisão em K[x]

O bloco WHILE..DO faz com que as operações inseridas após o comando DO sejam
repetidas até que a expressão entre o WHILE e o DO seja falsa. Isto é, até que r = 0 ou que
LT(g) não divida LT(r). A cada iteração do WHILE os comandos das linhas 4 e 5 redeﬁnem as
variáveis q e r.

Para provar que este algoritmo funciona temos que mostrar que em todas as etapas sempre
é verdade que f = qg + r, que o algoritmo em algum momento termina e que os valores de q e r

30

obtidos no ﬁnal satisfazem as propriedades de quociente e resto desejadas. Como inicialmente
r = f e q = 0, note que é válida a relação f = qg + r. Mesmo depois das redeﬁnições de q e r
esta relação continua válida como se pode veriﬁcar por essa igualdade:

(cid:18)

f = qg + r =

q +

LT r
LT g

(cid:19)

(cid:18)

g +

r −

(cid:19)

LT r
LT g

g

Para provar que o algoritmo termina, isto é, que em algum momento r = 0 ou que LT(g)

não divide LT(r), temos que observar que ao calcular o novo resto com a expressão

r −

(cid:18) LT r
LT g

(cid:19)

g

ou o grau diminui ou a expressão se anula. De fato, se r = amxm + · · · + a0 e g = bnxn + · · · + b0
com m ≥ n então
(cid:18) LT r
LT g
(cid:18) LT r
LT g

g = amxm + · · · + a0 − amxm −

g = (amxm + · · · + a0) −

(bn−1xn−1 + · · · + b0)

(cid:18) amxm
bnxn

(bnxn + · · · + b0)

(cid:18) amxm
bnxn

r −

r −

(cid:19)

(cid:19)

(cid:19)

(cid:19)

onde nesta expressão ocorre um cancelamento de termos líderes e a respectiva diminuição do
grau ou possivelmente toda expressão se anula. Como o grau não pode diminuir inﬁnitamente o
algoritmo tem que terminar em um número ﬁnitos de iterações.

Como as iterações do WHILE terminam quando r = 0 ou quando LT(g) não divide
LT(r), de fato teremos um resto nulo ou um resto com grau estritamente inferior ao grau do
divisor. Também ﬁca provado que q continua sendo um polinômio em K[x] por conta das
operações realizadas em cada iteração serem somas de q com termos monomiais.

Corolário 1. Todo ideal I de K[x] é principal, isto é, I = (cid:104)f (cid:105) para algum f ∈ K[x]. O polinômio
f é único a menos de uma multiplicação por constante não nula em K.

Demonstração. Considere um ideal I ⊆ K[x]. Se I = {0} então I = (cid:104)0(cid:105) e nada temos a provar.
Se não, tome um polinômio não nulo f de grau mínimo contido em I. Provaremos que (cid:104)f (cid:105) = I.
É fácil ver que (cid:104)f (cid:105) ⊆ I pois I é um ideal e f ∈ I. Para provar a outra inclusão, tome g ∈ I e o
divida por f , obtendo g = qf + r com r = 0 ou deg(r) < deg(f ). Como I é um ideal qf ∈ I
logo r ∈ I pois r = g − qf . Agora temos duas possibilidades: r = 0 ou deg(r) < deg(f ). Se r
não fosse zero, então deg(r) < deg(f ) implicaria na existência de um polinômio de grau menor
ainda do que f em I. Isto não é possível pois contradiz a nossa escolha de f . Desta forma só
pode ser r = 0 daí g = qf ∈ (cid:104)f (cid:105). Isto prova a inclusão I ⊆ (cid:104)f (cid:105) e termina a demonstração de que
I = (cid:104)f (cid:105). Para provar unicidade, suponha que (cid:104)f (cid:105) = (cid:104)g(cid:105). Então f ∈ (cid:104)g(cid:105) signiﬁca que f = hg
para algum polinômio h. Analisando o grau desses polinômios temos deg(f ) = deg(h) + deg(g)
e consequentemente deg(f ) ≥ deg(g). Analogamente, trocando f por g e usando o mesmo

31

raciocínio obtemos deg(g) ≥ deg(f ) e por consequência deg(f ) = deg(g). Unindo isso à
equação inicial obtemos

deg(f ) = deg(h) + deg(g) ⇒ deg(h) = 0

e h tem que ser uma constante não nula em K.

Essa demonstração não é construtiva pois não nos fornece um algoritmo para determinar
esse gerador único. Para resolver esse problema usaremos a ideia de máximo divisor comum
apresentada na próxima seção.

3.5 O Máximo Divisor Comum de Polinômios

A seguir deﬁniremos o Máximo Divisor Comum de dois polinômios f, g ∈ K[x],
abreviado por MDC (f, g). A deﬁnição segue a mesma lógica da deﬁnição para números inteiros.

Deﬁnição 10. Um máximo divisor comum dos polinômios f, g ∈ K[x] é um polinômio h tal que

1. h divide f e g

2. Se p é um outro polinômio que divide f e g, então p divide h

Se h gozar dessas propriedades escreveremos h = MDC (f, g)

Proposição 5. Sejam f, g ∈ K[x]. Então:

1. MDC (f, g) existe e é único a menos do produto por uma constante não nula em K.

2. MDC (f, g) é um gerador do ideal (cid:104)f, g(cid:105).

3. Existe um algoritmo para a determinação do MDC (f, g)

Demonstração. Primeiro provaremos a existência do MDC. Como vimos anteriormente, todo
ideal de K[x] é principal, logo (cid:104)f, g(cid:105) = (cid:104)h(cid:105) para algum polinômio h ∈ K[x]. Aﬁrmamos que
h = MDC (f, g). De fato, h divide f e g pois f, g ∈ (cid:104)h(cid:105) = (cid:104)f, g(cid:105). Agora se p ∈ K[x] divide f e
g temos f = Cp e g = Dp para determinados C, D ∈ K[x]. Mas como h ∈ (cid:104)f, g(cid:105), então pode
ser escrito como combinação h = Af + Bg com A, B ∈ K[x]. Usando as expressões de f e g
nesta última equação obtemos:

h = Af + Bg = ACp + BDp = (AC + BD)p

o que mostra que p divide h e assim h = MDC (f, g).

Para provar a unicidade suponha que h(cid:48) é um outro MDC de f e g. Pela segunda parte da
deﬁnição de MDC temos que h(cid:48) divide h e h divide h(cid:48). Isto é, h = Ah(cid:48) e h(cid:48) = Bh donde temos

32

que AB = 1 com o grau de AB zero. Isto é, h = λh(cid:48) onde λ (cid:54)= 0 ∈ K é uma constante. Assim
ﬁcam provadas parte 1 e parte 2 da proposição.

Para mostrarmos o algoritmo utilizado para encontrar o MDC de dois polinômios de
uma variável estabeleceremos a seguinte notação: Sejam f, g ∈ K[x] com g (cid:54)= 0. Dividindo f
por g obtemos q e r tais que f = qg + r. Deﬁna r como o resto da divisão de f por g isto é,
r = resto (f, g).

Input: f, g
Output: h = MDC (f, g)

1 h := f ;
2 s := g;
3 while s (cid:54)= 0 do

4

5

6

rem := resto(h, s);
h := s;
s := rem;

7 return h

Algoritmo 2: O Algoritmo Euclidiano (Cálculo do MDC)

O Algoritmo apresentado acima é devido a Euclides3 e seu funcionamento utiliza sucessi-
vas divisões com resto. A ideia principal é usar o fato de que se f = qg + r então MDC (f, g) =
MDC (f − qg, g) = MDC (r, g). Isto signiﬁca que a cada divisão que é feita troca-se um po-
linômio por outro de grau menor (f por r). Como os restos não podem diminuir inﬁnitamente,
em algum momento teremos um resto 0. Assim teremos MDC (ri, 0) = ri = MDC (f, g).
Para provar que MDC (f, g) = MDC (f − qg, g) = MDC (r, g) lembre-se que MDC (f, g) é
um gerador do ideal (cid:104)f, g(cid:105). Então se mostrarmos que (cid:104)f, g(cid:105) = (cid:104)f − qg, g(cid:105) mostraremos que
MDC (f, g) = MDC (f − qg, g). De fato,(cid:104)f, g(cid:105) ⊂ (cid:104)f − qg, g(cid:105). Tome h ∈ (cid:104)f, g(cid:105), pela deﬁnição
de ideal gerado temos h = Af + Bg para determinados A, B ∈ K[x]. Então

h = Af + Bg = Af − Aqg + Bg + Aqg = A(f − qg) + (B + Aq)g

isto é, h ∈ (cid:104)f − qg, g(cid:105). Para provar a outra inclusão tome s ∈ (cid:104)f − qg, g(cid:105), assim

s = C(f − qg) + Dg = Cf − Cqg + Dg = Cf + (D − Cq)g ∈ (cid:104)f, g(cid:105)

3 Euclides de Alexandria (300 AC), inicia o seu livro VII, da coleção Os Elementos, mostrando como calcular o MDC

de duas medidas (números).

33

3.6 O problema da pertinência à um Ideal

O estudo desenvolvido até aqui resolve um problema de grande relevância neste trabalho:
Dados f1, . . . , fs polinômios em K[x] há como determinar se um polinômio especíﬁco f pertence
ao ideal (cid:104)f1, . . . , fs(cid:105) ⊂ K[x]?

Como podemos descobrir se f = x3 pertence ao ideal (cid:104)x4 − 1, x6 − 1(cid:105) ⊂ R[x]? Primei-
ramente sabemos que todo ideal em K[x] é principal, e para determinar o gerador calculamos
o MDC(x4 − 1, x6 − 1). Para isso, usaremos o algoritmo 2, apresentado na seção anterior.
Inicialmente h = f = x4 − 1 e s = g = x6 − 1. Observe que dividindo x4 − 1 por x6 − 1
obtemos quociente nulo e o resto igual ao próprio dividendo. Agora, h = x6 − 1 e s = x4 − 1.
Continuando o algoritmo agora temos que dividir x6 − 1 por x4 − 1

x6

− x6 + x2

− 1 x4 − 1
x2

x2 − 1

Continuando o algoritmo, agora com h = x4 − 1 e x2 − 1

x4

− x4 + x2

− 1 x2 − 1
x2 + 1

x2 − 1
− x2 + 1

0

Nesta etapa, obtemos h = x2 − 1 e s = 0. Assim, MDC(x4 − 1, x6 − 1) = MDC(x2 −

1, 0) = x2 − 1. Com este cálculo, ﬁca provado que (cid:104)x4 − 1, x6 − 1(cid:105) = (cid:104)x2 − 1(cid:105) ⊂ K[x]

A pergunta então ﬁca muito mais simples, e é a mesma que havíamos deixado em aberto,
na página 23: Como determinar se f = x3 pertence ao ideal (cid:104)x2 − 1(cid:105) ⊂ R[x]? Agora podemos
usar o algoritmo da divisão para dividir f = x3 por x2 − 1 e obter x3 = (x2 − 1)x + x. Como o
resto obtido é x, e temos a garantia que esse resto é o único possível, então ﬁca demonstrado
que f = x3 não pode ser escrito como um múltiplo de x2 − 1, isto é, f = x3 não pertence ao
ideal (cid:104)x2 − 1(cid:105) = (cid:104)x4 − 1, x6 − 1(cid:105). É verdade que f ∈ (cid:104)h(cid:105), h ∈ K[x] se e somente se o resto da
divisão de f por h for zero.

34

3.7 Polinômios em K[x1, . . . , xn]

Nesta seção apresentaremos o conjunto K[x1, . . . , xn] dos polinômios em várias indeter-
minadas com coeﬁcientes num corpo K. A partir de agora, esse será o ambiente onde efetuaremos
nossos cálculos.

Para começar a entender este conjunto, relembre que, se D for um domínio, então D[x]
também será um domínio de integridade (apêndice seção A.1). Desta forma, podemos visualizar
o conjunto (D[x])[y] também como um domínio integridade, formado pelos polinômios na
indeterminada y e com “coeﬁcientes” no domínio D[x]. Na verdade, estes “coeﬁcientes” em D[x]
são polinômios. Mostramos no apêndice seção A.2, que (D[x])[y] = (D[y])[x] = D[x, y], ou
seja, D[x, y] pode ser interpretado como formado por polinômios nas indeterminadas x e y com
coeﬁcientes num domínio de integridade D. Indutivamente podemos seguir com esse raciocínio
e concluir que D[x1, . . . , xn] é um domínio de integridade, formado por polinômios de várias
indeterminadas e coeﬁcientes num domínio D. Toda essa análise é válida substituindo o domínio
D por um corpo K, pois todo corpo é um domínio.

Um monômio em K[x1, . . . , xn] é uma expressão da forma

1 xα2
xα1

2 . . . xαn
n

Adotaremos a seguinte notação para esses monômios:

1 xα2
xα1

2 . . . xαn

n = X α com α = (α1, α2, . . . , αn) ∈ Zn

+

O grau total desse monômio é deﬁnido por |α| = α1 + α2 + · · · + αn

Dessa forma, estabelecemos uma relação biunívoca entre os monômios de K[x1, . . . , xn]

e o conjunto dos vetores com entradas inteiras não negativas Zn
+.

Assim, podemos escrever um polinômio f ∈ K[x1, . . . , xn] como

f = aα1X α1 + · · · + aαpX αp, aαi ∈ K, αi ∈ Zn

+, p ∈ Z+ e 1 ≤ i ≤ p

e deﬁnir o seu grau total como sendo max{|αi| : 1 ≤ i ≤ p}. Também podemos representar

K[x1, . . . , xn] =

(cid:40) p

(cid:88)

i=1

aαiX αi : aαi ∈ K, αi ∈ Zn

+, p ∈ Z+

(cid:41)

Exemplo 9. Considere os monômios abaixo:

1. x2yz3 = X α ∈ Q[x, y, z]. Neste caso α = (2, 1, 3) ∈ Z3

+ e o grau total é |α| = 6

2. xy4z2w7 = X α ∈ R[x, y, z, w]. Neste caso α = (1, 4, 2, 7) ∈ Z4

+, e o grau total é |α| = 14

Exemplo 10. Considere o polinômio

f = 5x2y3z − 4x3z − 2x6y3 = aα1X α1 + aα2X α2 + aα3X α3

35

Neste exemplo temos:
aα1 = 5, aα2 = −4, aα3 = −2, α1 = (2, 3, 1), α2 = (3, 0, 1), α3 = (6, 3, 0),

Na próxima seção estenderemos o Algoritmo da Divisão para polinômios de várias

indeterminadas. Para isso, precisaremos das Ordens Monomiais.

3.8 Ordem Monomial em K[x1, . . . , xn]

O ingrediente fundamental do algoritmo da divisão que vimos anteriormente é a dimi-
nuição do grau do dividendo a cada etapa. Para que isso ocorra, ordenamos os polinômios por
grau decrescente e sistematicamente efetuamos cancelamentos com os termos líderes. Com esses
cancelamentos o grau do dividendo diminui até eventualmente chegar a zero ou a um resto com
grau menor do que o do divisor. Para que possamos estender o algoritmo da divisão para várias
indeterminadas o primeiro passo é criar uma forma de ordenar polinômios em K[x1, . . . , xn].
Apresentaremos formas de colocar esses polinômios em ordem crescente ou decrescente sem
ambiguidade.

Deﬁnição 11. Uma relação de ordem sobre um conjunto A (cid:54)= ∅ é uma relação (cid:60) que satisfaz:

1. a (cid:60) a para todo a ∈ A (Reﬂexividade);

2. Se a, b ∈ A são tais que a (cid:60) b e b (cid:60) a então a = b. (Antissimetria);

3. Dados a, b, c ∈ A com a (cid:60) b e b (cid:60) c, então a (cid:60) c (Transitividade).

Quando ocorrer a (cid:60) b com a (cid:54)= b escreveremos a (cid:31) b.

Deﬁnição 12. Uma relação de ordem (cid:60) sobre um conjunto A (cid:54)= ∅ é total, se para quaisquer
a, b ∈ A tem-se

a (cid:31) b, b (cid:31) a ou a = b

Como já foi visto, o conjunto dos monômios de K[x1, . . . , xn] pode ser identiﬁcado
+. Desse modo, deﬁnir uma
+. Os resultados que
+ podem ser traduzidos, usando esta equivalência, para o conjunto dos
+} ⊂ K[x1, . . . , xn] e reciprocamente.

com o conjunto dos vetores com entradas inteiras não negativas Zn
ordem no conjunto dos monômios equivale a deﬁnir uma ordem em Zn
serão apresentados para Zn
monômios {X α : α ∈ Zn

Deﬁnição 13. Uma ordem monomial em K[x1, . . . , xn] é uma relação entre os monômios X α,
com α ∈ Zn
+ que satisfaz às seguintes condições:

+, ou equivalentemente é uma relação (cid:31) em Zn

1. (cid:31) é uma relação de ordem total sobre Zn

+, isto é, para quaisquer α, β ∈ Zn

+, apenas uma

das condições é satisfeita: α (cid:31) β, α = β ou β (cid:31) α.

2. Se α (cid:31) β e γ ∈ Zn

+ então α + γ (cid:31) β + γ.

36

3. (Princípio da Boa Ordenação) O conjunto Zn

junto não vazio S de Zn
dizemos que S tem um menor elemento α com respeito à relação (cid:31).

+ é bem ordenado, isto é, para todo subcon-
+ existe α ∈ S tal que, para todo β ∈ S − {α}, β (cid:31) α. Neste caso,

Exemplo 11. O grau em R[x] é uma ordem monomial. De fato, as três condições acima são
satisfeitas:

1. O grau é uma relação de ordem total sobre Z+.

2. Se i, j, k ∈ Z+ ,com i > j, então i + k > j + k.

3. Finalmente, basta observar que Z+ é um conjunto bem ordenado em relação à ordem

usual.

Para demonstrar que uma relação (cid:31) em K[x1, . . . , xn] é uma ordem monomial, podemos
encontrar diﬁculdades em justiﬁcar o item (3) da Deﬁnição (13). O próximo lema facilitará
este trabalho. Além disso também desempenhará papel fundamental na demonstração de que
determinados algoritmos terminam.

Lema 1. O conjunto Zn
sequência estritamente decrescente em Zn
+

+ é dito bem ordenado com respeito à relação (cid:31) se, e somente se, toda

é ﬁnita.

α1 (cid:31) α2 (cid:31) α3 (cid:31) · · ·

Demonstração. Equivalentemente, vamos provar que Zn
+ não é bem ordenado se, e só se, existe
+. De fato, se Zn
uma sequência inﬁnita estritamente decrescente em Zn
+ não é bem ordenado,
então algum subconjunto não vazio S ⊂ Zn
+ não possui um menor elemento. Assim, tomando
α1 ∈ S, podemos encontrar α2 ∈ S, com α1 (cid:31) α2. Analogamente, α2 não é o menor elemento
de S, logo existe α3 ∈ S, com α2 (cid:31) α3. Desta forma, formamos uma sequência inﬁnita {αi}∞
i=1
estritamente decrescente. Reciprocamente, dada uma sequência inﬁnita α1 (cid:31) α2 (cid:31) α3 (cid:31) · · · ,
temos que {α1, α2, α3, . . .} é um subconjunto não vazio de Zn
+ que não possui menor elemento
e, por isso, Zn

+ não é bem ordenado.

Deﬁnição 14 (Ordem Lexicográﬁca “LEX”). Sejam α = (α1, . . . , αn) e
β = (β1, . . . , βn) ∈ Zn
+. Dizemos que X α >LEX X β se α (cid:54)= β e no vetor diferença α − β ∈ Zn,
a primeira entrada não nula, da esquerda para direita, é positiva. Também podemos representar
essa relação usando a notação vetorial α >LEX β.

Exemplo 12. Em Q[x, y, z, w] temos:

37

1. x3y2z6w >LEX xy5z8w3 já que o vetor (3, 2, 6, 1) − (1, 5, 8, 3) = (2, −3, −2, −2) tem a

primeira entrada não-nula, da esquerda para a direita, positiva. Isto é, (3, 2, 6, 1) >LEX (1, 5, 8, 3).

2. w2 >LEX w1, já que o vetor (0, 0, 0, 2) − (0, 0, 0, 1) = (0, 0, 0, 1) tem a primeira entrada

não-nula, da esquerda para a direita, positiva. Isto é, (0, 0, 0, 2) >LEX (0, 0, 0, 1).

3. x >LEX y >LEX z >LEX w, já que (1, 0, 0, 0) >LEX (0, 1, 0, 0) >LEX (0, 0, 1, 0) >LEX (0, 0, 0, 1).

Com o auxílio do Lema 1, provaremos na próxima proposição que a relação deﬁnida

acima é uma ordem monomial.

Proposição 6. A ordem lexicográﬁca em Zn

+ é uma ordem monomial.

Demonstração. Vamos provar que as condições da deﬁnição de ordem monomial são satisfeitas.
De fato:

1. Para veriﬁcar que >LEX é relação de ordem total, basta usar o fato de que Z é um anel

totalmente ordenado.

2. Se α >LEX β, então temos que a primeira entrada não nula (da esquerda para direita) em
α − β, digamos αk − βk, é positiva. Como X αX γ = X α+γ e X βX γ = X β+γ então, por
hipótese, a primeira entrada não nula (da esquerda para direita) de (α+γ)−(β+γ) = α−β
é αk − βk > 0. Logo, (α + γ) >LEX (β + γ), provando assim que vale o segundo item da
deﬁnição de ordem monomial.

3. Suponha que, com respeito à ordem >LEX , Zn

+ não seja um conjunto bem ordenado. Então,

pelo Lema 1, existe uma sequência inﬁnita e estritamente decrescente

α1 >LEX α2 >LEX α3 >LEX · · ·

(3.1)

1}∞

1}∞

1 = αk

i=1, onde αi

de elementos de Zn
+. Considere a sequência {αi
1 é a primeira entrada do vetor
αi da sequência (3.1). Pela deﬁnição da ordem lexicográﬁca, {αi
i=1 é uma sequência
de inteiros não negativos e não crescente, com relação a ordem usual >. Como Z+ é
bem ordenado em relação à ordem usual, a sequência {αi
i=1 estaciona, isto é, existe um
inteiro k tal que αi
2}∞
i=k,
formada pela segunda entrada de cada elemento da sequência αk, αk+1, . . ., também é não
crescente em relação à ordem usual >. De forma análoga, a sequência {αi
i=k estaciona.
Continuando com este procedimento, vamos concluir que, para algum l, αl, αl+1, . . . são
todos iguais, já que a sequência (3.1) é formada por vetores com n entradas. Isto contradiz
o fato da sequência (3.1) ser estritamente decrescente. Assim, provamos que vale o terceiro
item da deﬁnição de ordem monomial e, portanto, provamos a proposição.

1, para todo i ≥ k. A sequência de inteiros não negativos {αi

2}∞

1}∞

De forma análoga, podemos provar que as relações deﬁnidas adiante também são ordens

monomiais.

Deﬁnição 15 (Ordem Lexicográﬁca Graduada “GRLEX”). Sejam α e β ∈ Zn
xα >GRLEX X β se

+. Dizemos que

38

1. |α| = (cid:80)n

i=1 αi > |β| = (cid:80)n

i=1 βi, onde > é a ordem usual em N, ou

2. |α| = |β| e α >LEX β.

Observe que a ordem lexicográﬁca graduada ordena primeiro pelo grau total e depois

desempata com a ordem lexicográﬁca.

Exemplo 13. Em Q[x, y, z],temos:

1. xy4z5 >GRLEX x5yz já que |(1, 4, 5)| = 10 > |(5, 1, 1)| = 7.

2. x3y2z >GRLEX x3yz2 já que |(3, 2, 1)| = 6 = |(3, 1, 2)| e (3, 2, 1) >LEX (3, 1, 2).

Deﬁnição 16 (Ordem Lexicográﬁca Reversa Graduada “GREVLEX”). Sejam
α e β ∈ Zn

+. Dizemos que X α >GREVLEX X β se

1. |α| = (cid:80)n

i=1 αi > |β| = (cid:80)n

i=1 βi, onde > é a ordem usual em N, ou

2. |α| = |β|, α (cid:54)= β e a primeira entrada não nula, da direita para a esquerda, de α −β ∈ Zn

é negativa.

Exemplo 14. Em R[x, y, z],temos:

1. x2y4z5 >GREVLEX x5yz já que |(2, 4, 5)| = 11 > |(5, 1, 1)| = 7.

2. x3y2z >GREVLEX x3yz2 já que |(3, 2, 1)| = 6 = |(3, 1, 2)| e em α − β = (0, 1, −1) temos

a primeira entrada não nula, da direita para esquerda, negativa.

Para encerrar a seção, veremos como uma ordem monomial pode ser aplicada em
polinômios. Para isso, dados um polinômio f = (cid:80)
α aαX α e uma ordem monomial (cid:31) em
K[x1, . . . , xn], podemos ordenar os monômios de f usando a ordem (cid:31). Por exemplo, se f =
x3y − 3x4y2z − xy2z ∈ Q[x, y, z], então podemos reordenar, usando a ordem lexicográﬁca, os
termos de f de forma decrescente como

f = −3x4y2z + x3y − xy2z

Neste sentido, segue a próxima deﬁnição cuja terminologia é a mesma usada anterior-

mente.

Deﬁnição 17. Sejam f = (cid:80)
uma ordem monomial.

α aαX α um polinômio não nulo em K[x1, . . . , xn], K corpo e (cid:31)

39

1. aαX α é um termo de f .

2. X α é um monômio de f .

3. O multigrau de f é o vetor n-dimensional

multideg (f ) = max {α ∈ Zn

+ : aα (cid:54)= 0},

onde o máximo é tomado com respeito a ordem monomial (cid:31).

4. O coeﬁciente líder de f é

5. O monômio líder de f é

6. O termo líder de f é

LC (f ) = amultideg (f ) ∈ K

LM (f ) = X multideg (f )

LT (f ) = LC (f ) · LM (f )

Exemplo 15. Sejam f = −3x4y2z + x3y − xy2z ∈ R[x, y, z] e (cid:31) a ordem lex. Então,

multideg (f ) = (4, 2, 1)

LC (f ) = −3

LM (f ) = x4y2z

LT (f ) = −3x4y2z

As propriedades de multigrau, listadas na próxima proposição, são generalizações das

propriedades de grau para polinômios em uma variável vistas anteriormente.

Proposição 7. Sejam f ,g polinômios não nulos em K[x1, . . . , xn] e (cid:31) uma ordem monomial.
Então,

1. LT(f g) = LT(f ) LT(g)

2. multideg (f g) = multideg(f ) + multideg(g)

3. Se f + g (cid:54)= 0, temos que max{multideg(f ), multideg(g)} (cid:31) multideg(f + g) ou

max{multideg(f ), multideg(g)} = multideg(f +g). Valendo sempre a igualdade quando
multideg(f ) (cid:54)= multideg(g).

40

Demonstração. Sejam

f =

(cid:88)

α

aαX α, com LT(f ) = aα(0)X α(0), aα(0) (cid:54)= 0 e

(cid:88)

g =

β

bβX β, com LT(g) = bβ(0)X β(0), bβ(0) (cid:54)= 0

1. Temos

f g =

(cid:88)

α,β

aαbβX αX β

Pela deﬁnição 17, temos garantia de que X α(0) (cid:60) X α para todo α, e X β(0) (cid:60) X β para todo
β. Daí, X α(0)X β(0) (cid:60) X α(0)X β (cid:60) X αX β para todo α, β. Como aα(0)bβ(0) (cid:54)= 0, temos
assim que LT(f g) = aα(0)bβ(0)X α(0)X β(0) = aα(0)X α(0)bβ(0)X β(0) = LT(f ) LT(g)

2. Usando o item anterior, temos que o termo líder do produto f g é o produto dos termos
líderes de f e g, assim, o multigrau de f g será o multigrau de aα(0)X α(0)bβ(0)X β(0) =
aα(0)bβ(0)X α(0)+β(0) que é igual a α(0) + β(0), portanto multideg (f g) = multideg(f ) +
multideg(g)

3. Segue imediatamente da deﬁnição de soma de polinômios e da deﬁnição de ordem mono-
mial que max{multideg(f ), multideg(g)} (cid:60) multideg(f + g). Agora, se multideg(f ) (cid:54)=
multideg(g), isto é, se α(0) (cid:54)= β(0), podemos supor, sem perda de generalidade, que
α(0) (cid:31) β(0). Como β(0) (cid:60) β, para todo β, então α(0) (cid:31) β(0) (cid:60) β, para todo β.
Além disso, também temos que α(0) (cid:60) α, para todo α. Então, pela deﬁnição de soma de
polinômios, temos que:

multideg(f + g) = α(0) = multideg(f ) = max{multideg(f ), multideg(g)}.

3.9 O Algoritmo da Divisão em K[x1, . . . , xn]

Nesta seção apresentaremos a divisão de f por g (cid:54)= 0 em K[x1, . . . , xn]. Veriﬁcaremos
que a divisão termina quando o resto for zero ou não apresentar nenhum termo divisível pelo
termo líder de g. Aqui usaremos outra formatação para a divisão. A nossa intenção é a fami-
liarização com as notações adotadas no Algoritmo da Pseudodivisão, que será apresentado na
próxima seção.

Exemplo 16. Consideremos f = x3 + x2y + xy3 + y3 e g = x + y2 polinômios em R[x, y].
Usando a ordem lexicográﬁca graduada, vamos dividir f por g. Para começar, ordenaremos os
polinômios com a ordem GRLEX:

f = xy3 + x3 + x2y + y3, e g = y2 + x

41

e os organizaremos numa tabela como se segue:

g

f

y2 + x xy3 + x3 + x2y + y3

q =

LT(f )

Observe que LT(g) = y2 divide LT(f ) = xy3, então o primeiro quociente encontrado é
LT(g) = xy. Subtraindo xy · g = xy3 + x2y de f obtemos x3 + y3. Observe abaixo, o quadro
atualizado:

g

f

y2 + x xy3 + x3 + x2y + y3

xy

q = xy

−xy3 − x2y
x3 + y3

Note agora que LT(g) = y2 não divide LT(x3 + y3) = x3, porém dividiria y3 que é um
termo menor deste dividendo (segundo a ordem GRLEX). Como a ideia básica da divisão é
que nenhum termo do resto seja divisível pelo termo líder de g, vamos adicionar o termo x3
ao resto e continuar dividindo a expressão remanescente y3. Essa é a grande diferença entre a
divisão em K[x] e a divisão em K[x1, . . . , xn]: No caso de uma indeterminada, se LT(g) não
divide LT(f ) então LT(g) não divide nenhum outro termo de f . Para continuar o processo de
divisão, adicionaremos ao nosso quadro um coluna extra que acumulará os restos.

g
y2 + x
xy

f
xy3 + x3 + x2y + y3
−xy3 − x2y
(cid:0)(cid:0)x3 + y3

r

x3

q = xy + y

Continuamos a divisão, agora com o termo x3 já na coluna dos restos. Observe que
LT(g) = y2 divide LT(y3) = y3 e o quociente é y. Agora, subtraindo y · g = y3 + xy do
dividendo y3 obtemos −xy.

42

g
y2 + x
xy

y

f
xy3 + x3 + x2y + y3
−xy3 − x2y
(cid:0)(cid:0)x3 + y3
−y3 − xy
−xy

q = xy + y

r

x3

x3

Como −xy não é divisível por LT(g) = y2 a divisão acaba e o termo −xy é adicionado
aos restos. Assim obtemos f = qg + r onde q = xy + y e r = x3 − xy. Observe que a
característica do resto é que nenhum dos seus termos é divisível por LT(g) = y2.

g
y2 + x
xy

y

f
xy3 + x3 + x2y + y3
−xy3 − x2y
(cid:0)(cid:0)x3 + y3
−y3 − xy
(cid:8)(cid:8)−xy
(cid:8)

q = xy + y

r

x3

−xy
x3 − xy

Exemplo 17. Vamos dividir f = x2y2 + x + y por g = xy + y2 usando a ordem lexicográﬁca:

g
xy + y2
xy

−y2

f
x2y2 + x + y
−x2y2 − xy3
−xy3 + x + y
xy3 + y4
(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)
x + y4 + y

q = xy + y2

r

x + y4 + y
x + y4 + y

Assim obtemos f = qg + r onde q = xy + y2 e r = x + y4 + y. Observe que que nenhum

dos termos do resto é divisível por LT(g) = xy.

A seguir demonstraremos o Teorema da Divisão para polinômios de várias indetermina-

das.

Teorema 2 (O Teorema da Divisão em K[x1, . . . , xn]). Considere uma ordem monomial (cid:31)
ﬁxada. Dados os polinômios f, g ∈ K[x1, . . . , xn] com g não nulo, existem q, r ∈ K[x1, . . . , xn]
unicamente determinados pelas condições

f = qg + r, com r = 0 ou os termos de r não são divisíveis por LT(g)

43

Demonstração. Se f = 0, então q = r = 0. Seja f = f0 (cid:54)= 0. Se nenhum termo de f0 for
divisível por LT(g) então q = 0 e r = f = f0 satisfazem o teorema. Caso contrário, deﬁna
LT(g) g. Se nenhum termo de f1 for divisível por LT(g) então q = LT(f0)
f1 = f0 − LT(f0)
LT(g) e r = f1
satisfazem o teorema. Caso contrário, deﬁna f2 = f1 − LT(f1)
LT(g) g. Continuando dessa forma criamos
uma sequência fi+1 = fi − LT(fi)
LT(g) g onde sempre há uma redução no multigrau ou eventualmente,
um anulamento desta diferença. De fato, usando 7.1,

LT

(cid:18) LT(fi)
LT(g)

(cid:19)

g

=

LT(fi)
LT(g)

LT(g) = LT(fi)

vemos que fi e LT(fi)
LT(g) g possuem os mesmos termos líderes, portanto a sua diferença tem multigrau
menor ou eventualmente pode ser nula. Dessa forma, ﬁca formada uma sequência decrescente
de multigraus, e como vimos no Lema 1, essa sequência tem que terminar em algum momento.
Digamos que a sequência acaba na etapa k ∈ N. Então, fk = fk−1 − LT(fk−1)
LT(g) g com nenhum
termo de fk divisível por LT(g) ou fk = 0. Deﬁnindo

q =

k−1
(cid:88)

i=0

LT(fi)
LT(g)

∈ K[x1, . . . , xn] e r = fk

temos o teorema satisfeito.

Para provar a unicidade, suponha q1, q2, r1, r2 ∈ K[x1, . . . , xn] tais que q1g + r1 = f =

q2g + r2 com os restos nulos ou com nenhum termo de r1 ou r2 divisível por LT(g). Então,

0 = f − f = (q1 − q2)g + (r1 − r2) ⇒ r2 − r1 = (q1 − q2)g

Com isso, supor r1 (cid:54)= r2 nos levaria a conclusão de que LT(g) divide LT(r2 − r1) o que é um
absurdo. Concluímos que r1 = r2. A nossa igualdade então ﬁca

0 = (q1 − q2)g

Como por hipótese g (cid:54)= 0 e sabemos que K[x1, . . . , xn] é um domínio de integridade então
q1 = q2 e assim ﬁca provada a unicidade.

Da mesma forma que em K[x], quando dividirmos f por g (cid:54)= 0 em K[x1, . . . , xn] obtendo

f = qg + r, chamaremos o único polinômio q de quociente e o único polinômio r de resto.

Abaixo reproduzimos o algoritmo que utilizamos para efetuar a divisão de f por g não

nulo em K[x1, . . . , xn].

Input: f, g ∈ K[x1, . . . , xn] com g (cid:54)= 0
Output: q, r satisfazendo f = qg + r com r = 0 ou nenhum termo de r divisível por

44

LT(g)

1 q := 0;
2 r := 0;
3 h := f ;
4 while h (cid:54)= 0 do

5

6

7

8

9

10

if LT(g) divide LT(h) then

q := q + LT(h)
LT(g) ;
h := h − LT(h)
LT(g) g;

else

r := r + LT(h);
h := h − LT(h);

11 return q, r

Algoritmo 3: O algoritmo da divisão em K[x1, . . . , xn]

3.10 O Algoritmo da Pseudodivisão em K[x1, . . . , xn]

Usando o algoritmo da divisão em K[x] conseguimos provar que todo ideal em K[x]
pode ser gerado por um único elemento, isto juntamente com a unicidade do resto da divisão
nos permitiu resolver o problema de decidir se um polinômio f pertence à um ideal I ⊆ K[x].
Agora continuaremos a tratar a questão no caso de várias indeterminadas: Dados f, f1, . . . , fs ∈
K[x1, . . . , xn] como decidir se f ∈ (cid:104)f1, . . . , fs(cid:105)? Para isto iremos estender o algoritmo da divisão
para dividir f por uma lista de polinômios f1, ..., fs.

Dividir f por uma lista de polinômios f1, ..., fs signiﬁca escrever f da forma

f = q1f1 + ... + qsfs + r

(3.2)

onde os “quocientes” q1, . . . , qs e o resto r são elementos de K[x1, . . . , xn]. Nos próximos
exemplos, veremos que a ideia básica do algoritmo da Pseudodivisão é a mesma do algoritmo da
divisão: Tentaremos cancelar o termo líder de f com respeito a uma ordem monomial ﬁxada
usando o termo líder de algum fi. O resto, como vimos no algoritmo da divisão, terá uma
caracterização especial. Vejamos alguns exemplos:

Exemplo 18. Dados f = x2y2 + x + y, f1 = xy + y2 e f2 = x + y, vamos escrever f na
forma f = a1f1 + a2f2 + r, usando a ordem lexicográﬁca. Para isto, estabelecemos a seguinte

45

organização para o cálculo de a1 e a2:

f1

f2

f

xy + y2 x + y x2y2 + x + y

a1 =

a2 =

Observe que tanto LT(f1) = xy como LT(f2) = x dividem LT(f ) = x2y2. Como
f1 foi listado primeiro, dividiremos x2y2 por xy, obtendo xy como quociente. Subtraindo
xyf1 = x2y2 + xy3 de f , obtemos −xy3 + x + y.

Vamos organizar esses resultados no esquema abaixo:

f1

f2

f

xy + y2 x + y x2y2 + x + y
−x2y2 − xy3
−xy3 + x + y

xy

a1 = xy

a2 =

Agora repetimos o mesmo processo para −xy3 + x + y. Neste caso, LT(−xy3 + x + y) =
−xy3 também é divisível por LT(f1) e por LT(f2). Assim, escolhemos dividir −xy3 + x + y
por f1 obtendo −y2 como quociente. Então, subtraímos −y2f1 = −xy3 − y4 de −xy3 + x + y,
obtendo x + y4 + y. Agora, repetimos o processo para x + y4 + y, sendo que LT(x + y4 + y) = x
é divisível apenas por LT(f2). Veja como ﬁcou a tabela:

f1
xy + y2
xy

−y2

f2
x + y

1

f
x2y2 + x + y
−x2y2 − xy3
−xy3 + x + y
xy3 + y4
x + y4 + y
−x − y
y4

a1 = xy − y2 a2 = 1

Observe que o resto é r = y4, pois este não é divisível nem por LT(f1) e nem por LT(f2). Assim
podemos escrever f da seguinte forma:

f = (xy − y2)f1 + f2 + y4

Exemplo 19. Agora vamos dividir f = x2y + xy2 + y2 por f1 = xy − 1 e por f2 = y2 − 1,
usando a ordem lexicográﬁca.

Procedendo exatamente como no exemplo acima, obtemos:

46

f1
xy − 1

f2

f

y2 − 1 x2y + xy2 + y2

x

y

−x2y + x
xy2 + x + y2
−xy2 + y
x + y2 + y

a1 = x + y

a2 =

Observe que, LT(x + y2 + y) = x não é divisível por LT(f1) nem por LT(f2). Porém
o termo y2 de x + y2 + y é divisível por LT(f2) = y2. Da mesma forma como no exemplo 16,
iremos considerar como resto, o polinômio cujos termos não são divisíveis por nenhum dos
termos líderes dos fi’s. Então para obter um resto com tal característica, daremos continuidade
ao algoritmo da seguinte forma:

Criamos, à direita da tabela acima, uma coluna r onde colocamos o termo
LT(x + y2 + y) = x que não é divisível por LT(f1) nem por LT(f2), conforme a tabela:

x

f1 = xy − 1 f2 = y2 − 1 f = x2y + xy2 + y2
−x2y + x
xy2 + x + y2
−xy2 + y
(cid:26)x + y2 + y

y

r

a1 = x + y

a2 =

y2 + y x

Como LT(f2) divide LT(y2 + y), procedemos como o usual. Caso não fosse possível
efetuar a divisão por LT(f1) nem por LT(f2), moveríamos o então termo líder de y2 + y para
a coluna dos restos até obtermos um termo líder que permita a divisão ou até este polinômio
tornar-se zero. Assim temos a seguinte tabela:

y

x

f1 = xy − 1 f2 = y2 − 1 f = x2y + xy2 + y2
−x2y + x
xy2 + x + y2
−xy2 + y
(cid:26)x + y2 + y
y2 + y
−y2 + 1
(cid:19)y + 1
(cid:1)1
0

1

47

r

x

y
1

a1 = x + y

a2 = 1

x + y + 1

Assim, o resto é x + y + 1, e obtemos:

x2y + xy2 + y2 = (x + y)(xy − 1) + (y2 − 1) + (x + y + 1)

Exemplo 20. Dividir g = x4y + x3y3 + xy4 por g1 = xy + y3 e g2 = x4 + y usando a ordem
lexicográﬁca e depois usando a ordem lexicográﬁca graduada.

Usando a ordem lex:

x3

g1 = xy + y3 g2 = x4 + y g = x4y + x3y3 + xy4
−x4y − x3y3
xy4
−xy4 − y6
−y6

y3

a1 = x3 + y3

a2 = 0

Usando a ordem grlex:

x3

g1 = y3 + xy g2 = x4 + y g = x3y3 + x4y + xy4
−x3y3 − x4y
xy4
−xy4 − x2y2
−x2y2

xy

r

−y6

r

a1 = x3 + xy

a2 = 0

−x2y2

Observe que ao trocar a ordem monomial tanto os quocientes como o resto mudaram. O

próximo teorema formaliza as ideias expostas até agora.

Teorema 3 (Algoritmo da Pseudodivisão em K[x1, . . . , xn]). Fixada uma ordem monomial
+, considere a lista (f1, ..., fs) de polinômios em K[x1, . . . , xn]. Então todo elemento
sobre Zn

48

f ∈ K[x1, . . . , xn] pode ser escrito como

f = q1f1 + ... + qsfs + r,

onde q1, ..., qs, r ∈ K[x1, . . . , xn], e r = 0 ou os termos de r não são divisíveis por nenhum dos
termos líderes dos fi’s. Chamaremos r de um resto de f na divisão por f1, ..., fs nesta ordem.

Demonstração. O algoritmo mostrado abaixo prova a existência dos quocientes e do resto. Além
disso, mostraremos que o algoritmo sempre funciona independente dos polinômios inseridos.

Input: f1, . . . , fs, f
Output: q1, . . . , qs, r

1 q1 := 0; . . . ; qs := 0; r := 0;
2 p := f ;
3 while p (cid:54)= 0 do
i := 1;
ocorreudivisão := FALSE;
while i ≤ s and ocorreudivisão := FALSE do

4

5

6

7

8

9

10

11

12

13

14

15

if LT(fi) divide LT(p) then

qi := qi + LT(p)/ LT(fi);
p := p − (LT(p)/ LT(fi))fi;
ocorreudivisão := TRUE;

else

i := i + 1;

if ocorreudivisão := FALSE then

r := r + LT(p);
p := p − LT(p);

16 return q1, . . . , qs, r

Algoritmo 4: O algoritmo da Pseudodivisão em K[x1, . . . , xn]

Como podemos observar nas linhas 2, 3, 7, 9 e 15, a variável p representa o dividendo
nos seus diferentes estágios da divisão, enquanto que r é o resto que (possivelmente) vai se
acumulando cada vez que nenhum dos LT(fi) divide LT(p) (linhas 1,13 e 14). A variável boleana
“ocorreudivisão” é iniciada como FALSE e muda para TRUE quando ocorreu uma divisão, isto
é, algum dos LT(fi) divide LT(p). Dentro do loop principal, iniciado na linha 6, somente duas
coisas podem acontecer: Ocorrer uma divisão, no caso em que algum dos LT(fi) divide LT(p),
ou, não ocorrer uma divisão, no caso em que nenhum dos LT(fi) dividir LT(p). Neste caso, o
resto r é acrescido de LT(p) enquanto o dividendo p é subtraído de LT(p).

Para mostrar que o algoritmo funciona mostraremos que em todos estágios de sua

execução vale

f = q1f1 + ... + qsfs + p + r

(3.3)

49

Para os valores iniciais q1 = 0, . . . , qs = 0, r = 0 e p = f a relação (3.3) é óbvia. Agora suponha
que estamos num determinado estágio do algoritmo com a a relação (3.3) válida. Se o próximo
passo for o de divisão, é porque algum dos LT(fi) divide LT(p). Então

qifi + p = (qi + LT(p)/ LT(fi))fi + (p − (LT(p)/ LT(fi))fi)

e assim qifi + p não muda e assim a relação (3.3) continua válida. Se for o caso em que nenhum
dos LT(fi) dividir LT(p) o resto r e p mudam porém a soma r + p não muda pois adicionamos
LT(p) à r e subtraímos LT(p) de p. Dessa maneira a relação (3.3) continua válida. O algoritmo
pára quando p = 0 e nessa situação a relação (3.3) se torna

f = q1f1 + ... + qsfs + r

Além disso, por construção, é claro que no ﬁnal do processo de divisão teremos r = 0

ou que nenhum dos termos de r é divisível por algum LT(fi)

Para mostrar que o algoritmo, em algum momento, tem que terminar, basta mostrar que
p sempre diminui o seu multigrau ou que p se torna nulo. De fato, se no processo de divisão, for
possível dividir, p se tornará p(cid:48) = p − LT(p)/ LT(fi))fi. Mas como sabemos, o grau do produto
de polinômios é a soma dos graus dos polinômios então

LT

(cid:18) LT(p)
LT(fi)

(cid:19)

fi

=

LT(p)
LT(fi)

LT(fi) = LT(p)

Como p e LT(p)/ LT(fi))fi tem os termos líderes iguais então a sua diferença p(cid:48) tem

que ter multigrau menor quando p(cid:48) (cid:54)= 0.

Por outro lado, se no processo de divisão não for possível dividir, então p(cid:48) = p − LT(p).
Assim temos que ter multideg(p(cid:48)) < multideg(p) quando p(cid:48)
(cid:54)= 0. Em qualquer um dos dois
casos o multigrau sempre diminui. Se o algoritmo nunca terminasse, teríamos uma sequência
inﬁnita decrescente de multigraus, um absurdo pelo princípio da boa ordenação para ordens
monomiais. Então p se torna nulo num número ﬁnito de passos do algoritmo.

Apesar de termos um algoritmo de pseudodivisão para polinômios em K[x1, . . . , xn],
este ainda não satisfaz a importante propriedade do algoritmo da divisão. Já vimos que ao trocar
a ordem monomial o resto pode mudar, como no exemplo (20). Mesmo usando a mesma ordem
monomial, podem-se obter restos distintos. Vamos ilustrar este fato no próximo exemplo.

Exemplo 21. Sejam f = y2x − x, g = y2 − x e h = xy − y. Usando a ordem lexicográﬁca
graduada, se enumerarmos f1 = g e f2 = h, então, aplicando o algoritmo da pseudodivisão,
teremos f = xf1+0·f2+(x2−x), mas se enumerarmos f1 = h e f2 = g teremos f = yf1+1·f2.

f = (cid:80)s

Esse exemplo mostra que, se ao aplicarmos o algoritmo da divisão obtemos r = 0, então
i=1 aifi, isto é, f ∈ (cid:104)f1, . . . , fs(cid:105). Porém se f = (cid:80)s
i=1 qifi + r com r (cid:54)= 0, então não

podemos aﬁrmar que f /∈ (cid:104)f1, . . . , fs(cid:105), uma vez que o algoritmo não garante a unicidade do
resto. Desse modo, o algoritmo da Pseudodivisão apresentado no teorema acima não é uma
generalização perfeita do algoritmo da divisão para polinômios em uma indeterminada. No
entanto, na Proposição 9, veremos que existe um tipo particular de ideal I ⊂ K[x1, . . . , xn] em
que veriﬁcaremos facilmente quando um dado polinômio f ∈ K[x1, . . . , xn] pertence ou não a I.

50

4 SISTEMAS POLINOMIAIS

51

Muitas das aplicações práticas das Bases de Gröbner recaem na resolução de sistemas
polinomiais, como é o caso da resolução de sudokus, coloração de grafos, quebra de sistemas
criptográﬁcos, dentre muitos outros. Neste capítulo, apresentaremos qual é a vantagem de usar
essas bases para resolver esses complicados sistemas.

4.1 Sistemas Polinomiais em Várias Indeterminadas

Uma das mais importantes aplicações para as Bases de Gröbner, é a resolução de Sistemas
Polinomiais em Várias Variáveis. Para entender este uso das Bases de Gröbner, é importante
observar que um ideal polinomial tem uma relação muito importante com um sistema de
equações polinomiais. Sejam f1, . . . , fs e g1, . . . , gt bases de um mesmo ideal I ⊂ K[x1, . . . , xn].
Consideremos os sistemas de equações associados a cada conjunto gerador:






f1(x1, . . . , xn) = 0

f2(x1, . . . , xn) = 0

. . .

fs(x1, . . . , xn) = 0






g1(x1, . . . , xn) = 0

g2(x1, . . . , xn) = 0

. . .

gt(x1, . . . , xn) = 0

Como por hipótese (cid:104)f1, . . . , fs(cid:105) = I = (cid:104)g1, . . . , gt(cid:105), podemos escrever cada gj como

combinação dos fi’s, isto é,

gj =

(cid:88)

i

cj,ifi, para 1 ≤ j ≤ t

Analogamente, cada fi pode ser escrito como combinação dos gj’s.

fi =

(cid:88)

j

di,jgj, para 1 ≤ i ≤ s

Dessa forma, se temos (a1, . . . , an) ∈ Cn tal que fi(a1, . . . , an) = 0 para 1 ≤ i ≤ s então

gj(a1, . . . , an) =

(cid:88)

i

cj,ifi(a1, . . . , an) = 0, para 1 ≤ j ≤ t

Concluímos que se (a1, . . . , an) é solução do sistema de equações formado pelos polinômios
gj’s, então (a1, . . . , an) é solução do sistema formado pelos polinômios fi’s.

Analogamente, prova-se que toda solução do sistema formado pelos fi’s é solução do

sistema formado pelos gj’s.

Em resumo, mostramos que se temos duas bases diferentes para o mesmo ideal I, então

as soluções dos sistemas associados a cada conjunto gerador são as mesmas.

Para ser mais especíﬁco, consideremos o seguinte sistema em C[x, y, z]:


x2 + y2 + z2 − 1 = 0

x2 + y2 + z2 − 2x = 0

2x − 3y − z = 0

52

(A)

Calculando uma base de Gröbner1, usando a ordem lexicográﬁca, para o ideal I = (cid:104)x2 +
y2 + z2 − 1, x2 + y2 + z2 − 2x, 2x − 3y − z(cid:105) obtemos que I pode ser gerado por G =
{2x − 1, 3y + z − 1, 40z2 − 8z − 23}. Isto signiﬁca que o sistema (B), formado pelos polinômios
dessa nova base G, é equivalente ao sistema inicial (A).





2x − 1 = 0

3y + z − 1 = 0

40z2 − 8z − 23 = 0

(B)

Observemos que o processo de resolução desse sistema equivalente seria muito mais simples
do que o anterior. Poderíamos determinar os valores de z usando a última equação. Depois,
substituindo os valores de z na segunda equação, determinaríamos os valores de y e, por ﬁm,
usando a primeira equação, determinaríamos o valor de x.

A grande questão é que, ao calcularmos uma base de Gröbner usando a ordem lexico-
gráﬁca com x > y > z para o ideal I = (cid:104)x2 + y2 + z2 − 1, x2 + y2 + z2 − 2x, 2x − 3y − z(cid:105),
encontramos uma base G = {2x − 1, 3y + z − 1, 40z2 − 8z − 23} mais simples. Mais especiﬁ-
camente, houve um processo de eliminação de variáveis. Repare que na segunda equação não
há variável x, enquanto que na terceira não há variável x nem y. Este fenômeno foi provocado
pela escolha da ordem lexicográﬁca com x > y > z. Não é uma coincidência que esse processo
se assemelhe ao processo de Eliminação Gaussiana (ou escalonamento) de sistemas lineares.
Na verdade, podemos dizer que o processo de eliminação Gaussiana é um caso particular do
processo de obtenção de uma Base de Gröbner.

Para exempliﬁcar, consideremos o sistema linear abaixo:





x + y + z = 6

2x − 3y + 2z = 2

5x + 2y − z = 6

(C)

Ao calcularmos uma Base de Gröbner, usando a ordem lexicográﬁca com x > y > z, para
o ideal I = (cid:104)x+y+z−6, 2x−3y+2z−2, 5x+2y−z−6(cid:105) obtemos G = {x+y+z−6, y−2, z−3}
que nada mais é do que o sistema (C) escalonado

1 Veremos no capítulo Capítulo 5 como calcular uma Base de Gröbner para um ideal.

53





x + y + z − 6 = 0

y − 2 = 0

z − 3 = 0

O próximo capítulo apresentará os resultados e algoritmos necessários para o cálculo de

uma Base de Gröbner.

5 BASES DE GRÖBNER

54

Neste capítulo apresentaremos a teoria básica das Bases de Gröbner. Algumas demons-

trações foram reservadas para uma leitura posterior no apêndice, seção A.3, da dissertação.

5.1

Ideais Monomiais

Ideais monomiais são a ponte para obter os resultados para Ideais Polinomiais. Nesta
seção apresentaremos o importante Lema de Dickson, que desempenhará papel fundamental na
teoria das Bases de Gröbner.

A proposição a seguir nos ajudará a mostrar que dois ideais são iguais.

Proposição 8. Seja I ⊆ K[x1, . . . , xn] um ideal e f1, . . . , fs ∈ K[x1, . . . , xn], então f1, . . . , fs ∈
I se, e somente se (cid:104)f1, . . . , fs(cid:105) ⊆ I.

Para a demonstração, veja o apêndice seção A.3, na página 91.

Deﬁnição 18. Um ideal I de K[x1, . . . , xn] é dito ideal monomial, se I pode ser gerado por
monômios. Neste caso, escrevemos I = (cid:104)X α : α ∈ A(cid:105) para algum subconjunto A ⊂ Zn
+ (A
pode ser um conjunto inﬁnito).

Exemplo 22.

1. I = Q[x] é monomial, pois em Q[x], I = Q[x] = (cid:104)1, x, x2, x3, . . .(cid:105) = (cid:104)1(cid:105) = (cid:104)x0(cid:105).

2. I = (cid:104)x3y, xy2(cid:105) é ideal monomial.

3. I = (cid:104)x3 + xy4, y2(cid:105) ⊆ Q[x, y] é monomial. Usaremos a proposição (8) para provar que
I = (cid:104)x3, y2(cid:105). De fato,I ⊆ (cid:104)x3, y2(cid:105) pois x3 + xy4 = 1 · (x3) + xy2(y2) e y2 = 1 · (y2) ∈ I.
(cid:104)x3, y2(cid:105) ⊆ I pois x3 = 1 · (x3 + xy4) − xy2 · (y2) ∈ I. Dessa forma temos I = (cid:104)x3, y2(cid:105).

4. I = (cid:104)x3, x2 + x + 1, x − 1(cid:105) ⊆ R[x] é um ideal monomial. Mostraremos que I = R[x] =
(cid:104)1(cid:105). De fato, observe que x3 −1 = (x2 +x+1)(x−1) ∈ I e portanto x3 −(x3 −1) = 1 ∈ I.
Logo I = R[x] = (cid:104)1(cid:105).

5. I = (cid:104)x2 + 1(cid:105) ⊂ R[x] não é monomial. Caso contrário, como todo ideal de R[x] é principal,
deveríamos ter I = (cid:104)xn(cid:105), para algum n ∈ N∗ (já que I (cid:54)= R[x]), isto é, x2 + 1 = h(x)xn,
para algum h(x) ∈ R[x]. Mas isso seria um absurdo, uma vez que x2 + 1 é irredutível em
R[x].

Nos próximos resultados veremos importantes propriedades dos ideais monomiais.

55

Proposição 9. Seja I = (cid:104)X α : α ∈ A(cid:105) um ideal monomial. Então um monômio X β pertence ao
ideal I se e somente se X β é divisível por X α para algum α ∈ A.

Para a demonstração, veja o apêndice seção A.3, na página 91.

Exemplo 23. Consideremos o ideal monomial I = (cid:104)x2y3, x5, x4y2(cid:105) ⊂ K[x, y]. Baseados na
proposição anterior, podemos visualizar os monômios em I como o conjunto de todos os pontos
de coordenadas inteiras da região escura do primeiro quadrante como na Figura 5 a seguir:

Figura 5 – Monômios de um Ideal Monomial

Fonte: O autor

Na Figura 5, cada ponto (p, q) de coordenadas inteiras corresponde a um monômio
xpyq. Por exemplo, qualquer monômio múltiplo de x2y3 pertence a I: x4y4, x5y4, x6y4, . . . são
monômios de I.

Como vimos acima, determinar se um monômio pertence à um ideal monomial é simples.
A próxima proposição fornece uma condição necessária e suﬁciente para que um polinômio
pertença a um ideal monomial.

Proposição 10. Sejam I um ideal monomial de K[x1, . . . , xn] e f ∈ K[x1, . . . , xn]. Então são
equivalentes:

1. f ∈ I

2. todo termo de f está em I

3. f é uma K-combinação linear de monômios em I

Para a demonstração, veja o apêndice seção A.3, na página 91.

pq56

Corolário 2. Dois ideais monomiais são iguais se e somente se eles contém os mesmos monô-
mios.

Demonstração. Se I = J, então I e J possuem os mesmos monômios. Agora, suponhamos que
I e J possuam os mesmos monômios. Então, se f ∈ I, sabemos pela Proposição 10 que f é uma
K-combinação linear de monômios em I, logo é uma K-combinação linear de monômios em
J e portanto f ∈ J. De forma análoga, também podemos concluir que se f ∈ J, então f ∈ I,
provando assim que I = J.

Exemplo 24. O polinômio x4y2 + 7x3y3 + xy5 ∈ (cid:104)x3y, y2(cid:105), uma vez que os monômios x4y2,
x3y3 e xy5 são divisíveis pelo monômio y2 ∈ I.

5.2 Teoria de Gröbner

Nesta seção, vamos solucionar o problema da unicidade do resto não garantida no
Algoritmo da Pseudodivisão. Para isso, vamos provar que todo ideal em K[x1, . . . , xn] possui um
conjunto gerador ﬁnito, de forma que o resto da divisão de qualquer polinômio f ∈ K[x1, . . . , xn]
por tais geradores seja único. Essas bases, que garantem a unicidade do resto, foram nomeadas
Bases de Gröbner por Buchberger em homenagem ao seu orientador Wolfgang Gröbner.

Observe que ﬁxada uma ordem monomial, cada polinômio em K[x1, . . . , xn] possui um

único termo líder, então podemos deﬁnir o ideal dos termos líderes como abaixo.

Deﬁnição 19. Sejam I ⊂ K[x1, . . . , xn] um ideal não nulo e uma ordem monomial estabelecida
em K[x1, . . . , xn].

1. O conjunto dos termos líderes de I é o conjunto,

LT(I) = {cX α : existe f ∈ I com LT(f ) = cX α, c ∈ K, α ∈ Zn

+}

2. Denotaremos por (cid:104)LT(I)(cid:105) o ideal gerado pelos elementos de LT(I).

Observação 1. Se I ⊂ K[x1, . . . , xn] é um ideal diferente de {0}, então (cid:104)LT(I)(cid:105) é um ideal
monomial. De fato, basta notar que LM(g) e LT(g) obtêm-se um do outro pelo produto de uma
constante não nula. Dessa forma o ideal monomial (cid:104)LM(g) : g ∈ I − {0}(cid:105) é igual ao ideal
(cid:104)LT(g) : g ∈ I − {0}(cid:105) = (cid:104)LT(I)(cid:105)

Observe que, se I = (cid:104)f1, . . . , ft(cid:105) então (cid:104)LT(f1), . . . , LT(ft)(cid:105) ⊂ (cid:104)LT(I)(cid:105). Por outro lado,

a inclusão contrária nem sempre é garantida, como mostra o exemplo abaixo.

Exemplo 25. Seja I = (cid:104)f1, f2(cid:105), onde f1 = x3 − 2xy e f2 = x2y − 2y2 + x. Usando a ordem
lexicográﬁca graduada em K[x, y] temos que

x(x2y − 2y2 + x) − y(x3 − 2xy) = x2 ∈ I,

57

e portanto LT(x2) = x2 ∈ (cid:104)LT(I)(cid:105). Mas, x2 não é divisível por x3 = LT(f1) nem por
x2y = LT(f2). Logo pela proposição 10.2, temos que x2 /∈ (cid:104)LT(f1), LT(f2)(cid:105) e, conseqüen-
temente, (cid:104)LT(I)(cid:105) (cid:54)⊂ (cid:104)LT(f1), LT(f2)(cid:105). Adiante, deﬁniremos que se I = (cid:104)f1, . . . , fr(cid:105), com
(cid:104)LT(f1), . . . , LT(fr)(cid:105) = (cid:104)LT(I)(cid:105) então f1, . . . , fr é uma Base de Gröbner para I.

Deﬁnição 20. Fixada uma ordem monomial, um subconjunto G = {g1, . . . , gt} de um ideal I é
dito Base de Gröbner se

(cid:104)LT(I)(cid:105) = (cid:104)LT(g1), . . . , LT(gt)(cid:105)

Equivalentemente, segue da Proposição 10 item 2, que G = {g1, . . . , gt} é base de
Gröbner se, e somente se, o termo líder de qualquer elemento de I é divisível por LT(gi), para
algum 1 ≤ i ≤ t.

Exemplo 26.

1. Se I = (cid:104)X α1, . . . , X αk(cid:105), então G = {X α1, . . . , X αk} é uma Base de Gröbner para I.

2. Se I = (cid:104)x3 − 2xy, x2y − 2y2 + x(cid:105), então G = {x3 − 2xy, x2y − 2y2 + x} não é Base de
Gröbner para I, com relação a ordem lexicográﬁca graduada, pois pelo Exemplo 25, temos
que x2 ∈ I, porém x2 não é divisível por LT(x3 − 2xy) nem por LT(x2y − 2y2 + x).

A pergunta que naturalmente surge é se todo ideal de K[x1, . . . , xn] possui uma Base de

Gröbner. Veremos a seguir que sim.

Lema 2 (Lema de Dickson). Se I um ideal monomial de K[x1, . . . , xn], então existe um conjunto
ﬁnito de monômios que geram I.

Para a demonstração, veja o apêndice seção A.3, na página 92.

O Lema de Dickson permite provarmos que todo ideal de K[x1, . . . , xn] possui uma base
de Gröbner e que todo ideal de K[x1, . . . , xn], não somente os ideais monomiais, possui um
conjunto ﬁnito de geradores.

Proposição 11. Todo ideal não nulo de K[x1, . . . , xn] possui uma Base de Gröbner.

Demonstração. Seja I ⊂ K[x1, . . . , xn] um ideal não nulo. Como (cid:104)LT(I)(cid:105) é ideal monomial,
segue do Lema de Dickson que existem monômios m1, . . . , mt ∈ (cid:104)LT(I)(cid:105) tais que (cid:104)LT(I)(cid:105) =
(cid:104)m1, . . . , mt(cid:105). Escolhendo elementos gi ∈ I tais que LT(gi) = mi, para todo i = 1, . . . , t,
formamos o conjunto G = {g1, . . . , gt}. Assim, se tomarmos f ∈ I qualquer, então LT(f ) ∈
(cid:104)LT(I)(cid:105) e LT(f ) é divisível por algum mi = LT(gi) e portanto G é uma Base de Gröbner para
I conforme visto na deﬁnição 20.

Teorema 4 (Teorema da Base de Hilbert). . Todo ideal I ⊆ K[x1, . . . , xn] possui um conjunto
gerador ﬁnito. Isto é, I = (cid:104)g1, . . . , gt(cid:105) para g1, . . . , gt ∈ I

58

Demonstração. Se I = {0} tomamos como conjunto gerador {0} que é ﬁnito. Se I (cid:54)= {0}, então,
pela Proposição 11, existe {g1, . . . , gt} com gi ∈ I tal que (cid:104)LT(I)(cid:105) = (cid:104)LT(g1), . . . , LT(gt)(cid:105).
Aﬁrmamos que I = (cid:104)g1, . . . , gt(cid:105). De fato:

É claro que (cid:104)g1, . . . , gt(cid:105) ⊂ I pois cada gi está em I. Para provarmos a outra inclusão
considere um polinômio f ∈ I. Dividindo f pela t-upla (g1, . . . , gt) segue, do algoritmo da
Pseudodivisão 3, que f pode ser escrito como

f = a1g1 + . . . + atgt + r

onde ai, r ∈ K[x1, . . . , xn], para 1 ≤ i ≤ t, e r é uma K-combinação linear de monômios
em K[x1, . . . , xn], nenhum deles sendo divisível por LT(gi) para 1 ≤ i ≤ t. Aﬁrmamos que
r = 0. De fato, note que r = f − a1g1 − . . . atgt ∈ I e se r (cid:54)= 0, então LT(r) ∈ (cid:104)LT(I)(cid:105) =
(cid:104)LT(g1), . . . , LT(gt)(cid:105). Mas, pela Proposição 9, segue que LT(r) deve ser divisível por algum
LT(gi), o que contradiz a deﬁnição de resto. Logo r = 0 e f = a1g1 + . . . + atgt ∈ (cid:104)g1, . . . , gt(cid:105).

Observe que o Teorema da Base de Hilbert responde uma questão crucial: todo ideal
I ⊆ K[x1, . . . , xn] possui um conjunto gerador ﬁnito. E mais do que isso, na demonstração
do referido teorema, vimos que se G = {g1, . . . , gt} é uma Base de Gröbner para I, então
I = (cid:104)g1, . . . , gt(cid:105) e, por deﬁnição de Base de Gröbner, (cid:104)LT(I)(cid:105) = (cid:104)LT(g1), . . . , LT(gt)(cid:105). Como
vimos no Exemplo 25 nem todos os geradores de um ideal possuem esta propriedade.

A proposição que se segue mostra que as Bases de Gröbner resolvem o problema do

resto único na pseudodivisão.

Proposição 12. Sejam G = {g1, . . . , gs} uma base de Gröbner para um ideal I ⊂ K[x1, . . . , xn]
e f ∈ K[x1, . . . , xn]. Então existe um único r ∈ K[x1, . . . , xn] com as seguintes propriedades:

(i) Nenhum termo de r é divisível por algum dos LT(g1), . . . , LT(gs).

(ii) Existe g ∈ I tal que f = g + r.

Em particular, r é o resto na divisão de f por g, não importando a ordem em que os elementos
de G são listados, quando usamos o algoritmo da divisão.

Demonstração. Segue do Algoritmo da Divisão que f = a1g1 + · · · + asgs + r, ai, r ∈
K[x1, . . . , xn], onde r satisfaz a condição (i). A condição (ii) pode ser atendida se tomarmos
g = a1g1 + · · · + asgs. Isso mostra a existência de r.

Para provar a unicidade, suponhamos que f = g1 + r1 = g2 + r2 satisfaça as condições
(i) e (ii). Então r2 − r1 = g1 − g2 ∈ I. Se r2 − r1 (cid:54)= 0, temos que LT(r2 − r1) ∈ (cid:104)LT(I)(cid:105) =
(cid:104)LT(g1), . . . , LT(gs)(cid:105) . Pela Proposição 9 segue que LT(r2 − r1) é divisível por algum dos

LT(gi), o que contradiz (i). Desse modo, r2 = r1 e a unicidade está provada. A parte ﬁnal da
proposição segue da unicidade de r.

59

Finalmente, com essa propriedade, somos capazes de saber quando um polinômio per-

tence a um dado ideal polinomial, como mostra o próximo corolário.

Corolário 3. Sejam G = {g1, . . . , gs} uma base de Gröbner para um ideal I ⊂ K[x1, . . . , xn] e
f ∈ K[x1, . . . , xn]. Então f ∈ I se e somente se o resto da pseudodivisão de f por G é zero.

Demonstração. Se o resto é zero, então é claro que f ∈ I. Reciprocamente, dado f ∈ I, temos
f = f + 0 satisfazendo as duas condições da Proposição 12. Assim, 0 é o resto de f na divisão
por G.

5.3 Critério e Algoritmo de Buchberger

O objetivo desta seção é identiﬁcar e construir Bases de Gröbner. Para identiﬁcar e

construir tais bases utilizaremos, respectivamente, o Critério e o Algoritmo de Buchberger.

Por deﬁnição, dado um ideal I ⊂ K[x1, . . . , xn], um conjunto G = {g1, . . . , gs} ⊂ I
é uma Base de Gröbner para I quando (cid:104)LT(g1), . . . , LT(gs)(cid:105) = (cid:104)LT(I)(cid:105). Como sempre vale
a inclusão (cid:104)LT(g1), . . . , LT(gs)(cid:105) ⊂ (cid:104)LT(I)(cid:105), então para veriﬁcar se G = {g1, . . . , gs} é Base
de Gröbner para I, basta veriﬁcar se vale a inclusão (cid:104)LT(I)(cid:105) ⊂ (cid:104)LT(g1), . . . , LT(gs)(cid:105). Como
vimos no Exemplo 25, esta última inclusão pode não ocorrer e, portanto, G não será Base de
Gröbner. Uma forma disso ocorrer é o caso em que numa determinada combinação

aX αgi − bX βgj,

LT(aX αgi) e LT(bX βgj) se cancelam implicando em LT(aX αgi−bX βgj) /∈ (cid:104)LT(g1), . . . , LT(gs)(cid:105)
mas, com LT(aX αgi − bX βgj) ∈ (cid:104)LT(I)(cid:105), uma vez que aX αgi − bX βgj ∈ I. Esses tipos de
cancelamentos são de vital importância para veriﬁcar se um determinado conjunto é uma base
de Gröbner para um ideal. Assim, introduziremos na próxima deﬁnição, um tipo especial de
combinação chamada de S-processo ou S-polinômio.

Deﬁnição 21. Sejam f, g ∈ K[x1, . . . , xn] polinômios não nulos.

Considere multideg(f ) = α, multideg(g) = β e γ = (γ1, . . . , γn), com γi = max{αi, βi}
para cada i ∈ {1, . . . , n}. Chamaremos X γ o mínimo múltiplo comum de LM(f ) e LM(g)
e escreveremos X γ = MMC(LM(f ), LM(g))

O S-processo de f e g é a combinação:

S(f, g) =

X γ
LT(f )

f −

X γ
LT(g)

g

Exemplo 27. Sejam f = x3 − 2xy e g = x2y − 2y2 + x. Usando a ordem lexicográﬁca graduada,
temos X γ = MMC(LM(f ), LM(g)) = MMC(x3, x2y) = x3y ou seja γ = (3, 1). Assim, o
S-processo de f e g é:

60

S(f, g) =

X γ
LT(f )

f −

X γ
LT(g)

g

= x3y

(cid:19)

(cid:18) f
x3 −

g
x2y

= x3y

(cid:19)

(cid:18) yf − xg
x3y

= x3y − 2xy2 − x3y + 2xy2 − x2
= −x2

Observemos que o objetivo do S-processo é cancelar termos líderes entre polinômios. O
próximo lema garante que toda combinação que cancela termos líderes de polinômios de mesmo
multigrau é resultado de um de S-processo.

Lema 3. Considere (cid:31) uma ordem monomial e (cid:80)s
i=1 cifi, com ci ∈ K e multideg(fi) = δ ∈ Zn
+,
para todo i ∈ {1, . . . , s}. Se δ (cid:31) multideg((cid:80)s
i=1 cifi é uma K-combinação
linear de S-processos S(fj, fk) para 1 ≤ j, k ≤ s. Além disso, δ (cid:31) multideg (S(fj, fk)), para
1 ≤ j, k ≤ s.

i=1 cifi), então (cid:80)s

Para a demonstração, veja o apêndice seção A.3, na página 92.

Antes de passarmos aos resultados mais importantes da seção, vejamos uma nova notação

a ser utilizada:

F

Denotareremos f

o resto da pseudodivisão de f pela s-upla ordenada F = (f1, . . . , fs).
Se F é uma base de Gröbner para (cid:104)f1, . . . , fs(cid:105) então, pela Proposição 12, podemos considerar F
como um conjunto sem uma ordem particular.

Exemplo 28. Sejam f = x4y + x3y3 + xy4, F = (xy + y3, x4 + y) e a ordem monomial
lexicográﬁca ﬁxada, então f

= −y6.

F

Teorema 5 (Critério de Buchberger). Seja I = (cid:104)g1, . . . , gs(cid:105) ⊂ K[x1, . . . , xn] um ideal. Então
G = {g1, . . . , gs} é uma Base de Gröbner para I se, e somente se, para todos os pares i (cid:54)= j, o
resto na pseudodivisão de S(gi, gj) por G (com qualquer ordenação) é zero.

Para a demonstração, veja o apêndice seção A.3, na página 93.

O próximo exemplo ilustra a utilização do Critério de Buchberger.

Exemplo 29. Considere o ideal I = (cid:104)y − x2, z − x3(cid:105) ⊂ K[x, y, z]. Aﬁrmamos que G =
{y − x2, z − x3} é uma base de Gröbner com relação a ordem lexicográﬁca com y > z > x. De

61

fato, considere o S-processo

S(y − x2, z − x3) =

yz
y

(y − x2) −

yz
z

(z − x3) = −zx2 + yx3.

Dividindo S(y − x2, z − x3) por (y − x2, z − x3) encontramos:

−zx2 + yx3 = x3(y − x2) + (−x2)(z − x3),

isto é, S(y − x2, z − x3)
para I.

G

= 0. Então, pelo Critério de Buchberger, G é uma base de Gröbner

Antes de passarmos a construção de uma Base de Gröbner para um ideal I, vamos

estabelecer a seguinte notação:

Se G = {f1, . . . , fs} ⊂ K[x1, . . . xn], denotaremos por (cid:104)G(cid:105) e por (cid:104)LT(G)(cid:105) os seguintes

ideais:

(cid:104)G(cid:105) = (cid:104)f1, . . . , fs(cid:105)

(cid:104)LT(G)(cid:105) = (cid:104)LT(f1), . . . , LT(fs)(cid:105) .

Teorema 6 (Algoritmo de Buchberger). Seja I = (cid:104)f1, . . . , fs(cid:105) ⊂ K[x1, . . . xn] um ideal não
nulo. Então uma base de Gröbner para I pode ser construída em número ﬁnito de passos pelo
seguinte algoritmo:

Input: F = (f1, . . . , fs)
Output: Uma base de Gröbner G = (g1, . . . , gs) para I, com F ⊆ G

1 G := F ;

2 repeat

3

4

5

6

G(cid:48) := G;
for Cada par {p, q}, p (cid:54)= q em G(cid:48) do

G(cid:48)

r := S(p, q)
if r (cid:54)= 0 then

;

G := G ∪ {r};

7
8 until G = G(cid:48);
9 return G

Algoritmo 5: O algoritmo de Buchberger

Demonstração. Começaremos mostrando que G ⊂ I em todas as etapas do algoritmo. Isto
é verdade inicialmente, pois G = F ⊂ I. No ﬁm de cada passo, aumentamos o conjunto G
adicionando o resto r = S(p, q)
com p, q ∈ G. Assim, se G ⊂ I, então p, q ∈ I e, portanto
S(p, q) ∈ I. Como dividimos S(p, q) por G(cid:48) ⊂ I, então G ∪ {r} ⊂ I.

G(cid:48)

Observamos que, no ﬁnal da execução do algoritmo, G gera I, pois F ⊂ G. Além disso,
= 0, para todo p, q ∈ G. Com isto, o

o algoritmo termina quando G = G(cid:48), isto é, S(p, q)
Critério de Buchberger garante que G é uma base de Gröbner para I.

G(cid:48)

62

Finalmente, devemos provar que o algoritmo termina. Para isso, precisamos observar o
conjunto G após cada iteração. Note que o conjunto G consiste de G(cid:48) (o antigo G) unido com os
restos não nulos dos S-processos dos elementos de G(cid:48). Como G(cid:48) ⊂ G, temos que:

(cid:104)LT(G(cid:48))(cid:105) ⊂ (cid:104)LT(G)(cid:105) .

Agora, considere a aﬁrmação: se G (cid:54)= G(cid:48), então (cid:104)LT(G(cid:48))(cid:105) é estritamente menor que
(cid:104)LT(G)(cid:105). De fato, suponha que um resto não nulo r de um S-processo foi adicionado a G(cid:48)
formando G. Como r é um resto na divisão por G(cid:48), LT(r) não é divisível pelos termos líderes dos
elementos de G(cid:48), e assim, LT(r) /∈ (cid:104)LT(G(cid:48))(cid:105). Mas, LT(r) ∈ (cid:104)LT(G)(cid:105), o que prova a aﬁrmação.

Assim, se o algoritmo não termina, os ideais (cid:104)LT(G(cid:48))(cid:105) das sucessivas iterações do
algoritmo formam uma cadeia ascendente de ideais monomiais distintos em K[x1, . . . , xn].
Como, pelo Lema de Dickson, todo ideal monomial é ﬁnitamente gerado, então a cadeia
construída estaciona, ou seja, (cid:104)LT(G(cid:48))(cid:105) = (cid:104)LT(G)(cid:105) após certo número ﬁnito de iterações. Logo,
pela aﬁrmação do parágrafo anterior, isso implica em G(cid:48) = G, ou seja, o algoritmo termina.

Exemplo 30. Calcular uma base de Gröbner para o ideal I = (cid:104)2x2 + 3y2 − 11, x2 − y2 − 3(cid:105) ⊂
Q[x, y] usando a ordem lexicográﬁca.

Utilizando o algoritmo de Buchberger, temos:

F = (f1, f2) = (2x2 + 3y2 − 11, x2 − y2 − 3)

G = (f1, f2)

G(cid:48)

S

(f1, f2)

S = S(f1, f2)

G(cid:48)

= y2 − 1

(f1, f2, f3) S =





G(cid:48)

G(cid:48)

G(cid:48)

S(f1, f2)

S(f1, f3)

S(f2, f3)

= 0

= 0

= 0

G
(f1, f2, f3) =
(2x2 + 3y2 − 11, x2 − y2 − 3, y2 − 1)

G = G(cid:48)

Falso

(f1, f2, f3) =
(2x2 + 3y2 − 11, x2 − y2 − 3, y2 − 1)

Verdadeiro

Nessa disposição, cada coluna possui os valores assumidos pelas variáveis do algoritmo
em cada iteração. Em especial, a última coluna corresponde a condição de parada do algoritmo.
Quando G = G(cid:48) é verdadeiro, concluímos que o algoritmo termina e que temos como saída uma
base de Gröbner G = {2x2 + 3y2 − 11, x2 − y2 − 3, y2 − 1} para o ideal I.

Ao construírmos bases de Gröbner, freqüentemente encontramos conjunto de geradores
muito grandes. Podemos eliminar alguns elementos desnecessários desse conjunto de acordo
com a próxima proposição.

63

Proposição 13. Sejam G uma base de Gröbner para um ideal I ⊂ K[x1, . . . xn] e p ∈ G um
polinômio tal que LT(p) ∈ (cid:104)LT(G − {p})(cid:105). Então G − {p} também é uma base de Gröbner
para I.

Demonstração. Sabemos que (cid:104)LT(G)(cid:105) = (cid:104)LT(I)(cid:105). Se LT(p) ∈ (cid:104)LT(G − {p})(cid:105), então (cid:104)LT(G)(cid:105) =
(cid:104)LT(G − {p})(cid:105) e, portanto, (cid:104)LT(G − {p})(cid:105) é base de Gröbner para I.

Com esta proposição, podemos deﬁnir uma base de Gröbner mais simples como se segue:

Deﬁnição 22. Uma base de Gröbner G para um ideal polinomial I é dita mínima quando:

1. LC(p) = 1, ∀p ∈ G

2. LT(p) /∈ (cid:104)LT(G − {p})(cid:105) , ∀p ∈ G

Podemos construir uma base de Gröbner mínima para um ideal não nulo, aplicando o

algoritmo de Buchberger e a Proposição 13. Vejamos um exemplo.

Exemplo 31. Vamos calcular uma base de Gröbner mínima para o ideal do exemplo 30: Com
I = (cid:104)2x2 + 3y2 − 11, x2 − y2 − 3(cid:105), obtemos uma base de Gröbner para a ordem lexicográﬁca
G = {2x2 + 3y2 − 11, x2 − y2 − 3, y2 − 1}.

Agora, fazendo p1 = 2x2 + 3y2 − 11, temos LT(p1) = 2x2 e observe que LT(p1) =
2x2 ∈ (cid:104)x2, y2(cid:105) = (cid:104)LT(G − {p1})(cid:105). Dessa forma podemos remover p1 de G. Continuando,
fazendo p2 = x2 − y2 − 3, temos LT(p2) = x2 e observe que LT(p2) = x2 /∈ (cid:104)y2(cid:105). Finalmente,
fazendo p3 = y2 − 1, temos LT(p3) = y2 e observe que LT(p3) = y2 /∈ (cid:104)x2(cid:105). Assim o conjunto
G = {x2 − y2 − 3, y2 − 1} de acordo com a Deﬁnição 22, é base de Gröbner mínima para I.

Podemos ter eventualmente várias bases de Gröbner mínimas distintas. Isto é facilmente

veriﬁcado, como mostra o próximo exemplo.

Exemplo 32. No Exemplo 31, podíamos ter removido p2 ao invés de p1 e assim obter uma outra
base de Gröbner mínima: {x2 + 3/2y2 − 11/2, y2 − 1}. Assim, podemos concluir que não existe
uma única base de Gröbner mínima.

Seria muito útil se existisse algum tipo de base de Gröbner unicamente determinada.
Por exemplo, dados dois ideais polinomiais I e J, como saber se eles são iguais? Se houvesse
algum conjunto de geradores para tais ideais unicamente determinados, seria simples resolver
essa questão. A próxima deﬁnição vem responder à questão da unicidade para bases de Gröbner.

Deﬁnição 23. Uma base de Gröbner G para um ideal polinomial I é dita reduzida quando:

1. LC(p) = 1, para todo p ∈ G;

64

2. Nenhum monômio de p pertence (cid:104)LT(G − {p})(cid:105), para todo p ∈ G.

O próximo teorema estabelecerá a unicidade das bases de Gröbner reduzidas. Primeira-

mente, vejamos um lema.

Lema 4. Sejam G e G(cid:48) bases de Gröbner mínimas para o ideal polinomial I ⊂ K[x1, . . . , xn].
Então G e G(cid:48) têm a mesma cardinalidade e LT(G) = LT(G(cid:48)).

Demonstração. Sendo G = {f1, . . . , fs} e G(cid:48) = {g1, . . . , gl} bases de Gröbner mínimas, então
temos que (cid:104)LT(G)(cid:105) = (cid:104)LT(I)(cid:105) = (cid:104)LT(G(cid:48))(cid:105). Assim, se LT(fi) ∈ (cid:104)LT(G(cid:48))(cid:105), temos:

LT(fi) = X α LT(gj),

para algum gj ∈ G(cid:48). Com o mesmo raciocínio obtemos:

LT(gj) = X β LT(fr),

para algum fr ∈ G. Relacionando as duas equações acima encontramos:

LT(fi) = X αX β LT(fr)

(5.1)

(5.2)

Como G é mínima, X αX β = 1 e fi = fr, ou ainda, X α = X β = 1 e fi = fr. De (5.1)
temos LT(fi) = LT(gj), provando assim que LT(G) ⊂ LT(G(cid:48)). De modo análogo, temos que
LT(G(cid:48)) ⊂ LT(G), o conclui a demonstração.

Teorema 7. Seja I (cid:54)= {0} um ideal polinomial. Então, dada uma ordem monomial, I possui
uma única base de Gröbner reduzida.

Para a demonstração, veja o apêndice seção A.3, na página 95.

A demonstração do Teorema 7, mostra como calcular a base de Gröbner reduzida a
partir de uma base mínima. Dada uma base mínima G = {g1, g2, . . . , gt} a ideia é dividir
g1 por G − {g1} obtendo o resto g(cid:48)
1 na base,
que agora denotaremos por G(cid:48). Seguindo, repetiríamos o processo, agora com g2. Calculamos
g(cid:48)
2 obtendo uma nova base G(cid:48)(cid:48). Ao terminar esse processo
2 = g2
com cada um dos gi’s, teremos uma base de Gröbner reduzida.

(G−{g1}). Depois, substituímos g1 por g(cid:48)

(G(cid:48)−{g2}) e trocamos g2 por g(cid:48)

1 = g1

Exemplo 33. Considere I = (cid:104)2x2 + 3y2 − 11, x2 − y2 − 3(cid:105) ⊂ Q[x, y]. Utilizando a ordem
lexicográﬁca, segue do exemplo 31 que G = {x2 − y2 − 3, y2 − 1} é uma base de Gröbner
G(cid:48)−{g1} = x2 − 4 e, assim obtemos
mínima para I. Fazendo g1 = x2 − y2 − 3, temos que g1
G(cid:48)−{g2} = y2 − 1,
G(cid:48) = {x2 − 4, y2 − 1}. Finalmente, fazendo g2 = y2 − 1, temos que g2
e, pela demonstração do Teorema 7, temos que G(cid:48)(cid:48) = {x2 − 4, y2 − 1} é uma base de Gröbner
reduzida para I já que agora todos os termos foram reduzidos.

(cid:48) = g1

(cid:48) = g2

Finalmente, temos todas as ferramentas para tratar o nosso problema aplicado. No
próximo capítulo apresentaremos um “curso básico” do software CoCoA, para que possamos
aplicar nossos conhecimentos algébricos para resolver sistemas polinomiais muito complexos.

65

6 O SOFTWARE COCOA

66

Como vimos no capítulo anterior, o processo de obtenção de uma base de Gröbner toma
muito tempo mesmo nos exemplos mais fáceis. Por esse motivo, nesta seção apresentaremos
uma introdução ao sistema de computação algébrica CoCoA, que facilitará todos os cálculos
relativos à essas bases. A referência utilizada é o próprio manual que se encontra no site oﬁcial.1.

CoCoA é um acrônimo para “Computations in Commutative Algebra”. Este software
é gratuito para ﬁns educacionais e pesquisa. Basicamente efetua cálculos com polinômios de
várias variáveis. Usaremos o CoCoA para efetuar cálculos com bases de Gröbner . A versão que
usaremos será a 4.7.5 (Windows) que possui uma interface gráﬁca.

6.1

Instalação no Windows

Observe na (Figura 6), a página principal do site do CoCoA

(<http:// cocoa.dima.unige.it/ )> com a sua divisão em 9 blocos principais. Para descarregar o
arquivo, basta clicar no segundo bloco da primeira coluna, no link “CoCoA-4.7.5 old system
(2009)”. Na página aberta, procure pela versão MSWindows “CoCoA-4.7.5 (7.5M)”. Clicando
neste link, o navegador fará o download do arquivo compactado em formato compactado de
extensão .zip. Depois, basta extrair os arquivos para uma pasta do seu computador. Para iniciar o
programa, basta executar o arquivo cocoaqt.exe que está localizado pasta raiz do programa.

Figura 6 – Página principal do CoCoA

Fonte: Print Screen da página principal do CoCoA. Disponível em: http://cocoa.dima.unige.it/.
Acesso em: 5 fev. 2019

1 Neste trabalho, utilizamos a versão 4.7.5 cujo manual se encontra em <http://cocoa.dima.unige.it/download/doc/

GUI_help/toc.html>

67

6.2

Interface e Alguns Comandos

A interface gráﬁca do CoCoA é dividida em duas partes: Na superior, temos os resultados

que obtemos a partir dos comandos inseridos na inferior, como na Figura 7.

Figura 7 – Tela principal do CoCoA

Fonte: Print Screen da interface do CoCoA 4.7.5

Execute o CoCoA e digite na parte inferior:

1+1;

com o cursor nesta linha pressione CRTL+ENTER. Você terá na tela superior como resultado
deste comando:

1+1;
-----------------
2

Todos os comandos do CoCoA devem ser terminados por um ponto e vírgula. Por

exemplo, escreva a sequência de comandos a seguir:

68

A:=2*5;
B:=3;
A+B;
A/B;
A^B;
Fact(B);
Mod(A,B);

Nesta sequência, observe que usamos o comando de atribuição :=, desta forma, atribuímos
a variável A, o valor 2*5=10, e a variável B, o valor 3. Para executar todas essas linhas de
comandos, selecione todas as linhas e pressione CRTL+ENTER. O resultado obtido na parte
superior será:

A:=2*5;
B:=3;
A+B;
A/B;
A^B;
Fact(B);
Mod(A,B);
13
-------------------------------
10/3
-------------------------------
1000
-------------------------------
6
-------------------------------
1
-------------------------------

Além do uso do comando :=, também usamos os comandos *,+,/,∧, Fact e Mod. Estes comandos
respectivamente efetuam: multiplicação, adição, divisão, exponenciação, cálculo do fatorial
de um número e o cálculo do resto da divisão de dois números. É importante observar que as
variáveis que guardam resultados efetuados pelo CoCoA sempre tem que ser maiúsculas, assim
também as funções (Fact, Mod etc). Para ilustrar isso, execute os comandos abaixo:

A:=8;

69

fact(A);
Fact(A);
b:=4;
B:=4;
Fact(B);

O Resultado obtido é:

A:=8;
fact(A);
Fact(A);
b:=4;
B:=4;
Fact(B);
ERROR: Undefined indeterminate f
CONTEXT: f * a * c * t * (A)
-------------------------------
40320
-------------------------------
ERROR: parse error in line 4 of device
-------------------------------
4
-------------------------------
24
-------------------------------

Observe que o CoCoA não aceitou o comando fact(A); pois a função está iniciada por letra mi-
núscula. Da mesma forma ao tentar armazenar o valor 4 na variável b (minúscula) é apresentado
um erro.

6.3 Polinômios no CoCoA

Os comandos LC, LT, LM e Deg retornam respectivamente o coeﬁciente líder, o monômio
líder, o termo líder e o grau de um polinômio. É importante observar que no CoCoA, as deﬁnições
de termo líder e monômio líder diferem das usadas neste trabalho. Note abaixo que ao usar o
comando LT(F) onde F = 3x5 + 7x2 − 3x + 1, é retornado apenas x5, enquanto que ao usar o
comando LM(F), é retornado 3x5.

Use R ::= QQ[x];-- Usa o anel Q[x]
F := 3x^5+7x^2-3x+1;--Polinômio atribuído à variável F

70

LC(F);
3
-------------------------------
LT(F);
x^5
-------------------------------
LM(F);
3x^5
-------------------------------
Deg(F);
5
-------------------------------

Na primeira linha desse exemplo, tudo o que vem depois dos dois traços seguidos: – é ignorado
pelo CoCoA. Este comando permite que façamos comentários nas linhas de programação.

Para dividir dois polinômios no CoCoA usamos o comando DivAlg. Por exemplo:

Use R ::= QQ[x];-- Usa o anel Q[x]
F := 3x^5+16x^3+x^2-10x+9;--Dividendo
G := [x^2+6];-- Lista com os polinomios Divisores
DivAlg(F,G);-- Comando para dividir F por G
-------------------------------
Record[Quotients := [3x^3 - 2x + 1], Remainder := 2x + 3]

O Comando DivAlg retorna um RECORD com dois campos: Quotients - uma lista com

os quocientes e Remainder - O resto da divisão ou pseudodivisão como no exemplo abaixo:

Use R ::= QQ[x,y], Lex; -- Especifica o uso da ordem lexicográfica
F:=x^2y^2+x+y;
G:=x+y;
H:=xy+y^2;

DivAlg(F,[G,H]);
Record[Quotients := [xy^2 - y^3 + 1, 0], Remainder := y^4]
-------------------------------

No exemplo acima, depois do comando Use, onde informamos o anel em que queremos efetuar
os cálculos, também especiﬁcamos qual ordem monomial queremos usar. Algumas opções
possíveis são: Lex (lexicográﬁca), DegLex (lexicográﬁca graduada), DegRevLex (Lexicográﬁca
Graduada Reversa) que é a ordem usada por padrão.

Para calcular o MDC de dois polinômios F e G usamos o comando GCD(F, G); No
exemplo abaixo estamos calculando o MDC(f, g) com f = x2−4 = (x+2)(x−2) e g = (x−2)3

71

Use R ::= QQ[x];
F := x^2-4;
G := (x-2)^3;
GCD(F, G);
-------------------------------
x-2

Para veriﬁcar se um polinômio pertence à um ideal usamos o comando IsIn. O comando

Ideal(F,G), cria o ideal gerado pelos polinômios F e G.

Use R ::= QQ[x];
F := x^3;
I := Ideal(x^6-1,x^4-1);
F IsIn I; --Verifica se F pertence à I
(retorna um valor boleano True False)
-------------------------------
False

O exemplo abaixo, mostra que o Algoritmo da PseudoDivisão não goza da unicidade do

resto.

Use R ::= QQ[x,y], DegLex; --muda para ordem Lexicográfica Graduada
F:=y^2x-x;
D:=[y^2-x,xy-y];
E:=[xy-y,y^2-x];
DivAlg(F,D);
-------------------------------
Record[ Quotients := [x,0], Remainder:= x^2 - x]
DivAlg(F,E);
-------------------------------
Record[ Quotients := [y,1], Remainder := 0]

Com o CoCoA podemos calcular bases de Gröbner interativamente como se segue:

Use R ::= QQ[x,y], Lex;
I:=Ideal([2x^2+3y^2-11,x^2-y^2-3]);
$gb.Start_GBasis(I); -- inicia o cálculo da Base de Grobner
I.GBasis; -- inicialmente a Base está vazia

72

-------------------------------
Null
$gb.Steps(I,1); -- uma etapa do cálculo da Base de Grobner
I.GBasis;
-------------------------------
[x^2 - y^2 - 3]
$gb.Complete(I); -- cálculo completo
I.GBasis;
-------------------------------
[

2x^2 + 3y^2 - 11,-5/2y^2 + 5/2]

Para calcular uma base de Gröbner reduzida para um ideal I, usamos o comando Redu-

cedGBasis(I).

Use R ::= QQ[x,y], Lex;
I:=Ideal([2x^2+3y^2-11,x^2-y^2-3]);
ReducedGBasis(I);
-------------------------------
[y^2 - 1, x^2 - 4]

7 APLICAÇÃO DAS BASES DE GRÖBNER NA RESOLUÇÃO DE UM SHIDOKU

73

Neste capítulo mostraremos que a resolução algébrica de um Shidoku está associada à
resolução de um sistema polinomial de várias indeterminadas com mais de 40 equações. Desse
modo, utilizaremos as Bases de Gröbner para transformar esse sistema em outro equivalente,
cuja resolução será muito mais simples. Nesse caso, o uso das Bases de Gröbner vai atuar de
forma semelhante à eliminação gaussiana dos sistemas lineares. O software CoCoA, estudado no
capítulo 6, será o meio pelo qual conseguiremos efetuar os cálculos extremamente complicados
que surgem nessa aplicação.

Iniciaremos este capítulo apresentando o quebra-cabeças Sudoku e sua versão reduzida,
o Shidoku. Depois de entendidas as regras desses quebra-cabeças, modelaremos algebricamente
o Shidoku como um sistema de equações polinomiais com mais de 40 equações e 16 incógnitas.
Como vimos no Capítulo 4, podemos relacionar esse sistema polinomial com um ideal I, e então
calculando uma base de Gröbner para I, obteremos um sistema equivalente ao original, mas num
formato muito mais simples de se resolver. O uso do CoCoA atua na obtenção dessa base, uma
vez que obtê-la com o Algoritmo de Buchberger é um processo muito trabalhoso até mesmo
nos exemplos mais simples. Além disso, usaremos técnicas básicas de programação para não
precisar inserir manualmente os mais de 40 polinômios que compõem esse referido sistema.

7.1 O que é um Sudoku?

O Sudoku é um popular quebra-cabeças, ﬁgurando em muitos jornais, revistas e até em
aplicativos de celular. Segundo Hayes (2006), as aparições mais antigas conhecidas remontam
ao ano de 1979 numa revista americana entitulada Dell Pencil Puzzles e Word Games, onde
o jogo era conhecido por Number Place. Porém, no ﬁnal do século XIX, na França, vários
jornais e revistas publicavam jogos que eram muito próximos ao Sudoku como conhecemos hoje.
(BOYER, 2007). A palavra Sudoku tem sua origem do japonês Su, que signiﬁca número e Doku,
que signiﬁca sozinho. (HAYES, 2006).

O tradicional quebra-cabeças é composto por uma grade com 9 linhas e 9 colunas,
subdividida em 9 blocos de tamanho 3x3. O desaﬁo consiste em preencher as células vazias
com os dígitos de 1 a 9 de tal maneira que cada linha, coluna e bloco 3x3 contenha cada dígito
exatamente uma vez. Na ﬁgura Figura 8 temos um exemplo de um Sudoku com 28 células já
preenchidas. Chamaremos de valores iniciais, os dígitos dessas células preenchidas.

7.2 O que é um Shidoku?

O Shidoku é uma versão 4x4 do Sudoku que conhecemos. Isto é, temos uma grade com
4 linhas e 4 colunas, subdividida em 4 blocos de tamanho 2x2, como na Figura 9. Chamamos

Figura 8 – Um Sudoku

74

2 5

1

4

7

5 2

1

8

3

4

9

2

9 8 1

3

3 6

7 2

4

7

3

4

9

3

6

Fonte: O autor

de região, qualquer linha, coluna ou cada um dos quatro blocos 2x2 da grade. As células vazias
devem ser preenchidas com os dígitos de 1 a 4 de tal maneira que cada linha, coluna e bloco 2x2
contenha cada dígito uma única vez. A Figura 9 mostra um exemplo de Shidoku.

Figura 9 – Um Shidoku

1

4

2

3

Fonte: O autor

7.3 Representando um Shidoku usando polinômios

Baseados em Arnold, Lucas e Taalman (2010), apresentaremos uma modelagem do
Shidoku por meio de polinômios. Considere o quadro abaixo com as 16 células de um Shidoku.
Usaremos a notação xi,j, com 1 ≤ i, j ≤ 4 para representar o dígito que ocupa a célula que está
na linha i e coluna j. Pelas regras do jogo, em qualquer região temos sempre os dígitos 1, 2, 3, 4
presentes uma única vez.

Figura 10 – Modelando um Shidoku

75

x1,1 x1,2 x1,3 x1,4

x2,1 x2,2 x2,3 x2,4

x3,1 x3,2 x3,3 x3,4

x4,1 x4,2 x4,3 x4,4

Fonte: O autor

Inicialmente, podemos notar que cada uma das células xi,j é um dígito escolhido entre 1,

2, 3 ou 4, portanto temos:

(xi,j − 1)(xi,j − 2)(xi,j − 3)(xi,j − 4) = 0

i,j − 10x3
x4

i,j + 35x2

i,j − 50xi,j + 24 = 0

para todo 1 ≤ i, j ≤ 4, totalizando 16 equações. Por exemplo, a equação (x1,1 − 1)(x1,1 −
2)(x1,1 − 3)(x1,1 − 4) = 0 modela o fato de que x1,1 ∈ {1, 2, 3, 4}.

Além disso, em cada região, o produto das 4 incógnitas tem que ser 1 × 2 × 3 × 4 = 24,

portanto se chamarmos as incógnitas de a, b, c, d, temos que ter:

abcd − 24 = 0

Por exemplo, considerando a primeira linha, teremos a equação x1,1x1,2x1,3x1,4 − 24 = 0.
Se considerarmos a segunda coluna, teremos a equação x1,2x2,2x3,2x4,2 − 24 = 0. Por ﬁm,
considerando o bloco inferior direito, teremos a equação x3,3x3,4x4,3x4,4 − 24 = 0. Como temos
4 linhas, 4 colunas e 4 blocos, isso acrescenta 12 equações às 16 já existentes.

Por ﬁm, se a, b, c, d são elementos de uma região, então a sua soma tem que resultar em

1 + 2 + 3 + 4 = 10. Assim temos mais 12 equações da forma

a + b + c + d − 10 = 0

Por exemplo, considerando a terceira linha, teremos a equação x3,1 + x3,2 + x3,3 + x3,4 −
10 = 0. Se considerarmos a segunda coluna, teremos a equação x1,2 + x2,2 + x3,2 + x4,2 − 10 = 0.
Por ﬁm, considerando o bloco inferior esquerdo, teremos a equação x3,1 +x3,2 +x4,1 +x4,2 −10 =
0.

Com essa modelagem, obtemos um total de 16 + 12 + 12 = 40 equações, que é geral

para qualquer Shidoku.

Agora, considerando os valores iniciais apresentados, outras equações serão acrescenta-

das ao sistema.

Relembrando o Shidoku que propusemos no início Nesse caso teríamos que acrescentar

Figura 11 – O Shidoku proposto

76

1

4

2

3

Fonte: O autor

ao sistema as equações:

x2,3 − 1 = 0, x3,1 − 4 = 0, x4,2 − 2 = 0, x4,4 − 3 = 0

Temos agora a modelagem completa do Shidoku proposto. O sistema possui 16 indeter-
minadas e 44 equações. Na próxima seção, iremos implementar no CoCoA o cálculo da base de
Gröbner associada à esse sistema. Além disso, exibiremos o sistema equivalente gerado a partir
dessa base.

7.4 Programando para resolver um Shidoku

Para implementar a obtenção da base de Gröbner Reduzida no CoCoA, precisaremos
criar um ideal I com os 44 polinômios que formam o sistema associado ao Shidoku proposto e
posteriormente calcularemos uma base de Gröbner reduzida para I. Dessa maneira, como vimos
no capítulo 4, transformaremos o complexo sistema de 44 equações num sistema muito mais
simples de resolver. No que se segue, comentaremos passo a passo toda a programação envolvida:
Criaremos um método para automatizar a tediosa inserção manual dos mais de 40 polinômios
que modelam o nosso quebra-cabeças e também apresentaremos alguns novos comandos do
CoCoA ao longo do processo de implementação.

Inicialmente devemos deﬁnir o anel onde efetuaremos os cálculos. Isto é feito usando o

comando Use.

Use R ::= QQ[x[1..4,1..4]];

77

Neste caso estamos criando um anel de 16 indeterminadas Q[x(1,1), x(1,2), x(1,3), . . . , x(4,4)] e
usando a ordem monomial padrão do CoCoA: A ordem Lexicográﬁca Graduada Reversa “GRE-
VLEX”. Observe que x[1..4,1..4] faz todas as combinações possíveis de x(i,j) com i, j variando
de 1 à 4.

Agora, usaremos técnicas básicas de programação para evitar que tenhamos que escrever
manualmente as 44 equações na tela de entrada do CoCoA. Usamos o código C:=NewMat(4,4)
para criar uma matriz 4x4 e atribuí-la a variável C. Essa matriz guardará os 16 polinômios
referentes às 16 células do Shidoku. Depois temos um comando de repetição chamado For.
Por meio dessa estrutura, podemos criar várias equações de forma automática. Observe que o
primeiro For faz variar o índice i de 1 à 4 enquanto o segundo, que está dentro do primeiro, faz
variar o índice j de 1 à 4. Quando i = 1 e j = 1 construímos o polinômio

C[1, 1] = (x[1, 1] − 1)(x[1, 1] − 2)(x[1, 1] − 3)(x[1, 1] − 4);

que ocupa a primeira linha e primeira coluna da matriz C. Na próxima iteração desse duplo For,
teremos i = 1 e j = 2, assim cria-se

C[1, 2] = (x[1, 2] − 1)(x[1, 2] − 2)(x[1, 2] − 3)(x[1, 2] − 4);

e assim sucessivamente. Ao ﬁnal das iterações, teremos os 16 polinômios (C[I, J] := (x[I, J] −
1)(x[I, J]−2)(x[I, J]−3)(x[I, J]−4)) referentes a cada uma das células do Shidoku preenchidas
na matriz 4x4 C. Usamos o comando Set Indentation para que a formatação dos resultados ﬁque
mais legível.

Set Indentation;
C:=NewMat(4,4);
I:=1;
J:=1;
For I:=1 To 4 Do
For J:=1 To 4 Do
C[I,J]:=(x[I,J]-1)(x[I,J]-2)(x[I,J]-3)(x[I,J]-4);
EndFor;
EndFor;
C;

Depois de executar esse comando junto com o anterior, o resultado será esse:

Use R ::= QQ[x[1..4,1..4]];
Set Indentation;
C:=NewMat(4,4);
I:=1;

78

J:=1;
For I:=1 To 4 Do
For J:=1 To 4 Do
C[I,J]:=(x[I,J]-1)(x[I,J]-2)(x[I,J]-3)(x[I,J]-4);
EndFor;
EndFor;
C;
---------------------------------------
Mat([

[x[1,1]^4 - 10x[1,1]^3 + 35x[1,1]^2 - 50x[1,1] + 24,
x[1,2]^4 - 10x[1,2]^3 + 35x[1,2]^2 - 50x[1,2] + 24,
x[1,3]^4 - 10x[1,3]^3 + 35x[1,3]^2 - 50x[1,3] + 24,
x[1,4]^4 - 10x[1,4]^3 + 35x[1,4]^2 - 50x[1,4] + 24],

[x[2,1]^4 - 10x[2,1]^3 + 35x[2,1]^2 - 50x[2,1] + 24,
x[2,2]^4 - 10x[2,2]^3 + 35x[2,2]^2 - 50x[2,2] + 24,
x[2,3]^4 - 10x[2,3]^3 + 35x[2,3]^2 - 50x[2,3] + 24,
x[2,4]^4 - 10x[2,4]^3 + 35x[2,4]^2 - 50x[2,4] + 24],

[x[3,1]^4 - 10x[3,1]^3 + 35x[3,1]^2 - 50x[3,1] + 24,
x[3,2]^4 - 10x[3,2]^3 + 35x[3,2]^2 - 50x[3,2] + 24,
x[3,3]^4 - 10x[3,3]^3 + 35x[3,3]^2 - 50x[3,3] + 24,
x[3,4]^4 - 10x[3,4]^3 + 35x[3,4]^2 - 50x[3,4] + 24],

[x[4,1]^4 - 10x[4,1]^3 + 35x[4,1]^2 - 50x[4,1] + 24,
x[4,2]^4 - 10x[4,2]^3 + 35x[4,2]^2 - 50x[4,2] + 24,
x[4,3]^4 - 10x[4,3]^3 + 35x[4,3]^2 - 50x[4,3] + 24,
x[4,4]^4 - 10x[4,4]^3 + 35x[4,4]^2 - 50x[4,4] + 24]

])

Depois disso, criamos uma outra matriz L, dessa vez 4x2, para guardar os 8 polinômios
referentes as linhas: Os 4 polinômios referentes a soma 10 e os 4 polinômios referentes ao
produto 24. Para exempliﬁcar, vejamos os exemplos de polinômios para a segunda linha do
Shidoku:

x[2, 1]x[2, 2]x[2, 3]x[2, 4] − 24

Este polinômio modela o produto da linha 2 do Shidoku. Iremos alocar os polinômios referentes
ao produto na primeira coluna de L.

x[2, 1] + x[2, 2] + x[2, 3] + x[2, 4] − 10

Este polinômio modela a soma da linha 2 do Shidoku. Iremos alocar os polinômios referentes à
soma na segunda coluna de L. A programação desta vez é mais simples, pois temos apenas um

For simples que faz variar o índice i de 1 a 4. Abaixo mostramos o código, com o seu respectivo
resultado:

79

L:=NewMat(4,2);

I:=1;

J:=1;

For I:=1 To 4 Do

L[I,1]:=x[I,J]x[I,J+1]x[I,J+2]x[I,J+3]-24;

L[I,2]:=x[I,J]+x[I,J+1]+x[I,J+2]+x[I,J+3]-10;

EndFor;

L;

-------------------------------

Mat([

[x[1,1]x[1,2]x[1,3]x[1,4] - 24, x[1,1] + x[1,2] + x[1,3] + x[1,4] - 10],

[x[2,1]x[2,2]x[2,3]x[2,4] - 24, x[2,1] + x[2,2] + x[2,3] + x[2,4] - 10],

[x[3,1]x[3,2]x[3,3]x[3,4] - 24, x[3,1] + x[3,2] + x[3,3] + x[3,4] - 10],

[x[4,1]x[4,2]x[4,3]x[4,4] - 24, x[4,1] + x[4,2] + x[4,3] + x[4,4] - 10]

])

Nessa parte, criamos uma matrix 2x4 chamada COL que guardará as 8 equações re-
ferentes às colunas. Para exempliﬁcar, vejamos os exemplos de polinômios para a terceira
coluna:

x[1, 3]x[2, 3]x[3, 3]x[4, 3] − 24

Este polinômio modela o produto da coluna 3 do Shidoku. Iremos alocar os polinômios referentes
ao produto na primeira linha da matriz COL.

x[1, 3] + x[2, 3] + x[3, 3] + x[4, 3] − 10

Este polinômio modela a soma da coluna 3 do Shidoku. Iremos alocar os polinômios referentes
à soma na segunda linha da matriz COL.

COL:=NewMat(2,4);

I:=1;

J:=1;

For J:=1 To 4 Do

COL[1,J]:=x[I,J]x[I+1,J]x[I+2,J]x[I+3,J]-24;

COL[2,J]:=x[I,J]+x[I+1,J]+x[I+2,J]+x[I+3,J]-10;

EndFor;

COL;

-------------------------------

Mat([

[x[1,1]x[2,1]x[3,1]x[4,1] - 24,

x[1,2]x[2,2]x[3,2]x[4,2] - 24,

x[1,3]x[2,3]x[3,3]x[4,3] - 24, x[1,4]x[2,4]x[3,4]x[4,4] - 24],

[x[1,1]+x[2,1]+x[3,1]+x[4,1]-10, x[1,2]+x[2,2]+x[3,2]+x[4,2]-10,

x[1,3]+x[2,3]+x[3,3]+x[4,3]-10, x[1,4]+x[2,4]+x[3,4]+x[4,4]-10]

])

80

Faremos o mesmo processo para as condições dos blocos 2x2. Criamos uma matriz BOX
4x4 para guardar as 8 equações. Para exempliﬁcar, vejamos os exemplos de polinômios para o
bloco superior direito do Shidoku:

x[1, 3]x[1, 4]x[2, 3]x[2, 4] − 24

Este polinômio modela o produto do bloco superior direito do Shidoku. Iremos alocar os
polinômios referentes ao produto na primeira linha da matriz BOX.

x[1, 3] + x[1, 4] + x[2, 3] + x[2, 4] − 10

Este polinômio modela a soma do bloco superior direito do Shidoku. Iremos alocar os polinômios
referentes à soma na terceira linha da matriz BOX.

BOX:=NewMat(4,4);

I:=1;

J:=1;

For I:=1 To 4 Step 2 Do -- Faz com que o índice varie de 2 em 2

For J:=1 To 4 Step 2 Do

BOX[I,J]:=x[I,J]x[I,J+1]x[I+1,J]x[I+1,J+1]-24;

BOX[I,J+1]:=x[I,J]+x[I,J+1]+x[I+1,J]+x[I+1,J+1]-10;

EndFor;

EndFor;

BOX;

-------------------------------

Mat([

[x[1,1]x[1,2]x[2,1]x[2,2] - 24, x[1,1] + x[1,2] + x[2,1] + x[2,2] - 10,

x[1,3]x[1,4]x[2,3]x[2,4] - 24, x[1,3] + x[1,4] + x[2,3] + x[2,4] - 10],

[Null, Null, Null, Null],

[x[3,1]x[3,2]x[4,1]x[4,2] - 24, x[3,1] + x[3,2] + x[4,1] + x[4,2] - 10,

x[3,3]x[3,4]x[4,3]x[4,4] - 24, x[3,3] + x[3,4] + x[4,3] + x[4,4] - 10],

[Null, Null, Null, Null]

])

Repare que a matriz ﬁca com a segunda e quarta linhas vazias. Para nos desfazermos das duas
linhas vazias da matriz BOX iremos criar uma outra matriz P 2x4 que será composta pela linha

1 e linha 3 da matriz BOX. Além disso usaremos o comando Transposed para obter a transposta
da matriz P e da matriz COL. Dessa forma todas as matrizes, C,L, COL e P serão matrizes com
4 linhas. Isso é fundamental para que possamos unir todas essas matrizes em uma só. Usaremos
para isso o comando BlockMatrix.

81

P:=NewMat(2,4);
P[1]:=BOX[1];
P[2]:=BOX[3];
P:=Transposed(P);
COL:=Transposed(COL);
COL;
H:=BlockMatrix([[L,C,COL,P]]);

Agora temos as 40 equações distribuídas em uma única matriz H. Para que consigamos
criar o ideal com todos esses polinômios, é necessário que tenhamos uma lista ao invés de uma
matriz. Para converter uma matriz numa lista, usaremos o comando Cast. O problema é que,
quando transformamos uma matriz numa lista, cada linha da matriz se torna um elemento da
lista. Por exemplo, a matriz a seguir:

Mat([

[1, 2],
[3, 4]

])

se transforma na lista:

[[1,2],[3,4]];

Repare que essa lista possui dois elementos, que por sua vez são listas também. Para obter uma
lista, onde cada elemento ocupe uma entrada separada, devemos usar o comando Flatten:

Flatten([[1,2],[3,4]]);
----------------------
[1,2,3,4]

Então, para obtermos o resultado que queremos, devemos seguir a sequência a seguir:

H:=Cast(H, LIST);
H:=Flatten(H);
Len(H);

82

--------------------------
40

Observe o uso do comando Len que retorna o tamanho da lista H, assim temos certeza

que obtivemos os 40 polinômios.

Finalmente, devemos adicionar os polinômios que caracterizam os valores iniciais dados
no nosso Shidoku. Escreveremos manualmente os 4 polinômios que descrevem os valores iniciais
e usaremos o comando Append para anexar cada um desses polinômios à nossa lista H. Para
criar o ideal com todos os nossos 44 polinômios utilizamos a sintaxe Ideal e por ﬁm calculamos
a base de Gröbner reduzida para este ideal com o comando ReducedGBasis.

A:=x[2,3]-1;
B:=x[3,1]-4;
C:=x[4,2]-2;
D:=x[4,4]-3;
Append(H,A);
Append(H,B);
Append(H,C);
Append(H,D);
Len(H);
I:=Ideal(H);
Time ReducedGBasis(I);
-------------------------------
[

x[4,3] - 4,
x[2,4] - 2,
x[2,2] - 4,
x[4,4] - 3,
x[4,2] - 2,
x[2,3] - 1,
x[3,3] - 2,
x[1,4] - 4,
x[4,1] - 1,
x[1,3] - 3,
x[3,1] - 4,
x[1,2] - 1,
x[2,1] - 3,
x[1,1] - 2,
x[3,2] - 3,

83

x[3,4] - 1]

Cpu time = 0.01, User time = 0

Com o cálculo da base de Gröbner reduzida para o ideal I, obtemos um novo conjunto

gerador com apenas 16 polinômios da forma xij − aij, com 1 ≤ i, j ≤ 4, aij ∈ {1, 2, 3, 4}.

Dessa forma, obtemos o seguinte sistema equivalente ao original:






x11 − 2 = 0

x12 − 1 = 0

x13 − 3 = 0

x14 − 4 = 0

x21 − 3 = 0

x22 − 4 = 0

x23 − 1 = 0

x24 − 2 = 0

x31 − 4 = 0 (A)

x32 − 3 = 0

x33 − 2 = 0

x34 − 1 = 0

x41 − 1 = 0

x42 − 2 = 0

x43 − 4 = 0

x44 − 3 = 0

Claramente, a solução de (A) é dada por:

x11 = 2, x12 = 1, x13 = 3, x14 = 4,

x21 = 3, x22 = 4, x23 = 1, x24 = 2,

x31 = 4, x32 = 3, x33 = 2, x34 = 1,

x41 = 1, x42 = 2, x43 = 4, x44 = 3

Voltando ao Shidoku proposto inicialmente, como cada xij obtido representa o dígito que
ocupa cada uma de suas células (i, j) com 1 ≤ i, j ≤ 4, temos que a Figura 12 é a representação
do Shidoku preenchido com sua respectiva solução.

84

Figura 12 – Shidoku Resolvido

2

3

4

1

1

4

3

2

3

1

2

4

4

2

1

3

Fonte: O autor

8 CONCLUSÃO

85

Nesse trabalho resolvemos algebricamente um Shidoku por meio do cálculo de uma Base
de Gröbner Reduzida. Essa resolução foi possível graças a modelagem do Shidoku por meio de
um sistema de equações que foi implementado no software de computação algébrica CoCoA.
Além disso, foi apresentada a teoria matemática que sustenta o cálculo de tais Bases.

A ﬁm de tornar a leitura dessa dissertação mais leve, algumas demonstrações foram
retiradas do texto principal e alocadas num Apêndice, assim como vários exemplos foram
inseridos para que o entendimento das deﬁnições e dos resultados ocorresse de forma mais
natural. O grande foco que foi dado à transição entre o anel de polinômios K[x] e o anel
K[x1, . . . , xn] tem a justiﬁcativa de que o caso unidimensional serve de base para a extensão
para o caso multidimensional. Nesse aspecto, foi muito importante a observação da perda da
unicidade do resto na chamada Pseudodivisão, para que então outra Teoria se apresentasse para
cobrir essa “falha”.

Uma possibilidade de continuação desse Trabalho consiste nas análises que podem ser
feitas com a modelagem polinomial do Shidoku, como por exemplo, o estudo da relação da
quantidade de valores iniciais do Shidoku com o seu número de soluções. Além disso, uma
extensão possível é a implementação da solução de um Sudoku. Possivelmente, nesse caso, uma
maior base em programação será necessária.

É importante salientar que a Teoria das Bases de Gröbner tem muitas outras aplicações,
que podem servir de inspiração para outras pesquisas, como: braços robóticos no espaço tri-
dimensional; quebra de sistemas criptográﬁcos; prova automática de teoremas da Geometria
(raciocínio autônomo); problemas de Programação Inteira; Coloração de Grafos; entre outras.

Em uma Iniciação Cientíﬁca, espera-se que o aluno se aproprie do conteúdo e da execução
da Pseudodivisão usando as principais Ordens Monomiais apresentadas. Além disso, que o
discente ganhe autonomia com o uso do CoCoA. Isso permitirá que veriﬁque respostas e crie
seus próprios procedimentos. Lembramos que a habilidade de programar é uma nova habilidade
indicada na BNCC.

REFERÊNCIAS

86

ARNOLD, E.; LUCAS, S.; TAALMAN, L. Gröbner basis representations of sudoku. The
College Mathematics Journal, Washington, v. 41, p. 101–112, 03 2010.

BOYER, C. Sudoku’s french ancestors. The Mathematical Intelligencer, Heidelberg, v. 29, n. 1,
p. 37–44, Dec 2007. Disponível em: <https://doi.org/10.1007/BF02984758>. Acesso em: 05 fev.
2019.

COX, D.; LITTLE, J.; O’SHEA, D. Ideals, Varieties, and Algorithms. [S.l.]: Springer Verlag,
2015.

FRALEIGH, J.; KATZ, V. A ﬁrst course in abstract algebra. [S.l.]: Addison-Wesley, 2003.
(Addison-Wesley world student series).

HAYES, B. Computing science: Unwed numbers. American Scientist, Sigma Xi,
The Scientiﬁc Research Society, UK, v. 94, n. 1, p. 12–15, 2006. Disponível em:
<http://www.jstor.org/stable/27858699>. Acesso em: 05 fev. 2019.

HONG, H. et al. Bruno buchberger — a life devoted to symbolic computation. J. Symb. Comput.,
Linz, v. 41, p. 255–258, 03 2006.

KRAMER, J.; PIPPICH, A.-M. von. From Natural Numbers to Quaternions. [S.l.: s.n.], 2017.

REITBERGER, H. Wolfgang grobner (11.2.1899–20.8.1980) zum 20. todestag. Internationale
Mathematische Nachrichten, Wien, v. 184, p. 1–27, 08 2001.

APÊNDICES

APÊNDICE A – ALGUMAS DEMONSTRAÇÕES

88

A.1 K[x] é um domínio de integridade

Teorema 8. Dado D um domínio de integridade, o conjunto

D[x] = {a0 + a1x + a2x2 + · · · + anxn : n ∈ N e ai ∈ D}

dos polinômios em x com coeﬁcientes num domínio de integridade D é um domínio de integri-
dade.

Demonstração. Considere dados

m
(cid:88)

f =

fixi , g =

n
(cid:88)

gixi e h =

l
(cid:88)

hixi

i=0
polinômios em D[x] com fm, gn e hl todos não nulos. Para facilitar, completaremos alguns
termos com coeﬁcientes 0 para que tenhamos m = n = l.

i=0

i=0

1. Fechamento da adição: Como D é domínio de integridade,

f + g =

n
(cid:88)

i=0

fixi +

n
(cid:88)

i=0

gixi =

n
(cid:88)

i=0

xi

(fi + gi)
(cid:124) (cid:123)(cid:122) (cid:125)
∈D

é um elemento de D[x].

2. Associatividade da adição:

f + (g + h) =

=

=

=

=

=

fixi +

(cid:32) n

(cid:88)

i=0

gixi +

(cid:33)

hixi

n
(cid:88)

i=0

fixi +

n
(cid:88)

(gi + hi)xi

i=0

n
(cid:88)

i=0
n
(cid:88)

i=0
n
(cid:88)

(fi + (gi + hi))xi

i=0
n
(cid:88)

((fi + gi) + hi)xi

i=0
n
(cid:88)

(fi + gi)xi +

i=0
(cid:32) n

(cid:88)

i=0

fixi +

n
(cid:88)

i=0

n
(cid:88)

hixi

i=0

(cid:33)

gixi

+

n
(cid:88)

i=0

hixi

= (f + g) + h

89

3. Comutatividade da adição:

f +g =

n
(cid:88)

i=0

fixi+

n
(cid:88)

i=0

gixi =

n
(cid:88)

i=0

(fi+gi)xi =

n
(cid:88)

i=0

(gi+fi)xi =

n
(cid:88)

i=0

gixi+

n
(cid:88)

i=0

fixi = g+f

4. Elemento neutro da adição: O polinômio 0 = 0 + 0x + 0x1 + · · · é o elemento neutro

aditivo. De fato, dado qualquer polinômio p ∈ D[x] temos p + 0 = p = 0 + p;

5. Inverso aditivo: O inverso aditivo do polinômio f = (cid:80)n

i=0 fixi é o polinômio (cid:80)n

i=0(−fi)xi,

de fato

n
(cid:88)

i=0

fixi +

n
(cid:88)

i=0

(−fi)xi =

n
(cid:88)

i=0

(fi − fi)xi =

n
(cid:88)

i=0

(0)xi = 0

6. Fechamento da multiplicação: Como D é domínio de integridade,

(cid:32)

m+n
(cid:88)

(cid:88)

(cid:33)

figj

xk

f · g =

k=0

i+j=k
(cid:123)(cid:122)
∈K

(cid:124)

(cid:125)

é um elemento de D[x];

7. Associatividade da multiplicação:
(cid:34)m+n
(cid:88)

(f g)h =

(cid:32)

(cid:88)

(cid:33)

(cid:35)

figj

xq

h

=

=

=

=

=

q=0
(cid:34)m+n
(cid:88)

(cid:32)

i+j=q

(cid:88)

(cid:33)

figj

xq

(cid:35) l

(cid:88)

hkxk

q=0

i+j=q

(cid:34)

m+n+l
(cid:88)

(cid:88)

(cid:32)

(cid:88)

k=0
(cid:33)

(cid:35)

figj

hk

xh

h=0

m+n+p
(cid:88)

q+k=h
(cid:34)

(cid:88)

i+j=q

(cid:35)

figjhk

xh

h=0

i+j+k=h

(cid:34)

m+n+p
(cid:88)

(cid:88)

(cid:32)

(cid:88)

fi

(cid:33)(cid:35)

gjhk

xh

i+r=h
(cid:34) n+l
(cid:88)

j+k=r

(cid:32)

(cid:88)

(cid:33)

(cid:35)

gjhk

xr

fsxs

h=0

m
(cid:88)

s=0

(cid:32)

(cid:34) n+l
(cid:88)

= f

r=0

(cid:88)

j+k=r
(cid:33)

(cid:35)

gjhk

xr

r=0

j+k=r

= f (gh)

8. Comutatividade da multiplicação:

(cid:32)

m+n
(cid:88)

(cid:88)

(cid:33)

figj

xk =

(cid:32)

m+n
(cid:88)

(cid:88)

f g =

(cid:33)

gjfi

xk = gf

k=0

i+j=k

k=0

i+j=k

9. Leis Distributivas Como já provamos a comutatividade basta demonstrar que vale f (g +

90

h) = f g + f h. De fato,

f (g + h) = f

(cid:32) n

(cid:88)

(gj + hj)xj

(cid:33)

j=0
(cid:32)

(cid:88)

m+n
(cid:88)

k=0

i+j=k

(cid:32)

m+n
(cid:88)

(cid:88)

k=0

i+j=k

(cid:32)

m+n
(cid:88)

(cid:88)

=

=

=

(cid:33)

fi(gj + hj)

xk

(cid:33)

(figj + fihj)

xk

(cid:33)

figj

xk +

(cid:32)

m+n
(cid:88)

(cid:88)

(cid:33)

fihj

xk

k=0

i+j=k

k=0

i+j=k

= f g + f h

Observe que a unidade de D[x] é o polinômio 1 ∈ D, de fato, f · 1 = f qualquer que seja
f . Assim ﬁca provado que D[x] é um anel comutativo, com unidade. Para provar que D[x] é um
domínio de integridade basta considerar o produto de f por g ambos não-nulos. Neste produto
o termo de maior grau será fmgnxm+n. Como por hipótese temos fm e gn não nulos e D é um
domínio de integridade então f g (cid:54)= 0.

A.2 O domínio de integridade (D[x])[y]

Lema 0. Se D[x] é um domínio então (D[x])[y] = (D[y])[x].

Um elemento de (D[x])[y] é um polinômio da forma abaixo:

P = fnyn + · · · + f1y + f0

onde fi = (cid:80)mi

j=0 aijxj ∈ D[x], n, mi ∈ Z+, aij ∈ K, ∀i ∈ {0, 1, . . . n}

Dessa maneira:

P =fnyn + · · · + f1y + f0

(cid:34)(cid:32) mn(cid:88)

j=0
(cid:34)(cid:32) n

(cid:88)

=

=

l=0

(cid:33)

anjxj

yn + · · · +

(cid:32) m1(cid:88)

(cid:33)

a1jxj

y +

(cid:32) m0(cid:88)

a0jxj

(cid:33)(cid:35)

(cid:33)

almkyl

xmk + · · · +

j=0
(cid:32) n

(cid:88)

l=0

(cid:33)

al1yl

x +

j=0
(cid:32) n

(cid:88)

l=0

(cid:33)(cid:35)

al0yl

então P pode também ser interpretado como um polinômio em (D[y]) [x]. Fica assim provado
que (D[x])[y] = (D[y])[x], e, para aliviar as notações, nos referenciaremos a esse domínio
simplesmente por D[x, y].

91

A.3 Demonstrações do capítulo 5

Proposição 8. Seja I ⊆ K[x1, . . . , xn] um ideal e f1, . . . , fs ∈ K[x1, . . . , xn], então f1, . . . , fs ∈
I se, e somente se (cid:104)f1, . . . , fs(cid:105) ⊆ I.

Demonstração. (⇒) Tome f ∈ (cid:104)f1, . . . , fs(cid:105) então f = (cid:80)s
i=1 hifi = h1f1 + · · · + hsfs para
determinados h1, . . . , hs ∈ K[x1, . . . , xn]. Como I é um ideal e por hipótese f1, . . . , fs ∈ I
temos hifi ∈ I para cada i e ﬁnalmente f = h1f1 +· · ·+hsfs ∈ I pois é uma soma de elementos
de I.

(⇐) É claro que f1, . . . , fs ∈ (cid:104)f1, . . . , fs(cid:105) e como por hipótese (cid:104)f1, . . . , fs(cid:105) ⊆ I então

f1, . . . , fs ∈ I

Proposição 9. Seja I = (cid:104)X α : α ∈ A(cid:105) um ideal monomial. Então um monômio X β pertence ao
ideal I se e somente se X β é divisível por X α para algum α ∈ A.

Demonstração. Suponhamos que X β ∈ I. Assim, X β = (cid:80)s
i=1 hiX αi, onde hi ∈ K[x1, . . . , xn]
e αi ∈ A. Como cada hi pode ser expandido como uma soma de monômios com coeﬁcientes em
K, temos:

X β =

s
(cid:88)

i=1

s
(cid:88)

hiX αi =

(cid:32) ki(cid:88)

i=1

j=1

(cid:33)

aijX βij

X αi =

aijX βij X αi

(cid:88)

i,j

onde a expressão à direita é uma soma de monômios, cada um, divisível por algum X α, com
α ∈ A. Logo, o monômio X β é divisível por algum X α. Reciprocamente, se X β for divisível
por X α, para algum α ∈ A, então X β ∈ I, pela deﬁnição de ideal.

Proposição 10. Sejam I um ideal monomial de K[x1, . . . , xn] e f ∈ K[x1, . . . , xn]. Então são
equivalentes:

1. f ∈ I

2. todo termo de f está em I

3. f é uma K-combinação linear de monômios em I

Demonstração.

(3)⇒(2)⇒ (1) Seguem da deﬁnição de ideal.

(1)⇒(3) Se f ∈ I, temos que f = (cid:80)s
i=1 hiX αi, com hi ∈ K[x1, . . . , xn] e X αi ∈ I.
Como ﬁzemos na proposição (9), expandindo cada hi como uma combinação linear de
monômios podemos escrever

f =

s
(cid:88)

ki(cid:88)

i=1

j=1

aijX βij X αi,

(A.1)

onde aijX βij é um termo do polinômio hi, com j = 1, . . . , ki e aij ∈ K. Como I é um
ideal, o produto X βij X αi é um monômio de I. Assim, podemos concluir que f é uma
K-combinação linear de monômios em I.

92

Lema 2 (Lema de Dickson). Se I um ideal monomial de K[x1, . . . , xn], então existe um conjunto
ﬁnito de monômios que geram I.

Demonstração. Vamos provar o teorema usando indução sobre o número de indeterminadas de
K[x1, . . . , xn]. O caso de uma indeterminada é verdadeiro, uma vez que em K[x1] todo ideal é
principal, consequentemente, pode ser gerado por um único polinômio, que neste caso se resume
a um monômio.

Vamos considerar o teorema válido para n − 1 indeterminadas. Agora, se I é um ideal
monomial de K[x1, . . . , xn], escolha um elemento f1 = g1xαn1
n ∈ I, com g1 um monômio
em K[x1, . . . , xn−1] e αn1 o menor possível. Se I = (cid:104)f1(cid:105), então o teorema está demonstrado.
Caso contrário, escolha um elemento f2 = g2xαn2
∈ I \ (cid:104)f1(cid:105), com g2 um monômio em
K[x1, . . . , xn−1] e αn2 o menor possível. Observe que, obrigatoriamente, temos que αn2 ≥ αn1
pois, caso contrário, f1 foi escolhido de forma errada. Se I = (cid:104)f1, f2(cid:105), então o teorema está
demonstrado. Caso contrário, continuamos com o procedimento.

n

Vamos supor que este procedimento continua indeﬁnidamente, ou seja, é possível obter
n ∈ I \ (cid:104)f1, . . . , fi−1(cid:105), com gi um monômio

uma seqüência inﬁnita f1, f2, . . . tal que fi = gixαni
em K[x1, . . . , xn−1], αni o menor possível e αni ≥ αn(i−1).

Por hipótese de indução, temos que o ideal J ∈ K[x1, . . . , xn−1] gerado pelos monômios
g1, g2, . . . é ﬁnitamente gerado, digamos que I = (cid:104)g1, . . . gk(cid:105), para algum índice k. Deste modo,
segue da Proposição 9, que gk+1 é divisível por algum gi, para i = 1, . . . k, digamos, gk+1 = hgm,
para algum monômio h ∈ K[x1, . . . , xn−1]. Logo

fk+1 = gk+1x

αn(k+1)
n

= hgmx

αn(k+1)
n

αn(k+1)−αnm
= hx
n

(gmxαnm
n

αn(k+1)−αnm
) = hx
n

fm

e então fk+1 ∈ (cid:104)fm(cid:105), contrariando a escolha do fk+1. Assim, I é ﬁnitamente gerado.

Lema 3. Considere (cid:31) uma ordem monomial e (cid:80)s
i=1 cifi, com ci ∈ K e multideg(fi) = δ ∈ Zn
+,
para todo i ∈ {1, . . . , s}. Se δ (cid:31) multideg((cid:80)s
i=1 cifi é uma K-combinação
linear de S-processos S(fj, fk) para 1 ≤ j, k ≤ s. Além disso, δ (cid:31) multideg (S(fj, fk)), para
1 ≤ j, k ≤ s.

i=1 cifi), então (cid:80)s

Demonstração. Seja di = LC(fi) de modo que cidi = LC(cifi). Como cifi tem multigrau δ e
δ (cid:31) multideg ((cid:80)s
i=1 cidi = 0.

i=1 cifi), segue que (cid:80)s

Deﬁnindo pi = fi/di, temos que pi é um polinômio com coeﬁciente líder igual à 1.

Agora, considere a seguinte soma:

93

(cid:80)s

i=1 cifi = (cid:80)s

i=1 cidipi

= c1d1(p1 − p2) + (c1d1 + c2d2)(p2 − p3) + . . .
+(c1d1 + . . . + cs−1ds−1)(ps−1 − ps) + (c1d1 + . . . + csds)ps

(A.2)

Sabemos que LT(fi) = diX δ, para todo i = 1, . . . , s, o que implica em

MMC(LM(fj), LM(fk)) = X δ

. Então:

S(fj, fk) =

X δ
LT(fj)

fj −

X δ
LT(fk)

fk =

X δ
djX δ fj −

X δ
dkX δ fk =

fj
dj

−

fk
dk

= pj − pk

(A.3)

Usando as igualdades (A.3) e (A.2), e o fato de que (cid:80)s

i=1 cidi = 0, temos que:

cifi = c1d1 S(f1, f2) + (c1d1 + c2d2) S(f2, f3) + . . . + (c1d1 + . . . + cs−1ds−1) S(fs−1, fs),

s
(cid:88)

i=1

que é a soma desejada. Finalmente, observe que δ (cid:31) multideg(pj − pk), pois pj e pk têm
multigrau δ e coeﬁciente líder 1. Pela igualdade (A.3), temos que δ (cid:31) multideg(S(fj, fk)).

Teorema 5 (Critério de Buchberger). Seja I = (cid:104)g1, . . . , gs(cid:105) ⊂ K[x1, . . . , xn] um ideal. Então
G = {g1, . . . , gs} é uma Base de Gröbner para I se, e somente se, para todos os pares i (cid:54)= j, o
resto na pseudodivisão de S(gi, gj) por G (com qualquer ordenação) é zero.

Demonstração. (⇒) Se G é uma base de Gröbner, então como S(gi, gj) ∈ I, segue do Corolário

3 que o resto na divisão por G é zero.

(⇐) Seja f ∈ I = (cid:104)g1, . . . , gs(cid:105) um polinômio não nulo. Precisamos mostrar que LT(f ) ∈
(cid:104)LT(g1), . . . , LT(gs)(cid:105). Antes, porém, faremos um esboço da prova para facilitar o entendi-
mento.

Sabemos que f pode ser escrito da forma:

f =

s
(cid:88)

i=1

higi,

com hi ∈ K[x1, . . . , xn], e do Lema 7 temos que:

max{multideg(higi)} (cid:60) multideg(f ).

(A.4)

(A.5)

94

Observe que o teorema já estaria provado se ocorresse a igualdade em (A.5). De fato,
teríamos LT(f ) divisível por LT(gi), para algum i ∈ {1, . . . , s} e, pelo Lema 9, poderíamos
concluir que LT(f ) ∈ (cid:104)LT(g1), . . . , LT(gs)(cid:105).

Assim, vamos mostrar que existem (cid:101)h1, . . . , (cid:101)hs ∈ K[x1, . . . , xn], tais que f = (cid:80)s

i=1 (cid:101)higi

e max{multideg((cid:101)higi)} = multideg(f ).

Passemos aos detalhes da prova. Considere f como em (A.4), m(i) = multideg(higi) e

δ = max{m(1), . . . , m(s)}. Assim, segue de (A.5) que δ (cid:60) multideg(f ).

Agora considere todos os modos possíveis de se escrever f na forma (A.4). Talvez tenha-
mos um δ diferente para cada um desses modos. Mas, como vale o Princípio da Boa Ordenação
para ordens monomiais, podemos tomar, dentre os possíveis δ, o mínimo, que designaremos por
δ0. Logo, existem (cid:101)h1, . . . , (cid:101)hs ∈ K[x1, . . . , xn], tais que f = (cid:80)s
i=1 (cid:101)higi com δ0 (cid:60) multideg(f ).

Vamos mostrar que δ0 = multideg(f ), provando assim o teorema. De fato, vamos supor

que δ0 (cid:31) multideg(f ). Reescrevendo f , isolando os termos de multigrau δ0, temos:

(cid:88)

f =

(cid:101)higi +

(cid:88)

(cid:101)higi

=

m(i)=δ0
(cid:88)

m(i)=δ0

δ0(cid:31)m(i)

LT((cid:101)hi)gi +

(cid:88)

m(i)=δ0

((cid:101)hi − LT((cid:101)hi))gi +

(cid:88)

(cid:101)higi

δ0(cid:31)m(i)

(A.6)

(A.7)

Observe que δ0 é maior ((cid:31)) que o multigrau dos monômios da segunda soma e da
terceira soma na segunda linha. Mas como δ0 (cid:31) multideg(f ), então δ0 também é maior ((cid:31)) que
o multigrau da primeira soma.

Se LT((cid:101)hi) = ciX αi, então a primeira soma (cid:80)

ciX αigi
atende às condições do Lema 3, considerando fi = X αigi. Então essa soma é uma combinação
linear de S-processos S(X αj gj, X αkgk). Entretanto:

LT((cid:101)hi)gi = (cid:80)

m(i)=δ0

m(i)=δ0

S(X αj gj, X αkgk) =

X δ0
X αj LT(gj)

X αj gj −

X δ0
X αk LT(gk)

X αkgk = X δ0−γjk S(gj, gk),

onde X γjk = MMC(LM(gj), LM(gk)). Portanto, existem constantes cjk ∈ K tais que:

(cid:88)

m(i)=δ0

LT((cid:101)hi)gi =

(cid:88)

jk

cjkX δ0−γjk S(gj, gk)

(A.8)

Temos ainda a hipótese de S(gj, gk)

G

= 0. Assim, usando o algoritmo da divisão,

podemos escrever S(gj, gk) na forma:

S(gj, gk) =

s
(cid:88)

i=1

aijkgi,

(A.9)

95

onde aijk ∈ K[x1, . . . , xn]. O algoritmo da divisão também nos diz que:

multideg(S(gj, gk)) (cid:60) multideg(aijkgi),

(A.10)

para todo i, j, k. Multiplicando a expressão (A.9) por X δ0−γjk obtemos:

X δ0−γjk S(gj, gk) =

s
(cid:88)

i=1

bijkgi,

(A.11)

onde bijk = X δ0−γjkaijk. Então a condição (A.8) e o Lema 3 implicam em:

δ0 (cid:31) multideg(X δ0−γjk S(gj, gk)) (cid:60) multideg(bijkgi)

(A.12)

Substituindo (A.11) em (A.8) temos a igualdade:

(cid:80)

m(i)=δ0

LT((cid:101)hi)gi = (cid:80)

jk cjkX δ−γjkS(gj, gk)

G

= (cid:80)

jk cjk((cid:80)

i bijkgi) = (cid:80)

i

¯higi,

que por (A.12) tem a propriedade válida para todo i:

δ0 (cid:31) multideg(¯higi)

Finalmente, substituindo (cid:80)

m(i)=δ0

LT((cid:101)hi)gi = (cid:80)

i

¯higi em (A.3), temos que:

f = (cid:80)

m(i)=δ0

¯higi + (cid:80)

m(i)=δ0

((cid:101)hi − LT((cid:101)hi))gi + (cid:80)

δ0(cid:31)m(i) (cid:101)higi.

Observe que, agora passamos a ter não somente δ0 maior ((cid:31)) que todos os multigraus
dos termos da segunda e da terceira soma, mas também maior ((cid:31)) que todos os multigraus
dos termos da primeira soma (repare que em (A.3) tínhamos apenas que δ0 era maior ((cid:31)) que
o multigrau da primeira soma como um todo). Mas, isso contradiz a minimalidade de δ0 e o
teorema está provado.

Teorema 7. Seja I (cid:54)= {0} um ideal polinomial. Então, dada uma ordem monomial, I possui
uma única base de Gröbner reduzida.

Demonstração. (Existência) Seja G uma base de Gröbner mínima para I. Dizemos que g ∈ G
é reduzido para G quando nenhum monômio de g pertence a (cid:104)LT(G − {g})(cid:105). Nosso objetivo é
modiﬁcar a base G até que todos os seus elementos sejam reduzidos.

Dado g ∈ G, considere g(cid:48) = g(G−{g}) e o conjunto G(cid:48) = (G − {g}) ∪ {g(cid:48)}. Aﬁrmamos
que G(cid:48) é uma base de Gröbner mínima para I. De fato, quando dividimos g por G − {g}, LT(g)
é um termo do resto, pois ele não é divisível por nenhum elemento de LT(G − {g}). Assim
LT(g(cid:48)) = LT(g), e portanto LT(G) = LT(G(cid:48)) e (cid:104)LT(G(cid:48))(cid:105) = (cid:104)LT(G)(cid:105) = (cid:104)LT(I)(cid:105). Como G(cid:48) ⊂

96

I, da igualdade anterior temos que G(cid:48) é uma base de Gröbner e, por construção, mínima. Além
disso, g(cid:48) é reduzido para G(cid:48). Realmente, nenhum monômio de g(cid:48) está em (cid:104)LT(G(cid:48) − {g(cid:48)})(cid:105) =
(cid:104)LT(G − {g})(cid:105), pois g(cid:48) é o resto da divisão de g por G − {g}.

Por ﬁm, repetindo o processo acima para cada elemento de G, encontraremos uma base
de Gröbner reduzida. É claro que a base de Gröbner mudará a cada etapa do processo. Entretanto,
uma vez que o elemento é reduzido, ele permanecerá assim até o ﬁm do processo, pois em cada
passo os termos líderes são conservados, isto é, LT(G) = LT(G(cid:48)).

(Unicidade) Suponha que G e (cid:101)G são duas bases de Gröbner reduzidas para I. Então, G
e (cid:101)G são duas bases de Gröbner mínimas e, pelo Lema 4, elas têm os mesmos termos líderes, isto
é, LT(G) = LT( ˜G). Assim, dado g ∈ G, existe (cid:101)g ∈ (cid:101)G tal que LT(g) = LT((cid:101)g). Se mostrarmos
que g = (cid:101)g, seguirá que G = (cid:101)G, e a unicidade estará provada.

Para mostrar que g = (cid:101)g, considere g − (cid:101)g. Sabemos que g − (cid:101)g ∈ I, e como G é uma base
= 0. Mas, LT(g) = LT((cid:101)g), esses termos se cancelam em g − (cid:101)g e os
de Gröbner, temos g − (cid:101)g
termos restantes não são divisíveis por nenhum dos elementos de LT(G) = LT( (cid:101)G), pois G e (cid:101)G
G
são bases de Gröbner reduzidas. Então, g − (cid:101)g

= g − (cid:101)g e g − (cid:101)g = 0 . Logo, g = (cid:101)g.

G

